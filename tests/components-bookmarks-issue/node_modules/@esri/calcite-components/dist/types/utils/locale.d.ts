export declare const defaultLocale = "en";
export declare const t9nLocales: string[];
export declare const locales: string[];
export declare const numberingSystems: readonly ["arab", "arabext", "latn"];
export declare const supportedLocales: readonly string[];
export type NumberingSystem = (typeof numberingSystems)[number];
export type SupportedLocale = (typeof supportedLocales)[number];
export declare const defaultNumberingSystem: "arab" | "arabext" | "latn";
export declare const getSupportedNumberingSystem: (numberingSystem: string) => NumberingSystem;
/**
 * Gets the locale that best matches the context.
 *
 * @param locale â€“ the BCP 47 locale code
 * @param context - specifies whether the locale code should match in the context of CLDR or T9N (translation)
 */
export declare function getSupportedLocale(locale: string, context?: "cldr" | "t9n"): SupportedLocale;
/**
 * This interface is for components that need to determine locale from the lang attribute.
 */
export interface LocalizedComponent {
    el: HTMLElement;
    /**
     * Used to store the effective locale to avoid multiple lookups.
     *
     * This is an internal property and should:
     *
     * - use the `@State` decorator
     * - be initialized to ""
     *
     * Components should watch this prop to ensure messages are updated.
     *
     * @Watch("effectiveLocale")
     * effectiveLocaleChange(): void {
     *   updateMessages(this, this.effectiveLocale);
     * }
     */
    effectiveLocale: string;
}
/**
 * This utility sets up internals for messages support.
 *
 * It needs to be called in `connectedCallback` before any logic that depends on locale
 *
 * @param component
 */
export declare function connectLocalized(component: LocalizedComponent): void;
/**
 * This is only exported for components that implemented the now deprecated `locale` prop.
 *
 * Do not use this utils for new components.
 *
 * @param component
 */
export declare function updateEffectiveLocale(component: LocalizedComponent): void;
/**
 * This utility tears down internals for messages support.
 *
 * It needs to be called in `disconnectedCallback`
 *
 * @param component
 */
export declare function disconnectLocalized(component: LocalizedComponent): void;
export interface NumberStringFormatOptions extends Intl.NumberFormatOptions {
    numberingSystem: NumberingSystem;
    locale: string;
}
/**
 * This util formats and parses numbers for localization
 */
export declare class NumberStringFormat {
    /**
     * The actual group separator for the specified locale.
     * White-space group separators are changed to the non-breaking space (nbsp) unicode character.
     * so we replace them with a normal <SPACE>.
     */
    private _actualGroup;
    /** the corrected group separator */
    private _group;
    get group(): string;
    private _decimal;
    get decimal(): string;
    private _minusSign;
    get minusSign(): string;
    private _digits;
    get digits(): Array<string>;
    private _getDigitIndex;
    private _numberFormatter;
    get numberFormatter(): Intl.NumberFormat;
    private _numberFormatOptions;
    get numberFormatOptions(): NumberStringFormatOptions;
    /**
     * numberFormatOptions needs to be set before localize/delocalize is called to ensure the options are up to date
     */
    set numberFormatOptions(options: NumberStringFormatOptions);
    delocalize: (numberString: string) => string;
    localize: (numberString: string) => string;
}
export declare const numberStringFormatter: NumberStringFormat;
export type LocaleDateTimeOptionKey = string;
/**
 * Exported for testing purposes only.
 *
 * @internal
 */
export declare let dateTimeFormatCache: Map<LocaleDateTimeOptionKey, Intl.DateTimeFormat>;
/**
 * Returns an instance of Intl.DateTimeFormat and reuses it if requested with the same locale and options.
 *
 * **Note**: the cache will be cleared if a different locale is provided
 *
 * @internal
 */
export declare function getDateTimeFormat(locale: string, options?: Intl.DateTimeFormatOptions): Intl.DateTimeFormat;
