import { E2EPage } from "@stencil/core/testing";
import type { JSX } from "../components";
import { KeyInput } from "puppeteer";
type ComponentTag = keyof JSX.IntrinsicElements;
type ComponentHTML = string;
type TagOrHTML = ComponentTag | ComponentHTML;
type BeforeContent = (page: E2EPage) => Promise<void>;
export type TagAndPage = {
    tag: ComponentTag;
    page: E2EPage;
};
type TagOrHTMLWithBeforeContent = {
    tagOrHTML: TagOrHTML;
    /**
     * Allows for custom setup of the page.
     *
     * This is useful for test helpers that need to create and configure the test page before running tests.
     *
     * @param page
     */
    beforeContent: BeforeContent;
};
export declare const HYDRATED_ATTR: string;
/**
 * Helper for asserting that a component is accessible.
 *
 * Note that this helper should be used within a describe block.
 *
 * @example
 * describe("accessible"), () => {
 *    accessible(`<calcite-tree></calcite-tree>`);
 * });
 *
 * @param {ComponentTestSetup} componentTestSetup - A component tag, html, or the tag and e2e page for setting up a test
 */
export declare function accessible(componentTestSetup: ComponentTestSetup): void;
/**
 * Note that this helper should be used within a describe block.
 *
 * @example
 * describe("renders", () => {
 *    renders(`<calcite-tree></calcite-tree>`);
 * });
 * @param componentTestSetup
 *
 * @param {string} componentTagOrHTML - the component tag or HTML markup to test against
 * @param {object} options - additional options to assert
 * @param {string} options.visible - is the component visible
 * @param {string} options.display - is the component's display "inline"
 */
export declare function renders(componentTestSetup: ComponentTestSetup, options?: {
    visible?: boolean;
    display: string;
}): Promise<void>;
/**
 *
 * Helper for asserting that a component reflects
 *
 * Note that this helper should be used within a describe block.
 *
 * @example
 * describe("reflects", () => {
 *    reflects("calcite-action-bar", [
 *      {
 *        propertyName: "expandDisabled",
 *        value: true
 *      },
 *      {
 *        propertyName: "expanded",
 *        value: true
 *      }
 *    ])
 * })
 *
 * @param {string} componentTagOrHTML - the component tag or HTML markup to test against
 * @param componentTestSetup
 * @param {object[]} propsToTest - the properties to test
 * @param {string} propsToTest.propertyName - the property name
 * @param {any} propsToTest.value - the property value (if boolean, needs to be `true` to ensure reflection)
 */
export declare function reflects(componentTestSetup: ComponentTestSetup, propsToTest: {
    propertyName: string;
    value: any;
}[]): void;
/**
 * Helper for asserting that a property's value is its default
 *
 * Note that this helper should be used within a describe block.
 *
 * @example
 * describe("defaults", () => {
 *    defaults("calcite-action", [
 *      {
 *        propertyName: "active",
 *        defaultValue: false
 *      },
 *      {
 *        propertyName: "appearance",
 *        defaultValue: "solid"
 *      }
 *    ])
 * })
 *
 * @param {string} componentTagOrHTML - the component tag or HTML markup to test against
 * @param componentTestSetup
 * @param {object[]} propsToTest - the properties to test
 * @param {string} propsToTest.propertyName - the property name
 * @param {any} propsToTest.value - the property value
 */
export declare function defaults(componentTestSetup: ComponentTestSetup, propsToTest: {
    propertyName: string;
    defaultValue: any;
}[]): void;
/**
 * Helper for asserting that a component is not visible when hidden
 *
 * Note that this helper should be used within a describe block.
 *
 * @example
 * @param componentTestSetup
 * describe("honors hidden attribute", () => {
 *    hidden("calcite-accordion")
 * });
 *
 * @param {string} componentTagOrHTML - the component tag or HTML markup to test against
 */
export declare function hidden(componentTestSetup: ComponentTestSetup): Promise<void>;
interface FocusableOptions {
    /**
     * use this to pass an ID to setFocus()
     *
     * @deprecated components should no longer use a focusId parameter for setFocus()
     */
    focusId?: string;
    /**
     * selector used to assert the focused DOM element
     */
    focusTargetSelector?: string;
    /**
     * selector used to assert the focused shadow DOM element
     */
    shadowFocusTargetSelector?: string;
}
/**
 * Helper for asserting that a component is focusable
 *
 * Note that this helper should be used within a describe block.
 *
 * @example
 * describe("is focusable", () => {
 *    focusable(`calcite-input-number`, { shadowFocusTargetSelector: "input" })
 * });
 *
 * @param {string} componentTagOrHTML - the component tag or HTML markup to test against
 * @param componentTestSetup
 * @param {FocusableOptions} [options] - additional options for asserting focus
 */
export declare function focusable(componentTestSetup: ComponentTestSetup, options?: FocusableOptions): void;
/**
 * Helper for asserting slots.
 *
 * Note that this helper should be used within a describe block.
 *
 * @example
 * describe("slots", () => {
 *    slots("calcite-stack", SLOTS)
 * })
 *
 * @param {string} componentTagOrHTML - The component tag or HTML markup to test against.
 * @param {Record<string, string> | string[]} slots - A component's SLOTS resource object or an array of slot names.
 * @param {boolean} includeDefaultSlot - When true, it will run assertions on the default slot.
 */
export declare function slots(componentTagOrHTML: TagOrHTML, slots: Record<string, string> | string[], includeDefaultSlot?: boolean): void;
interface LabelableOptions extends Pick<FocusableOptions, "focusTargetSelector" | "shadowFocusTargetSelector"> {
    /**
     * If clicking on a label toggles the labelable component, use this prop to specify the name of the toggled prop.
     */
    propertyToToggle?: string;
}
/**
 * Helper for asserting label clicking functionality works.
 *
 * Note that this helper should be used within a describe block.
 *
 * @example
 * describe("labelable", () => {
 *    async () => labelable("calcite-button")
 * })
 *
 * @param {string} componentTagOrHtml - The component tag or HTML used to test label support.
 * @param {LabelableOptions} [options] - Labelable options.
 */
export declare function labelable(componentTagOrHtml: TagOrHTML | TagOrHTMLWithBeforeContent, options?: LabelableOptions): void;
interface FormAssociatedOptions {
    /**
     * This value will be set on the component and submitted by the form.
     */
    testValue: any;
    /**
     * Set this if the expected submit value **is different** from stringifying `testValue`.
     * For example, a component may transform an object to a serializable string.
     */
    expectedSubmitValue?: any;
    validUserInputTestValue?: string;
    changeValueKeys?: KeyInput[];
    /**
     * Specifies the input type that will be used to capture the value.
     */
    inputType?: HTMLInputElement["type"];
    /**
     * Specifies if the component supports submitting the form on Enter key press.
     */
    submitsOnEnter?: boolean;
    /**
     * Specifies if the component supports clearing its value (i.e., setting to null).
     */
    clearable?: boolean;
    /**
     * Specifies if the component supports preventing submission and displaying validation messages.
     */
    validation?: boolean;
}
/**
 * Helper for testing form-associated components; specifically form submitting and resetting.
 *
 * Note that this helper should be used within a describe block.
 *
 * @param {string} componentTagOrHtml - the component tag or HTML markup to test against
 * @param {FormAssociatedOptions} options - form associated options
 */
export declare function formAssociated(componentTagOrHtml: TagOrHTML | TagOrHTMLWithBeforeContent, options: FormAssociatedOptions): void;
interface TabAndClickTargets {
    tab: string;
    click: string;
}
type FocusTarget = "host" | "child" | "none";
interface DisabledOptions {
    /**
     *  Use this to specify whether the test should cover focusing.
     */
    focusTarget?: FocusTarget | TabAndClickTargets;
    /**
     *  Use this to specify the main wrapped component in shadow DOM that handles disabling interaction.
     *
     *  Note: this should only be used for components that wrap a single component that implements disabled behavior.
     */
    shadowAriaAttributeTargetSelector?: string;
}
type ComponentTestContent = TagOrHTML | TagAndPage;
type ComponentTestSetupProvider = (() => ComponentTestContent) | (() => Promise<ComponentTestContent>);
type ComponentTestSetup = ComponentTestContent | ComponentTestSetupProvider;
/**
 * Helper to test the disabled prop disabling user interaction.
 *
 * Note that this helper should be used within a describe block.
 *
 * @example
 * describe("disabled", () => {
 *    disabled("calcite-input")
 * });
 *
 * @param {ComponentTestSetup} componentTestSetup - A component tag, html, or the tag and e2e page for setting up a test.
 * @param {DisabledOptions} [options] - Disabled options.
 */
export declare function disabled(componentTestSetup: ComponentTestSetup, options?: DisabledOptions): void;
/**
 * This helper will test if a floating-ui-owning component has configured the floating-ui correctly.
 * At the moment, this only tests if the scroll event listeners are only active when the floating-ui is displayed.
 *
 * Note that this helper should be used within a describe block.
 *
 * @example
 * describe("owns a floating-ui", () => {
 *  floatingUIOwner(
 *    `<calcite-input-date-picker></calcite-input-date-picker>`,
 *      "open",
 *      { shadowSelector: ".menu-container" }
 *  )
 * });
 *
 * @param {TagOrHTML} componentTagOrHTML - The component tag or HTML markup to test against.
 * @param {string} togglePropName - The component property that toggles the floating-ui.
 * @param [options] - additional options for asserting focus
 * @param {string} [options.shadowSelector] - The selector in the shadow DOM for the floating-ui element.
 */
export declare function floatingUIOwner(componentTagOrHTML: TagOrHTML, togglePropName: string, options?: {
    /**
     * Use this to specify the selector in the shadow DOM for the floating-ui element.
     */
    shadowSelector?: string;
}): void;
/**
 * Helper to test if a component has a floating-UI-owning component wired up.
 *
 * Note: this performs a shallow test and assumes the underlying component has floating-ui properly configured.
 *
 * @example
 * describe("delegates to floating-ui-owner component", () => {
 *   delegatesToFloatingUiOwningComponent("calcite-pad", "calcite-action-group");
 * });
 *
 * @param componentTagOrHTML
 * @param floatingUiOwnerComponentTag
 */
export declare function delegatesToFloatingUiOwningComponent(componentTagOrHTML: TagOrHTML, floatingUiOwnerComponentTag: ComponentTag): Promise<void>;
/**
 * Helper to test t9n component setup.
 *
 * Note that this helper should be used within a describe block.
 *
 * @example
 * describe("translation support", () => {
 *   t9n("calcite-action");
 * });
 *
 * @param {ComponentTestSetup} componentTestSetup - A component tag, html, or the tag and e2e page for setting up a test.
 */
export declare function t9n(componentTestSetup: ComponentTestSetup): Promise<void>;
interface BeforeToggle {
    /**
     * Function argument to simulate user input (mouse or keyboard), to open the component.
     */
    open: (page: E2EPage) => Promise<void>;
    /**
     * Function argument to simulate user input (mouse or keyboard), to close the component.
     */
    close: (page: E2EPage) => Promise<void>;
}
interface OpenCloseOptions {
    /**
     * Toggle property to test. Currently, either "open" or "expanded".
     */
    openPropName?: string;
    /**
     * Indicates the initial value of the toggle property.
     */
    initialToggleValue?: boolean;
    /**
     * Optional argument with functions to simulate user input (mouse or keyboard), to open or close the component.
     */
    beforeToggle?: BeforeToggle;
}
/**
 * Helper to test openClose component setup.
 *
 * Note that this helper should be used within a `describe` block.
 *
 * @example
 *
 * describe("openClose", () => {
 *   openClose("calcite-combobox opened with a tab", {
 *     beforeToggle: {
 *        open: async (page) => {
 *            await page.keyboard.press("Tab");
 *            await page.waitForChanges();
 *        },
 *        close: async (page) => {
 *            await page.keyboard.press("Tab");
 *            await page.waitForChanges();
 *        },
 *      }
 *   });
 *
 *  openClose("open calcite-combobox closed with a tab", {
 *        initialToggleValue: true,
 *        beforeToggle: {
 *          close: async (page) => {
 *            await page.keyboard.press("Tab");
 *            await page.waitForChanges();
 *        },
 *      }
 *    }
 * })
 *
 * @param componentTagOrHTML - The component tag or HTML markup to test against.
 * @param {object} [options] - Additional options to assert.
 */
export declare function openClose(componentTagOrHTML: TagOrHTML, options?: OpenCloseOptions): void;
export {};
