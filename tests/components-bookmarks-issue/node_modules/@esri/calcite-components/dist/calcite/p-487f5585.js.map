{"version":3,"names":["inRange","date","min","max","time","getTime","afterMin","Date","beforeMax","dateFromRange","beforeMin","afterMax","dateFromISO","iso8601","isEndDate","d","split","map","parseFloat","setFullYear","isNaN","Error","setEndOfDay","dateFromLocalizedString","value","localeData","separator","parts","parseDateString","day","month","year","parseCalendarYear","validDay","validMonth","validDate","validLength","filter","c","length","validYear","toString","processCalendarYear","formatCalendarYear","mode","BUDDHIST_CALENDAR_YEAR_OFFSET","yearOffset","datePartsFromLocalizedString","string","unitOrder","order","getOrder","values","part","numberStringFormatter","delocalize","indexOf","dateToISO","getTimezoneOffset","toISOString","datePartsFromISO","isoDate","dateParts","sameDate","d1","d2","getDate","getMonth","getFullYear","prevMonth","nextDate","setMonth","nextMonth","parseInt","signifiers","toLowerCase","sort","a","b","getDaysDiff","date1","date2","ts1","ts2","setHours","translationCache","requestCache","async","getLocaleData","lang","locale","getSupportedLocale","fetch","getAssetPath","then","resp","json","catch","console","error","data","getValueAsDateRange","v","index"],"sources":["src/utils/date.ts","src/components/date-picker/utils.ts"],"sourcesContent":["import { DateLocaleData } from \"../components/date-picker/utils\";\nimport { numberStringFormatter } from \"./locale\";\n\nexport interface HoverRange {\n  focused: \"end\" | \"start\";\n  start: Date;\n  end: Date;\n}\n\n/**\n * Check if date is within a min and max\n *\n * @param date\n * @param min\n * @param max\n */\nexport function inRange(date: Date, min?: Date | string, max?: Date | string): boolean {\n  if (!date) {\n    return;\n  }\n  const time = date.getTime();\n  const afterMin = !(min instanceof Date) || time >= min.getTime();\n  const beforeMax = !(max instanceof Date) || time <= max.getTime();\n  return afterMin && beforeMax;\n}\n\n/**\n * Ensures date is within range,\n * returns min or max if out of bounds\n *\n * @param date\n * @param min\n * @param max\n */\nexport function dateFromRange(date?: any, min?: Date | string, max?: Date | string): Date | null {\n  if (!(date instanceof Date)) {\n    return null;\n  }\n  const time = date.getTime();\n  const beforeMin = min instanceof Date && time < min.getTime();\n  const afterMax = max instanceof Date && time > max.getTime();\n  if (beforeMin) {\n    return min as Date;\n  }\n  if (afterMax) {\n    return max as Date;\n  }\n  return date;\n}\n\n/**\n * Parse an iso8601 string (YYYY-mm-dd) into a valid date.\n * TODO: handle time when time of day UI is added\n *\n * @param iso8601\n * @param isEndDate\n */\nexport function dateFromISO(iso8601: string | Date, isEndDate = false): Date | null {\n  if (iso8601 instanceof Date) {\n    return iso8601;\n  }\n  if (!iso8601 || typeof iso8601 !== \"string\") {\n    return null;\n  }\n  const d = iso8601.split(/[: T-]/).map(parseFloat);\n  const date = new Date(d[0], (d[1] || 1) - 1, d[2] || 1);\n  date.setFullYear(d[0]);\n  if (isNaN(date.getTime())) {\n    throw new Error(`Invalid ISO 8601 date: \"${iso8601}\"`);\n  }\n  if (isEndDate) {\n    return setEndOfDay(date);\n  }\n  return date;\n}\n\n/**\n * Parse a localized date string into a valid Date.\n * return false if date is invalid, or out of range\n *\n * @param value\n * @param localeData\n */\nexport function dateFromLocalizedString(value: string, localeData: DateLocaleData): Date {\n  if (!localeData) {\n    return null;\n  }\n  const { separator } = localeData;\n  const parts = parseDateString(value, localeData);\n\n  const { day, month } = parts;\n  const year = parseCalendarYear(parts.year, localeData);\n\n  const date = new Date(year, month, day);\n  date.setFullYear(year);\n\n  const validDay = day > 0;\n  const validMonth = month > -1;\n  const validDate = !isNaN(date.getTime());\n  const validLength = value.split(separator).filter((c) => c).length > 2;\n  const validYear = year.toString().length > 0;\n\n  if (validDay && validMonth && validDate && validLength && validYear) {\n    return date;\n  }\n  return null;\n}\n\nexport function parseCalendarYear(year: number, localeData: DateLocaleData): number {\n  return processCalendarYear(year, localeData, \"read\");\n}\n\nexport function formatCalendarYear(year: number, localeData: DateLocaleData): number {\n  return processCalendarYear(year, localeData, \"write\");\n}\n\nfunction processCalendarYear(year: number, localeData: DateLocaleData, mode: \"read\" | \"write\"): number {\n  if (localeData[\"default-calendar\"] !== \"buddhist\") {\n    return year;\n  }\n\n  const BUDDHIST_CALENDAR_YEAR_OFFSET = 543;\n  const yearOffset = BUDDHIST_CALENDAR_YEAR_OFFSET * (mode === \"read\" ? -1 : 1);\n\n  return year + yearOffset;\n}\n\n/**\n * Retrieve day, month, and year strings from a localized string\n *\n * @param string\n * @param localeData\n */\nexport function datePartsFromLocalizedString(\n  string: string,\n  localeData: DateLocaleData,\n): { day: string; month: string; year: string } {\n  const { separator, unitOrder } = localeData;\n  const order = getOrder(unitOrder);\n  const values = string.split(separator).map((part) => numberStringFormatter.delocalize(part));\n  const day = values[order.indexOf(\"d\")];\n  const month = values[order.indexOf(\"m\")];\n  const year = values[order.indexOf(\"y\")];\n  return { day, month, year };\n}\n\n/**\n * Return first portion of ISO string (YYYY-mm-dd)\n *\n * @param date\n */\nexport function dateToISO(date?: Date): string {\n  if (date instanceof Date) {\n    return new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().split(\"T\")[0];\n  }\n  return \"\";\n}\n\n/**\n * Retrieve day, month, and year strings from a ISO string (YYYY-mm-dd)\n *\n * @param string\n * @param isoDate\n */\nexport function datePartsFromISO(isoDate: string): { day: string; month: string; year: string } {\n  const dateParts = isoDate.split(\"-\");\n  return { day: dateParts[2], month: dateParts[1], year: dateParts[0] };\n}\n\n/**\n * Check if two dates are the same day, month, year\n *\n * @param d1\n * @param d2\n */\nexport function sameDate(d1: Date, d2: Date): boolean {\n  return (\n    d1 instanceof Date &&\n    d2 instanceof Date &&\n    d1.getDate() === d2.getDate() &&\n    d1.getMonth() === d2.getMonth() &&\n    d1.getFullYear() === d2.getFullYear()\n  );\n}\n\n/**\n * Get a date one month in the past\n *\n * @param date\n */\nexport function prevMonth(date: Date): Date {\n  const month = date.getMonth();\n  const nextDate = new Date(date);\n  nextDate.setMonth(month - 1);\n  // date doesn't exist in new month, use last day\n  if (month === nextDate.getMonth()) {\n    return new Date(date.getFullYear(), month, 0);\n  }\n  return nextDate;\n}\n\n/**\n * Get a date one month in the future\n *\n * @param date\n */\nexport function nextMonth(date: Date): Date {\n  const month = date.getMonth();\n  const nextDate = new Date(date);\n  nextDate.setMonth(month + 1);\n  // date doesn't exist in new month, use last day\n  if ((month + 2) % 7 === nextDate.getMonth() % 7) {\n    return new Date(date.getFullYear(), month + 2, 0);\n  }\n  return nextDate;\n}\n\n/**\n * Parse numeric units for day, month, and year from a localized string\n * month starts at 0 (can pass to date constructor)\n * can return values as number or string\n *\n * @param string\n * @param localeData\n */\nexport function parseDateString(\n  string: string,\n  localeData: DateLocaleData,\n): { day: number; month: number; year: number } {\n  const { day, month, year } = datePartsFromLocalizedString(string, localeData);\n  return {\n    day: parseInt(day),\n    month: parseInt(month) - 1, // this subtracts by 1 because the month in the Date constructor is zero-based https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth\n    year: parseInt(year),\n  };\n}\n\ntype unitOrderSignifier = \"m\" | \"d\" | \"y\";\n\n/**\n * Based on the unitOrder string, find order of month, day, and year for locale\n *\n * @param unitOrder\n */\nexport function getOrder(unitOrder: string): unitOrderSignifier[] {\n  const signifiers: unitOrderSignifier[] = [\"d\", \"m\", \"y\"];\n  const order = unitOrder.toLowerCase();\n  return signifiers.sort((a, b) => order.indexOf(a) - order.indexOf(b));\n}\n\n/**\n * Get number of days between two dates\n *\n * @param date1\n * @param date2\n */\nexport function getDaysDiff(date1: Date, date2: Date): number {\n  const ts1 = date1.getTime();\n  const ts2 = date2.getTime();\n  return (ts1 - ts2) / (1000 * 3600 * 24);\n}\n\n/**\n * Set time of the day to the end.\n *\n * @param {Date} date Date.\n * @returns {Date} Date with time set to end of day .\n */\nexport function setEndOfDay(date: Date): Date {\n  date.setHours(23, 59, 59, 999);\n  return date;\n}\n","import { getAssetPath } from \"@stencil/core\";\nimport { dateFromISO } from \"../../utils/date\";\nimport { getSupportedLocale } from \"../../utils/locale\";\n\n/**\n * Translation resource data structure\n *\n * @private\n */\nexport interface DateLocaleData {\n  \"default-calendar\": \"gregorian\" | \"buddhist\";\n  separator: string;\n  unitOrder: string;\n  weekStart: number;\n  placeholder: string;\n  days: {\n    abbreviated?: string[];\n    narrow?: string[];\n    short?: string[];\n    wide?: string[];\n  };\n  numerals: string;\n  months: {\n    abbreviated: string[];\n    narrow: string[];\n    wide: string[];\n  };\n  year?: {\n    suffix: string;\n  };\n}\n\n/**\n * CLDR cache.\n * Exported for testing purposes.\n *\n * @private\n */\nexport const translationCache: Record<string, DateLocaleData> = {};\n\n/**\n * CLDR request cache.\n * Exported for testing purposes.\n *\n * @private\n */\nexport const requestCache: Record<string, Promise<DateLocaleData>> = {};\n\n/**\n * Fetch calendar data for a given locale from list of supported languages\n *\n * @param lang\n * @public\n */\nexport async function getLocaleData(lang: string): Promise<DateLocaleData> {\n  const locale = getSupportedLocale(lang);\n  if (translationCache[locale]) {\n    return translationCache[locale];\n  }\n  if (!requestCache[locale]) {\n    requestCache[locale] = fetch(getAssetPath(`./assets/date-picker/nls/${locale}.json`))\n      .then((resp) => resp.json())\n      .catch(() => {\n        console.error(`Translations for \"${locale}\" not found or invalid, falling back to english`);\n        return getLocaleData(\"en\");\n      });\n  }\n\n  const data = await requestCache[locale];\n  translationCache[locale] = data;\n\n  return data;\n}\n\n/**\n *  Maps value to valueAsDate\n *\n * @param value\n */\n\nexport function getValueAsDateRange(value: string[]): Date[] {\n  return value.map((v, index) => dateFromISO(v, index === 1));\n}\n"],"mappings":"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"}