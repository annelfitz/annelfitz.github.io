{"version":3,"names":["isOpen","component","opened","open","emitImmediately","nonOpenCloseComponent","transitionProp","onBeforeOpen","onBeforeClose","onOpen","onClose","onToggleOpenCloseComponent","readTask","transitionEl","transitionDuration","allDurations","transitionProperty","allProps","getComputedStyle","allTransitionDurationsArray","split","allTransitionPropsArray","openTransitionPropIndex","indexOf","openTransitionProp","fallbackTimeoutId","setTimeout","removeEventListener","onStart","onEndOrCancel","parseFloat","addEventListener","event","propertyName","target","clearTimeout"],"sources":["src/utils/openCloseComponent.ts"],"sourcesContent":["import { readTask } from \"@stencil/core\";\n/**\n * Defines interface for components with open/close public emitter.\n * All implementations of this interface must handle the following events: `beforeOpen`, `open`, `beforeClose`, `close`.\n */\nexport interface OpenCloseComponent {\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n\n  /**\n   * When true, the component opens.\n   */\n  open?: boolean;\n\n  /**\n   * When true, the component is open.\n   */\n  opened?: boolean;\n\n  /**\n   *  Specifies the name of transitionProp.\n   */\n  transitionProp?: string;\n\n  /**\n   * Specifies property on which active transition is watched for.\n   */\n  openTransitionProp: string;\n\n  /**\n   * Specifies element that the transition is allowed to emit on.\n   */\n  transitionEl: HTMLElement;\n\n  /**\n   * Defines method for `beforeOpen` event handler.\n   */\n  onBeforeOpen: () => void;\n\n  /**\n   * Defines method for `open` event handler:\n   */\n  onOpen: () => void;\n\n  /**\n   * Defines method for `beforeClose` event handler:\n   */\n  onBeforeClose: () => void;\n\n  /**\n   * Defines method for `close` event handler:\n   */\n  onClose: () => void;\n}\n\nconst componentToTransitionListeners = new WeakMap<\n  OpenCloseComponent,\n  [HTMLElement, typeof transitionStart, typeof transitionEnd]\n>();\n\nfunction transitionStart(this: OpenCloseComponent, event: TransitionEvent): void {\n  if (event.propertyName === this.openTransitionProp && event.target === this.transitionEl) {\n    isOpen(this) ? this.onBeforeOpen() : this.onBeforeClose();\n  }\n}\nfunction transitionEnd(this: OpenCloseComponent, event: TransitionEvent): void {\n  if (event.propertyName === this.openTransitionProp && event.target === this.transitionEl) {\n    isOpen(this) ? this.onOpen() : this.onClose();\n  }\n}\n\nfunction isOpen(component: OpenCloseComponent): boolean {\n  return \"opened\" in component ? component.opened : component.open;\n}\n\nfunction emitImmediately(component: OpenCloseComponent, nonOpenCloseComponent = false): void {\n  (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))\n    ? component.onBeforeOpen()\n    : component.onBeforeClose();\n  (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))\n    ? component.onOpen()\n    : component.onClose();\n}\n\n/**\n * Helper to determine globally set transition duration on the given openTransitionProp, which is imported and set in the @Watch(\"open\").\n * Used to emit (before)open/close events both for when the opacity transition is present and when there is none (transition-duration is set to 0).\n *\n * @example\n * import { onToggleOpenCloseComponent, OpenCloseComponent } from \"../../utils/openCloseComponent\";\n *\n * async componentWillLoad() {\n * // When component initially renders, if `open` was set we need to trigger on load as watcher doesn't fire.\n * if (this.open) {\n *    onToggleOpenCloseComponent(this);\n * }\n * @Watch(\"open\")\n * async toggleModal(value: boolean): Promise<void> {\n *    onToggleOpenCloseComponent(this);\n * }\n *\n * @param component - OpenCloseComponent uses `open` prop to emit (before)open/close.\n * @param nonOpenCloseComponent - OpenCloseComponent uses `expanded` prop to emit (before)open/close.\n */\nexport function onToggleOpenCloseComponent(component: OpenCloseComponent, nonOpenCloseComponent = false): void {\n  readTask((): void => {\n    if (component.transitionEl) {\n      const { transitionDuration: allDurations, transitionProperty: allProps } = getComputedStyle(\n        component.transitionEl,\n      );\n      const allTransitionDurationsArray = allDurations.split(\",\");\n      const allTransitionPropsArray = allProps.split(\",\");\n      const openTransitionPropIndex = allTransitionPropsArray.indexOf(component.openTransitionProp);\n\n      const transitionDuration =\n        allTransitionDurationsArray[openTransitionPropIndex] ??\n        /* Safari will have a single transition value if multiple props share it,\n        so we fall back to it if there's no matching prop duration */\n        allTransitionDurationsArray[0];\n\n      if (transitionDuration === \"0s\") {\n        emitImmediately(component, nonOpenCloseComponent);\n        return;\n      }\n\n      const fallbackTimeoutId = setTimeout(\n        (): void => {\n          component.transitionEl.removeEventListener(\"transitionstart\", onStart);\n          component.transitionEl.removeEventListener(\"transitionend\", onEndOrCancel);\n          component.transitionEl.removeEventListener(\"transitioncancel\", onEndOrCancel);\n          emitImmediately(component, nonOpenCloseComponent);\n        },\n        parseFloat(transitionDuration) * 1000,\n      );\n\n      component.transitionEl.addEventListener(\"transitionstart\", onStart);\n      component.transitionEl.addEventListener(\"transitionend\", onEndOrCancel);\n      component.transitionEl.addEventListener(\"transitioncancel\", onEndOrCancel);\n\n      function onStart(event: TransitionEvent): void {\n        if (event.propertyName === component.openTransitionProp && event.target === component.transitionEl) {\n          clearTimeout(fallbackTimeoutId);\n          component.transitionEl.removeEventListener(\"transitionstart\", onStart);\n          (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))\n            ? component.onBeforeOpen()\n            : component.onBeforeClose();\n        }\n      }\n\n      function onEndOrCancel(event: TransitionEvent): void {\n        if (event.propertyName === component.openTransitionProp && event.target === component.transitionEl) {\n          (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))\n            ? component.onOpen()\n            : component.onClose();\n\n          component.transitionEl.removeEventListener(\"transitionend\", onEndOrCancel);\n          component.transitionEl.removeEventListener(\"transitioncancel\", onEndOrCancel);\n        }\n      }\n    }\n  });\n}\n\n/**\n * Helper to keep track of transition listeners on setTransitionEl and connectedCallback on OpenCloseComponent components.\n *\n * For component which do not have open prop, use `onToggleOpenCloseComponent` implementation.\n *\n * @param component\n * @deprecated Call `onToggleOpenClose` in `componentWillLoad` and `open` property watchers instead.\n */\nexport function connectOpenCloseComponent(component: OpenCloseComponent): void {\n  disconnectOpenCloseComponent(component);\n  if (component.transitionEl) {\n    const boundOnTransitionStart: (event: TransitionEvent) => void = transitionStart.bind(component);\n    const boundOnTransitionEnd: (event: TransitionEvent) => void = transitionEnd.bind(component);\n\n    componentToTransitionListeners.set(component, [\n      component.transitionEl,\n      boundOnTransitionStart,\n      boundOnTransitionEnd,\n    ]);\n\n    component.transitionEl.addEventListener(\"transitionstart\", boundOnTransitionStart);\n    component.transitionEl.addEventListener(\"transitionend\", boundOnTransitionEnd);\n  }\n}\n/**\n * Helper to tear down transition listeners on disconnectedCallback on OpenCloseComponent components.\n *\n * @param component\n * @deprecated Call `onToggleOpenClose` in `componentWillLoad` and `open` property watchers instead.\n */\nexport function disconnectOpenCloseComponent(component: OpenCloseComponent): void {\n  if (!componentToTransitionListeners.has(component)) {\n    return;\n  }\n  const [transitionEl, start, end] = componentToTransitionListeners.get(component);\n  transitionEl.removeEventListener(\"transitionstart\", start);\n  transitionEl.removeEventListener(\"transitionend\", end);\n\n  componentToTransitionListeners.delete(component);\n}\n"],"mappings":";;;;;oCAyEA,SAASA,EAAOC,GACd,MAAO,WAAYA,EAAYA,EAAUC,OAASD,EAAUE,IAC9D,CAEA,SAASC,EAAgBH,EAA+BI,EAAwB,QAC7EA,EAAwBJ,EAAUA,EAAUK,gBAAkBN,EAAOC,IAClEA,EAAUM,eACVN,EAAUO,iBACbH,EAAwBJ,EAAUA,EAAUK,gBAAkBN,EAAOC,IAClEA,EAAUQ,SACVR,EAAUS,SAChB,C,SAsBgBC,EAA2BV,EAA+BI,EAAwB,OAChGO,GAAS,KACP,GAAIX,EAAUY,aAAc,CAC1B,MAAQC,mBAAoBC,EAAcC,mBAAoBC,GAAaC,iBACzEjB,EAAUY,cAEZ,MAAMM,EAA8BJ,EAAaK,MAAM,KACvD,MAAMC,EAA0BJ,EAASG,MAAM,KAC/C,MAAME,EAA0BD,EAAwBE,QAAQtB,EAAUuB,oBAE1E,MAAMV,EACJK,EAA4BG,IAG5BH,EAA4B,GAE9B,GAAIL,IAAuB,KAAM,CAC/BV,EAAgBH,EAAWI,GAC3B,M,CAGF,MAAMoB,EAAoBC,YACxB,KACEzB,EAAUY,aAAac,oBAAoB,kBAAmBC,GAC9D3B,EAAUY,aAAac,oBAAoB,gBAAiBE,GAC5D5B,EAAUY,aAAac,oBAAoB,mBAAoBE,GAC/DzB,EAAgBH,EAAWI,EAAsB,GAEnDyB,WAAWhB,GAAsB,KAGnCb,EAAUY,aAAakB,iBAAiB,kBAAmBH,GAC3D3B,EAAUY,aAAakB,iBAAiB,gBAAiBF,GACzD5B,EAAUY,aAAakB,iBAAiB,mBAAoBF,GAE5D,SAASD,EAAQI,GACf,GAAIA,EAAMC,eAAiBhC,EAAUuB,oBAAsBQ,EAAME,SAAWjC,EAAUY,aAAc,CAClGsB,aAAaV,GACbxB,EAAUY,aAAac,oBAAoB,kBAAmBC,IAC7DvB,EAAwBJ,EAAUA,EAAUK,gBAAkBN,EAAOC,IAClEA,EAAUM,eACVN,EAAUO,e,EAIlB,SAASqB,EAAcG,GACrB,GAAIA,EAAMC,eAAiBhC,EAAUuB,oBAAsBQ,EAAME,SAAWjC,EAAUY,aAAc,EACjGR,EAAwBJ,EAAUA,EAAUK,gBAAkBN,EAAOC,IAClEA,EAAUQ,SACVR,EAAUS,UAEdT,EAAUY,aAAac,oBAAoB,gBAAiBE,GAC5D5B,EAAUY,aAAac,oBAAoB,mBAAoBE,E,MAKzE,Q"}