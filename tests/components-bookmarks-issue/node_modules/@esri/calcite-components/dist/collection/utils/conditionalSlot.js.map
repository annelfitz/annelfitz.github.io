{"version":3,"file":"conditionalSlot.js","sourceRoot":"","sources":["../../../src/utils/conditionalSlot.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;AAE7C,MAAM,QAAQ,GAAG,IAAI,GAAG,EAAe,CAAC;AAkBxC,IAAI,gBAAkC,CAAC;AACvC,MAAM,eAAe,GAAkE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC;AAE3G;;;;;;;;;GASG;AACH,MAAM,UAAU,+BAA+B,CAAC,SAAmC;IACjF,IAAI,CAAC,gBAAgB,EAAE;QACrB,gBAAgB,GAAG,cAAc,CAAC,UAAU,EAAE,gBAAgB,CAAC,CAAC;KACjE;IAED,gBAAgB,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,EAAE,eAAe,CAAC,CAAC;AAC1D,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,kCAAkC,CAAC,SAAmC;IACpF,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;IAE9B,sEAAsE;IACtE,iEAAiE;IACjE,+CAA+C;IAC/C,gBAAgB,CAAC,gBAAgB,CAAC,WAAW,EAAE,CAAC,CAAC;IACjD,gBAAgB,CAAC,UAAU,EAAE,CAAC;IAC9B,KAAK,MAAM,CAAC,OAAO,CAAC,IAAI,QAAQ,CAAC,OAAO,EAAE,EAAE;QAC1C,gBAAgB,CAAC,OAAO,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;KACpD;AACH,CAAC;AAED,SAAS,gBAAgB,CAAC,SAA2B;IACnD,SAAS,CAAC,OAAO,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE;QAC/B,WAAW,CAAC,MAAM,CAAC,CAAC;IACtB,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["import { forceUpdate } from \"@stencil/core\";\nimport { createObserver } from \"./observers\";\n\nconst observed = new Set<HTMLElement>();\n\n/**\n * Defines interface for components with a dynamically changing slot.\n *\n * @deprecated Use `onSlotchange` event with `slotChangeHasAssignedElement` DOM utility instead.\n *\n * ```\n * <slot onSlotchange={(event) => this.mySlotHasElement = slotChangeHasAssignedElement(event)} />}\n * ```\n */\nexport interface ConditionalSlotComponent {\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n}\n\nlet mutationObserver: MutationObserver;\nconst observerOptions: Pick<Parameters<MutationObserver[\"observe\"]>[1], \"childList\"> = { childList: true };\n\n/**\n * Helper to set up a conditional slot component on connectedCallback.\n *\n * @param component\n * @deprecated Use `onSlotchange` event with `slotChangeHasAssignedElement` DOM utility instead.\n *\n * ```\n * <slot onSlotchange={(event) => this.mySlotHasElement = slotChangeHasAssignedElement(event)} />}\n * ```\n */\nexport function connectConditionalSlotComponent(component: ConditionalSlotComponent): void {\n  if (!mutationObserver) {\n    mutationObserver = createObserver(\"mutation\", processMutations);\n  }\n\n  mutationObserver.observe(component.el, observerOptions);\n}\n\n/**\n * Helper to tear down a conditional slot component on disconnectedCallback.\n *\n * @param component\n * @deprecated Use `onSlotchange` event with `slotChangeHasAssignedElement` DOM utility instead.\n *\n * ```\n * <slot onSlotchange={(event) => this.mySlotHasElement = slotChangeHasAssignedElement(event)} />}\n * ```\n */\nexport function disconnectConditionalSlotComponent(component: ConditionalSlotComponent): void {\n  observed.delete(component.el);\n\n  // we explicitly process queued mutations and disconnect and reconnect\n  // the observer until MutationObserver gets an `unobserve` method\n  // see https://github.com/whatwg/dom/issues/126\n  processMutations(mutationObserver.takeRecords());\n  mutationObserver.disconnect();\n  for (const [element] of observed.entries()) {\n    mutationObserver.observe(element, observerOptions);\n  }\n}\n\nfunction processMutations(mutations: MutationRecord[]): void {\n  mutations.forEach(({ target }) => {\n    forceUpdate(target);\n  });\n}\n"]}