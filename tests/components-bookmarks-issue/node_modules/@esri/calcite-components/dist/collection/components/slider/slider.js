/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.6.0
 */
import { h, Host, } from "@stencil/core";
import { guid } from "../../utils/guid";
import { intersects, isPrimaryPointerButton } from "../../utils/dom";
import { afterConnectDefaultValueSet, connectForm, disconnectForm, HiddenFormInputSlot, } from "../../utils/form";
import { connectInteractive, disconnectInteractive, InteractiveContainer, updateHostInteraction, } from "../../utils/interactive";
import { isActivationKey } from "../../utils/key";
import { connectLabel, disconnectLabel, getLabelText } from "../../utils/label";
import { componentFocusable, setComponentLoaded, setUpLoadableComponent, } from "../../utils/loadable";
import { connectLocalized, disconnectLocalized, numberStringFormatter, } from "../../utils/locale";
import { clamp, decimalPlaces } from "../../utils/math";
import { CSS, maxTickElementThreshold } from "./resources";
function isRange(value) {
    return Array.isArray(value);
}
export class Slider {
    constructor() {
        this.activeProp = "value";
        this.guid = `calcite-slider-${guid()}`;
        this.onThumbBlur = () => {
            this.activeProp = null;
        };
        this.onThumbFocus = (event) => {
            const thumb = event.currentTarget;
            this.activeProp = thumb.getAttribute("data-value-prop");
        };
        this.onThumbPointerDown = (event) => {
            const thumb = event.currentTarget;
            this.pointerDownDragStart(event, thumb.getAttribute("data-value-prop"));
        };
        this.onTrackPointerDown = (event) => {
            this.pointerDownDragStart(event, "minMaxValue");
        };
        this.dragUpdate = (event) => {
            if (this.disabled) {
                return;
            }
            event.preventDefault();
            if (this.dragProp) {
                const value = this.translate(event.clientX || event.pageX);
                if (isRange(this.value) && this.dragProp === "minMaxValue") {
                    if (this.minValueDragRange && this.maxValueDragRange && this.minMaxValueRange) {
                        const newMinValue = value - this.minValueDragRange;
                        const newMaxValue = value + this.maxValueDragRange;
                        if (newMaxValue <= this.max &&
                            newMinValue >= this.min &&
                            newMaxValue - newMinValue === this.minMaxValueRange) {
                            this.setValue({
                                minValue: this.clamp(newMinValue, "minValue"),
                                maxValue: this.clamp(newMaxValue, "maxValue"),
                            });
                        }
                    }
                    else {
                        this.minValueDragRange = value - this.minValue;
                        this.maxValueDragRange = this.maxValue - value;
                        this.minMaxValueRange = this.maxValue - this.minValue;
                    }
                }
                else {
                    this.setValue({ [this.dragProp]: this.clamp(value, this.dragProp) });
                }
            }
        };
        this.pointerUpDragEnd = (event) => {
            if (this.disabled || !isPrimaryPointerButton(event)) {
                return;
            }
            this.dragEnd(event);
        };
        this.dragEnd = (event) => {
            if (this.disabled) {
                return;
            }
            this.removeDragListeners();
            this.focusActiveHandle(event.clientX);
            if (this.lastDragPropValue != this[this.dragProp]) {
                this.emitChange();
            }
            this.dragProp = null;
            this.lastDragPropValue = null;
            this.minValueDragRange = null;
            this.maxValueDragRange = null;
            this.minMaxValueRange = null;
        };
        this.storeTrackRef = (node) => {
            this.trackEl = node;
        };
        this.storeThumbRef = (el) => {
            if (!el) {
                return;
            }
            const valueProp = el.getAttribute("data-value-prop");
            valueProp === "minValue" ? (this.minHandle = el) : (this.maxHandle = el);
        };
        /**
         * Returns a string representing the localized label value based if the groupSeparator prop is parsed.
         *
         * @param value
         */
        this.formatValue = (value) => {
            numberStringFormatter.numberFormatOptions = {
                locale: this.effectiveLocale,
                numberingSystem: this.numberingSystem,
                useGrouping: this.groupSeparator,
            };
            return numberStringFormatter.localize(value.toString());
        };
        this.disabled = false;
        this.form = undefined;
        this.groupSeparator = false;
        this.hasHistogram = false;
        this.histogram = undefined;
        this.histogramStops = undefined;
        this.labelHandles = false;
        this.labelTicks = false;
        this.max = 100;
        this.maxLabel = undefined;
        this.maxValue = undefined;
        this.min = 0;
        this.minLabel = undefined;
        this.minValue = undefined;
        this.mirrored = false;
        this.name = undefined;
        this.numberingSystem = undefined;
        this.pageStep = undefined;
        this.precise = false;
        this.required = false;
        this.snap = false;
        this.step = 1;
        this.ticks = undefined;
        this.value = 0;
        this.scale = "m";
        this.effectiveLocale = "";
        this.minMaxValueRange = null;
        this.minValueDragRange = null;
        this.maxValueDragRange = null;
        this.tickValues = [];
    }
    histogramWatcher(newHistogram) {
        this.hasHistogram = !!newHistogram;
    }
    ticksWatcher() {
        this.tickValues = this.generateTickValues();
    }
    valueHandler() {
        this.setMinMaxFromValue();
    }
    minMaxValueHandler() {
        this.setValueFromMinMax();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        this.setMinMaxFromValue();
        this.setValueFromMinMax();
        connectLabel(this);
        connectForm(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
        disconnectLocalized(this);
        this.removeDragListeners();
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
        if (!isRange(this.value)) {
            this.value = this.snap ? this.getClosestStep(this.value) : this.clamp(this.value);
        }
        this.ticksWatcher();
        this.histogramWatcher(this.histogram);
        afterConnectDefaultValueSet(this, this.value);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        if (this.labelHandles) {
            this.adjustHostObscuredHandleLabel("value");
            if (isRange(this.value)) {
                this.adjustHostObscuredHandleLabel("minValue");
                if (!(this.precise && !this.hasHistogram)) {
                    this.hyphenateCollidingRangeHandleLabels();
                }
            }
        }
        this.hideObscuredBoundingTickLabels();
        updateHostInteraction(this);
    }
    render() {
        const id = this.el.id || this.guid;
        const value = isRange(this.value) ? this.maxValue : this.value;
        const min = this.minValue || this.min;
        const useMinValue = this.shouldUseMinValue();
        const minInterval = this.getUnitInterval(useMinValue ? this.minValue : min) * 100;
        const maxInterval = this.getUnitInterval(value) * 100;
        const mirror = this.shouldMirror();
        const valueIsRange = isRange(this.value);
        const thumbTypes = this.buildThumbType("max");
        const thumb = this.renderThumb({
            type: thumbTypes,
            thumbPlacement: thumbTypes.includes("histogram") ? "below" : "above",
            maxInterval,
            minInterval,
            mirror,
        });
        const minThumbTypes = this.buildThumbType("min");
        const minThumb = valueIsRange &&
            this.renderThumb({
                type: minThumbTypes,
                thumbPlacement: minThumbTypes.includes("histogram") || minThumbTypes.includes("precise")
                    ? "below"
                    : "above",
                maxInterval,
                minInterval,
                mirror,
            });
        return (h(Host, { id: id, onTouchStart: this.handleTouchStart }, h(InteractiveContainer, { disabled: this.disabled }, h("div", { "aria-label": getLabelText(this), class: {
                [CSS.container]: true,
                [CSS.containerRange]: valueIsRange,
                [`scale--${this.scale}`]: true,
            } }, this.renderGraph(), h("div", { class: CSS.track,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeTrackRef }, h("div", { class: CSS.trackRange, onPointerDown: this.onTrackPointerDown, style: {
                left: `${mirror ? 100 - maxInterval : minInterval}%`,
                right: `${mirror ? minInterval : 100 - maxInterval}%`,
            } }), h("div", { class: CSS.ticks }, this.tickValues.map((tick) => {
            const tickOffset = `${this.getUnitInterval(tick) * 100}%`;
            let activeTicks = tick >= min && tick <= value;
            if (useMinValue) {
                activeTicks = tick >= this.minValue && tick <= this.maxValue;
            }
            return (h("span", { class: {
                    [CSS.tick]: true,
                    [CSS.tickActive]: activeTicks,
                }, style: {
                    left: mirror ? "" : tickOffset,
                    right: mirror ? tickOffset : "",
                } }, this.renderTickLabel(tick)));
        }))), h("div", { class: CSS.thumbContainer }, minThumb, thumb, h(HiddenFormInputSlot, { component: this }))))));
    }
    renderThumb({ type, mirror, thumbPlacement, minInterval, maxInterval, }) {
        const isLabeled = type.includes("labeled");
        const isPrecise = type.includes("precise");
        const isMinThumb = type.includes("min");
        const valueIsRange = isRange(this.value);
        const value = isMinThumb
            ? this.minValue
            : valueIsRange
                ? this.maxValue
                : this.value;
        const valueProp = isMinThumb ? "minValue" : valueIsRange ? "maxValue" : "value";
        const ariaLabel = isMinThumb ? this.minLabel : valueIsRange ? this.maxLabel : this.minLabel;
        const ariaValuenow = isMinThumb ? this.minValue : value;
        const displayedValue = isMinThumb ? this.formatValue(this.minValue) : this.formatValue(value);
        const thumbStyle = isMinThumb
            ? { left: `${mirror ? 100 - minInterval : minInterval}%` }
            : { right: `${mirror ? maxInterval : 100 - maxInterval}%` };
        const thumbLabelClasses = `${CSS.handleLabel} ${isMinThumb ? CSS.handleLabelMinValue : CSS.handleLabelValue}`;
        const labels = isLabeled
            ? [
                h("span", { "aria-hidden": "true", class: thumbLabelClasses }, displayedValue),
                h("span", { "aria-hidden": "true", class: `${thumbLabelClasses} ${CSS.static}` }, displayedValue),
                h("span", { "aria-hidden": "true", class: `${thumbLabelClasses} ${CSS.transformed}` }, displayedValue),
            ]
            : [];
        const thumbContent = [
            ...labels,
            h("div", { class: CSS.handle }),
            isPrecise && h("div", { class: CSS.handleExtension }),
        ];
        if (thumbPlacement === "below") {
            thumbContent.reverse();
        }
        return (h("div", { "aria-disabled": this.disabled, "aria-label": ariaLabel, "aria-orientation": "horizontal", "aria-valuemax": this.max, "aria-valuemin": this.min, "aria-valuenow": ariaValuenow, class: {
                [CSS.thumb]: true,
                [CSS.thumbValue]: !isMinThumb,
                [CSS.thumbActive]: this.lastDragProp !== "minMaxValue" && this.dragProp === valueProp,
                [CSS.thumbPrecise]: isPrecise,
                [CSS.thumbMinValue]: isMinThumb,
            }, "data-value-prop": valueProp, key: type, onBlur: this.onThumbBlur, onFocus: this.onThumbFocus, onPointerDown: this.onThumbPointerDown, role: "slider", style: thumbStyle, tabIndex: 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeThumbRef }, thumbContent));
    }
    renderGraph() {
        return this.histogram ? (h("calcite-graph", { class: CSS.graph, colorStops: this.histogramStops, data: this.histogram, highlightMax: isRange(this.value) ? this.maxValue : this.value, highlightMin: isRange(this.value) ? this.minValue : this.min, max: this.max, min: this.min })) : null;
    }
    renderTickLabel(tick) {
        const { hasHistogram, labelHandles, labelTicks, max, min, precise, value } = this;
        const valueIsRange = isRange(value);
        const isMinTickLabel = tick === min;
        const isMaxTickLabel = tick === max;
        const isAtEdge = isMinTickLabel || isMaxTickLabel;
        const shouldDisplayLabel = labelTicks &&
            ((!hasHistogram && (isAtEdge || !precise || !valueIsRange)) ||
                (hasHistogram && (isAtEdge || (!precise && !labelHandles))));
        return shouldDisplayLabel ? (h("span", { class: {
                [CSS.tickLabel]: true,
                [CSS.tickMin]: isMinTickLabel,
                [CSS.tickMax]: isMaxTickLabel,
            } }, this.formatValue(tick))) : null;
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    keyDownHandler(event) {
        const mirror = this.shouldMirror();
        const { activeProp, max, min, pageStep, step } = this;
        const value = this[activeProp];
        const { key } = event;
        if (isActivationKey(key)) {
            event.preventDefault();
            return;
        }
        let adjustment;
        if (key === "ArrowUp" || key === "ArrowRight") {
            const directionFactor = mirror && key === "ArrowRight" ? -1 : 1;
            adjustment = value + step * directionFactor;
        }
        else if (key === "ArrowDown" || key === "ArrowLeft") {
            const directionFactor = mirror && key === "ArrowLeft" ? -1 : 1;
            adjustment = value - step * directionFactor;
        }
        else if (key === "PageUp") {
            if (pageStep) {
                adjustment = value + pageStep;
            }
        }
        else if (key === "PageDown") {
            if (pageStep) {
                adjustment = value - pageStep;
            }
        }
        else if (key === "Home") {
            adjustment = min;
        }
        else if (key === "End") {
            adjustment = max;
        }
        if (isNaN(adjustment)) {
            return;
        }
        event.preventDefault();
        const fixedDecimalAdjustment = Number(adjustment.toFixed(decimalPlaces(step)));
        this.setValue({
            [activeProp]: this.clamp(fixedDecimalAdjustment, activeProp),
        });
    }
    pointerDownHandler(event) {
        if (this.disabled || !isPrimaryPointerButton(event)) {
            return;
        }
        const x = event.clientX || event.pageX;
        const position = this.translate(x);
        let prop = "value";
        if (isRange(this.value)) {
            const inRange = position >= this.minValue && position <= this.maxValue;
            if (inRange && this.lastDragProp === "minMaxValue") {
                prop = "minMaxValue";
            }
            else {
                const closerToMax = Math.abs(this.maxValue - position) < Math.abs(this.minValue - position);
                prop = closerToMax || position > this.maxValue ? "maxValue" : "minValue";
            }
        }
        this.lastDragPropValue = this[prop];
        this.dragStart(prop);
        const isThumbActive = this.el.shadowRoot.querySelector(`.${CSS.thumb}:active`);
        if (!isThumbActive) {
            this.setValue({ [prop]: this.clamp(position, prop) });
        }
        this.focusActiveHandle(x);
    }
    handleTouchStart(event) {
        // needed to prevent extra click at the end of a handle drag
        event.preventDefault();
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        const handle = this.minHandle ? this.minHandle : this.maxHandle;
        handle?.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    buildThumbType(type) {
        const thumbTypeParts = [type];
        if (this.labelHandles) {
            thumbTypeParts.push("labeled");
        }
        if (this.precise) {
            thumbTypeParts.push("precise");
        }
        if (this.hasHistogram) {
            thumbTypeParts.push("histogram");
        }
        return thumbTypeParts.join("-");
    }
    setValueFromMinMax() {
        const { minValue, maxValue } = this;
        if (typeof minValue === "number" && typeof maxValue === "number") {
            this.value = [minValue, maxValue];
        }
    }
    setMinMaxFromValue() {
        const { value } = this;
        if (isRange(value)) {
            this.minValue = value[0];
            this.maxValue = value[1];
        }
    }
    onLabelClick() {
        this.setFocus();
    }
    shouldMirror() {
        return this.mirrored && !this.hasHistogram;
    }
    shouldUseMinValue() {
        if (!isRange(this.value)) {
            return false;
        }
        return ((this.hasHistogram && this.maxValue === 0) || (!this.hasHistogram && this.minValue === 0));
    }
    getTickDensity() {
        const density = (this.max - this.min) / this.ticks / maxTickElementThreshold;
        return density < 1 ? 1 : density;
    }
    generateTickValues() {
        const tickInterval = this.ticks ?? 0;
        if (tickInterval <= 0) {
            return [];
        }
        const ticks = [this.min];
        const density = this.getTickDensity();
        const tickOffset = tickInterval * density;
        let current = this.min;
        while (current < this.max) {
            current += tickOffset;
            ticks.push(Math.min(current, this.max));
        }
        if (!ticks.includes(this.max)) {
            ticks.push(this.max);
        }
        return ticks;
    }
    pointerDownDragStart(event, prop) {
        if (!isPrimaryPointerButton(event)) {
            return;
        }
        this.dragStart(prop);
    }
    dragStart(prop) {
        this.dragProp = prop;
        this.lastDragProp = this.dragProp;
        this.activeProp = prop;
        window.addEventListener("pointermove", this.dragUpdate);
        window.addEventListener("pointerup", this.pointerUpDragEnd);
        window.addEventListener("pointercancel", this.dragEnd);
    }
    focusActiveHandle(valueX) {
        switch (this.dragProp) {
            case "minValue":
                this.minHandle.focus();
                break;
            case "maxValue":
            case "value":
                this.maxHandle.focus();
                break;
            case "minMaxValue":
                this.getClosestHandle(valueX).focus();
                break;
            default:
                break;
        }
    }
    emitInput() {
        this.calciteSliderInput.emit();
    }
    emitChange() {
        this.calciteSliderChange.emit();
    }
    removeDragListeners() {
        window.removeEventListener("pointermove", this.dragUpdate);
        window.removeEventListener("pointerup", this.pointerUpDragEnd);
        window.removeEventListener("pointercancel", this.dragEnd);
    }
    /**
     * Set prop value(s) if changed at the component level
     *
     * @param {object} values - a set of key/value pairs delineating what properties in the component to update
     */
    setValue(values) {
        let valueChanged;
        Object.keys(values).forEach((propName) => {
            const newValue = values[propName];
            if (!valueChanged) {
                const oldValue = this[propName];
                valueChanged = oldValue !== newValue;
            }
            this[propName] = newValue;
        });
        if (!valueChanged) {
            return;
        }
        const dragging = this.dragProp;
        if (!dragging) {
            this.emitChange();
        }
        this.emitInput();
    }
    /**
     * If number is outside range, constrain to min or max
     *
     * @param value
     * @param prop
     * @internal
     */
    clamp(value, prop) {
        value = clamp(value, this.min, this.max);
        // ensure that maxValue and minValue don't swap positions
        if (prop === "maxValue") {
            value = Math.max(value, this.minValue);
        }
        if (prop === "minValue") {
            value = Math.min(value, this.maxValue);
        }
        return value;
    }
    /**
     * Translate a pixel position to value along the range
     *
     * @param x
     * @internal
     */
    translate(x) {
        const range = this.max - this.min;
        const { left, width } = this.trackEl.getBoundingClientRect();
        const percent = (x - left) / width;
        const mirror = this.shouldMirror();
        const clampedValue = this.clamp(this.min + range * (mirror ? 1 - percent : percent));
        let value = Number(clampedValue.toFixed(decimalPlaces(this.step)));
        if (this.snap && this.step) {
            value = this.getClosestStep(value);
        }
        return value;
    }
    /**
     * Get closest allowed value along stepped values
     *
     * @param num
     * @internal
     */
    getClosestStep(num) {
        num = Number(this.clamp(num).toFixed(decimalPlaces(this.step)));
        if (this.step) {
            const step = Math.round(num / this.step) * this.step;
            num = Number(this.clamp(step).toFixed(decimalPlaces(this.step)));
        }
        return num;
    }
    getClosestHandle(valueX) {
        return this.getDistanceX(this.maxHandle, valueX) > this.getDistanceX(this.minHandle, valueX)
            ? this.minHandle
            : this.maxHandle;
    }
    getDistanceX(el, valueX) {
        return Math.abs(el.getBoundingClientRect().left - valueX);
    }
    getFontSizeForElement(element) {
        return Number(window.getComputedStyle(element).getPropertyValue("font-size").match(/\d+/)[0]);
    }
    /**
     * Get position of value along range as fractional value
     *
     * @param num
     * @return {number} number in the unit interval [0,1]
     * @internal
     */
    getUnitInterval(num) {
        num = this.clamp(num);
        const range = this.max - this.min;
        return (num - this.min) / range;
    }
    adjustHostObscuredHandleLabel(name) {
        const label = this.el.shadowRoot.querySelector(`.handle__label--${name}`);
        const labelStatic = this.el.shadowRoot.querySelector(`.handle__label--${name}.static`);
        const labelTransformed = this.el.shadowRoot.querySelector(`.handle__label--${name}.transformed`);
        const labelStaticBounds = labelStatic.getBoundingClientRect();
        const labelStaticOffset = this.getHostOffset(labelStaticBounds.left, labelStaticBounds.right);
        label.style.transform = `translateX(${labelStaticOffset}px)`;
        labelTransformed.style.transform = `translateX(${labelStaticOffset}px)`;
    }
    hyphenateCollidingRangeHandleLabels() {
        const { shadowRoot } = this.el;
        const mirror = this.shouldMirror();
        const leftModifier = mirror ? "value" : "minValue";
        const rightModifier = mirror ? "minValue" : "value";
        const leftValueLabel = shadowRoot.querySelector(`.handle__label--${leftModifier}`);
        const leftValueLabelStatic = shadowRoot.querySelector(`.handle__label--${leftModifier}.static`);
        const leftValueLabelTransformed = shadowRoot.querySelector(`.handle__label--${leftModifier}.transformed`);
        const leftValueLabelStaticHostOffset = this.getHostOffset(leftValueLabelStatic.getBoundingClientRect().left, leftValueLabelStatic.getBoundingClientRect().right);
        const rightValueLabel = shadowRoot.querySelector(`.handle__label--${rightModifier}`);
        const rightValueLabelStatic = shadowRoot.querySelector(`.handle__label--${rightModifier}.static`);
        const rightValueLabelTransformed = shadowRoot.querySelector(`.handle__label--${rightModifier}.transformed`);
        const rightValueLabelStaticHostOffset = this.getHostOffset(rightValueLabelStatic.getBoundingClientRect().left, rightValueLabelStatic.getBoundingClientRect().right);
        const labelFontSize = this.getFontSizeForElement(leftValueLabel);
        const labelTransformedOverlap = this.getRangeLabelOverlap(leftValueLabelTransformed, rightValueLabelTransformed);
        const hyphenLabel = leftValueLabel;
        const labelOffset = labelFontSize / 2;
        if (labelTransformedOverlap > 0) {
            hyphenLabel.classList.add(CSS.hyphen, CSS.hyphenWrap);
            if (rightValueLabelStaticHostOffset === 0 && leftValueLabelStaticHostOffset === 0) {
                // Neither handle overlaps the host boundary
                let leftValueLabelTranslate = labelTransformedOverlap / 2 - labelOffset;
                leftValueLabelTranslate =
                    Math.sign(leftValueLabelTranslate) === -1
                        ? Math.abs(leftValueLabelTranslate)
                        : -leftValueLabelTranslate;
                const leftValueLabelTransformedHostOffset = this.getHostOffset(leftValueLabelTransformed.getBoundingClientRect().left +
                    leftValueLabelTranslate -
                    labelOffset, leftValueLabelTransformed.getBoundingClientRect().right +
                    leftValueLabelTranslate -
                    labelOffset);
                let rightValueLabelTranslate = labelTransformedOverlap / 2;
                const rightValueLabelTransformedHostOffset = this.getHostOffset(rightValueLabelTransformed.getBoundingClientRect().left + rightValueLabelTranslate, rightValueLabelTransformed.getBoundingClientRect().right + rightValueLabelTranslate);
                if (leftValueLabelTransformedHostOffset !== 0) {
                    leftValueLabelTranslate += leftValueLabelTransformedHostOffset;
                    rightValueLabelTranslate += leftValueLabelTransformedHostOffset;
                }
                if (rightValueLabelTransformedHostOffset !== 0) {
                    leftValueLabelTranslate += rightValueLabelTransformedHostOffset;
                    rightValueLabelTranslate += rightValueLabelTransformedHostOffset;
                }
                leftValueLabel.style.transform = `translateX(${leftValueLabelTranslate}px)`;
                leftValueLabelTransformed.style.transform = `translateX(${leftValueLabelTranslate - labelOffset}px)`;
                rightValueLabel.style.transform = `translateX(${rightValueLabelTranslate}px)`;
                rightValueLabelTransformed.style.transform = `translateX(${rightValueLabelTranslate}px)`;
            }
            else if (leftValueLabelStaticHostOffset > 0 || rightValueLabelStaticHostOffset > 0) {
                // labels overlap host boundary on the left side
                leftValueLabel.style.transform = `translateX(${leftValueLabelStaticHostOffset + labelOffset}px)`;
                rightValueLabel.style.transform = `translateX(${labelTransformedOverlap + rightValueLabelStaticHostOffset}px)`;
                rightValueLabelTransformed.style.transform = `translateX(${labelTransformedOverlap + rightValueLabelStaticHostOffset}px)`;
            }
            else if (leftValueLabelStaticHostOffset < 0 || rightValueLabelStaticHostOffset < 0) {
                // labels overlap host boundary on the right side
                let leftValueLabelTranslate = Math.abs(leftValueLabelStaticHostOffset) + labelTransformedOverlap - labelOffset;
                leftValueLabelTranslate =
                    Math.sign(leftValueLabelTranslate) === -1
                        ? Math.abs(leftValueLabelTranslate)
                        : -leftValueLabelTranslate;
                leftValueLabel.style.transform = `translateX(${leftValueLabelTranslate}px)`;
                leftValueLabelTransformed.style.transform = `translateX(${leftValueLabelTranslate - labelOffset}px)`;
            }
        }
        else {
            hyphenLabel.classList.remove(CSS.hyphen, CSS.hyphenWrap);
            leftValueLabel.style.transform = `translateX(${leftValueLabelStaticHostOffset}px)`;
            leftValueLabelTransformed.style.transform = `translateX(${leftValueLabelStaticHostOffset}px)`;
            rightValueLabel.style.transform = `translateX(${rightValueLabelStaticHostOffset}px)`;
            rightValueLabelTransformed.style.transform = `translateX(${rightValueLabelStaticHostOffset}px)`;
        }
    }
    /**
     * Hides bounding tick labels that are obscured by either handle.
     */
    hideObscuredBoundingTickLabels() {
        const valueIsRange = isRange(this.value);
        if (!this.hasHistogram && !valueIsRange && !this.labelHandles && !this.precise) {
            return;
        }
        if (!this.hasHistogram && !valueIsRange && this.labelHandles && !this.precise) {
            return;
        }
        if (!this.hasHistogram && !valueIsRange && !this.labelHandles && this.precise) {
            return;
        }
        if (!this.hasHistogram && !valueIsRange && this.labelHandles && this.precise) {
            return;
        }
        if (!this.hasHistogram && valueIsRange && !this.precise) {
            return;
        }
        if (this.hasHistogram && !this.precise && !this.labelHandles) {
            return;
        }
        const minHandle = this.el.shadowRoot.querySelector(`.${CSS.thumbMinValue}`);
        const maxHandle = this.el.shadowRoot.querySelector(`.${CSS.thumbValue}`);
        const minTickLabel = this.el.shadowRoot.querySelector(`.${CSS.tickMin}`);
        const maxTickLabel = this.el.shadowRoot.querySelector(`.${CSS.tickMax}`);
        if (!minHandle && maxHandle && minTickLabel && maxTickLabel) {
            minTickLabel.style.opacity = this.isMinTickLabelObscured(minTickLabel, maxHandle) ? "0" : "1";
            maxTickLabel.style.opacity = this.isMaxTickLabelObscured(maxTickLabel, maxHandle) ? "0" : "1";
        }
        if (minHandle && maxHandle && minTickLabel && maxTickLabel) {
            minTickLabel.style.opacity =
                this.isMinTickLabelObscured(minTickLabel, minHandle) ||
                    this.isMinTickLabelObscured(minTickLabel, maxHandle)
                    ? "0"
                    : "1";
            maxTickLabel.style.opacity =
                this.isMaxTickLabelObscured(maxTickLabel, minHandle) ||
                    (this.isMaxTickLabelObscured(maxTickLabel, maxHandle) && this.hasHistogram)
                    ? "0"
                    : "1";
        }
    }
    /**
     * Returns an integer representing the number of pixels to offset on the left or right side based on desired position behavior.
     *
     * @param leftBounds
     * @param rightBounds
     * @internal
     */
    getHostOffset(leftBounds, rightBounds) {
        const hostBounds = this.el.getBoundingClientRect();
        const buffer = 7;
        if (leftBounds + buffer < hostBounds.left) {
            return hostBounds.left - leftBounds - buffer;
        }
        if (rightBounds - buffer > hostBounds.right) {
            return -(rightBounds - hostBounds.right) + buffer;
        }
        return 0;
    }
    /**
     * Returns an integer representing the number of pixels that the two given span elements are overlapping, taking into account
     * a space in between the two spans equal to the font-size set on them to account for the space needed to render a hyphen.
     *
     * @param leftLabel
     * @param rightLabel
     */
    getRangeLabelOverlap(leftLabel, rightLabel) {
        const leftLabelBounds = leftLabel.getBoundingClientRect();
        const rightLabelBounds = rightLabel.getBoundingClientRect();
        const leftLabelFontSize = this.getFontSizeForElement(leftLabel);
        const rangeLabelOverlap = leftLabelBounds.right + leftLabelFontSize - rightLabelBounds.left;
        return Math.max(rangeLabelOverlap, 0);
    }
    /**
     * Returns a boolean value representing if the minLabel span element is obscured (being overlapped) by the given handle div element.
     *
     * @param minLabel
     * @param handle
     */
    isMinTickLabelObscured(minLabel, handle) {
        const minLabelBounds = minLabel.getBoundingClientRect();
        const handleBounds = handle.getBoundingClientRect();
        return intersects(minLabelBounds, handleBounds);
    }
    /**
     * Returns a boolean value representing if the maxLabel span element is obscured (being overlapped) by the given handle div element.
     *
     * @param maxLabel
     * @param handle
     */
    isMaxTickLabelObscured(maxLabel, handle) {
        const maxLabelBounds = maxLabel.getBoundingClientRect();
        const handleBounds = handle.getBoundingClientRect();
        return intersects(maxLabelBounds, handleBounds);
    }
    static get is() { return "calcite-slider"; }
    static get encapsulation() { return "shadow"; }
    static get delegatesFocus() { return true; }
    static get originalStyleUrls() {
        return {
            "$": ["slider.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["slider.css"]
        };
    }
    static get properties() {
        return {
            "disabled": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, interaction is prevented and the component is displayed with lower opacity."
                },
                "attribute": "disabled",
                "reflect": true,
                "defaultValue": "false"
            },
            "form": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The `id` of the form that will be associated with the component.\n\nWhen not set, the component will be associated with its ancestor form element, if any."
                },
                "attribute": "form",
                "reflect": true
            },
            "groupSeparator": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, number values are displayed with a group separator corresponding to the language and country format."
                },
                "attribute": "group-separator",
                "reflect": true,
                "defaultValue": "false"
            },
            "hasHistogram": {
                "type": "boolean",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, indicates a histogram is present."
                },
                "attribute": "has-histogram",
                "reflect": true,
                "defaultValue": "false"
            },
            "histogram": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "DataSeries",
                    "resolved": "Point[]",
                    "references": {
                        "DataSeries": {
                            "location": "import",
                            "path": "../graph/interfaces",
                            "id": "src/components/graph/interfaces.ts::DataSeries"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "see",
                            "text": "[DataSeries](https://github.com/Esri/calcite-design-system/blob/main/src/components/graph/interfaces.ts#L5)"
                        }],
                    "text": "A list of the histogram's x,y coordinates within the component's `min` and `max`. Displays above the component's track."
                }
            },
            "histogramStops": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "ColorStop[]",
                    "resolved": "ColorStop[]",
                    "references": {
                        "ColorStop": {
                            "location": "import",
                            "path": "../graph/interfaces",
                            "id": "src/components/graph/interfaces.ts::ColorStop"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "A set of single color stops for a histogram, sorted by offset ascending."
                }
            },
            "labelHandles": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, displays label handles with their numeric value."
                },
                "attribute": "label-handles",
                "reflect": true,
                "defaultValue": "false"
            },
            "labelTicks": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true` and `ticks` is specified, displays label tick marks with their numeric value."
                },
                "attribute": "label-ticks",
                "reflect": true,
                "defaultValue": "false"
            },
            "max": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The component's maximum selectable value."
                },
                "attribute": "max",
                "reflect": true,
                "defaultValue": "100"
            },
            "maxLabel": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "For multiple selections, the accessible name for the second handle, such as `\"Temperature, upper bound\"`."
                },
                "attribute": "max-label",
                "reflect": false
            },
            "maxValue": {
                "type": "number",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "For multiple selections, the component's upper value."
                },
                "attribute": "max-value",
                "reflect": false
            },
            "min": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The component's minimum selectable value."
                },
                "attribute": "min",
                "reflect": true,
                "defaultValue": "0"
            },
            "minLabel": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Accessible name for first (or only) handle, such as `\"Temperature, lower bound\"`."
                },
                "attribute": "min-label",
                "reflect": false
            },
            "minValue": {
                "type": "number",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "For multiple selections, the component's lower value."
                },
                "attribute": "min-value",
                "reflect": false
            },
            "mirrored": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, the slider will display values from high to low.\n\nNote that this value will be ignored if the slider has an associated histogram."
                },
                "attribute": "mirrored",
                "reflect": true,
                "defaultValue": "false"
            },
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the name of the component.\n\nRequired to pass the component's `value` on form submission."
                },
                "attribute": "name",
                "reflect": true
            },
            "numberingSystem": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "NumberingSystem",
                    "resolved": "\"arab\" | \"arabext\" | \"latn\"",
                    "references": {
                        "NumberingSystem": {
                            "location": "import",
                            "path": "../../utils/locale",
                            "id": "src/utils/locale.ts::NumberingSystem"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the Unicode numeral system used by the component for localization."
                },
                "attribute": "numbering-system",
                "reflect": false
            },
            "pageStep": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the interval to move with the page up, or page down keys."
                },
                "attribute": "page-step",
                "reflect": true
            },
            "precise": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, sets a finer point for handles."
                },
                "attribute": "precise",
                "reflect": true,
                "defaultValue": "false"
            },
            "required": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, the component must have a value in order for the form to submit."
                },
                "attribute": "required",
                "reflect": true,
                "defaultValue": "false"
            },
            "snap": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, enables snap selection in coordination with `step` via a mouse."
                },
                "attribute": "snap",
                "reflect": true,
                "defaultValue": "false"
            },
            "step": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the interval to move with the up, or down keys."
                },
                "attribute": "step",
                "reflect": true,
                "defaultValue": "1"
            },
            "ticks": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Displays tick marks on the number line at a specified interval."
                },
                "attribute": "ticks",
                "reflect": true
            },
            "value": {
                "type": "number",
                "mutable": true,
                "complexType": {
                    "original": "null | number | number[]",
                    "resolved": "number | number[]",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The component's value."
                },
                "attribute": "value",
                "reflect": true,
                "defaultValue": "0"
            },
            "scale": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "Scale",
                    "resolved": "\"l\" | \"m\" | \"s\"",
                    "references": {
                        "Scale": {
                            "location": "import",
                            "path": "../interfaces",
                            "id": "src/components/interfaces.ts::Scale"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the size of the component."
                },
                "attribute": "scale",
                "reflect": true,
                "defaultValue": "\"m\""
            }
        };
    }
    static get states() {
        return {
            "effectiveLocale": {},
            "minMaxValueRange": {},
            "minValueDragRange": {},
            "maxValueDragRange": {},
            "tickValues": {}
        };
    }
    static get events() {
        return [{
                "method": "calciteSliderInput",
                "name": "calciteSliderInput",
                "bubbles": true,
                "cancelable": false,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Fires on all updates to the component.\n\nNote: Fires frequently during drag. To perform\nexpensive operations consider using a debounce or throttle to avoid\nlocking up the main thread."
                },
                "complexType": {
                    "original": "void",
                    "resolved": "void",
                    "references": {}
                }
            }, {
                "method": "calciteSliderChange",
                "name": "calciteSliderChange",
                "bubbles": true,
                "cancelable": false,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Fires when the thumb is released on the component.\n\nNote: To constantly listen to the drag event,\nuse `calciteSliderInput` instead."
                },
                "complexType": {
                    "original": "void",
                    "resolved": "void",
                    "references": {}
                }
            }];
    }
    static get methods() {
        return {
            "setFocus": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Sets focus on the component.",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "histogram",
                "methodName": "histogramWatcher"
            }, {
                "propName": "ticks",
                "methodName": "ticksWatcher"
            }, {
                "propName": "value",
                "methodName": "valueHandler"
            }, {
                "propName": "minValue",
                "methodName": "minMaxValueHandler"
            }, {
                "propName": "maxValue",
                "methodName": "minMaxValueHandler"
            }];
    }
    static get listeners() {
        return [{
                "name": "keydown",
                "method": "keyDownHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "pointerdown",
                "method": "pointerDownHandler",
                "target": undefined,
                "capture": false,
                "passive": true
            }];
    }
}
//# sourceMappingURL=slider.js.map
