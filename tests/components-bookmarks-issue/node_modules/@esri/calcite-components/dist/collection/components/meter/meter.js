/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.6.0
 */
import { h, Host } from "@stencil/core";
import { CSS } from "./resources";
import { setComponentLoaded, setUpLoadableComponent, } from "../../utils/loadable";
import { afterConnectDefaultValueSet, connectForm, disconnectForm, } from "../../utils/form";
import { connectLocalized, disconnectLocalized, getSupportedLocale, numberStringFormatter, } from "../../utils/locale";
import { intersects } from "../../utils/dom";
import { createObserver } from "../../utils/observers";
export class Meter {
    constructor() {
        this.labelFlipMax = 0.8;
        this.labelFlipProximity = 0.15;
        this.maxPercent = 100;
        this.minPercent = 0;
        this.resizeObserver = createObserver("resize", () => this.resizeHandler());
        this.formatLabel = (value, labelType) => {
            if (labelType === "percent") {
                if (!this.percentFormatting) {
                    const locale = getSupportedLocale(this.effectiveLocale);
                    const formatter = new Intl.NumberFormat(locale, {
                        useGrouping: this.groupSeparator,
                        style: "percent",
                    });
                    this.percentFormatting = { formatter, locale };
                }
                return this.percentFormatting.formatter.format(value);
            }
            else {
                numberStringFormatter.numberFormatOptions = {
                    locale: this.effectiveLocale,
                    numberingSystem: this.numberingSystem,
                    useGrouping: this.groupSeparator,
                };
                return numberStringFormatter.localize(value.toString());
            }
        };
        this.appearance = "outline-fill";
        this.disabled = false;
        this.fillType = "range";
        this.form = undefined;
        this.groupSeparator = false;
        this.high = undefined;
        this.label = undefined;
        this.low = undefined;
        this.max = 100;
        this.min = 0;
        this.name = undefined;
        this.numberingSystem = undefined;
        this.rangeLabels = false;
        this.rangeLabelType = "percent";
        this.scale = "m";
        this.unitLabel = "";
        this.value = undefined;
        this.valueLabel = false;
        this.valueLabelType = "percent";
        this.currentPercent = undefined;
        this.effectiveLocale = undefined;
        this.highActive = undefined;
        this.highPercent = undefined;
        this.lowActive = undefined;
        this.lowPercent = undefined;
    }
    handleRangeChange() {
        this.calculateValues();
        this.updateLabels();
    }
    handleLabelChange() {
        this.updateLabels();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        setUpLoadableComponent(this);
        this.calculateValues();
        afterConnectDefaultValueSet(this, this.value);
    }
    componentDidLoad() {
        setComponentLoaded(this);
        this.updateLabels();
    }
    connectedCallback() {
        connectLocalized(this);
        connectForm(this);
        this.resizeObserver?.observe(this.el);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectForm(this);
        this.resizeObserver?.disconnect();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    resizeHandler() {
        this.updateLabels();
    }
    updateLabels() {
        if (this.valueLabelEl) {
            this.determineValueLabelPosition();
        }
        if (this.rangeLabels) {
            this.determineVisibleLabels();
        }
    }
    calculateValues() {
        const { min, max, low, high, value } = this;
        const lowPercent = (100 * (low - min)) / (max - min);
        const highPercent = (100 * (high - min)) / (max - min);
        const currentPercent = (100 * (value - min)) / (max - min);
        if (!low || low < min || low > high || low > max) {
            this.low = min;
        }
        if (!high || high > max || high < low || high < min) {
            this.high = max;
        }
        if (!value) {
            this.value = min;
        }
        this.lowPercent = lowPercent;
        this.highPercent = highPercent;
        this.currentPercent = value ? currentPercent : 0;
        this.lowActive = !!low && low > min && (!value || low > value) && (!high || low < high);
        this.highActive =
            !!high && min <= high && high < max && (!value || high > value) && (!low || high > low);
    }
    getMeterKindCssClass() {
        const { low, high, min, max, value } = this;
        const lowest = low ? low : min;
        const highest = high ? high : max;
        const aboveLowest = value >= lowest;
        const belowLowest = value < lowest;
        const aboveHighest = value >= highest;
        const belowHighest = value < highest;
        if (!value || (!low && belowHighest) || belowLowest) {
            return CSS.success;
        }
        else if (aboveLowest && belowHighest) {
            return CSS.warning;
        }
        else if (aboveHighest) {
            return CSS.danger;
        }
        else {
            return CSS.success;
        }
    }
    intersects(el1, el2) {
        return el1 && el2 && intersects(el1.getBoundingClientRect(), el2.getBoundingClientRect());
    }
    determineVisibleLabels() {
        const { minLabelEl, lowLabelEl, highLabelEl, maxLabelEl } = this;
        const highMaxOverlap = this.intersects(highLabelEl, maxLabelEl);
        const lowHighOverlap = this.intersects(lowLabelEl, highLabelEl);
        const lowMaxOverlap = this.intersects(lowLabelEl, maxLabelEl);
        const minHighOverlap = this.intersects(minLabelEl, highLabelEl);
        const minLowOverlap = this.intersects(minLabelEl, lowLabelEl);
        const minMaxOverlap = this.intersects(minLabelEl, maxLabelEl);
        const hiddenClass = CSS.labelHidden;
        if (lowLabelEl) {
            if (minLowOverlap || lowMaxOverlap || lowHighOverlap) {
                lowLabelEl.classList.add(hiddenClass);
            }
            else {
                lowLabelEl.classList.remove(hiddenClass);
            }
        }
        if (highLabelEl) {
            if (minHighOverlap || lowMaxOverlap || highMaxOverlap) {
                highLabelEl.classList.add(hiddenClass);
            }
            else {
                highLabelEl.classList.remove(hiddenClass);
            }
        }
        if (minLabelEl && maxLabelEl) {
            if (minMaxOverlap) {
                maxLabelEl.classList.add(hiddenClass);
            }
            else {
                maxLabelEl.classList.remove(hiddenClass);
            }
        }
    }
    determineValueLabelPosition() {
        const { valueLabelEl, meterContainerEl, currentPercent } = this;
        const valuePosition = currentPercent > 100 ? 100 : currentPercent > 0 ? currentPercent : 0;
        const valueLabelWidth = valueLabelEl.getBoundingClientRect().width;
        const containerWidth = meterContainerEl.getBoundingClientRect().width;
        const labelWidthPercent = (100 * (valueLabelWidth - 0)) / (containerWidth - 0);
        if (valuePosition + labelWidthPercent >= 100) {
            valueLabelEl.style.insetInlineEnd = "0%";
            valueLabelEl.style.removeProperty("inset-inline-start");
        }
        else {
            valueLabelEl.style.insetInlineStart = `${valuePosition}% `;
            valueLabelEl.style.removeProperty("inset-inline-end");
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    renderMeterFill() {
        const { currentPercent, fillType } = this;
        const kindClass = this.getMeterKindCssClass();
        return (h("div", { class: { [CSS.fill]: true, [kindClass]: fillType !== "single" }, style: { width: `${currentPercent}%` } }));
    }
    renderRangeLine(position) {
        const style = { insetInlineStart: `${position}%` };
        return h("div", { class: CSS.stepLine, style: style });
    }
    renderValueLabel() {
        const { currentPercent, valueLabelType, unitLabel, value } = this;
        const label = this.formatLabel(valueLabelType === "percent" ? currentPercent / 100 : value || 0, valueLabelType);
        return (h("div", { class: { [CSS.label]: true, [CSS.labelValue]: true }, key: "low-label-line",
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.valueLabelEl = el) }, label, unitLabel && valueLabelType !== "percent" && (h("span", { class: CSS.unitLabel }, "\u00A0", unitLabel))));
    }
    renderMinLabel() {
        const { rangeLabelType, min, minPercent, unitLabel } = this;
        const style = { insetInlineStart: `${minPercent}%` };
        const labelMin = this.formatLabel(rangeLabelType === "percent" ? minPercent : min, rangeLabelType);
        return (h("div", { class: { [CSS.label]: true, [CSS.labelRange]: true }, key: "min-label-line", style: style,
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.minLabelEl = el) }, labelMin, unitLabel && rangeLabelType !== "percent" && (h("span", { class: CSS.unitLabel }, "\u00A0", unitLabel))));
    }
    renderLowLabel() {
        const { rangeLabelType, low, lowPercent, highPercent, labelFlipProximity } = this;
        const label = low
            ? this.formatLabel(rangeLabelType === "percent" ? lowPercent / 100 : low, rangeLabelType)
            : "";
        const styleDefault = { insetInlineStart: `${lowPercent}%` };
        const styleFlipped = { insetInlineEnd: `${100 - lowPercent}%` };
        const style = (highPercent - lowPercent) / 100 < labelFlipProximity ? styleFlipped : styleDefault;
        return (h("div", { class: { [CSS.label]: true, [CSS.labelRange]: true }, key: "low-label-line", style: style,
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.lowLabelEl = el) }, label));
    }
    renderHighLabel() {
        const { rangeLabelType, high, highPercent, labelFlipMax } = this;
        const label = high
            ? this.formatLabel(rangeLabelType === "percent" ? highPercent / 100 : high, rangeLabelType)
            : "";
        const styleDefault = { insetInlineStart: `${highPercent}%` };
        const styleFlipped = { insetInlineEnd: `${100 - highPercent}%` };
        const style = highPercent / 100 >= labelFlipMax ? styleFlipped : styleDefault;
        return (h("div", { class: { [CSS.label]: true, [CSS.labelRange]: true }, key: "high-label-line", style: style,
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.highLabelEl = el) }, label));
    }
    renderMaxLabel() {
        const { rangeLabelType, max, maxPercent } = this;
        const style = { insetInlineEnd: `${100 - maxPercent}%` };
        const labelMax = this.formatLabel(rangeLabelType === "percent" ? maxPercent / 100 : max, rangeLabelType);
        return (h("div", { class: { [CSS.label]: true, [CSS.labelRange]: true }, key: "max-label-line", style: style,
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.maxLabelEl = el) }, labelMax));
    }
    render() {
        const { appearance, currentPercent, highActive, highPercent, label, lowActive, lowPercent, max, maxPercent, min, minPercent, rangeLabels, rangeLabelType, unitLabel, value, valueLabel, valueLabelType, } = this;
        const textPercentLabelWithPercent = this.formatLabel(currentPercent / 100, "percent");
        const textUnitLabel = `${value} ${unitLabel}`;
        const valueText = valueLabelType === "percent"
            ? textPercentLabelWithPercent
            : unitLabel
                ? textUnitLabel
                : undefined;
        return (h(Host, null, h("div", { "aria-label": label, "aria-valuemax": rangeLabelType === "percent" ? maxPercent : max, "aria-valuemin": rangeLabelType === "percent" ? minPercent : min, "aria-valuenow": valueLabelType === "percent" ? currentPercent : value, "aria-valuetext": valueText, class: {
                [CSS.container]: true,
                [CSS.stepsVisible]: rangeLabels,
                [CSS.valueVisible]: valueLabel,
                [appearance]: appearance !== "outline-fill",
            }, role: "meter",
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.meterContainerEl = el) }, this.renderMeterFill(), valueLabel && this.renderValueLabel(), lowActive && this.renderRangeLine(lowPercent), highActive && this.renderRangeLine(highPercent), rangeLabels && this.renderMinLabel(), rangeLabels && lowActive && this.renderLowLabel(), rangeLabels && highActive && this.renderHighLabel(), rangeLabels && this.renderMaxLabel())));
    }
    static get is() { return "calcite-meter"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["meter.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["meter.css"]
        };
    }
    static get properties() {
        return {
            "appearance": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "Extract<\"outline\" | \"outline-fill\" | \"solid\", Appearance>",
                    "resolved": "\"outline\" | \"outline-fill\" | \"solid\"",
                    "references": {
                        "Extract": {
                            "location": "global",
                            "id": "global::Extract"
                        },
                        "Appearance": {
                            "location": "import",
                            "path": "../interfaces",
                            "id": "src/components/interfaces.ts::Appearance"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the appearance style of the component."
                },
                "attribute": "appearance",
                "reflect": true,
                "defaultValue": "\"outline-fill\""
            },
            "disabled": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, interaction is prevented and the component is displayed with lower opacity."
                },
                "attribute": "disabled",
                "reflect": true,
                "defaultValue": "false"
            },
            "fillType": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "\"single\" | \"range\"",
                    "resolved": "\"range\" | \"single\"",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the component's display, where `\"single\"` displays a single color and `\"range\"` displays a range of colors based on provided `low`, `high`, `min` or `max` values."
                },
                "attribute": "fill-type",
                "reflect": true,
                "defaultValue": "\"range\""
            },
            "form": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The `id` of the form that will be associated with the component.\n\nWhen not set, the component will be associated with its ancestor form element, if any."
                },
                "attribute": "form",
                "reflect": true
            },
            "groupSeparator": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, number values are displayed with a group separator corresponding to the language and country format."
                },
                "attribute": "group-separator",
                "reflect": true,
                "defaultValue": "false"
            },
            "high": {
                "type": "number",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies a high value.  When `fillType` is `\"range\"`, displays a different color when above the specified threshold."
                },
                "attribute": "high",
                "reflect": true
            },
            "label": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": true,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Accessible name for the component."
                },
                "attribute": "label",
                "reflect": false
            },
            "low": {
                "type": "number",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies a low value.  When `fillType` is `\"range\"`, displays a different color when above the specified threshold."
                },
                "attribute": "low",
                "reflect": true
            },
            "max": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the highest allowed value of the component."
                },
                "attribute": "max",
                "reflect": true,
                "defaultValue": "100"
            },
            "min": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the lowest allowed value of the component."
                },
                "attribute": "min",
                "reflect": true,
                "defaultValue": "0"
            },
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the name of the component.\n\nRequired to pass the component's `value` on form submission."
                },
                "attribute": "name",
                "reflect": true
            },
            "numberingSystem": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "NumberingSystem",
                    "resolved": "\"arab\" | \"arabext\" | \"latn\"",
                    "references": {
                        "NumberingSystem": {
                            "location": "import",
                            "path": "../../utils/locale",
                            "id": "src/utils/locale.ts::NumberingSystem"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the Unicode numeral system used by the component for localization."
                },
                "attribute": "numbering-system",
                "reflect": false
            },
            "rangeLabels": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, displays the values of `high`, `low`, `min`, and `max`."
                },
                "attribute": "range-labels",
                "reflect": true,
                "defaultValue": "false"
            },
            "rangeLabelType": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "MeterLabelType",
                    "resolved": "\"percent\" | \"units\"",
                    "references": {
                        "MeterLabelType": {
                            "location": "import",
                            "path": "./interfaces",
                            "id": "src/components/meter/interfaces.ts::MeterLabelType"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `rangeLabels` is `true`, specifies the format of displayed labels."
                },
                "attribute": "range-label-type",
                "reflect": true,
                "defaultValue": "\"percent\""
            },
            "scale": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "Scale",
                    "resolved": "\"l\" | \"m\" | \"s\"",
                    "references": {
                        "Scale": {
                            "location": "import",
                            "path": "../interfaces",
                            "id": "src/components/interfaces.ts::Scale"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the size of the component."
                },
                "attribute": "scale",
                "reflect": true,
                "defaultValue": "\"m\""
            },
            "unitLabel": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `rangeLabelType` is `\"units\"` and either `valueLabel` or `rangeLabels` are `true`, displays beside the `value` and/or  `min` values."
                },
                "attribute": "unit-label",
                "reflect": false,
                "defaultValue": "\"\""
            },
            "value": {
                "type": "number",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the current value of the component."
                },
                "attribute": "value",
                "reflect": false
            },
            "valueLabel": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, displays the current value."
                },
                "attribute": "value-label",
                "reflect": true,
                "defaultValue": "false"
            },
            "valueLabelType": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "MeterLabelType",
                    "resolved": "\"percent\" | \"units\"",
                    "references": {
                        "MeterLabelType": {
                            "location": "import",
                            "path": "./interfaces",
                            "id": "src/components/meter/interfaces.ts::MeterLabelType"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `valueLabel` is `true`, specifies the format of displayed label."
                },
                "attribute": "value-label-type",
                "reflect": true,
                "defaultValue": "\"percent\""
            }
        };
    }
    static get states() {
        return {
            "currentPercent": {},
            "effectiveLocale": {},
            "highActive": {},
            "highPercent": {},
            "lowActive": {},
            "lowPercent": {}
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "min",
                "methodName": "handleRangeChange"
            }, {
                "propName": "max",
                "methodName": "handleRangeChange"
            }, {
                "propName": "low",
                "methodName": "handleRangeChange"
            }, {
                "propName": "high",
                "methodName": "handleRangeChange"
            }, {
                "propName": "value",
                "methodName": "handleRangeChange"
            }, {
                "propName": "rangeLabels",
                "methodName": "handleLabelChange"
            }, {
                "propName": "rangeLabelType",
                "methodName": "handleLabelChange"
            }, {
                "propName": "unitLabel",
                "methodName": "handleLabelChange"
            }, {
                "propName": "valueLabel",
                "methodName": "handleLabelChange"
            }, {
                "propName": "valueLabelType",
                "methodName": "handleLabelChange"
            }];
    }
}
//# sourceMappingURL=meter.js.map
