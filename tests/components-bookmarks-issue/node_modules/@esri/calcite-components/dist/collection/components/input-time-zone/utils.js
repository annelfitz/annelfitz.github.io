/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.6.0
 */
import { getDateTimeFormat } from "../../utils/locale";
const hourToMinutes = 60;
const timeZoneNameBlockList = [
    "CET",
    "CST6CDT",
    "EET",
    "EST",
    "EST5EDT",
    "Factory",
    "HST",
    "MET",
    "MST",
    "MST7MDT",
    "PST8PDT",
    "UTC",
    "WET",
];
function timeZoneOffsetToDecimal(shortOffsetTimeZoneName) {
    const minusSign = "âˆ’";
    const hyphen = "-";
    return (shortOffsetTimeZoneName
        .replace(":15", ".25")
        .replace(":30", ".5")
        .replace(":45", ".75")
        // ensures decimal string representation is parseable
        .replace(minusSign, hyphen));
}
function toOffsetValue(timeZoneName, referenceDateInMs) {
    // we use "en-US" to allow us to reliably remove the standard time token
    const offset = getTimeZoneShortOffset(timeZoneName, "en-US", referenceDateInMs).replace("GMT", "");
    if (offset === "") {
        return 0;
    }
    return Number(timeZoneOffsetToDecimal(offset)) * hourToMinutes;
}
export function getUserTimeZoneOffset() {
    const localDate = new Date();
    return localDate.getTimezoneOffset() * -1;
}
export function getUserTimeZoneName() {
    const dateFormatter = new Intl.DateTimeFormat();
    return dateFormatter.resolvedOptions().timeZone;
}
/**
 * The lazy-loaded timezone-groups lib to be used across instances.
 */
let timeZoneGroups;
export async function createTimeZoneItems(locale, messages, mode, referenceDate) {
    const referenceDateInMs = referenceDate.getTime();
    const timeZoneNames = Intl.supportedValuesOf("timeZone");
    if (mode === "offset") {
        if (!timeZoneGroups) {
            timeZoneGroups = Promise.all([
                import("timezone-groups/dist/index.js"),
                import("timezone-groups/dist/strategy/native/index.js"),
            ]);
        }
        return timeZoneGroups.then(async ([{ groupTimeZones }, { DateEngine }]) => {
            const timeZoneGroups = await groupTimeZones({
                dateEngine: new DateEngine(),
                groupDateRange: 1,
                startDate: new Date(referenceDateInMs).toISOString(),
            });
            const listFormatter = new Intl.ListFormat(locale, { style: "long", type: "conjunction" });
            // we remove blocked entries from tzs and adjust label indices accordingly
            timeZoneGroups.forEach((group) => {
                const indexOffsets = [];
                let removedSoFar = 0;
                group.tzs.forEach((tz, index) => {
                    if (timeZoneNameBlockList.includes(tz)) {
                        removedSoFar++;
                    }
                    indexOffsets[index] = removedSoFar;
                });
                group.tzs = group.tzs.filter((tz) => !timeZoneNameBlockList.includes(tz));
                group.labelTzIndices = group.labelTzIndices
                    .map((index) => index - indexOffsets[index])
                    .filter((index) => index >= 0 && index < group.tzs.length);
            });
            return timeZoneGroups
                .map(({ labelTzIndices, tzs }) => {
                const groupRepTz = tzs[0];
                const decimalOffset = timeZoneOffsetToDecimal(getTimeZoneShortOffset(groupRepTz, locale, referenceDateInMs));
                const value = toOffsetValue(groupRepTz, referenceDateInMs);
                const tzLabels = labelTzIndices.map((index) => {
                    const timeZone = tzs[index];
                    const timeZoneLabel = messages[timeZone];
                    return (timeZoneLabel ||
                        // get city token
                        timeZone.split("/").pop());
                });
                const label = createTimeZoneOffsetLabel(messages, decimalOffset, listFormatter.format(tzLabels));
                return {
                    label,
                    value,
                    filterValue: tzs.map((tz) => toUserFriendlyName(tz)),
                };
            })
                .filter((group) => !!group)
                .sort((groupA, groupB) => groupA.value - groupB.value);
        });
    }
    return timeZoneNames
        .map((timeZone) => {
        const label = toUserFriendlyName(timeZone);
        const value = timeZone;
        return {
            label,
            value,
            filterValue: timeZone,
        };
    })
        .filter((group) => !!group)
        .sort();
}
/**
 * Exported for testing purposes only
 *
 * @internal
 */
export function toUserFriendlyName(timeZoneName) {
    return timeZoneName.replace(/_/g, " ");
}
function createTimeZoneOffsetLabel(messages, offsetLabel, groupLabel) {
    return messages.timeZoneLabel.replace("{offset}", offsetLabel).replace("{cities}", groupLabel);
}
function getTimeZoneShortOffset(timeZone, locale, referenceDateInMs = Date.now()) {
    const dateTimeFormat = getDateTimeFormat(locale, { timeZone, timeZoneName: "shortOffset" });
    const parts = dateTimeFormat.formatToParts(referenceDateInMs);
    return parts.find(({ type }) => type === "timeZoneName").value;
}
//# sourceMappingURL=utils.js.map
