/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.6.0
 */
import { h, Host, } from "@stencil/core";
import { focusElement, nodeListToArray } from "../../utils/dom";
import { getTraversableItems, isTreeItem } from "./utils";
/**
 * @slot - A slot for `calcite-tree-item` elements.
 */
export class Tree {
    constructor() {
        this.keyDownHandler = (event) => {
            if (this.child) {
                return;
            }
            const root = this.el;
            const target = event.target;
            const supportedKeys = ["ArrowRight", "ArrowDown", "ArrowLeft", "ArrowUp", "Home", "End", "Tab"];
            if (!(isTreeItem(target) && this.el.contains(target)) || !supportedKeys.includes(event.key)) {
                return;
            }
            const traversableItems = getTraversableItems(root);
            if (event.key === "Tab") {
                // root tabindex will be restored when blurred/focused
                traversableItems.forEach((item) => (item.tabIndex = -1));
                return;
            }
            if (event.key === "ArrowDown") {
                const currentItemIndex = traversableItems.indexOf(target);
                const nextItem = traversableItems[currentItemIndex + 1];
                nextItem?.focus();
                event.preventDefault();
                return;
            }
            if (event.key === "ArrowUp") {
                const currentItemIndex = traversableItems.indexOf(target);
                const previousItem = traversableItems[currentItemIndex - 1];
                previousItem?.focus();
                event.preventDefault();
                return;
            }
            if (event.key === "ArrowLeft") {
                if (target.hasChildren && target.expanded) {
                    target.expanded = false;
                    event.preventDefault();
                    return;
                }
                const rootToItemPath = traversableItems.slice(0, traversableItems.indexOf(target)).reverse();
                const parentItem = rootToItemPath.find((item) => item.depth === target.depth - 1);
                parentItem?.focus();
                event.preventDefault();
                return;
            }
            if (event.key === "ArrowRight") {
                if (!target.disabled && target.hasChildren) {
                    if (!target.expanded) {
                        target.expanded = true;
                        event.preventDefault();
                    }
                    else {
                        const currentItemIndex = traversableItems.indexOf(target);
                        const nextItem = traversableItems[currentItemIndex + 1];
                        nextItem?.focus();
                        event.preventDefault();
                    }
                }
                return;
            }
            if (event.key === "Home") {
                const firstNode = traversableItems.shift();
                if (firstNode) {
                    firstNode.focus();
                    event.preventDefault();
                }
                return;
            }
            if (event.key === "End") {
                const lastNode = traversableItems.pop();
                if (lastNode) {
                    lastNode.focus();
                    event.preventDefault();
                }
                return;
            }
        };
        this.lines = false;
        this.child = undefined;
        this.scale = "m";
        this.selectionMode = "single";
        this.selectedItems = [];
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentWillRender() {
        const parent = this.el.parentElement?.closest("calcite-tree");
        this.lines = parent ? parent.lines : this.lines;
        this.scale = parent ? parent.scale : this.scale;
        this.selectionMode = parent ? parent.selectionMode : this.selectionMode;
        this.child = !!parent;
    }
    render() {
        return (h(Host, { "aria-multiselectable": this.child
                ? undefined
                : (this.selectionMode === "multiple" || this.selectionMode === "multichildren").toString(), onKeyDown: this.keyDownHandler, role: !this.child ? "tree" : undefined, tabIndex: this.getRootTabIndex() }, h("slot", null)));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    onFocus() {
        if (!this.child) {
            const focusTarget = this.el.querySelector("calcite-tree-item[selected]:not([disabled])") || this.el.querySelector("calcite-tree-item:not([disabled])");
            focusElement(focusTarget);
        }
    }
    onFocusIn(event) {
        const focusedFromRootOrOutsideTree = event.relatedTarget === this.el || !this.el.contains(event.relatedTarget);
        if (focusedFromRootOrOutsideTree) {
            // gives user the ability to tab into external elements (modifying tabindex property will not work in firefox)
            this.el.removeAttribute("tabindex");
        }
    }
    onFocusOut(event) {
        const willFocusOutsideTree = !this.el.contains(event.relatedTarget);
        if (willFocusOutsideTree) {
            this.el.tabIndex = this.getRootTabIndex();
        }
    }
    onInternalTreeItemSelect(event) {
        if (this.child) {
            return;
        }
        const target = event.target;
        const childItems = nodeListToArray(target.querySelectorAll("calcite-tree-item"));
        event.preventDefault();
        event.stopPropagation();
        if (this.selectionMode === "ancestors") {
            this.updateAncestorTree(event);
            return;
        }
        const isNoneSelectionMode = this.selectionMode === "none";
        const shouldSelect = this.selectionMode !== null &&
            (!target.hasChildren ||
                (target.hasChildren &&
                    (this.selectionMode === "children" || this.selectionMode === "multichildren")));
        const shouldDeselectAllChildren = this.selectionMode === "multichildren" && target.hasChildren;
        const shouldModifyToCurrentSelection = !isNoneSelectionMode &&
            event.detail.modifyCurrentSelection &&
            (this.selectionMode === "multiple" || this.selectionMode === "multichildren");
        const shouldClearCurrentSelection = !shouldModifyToCurrentSelection &&
            (((this.selectionMode === "single" || this.selectionMode === "multiple") &&
                childItems.length <= 0) ||
                this.selectionMode === "children" ||
                this.selectionMode === "multichildren");
        const shouldUpdateExpand = ["multiple", "none", "single", "single-persist"].includes(this.selectionMode) &&
            target.hasChildren;
        const targetItems = [];
        if (shouldSelect) {
            targetItems.push(target);
        }
        if (shouldClearCurrentSelection) {
            const selectedItems = nodeListToArray(this.el.querySelectorAll("calcite-tree-item[selected]"));
            selectedItems.forEach((treeItem) => {
                if (!targetItems.includes(treeItem)) {
                    treeItem.selected = false;
                }
            });
        }
        if (shouldUpdateExpand &&
            ["multiple", "none", "single", "single-persist"].includes(this.selectionMode)) {
            target.expanded = !target.expanded;
        }
        if (shouldDeselectAllChildren) {
            childItems.forEach((item) => {
                item.selected = false;
                if (item.hasChildren) {
                    item.expanded = false;
                }
            });
        }
        if (shouldModifyToCurrentSelection) {
            window.getSelection().removeAllRanges();
        }
        if (shouldModifyToCurrentSelection && target.selected) {
            targetItems.forEach((treeItem) => {
                if (!treeItem.disabled) {
                    treeItem.selected = false;
                }
            });
        }
        else if (!isNoneSelectionMode) {
            targetItems.forEach((treeItem) => {
                if (!treeItem.disabled) {
                    treeItem.selected = true;
                }
            });
        }
        this.selectedItems = isNoneSelectionMode
            ? []
            : nodeListToArray(this.el.querySelectorAll("calcite-tree-item")).filter((i) => i.selected);
        this.calciteTreeSelect.emit();
        event.stopPropagation();
    }
    updateAncestorTree(event) {
        const item = event.target;
        const updateItem = event.detail.updateItem;
        if (item.disabled || (item.indeterminate && !updateItem)) {
            return;
        }
        const ancestors = [];
        let parent = item.parentElement.closest("calcite-tree-item");
        while (parent) {
            ancestors.push(parent);
            parent = parent.parentElement.closest("calcite-tree-item");
        }
        const childItems = Array.from(item.querySelectorAll("calcite-tree-item:not([disabled])"));
        const childItemsWithNoChildren = childItems.filter((child) => !child.hasChildren);
        const childItemsWithChildren = childItems.filter((child) => child.hasChildren);
        let futureSelected;
        if (updateItem) {
            futureSelected = item.hasChildren ? !(item.selected || item.indeterminate) : !item.selected;
        }
        else {
            futureSelected = item.selected;
        }
        childItemsWithNoChildren.forEach((el) => {
            el.selected = futureSelected;
            el.indeterminate = false;
        });
        function updateItemState(childItems, item) {
            const selected = childItems.filter((child) => child.selected);
            const unselected = childItems.filter((child) => !child.selected);
            item.selected = selected.length === childItems.length;
            item.indeterminate = selected.length > 0 && unselected.length > 0;
        }
        childItemsWithChildren.reverse().forEach((el) => {
            const directChildItems = Array.from(el.querySelectorAll(":scope > calcite-tree > calcite-tree-item"));
            updateItemState(directChildItems, el);
        });
        if (updateItem) {
            if (item.hasChildren) {
                updateItemState(childItems, item);
            }
            else {
                item.selected = futureSelected;
                item.indeterminate = false;
            }
        }
        ancestors.forEach((ancestor) => {
            const descendants = nodeListToArray(ancestor.querySelectorAll("calcite-tree-item"));
            const activeDescendants = descendants.filter((el) => el.selected);
            if (activeDescendants.length === 0) {
                ancestor.selected = false;
                ancestor.indeterminate = false;
                return;
            }
            const indeterminate = activeDescendants.length < descendants.length;
            ancestor.indeterminate = indeterminate;
            ancestor.selected = !indeterminate;
        });
        this.selectedItems = nodeListToArray(this.el.querySelectorAll("calcite-tree-item")).filter((i) => i.selected);
        if (updateItem) {
            this.calciteTreeSelect.emit();
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    getRootTabIndex() {
        return !this.child ? 0 : -1;
    }
    static get is() { return "calcite-tree"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["tree.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["tree.css"]
        };
    }
    static get properties() {
        return {
            "lines": {
                "type": "boolean",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "When `true`, displays indentation guide lines."
                },
                "attribute": "lines",
                "reflect": true,
                "defaultValue": "false"
            },
            "child": {
                "type": "boolean",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "internal",
                            "text": undefined
                        }],
                    "text": ""
                },
                "attribute": "child",
                "reflect": true
            },
            "scale": {
                "type": "string",
                "mutable": true,
                "complexType": {
                    "original": "Scale",
                    "resolved": "\"l\" | \"m\" | \"s\"",
                    "references": {
                        "Scale": {
                            "location": "import",
                            "path": "../interfaces",
                            "id": "src/components/interfaces.ts::Scale"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Specifies the size of the component."
                },
                "attribute": "scale",
                "reflect": true,
                "defaultValue": "\"m\""
            },
            "selectionMode": {
                "type": "string",
                "mutable": true,
                "complexType": {
                    "original": "SelectionMode",
                    "resolved": "\"ancestors\" | \"children\" | \"multichildren\" | \"multiple\" | \"none\" | \"single\" | \"single-persist\"",
                    "references": {
                        "SelectionMode": {
                            "location": "import",
                            "path": "../interfaces",
                            "id": "src/components/interfaces.ts::SelectionMode"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "default",
                            "text": "\"single\""
                        }],
                    "text": "Specifies the selection mode of the component, where:\n\n`\"ancestors\"` displays with a checkbox and allows any number of selections from corresponding parent and child selections,\n\n`\"children\"` allows any number of selections from one parent from corresponding parent and child selections,\n\n`\"multichildren\"` allows any number of selections from corresponding parent and child selections,\n\n`\"multiple\"` allows any number of selections,\n\n`\"none\"` allows no selections,\n\n`\"single\"` allows one selection, and\n\n`\"single-persist\"` allows and requires one selection."
                },
                "attribute": "selection-mode",
                "reflect": true,
                "defaultValue": "\"single\""
            },
            "selectedItems": {
                "type": "unknown",
                "mutable": true,
                "complexType": {
                    "original": "HTMLCalciteTreeItemElement[]",
                    "resolved": "HTMLCalciteTreeItemElement[]",
                    "references": {
                        "HTMLCalciteTreeItemElement": {
                            "location": "global",
                            "id": "global::HTMLCalciteTreeItemElement"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "readonly",
                            "text": undefined
                        }],
                    "text": "Specifies the component's selected items."
                },
                "defaultValue": "[]"
            }
        };
    }
    static get events() {
        return [{
                "method": "calciteTreeSelect",
                "name": "calciteTreeSelect",
                "bubbles": true,
                "cancelable": false,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Fires when the user selects/deselects `calcite-tree-items`."
                },
                "complexType": {
                    "original": "void",
                    "resolved": "void",
                    "references": {}
                }
            }];
    }
    static get elementRef() { return "el"; }
    static get listeners() {
        return [{
                "name": "focus",
                "method": "onFocus",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "focusin",
                "method": "onFocusIn",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "focusout",
                "method": "onFocusOut",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "calciteInternalTreeItemSelect",
                "method": "onInternalTreeItemSelect",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
}
//# sourceMappingURL=tree.js.map
