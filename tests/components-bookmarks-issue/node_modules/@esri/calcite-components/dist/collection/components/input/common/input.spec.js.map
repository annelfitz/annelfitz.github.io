{"version":3,"file":"input.spec.js","sourceRoot":"","sources":["../../../../../src/components/input/common/input.spec.ts"],"names":[],"mappings":"AAAA,yMAAyM;AACzM,OAAO,EAAE,iBAAiB,EAAE,eAAe,EAAE,YAAY,EAAE,mBAAmB,EAAE,MAAM,SAAS,CAAC;AAEhG,QAAQ,CAAC,oBAAoB,EAAE,GAAG,EAAE;IAClC,EAAE,CAAC,qBAAqB,EAAE,KAAK,IAAI,EAAE;QACnC,MAAM,sBAAsB,GAAG,EAAE,SAAS,EAAE,CAAC,EAAE,SAAS,EAAE,EAAE,EAAE,CAAC;QAC/D,MAAM,gBAAgB,GAAG,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC;QAC7C,MAAM,oBAAoB,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;QAE1D,MAAM,QAAQ,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,iBAAiB,EAAE,GAAG,YAAY,EAAE,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;QAClG,MAAM,0BAA0B,GAAG,EAAE,GAAG,sBAAsB,EAAE,GAAG,oBAAoB,EAAE,GAAG,gBAAgB,EAAE,CAAC;QAE/G,MAAM,eAAe,GAAG,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAExD,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YACxB,mBAAmB,CAAC,IAAI,EAAE,0BAA0B,EAAE,eAAe,CAAC,CAAC;YAEvE,MAAM,YAAY,GAAG,IAAI,KAAK,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;YAEzD,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAEhD,IAAI,eAAe,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBAClC,MAAM,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,oBAAoB,CAAC,GAAG,EAAE,CAAC,CAAC;gBAChE,MAAM,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,oBAAoB,CAAC,GAAG,EAAE,CAAC,CAAC;gBAChE,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,oBAAoB,CAAC,IAAI,EAAE,CAAC,CAAC;aACnE;YAED,IAAI,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBACpC,MAAM,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,SAAS,CAAC,CAAC;gBACzE,MAAM,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,SAAS,CAAC,CAAC;aAC1E;YAED,IAAI,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBAC/B,MAAM,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;aAChE;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["/* eslint-disable jest/no-conditional-expect -- Using conditional logic in a confined test helper to handle specific scenarios, reducing duplication, balancing test readability and maintainability. **/\nimport { minMaxLengthTypes, minMaxStepTypes, patternTypes, syncHiddenFormInput } from \"./input\";\n\ndescribe(\"common input utils\", () => {\n  it(\"syncHiddenFormInput\", async () => {\n    const minMaxLengthTestValues = { minLength: 0, maxLength: 10 };\n    const patternTestValue = { pattern: \"test\" };\n    const minMaxStepTestValues = { min: 0, max: 10, step: 1 };\n\n    const allTypes = Array.from(new Set([...minMaxLengthTypes, ...patternTypes, ...minMaxStepTypes]));\n    const allValueFakeInputComponent = { ...minMaxLengthTestValues, ...minMaxStepTestValues, ...patternTestValue };\n\n    const hiddenFormInput = document.createElement(\"input\");\n\n    allTypes.forEach((type) => {\n      syncHiddenFormInput(type, allValueFakeInputComponent, hiddenFormInput);\n\n      const expectedType = type === \"textarea\" ? \"text\" : type;\n\n      expect(hiddenFormInput.type).toBe(expectedType);\n\n      if (minMaxStepTypes.includes(type)) {\n        expect(hiddenFormInput.min).toBe(`${minMaxStepTestValues.min}`);\n        expect(hiddenFormInput.max).toBe(`${minMaxStepTestValues.max}`);\n        expect(hiddenFormInput.step).toBe(`${minMaxStepTestValues.step}`);\n      }\n\n      if (minMaxLengthTypes.includes(type)) {\n        expect(hiddenFormInput.minLength).toBe(minMaxLengthTestValues.minLength);\n        expect(hiddenFormInput.maxLength).toBe(minMaxLengthTestValues.maxLength);\n      }\n\n      if (patternTypes.includes(type)) {\n        expect(hiddenFormInput.pattern).toBe(patternTestValue.pattern);\n      }\n    });\n  });\n});\n"]}