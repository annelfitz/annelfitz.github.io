/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.6.0
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*!
 Stencil Mock Doc v4.9.0 | MIT Licensed | https://stenciljs.com
 */
const CONTENT_REF_ID = 'r';
const ORG_LOCATION_ID = 'o';
const SLOT_NODE_ID = 's';
const TEXT_NODE_ID = 't';
const XLINK_NS = 'http://www.w3.org/1999/xlink';

const attrHandler = {
    get(obj, prop) {
        if (prop in obj) {
            return obj[prop];
        }
        if (typeof prop !== 'symbol' && !isNaN(prop)) {
            return obj.__items[prop];
        }
        return undefined;
    },
};
const createAttributeProxy = (caseInsensitive) => new Proxy(new MockAttributeMap(caseInsensitive), attrHandler);
class MockAttributeMap {
    constructor(caseInsensitive = false) {
        this.caseInsensitive = caseInsensitive;
        this.__items = [];
    }
    get length() {
        return this.__items.length;
    }
    item(index) {
        return this.__items[index] || null;
    }
    setNamedItem(attr) {
        attr.namespaceURI = null;
        this.setNamedItemNS(attr);
    }
    setNamedItemNS(attr) {
        if (attr != null && attr.value != null) {
            attr.value = String(attr.value);
        }
        const existingAttr = this.__items.find((a) => a.name === attr.name && a.namespaceURI === attr.namespaceURI);
        if (existingAttr != null) {
            existingAttr.value = attr.value;
        }
        else {
            this.__items.push(attr);
        }
    }
    getNamedItem(attrName) {
        if (this.caseInsensitive) {
            attrName = attrName.toLowerCase();
        }
        return this.getNamedItemNS(null, attrName);
    }
    getNamedItemNS(namespaceURI, attrName) {
        namespaceURI = getNamespaceURI(namespaceURI);
        return (this.__items.find((attr) => attr.name === attrName && getNamespaceURI(attr.namespaceURI) === namespaceURI) || null);
    }
    removeNamedItem(attr) {
        this.removeNamedItemNS(attr);
    }
    removeNamedItemNS(attr) {
        for (let i = 0, ii = this.__items.length; i < ii; i++) {
            if (this.__items[i].name === attr.name && this.__items[i].namespaceURI === attr.namespaceURI) {
                this.__items.splice(i, 1);
                break;
            }
        }
    }
    [Symbol.iterator]() {
        let i = 0;
        return {
            next: () => ({
                done: i === this.length,
                value: this.item(i++),
            }),
        };
    }
    get [Symbol.toStringTag]() {
        return 'MockAttributeMap';
    }
}
function getNamespaceURI(namespaceURI) {
    return namespaceURI === XLINK_NS ? null : namespaceURI;
}
function cloneAttributes(srcAttrs, sortByName = false) {
    const dstAttrs = new MockAttributeMap(srcAttrs.caseInsensitive);
    if (srcAttrs != null) {
        const attrLen = srcAttrs.length;
        if (sortByName && attrLen > 1) {
            const sortedAttrs = [];
            for (let i = 0; i < attrLen; i++) {
                const srcAttr = srcAttrs.item(i);
                const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
                sortedAttrs.push(dstAttr);
            }
            sortedAttrs.sort(sortAttributes).forEach((attr) => {
                dstAttrs.setNamedItemNS(attr);
            });
        }
        else {
            for (let i = 0; i < attrLen; i++) {
                const srcAttr = srcAttrs.item(i);
                const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
                dstAttrs.setNamedItemNS(dstAttr);
            }
        }
    }
    return dstAttrs;
}
function sortAttributes(a, b) {
    if (a.name < b.name)
        return -1;
    if (a.name > b.name)
        return 1;
    return 0;
}
class MockAttr {
    constructor(attrName, attrValue, namespaceURI = null) {
        this._name = attrName;
        this._value = String(attrValue);
        this._namespaceURI = namespaceURI;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = String(value);
    }
    get nodeName() {
        return this._name;
    }
    set nodeName(value) {
        this._name = value;
    }
    get nodeValue() {
        return this._value;
    }
    set nodeValue(value) {
        this._value = String(value);
    }
    get namespaceURI() {
        return this._namespaceURI;
    }
    set namespaceURI(namespaceURI) {
        this._namespaceURI = namespaceURI;
    }
}

class MockClassList {
    constructor(elm) {
        this.elm = elm;
    }
    add(...classNames) {
        const clsNames = getItems(this.elm);
        let updated = false;
        classNames.forEach((className) => {
            className = String(className);
            validateClass(className);
            if (clsNames.includes(className) === false) {
                clsNames.push(className);
                updated = true;
            }
        });
        if (updated) {
            this.elm.setAttributeNS(null, 'class', clsNames.join(' '));
        }
    }
    remove(...classNames) {
        const clsNames = getItems(this.elm);
        let updated = false;
        classNames.forEach((className) => {
            className = String(className);
            validateClass(className);
            const index = clsNames.indexOf(className);
            if (index > -1) {
                clsNames.splice(index, 1);
                updated = true;
            }
        });
        if (updated) {
            this.elm.setAttributeNS(null, 'class', clsNames.filter((c) => c.length > 0).join(' '));
        }
    }
    contains(className) {
        className = String(className);
        return getItems(this.elm).includes(className);
    }
    toggle(className) {
        className = String(className);
        if (this.contains(className) === true) {
            this.remove(className);
        }
        else {
            this.add(className);
        }
    }
    get length() {
        return getItems(this.elm).length;
    }
    item(index) {
        return getItems(this.elm)[index];
    }
    toString() {
        return getItems(this.elm).join(' ');
    }
}
function validateClass(className) {
    if (className === '') {
        throw new Error('The token provided must not be empty.');
    }
    if (/\s/.test(className)) {
        throw new Error(`The token provided ('${className}') contains HTML space characters, which are not valid in tokens.`);
    }
}
function getItems(elm) {
    const className = elm.getAttribute('class');
    if (typeof className === 'string' && className.length > 0) {
        return className
            .trim()
            .split(' ')
            .filter((c) => c.length > 0);
    }
    return [];
}

class MockCSSStyleDeclaration {
    constructor() {
        this._styles = new Map();
    }
    setProperty(prop, value) {
        prop = jsCaseToCssCase(prop);
        if (value == null || value === '') {
            this._styles.delete(prop);
        }
        else {
            this._styles.set(prop, String(value));
        }
    }
    getPropertyValue(prop) {
        prop = jsCaseToCssCase(prop);
        return String(this._styles.get(prop) || '');
    }
    removeProperty(prop) {
        prop = jsCaseToCssCase(prop);
        this._styles.delete(prop);
    }
    get length() {
        return this._styles.size;
    }
    get cssText() {
        const cssText = [];
        this._styles.forEach((value, prop) => {
            cssText.push(`${prop}: ${value};`);
        });
        return cssText.join(' ').trim();
    }
    set cssText(cssText) {
        if (cssText == null || cssText === '') {
            this._styles.clear();
            return;
        }
        cssText.split(';').forEach((rule) => {
            rule = rule.trim();
            if (rule.length > 0) {
                const splt = rule.split(':');
                if (splt.length > 1) {
                    const prop = splt[0].trim();
                    const value = splt.slice(1).join(':').trim();
                    if (prop !== '' && value !== '') {
                        this._styles.set(jsCaseToCssCase(prop), value);
                    }
                }
            }
        });
    }
}
function createCSSStyleDeclaration() {
    return new Proxy(new MockCSSStyleDeclaration(), cssProxyHandler);
}
const cssProxyHandler = {
    get(cssStyle, prop) {
        if (prop in cssStyle) {
            return cssStyle[prop];
        }
        prop = cssCaseToJsCase(prop);
        return cssStyle.getPropertyValue(prop);
    },
    set(cssStyle, prop, value) {
        if (prop in cssStyle) {
            cssStyle[prop] = value;
        }
        else {
            cssStyle.setProperty(prop, value);
        }
        return true;
    },
};
function cssCaseToJsCase(str) {
    // font-size to fontSize
    if (str.length > 1 && str.includes('-') === true) {
        str = str
            .toLowerCase()
            .split('-')
            .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
            .join('');
        str = str.slice(0, 1).toLowerCase() + str.slice(1);
    }
    return str;
}
function jsCaseToCssCase(str) {
    // fontSize to font-size
    if (str.length > 1 && str.includes('-') === false && /[A-Z]/.test(str) === true) {
        str = str
            .replace(/([A-Z])/g, (g) => ' ' + g[0])
            .trim()
            .replace(/ /g, '-')
            .toLowerCase();
    }
    return str;
}

class MockCustomElementRegistry {
    constructor(win) {
        this.win = win;
    }
    define(tagName, cstr, options) {
        if (tagName.toLowerCase() !== tagName) {
            throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': "${tagName}" is not a valid custom element name`);
        }
        if (this.__registry == null) {
            this.__registry = new Map();
        }
        this.__registry.set(tagName, { cstr, options });
        if (this.__whenDefined != null) {
            const whenDefinedResolveFns = this.__whenDefined.get(tagName);
            if (whenDefinedResolveFns != null) {
                whenDefinedResolveFns.forEach((whenDefinedResolveFn) => {
                    whenDefinedResolveFn();
                });
                whenDefinedResolveFns.length = 0;
                this.__whenDefined.delete(tagName);
            }
        }
        const doc = this.win.document;
        if (doc != null) {
            const hosts = doc.querySelectorAll(tagName);
            hosts.forEach((host) => {
                if (upgradedElements.has(host) === false) {
                    tempDisableCallbacks.add(doc);
                    const upgradedCmp = createCustomElement(this, doc, tagName);
                    for (let i = 0; i < host.childNodes.length; i++) {
                        const childNode = host.childNodes[i];
                        childNode.remove();
                        upgradedCmp.appendChild(childNode);
                    }
                    tempDisableCallbacks.delete(doc);
                    if (proxyElements.has(host)) {
                        proxyElements.set(host, upgradedCmp);
                    }
                }
                fireConnectedCallback(host);
            });
        }
    }
    get(tagName) {
        if (this.__registry != null) {
            const def = this.__registry.get(tagName.toLowerCase());
            if (def != null) {
                return def.cstr;
            }
        }
        return undefined;
    }
    upgrade(_rootNode) {
        //
    }
    clear() {
        if (this.__registry != null) {
            this.__registry.clear();
        }
        if (this.__whenDefined != null) {
            this.__whenDefined.clear();
        }
    }
    whenDefined(tagName) {
        tagName = tagName.toLowerCase();
        if (this.__registry != null && this.__registry.has(tagName) === true) {
            return Promise.resolve(this.__registry.get(tagName).cstr);
        }
        return new Promise((resolve) => {
            if (this.__whenDefined == null) {
                this.__whenDefined = new Map();
            }
            let whenDefinedResolveFns = this.__whenDefined.get(tagName);
            if (whenDefinedResolveFns == null) {
                whenDefinedResolveFns = [];
                this.__whenDefined.set(tagName, whenDefinedResolveFns);
            }
            whenDefinedResolveFns.push(resolve);
        });
    }
}
function createCustomElement(customElements, ownerDocument, tagName) {
    const Cstr = customElements.get(tagName);
    if (Cstr != null) {
        const cmp = new Cstr(ownerDocument);
        cmp.nodeName = tagName.toUpperCase();
        upgradedElements.add(cmp);
        return cmp;
    }
    const host = new Proxy({}, {
        get(obj, prop) {
            const elm = proxyElements.get(host);
            if (elm != null) {
                return elm[prop];
            }
            return obj[prop];
        },
        set(obj, prop, val) {
            const elm = proxyElements.get(host);
            if (elm != null) {
                elm[prop] = val;
            }
            else {
                obj[prop] = val;
            }
            return true;
        },
        has(obj, prop) {
            const elm = proxyElements.get(host);
            if (prop in elm) {
                return true;
            }
            if (prop in obj) {
                return true;
            }
            return false;
        },
    });
    const elm = new MockHTMLElement(ownerDocument, tagName);
    proxyElements.set(host, elm);
    return host;
}
const proxyElements = new WeakMap();
const upgradedElements = new WeakSet();
function connectNode(ownerDocument, node) {
    node.ownerDocument = ownerDocument;
    if (node.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
        if (ownerDocument != null && node.nodeName.includes('-')) {
            const win = ownerDocument.defaultView;
            if (win != null && typeof node.connectedCallback === 'function' && node.isConnected) {
                fireConnectedCallback(node);
            }
            const shadowRoot = node.shadowRoot;
            if (shadowRoot != null) {
                shadowRoot.childNodes.forEach((childNode) => {
                    connectNode(ownerDocument, childNode);
                });
            }
        }
        node.childNodes.forEach((childNode) => {
            connectNode(ownerDocument, childNode);
        });
    }
    else {
        node.childNodes.forEach((childNode) => {
            childNode.ownerDocument = ownerDocument;
        });
    }
}
function fireConnectedCallback(node) {
    if (typeof node.connectedCallback === 'function') {
        if (tempDisableCallbacks.has(node.ownerDocument) === false) {
            try {
                node.connectedCallback();
            }
            catch (e) {
                console.error(e);
            }
        }
    }
}
function disconnectNode(node) {
    if (node.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
        if (node.nodeName.includes('-') === true && typeof node.disconnectedCallback === 'function') {
            if (tempDisableCallbacks.has(node.ownerDocument) === false) {
                try {
                    node.disconnectedCallback();
                }
                catch (e) {
                    console.error(e);
                }
            }
        }
        node.childNodes.forEach(disconnectNode);
    }
}
function attributeChanged(node, attrName, oldValue, newValue) {
    attrName = attrName.toLowerCase();
    const observedAttributes = node.constructor.observedAttributes;
    if (Array.isArray(observedAttributes) === true &&
        observedAttributes.some((obs) => obs.toLowerCase() === attrName) === true) {
        try {
            node.attributeChangedCallback(attrName, oldValue, newValue);
        }
        catch (e) {
            console.error(e);
        }
    }
}
function checkAttributeChanged(node) {
    return node.nodeName.includes('-') === true && typeof node.attributeChangedCallback === 'function';
}
const tempDisableCallbacks = new Set();

function dataset(elm) {
    const ds = {};
    const attributes = elm.attributes;
    const attrLen = attributes.length;
    for (let i = 0; i < attrLen; i++) {
        const attr = attributes.item(i);
        const nodeName = attr.nodeName;
        if (nodeName.startsWith('data-')) {
            ds[dashToPascalCase(nodeName)] = attr.nodeValue;
        }
    }
    return new Proxy(ds, {
        get(_obj, camelCaseProp) {
            return ds[camelCaseProp];
        },
        set(_obj, camelCaseProp, value) {
            const dataAttr = toDataAttribute(camelCaseProp);
            elm.setAttribute(dataAttr, value);
            return true;
        },
    });
}
function toDataAttribute(str) {
    return ('data-' +
        String(str)
            .replace(/([A-Z0-9])/g, (g) => ' ' + g[0])
            .trim()
            .replace(/ /g, '-')
            .toLowerCase());
}
function dashToPascalCase(str) {
    str = String(str).slice(5);
    return str
        .split('-')
        .map((segment, index) => {
        if (index === 0) {
            return segment.charAt(0).toLowerCase() + segment.slice(1);
        }
        return segment.charAt(0).toUpperCase() + segment.slice(1);
    })
        .join('');
}

class MockEvent {
    constructor(type, eventInitDict) {
        this.bubbles = false;
        this.cancelBubble = false;
        this.cancelable = false;
        this.composed = false;
        this.currentTarget = null;
        this.defaultPrevented = false;
        this.srcElement = null;
        this.target = null;
        if (typeof type !== 'string') {
            throw new Error(`Event type required`);
        }
        this.type = type;
        this.timeStamp = Date.now();
        if (eventInitDict != null) {
            Object.assign(this, eventInitDict);
        }
    }
    preventDefault() {
        this.defaultPrevented = true;
    }
    stopPropagation() {
        this.cancelBubble = true;
    }
    stopImmediatePropagation() {
        this.cancelBubble = true;
    }
    composedPath() {
        const composedPath = [];
        let currentElement = this.target;
        while (currentElement) {
            composedPath.push(currentElement);
            if (!currentElement.parentElement && currentElement.nodeName === "#document" /* NODE_NAMES.DOCUMENT_NODE */) {
                // the current element doesn't have a parent, but we've detected it's our root document node. push the window
                // object associated with the document onto the path
                composedPath.push(currentElement.defaultView);
                break;
            }
            currentElement = currentElement.parentElement;
        }
        return composedPath;
    }
}
class MockCustomEvent extends MockEvent {
    constructor(type, customEventInitDic) {
        super(type);
        this.detail = null;
        if (customEventInitDic != null) {
            Object.assign(this, customEventInitDic);
        }
    }
}
class MockKeyboardEvent extends MockEvent {
    constructor(type, keyboardEventInitDic) {
        super(type);
        this.code = '';
        this.key = '';
        this.altKey = false;
        this.ctrlKey = false;
        this.metaKey = false;
        this.shiftKey = false;
        this.location = 0;
        this.repeat = false;
        if (keyboardEventInitDic != null) {
            Object.assign(this, keyboardEventInitDic);
        }
    }
}
class MockMouseEvent extends MockEvent {
    constructor(type, mouseEventInitDic) {
        super(type);
        this.screenX = 0;
        this.screenY = 0;
        this.clientX = 0;
        this.clientY = 0;
        this.ctrlKey = false;
        this.shiftKey = false;
        this.altKey = false;
        this.metaKey = false;
        this.button = 0;
        this.buttons = 0;
        this.relatedTarget = null;
        if (mouseEventInitDic != null) {
            Object.assign(this, mouseEventInitDic);
        }
    }
}
class MockUIEvent extends MockEvent {
    constructor(type, uiEventInitDic) {
        super(type);
        this.detail = null;
        this.view = null;
        if (uiEventInitDic != null) {
            Object.assign(this, uiEventInitDic);
        }
    }
}
class MockFocusEvent extends MockUIEvent {
    constructor(type, focusEventInitDic) {
        super(type);
        this.relatedTarget = null;
        if (focusEventInitDic != null) {
            Object.assign(this, focusEventInitDic);
        }
    }
}
class MockEventListener {
    constructor(type, handler) {
        this.type = type;
        this.handler = handler;
    }
}
function addEventListener(elm, type, handler) {
    const target = elm;
    if (target.__listeners == null) {
        target.__listeners = [];
    }
    target.__listeners.push(new MockEventListener(type, handler));
}
function removeEventListener(elm, type, handler) {
    const target = elm;
    if (target != null && Array.isArray(target.__listeners) === true) {
        const elmListener = target.__listeners.find((e) => e.type === type && e.handler === handler);
        if (elmListener != null) {
            const index = target.__listeners.indexOf(elmListener);
            target.__listeners.splice(index, 1);
        }
    }
}
function resetEventListeners(target) {
    if (target != null && target.__listeners != null) {
        target.__listeners = null;
    }
}
function triggerEventListener(elm, ev) {
    if (elm == null || ev.cancelBubble === true) {
        return;
    }
    const target = elm;
    ev.currentTarget = elm;
    if (Array.isArray(target.__listeners) === true) {
        const listeners = target.__listeners.filter((e) => e.type === ev.type);
        listeners.forEach((listener) => {
            try {
                listener.handler.call(target, ev);
            }
            catch (err) {
                console.error(err);
            }
        });
    }
    if (ev.bubbles === false) {
        return;
    }
    if (elm.nodeName === "#document" /* NODE_NAMES.DOCUMENT_NODE */) {
        triggerEventListener(elm.defaultView, ev);
    }
    else {
        triggerEventListener(elm.parentElement, ev);
    }
}
function dispatchEvent(currentTarget, ev) {
    ev.target = currentTarget;
    triggerEventListener(currentTarget, ev);
    return true;
}

// Parse5 7.1.2
const e=function(e){const t=new Set([65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111]),s="�";var a;!function(e){e[e.EOF=-1]="EOF",e[e.NULL=0]="NULL",e[e.TABULATION=9]="TABULATION",e[e.CARRIAGE_RETURN=13]="CARRIAGE_RETURN",e[e.LINE_FEED=10]="LINE_FEED",e[e.FORM_FEED=12]="FORM_FEED",e[e.SPACE=32]="SPACE",e[e.EXCLAMATION_MARK=33]="EXCLAMATION_MARK",e[e.QUOTATION_MARK=34]="QUOTATION_MARK",e[e.NUMBER_SIGN=35]="NUMBER_SIGN",e[e.AMPERSAND=38]="AMPERSAND",e[e.APOSTROPHE=39]="APOSTROPHE",e[e.HYPHEN_MINUS=45]="HYPHEN_MINUS",e[e.SOLIDUS=47]="SOLIDUS",e[e.DIGIT_0=48]="DIGIT_0",e[e.DIGIT_9=57]="DIGIT_9",e[e.SEMICOLON=59]="SEMICOLON",e[e.LESS_THAN_SIGN=60]="LESS_THAN_SIGN",e[e.EQUALS_SIGN=61]="EQUALS_SIGN",e[e.GREATER_THAN_SIGN=62]="GREATER_THAN_SIGN",e[e.QUESTION_MARK=63]="QUESTION_MARK",e[e.LATIN_CAPITAL_A=65]="LATIN_CAPITAL_A",e[e.LATIN_CAPITAL_F=70]="LATIN_CAPITAL_F",e[e.LATIN_CAPITAL_X=88]="LATIN_CAPITAL_X",e[e.LATIN_CAPITAL_Z=90]="LATIN_CAPITAL_Z",e[e.RIGHT_SQUARE_BRACKET=93]="RIGHT_SQUARE_BRACKET",e[e.GRAVE_ACCENT=96]="GRAVE_ACCENT",e[e.LATIN_SMALL_A=97]="LATIN_SMALL_A",e[e.LATIN_SMALL_F=102]="LATIN_SMALL_F",e[e.LATIN_SMALL_X=120]="LATIN_SMALL_X",e[e.LATIN_SMALL_Z=122]="LATIN_SMALL_Z",e[e.REPLACEMENT_CHARACTER=65533]="REPLACEMENT_CHARACTER";}(a=a||(a={}));const r="[CDATA[",n="doctype",i="script";function o(e){return e>=55296&&e<=57343}function c(e){return 32!==e&&10!==e&&13!==e&&9!==e&&12!==e&&e>=1&&e<=31||e>=127&&e<=159}function E(e){return e>=64976&&e<=65007||t.has(e)}var T,h;!function(e){e.controlCharacterInInputStream="control-character-in-input-stream",e.noncharacterInInputStream="noncharacter-in-input-stream",e.surrogateInInputStream="surrogate-in-input-stream",e.nonVoidHtmlElementStartTagWithTrailingSolidus="non-void-html-element-start-tag-with-trailing-solidus",e.endTagWithAttributes="end-tag-with-attributes",e.endTagWithTrailingSolidus="end-tag-with-trailing-solidus",e.unexpectedSolidusInTag="unexpected-solidus-in-tag",e.unexpectedNullCharacter="unexpected-null-character",e.unexpectedQuestionMarkInsteadOfTagName="unexpected-question-mark-instead-of-tag-name",e.invalidFirstCharacterOfTagName="invalid-first-character-of-tag-name",e.unexpectedEqualsSignBeforeAttributeName="unexpected-equals-sign-before-attribute-name",e.missingEndTagName="missing-end-tag-name",e.unexpectedCharacterInAttributeName="unexpected-character-in-attribute-name",e.unknownNamedCharacterReference="unknown-named-character-reference",e.missingSemicolonAfterCharacterReference="missing-semicolon-after-character-reference",e.unexpectedCharacterAfterDoctypeSystemIdentifier="unexpected-character-after-doctype-system-identifier",e.unexpectedCharacterInUnquotedAttributeValue="unexpected-character-in-unquoted-attribute-value",e.eofBeforeTagName="eof-before-tag-name",e.eofInTag="eof-in-tag",e.missingAttributeValue="missing-attribute-value",e.missingWhitespaceBetweenAttributes="missing-whitespace-between-attributes",e.missingWhitespaceAfterDoctypePublicKeyword="missing-whitespace-after-doctype-public-keyword",e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers="missing-whitespace-between-doctype-public-and-system-identifiers",e.missingWhitespaceAfterDoctypeSystemKeyword="missing-whitespace-after-doctype-system-keyword",e.missingQuoteBeforeDoctypePublicIdentifier="missing-quote-before-doctype-public-identifier",e.missingQuoteBeforeDoctypeSystemIdentifier="missing-quote-before-doctype-system-identifier",e.missingDoctypePublicIdentifier="missing-doctype-public-identifier",e.missingDoctypeSystemIdentifier="missing-doctype-system-identifier",e.abruptDoctypePublicIdentifier="abrupt-doctype-public-identifier",e.abruptDoctypeSystemIdentifier="abrupt-doctype-system-identifier",e.cdataInHtmlContent="cdata-in-html-content",e.incorrectlyOpenedComment="incorrectly-opened-comment",e.eofInScriptHtmlCommentLikeText="eof-in-script-html-comment-like-text",e.eofInDoctype="eof-in-doctype",e.nestedComment="nested-comment",e.abruptClosingOfEmptyComment="abrupt-closing-of-empty-comment",e.eofInComment="eof-in-comment",e.incorrectlyClosedComment="incorrectly-closed-comment",e.eofInCdata="eof-in-cdata",e.absenceOfDigitsInNumericCharacterReference="absence-of-digits-in-numeric-character-reference",e.nullCharacterReference="null-character-reference",e.surrogateCharacterReference="surrogate-character-reference",e.characterReferenceOutsideUnicodeRange="character-reference-outside-unicode-range",e.controlCharacterReference="control-character-reference",e.noncharacterCharacterReference="noncharacter-character-reference",e.missingWhitespaceBeforeDoctypeName="missing-whitespace-before-doctype-name",e.missingDoctypeName="missing-doctype-name",e.invalidCharacterSequenceAfterDoctypeName="invalid-character-sequence-after-doctype-name",e.duplicateAttribute="duplicate-attribute",e.nonConformingDoctype="non-conforming-doctype",e.missingDoctype="missing-doctype",e.misplacedDoctype="misplaced-doctype",e.endTagWithoutMatchingOpenElement="end-tag-without-matching-open-element",e.closingOfElementWithOpenChildElements="closing-of-element-with-open-child-elements",e.disallowedContentInNoscriptInHead="disallowed-content-in-noscript-in-head",e.openElementsLeftAfterEof="open-elements-left-after-eof",e.abandonedHeadElementChild="abandoned-head-element-child",e.misplacedStartTagForHeadElement="misplaced-start-tag-for-head-element",e.nestedNoscriptInHead="nested-noscript-in-head",e.eofInElementThatCanContainOnlyText="eof-in-element-that-can-contain-only-text";}(T=T||(T={}));class _{constructor(e){this.handler=e,this.html="",this.pos=-1,this.lastGapPos=-2,this.gapStack=[],this.skipNextNewLine=!1,this.lastChunkWritten=!1,this.endOfChunkHit=!1,this.bufferWaterline=65536,this.isEol=!1,this.lineStartPos=0,this.droppedBufferSize=0,this.line=1,this.lastErrOffset=-1;}get col(){return this.pos-this.lineStartPos+Number(this.lastGapPos!==this.pos)}get offset(){return this.droppedBufferSize+this.pos}getError(e){const{line:t,col:s,offset:a}=this;return {code:e,startLine:t,endLine:t,startCol:s,endCol:s,startOffset:a,endOffset:a}}_err(e){this.handler.onParseError&&this.lastErrOffset!==this.offset&&(this.lastErrOffset=this.offset,this.handler.onParseError(this.getError(e)));}_addGap(){this.gapStack.push(this.lastGapPos),this.lastGapPos=this.pos;}_processSurrogate(e){if(this.pos!==this.html.length-1){const t=this.html.charCodeAt(this.pos+1);if(function(e){return e>=56320&&e<=57343}(t))return this.pos++,this._addGap(),1024*(e-55296)+9216+t}else if(!this.lastChunkWritten)return this.endOfChunkHit=!0,a.EOF;return this._err(T.surrogateInInputStream),e}willDropParsedChunk(){return this.pos>this.bufferWaterline}dropParsedChunk(){this.willDropParsedChunk()&&(this.html=this.html.substring(this.pos),this.lineStartPos-=this.pos,this.droppedBufferSize+=this.pos,this.pos=0,this.lastGapPos=-2,this.gapStack.length=0);}write(e,t){this.html.length>0?this.html+=e:this.html=e,this.endOfChunkHit=!1,this.lastChunkWritten=t;}insertHtmlAtCurrentPos(e){this.html=this.html.substring(0,this.pos+1)+e+this.html.substring(this.pos+1),this.endOfChunkHit=!1;}startsWith(e,t){if(this.pos+e.length>this.html.length)return this.endOfChunkHit=!this.lastChunkWritten,!1;if(t)return this.html.startsWith(e,this.pos);for(let t=0;t<e.length;t++)if((32|this.html.charCodeAt(this.pos+t))!==e.charCodeAt(t))return !1;return !0}peek(e){const t=this.pos+e;if(t>=this.html.length)return this.endOfChunkHit=!this.lastChunkWritten,a.EOF;const s=this.html.charCodeAt(t);return s===a.CARRIAGE_RETURN?a.LINE_FEED:s}advance(){if(this.pos++,this.isEol&&(this.isEol=!1,this.line++,this.lineStartPos=this.pos),this.pos>=this.html.length)return this.endOfChunkHit=!this.lastChunkWritten,a.EOF;let e=this.html.charCodeAt(this.pos);return e===a.CARRIAGE_RETURN?(this.isEol=!0,this.skipNextNewLine=!0,a.LINE_FEED):e===a.LINE_FEED&&(this.isEol=!0,this.skipNextNewLine)?(this.line--,this.skipNextNewLine=!1,this._addGap(),this.advance()):(this.skipNextNewLine=!1,o(e)&&(e=this._processSurrogate(e)),null===this.handler.onParseError||e>31&&e<127||e===a.LINE_FEED||e===a.CARRIAGE_RETURN||e>159&&e<64976||this._checkForProblematicCharacters(e),e)}_checkForProblematicCharacters(e){c(e)?this._err(T.controlCharacterInInputStream):E(e)&&this._err(T.noncharacterInInputStream);}retreat(e){for(this.pos-=e;this.pos<this.lastGapPos;)this.lastGapPos=this.gapStack.pop(),this.pos--;this.isEol=!1;}}function A(e,t){for(let s=e.attrs.length-1;s>=0;s--)if(e.attrs[s].name===t)return e.attrs[s].value;return null}!function(e){e[e.CHARACTER=0]="CHARACTER",e[e.NULL_CHARACTER=1]="NULL_CHARACTER",e[e.WHITESPACE_CHARACTER=2]="WHITESPACE_CHARACTER",e[e.START_TAG=3]="START_TAG",e[e.END_TAG=4]="END_TAG",e[e.COMMENT=5]="COMMENT",e[e.DOCTYPE=6]="DOCTYPE",e[e.EOF=7]="EOF",e[e.HIBERNATION=8]="HIBERNATION";}(h=h||(h={}));var l="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function m(e,t,s){return e(s={path:t,exports:{},require:function(e,t){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==t&&s.path)}},s.exports),s.exports}var d,p,u,N,I,C=m((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=new Uint16Array('ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((function(e){return e.charCodeAt(0)})));})),S=m((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=new Uint16Array("Ȁaglq\tɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((function(e){return e.charCodeAt(0)})));})),D=m((function(e,t){var s;Object.defineProperty(t,"__esModule",{value:!0}),t.replaceCodePoint=t.fromCodePoint=void 0;var a=new Map([[0,65533],[128,8364],[130,8218],[131,402],[132,8222],[133,8230],[134,8224],[135,8225],[136,710],[137,8240],[138,352],[139,8249],[140,338],[142,381],[145,8216],[146,8217],[147,8220],[148,8221],[149,8226],[150,8211],[151,8212],[152,732],[153,8482],[154,353],[155,8250],[156,339],[158,382],[159,376]]);function r(e){var t;return e>=55296&&e<=57343||e>1114111?65533:null!==(t=a.get(e))&&void 0!==t?t:e}t.fromCodePoint=null!==(s=String.fromCodePoint)&&void 0!==s?s:function(e){var t="";return e>65535&&(e-=65536,t+=String.fromCharCode(e>>>10&1023|55296),e=56320|1023&e),t+String.fromCharCode(e)},t.replaceCodePoint=r,t.default=function(e){return (0, t.fromCodePoint)(r(e))};})),R=m((function(e,t){var s=l&&l.__createBinding||(Object.create?function(e,t,s,a){void 0===a&&(a=s);var r=Object.getOwnPropertyDescriptor(t,s);r&&!("get"in r?!t.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return t[s]}}),Object.defineProperty(e,a,r);}:function(e,t,s,a){void 0===a&&(a=s),e[a]=t[s];}),a=l&&l.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t});}:function(e,t){e.default=t;}),r=l&&l.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&s(t,e,r);return a(t,e),t},n=l&&l.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.decodeXML=t.decodeHTMLStrict=t.decodeHTMLAttribute=t.decodeHTML=t.determineBranch=t.EntityDecoder=t.DecodingMode=t.BinTrieFlags=t.fromCodePoint=t.replaceCodePoint=t.decodeCodePoint=t.xmlDecodeTree=t.htmlDecodeTree=void 0;var i=n(C);t.htmlDecodeTree=i.default;var o=n(S);t.xmlDecodeTree=o.default;var c=r(D);t.decodeCodePoint=c.default;var E,T,h,_,A=D;function m(e){return e>=E.ZERO&&e<=E.NINE}Object.defineProperty(t,"replaceCodePoint",{enumerable:!0,get:function(){return A.replaceCodePoint}}),Object.defineProperty(t,"fromCodePoint",{enumerable:!0,get:function(){return A.fromCodePoint}}),function(e){e[e.NUM=35]="NUM",e[e.SEMI=59]="SEMI",e[e.EQUALS=61]="EQUALS",e[e.ZERO=48]="ZERO",e[e.NINE=57]="NINE",e[e.LOWER_A=97]="LOWER_A",e[e.LOWER_F=102]="LOWER_F",e[e.LOWER_X=120]="LOWER_X",e[e.LOWER_Z=122]="LOWER_Z",e[e.UPPER_A=65]="UPPER_A",e[e.UPPER_F=70]="UPPER_F",e[e.UPPER_Z=90]="UPPER_Z";}(E||(E={})),function(e){e[e.VALUE_LENGTH=49152]="VALUE_LENGTH",e[e.BRANCH_LENGTH=16256]="BRANCH_LENGTH",e[e.JUMP_TABLE=127]="JUMP_TABLE";}(T=t.BinTrieFlags||(t.BinTrieFlags={})),function(e){e[e.EntityStart=0]="EntityStart",e[e.NumericStart=1]="NumericStart",e[e.NumericDecimal=2]="NumericDecimal",e[e.NumericHex=3]="NumericHex",e[e.NamedEntity=4]="NamedEntity";}(h||(h={})),function(e){e[e.Legacy=0]="Legacy",e[e.Strict=1]="Strict",e[e.Attribute=2]="Attribute";}(_=t.DecodingMode||(t.DecodingMode={}));var d=function(){function e(e,t,s){this.decodeTree=e,this.emitCodePoint=t,this.errors=s,this.state=h.EntityStart,this.consumed=1,this.result=0,this.treeIndex=0,this.excess=1,this.decodeMode=_.Strict;}return e.prototype.startEntity=function(e){this.decodeMode=e,this.state=h.EntityStart,this.result=0,this.treeIndex=0,this.excess=1,this.consumed=1;},e.prototype.write=function(e,t){switch(this.state){case h.EntityStart:return e.charCodeAt(t)===E.NUM?(this.state=h.NumericStart,this.consumed+=1,this.stateNumericStart(e,t+1)):(this.state=h.NamedEntity,this.stateNamedEntity(e,t));case h.NumericStart:return this.stateNumericStart(e,t);case h.NumericDecimal:return this.stateNumericDecimal(e,t);case h.NumericHex:return this.stateNumericHex(e,t);case h.NamedEntity:return this.stateNamedEntity(e,t)}},e.prototype.stateNumericStart=function(e,t){return t>=e.length?-1:(32|e.charCodeAt(t))===E.LOWER_X?(this.state=h.NumericHex,this.consumed+=1,this.stateNumericHex(e,t+1)):(this.state=h.NumericDecimal,this.stateNumericDecimal(e,t))},e.prototype.addToNumericResult=function(e,t,s,a){if(t!==s){var r=s-t;this.result=this.result*Math.pow(a,r)+parseInt(e.substr(t,r),a),this.consumed+=r;}},e.prototype.stateNumericHex=function(e,t){for(var s,a=t;t<e.length;){var r=e.charCodeAt(t);if(!(m(r)||(s=r,s>=E.UPPER_A&&s<=E.UPPER_F||s>=E.LOWER_A&&s<=E.LOWER_F)))return this.addToNumericResult(e,a,t,16),this.emitNumericEntity(r,3);t+=1;}return this.addToNumericResult(e,a,t,16),-1},e.prototype.stateNumericDecimal=function(e,t){for(var s=t;t<e.length;){var a=e.charCodeAt(t);if(!m(a))return this.addToNumericResult(e,s,t,10),this.emitNumericEntity(a,2);t+=1;}return this.addToNumericResult(e,s,t,10),-1},e.prototype.emitNumericEntity=function(e,t){var s;if(this.consumed<=t)return null===(s=this.errors)||void 0===s||s.absenceOfDigitsInNumericCharacterReference(this.consumed),0;if(e===E.SEMI)this.consumed+=1;else if(this.decodeMode===_.Strict)return 0;return this.emitCodePoint((0, c.replaceCodePoint)(this.result),this.consumed),this.errors&&(e!==E.SEMI&&this.errors.missingSemicolonAfterCharacterReference(),this.errors.validateNumericCharacterReference(this.result)),this.consumed},e.prototype.stateNamedEntity=function(e,t){for(var s=this.decodeTree,a=s[this.treeIndex],r=(a&T.VALUE_LENGTH)>>14;t<e.length;t++,this.excess++){var n=e.charCodeAt(t);if(this.treeIndex=u(s,a,this.treeIndex+Math.max(1,r),n),this.treeIndex<0)return 0===this.result||this.decodeMode===_.Attribute&&(0===r||((i=n)===E.EQUALS||function(e){return e>=E.UPPER_A&&e<=E.UPPER_Z||e>=E.LOWER_A&&e<=E.LOWER_Z||m(e)}(i)))?0:this.emitNotTerminatedNamedEntity();if(0!=(r=((a=s[this.treeIndex])&T.VALUE_LENGTH)>>14)){if(n===E.SEMI)return this.emitNamedEntityData(this.treeIndex,r,this.consumed+this.excess);this.decodeMode!==_.Strict&&(this.result=this.treeIndex,this.consumed+=this.excess,this.excess=0);}}var i;return -1},e.prototype.emitNotTerminatedNamedEntity=function(){var e,t=this.result,s=(this.decodeTree[t]&T.VALUE_LENGTH)>>14;return this.emitNamedEntityData(t,s,this.consumed),null===(e=this.errors)||void 0===e||e.missingSemicolonAfterCharacterReference(),this.consumed},e.prototype.emitNamedEntityData=function(e,t,s){var a=this.decodeTree;return this.emitCodePoint(1===t?a[e]&~T.VALUE_LENGTH:a[e+1],s),3===t&&this.emitCodePoint(a[e+2],s),s},e.prototype.end=function(){var e;switch(this.state){case h.NamedEntity:return 0===this.result||this.decodeMode===_.Attribute&&this.result!==this.treeIndex?0:this.emitNotTerminatedNamedEntity();case h.NumericDecimal:return this.emitNumericEntity(0,2);case h.NumericHex:return this.emitNumericEntity(0,3);case h.NumericStart:return null===(e=this.errors)||void 0===e||e.absenceOfDigitsInNumericCharacterReference(this.consumed),0;case h.EntityStart:return 0}},e}();function p(e){var t="",s=new d(e,(function(e){return t+=(0, c.fromCodePoint)(e)}));return function(e,a){for(var r=0,n=0;(n=e.indexOf("&",n))>=0;){t+=e.slice(r,n),s.startEntity(a);var i=s.write(e,n+1);if(i<0){r=n+s.end();break}r=n+i,n=0===i?r+1:r;}var o=t+e.slice(r);return t="",o}}function u(e,t,s,a){var r=(t&T.BRANCH_LENGTH)>>7,n=t&T.JUMP_TABLE;if(0===r)return 0!==n&&a===n?s:-1;if(n){var i=a-n;return i<0||i>=r?-1:e[s+i]-1}for(var o=s,c=o+r-1;o<=c;){var E=o+c>>>1,h=e[E];if(h<a)o=E+1;else {if(!(h>a))return e[E+r];c=E-1;}}return -1}t.EntityDecoder=d,t.determineBranch=u;var N=p(i.default),I=p(o.default);t.decodeHTML=function(e,t){return void 0===t&&(t=_.Legacy),N(e,t)},t.decodeHTMLAttribute=function(e){return N(e,_.Attribute)},t.decodeHTMLStrict=function(e){return N(e,_.Strict)},t.decodeXML=function(e){return I(e,_.Strict)};}));!function(e){e.HTML="http://www.w3.org/1999/xhtml",e.MATHML="http://www.w3.org/1998/Math/MathML",e.SVG="http://www.w3.org/2000/svg",e.XLINK="http://www.w3.org/1999/xlink",e.XML="http://www.w3.org/XML/1998/namespace",e.XMLNS="http://www.w3.org/2000/xmlns/";}(d=d||(d={})),function(e){e.TYPE="type",e.ACTION="action",e.ENCODING="encoding",e.PROMPT="prompt",e.NAME="name",e.COLOR="color",e.FACE="face",e.SIZE="size";}(p=p||(p={})),function(e){e.NO_QUIRKS="no-quirks",e.QUIRKS="quirks",e.LIMITED_QUIRKS="limited-quirks";}(u=u||(u={})),function(e){e.A="a",e.ADDRESS="address",e.ANNOTATION_XML="annotation-xml",e.APPLET="applet",e.AREA="area",e.ARTICLE="article",e.ASIDE="aside",e.B="b",e.BASE="base",e.BASEFONT="basefont",e.BGSOUND="bgsound",e.BIG="big",e.BLOCKQUOTE="blockquote",e.BODY="body",e.BR="br",e.BUTTON="button",e.CAPTION="caption",e.CENTER="center",e.CODE="code",e.COL="col",e.COLGROUP="colgroup",e.DD="dd",e.DESC="desc",e.DETAILS="details",e.DIALOG="dialog",e.DIR="dir",e.DIV="div",e.DL="dl",e.DT="dt",e.EM="em",e.EMBED="embed",e.FIELDSET="fieldset",e.FIGCAPTION="figcaption",e.FIGURE="figure",e.FONT="font",e.FOOTER="footer",e.FOREIGN_OBJECT="foreignObject",e.FORM="form",e.FRAME="frame",e.FRAMESET="frameset",e.H1="h1",e.H2="h2",e.H3="h3",e.H4="h4",e.H5="h5",e.H6="h6",e.HEAD="head",e.HEADER="header",e.HGROUP="hgroup",e.HR="hr",e.HTML="html",e.I="i",e.IMG="img",e.IMAGE="image",e.INPUT="input",e.IFRAME="iframe",e.KEYGEN="keygen",e.LABEL="label",e.LI="li",e.LINK="link",e.LISTING="listing",e.MAIN="main",e.MALIGNMARK="malignmark",e.MARQUEE="marquee",e.MATH="math",e.MENU="menu",e.META="meta",e.MGLYPH="mglyph",e.MI="mi",e.MO="mo",e.MN="mn",e.MS="ms",e.MTEXT="mtext",e.NAV="nav",e.NOBR="nobr",e.NOFRAMES="noframes",e.NOEMBED="noembed",e.NOSCRIPT="noscript",e.OBJECT="object",e.OL="ol",e.OPTGROUP="optgroup",e.OPTION="option",e.P="p",e.PARAM="param",e.PLAINTEXT="plaintext",e.PRE="pre",e.RB="rb",e.RP="rp",e.RT="rt",e.RTC="rtc",e.RUBY="ruby",e.S="s",e.SCRIPT="script",e.SECTION="section",e.SELECT="select",e.SOURCE="source",e.SMALL="small",e.SPAN="span",e.STRIKE="strike",e.STRONG="strong",e.STYLE="style",e.SUB="sub",e.SUMMARY="summary",e.SUP="sup",e.TABLE="table",e.TBODY="tbody",e.TEMPLATE="template",e.TEXTAREA="textarea",e.TFOOT="tfoot",e.TD="td",e.TH="th",e.THEAD="thead",e.TITLE="title",e.TR="tr",e.TRACK="track",e.TT="tt",e.U="u",e.UL="ul",e.SVG="svg",e.VAR="var",e.WBR="wbr",e.XMP="xmp";}(N=N||(N={})),function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.A=1]="A",e[e.ADDRESS=2]="ADDRESS",e[e.ANNOTATION_XML=3]="ANNOTATION_XML",e[e.APPLET=4]="APPLET",e[e.AREA=5]="AREA",e[e.ARTICLE=6]="ARTICLE",e[e.ASIDE=7]="ASIDE",e[e.B=8]="B",e[e.BASE=9]="BASE",e[e.BASEFONT=10]="BASEFONT",e[e.BGSOUND=11]="BGSOUND",e[e.BIG=12]="BIG",e[e.BLOCKQUOTE=13]="BLOCKQUOTE",e[e.BODY=14]="BODY",e[e.BR=15]="BR",e[e.BUTTON=16]="BUTTON",e[e.CAPTION=17]="CAPTION",e[e.CENTER=18]="CENTER",e[e.CODE=19]="CODE",e[e.COL=20]="COL",e[e.COLGROUP=21]="COLGROUP",e[e.DD=22]="DD",e[e.DESC=23]="DESC",e[e.DETAILS=24]="DETAILS",e[e.DIALOG=25]="DIALOG",e[e.DIR=26]="DIR",e[e.DIV=27]="DIV",e[e.DL=28]="DL",e[e.DT=29]="DT",e[e.EM=30]="EM",e[e.EMBED=31]="EMBED",e[e.FIELDSET=32]="FIELDSET",e[e.FIGCAPTION=33]="FIGCAPTION",e[e.FIGURE=34]="FIGURE",e[e.FONT=35]="FONT",e[e.FOOTER=36]="FOOTER",e[e.FOREIGN_OBJECT=37]="FOREIGN_OBJECT",e[e.FORM=38]="FORM",e[e.FRAME=39]="FRAME",e[e.FRAMESET=40]="FRAMESET",e[e.H1=41]="H1",e[e.H2=42]="H2",e[e.H3=43]="H3",e[e.H4=44]="H4",e[e.H5=45]="H5",e[e.H6=46]="H6",e[e.HEAD=47]="HEAD",e[e.HEADER=48]="HEADER",e[e.HGROUP=49]="HGROUP",e[e.HR=50]="HR",e[e.HTML=51]="HTML",e[e.I=52]="I",e[e.IMG=53]="IMG",e[e.IMAGE=54]="IMAGE",e[e.INPUT=55]="INPUT",e[e.IFRAME=56]="IFRAME",e[e.KEYGEN=57]="KEYGEN",e[e.LABEL=58]="LABEL",e[e.LI=59]="LI",e[e.LINK=60]="LINK",e[e.LISTING=61]="LISTING",e[e.MAIN=62]="MAIN",e[e.MALIGNMARK=63]="MALIGNMARK",e[e.MARQUEE=64]="MARQUEE",e[e.MATH=65]="MATH",e[e.MENU=66]="MENU",e[e.META=67]="META",e[e.MGLYPH=68]="MGLYPH",e[e.MI=69]="MI",e[e.MO=70]="MO",e[e.MN=71]="MN",e[e.MS=72]="MS",e[e.MTEXT=73]="MTEXT",e[e.NAV=74]="NAV",e[e.NOBR=75]="NOBR",e[e.NOFRAMES=76]="NOFRAMES",e[e.NOEMBED=77]="NOEMBED",e[e.NOSCRIPT=78]="NOSCRIPT",e[e.OBJECT=79]="OBJECT",e[e.OL=80]="OL",e[e.OPTGROUP=81]="OPTGROUP",e[e.OPTION=82]="OPTION",e[e.P=83]="P",e[e.PARAM=84]="PARAM",e[e.PLAINTEXT=85]="PLAINTEXT",e[e.PRE=86]="PRE",e[e.RB=87]="RB",e[e.RP=88]="RP",e[e.RT=89]="RT",e[e.RTC=90]="RTC",e[e.RUBY=91]="RUBY",e[e.S=92]="S",e[e.SCRIPT=93]="SCRIPT",e[e.SECTION=94]="SECTION",e[e.SELECT=95]="SELECT",e[e.SOURCE=96]="SOURCE",e[e.SMALL=97]="SMALL",e[e.SPAN=98]="SPAN",e[e.STRIKE=99]="STRIKE",e[e.STRONG=100]="STRONG",e[e.STYLE=101]="STYLE",e[e.SUB=102]="SUB",e[e.SUMMARY=103]="SUMMARY",e[e.SUP=104]="SUP",e[e.TABLE=105]="TABLE",e[e.TBODY=106]="TBODY",e[e.TEMPLATE=107]="TEMPLATE",e[e.TEXTAREA=108]="TEXTAREA",e[e.TFOOT=109]="TFOOT",e[e.TD=110]="TD",e[e.TH=111]="TH",e[e.THEAD=112]="THEAD",e[e.TITLE=113]="TITLE",e[e.TR=114]="TR",e[e.TRACK=115]="TRACK",e[e.TT=116]="TT",e[e.U=117]="U",e[e.UL=118]="UL",e[e.SVG=119]="SVG",e[e.VAR=120]="VAR",e[e.WBR=121]="WBR",e[e.XMP=122]="XMP";}(I=I||(I={}));const O=new Map([[N.A,I.A],[N.ADDRESS,I.ADDRESS],[N.ANNOTATION_XML,I.ANNOTATION_XML],[N.APPLET,I.APPLET],[N.AREA,I.AREA],[N.ARTICLE,I.ARTICLE],[N.ASIDE,I.ASIDE],[N.B,I.B],[N.BASE,I.BASE],[N.BASEFONT,I.BASEFONT],[N.BGSOUND,I.BGSOUND],[N.BIG,I.BIG],[N.BLOCKQUOTE,I.BLOCKQUOTE],[N.BODY,I.BODY],[N.BR,I.BR],[N.BUTTON,I.BUTTON],[N.CAPTION,I.CAPTION],[N.CENTER,I.CENTER],[N.CODE,I.CODE],[N.COL,I.COL],[N.COLGROUP,I.COLGROUP],[N.DD,I.DD],[N.DESC,I.DESC],[N.DETAILS,I.DETAILS],[N.DIALOG,I.DIALOG],[N.DIR,I.DIR],[N.DIV,I.DIV],[N.DL,I.DL],[N.DT,I.DT],[N.EM,I.EM],[N.EMBED,I.EMBED],[N.FIELDSET,I.FIELDSET],[N.FIGCAPTION,I.FIGCAPTION],[N.FIGURE,I.FIGURE],[N.FONT,I.FONT],[N.FOOTER,I.FOOTER],[N.FOREIGN_OBJECT,I.FOREIGN_OBJECT],[N.FORM,I.FORM],[N.FRAME,I.FRAME],[N.FRAMESET,I.FRAMESET],[N.H1,I.H1],[N.H2,I.H2],[N.H3,I.H3],[N.H4,I.H4],[N.H5,I.H5],[N.H6,I.H6],[N.HEAD,I.HEAD],[N.HEADER,I.HEADER],[N.HGROUP,I.HGROUP],[N.HR,I.HR],[N.HTML,I.HTML],[N.I,I.I],[N.IMG,I.IMG],[N.IMAGE,I.IMAGE],[N.INPUT,I.INPUT],[N.IFRAME,I.IFRAME],[N.KEYGEN,I.KEYGEN],[N.LABEL,I.LABEL],[N.LI,I.LI],[N.LINK,I.LINK],[N.LISTING,I.LISTING],[N.MAIN,I.MAIN],[N.MALIGNMARK,I.MALIGNMARK],[N.MARQUEE,I.MARQUEE],[N.MATH,I.MATH],[N.MENU,I.MENU],[N.META,I.META],[N.MGLYPH,I.MGLYPH],[N.MI,I.MI],[N.MO,I.MO],[N.MN,I.MN],[N.MS,I.MS],[N.MTEXT,I.MTEXT],[N.NAV,I.NAV],[N.NOBR,I.NOBR],[N.NOFRAMES,I.NOFRAMES],[N.NOEMBED,I.NOEMBED],[N.NOSCRIPT,I.NOSCRIPT],[N.OBJECT,I.OBJECT],[N.OL,I.OL],[N.OPTGROUP,I.OPTGROUP],[N.OPTION,I.OPTION],[N.P,I.P],[N.PARAM,I.PARAM],[N.PLAINTEXT,I.PLAINTEXT],[N.PRE,I.PRE],[N.RB,I.RB],[N.RP,I.RP],[N.RT,I.RT],[N.RTC,I.RTC],[N.RUBY,I.RUBY],[N.S,I.S],[N.SCRIPT,I.SCRIPT],[N.SECTION,I.SECTION],[N.SELECT,I.SELECT],[N.SOURCE,I.SOURCE],[N.SMALL,I.SMALL],[N.SPAN,I.SPAN],[N.STRIKE,I.STRIKE],[N.STRONG,I.STRONG],[N.STYLE,I.STYLE],[N.SUB,I.SUB],[N.SUMMARY,I.SUMMARY],[N.SUP,I.SUP],[N.TABLE,I.TABLE],[N.TBODY,I.TBODY],[N.TEMPLATE,I.TEMPLATE],[N.TEXTAREA,I.TEXTAREA],[N.TFOOT,I.TFOOT],[N.TD,I.TD],[N.TH,I.TH],[N.THEAD,I.THEAD],[N.TITLE,I.TITLE],[N.TR,I.TR],[N.TRACK,I.TRACK],[N.TT,I.TT],[N.U,I.U],[N.UL,I.UL],[N.SVG,I.SVG],[N.VAR,I.VAR],[N.WBR,I.WBR],[N.XMP,I.XMP]]);function f(e){var t;return null!==(t=O.get(e))&&void 0!==t?t:I.UNKNOWN}const L=I,M={[d.HTML]:new Set([L.ADDRESS,L.APPLET,L.AREA,L.ARTICLE,L.ASIDE,L.BASE,L.BASEFONT,L.BGSOUND,L.BLOCKQUOTE,L.BODY,L.BR,L.BUTTON,L.CAPTION,L.CENTER,L.COL,L.COLGROUP,L.DD,L.DETAILS,L.DIR,L.DIV,L.DL,L.DT,L.EMBED,L.FIELDSET,L.FIGCAPTION,L.FIGURE,L.FOOTER,L.FORM,L.FRAME,L.FRAMESET,L.H1,L.H2,L.H3,L.H4,L.H5,L.H6,L.HEAD,L.HEADER,L.HGROUP,L.HR,L.HTML,L.IFRAME,L.IMG,L.INPUT,L.LI,L.LINK,L.LISTING,L.MAIN,L.MARQUEE,L.MENU,L.META,L.NAV,L.NOEMBED,L.NOFRAMES,L.NOSCRIPT,L.OBJECT,L.OL,L.P,L.PARAM,L.PLAINTEXT,L.PRE,L.SCRIPT,L.SECTION,L.SELECT,L.SOURCE,L.STYLE,L.SUMMARY,L.TABLE,L.TBODY,L.TD,L.TEMPLATE,L.TEXTAREA,L.TFOOT,L.TH,L.THEAD,L.TITLE,L.TR,L.TRACK,L.UL,L.WBR,L.XMP]),[d.MATHML]:new Set([L.MI,L.MO,L.MN,L.MS,L.MTEXT,L.ANNOTATION_XML]),[d.SVG]:new Set([L.TITLE,L.FOREIGN_OBJECT,L.DESC]),[d.XLINK]:new Set,[d.XML]:new Set,[d.XMLNS]:new Set};function g(e){return e===L.H1||e===L.H2||e===L.H3||e===L.H4||e===L.H5||e===L.H6}new Set([N.STYLE,N.SCRIPT,N.XMP,N.IFRAME,N.NOEMBED,N.NOFRAMES,N.PLAINTEXT]);const P=new Map([[128,8364],[130,8218],[131,402],[132,8222],[133,8230],[134,8224],[135,8225],[136,710],[137,8240],[138,352],[139,8249],[140,338],[142,381],[145,8216],[146,8217],[147,8220],[148,8221],[149,8226],[150,8211],[151,8212],[152,732],[153,8482],[154,353],[155,8250],[156,339],[158,382],[159,376]]);var k;!function(e){e[e.DATA=0]="DATA",e[e.RCDATA=1]="RCDATA",e[e.RAWTEXT=2]="RAWTEXT",e[e.SCRIPT_DATA=3]="SCRIPT_DATA",e[e.PLAINTEXT=4]="PLAINTEXT",e[e.TAG_OPEN=5]="TAG_OPEN",e[e.END_TAG_OPEN=6]="END_TAG_OPEN",e[e.TAG_NAME=7]="TAG_NAME",e[e.RCDATA_LESS_THAN_SIGN=8]="RCDATA_LESS_THAN_SIGN",e[e.RCDATA_END_TAG_OPEN=9]="RCDATA_END_TAG_OPEN",e[e.RCDATA_END_TAG_NAME=10]="RCDATA_END_TAG_NAME",e[e.RAWTEXT_LESS_THAN_SIGN=11]="RAWTEXT_LESS_THAN_SIGN",e[e.RAWTEXT_END_TAG_OPEN=12]="RAWTEXT_END_TAG_OPEN",e[e.RAWTEXT_END_TAG_NAME=13]="RAWTEXT_END_TAG_NAME",e[e.SCRIPT_DATA_LESS_THAN_SIGN=14]="SCRIPT_DATA_LESS_THAN_SIGN",e[e.SCRIPT_DATA_END_TAG_OPEN=15]="SCRIPT_DATA_END_TAG_OPEN",e[e.SCRIPT_DATA_END_TAG_NAME=16]="SCRIPT_DATA_END_TAG_NAME",e[e.SCRIPT_DATA_ESCAPE_START=17]="SCRIPT_DATA_ESCAPE_START",e[e.SCRIPT_DATA_ESCAPE_START_DASH=18]="SCRIPT_DATA_ESCAPE_START_DASH",e[e.SCRIPT_DATA_ESCAPED=19]="SCRIPT_DATA_ESCAPED",e[e.SCRIPT_DATA_ESCAPED_DASH=20]="SCRIPT_DATA_ESCAPED_DASH",e[e.SCRIPT_DATA_ESCAPED_DASH_DASH=21]="SCRIPT_DATA_ESCAPED_DASH_DASH",e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN=22]="SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN",e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN=23]="SCRIPT_DATA_ESCAPED_END_TAG_OPEN",e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME=24]="SCRIPT_DATA_ESCAPED_END_TAG_NAME",e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START=25]="SCRIPT_DATA_DOUBLE_ESCAPE_START",e[e.SCRIPT_DATA_DOUBLE_ESCAPED=26]="SCRIPT_DATA_DOUBLE_ESCAPED",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH=27]="SCRIPT_DATA_DOUBLE_ESCAPED_DASH",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH=28]="SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN=29]="SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN",e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END=30]="SCRIPT_DATA_DOUBLE_ESCAPE_END",e[e.BEFORE_ATTRIBUTE_NAME=31]="BEFORE_ATTRIBUTE_NAME",e[e.ATTRIBUTE_NAME=32]="ATTRIBUTE_NAME",e[e.AFTER_ATTRIBUTE_NAME=33]="AFTER_ATTRIBUTE_NAME",e[e.BEFORE_ATTRIBUTE_VALUE=34]="BEFORE_ATTRIBUTE_VALUE",e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED=35]="ATTRIBUTE_VALUE_DOUBLE_QUOTED",e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED=36]="ATTRIBUTE_VALUE_SINGLE_QUOTED",e[e.ATTRIBUTE_VALUE_UNQUOTED=37]="ATTRIBUTE_VALUE_UNQUOTED",e[e.AFTER_ATTRIBUTE_VALUE_QUOTED=38]="AFTER_ATTRIBUTE_VALUE_QUOTED",e[e.SELF_CLOSING_START_TAG=39]="SELF_CLOSING_START_TAG",e[e.BOGUS_COMMENT=40]="BOGUS_COMMENT",e[e.MARKUP_DECLARATION_OPEN=41]="MARKUP_DECLARATION_OPEN",e[e.COMMENT_START=42]="COMMENT_START",e[e.COMMENT_START_DASH=43]="COMMENT_START_DASH",e[e.COMMENT=44]="COMMENT",e[e.COMMENT_LESS_THAN_SIGN=45]="COMMENT_LESS_THAN_SIGN",e[e.COMMENT_LESS_THAN_SIGN_BANG=46]="COMMENT_LESS_THAN_SIGN_BANG",e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH=47]="COMMENT_LESS_THAN_SIGN_BANG_DASH",e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH=48]="COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH",e[e.COMMENT_END_DASH=49]="COMMENT_END_DASH",e[e.COMMENT_END=50]="COMMENT_END",e[e.COMMENT_END_BANG=51]="COMMENT_END_BANG",e[e.DOCTYPE=52]="DOCTYPE",e[e.BEFORE_DOCTYPE_NAME=53]="BEFORE_DOCTYPE_NAME",e[e.DOCTYPE_NAME=54]="DOCTYPE_NAME",e[e.AFTER_DOCTYPE_NAME=55]="AFTER_DOCTYPE_NAME",e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD=56]="AFTER_DOCTYPE_PUBLIC_KEYWORD",e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER=57]="BEFORE_DOCTYPE_PUBLIC_IDENTIFIER",e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED=58]="DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED",e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED=59]="DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED",e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER=60]="AFTER_DOCTYPE_PUBLIC_IDENTIFIER",e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS=61]="BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS",e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD=62]="AFTER_DOCTYPE_SYSTEM_KEYWORD",e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER=63]="BEFORE_DOCTYPE_SYSTEM_IDENTIFIER",e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED=64]="DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED",e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED=65]="DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED",e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER=66]="AFTER_DOCTYPE_SYSTEM_IDENTIFIER",e[e.BOGUS_DOCTYPE=67]="BOGUS_DOCTYPE",e[e.CDATA_SECTION=68]="CDATA_SECTION",e[e.CDATA_SECTION_BRACKET=69]="CDATA_SECTION_BRACKET",e[e.CDATA_SECTION_END=70]="CDATA_SECTION_END",e[e.CHARACTER_REFERENCE=71]="CHARACTER_REFERENCE",e[e.NAMED_CHARACTER_REFERENCE=72]="NAMED_CHARACTER_REFERENCE",e[e.AMBIGUOUS_AMPERSAND=73]="AMBIGUOUS_AMPERSAND",e[e.NUMERIC_CHARACTER_REFERENCE=74]="NUMERIC_CHARACTER_REFERENCE",e[e.HEXADEMICAL_CHARACTER_REFERENCE_START=75]="HEXADEMICAL_CHARACTER_REFERENCE_START",e[e.HEXADEMICAL_CHARACTER_REFERENCE=76]="HEXADEMICAL_CHARACTER_REFERENCE",e[e.DECIMAL_CHARACTER_REFERENCE=77]="DECIMAL_CHARACTER_REFERENCE",e[e.NUMERIC_CHARACTER_REFERENCE_END=78]="NUMERIC_CHARACTER_REFERENCE_END";}(k||(k={}));const b={DATA:k.DATA,RCDATA:k.RCDATA,RAWTEXT:k.RAWTEXT,SCRIPT_DATA:k.SCRIPT_DATA,PLAINTEXT:k.PLAINTEXT,CDATA_SECTION:k.CDATA_SECTION};function B(e){return e>=a.DIGIT_0&&e<=a.DIGIT_9}function H(e){return e>=a.LATIN_CAPITAL_A&&e<=a.LATIN_CAPITAL_Z}function F(e){return function(e){return e>=a.LATIN_SMALL_A&&e<=a.LATIN_SMALL_Z}(e)||H(e)}function U(e){return F(e)||B(e)}function y(e){return e>=a.LATIN_CAPITAL_A&&e<=a.LATIN_CAPITAL_F}function G(e){return e>=a.LATIN_SMALL_A&&e<=a.LATIN_SMALL_F}function w(e){return e+32}function x(e){return e===a.SPACE||e===a.LINE_FEED||e===a.TABULATION||e===a.FORM_FEED}function Y(e){return x(e)||e===a.SOLIDUS||e===a.GREATER_THAN_SIGN}class v{constructor(e,t){this.options=e,this.handler=t,this.paused=!1,this.inLoop=!1,this.inForeignNode=!1,this.lastStartTagName="",this.active=!1,this.state=k.DATA,this.returnState=k.DATA,this.charRefCode=-1,this.consumedAfterSnapshot=-1,this.currentCharacterToken=null,this.currentToken=null,this.currentAttr={name:"",value:""},this.preprocessor=new _(t),this.currentLocation=this.getCurrentLocation(-1);}_err(e){var t,s;null===(s=(t=this.handler).onParseError)||void 0===s||s.call(t,this.preprocessor.getError(e));}getCurrentLocation(e){return this.options.sourceCodeLocationInfo?{startLine:this.preprocessor.line,startCol:this.preprocessor.col-e,startOffset:this.preprocessor.offset-e,endLine:-1,endCol:-1,endOffset:-1}:null}_runParsingLoop(){if(!this.inLoop){for(this.inLoop=!0;this.active&&!this.paused;){this.consumedAfterSnapshot=0;const e=this._consume();this._ensureHibernation()||this._callState(e);}this.inLoop=!1;}}pause(){this.paused=!0;}resume(e){if(!this.paused)throw new Error("Parser was already resumed");this.paused=!1,this.inLoop||(this._runParsingLoop(),this.paused||null==e||e());}write(e,t,s){this.active=!0,this.preprocessor.write(e,t),this._runParsingLoop(),this.paused||null==s||s();}insertHtmlAtCurrentPos(e){this.active=!0,this.preprocessor.insertHtmlAtCurrentPos(e),this._runParsingLoop();}_ensureHibernation(){return !!this.preprocessor.endOfChunkHit&&(this._unconsume(this.consumedAfterSnapshot),this.active=!1,!0)}_consume(){return this.consumedAfterSnapshot++,this.preprocessor.advance()}_unconsume(e){this.consumedAfterSnapshot-=e,this.preprocessor.retreat(e);}_reconsumeInState(e,t){this.state=e,this._callState(t);}_advanceBy(e){this.consumedAfterSnapshot+=e;for(let t=0;t<e;t++)this.preprocessor.advance();}_consumeSequenceIfMatch(e,t){return !!this.preprocessor.startsWith(e,t)&&(this._advanceBy(e.length-1),!0)}_createStartTagToken(){this.currentToken={type:h.START_TAG,tagName:"",tagID:I.UNKNOWN,selfClosing:!1,ackSelfClosing:!1,attrs:[],location:this.getCurrentLocation(1)};}_createEndTagToken(){this.currentToken={type:h.END_TAG,tagName:"",tagID:I.UNKNOWN,selfClosing:!1,ackSelfClosing:!1,attrs:[],location:this.getCurrentLocation(2)};}_createCommentToken(e){this.currentToken={type:h.COMMENT,data:"",location:this.getCurrentLocation(e)};}_createDoctypeToken(e){this.currentToken={type:h.DOCTYPE,name:e,forceQuirks:!1,publicId:null,systemId:null,location:this.currentLocation};}_createCharacterToken(e,t){this.currentCharacterToken={type:e,chars:t,location:this.currentLocation};}_createAttr(e){this.currentAttr={name:e,value:""},this.currentLocation=this.getCurrentLocation(0);}_leaveAttrName(){var e,t;const s=this.currentToken;null===A(s,this.currentAttr.name)?(s.attrs.push(this.currentAttr),s.location&&this.currentLocation&&((null!==(e=(t=s.location).attrs)&&void 0!==e?e:t.attrs=Object.create(null))[this.currentAttr.name]=this.currentLocation,this._leaveAttrValue())):this._err(T.duplicateAttribute);}_leaveAttrValue(){this.currentLocation&&(this.currentLocation.endLine=this.preprocessor.line,this.currentLocation.endCol=this.preprocessor.col,this.currentLocation.endOffset=this.preprocessor.offset);}prepareToken(e){this._emitCurrentCharacterToken(e.location),this.currentToken=null,e.location&&(e.location.endLine=this.preprocessor.line,e.location.endCol=this.preprocessor.col+1,e.location.endOffset=this.preprocessor.offset+1),this.currentLocation=this.getCurrentLocation(-1);}emitCurrentTagToken(){const e=this.currentToken;this.prepareToken(e),e.tagID=f(e.tagName),e.type===h.START_TAG?(this.lastStartTagName=e.tagName,this.handler.onStartTag(e)):(e.attrs.length>0&&this._err(T.endTagWithAttributes),e.selfClosing&&this._err(T.endTagWithTrailingSolidus),this.handler.onEndTag(e)),this.preprocessor.dropParsedChunk();}emitCurrentComment(e){this.prepareToken(e),this.handler.onComment(e),this.preprocessor.dropParsedChunk();}emitCurrentDoctype(e){this.prepareToken(e),this.handler.onDoctype(e),this.preprocessor.dropParsedChunk();}_emitCurrentCharacterToken(e){if(this.currentCharacterToken){switch(e&&this.currentCharacterToken.location&&(this.currentCharacterToken.location.endLine=e.startLine,this.currentCharacterToken.location.endCol=e.startCol,this.currentCharacterToken.location.endOffset=e.startOffset),this.currentCharacterToken.type){case h.CHARACTER:this.handler.onCharacter(this.currentCharacterToken);break;case h.NULL_CHARACTER:this.handler.onNullCharacter(this.currentCharacterToken);break;case h.WHITESPACE_CHARACTER:this.handler.onWhitespaceCharacter(this.currentCharacterToken);}this.currentCharacterToken=null;}}_emitEOFToken(){const e=this.getCurrentLocation(0);e&&(e.endLine=e.startLine,e.endCol=e.startCol,e.endOffset=e.startOffset),this._emitCurrentCharacterToken(e),this.handler.onEof({type:h.EOF,location:e}),this.active=!1;}_appendCharToCurrentCharacterToken(e,t){if(this.currentCharacterToken){if(this.currentCharacterToken.type===e)return void(this.currentCharacterToken.chars+=t);this.currentLocation=this.getCurrentLocation(0),this._emitCurrentCharacterToken(this.currentLocation),this.preprocessor.dropParsedChunk();}this._createCharacterToken(e,t);}_emitCodePoint(e){const t=x(e)?h.WHITESPACE_CHARACTER:e===a.NULL?h.NULL_CHARACTER:h.CHARACTER;this._appendCharToCurrentCharacterToken(t,String.fromCodePoint(e));}_emitChars(e){this._appendCharToCurrentCharacterToken(h.CHARACTER,e);}_matchNamedCharacterReference(e){let t=null,s=0,r=!1;for(let i=0,o=R.htmlDecodeTree[0];i>=0&&(i=R.determineBranch(R.htmlDecodeTree,o,i+1,e),!(i<0));e=this._consume()){s+=1,o=R.htmlDecodeTree[i];const c=o&R.BinTrieFlags.VALUE_LENGTH;if(c){const o=(c>>14)-1;if(e!==a.SEMICOLON&&this._isCharacterReferenceInAttribute()&&((n=this.preprocessor.peek(1))===a.EQUALS_SIGN||U(n))?(t=[a.AMPERSAND],i+=o):(t=0===o?[R.htmlDecodeTree[i]&~R.BinTrieFlags.VALUE_LENGTH]:1===o?[R.htmlDecodeTree[++i]]:[R.htmlDecodeTree[++i],R.htmlDecodeTree[++i]],s=0,r=e!==a.SEMICOLON),0===o){this._consume();break}}}var n;return this._unconsume(s),r&&!this.preprocessor.endOfChunkHit&&this._err(T.missingSemicolonAfterCharacterReference),this._unconsume(1),t}_isCharacterReferenceInAttribute(){return this.returnState===k.ATTRIBUTE_VALUE_DOUBLE_QUOTED||this.returnState===k.ATTRIBUTE_VALUE_SINGLE_QUOTED||this.returnState===k.ATTRIBUTE_VALUE_UNQUOTED}_flushCodePointConsumedAsCharacterReference(e){this._isCharacterReferenceInAttribute()?this.currentAttr.value+=String.fromCodePoint(e):this._emitCodePoint(e);}_callState(e){switch(this.state){case k.DATA:this._stateData(e);break;case k.RCDATA:this._stateRcdata(e);break;case k.RAWTEXT:this._stateRawtext(e);break;case k.SCRIPT_DATA:this._stateScriptData(e);break;case k.PLAINTEXT:this._statePlaintext(e);break;case k.TAG_OPEN:this._stateTagOpen(e);break;case k.END_TAG_OPEN:this._stateEndTagOpen(e);break;case k.TAG_NAME:this._stateTagName(e);break;case k.RCDATA_LESS_THAN_SIGN:this._stateRcdataLessThanSign(e);break;case k.RCDATA_END_TAG_OPEN:this._stateRcdataEndTagOpen(e);break;case k.RCDATA_END_TAG_NAME:this._stateRcdataEndTagName(e);break;case k.RAWTEXT_LESS_THAN_SIGN:this._stateRawtextLessThanSign(e);break;case k.RAWTEXT_END_TAG_OPEN:this._stateRawtextEndTagOpen(e);break;case k.RAWTEXT_END_TAG_NAME:this._stateRawtextEndTagName(e);break;case k.SCRIPT_DATA_LESS_THAN_SIGN:this._stateScriptDataLessThanSign(e);break;case k.SCRIPT_DATA_END_TAG_OPEN:this._stateScriptDataEndTagOpen(e);break;case k.SCRIPT_DATA_END_TAG_NAME:this._stateScriptDataEndTagName(e);break;case k.SCRIPT_DATA_ESCAPE_START:this._stateScriptDataEscapeStart(e);break;case k.SCRIPT_DATA_ESCAPE_START_DASH:this._stateScriptDataEscapeStartDash(e);break;case k.SCRIPT_DATA_ESCAPED:this._stateScriptDataEscaped(e);break;case k.SCRIPT_DATA_ESCAPED_DASH:this._stateScriptDataEscapedDash(e);break;case k.SCRIPT_DATA_ESCAPED_DASH_DASH:this._stateScriptDataEscapedDashDash(e);break;case k.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN:this._stateScriptDataEscapedLessThanSign(e);break;case k.SCRIPT_DATA_ESCAPED_END_TAG_OPEN:this._stateScriptDataEscapedEndTagOpen(e);break;case k.SCRIPT_DATA_ESCAPED_END_TAG_NAME:this._stateScriptDataEscapedEndTagName(e);break;case k.SCRIPT_DATA_DOUBLE_ESCAPE_START:this._stateScriptDataDoubleEscapeStart(e);break;case k.SCRIPT_DATA_DOUBLE_ESCAPED:this._stateScriptDataDoubleEscaped(e);break;case k.SCRIPT_DATA_DOUBLE_ESCAPED_DASH:this._stateScriptDataDoubleEscapedDash(e);break;case k.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH:this._stateScriptDataDoubleEscapedDashDash(e);break;case k.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN:this._stateScriptDataDoubleEscapedLessThanSign(e);break;case k.SCRIPT_DATA_DOUBLE_ESCAPE_END:this._stateScriptDataDoubleEscapeEnd(e);break;case k.BEFORE_ATTRIBUTE_NAME:this._stateBeforeAttributeName(e);break;case k.ATTRIBUTE_NAME:this._stateAttributeName(e);break;case k.AFTER_ATTRIBUTE_NAME:this._stateAfterAttributeName(e);break;case k.BEFORE_ATTRIBUTE_VALUE:this._stateBeforeAttributeValue(e);break;case k.ATTRIBUTE_VALUE_DOUBLE_QUOTED:this._stateAttributeValueDoubleQuoted(e);break;case k.ATTRIBUTE_VALUE_SINGLE_QUOTED:this._stateAttributeValueSingleQuoted(e);break;case k.ATTRIBUTE_VALUE_UNQUOTED:this._stateAttributeValueUnquoted(e);break;case k.AFTER_ATTRIBUTE_VALUE_QUOTED:this._stateAfterAttributeValueQuoted(e);break;case k.SELF_CLOSING_START_TAG:this._stateSelfClosingStartTag(e);break;case k.BOGUS_COMMENT:this._stateBogusComment(e);break;case k.MARKUP_DECLARATION_OPEN:this._stateMarkupDeclarationOpen(e);break;case k.COMMENT_START:this._stateCommentStart(e);break;case k.COMMENT_START_DASH:this._stateCommentStartDash(e);break;case k.COMMENT:this._stateComment(e);break;case k.COMMENT_LESS_THAN_SIGN:this._stateCommentLessThanSign(e);break;case k.COMMENT_LESS_THAN_SIGN_BANG:this._stateCommentLessThanSignBang(e);break;case k.COMMENT_LESS_THAN_SIGN_BANG_DASH:this._stateCommentLessThanSignBangDash(e);break;case k.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH:this._stateCommentLessThanSignBangDashDash(e);break;case k.COMMENT_END_DASH:this._stateCommentEndDash(e);break;case k.COMMENT_END:this._stateCommentEnd(e);break;case k.COMMENT_END_BANG:this._stateCommentEndBang(e);break;case k.DOCTYPE:this._stateDoctype(e);break;case k.BEFORE_DOCTYPE_NAME:this._stateBeforeDoctypeName(e);break;case k.DOCTYPE_NAME:this._stateDoctypeName(e);break;case k.AFTER_DOCTYPE_NAME:this._stateAfterDoctypeName(e);break;case k.AFTER_DOCTYPE_PUBLIC_KEYWORD:this._stateAfterDoctypePublicKeyword(e);break;case k.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:this._stateBeforeDoctypePublicIdentifier(e);break;case k.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:this._stateDoctypePublicIdentifierDoubleQuoted(e);break;case k.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:this._stateDoctypePublicIdentifierSingleQuoted(e);break;case k.AFTER_DOCTYPE_PUBLIC_IDENTIFIER:this._stateAfterDoctypePublicIdentifier(e);break;case k.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS:this._stateBetweenDoctypePublicAndSystemIdentifiers(e);break;case k.AFTER_DOCTYPE_SYSTEM_KEYWORD:this._stateAfterDoctypeSystemKeyword(e);break;case k.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:this._stateBeforeDoctypeSystemIdentifier(e);break;case k.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:this._stateDoctypeSystemIdentifierDoubleQuoted(e);break;case k.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:this._stateDoctypeSystemIdentifierSingleQuoted(e);break;case k.AFTER_DOCTYPE_SYSTEM_IDENTIFIER:this._stateAfterDoctypeSystemIdentifier(e);break;case k.BOGUS_DOCTYPE:this._stateBogusDoctype(e);break;case k.CDATA_SECTION:this._stateCdataSection(e);break;case k.CDATA_SECTION_BRACKET:this._stateCdataSectionBracket(e);break;case k.CDATA_SECTION_END:this._stateCdataSectionEnd(e);break;case k.CHARACTER_REFERENCE:this._stateCharacterReference(e);break;case k.NAMED_CHARACTER_REFERENCE:this._stateNamedCharacterReference(e);break;case k.AMBIGUOUS_AMPERSAND:this._stateAmbiguousAmpersand(e);break;case k.NUMERIC_CHARACTER_REFERENCE:this._stateNumericCharacterReference(e);break;case k.HEXADEMICAL_CHARACTER_REFERENCE_START:this._stateHexademicalCharacterReferenceStart(e);break;case k.HEXADEMICAL_CHARACTER_REFERENCE:this._stateHexademicalCharacterReference(e);break;case k.DECIMAL_CHARACTER_REFERENCE:this._stateDecimalCharacterReference(e);break;case k.NUMERIC_CHARACTER_REFERENCE_END:this._stateNumericCharacterReferenceEnd(e);break;default:throw new Error("Unknown state")}}_stateData(e){switch(e){case a.LESS_THAN_SIGN:this.state=k.TAG_OPEN;break;case a.AMPERSAND:this.returnState=k.DATA,this.state=k.CHARACTER_REFERENCE;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitCodePoint(e);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateRcdata(e){switch(e){case a.AMPERSAND:this.returnState=k.RCDATA,this.state=k.CHARACTER_REFERENCE;break;case a.LESS_THAN_SIGN:this.state=k.RCDATA_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateRawtext(e){switch(e){case a.LESS_THAN_SIGN:this.state=k.RAWTEXT_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateScriptData(e){switch(e){case a.LESS_THAN_SIGN:this.state=k.SCRIPT_DATA_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_statePlaintext(e){switch(e){case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateTagOpen(e){if(F(e))this._createStartTagToken(),this.state=k.TAG_NAME,this._stateTagName(e);else switch(e){case a.EXCLAMATION_MARK:this.state=k.MARKUP_DECLARATION_OPEN;break;case a.SOLIDUS:this.state=k.END_TAG_OPEN;break;case a.QUESTION_MARK:this._err(T.unexpectedQuestionMarkInsteadOfTagName),this._createCommentToken(1),this.state=k.BOGUS_COMMENT,this._stateBogusComment(e);break;case a.EOF:this._err(T.eofBeforeTagName),this._emitChars("<"),this._emitEOFToken();break;default:this._err(T.invalidFirstCharacterOfTagName),this._emitChars("<"),this.state=k.DATA,this._stateData(e);}}_stateEndTagOpen(e){if(F(e))this._createEndTagToken(),this.state=k.TAG_NAME,this._stateTagName(e);else switch(e){case a.GREATER_THAN_SIGN:this._err(T.missingEndTagName),this.state=k.DATA;break;case a.EOF:this._err(T.eofBeforeTagName),this._emitChars("</"),this._emitEOFToken();break;default:this._err(T.invalidFirstCharacterOfTagName),this._createCommentToken(2),this.state=k.BOGUS_COMMENT,this._stateBogusComment(e);}}_stateTagName(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=k.BEFORE_ATTRIBUTE_NAME;break;case a.SOLIDUS:this.state=k.SELF_CLOSING_START_TAG;break;case a.GREATER_THAN_SIGN:this.state=k.DATA,this.emitCurrentTagToken();break;case a.NULL:this._err(T.unexpectedNullCharacter),t.tagName+=s;break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:t.tagName+=String.fromCodePoint(H(e)?w(e):e);}}_stateRcdataLessThanSign(e){e===a.SOLIDUS?this.state=k.RCDATA_END_TAG_OPEN:(this._emitChars("<"),this.state=k.RCDATA,this._stateRcdata(e));}_stateRcdataEndTagOpen(e){F(e)?(this.state=k.RCDATA_END_TAG_NAME,this._stateRcdataEndTagName(e)):(this._emitChars("</"),this.state=k.RCDATA,this._stateRcdata(e));}handleSpecialEndTag(e){if(!this.preprocessor.startsWith(this.lastStartTagName,!1))return !this._ensureHibernation();switch(this._createEndTagToken(),this.currentToken.tagName=this.lastStartTagName,this.preprocessor.peek(this.lastStartTagName.length)){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:return this._advanceBy(this.lastStartTagName.length),this.state=k.BEFORE_ATTRIBUTE_NAME,!1;case a.SOLIDUS:return this._advanceBy(this.lastStartTagName.length),this.state=k.SELF_CLOSING_START_TAG,!1;case a.GREATER_THAN_SIGN:return this._advanceBy(this.lastStartTagName.length),this.emitCurrentTagToken(),this.state=k.DATA,!1;default:return !this._ensureHibernation()}}_stateRcdataEndTagName(e){this.handleSpecialEndTag(e)&&(this._emitChars("</"),this.state=k.RCDATA,this._stateRcdata(e));}_stateRawtextLessThanSign(e){e===a.SOLIDUS?this.state=k.RAWTEXT_END_TAG_OPEN:(this._emitChars("<"),this.state=k.RAWTEXT,this._stateRawtext(e));}_stateRawtextEndTagOpen(e){F(e)?(this.state=k.RAWTEXT_END_TAG_NAME,this._stateRawtextEndTagName(e)):(this._emitChars("</"),this.state=k.RAWTEXT,this._stateRawtext(e));}_stateRawtextEndTagName(e){this.handleSpecialEndTag(e)&&(this._emitChars("</"),this.state=k.RAWTEXT,this._stateRawtext(e));}_stateScriptDataLessThanSign(e){switch(e){case a.SOLIDUS:this.state=k.SCRIPT_DATA_END_TAG_OPEN;break;case a.EXCLAMATION_MARK:this.state=k.SCRIPT_DATA_ESCAPE_START,this._emitChars("<!");break;default:this._emitChars("<"),this.state=k.SCRIPT_DATA,this._stateScriptData(e);}}_stateScriptDataEndTagOpen(e){F(e)?(this.state=k.SCRIPT_DATA_END_TAG_NAME,this._stateScriptDataEndTagName(e)):(this._emitChars("</"),this.state=k.SCRIPT_DATA,this._stateScriptData(e));}_stateScriptDataEndTagName(e){this.handleSpecialEndTag(e)&&(this._emitChars("</"),this.state=k.SCRIPT_DATA,this._stateScriptData(e));}_stateScriptDataEscapeStart(e){e===a.HYPHEN_MINUS?(this.state=k.SCRIPT_DATA_ESCAPE_START_DASH,this._emitChars("-")):(this.state=k.SCRIPT_DATA,this._stateScriptData(e));}_stateScriptDataEscapeStartDash(e){e===a.HYPHEN_MINUS?(this.state=k.SCRIPT_DATA_ESCAPED_DASH_DASH,this._emitChars("-")):(this.state=k.SCRIPT_DATA,this._stateScriptData(e));}_stateScriptDataEscaped(e){switch(e){case a.HYPHEN_MINUS:this.state=k.SCRIPT_DATA_ESCAPED_DASH,this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=k.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateScriptDataEscapedDash(e){switch(e){case a.HYPHEN_MINUS:this.state=k.SCRIPT_DATA_ESCAPED_DASH_DASH,this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=k.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this.state=k.SCRIPT_DATA_ESCAPED,this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this.state=k.SCRIPT_DATA_ESCAPED,this._emitCodePoint(e);}}_stateScriptDataEscapedDashDash(e){switch(e){case a.HYPHEN_MINUS:this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=k.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;break;case a.GREATER_THAN_SIGN:this.state=k.SCRIPT_DATA,this._emitChars(">");break;case a.NULL:this._err(T.unexpectedNullCharacter),this.state=k.SCRIPT_DATA_ESCAPED,this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this.state=k.SCRIPT_DATA_ESCAPED,this._emitCodePoint(e);}}_stateScriptDataEscapedLessThanSign(e){e===a.SOLIDUS?this.state=k.SCRIPT_DATA_ESCAPED_END_TAG_OPEN:F(e)?(this._emitChars("<"),this.state=k.SCRIPT_DATA_DOUBLE_ESCAPE_START,this._stateScriptDataDoubleEscapeStart(e)):(this._emitChars("<"),this.state=k.SCRIPT_DATA_ESCAPED,this._stateScriptDataEscaped(e));}_stateScriptDataEscapedEndTagOpen(e){F(e)?(this.state=k.SCRIPT_DATA_ESCAPED_END_TAG_NAME,this._stateScriptDataEscapedEndTagName(e)):(this._emitChars("</"),this.state=k.SCRIPT_DATA_ESCAPED,this._stateScriptDataEscaped(e));}_stateScriptDataEscapedEndTagName(e){this.handleSpecialEndTag(e)&&(this._emitChars("</"),this.state=k.SCRIPT_DATA_ESCAPED,this._stateScriptDataEscaped(e));}_stateScriptDataDoubleEscapeStart(e){if(this.preprocessor.startsWith(i,!1)&&Y(this.preprocessor.peek(6))){this._emitCodePoint(e);for(let e=0;e<6;e++)this._emitCodePoint(this._consume());this.state=k.SCRIPT_DATA_DOUBLE_ESCAPED;}else this._ensureHibernation()||(this.state=k.SCRIPT_DATA_ESCAPED,this._stateScriptDataEscaped(e));}_stateScriptDataDoubleEscaped(e){switch(e){case a.HYPHEN_MINUS:this.state=k.SCRIPT_DATA_DOUBLE_ESCAPED_DASH,this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=k.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,this._emitChars("<");break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateScriptDataDoubleEscapedDash(e){switch(e){case a.HYPHEN_MINUS:this.state=k.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH,this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=k.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,this._emitChars("<");break;case a.NULL:this._err(T.unexpectedNullCharacter),this.state=k.SCRIPT_DATA_DOUBLE_ESCAPED,this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this.state=k.SCRIPT_DATA_DOUBLE_ESCAPED,this._emitCodePoint(e);}}_stateScriptDataDoubleEscapedDashDash(e){switch(e){case a.HYPHEN_MINUS:this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=k.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,this._emitChars("<");break;case a.GREATER_THAN_SIGN:this.state=k.SCRIPT_DATA,this._emitChars(">");break;case a.NULL:this._err(T.unexpectedNullCharacter),this.state=k.SCRIPT_DATA_DOUBLE_ESCAPED,this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this.state=k.SCRIPT_DATA_DOUBLE_ESCAPED,this._emitCodePoint(e);}}_stateScriptDataDoubleEscapedLessThanSign(e){e===a.SOLIDUS?(this.state=k.SCRIPT_DATA_DOUBLE_ESCAPE_END,this._emitChars("/")):(this.state=k.SCRIPT_DATA_DOUBLE_ESCAPED,this._stateScriptDataDoubleEscaped(e));}_stateScriptDataDoubleEscapeEnd(e){if(this.preprocessor.startsWith(i,!1)&&Y(this.preprocessor.peek(6))){this._emitCodePoint(e);for(let e=0;e<6;e++)this._emitCodePoint(this._consume());this.state=k.SCRIPT_DATA_ESCAPED;}else this._ensureHibernation()||(this.state=k.SCRIPT_DATA_DOUBLE_ESCAPED,this._stateScriptDataDoubleEscaped(e));}_stateBeforeAttributeName(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.SOLIDUS:case a.GREATER_THAN_SIGN:case a.EOF:this.state=k.AFTER_ATTRIBUTE_NAME,this._stateAfterAttributeName(e);break;case a.EQUALS_SIGN:this._err(T.unexpectedEqualsSignBeforeAttributeName),this._createAttr("="),this.state=k.ATTRIBUTE_NAME;break;default:this._createAttr(""),this.state=k.ATTRIBUTE_NAME,this._stateAttributeName(e);}}_stateAttributeName(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:case a.SOLIDUS:case a.GREATER_THAN_SIGN:case a.EOF:this._leaveAttrName(),this.state=k.AFTER_ATTRIBUTE_NAME,this._stateAfterAttributeName(e);break;case a.EQUALS_SIGN:this._leaveAttrName(),this.state=k.BEFORE_ATTRIBUTE_VALUE;break;case a.QUOTATION_MARK:case a.APOSTROPHE:case a.LESS_THAN_SIGN:this._err(T.unexpectedCharacterInAttributeName),this.currentAttr.name+=String.fromCodePoint(e);break;case a.NULL:this._err(T.unexpectedNullCharacter),this.currentAttr.name+=s;break;default:this.currentAttr.name+=String.fromCodePoint(H(e)?w(e):e);}}_stateAfterAttributeName(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.SOLIDUS:this.state=k.SELF_CLOSING_START_TAG;break;case a.EQUALS_SIGN:this.state=k.BEFORE_ATTRIBUTE_VALUE;break;case a.GREATER_THAN_SIGN:this.state=k.DATA,this.emitCurrentTagToken();break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this._createAttr(""),this.state=k.ATTRIBUTE_NAME,this._stateAttributeName(e);}}_stateBeforeAttributeValue(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.QUOTATION_MARK:this.state=k.ATTRIBUTE_VALUE_DOUBLE_QUOTED;break;case a.APOSTROPHE:this.state=k.ATTRIBUTE_VALUE_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingAttributeValue),this.state=k.DATA,this.emitCurrentTagToken();break;default:this.state=k.ATTRIBUTE_VALUE_UNQUOTED,this._stateAttributeValueUnquoted(e);}}_stateAttributeValueDoubleQuoted(e){switch(e){case a.QUOTATION_MARK:this.state=k.AFTER_ATTRIBUTE_VALUE_QUOTED;break;case a.AMPERSAND:this.returnState=k.ATTRIBUTE_VALUE_DOUBLE_QUOTED,this.state=k.CHARACTER_REFERENCE;break;case a.NULL:this._err(T.unexpectedNullCharacter),this.currentAttr.value+=s;break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this.currentAttr.value+=String.fromCodePoint(e);}}_stateAttributeValueSingleQuoted(e){switch(e){case a.APOSTROPHE:this.state=k.AFTER_ATTRIBUTE_VALUE_QUOTED;break;case a.AMPERSAND:this.returnState=k.ATTRIBUTE_VALUE_SINGLE_QUOTED,this.state=k.CHARACTER_REFERENCE;break;case a.NULL:this._err(T.unexpectedNullCharacter),this.currentAttr.value+=s;break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this.currentAttr.value+=String.fromCodePoint(e);}}_stateAttributeValueUnquoted(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this._leaveAttrValue(),this.state=k.BEFORE_ATTRIBUTE_NAME;break;case a.AMPERSAND:this.returnState=k.ATTRIBUTE_VALUE_UNQUOTED,this.state=k.CHARACTER_REFERENCE;break;case a.GREATER_THAN_SIGN:this._leaveAttrValue(),this.state=k.DATA,this.emitCurrentTagToken();break;case a.NULL:this._err(T.unexpectedNullCharacter),this.currentAttr.value+=s;break;case a.QUOTATION_MARK:case a.APOSTROPHE:case a.LESS_THAN_SIGN:case a.EQUALS_SIGN:case a.GRAVE_ACCENT:this._err(T.unexpectedCharacterInUnquotedAttributeValue),this.currentAttr.value+=String.fromCodePoint(e);break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this.currentAttr.value+=String.fromCodePoint(e);}}_stateAfterAttributeValueQuoted(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this._leaveAttrValue(),this.state=k.BEFORE_ATTRIBUTE_NAME;break;case a.SOLIDUS:this._leaveAttrValue(),this.state=k.SELF_CLOSING_START_TAG;break;case a.GREATER_THAN_SIGN:this._leaveAttrValue(),this.state=k.DATA,this.emitCurrentTagToken();break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this._err(T.missingWhitespaceBetweenAttributes),this.state=k.BEFORE_ATTRIBUTE_NAME,this._stateBeforeAttributeName(e);}}_stateSelfClosingStartTag(e){switch(e){case a.GREATER_THAN_SIGN:this.currentToken.selfClosing=!0,this.state=k.DATA,this.emitCurrentTagToken();break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this._err(T.unexpectedSolidusInTag),this.state=k.BEFORE_ATTRIBUTE_NAME,this._stateBeforeAttributeName(e);}}_stateBogusComment(e){const t=this.currentToken;switch(e){case a.GREATER_THAN_SIGN:this.state=k.DATA,this.emitCurrentComment(t);break;case a.EOF:this.emitCurrentComment(t),this._emitEOFToken();break;case a.NULL:this._err(T.unexpectedNullCharacter),t.data+=s;break;default:t.data+=String.fromCodePoint(e);}}_stateMarkupDeclarationOpen(e){this._consumeSequenceIfMatch("--",!0)?(this._createCommentToken(3),this.state=k.COMMENT_START):this._consumeSequenceIfMatch(n,!1)?(this.currentLocation=this.getCurrentLocation(8),this.state=k.DOCTYPE):this._consumeSequenceIfMatch(r,!0)?this.inForeignNode?this.state=k.CDATA_SECTION:(this._err(T.cdataInHtmlContent),this._createCommentToken(8),this.currentToken.data="[CDATA[",this.state=k.BOGUS_COMMENT):this._ensureHibernation()||(this._err(T.incorrectlyOpenedComment),this._createCommentToken(2),this.state=k.BOGUS_COMMENT,this._stateBogusComment(e));}_stateCommentStart(e){switch(e){case a.HYPHEN_MINUS:this.state=k.COMMENT_START_DASH;break;case a.GREATER_THAN_SIGN:{this._err(T.abruptClosingOfEmptyComment),this.state=k.DATA;const e=this.currentToken;this.emitCurrentComment(e);break}default:this.state=k.COMMENT,this._stateComment(e);}}_stateCommentStartDash(e){const t=this.currentToken;switch(e){case a.HYPHEN_MINUS:this.state=k.COMMENT_END;break;case a.GREATER_THAN_SIGN:this._err(T.abruptClosingOfEmptyComment),this.state=k.DATA,this.emitCurrentComment(t);break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+="-",this.state=k.COMMENT,this._stateComment(e);}}_stateComment(e){const t=this.currentToken;switch(e){case a.HYPHEN_MINUS:this.state=k.COMMENT_END_DASH;break;case a.LESS_THAN_SIGN:t.data+="<",this.state=k.COMMENT_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.data+=s;break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+=String.fromCodePoint(e);}}_stateCommentLessThanSign(e){const t=this.currentToken;switch(e){case a.EXCLAMATION_MARK:t.data+="!",this.state=k.COMMENT_LESS_THAN_SIGN_BANG;break;case a.LESS_THAN_SIGN:t.data+="<";break;default:this.state=k.COMMENT,this._stateComment(e);}}_stateCommentLessThanSignBang(e){e===a.HYPHEN_MINUS?this.state=k.COMMENT_LESS_THAN_SIGN_BANG_DASH:(this.state=k.COMMENT,this._stateComment(e));}_stateCommentLessThanSignBangDash(e){e===a.HYPHEN_MINUS?this.state=k.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH:(this.state=k.COMMENT_END_DASH,this._stateCommentEndDash(e));}_stateCommentLessThanSignBangDashDash(e){e!==a.GREATER_THAN_SIGN&&e!==a.EOF&&this._err(T.nestedComment),this.state=k.COMMENT_END,this._stateCommentEnd(e);}_stateCommentEndDash(e){const t=this.currentToken;switch(e){case a.HYPHEN_MINUS:this.state=k.COMMENT_END;break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+="-",this.state=k.COMMENT,this._stateComment(e);}}_stateCommentEnd(e){const t=this.currentToken;switch(e){case a.GREATER_THAN_SIGN:this.state=k.DATA,this.emitCurrentComment(t);break;case a.EXCLAMATION_MARK:this.state=k.COMMENT_END_BANG;break;case a.HYPHEN_MINUS:t.data+="-";break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+="--",this.state=k.COMMENT,this._stateComment(e);}}_stateCommentEndBang(e){const t=this.currentToken;switch(e){case a.HYPHEN_MINUS:t.data+="--!",this.state=k.COMMENT_END_DASH;break;case a.GREATER_THAN_SIGN:this._err(T.incorrectlyClosedComment),this.state=k.DATA,this.emitCurrentComment(t);break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+="--!",this.state=k.COMMENT,this._stateComment(e);}}_stateDoctype(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=k.BEFORE_DOCTYPE_NAME;break;case a.GREATER_THAN_SIGN:this.state=k.BEFORE_DOCTYPE_NAME,this._stateBeforeDoctypeName(e);break;case a.EOF:{this._err(T.eofInDoctype),this._createDoctypeToken(null);const e=this.currentToken;e.forceQuirks=!0,this.emitCurrentDoctype(e),this._emitEOFToken();break}default:this._err(T.missingWhitespaceBeforeDoctypeName),this.state=k.BEFORE_DOCTYPE_NAME,this._stateBeforeDoctypeName(e);}}_stateBeforeDoctypeName(e){if(H(e))this._createDoctypeToken(String.fromCharCode(w(e))),this.state=k.DOCTYPE_NAME;else switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.NULL:this._err(T.unexpectedNullCharacter),this._createDoctypeToken(s),this.state=k.DOCTYPE_NAME;break;case a.GREATER_THAN_SIGN:{this._err(T.missingDoctypeName),this._createDoctypeToken(null);const e=this.currentToken;e.forceQuirks=!0,this.emitCurrentDoctype(e),this.state=k.DATA;break}case a.EOF:{this._err(T.eofInDoctype),this._createDoctypeToken(null);const e=this.currentToken;e.forceQuirks=!0,this.emitCurrentDoctype(e),this._emitEOFToken();break}default:this._createDoctypeToken(String.fromCodePoint(e)),this.state=k.DOCTYPE_NAME;}}_stateDoctypeName(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=k.AFTER_DOCTYPE_NAME;break;case a.GREATER_THAN_SIGN:this.state=k.DATA,this.emitCurrentDoctype(t);break;case a.NULL:this._err(T.unexpectedNullCharacter),t.name+=s;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.name+=String.fromCodePoint(H(e)?w(e):e);}}_stateAfterDoctypeName(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.GREATER_THAN_SIGN:this.state=k.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._consumeSequenceIfMatch("public",!1)?this.state=k.AFTER_DOCTYPE_PUBLIC_KEYWORD:this._consumeSequenceIfMatch("system",!1)?this.state=k.AFTER_DOCTYPE_SYSTEM_KEYWORD:this._ensureHibernation()||(this._err(T.invalidCharacterSequenceAfterDoctypeName),t.forceQuirks=!0,this.state=k.BOGUS_DOCTYPE,this._stateBogusDoctype(e));}}_stateAfterDoctypePublicKeyword(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=k.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;break;case a.QUOTATION_MARK:this._err(T.missingWhitespaceAfterDoctypePublicKeyword),t.publicId="",this.state=k.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:this._err(T.missingWhitespaceAfterDoctypePublicKeyword),t.publicId="",this.state=k.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingDoctypePublicIdentifier),t.forceQuirks=!0,this.state=k.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypePublicIdentifier),t.forceQuirks=!0,this.state=k.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateBeforeDoctypePublicIdentifier(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.QUOTATION_MARK:t.publicId="",this.state=k.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:t.publicId="",this.state=k.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingDoctypePublicIdentifier),t.forceQuirks=!0,this.state=k.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypePublicIdentifier),t.forceQuirks=!0,this.state=k.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateDoctypePublicIdentifierDoubleQuoted(e){const t=this.currentToken;switch(e){case a.QUOTATION_MARK:this.state=k.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.publicId+=s;break;case a.GREATER_THAN_SIGN:this._err(T.abruptDoctypePublicIdentifier),t.forceQuirks=!0,this.emitCurrentDoctype(t),this.state=k.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.publicId+=String.fromCodePoint(e);}}_stateDoctypePublicIdentifierSingleQuoted(e){const t=this.currentToken;switch(e){case a.APOSTROPHE:this.state=k.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.publicId+=s;break;case a.GREATER_THAN_SIGN:this._err(T.abruptDoctypePublicIdentifier),t.forceQuirks=!0,this.emitCurrentDoctype(t),this.state=k.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.publicId+=String.fromCodePoint(e);}}_stateAfterDoctypePublicIdentifier(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=k.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;break;case a.GREATER_THAN_SIGN:this.state=k.DATA,this.emitCurrentDoctype(t);break;case a.QUOTATION_MARK:this._err(T.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),t.systemId="",this.state=k.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:this._err(T.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),t.systemId="",this.state=k.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=k.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateBetweenDoctypePublicAndSystemIdentifiers(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.GREATER_THAN_SIGN:this.emitCurrentDoctype(t),this.state=k.DATA;break;case a.QUOTATION_MARK:t.systemId="",this.state=k.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:t.systemId="",this.state=k.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=k.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateAfterDoctypeSystemKeyword(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=k.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;break;case a.QUOTATION_MARK:this._err(T.missingWhitespaceAfterDoctypeSystemKeyword),t.systemId="",this.state=k.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:this._err(T.missingWhitespaceAfterDoctypeSystemKeyword),t.systemId="",this.state=k.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=k.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=k.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateBeforeDoctypeSystemIdentifier(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.QUOTATION_MARK:t.systemId="",this.state=k.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:t.systemId="",this.state=k.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=k.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=k.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateDoctypeSystemIdentifierDoubleQuoted(e){const t=this.currentToken;switch(e){case a.QUOTATION_MARK:this.state=k.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.systemId+=s;break;case a.GREATER_THAN_SIGN:this._err(T.abruptDoctypeSystemIdentifier),t.forceQuirks=!0,this.emitCurrentDoctype(t),this.state=k.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.systemId+=String.fromCodePoint(e);}}_stateDoctypeSystemIdentifierSingleQuoted(e){const t=this.currentToken;switch(e){case a.APOSTROPHE:this.state=k.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.systemId+=s;break;case a.GREATER_THAN_SIGN:this._err(T.abruptDoctypeSystemIdentifier),t.forceQuirks=!0,this.emitCurrentDoctype(t),this.state=k.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.systemId+=String.fromCodePoint(e);}}_stateAfterDoctypeSystemIdentifier(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.GREATER_THAN_SIGN:this.emitCurrentDoctype(t),this.state=k.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.unexpectedCharacterAfterDoctypeSystemIdentifier),this.state=k.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateBogusDoctype(e){const t=this.currentToken;switch(e){case a.GREATER_THAN_SIGN:this.emitCurrentDoctype(t),this.state=k.DATA;break;case a.NULL:this._err(T.unexpectedNullCharacter);break;case a.EOF:this.emitCurrentDoctype(t),this._emitEOFToken();}}_stateCdataSection(e){switch(e){case a.RIGHT_SQUARE_BRACKET:this.state=k.CDATA_SECTION_BRACKET;break;case a.EOF:this._err(T.eofInCdata),this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateCdataSectionBracket(e){e===a.RIGHT_SQUARE_BRACKET?this.state=k.CDATA_SECTION_END:(this._emitChars("]"),this.state=k.CDATA_SECTION,this._stateCdataSection(e));}_stateCdataSectionEnd(e){switch(e){case a.GREATER_THAN_SIGN:this.state=k.DATA;break;case a.RIGHT_SQUARE_BRACKET:this._emitChars("]");break;default:this._emitChars("]]"),this.state=k.CDATA_SECTION,this._stateCdataSection(e);}}_stateCharacterReference(e){e===a.NUMBER_SIGN?this.state=k.NUMERIC_CHARACTER_REFERENCE:U(e)?(this.state=k.NAMED_CHARACTER_REFERENCE,this._stateNamedCharacterReference(e)):(this._flushCodePointConsumedAsCharacterReference(a.AMPERSAND),this._reconsumeInState(this.returnState,e));}_stateNamedCharacterReference(e){const t=this._matchNamedCharacterReference(e);if(this._ensureHibernation());else if(t){for(let e=0;e<t.length;e++)this._flushCodePointConsumedAsCharacterReference(t[e]);this.state=this.returnState;}else this._flushCodePointConsumedAsCharacterReference(a.AMPERSAND),this.state=k.AMBIGUOUS_AMPERSAND;}_stateAmbiguousAmpersand(e){U(e)?this._flushCodePointConsumedAsCharacterReference(e):(e===a.SEMICOLON&&this._err(T.unknownNamedCharacterReference),this._reconsumeInState(this.returnState,e));}_stateNumericCharacterReference(e){this.charRefCode=0,e===a.LATIN_SMALL_X||e===a.LATIN_CAPITAL_X?this.state=k.HEXADEMICAL_CHARACTER_REFERENCE_START:B(e)?(this.state=k.DECIMAL_CHARACTER_REFERENCE,this._stateDecimalCharacterReference(e)):(this._err(T.absenceOfDigitsInNumericCharacterReference),this._flushCodePointConsumedAsCharacterReference(a.AMPERSAND),this._flushCodePointConsumedAsCharacterReference(a.NUMBER_SIGN),this._reconsumeInState(this.returnState,e));}_stateHexademicalCharacterReferenceStart(e){!function(e){return B(e)||y(e)||G(e)}(e)?(this._err(T.absenceOfDigitsInNumericCharacterReference),this._flushCodePointConsumedAsCharacterReference(a.AMPERSAND),this._flushCodePointConsumedAsCharacterReference(a.NUMBER_SIGN),this._unconsume(2),this.state=this.returnState):(this.state=k.HEXADEMICAL_CHARACTER_REFERENCE,this._stateHexademicalCharacterReference(e));}_stateHexademicalCharacterReference(e){y(e)?this.charRefCode=16*this.charRefCode+e-55:G(e)?this.charRefCode=16*this.charRefCode+e-87:B(e)?this.charRefCode=16*this.charRefCode+e-48:e===a.SEMICOLON?this.state=k.NUMERIC_CHARACTER_REFERENCE_END:(this._err(T.missingSemicolonAfterCharacterReference),this.state=k.NUMERIC_CHARACTER_REFERENCE_END,this._stateNumericCharacterReferenceEnd(e));}_stateDecimalCharacterReference(e){B(e)?this.charRefCode=10*this.charRefCode+e-48:e===a.SEMICOLON?this.state=k.NUMERIC_CHARACTER_REFERENCE_END:(this._err(T.missingSemicolonAfterCharacterReference),this.state=k.NUMERIC_CHARACTER_REFERENCE_END,this._stateNumericCharacterReferenceEnd(e));}_stateNumericCharacterReferenceEnd(e){if(this.charRefCode===a.NULL)this._err(T.nullCharacterReference),this.charRefCode=a.REPLACEMENT_CHARACTER;else if(this.charRefCode>1114111)this._err(T.characterReferenceOutsideUnicodeRange),this.charRefCode=a.REPLACEMENT_CHARACTER;else if(o(this.charRefCode))this._err(T.surrogateCharacterReference),this.charRefCode=a.REPLACEMENT_CHARACTER;else if(E(this.charRefCode))this._err(T.noncharacterCharacterReference);else if(c(this.charRefCode)||this.charRefCode===a.CARRIAGE_RETURN){this._err(T.controlCharacterReference);const e=P.get(this.charRefCode);void 0!==e&&(this.charRefCode=e);}this._flushCodePointConsumedAsCharacterReference(this.charRefCode),this._reconsumeInState(this.returnState,e);}}const Q=new Set([I.DD,I.DT,I.LI,I.OPTGROUP,I.OPTION,I.P,I.RB,I.RP,I.RT,I.RTC]),q=new Set([...Q,I.CAPTION,I.COLGROUP,I.TBODY,I.TD,I.TFOOT,I.TH,I.THEAD,I.TR]),W=new Map([[I.APPLET,d.HTML],[I.CAPTION,d.HTML],[I.HTML,d.HTML],[I.MARQUEE,d.HTML],[I.OBJECT,d.HTML],[I.TABLE,d.HTML],[I.TD,d.HTML],[I.TEMPLATE,d.HTML],[I.TH,d.HTML],[I.ANNOTATION_XML,d.MATHML],[I.MI,d.MATHML],[I.MN,d.MATHML],[I.MO,d.MATHML],[I.MS,d.MATHML],[I.MTEXT,d.MATHML],[I.DESC,d.SVG],[I.FOREIGN_OBJECT,d.SVG],[I.TITLE,d.SVG]]),X=[I.H1,I.H2,I.H3,I.H4,I.H5,I.H6],K=[I.TR,I.TEMPLATE,I.HTML],V=[I.TBODY,I.TFOOT,I.THEAD,I.TEMPLATE,I.HTML],j=[I.TABLE,I.TEMPLATE,I.HTML],z=[I.TD,I.TH];class J{get currentTmplContentOrNode(){return this._isInTemplate()?this.treeAdapter.getTemplateContent(this.current):this.current}constructor(e,t,s){this.treeAdapter=t,this.handler=s,this.items=[],this.tagIDs=[],this.stackTop=-1,this.tmplCount=0,this.currentTagId=I.UNKNOWN,this.current=e;}_indexOf(e){return this.items.lastIndexOf(e,this.stackTop)}_isInTemplate(){return this.currentTagId===I.TEMPLATE&&this.treeAdapter.getNamespaceURI(this.current)===d.HTML}_updateCurrentElement(){this.current=this.items[this.stackTop],this.currentTagId=this.tagIDs[this.stackTop];}push(e,t){this.stackTop++,this.items[this.stackTop]=e,this.current=e,this.tagIDs[this.stackTop]=t,this.currentTagId=t,this._isInTemplate()&&this.tmplCount++,this.handler.onItemPush(e,t,!0);}pop(){const e=this.current;this.tmplCount>0&&this._isInTemplate()&&this.tmplCount--,this.stackTop--,this._updateCurrentElement(),this.handler.onItemPop(e,!0);}replace(e,t){const s=this._indexOf(e);this.items[s]=t,s===this.stackTop&&(this.current=t);}insertAfter(e,t,s){const a=this._indexOf(e)+1;this.items.splice(a,0,t),this.tagIDs.splice(a,0,s),this.stackTop++,a===this.stackTop&&this._updateCurrentElement(),this.handler.onItemPush(this.current,this.currentTagId,a===this.stackTop);}popUntilTagNamePopped(e){let t=this.stackTop+1;do{t=this.tagIDs.lastIndexOf(e,t-1);}while(t>0&&this.treeAdapter.getNamespaceURI(this.items[t])!==d.HTML);this.shortenToLength(t<0?0:t);}shortenToLength(e){for(;this.stackTop>=e;){const t=this.current;this.tmplCount>0&&this._isInTemplate()&&(this.tmplCount-=1),this.stackTop--,this._updateCurrentElement(),this.handler.onItemPop(t,this.stackTop<e);}}popUntilElementPopped(e){const t=this._indexOf(e);this.shortenToLength(t<0?0:t);}popUntilPopped(e,t){const s=this._indexOfTagNames(e,t);this.shortenToLength(s<0?0:s);}popUntilNumberedHeaderPopped(){this.popUntilPopped(X,d.HTML);}popUntilTableCellPopped(){this.popUntilPopped(z,d.HTML);}popAllUpToHtmlElement(){this.tmplCount=0,this.shortenToLength(1);}_indexOfTagNames(e,t){for(let s=this.stackTop;s>=0;s--)if(e.includes(this.tagIDs[s])&&this.treeAdapter.getNamespaceURI(this.items[s])===t)return s;return -1}clearBackTo(e,t){const s=this._indexOfTagNames(e,t);this.shortenToLength(s+1);}clearBackToTableContext(){this.clearBackTo(j,d.HTML);}clearBackToTableBodyContext(){this.clearBackTo(V,d.HTML);}clearBackToTableRowContext(){this.clearBackTo(K,d.HTML);}remove(e){const t=this._indexOf(e);t>=0&&(t===this.stackTop?this.pop():(this.items.splice(t,1),this.tagIDs.splice(t,1),this.stackTop--,this._updateCurrentElement(),this.handler.onItemPop(e,!1)));}tryPeekProperlyNestedBodyElement(){return this.stackTop>=1&&this.tagIDs[1]===I.BODY?this.items[1]:null}contains(e){return this._indexOf(e)>-1}getCommonAncestor(e){const t=this._indexOf(e)-1;return t>=0?this.items[t]:null}isRootHtmlElementCurrent(){return 0===this.stackTop&&this.tagIDs[0]===I.HTML}hasInScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t],a=this.treeAdapter.getNamespaceURI(this.items[t]);if(s===e&&a===d.HTML)return !0;if(W.get(s)===a)return !1}return !0}hasNumberedHeaderInScope(){for(let e=this.stackTop;e>=0;e--){const t=this.tagIDs[e],s=this.treeAdapter.getNamespaceURI(this.items[e]);if(g(t)&&s===d.HTML)return !0;if(W.get(t)===s)return !1}return !0}hasInListItemScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t],a=this.treeAdapter.getNamespaceURI(this.items[t]);if(s===e&&a===d.HTML)return !0;if((s===I.UL||s===I.OL)&&a===d.HTML||W.get(s)===a)return !1}return !0}hasInButtonScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t],a=this.treeAdapter.getNamespaceURI(this.items[t]);if(s===e&&a===d.HTML)return !0;if(s===I.BUTTON&&a===d.HTML||W.get(s)===a)return !1}return !0}hasInTableScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t];if(this.treeAdapter.getNamespaceURI(this.items[t])===d.HTML){if(s===e)return !0;if(s===I.TABLE||s===I.TEMPLATE||s===I.HTML)return !1}}return !0}hasTableBodyContextInTableScope(){for(let e=this.stackTop;e>=0;e--){const t=this.tagIDs[e];if(this.treeAdapter.getNamespaceURI(this.items[e])===d.HTML){if(t===I.TBODY||t===I.THEAD||t===I.TFOOT)return !0;if(t===I.TABLE||t===I.HTML)return !1}}return !0}hasInSelectScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t];if(this.treeAdapter.getNamespaceURI(this.items[t])===d.HTML){if(s===e)return !0;if(s!==I.OPTION&&s!==I.OPTGROUP)return !1}}return !0}generateImpliedEndTags(){for(;Q.has(this.currentTagId);)this.pop();}generateImpliedEndTagsThoroughly(){for(;q.has(this.currentTagId);)this.pop();}generateImpliedEndTagsWithExclusion(e){for(;this.currentTagId!==e&&q.has(this.currentTagId);)this.pop();}}var Z;!function(e){e[e.Marker=0]="Marker",e[e.Element=1]="Element";}(Z=Z||(Z={}));const $={type:Z.Marker};class ee{constructor(e){this.treeAdapter=e,this.entries=[],this.bookmark=null;}_getNoahArkConditionCandidates(e,t){const s=[],a=t.length,r=this.treeAdapter.getTagName(e),n=this.treeAdapter.getNamespaceURI(e);for(let e=0;e<this.entries.length;e++){const t=this.entries[e];if(t.type===Z.Marker)break;const{element:i}=t;if(this.treeAdapter.getTagName(i)===r&&this.treeAdapter.getNamespaceURI(i)===n){const t=this.treeAdapter.getAttrList(i);t.length===a&&s.push({idx:e,attrs:t});}}return s}_ensureNoahArkCondition(e){if(this.entries.length<3)return;const t=this.treeAdapter.getAttrList(e),s=this._getNoahArkConditionCandidates(e,t);if(s.length<3)return;const a=new Map(t.map((e=>[e.name,e.value])));let r=0;for(let e=0;e<s.length;e++){const t=s[e];t.attrs.every((e=>a.get(e.name)===e.value))&&(r+=1,r>=3&&this.entries.splice(t.idx,1));}}insertMarker(){this.entries.unshift($);}pushElement(e,t){this._ensureNoahArkCondition(e),this.entries.unshift({type:Z.Element,element:e,token:t});}insertElementAfterBookmark(e,t){const s=this.entries.indexOf(this.bookmark);this.entries.splice(s,0,{type:Z.Element,element:e,token:t});}removeEntry(e){const t=this.entries.indexOf(e);t>=0&&this.entries.splice(t,1);}clearToLastMarker(){const e=this.entries.indexOf($);e>=0?this.entries.splice(0,e+1):this.entries.length=0;}getElementEntryInScopeWithTagName(e){const t=this.entries.find((t=>t.type===Z.Marker||this.treeAdapter.getTagName(t.element)===e));return t&&t.type===Z.Element?t:null}getElementEntry(e){return this.entries.find((t=>t.type===Z.Element&&t.element===e))}}function te(e){return {nodeName:"#text",value:e,parentNode:null}}const se={createDocument:()=>({nodeName:"#document",mode:u.NO_QUIRKS,childNodes:[]}),createDocumentFragment:()=>({nodeName:"#document-fragment",childNodes:[]}),createElement:(e,t,s)=>({nodeName:e,tagName:e,attrs:s,namespaceURI:t,childNodes:[],parentNode:null}),createCommentNode:e=>({nodeName:"#comment",data:e,parentNode:null}),appendChild(e,t){e.childNodes.push(t),t.parentNode=e;},insertBefore(e,t,s){const a=e.childNodes.indexOf(s);e.childNodes.splice(a,0,t),t.parentNode=e;},setTemplateContent(e,t){e.content=t;},getTemplateContent:e=>e.content,setDocumentType(e,t,s,a){const r=e.childNodes.find((e=>"#documentType"===e.nodeName));if(r)r.name=t,r.publicId=s,r.systemId=a;else {const r={nodeName:"#documentType",name:t,publicId:s,systemId:a,parentNode:null};se.appendChild(e,r);}},setDocumentMode(e,t){e.mode=t;},getDocumentMode:e=>e.mode,detachNode(e){if(e.parentNode){const t=e.parentNode.childNodes.indexOf(e);e.parentNode.childNodes.splice(t,1),e.parentNode=null;}},insertText(e,t){if(e.childNodes.length>0){const s=e.childNodes[e.childNodes.length-1];if(se.isTextNode(s))return void(s.value+=t)}se.appendChild(e,te(t));},insertTextBefore(e,t,s){const a=e.childNodes[e.childNodes.indexOf(s)-1];a&&se.isTextNode(a)?a.value+=t:se.insertBefore(e,te(t),s);},adoptAttributes(e,t){const s=new Set(e.attrs.map((e=>e.name)));for(let a=0;a<t.length;a++)s.has(t[a].name)||e.attrs.push(t[a]);},getFirstChild:e=>e.childNodes[0],getChildNodes:e=>e.childNodes,getParentNode:e=>e.parentNode,getAttrList:e=>e.attrs,getTagName:e=>e.tagName,getNamespaceURI:e=>e.namespaceURI,getTextNodeContent:e=>e.value,getCommentNodeContent:e=>e.data,getDocumentTypeNodeName:e=>e.name,getDocumentTypeNodePublicId:e=>e.publicId,getDocumentTypeNodeSystemId:e=>e.systemId,isTextNode:e=>"#text"===e.nodeName,isCommentNode:e=>"#comment"===e.nodeName,isDocumentTypeNode:e=>"#documentType"===e.nodeName,isElementNode:e=>Object.prototype.hasOwnProperty.call(e,"tagName"),setNodeSourceCodeLocation(e,t){e.sourceCodeLocation=t;},getNodeSourceCodeLocation:e=>e.sourceCodeLocation,updateNodeSourceCodeLocation(e,t){e.sourceCodeLocation={...e.sourceCodeLocation,...t};}},ae="html",re=["+//silmaril//dtd html pro v0r11 19970101//","-//as//dtd html 3.0 aswedit + extensions//","-//advasoft ltd//dtd html 3.0 aswedit + extensions//","-//ietf//dtd html 2.0 level 1//","-//ietf//dtd html 2.0 level 2//","-//ietf//dtd html 2.0 strict level 1//","-//ietf//dtd html 2.0 strict level 2//","-//ietf//dtd html 2.0 strict//","-//ietf//dtd html 2.0//","-//ietf//dtd html 2.1e//","-//ietf//dtd html 3.0//","-//ietf//dtd html 3.2 final//","-//ietf//dtd html 3.2//","-//ietf//dtd html 3//","-//ietf//dtd html level 0//","-//ietf//dtd html level 1//","-//ietf//dtd html level 2//","-//ietf//dtd html level 3//","-//ietf//dtd html strict level 0//","-//ietf//dtd html strict level 1//","-//ietf//dtd html strict level 2//","-//ietf//dtd html strict level 3//","-//ietf//dtd html strict//","-//ietf//dtd html//","-//metrius//dtd metrius presentational//","-//microsoft//dtd internet explorer 2.0 html strict//","-//microsoft//dtd internet explorer 2.0 html//","-//microsoft//dtd internet explorer 2.0 tables//","-//microsoft//dtd internet explorer 3.0 html strict//","-//microsoft//dtd internet explorer 3.0 html//","-//microsoft//dtd internet explorer 3.0 tables//","-//netscape comm. corp.//dtd html//","-//netscape comm. corp.//dtd strict html//","-//o'reilly and associates//dtd html 2.0//","-//o'reilly and associates//dtd html extended 1.0//","-//o'reilly and associates//dtd html extended relaxed 1.0//","-//sq//dtd html 2.0 hotmetal + extensions//","-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//","-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//","-//spyglass//dtd html 2.0 extended//","-//sun microsystems corp.//dtd hotjava html//","-//sun microsystems corp.//dtd hotjava strict html//","-//w3c//dtd html 3 1995-03-24//","-//w3c//dtd html 3.2 draft//","-//w3c//dtd html 3.2 final//","-//w3c//dtd html 3.2//","-//w3c//dtd html 3.2s draft//","-//w3c//dtd html 4.0 frameset//","-//w3c//dtd html 4.0 transitional//","-//w3c//dtd html experimental 19960712//","-//w3c//dtd html experimental 970421//","-//w3c//dtd w3 html//","-//w3o//dtd w3 html 3.0//","-//webtechs//dtd mozilla html 2.0//","-//webtechs//dtd mozilla html//"],ne=[...re,"-//w3c//dtd html 4.01 frameset//","-//w3c//dtd html 4.01 transitional//"],ie=new Set(["-//w3o//dtd w3 html strict 3.0//en//","-/w3c/dtd html 4.0 transitional/en","html"]),oe=["-//w3c//dtd xhtml 1.0 frameset//","-//w3c//dtd xhtml 1.0 transitional//"],ce=[...oe,"-//w3c//dtd html 4.01 frameset//","-//w3c//dtd html 4.01 transitional//"];function Ee(e,t){return t.some((t=>e.startsWith(t)))}const Te="text/html",he="application/xhtml+xml",_e="definitionurl",Ae="definitionURL",le=new Map(["attributeName","attributeType","baseFrequency","baseProfile","calcMode","clipPathUnits","diffuseConstant","edgeMode","filterUnits","glyphRef","gradientTransform","gradientUnits","kernelMatrix","kernelUnitLength","keyPoints","keySplines","keyTimes","lengthAdjust","limitingConeAngle","markerHeight","markerUnits","markerWidth","maskContentUnits","maskUnits","numOctaves","pathLength","patternContentUnits","patternTransform","patternUnits","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","preserveAspectRatio","primitiveUnits","refX","refY","repeatCount","repeatDur","requiredExtensions","requiredFeatures","specularConstant","specularExponent","spreadMethod","startOffset","stdDeviation","stitchTiles","surfaceScale","systemLanguage","tableValues","targetX","targetY","textLength","viewBox","viewTarget","xChannelSelector","yChannelSelector","zoomAndPan"].map((e=>[e.toLowerCase(),e]))),me=new Map([["xlink:actuate",{prefix:"xlink",name:"actuate",namespace:d.XLINK}],["xlink:arcrole",{prefix:"xlink",name:"arcrole",namespace:d.XLINK}],["xlink:href",{prefix:"xlink",name:"href",namespace:d.XLINK}],["xlink:role",{prefix:"xlink",name:"role",namespace:d.XLINK}],["xlink:show",{prefix:"xlink",name:"show",namespace:d.XLINK}],["xlink:title",{prefix:"xlink",name:"title",namespace:d.XLINK}],["xlink:type",{prefix:"xlink",name:"type",namespace:d.XLINK}],["xml:base",{prefix:"xml",name:"base",namespace:d.XML}],["xml:lang",{prefix:"xml",name:"lang",namespace:d.XML}],["xml:space",{prefix:"xml",name:"space",namespace:d.XML}],["xmlns",{prefix:"",name:"xmlns",namespace:d.XMLNS}],["xmlns:xlink",{prefix:"xmlns",name:"xlink",namespace:d.XMLNS}]]),de=new Map(["altGlyph","altGlyphDef","altGlyphItem","animateColor","animateMotion","animateTransform","clipPath","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","foreignObject","glyphRef","linearGradient","radialGradient","textPath"].map((e=>[e.toLowerCase(),e]))),pe=new Set([I.B,I.BIG,I.BLOCKQUOTE,I.BODY,I.BR,I.CENTER,I.CODE,I.DD,I.DIV,I.DL,I.DT,I.EM,I.EMBED,I.H1,I.H2,I.H3,I.H4,I.H5,I.H6,I.HEAD,I.HR,I.I,I.IMG,I.LI,I.LISTING,I.MENU,I.META,I.NOBR,I.OL,I.P,I.PRE,I.RUBY,I.S,I.SMALL,I.SPAN,I.STRONG,I.STRIKE,I.SUB,I.SUP,I.TABLE,I.TT,I.U,I.UL,I.VAR]);function ue(e){for(let t=0;t<e.attrs.length;t++)if(e.attrs[t].name===_e){e.attrs[t].name=Ae;break}}function Ne(e){for(let t=0;t<e.attrs.length;t++){const s=le.get(e.attrs[t].name);null!=s&&(e.attrs[t].name=s);}}function Ie(e){for(let t=0;t<e.attrs.length;t++){const s=me.get(e.attrs[t].name);s&&(e.attrs[t].prefix=s.prefix,e.attrs[t].name=s.name,e.attrs[t].namespace=s.namespace);}}const Ce="hidden",Se=8,De=3;var Re;!function(e){e[e.INITIAL=0]="INITIAL",e[e.BEFORE_HTML=1]="BEFORE_HTML",e[e.BEFORE_HEAD=2]="BEFORE_HEAD",e[e.IN_HEAD=3]="IN_HEAD",e[e.IN_HEAD_NO_SCRIPT=4]="IN_HEAD_NO_SCRIPT",e[e.AFTER_HEAD=5]="AFTER_HEAD",e[e.IN_BODY=6]="IN_BODY",e[e.TEXT=7]="TEXT",e[e.IN_TABLE=8]="IN_TABLE",e[e.IN_TABLE_TEXT=9]="IN_TABLE_TEXT",e[e.IN_CAPTION=10]="IN_CAPTION",e[e.IN_COLUMN_GROUP=11]="IN_COLUMN_GROUP",e[e.IN_TABLE_BODY=12]="IN_TABLE_BODY",e[e.IN_ROW=13]="IN_ROW",e[e.IN_CELL=14]="IN_CELL",e[e.IN_SELECT=15]="IN_SELECT",e[e.IN_SELECT_IN_TABLE=16]="IN_SELECT_IN_TABLE",e[e.IN_TEMPLATE=17]="IN_TEMPLATE",e[e.AFTER_BODY=18]="AFTER_BODY",e[e.IN_FRAMESET=19]="IN_FRAMESET",e[e.AFTER_FRAMESET=20]="AFTER_FRAMESET",e[e.AFTER_AFTER_BODY=21]="AFTER_AFTER_BODY",e[e.AFTER_AFTER_FRAMESET=22]="AFTER_AFTER_FRAMESET";}(Re||(Re={}));const Oe={startLine:-1,startCol:-1,startOffset:-1,endLine:-1,endCol:-1,endOffset:-1},fe=new Set([I.TABLE,I.TBODY,I.TFOOT,I.THEAD,I.TR]),Le={scriptingEnabled:!0,sourceCodeLocationInfo:!1,treeAdapter:se,onParseError:null};class Me{constructor(e,t,s=null,a=null){this.fragmentContext=s,this.scriptHandler=a,this.currentToken=null,this.stopped=!1,this.insertionMode=Re.INITIAL,this.originalInsertionMode=Re.INITIAL,this.headElement=null,this.formElement=null,this.currentNotInHTML=!1,this.tmplInsertionModeStack=[],this.pendingCharacterTokens=[],this.hasNonWhitespacePendingCharacterToken=!1,this.framesetOk=!0,this.skipNextNewLine=!1,this.fosterParentingEnabled=!1,this.options={...Le,...e},this.treeAdapter=this.options.treeAdapter,this.onParseError=this.options.onParseError,this.onParseError&&(this.options.sourceCodeLocationInfo=!0),this.document=null!=t?t:this.treeAdapter.createDocument(),this.tokenizer=new v(this.options,this),this.activeFormattingElements=new ee(this.treeAdapter),this.fragmentContextID=s?f(this.treeAdapter.getTagName(s)):I.UNKNOWN,this._setContextModes(null!=s?s:this.document,this.fragmentContextID),this.openElements=new J(this.document,this.treeAdapter,this);}static parse(e,t){const s=new this(t);return s.tokenizer.write(e,!0),s.document}static getFragmentParser(e,t){const s={...Le,...t};null!=e||(e=s.treeAdapter.createElement(N.TEMPLATE,d.HTML,[]));const a=s.treeAdapter.createElement("documentmock",d.HTML,[]),r=new this(s,a,e);return r.fragmentContextID===I.TEMPLATE&&r.tmplInsertionModeStack.unshift(Re.IN_TEMPLATE),r._initTokenizerForFragmentParsing(),r._insertFakeRootElement(),r._resetInsertionMode(),r._findFormInFragmentContext(),r}getFragment(){const e=this.treeAdapter.getFirstChild(this.document),t=this.treeAdapter.createDocumentFragment();return this._adoptNodes(e,t),t}_err(e,t,s){var a;if(!this.onParseError)return;const r=null!==(a=e.location)&&void 0!==a?a:Oe,n={code:t,startLine:r.startLine,startCol:r.startCol,startOffset:r.startOffset,endLine:s?r.startLine:r.endLine,endCol:s?r.startCol:r.endCol,endOffset:s?r.startOffset:r.endOffset};this.onParseError(n);}onItemPush(e,t,s){var a,r;null===(r=(a=this.treeAdapter).onItemPush)||void 0===r||r.call(a,e),s&&this.openElements.stackTop>0&&this._setContextModes(e,t);}onItemPop(e,t){var s,a;if(this.options.sourceCodeLocationInfo&&this._setEndLocation(e,this.currentToken),null===(a=(s=this.treeAdapter).onItemPop)||void 0===a||a.call(s,e,this.openElements.current),t){let e,t;0===this.openElements.stackTop&&this.fragmentContext?(e=this.fragmentContext,t=this.fragmentContextID):({current:e,currentTagId:t}=this.openElements),this._setContextModes(e,t);}}_setContextModes(e,t){const s=e===this.document||this.treeAdapter.getNamespaceURI(e)===d.HTML;this.currentNotInHTML=!s,this.tokenizer.inForeignNode=!s&&!this._isIntegrationPoint(t,e);}_switchToTextParsing(e,t){this._insertElement(e,d.HTML),this.tokenizer.state=t,this.originalInsertionMode=this.insertionMode,this.insertionMode=Re.TEXT;}switchToPlaintextParsing(){this.insertionMode=Re.TEXT,this.originalInsertionMode=Re.IN_BODY,this.tokenizer.state=b.PLAINTEXT;}_getAdjustedCurrentElement(){return 0===this.openElements.stackTop&&this.fragmentContext?this.fragmentContext:this.openElements.current}_findFormInFragmentContext(){let e=this.fragmentContext;for(;e;){if(this.treeAdapter.getTagName(e)===N.FORM){this.formElement=e;break}e=this.treeAdapter.getParentNode(e);}}_initTokenizerForFragmentParsing(){if(this.fragmentContext&&this.treeAdapter.getNamespaceURI(this.fragmentContext)===d.HTML)switch(this.fragmentContextID){case I.TITLE:case I.TEXTAREA:this.tokenizer.state=b.RCDATA;break;case I.STYLE:case I.XMP:case I.IFRAME:case I.NOEMBED:case I.NOFRAMES:case I.NOSCRIPT:this.tokenizer.state=b.RAWTEXT;break;case I.SCRIPT:this.tokenizer.state=b.SCRIPT_DATA;break;case I.PLAINTEXT:this.tokenizer.state=b.PLAINTEXT;}}_setDocumentType(e){const t=e.name||"",s=e.publicId||"",a=e.systemId||"";if(this.treeAdapter.setDocumentType(this.document,t,s,a),e.location){const t=this.treeAdapter.getChildNodes(this.document).find((e=>this.treeAdapter.isDocumentTypeNode(e)));t&&this.treeAdapter.setNodeSourceCodeLocation(t,e.location);}}_attachElementToTree(e,t){if(this.options.sourceCodeLocationInfo){const s=t&&{...t,startTag:t};this.treeAdapter.setNodeSourceCodeLocation(e,s);}if(this._shouldFosterParentOnInsertion())this._fosterParentElement(e);else {const t=this.openElements.currentTmplContentOrNode;this.treeAdapter.appendChild(t,e);}}_appendElement(e,t){const s=this.treeAdapter.createElement(e.tagName,t,e.attrs);this._attachElementToTree(s,e.location);}_insertElement(e,t){const s=this.treeAdapter.createElement(e.tagName,t,e.attrs);this._attachElementToTree(s,e.location),this.openElements.push(s,e.tagID);}_insertFakeElement(e,t){const s=this.treeAdapter.createElement(e,d.HTML,[]);this._attachElementToTree(s,null),this.openElements.push(s,t);}_insertTemplate(e){const t=this.treeAdapter.createElement(e.tagName,d.HTML,e.attrs),s=this.treeAdapter.createDocumentFragment();this.treeAdapter.setTemplateContent(t,s),this._attachElementToTree(t,e.location),this.openElements.push(t,e.tagID),this.options.sourceCodeLocationInfo&&this.treeAdapter.setNodeSourceCodeLocation(s,null);}_insertFakeRootElement(){const e=this.treeAdapter.createElement(N.HTML,d.HTML,[]);this.options.sourceCodeLocationInfo&&this.treeAdapter.setNodeSourceCodeLocation(e,null),this.treeAdapter.appendChild(this.openElements.current,e),this.openElements.push(e,I.HTML);}_appendCommentNode(e,t){const s=this.treeAdapter.createCommentNode(e.data);this.treeAdapter.appendChild(t,s),this.options.sourceCodeLocationInfo&&this.treeAdapter.setNodeSourceCodeLocation(s,e.location);}_insertCharacters(e){let t,s;if(this._shouldFosterParentOnInsertion()?(({parent:t,beforeElement:s}=this._findFosterParentingLocation()),s?this.treeAdapter.insertTextBefore(t,e.chars,s):this.treeAdapter.insertText(t,e.chars)):(t=this.openElements.currentTmplContentOrNode,this.treeAdapter.insertText(t,e.chars)),!e.location)return;const a=this.treeAdapter.getChildNodes(t),r=s?a.lastIndexOf(s):a.length,n=a[r-1];if(this.treeAdapter.getNodeSourceCodeLocation(n)){const{endLine:t,endCol:s,endOffset:a}=e.location;this.treeAdapter.updateNodeSourceCodeLocation(n,{endLine:t,endCol:s,endOffset:a});}else this.options.sourceCodeLocationInfo&&this.treeAdapter.setNodeSourceCodeLocation(n,e.location);}_adoptNodes(e,t){for(let s=this.treeAdapter.getFirstChild(e);s;s=this.treeAdapter.getFirstChild(e))this.treeAdapter.detachNode(s),this.treeAdapter.appendChild(t,s);}_setEndLocation(e,t){if(this.treeAdapter.getNodeSourceCodeLocation(e)&&t.location){const s=t.location,a=this.treeAdapter.getTagName(e),r=t.type===h.END_TAG&&a===t.tagName?{endTag:{...s},endLine:s.endLine,endCol:s.endCol,endOffset:s.endOffset}:{endLine:s.startLine,endCol:s.startCol,endOffset:s.startOffset};this.treeAdapter.updateNodeSourceCodeLocation(e,r);}}shouldProcessStartTagTokenInForeignContent(e){if(!this.currentNotInHTML)return !1;let t,s;return 0===this.openElements.stackTop&&this.fragmentContext?(t=this.fragmentContext,s=this.fragmentContextID):({current:t,currentTagId:s}=this.openElements),(e.tagID!==I.SVG||this.treeAdapter.getTagName(t)!==N.ANNOTATION_XML||this.treeAdapter.getNamespaceURI(t)!==d.MATHML)&&(this.tokenizer.inForeignNode||(e.tagID===I.MGLYPH||e.tagID===I.MALIGNMARK)&&!this._isIntegrationPoint(s,t,d.HTML))}_processToken(e){switch(e.type){case h.CHARACTER:this.onCharacter(e);break;case h.NULL_CHARACTER:this.onNullCharacter(e);break;case h.COMMENT:this.onComment(e);break;case h.DOCTYPE:this.onDoctype(e);break;case h.START_TAG:this._processStartTag(e);break;case h.END_TAG:this.onEndTag(e);break;case h.EOF:this.onEof(e);break;case h.WHITESPACE_CHARACTER:this.onWhitespaceCharacter(e);}}_isIntegrationPoint(e,t,s){return function(e,t,s,a){return (!a||a===d.HTML)&&function(e,t,s){if(t===d.MATHML&&e===I.ANNOTATION_XML)for(let e=0;e<s.length;e++)if(s[e].name===p.ENCODING){const t=s[e].value.toLowerCase();return t===Te||t===he}return t===d.SVG&&(e===I.FOREIGN_OBJECT||e===I.DESC||e===I.TITLE)}(e,t,s)||(!a||a===d.MATHML)&&function(e,t){return t===d.MATHML&&(e===I.MI||e===I.MO||e===I.MN||e===I.MS||e===I.MTEXT)}(e,t)}(e,this.treeAdapter.getNamespaceURI(t),this.treeAdapter.getAttrList(t),s)}_reconstructActiveFormattingElements(){const e=this.activeFormattingElements.entries.length;if(e){const t=this.activeFormattingElements.entries.findIndex((e=>e.type===Z.Marker||this.openElements.contains(e.element)));for(let s=t<0?e-1:t-1;s>=0;s--){const e=this.activeFormattingElements.entries[s];this._insertElement(e.token,this.treeAdapter.getNamespaceURI(e.element)),e.element=this.openElements.current;}}}_closeTableCell(){this.openElements.generateImpliedEndTags(),this.openElements.popUntilTableCellPopped(),this.activeFormattingElements.clearToLastMarker(),this.insertionMode=Re.IN_ROW;}_closePElement(){this.openElements.generateImpliedEndTagsWithExclusion(I.P),this.openElements.popUntilTagNamePopped(I.P);}_resetInsertionMode(){for(let e=this.openElements.stackTop;e>=0;e--)switch(0===e&&this.fragmentContext?this.fragmentContextID:this.openElements.tagIDs[e]){case I.TR:return void(this.insertionMode=Re.IN_ROW);case I.TBODY:case I.THEAD:case I.TFOOT:return void(this.insertionMode=Re.IN_TABLE_BODY);case I.CAPTION:return void(this.insertionMode=Re.IN_CAPTION);case I.COLGROUP:return void(this.insertionMode=Re.IN_COLUMN_GROUP);case I.TABLE:return void(this.insertionMode=Re.IN_TABLE);case I.BODY:return void(this.insertionMode=Re.IN_BODY);case I.FRAMESET:return void(this.insertionMode=Re.IN_FRAMESET);case I.SELECT:return void this._resetInsertionModeForSelect(e);case I.TEMPLATE:return void(this.insertionMode=this.tmplInsertionModeStack[0]);case I.HTML:return void(this.insertionMode=this.headElement?Re.AFTER_HEAD:Re.BEFORE_HEAD);case I.TD:case I.TH:if(e>0)return void(this.insertionMode=Re.IN_CELL);break;case I.HEAD:if(e>0)return void(this.insertionMode=Re.IN_HEAD)}this.insertionMode=Re.IN_BODY;}_resetInsertionModeForSelect(e){if(e>0)for(let t=e-1;t>0;t--){const e=this.openElements.tagIDs[t];if(e===I.TEMPLATE)break;if(e===I.TABLE)return void(this.insertionMode=Re.IN_SELECT_IN_TABLE)}this.insertionMode=Re.IN_SELECT;}_isElementCausesFosterParenting(e){return fe.has(e)}_shouldFosterParentOnInsertion(){return this.fosterParentingEnabled&&this._isElementCausesFosterParenting(this.openElements.currentTagId)}_findFosterParentingLocation(){for(let e=this.openElements.stackTop;e>=0;e--){const t=this.openElements.items[e];switch(this.openElements.tagIDs[e]){case I.TEMPLATE:if(this.treeAdapter.getNamespaceURI(t)===d.HTML)return {parent:this.treeAdapter.getTemplateContent(t),beforeElement:null};break;case I.TABLE:{const s=this.treeAdapter.getParentNode(t);return s?{parent:s,beforeElement:t}:{parent:this.openElements.items[e-1],beforeElement:null}}}}return {parent:this.openElements.items[0],beforeElement:null}}_fosterParentElement(e){const t=this._findFosterParentingLocation();t.beforeElement?this.treeAdapter.insertBefore(t.parent,e,t.beforeElement):this.treeAdapter.appendChild(t.parent,e);}_isSpecialElement(e,t){const s=this.treeAdapter.getNamespaceURI(e);return M[s].has(t)}onCharacter(e){if(this.skipNextNewLine=!1,this.tokenizer.inForeignNode)!function(e,t){e._insertCharacters(t),e.framesetOk=!1;}(this,e);else switch(this.insertionMode){case Re.INITIAL:Ge(this,e);break;case Re.BEFORE_HTML:we(this,e);break;case Re.BEFORE_HEAD:xe(this,e);break;case Re.IN_HEAD:Qe(this,e);break;case Re.IN_HEAD_NO_SCRIPT:qe(this,e);break;case Re.AFTER_HEAD:We(this,e);break;case Re.IN_BODY:case Re.IN_CAPTION:case Re.IN_CELL:case Re.IN_TEMPLATE:Ve(this,e);break;case Re.TEXT:case Re.IN_SELECT:case Re.IN_SELECT_IN_TABLE:this._insertCharacters(e);break;case Re.IN_TABLE:case Re.IN_TABLE_BODY:case Re.IN_ROW:at(this,e);break;case Re.IN_TABLE_TEXT:ct(this,e);break;case Re.IN_COLUMN_GROUP:_t(this,e);break;case Re.AFTER_BODY:Ct(this,e);break;case Re.AFTER_AFTER_BODY:St(this,e);}}onNullCharacter(e){if(this.skipNextNewLine=!1,this.tokenizer.inForeignNode)!function(e,t){t.chars=s,e._insertCharacters(t);}(this,e);else switch(this.insertionMode){case Re.INITIAL:Ge(this,e);break;case Re.BEFORE_HTML:we(this,e);break;case Re.BEFORE_HEAD:xe(this,e);break;case Re.IN_HEAD:Qe(this,e);break;case Re.IN_HEAD_NO_SCRIPT:qe(this,e);break;case Re.AFTER_HEAD:We(this,e);break;case Re.TEXT:this._insertCharacters(e);break;case Re.IN_TABLE:case Re.IN_TABLE_BODY:case Re.IN_ROW:at(this,e);break;case Re.IN_COLUMN_GROUP:_t(this,e);break;case Re.AFTER_BODY:Ct(this,e);break;case Re.AFTER_AFTER_BODY:St(this,e);}}onComment(e){if(this.skipNextNewLine=!1,this.currentNotInHTML)Ue(this,e);else switch(this.insertionMode){case Re.INITIAL:case Re.BEFORE_HTML:case Re.BEFORE_HEAD:case Re.IN_HEAD:case Re.IN_HEAD_NO_SCRIPT:case Re.AFTER_HEAD:case Re.IN_BODY:case Re.IN_TABLE:case Re.IN_CAPTION:case Re.IN_COLUMN_GROUP:case Re.IN_TABLE_BODY:case Re.IN_ROW:case Re.IN_CELL:case Re.IN_SELECT:case Re.IN_SELECT_IN_TABLE:case Re.IN_TEMPLATE:case Re.IN_FRAMESET:case Re.AFTER_FRAMESET:Ue(this,e);break;case Re.IN_TABLE_TEXT:Et(this,e);break;case Re.AFTER_BODY:!function(e,t){e._appendCommentNode(t,e.openElements.items[0]);}(this,e);break;case Re.AFTER_AFTER_BODY:case Re.AFTER_AFTER_FRAMESET:!function(e,t){e._appendCommentNode(t,e.document);}(this,e);}}onDoctype(e){switch(this.skipNextNewLine=!1,this.insertionMode){case Re.INITIAL:!function(e,t){e._setDocumentType(t);const s=t.forceQuirks?u.QUIRKS:function(e){if(e.name!==ae)return u.QUIRKS;const{systemId:t}=e;if(t&&"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"===t.toLowerCase())return u.QUIRKS;let{publicId:s}=e;if(null!==s){if(s=s.toLowerCase(),ie.has(s))return u.QUIRKS;let e=null===t?ne:re;if(Ee(s,e))return u.QUIRKS;if(e=null===t?oe:ce,Ee(s,e))return u.LIMITED_QUIRKS}return u.NO_QUIRKS}(t);(function(e){return e.name===ae&&null===e.publicId&&(null===e.systemId||"about:legacy-compat"===e.systemId)})(t)||e._err(t,T.nonConformingDoctype),e.treeAdapter.setDocumentMode(e.document,s),e.insertionMode=Re.BEFORE_HTML;}(this,e);break;case Re.BEFORE_HEAD:case Re.IN_HEAD:case Re.IN_HEAD_NO_SCRIPT:case Re.AFTER_HEAD:this._err(e,T.misplacedDoctype);break;case Re.IN_TABLE_TEXT:Et(this,e);}}onStartTag(e){this.skipNextNewLine=!1,this.currentToken=e,this._processStartTag(e),e.selfClosing&&!e.ackSelfClosing&&this._err(e,T.nonVoidHtmlElementStartTagWithTrailingSolidus);}_processStartTag(e){this.shouldProcessStartTagTokenInForeignContent(e)?function(e,t){if(function(e){const t=e.tagID;return t===I.FONT&&e.attrs.some((({name:e})=>e===p.COLOR||e===p.SIZE||e===p.FACE))||pe.has(t)}(t))Dt(e),e._startTagOutsideForeignContent(t);else {const s=e._getAdjustedCurrentElement(),a=e.treeAdapter.getNamespaceURI(s);a===d.MATHML?ue(t):a===d.SVG&&(function(e){const t=de.get(e.tagName);null!=t&&(e.tagName=t,e.tagID=f(e.tagName));}(t),Ne(t)),Ie(t),t.selfClosing?e._appendElement(t,a):e._insertElement(t,a),t.ackSelfClosing=!0;}}(this,e):this._startTagOutsideForeignContent(e);}_startTagOutsideForeignContent(e){switch(this.insertionMode){case Re.INITIAL:Ge(this,e);break;case Re.BEFORE_HTML:!function(e,t){t.tagID===I.HTML?(e._insertElement(t,d.HTML),e.insertionMode=Re.BEFORE_HEAD):we(e,t);}(this,e);break;case Re.BEFORE_HEAD:!function(e,t){switch(t.tagID){case I.HTML:$e(e,t);break;case I.HEAD:e._insertElement(t,d.HTML),e.headElement=e.openElements.current,e.insertionMode=Re.IN_HEAD;break;default:xe(e,t);}}(this,e);break;case Re.IN_HEAD:Ye(this,e);break;case Re.IN_HEAD_NO_SCRIPT:!function(e,t){switch(t.tagID){case I.HTML:$e(e,t);break;case I.BASEFONT:case I.BGSOUND:case I.HEAD:case I.LINK:case I.META:case I.NOFRAMES:case I.STYLE:Ye(e,t);break;case I.NOSCRIPT:e._err(t,T.nestedNoscriptInHead);break;default:qe(e,t);}}(this,e);break;case Re.AFTER_HEAD:!function(e,t){switch(t.tagID){case I.HTML:$e(e,t);break;case I.BODY:e._insertElement(t,d.HTML),e.framesetOk=!1,e.insertionMode=Re.IN_BODY;break;case I.FRAMESET:e._insertElement(t,d.HTML),e.insertionMode=Re.IN_FRAMESET;break;case I.BASE:case I.BASEFONT:case I.BGSOUND:case I.LINK:case I.META:case I.NOFRAMES:case I.SCRIPT:case I.STYLE:case I.TEMPLATE:case I.TITLE:e._err(t,T.abandonedHeadElementChild),e.openElements.push(e.headElement,I.HEAD),Ye(e,t),e.openElements.remove(e.headElement);break;case I.HEAD:e._err(t,T.misplacedStartTagForHeadElement);break;default:We(e,t);}}(this,e);break;case Re.IN_BODY:$e(this,e);break;case Re.IN_TABLE:rt(this,e);break;case Re.IN_TABLE_TEXT:Et(this,e);break;case Re.IN_CAPTION:!function(e,t){const s=t.tagID;Tt.has(s)?e.openElements.hasInTableScope(I.CAPTION)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(I.CAPTION),e.activeFormattingElements.clearToLastMarker(),e.insertionMode=Re.IN_TABLE,rt(e,t)):$e(e,t);}(this,e);break;case Re.IN_COLUMN_GROUP:ht(this,e);break;case Re.IN_TABLE_BODY:At(this,e);break;case Re.IN_ROW:mt(this,e);break;case Re.IN_CELL:!function(e,t){const s=t.tagID;Tt.has(s)?(e.openElements.hasInTableScope(I.TD)||e.openElements.hasInTableScope(I.TH))&&(e._closeTableCell(),mt(e,t)):$e(e,t);}(this,e);break;case Re.IN_SELECT:pt(this,e);break;case Re.IN_SELECT_IN_TABLE:!function(e,t){const s=t.tagID;s===I.CAPTION||s===I.TABLE||s===I.TBODY||s===I.TFOOT||s===I.THEAD||s===I.TR||s===I.TD||s===I.TH?(e.openElements.popUntilTagNamePopped(I.SELECT),e._resetInsertionMode(),e._processStartTag(t)):pt(e,t);}(this,e);break;case Re.IN_TEMPLATE:!function(e,t){switch(t.tagID){case I.BASE:case I.BASEFONT:case I.BGSOUND:case I.LINK:case I.META:case I.NOFRAMES:case I.SCRIPT:case I.STYLE:case I.TEMPLATE:case I.TITLE:Ye(e,t);break;case I.CAPTION:case I.COLGROUP:case I.TBODY:case I.TFOOT:case I.THEAD:e.tmplInsertionModeStack[0]=Re.IN_TABLE,e.insertionMode=Re.IN_TABLE,rt(e,t);break;case I.COL:e.tmplInsertionModeStack[0]=Re.IN_COLUMN_GROUP,e.insertionMode=Re.IN_COLUMN_GROUP,ht(e,t);break;case I.TR:e.tmplInsertionModeStack[0]=Re.IN_TABLE_BODY,e.insertionMode=Re.IN_TABLE_BODY,At(e,t);break;case I.TD:case I.TH:e.tmplInsertionModeStack[0]=Re.IN_ROW,e.insertionMode=Re.IN_ROW,mt(e,t);break;default:e.tmplInsertionModeStack[0]=Re.IN_BODY,e.insertionMode=Re.IN_BODY,$e(e,t);}}(this,e);break;case Re.AFTER_BODY:!function(e,t){t.tagID===I.HTML?$e(e,t):Ct(e,t);}(this,e);break;case Re.IN_FRAMESET:!function(e,t){switch(t.tagID){case I.HTML:$e(e,t);break;case I.FRAMESET:e._insertElement(t,d.HTML);break;case I.FRAME:e._appendElement(t,d.HTML),t.ackSelfClosing=!0;break;case I.NOFRAMES:Ye(e,t);}}(this,e);break;case Re.AFTER_FRAMESET:!function(e,t){switch(t.tagID){case I.HTML:$e(e,t);break;case I.NOFRAMES:Ye(e,t);}}(this,e);break;case Re.AFTER_AFTER_BODY:!function(e,t){t.tagID===I.HTML?$e(e,t):St(e,t);}(this,e);break;case Re.AFTER_AFTER_FRAMESET:!function(e,t){switch(t.tagID){case I.HTML:$e(e,t);break;case I.NOFRAMES:Ye(e,t);}}(this,e);}}onEndTag(e){this.skipNextNewLine=!1,this.currentToken=e,this.currentNotInHTML?function(e,t){if(t.tagID===I.P||t.tagID===I.BR)return Dt(e),void e._endTagOutsideForeignContent(t);for(let s=e.openElements.stackTop;s>0;s--){const a=e.openElements.items[s];if(e.treeAdapter.getNamespaceURI(a)===d.HTML){e._endTagOutsideForeignContent(t);break}const r=e.treeAdapter.getTagName(a);if(r.toLowerCase()===t.tagName){t.tagName=r,e.openElements.shortenToLength(s);break}}}(this,e):this._endTagOutsideForeignContent(e);}_endTagOutsideForeignContent(e){switch(this.insertionMode){case Re.INITIAL:Ge(this,e);break;case Re.BEFORE_HTML:!function(e,t){const s=t.tagID;s!==I.HTML&&s!==I.HEAD&&s!==I.BODY&&s!==I.BR||we(e,t);}(this,e);break;case Re.BEFORE_HEAD:!function(e,t){const s=t.tagID;s===I.HEAD||s===I.BODY||s===I.HTML||s===I.BR?xe(e,t):e._err(t,T.endTagWithoutMatchingOpenElement);}(this,e);break;case Re.IN_HEAD:!function(e,t){switch(t.tagID){case I.HEAD:e.openElements.pop(),e.insertionMode=Re.AFTER_HEAD;break;case I.BODY:case I.BR:case I.HTML:Qe(e,t);break;case I.TEMPLATE:ve(e,t);break;default:e._err(t,T.endTagWithoutMatchingOpenElement);}}(this,e);break;case Re.IN_HEAD_NO_SCRIPT:!function(e,t){switch(t.tagID){case I.NOSCRIPT:e.openElements.pop(),e.insertionMode=Re.IN_HEAD;break;case I.BR:qe(e,t);break;default:e._err(t,T.endTagWithoutMatchingOpenElement);}}(this,e);break;case Re.AFTER_HEAD:!function(e,t){switch(t.tagID){case I.BODY:case I.HTML:case I.BR:We(e,t);break;case I.TEMPLATE:ve(e,t);break;default:e._err(t,T.endTagWithoutMatchingOpenElement);}}(this,e);break;case Re.IN_BODY:tt(this,e);break;case Re.TEXT:!function(e,t){var s;t.tagID===I.SCRIPT&&(null===(s=e.scriptHandler)||void 0===s||s.call(e,e.openElements.current)),e.openElements.pop(),e.insertionMode=e.originalInsertionMode;}(this,e);break;case Re.IN_TABLE:nt(this,e);break;case Re.IN_TABLE_TEXT:Et(this,e);break;case Re.IN_CAPTION:!function(e,t){const s=t.tagID;switch(s){case I.CAPTION:case I.TABLE:e.openElements.hasInTableScope(I.CAPTION)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(I.CAPTION),e.activeFormattingElements.clearToLastMarker(),e.insertionMode=Re.IN_TABLE,s===I.TABLE&&nt(e,t));break;case I.BODY:case I.COL:case I.COLGROUP:case I.HTML:case I.TBODY:case I.TD:case I.TFOOT:case I.TH:case I.THEAD:case I.TR:break;default:tt(e,t);}}(this,e);break;case Re.IN_COLUMN_GROUP:!function(e,t){switch(t.tagID){case I.COLGROUP:e.openElements.currentTagId===I.COLGROUP&&(e.openElements.pop(),e.insertionMode=Re.IN_TABLE);break;case I.TEMPLATE:ve(e,t);break;case I.COL:break;default:_t(e,t);}}(this,e);break;case Re.IN_TABLE_BODY:lt(this,e);break;case Re.IN_ROW:dt(this,e);break;case Re.IN_CELL:!function(e,t){const s=t.tagID;switch(s){case I.TD:case I.TH:e.openElements.hasInTableScope(s)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(s),e.activeFormattingElements.clearToLastMarker(),e.insertionMode=Re.IN_ROW);break;case I.TABLE:case I.TBODY:case I.TFOOT:case I.THEAD:case I.TR:e.openElements.hasInTableScope(s)&&(e._closeTableCell(),dt(e,t));break;case I.BODY:case I.CAPTION:case I.COL:case I.COLGROUP:case I.HTML:break;default:tt(e,t);}}(this,e);break;case Re.IN_SELECT:ut(this,e);break;case Re.IN_SELECT_IN_TABLE:!function(e,t){const s=t.tagID;s===I.CAPTION||s===I.TABLE||s===I.TBODY||s===I.TFOOT||s===I.THEAD||s===I.TR||s===I.TD||s===I.TH?e.openElements.hasInTableScope(s)&&(e.openElements.popUntilTagNamePopped(I.SELECT),e._resetInsertionMode(),e.onEndTag(t)):ut(e,t);}(this,e);break;case Re.IN_TEMPLATE:!function(e,t){t.tagID===I.TEMPLATE&&ve(e,t);}(this,e);break;case Re.AFTER_BODY:It(this,e);break;case Re.IN_FRAMESET:!function(e,t){t.tagID!==I.FRAMESET||e.openElements.isRootHtmlElementCurrent()||(e.openElements.pop(),e.fragmentContext||e.openElements.currentTagId===I.FRAMESET||(e.insertionMode=Re.AFTER_FRAMESET));}(this,e);break;case Re.AFTER_FRAMESET:!function(e,t){t.tagID===I.HTML&&(e.insertionMode=Re.AFTER_AFTER_FRAMESET);}(this,e);break;case Re.AFTER_AFTER_BODY:St(this,e);}}onEof(e){switch(this.insertionMode){case Re.INITIAL:Ge(this,e);break;case Re.BEFORE_HTML:we(this,e);break;case Re.BEFORE_HEAD:xe(this,e);break;case Re.IN_HEAD:Qe(this,e);break;case Re.IN_HEAD_NO_SCRIPT:qe(this,e);break;case Re.AFTER_HEAD:We(this,e);break;case Re.IN_BODY:case Re.IN_TABLE:case Re.IN_CAPTION:case Re.IN_COLUMN_GROUP:case Re.IN_TABLE_BODY:case Re.IN_ROW:case Re.IN_CELL:case Re.IN_SELECT:case Re.IN_SELECT_IN_TABLE:st(this,e);break;case Re.TEXT:!function(e,t){e._err(t,T.eofInElementThatCanContainOnlyText),e.openElements.pop(),e.insertionMode=e.originalInsertionMode,e.onEof(t);}(this,e);break;case Re.IN_TABLE_TEXT:Et(this,e);break;case Re.IN_TEMPLATE:Nt(this,e);break;case Re.AFTER_BODY:case Re.IN_FRAMESET:case Re.AFTER_FRAMESET:case Re.AFTER_AFTER_BODY:case Re.AFTER_AFTER_FRAMESET:ye(this,e);}}onWhitespaceCharacter(e){if(this.skipNextNewLine&&(this.skipNextNewLine=!1,e.chars.charCodeAt(0)===a.LINE_FEED)){if(1===e.chars.length)return;e.chars=e.chars.substr(1);}if(this.tokenizer.inForeignNode)this._insertCharacters(e);else switch(this.insertionMode){case Re.IN_HEAD:case Re.IN_HEAD_NO_SCRIPT:case Re.AFTER_HEAD:case Re.TEXT:case Re.IN_COLUMN_GROUP:case Re.IN_SELECT:case Re.IN_SELECT_IN_TABLE:case Re.IN_FRAMESET:case Re.AFTER_FRAMESET:this._insertCharacters(e);break;case Re.IN_BODY:case Re.IN_CAPTION:case Re.IN_CELL:case Re.IN_TEMPLATE:case Re.AFTER_BODY:case Re.AFTER_AFTER_BODY:case Re.AFTER_AFTER_FRAMESET:Ke(this,e);break;case Re.IN_TABLE:case Re.IN_TABLE_BODY:case Re.IN_ROW:at(this,e);break;case Re.IN_TABLE_TEXT:ot(this,e);}}}function ge(e,t){let s=e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);return s?e.openElements.contains(s.element)?e.openElements.hasInScope(t.tagID)||(s=null):(e.activeFormattingElements.removeEntry(s),s=null):et(e,t),s}function Pe(e,t){let s=null,a=e.openElements.stackTop;for(;a>=0;a--){const r=e.openElements.items[a];if(r===t.element)break;e._isSpecialElement(r,e.openElements.tagIDs[a])&&(s=r);}return s||(e.openElements.shortenToLength(a<0?0:a),e.activeFormattingElements.removeEntry(t)),s}function ke(e,t,s){let a=t,r=e.openElements.getCommonAncestor(t);for(let n=0,i=r;i!==s;n++,i=r){r=e.openElements.getCommonAncestor(i);const s=e.activeFormattingElements.getElementEntry(i),o=s&&n>=De;!s||o?(o&&e.activeFormattingElements.removeEntry(s),e.openElements.remove(i)):(i=be(e,s),a===t&&(e.activeFormattingElements.bookmark=s),e.treeAdapter.detachNode(a),e.treeAdapter.appendChild(i,a),a=i);}return a}function be(e,t){const s=e.treeAdapter.getNamespaceURI(t.element),a=e.treeAdapter.createElement(t.token.tagName,s,t.token.attrs);return e.openElements.replace(t.element,a),t.element=a,a}function Be(e,t,s){const a=f(e.treeAdapter.getTagName(t));if(e._isElementCausesFosterParenting(a))e._fosterParentElement(s);else {const r=e.treeAdapter.getNamespaceURI(t);a===I.TEMPLATE&&r===d.HTML&&(t=e.treeAdapter.getTemplateContent(t)),e.treeAdapter.appendChild(t,s);}}function He(e,t,s){const a=e.treeAdapter.getNamespaceURI(s.element),{token:r}=s,n=e.treeAdapter.createElement(r.tagName,a,r.attrs);e._adoptNodes(t,n),e.treeAdapter.appendChild(t,n),e.activeFormattingElements.insertElementAfterBookmark(n,r),e.activeFormattingElements.removeEntry(s),e.openElements.remove(s.element),e.openElements.insertAfter(t,n,r.tagID);}function Fe(e,t){for(let s=0;s<Se;s++){const s=ge(e,t);if(!s)break;const a=Pe(e,s);if(!a)break;e.activeFormattingElements.bookmark=s;const r=ke(e,a,s.element),n=e.openElements.getCommonAncestor(s.element);e.treeAdapter.detachNode(r),n&&Be(e,n,r),He(e,a,s);}}function Ue(e,t){e._appendCommentNode(t,e.openElements.currentTmplContentOrNode);}function ye(e,t){if(e.stopped=!0,t.location){const s=e.fragmentContext?0:2;for(let a=e.openElements.stackTop;a>=s;a--)e._setEndLocation(e.openElements.items[a],t);if(!e.fragmentContext&&e.openElements.stackTop>=0){const s=e.openElements.items[0],a=e.treeAdapter.getNodeSourceCodeLocation(s);if(a&&!a.endTag&&(e._setEndLocation(s,t),e.openElements.stackTop>=1)){const s=e.openElements.items[1],a=e.treeAdapter.getNodeSourceCodeLocation(s);a&&!a.endTag&&e._setEndLocation(s,t);}}}}function Ge(e,t){e._err(t,T.missingDoctype,!0),e.treeAdapter.setDocumentMode(e.document,u.QUIRKS),e.insertionMode=Re.BEFORE_HTML,e._processToken(t);}function we(e,t){e._insertFakeRootElement(),e.insertionMode=Re.BEFORE_HEAD,e._processToken(t);}function xe(e,t){e._insertFakeElement(N.HEAD,I.HEAD),e.headElement=e.openElements.current,e.insertionMode=Re.IN_HEAD,e._processToken(t);}function Ye(e,t){switch(t.tagID){case I.HTML:$e(e,t);break;case I.BASE:case I.BASEFONT:case I.BGSOUND:case I.LINK:case I.META:e._appendElement(t,d.HTML),t.ackSelfClosing=!0;break;case I.TITLE:e._switchToTextParsing(t,b.RCDATA);break;case I.NOSCRIPT:e.options.scriptingEnabled?e._switchToTextParsing(t,b.RAWTEXT):(e._insertElement(t,d.HTML),e.insertionMode=Re.IN_HEAD_NO_SCRIPT);break;case I.NOFRAMES:case I.STYLE:e._switchToTextParsing(t,b.RAWTEXT);break;case I.SCRIPT:e._switchToTextParsing(t,b.SCRIPT_DATA);break;case I.TEMPLATE:e._insertTemplate(t),e.activeFormattingElements.insertMarker(),e.framesetOk=!1,e.insertionMode=Re.IN_TEMPLATE,e.tmplInsertionModeStack.unshift(Re.IN_TEMPLATE);break;case I.HEAD:e._err(t,T.misplacedStartTagForHeadElement);break;default:Qe(e,t);}}function ve(e,t){e.openElements.tmplCount>0?(e.openElements.generateImpliedEndTagsThoroughly(),e.openElements.currentTagId!==I.TEMPLATE&&e._err(t,T.closingOfElementWithOpenChildElements),e.openElements.popUntilTagNamePopped(I.TEMPLATE),e.activeFormattingElements.clearToLastMarker(),e.tmplInsertionModeStack.shift(),e._resetInsertionMode()):e._err(t,T.endTagWithoutMatchingOpenElement);}function Qe(e,t){e.openElements.pop(),e.insertionMode=Re.AFTER_HEAD,e._processToken(t);}function qe(e,t){const s=t.type===h.EOF?T.openElementsLeftAfterEof:T.disallowedContentInNoscriptInHead;e._err(t,s),e.openElements.pop(),e.insertionMode=Re.IN_HEAD,e._processToken(t);}function We(e,t){e._insertFakeElement(N.BODY,I.BODY),e.insertionMode=Re.IN_BODY,Xe(e,t);}function Xe(e,t){switch(t.type){case h.CHARACTER:Ve(e,t);break;case h.WHITESPACE_CHARACTER:Ke(e,t);break;case h.COMMENT:Ue(e,t);break;case h.START_TAG:$e(e,t);break;case h.END_TAG:tt(e,t);break;case h.EOF:st(e,t);}}function Ke(e,t){e._reconstructActiveFormattingElements(),e._insertCharacters(t);}function Ve(e,t){e._reconstructActiveFormattingElements(),e._insertCharacters(t),e.framesetOk=!1;}function je(e,t){e._reconstructActiveFormattingElements(),e._appendElement(t,d.HTML),e.framesetOk=!1,t.ackSelfClosing=!0;}function ze(e){const t=A(e,p.TYPE);return null!=t&&t.toLowerCase()===Ce}function Je(e,t){e._switchToTextParsing(t,b.RAWTEXT);}function Ze(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,d.HTML);}function $e(e,t){switch(t.tagID){case I.I:case I.S:case I.B:case I.U:case I.EM:case I.TT:case I.BIG:case I.CODE:case I.FONT:case I.SMALL:case I.STRIKE:case I.STRONG:!function(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,d.HTML),e.activeFormattingElements.pushElement(e.openElements.current,t);}(e,t);break;case I.A:!function(e,t){const s=e.activeFormattingElements.getElementEntryInScopeWithTagName(N.A);s&&(Fe(e,t),e.openElements.remove(s.element),e.activeFormattingElements.removeEntry(s)),e._reconstructActiveFormattingElements(),e._insertElement(t,d.HTML),e.activeFormattingElements.pushElement(e.openElements.current,t);}(e,t);break;case I.H1:case I.H2:case I.H3:case I.H4:case I.H5:case I.H6:!function(e,t){e.openElements.hasInButtonScope(I.P)&&e._closePElement(),g(e.openElements.currentTagId)&&e.openElements.pop(),e._insertElement(t,d.HTML);}(e,t);break;case I.P:case I.DL:case I.OL:case I.UL:case I.DIV:case I.DIR:case I.NAV:case I.MAIN:case I.MENU:case I.ASIDE:case I.CENTER:case I.FIGURE:case I.FOOTER:case I.HEADER:case I.HGROUP:case I.DIALOG:case I.DETAILS:case I.ADDRESS:case I.ARTICLE:case I.SECTION:case I.SUMMARY:case I.FIELDSET:case I.BLOCKQUOTE:case I.FIGCAPTION:!function(e,t){e.openElements.hasInButtonScope(I.P)&&e._closePElement(),e._insertElement(t,d.HTML);}(e,t);break;case I.LI:case I.DD:case I.DT:!function(e,t){e.framesetOk=!1;const s=t.tagID;for(let t=e.openElements.stackTop;t>=0;t--){const a=e.openElements.tagIDs[t];if(s===I.LI&&a===I.LI||(s===I.DD||s===I.DT)&&(a===I.DD||a===I.DT)){e.openElements.generateImpliedEndTagsWithExclusion(a),e.openElements.popUntilTagNamePopped(a);break}if(a!==I.ADDRESS&&a!==I.DIV&&a!==I.P&&e._isSpecialElement(e.openElements.items[t],a))break}e.openElements.hasInButtonScope(I.P)&&e._closePElement(),e._insertElement(t,d.HTML);}(e,t);break;case I.BR:case I.IMG:case I.WBR:case I.AREA:case I.EMBED:case I.KEYGEN:je(e,t);break;case I.HR:!function(e,t){e.openElements.hasInButtonScope(I.P)&&e._closePElement(),e._appendElement(t,d.HTML),e.framesetOk=!1,t.ackSelfClosing=!0;}(e,t);break;case I.RB:case I.RTC:!function(e,t){e.openElements.hasInScope(I.RUBY)&&e.openElements.generateImpliedEndTags(),e._insertElement(t,d.HTML);}(e,t);break;case I.RT:case I.RP:!function(e,t){e.openElements.hasInScope(I.RUBY)&&e.openElements.generateImpliedEndTagsWithExclusion(I.RTC),e._insertElement(t,d.HTML);}(e,t);break;case I.PRE:case I.LISTING:!function(e,t){e.openElements.hasInButtonScope(I.P)&&e._closePElement(),e._insertElement(t,d.HTML),e.skipNextNewLine=!0,e.framesetOk=!1;}(e,t);break;case I.XMP:!function(e,t){e.openElements.hasInButtonScope(I.P)&&e._closePElement(),e._reconstructActiveFormattingElements(),e.framesetOk=!1,e._switchToTextParsing(t,b.RAWTEXT);}(e,t);break;case I.SVG:!function(e,t){e._reconstructActiveFormattingElements(),Ne(t),Ie(t),t.selfClosing?e._appendElement(t,d.SVG):e._insertElement(t,d.SVG),t.ackSelfClosing=!0;}(e,t);break;case I.HTML:!function(e,t){0===e.openElements.tmplCount&&e.treeAdapter.adoptAttributes(e.openElements.items[0],t.attrs);}(e,t);break;case I.BASE:case I.LINK:case I.META:case I.STYLE:case I.TITLE:case I.SCRIPT:case I.BGSOUND:case I.BASEFONT:case I.TEMPLATE:Ye(e,t);break;case I.BODY:!function(e,t){const s=e.openElements.tryPeekProperlyNestedBodyElement();s&&0===e.openElements.tmplCount&&(e.framesetOk=!1,e.treeAdapter.adoptAttributes(s,t.attrs));}(e,t);break;case I.FORM:!function(e,t){const s=e.openElements.tmplCount>0;e.formElement&&!s||(e.openElements.hasInButtonScope(I.P)&&e._closePElement(),e._insertElement(t,d.HTML),s||(e.formElement=e.openElements.current));}(e,t);break;case I.NOBR:!function(e,t){e._reconstructActiveFormattingElements(),e.openElements.hasInScope(I.NOBR)&&(Fe(e,t),e._reconstructActiveFormattingElements()),e._insertElement(t,d.HTML),e.activeFormattingElements.pushElement(e.openElements.current,t);}(e,t);break;case I.MATH:!function(e,t){e._reconstructActiveFormattingElements(),ue(t),Ie(t),t.selfClosing?e._appendElement(t,d.MATHML):e._insertElement(t,d.MATHML),t.ackSelfClosing=!0;}(e,t);break;case I.TABLE:!function(e,t){e.treeAdapter.getDocumentMode(e.document)!==u.QUIRKS&&e.openElements.hasInButtonScope(I.P)&&e._closePElement(),e._insertElement(t,d.HTML),e.framesetOk=!1,e.insertionMode=Re.IN_TABLE;}(e,t);break;case I.INPUT:!function(e,t){e._reconstructActiveFormattingElements(),e._appendElement(t,d.HTML),ze(t)||(e.framesetOk=!1),t.ackSelfClosing=!0;}(e,t);break;case I.PARAM:case I.TRACK:case I.SOURCE:!function(e,t){e._appendElement(t,d.HTML),t.ackSelfClosing=!0;}(e,t);break;case I.IMAGE:!function(e,t){t.tagName=N.IMG,t.tagID=I.IMG,je(e,t);}(e,t);break;case I.BUTTON:!function(e,t){e.openElements.hasInScope(I.BUTTON)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(I.BUTTON)),e._reconstructActiveFormattingElements(),e._insertElement(t,d.HTML),e.framesetOk=!1;}(e,t);break;case I.APPLET:case I.OBJECT:case I.MARQUEE:!function(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,d.HTML),e.activeFormattingElements.insertMarker(),e.framesetOk=!1;}(e,t);break;case I.IFRAME:!function(e,t){e.framesetOk=!1,e._switchToTextParsing(t,b.RAWTEXT);}(e,t);break;case I.SELECT:!function(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,d.HTML),e.framesetOk=!1,e.insertionMode=e.insertionMode===Re.IN_TABLE||e.insertionMode===Re.IN_CAPTION||e.insertionMode===Re.IN_TABLE_BODY||e.insertionMode===Re.IN_ROW||e.insertionMode===Re.IN_CELL?Re.IN_SELECT_IN_TABLE:Re.IN_SELECT;}(e,t);break;case I.OPTION:case I.OPTGROUP:!function(e,t){e.openElements.currentTagId===I.OPTION&&e.openElements.pop(),e._reconstructActiveFormattingElements(),e._insertElement(t,d.HTML);}(e,t);break;case I.NOEMBED:Je(e,t);break;case I.FRAMESET:!function(e,t){const s=e.openElements.tryPeekProperlyNestedBodyElement();e.framesetOk&&s&&(e.treeAdapter.detachNode(s),e.openElements.popAllUpToHtmlElement(),e._insertElement(t,d.HTML),e.insertionMode=Re.IN_FRAMESET);}(e,t);break;case I.TEXTAREA:!function(e,t){e._insertElement(t,d.HTML),e.skipNextNewLine=!0,e.tokenizer.state=b.RCDATA,e.originalInsertionMode=e.insertionMode,e.framesetOk=!1,e.insertionMode=Re.TEXT;}(e,t);break;case I.NOSCRIPT:e.options.scriptingEnabled?Je(e,t):Ze(e,t);break;case I.PLAINTEXT:!function(e,t){e.openElements.hasInButtonScope(I.P)&&e._closePElement(),e._insertElement(t,d.HTML),e.tokenizer.state=b.PLAINTEXT;}(e,t);break;case I.COL:case I.TH:case I.TD:case I.TR:case I.HEAD:case I.FRAME:case I.TBODY:case I.TFOOT:case I.THEAD:case I.CAPTION:case I.COLGROUP:break;default:Ze(e,t);}}function et(e,t){const s=t.tagName,a=t.tagID;for(let t=e.openElements.stackTop;t>0;t--){const r=e.openElements.items[t],n=e.openElements.tagIDs[t];if(a===n&&(a!==I.UNKNOWN||e.treeAdapter.getTagName(r)===s)){e.openElements.generateImpliedEndTagsWithExclusion(a),e.openElements.stackTop>=t&&e.openElements.shortenToLength(t);break}if(e._isSpecialElement(r,n))break}}function tt(e,t){switch(t.tagID){case I.A:case I.B:case I.I:case I.S:case I.U:case I.EM:case I.TT:case I.BIG:case I.CODE:case I.FONT:case I.NOBR:case I.SMALL:case I.STRIKE:case I.STRONG:Fe(e,t);break;case I.P:!function(e){e.openElements.hasInButtonScope(I.P)||e._insertFakeElement(N.P,I.P),e._closePElement();}(e);break;case I.DL:case I.UL:case I.OL:case I.DIR:case I.DIV:case I.NAV:case I.PRE:case I.MAIN:case I.MENU:case I.ASIDE:case I.BUTTON:case I.CENTER:case I.FIGURE:case I.FOOTER:case I.HEADER:case I.HGROUP:case I.DIALOG:case I.ADDRESS:case I.ARTICLE:case I.DETAILS:case I.SECTION:case I.SUMMARY:case I.LISTING:case I.FIELDSET:case I.BLOCKQUOTE:case I.FIGCAPTION:!function(e,t){const s=t.tagID;e.openElements.hasInScope(s)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(s));}(e,t);break;case I.LI:!function(e){e.openElements.hasInListItemScope(I.LI)&&(e.openElements.generateImpliedEndTagsWithExclusion(I.LI),e.openElements.popUntilTagNamePopped(I.LI));}(e);break;case I.DD:case I.DT:!function(e,t){const s=t.tagID;e.openElements.hasInScope(s)&&(e.openElements.generateImpliedEndTagsWithExclusion(s),e.openElements.popUntilTagNamePopped(s));}(e,t);break;case I.H1:case I.H2:case I.H3:case I.H4:case I.H5:case I.H6:!function(e){e.openElements.hasNumberedHeaderInScope()&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilNumberedHeaderPopped());}(e);break;case I.BR:!function(e){e._reconstructActiveFormattingElements(),e._insertFakeElement(N.BR,I.BR),e.openElements.pop(),e.framesetOk=!1;}(e);break;case I.BODY:!function(e,t){if(e.openElements.hasInScope(I.BODY)&&(e.insertionMode=Re.AFTER_BODY,e.options.sourceCodeLocationInfo)){const s=e.openElements.tryPeekProperlyNestedBodyElement();s&&e._setEndLocation(s,t);}}(e,t);break;case I.HTML:!function(e,t){e.openElements.hasInScope(I.BODY)&&(e.insertionMode=Re.AFTER_BODY,It(e,t));}(e,t);break;case I.FORM:!function(e){const t=e.openElements.tmplCount>0,{formElement:s}=e;t||(e.formElement=null),(s||t)&&e.openElements.hasInScope(I.FORM)&&(e.openElements.generateImpliedEndTags(),t?e.openElements.popUntilTagNamePopped(I.FORM):s&&e.openElements.remove(s));}(e);break;case I.APPLET:case I.OBJECT:case I.MARQUEE:!function(e,t){const s=t.tagID;e.openElements.hasInScope(s)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(s),e.activeFormattingElements.clearToLastMarker());}(e,t);break;case I.TEMPLATE:ve(e,t);break;default:et(e,t);}}function st(e,t){e.tmplInsertionModeStack.length>0?Nt(e,t):ye(e,t);}function at(e,t){if(fe.has(e.openElements.currentTagId))switch(e.pendingCharacterTokens.length=0,e.hasNonWhitespacePendingCharacterToken=!1,e.originalInsertionMode=e.insertionMode,e.insertionMode=Re.IN_TABLE_TEXT,t.type){case h.CHARACTER:ct(e,t);break;case h.WHITESPACE_CHARACTER:ot(e,t);}else it(e,t);}function rt(e,t){switch(t.tagID){case I.TD:case I.TH:case I.TR:!function(e,t){e.openElements.clearBackToTableContext(),e._insertFakeElement(N.TBODY,I.TBODY),e.insertionMode=Re.IN_TABLE_BODY,At(e,t);}(e,t);break;case I.STYLE:case I.SCRIPT:case I.TEMPLATE:Ye(e,t);break;case I.COL:!function(e,t){e.openElements.clearBackToTableContext(),e._insertFakeElement(N.COLGROUP,I.COLGROUP),e.insertionMode=Re.IN_COLUMN_GROUP,ht(e,t);}(e,t);break;case I.FORM:!function(e,t){e.formElement||0!==e.openElements.tmplCount||(e._insertElement(t,d.HTML),e.formElement=e.openElements.current,e.openElements.pop());}(e,t);break;case I.TABLE:!function(e,t){e.openElements.hasInTableScope(I.TABLE)&&(e.openElements.popUntilTagNamePopped(I.TABLE),e._resetInsertionMode(),e._processStartTag(t));}(e,t);break;case I.TBODY:case I.TFOOT:case I.THEAD:!function(e,t){e.openElements.clearBackToTableContext(),e._insertElement(t,d.HTML),e.insertionMode=Re.IN_TABLE_BODY;}(e,t);break;case I.INPUT:!function(e,t){ze(t)?e._appendElement(t,d.HTML):it(e,t),t.ackSelfClosing=!0;}(e,t);break;case I.CAPTION:!function(e,t){e.openElements.clearBackToTableContext(),e.activeFormattingElements.insertMarker(),e._insertElement(t,d.HTML),e.insertionMode=Re.IN_CAPTION;}(e,t);break;case I.COLGROUP:!function(e,t){e.openElements.clearBackToTableContext(),e._insertElement(t,d.HTML),e.insertionMode=Re.IN_COLUMN_GROUP;}(e,t);break;default:it(e,t);}}function nt(e,t){switch(t.tagID){case I.TABLE:e.openElements.hasInTableScope(I.TABLE)&&(e.openElements.popUntilTagNamePopped(I.TABLE),e._resetInsertionMode());break;case I.TEMPLATE:ve(e,t);break;case I.BODY:case I.CAPTION:case I.COL:case I.COLGROUP:case I.HTML:case I.TBODY:case I.TD:case I.TFOOT:case I.TH:case I.THEAD:case I.TR:break;default:it(e,t);}}function it(e,t){const s=e.fosterParentingEnabled;e.fosterParentingEnabled=!0,Xe(e,t),e.fosterParentingEnabled=s;}function ot(e,t){e.pendingCharacterTokens.push(t);}function ct(e,t){e.pendingCharacterTokens.push(t),e.hasNonWhitespacePendingCharacterToken=!0;}function Et(e,t){let s=0;if(e.hasNonWhitespacePendingCharacterToken)for(;s<e.pendingCharacterTokens.length;s++)it(e,e.pendingCharacterTokens[s]);else for(;s<e.pendingCharacterTokens.length;s++)e._insertCharacters(e.pendingCharacterTokens[s]);e.insertionMode=e.originalInsertionMode,e._processToken(t);}const Tt=new Set([I.CAPTION,I.COL,I.COLGROUP,I.TBODY,I.TD,I.TFOOT,I.TH,I.THEAD,I.TR]);function ht(e,t){switch(t.tagID){case I.HTML:$e(e,t);break;case I.COL:e._appendElement(t,d.HTML),t.ackSelfClosing=!0;break;case I.TEMPLATE:Ye(e,t);break;default:_t(e,t);}}function _t(e,t){e.openElements.currentTagId===I.COLGROUP&&(e.openElements.pop(),e.insertionMode=Re.IN_TABLE,e._processToken(t));}function At(e,t){switch(t.tagID){case I.TR:e.openElements.clearBackToTableBodyContext(),e._insertElement(t,d.HTML),e.insertionMode=Re.IN_ROW;break;case I.TH:case I.TD:e.openElements.clearBackToTableBodyContext(),e._insertFakeElement(N.TR,I.TR),e.insertionMode=Re.IN_ROW,mt(e,t);break;case I.CAPTION:case I.COL:case I.COLGROUP:case I.TBODY:case I.TFOOT:case I.THEAD:e.openElements.hasTableBodyContextInTableScope()&&(e.openElements.clearBackToTableBodyContext(),e.openElements.pop(),e.insertionMode=Re.IN_TABLE,rt(e,t));break;default:rt(e,t);}}function lt(e,t){const s=t.tagID;switch(t.tagID){case I.TBODY:case I.TFOOT:case I.THEAD:e.openElements.hasInTableScope(s)&&(e.openElements.clearBackToTableBodyContext(),e.openElements.pop(),e.insertionMode=Re.IN_TABLE);break;case I.TABLE:e.openElements.hasTableBodyContextInTableScope()&&(e.openElements.clearBackToTableBodyContext(),e.openElements.pop(),e.insertionMode=Re.IN_TABLE,nt(e,t));break;case I.BODY:case I.CAPTION:case I.COL:case I.COLGROUP:case I.HTML:case I.TD:case I.TH:case I.TR:break;default:nt(e,t);}}function mt(e,t){switch(t.tagID){case I.TH:case I.TD:e.openElements.clearBackToTableRowContext(),e._insertElement(t,d.HTML),e.insertionMode=Re.IN_CELL,e.activeFormattingElements.insertMarker();break;case I.CAPTION:case I.COL:case I.COLGROUP:case I.TBODY:case I.TFOOT:case I.THEAD:case I.TR:e.openElements.hasInTableScope(I.TR)&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode=Re.IN_TABLE_BODY,At(e,t));break;default:rt(e,t);}}function dt(e,t){switch(t.tagID){case I.TR:e.openElements.hasInTableScope(I.TR)&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode=Re.IN_TABLE_BODY);break;case I.TABLE:e.openElements.hasInTableScope(I.TR)&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode=Re.IN_TABLE_BODY,lt(e,t));break;case I.TBODY:case I.TFOOT:case I.THEAD:(e.openElements.hasInTableScope(t.tagID)||e.openElements.hasInTableScope(I.TR))&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode=Re.IN_TABLE_BODY,lt(e,t));break;case I.BODY:case I.CAPTION:case I.COL:case I.COLGROUP:case I.HTML:case I.TD:case I.TH:break;default:nt(e,t);}}function pt(e,t){switch(t.tagID){case I.HTML:$e(e,t);break;case I.OPTION:e.openElements.currentTagId===I.OPTION&&e.openElements.pop(),e._insertElement(t,d.HTML);break;case I.OPTGROUP:e.openElements.currentTagId===I.OPTION&&e.openElements.pop(),e.openElements.currentTagId===I.OPTGROUP&&e.openElements.pop(),e._insertElement(t,d.HTML);break;case I.INPUT:case I.KEYGEN:case I.TEXTAREA:case I.SELECT:e.openElements.hasInSelectScope(I.SELECT)&&(e.openElements.popUntilTagNamePopped(I.SELECT),e._resetInsertionMode(),t.tagID!==I.SELECT&&e._processStartTag(t));break;case I.SCRIPT:case I.TEMPLATE:Ye(e,t);}}function ut(e,t){switch(t.tagID){case I.OPTGROUP:e.openElements.stackTop>0&&e.openElements.currentTagId===I.OPTION&&e.openElements.tagIDs[e.openElements.stackTop-1]===I.OPTGROUP&&e.openElements.pop(),e.openElements.currentTagId===I.OPTGROUP&&e.openElements.pop();break;case I.OPTION:e.openElements.currentTagId===I.OPTION&&e.openElements.pop();break;case I.SELECT:e.openElements.hasInSelectScope(I.SELECT)&&(e.openElements.popUntilTagNamePopped(I.SELECT),e._resetInsertionMode());break;case I.TEMPLATE:ve(e,t);}}function Nt(e,t){e.openElements.tmplCount>0?(e.openElements.popUntilTagNamePopped(I.TEMPLATE),e.activeFormattingElements.clearToLastMarker(),e.tmplInsertionModeStack.shift(),e._resetInsertionMode(),e.onEof(t)):ye(e,t);}function It(e,t){var s;if(t.tagID===I.HTML){if(e.fragmentContext||(e.insertionMode=Re.AFTER_AFTER_BODY),e.options.sourceCodeLocationInfo&&e.openElements.tagIDs[0]===I.HTML){e._setEndLocation(e.openElements.items[0],t);const a=e.openElements.items[1];a&&!(null===(s=e.treeAdapter.getNodeSourceCodeLocation(a))||void 0===s?void 0:s.endTag)&&e._setEndLocation(a,t);}}else Ct(e,t);}function Ct(e,t){e.insertionMode=Re.IN_BODY,Xe(e,t);}function St(e,t){e.insertionMode=Re.IN_BODY,Xe(e,t);}function Dt(e){for(;e.treeAdapter.getNamespaceURI(e.openElements.current)!==d.HTML&&!e._isIntegrationPoint(e.openElements.currentTagId,e.openElements.current);)e.openElements.pop();}return new Set([N.AREA,N.BASE,N.BASEFONT,N.BGSOUND,N.BR,N.COL,N.EMBED,N.FRAME,N.HR,N.IMG,N.INPUT,N.KEYGEN,N.LINK,N.META,N.PARAM,N.SOURCE,N.TRACK,N.WBR]),e.parse=function(e,t){return Me.parse(e,t)},e.parseFragment=function(e,t,s){"string"==typeof e&&(s=t,t=e,e=null);const a=Me.getFragmentParser(e,s);return a.tokenizer.write(t,!0),a.getFragment()},Object.defineProperty(e,"__esModule",{value:!0}),e}({});const parse=e.parse;const parseFragment=e.parseFragment;

const docParser = new WeakMap();
function parseDocumentUtil(ownerDocument, html) {
    const doc = parse(html.trim(), getParser(ownerDocument));
    doc.documentElement = doc.firstElementChild;
    doc.head = doc.documentElement.firstElementChild;
    doc.body = doc.head.nextElementSibling;
    return doc;
}
function parseFragmentUtil(ownerDocument, html) {
    if (typeof html === 'string') {
        html = html.trim();
    }
    else {
        html = '';
    }
    const frag = parseFragment(html, getParser(ownerDocument));
    return frag;
}
function getParser(ownerDocument) {
    let parseOptions = docParser.get(ownerDocument);
    if (parseOptions != null) {
        return parseOptions;
    }
    const treeAdapter = {
        createDocument() {
            const doc = ownerDocument.createElement("#document" /* NODE_NAMES.DOCUMENT_NODE */);
            doc['x-mode'] = 'no-quirks';
            return doc;
        },
        setNodeSourceCodeLocation(node, location) {
            node.sourceCodeLocation = location;
        },
        getNodeSourceCodeLocation(node) {
            return node.sourceCodeLocation;
        },
        createDocumentFragment() {
            return ownerDocument.createDocumentFragment();
        },
        createElement(tagName, namespaceURI, attrs) {
            const elm = ownerDocument.createElementNS(namespaceURI, tagName);
            for (let i = 0; i < attrs.length; i++) {
                const attr = attrs[i];
                if (attr.namespace == null || attr.namespace === 'http://www.w3.org/1999/xhtml') {
                    elm.setAttribute(attr.name, attr.value);
                }
                else {
                    elm.setAttributeNS(attr.namespace, attr.name, attr.value);
                }
            }
            return elm;
        },
        createCommentNode(data) {
            return ownerDocument.createComment(data);
        },
        appendChild(parentNode, newNode) {
            parentNode.appendChild(newNode);
        },
        insertBefore(parentNode, newNode, referenceNode) {
            parentNode.insertBefore(newNode, referenceNode);
        },
        setTemplateContent(templateElement, contentElement) {
            templateElement.content = contentElement;
        },
        getTemplateContent(templateElement) {
            return templateElement.content;
        },
        setDocumentType(doc, name, publicId, systemId) {
            let doctypeNode = doc.childNodes.find((n) => n.nodeType === 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */);
            if (doctypeNode == null) {
                doctypeNode = ownerDocument.createDocumentTypeNode();
                doc.insertBefore(doctypeNode, doc.firstChild);
            }
            doctypeNode.nodeValue = '!DOCTYPE';
            doctypeNode['x-name'] = name;
            doctypeNode['x-publicId'] = publicId;
            doctypeNode['x-systemId'] = systemId;
        },
        setDocumentMode(doc, mode) {
            doc['x-mode'] = mode;
        },
        getDocumentMode(doc) {
            return doc['x-mode'];
        },
        detachNode(node) {
            node.remove();
        },
        insertText(parentNode, text) {
            const lastChild = parentNode.lastChild;
            if (lastChild != null && lastChild.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
                lastChild.nodeValue += text;
            }
            else {
                parentNode.appendChild(ownerDocument.createTextNode(text));
            }
        },
        insertTextBefore(parentNode, text, referenceNode) {
            const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
            if (prevNode != null && prevNode.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
                prevNode.nodeValue += text;
            }
            else {
                parentNode.insertBefore(ownerDocument.createTextNode(text), referenceNode);
            }
        },
        adoptAttributes(recipient, attrs) {
            for (let i = 0; i < attrs.length; i++) {
                const attr = attrs[i];
                if (recipient.hasAttributeNS(attr.namespace, attr.name) === false) {
                    recipient.setAttributeNS(attr.namespace, attr.name, attr.value);
                }
            }
        },
        getFirstChild(node) {
            return node.childNodes[0];
        },
        getChildNodes(node) {
            return node.childNodes;
        },
        getParentNode(node) {
            return node.parentNode;
        },
        getAttrList(element) {
            const attrs = element.attributes.__items.map((attr) => {
                return {
                    name: attr.name,
                    value: attr.value,
                    namespace: attr.namespaceURI,
                    prefix: null,
                };
            });
            return attrs;
        },
        getTagName(element) {
            if (element.namespaceURI === 'http://www.w3.org/1999/xhtml') {
                return element.nodeName.toLowerCase();
            }
            else {
                return element.nodeName;
            }
        },
        getNamespaceURI(element) {
            // mock-doc widens the type of an element's namespace uri to 'string | null'
            // we use a type assertion here to adhere to parse5's type definitions
            return element.namespaceURI;
        },
        getTextNodeContent(textNode) {
            return textNode.nodeValue;
        },
        getCommentNodeContent(commentNode) {
            return commentNode.nodeValue;
        },
        getDocumentTypeNodeName(doctypeNode) {
            return doctypeNode['x-name'];
        },
        getDocumentTypeNodePublicId(doctypeNode) {
            return doctypeNode['x-publicId'];
        },
        getDocumentTypeNodeSystemId(doctypeNode) {
            return doctypeNode['x-systemId'];
        },
        // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['text']`. As a result, we cannot
        // complete this function signature
        isTextNode(node) {
            return node.nodeType === 3 /* NODE_TYPES.TEXT_NODE */;
        },
        // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['comment']`. As a result, we cannot
        // complete this function signature (which requires its return type to be a type predicate)
        isCommentNode(node) {
            return node.nodeType === 8 /* NODE_TYPES.COMMENT_NODE */;
        },
        // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['document']`. As a result, we cannot
        // complete this function signature (which requires its return type to be a type predicate)
        isDocumentTypeNode(node) {
            return node.nodeType === 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */;
        },
        // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['element']`. As a result, we cannot
        // complete this function signature (which requires its return type to be a type predicate)
        isElementNode(node) {
            return node.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */;
        },
    };
    parseOptions = {
        treeAdapter: treeAdapter,
    };
    docParser.set(ownerDocument, parseOptions);
    return parseOptions;
}

/* eslint-disable */
// @ts-nocheck
/**
 * ATTENTION: DO NOT MODIFY THIS FILE
 *
 * This file is generated by "scripts/updateSelectorEngine.ts" and can be overwritten
 * at any time. Don't make changes in here as they will get lost!
 */
const jQuery = /*!
 * jQuery JavaScript Library v4.0.0-pre+9352011a7.dirty +selector
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-12-11T17:55Z
 */ (function (global, factory) {
    {
        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        return factory(global, true);
    }
    // Pass this if window is not defined yet
})({
    document: {
        createElement() {
            return {};
        },
        nodeType: 9,
        documentElement: {
            nodeType: 1,
            nodeName: 'HTML'
        }
    }
}, function (window, noGlobal) {
    if (!window.document) {
        throw new Error("jQuery requires a window with a document");
    }
    var arr = [];
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    // Support: IE 11+
    // IE doesn't have Array#flat; provide a fallback.
    var flat = arr.flat ? function (array) {
        return arr.flat.call(array);
    } : function (array) {
        return arr.concat.apply([], array);
    };
    var push = arr.push;
    var indexOf = arr.indexOf;
    // [[Class]] -> type pairs
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    // All support tests are defined in their respective modules.
    var support = {};
    function toType(obj) {
        if (obj == null) {
            return obj + "";
        }
        return typeof obj === "object" ?
            class2type[toString.call(obj)] || "object" :
            typeof obj;
    }
    function isWindow(obj) {
        return obj != null && obj === obj.window;
    }
    function isArrayLike(obj) {
        var length = !!obj && obj.length, type = toType(obj);
        if (typeof obj === "function" || isWindow(obj)) {
            return false;
        }
        return type === "array" || length === 0 ||
            typeof length === "number" && length > 0 && (length - 1) in obj;
    }
    var document = window.document;
    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };
    function DOMEval(code, node, doc) {
        doc = doc || document;
        var i, script = doc.createElement("script");
        script.text = code;
        if (node) {
            for (i in preservedScriptAttributes) {
                if (node[i]) {
                    script[i] = node[i];
                }
            }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
    }
    const jQuery = {};
    var version = "4.0.0-pre+9352011a7.dirty +selector", rhtmlSuffix = /HTML$/i; 
    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,
        constructor: jQuery,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function () {
            return slice.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function (num) {
            // Return all the elements in a clean array
            if (num == null) {
                return slice.call(this);
            }
            // Return just the one element from the set
            return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function (elems) {
            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);
            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            // Return the newly-formed element set
            return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function (callback) {
            return jQuery.each(this, callback);
        },
        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function () {
            return this.eq(0);
        },
        last: function () {
            return this.eq(-1);
        },
        even: function () {
            return this.pushStack(jQuery.grep(this, function (_elem, i) {
                return (i + 1) % 2;
            }));
        },
        odd: function () {
            return this.pushStack(jQuery.grep(this, function (_elem, i) {
                return i % 2;
            }));
        },
        eq: function (i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function () {
            return this.prevObject || this.constructor();
        }
    };
    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            // Skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }
        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && typeof target !== "function") {
            target = {};
        }
        // Extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }
        for (; i < length; i++) {
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {
                // Extend the base object
                for (name in options) {
                    copy = options[name];
                    // Prevent Object.prototype pollution
                    // Prevent never-ending loop
                    if (name === "__proto__" || target === copy) {
                        continue;
                    }
                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) ||
                        (copyIsArray = Array.isArray(copy)))) {
                        src = target[name];
                        // Ensure proper type for the source value
                        if (copyIsArray && !Array.isArray(src)) {
                            clone = [];
                        }
                        else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                            clone = {};
                        }
                        else {
                            clone = src;
                        }
                        copyIsArray = false;
                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);
                        // Don't bring in undefined values
                    }
                    else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        // Return the modified object
        return target;
    };
    jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function (msg) {
            throw new Error(msg);
        },
        noop: function () { },
        isPlainObject: function (obj) {
            var proto, Ctor;
            // Detect obvious negatives
            // Use toString instead of jQuery.type to catch host objects
            if (!obj || toString.call(obj) !== "[object Object]") {
                return false;
            }
            proto = getProto(obj);
            // Objects with no prototype (e.g., `Object.create( null )`) are plain
            if (!proto) {
                return true;
            }
            // Objects with prototype are plain iff they were constructed by a global Object function
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function (code, options, doc) {
            DOMEval(code, { nonce: options && options.nonce }, doc);
        },
        each: function (obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }
            else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }
            return obj;
        },
        // Retrieve the text value of an array of DOM nodes
        text: function (elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                // If no nodeType, this is expected to be an array
                while ((node = elem[i++])) {
                    // Do not traverse comment nodes
                    ret += jQuery.text(node);
                }
            }
            if (nodeType === 1 || nodeType === 11) {
                return elem.textContent;
            }
            if (nodeType === 9) {
                return elem.documentElement.textContent;
            }
            if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            // Do not include comment or processing instruction nodes
            return ret;
        },
        // results is for internal usage only
        makeArray: function (arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ?
                        [arr] : arr);
                }
                else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        isXMLDoc: function (elem) {
            var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
            // Assume HTML when documentElement doesn't yet exist, such as inside
            // document fragments.
            return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
        },
        // Note: an element does not contain itself
        contains: function (a, b) {
            var bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && (
            // Support: IE 9 - 11+
            // IE doesn't have `contains` on SVG.
            a.contains ?
                a.contains(bup) :
                a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        },
        merge: function (first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (; j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function (elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            // Go through the array, only saving the items
            // that pass the validator function
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        // arg is for internal usage only
        map: function (elems, callback, arg) {
            var length, value, i = 0, ret = [];
            // Go through the array, translating each of the items to their new values
            if (isArrayLike(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
                // Go through every key on the object,
            }
            else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            // Flatten any nested arrays
            return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });
    if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    var pop = arr.pop;
    // https://www.w3.org/TR/css3-selectors/#whitespace
    var whitespace = "[\\x20\\t\\r\\n\\f]";
    var isIE = document.documentMode;
    // Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
    // Make sure the `:has()` argument is parsed unforgivingly.
    // We include `*` in the test to detect buggy implementations that are
    // _selectively_ forgiving (specifically when the list includes at least
    // one valid selector).
    // Note that we treat complete lack of support for `:has()` as if it were
    // spec-compliant support, which is fine because use of `:has()` in such
    // environments will fail in the qSA path and fall back to jQuery traversal
    // anyway.
    try {
        document.querySelector(":has(*,:jqfake)");
        support.cssHas = false;
    }
    catch (e) {
        support.cssHas = true;
    }
    // Build QSA regex.
    // Regex strategy adopted from Diego Perini.
    var rbuggyQSA = [];
    if (isIE) {
        rbuggyQSA.push(
        // Support: IE 9 - 11+
        // IE's :disabled selector does not pick up the children of disabled fieldsets
        ":enabled", ":disabled", 
        // Support: IE 11+
        // IE 11 doesn't find elements on a `[name='']` query in some cases.
        // Adding a temporary attribute to the document before the selection works
        // around the issue.
        "\\[" + whitespace + "*name" + whitespace + "*=" +
            whitespace + "*(?:''|\"\")");
    }
    if (!support.cssHas) {
        // Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
        // Our regular `try-catch` mechanism fails to detect natively-unsupported
        // pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
        // in browsers that parse the `:has()` argument as a forgiving selector list.
        // https://drafts.csswg.org/selectors/#relational now requires the argument
        // to be parsed unforgivingly, but browsers have not yet fully adjusted.
        rbuggyQSA.push(":has");
    }
    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
    var rtrimCSS = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g");
    // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
    var identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
        "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+";
    var booleans = "checked|selected|async|autofocus|autoplay|controls|" +
        "defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped";
    var rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" +
        whitespace + ")" + whitespace + "*");
    var rsibling = /[+~]/;
    var documentElement = document.documentElement;
    // Support: IE 9 - 11+
    // IE requires a prefix.
    var matches = documentElement.matches || documentElement.msMatchesSelector;
    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */
    function createCache() {
        var keys = [];
        function cache(key, value) {
            // Use (key + " ") to avoid collision with native prototype properties
            // (see https://github.com/jquery/sizzle/issues/157)
            if (keys.push(key + " ") > jQuery.expr.cacheLength) {
                // Only keep the most recent entries
                delete cache[keys.shift()];
            }
            return (cache[key + " "] = value);
        }
        return cache;
    }
    /**
     * Checks a node for validity as a jQuery selector context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */
    function testContext(context) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    // Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
    var attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
        // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace +
        // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
        whitespace + "*\\]";
    var pseudos = ":(" + identifier + ")(?:\\((" +
        // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
        // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
        // 3. anything else (capture 2)
        ".*" +
        ")\\)|)";
    var filterMatchExpr = {
        ID: new RegExp("^#(" + identifier + ")"),
        CLASS: new RegExp("^\\.(" + identifier + ")"),
        TAG: new RegExp("^(" + identifier + "|[*])"),
        ATTR: new RegExp("^" + attributes),
        PSEUDO: new RegExp("^" + pseudos),
        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
            whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
            whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i")
    };
    var rpseudo = new RegExp(pseudos);
    // CSS escapes
    var runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace +
        "?|\\\\([^\\r\\n\\f])", "g"), funescape = function (escape, nonHex) {
        var high = "0x" + escape.slice(1) - 0x10000;
        if (nonHex) {
            // Strip the backslash prefix from a non-hex escape sequence
            return nonHex;
        }
        // Replace a hexadecimal escape sequence with the encoded Unicode code point
        // Support: IE <=11+
        // For values outside the Basic Multilingual Plane (BMP), manually construct a
        // surrogate pair
        return high < 0 ?
            String.fromCharCode(high + 0x10000) :
            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
    };
    function unescapeSelector(sel) {
        return sel.replace(runescape, funescape);
    }
    function selectorError(msg) {
        jQuery.error("Syntax error, unrecognized expression: " + msg);
    }
    var rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*");
    var tokenCache = createCache();
    function tokenize(selector, parseOnly) {
        var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
        if (cached) {
            return parseOnly ? 0 : cached.slice(0);
        }
        soFar = selector;
        groups = [];
        preFilters = jQuery.expr.preFilter;
        while (soFar) {
            // Comma and first run
            if (!matched || (match = rcomma.exec(soFar))) {
                if (match) {
                    // Don't consume trailing commas as valid
                    soFar = soFar.slice(match[0].length) || soFar;
                }
                groups.push((tokens = []));
            }
            matched = false;
            // Combinators
            if ((match = rleadingCombinator.exec(soFar))) {
                matched = match.shift();
                tokens.push({
                    value: matched,
                    // Cast descendant combinators to space
                    type: match[0].replace(rtrimCSS, " ")
                });
                soFar = soFar.slice(matched.length);
            }
            // Filters
            for (type in filterMatchExpr) {
                if ((match = jQuery.expr.match[type].exec(soFar)) && (!preFilters[type] ||
                    (match = preFilters[type](match)))) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    });
                    soFar = soFar.slice(matched.length);
                }
            }
            if (!matched) {
                break;
            }
        }
        // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens
        if (parseOnly) {
            return soFar.length;
        }
        return soFar ?
            selectorError(selector) :
            // Cache the tokens
            tokenCache(selector, groups).slice(0);
    }
    var preFilter = {
        ATTR: function (match) {
            match[1] = unescapeSelector(match[1]);
            // Move the given value to match[3] whether quoted or unquoted
            match[3] = unescapeSelector(match[3] || match[4] || match[5] || "");
            if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
            }
            return match.slice(0, 4);
        },
        CHILD: function (match) {
            /* matches from filterMatchExpr["CHILD"]
                1 type (only|nth|...)
                2 what (child|of-type)
                3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                4 xn-component of xn+y argument ([+-]?\d*n|)
                5 sign of xn-component
                6 x of xn-component
                7 sign of y-component
                8 y of y-component
            */
            match[1] = match[1].toLowerCase();
            if (match[1].slice(0, 3) === "nth") {
                // nth-* requires argument
                if (!match[3]) {
                    selectorError(match[0]);
                }
                // numeric x and y parameters for jQuery.expr.filter.CHILD
                // remember that false/true cast respectively to 0/1
                match[4] = +(match[4] ?
                    match[5] + (match[6] || 1) :
                    2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +((match[7] + match[8]) || match[3] === "odd");
                // other types prohibit arguments
            }
            else if (match[3]) {
                selectorError(match[0]);
            }
            return match;
        },
        PSEUDO: function (match) {
            var excess, unquoted = !match[6] && match[2];
            if (filterMatchExpr.CHILD.test(match[0])) {
                return null;
            }
            // Accept quoted arguments as-is
            if (match[3]) {
                match[2] = match[4] || match[5] || "";
                // Strip excess characters from unquoted arguments
            }
            else if (unquoted && rpseudo.test(unquoted) &&
                // Get excess from tokenize (recursively)
                (excess = tokenize(unquoted, true)) &&
                // advance to the next closing parenthesis
                (excess = unquoted.indexOf(")", unquoted.length - excess) -
                    unquoted.length)) {
                // excess is a negative index
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
            }
            // Return only captures needed by the pseudo filter method (type and argument)
            return match.slice(0, 3);
        }
    };
    function toSelector(tokens) {
        var i = 0, len = tokens.length, selector = "";
        for (; i < len; i++) {
            selector += tokens[i].value;
        }
        return selector;
    }
    // CSS string/identifier serialization
    // https://drafts.csswg.org/cssom/#common-serializing-idioms
    var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
    function fcssescape(ch, asCodePoint) {
        if (asCodePoint) {
            // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
            if (ch === "\0") {
                return "\uFFFD";
            }
            // Control characters and (dependent upon position) numbers get escaped as code points
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }
        // Other potentially-special ASCII characters get backslash-escaped
        return "\\" + ch;
    }
    jQuery.escapeSelector = function (sel) {
        return (sel + "").replace(rcssescape, fcssescape);
    };
    var sort = arr.sort;
    var splice = arr.splice;
    var hasDuplicate;
    // Document order sorting
    function sortOrder(a, b) {
        // Flag for duplicate removal
        if (a === b) {
            hasDuplicate = true;
            return 0;
        }
        // Sort on method existence if only one input has compareDocumentPosition
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
            return compare;
        }
        // Calculate position if both inputs belong to the same document
        // Support: IE 11+
        // IE sometimes throws a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ?
            a.compareDocumentPosition(b) :
            // Otherwise we know they are disconnected
            1;
        // Disconnected nodes
        if (compare & 1) {
            // Choose the first element that is related to the document
            // Support: IE 11+
            // IE sometimes throws a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if (a == document || a.ownerDocument == document &&
                jQuery.contains(document, a)) {
                return -1;
            }
            // Support: IE 11+
            // IE sometimes throws a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if (b == document || b.ownerDocument == document &&
                jQuery.contains(document, b)) {
                return 1;
            }
            // Maintain original order
            return 0;
        }
        return compare & 4 ? -1 : 1;
    }
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */
    jQuery.uniqueSort = function (results) {
        var elem, duplicates = [], j = 0, i = 0;
        hasDuplicate = false;
        sort.call(results, sortOrder);
        if (hasDuplicate) {
            while ((elem = results[i++])) {
                if (elem === results[i]) {
                    j = duplicates.push(i);
                }
            }
            while (j--) {
                splice.call(results, duplicates[j], 1);
            }
        }
        return results;
    };
    jQuery.fn.uniqueSort = function () {
        return this.pushStack(jQuery.uniqueSort(slice.apply(this)));
    };
    var i, outermostContext, 
    // Local document vars
    document$1, documentElement$1, documentIsHTML, 
    // Instance-specific data
    dirruns = 0, done = 0, classCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), 
    // Regular expressions
    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rwhitespace = new RegExp(whitespace + "+", "g"), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = jQuery.extend({
        bool: new RegExp("^(?:" + booleans + ")$", "i"),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        needsContext: new RegExp("^" + whitespace +
            "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
            "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    }, filterMatchExpr), rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, 
    // Used for iframes; see `setDocument`.
    // Support: IE 9 - 11+
    // Removing the function wrapper causes a "Permission Denied"
    // error in IE.
    unloadHandler = function () {
        setDocument();
    }, inDisabledFieldset = addCombinator(function (elem) {
        return elem.disabled === true && nodeName(elem, "fieldset");
    }, { dir: "parentNode", next: "legend" });
    function find(selector, context, results, seed) {
        context && context.ownerDocument; 
        var // nodeType defaults to 9, since context defaults to document
        nodeType = context ? context.nodeType : 9;
        results = results || [];
        // Return early from calls with invalid selector or context
        if (typeof selector !== "string" || !selector ||
            nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
        }
        // All others
        return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
    }
    /**
     * Mark a function for special use by jQuery selector module
     * @param {Function} fn The function to mark
     */
    function markFunction(fn) {
        fn[jQuery.expando] = true;
        return fn;
    }
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */
    function createInputPseudo(type) {
        return function (elem) {
            return nodeName(elem, "input") && elem.type === type;
        };
    }
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */
    function createButtonPseudo(type) {
        return function (elem) {
            return (nodeName(elem, "input") || nodeName(elem, "button")) &&
                elem.type === type;
        };
    }
    /**
     * Returns a function to use in pseudos for :enabled/:disabled
     * @param {Boolean} disabled true for :disabled; false for :enabled
     */
    function createDisabledPseudo(disabled) {
        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
        return function (elem) {
            // Only certain elements can match :enabled or :disabled
            // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
            // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
            if ("form" in elem) {
                // Check for inherited disabledness on relevant non-disabled elements:
                // * listed form-associated elements in a disabled fieldset
                //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                // * option elements in a disabled optgroup
                //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                // All such elements have a "form" property.
                if (elem.parentNode && elem.disabled === false) {
                    // Option elements defer to a parent optgroup if present
                    if ("label" in elem) {
                        if ("label" in elem.parentNode) {
                            return elem.parentNode.disabled === disabled;
                        }
                        else {
                            return elem.disabled === disabled;
                        }
                    }
                    // Support: IE 6 - 11+
                    // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                    return elem.isDisabled === disabled ||
                        // Where there is no isDisabled, check manually
                        elem.isDisabled !== !disabled &&
                            inDisabledFieldset(elem) === disabled;
                }
                return elem.disabled === disabled;
                // Try to winnow out elements that can't be disabled before trusting the disabled property.
                // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                // even exist on them, let alone have a boolean value.
            }
            else if ("label" in elem) {
                return elem.disabled === disabled;
            }
            // Remaining elements are neither :enabled nor :disabled
            return false;
        };
    }
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */
    function createPositionalPseudo(fn) {
        return markFunction(function (argument) {
            argument = +argument;
            return markFunction(function (seed, matches) {
                var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                // Match elements found at the specified indexes
                while (i--) {
                    if (seed[(j = matchIndexes[i])]) {
                        seed[j] = !(matches[j] = seed[j]);
                    }
                }
            });
        });
    }
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [node] An element or document object to use to set the document
     */
    function setDocument(node) {
        var subWindow, doc = node ? node.ownerDocument || node : document;
        // Return early if doc is invalid or already selected
        // Support: IE 11+
        // IE sometimes throws a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if (doc == document$1 || doc.nodeType !== 9) {
            return;
        }
        // Update global variables
        document$1 = doc;
        documentElement$1 = document$1.documentElement;
        documentIsHTML = !jQuery.isXMLDoc(document$1);
        // Support: IE 9 - 11+
        // Accessing iframe documents after unload throws "permission denied" errors (see trac-13936)
        // Support: IE 11+
        // IE sometimes throws a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if (isIE && document != document$1 &&
            (subWindow = document$1.defaultView) && subWindow.top !== subWindow) {
            subWindow.addEventListener("unload", unloadHandler);
        }
    }
    find.matches = function (expr, elements) {
        return find(expr, null, null, elements);
    };
    find.matchesSelector = function (elem, expr) {
        setDocument(elem);
        if (documentIsHTML &&
            !nonnativeSelectorCache[expr + " "] &&
            (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
                return matches.call(elem, expr);
            }
            catch (e) {
                nonnativeSelectorCache(expr, true);
            }
        }
        return find(expr, document$1, null, [elem]).length > 0;
    };
    jQuery.expr = {
        // Can be adjusted by the user
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        find: {
            ID: function (id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                    var elem = context.getElementById(id);
                    return elem ? [elem] : [];
                }
            },
            TAG: function (tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                    return context.getElementsByTagName(tag);
                    // DocumentFragment nodes don't have gEBTN
                }
                else {
                    return context.querySelectorAll(tag);
                }
            },
            CLASS: function (className, context) {
                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            }
        },
        relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
        },
        preFilter: preFilter,
        filter: {
            ID: function (id) {
                var attrId = unescapeSelector(id);
                return function (elem) {
                    return elem.getAttribute("id") === attrId;
                };
            },
            TAG: function (nodeNameSelector) {
                var expectedNodeName = unescapeSelector(nodeNameSelector).toLowerCase();
                return nodeNameSelector === "*" ?
                    function () {
                        return true;
                    } :
                    function (elem) {
                        return nodeName(elem, expectedNodeName);
                    };
            },
            CLASS: function (className) {
                var pattern = classCache[className + " "];
                return pattern ||
                    (pattern = new RegExp("(^|" + whitespace + ")" + className +
                        "(" + whitespace + "|$)")) &&
                        classCache(className, function (elem) {
                            return pattern.test(typeof elem.className === "string" && elem.className ||
                                typeof elem.getAttribute !== "undefined" &&
                                    elem.getAttribute("class") ||
                                "");
                        });
            },
            ATTR: function (name, operator, check) {
                return function (elem) {
                    var result = elem.getAttribute(name);
                    if (result == null) {
                        return operator === "!=";
                    }
                    if (!operator) {
                        return true;
                    }
                    result += "";
                    if (operator === "=") {
                        return result === check;
                    }
                    if (operator === "!=") {
                        return result !== check;
                    }
                    if (operator === "^=") {
                        return check && result.indexOf(check) === 0;
                    }
                    if (operator === "*=") {
                        return check && result.indexOf(check) > -1;
                    }
                    if (operator === "$=") {
                        return check && result.slice(-check.length) === check;
                    }
                    if (operator === "~=") {
                        return (" " + result.replace(rwhitespace, " ") + " ")
                            .indexOf(check) > -1;
                    }
                    if (operator === "|=") {
                        return result === check || result.slice(0, check.length + 1) === check + "-";
                    }
                    return false;
                };
            },
            CHILD: function (type, what, _argument, first, last) {
                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                return first === 1 && last === 0 ?
                    // Shortcut for :nth-*(n)
                    function (elem) {
                        return !!elem.parentNode;
                    } :
                    function (elem, _context, xml) {
                        var cache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                        if (parent) {
                            // :(first|last|only)-(child|of-type)
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while ((node = node[dir])) {
                                        if (ofType ?
                                            nodeName(node, name) :
                                            node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    // Reverse direction for :only-* (if we haven't yet done so)
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [forward ? parent.firstChild : parent.lastChild];
                            // non-xml :nth-child(...) stores cache data on `parent`
                            if (forward && useCache) {
                                // Seek `elem` from a previously-cached index
                                outerCache = parent[jQuery.expando] ||
                                    (parent[jQuery.expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while ((node = ++nodeIndex && node && node[dir] ||
                                    // Fallback to seeking `elem` from the start
                                    (diff = nodeIndex = 0) || start.pop())) {
                                    // When found, cache indexes on `parent` and break
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [dirruns, nodeIndex, diff];
                                        break;
                                    }
                                }
                            }
                            else {
                                // Use previously-cached element index if available
                                if (useCache) {
                                    outerCache = elem[jQuery.expando] ||
                                        (elem[jQuery.expando] = {});
                                    cache = outerCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }
                                // xml :nth-child(...)
                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                if (diff === false) {
                                    // Use the same loop as above to seek `elem` from the start
                                    while ((node = ++nodeIndex && node && node[dir] ||
                                        (diff = nodeIndex = 0) || start.pop())) {
                                        if ((ofType ?
                                            nodeName(node, name) :
                                            node.nodeType === 1) &&
                                            ++diff) {
                                            // Cache the index of each encountered element
                                            if (useCache) {
                                                outerCache = node[jQuery.expando] ||
                                                    (node[jQuery.expando] = {});
                                                outerCache[type] = [dirruns, diff];
                                            }
                                            if (node === elem) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            // Incorporate the offset, then check against cycle size
                            diff -= last;
                            return diff === first || (diff % first === 0 && diff / first >= 0);
                        }
                    };
            },
            PSEUDO: function (pseudo, argument) {
                // pseudo-class names are case-insensitive
                // https://www.w3.org/TR/selectors/#pseudo-classes
                // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                // Remember that setFilters inherits from pseudos
                var fn = jQuery.expr.pseudos[pseudo] ||
                    jQuery.expr.setFilters[pseudo.toLowerCase()] ||
                    selectorError("unsupported pseudo: " + pseudo);
                // The user may use createPseudo to indicate that
                // arguments are needed to create the filter function
                // just as jQuery does
                if (fn[jQuery.expando]) {
                    return fn(argument);
                }
                return fn;
            }
        },
        pseudos: {
            // Potentially complex pseudos
            not: markFunction(function (selector) {
                // Trim the selector passed to compile
                // to avoid treating leading and trailing
                // spaces as combinators
                var input = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
                return matcher[jQuery.expando] ?
                    markFunction(function (seed, matches, _context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        // Match elements unmatched by `matcher`
                        while (i--) {
                            if ((elem = unmatched[i])) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) :
                    function (elem, _context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        // Don't keep the element
                        // (see https://github.com/jquery/sizzle/issues/299)
                        input[0] = null;
                        return !results.pop();
                    };
            }),
            has: markFunction(function (selector) {
                return function (elem) {
                    return find(selector, elem).length > 0;
                };
            }),
            contains: markFunction(function (text) {
                text = unescapeSelector(text);
                return function (elem) {
                    return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
                };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // https://www.w3.org/TR/selectors/#lang-pseudo
            lang: markFunction(function (lang) {
                // lang value must be a valid identifier
                if (!ridentifier.test(lang || "")) {
                    selectorError("unsupported lang: " + lang);
                }
                lang = unescapeSelector(lang).toLowerCase();
                return function (elem) {
                    var elemLang;
                    do {
                        if ((elemLang = documentIsHTML ?
                            elem.lang :
                            elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                            elemLang = elemLang.toLowerCase();
                            return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                        }
                    } while ((elem = elem.parentNode) && elem.nodeType === 1);
                    return false;
                };
            }),
            // Miscellaneous
            target: function (elem) {
                var hash = window.location && window.location.hash;
                return hash && hash.slice(1) === elem.id;
            },
            root: function (elem) {
                return elem === documentElement$1;
            },
            focus: function (elem) {
                return elem === document$1.activeElement &&
                    document$1.hasFocus() &&
                    !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            enabled: createDisabledPseudo(false),
            disabled: createDisabledPseudo(true),
            checked: function (elem) {
                // In CSS3, :checked should return both checked and selected elements
                // https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                return (nodeName(elem, "input") && !!elem.checked) ||
                    (nodeName(elem, "option") && !!elem.selected);
            },
            selected: function (elem) {
                // Support: IE <=11+
                // Accessing the selectedIndex property
                // forces the browser to treat the default option as
                // selected when in an optgroup.
                if (isIE && elem.parentNode) {
                    // eslint-disable-next-line no-unused-expressions
                    elem.parentNode.selectedIndex;
                }
                return elem.selected === true;
            },
            // Contents
            empty: function (elem) {
                // https://www.w3.org/TR/selectors/#empty-pseudo
                // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                //   but not by others (comment: 8; processing instruction: 7; etc.)
                // nodeType < 6 works because attributes (2) do not appear as children
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                    if (elem.nodeType < 6) {
                        return false;
                    }
                }
                return true;
            },
            parent: function (elem) {
                return !jQuery.expr.pseudos.empty(elem);
            },
            // Element/input types
            header: function (elem) {
                return rheader.test(elem.nodeName);
            },
            input: function (elem) {
                return rinputs.test(elem.nodeName);
            },
            button: function (elem) {
                return nodeName(elem, "input") && elem.type === "button" ||
                    nodeName(elem, "button");
            },
            text: function (elem) {
                return nodeName(elem, "input") && elem.type === "text";
            },
            // Position-in-collection
            first: createPositionalPseudo(function () {
                return [0];
            }),
            last: createPositionalPseudo(function (_matchIndexes, length) {
                return [length - 1];
            }),
            eq: createPositionalPseudo(function (_matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument];
            }),
            even: createPositionalPseudo(function (matchIndexes, length) {
                var i = 0;
                for (; i < length; i += 2) {
                    matchIndexes.push(i);
                }
                return matchIndexes;
            }),
            odd: createPositionalPseudo(function (matchIndexes, length) {
                var i = 1;
                for (; i < length; i += 2) {
                    matchIndexes.push(i);
                }
                return matchIndexes;
            }),
            lt: createPositionalPseudo(function (matchIndexes, length, argument) {
                var i;
                if (argument < 0) {
                    i = argument + length;
                }
                else if (argument > length) {
                    i = length;
                }
                else {
                    i = argument;
                }
                for (; --i >= 0;) {
                    matchIndexes.push(i);
                }
                return matchIndexes;
            }),
            gt: createPositionalPseudo(function (matchIndexes, length, argument) {
                var i = argument < 0 ? argument + length : argument;
                for (; ++i < length;) {
                    matchIndexes.push(i);
                }
                return matchIndexes;
            })
        }
    };
    jQuery.expr.pseudos.nth = jQuery.expr.pseudos.eq;
    // Add button/input type pseudos
    for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
        jQuery.expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in { submit: true, reset: true }) {
        jQuery.expr.pseudos[i] = createButtonPseudo(i);
    }
    // Easy API for creating new setFilters
    function setFilters() { }
    setFilters.prototype = jQuery.expr.filters = jQuery.expr.pseudos;
    jQuery.expr.setFilters = new setFilters();
    function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === "parentNode", doneName = done++;
        return combinator.first ?
            // Check against closest ancestor/preceding element
            function (elem, context, xml) {
                while ((elem = elem[dir])) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
                return false;
            } :
            // Check against all ancestor/preceding elements
            function (elem, context, xml) {
                var oldCache, outerCache, newCache = [dirruns, doneName];
                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                if (xml) {
                    while ((elem = elem[dir])) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                }
                else {
                    while ((elem = elem[dir])) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[jQuery.expando] || (elem[jQuery.expando] = {});
                            if (skip && nodeName(elem, skip)) {
                                elem = elem[dir] || elem;
                            }
                            else if ((oldCache = outerCache[key]) &&
                                oldCache[0] === dirruns && oldCache[1] === doneName) {
                                // Assign to newCache so results back-propagate to previous elements
                                return (newCache[2] = oldCache[2]);
                            }
                            else {
                                // Reuse newcache so results back-propagate to previous elements
                                outerCache[key] = newCache;
                                // A match means we're done; a fail means we have to keep checking
                                if ((newCache[2] = matcher(elem, context, xml))) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            };
    }
    function elementMatcher(matchers) {
        return matchers.length > 1 ?
            function (elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } :
            matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
        var i = 0, len = contexts.length;
        for (; i < len; i++) {
            find(selector, contexts[i], results);
        }
        return results;
    }
    function condense(unmatched, map, filter, context, xml) {
        var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
        for (; i < len; i++) {
            if ((elem = unmatched[i])) {
                if (!filter || filter(elem, context, xml)) {
                    newUnmatched.push(elem);
                    if (mapped) {
                        map.push(i);
                    }
                }
            }
        }
        return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[jQuery.expando]) {
            postFilter = setMatcher(postFilter);
        }
        if (postFinder && !postFinder[jQuery.expando]) {
            postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function (seed, results, context, xml) {
            var temp, i, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, 
            // Get initial elements from seed or context
            elems = seed ||
                multipleContexts(selector || "*", context.nodeType ? [context] : context, []), 
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter && (seed || !selector) ?
                condense(elems, preMap, preFilter, context, xml) :
                elems;
            if (matcher) {
                // If we have a postFinder, or filtered seed, or non-seed postFilter
                // or preexisting results,
                matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ?
                    // ...intermediate processing is necessary
                    [] :
                    // ...otherwise use results directly
                    results;
                // Find primary matches
                matcher(matcherIn, matcherOut, context, xml);
            }
            else {
                matcherOut = matcherIn;
            }
            // Apply postFilter
            if (postFilter) {
                temp = condense(matcherOut, postMap);
                postFilter(temp, [], context, xml);
                // Un-match failing elements by moving them back to matcherIn
                i = temp.length;
                while (i--) {
                    if ((elem = temp[i])) {
                        matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                    }
                }
            }
            if (seed) {
                if (postFinder || preFilter) {
                    if (postFinder) {
                        // Get the final matcherOut by condensing this intermediate into postFinder contexts
                        temp = [];
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i])) {
                                // Restore matcherIn since elem is not yet a final match
                                temp.push((matcherIn[i] = elem));
                            }
                        }
                        postFinder(null, (matcherOut = []), temp, xml);
                    }
                    // Move matched elements from seed to results to keep them synchronized
                    i = matcherOut.length;
                    while (i--) {
                        if ((elem = matcherOut[i]) &&
                            (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                            seed[temp] = !(results[temp] = elem);
                        }
                    }
                }
                // Add elements to results, through postFinder if defined
            }
            else {
                matcherOut = condense(matcherOut === results ?
                    matcherOut.splice(preexisting, matcherOut.length) :
                    matcherOut);
                if (postFinder) {
                    postFinder(null, results, matcherOut, xml);
                }
                else {
                    push.apply(results, matcherOut);
                }
            }
        });
    }
    function matcherFromTokens(tokens) {
        var checkContext, matcher, j, len = tokens.length, leadingRelative = jQuery.expr.relative[tokens[0].type], implicitRelative = leadingRelative || jQuery.expr.relative[" "], i = leadingRelative ? 1 : 0, 
        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator(function (elem) {
            return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
            return indexOf.call(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [function (elem, context, xml) {
                // Support: IE 11+
                // IE sometimes throws a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                var ret = (!leadingRelative && (xml || context != outermostContext)) || ((checkContext = context).nodeType ?
                    matchContext(elem, context, xml) :
                    matchAnyContext(elem, context, xml));
                // Avoid hanging onto element
                // (see https://github.com/jquery/sizzle/issues/299)
                checkContext = null;
                return ret;
            }];
        for (; i < len; i++) {
            if ((matcher = jQuery.expr.relative[tokens[i].type])) {
                matchers = [addCombinator(elementMatcher(matchers), matcher)];
            }
            else {
                matcher = jQuery.expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                // Return special upon seeing a positional matcher
                if (matcher[jQuery.expando]) {
                    // Find the next relative operator (if any) for proper handling
                    j = ++i;
                    for (; j < len; j++) {
                        if (jQuery.expr.relative[tokens[j].type]) {
                            break;
                        }
                    }
                    return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i - 1)
                        .concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrimCSS, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
                }
                matchers.push(matcher);
            }
        }
        return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
            var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, 
            // We must always have either seed elements or outermost context
            elems = seed || byElement && jQuery.expr.find.TAG("*", outermost), 
            // Use integer dirruns iff this is the outermost matcher
            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);
            if (outermost) {
                // Support: IE 11+
                // IE sometimes throws a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                outermostContext = context == document$1 || context || outermost;
            }
            // Add elements passing elementMatchers directly to results
            for (; (elem = elems[i]) != null; i++) {
                if (byElement && elem) {
                    j = 0;
                    // Support: IE 11+
                    // IE sometimes throws a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    // eslint-disable-next-line eqeqeq
                    if (!context && elem.ownerDocument != document$1) {
                        setDocument(elem);
                        xml = !documentIsHTML;
                    }
                    while ((matcher = elementMatchers[j++])) {
                        if (matcher(elem, context || document$1, xml)) {
                            push.call(results, elem);
                            break;
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                    }
                }
                // Track unmatched elements for set filters
                if (bySet) {
                    // They will have gone through all possible matchers
                    if ((elem = !matcher && elem)) {
                        matchedCount--;
                    }
                    // Lengthen the array for every element, matched or not
                    if (seed) {
                        unmatched.push(elem);
                    }
                }
            }
            // `i` is now the count of elements visited above, and adding it to `matchedCount`
            // makes the latter nonnegative.
            matchedCount += i;
            // Apply set filters to unmatched elements
            // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
            // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
            // no element matchers and no seed.
            // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
            // case, which will result in a "00" `matchedCount` that differs from `i` but is also
            // numerically zero.
            if (bySet && i !== matchedCount) {
                j = 0;
                while ((matcher = setMatchers[j++])) {
                    matcher(unmatched, setMatched, context, xml);
                }
                if (seed) {
                    // Reintegrate element matches to eliminate the need for sorting
                    if (matchedCount > 0) {
                        while (i--) {
                            if (!(unmatched[i] || setMatched[i])) {
                                setMatched[i] = pop.call(results);
                            }
                        }
                    }
                    // Discard index placeholder values to get only actual matches
                    setMatched = condense(setMatched);
                }
                // Add matches to results
                push.apply(results, setMatched);
                // Seedless set matches succeeding multiple successful matchers stipulate sorting
                if (outermost && !seed && setMatched.length > 0 &&
                    (matchedCount + setMatchers.length) > 1) {
                    jQuery.uniqueSort(results);
                }
            }
            // Override manipulation of globals by nested matchers
            if (outermost) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
            }
            return unmatched;
        };
        return bySet ?
            markFunction(superMatcher) :
            superMatcher;
    }
    function compile(selector, match /* Internal Use Only */) {
        var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
        if (!cached) {
            // Generate a function of recursive functions that can be used to check each element
            if (!match) {
                match = tokenize(selector);
            }
            i = match.length;
            while (i--) {
                cached = matcherFromTokens(match[i]);
                if (cached[jQuery.expando]) {
                    setMatchers.push(cached);
                }
                else {
                    elementMatchers.push(cached);
                }
            }
            // Cache the compiled function
            cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            // Save selector and tokenization
            cached.selector = selector;
        }
        return cached;
    }
    /**
     * A low-level selection function that works with jQuery's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with jQuery selector compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */
    function select(selector, context, results, seed) {
        var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize((selector = compiled.selector || selector));
        results = results || [];
        // Try to minimize operations if there is only one selector in the list and no seed
        // (the latter of which guarantees us context)
        if (match.length === 1) {
            // Reduce context if the leading compound selector is an ID
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                context.nodeType === 9 && documentIsHTML &&
                jQuery.expr.relative[tokens[1].type]) {
                context = (jQuery.expr.find.ID(unescapeSelector(token.matches[0]), context) || [])[0];
                if (!context) {
                    return results;
                    // Precompiled matchers will still verify ancestry, so step up a level
                }
                else if (compiled) {
                    context = context.parentNode;
                }
                selector = selector.slice(tokens.shift().value.length);
            }
            // Fetch a seed set for right-to-left matching
            i = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
            while (i--) {
                token = tokens[i];
                // Abort if we hit a combinator
                if (jQuery.expr.relative[(type = token.type)]) {
                    break;
                }
                if ((find = jQuery.expr.find[type])) {
                    // Search, expanding context for leading sibling combinators
                    if ((seed = find(unescapeSelector(token.matches[0]), rsibling.test(tokens[0].type) &&
                        testContext(context.parentNode) || context))) {
                        // If seed is empty or no tokens remain, we can return early
                        tokens.splice(i, 1);
                        selector = seed.length && toSelector(tokens);
                        if (!selector) {
                            push.apply(results, seed);
                            return results;
                        }
                        break;
                    }
                }
            }
        }
        // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above
        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
        return results;
    }
    // Initialize against the default document
    setDocument();
    jQuery.find = find;
    // These have always been private, but they used to be documented as part of
    // Sizzle so let's maintain them for now for backwards compatibility purposes.
    find.compile = compile;
    find.select = select;
    find.setDocument = setDocument;
    find.tokenize = tokenize;
    return jQuery;
});

function matches(selector, elm) {
    const r = jQuery.find(selector, undefined, undefined, [elm]);
    return r.length > 0;
}
function selectOne(selector, elm) {
    const r = jQuery.find(selector, elm, undefined, undefined);
    return r[0] || null;
}
function selectAll(selector, elm) {
    return jQuery.find(selector, elm, undefined, undefined);
}

function serializeNodeToHtml(elm, opts = {}) {
    const output = {
        currentLineWidth: 0,
        indent: 0,
        isWithinBody: false,
        text: [],
    };
    if (opts.prettyHtml) {
        if (typeof opts.indentSpaces !== 'number') {
            opts.indentSpaces = 2;
        }
        if (typeof opts.newLines !== 'boolean') {
            opts.newLines = true;
        }
        opts.approximateLineWidth = -1;
    }
    else {
        opts.prettyHtml = false;
        if (typeof opts.newLines !== 'boolean') {
            opts.newLines = false;
        }
        if (typeof opts.indentSpaces !== 'number') {
            opts.indentSpaces = 0;
        }
    }
    if (typeof opts.approximateLineWidth !== 'number') {
        opts.approximateLineWidth = -1;
    }
    if (typeof opts.removeEmptyAttributes !== 'boolean') {
        opts.removeEmptyAttributes = true;
    }
    if (typeof opts.removeAttributeQuotes !== 'boolean') {
        opts.removeAttributeQuotes = false;
    }
    if (typeof opts.removeBooleanAttributeQuotes !== 'boolean') {
        opts.removeBooleanAttributeQuotes = false;
    }
    if (typeof opts.removeHtmlComments !== 'boolean') {
        opts.removeHtmlComments = false;
    }
    if (typeof opts.serializeShadowRoot !== 'boolean') {
        opts.serializeShadowRoot = false;
    }
    if (opts.outerHtml) {
        serializeToHtml(elm, opts, output, false);
    }
    else {
        for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
            serializeToHtml(elm.childNodes[i], opts, output, false);
        }
    }
    if (output.text[0] === '\n') {
        output.text.shift();
    }
    if (output.text[output.text.length - 1] === '\n') {
        output.text.pop();
    }
    return output.text.join('');
}
function serializeToHtml(node, opts, output, isShadowRoot) {
    if (node.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */ || isShadowRoot) {
        const tagName = isShadowRoot ? 'mock:shadow-root' : getTagName(node);
        if (tagName === 'body') {
            output.isWithinBody = true;
        }
        const ignoreTag = opts.excludeTags != null && opts.excludeTags.includes(tagName);
        if (ignoreTag === false) {
            const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 ? isWithinWhitespaceSensitive(node) : false;
            if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
                output.text.push('\n');
                output.currentLineWidth = 0;
            }
            if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
                for (let i = 0; i < output.indent; i++) {
                    output.text.push(' ');
                }
                output.currentLineWidth += output.indent;
            }
            output.text.push('<' + tagName);
            output.currentLineWidth += tagName.length + 1;
            const attrsLength = node.attributes.length;
            const attributes = opts.prettyHtml && attrsLength > 1
                ? cloneAttributes(node.attributes, true)
                : node.attributes;
            for (let i = 0; i < attrsLength; i++) {
                const attr = attributes.item(i);
                const attrName = attr.name;
                if (attrName === 'style') {
                    continue;
                }
                let attrValue = attr.value;
                if (opts.removeEmptyAttributes && attrValue === '' && REMOVE_EMPTY_ATTR.has(attrName)) {
                    continue;
                }
                const attrNamespaceURI = attr.namespaceURI;
                if (attrNamespaceURI == null) {
                    output.currentLineWidth += attrName.length + 1;
                    if (opts.approximateLineWidth > 0 && output.currentLineWidth > opts.approximateLineWidth) {
                        output.text.push('\n' + attrName);
                        output.currentLineWidth = 0;
                    }
                    else {
                        output.text.push(' ' + attrName);
                    }
                }
                else if (attrNamespaceURI === 'http://www.w3.org/XML/1998/namespace') {
                    output.text.push(' xml:' + attrName);
                    output.currentLineWidth += attrName.length + 5;
                }
                else if (attrNamespaceURI === 'http://www.w3.org/2000/xmlns/') {
                    if (attrName !== 'xmlns') {
                        output.text.push(' xmlns:' + attrName);
                        output.currentLineWidth += attrName.length + 7;
                    }
                    else {
                        output.text.push(' ' + attrName);
                        output.currentLineWidth += attrName.length + 1;
                    }
                }
                else if (attrNamespaceURI === XLINK_NS) {
                    output.text.push(' xlink:' + attrName);
                    output.currentLineWidth += attrName.length + 7;
                }
                else {
                    output.text.push(' ' + attrNamespaceURI + ':' + attrName);
                    output.currentLineWidth += attrNamespaceURI.length + attrName.length + 2;
                }
                if (opts.prettyHtml && attrName === 'class') {
                    attrValue = attr.value = attrValue
                        .split(' ')
                        .filter((t) => t !== '')
                        .sort()
                        .join(' ')
                        .trim();
                }
                if (attrValue === '') {
                    if (opts.removeBooleanAttributeQuotes && BOOLEAN_ATTR.has(attrName)) {
                        continue;
                    }
                    if (opts.removeEmptyAttributes && attrName.startsWith('data-')) {
                        continue;
                    }
                }
                if (opts.removeAttributeQuotes && CAN_REMOVE_ATTR_QUOTES.test(attrValue)) {
                    output.text.push('=' + escapeString(attrValue, true));
                    output.currentLineWidth += attrValue.length + 1;
                }
                else {
                    output.text.push('="' + escapeString(attrValue, true) + '"');
                    output.currentLineWidth += attrValue.length + 3;
                }
            }
            if (node.hasAttribute('style')) {
                const cssText = node.style.cssText;
                if (opts.approximateLineWidth > 0 &&
                    output.currentLineWidth + cssText.length + 10 > opts.approximateLineWidth) {
                    output.text.push(`\nstyle="${cssText}">`);
                    output.currentLineWidth = 0;
                }
                else {
                    output.text.push(` style="${cssText}">`);
                    output.currentLineWidth += cssText.length + 10;
                }
            }
            else {
                output.text.push('>');
                output.currentLineWidth += 1;
            }
        }
        if (EMPTY_ELEMENTS.has(tagName) === false) {
            if (opts.serializeShadowRoot && node.shadowRoot != null) {
                output.indent = output.indent + opts.indentSpaces;
                serializeToHtml(node.shadowRoot, opts, output, true);
                output.indent = output.indent - opts.indentSpaces;
                if (opts.newLines &&
                    (node.childNodes.length === 0 ||
                        (node.childNodes.length === 1 &&
                            node.childNodes[0].nodeType === 3 /* NODE_TYPES.TEXT_NODE */ &&
                            node.childNodes[0].nodeValue.trim() === ''))) {
                    output.text.push('\n');
                    output.currentLineWidth = 0;
                    for (let i = 0; i < output.indent; i++) {
                        output.text.push(' ');
                    }
                    output.currentLineWidth += output.indent;
                }
            }
            if (opts.excludeTagContent == null || opts.excludeTagContent.includes(tagName) === false) {
                const childNodes = tagName === 'template' ? node.content.childNodes : node.childNodes;
                const childNodeLength = childNodes.length;
                if (childNodeLength > 0) {
                    if (childNodeLength === 1 &&
                        childNodes[0].nodeType === 3 /* NODE_TYPES.TEXT_NODE */ &&
                        (typeof childNodes[0].nodeValue !== 'string' || childNodes[0].nodeValue.trim() === '')) ;
                    else {
                        const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 ? isWithinWhitespaceSensitive(node) : false;
                        if (!isWithinWhitespaceSensitiveNode && opts.indentSpaces > 0 && ignoreTag === false) {
                            output.indent = output.indent + opts.indentSpaces;
                        }
                        for (let i = 0; i < childNodeLength; i++) {
                            serializeToHtml(childNodes[i], opts, output, false);
                        }
                        if (ignoreTag === false) {
                            if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
                                output.text.push('\n');
                                output.currentLineWidth = 0;
                            }
                            if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
                                output.indent = output.indent - opts.indentSpaces;
                                for (let i = 0; i < output.indent; i++) {
                                    output.text.push(' ');
                                }
                                output.currentLineWidth += output.indent;
                            }
                        }
                    }
                }
                if (ignoreTag === false) {
                    output.text.push('</' + tagName + '>');
                    output.currentLineWidth += tagName.length + 3;
                }
            }
        }
        if (opts.approximateLineWidth > 0 && STRUCTURE_ELEMENTS.has(tagName)) {
            output.text.push('\n');
            output.currentLineWidth = 0;
        }
        if (tagName === 'body') {
            output.isWithinBody = false;
        }
    }
    else if (node.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
        let textContent = node.nodeValue;
        if (typeof textContent === 'string') {
            const trimmedTextContent = textContent.trim();
            if (trimmedTextContent === '') {
                // this text node is whitespace only
                if (isWithinWhitespaceSensitive(node)) {
                    // whitespace matters within this element
                    // just add the exact text we were given
                    output.text.push(textContent);
                    output.currentLineWidth += textContent.length;
                }
                else if (opts.approximateLineWidth > 0 && !output.isWithinBody) ;
                else if (!opts.prettyHtml) {
                    // this text node is only whitespace, and it's not
                    // within a whitespace sensitive element like <pre> or <code>
                    // so replace the entire white space with a single new line
                    output.currentLineWidth += 1;
                    if (opts.approximateLineWidth > 0 && output.currentLineWidth > opts.approximateLineWidth) {
                        // good enough for a new line
                        // for perf these are all just estimates
                        // we don't care to ensure exact line lengths
                        output.text.push('\n');
                        output.currentLineWidth = 0;
                    }
                    else {
                        // let's keep it all on the same line yet
                        output.text.push(' ');
                    }
                }
            }
            else {
                // this text node has text content
                const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 || opts.prettyHtml ? isWithinWhitespaceSensitive(node) : false;
                if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
                    output.text.push('\n');
                    output.currentLineWidth = 0;
                }
                if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
                    for (let i = 0; i < output.indent; i++) {
                        output.text.push(' ');
                    }
                    output.currentLineWidth += output.indent;
                }
                let textContentLength = textContent.length;
                if (textContentLength > 0) {
                    // this text node has text content
                    const parentTagName = node.parentNode != null && node.parentNode.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */
                        ? node.parentNode.nodeName
                        : null;
                    if (NON_ESCAPABLE_CONTENT.has(parentTagName)) {
                        // this text node cannot have its content escaped since it's going
                        // into an element like <style> or <script>
                        if (isWithinWhitespaceSensitive(node)) {
                            output.text.push(textContent);
                        }
                        else {
                            output.text.push(trimmedTextContent);
                            textContentLength = trimmedTextContent.length;
                        }
                        output.currentLineWidth += textContentLength;
                    }
                    else {
                        // this text node is going into a normal element and html can be escaped
                        if (opts.prettyHtml && !isWithinWhitespaceSensitiveNode) {
                            // pretty print the text node
                            output.text.push(escapeString(textContent.replace(/\s\s+/g, ' ').trim(), false));
                            output.currentLineWidth += textContentLength;
                        }
                        else {
                            // not pretty printing the text node
                            if (isWithinWhitespaceSensitive(node)) {
                                output.currentLineWidth += textContentLength;
                            }
                            else {
                                // this element is not a whitespace sensitive one, like <pre> or <code> so
                                // any whitespace at the start and end can be cleaned up to just be one space
                                if (/\s/.test(textContent.charAt(0))) {
                                    textContent = ' ' + textContent.trimLeft();
                                }
                                textContentLength = textContent.length;
                                if (textContentLength > 1) {
                                    if (/\s/.test(textContent.charAt(textContentLength - 1))) {
                                        if (opts.approximateLineWidth > 0 &&
                                            output.currentLineWidth + textContentLength > opts.approximateLineWidth) {
                                            textContent = textContent.trimRight() + '\n';
                                            output.currentLineWidth = 0;
                                        }
                                        else {
                                            textContent = textContent.trimRight() + ' ';
                                        }
                                    }
                                }
                                output.currentLineWidth += textContentLength;
                            }
                            output.text.push(escapeString(textContent, false));
                        }
                    }
                }
            }
        }
    }
    else if (node.nodeType === 8 /* NODE_TYPES.COMMENT_NODE */) {
        const nodeValue = node.nodeValue;
        if (opts.removeHtmlComments) {
            const isHydrateAnnotation = nodeValue.startsWith(CONTENT_REF_ID + '.') ||
                nodeValue.startsWith(ORG_LOCATION_ID + '.') ||
                nodeValue.startsWith(SLOT_NODE_ID + '.') ||
                nodeValue.startsWith(TEXT_NODE_ID + '.');
            if (!isHydrateAnnotation) {
                return;
            }
        }
        const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 ? isWithinWhitespaceSensitive(node) : false;
        if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
            output.text.push('\n');
            output.currentLineWidth = 0;
        }
        if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
            for (let i = 0; i < output.indent; i++) {
                output.text.push(' ');
            }
            output.currentLineWidth += output.indent;
        }
        output.text.push('<!--' + nodeValue + '-->');
        output.currentLineWidth += nodeValue.length + 7;
    }
    else if (node.nodeType === 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */) {
        output.text.push('<!doctype html>');
    }
}
const AMP_REGEX = /&/g;
const NBSP_REGEX = /\u00a0/g;
const DOUBLE_QUOTE_REGEX = /"/g;
const LT_REGEX = /</g;
const GT_REGEX = />/g;
const CAN_REMOVE_ATTR_QUOTES = /^[^ \t\n\f\r"'`=<>\/\\-]+$/;
function getTagName(element) {
    if (element.namespaceURI === 'http://www.w3.org/1999/xhtml') {
        return element.nodeName.toLowerCase();
    }
    else {
        return element.nodeName;
    }
}
function escapeString(str, attrMode) {
    str = str.replace(AMP_REGEX, '&amp;').replace(NBSP_REGEX, '&nbsp;');
    if (attrMode) {
        return str.replace(DOUBLE_QUOTE_REGEX, '&quot;');
    }
    return str.replace(LT_REGEX, '&lt;').replace(GT_REGEX, '&gt;');
}
function isWithinWhitespaceSensitive(node) {
    while (node != null) {
        if (WHITESPACE_SENSITIVE.has(node.nodeName)) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}
/*@__PURE__*/ const NON_ESCAPABLE_CONTENT = new Set([
    'STYLE',
    'SCRIPT',
    'IFRAME',
    'NOSCRIPT',
    'XMP',
    'NOEMBED',
    'NOFRAMES',
    'PLAINTEXT',
]);
/*@__PURE__*/ const WHITESPACE_SENSITIVE = new Set([
    'CODE',
    'OUTPUT',
    'PLAINTEXT',
    'PRE',
    'SCRIPT',
    'TEMPLATE',
    'TEXTAREA',
]);
/*@__PURE__*/ const EMPTY_ELEMENTS = new Set([
    'area',
    'base',
    'basefont',
    'bgsound',
    'br',
    'col',
    'embed',
    'frame',
    'hr',
    'img',
    'input',
    'keygen',
    'link',
    'meta',
    'param',
    'source',
    'trace',
    'wbr',
]);
/*@__PURE__*/ const REMOVE_EMPTY_ATTR = new Set(['class', 'dir', 'id', 'lang', 'name', 'title']);
/*@__PURE__*/ const BOOLEAN_ATTR = new Set([
    'allowfullscreen',
    'async',
    'autofocus',
    'autoplay',
    'checked',
    'compact',
    'controls',
    'declare',
    'default',
    'defaultchecked',
    'defaultmuted',
    'defaultselected',
    'defer',
    'disabled',
    'enabled',
    'formnovalidate',
    'hidden',
    'indeterminate',
    'inert',
    'ismap',
    'itemscope',
    'loop',
    'multiple',
    'muted',
    'nohref',
    'nomodule',
    'noresize',
    'noshade',
    'novalidate',
    'nowrap',
    'open',
    'pauseonexit',
    'readonly',
    'required',
    'reversed',
    'scoped',
    'seamless',
    'selected',
    'sortable',
    'truespeed',
    'typemustmatch',
    'visible',
]);
/*@__PURE__*/ const STRUCTURE_ELEMENTS = new Set([
    'html',
    'body',
    'head',
    'iframe',
    'meta',
    'link',
    'base',
    'title',
    'script',
    'style',
]);

class MockNode {
    constructor(ownerDocument, nodeType, nodeName, nodeValue) {
        this.ownerDocument = ownerDocument;
        this.nodeType = nodeType;
        this.nodeName = nodeName;
        this._nodeValue = nodeValue;
        this.parentNode = null;
        this.childNodes = [];
    }
    appendChild(newNode) {
        if (newNode.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */) {
            const nodes = newNode.childNodes.slice();
            for (const child of nodes) {
                this.appendChild(child);
            }
        }
        else {
            newNode.remove();
            newNode.parentNode = this;
            this.childNodes.push(newNode);
            connectNode(this.ownerDocument, newNode);
        }
        return newNode;
    }
    append(...items) {
        items.forEach((item) => {
            const isNode = typeof item === 'object' && item !== null && 'nodeType' in item;
            this.appendChild(isNode ? item : this.ownerDocument.createTextNode(String(item)));
        });
    }
    prepend(...items) {
        const firstChild = this.firstChild;
        items.forEach((item) => {
            const isNode = typeof item === 'object' && item !== null && 'nodeType' in item;
            if (firstChild) {
                this.insertBefore(isNode ? item : this.ownerDocument.createTextNode(String(item)), firstChild);
            }
        });
    }
    cloneNode(deep) {
        throw new Error(`invalid node type to clone: ${this.nodeType}, deep: ${deep}`);
    }
    compareDocumentPosition(_other) {
        // unimplemented
        // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        return -1;
    }
    get firstChild() {
        return this.childNodes[0] || null;
    }
    insertBefore(newNode, referenceNode) {
        if (newNode.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */) {
            for (let i = 0, ii = newNode.childNodes.length; i < ii; i++) {
                insertBefore(this, newNode.childNodes[i], referenceNode);
            }
        }
        else {
            insertBefore(this, newNode, referenceNode);
        }
        return newNode;
    }
    get isConnected() {
        let node = this;
        while (node != null) {
            if (node.nodeType === 9 /* NODE_TYPES.DOCUMENT_NODE */) {
                return true;
            }
            node = node.parentNode;
            if (node != null && node.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */) {
                node = node.host;
            }
        }
        return false;
    }
    isSameNode(node) {
        return this === node;
    }
    get lastChild() {
        return this.childNodes[this.childNodes.length - 1] || null;
    }
    get nextSibling() {
        if (this.parentNode != null) {
            const index = this.parentNode.childNodes.indexOf(this) + 1;
            return this.parentNode.childNodes[index] || null;
        }
        return null;
    }
    get nodeValue() {
        var _a;
        return (_a = this._nodeValue) !== null && _a !== void 0 ? _a : '';
    }
    set nodeValue(value) {
        this._nodeValue = value;
    }
    get parentElement() {
        return this.parentNode || null;
    }
    set parentElement(value) {
        this.parentNode = value;
    }
    get previousSibling() {
        if (this.parentNode != null) {
            const index = this.parentNode.childNodes.indexOf(this) - 1;
            return this.parentNode.childNodes[index] || null;
        }
        return null;
    }
    contains(otherNode) {
        if (otherNode === this) {
            return true;
        }
        const childNodes = Array.from(this.childNodes);
        if (childNodes.includes(otherNode)) {
            return true;
        }
        return childNodes.some((node) => this.contains.bind(node)(otherNode));
    }
    removeChild(childNode) {
        const index = this.childNodes.indexOf(childNode);
        if (index > -1) {
            this.childNodes.splice(index, 1);
            if (this.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
                const wasConnected = this.isConnected;
                childNode.parentNode = null;
                if (wasConnected === true) {
                    disconnectNode(childNode);
                }
            }
            else {
                childNode.parentNode = null;
            }
        }
        else {
            throw new Error(`node not found within childNodes during removeChild`);
        }
        return childNode;
    }
    remove() {
        if (this.parentNode != null) {
            this.parentNode.removeChild(this);
        }
    }
    replaceChild(newChild, oldChild) {
        if (oldChild.parentNode === this) {
            this.insertBefore(newChild, oldChild);
            oldChild.remove();
            return newChild;
        }
        return null;
    }
    get textContent() {
        var _a;
        return (_a = this._nodeValue) !== null && _a !== void 0 ? _a : '';
    }
    set textContent(value) {
        this._nodeValue = String(value);
    }
}
MockNode.ELEMENT_NODE = 1;
MockNode.TEXT_NODE = 3;
MockNode.PROCESSING_INSTRUCTION_NODE = 7;
MockNode.COMMENT_NODE = 8;
MockNode.DOCUMENT_NODE = 9;
MockNode.DOCUMENT_TYPE_NODE = 10;
MockNode.DOCUMENT_FRAGMENT_NODE = 11;
class MockNodeList {
    constructor(ownerDocument, childNodes, length) {
        this.ownerDocument = ownerDocument;
        this.childNodes = childNodes;
        this.length = length;
    }
}
class MockElement extends MockNode {
    attachInternals() {
        return new Proxy({}, {
            get: function (_target, prop, _receiver) {
                console.error(`NOTE: Property ${String(prop)} was accessed on ElementInternals, but this property is not implemented.
Testing components with ElementInternals is fully supported in e2e tests.`);
            },
        });
    }
    constructor(ownerDocument, nodeName, namespaceURI = null) {
        super(ownerDocument, 1 /* NODE_TYPES.ELEMENT_NODE */, typeof nodeName === 'string' ? nodeName : null, null);
        this.__namespaceURI = namespaceURI;
        this.__shadowRoot = null;
        this.__attributeMap = null;
    }
    addEventListener(type, handler) {
        addEventListener(this, type, handler);
    }
    attachShadow(_opts) {
        const shadowRoot = this.ownerDocument.createDocumentFragment();
        this.shadowRoot = shadowRoot;
        return shadowRoot;
    }
    blur() {
        dispatchEvent(this, new MockFocusEvent('blur', { relatedTarget: null, bubbles: true, cancelable: true, composed: true }));
    }
    get namespaceURI() {
        return this.__namespaceURI;
    }
    get shadowRoot() {
        return this.__shadowRoot || null;
    }
    set shadowRoot(shadowRoot) {
        if (shadowRoot != null) {
            shadowRoot.host = this;
            this.__shadowRoot = shadowRoot;
        }
        else {
            delete this.__shadowRoot;
        }
    }
    get attributes() {
        if (this.__attributeMap == null) {
            const attrMap = createAttributeProxy(false);
            this.__attributeMap = attrMap;
            return attrMap;
        }
        return this.__attributeMap;
    }
    set attributes(attrs) {
        this.__attributeMap = attrs;
    }
    get children() {
        return this.childNodes.filter((n) => n.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */);
    }
    get childElementCount() {
        return this.childNodes.filter((n) => n.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */).length;
    }
    get className() {
        return this.getAttributeNS(null, 'class') || '';
    }
    set className(value) {
        this.setAttributeNS(null, 'class', value);
    }
    get classList() {
        return new MockClassList(this);
    }
    click() {
        dispatchEvent(this, new MockEvent('click', { bubbles: true, cancelable: true, composed: true }));
    }
    cloneNode(_deep) {
        // implemented on MockElement.prototype from within element.ts
        // @ts-ignore - implemented on MockElement.prototype from within element.ts
        return null;
    }
    closest(selector) {
        let elm = this;
        while (elm != null) {
            if (elm.matches(selector)) {
                return elm;
            }
            elm = elm.parentNode;
        }
        return null;
    }
    get dataset() {
        return dataset(this);
    }
    get dir() {
        return this.getAttributeNS(null, 'dir') || '';
    }
    set dir(value) {
        this.setAttributeNS(null, 'dir', value);
    }
    dispatchEvent(ev) {
        return dispatchEvent(this, ev);
    }
    get firstElementChild() {
        return this.children[0] || null;
    }
    focus(_options) {
        dispatchEvent(this, new MockFocusEvent('focus', { relatedTarget: null, bubbles: true, cancelable: true, composed: true }));
    }
    getAttribute(attrName) {
        if (attrName === 'style') {
            if (this.__style != null && this.__style.length > 0) {
                return this.style.cssText;
            }
            return null;
        }
        const attr = this.attributes.getNamedItem(attrName);
        if (attr != null) {
            return attr.value;
        }
        return null;
    }
    getAttributeNS(namespaceURI, attrName) {
        const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
        if (attr != null) {
            return attr.value;
        }
        return null;
    }
    getAttributeNode(attrName) {
        if (!this.hasAttribute(attrName)) {
            return null;
        }
        return new MockAttr(attrName, this.getAttribute(attrName));
    }
    getBoundingClientRect() {
        return { bottom: 0, height: 0, left: 0, right: 0, top: 0, width: 0, x: 0, y: 0 };
    }
    getRootNode(opts) {
        const isComposed = opts != null && opts.composed === true;
        let node = this;
        while (node.parentNode != null) {
            node = node.parentNode;
            if (isComposed === true && node.parentNode == null && node.host != null) {
                node = node.host;
            }
        }
        return node;
    }
    get draggable() {
        return this.getAttributeNS(null, 'draggable') === 'true';
    }
    set draggable(value) {
        this.setAttributeNS(null, 'draggable', value);
    }
    hasChildNodes() {
        return this.childNodes.length > 0;
    }
    get id() {
        return this.getAttributeNS(null, 'id') || '';
    }
    set id(value) {
        this.setAttributeNS(null, 'id', value);
    }
    get innerHTML() {
        if (this.childNodes.length === 0) {
            return '';
        }
        return serializeNodeToHtml(this, {
            newLines: false,
            indentSpaces: 0,
        });
    }
    set innerHTML(html) {
        var _a;
        if (NON_ESCAPABLE_CONTENT.has((_a = this.nodeName) !== null && _a !== void 0 ? _a : '') === true) {
            setTextContent(this, html);
        }
        else {
            for (let i = this.childNodes.length - 1; i >= 0; i--) {
                this.removeChild(this.childNodes[i]);
            }
            if (typeof html === 'string') {
                const frag = parseFragmentUtil(this.ownerDocument, html);
                while (frag.childNodes.length > 0) {
                    this.appendChild(frag.childNodes[0]);
                }
            }
        }
    }
    get innerText() {
        const text = [];
        getTextContent(this.childNodes, text);
        return text.join('');
    }
    set innerText(value) {
        setTextContent(this, value);
    }
    insertAdjacentElement(position, elm) {
        if (position === 'beforebegin') {
            insertBefore(this.parentNode, elm, this);
        }
        else if (position === 'afterbegin') {
            this.prepend(elm);
        }
        else if (position === 'beforeend') {
            this.appendChild(elm);
        }
        else if (position === 'afterend') {
            insertBefore(this.parentNode, elm, this.nextSibling);
        }
        return elm;
    }
    insertAdjacentHTML(position, html) {
        const frag = parseFragmentUtil(this.ownerDocument, html);
        if (position === 'beforebegin') {
            while (frag.childNodes.length > 0) {
                insertBefore(this.parentNode, frag.childNodes[0], this);
            }
        }
        else if (position === 'afterbegin') {
            while (frag.childNodes.length > 0) {
                this.prepend(frag.childNodes[frag.childNodes.length - 1]);
            }
        }
        else if (position === 'beforeend') {
            while (frag.childNodes.length > 0) {
                this.appendChild(frag.childNodes[0]);
            }
        }
        else if (position === 'afterend') {
            while (frag.childNodes.length > 0) {
                insertBefore(this.parentNode, frag.childNodes[frag.childNodes.length - 1], this.nextSibling);
            }
        }
    }
    insertAdjacentText(position, text) {
        const elm = this.ownerDocument.createTextNode(text);
        if (position === 'beforebegin') {
            insertBefore(this.parentNode, elm, this);
        }
        else if (position === 'afterbegin') {
            this.prepend(elm);
        }
        else if (position === 'beforeend') {
            this.appendChild(elm);
        }
        else if (position === 'afterend') {
            insertBefore(this.parentNode, elm, this.nextSibling);
        }
    }
    hasAttribute(attrName) {
        if (attrName === 'style') {
            return this.__style != null && this.__style.length > 0;
        }
        return this.getAttribute(attrName) !== null;
    }
    hasAttributeNS(namespaceURI, name) {
        return this.getAttributeNS(namespaceURI, name) !== null;
    }
    get hidden() {
        return this.hasAttributeNS(null, 'hidden');
    }
    set hidden(isHidden) {
        if (isHidden === true) {
            this.setAttributeNS(null, 'hidden', '');
        }
        else {
            this.removeAttributeNS(null, 'hidden');
        }
    }
    get lang() {
        return this.getAttributeNS(null, 'lang') || '';
    }
    set lang(value) {
        this.setAttributeNS(null, 'lang', value);
    }
    get lastElementChild() {
        const children = this.children;
        return children[children.length - 1] || null;
    }
    matches(selector) {
        return matches(selector, this);
    }
    get nextElementSibling() {
        const parentElement = this.parentElement;
        if (parentElement != null &&
            (parentElement.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */ ||
                parentElement.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */ ||
                parentElement.nodeType === 9 /* NODE_TYPES.DOCUMENT_NODE */)) {
            const children = parentElement.children;
            const index = children.indexOf(this) + 1;
            return parentElement.children[index] || null;
        }
        return null;
    }
    get outerHTML() {
        return serializeNodeToHtml(this, {
            newLines: false,
            outerHtml: true,
            indentSpaces: 0,
        });
    }
    get previousElementSibling() {
        const parentElement = this.parentElement;
        if (parentElement != null &&
            (parentElement.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */ ||
                parentElement.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */ ||
                parentElement.nodeType === 9 /* NODE_TYPES.DOCUMENT_NODE */)) {
            const children = parentElement.children;
            const index = children.indexOf(this) - 1;
            return parentElement.children[index] || null;
        }
        return null;
    }
    getElementsByClassName(classNames) {
        const classes = classNames
            .trim()
            .split(' ')
            .filter((c) => c.length > 0);
        const results = [];
        getElementsByClassName(this, classes, results);
        return results;
    }
    getElementsByTagName(tagName) {
        const results = [];
        getElementsByTagName(this, tagName.toLowerCase(), results);
        return results;
    }
    querySelector(selector) {
        return selectOne(selector, this);
    }
    querySelectorAll(selector) {
        return selectAll(selector, this);
    }
    removeAttribute(attrName) {
        if (attrName === 'style') {
            delete this.__style;
        }
        else {
            const attr = this.attributes.getNamedItem(attrName);
            if (attr != null) {
                this.attributes.removeNamedItemNS(attr);
                if (checkAttributeChanged(this) === true) {
                    attributeChanged(this, attrName, attr.value, null);
                }
            }
        }
    }
    removeAttributeNS(namespaceURI, attrName) {
        const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
        if (attr != null) {
            this.attributes.removeNamedItemNS(attr);
            if (checkAttributeChanged(this) === true) {
                attributeChanged(this, attrName, attr.value, null);
            }
        }
    }
    removeEventListener(type, handler) {
        removeEventListener(this, type, handler);
    }
    setAttribute(attrName, value) {
        if (attrName === 'style') {
            this.style = value;
        }
        else {
            const attributes = this.attributes;
            let attr = attributes.getNamedItem(attrName);
            const checkAttrChanged = checkAttributeChanged(this);
            if (attr != null) {
                if (checkAttrChanged === true) {
                    const oldValue = attr.value;
                    attr.value = value;
                    if (oldValue !== attr.value) {
                        attributeChanged(this, attr.name, oldValue, attr.value);
                    }
                }
                else {
                    attr.value = value;
                }
            }
            else {
                if (attributes.caseInsensitive) {
                    attrName = attrName.toLowerCase();
                }
                attr = new MockAttr(attrName, value);
                attributes.__items.push(attr);
                if (checkAttrChanged === true) {
                    attributeChanged(this, attrName, null, attr.value);
                }
            }
        }
    }
    setAttributeNS(namespaceURI, attrName, value) {
        const attributes = this.attributes;
        let attr = attributes.getNamedItemNS(namespaceURI, attrName);
        const checkAttrChanged = checkAttributeChanged(this);
        if (attr != null) {
            if (checkAttrChanged === true) {
                const oldValue = attr.value;
                attr.value = value;
                if (oldValue !== attr.value) {
                    attributeChanged(this, attr.name, oldValue, attr.value);
                }
            }
            else {
                attr.value = value;
            }
        }
        else {
            attr = new MockAttr(attrName, value, namespaceURI);
            attributes.__items.push(attr);
            if (checkAttrChanged === true) {
                attributeChanged(this, attrName, null, attr.value);
            }
        }
    }
    get style() {
        if (this.__style == null) {
            this.__style = createCSSStyleDeclaration();
        }
        return this.__style;
    }
    set style(val) {
        if (typeof val === 'string') {
            if (this.__style == null) {
                this.__style = createCSSStyleDeclaration();
            }
            this.__style.cssText = val;
        }
        else {
            this.__style = val;
        }
    }
    get tabIndex() {
        return parseInt(this.getAttributeNS(null, 'tabindex') || '-1', 10);
    }
    set tabIndex(value) {
        this.setAttributeNS(null, 'tabindex', value);
    }
    get tagName() {
        var _a;
        return (_a = this.nodeName) !== null && _a !== void 0 ? _a : '';
    }
    set tagName(value) {
        this.nodeName = value;
    }
    get textContent() {
        const text = [];
        getTextContent(this.childNodes, text);
        return text.join('');
    }
    set textContent(value) {
        setTextContent(this, value);
    }
    get title() {
        return this.getAttributeNS(null, 'title') || '';
    }
    set title(value) {
        this.setAttributeNS(null, 'title', value);
    }
    animate() {
        /**/
    }
    onanimationstart() {
        /**/
    }
    onanimationend() {
        /**/
    }
    onanimationiteration() {
        /**/
    }
    onabort() {
        /**/
    }
    onauxclick() {
        /**/
    }
    onbeforecopy() {
        /**/
    }
    onbeforecut() {
        /**/
    }
    onbeforepaste() {
        /**/
    }
    onblur() {
        /**/
    }
    oncancel() {
        /**/
    }
    oncanplay() {
        /**/
    }
    oncanplaythrough() {
        /**/
    }
    onchange() {
        /**/
    }
    onclick() {
        /**/
    }
    onclose() {
        /**/
    }
    oncontextmenu() {
        /**/
    }
    oncopy() {
        /**/
    }
    oncuechange() {
        /**/
    }
    oncut() {
        /**/
    }
    ondblclick() {
        /**/
    }
    ondrag() {
        /**/
    }
    ondragend() {
        /**/
    }
    ondragenter() {
        /**/
    }
    ondragleave() {
        /**/
    }
    ondragover() {
        /**/
    }
    ondragstart() {
        /**/
    }
    ondrop() {
        /**/
    }
    ondurationchange() {
        /**/
    }
    onemptied() {
        /**/
    }
    onended() {
        /**/
    }
    onerror() {
        /**/
    }
    onfocus() {
        /**/
    }
    onfocusin() {
        /**/
    }
    onfocusout() {
        /**/
    }
    onformdata() {
        /**/
    }
    onfullscreenchange() {
        /**/
    }
    onfullscreenerror() {
        /**/
    }
    ongotpointercapture() {
        /**/
    }
    oninput() {
        /**/
    }
    oninvalid() {
        /**/
    }
    onkeydown() {
        /**/
    }
    onkeypress() {
        /**/
    }
    onkeyup() {
        /**/
    }
    onload() {
        /**/
    }
    onloadeddata() {
        /**/
    }
    onloadedmetadata() {
        /**/
    }
    onloadstart() {
        /**/
    }
    onlostpointercapture() {
        /**/
    }
    onmousedown() {
        /**/
    }
    onmouseenter() {
        /**/
    }
    onmouseleave() {
        /**/
    }
    onmousemove() {
        /**/
    }
    onmouseout() {
        /**/
    }
    onmouseover() {
        /**/
    }
    onmouseup() {
        /**/
    }
    onmousewheel() {
        /**/
    }
    onpaste() {
        /**/
    }
    onpause() {
        /**/
    }
    onplay() {
        /**/
    }
    onplaying() {
        /**/
    }
    onpointercancel() {
        /**/
    }
    onpointerdown() {
        /**/
    }
    onpointerenter() {
        /**/
    }
    onpointerleave() {
        /**/
    }
    onpointermove() {
        /**/
    }
    onpointerout() {
        /**/
    }
    onpointerover() {
        /**/
    }
    onpointerup() {
        /**/
    }
    onprogress() {
        /**/
    }
    onratechange() {
        /**/
    }
    onreset() {
        /**/
    }
    onresize() {
        /**/
    }
    onscroll() {
        /**/
    }
    onsearch() {
        /**/
    }
    onseeked() {
        /**/
    }
    onseeking() {
        /**/
    }
    onselect() {
        /**/
    }
    onselectstart() {
        /**/
    }
    onstalled() {
        /**/
    }
    onsubmit() {
        /**/
    }
    onsuspend() {
        /**/
    }
    ontimeupdate() {
        /**/
    }
    ontoggle() {
        /**/
    }
    onvolumechange() {
        /**/
    }
    onwaiting() {
        /**/
    }
    onwebkitfullscreenchange() {
        /**/
    }
    onwebkitfullscreenerror() {
        /**/
    }
    onwheel() {
        /**/
    }
    requestFullscreen() {
        /**/
    }
    scrollBy() {
        /**/
    }
    scrollTo() {
        /**/
    }
    scrollIntoView() {
        /**/
    }
    toString(opts) {
        return serializeNodeToHtml(this, opts);
    }
}
function getElementsByClassName(elm, classNames, foundElms) {
    const children = elm.children;
    for (let i = 0, ii = children.length; i < ii; i++) {
        const childElm = children[i];
        for (let j = 0, jj = classNames.length; j < jj; j++) {
            if (childElm.classList.contains(classNames[j])) {
                foundElms.push(childElm);
            }
        }
        getElementsByClassName(childElm, classNames, foundElms);
    }
}
function getElementsByTagName(elm, tagName, foundElms) {
    var _a;
    const children = elm.children;
    for (let i = 0, ii = children.length; i < ii; i++) {
        const childElm = children[i];
        if (tagName === '*' || ((_a = childElm.nodeName) !== null && _a !== void 0 ? _a : '').toLowerCase() === tagName) {
            foundElms.push(childElm);
        }
        getElementsByTagName(childElm, tagName, foundElms);
    }
}
function resetElement(elm) {
    resetEventListeners(elm);
    delete elm.__attributeMap;
    delete elm.__shadowRoot;
    delete elm.__style;
}
function insertBefore(parentNode, newNode, referenceNode) {
    if (newNode !== referenceNode) {
        newNode.remove();
        newNode.parentNode = parentNode;
        newNode.ownerDocument = parentNode.ownerDocument;
        if (referenceNode != null) {
            const index = parentNode.childNodes.indexOf(referenceNode);
            if (index > -1) {
                parentNode.childNodes.splice(index, 0, newNode);
            }
            else {
                throw new Error(`referenceNode not found in parentNode.childNodes`);
            }
        }
        else {
            parentNode.childNodes.push(newNode);
        }
        connectNode(parentNode.ownerDocument, newNode);
    }
    return newNode;
}
class MockHTMLElement extends MockElement {
    constructor(ownerDocument, nodeName) {
        super(ownerDocument, typeof nodeName === 'string' ? nodeName.toUpperCase() : null);
        this.__namespaceURI = 'http://www.w3.org/1999/xhtml';
    }
    get tagName() {
        var _a;
        return (_a = this.nodeName) !== null && _a !== void 0 ? _a : '';
    }
    set tagName(value) {
        this.nodeName = value;
    }
    get attributes() {
        if (this.__attributeMap == null) {
            const attrMap = createAttributeProxy(true);
            this.__attributeMap = attrMap;
            return attrMap;
        }
        return this.__attributeMap;
    }
    set attributes(attrs) {
        this.__attributeMap = attrs;
    }
}
class MockTextNode extends MockNode {
    constructor(ownerDocument, text) {
        super(ownerDocument, 3 /* NODE_TYPES.TEXT_NODE */, "#text" /* NODE_NAMES.TEXT_NODE */, text);
    }
    cloneNode(_deep) {
        return new MockTextNode(null, this.nodeValue);
    }
    get textContent() {
        return this.nodeValue;
    }
    set textContent(text) {
        this.nodeValue = text;
    }
    get data() {
        return this.nodeValue;
    }
    set data(text) {
        this.nodeValue = text;
    }
    get wholeText() {
        if (this.parentNode != null) {
            const text = [];
            for (let i = 0, ii = this.parentNode.childNodes.length; i < ii; i++) {
                const childNode = this.parentNode.childNodes[i];
                if (childNode.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
                    text.push(childNode.nodeValue);
                }
            }
            return text.join('');
        }
        return this.nodeValue;
    }
}
function getTextContent(childNodes, text) {
    for (let i = 0, ii = childNodes.length; i < ii; i++) {
        const childNode = childNodes[i];
        if (childNode.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
            text.push(childNode.nodeValue);
        }
        else if (childNode.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
            getTextContent(childNode.childNodes, text);
        }
    }
}
function setTextContent(elm, text) {
    for (let i = elm.childNodes.length - 1; i >= 0; i--) {
        elm.removeChild(elm.childNodes[i]);
    }
    const textNode = new MockTextNode(elm.ownerDocument, text);
    elm.appendChild(textNode);
}

class MockComment extends MockNode {
    constructor(ownerDocument, data) {
        super(ownerDocument, 8 /* NODE_TYPES.COMMENT_NODE */, "#comment" /* NODE_NAMES.COMMENT_NODE */, data);
    }
    cloneNode(_deep) {
        return new MockComment(null, this.nodeValue);
    }
    get textContent() {
        return this.nodeValue;
    }
    set textContent(text) {
        this.nodeValue = text;
    }
}

class MockDocumentFragment extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, null);
        this.nodeName = "#document-fragment" /* NODE_NAMES.DOCUMENT_FRAGMENT_NODE */;
        this.nodeType = 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */;
    }
    getElementById(id) {
        return getElementById(this, id);
    }
    cloneNode(deep) {
        const cloned = new MockDocumentFragment(null);
        if (deep) {
            for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
                const childNode = this.childNodes[i];
                if (childNode.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */ ||
                    childNode.nodeType === 3 /* NODE_TYPES.TEXT_NODE */ ||
                    childNode.nodeType === 8 /* NODE_TYPES.COMMENT_NODE */) {
                    const clonedChildNode = this.childNodes[i].cloneNode(true);
                    cloned.appendChild(clonedChildNode);
                }
            }
        }
        return cloned;
    }
}

class MockDocumentTypeNode extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, '!DOCTYPE');
        this.nodeType = 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */;
        this.setAttribute('html', '');
    }
}

class MockCSSRule {
    constructor(parentStyleSheet) {
        this.parentStyleSheet = parentStyleSheet;
        this.cssText = '';
        this.type = 0;
    }
}
class MockCSSStyleSheet {
    constructor(ownerNode) {
        this.type = 'text/css';
        this.parentStyleSheet = null;
        this.cssRules = [];
        this.ownerNode = ownerNode;
    }
    get rules() {
        return this.cssRules;
    }
    set rules(rules) {
        this.cssRules = rules;
    }
    deleteRule(index) {
        if (index >= 0 && index < this.cssRules.length) {
            this.cssRules.splice(index, 1);
            updateStyleTextNode(this.ownerNode);
        }
    }
    insertRule(rule, index = 0) {
        if (typeof index !== 'number') {
            index = 0;
        }
        if (index < 0) {
            index = 0;
        }
        if (index > this.cssRules.length) {
            index = this.cssRules.length;
        }
        const cssRule = new MockCSSRule(this);
        cssRule.cssText = rule;
        this.cssRules.splice(index, 0, cssRule);
        updateStyleTextNode(this.ownerNode);
        return index;
    }
}
function getStyleElementText(styleElm) {
    const output = [];
    for (let i = 0; i < styleElm.childNodes.length; i++) {
        output.push(styleElm.childNodes[i].nodeValue);
    }
    return output.join('');
}
function setStyleElementText(styleElm, text) {
    // keeping the innerHTML and the sheet.cssRules connected
    // is not technically correct, but since we're doing
    // SSR we'll need to turn any assigned cssRules into
    // real text, not just properties that aren't rendered
    const sheet = styleElm.sheet;
    sheet.cssRules.length = 0;
    sheet.insertRule(text);
    updateStyleTextNode(styleElm);
}
function updateStyleTextNode(styleElm) {
    const childNodeLen = styleElm.childNodes.length;
    if (childNodeLen > 1) {
        for (let i = childNodeLen - 1; i >= 1; i--) {
            styleElm.removeChild(styleElm.childNodes[i]);
        }
    }
    else if (childNodeLen < 1) {
        styleElm.appendChild(styleElm.ownerDocument.createTextNode(''));
    }
    const textNode = styleElm.childNodes[0];
    textNode.nodeValue = styleElm.sheet.cssRules.map((r) => r.cssText).join('\n');
}

function createElement(ownerDocument, tagName) {
    if (typeof tagName !== 'string' || tagName === '' || !/^[a-z0-9-_:]+$/i.test(tagName)) {
        throw new Error(`The tag name provided (${tagName}) is not a valid name.`);
    }
    tagName = tagName.toLowerCase();
    switch (tagName) {
        case 'a':
            return new MockAnchorElement(ownerDocument);
        case 'base':
            return new MockBaseElement(ownerDocument);
        case 'button':
            return new MockButtonElement(ownerDocument);
        case 'canvas':
            return new MockCanvasElement(ownerDocument);
        case 'form':
            return new MockFormElement(ownerDocument);
        case 'img':
            return new MockImageElement(ownerDocument);
        case 'input':
            return new MockInputElement(ownerDocument);
        case 'link':
            return new MockLinkElement(ownerDocument);
        case 'meta':
            return new MockMetaElement(ownerDocument);
        case 'script':
            return new MockScriptElement(ownerDocument);
        case 'style':
            return new MockStyleElement(ownerDocument);
        case 'template':
            return new MockTemplateElement(ownerDocument);
        case 'title':
            return new MockTitleElement(ownerDocument);
        case 'ul':
            return new MockUListElement(ownerDocument);
    }
    if (ownerDocument != null && tagName.includes('-')) {
        const win = ownerDocument.defaultView;
        if (win != null && win.customElements != null) {
            return createCustomElement(win.customElements, ownerDocument, tagName);
        }
    }
    return new MockHTMLElement(ownerDocument, tagName);
}
function createElementNS(ownerDocument, namespaceURI, tagName) {
    if (namespaceURI === 'http://www.w3.org/1999/xhtml') {
        return createElement(ownerDocument, tagName);
    }
    else if (namespaceURI === 'http://www.w3.org/2000/svg') {
        switch (tagName.toLowerCase()) {
            case 'text':
            case 'tspan':
            case 'tref':
            case 'altglyph':
            case 'textpath':
                return new MockSVGTextContentElement(ownerDocument, tagName);
            case 'circle':
            case 'ellipse':
            case 'image':
            case 'line':
            case 'path':
            case 'polygon':
            case 'polyline':
            case 'rect':
            case 'use':
                return new MockSVGGraphicsElement(ownerDocument, tagName);
            case 'svg':
                return new MockSVGSVGElement(ownerDocument, tagName);
            default:
                return new MockSVGElement(ownerDocument, tagName);
        }
    }
    else {
        return new MockElement(ownerDocument, tagName, namespaceURI);
    }
}
class MockAnchorElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'a');
    }
    get href() {
        return fullUrl(this, 'href');
    }
    set href(value) {
        this.setAttribute('href', value);
    }
    get pathname() {
        return new URL(this.href).pathname;
    }
}
class MockButtonElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'button');
    }
}
patchPropAttributes(MockButtonElement.prototype, {
    type: String,
}, {
    type: 'submit',
});
class MockImageElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'img');
    }
    get draggable() {
        return this.getAttributeNS(null, 'draggable') !== 'false';
    }
    set draggable(value) {
        this.setAttributeNS(null, 'draggable', value);
    }
    get src() {
        return fullUrl(this, 'src');
    }
    set src(value) {
        this.setAttribute('src', value);
    }
}
patchPropAttributes(MockImageElement.prototype, {
    height: Number,
    width: Number,
});
class MockInputElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'input');
    }
    get list() {
        const listId = this.getAttribute('list');
        if (listId) {
            return this.ownerDocument.getElementById(listId);
        }
        return null;
    }
}
patchPropAttributes(MockInputElement.prototype, {
    accept: String,
    autocomplete: String,
    autofocus: Boolean,
    capture: String,
    checked: Boolean,
    disabled: Boolean,
    form: String,
    formaction: String,
    formenctype: String,
    formmethod: String,
    formnovalidate: String,
    formtarget: String,
    height: Number,
    inputmode: String,
    max: String,
    maxLength: Number,
    min: String,
    minLength: Number,
    multiple: Boolean,
    name: String,
    pattern: String,
    placeholder: String,
    required: Boolean,
    readOnly: Boolean,
    size: Number,
    spellCheck: Boolean,
    src: String,
    step: String,
    type: String,
    value: String,
    width: Number,
}, {
    type: 'text',
});
class MockFormElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'form');
    }
}
patchPropAttributes(MockFormElement.prototype, {
    name: String,
});
class MockLinkElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'link');
    }
    get href() {
        return fullUrl(this, 'href');
    }
    set href(value) {
        this.setAttribute('href', value);
    }
}
patchPropAttributes(MockLinkElement.prototype, {
    crossorigin: String,
    media: String,
    rel: String,
    type: String,
});
class MockMetaElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'meta');
    }
}
patchPropAttributes(MockMetaElement.prototype, {
    charset: String,
    content: String,
    name: String,
});
class MockScriptElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'script');
    }
    get src() {
        return fullUrl(this, 'src');
    }
    set src(value) {
        this.setAttribute('src', value);
    }
}
patchPropAttributes(MockScriptElement.prototype, {
    type: String,
});
class MockDOMMatrix {
    constructor() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.e = 0;
        this.f = 0;
        this.m11 = 1;
        this.m12 = 0;
        this.m13 = 0;
        this.m14 = 0;
        this.m21 = 0;
        this.m22 = 1;
        this.m23 = 0;
        this.m24 = 0;
        this.m31 = 0;
        this.m32 = 0;
        this.m33 = 1;
        this.m34 = 0;
        this.m41 = 0;
        this.m42 = 0;
        this.m43 = 0;
        this.m44 = 1;
        this.is2D = true;
        this.isIdentity = true;
    }
    static fromMatrix() {
        return new MockDOMMatrix();
    }
    inverse() {
        return new MockDOMMatrix();
    }
    flipX() {
        return new MockDOMMatrix();
    }
    flipY() {
        return new MockDOMMatrix();
    }
    multiply() {
        return new MockDOMMatrix();
    }
    rotate() {
        return new MockDOMMatrix();
    }
    rotateAxisAngle() {
        return new MockDOMMatrix();
    }
    rotateFromVector() {
        return new MockDOMMatrix();
    }
    scale() {
        return new MockDOMMatrix();
    }
    scaleNonUniform() {
        return new MockDOMMatrix();
    }
    skewX() {
        return new MockDOMMatrix();
    }
    skewY() {
        return new MockDOMMatrix();
    }
    toJSON() { }
    toString() { }
    transformPoint() {
        return new MockDOMPoint();
    }
    translate() {
        return new MockDOMMatrix();
    }
}
class MockDOMPoint {
    constructor() {
        this.w = 1;
        this.x = 0;
        this.y = 0;
        this.z = 0;
    }
    toJSON() { }
    matrixTransform() {
        return new MockDOMMatrix();
    }
}
class MockSVGRect {
    constructor() {
        this.height = 10;
        this.width = 10;
        this.x = 0;
        this.y = 0;
    }
}
class MockStyleElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'style');
        this.sheet = new MockCSSStyleSheet(this);
    }
    get innerHTML() {
        return getStyleElementText(this);
    }
    set innerHTML(value) {
        setStyleElementText(this, value);
    }
    get innerText() {
        return getStyleElementText(this);
    }
    set innerText(value) {
        setStyleElementText(this, value);
    }
    get textContent() {
        return getStyleElementText(this);
    }
    set textContent(value) {
        setStyleElementText(this, value);
    }
}
class MockSVGElement extends MockElement {
    constructor() {
        super(...arguments);
        this.__namespaceURI = 'http://www.w3.org/2000/svg';
    }
    // SVGElement properties and methods
    get ownerSVGElement() {
        return null;
    }
    get viewportElement() {
        return null;
    }
    onunload() {
        /**/
    }
    // SVGGeometryElement properties and methods
    get pathLength() {
        return 0;
    }
    isPointInFill(_pt) {
        return false;
    }
    isPointInStroke(_pt) {
        return false;
    }
    getTotalLength() {
        return 0;
    }
}
class MockSVGGraphicsElement extends MockSVGElement {
    getBBox(_options) {
        return new MockSVGRect();
    }
    getCTM() {
        return new MockDOMMatrix();
    }
    getScreenCTM() {
        return new MockDOMMatrix();
    }
}
class MockSVGSVGElement extends MockSVGGraphicsElement {
    createSVGPoint() {
        return new MockDOMPoint();
    }
}
class MockSVGTextContentElement extends MockSVGGraphicsElement {
    getComputedTextLength() {
        return 0;
    }
}
class MockBaseElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'base');
    }
    get href() {
        return fullUrl(this, 'href');
    }
    set href(value) {
        this.setAttribute('href', value);
    }
}
class MockTemplateElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'template');
        this.content = new MockDocumentFragment(ownerDocument);
    }
    get innerHTML() {
        return this.content.innerHTML;
    }
    set innerHTML(html) {
        this.content.innerHTML = html;
    }
    cloneNode(deep) {
        const cloned = new MockTemplateElement(null);
        cloned.attributes = cloneAttributes(this.attributes);
        const styleCssText = this.getAttribute('style');
        if (styleCssText != null && styleCssText.length > 0) {
            cloned.setAttribute('style', styleCssText);
        }
        cloned.content = this.content.cloneNode(deep);
        if (deep) {
            for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
                const clonedChildNode = this.childNodes[i].cloneNode(true);
                cloned.appendChild(clonedChildNode);
            }
        }
        return cloned;
    }
}
class MockTitleElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'title');
    }
    get text() {
        return this.textContent;
    }
    set text(value) {
        this.textContent = value;
    }
}
class MockUListElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'ul');
    }
}
class MockCanvasElement extends MockHTMLElement {
    constructor(ownerDocument) {
        super(ownerDocument, 'canvas');
    }
    getContext() {
        return {
            fillRect() {
                return;
            },
            clearRect() { },
            getImageData: function (_, __, w, h) {
                return {
                    data: new Array(w * h * 4),
                };
            },
            putImageData() { },
            createImageData: function () {
                return [];
            },
            setTransform() { },
            drawImage() { },
            save() { },
            fillText() { },
            restore() { },
            beginPath() { },
            moveTo() { },
            lineTo() { },
            closePath() { },
            stroke() { },
            translate() { },
            scale() { },
            rotate() { },
            arc() { },
            fill() { },
            measureText() {
                return { width: 0 };
            },
            transform() { },
            rect() { },
            clip() { },
        };
    }
}
function fullUrl(elm, attrName) {
    const val = elm.getAttribute(attrName) || '';
    if (elm.ownerDocument != null) {
        const win = elm.ownerDocument.defaultView;
        if (win != null) {
            const loc = win.location;
            if (loc != null) {
                try {
                    const url = new URL(val, loc.href);
                    return url.href;
                }
                catch (e) { }
            }
        }
    }
    return val.replace(/\'|\"/g, '').trim();
}
function patchPropAttributes(prototype, attrs, defaults = {}) {
    Object.keys(attrs).forEach((propName) => {
        const attr = attrs[propName];
        const defaultValue = defaults[propName];
        if (attr === Boolean) {
            Object.defineProperty(prototype, propName, {
                get() {
                    return this.hasAttribute(propName);
                },
                set(value) {
                    if (value) {
                        this.setAttribute(propName, '');
                    }
                    else {
                        this.removeAttribute(propName);
                    }
                },
            });
        }
        else if (attr === Number) {
            Object.defineProperty(prototype, propName, {
                get() {
                    const value = this.getAttribute(propName);
                    return value ? parseInt(value, 10) : defaultValue === undefined ? 0 : defaultValue;
                },
                set(value) {
                    this.setAttribute(propName, value);
                },
            });
        }
        else {
            Object.defineProperty(prototype, propName, {
                get() {
                    return this.hasAttribute(propName) ? this.getAttribute(propName) : defaultValue || '';
                },
                set(value) {
                    this.setAttribute(propName, value);
                },
            });
        }
    });
}
MockElement.prototype.cloneNode = function (deep) {
    // because we're creating elements, which extending specific HTML base classes there
    // is a MockElement circular reference that bundling has trouble dealing with so
    // the fix is to add cloneNode() to MockElement's prototype after the HTML classes
    const cloned = createElement(this.ownerDocument, this.nodeName);
    cloned.attributes = cloneAttributes(this.attributes);
    const styleCssText = this.getAttribute('style');
    if (styleCssText != null && styleCssText.length > 0) {
        cloned.setAttribute('style', styleCssText);
    }
    if (deep) {
        for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
            const clonedChildNode = this.childNodes[i].cloneNode(true);
            cloned.appendChild(clonedChildNode);
        }
    }
    return cloned;
};

let sharedDocument;
function parseHtmlToDocument(html, ownerDocument = null) {
    if (ownerDocument == null) {
        if (sharedDocument == null) {
            sharedDocument = new MockDocument();
        }
        ownerDocument = sharedDocument;
    }
    return parseDocumentUtil(ownerDocument, html);
}
function parseHtmlToFragment(html, ownerDocument = null) {
    if (ownerDocument == null) {
        if (sharedDocument == null) {
            sharedDocument = new MockDocument();
        }
        ownerDocument = sharedDocument;
    }
    return parseFragmentUtil(ownerDocument, html);
}

const consoleNoop = () => {
    /**/
};
function createConsole() {
    return {
        debug: consoleNoop,
        error: consoleNoop,
        info: consoleNoop,
        log: consoleNoop,
        warn: consoleNoop,
        dir: consoleNoop,
        dirxml: consoleNoop,
        table: consoleNoop,
        trace: consoleNoop,
        group: consoleNoop,
        groupCollapsed: consoleNoop,
        groupEnd: consoleNoop,
        clear: consoleNoop,
        count: consoleNoop,
        countReset: consoleNoop,
        assert: consoleNoop,
        profile: consoleNoop,
        profileEnd: consoleNoop,
        time: consoleNoop,
        timeLog: consoleNoop,
        timeEnd: consoleNoop,
        timeStamp: consoleNoop,
        context: consoleNoop,
        memory: consoleNoop,
    };
}

class MockHeaders {
    constructor(init) {
        this._values = [];
        if (typeof init === 'object') {
            if (typeof init[Symbol.iterator] === 'function') {
                const kvs = [];
                for (const kv of init) {
                    if (typeof kv[Symbol.iterator] === 'function') {
                        kvs.push([...kv]);
                    }
                }
                for (const kv of kvs) {
                    this.append(kv[0], kv[1]);
                }
            }
            else {
                for (const key in init) {
                    this.append(key, init[key]);
                }
            }
        }
    }
    append(key, value) {
        this._values.push([key, value + '']);
    }
    delete(key) {
        key = key.toLowerCase();
        for (let i = this._values.length - 1; i >= 0; i--) {
            if (this._values[i][0].toLowerCase() === key) {
                this._values.splice(i, 1);
            }
        }
    }
    entries() {
        const entries = [];
        for (const kv of this.keys()) {
            entries.push([kv, this.get(kv)]);
        }
        let index = -1;
        return {
            next() {
                index++;
                return {
                    value: entries[index],
                    done: !entries[index],
                };
            },
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    forEach(cb) {
        for (const kv of this.entries()) {
            cb(kv[1], kv[0]);
        }
    }
    get(key) {
        const rtn = [];
        key = key.toLowerCase();
        for (const kv of this._values) {
            if (kv[0].toLowerCase() === key) {
                rtn.push(kv[1]);
            }
        }
        return rtn.length > 0 ? rtn.join(', ') : null;
    }
    has(key) {
        key = key.toLowerCase();
        for (const kv of this._values) {
            if (kv[0].toLowerCase() === key) {
                return true;
            }
        }
        return false;
    }
    keys() {
        const keys = [];
        for (const kv of this._values) {
            const key = kv[0].toLowerCase();
            if (!keys.includes(key)) {
                keys.push(key);
            }
        }
        let index = -1;
        return {
            next() {
                index++;
                return {
                    value: keys[index],
                    done: !keys[index],
                };
            },
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    set(key, value) {
        for (const kv of this._values) {
            if (kv[0].toLowerCase() === key.toLowerCase()) {
                kv[1] = value + '';
                return;
            }
        }
        this.append(key, value);
    }
    values() {
        const values = this._values;
        let index = -1;
        return {
            next() {
                index++;
                const done = !values[index];
                return {
                    value: done ? undefined : values[index][1],
                    done,
                };
            },
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    [Symbol.iterator]() {
        return this.entries();
    }
}

class MockDOMParser {
    parseFromString(htmlToParse, mimeType) {
        if (mimeType !== 'text/html') {
            console.error('XML parsing not implemented yet, continuing as html');
        }
        return parseHtmlToDocument(htmlToParse);
    }
}

class MockRequest {
    constructor(input, init = {}) {
        this._method = 'GET';
        this._url = '/';
        this.bodyUsed = false;
        this.cache = 'default';
        this.credentials = 'same-origin';
        this.integrity = '';
        this.keepalive = false;
        this.mode = 'cors';
        this.redirect = 'follow';
        this.referrer = 'about:client';
        this.referrerPolicy = '';
        if (typeof input === 'string') {
            this.url = input;
        }
        else if (input) {
            Object.assign(this, input);
            this.headers = new MockHeaders(input.headers);
        }
        Object.assign(this, init);
        if (init.headers) {
            this.headers = new MockHeaders(init.headers);
        }
        if (!this.headers) {
            this.headers = new MockHeaders();
        }
    }
    get url() {
        if (typeof this._url === 'string') {
            return new URL(this._url, location.href).href;
        }
        return new URL('/', location.href).href;
    }
    set url(value) {
        this._url = value;
    }
    get method() {
        if (typeof this._method === 'string') {
            return this._method.toUpperCase();
        }
        return 'GET';
    }
    set method(value) {
        this._method = value;
    }
    clone() {
        const clone = { ...this };
        clone.headers = new MockHeaders(this.headers);
        return new MockRequest(clone);
    }
}
class MockResponse {
    constructor(body, init = {}) {
        this.ok = true;
        this.status = 200;
        this.statusText = '';
        this.type = 'default';
        this.url = '';
        this._body = body;
        if (init) {
            Object.assign(this, init);
        }
        this.headers = new MockHeaders(init.headers);
    }
    async json() {
        return JSON.parse(this._body);
    }
    async text() {
        return this._body;
    }
    clone() {
        const initClone = { ...this };
        initClone.headers = new MockHeaders(this.headers);
        return new MockResponse(this._body, initClone);
    }
}

function setupGlobal(gbl) {
    if (gbl.window == null) {
        const win = (gbl.window = new MockWindow());
        WINDOW_FUNCTIONS.forEach((fnName) => {
            if (!(fnName in gbl)) {
                gbl[fnName] = win[fnName].bind(win);
            }
        });
        WINDOW_PROPS.forEach((propName) => {
            if (!(propName in gbl)) {
                Object.defineProperty(gbl, propName, {
                    get() {
                        return win[propName];
                    },
                    set(val) {
                        win[propName] = val;
                    },
                    configurable: true,
                    enumerable: true,
                });
            }
        });
        GLOBAL_CONSTRUCTORS.forEach(([cstrName]) => {
            gbl[cstrName] = win[cstrName];
        });
    }
    return gbl.window;
}
function teardownGlobal(gbl) {
    const win = gbl.window;
    if (win && typeof win.close === 'function') {
        win.close();
    }
}
function patchWindow(winToBePatched) {
    const mockWin = new MockWindow(false);
    WINDOW_FUNCTIONS.forEach((fnName) => {
        if (typeof winToBePatched[fnName] !== 'function') {
            winToBePatched[fnName] = mockWin[fnName].bind(mockWin);
        }
    });
    WINDOW_PROPS.forEach((propName) => {
        if (winToBePatched === undefined) {
            Object.defineProperty(winToBePatched, propName, {
                get() {
                    return mockWin[propName];
                },
                set(val) {
                    mockWin[propName] = val;
                },
                configurable: true,
                enumerable: true,
            });
        }
    });
}
function addGlobalsToWindowPrototype(mockWinPrototype) {
    GLOBAL_CONSTRUCTORS.forEach(([cstrName, Cstr]) => {
        Object.defineProperty(mockWinPrototype, cstrName, {
            get() {
                return this['__' + cstrName] || Cstr;
            },
            set(cstr) {
                this['__' + cstrName] = cstr;
            },
            configurable: true,
            enumerable: true,
        });
    });
}
const WINDOW_FUNCTIONS = [
    'addEventListener',
    'alert',
    'blur',
    'cancelAnimationFrame',
    'cancelIdleCallback',
    'clearInterval',
    'clearTimeout',
    'close',
    'confirm',
    'dispatchEvent',
    'focus',
    'getComputedStyle',
    'matchMedia',
    'open',
    'prompt',
    'removeEventListener',
    'requestAnimationFrame',
    'requestIdleCallback',
    'URL',
];
const WINDOW_PROPS = [
    'customElements',
    'devicePixelRatio',
    'document',
    'history',
    'innerHeight',
    'innerWidth',
    'localStorage',
    'location',
    'navigator',
    'pageXOffset',
    'pageYOffset',
    'performance',
    'screenLeft',
    'screenTop',
    'screenX',
    'screenY',
    'scrollX',
    'scrollY',
    'sessionStorage',
    'CSS',
    'CustomEvent',
    'Event',
    'Element',
    'HTMLElement',
    'Node',
    'NodeList',
    'FocusEvent',
    'KeyboardEvent',
    'MouseEvent',
];
const GLOBAL_CONSTRUCTORS = [
    ['CustomEvent', MockCustomEvent],
    ['Event', MockEvent],
    ['Headers', MockHeaders],
    ['FocusEvent', MockFocusEvent],
    ['KeyboardEvent', MockKeyboardEvent],
    ['MouseEvent', MockMouseEvent],
    ['Request', MockRequest],
    ['Response', MockResponse],
    ['DOMParser', MockDOMParser],
    ['HTMLAnchorElement', MockAnchorElement],
    ['HTMLBaseElement', MockBaseElement],
    ['HTMLButtonElement', MockButtonElement],
    ['HTMLCanvasElement', MockCanvasElement],
    ['HTMLFormElement', MockFormElement],
    ['HTMLImageElement', MockImageElement],
    ['HTMLInputElement', MockInputElement],
    ['HTMLLinkElement', MockLinkElement],
    ['HTMLMetaElement', MockMetaElement],
    ['HTMLScriptElement', MockScriptElement],
    ['HTMLStyleElement', MockStyleElement],
    ['HTMLTemplateElement', MockTemplateElement],
    ['HTMLTitleElement', MockTitleElement],
    ['HTMLUListElement', MockUListElement],
];

class MockHistory {
    constructor() {
        this.items = [];
    }
    get length() {
        return this.items.length;
    }
    back() {
        this.go(-1);
    }
    forward() {
        this.go(1);
    }
    go(_value) {
        //
    }
    pushState(_state, _title, _url) {
        //
    }
    replaceState(_state, _title, _url) {
        //
    }
}

class MockIntersectionObserver {
    constructor() {
        /**/
    }
    disconnect() {
        /**/
    }
    observe() {
        /**/
    }
    takeRecords() {
        return [];
    }
    unobserve() {
        /**/
    }
}

class MockLocation {
    constructor() {
        this.ancestorOrigins = null;
        this.protocol = '';
        this.host = '';
        this.hostname = '';
        this.port = '';
        this.pathname = '';
        this.search = '';
        this.hash = '';
        this.username = '';
        this.password = '';
        this.origin = '';
        this._href = '';
    }
    get href() {
        return this._href;
    }
    set href(value) {
        const url = new URL(value, 'http://mockdoc.stenciljs.com');
        this._href = url.href;
        this.protocol = url.protocol;
        this.host = url.host;
        this.hostname = url.hostname;
        this.port = url.port;
        this.pathname = url.pathname;
        this.search = url.search;
        this.hash = url.hash;
        this.username = url.username;
        this.password = url.password;
        this.origin = url.origin;
    }
    assign(_url) {
        //
    }
    reload(_forcedReload) {
        //
    }
    replace(_url) {
        //
    }
    toString() {
        return this.href;
    }
}

class MockNavigator {
    constructor() {
        this.appCodeName = 'MockNavigator';
        this.appName = 'MockNavigator';
        this.appVersion = 'MockNavigator';
        this.platform = 'MockNavigator';
        this.userAgent = 'MockNavigator';
    }
}

/**
 * https://developer.mozilla.org/en-US/docs/Web/API/Performance
 */
class MockPerformance {
    constructor() {
        this.timeOrigin = Date.now();
        this.eventCounts = new Map();
    }
    addEventListener() {
        //
    }
    clearMarks() {
        //
    }
    clearMeasures() {
        //
    }
    clearResourceTimings() {
        //
    }
    dispatchEvent() {
        return true;
    }
    getEntries() {
        return [];
    }
    getEntriesByName() {
        return [];
    }
    getEntriesByType() {
        return [];
    }
    // Stencil's implementation of `mark` is non-compliant with the `Performance` interface. Because Stencil will
    // instantiate an instance of this class and may attempt to assign it to a variable of type `Performance`, the return
    // type must match the `Performance` interface (rather than typing this function as returning `void` and ignoring the
    // associated errors returned by the type checker)
    // @ts-ignore
    mark() {
        //
    }
    // Stencil's implementation of `measure` is non-compliant with the `Performance` interface. Because Stencil will
    // instantiate an instance of this class and may attempt to assign it to a variable of type `Performance`, the return
    // type must match the `Performance` interface (rather than typing this function as returning `void` and ignoring the
    // associated errors returned by the type checker)
    // @ts-ignore
    measure() {
        //
    }
    get navigation() {
        return {};
    }
    now() {
        return Date.now() - this.timeOrigin;
    }
    get onresourcetimingbufferfull() {
        return null;
    }
    removeEventListener() {
        //
    }
    setResourceTimingBufferSize() {
        //
    }
    get timing() {
        return {};
    }
    toJSON() {
        //
    }
}
function resetPerformance(perf) {
    if (perf != null) {
        try {
            perf.timeOrigin = Date.now();
        }
        catch (e) { }
    }
}

class MockStorage {
    constructor() {
        this.items = new Map();
    }
    key(_value) {
        //
    }
    getItem(key) {
        key = String(key);
        if (this.items.has(key)) {
            return this.items.get(key);
        }
        return null;
    }
    setItem(key, value) {
        if (value == null) {
            value = 'null';
        }
        this.items.set(String(key), String(value));
    }
    removeItem(key) {
        this.items.delete(String(key));
    }
    clear() {
        this.items.clear();
    }
}

const nativeClearInterval = clearInterval;
const nativeClearTimeout = clearTimeout;
const nativeSetInterval = setInterval;
const nativeSetTimeout = setTimeout;
const nativeURL = URL;
class MockWindow {
    constructor(html = null) {
        if (html !== false) {
            this.document = new MockDocument(html, this);
        }
        else {
            this.document = null;
        }
        this.performance = new MockPerformance();
        this.customElements = new MockCustomElementRegistry(this);
        this.console = createConsole();
        resetWindowDefaults(this);
        resetWindowDimensions(this);
    }
    addEventListener(type, handler) {
        addEventListener(this, type, handler);
    }
    alert(msg) {
        if (this.console) {
            this.console.debug(msg);
        }
        else {
            console.debug(msg);
        }
    }
    blur() {
        /**/
    }
    cancelAnimationFrame(id) {
        this.__clearTimeout(id);
    }
    cancelIdleCallback(id) {
        this.__clearTimeout(id);
    }
    get CharacterData() {
        if (this.__charDataCstr == null) {
            const ownerDocument = this.document;
            this.__charDataCstr = class extends MockNode {
                constructor() {
                    super(ownerDocument, 0, 'test', '');
                    throw new Error('Illegal constructor: cannot construct CharacterData');
                }
            };
        }
        return this.__charDataCstr;
    }
    set CharacterData(charDataCstr) {
        this.__charDataCstr = charDataCstr;
    }
    clearInterval(id) {
        this.__clearInterval(id);
    }
    clearTimeout(id) {
        this.__clearTimeout(id);
    }
    close() {
        resetWindow(this);
    }
    confirm() {
        return false;
    }
    get CSS() {
        return {
            supports: () => true,
        };
    }
    get Document() {
        if (this.__docCstr == null) {
            const win = this;
            this.__docCstr = class extends MockDocument {
                constructor() {
                    super(false, win);
                    throw new Error('Illegal constructor: cannot construct Document');
                }
            };
        }
        return this.__docCstr;
    }
    set Document(docCstr) {
        this.__docCstr = docCstr;
    }
    get DocumentFragment() {
        if (this.__docFragCstr == null) {
            const ownerDocument = this.document;
            this.__docFragCstr = class extends MockDocumentFragment {
                constructor() {
                    super(ownerDocument);
                    throw new Error('Illegal constructor: cannot construct DocumentFragment');
                }
            };
        }
        return this.__docFragCstr;
    }
    set DocumentFragment(docFragCstr) {
        this.__docFragCstr = docFragCstr;
    }
    get DocumentType() {
        if (this.__docTypeCstr == null) {
            const ownerDocument = this.document;
            this.__docTypeCstr = class extends MockNode {
                constructor() {
                    super(ownerDocument, 0, 'test', '');
                    throw new Error('Illegal constructor: cannot construct DocumentType');
                }
            };
        }
        return this.__docTypeCstr;
    }
    set DocumentType(docTypeCstr) {
        this.__docTypeCstr = docTypeCstr;
    }
    get DOMTokenList() {
        if (this.__domTokenListCstr == null) {
            this.__domTokenListCstr = class MockDOMTokenList {
            };
        }
        return this.__domTokenListCstr;
    }
    set DOMTokenList(domTokenListCstr) {
        this.__domTokenListCstr = domTokenListCstr;
    }
    dispatchEvent(ev) {
        return dispatchEvent(this, ev);
    }
    get Element() {
        if (this.__elementCstr == null) {
            const ownerDocument = this.document;
            this.__elementCstr = class extends MockElement {
                constructor() {
                    super(ownerDocument, '');
                    throw new Error('Illegal constructor: cannot construct Element');
                }
            };
        }
        return this.__elementCstr;
    }
    fetch(input, init) {
        if (typeof fetch === 'function') {
            return fetch(input, init);
        }
        throw new Error(`fetch() not implemented`);
    }
    focus() {
        /**/
    }
    getComputedStyle(_) {
        return {
            cssText: '',
            length: 0,
            parentRule: null,
            getPropertyPriority() {
                return null;
            },
            getPropertyValue() {
                return '';
            },
            item() {
                return null;
            },
            removeProperty() {
                return null;
            },
            setProperty() {
                return null;
            },
        };
    }
    get globalThis() {
        return this;
    }
    get history() {
        if (this.__history == null) {
            this.__history = new MockHistory();
        }
        return this.__history;
    }
    set history(hsty) {
        this.__history = hsty;
    }
    get JSON() {
        return JSON;
    }
    get HTMLElement() {
        if (this.__htmlElementCstr == null) {
            const ownerDocument = this.document;
            this.__htmlElementCstr = class extends MockHTMLElement {
                constructor() {
                    super(ownerDocument, '');
                    const observedAttributes = this.constructor.observedAttributes;
                    if (Array.isArray(observedAttributes) && typeof this.attributeChangedCallback === 'function') {
                        observedAttributes.forEach((attrName) => {
                            const attrValue = this.getAttribute(attrName);
                            if (attrValue != null) {
                                this.attributeChangedCallback(attrName, null, attrValue);
                            }
                        });
                    }
                }
            };
        }
        return this.__htmlElementCstr;
    }
    set HTMLElement(htmlElementCstr) {
        this.__htmlElementCstr = htmlElementCstr;
    }
    get IntersectionObserver() {
        return MockIntersectionObserver;
    }
    get localStorage() {
        if (this.__localStorage == null) {
            this.__localStorage = new MockStorage();
        }
        return this.__localStorage;
    }
    set localStorage(locStorage) {
        this.__localStorage = locStorage;
    }
    get location() {
        if (this.__location == null) {
            this.__location = new MockLocation();
        }
        return this.__location;
    }
    set location(val) {
        if (typeof val === 'string') {
            if (this.__location == null) {
                this.__location = new MockLocation();
            }
            this.__location.href = val;
        }
        else {
            this.__location = val;
        }
    }
    matchMedia(media) {
        return {
            media,
            matches: false,
            addListener: (_handler) => { },
            removeListener: (_handler) => { },
            addEventListener: (_type, _handler) => { },
            removeEventListener: (_type, _handler) => { },
            dispatchEvent: (_ev) => { },
            onchange: null,
        };
    }
    get Node() {
        if (this.__nodeCstr == null) {
            const ownerDocument = this.document;
            this.__nodeCstr = class extends MockNode {
                constructor() {
                    super(ownerDocument, 0, 'test', '');
                    throw new Error('Illegal constructor: cannot construct Node');
                }
            };
        }
        return this.__nodeCstr;
    }
    get NodeList() {
        if (this.__nodeListCstr == null) {
            const ownerDocument = this.document;
            this.__nodeListCstr = class extends MockNodeList {
                constructor() {
                    super(ownerDocument, [], 0);
                    throw new Error('Illegal constructor: cannot construct NodeList');
                }
            };
        }
        return this.__nodeListCstr;
    }
    get navigator() {
        if (this.__navigator == null) {
            this.__navigator = new MockNavigator();
        }
        return this.__navigator;
    }
    set navigator(nav) {
        this.__navigator = nav;
    }
    get parent() {
        return null;
    }
    prompt() {
        return '';
    }
    open() {
        return null;
    }
    get origin() {
        return this.location.origin;
    }
    removeEventListener(type, handler) {
        removeEventListener(this, type, handler);
    }
    requestAnimationFrame(callback) {
        return this.setTimeout(() => {
            callback(Date.now());
        }, 0);
    }
    requestIdleCallback(callback) {
        return this.setTimeout(() => {
            callback({
                didTimeout: false,
                timeRemaining: () => 0,
            });
        }, 0);
    }
    scroll(_x, _y) {
        /**/
    }
    scrollBy(_x, _y) {
        /**/
    }
    scrollTo(_x, _y) {
        /**/
    }
    get self() {
        return this;
    }
    get sessionStorage() {
        if (this.__sessionStorage == null) {
            this.__sessionStorage = new MockStorage();
        }
        return this.__sessionStorage;
    }
    set sessionStorage(locStorage) {
        this.__sessionStorage = locStorage;
    }
    setInterval(callback, ms, ...args) {
        if (this.__timeouts == null) {
            this.__timeouts = new Set();
        }
        ms = Math.min(ms, this.__maxTimeout);
        if (this.__allowInterval) {
            const intervalId = this.__setInterval(() => {
                if (this.__timeouts) {
                    this.__timeouts.delete(intervalId);
                    try {
                        callback(...args);
                    }
                    catch (e) {
                        if (this.console) {
                            this.console.error(e);
                        }
                        else {
                            console.error(e);
                        }
                    }
                }
            }, ms);
            if (this.__timeouts) {
                this.__timeouts.add(intervalId);
            }
            return intervalId;
        }
        const timeoutId = this.__setTimeout(() => {
            if (this.__timeouts) {
                this.__timeouts.delete(timeoutId);
                try {
                    callback(...args);
                }
                catch (e) {
                    if (this.console) {
                        this.console.error(e);
                    }
                    else {
                        console.error(e);
                    }
                }
            }
        }, ms);
        if (this.__timeouts) {
            this.__timeouts.add(timeoutId);
        }
        return timeoutId;
    }
    setTimeout(callback, ms, ...args) {
        if (this.__timeouts == null) {
            this.__timeouts = new Set();
        }
        ms = Math.min(ms, this.__maxTimeout);
        const timeoutId = this.__setTimeout(() => {
            if (this.__timeouts) {
                this.__timeouts.delete(timeoutId);
                try {
                    callback(...args);
                }
                catch (e) {
                    if (this.console) {
                        this.console.error(e);
                    }
                    else {
                        console.error(e);
                    }
                }
            }
        }, ms);
        if (this.__timeouts) {
            this.__timeouts.add(timeoutId);
        }
        return timeoutId;
    }
    get top() {
        return this;
    }
    get window() {
        return this;
    }
    onanimationstart() {
        /**/
    }
    onanimationend() {
        /**/
    }
    onanimationiteration() {
        /**/
    }
    onabort() {
        /**/
    }
    onauxclick() {
        /**/
    }
    onbeforecopy() {
        /**/
    }
    onbeforecut() {
        /**/
    }
    onbeforepaste() {
        /**/
    }
    onblur() {
        /**/
    }
    oncancel() {
        /**/
    }
    oncanplay() {
        /**/
    }
    oncanplaythrough() {
        /**/
    }
    onchange() {
        /**/
    }
    onclick() {
        /**/
    }
    onclose() {
        /**/
    }
    oncontextmenu() {
        /**/
    }
    oncopy() {
        /**/
    }
    oncuechange() {
        /**/
    }
    oncut() {
        /**/
    }
    ondblclick() {
        /**/
    }
    ondrag() {
        /**/
    }
    ondragend() {
        /**/
    }
    ondragenter() {
        /**/
    }
    ondragleave() {
        /**/
    }
    ondragover() {
        /**/
    }
    ondragstart() {
        /**/
    }
    ondrop() {
        /**/
    }
    ondurationchange() {
        /**/
    }
    onemptied() {
        /**/
    }
    onended() {
        /**/
    }
    onerror() {
        /**/
    }
    onfocus() {
        /**/
    }
    onfocusin() {
        /**/
    }
    onfocusout() {
        /**/
    }
    onformdata() {
        /**/
    }
    onfullscreenchange() {
        /**/
    }
    onfullscreenerror() {
        /**/
    }
    ongotpointercapture() {
        /**/
    }
    oninput() {
        /**/
    }
    oninvalid() {
        /**/
    }
    onkeydown() {
        /**/
    }
    onkeypress() {
        /**/
    }
    onkeyup() {
        /**/
    }
    onload() {
        /**/
    }
    onloadeddata() {
        /**/
    }
    onloadedmetadata() {
        /**/
    }
    onloadstart() {
        /**/
    }
    onlostpointercapture() {
        /**/
    }
    onmousedown() {
        /**/
    }
    onmouseenter() {
        /**/
    }
    onmouseleave() {
        /**/
    }
    onmousemove() {
        /**/
    }
    onmouseout() {
        /**/
    }
    onmouseover() {
        /**/
    }
    onmouseup() {
        /**/
    }
    onmousewheel() {
        /**/
    }
    onpaste() {
        /**/
    }
    onpause() {
        /**/
    }
    onplay() {
        /**/
    }
    onplaying() {
        /**/
    }
    onpointercancel() {
        /**/
    }
    onpointerdown() {
        /**/
    }
    onpointerenter() {
        /**/
    }
    onpointerleave() {
        /**/
    }
    onpointermove() {
        /**/
    }
    onpointerout() {
        /**/
    }
    onpointerover() {
        /**/
    }
    onpointerup() {
        /**/
    }
    onprogress() {
        /**/
    }
    onratechange() {
        /**/
    }
    onreset() {
        /**/
    }
    onresize() {
        /**/
    }
    onscroll() {
        /**/
    }
    onsearch() {
        /**/
    }
    onseeked() {
        /**/
    }
    onseeking() {
        /**/
    }
    onselect() {
        /**/
    }
    onselectstart() {
        /**/
    }
    onstalled() {
        /**/
    }
    onsubmit() {
        /**/
    }
    onsuspend() {
        /**/
    }
    ontimeupdate() {
        /**/
    }
    ontoggle() {
        /**/
    }
    onvolumechange() {
        /**/
    }
    onwaiting() {
        /**/
    }
    onwebkitfullscreenchange() {
        /**/
    }
    onwebkitfullscreenerror() {
        /**/
    }
    onwheel() {
        /**/
    }
}
addGlobalsToWindowPrototype(MockWindow.prototype);
function resetWindowDefaults(win) {
    win.__clearInterval = nativeClearInterval;
    win.__clearTimeout = nativeClearTimeout;
    win.__setInterval = nativeSetInterval;
    win.__setTimeout = nativeSetTimeout;
    win.__maxTimeout = 30000;
    win.__allowInterval = true;
    win.URL = nativeURL;
}
function cloneWindow(srcWin, opts = {}) {
    if (srcWin == null) {
        return null;
    }
    const clonedWin = new MockWindow(false);
    if (!opts.customElementProxy) {
        // TODO(STENCIL-345) - Evaluate reconciling MockWindow, Window differences
        // @ts-ignore
        srcWin.customElements = null;
    }
    if (srcWin.document != null) {
        const clonedDoc = new MockDocument(false, clonedWin);
        clonedWin.document = clonedDoc;
        clonedDoc.documentElement = srcWin.document.documentElement.cloneNode(true);
    }
    else {
        clonedWin.document = new MockDocument(null, clonedWin);
    }
    return clonedWin;
}
function cloneDocument(srcDoc) {
    if (srcDoc == null) {
        return null;
    }
    const dstWin = cloneWindow(srcDoc.defaultView);
    return dstWin.document;
}
// TODO(STENCIL-345) - Evaluate reconciling MockWindow, Window differences
/**
 * Constrain setTimeout() to 1ms, but still async. Also
 * only allow setInterval() to fire once, also constrained to 1ms.
 * @param win the mock window instance to update
 */
function constrainTimeouts(win) {
    win.__allowInterval = false;
    win.__maxTimeout = 0;
}
function resetWindow(win) {
    if (win != null) {
        if (win.__timeouts) {
            win.__timeouts.forEach((timeoutId) => {
                nativeClearInterval(timeoutId);
                nativeClearTimeout(timeoutId);
            });
            win.__timeouts.clear();
        }
        if (win.customElements && win.customElements.clear) {
            win.customElements.clear();
        }
        resetDocument(win.document);
        resetPerformance(win.performance);
        for (const key in win) {
            if (win.hasOwnProperty(key) && key !== 'document' && key !== 'performance' && key !== 'customElements') {
                delete win[key];
            }
        }
        resetWindowDefaults(win);
        resetWindowDimensions(win);
        resetEventListeners(win);
        if (win.document != null) {
            try {
                win.document.defaultView = win;
            }
            catch (e) { }
        }
        // ensure we don't hold onto nodeFetch values
        win.fetch = null;
        win.Headers = null;
        win.Request = null;
        win.Response = null;
        win.FetchError = null;
    }
}
function resetWindowDimensions(win) {
    try {
        win.devicePixelRatio = 1;
        win.innerHeight = 768;
        win.innerWidth = 1366;
        win.pageXOffset = 0;
        win.pageYOffset = 0;
        win.screenLeft = 0;
        win.screenTop = 0;
        win.screenX = 0;
        win.screenY = 0;
        win.scrollX = 0;
        win.scrollY = 0;
        win.screen = {
            availHeight: win.innerHeight,
            availLeft: 0,
            availTop: 0,
            availWidth: win.innerWidth,
            colorDepth: 24,
            height: win.innerHeight,
            keepAwake: false,
            orientation: {
                angle: 0,
                type: 'portrait-primary',
            },
            pixelDepth: 24,
            width: win.innerWidth,
        };
    }
    catch (e) { }
}

class MockDocument extends MockHTMLElement {
    constructor(html = null, win = null) {
        super(null, null);
        this.nodeName = "#document" /* NODE_NAMES.DOCUMENT_NODE */;
        this.nodeType = 9 /* NODE_TYPES.DOCUMENT_NODE */;
        this.defaultView = win;
        this.cookie = '';
        this.referrer = '';
        this.appendChild(this.createDocumentTypeNode());
        if (typeof html === 'string') {
            const parsedDoc = parseDocumentUtil(this, html);
            const documentElement = parsedDoc.children.find((elm) => elm.nodeName === 'HTML');
            if (documentElement != null) {
                this.appendChild(documentElement);
                setOwnerDocument(documentElement, this);
            }
        }
        else if (html !== false) {
            const documentElement = new MockHTMLElement(this, 'html');
            this.appendChild(documentElement);
            documentElement.appendChild(new MockHTMLElement(this, 'head'));
            documentElement.appendChild(new MockHTMLElement(this, 'body'));
        }
    }
    get dir() {
        return this.documentElement.dir;
    }
    set dir(value) {
        this.documentElement.dir = value;
    }
    get location() {
        if (this.defaultView != null) {
            return this.defaultView.location;
        }
        return null;
    }
    set location(val) {
        if (this.defaultView != null) {
            this.defaultView.location = val;
        }
    }
    get baseURI() {
        const baseNode = this.head.childNodes.find((node) => node.nodeName === 'BASE');
        if (baseNode) {
            return baseNode.href;
        }
        return this.URL;
    }
    get URL() {
        return this.location.href;
    }
    get styleSheets() {
        return this.querySelectorAll('style');
    }
    get scripts() {
        return this.querySelectorAll('script');
    }
    get forms() {
        return this.querySelectorAll('form');
    }
    get images() {
        return this.querySelectorAll('img');
    }
    get scrollingElement() {
        return this.documentElement;
    }
    get documentElement() {
        for (let i = this.childNodes.length - 1; i >= 0; i--) {
            if (this.childNodes[i].nodeName === 'HTML') {
                return this.childNodes[i];
            }
        }
        const documentElement = new MockHTMLElement(this, 'html');
        this.appendChild(documentElement);
        return documentElement;
    }
    set documentElement(documentElement) {
        for (let i = this.childNodes.length - 1; i >= 0; i--) {
            if (this.childNodes[i].nodeType !== 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */) {
                this.childNodes[i].remove();
            }
        }
        if (documentElement != null) {
            this.appendChild(documentElement);
            setOwnerDocument(documentElement, this);
        }
    }
    get head() {
        const documentElement = this.documentElement;
        for (let i = 0; i < documentElement.childNodes.length; i++) {
            if (documentElement.childNodes[i].nodeName === 'HEAD') {
                return documentElement.childNodes[i];
            }
        }
        const head = new MockHTMLElement(this, 'head');
        documentElement.insertBefore(head, documentElement.firstChild);
        return head;
    }
    set head(head) {
        const documentElement = this.documentElement;
        for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
            if (documentElement.childNodes[i].nodeName === 'HEAD') {
                documentElement.childNodes[i].remove();
            }
        }
        if (head != null) {
            documentElement.insertBefore(head, documentElement.firstChild);
            setOwnerDocument(head, this);
        }
    }
    get body() {
        const documentElement = this.documentElement;
        for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
            if (documentElement.childNodes[i].nodeName === 'BODY') {
                return documentElement.childNodes[i];
            }
        }
        const body = new MockHTMLElement(this, 'body');
        documentElement.appendChild(body);
        return body;
    }
    set body(body) {
        const documentElement = this.documentElement;
        for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
            if (documentElement.childNodes[i].nodeName === 'BODY') {
                documentElement.childNodes[i].remove();
            }
        }
        if (body != null) {
            documentElement.appendChild(body);
            setOwnerDocument(body, this);
        }
    }
    appendChild(newNode) {
        newNode.remove();
        newNode.parentNode = this;
        this.childNodes.push(newNode);
        return newNode;
    }
    createComment(data) {
        return new MockComment(this, data);
    }
    createAttribute(attrName) {
        return new MockAttr(attrName.toLowerCase(), '');
    }
    createAttributeNS(namespaceURI, attrName) {
        return new MockAttr(attrName, '', namespaceURI);
    }
    createElement(tagName) {
        if (tagName === "#document" /* NODE_NAMES.DOCUMENT_NODE */) {
            const doc = new MockDocument(false);
            doc.nodeName = tagName;
            doc.parentNode = null;
            return doc;
        }
        return createElement(this, tagName);
    }
    createElementNS(namespaceURI, tagName) {
        const elmNs = createElementNS(this, namespaceURI, tagName);
        return elmNs;
    }
    createTextNode(text) {
        return new MockTextNode(this, text);
    }
    createDocumentFragment() {
        return new MockDocumentFragment(this);
    }
    createDocumentTypeNode() {
        return new MockDocumentTypeNode(this);
    }
    getElementById(id) {
        return getElementById(this, id);
    }
    getElementsByName(elmName) {
        return getElementsByName(this, elmName.toLowerCase());
    }
    get title() {
        const title = this.head.childNodes.find((elm) => elm.nodeName === 'TITLE');
        if (title != null && typeof title.textContent === 'string') {
            return title.textContent.trim();
        }
        return '';
    }
    set title(value) {
        const head = this.head;
        let title = head.childNodes.find((elm) => elm.nodeName === 'TITLE');
        if (title == null) {
            title = this.createElement('title');
            head.appendChild(title);
        }
        title.textContent = value;
    }
}
function createDocument(html = null) {
    return new MockWindow(html).document;
}
function createFragment(html) {
    return parseHtmlToFragment(html, null);
}
function resetDocument(doc) {
    if (doc != null) {
        resetEventListeners(doc);
        const documentElement = doc.documentElement;
        if (documentElement != null) {
            resetElement(documentElement);
            for (let i = 0, ii = documentElement.childNodes.length; i < ii; i++) {
                const childNode = documentElement.childNodes[i];
                resetElement(childNode);
                childNode.childNodes.length = 0;
            }
        }
        for (const key in doc) {
            if (doc.hasOwnProperty(key) && !DOC_KEY_KEEPERS.has(key)) {
                delete doc[key];
            }
        }
        try {
            doc.nodeName = "#document" /* NODE_NAMES.DOCUMENT_NODE */;
        }
        catch (e) { }
        try {
            doc.nodeType = 9 /* NODE_TYPES.DOCUMENT_NODE */;
        }
        catch (e) { }
        try {
            doc.cookie = '';
        }
        catch (e) { }
        try {
            doc.referrer = '';
        }
        catch (e) { }
    }
}
const DOC_KEY_KEEPERS = new Set([
    'nodeName',
    'nodeType',
    'nodeValue',
    'ownerDocument',
    'parentNode',
    'childNodes',
    '_shadowRoot',
]);
function getElementById(elm, id) {
    const children = elm.children;
    for (let i = 0, ii = children.length; i < ii; i++) {
        const childElm = children[i];
        if (childElm.id === id) {
            return childElm;
        }
        const childElmFound = getElementById(childElm, id);
        if (childElmFound != null) {
            return childElmFound;
        }
    }
    return null;
}
function getElementsByName(elm, elmName, foundElms = []) {
    const children = elm.children;
    for (let i = 0, ii = children.length; i < ii; i++) {
        const childElm = children[i];
        if (childElm.name && childElm.name.toLowerCase() === elmName) {
            foundElms.push(childElm);
        }
        getElementsByName(childElm, elmName, foundElms);
    }
    return foundElms;
}
function setOwnerDocument(elm, ownerDocument) {
    for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
        elm.childNodes[i].ownerDocument = ownerDocument;
        if (elm.childNodes[i].nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
            setOwnerDocument(elm.childNodes[i], ownerDocument);
        }
    }
}

function hydrateFactory($stencilWindow, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve) {
  var globalThis = $stencilWindow;
  var self = $stencilWindow;
  var top = $stencilWindow;
  var parent = $stencilWindow;

  var addEventListener = $stencilWindow.addEventListener.bind($stencilWindow);
  var alert = $stencilWindow.alert.bind($stencilWindow);
  var blur = $stencilWindow.blur.bind($stencilWindow);
  var cancelAnimationFrame = $stencilWindow.cancelAnimationFrame.bind($stencilWindow);
  var cancelIdleCallback = $stencilWindow.cancelIdleCallback.bind($stencilWindow);
  var clearInterval = $stencilWindow.clearInterval.bind($stencilWindow);
  var clearTimeout = $stencilWindow.clearTimeout.bind($stencilWindow);
  var close = () => {};
  var confirm = $stencilWindow.confirm.bind($stencilWindow);
  var dispatchEvent = $stencilWindow.dispatchEvent.bind($stencilWindow);
  var focus = $stencilWindow.focus.bind($stencilWindow);
  var getComputedStyle = $stencilWindow.getComputedStyle.bind($stencilWindow);
  var matchMedia = $stencilWindow.matchMedia.bind($stencilWindow);
  var open = $stencilWindow.open.bind($stencilWindow);
  var prompt = $stencilWindow.prompt.bind($stencilWindow);
  var removeEventListener = $stencilWindow.removeEventListener.bind($stencilWindow);
  var requestAnimationFrame = $stencilWindow.requestAnimationFrame.bind($stencilWindow);
  var requestIdleCallback = $stencilWindow.requestIdleCallback.bind($stencilWindow);
  var setInterval = $stencilWindow.setInterval.bind($stencilWindow);
  var setTimeout = $stencilWindow.setTimeout.bind($stencilWindow);

  var CharacterData = $stencilWindow.CharacterData;
  var CSS = $stencilWindow.CSS;
  var CustomEvent = $stencilWindow.CustomEvent;
  var Document = $stencilWindow.Document;
  var DocumentFragment = $stencilWindow.DocumentFragment;
  var DocumentType = $stencilWindow.DocumentType;
  var DOMTokenList = $stencilWindow.DOMTokenList;
  var Element = $stencilWindow.Element;
  var Event = $stencilWindow.Event;
  var HTMLAnchorElement = $stencilWindow.HTMLAnchorElement;
  var HTMLBaseElement = $stencilWindow.HTMLBaseElement;
  var HTMLButtonElement = $stencilWindow.HTMLButtonElement;
  var HTMLCanvasElement = $stencilWindow.HTMLCanvasElement;
  var HTMLElement = $stencilWindow.HTMLElement;
  var HTMLFormElement = $stencilWindow.HTMLFormElement;
  var HTMLImageElement = $stencilWindow.HTMLImageElement;
  var HTMLInputElement = $stencilWindow.HTMLInputElement;
  var HTMLLinkElement = $stencilWindow.HTMLLinkElement;
  var HTMLMetaElement = $stencilWindow.HTMLMetaElement;
  var HTMLScriptElement = $stencilWindow.HTMLScriptElement;
  var HTMLStyleElement = $stencilWindow.HTMLStyleElement;
  var HTMLTemplateElement = $stencilWindow.HTMLTemplateElement;
  var HTMLTitleElement = $stencilWindow.HTMLTitleElement;
  var IntersectionObserver = $stencilWindow.IntersectionObserver;
  var KeyboardEvent = $stencilWindow.KeyboardEvent;
  var MouseEvent = $stencilWindow.MouseEvent;
  var Node = $stencilWindow.Node;
  var NodeList = $stencilWindow.NodeList;
  var URL = $stencilWindow.URL;

  var console = $stencilWindow.console;
  var customElements = $stencilWindow.customElements;
  var history = $stencilWindow.history;
  var localStorage = $stencilWindow.localStorage;
  var location = $stencilWindow.location;
  var navigator = $stencilWindow.navigator;
  var performance = $stencilWindow.performance;
  var sessionStorage = $stencilWindow.sessionStorage;

  var devicePixelRatio = $stencilWindow.devicePixelRatio;
  var innerHeight = $stencilWindow.innerHeight;
  var innerWidth = $stencilWindow.innerWidth;
  var origin = $stencilWindow.origin;
  var pageXOffset = $stencilWindow.pageXOffset;
  var pageYOffset = $stencilWindow.pageYOffset;
  var screen = $stencilWindow.screen;
  var screenLeft = $stencilWindow.screenLeft;
  var screenTop = $stencilWindow.screenTop;
  var screenX = $stencilWindow.screenX;
  var screenY = $stencilWindow.screenY;
  var scrollX = $stencilWindow.scrollX;
  var scrollY = $stencilWindow.scrollY;
  var exports = {};

  var fetch, FetchError, Headers, Request, Response;

  if (typeof $stencilWindow.fetch === 'function') {
    fetch = $stencilWindow.fetch;
  } else {
    fetch = $stencilWindow.fetch = function() { throw new Error('fetch() is not implemented'); };
  }

  if (typeof $stencilWindow.FetchError === 'function') {
    FetchError = $stencilWindow.FetchError;
  } else {
    FetchError = $stencilWindow.FetchError = class FetchError { constructor() { throw new Error('FetchError is not implemented'); } };
  }

  if (typeof $stencilWindow.Headers === 'function') {
    Headers = $stencilWindow.Headers;
  } else {
    Headers = $stencilWindow.Headers = class Headers { constructor() { throw new Error('Headers is not implemented'); } };
  }

  if (typeof $stencilWindow.Request === 'function') {
    Request = $stencilWindow.Request;
  } else {
    Request = $stencilWindow.Request = class Request { constructor() { throw new Error('Request is not implemented'); } };
  }

  if (typeof $stencilWindow.Response === 'function') {
    Response = $stencilWindow.Response;
  } else {
    Response = $stencilWindow.Response = class Response { constructor() { throw new Error('Response is not implemented'); } };
  }

  function hydrateAppClosure($stencilWindow) {
    const window = $stencilWindow;
    const document = $stencilWindow.document;
    /*hydrateAppClosure start*/


const NAMESPACE = 'calcite';
const BUILD = /* calcite */ { allRenderFn: true, appendChildSlotFix: false, asyncLoading: true, attachStyles: true, cloneNodeFix: false, cmpDidLoad: true, cmpDidRender: true, cmpDidUnload: false, cmpDidUpdate: true, cmpShouldUpdate: true, cmpWillLoad: true, cmpWillRender: true, cmpWillUpdate: false, connectedCallback: true, constructableCSS: false, cssAnnotations: true, devTools: false, disconnectedCallback: true, element: false, event: true, experimentalSlotFixes: false, formAssociated: false, hasRenderFn: true, hostListener: true, hostListenerTarget: true, hostListenerTargetBody: true, hostListenerTargetDocument: true, hostListenerTargetParent: false, hostListenerTargetWindow: true, hotModuleReplacement: false, hydrateClientSide: true, hydrateServerSide: true, hydratedAttribute: false, hydratedClass: true, isDebug: false, isDev: false, isTesting: false, lazyLoad: true, lifecycle: true, lifecycleDOMEvents: false, member: true, method: true, mode: false, observeAttribute: true, profile: false, prop: true, propBoolean: true, propMutable: true, propNumber: true, propString: true, reflect: true, scoped: false, scriptDataOpts: false, shadowDelegatesFocus: true, shadowDom: true, shadowDomShim: true, slot: true, slotChildNodesFix: false, slotRelocation: true, state: true, style: true, svg: true, taskQueue: true, updatable: true, vdomAttribute: true, vdomClass: true, vdomFunctional: true, vdomKey: true, vdomListener: true, vdomPropOrAttr: true, vdomRef: true, vdomRender: true, vdomStyle: true, vdomText: true, vdomXlink: true, watchCallback: true };

const autoMode = "calcite-mode-auto";
const darkMode = "calcite-mode-dark";
const lightMode = "calcite-mode-light";
const CSS_UTILITY = {
    autoMode,
    darkMode,
    lightMode,
    rtl: "calcite--rtl",
    calciteAnimate: "calcite-animate",
    calciteAnimateIn: "calcite-animate__in",
    calciteAnimateInUp: "calcite-animate__in-up",
    calciteAnimateInDown: "calcite-animate__in-down",
    calciteAnimateInRight: "calcite-animate__in-right",
    calciteAnimateInLeft: "calcite-animate__in-left",
    calciteAnimateInScale: "calcite-animate__in-scale",
};

/**
 * Emits when the mode is dynamically toggled between light and dark on <body> or in OS preferences.
 */
function initModeChangeEvent() {
    const { classList } = document.body;
    const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
    const getMode = () => classList.contains(darkMode) || (classList.contains(autoMode) && prefersDark) ? "dark" : "light";
    const emitModeChange = (mode) => document.body.dispatchEvent(new CustomEvent("calciteModeChange", { bubbles: true, detail: { mode } }));
    const modeChangeHandler = (newMode) => {
        currentMode !== newMode && emitModeChange(newMode);
        currentMode = newMode;
    };
    let currentMode = getMode();
    // emits event on page load
    emitModeChange(currentMode);
    // emits event when changing OS mode preferences
    window
        .matchMedia("(prefers-color-scheme: dark)")
        .addEventListener("change", (event) => modeChangeHandler(event.matches ? "dark" : "light"));
    // emits event when toggling between mode classes on <body>
    new MutationObserver(() => modeChangeHandler(getMode())).observe(document.body, {
        attributes: true,
        attributeFilter: ["class"],
    });
}

/**
 * This file is imported in Stencil's `globalScript` config option.
 *
 * @see {@link https://stenciljs.com/docs/config#globalscript}
 */
function appGlobalScript () {
    const isBrowser = typeof window !== "undefined" &&
        typeof location !== "undefined" &&
        typeof document !== "undefined" &&
        window.location === location &&
        window.document === document;
    if (isBrowser) {
        if (document.readyState === "interactive") {
            initModeChangeEvent();
        }
        else {
            document.addEventListener("DOMContentLoaded", () => initModeChangeEvent(), { once: true });
        }
    }
}

const globalScripts = appGlobalScript;

function queryNonceMetaTagContent(e) {
 var t, o, n;
 return null !== (n = null === (o = null === (t = e.head) || void 0 === t ? void 0 : t.querySelector('meta[name="csp-nonce"]')) || void 0 === o ? void 0 : o.getAttribute("content")) && void 0 !== n ? n : void 0;
}

function componentOnReady$1() {
 return getHostRef(this).$onReadyPromise$;
}

function forceUpdate() {}

function hydrateApp(e, t, o, n, s) {
 function l() {
  if (global.clearTimeout(p), i.clear(), r.clear(), !h) {
   h = !0;
   try {
    t.clientHydrateAnnotations && insertVdomAnnotations(e.document, t.staticComponents), 
    e.dispatchEvent(new e.Event("DOMContentLoaded")), e.document.createElement = c, 
    e.document.createElementNS = $;
   } catch (e) {
    renderCatchError(t, o, e);
   }
  }
  n(e, t, o, s);
 }
 function a(e) {
  renderCatchError(t, o, e), l();
 }
 const r = new Set, i = new Set, d = new Set, c = e.document.createElement, $ = e.document.createElementNS, m = Promise.resolve();
 let p, h = !1;
 try {
  function f() {
   return L(this);
  }
  function u(e) {
   if (isValidComponent(e, t) && !getHostRef(e)) {
    const t = loadModule({
     $tagName$: e.nodeName.toLowerCase(),
     $flags$: null
    });
    null != t && null != t.cmpMeta && (i.add(e), e.connectedCallback = f, registerHost(e, t.cmpMeta), 
    function o(e, t) {
     if ("function" != typeof e.componentOnReady && (e.componentOnReady = componentOnReady$1), 
     "function" != typeof e.forceUpdate && (e.forceUpdate = forceUpdate), 1 & t.$flags$ && (e.shadowRoot = e), 
     null != t.$members$) {
      const o = getHostRef(e);
      Object.entries(t.$members$).forEach((([n, s]) => {
       const l = s[0];
       if (31 & l) {
        const a = s[1] || n, r = e.getAttribute(a);
        if (null != r) {
         const e = parsePropertyValue(r, l);
         o.$instanceValues$.set(n, e);
        }
        const i = e[n];
        void 0 !== i && (o.$instanceValues$.set(n, i), delete e[n]), Object.defineProperty(e, n, {
         get() {
          return getValue(this, n);
         },
         set(e) {
          setValue(this, n, e, t);
         },
         configurable: !0,
         enumerable: !0
        });
       } else 64 & l && Object.defineProperty(e, n, {
        value(...e) {
         const t = getHostRef(this);
         return t.$onInstancePromise$.then((() => t.$lazyInstance$[n](...e))).catch(consoleError);
        }
       });
      }));
     }
    }(e, t.cmpMeta));
   }
  }
  function g(e) {
   if (null != e && 1 === e.nodeType) {
    u(e);
    const t = e.children;
    for (let e = 0, o = t.length; e < o; e++) g(t[e]);
   }
  }
  function L(n) {
   return i.delete(n), isValidComponent(n, t) && o.hydratedCount < t.maxHydrateCount && !r.has(n) && shouldHydrate(n) ? (r.add(n), 
   async function s(e, t, o, n, l) {
    o = o.toLowerCase();
    const a = loadModule({
     $tagName$: o,
     $flags$: null
    });
    if (null != a && null != a.cmpMeta) {
     l.add(n);
     try {
      connectedCallback(n), await n.componentOnReady(), t.hydratedCount++;
      const e = getHostRef(n), s = e.$modeName$ ? e.$modeName$ : "$";
      t.components.some((e => e.tag === o && e.mode === s)) || t.components.push({
       tag: o,
       mode: s,
       count: 0,
       depth: -1
      });
     } catch (t) {
      e.console.error(t);
     }
     l.delete(n);
    }
   }(e, o, n.nodeName, n, d)) : m;
  }
  function y() {
   const e = Array.from(i).filter((e => e.parentElement));
   return e.length > 0 ? Promise.all(e.map(L)).then(y) : m;
  }
  e.document.createElement = function t(o) {
   const n = c.call(e.document, o);
   return u(n), n;
  }, e.document.createElementNS = function t(o, n) {
   const s = $.call(e.document, o, n);
   return u(s), s;
  }, p = global.setTimeout((function I() {
   a(`Hydrate exceeded timeout${function e(t) {
    return Array.from(t).map(waitingOnElementMsg);
   }(d)}`);
  }), t.timeout), plt.$resourcesUrl$ = new URL(t.resourcesUrl || "./", doc.baseURI).href, 
  globalScripts(), g(e.document.body), y().then(l).catch(a);
 } catch (D) {
  a(D);
 }
}

function isValidComponent(e, t) {
 if (null != e && 1 === e.nodeType) {
  const o = e.nodeName;
  if ("string" == typeof o && o.includes("-")) return !t.excludeComponents.includes(o.toLowerCase());
 }
 return !1;
}

function shouldHydrate(e) {
 if (9 === e.nodeType) return !0;
 if (NO_HYDRATE_TAGS.has(e.nodeName)) return !1;
 if (e.hasAttribute("no-prerender")) return !1;
 const t = e.parentNode;
 return null == t || shouldHydrate(t);
}

function renderCatchError(e, t, o) {
 const n = {
  level: "error",
  type: "build",
  header: "Hydrate Error",
  messageText: "",
  relFilePath: void 0,
  absFilePath: void 0,
  lines: []
 };
 if (e.url) try {
  const t = new URL(e.url);
  "/" !== t.pathname && (n.header += ": " + t.pathname);
 } catch (e) {}
 null != o && (null != o.stack ? n.messageText = o.stack.toString() : null != o.message ? n.messageText = o.message.toString() : n.messageText = o.toString()), 
 t.diagnostics.push(n);
}

function printTag(e) {
 let t = `<${e.nodeName.toLowerCase()}`;
 if (Array.isArray(e.attributes)) for (let o = 0; o < e.attributes.length; o++) {
  const n = e.attributes[o];
  t += ` ${n.name}`, "" !== n.value && (t += `="${n.value}"`);
 }
 return t += ">", t;
}

function waitingOnElementMsg(e) {
 let t = "";
 if (e) {
  const o = [];
  t = " - waiting on:";
  let n = e;
  for (;n && 9 !== n.nodeType && "BODY" !== n.nodeName; ) o.unshift(printTag(n)), 
  n = n.parentElement;
  let s = "";
  for (const e of o) s += "  ", t += `\n${s}${e}`;
 }
 return t;
}

const createTime = (e, t = "") => {
 return () => {};
}, SLOT_FB_CSS = "slot-fb{display:contents}slot-fb[hidden]{display:none}", XLINK_NS = "http://www.w3.org/1999/xlink", EMPTY_OBJ = {}, isComplexType = e => "object" == (e = typeof e) || "function" === e, isPromise = e => !!e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then, h = (e, t, ...o) => {
 let n = null, s = null, l = null, a = !1, r = !1;
 const i = [], d = t => {
  for (let o = 0; o < t.length; o++) n = t[o], Array.isArray(n) ? d(n) : null != n && "boolean" != typeof n && ((a = "function" != typeof e && !isComplexType(n)) ? n = String(n) : BUILD.isDev  , 
  a && r ? i[i.length - 1].$text$ += n : i.push(a ? newVNode(null, n) : n), r = a);
 };
 if (d(o), t && (t.key && (s = t.key), 
 t.name && (l = t.name), BUILD.vdomClass)) {
  const e = t.className || t.class;
  e && (t.class = "object" != typeof e ? e : Object.keys(e).filter((t => e[t])).join(" "));
 }
 if ("function" == typeof e) return e(null === t ? {} : t, i, vdomFnUtils);
 const c = newVNode(e, null);
 return c.$attrs$ = t, i.length > 0 && (c.$children$ = i), (c.$key$ = s), 
 (c.$name$ = l), c;
}, newVNode = (e, t) => {
 const o = {
  $flags$: 0,
  $tag$: e,
  $text$: t,
  $elm$: null,
  $children$: null
 };
 return (o.$attrs$ = null), (o.$key$ = null), 
 (o.$name$ = null), o;
}, Host = {}, isHost = e => e && e.$tag$ === Host, vdomFnUtils = {
 forEach: (e, t) => e.map(convertToPublic).forEach(t),
 map: (e, t) => e.map(convertToPublic).map(t).map(convertToPrivate)
}, convertToPublic = e => ({
 vattrs: e.$attrs$,
 vchildren: e.$children$,
 vkey: e.$key$,
 vname: e.$name$,
 vtag: e.$tag$,
 vtext: e.$text$
}), convertToPrivate = e => {
 if ("function" == typeof e.vtag) {
  const t = {
   ...e.vattrs
  };
  return e.vkey && (t.key = e.vkey), e.vname && (t.name = e.vname), h(e.vtag, t, ...e.vchildren || []);
 }
 const t = newVNode(e.vtag, e.vtext);
 return t.$attrs$ = e.vattrs, t.$children$ = e.vchildren, t.$key$ = e.vkey, t.$name$ = e.vname, 
 t;
}, clientHydrate = (e, t, o, n, s, l, a) => {
 let r, i, d, c;
 if (1 === l.nodeType) {
  for (r = l.getAttribute("c-id"), r && (i = r.split("."), i[0] !== a && "0" !== i[0] || (d = {
   $flags$: 0,
   $hostId$: i[0],
   $nodeId$: i[1],
   $depth$: i[2],
   $index$: i[3],
   $tag$: l.tagName.toLowerCase(),
   $elm$: l,
   $attrs$: null,
   $children$: null,
   $key$: null,
   $name$: null,
   $text$: null
  }, t.push(d), l.removeAttribute("c-id"), e.$children$ || (e.$children$ = []), e.$children$[d.$index$] = d, 
  e = d, n && "0" === d.$depth$ && (n[d.$index$] = d.$elm$))), c = l.childNodes.length - 1; c >= 0; c--) clientHydrate(e, t, o, n, s, l.childNodes[c], a);
  if (l.shadowRoot) for (c = l.shadowRoot.childNodes.length - 1; c >= 0; c--) clientHydrate(e, t, o, n, s, l.shadowRoot.childNodes[c], a);
 } else if (8 === l.nodeType) i = l.nodeValue.split("."), i[1] !== a && "0" !== i[1] || (r = i[0], 
 d = {
  $flags$: 0,
  $hostId$: i[1],
  $nodeId$: i[2],
  $depth$: i[3],
  $index$: i[4],
  $elm$: l,
  $attrs$: null,
  $children$: null,
  $key$: null,
  $name$: null,
  $tag$: null,
  $text$: null
 }, "t" === r ? (d.$elm$ = l.nextSibling, d.$elm$ && 3 === d.$elm$.nodeType && (d.$text$ = d.$elm$.textContent, 
 t.push(d), l.remove(), e.$children$ || (e.$children$ = []), e.$children$[d.$index$] = d, 
 n && "0" === d.$depth$ && (n[d.$index$] = d.$elm$))) : d.$hostId$ === a && ("s" === r ? (d.$tag$ = "slot", 
 i[5] ? l["s-sn"] = d.$name$ = i[5] : l["s-sn"] = "", l["s-sr"] = !0, n && (d.$elm$ = doc.createElement(d.$tag$), 
 d.$name$ && d.$elm$.setAttribute("name", d.$name$), l.parentNode.insertBefore(d.$elm$, l), 
 l.remove(), "0" === d.$depth$ && (n[d.$index$] = d.$elm$)), o.push(d), e.$children$ || (e.$children$ = []), 
 e.$children$[d.$index$] = d) : "r" === r && (n ? l.remove() : (s["s-cr"] = l, 
 l["s-cn"] = !0)))); else if (e && "style" === e.$tag$) {
  const t = newVNode(null, l.textContent);
  t.$elm$ = l, t.$index$ = "0", e.$children$ = [ t ];
 }
}, initializeDocumentHydrate = (e, t) => {
 if (1 === e.nodeType) {
  let o = 0;
  for (;o < e.childNodes.length; o++) initializeDocumentHydrate(e.childNodes[o], t);
  if (e.shadowRoot) for (o = 0; o < e.shadowRoot.childNodes.length; o++) initializeDocumentHydrate(e.shadowRoot.childNodes[o], t);
 } else if (8 === e.nodeType) {
  const o = e.nodeValue.split(".");
  "o" === o[0] && (t.set(o[1] + "." + o[2], e), e.nodeValue = "", e["s-en"] = o[3]);
 }
}, parsePropertyValue = (e, t) => null == e || isComplexType(e) ? e : 4 & t ? "false" !== e && ("" === e || !!e) : 2 & t ? parseFloat(e) : 1 & t ? String(e) : e, getElement = e => getHostRef(e).$hostElement$ , createEvent = (e, t, o) => {
 const n = getElement(e);
 return {
  emit: e => (emitEvent(n, t, {
   bubbles: !!(4 & o),
   composed: !!(2 & o),
   cancelable: !!(1 & o),
   detail: e
  }))
 };
}, emitEvent = (e, t, o) => {
 const n = plt.ce(t, o);
 return e.dispatchEvent(n), n;
}, rootAppliedStyles = new WeakMap, registerStyle = (e, t, o) => {
 let n = styles.get(e);
 n = t, styles.set(e, n);
}, addStyle = (e, t, o) => {
 var n;
 const s = getScopeId(t), l = styles.get(s);
 if (e = 11 === e.nodeType ? e : doc, l) if ("string" == typeof l) {
  e = e.head || e;
  let o, a = rootAppliedStyles.get(e);
  if (a || rootAppliedStyles.set(e, a = new Set), !a.has(s)) {
   if (e.host && (o = e.querySelector(`[sty-id="${s}"]`))) o.innerHTML = l; else {
    o = doc.createElement("style"), o.innerHTML = l;
    const t = null !== (n = plt.$nonce$) && void 0 !== n ? n : queryNonceMetaTagContent(doc);
    null != t && o.setAttribute("nonce", t), o.setAttribute("sty-id", s), 
    e.insertBefore(o, e.querySelector("link"));
   }
   4 & t.$flags$ && (o.innerHTML += SLOT_FB_CSS), a && a.add(s);
  }
 }
 return s;
}, attachStyles = e => {
 const t = e.$cmpMeta$, o = e.$hostElement$, n = t.$flags$, s = createTime("attachStyles", t.$tagName$), l = addStyle(o.getRootNode(), t);
 10 & n && (o["s-sc"] = l, 
 o.classList.add(l + "-h"), BUILD.scoped  ), 
 s();
}, getScopeId = (e, t) => "sc-" + (e.$tagName$), setAccessor = (e, t, o, n, s, l) => {
 if (o !== n) {
  let a = isMemberInElement(e, t), r = t.toLowerCase();
  if ("class" === t) {
   const t = e.classList, s = parseClassList(o), l = parseClassList(n);
   t.remove(...s.filter((e => e && !l.includes(e)))), t.add(...l.filter((e => e && !s.includes(e))));
  } else if ("style" === t) {
   for (const t in o) n && null != n[t] || (e.style[t] = "");
   for (const t in n) o && n[t] === o[t] || (e.style[t] = n[t]);
  } else if ("key" === t) ; else if ("ref" === t) n && n(e); else if ((a ) || "o" !== t[0] || "n" !== t[1]) {
   {
    const i = isComplexType(n);
    if ((a || i && null !== n) && !s) try {
     if (e.tagName.includes("-")) e[t] = n; else {
      const s = null == n ? "" : n;
      "list" === t ? a = !1 : null != o && e[t] == s || (e[t] = s);
     }
    } catch (e) {}
    let d = !1;
    r !== (r = r.replace(/^xlink\:?/, "")) && (t = r, d = !0), null == n || !1 === n ? !1 === n && "" !== e.getAttribute(t) || (d ? e.removeAttributeNS(XLINK_NS, t) : e.removeAttribute(t)) : (!a || 4 & l || s) && !i && (n = !0 === n ? "" : n, 
    d ? e.setAttributeNS(XLINK_NS, t, n) : e.setAttribute(t, n));
   }
  } else if (t = "-" === t[2] ? t.slice(3) : isMemberInElement(win, r) ? r.slice(2) : r[2] + t.slice(3), 
  o || n) {
   const s = t.endsWith(CAPTURE_EVENT_SUFFIX);
   t = t.replace(CAPTURE_EVENT_REGEX, ""), o && plt.rel(e, t, o, s), n && plt.ael(e, t, n, s);
  }
 }
}, parseClassListRegex = /\s/, parseClassList = e => e ? e.split(parseClassListRegex) : [], CAPTURE_EVENT_SUFFIX = "Capture", CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + "$"), updateElement = (e, t, o, n) => {
 const s = 11 === t.$elm$.nodeType && t.$elm$.host ? t.$elm$.host : t.$elm$, l = e && e.$attrs$ || EMPTY_OBJ, a = t.$attrs$ || EMPTY_OBJ;
 for (n in l) n in a || setAccessor(s, n, l[n], void 0, o, t.$flags$);
 for (n in a) setAccessor(s, n, l[n], a[n], o, t.$flags$);
};

let scopeId, contentRef, hostTagName, useNativeShadowDom = !1, checkSlotFallbackVisibility = !1, checkSlotRelocate = !1, isSvgMode = !1;

const createElm = (e, t, o, n) => {
 var s;
 const l = t.$children$[o];
 let a, r, i, d = 0;
 if (!useNativeShadowDom && (checkSlotRelocate = !0, "slot" === l.$tag$ && (scopeId && n.classList.add(scopeId + "-s"), 
 l.$flags$ |= l.$children$ ? 2 : 1)), null !== l.$text$) a = l.$elm$ = doc.createTextNode(l.$text$); else if (1 & l.$flags$) a = l.$elm$ = slotReferenceDebugNode(l) ; else {
  if (!isSvgMode && (isSvgMode = "svg" === l.$tag$), a = l.$elm$ = doc.createElementNS(isSvgMode ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", 2 & l.$flags$ ? "slot-fb" : l.$tag$) , 
  isSvgMode && "foreignObject" === l.$tag$ && (isSvgMode = !1), updateElement(null, l, isSvgMode), 
  null != scopeId && a["s-si"] !== scopeId && a.classList.add(a["s-si"] = scopeId), 
  l.$children$) for (d = 0; d < l.$children$.length; ++d) r = createElm(e, l, d, a), 
  r && a.appendChild(r);
  ("svg" === l.$tag$ ? isSvgMode = !1 : "foreignObject" === a.tagName && (isSvgMode = !0));
 }
 return a["s-hn"] = hostTagName, 3 & l.$flags$ && (a["s-sr"] = !0, 
 a["s-fs"] = null === (s = l.$attrs$) || void 0 === s ? void 0 : s.slot, a["s-cr"] = contentRef, 
 a["s-sn"] = l.$name$ || "", i = e && e.$children$ && e.$children$[o], i && i.$tag$ === l.$tag$ && e.$elm$ && (putBackInOriginalLocation(e.$elm$, !1))), 
 a;
}, putBackInOriginalLocation = (e, t) => {
 var o;
 plt.$flags$ |= 1;
 const n = e.childNodes;
 for (let e = n.length - 1; e >= 0; e--) {
  const s = n[e];
  s["s-hn"] !== hostTagName && s["s-ol"] && (parentReferenceNode(s).insertBefore(s, referenceNode(s)), 
  s["s-ol"].remove(), s["s-ol"] = void 0, s["s-sh"] = void 0, 1 === s.nodeType && s.setAttribute("slot", null !== (o = s["s-sn"]) && void 0 !== o ? o : ""), 
  checkSlotRelocate = !0), t && putBackInOriginalLocation(s, t);
 }
 plt.$flags$ &= -2;
}, addVnodes = (e, t, o, n, s, l) => {
 let a, r = e["s-cr"] && e["s-cr"].parentNode || e;
 for (r.shadowRoot && r.tagName === hostTagName && (r = r.shadowRoot); s <= l; ++s) n[s] && (a = createElm(null, o, s, e), 
 a && (n[s].$elm$ = a, r.insertBefore(a, referenceNode(t) )));
}, removeVnodes = (e, t, o) => {
 for (let n = t; n <= o; ++n) {
  const t = e[n];
  if (t) {
   const e = t.$elm$;
   nullifyVNodeRefs(t), e && ((checkSlotFallbackVisibility = !0, 
   e["s-ol"] ? e["s-ol"].remove() : putBackInOriginalLocation(e, !0)), e.remove());
  }
 }
}, isSameVnode = (e, t, o = !1) => e.$tag$ === t.$tag$ && ("slot" === e.$tag$ ? e.$name$ === t.$name$ : !(!o) || e.$key$ === t.$key$), referenceNode = e => e && e["s-ol"] || e, parentReferenceNode = e => (e["s-ol"] ? e["s-ol"] : e).parentNode, patch = (e, t, o = !1) => {
 const n = t.$elm$ = e.$elm$, s = e.$children$, l = t.$children$, a = t.$tag$, r = t.$text$;
 let i;
 null !== r ? (i = n["s-cr"]) ? i.parentNode.textContent = r : e.$text$ !== r && (n.data = r) : ((isSvgMode = "svg" === a || "foreignObject" !== a && isSvgMode), 
 ("slot" === a || updateElement(e, t, isSvgMode)), 
 null !== s && null !== l ? ((e, t, o, n, s = !1) => {
  let l, a, r = 0, i = 0, d = 0, c = 0, $ = t.length - 1, m = t[0], p = t[$], h = n.length - 1, f = n[0], u = n[h];
  for (;r <= $ && i <= h; ) if (null == m) m = t[++r]; else if (null == p) p = t[--$]; else if (null == f) f = n[++i]; else if (null == u) u = n[--h]; else if (isSameVnode(m, f, s)) patch(m, f, s), 
  m = t[++r], f = n[++i]; else if (isSameVnode(p, u, s)) patch(p, u, s), p = t[--$], 
  u = n[--h]; else if (isSameVnode(m, u, s)) "slot" !== m.$tag$ && "slot" !== u.$tag$ || putBackInOriginalLocation(m.$elm$.parentNode, !1), 
  patch(m, u, s), e.insertBefore(m.$elm$, p.$elm$.nextSibling), m = t[++r], u = n[--h]; else if (isSameVnode(p, f, s)) "slot" !== m.$tag$ && "slot" !== u.$tag$ || putBackInOriginalLocation(p.$elm$.parentNode, !1), 
  patch(p, f, s), e.insertBefore(p.$elm$, m.$elm$), p = t[--$], f = n[++i]; else {
   if (d = -1, BUILD.vdomKey) for (c = r; c <= $; ++c) if (t[c] && null !== t[c].$key$ && t[c].$key$ === f.$key$) {
    d = c;
    break;
   }
   d >= 0 ? (a = t[d], a.$tag$ !== f.$tag$ ? l = createElm(t && t[i], o, d, e) : (patch(a, f, s), 
   t[d] = void 0, l = a.$elm$), f = n[++i]) : (l = createElm(t && t[i], o, i, e), f = n[++i]), 
   l && (parentReferenceNode(m.$elm$).insertBefore(l, referenceNode(m.$elm$)) );
  }
  r > $ ? addVnodes(e, null == n[h + 1] ? null : n[h + 1].$elm$, o, n, i, h) : i > h && removeVnodes(t, r, $);
 })(n, s, t, l, o) : null !== l ? (null !== e.$text$ && (n.textContent = ""), 
 addVnodes(n, null, t, l, 0, l.length - 1)) : null !== s && removeVnodes(s, 0, s.length - 1), 
 isSvgMode && "svg" === a && (isSvgMode = !1));
}, updateFallbackSlotVisibility = e => {
 const t = e.childNodes;
 for (const e of t) if (1 === e.nodeType) {
  if (e["s-sr"]) {
   const o = e["s-sn"];
   e.hidden = !1;
   for (const n of t) if (n !== e) if (n["s-hn"] !== e["s-hn"] || "" !== o) {
    if (1 === n.nodeType && (o === n.getAttribute("slot") || o === n["s-sn"])) {
     e.hidden = !0;
     break;
    }
   } else if (1 === n.nodeType || 3 === n.nodeType && "" !== n.textContent.trim()) {
    e.hidden = !0;
    break;
   }
  }
  updateFallbackSlotVisibility(e);
 }
}, relocateNodes = [], markSlotContentForRelocation = e => {
 let t, o, n;
 for (const s of e.childNodes) {
  if (s["s-sr"] && (t = s["s-cr"]) && t.parentNode) {
   o = t.parentNode.childNodes;
   const e = s["s-sn"];
   for (n = o.length - 1; n >= 0; n--) if (t = o[n], !(t["s-cn"] || t["s-nr"] || t["s-hn"] === s["s-hn"] || BUILD.experimentalSlotFixes  )) if (isNodeLocatedInSlot(t, e)) {
    let o = relocateNodes.find((e => e.$nodeToRelocate$ === t));
    checkSlotFallbackVisibility = !0, t["s-sn"] = t["s-sn"] || e, o ? (o.$nodeToRelocate$["s-sh"] = s["s-hn"], 
    o.$slotRefNode$ = s) : (t["s-sh"] = s["s-hn"], relocateNodes.push({
     $slotRefNode$: s,
     $nodeToRelocate$: t
    })), t["s-sr"] && relocateNodes.map((e => {
     isNodeLocatedInSlot(e.$nodeToRelocate$, t["s-sn"]) && (o = relocateNodes.find((e => e.$nodeToRelocate$ === t)), 
     o && !e.$slotRefNode$ && (e.$slotRefNode$ = o.$slotRefNode$));
    }));
   } else relocateNodes.some((e => e.$nodeToRelocate$ === t)) || relocateNodes.push({
    $nodeToRelocate$: t
   });
  }
  1 === s.nodeType && markSlotContentForRelocation(s);
 }
}, isNodeLocatedInSlot = (e, t) => 1 === e.nodeType ? null === e.getAttribute("slot") && "" === t || e.getAttribute("slot") === t : e["s-sn"] === t || "" === t, nullifyVNodeRefs = e => {
 (e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(nullifyVNodeRefs));
}, renderVdom = (e, t, o = !1) => {
 var n, s, l, a;
 const i = e.$hostElement$, d = e.$cmpMeta$, c = e.$vnode$ || newVNode(null, null), $ = isHost(t) ? t : h(null, null, t);
 if (hostTagName = i.tagName, BUILD.isDev  ) ;
 if (d.$attrsToReflect$ && ($.$attrs$ = $.$attrs$ || {}, d.$attrsToReflect$.map((([e, t]) => $.$attrs$[t] = i[e]))), 
 o && $.$attrs$) for (const e of Object.keys($.$attrs$)) i.hasAttribute(e) && ![ "key", "ref", "style", "class" ].includes(e) && ($.$attrs$[e] = i[e]);
 if ($.$tag$ = null, $.$flags$ |= 4, e.$vnode$ = $, $.$elm$ = c.$elm$ = i.shadowRoot || i, 
 (scopeId = i["s-sc"]), (contentRef = i["s-cr"], 
 useNativeShadowDom = supportsShadow, checkSlotFallbackVisibility = !1), patch(c, $, o), 
 BUILD.slotRelocation) {
  if (plt.$flags$ |= 1, checkSlotRelocate) {
   markSlotContentForRelocation($.$elm$);
   for (const e of relocateNodes) {
    const t = e.$nodeToRelocate$;
    if (!t["s-ol"]) {
     const e = originalLocationDebugNode(t) ;
     e["s-nr"] = t, t.parentNode.insertBefore(t["s-ol"] = e, t);
    }
   }
   for (const e of relocateNodes) {
    const t = e.$nodeToRelocate$, r = e.$slotRefNode$;
    if (r) {
     const e = r.parentNode;
     let o = r.nextSibling;
     {
      let l = null === (n = t["s-ol"]) || void 0 === n ? void 0 : n.previousSibling;
      for (;l; ) {
       let n = null !== (s = l["s-nr"]) && void 0 !== s ? s : null;
       if (n && n["s-sn"] === t["s-sn"] && e === n.parentNode && (n = n.nextSibling, !n || !n["s-nr"])) {
        o = n;
        break;
       }
       l = l.previousSibling;
      }
     }
     (!o && e !== t.parentNode || t.nextSibling !== o) && t !== o && (t["s-hn"] || !t["s-ol"] || (t["s-hn"] = t["s-ol"].parentNode.nodeName), 
     e.insertBefore(t, o), 1 === t.nodeType && (t.hidden = null !== (l = t["s-ih"]) && void 0 !== l && l));
    } else 1 === t.nodeType && (o && (t["s-ih"] = null !== (a = t.hidden) && void 0 !== a && a), 
    t.hidden = !0);
   }
  }
  checkSlotFallbackVisibility && updateFallbackSlotVisibility($.$elm$), plt.$flags$ &= -2, 
  relocateNodes.length = 0;
 }
}, slotReferenceDebugNode = e => doc.createComment(`<slot${e.$name$ ? ' name="' + e.$name$ + '"' : ""}> (host=${hostTagName.toLowerCase()})`), originalLocationDebugNode = e => doc.createComment("org-location for " + (e.localName ? `<${e.localName}> (host=${e["s-hn"]})` : `[${e.textContent}]`)), attachToAncestor = (e, t) => {
 t && !e.$onRenderResolve$ && t["s-p"] && t["s-p"].push(new Promise((t => e.$onRenderResolve$ = t)));
}, scheduleUpdate = (e, t) => {
 if ((e.$flags$ |= 16), 4 & e.$flags$) return void (e.$flags$ |= 512);
 attachToAncestor(e, e.$ancestorComponent$);
 const o = () => dispatchHooks(e, t);
 return writeTask(o) ;
}, dispatchHooks = (e, t) => {
 const n = createTime("scheduleUpdate", e.$cmpMeta$.$tagName$), s = e.$lazyInstance$ ;
 let l;
 return t ? ((e.$flags$ |= 256, e.$queuedListeners$ && (e.$queuedListeners$.map((([e, t]) => safeCall(s, e, t))), 
 e.$queuedListeners$ = void 0)), (l = safeCall(s, "componentWillLoad"))) : (BUILD.cmpWillUpdate ), (l = enqueue(l, (() => safeCall(s, "componentWillRender")))), 
 n(), enqueue(l, (() => updateComponent(e, s, t)));
}, enqueue = (e, t) => isPromisey(e) ? e.then(t) : t(), isPromisey = e => e instanceof Promise || e && e.then && "function" == typeof e.then, updateComponent = async (e, t, o) => {
 var n;
 const s = e.$hostElement$, l = createTime("update", e.$cmpMeta$.$tagName$), a = s["s-rc"];
 o && attachStyles(e);
 const r = createTime("render", e.$cmpMeta$.$tagName$);
 if (await callRender(e, t, s, o) , 
 BUILD.hydrateServerSide) try {
  serverSideConnected(s), o && (1 & e.$cmpMeta$.$flags$ ? s["s-en"] = "" : 2 & e.$cmpMeta$.$flags$ && (s["s-en"] = "c"));
 } catch (e) {
  consoleError(e, s);
 }
 if (a && (a.map((e => e())), s["s-rc"] = void 0), r(), l(), 
 BUILD.asyncLoading) {
  const t = null !== (n = s["s-p"]) && void 0 !== n ? n : [], o = () => postUpdateComponent(e);
  0 === t.length ? o() : (Promise.all(t).then(o), e.$flags$ |= 4, t.length = 0);
 }
};

const callRender = (e, t, o, n) => {
 try {
  if (t = t.render(), (e.$flags$ &= -17), 
  (e.$flags$ |= 2), BUILD.hasRenderFn ) {
   return Promise.resolve(t).then((t => renderVdom(e, t, n)));
  }
 } catch (t) {
  consoleError(t, e.$hostElement$);
 }
 return null;
}, postUpdateComponent = e => {
 const t = e.$cmpMeta$.$tagName$, o = e.$hostElement$, n = createTime("postUpdate", t), s = e.$lazyInstance$ , l = e.$ancestorComponent$;
 (safeCall(s, "componentDidRender"), 
 BUILD.isDev ), 64 & e.$flags$ ? ((safeCall(s, "componentDidUpdate"), 
 BUILD.isDev ), n()) : (e.$flags$ |= 64, addHydratedFlag(o), 
 (safeCall(s, "componentDidLoad"), 
 BUILD.isDev ), n(), (e.$onReadyResolve$(o), l || appDidLoad())), e.$onInstanceResolve$(o), 
 (e.$onRenderResolve$ && (e.$onRenderResolve$(), e.$onRenderResolve$ = void 0), 
 512 & e.$flags$ && nextTick((() => scheduleUpdate(e, !1))), e.$flags$ &= -517);
}, appDidLoad = e => {
 addHydratedFlag(doc.documentElement), nextTick((() => emitEvent(win, "appload", {
  detail: {
   namespace: NAMESPACE
  }
 }))), BUILD.profile  ;
}, safeCall = (e, t, o) => {
 if (e && e[t]) try {
  return e[t](o);
 } catch (e) {
  consoleError(e);
 }
}, addHydratedFlag = e => e.classList.add("calcite-hydrated") , serverSideConnected = e => {
 const t = e.children;
 if (null != t) for (let e = 0, o = t.length; e < o; e++) {
  const o = t[e];
  "function" == typeof o.connectedCallback && o.connectedCallback(), serverSideConnected(o);
 }
}, getValue = (e, t) => getHostRef(e).$instanceValues$.get(t), setValue = (e, t, o, n) => {
 const s = getHostRef(e), l = s.$hostElement$ , a = s.$instanceValues$.get(t), r = s.$flags$, i = s.$lazyInstance$ ;
 o = parsePropertyValue(o, n.$members$[t][0]);
 const d = Number.isNaN(a) && Number.isNaN(o), c = o !== a && !d;
 if ((!(8 & r) || void 0 === a) && c && (s.$instanceValues$.set(t, o), 
 i)) {
  if (n.$watchers$ && 128 & r) {
   const e = n.$watchers$[t];
   e && e.map((e => {
    try {
     i[e](o, a, t);
    } catch (e) {
     consoleError(e, l);
    }
   }));
  }
  if (2 == (18 & r)) {
   if (i.componentShouldUpdate && !1 === i.componentShouldUpdate(o, a, t)) return;
   scheduleUpdate(s, !1);
  }
 }
}, proxyComponent = (e, t, o) => {
 var n;
 const s = e.prototype;
 if (t.$members$) {
  e.watchers && (t.$watchers$ = e.watchers);
  const l = Object.entries(t.$members$);
  if (l.map((([e, [n]]) => {
   (31 & n || (2 & o) && 32 & n) ? Object.defineProperty(s, e, {
    get() {
     return getValue(this, e);
    },
    set(s) {
     setValue(this, e, s, t);
    },
    configurable: !0,
    enumerable: !0
   }) : 1 & o && 64 & n && Object.defineProperty(s, e, {
    value(...t) {
     var o;
     const n = getHostRef(this);
     return null === (o = null == n ? void 0 : n.$onInstancePromise$) || void 0 === o ? void 0 : o.then((() => {
      var o;
      return null === (o = n.$lazyInstance$) || void 0 === o ? void 0 : o[e](...t);
     }));
    }
   });
  })), (1 & o)) {
   const o = new Map;
   s.attributeChangedCallback = function(e, n, l) {
    plt.jmp((() => {
     var a;
     const r = o.get(e);
     if (this.hasOwnProperty(r)) l = this[r], delete this[r]; else {
      if (s.hasOwnProperty(r) && "number" == typeof this[r] && this[r] == l) return;
      if (null == r) {
       const o = getHostRef(this), s = null == o ? void 0 : o.$flags$;
       if (s && !(8 & s) && 128 & s && l !== n) {
        const r = o.$lazyInstance$ , i = null === (a = t.$watchers$) || void 0 === a ? void 0 : a[e];
        null == i || i.forEach((t => {
         null != r[t] && r[t].call(r, l, n, e);
        }));
       }
       return;
      }
     }
     this[r] = (null !== l || "boolean" != typeof this[r]) && l;
    }));
   }, e.observedAttributes = Array.from(new Set([ ...Object.keys(null !== (n = t.$watchers$) && void 0 !== n ? n : {}), ...l.filter((([e, t]) => 15 & t[0])).map((([e, n]) => {
    var s;
    const l = n[1] || e;
    return o.set(l, e), 512 & n[0] && (null === (s = t.$attrsToReflect$) || void 0 === s || s.push([ e, l ])), 
    l;
   })) ]));
  }
 }
 return e;
}, initializeComponent = async (e, t, o, n) => {
 let s;
 if (0 == (32 & t.$flags$)) {
  if (t.$flags$ |= 32, BUILD.lazyLoad ) {
   if (s = loadModule(o), s.then) {
    const e = (() => {});
    s = await s, e();
   }
   !s.isProxied && ((o.$watchers$ = s.watchers), 
   proxyComponent(s, o, 2), s.isProxied = !0);
   const e = createTime("createInstance", o.$tagName$);
   (t.$flags$ |= 8);
   try {
    new s(t);
   } catch (e) {
    consoleError(e);
   }
   (t.$flags$ &= -9), (t.$flags$ |= 128), e(), 
   fireConnectedCallback(t.$lazyInstance$);
  }
  if (s.style) {
   let n = s.style;
   const l = getScopeId(o);
   if (!styles.has(l)) {
    const e = createTime("registerStyles", o.$tagName$);
    registerStyle(l, n), e();
   }
  }
 }
 const r = t.$ancestorComponent$, i = () => scheduleUpdate(t, !0);
 r && r["s-rc"] ? r["s-rc"].push(i) : i();
}, fireConnectedCallback = e => {
 safeCall(e, "connectedCallback");
}, connectedCallback = e => {
 if (0 == (1 & plt.$flags$)) {
  const t = getHostRef(e), o = t.$cmpMeta$, n = createTime("connectedCallback", o.$tagName$);
  if (1 & t.$flags$) addHostEventListeners(e, t, o.$listeners$), (null == t ? void 0 : t.$lazyInstance$) ? fireConnectedCallback(t.$lazyInstance$) : (null == t ? void 0 : t.$onReadyPromise$) && t.$onReadyPromise$.then((() => fireConnectedCallback(t.$lazyInstance$))); else {
   let n;
   if (t.$flags$ |= 1, (n = e.getAttribute("s-id"), n)) {
    ((e, t, o, n) => {
     const s = createTime("hydrateClient", t), l = e.shadowRoot, a = [], r = l ? [] : null, i = n.$vnode$ = newVNode(t, null);
     plt.$orgLocNodes$ || initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = new Map), 
     e["s-id"] = o, e.removeAttribute("s-id"), clientHydrate(i, a, [], r, e, e, o), a.map((e => {
      const o = e.$hostId$ + "." + e.$nodeId$, n = plt.$orgLocNodes$.get(o), s = e.$elm$;
      n && supportsShadow && "" === n["s-en"] && n.parentNode.insertBefore(s, n.nextSibling), 
      l || (s["s-hn"] = t, n && (s["s-ol"] = n, s["s-ol"]["s-nr"] = s)), plt.$orgLocNodes$.delete(o);
     })), l && r.map((e => {
      e && l.appendChild(e);
     })), s();
    })(e, o.$tagName$, n, t);
   }
   if (!n && (BUILD.hydrateServerSide ) && setContentReference(e), 
   BUILD.asyncLoading) {
    let o = e;
    for (;o = o.parentNode || o.host; ) if (1 === o.nodeType && o.hasAttribute("s-id") && o["s-p"] || o["s-p"]) {
     attachToAncestor(t, t.$ancestorComponent$ = o);
     break;
    }
   }
   initializeComponent(e, t, o);
  }
  n();
 }
}, setContentReference = e => {
 const t = e["s-cr"] = doc.createComment("");
 t["s-cn"] = !0, e.insertBefore(t, e.firstChild);
}, Fragment = (e, t) => t, addHostEventListeners = (e, t, o, n) => {
 o && (o.map((([o, n, s]) => {
  const l = getHostListenerTarget(e, o) , a = hostListenerProxy(t, s), r = hostListenerOpts(o);
  plt.ael(l, n, a, r), (t.$rmListeners$ = t.$rmListeners$ || []).push((() => plt.rel(l, n, a, r)));
 })));
}, hostListenerProxy = (e, t) => o => {
 try {
  256 & e.$flags$ ? e.$lazyInstance$[t](o) : (e.$queuedListeners$ = e.$queuedListeners$ || []).push([ t, o ]) ;
 } catch (e) {
  consoleError(e);
 }
}, getHostListenerTarget = (e, t) => 4 & t ? doc : 8 & t ? win : 16 & t ? doc.body : e, hostListenerOpts = e => 0 != (2 & e), insertVdomAnnotations = (e, t) => {
 if (null != e) {
  const o = {
   hostIds: 0,
   rootLevelIds: 0,
   staticComponents: new Set(t)
  }, n = [];
  parseVNodeAnnotations(e, e.body, o, n), n.forEach((t => {
   if (null != t) {
    const n = t["s-nr"];
    let s = n["s-host-id"], l = n["s-node-id"], a = `${s}.${l}`;
    if (null == s) if (s = 0, o.rootLevelIds++, l = o.rootLevelIds, a = `${s}.${l}`, 
    1 === n.nodeType) n.setAttribute("c-id", a); else if (3 === n.nodeType) {
     if (0 === s && "" === n.nodeValue.trim()) return void t.remove();
     const o = e.createComment(a);
     o.nodeValue = `t.${a}`, n.parentNode.insertBefore(o, n);
    }
    let r = `o.${a}`;
    const i = t.parentElement;
    i && ("" === i["s-en"] ? r += "." : "c" === i["s-en"] && (r += ".c")), t.nodeValue = r;
   }
  }));
 }
}, parseVNodeAnnotations = (e, t, o, n) => {
 null != t && (null != t["s-nr"] && n.push(t), 1 === t.nodeType && t.childNodes.forEach((t => {
  const s = getHostRef(t);
  if (null != s && !o.staticComponents.has(t.nodeName.toLowerCase())) {
   const n = {
    nodeIds: 0
   };
   insertVNodeAnnotations(e, t, s.$vnode$, o, n);
  }
  parseVNodeAnnotations(e, t, o, n);
 })));
}, insertVNodeAnnotations = (e, t, o, n, s) => {
 if (null != o) {
  const l = ++n.hostIds;
  if (t.setAttribute("s-id", l), null != t["s-cr"] && (t["s-cr"].nodeValue = `r.${l}`), 
  null != o.$children$) {
   const t = 0;
   o.$children$.forEach(((o, n) => {
    insertChildVNodeAnnotations(e, o, s, l, t, n);
   }));
  }
  if (t && o && o.$elm$ && !t.hasAttribute("c-id")) {
   const e = t.parentElement;
   if (e && e.childNodes) {
    const n = Array.from(e.childNodes), s = n.find((e => 8 === e.nodeType && e["s-sr"]));
    if (s) {
     const e = n.indexOf(t) - 1;
     o.$elm$.setAttribute("c-id", `${s["s-host-id"]}.${s["s-node-id"]}.0.${e}`);
    }
   }
  }
 }
}, insertChildVNodeAnnotations = (e, t, o, n, s, l) => {
 const a = t.$elm$;
 if (null == a) return;
 const r = o.nodeIds++, i = `${n}.${r}.${s}.${l}`;
 if (a["s-host-id"] = n, a["s-node-id"] = r, 1 === a.nodeType) a.setAttribute("c-id", i); else if (3 === a.nodeType) {
  const t = a.parentNode, o = t.nodeName;
  if ("STYLE" !== o && "SCRIPT" !== o) {
   const o = `t.${i}`, n = e.createComment(o);
   t.insertBefore(n, a);
  }
 } else if (8 === a.nodeType && a["s-sr"]) {
  const e = `s.${i}.${a["s-sn"] || ""}`;
  a.nodeValue = e;
 }
 if (null != t.$children$) {
  const l = s + 1;
  t.$children$.forEach(((t, s) => {
   insertChildVNodeAnnotations(e, t, o, n, l, s);
  }));
 }
}, hAsync = (e, t, ...o) => {
 if (Array.isArray(o) && o.length > 0) {
  const n = o.flat(1 / 0);
  return n.some(isPromise) ? Promise.all(n).then((o => h(e, t, ...o))).catch((o => h(e, t))) : h(e, t, ...o);
 }
 return h(e, t);
}, NO_HYDRATE_TAGS = new Set([ "CODE", "HEAD", "IFRAME", "INPUT", "OBJECT", "OUTPUT", "NOSCRIPT", "PRE", "SCRIPT", "SELECT", "STYLE", "TEMPLATE", "TEXTAREA" ]);

const cmpModules = new Map, getModule = e => {
 if ("string" == typeof e) {
  e = e.toLowerCase();
  const t = cmpModules.get(e);
  if (null != t) return t[e];
 }
 return null;
}, loadModule = (e, t, o) => getModule(e.$tagName$), isMemberInElement = (e, t) => {
 if (null != e) {
  if (t in e) return !0;
  const o = getModule(e.nodeName);
  if (null != o) {
   const e = o;
   if (null != e && null != e.cmpMeta && null != e.cmpMeta.$members$) return t in e.cmpMeta.$members$;
  }
 }
 return !1;
}, registerComponents = e => {
 for (const t of e) {
  const e = t.cmpMeta.$tagName$;
  cmpModules.set(e, {
   [e]: t
  });
 }
}, win = window, doc = win.document, readTask = e => {
 process.nextTick((() => {
  try {
   e();
  } catch (e) {
   consoleError(e);
  }
 }));
}, writeTask = e => {
 process.nextTick((() => {
  try {
   e();
  } catch (e) {
   consoleError(e);
  }
 }));
}, resolved = Promise.resolve(), nextTick = e => resolved.then(e), defaultConsoleError = e => {
 null != e && console.error(e.stack || e.message || e);
}, consoleError = (e, t) => (defaultConsoleError)(e, t), plt = {
 $flags$: 0,
 $resourcesUrl$: "",
 jmp: e => e(),
 raf: e => requestAnimationFrame(e),
 ael: (e, t, o, n) => e.addEventListener(t, o, n),
 rel: (e, t, o, n) => e.removeEventListener(t, o, n),
 ce: (e, t) => new win.CustomEvent(e, t)
}, supportsShadow = !1, hostRefs = new WeakMap, getHostRef = e => hostRefs.get(e), registerInstance = (e, t) => hostRefs.set(t.$lazyInstance$ = e, t), registerHost = (e, t) => {
 const o = {
  $flags$: 0,
  $cmpMeta$: t,
  $hostElement$: e,
  $instanceValues$: new Map,
  $renderCount$: 0
 };
 return o.$onInstancePromise$ = new Promise((e => o.$onInstanceResolve$ = e)), o.$onReadyPromise$ = new Promise((e => o.$onReadyResolve$ = e)), 
 e["s-p"] = [], e["s-rc"] = [], addHostEventListeners(e, o, t.$listeners$), hostRefs.set(e, o);
}, styles = new Map;

/**
 * This utility ensures observers are created only for browser contexts.
 *
 * @param type - the type of observer to create
 * @param callback - the observer callback
 * @param options - the observer options
 */
function createObserver(type, callback, options) {
    {
        return undefined;
    }
}

const accordionCss = "/*!@:host([scale=s])*/[scale=s].sc-calcite-accordion-h{--calcite-accordion-item-spacing-unit:0.25rem;--calcite-accordion-icon-margin:0.5rem;--calcite-accordion-item-padding:var(--calcite-accordion-item-spacing-unit) 0.5rem;font-size:var(--calcite-font-size--2);line-height:1rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-accordion-h{--calcite-accordion-item-spacing-unit:0.5rem;--calcite-accordion-icon-margin:0.75rem;--calcite-accordion-item-padding:var(--calcite-accordion-item-spacing-unit) 0.75rem;font-size:var(--calcite-font-size--1);line-height:1rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-accordion-h{--calcite-accordion-item-spacing-unit:0.75rem;--calcite-accordion-icon-margin:1rem;--calcite-accordion-item-padding:var(--calcite-accordion-item-spacing-unit) 1rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host*/.sc-calcite-accordion-h{position:relative;display:block;max-inline-size:100%;line-height:1.5rem;--calcite-accordion-item-border:var(--calcite-color-border-2);--calcite-accordion-item-background:var(--calcite-color-foreground-1)}/*!@.accordion--transparent*/.accordion--transparent.sc-calcite-accordion{--calcite-accordion-item-border:transparent;--calcite-accordion-item-background:transparent}/*!@.accordion*/.accordion.sc-calcite-accordion{border-width:1px;border-block-end-width:0px;border-style:solid;border-color:var(--calcite-color-border-2)}/*!@:host([hidden])*/[hidden].sc-calcite-accordion-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-accordion{display:none}";

/**
 * @slot - A slot for adding `calcite-accordion-item`s. `calcite-accordion` cannot be nested, however `calcite-accordion-item`s can.
 */
class Accordion {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalAccordionChange = createEvent(this, "calciteInternalAccordionChange", 6);
        this.mutationObserver = createObserver();
        this.appearance = "solid";
        this.iconPosition = "end";
        this.iconType = "chevron";
        this.scale = "m";
        this.selectionMode = "multiple";
    }
    handlePropsChange() {
        this.updateAccordionItems();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.mutationObserver?.observe(this.el, { childList: true });
        this.updateAccordionItems();
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
    }
    render() {
        const transparent = this.appearance === "transparent";
        return (hAsync("div", { class: {
                "accordion--transparent": transparent,
                accordion: !transparent,
            } }, hAsync("slot", null)));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    updateActiveItemOnChange(event) {
        this.calciteInternalAccordionChange.emit({
            requestedAccordionItem: event.detail.requestedAccordionItem,
        });
        event.stopPropagation();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    updateAccordionItems() {
        this.el.querySelectorAll("calcite-accordion-item").forEach((item) => {
            item.iconPosition = this.iconPosition;
            item.iconType = this.iconType;
            item.scale = this.scale;
        });
        // sync props on items across shadow DOM
        document.dispatchEvent(new CustomEvent("calciteInternalAccordionItemsSync"));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "iconPosition": ["handlePropsChange"],
        "iconType": ["handlePropsChange"],
        "scale": ["handlePropsChange"],
        "selectionMode": ["handlePropsChange"]
    }; }
    static get style() { return accordionCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-accordion",
        "$members$": {
            "appearance": [513],
            "iconPosition": [513, "icon-position"],
            "iconType": [513, "icon-type"],
            "scale": [513],
            "selectionMode": [513, "selection-mode"]
        },
        "$listeners$": [[0, "calciteInternalAccordionItemSelect", "updateActiveItemOnChange"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["appearance", "appearance"], ["iconPosition", "icon-position"], ["iconType", "icon-type"], ["scale", "scale"], ["selectionMode", "selection-mode"]]
    }; }
}

const observed = new Set();
let mutationObserver$1;
const observerOptions = { childList: true };
/**
 * Helper to set up a conditional slot component on connectedCallback.
 *
 * @param component
 * @deprecated Use `onSlotchange` event with `slotChangeHasAssignedElement` DOM utility instead.
 *
 * ```
 * <slot onSlotchange={(event) => this.mySlotHasElement = slotChangeHasAssignedElement(event)} />}
 * ```
 */
function connectConditionalSlotComponent(component) {
    if (!mutationObserver$1) {
        mutationObserver$1 = createObserver();
    }
    mutationObserver$1.observe(component.el, observerOptions);
}
/**
 * Helper to tear down a conditional slot component on disconnectedCallback.
 *
 * @param component
 * @deprecated Use `onSlotchange` event with `slotChangeHasAssignedElement` DOM utility instead.
 *
 * ```
 * <slot onSlotchange={(event) => this.mySlotHasElement = slotChangeHasAssignedElement(event)} />}
 * ```
 */
function disconnectConditionalSlotComponent(component) {
    observed.delete(component.el);
    // we explicitly process queued mutations and disconnect and reconnect
    // the observer until MutationObserver gets an `unobserve` method
    // see https://github.com/whatwg/dom/issues/126
    processMutations(mutationObserver$1.takeRecords());
    mutationObserver$1.disconnect();
    for (const [element] of observed.entries()) {
        mutationObserver$1.observe(element, observerOptions);
    }
}
function processMutations(mutations) {
    mutations.forEach(({ target }) => {
    });
}

/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
// NOTE: separate `:not()` selectors has broader browser support than the newer
//  `:not([inert], [inert] *)` (Feb 2023)
// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes
//  the entire query to fail, resulting in no nodes found, which will break a lot
//  of things... so we have to rely on JS to identify nodes inside an inert container
var candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable="false"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];
var candidateSelector = /* #__PURE__ */candidateSelectors.join(',');
var NoElement = typeof Element === 'undefined';
var matches$1 = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode$1 = !NoElement && Element.prototype.getRootNode ? function (element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function (element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};

/**
 * Determines if a node is inert or in an inert ancestor.
 * @param {Element} [node]
 * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to
 *  see if any of them are inert. If false, only `node` itself is considered.
 * @returns {boolean} True if inert itself or by way of being in an inert ancestor.
 *  False if `node` is falsy.
 */
var isInert = function isInert(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`
  //  JS API property; we have to check the attribute, which can either be empty or 'true';
  //  if it's `null` (not specified) or 'false', it's an active element
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');
  var inert = inertAtt === '' || inertAtt === 'true';

  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`
  //  if it weren't for `matches()` not being a function on shadow roots; the following
  //  code works for any kind of node
  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`
  //  so it likely would not support `:is([inert] *)` either...
  var result = inert || lookUp && node && isInert(node.parentNode); // recursive

  return result;
};

/**
 * Determines if a node's content is editable.
 * @param {Element} [node]
 * @returns True if it's content-editable; false if it's not or `node` is falsy.
 */
var isContentEditable = function isContentEditable(node) {
  var _node$getAttribute2;
  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have
  //  to use the attribute directly to check for this, which can either be empty or 'true';
  //  if it's `null` (not specified) or 'false', it's a non-editable element
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');
  return attValue === '' || attValue === 'true';
};

/**
 * @param {Element} el container to check in
 * @param {boolean} includeContainer add container to check
 * @param {(node: Element) => boolean} filter filter candidates
 * @returns {Element[]}
 */
var getCandidates = function getCandidates(el, includeContainer, filter) {
  // even if `includeContainer=false`, we still have to check it for inertness because
  //  if it's inert, all its children are inert
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches$1.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};

/**
 * @callback GetShadowRoot
 * @param {Element} element to check for shadow root
 * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.
 */

/**
 * @callback ShadowRootFilter
 * @param {Element} shadowHostNode the element which contains shadow content
 * @returns {boolean} true if a shadow root could potentially contain valid candidates.
 */

/**
 * @typedef {Object} CandidateScope
 * @property {Element} scopeParent contains inner candidates
 * @property {Element[]} candidates list of candidates found in the scope parent
 */

/**
 * @typedef {Object} IterativeOptions
 * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;
 *  if a function, implies shadow support is enabled and either returns the shadow root of an element
 *  or a boolean stating if it has an undisclosed shadow root
 * @property {(node: Element) => boolean} filter filter candidates
 * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list
 * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;
 */

/**
 * @param {Element[]} elements list of element containers to match candidates from
 * @param {boolean} includeContainer add container list to check
 * @param {IterativeOptions} options
 * @returns {Array.<Element|CandidateScope>}
 */
var getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      // no need to look up since we're drilling down
      // anything inside this container will also be inert
      continue;
    }
    if (element.tagName === 'SLOT') {
      // add shadow dom slot scope (slot itself cannot be focusable)
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      // check candidate element
      var validCandidate = matches$1.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }

      // iterate over shadow content if possible
      var shadowRoot = element.shadowRoot ||
      // check for an undisclosed shadow
      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);

      // no inert look up because we're already drilling down and checking for inertness
      //  on the way down, so all containers to this root node should have already been
      //  vetted as non-inert
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed
        //  shadow exists, so look at light dom children as fallback BUT create a scope for any
        //  child candidates found because they're likely slotted elements (elements that are
        //  children of the web component element (which has the shadow), in the light dom, but
        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,
        //  _after_ we return from this recursive call
        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        // there's not shadow so just dig into the element's (light dom) children
        //  __without__ giving the element special scope treatment
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};

/**
 * @private
 * Determines if the node has an explicitly specified `tabindex` attribute.
 * @param {HTMLElement} node
 * @returns {boolean} True if so; false if not.
 */
var hasTabIndex = function hasTabIndex(node) {
  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));
};

/**
 * Determine the tab index of a given node.
 * @param {HTMLElement} node
 * @returns {number} Tab order (negative, 0, or positive number).
 * @throws {Error} If `node` is falsy.
 */
var getTabIndex = function getTabIndex(node) {
  if (!node) {
    throw new Error('No node provided');
  }
  if (node.tabIndex < 0) {
    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
    // yet they are still part of the regular tab order; in FF, they get a default
    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab
    // order, consider their tab index to be 0.
    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};

/**
 * Determine the tab index of a given node __for sort order purposes__.
 * @param {HTMLElement} node
 * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,
 *  has tabIndex -1, but needs to be sorted by document order in order for its content to be
 *  inserted into the correct sort position.
 * @returns {number} Tab order (negative, 0, or positive number).
 */
var getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput(node) {
  return node.tagName === 'INPUT';
};
var isHiddenInput = function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
};
var isDetailsWithSummary = function isDetailsWithSummary(node) {
  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
    return child.tagName === 'SUMMARY';
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode$1(node);
  var queryRadios = function queryRadios(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio(node) {
  return isInput(node) && node.type === 'radio';
};
var isNonTabbableRadio = function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
};

// determines if a node is ultimately attached to the window's document
var isNodeAttached = function isNodeAttached(node) {
  var _nodeRoot;
  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
  //  (but NOT _the_ document; see second 'If' comment below for more).
  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
  //  is attached, and the one we need to check if it's in the document or not (because the
  //  shadow, and all nodes it contains, is never considered in the document since shadows
  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
  //  visibility, including all the nodes it contains). The host could be any normal node,
  //  or a custom element (i.e. web component). Either way, that's the one that is considered
  //  part of the document, not the shadow root, nor any of its children (i.e. the node being
  //  tested).
  // To further complicate things, we have to look all the way up until we find a shadow HOST
  //  that is attached (or find none) because the node might be in nested shadows...
  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
  //  document (per the docs) and while it's a Document-type object, that document does not
  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
  //  node is actually detached.
  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible
  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed
  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then
  //  `ownerDocument` will be `null`, hence the optional chaining on it.
  var nodeRoot = node && getRootNode$1(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;

  // in some cases, a detached node will return itself as the root instead of a document or
  //  shadow root object, in which case, we shouldn't try to look further up the host chain
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
      //  which means we need to get the host's host and check if that parent host is contained
      //  in (i.e. attached to) the document
      nodeRoot = getRootNode$1(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(),
    width = _node$getBoundingClie.width,
    height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden(node, _ref) {
  var displayCheck = _ref.displayCheck,
    getShadowRoot = _ref.getShadowRoot;
  // NOTE: visibility will be `undefined` if node is detached from the document
  //  (see notes about this further down), which means we will consider it visible
  //  (this is legacy behavior from a very long way back)
  // NOTE: we check this regardless of `displayCheck="none"` because this is a
  //  _visibility_ check, not a _display_ check
  if (getComputedStyle(node).visibility === 'hidden') {
    return true;
  }
  var isDirectSummary = matches$1.call(node, 'details>summary:first-of-type');
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches$1.call(nodeUnderDetails, 'details:not([open]) *')) {
    return true;
  }
  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
    if (typeof getShadowRoot === 'function') {
      // figure out if we should consider the node to be in an undisclosed shadow and use the
      //  'non-zero-area' fallback
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode$1(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
        ) {
          // node has an undisclosed shadow which means we can only treat it as a black box, so we
          //  fall back to a non-zero-area test
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          // iterate up slot
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          // cross shadow boundary
          node = rootNode.host;
        } else {
          // iterate up normal dom
          node = parentElement;
        }
      }
      node = originalNode;
    }
    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
    //  it might be a falsy value, which means shadow DOM support is disabled

    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
    //  now we can just test to see if it would normally be visible or not, provided it's
    //  attached to the main document.
    // NOTE: We must consider case where node is inside a shadow DOM and given directly to
    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.

    if (isNodeAttached(node)) {
      // this works wherever the node is: if there's at least one client rect, it's
      //  somehow displayed; it also covers the CSS 'display: contents' case where the
      //  node itself is hidden in place of its contents; and there's no need to search
      //  up the hierarchy either
      return !node.getClientRects().length;
    }

    // Else, the node isn't attached to the document, which means the `getClientRects()`
    //  API will __always__ return zero rects (this can happen, for example, if React
    //  is used to render nodes onto a detached tree, as confirmed in this thread:
    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
    //
    // It also means that even window.getComputedStyle(node).display will return `undefined`
    //  because styles are only computed for nodes that are in the document.
    //
    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
    //  somehow. Though it was never stated officially, anyone who has ever used tabbable
    //  APIs on nodes in detached containers has actually implicitly used tabbable in what
    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
    //  considering __everything__ to be visible because of the innability to determine styles.
    //
    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
    //  nodes as visible with the 'none' fallback.__
    if (displayCheck !== 'legacy-full') {
      return true; // hidden
    }
    // else, fallback to 'none' mode and consider the node visible
  } else if (displayCheck === 'non-zero-area') {
    // NOTE: Even though this tests that the node's client rect is non-zero to determine
    //  whether it's displayed, and that a detached node will __always__ have a zero-area
    //  client rect, we don't special-case for whether the node is attached or not. In
    //  this mode, we do want to consider nodes that have a zero area to be hidden at all
    //  times, and that includes attached or not.
    return isZeroArea(node);
  }

  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
  //  it's visible
  return false;
};

// form fields (nested) inside a disabled fieldset are not focusable/tabbable
//  unless they are in the _first_ <legend> element of the top-most disabled
//  fieldset
var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    // check if `node` is contained in a disabled <fieldset>
    while (parentNode) {
      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
        // look for the first <legend> among the children of the disabled <fieldset>
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          // when the first <legend> (in document order) is found
          if (child.tagName === 'LEGEND') {
            // if its parent <fieldset> is not nested in another disabled <fieldset>,
            // return whether `node` is a descendant of its first <legend>
            return matches$1.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
          }
        }
        // the disabled <fieldset> containing `node` has no <legend>
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }

  // else, node's tabbable/focusable state should not be affected by a fieldset's
  //  enabled/disabled state
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
  if (node.disabled ||
  // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||
  // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  // If a custom element has an explicit negative tabindex,
  // browsers will not allow tab targeting said element's children.
  return false;
};

/**
 * @param {Array.<Element|CandidateScope>} candidates
 * @returns Element[]
 */
var sortByOrder = function sortByOrder(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function (item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item: item,
        isScope: isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches$1.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');
var isFocusable = function isFocusable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches$1.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

function gen(counts) {
    return counts
        .map((count) => {
        let out = "";
        for (let i = 0; i < count; i++) {
            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        return out;
    })
        .join("-");
}
const guid = () => gen([2, 1, 1, 1, 3]);

/**
 * The default `focus-trap/tabbable` options.
 *
 * See https://github.com/focus-trap/tabbable#tabbable
 */
const tabbableOptions = {
    getShadowRoot: true,
};
/**
 * This helper will guarantee an ID on the provided element.
 *
 * If it already has an ID, it will be preserved, otherwise a unique one will be generated and assigned.
 *
 * @param {Element} el An element.
 * @returns {string} The element's ID.
 */
function ensureId(el) {
    if (!el) {
        return "";
    }
    return (el.id = el.id || `${el.tagName.toLowerCase()}-${guid()}`);
}
/**
 * This helper returns an array from a NodeList.
 *
 * @param {NodeList} nodeList A NodeList.
 * @returns {Element[]} An array of elements.
 */
function nodeListToArray(nodeList) {
    return Array.isArray(nodeList) ? nodeList : Array.from(nodeList);
}
/**
 * This helper returns the Calcite "mode" of an element.
 *
 * @param {HTMLElement} el An element.
 * @returns {"light"|"dark"} The Calcite mode.
 */
function getModeName(el) {
    const closestElWithMode = closestElementCrossShadowBoundary(el, `.${CSS_UTILITY.darkMode}, .${CSS_UTILITY.lightMode}`);
    return closestElWithMode?.classList.contains("calcite-mode-dark") ? "dark" : "light";
}
/**
 * This helper returns the direction of a HTML element.
 *
 * @param {HTMLElement} el An element.
 * @returns {Direction} The direction.
 */
function getElementDir(el) {
    const prop = "dir";
    const selector = `[${prop}]`;
    const closest = closestElementCrossShadowBoundary(el, selector);
    return closest ? closest.getAttribute(prop) : "ltr";
}
/**
 * This helper returns the computed width in pixels of a rendered HTMLElement.
 *
 * @param {HTMLElement} el An element.
 * @returns {number} The element's width.
 */
function getElementWidth(el) {
    if (!el) {
        return 0;
    }
    return parseFloat(getComputedStyle(el).inlineSize);
}
/**
 * This helper returns the rootNode of an element.
 *
 * @param {Element} el An element.
 * @returns {Document|ShadowRoot} The element's root node.
 */
function getRootNode(el) {
    return el.getRootNode();
}
/**
 * This helper returns the node's shadowRoot root node if it exists.
 *
 * @param {Element} el The element.
 * @returns {ShadowRoot|null} The element's root node ShadowRoot.
 */
function getShadowRootNode(el) {
    const rootNode = getRootNode(el);
    return "host" in rootNode ? rootNode : null;
}
/**
 * This helper returns the computed width in pixels a given text string takes up on screen.
 *
 * See https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript
 *
 * @param {string} text The string of text to measure.
 * @param {string} font The CSS font attribute's value, which should include size and face, e.g. "12px Arial".
 */
function getTextWidth(text, font) {
    if (!text) {
        return 0;
    }
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    context.font = font;
    return context.measureText(text).width;
}
/**
 * This helper returns the host of a ShadowRoot.
 *
 * @param {Document | ShadowRoot} root A root element.
 * @returns {Element | null} The host element.
 */
function getHost(root) {
    return root.host || null;
}
/**
 * This helper queries an element's rootNode and any ancestor rootNodes.
 *
 * If both an 'id' and 'selector' are supplied, 'id' will take precedence over 'selector'.
 *
 * @param {Element} element An element.
 * @param root0
 * @param root0.selector
 * @param root0.id
 * @returns {Element} An element.
 */
function queryElementRoots(element, { selector, id, }) {
    // Gets the rootNode and any ancestor rootNodes (shadowRoot or document) of an element and queries them for a selector.
    // Based on: https://stackoverflow.com/q/54520554/194216
    function queryFrom(el) {
        if (!el) {
            return null;
        }
        if (el.assignedSlot) {
            el = el.assignedSlot;
        }
        const rootNode = getRootNode(el);
        const found = id
            ? "getElementById" in rootNode
                ? /*
                  Check to make sure 'getElementById' exists in cases where element is no longer connected to the DOM and getRootNode() returns the element.
                  https://github.com/Esri/calcite-design-system/pull/4280
                   */
                    rootNode.getElementById(id)
                : null
            : selector
                ? rootNode.querySelector(selector)
                : null;
        const host = getHost(rootNode);
        return found ? found : host ? queryFrom(host) : null;
    }
    return queryFrom(element);
}
/**
 * This helper returns the closest element matching the selector by crossing he shadow boundary if necessary.
 *
 * @param {Element} element The starting element.
 * @param {string} selector The selector.
 * @returns {Element} The targeted element.
 */
function closestElementCrossShadowBoundary(element, selector) {
    // based on https://stackoverflow.com/q/54520554/194216
    function closestFrom(el) {
        return el ? el.closest(selector) || closestFrom(getHost(getRootNode(el))) : null;
    }
    return closestFrom(element);
}
/**
 * This helper returns true when an element has a setFocus method.
 *
 * @param {Element} el An element.
 * @returns {boolean} The result.
 */
function isCalciteFocusable(el) {
    return typeof el?.setFocus === "function";
}
/**
 * This helper focuses an element using the `setFocus` method if available and falls back to using the `focus` method if not available.
 *
 * @param {Element} el An element.
 */
async function focusElement(el) {
    if (!el) {
        return;
    }
    return isCalciteFocusable(el) ? el.setFocus() : el.focus();
}
/**
 * Helper to get the first tabbable element.
 *
 * @param {HTMLElement} element The html element containing tabbable elements.
 * @returns the first tabbable element.
 */
function getFirstTabbable(element) {
    if (!element) {
        return;
    }
    return (tabbable(element, tabbableOptions)[0] ?? element);
}
/**
 * Helper to focus the first tabbable element.
 *
 * @param {HTMLElement} element The html element containing tabbable elements.
 */
function focusFirstTabbable(element) {
    getFirstTabbable(element)?.focus();
}
const defaultSlotSelector = ":not([slot])";
function getSlotted(element, slotName, options) {
    if (slotName && !Array.isArray(slotName) && typeof slotName !== "string") {
        options = slotName;
        slotName = null;
    }
    const slotSelector = slotName
        ? Array.isArray(slotName)
            ? slotName.map((name) => `[slot="${name}"]`).join(",")
            : `[slot="${slotName}"]`
        : defaultSlotSelector;
    if (options?.all) {
        return queryMultiple(element, slotSelector, options);
    }
    return querySingle(element, slotSelector, options);
}
function getDirectChildren(el, selector) {
    return el ? Array.from(el.children || []).filter((child) => child?.matches(selector)) : [];
}
function queryMultiple(element, slotSelector, options) {
    let matches = slotSelector === defaultSlotSelector
        ? getDirectChildren(element, defaultSlotSelector)
        : Array.from(element.querySelectorAll(slotSelector));
    matches = options && options.direct === false ? matches : matches.filter((el) => el.parentElement === element);
    matches = options?.matches ? matches.filter((el) => el?.matches(options.matches)) : matches;
    const selector = options?.selector;
    return selector
        ? matches
            .map((item) => Array.from(item.querySelectorAll(selector)))
            .reduce((previousValue, currentValue) => [...previousValue, ...currentValue], [])
            .filter((match) => !!match)
        : matches;
}
function querySingle(element, slotSelector, options) {
    let match = slotSelector === defaultSlotSelector
        ? getDirectChildren(element, defaultSlotSelector)[0] || null
        : element.querySelector(slotSelector);
    match = options && options.direct === false ? match : match?.parentElement === element ? match : null;
    match = options?.matches ? (match?.matches(options.matches) ? match : null) : match;
    const selector = options?.selector;
    return selector ? match?.querySelector(selector) : match;
}
/**
 * Filters direct children.
 *
 * @param {Element} el An element.
 * @param {string} selector The selector.
 * @returns {Element[]} An array of elements.
 */
function filterDirectChildren(el, selector) {
    return Array.from(el.children).filter((child) => child.matches(selector));
}
/**
 * Set a default icon from a defined set or allow an override with an icon name string
 *
 * @param {Record<string, string>} iconObject The icon object.
 * @param {string | boolean} iconValue The icon value.
 * @param {string} matchedValue The matched value.
 * @returns {string|undefined} The resulting icon value.
 */
function setRequestedIcon(iconObject, iconValue, matchedValue) {
    if (typeof iconValue === "string" && iconValue !== "") {
        return iconValue;
    }
    else if (iconValue === "") {
        return iconObject[matchedValue];
    }
}
/**
 * This helper returns true when two rectangles intersect.
 *
 * @param {DOMRect} rect1 The first rectangle.
 * @param {DOMRect} rect2 The second rectangle.
 * @returns {boolean} The result.
 */
function intersects(rect1, rect2) {
    return !(rect2.left > rect1.right ||
        rect2.right < rect1.left ||
        rect2.top > rect1.bottom ||
        rect2.bottom < rect1.top);
}
/**
 * This helper makes sure that boolean aria attributes are properly converted to a string.
 *
 * It should only be used for aria attributes that require a string value of "true" or "false".
 *
 * @param {boolean} value The value.
 * @returns {string} The string conversion of a boolean value ("true" | "false").
 */
function toAriaBoolean(value) {
    return Boolean(value).toString();
}
/**
 * This helper returns `true` if the target `slot` element from the `onSlotchange` event has any content (text or elements).
 *
 * ```
 * <slot onSlotchange={(event) => this.mySlotHasContent = slotChangeHasContent(event)} />}
 * ```
 *
 * @param {Event} event The event.
 * @returns {boolean} Whether the slot has any content.
 */
function slotChangeHasContent(event) {
    return slotChangeHasAssignedElement(event) || slotChangeHasTextContent(event);
}
/**
 * This helper returns a string of textContent if the target `slot` element from the `onSlotchange` event has any text content.
 *
 * ```
 * <slot onSlotchange={(event) => this.mySlotText = slotChangeGetTextContent(event)} />}
 * ```
 *
 * @param {Event} event The event.
 * @returns {string} The slots text.
 */
function slotChangeGetTextContent(event) {
    return slotChangeGetAssignedNodes(event)
        .filter((node) => node.nodeType === Node.TEXT_NODE)
        .map((node) => node.textContent)
        .join("")
        .trim();
}
/**
 * This helper returns `true` if the target `slot` element from the `onSlotchange` event has any text content.
 *
 * ```
 * <slot onSlotchange={(event) => this.mySlotHasTextContent = slotChangeHasTextContent(event)} />}
 * ```
 *
 * @param {Event} event The event.
 * @returns {boolean} Whether the slot has any text content.
 */
function slotChangeHasTextContent(event) {
    return !!slotChangeGetTextContent(event);
}
/**
 * This helper returns the assigned nodes on a `slot` element from the `onSlotchange` event.
 *
 * ```
 * <slot onSlotchange={(event) => this.mySlotNodes = slotChangeGetAssignedNodes(event)} />}
 * ```
 *
 * @param {Event} event The event.
 * @returns {boolean} Whether the slot has any assigned nodes.
 */
function slotChangeGetAssignedNodes(event) {
    return event.target.assignedNodes({
        flatten: true,
    });
}
/**
 * This helper returns `true` if the target `slot` element from the `onSlotchange` event has an assigned element.
 *
 * ```
 * <slot onSlotchange={(event) => this.mySlotHasElement = slotChangeHasAssignedElement(event)} />}
 * ```
 *
 * @param {Event} event The event.
 * @returns {boolean} Whether the slot has any assigned elements.
 */
function slotChangeHasAssignedElement(event) {
    return !!slotChangeGetAssignedElements(event).length;
}
/**
 * This helper returns the assigned elements on a `slot` element from the `onSlotchange` event.
 *
 * ```
 * <slot onSlotchange={(event) => this.mySlotElements = slotChangeGetAssignedElements(event)} />}
 * ```
 *
 * @param {Event} event The event.
 * @returns {boolean} Whether the slot has any assigned elements.
 */
function slotChangeGetAssignedElements(event) {
    return event.target.assignedElements({
        flatten: true,
    });
}
/**
 * This helper returns true if the pointer event fired from the primary button of the device.
 *
 * See https://www.w3.org/TR/pointerevents/#the-button-property.
 *
 * @param {PointerEvent} event The pointer event.
 * @returns {boolean} The value.
 */
function isPrimaryPointerButton(event) {
    return !!(event.isPrimary && event.button === 0);
}
/**
 * This helper sets focus on and returns a destination element from within a group of provided elements.
 *
 * @param {Element[]} elements An array of elements.
 * @param {Element} currentElement The current element.
 * @param {FocusElementInGroupDestination} destination The target destination element to focus.
 * @param {boolean} cycle Should navigation cycle through elements or stop at extent - defaults to true.
 * @returns {Element} The focused element
 */
const focusElementInGroup = (elements, currentElement, destination, cycle = true) => {
    const currentIndex = elements.indexOf(currentElement);
    const isFirstItem = currentIndex === 0;
    const isLastItem = currentIndex === elements.length - 1;
    if (cycle) {
        destination =
            destination === "previous" && isFirstItem ? "last" : destination === "next" && isLastItem ? "first" : destination;
    }
    let focusTarget;
    if (destination === "previous") {
        focusTarget = elements[currentIndex - 1] || elements[cycle ? elements.length - 1 : currentIndex];
    }
    else if (destination === "next") {
        focusTarget = elements[currentIndex + 1] || elements[cycle ? 0 : currentIndex];
    }
    else if (destination === "last") {
        focusTarget = elements[elements.length - 1];
    }
    else {
        focusTarget = elements[0];
    }
    focusElement(focusTarget);
    return focusTarget;
};
/**
 * This helper determines if an element is before another element in the DOM.
 *
 * @param a the reference element to compare
 * @param b the element to compare against
 *
 * @returns true when a is before b in the DOM
 */
function isBefore(a, b) {
    if (a.parentNode !== b.parentNode) {
        return false;
    }
    const children = Array.from(a.parentNode.children);
    return children.indexOf(a) < children.indexOf(b);
}

function getIconScale(componentScale) {
    return componentScale === "l" ? "m" : "s";
}
/**
 * This util helps us wait for a component to be ready for both lazy-loading (`dist` output) and non-lazy-loading (`components` output) components.
 *
 * Based on https://github.com/ionic-team/ionic-framework/blob/1a8bd6d/core/src/utils/helpers.ts#L60C1-L79C3
 *
 * @param el - the host element to wait for
 */
async function componentOnReady(el) {
    await (isStencilEl(el)
        ? el.componentOnReady()
        : new Promise((resolve) => requestAnimationFrame(() => resolve())));
}
function isStencilEl(el) {
    return typeof el.componentOnReady === "function";
}

const SLOTS$z = {
    actionsStart: "actions-start",
    actionsEnd: "actions-end",
};
const CSS$1o = {
    icon: "icon",
    header: "header",
    headerContent: "header-content",
    actionsStart: "actions-start",
    actionsEnd: "actions-end",
    headerText: "header-text",
    heading: "heading",
    description: "description",
    expandIcon: "expand-icon",
    content: "content",
    iconStart: "icon--start",
    iconEnd: "icon--end",
    headerContainer: "header-container",
};
const IDS$2 = {
    section: "section",
    sectionToggle: "section-toggle",
};

const accordionItemCss = "/*!@.icon-position--end, .icon-position--start*/.icon-position--end.sc-calcite-accordion-item,.icon-position--start.sc-calcite-accordion-item{--calcite-accordion-item-icon-rotation:calc(90deg * -1);--calcite-accordion-item-active-icon-rotation:0deg;--calcite-accordion-item-icon-rotation-rtl:90deg;--calcite-accordion-item-active-icon-rotation-rtl:0deg}/*!@.icon-position--start*/.icon-position--start.sc-calcite-accordion-item{--calcite-accordion-item-flex-direction:row-reverse;--calcite-accordion-item-icon-spacing-start:0;--calcite-accordion-item-icon-spacing-end:var(--calcite-accordion-icon-margin)}/*!@.icon-position--end*/.icon-position--end.sc-calcite-accordion-item{--calcite-accordion-item-flex-direction:row;--calcite-accordion-item-icon-spacing-start:var(--calcite-accordion-icon-margin);--calcite-accordion-item-icon-spacing-end:0}/*!@.icon-position--end:not(.icon-type--plus-minus)*/.icon-position--end.sc-calcite-accordion-item:not(.icon-type--plus-minus){--calcite-accordion-item-icon-rotation:0deg;--calcite-accordion-item-active-icon-rotation:180deg;--calcite-accordion-item-icon-rotation-rtl:0deg;--calcite-accordion-item-active-icon-rotation-rtl:calc(180deg * -1)}/*!@:host*/.sc-calcite-accordion-item-h{position:relative;display:flex;flex-direction:column;color:var(--calcite-color-text-3);text-decoration-line:none;background-color:var(--calcite-accordion-item-background, var(--calcite-color-foreground-1))}/*!@:host .header-content*/.sc-calcite-accordion-item-h .header-content.sc-calcite-accordion-item{outline-color:transparent}/*!@:host(:focus) .header-content*/.sc-calcite-accordion-item-h:focus .header-content.sc-calcite-accordion-item{outline:2px solid transparent;outline-offset:2px;outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([expanded])*/[expanded].sc-calcite-accordion-item-h{color:var(--calcite-color-text-1)}/*!@:host([expanded]) .content*/[expanded].sc-calcite-accordion-item-h .content.sc-calcite-accordion-item{display:block;color:var(--calcite-color-text-1)}/*!@:host([expanded]) .header*/[expanded].sc-calcite-accordion-item-h .header.sc-calcite-accordion-item{border-block-end-color:transparent}/*!@:host .header*/.sc-calcite-accordion-item-h .header.sc-calcite-accordion-item{display:flex;align-items:stretch}/*!@:host .icon*/.sc-calcite-accordion-item-h .icon.sc-calcite-accordion-item{position:relative;margin:0px;display:inline-flex;color:var(--calcite-color-text-3);transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);margin-inline-end:var(--calcite-accordion-item-icon-spacing-start);margin-inline-start:var(--calcite-accordion-item-icon-spacing-end)}/*!@.icon--start*/.icon--start.sc-calcite-accordion-item{display:flex;align-items:center;margin-inline-end:var(--calcite-accordion-icon-margin)}/*!@.icon--end*/.icon--end.sc-calcite-accordion-item{display:flex;align-items:center;margin-inline-end:var(--calcite-accordion-icon-margin);margin-inline-start:var(--calcite-accordion-icon-margin)}/*!@.header-container*/.header-container.sc-calcite-accordion-item{inline-size:100%}/*!@.content*/.content.sc-calcite-accordion-item{padding:var(--calcite-accordion-item-padding)}/*!@:host .content,\n:host .header*/.sc-calcite-accordion-item-h .content.sc-calcite-accordion-item,.sc-calcite-accordion-item-h .header.sc-calcite-accordion-item{border-block-end:1px solid var(--calcite-accordion-item-border, var(--calcite-color-border-2))}/*!@:host .header **/.sc-calcite-accordion-item-h .header.sc-calcite-accordion-item *.sc-calcite-accordion-item{display:inline-flex;align-items:center;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);word-wrap:break-word;word-break:break-word}/*!@:host .content*/.sc-calcite-accordion-item-h .content.sc-calcite-accordion-item{display:none;padding-block-start:0px;color:var(--calcite-color-text-3);text-align:initial}/*!@:host .expand-icon*/.sc-calcite-accordion-item-h .expand-icon.sc-calcite-accordion-item{color:var(--calcite-color-text-3);margin-inline-start:var(--calcite-accordion-item-icon-spacing-start);margin-inline-end:var(--calcite-accordion-item-icon-spacing-end);transform:rotate(var(--calcite-accordion-item-icon-rotation))}/*!@.calcite--rtl .expand-icon*/.calcite--rtl.sc-calcite-accordion-item .expand-icon.sc-calcite-accordion-item{transform:rotate(var(--calcite-accordion-item-icon-rotation-rtl))}/*!@:host([expanded]) .expand-icon*/[expanded].sc-calcite-accordion-item-h .expand-icon.sc-calcite-accordion-item{color:var(--calcite-color-text-3);transform:rotate(var(--calcite-accordion-item-active-icon-rotation))}/*!@:host([expanded]) .calcite--rtl .expand-icon*/[expanded].sc-calcite-accordion-item-h .calcite--rtl.sc-calcite-accordion-item .expand-icon.sc-calcite-accordion-item{transform:rotate(var(--calcite-accordion-item-active-icon-rotation-rtl))}/*!@:host .header-text*/.sc-calcite-accordion-item-h .header-text.sc-calcite-accordion-item{margin-block:0px;flex-grow:1;flex-direction:column;padding-block:0px;text-align:initial;margin-inline-end:auto}/*!@:host .heading,\n:host .description*/.sc-calcite-accordion-item-h .heading.sc-calcite-accordion-item,.sc-calcite-accordion-item-h .description.sc-calcite-accordion-item{display:flex;inline-size:100%}/*!@:host .heading*/.sc-calcite-accordion-item-h .heading.sc-calcite-accordion-item{font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-2)}/*!@:host .description*/.sc-calcite-accordion-item-h .description.sc-calcite-accordion-item{margin-block-start:0.25rem;color:var(--calcite-color-text-3)}/*!@:host(:focus) .heading,\n:host(:hover) .heading*/.sc-calcite-accordion-item-h:focus .heading.sc-calcite-accordion-item,.sc-calcite-accordion-item-h:hover .heading.sc-calcite-accordion-item{color:var(--calcite-color-text-1)}/*!@:host(:focus) .icon,\n:host(:hover) .icon*/.sc-calcite-accordion-item-h:focus .icon.sc-calcite-accordion-item,.sc-calcite-accordion-item-h:hover .icon.sc-calcite-accordion-item{color:var(--calcite-color-text-1)}/*!@:host(:focus) .expand-icon,\n:host(:hover) .expand-icon*/.sc-calcite-accordion-item-h:focus .expand-icon.sc-calcite-accordion-item,.sc-calcite-accordion-item-h:hover .expand-icon.sc-calcite-accordion-item{color:var(--calcite-color-text-1)}/*!@:host(:focus) .description,\n:host(:hover) .description*/.sc-calcite-accordion-item-h:focus .description.sc-calcite-accordion-item,.sc-calcite-accordion-item-h:hover .description.sc-calcite-accordion-item{color:var(--calcite-color-text-2)}/*!@:host(:focus) .heading,\n:host(:active) .heading,\n:host([expanded]) .heading*/.sc-calcite-accordion-item-h:focus .heading.sc-calcite-accordion-item,.sc-calcite-accordion-item-h:active .heading.sc-calcite-accordion-item,[expanded].sc-calcite-accordion-item-h .heading.sc-calcite-accordion-item{color:var(--calcite-color-text-1)}/*!@:host(:focus) .icon,\n:host(:active) .icon,\n:host([expanded]) .icon*/.sc-calcite-accordion-item-h:focus .icon.sc-calcite-accordion-item,.sc-calcite-accordion-item-h:active .icon.sc-calcite-accordion-item,[expanded].sc-calcite-accordion-item-h .icon.sc-calcite-accordion-item{color:var(--calcite-color-text-1)}/*!@:host(:focus) .description,\n:host(:active) .description,\n:host([expanded]) .description*/.sc-calcite-accordion-item-h:focus .description.sc-calcite-accordion-item,.sc-calcite-accordion-item-h:active .description.sc-calcite-accordion-item,[expanded].sc-calcite-accordion-item-h .description.sc-calcite-accordion-item{color:var(--calcite-color-text-2)}/*!@.header-content*/.header-content.sc-calcite-accordion-item{flex-grow:1;cursor:pointer;padding:var(--calcite-accordion-item-padding);flex-direction:var(--calcite-accordion-item-flex-direction)}/*!@.actions-start,\n.actions-end*/.actions-start.sc-calcite-accordion-item,.actions-end.sc-calcite-accordion-item{display:flex;align-items:center}@media (forced-colors: active){/*!@:host([expanded]) .header*/[expanded].sc-calcite-accordion-item-h .header.sc-calcite-accordion-item{border-block-end:none}/*!@:host([expanded]) .heading*/[expanded].sc-calcite-accordion-item-h .heading.sc-calcite-accordion-item{font-weight:bolder}/*!@:host(:hover) .heading,\n  :host(:focus) .heading*/.sc-calcite-accordion-item-h:hover .heading.sc-calcite-accordion-item,.sc-calcite-accordion-item-h:focus .heading.sc-calcite-accordion-item{text-decoration:underline}}/*!@:host([hidden])*/[hidden].sc-calcite-accordion-item-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-accordion-item{display:none}";

/**
 * @slot - A slot for adding custom content, including nested `calcite-accordion-item`s.
 * @slot actions-end - A slot for adding `calcite-action`s or content to the end side of the component's header.
 * @slot actions-start - A slot for adding `calcite-action`s or content to the start side of the component's header.
 */
class AccordionItem {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalAccordionItemSelect = createEvent(this, "calciteInternalAccordionItemSelect", 6);
        this.calciteInternalAccordionItemClose = createEvent(this, "calciteInternalAccordionItemClose", 6);
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        /** handle clicks on item header */
        this.itemHeaderClickHandler = () => this.emitRequestedItem();
        this.expanded = false;
        this.heading = undefined;
        this.description = undefined;
        this.iconStart = undefined;
        this.iconEnd = undefined;
        this.iconFlipRtl = undefined;
        this.iconPosition = undefined;
        this.iconType = undefined;
        this.accordionParent = undefined;
        this.scale = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectConditionalSlotComponent(this);
    }
    disconnectedCallback() {
        disconnectConditionalSlotComponent(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderActionsStart() {
        const { el } = this;
        return getSlotted(el, SLOTS$z.actionsStart) ? (hAsync("div", { class: CSS$1o.actionsStart }, hAsync("slot", { name: SLOTS$z.actionsStart }))) : null;
    }
    renderActionsEnd() {
        const { el } = this;
        return getSlotted(el, SLOTS$z.actionsEnd) ? (hAsync("div", { class: CSS$1o.actionsEnd }, hAsync("slot", { name: SLOTS$z.actionsEnd }))) : null;
    }
    render() {
        const { iconFlipRtl } = this;
        const dir = getElementDir(this.el);
        const iconStartEl = this.iconStart ? (hAsync("calcite-icon", { class: CSS$1o.iconStart, flipRtl: iconFlipRtl === "both" || iconFlipRtl === "start", icon: this.iconStart, key: "icon-start", scale: getIconScale(this.scale) })) : null;
        const iconEndEl = this.iconEnd ? (hAsync("calcite-icon", { class: CSS$1o.iconEnd, flipRtl: iconFlipRtl === "both" || iconFlipRtl === "end", icon: this.iconEnd, key: "icon-end", scale: getIconScale(this.scale) })) : null;
        const { description } = this;
        return (hAsync(Host, null, hAsync("div", { class: {
                [`icon-position--${this.iconPosition}`]: true,
                [`icon-type--${this.iconType}`]: true,
            } }, hAsync("div", { class: { [CSS$1o.header]: true, [CSS_UTILITY.rtl]: dir === "rtl" } }, this.renderActionsStart(), hAsync("div", { "aria-controls": IDS$2.section, "aria-expanded": toAriaBoolean(this.expanded), class: CSS$1o.headerContent, id: IDS$2.sectionToggle, onClick: this.itemHeaderClickHandler, role: "button", tabindex: "0" }, hAsync("div", { class: CSS$1o.headerContainer }, iconStartEl, hAsync("div", { class: CSS$1o.headerText }, hAsync("span", { class: CSS$1o.heading }, this.heading), description ? hAsync("span", { class: CSS$1o.description }, description) : null), iconEndEl), hAsync("calcite-icon", { class: CSS$1o.expandIcon, icon: this.iconType === "chevron"
                ? "chevronDown"
                : this.iconType === "caret"
                    ? "caretDown"
                    : this.expanded
                        ? "minus"
                        : "plus", scale: getIconScale(this.scale) })), this.renderActionsEnd()), hAsync("section", { "aria-labelledby": IDS$2.sectionToggle, class: CSS$1o.content, id: IDS$2.section }, hAsync("slot", null)))));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    keyDownHandler(event) {
        if (event.target === this.el) {
            switch (event.key) {
                case " ":
                case "Enter":
                    this.emitRequestedItem();
                    event.preventDefault();
                    break;
            }
        }
    }
    updateActiveItemOnChange(event) {
        const [accordion] = event.composedPath();
        const parent = closestElementCrossShadowBoundary(this.el, "calcite-accordion");
        if (accordion !== parent) {
            return;
        }
        this.determineActiveItem(parent.selectionMode, event.detail.requestedAccordionItem);
        event.stopPropagation();
    }
    accordionItemSyncHandler(event) {
        const [accordion] = event.composedPath();
        const accordionItem = this.el;
        // we sync with our accordion parent via event only if the item is wrapped within another component's shadow DOM,
        // otherwise, the accordion parent will sync the item directly
        const willBeSyncedByDirectParent = accordionItem.parentElement === accordion;
        if (willBeSyncedByDirectParent) {
            return;
        }
        const closestAccordionParent = closestElementCrossShadowBoundary(accordionItem, "calcite-accordion");
        if (accordion !== closestAccordionParent) {
            return;
        }
        accordionItem.iconPosition = closestAccordionParent.iconPosition;
        accordionItem.iconType = closestAccordionParent.iconType;
        accordionItem.scale = closestAccordionParent.scale;
        event.stopPropagation();
    }
    determineActiveItem(selectionMode, requestedItem) {
        switch (selectionMode) {
            case "multiple":
                if (this.el === requestedItem) {
                    this.expanded = !this.expanded;
                }
                break;
            case "single":
                this.expanded = this.el === requestedItem ? !this.expanded : false;
                break;
            case "single-persist":
                this.expanded = this.el === requestedItem;
                break;
        }
    }
    emitRequestedItem() {
        this.calciteInternalAccordionItemSelect.emit({
            requestedAccordionItem: this.el,
        });
    }
    get el() { return getElement(this); }
    static get style() { return accordionItemCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-accordion-item",
        "$members$": {
            "expanded": [1540],
            "heading": [1],
            "description": [1],
            "iconStart": [513, "icon-start"],
            "iconEnd": [513, "icon-end"],
            "iconFlipRtl": [513, "icon-flip-rtl"],
            "iconPosition": [1, "icon-position"],
            "iconType": [1, "icon-type"],
            "accordionParent": [16],
            "scale": [1]
        },
        "$listeners$": [[0, "keydown", "keyDownHandler"], [16, "calciteInternalAccordionChange", "updateActiveItemOnChange"], [4, "calciteInternalAccordionItemsSync", "accordionItemSyncHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["expanded", "expanded"], ["iconStart", "icon-start"], ["iconEnd", "icon-end"], ["iconFlipRtl", "icon-flip-rtl"]]
    }; }
}

function getUserAgentString() {
    {
        return "";
    }
}

// ⚠️ browser-sniffing is not a best practice and should be avoided ⚠️
const isFirefox = /firefox/i.test(getUserAgentString());
const disabledElementToParent = isFirefox
    ? new WeakMap()
    : null;
function interceptedClick() {
    const { disabled } = this;
    if (!disabled) {
        HTMLElement.prototype.click.call(this);
    }
}
function onPointerDown(event) {
    const interactiveElement = event.target;
    if (isFirefox && !disabledElementToParent.get(interactiveElement)) {
        return;
    }
    const { disabled } = interactiveElement;
    if (disabled) {
        // prevent click from moving focus on host
        event.preventDefault();
    }
}
const nonBubblingWhenDisabledMouseEvents = ["mousedown", "mouseup", "click"];
function onNonBubblingWhenDisabledMouseEvent(event) {
    const interactiveElement = event.target;
    if (isFirefox && !disabledElementToParent.get(interactiveElement)) {
        return;
    }
    // prevent disallowed mouse events from being emitted on the disabled host (per https://github.com/whatwg/html/issues/5886)
    // ⚠ we generally avoid stopping propagation of events, but this is needed to adhere to the intended spec changes above ⚠
    if (interactiveElement.disabled) {
        event.stopImmediatePropagation();
        event.preventDefault();
    }
}
const captureOnlyOptions = { capture: true };
/**
 * This helper updates the host element to prevent keyboard interaction on its subtree and sets the appropriate aria attribute for accessibility.
 *
 * This should be used in the `componentDidRender` lifecycle hook.
 *
 * **Notes**
 *
 * this util is not needed for simple components whose root element or elements are an interactive component (custom element or native control). For those cases, set the `disabled` props on the root components instead.
 * technically, users can override `tabindex` and restore keyboard navigation, but this will be considered user error
 *
 * @param component
 */
function updateHostInteraction(component) {
    if (component.disabled) {
        component.el.setAttribute("aria-disabled", "true");
        if (component.el.contains(document.activeElement)) {
            document.activeElement.blur();
        }
        blockInteraction(component);
        return;
    }
    restoreInteraction(component);
    component.el.removeAttribute("aria-disabled");
}
function blockInteraction(component) {
    component.el.click = interceptedClick;
    if (isFirefox) {
        const currentParent = getParentElement(component);
        const trackedParent = disabledElementToParent.get(component.el);
        if (trackedParent !== currentParent) {
            removeInteractionListeners(trackedParent);
            disabledElementToParent.set(component.el, currentParent);
        }
        addInteractionListeners(disabledElementToParent.get(component.el));
        return;
    }
    addInteractionListeners(component.el);
}
function addInteractionListeners(element) {
    if (!element) {
        // this early return path is only applicable to Firefox
        return;
    }
    element.addEventListener("pointerdown", onPointerDown, captureOnlyOptions);
    nonBubblingWhenDisabledMouseEvents.forEach((event) => element.addEventListener(event, onNonBubblingWhenDisabledMouseEvent, captureOnlyOptions));
}
function getParentElement(component) {
    return (component.el.parentElement || component.el); /* assume element is host if it has no parent when connected */
}
function restoreInteraction(component) {
    delete component.el.click; // fallback on HTMLElement.prototype.click
    if (isFirefox) {
        removeInteractionListeners(disabledElementToParent.get(component.el));
        disabledElementToParent.delete(component.el);
        return;
    }
    removeInteractionListeners(component.el);
}
function removeInteractionListeners(element) {
    if (!element) {
        // this early return path is only applicable to Firefox
        return;
    }
    element.removeEventListener("pointerdown", onPointerDown, captureOnlyOptions);
    nonBubblingWhenDisabledMouseEvents.forEach((event) => element.removeEventListener(event, onNonBubblingWhenDisabledMouseEvent, captureOnlyOptions));
}
/**
 * This utility helps disable components consistently in Firefox.
 *
 * It needs to be called in `connectedCallback` and is only needed for Firefox as it does not call capture event listeners before non-capture ones (see https://bugzilla.mozilla.org/show_bug.cgi?id=1731504).
 *
 * @param component
 */
function connectInteractive(component) {
    if (!component.disabled || !isFirefox) {
        return;
    }
    blockInteraction(component);
}
/**
 * This utility restores interactivity to disabled components consistently in Firefox.
 *
 * It needs to be called in `disconnectedCallback` and is only needed for Firefox as it does not call capture event listeners before non-capture ones (see https://bugzilla.mozilla.org/show_bug.cgi?id=1731504).
 *
 * @param component
 */
function disconnectInteractive(component) {
    if (!isFirefox) {
        return;
    }
    restoreInteraction(component);
}
const CSS$1n = {
    container: "interaction-container",
};
function InteractiveContainer({ disabled }, children) {
    return (hAsync("div", { class: CSS$1n.container, inert: disabled }, ...children));
}

const resolveMap = new WeakMap();
const promiseMap = new WeakMap();
/**
 * This helper util sets up the component for the ability to know when the component has been loaded.
 *
 * This should be used in the `componentWillLoad` lifecycle hook.
 *
 * ```
 * componentWillLoad(): void {
 *   setUpLoadableComponent(this);
 * }
 * ```
 *
 * @param component
 */
function setUpLoadableComponent(component) {
    promiseMap.set(component, new Promise((resolve) => resolveMap.set(component, resolve)));
}
/**
 * This helper util lets the loadable component know that it is now loaded.
 *
 * This should be used in the `componentDidLoad` lifecycle hook.
 *
 * ```
 * componentDidLoad(): void {
 *   setComponentLoaded(this);
 * }
 * ```
 *
 * @param component
 */
function setComponentLoaded(component) {
    resolveMap.get(component)();
}
/**
 * This helper util can be used to ensure a component has been loaded (The "componentDidLoad" Stencil lifecycle method has been called).
 *
 * Requires requires `LoadableComponent` to be implemented.
 *
 * A component developer can await this method before proceeding with any logic that requires a component to be loaded first.
 *
 * ```
 * async myMethod(): Promise<void> {
 *   await componentLoaded(this);
 * }
 * ```
 *
 * @param component
 * @returns Promise<void>
 */
function componentLoaded(component) {
    return promiseMap.get(component);
}
/**
 * This helper util can be used to ensuring the component is loaded and rendered by the browser (The "componentDidLoad" Stencil lifecycle method has been called and any internal elements are focusable).
 *
 * Requires requires `LoadableComponent` to be implemented.
 *
 * A component developer can await this method before proceeding with any logic that requires a component to be loaded first and then an internal element be focused.
 *
 * ```
 * async setFocus(): Promise<void> {
 *   await componentFocusable(this);
 *   this.internalElement?.focus();
 * }
 * ```
 *
 * @param component
 * @returns Promise<void>
 */
async function componentFocusable(component) {
    await componentLoaded(component);
    {
        return;
    }
}

function isActivationKey(key) {
    return key === "Enter" || key === " ";
}
const numberKeys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];

const unnecessaryDecimal = new RegExp(`\\${"."}(0+)?$`);
const trailingZeros = new RegExp("0+$");
// adopted from https://stackoverflow.com/a/66939244
class BigDecimal {
    constructor(input) {
        if (input instanceof BigDecimal) {
            return input;
        }
        const [integers, decimals] = expandExponentialNumberString(input).split(".").concat("");
        this.value =
            BigInt(integers + decimals.padEnd(BigDecimal.DECIMALS, "0").slice(0, BigDecimal.DECIMALS)) +
                BigInt(BigDecimal.ROUNDED && decimals[BigDecimal.DECIMALS] >= "5");
        this.isNegative = input.charAt(0) === "-";
    }
    getIntegersAndDecimals() {
        const s = this.value
            .toString()
            .replace("-", "")
            .padStart(BigDecimal.DECIMALS + 1, "0");
        const integers = s.slice(0, -BigDecimal.DECIMALS);
        const decimals = s.slice(-BigDecimal.DECIMALS).replace(trailingZeros, "");
        return { integers, decimals };
    }
    toString() {
        const { integers, decimals } = this.getIntegersAndDecimals();
        return `${this.isNegative ? "-" : ""}${integers}${decimals.length ? "." + decimals : ""}`;
    }
    formatToParts(formatter) {
        const { integers, decimals } = this.getIntegersAndDecimals();
        const parts = formatter.numberFormatter.formatToParts(BigInt(integers));
        this.isNegative && parts.unshift({ type: "minusSign", value: formatter.minusSign });
        if (decimals.length) {
            parts.push({ type: "decimal", value: formatter.decimal });
            decimals.split("").forEach((char) => parts.push({ type: "fraction", value: char }));
        }
        return parts;
    }
    format(formatter) {
        const { integers, decimals } = this.getIntegersAndDecimals();
        const integersFormatted = `${this.isNegative ? formatter.minusSign : ""}${formatter.numberFormatter.format(BigInt(integers))}`;
        const decimalsFormatted = decimals.length
            ? `${formatter.decimal}${decimals
                .split("")
                .map((char) => formatter.numberFormatter.format(Number(char)))
                .join("")}`
            : "";
        return `${integersFormatted}${decimalsFormatted}`;
    }
    add(n) {
        return BigDecimal.fromBigInt(this.value + new BigDecimal(n).value);
    }
    subtract(n) {
        return BigDecimal.fromBigInt(this.value - new BigDecimal(n).value);
    }
    multiply(n) {
        return BigDecimal._divRound(this.value * new BigDecimal(n).value, BigDecimal.SHIFT);
    }
    divide(n) {
        return BigDecimal._divRound(this.value * BigDecimal.SHIFT, new BigDecimal(n).value);
    }
}
// Configuration: constants
BigDecimal.DECIMALS = 100; // number of decimals on all instances
BigDecimal.ROUNDED = true; // numbers are truncated (false) or rounded (true)
BigDecimal.SHIFT = BigInt("1" + "0".repeat(BigDecimal.DECIMALS)); // derived constant
BigDecimal._divRound = (dividend, divisor) => BigDecimal.fromBigInt(dividend / divisor + (BigDecimal.ROUNDED ? ((dividend * BigInt(2)) / divisor) % BigInt(2) : BigInt(0)));
BigDecimal.fromBigInt = (bigint) => Object.assign(Object.create(BigDecimal.prototype), { value: bigint, isNegative: bigint < BigInt(0) });
function isValidNumber(numberString) {
    return !(!numberString || isNaN(Number(numberString)));
}
function parseNumberString(numberString) {
    if (!numberString || !stringContainsNumbers(numberString)) {
        return "";
    }
    return sanitizeExponentialNumberString(numberString, (nonExpoNumString) => {
        let containsDecimal = false;
        const result = nonExpoNumString
            .split("")
            .filter((value, i) => {
            if (value.match(/\./g) && !containsDecimal) {
                containsDecimal = true;
                return true;
            }
            if (value.match(/\-/g) && i === 0) {
                return true;
            }
            return numberKeys.includes(value);
        })
            .join("");
        return isValidNumber(result) ? new BigDecimal(result).toString() : "";
    });
}
// regex for number sanitization
const allLeadingZerosOptionallyNegative = /^([-0])0+(?=\d)/;
const decimalOnlyAtEndOfString = /(?!^\.)\.$/;
const allHyphensExceptTheStart = /(?!^-)-/g;
const isNegativeDecimalOnlyZeros = /^-\b0\b\.?0*$/;
const hasTrailingDecimalZeros = /0*$/;
const sanitizeNumberString = (numberString) => sanitizeExponentialNumberString(numberString, (nonExpoNumString) => {
    const sanitizedValue = nonExpoNumString
        .replace(allHyphensExceptTheStart, "")
        .replace(decimalOnlyAtEndOfString, "")
        .replace(allLeadingZerosOptionallyNegative, "$1");
    return isValidNumber(sanitizedValue)
        ? isNegativeDecimalOnlyZeros.test(sanitizedValue)
            ? sanitizedValue
            : getBigDecimalAsString(sanitizedValue)
        : nonExpoNumString;
});
function getBigDecimalAsString(sanitizedValue) {
    const sanitizedValueDecimals = sanitizedValue.split(".")[1];
    const value = new BigDecimal(sanitizedValue).toString();
    const [bigDecimalValueInteger, bigDecimalValueDecimals] = value.split(".");
    return sanitizedValueDecimals && bigDecimalValueDecimals !== sanitizedValueDecimals
        ? `${bigDecimalValueInteger}.${sanitizedValueDecimals}`
        : value;
}
function sanitizeExponentialNumberString(numberString, func) {
    if (!numberString) {
        return numberString;
    }
    const firstE = numberString.toLowerCase().indexOf("e") + 1;
    if (!firstE) {
        return func(numberString);
    }
    return numberString
        .replace(/[eE]*$/g, "")
        .substring(0, firstE)
        .concat(numberString.slice(firstE).replace(/[eE]/g, ""))
        .split(/[eE]/)
        .map((section, i) => (i === 1 ? func(section.replace(/\./g, "")) : func(section)))
        .join("e")
        .replace(/^e/, "1e");
}
/**
 * Converts an exponential notation numberString into decimal notation.
 * BigInt doesn't support exponential notation, so this is required to maintain precision
 *
 * @param {string} numberString - pre-validated exponential or decimal number
 * @returns {string} numberString in decimal notation
 */
function expandExponentialNumberString(numberString) {
    const exponentialParts = numberString.split(/[eE]/);
    if (exponentialParts.length === 1) {
        return numberString;
    }
    const number = +numberString;
    if (Number.isSafeInteger(number)) {
        return `${number}`;
    }
    const isNegative = numberString.charAt(0) === "-";
    const magnitude = +exponentialParts[1];
    const decimalParts = exponentialParts[0].split(".");
    const integers = (isNegative ? decimalParts[0].substring(1) : decimalParts[0]) || "";
    const decimals = decimalParts[1] || "";
    const shiftDecimalLeft = (integers, magnitude) => {
        const magnitudeDelta = Math.abs(magnitude) - integers.length;
        const leftPaddedZeros = magnitudeDelta > 0 ? `${"0".repeat(magnitudeDelta)}${integers}` : integers;
        const shiftedDecimal = `${leftPaddedZeros.slice(0, magnitude)}${"."}${leftPaddedZeros.slice(magnitude)}`;
        return shiftedDecimal;
    };
    const shiftDecimalRight = (decimals, magnitude) => {
        const rightPaddedZeros = magnitude > decimals.length ? `${decimals}${"0".repeat(magnitude - decimals.length)}` : decimals;
        const shiftedDecimal = `${rightPaddedZeros.slice(0, magnitude)}${"."}${rightPaddedZeros.slice(magnitude)}`;
        return shiftedDecimal;
    };
    const expandedNumberString = magnitude > 0
        ? `${integers}${shiftDecimalRight(decimals, magnitude)}`
        : `${shiftDecimalLeft(integers, magnitude)}${decimals}`;
    return `${isNegative ? "-" : ""}${expandedNumberString.charAt(0) === "." ? "0" : ""}${expandedNumberString
        .replace(unnecessaryDecimal, "")
        .replace(allLeadingZerosOptionallyNegative, "")}`;
}
function stringContainsNumbers(string) {
    return numberKeys.some((number) => string.includes(number));
}
/**
 * Adds localized trailing decimals zero values to the number string.
 * BigInt conversion to string removes the trailing decimal zero values (Ex: 1.000 is returned as 1). This method helps adding them back.
 *
 * @param {string} localizedValue - localized number string value
 * @param {string} value - current value in the input field
 * @param {NumberStringFormat} formatter - numberStringFormatter instance to localize the number value
 * @returns {string} localized number string value
 */
function addLocalizedTrailingDecimalZeros(localizedValue, value, formatter) {
    const decimals = value.split(".")[1];
    if (decimals) {
        const trailingDecimalZeros = decimals.match(hasTrailingDecimalZeros)[0];
        if (trailingDecimalZeros &&
            formatter.delocalize(localizedValue).length !== value.length &&
            decimals.indexOf("e") === -1) {
            const decimalSeparator = formatter.decimal;
            localizedValue = !localizedValue.includes(decimalSeparator)
                ? `${localizedValue}${decimalSeparator}`
                : localizedValue;
            return localizedValue.padEnd(localizedValue.length + trailingDecimalZeros.length, formatter.localize("0"));
        }
    }
    return localizedValue;
}

const defaultLocale = "en";
const t9nLocales = [
    "ar",
    "bg",
    "bs",
    "ca",
    "cs",
    "da",
    "de",
    "el",
    defaultLocale,
    "es",
    "et",
    "fi",
    "fr",
    "he",
    "hr",
    "hu",
    "id",
    "it",
    "ja",
    "ko",
    "lt",
    "lv",
    "no",
    "nl",
    "pl",
    "pt-BR",
    "pt-PT",
    "ro",
    "ru",
    "sk",
    "sl",
    "sr",
    "sv",
    "th",
    "tr",
    "uk",
    "vi",
    "zh-CN",
    "zh-HK",
    "zh-TW",
];
const locales = [
    "ar",
    "bg",
    "bs",
    "ca",
    "cs",
    "da",
    "de",
    "de-AT",
    "de-CH",
    "el",
    defaultLocale,
    "en-AU",
    "en-CA",
    "en-GB",
    "es",
    "es-MX",
    "et",
    "fi",
    "fr",
    "fr-CH",
    "he",
    "hi",
    "hr",
    "hu",
    "id",
    "it",
    "it-CH",
    "ja",
    "ko",
    "lt",
    "lv",
    "mk",
    "no",
    "nl",
    "pl",
    "pt",
    "pt-PT",
    "ro",
    "ru",
    "sk",
    "sl",
    "sr",
    "sv",
    "th",
    "tr",
    "uk",
    "vi",
    "zh-CN",
    "zh-HK",
    "zh-TW",
];
const numberingSystems = ["arab", "arabext", "latn"];
const isNumberingSystemSupported = (numberingSystem) => numberingSystems.includes(numberingSystem);
const browserNumberingSystem = new Intl.NumberFormat().resolvedOptions().numberingSystem;
// for consistent browser behavior, we normalize numberingSystem to prevent the browser-inferred value
// see https://github.com/Esri/calcite-design-system/issues/3079#issuecomment-1168964195 for more info
const defaultNumberingSystem = browserNumberingSystem === "arab" || !isNumberingSystemSupported(browserNumberingSystem)
    ? "latn"
    : browserNumberingSystem;
const getSupportedNumberingSystem = (numberingSystem) => isNumberingSystemSupported(numberingSystem) ? numberingSystem : defaultNumberingSystem;
/**
 * Gets the locale that best matches the context.
 *
 * @param locale – the BCP 47 locale code
 * @param context - specifies whether the locale code should match in the context of CLDR or T9N (translation)
 */
function getSupportedLocale(locale, context = "cldr") {
    const contextualLocales = context === "cldr" ? locales : t9nLocales;
    if (!locale) {
        return defaultLocale;
    }
    if (contextualLocales.includes(locale)) {
        return locale;
    }
    locale = locale.toLowerCase();
    // we support both 'nb' and 'no' (BCP 47) for Norwegian but only `no` has corresponding bundle
    if (locale === "nb") {
        return "no";
    }
    // we use `pt-BR` as it will have the same translations as `pt`, which has no corresponding bundle
    if (context === "t9n" && locale === "pt") {
        return "pt-BR";
    }
    if (locale.includes("-")) {
        locale = locale.replace(/(\w+)-(\w+)/, (_match, language, region) => `${language}-${region.toUpperCase()}`);
        if (!contextualLocales.includes(locale)) {
            locale = locale.split("-")[0];
        }
    }
    // we can `zh-CN` as base translation for chinese locales which has no corresponding bundle.
    if (locale === "zh") {
        return "zh-CN";
    }
    if (!contextualLocales.includes(locale)) {
        console.warn(`Translations for the "${locale}" locale are not available and will fall back to the default, English (en).`);
        return defaultLocale;
    }
    return locale;
}
const connectedComponents = new Set();
/**
 * This utility sets up internals for messages support.
 *
 * It needs to be called in `connectedCallback` before any logic that depends on locale
 *
 * @param component
 */
function connectLocalized(component) {
    updateEffectiveLocale(component);
    if (connectedComponents.size === 0) {
        mutationObserver?.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ["lang"],
            subtree: true,
        });
    }
    connectedComponents.add(component);
}
/**
 * This is only exported for components that implemented the now deprecated `locale` prop.
 *
 * Do not use this utils for new components.
 *
 * @param component
 */
function updateEffectiveLocale(component) {
    component.effectiveLocale = getLocale(component);
}
/**
 * This utility tears down internals for messages support.
 *
 * It needs to be called in `disconnectedCallback`
 *
 * @param component
 */
function disconnectLocalized(component) {
    connectedComponents.delete(component);
    if (connectedComponents.size === 0) {
        mutationObserver.disconnect();
    }
}
const mutationObserver = createObserver();
/**
 * This util helps resolve a component's locale.
 * It will also fall back on the deprecated `locale` if a component implemented this previously.
 *
 * @param component
 */
function getLocale(component) {
    return (component.el.lang ||
        closestElementCrossShadowBoundary(component.el, "[lang]")?.lang ||
        document.documentElement.lang ||
        defaultLocale);
}
/**
 * This util formats and parses numbers for localization
 */
class NumberStringFormat {
    constructor() {
        this.delocalize = (numberString) => 
        // For performance, (de)localization is skipped if the formatter isn't initialized.
        // In order to localize/delocalize, e.g. when lang/numberingSystem props are not default values,
        // `numberFormatOptions` must be set in a component to create and cache the formatter.
        this._numberFormatOptions
            ? sanitizeExponentialNumberString(numberString, (nonExpoNumString) => nonExpoNumString
                .replace(new RegExp(`[${this._minusSign}]`, "g"), "-")
                .replace(new RegExp(`[${this._group}]`, "g"), "")
                .replace(new RegExp(`[${this._decimal}]`, "g"), ".")
                .replace(new RegExp(`[${this._digits.join("")}]`, "g"), this._getDigitIndex))
            : numberString;
        this.localize = (numberString) => this._numberFormatOptions
            ? sanitizeExponentialNumberString(numberString, (nonExpoNumString) => isValidNumber(nonExpoNumString.trim())
                ? new BigDecimal(nonExpoNumString.trim())
                    .format(this)
                    .replace(new RegExp(`[${this._actualGroup}]`, "g"), this._group)
                : nonExpoNumString)
            : numberString;
    }
    get group() {
        return this._group;
    }
    get decimal() {
        return this._decimal;
    }
    get minusSign() {
        return this._minusSign;
    }
    get digits() {
        return this._digits;
    }
    get numberFormatter() {
        return this._numberFormatter;
    }
    get numberFormatOptions() {
        return this._numberFormatOptions;
    }
    /**
     * numberFormatOptions needs to be set before localize/delocalize is called to ensure the options are up to date
     */
    set numberFormatOptions(options) {
        options.locale = getSupportedLocale(options?.locale);
        options.numberingSystem = getSupportedNumberingSystem(options?.numberingSystem);
        if (
        // No need to create the formatter if `locale` and `numberingSystem`
        // are the default values and `numberFormatOptions` has not been set
        (!this._numberFormatOptions &&
            options.locale === defaultLocale &&
            options.numberingSystem === defaultNumberingSystem &&
            // don't skip initialization if any options besides locale/numberingSystem are set
            Object.keys(options).length === 2) ||
            // cache formatter by only recreating when options change
            JSON.stringify(this._numberFormatOptions) === JSON.stringify(options)) {
            return;
        }
        this._numberFormatOptions = options;
        this._numberFormatter = new Intl.NumberFormat(this._numberFormatOptions.locale, this._numberFormatOptions);
        this._digits = [
            ...new Intl.NumberFormat(this._numberFormatOptions.locale, {
                useGrouping: false,
                numberingSystem: this._numberFormatOptions.numberingSystem,
            }).format(9876543210),
        ].reverse();
        const index = new Map(this._digits.map((d, i) => [d, i]));
        // numberingSystem is parsed to return consistent decimal separator across browsers.
        const parts = new Intl.NumberFormat(this._numberFormatOptions.locale, {
            numberingSystem: this._numberFormatOptions.numberingSystem,
        }).formatToParts(-12345678.9);
        this._actualGroup = parts.find((d) => d.type === "group").value;
        // change whitespace group separators to the unicode non-breaking space (nbsp)
        this._group = this._actualGroup.trim().length === 0 || this._actualGroup == " " ? "\u00A0" : this._actualGroup;
        this._decimal = parts.find((d) => d.type === "decimal").value;
        this._minusSign = parts.find((d) => d.type === "minusSign").value;
        this._getDigitIndex = (d) => index.get(d);
    }
}
const numberStringFormatter = new NumberStringFormat();
/**
 * Exported for testing purposes only.
 *
 * @internal
 */
let dateTimeFormatCache;
/**
 * Used to ensure all cached formats are for the same locale.
 *
 * @internal
 */
let previousLocaleUsedForCaching;
/**
 * Generates a cache key for date time format lookups.
 *
 * @internal
 */
function buildDateTimeFormatCacheKey(options = {}) {
    return Object.entries(options)
        .sort(([key1], [key2]) => key1.localeCompare(key2))
        .map((keyValue) => `${keyValue[0]}-${keyValue[1]}`)
        .flat()
        .join(":");
}
/**
 * Returns an instance of Intl.DateTimeFormat and reuses it if requested with the same locale and options.
 *
 * **Note**: the cache will be cleared if a different locale is provided
 *
 * @internal
 */
function getDateTimeFormat(locale, options) {
    locale = getSupportedLocale(locale);
    if (!dateTimeFormatCache) {
        dateTimeFormatCache = new Map();
    }
    if (previousLocaleUsedForCaching !== locale) {
        dateTimeFormatCache.clear();
        previousLocaleUsedForCaching = locale;
    }
    const key = buildDateTimeFormatCacheKey(options);
    const cached = dateTimeFormatCache.get(key);
    if (cached) {
        return cached;
    }
    const format = new Intl.DateTimeFormat(locale, options);
    dateTimeFormatCache.set(key, format);
    return format;
}

function mergeMessages(component) {
    component.messages = {
        ...component.defaultMessages,
        ...component.messageOverrides,
    };
}
/**
 * This utility sets up the messages used by the component. It should be awaited in the `componentWillLoad` lifecycle hook.
 *
 * @param component
 */
async function setUpMessages(component) {
    component.defaultMessages = await fetchMessages();
    mergeMessages(component);
}
async function fetchMessages(component, lang) {
    {
        return {};
    }
}
/**
 * This utility must be set up for the component to update its default message bundle if the locale changes.
 *
 * It can be set up in **either** of the following ways:
 *
 * 1. called from `LocalizedComponent`'s `onLocaleChange` method or
 * 2. called from a watcher configured to watch `LocalizedComponent`'s `effectiveLocale` prop
 *
 * @param component
 * @param lang
 */
async function updateMessages(component, lang) {
    component.defaultMessages = await fetchMessages();
    mergeMessages(component);
}
/**
 * This utility sets up internals for messages support.
 *
 * It needs to be called in `connectedCallback`
 *
 * **Note**: this must be called after `LocalizedComponent`'s `connectLocalized` method.
 *
 * @param component
 */
function connectMessages(component) {
    component.onMessagesChange = defaultOnMessagesChange;
}
/**
 * This utility tears down internals for messages support.
 *
 * It needs to be called in `disconnectedCallback`
 *
 * @param component
 */
function disconnectMessages(component) {
    component.onMessagesChange = undefined;
}
function defaultOnMessagesChange() {
    mergeMessages(this);
}

const CSS$1m = {
    button: "button",
    buttonTextVisible: "button--text-visible",
    buttonCompact: "button--compact",
    indicatorText: "indicator-text",
    iconContainer: "icon-container",
    slotContainer: "slot-container",
    slotContainerHidden: "slot-container--hidden",
    textContainer: "text-container",
    textContainerVisible: "text-container--visible",
    indicatorWithIcon: "indicator-with-icon",
    indicatorWithoutIcon: "indicator-without-icon",
};
const SLOTS$y = {
    tooltip: "tooltip",
};

const actionCss = "/*!@:host*/.sc-calcite-action-h{box-sizing:border-box;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host **/.sc-calcite-action-h *.sc-calcite-action{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-calcite-action-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-action-h *.sc-calcite-action,.sc-calcite-action-h[disabled].sc-calcite-action-s>*,.sc-calcite-action-h[disabled] .sc-calcite-action-s>*{pointer-events:none}/*!@:host*/.sc-calcite-action-h{display:flex;background-color:transparent;--calcite-action-indicator-color:var(--calcite-color-brand);--calcite-action-color-transparent-hover:var(--calcite-color-transparent-hover);--calcite-action-color-transparent-press:var(--calcite-color-transparent-press)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-action-h[disabled] .sc-calcite-action-s>[calcite-hydrated][disabled],[disabled].sc-calcite-action-h [calcite-hydrated][disabled].sc-calcite-action{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-action{display:contents}/*!@.button*/.button.sc-calcite-action{position:relative;margin:0px;display:flex;inline-size:auto;cursor:pointer;align-items:center;justify-content:flex-start;border-style:none;background-color:var(--calcite-color-foreground-1);fill:var(--calcite-color-text-3);font-family:var(--calcite-sans-family);font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-3);outline-color:transparent;text-align:unset;flex:1 0 auto}/*!@.button:hover*/.button.sc-calcite-action:hover{background-color:var(--calcite-color-foreground-2);fill:var(--calcite-color-text-1);color:var(--calcite-color-text-1)}/*!@.button:focus*/.button.sc-calcite-action:focus{background-color:var(--calcite-color-foreground-2);fill:var(--calcite-color-text-1);color:var(--calcite-color-text-1);outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.button:active*/.button.sc-calcite-action:active{background-color:var(--calcite-color-foreground-3)}/*!@.button .icon-container*/.button.sc-calcite-action .icon-container.sc-calcite-action{pointer-events:none;margin:0px;display:flex;align-items:center;justify-content:center;min-inline-size:1rem;min-block-size:1rem}/*!@.button .text-container*/.button.sc-calcite-action .text-container.sc-calcite-action{margin:0px;inline-size:0px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;line-height:1.5rem;opacity:0;transition-property:opacity;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-property:margin;transition-property:inline-size}/*!@.button .text-container--visible*/.button.sc-calcite-action .text-container--visible.sc-calcite-action{inline-size:auto;flex:1 1 auto;opacity:1}/*!@:host([data-active]) .button*/[data-active].sc-calcite-action-h .button.sc-calcite-action{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([scale=s]) .button*/[scale=s].sc-calcite-action-h .button.sc-calcite-action{padding-inline:0.5rem;padding-block:0.25rem;font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-normal)}/*!@:host([scale=s]) .button--text-visible .icon-container*/[scale=s].sc-calcite-action-h .button--text-visible.sc-calcite-action .icon-container.sc-calcite-action{margin-inline-end:0.5rem}/*!@:host([scale=m]) .button*/[scale=m].sc-calcite-action-h .button.sc-calcite-action{padding-inline:1rem;padding-block:0.75rem;font-size:var(--calcite-font-size--1);line-height:1rem;font-weight:var(--calcite-font-weight-normal)}/*!@:host([scale=m]) .button--text-visible .icon-container*/[scale=m].sc-calcite-action-h .button--text-visible.sc-calcite-action .icon-container.sc-calcite-action{margin-inline-end:0.75rem}/*!@:host([scale=l]) .button*/[scale=l].sc-calcite-action-h .button.sc-calcite-action{padding:1.25rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;font-weight:var(--calcite-font-weight-normal)}/*!@:host([scale=l]) .button--text-visible .icon-container*/[scale=l].sc-calcite-action-h .button--text-visible.sc-calcite-action .icon-container.sc-calcite-action{margin-inline-end:1rem}/*!@:host([alignment=center]) .button*/[alignment=center].sc-calcite-action-h .button.sc-calcite-action{justify-content:center}/*!@:host([alignment=end]) .button*/[alignment=end].sc-calcite-action-h .button.sc-calcite-action{justify-content:flex-end}/*!@:host([alignment=center]) .button .text-container--visible,\n:host([alignment=end]) .button .text-container--visible*/[alignment=center].sc-calcite-action-h .button.sc-calcite-action .text-container--visible.sc-calcite-action,[alignment=end].sc-calcite-action-h .button.sc-calcite-action .text-container--visible.sc-calcite-action{flex:0 1 auto}/*!@:host([scale=s][compact]) .button,\n:host([scale=m][compact]) .button,\n:host([scale=l][compact]) .button*/[scale=s][compact].sc-calcite-action-h .button.sc-calcite-action,[scale=m][compact].sc-calcite-action-h .button.sc-calcite-action,[scale=l][compact].sc-calcite-action-h .button.sc-calcite-action{padding-inline:0px}/*!@.slot-container*/.slot-container.sc-calcite-action{display:flex}/*!@.slot-container--hidden*/.slot-container--hidden.sc-calcite-action{display:none}/*!@.button--text-visible*/.button--text-visible.sc-calcite-action{inline-size:100%}/*!@:host([active]) .button,\n:host([active]) .button:hover,\n:host([active]) .button:focus,\n:host([active][loading]) .button*/[active].sc-calcite-action-h .button.sc-calcite-action,[active].sc-calcite-action-h .button.sc-calcite-action:hover,[active].sc-calcite-action-h .button.sc-calcite-action:focus,[active][loading].sc-calcite-action-h .button.sc-calcite-action{background-color:var(--calcite-color-foreground-3);fill:var(--calcite-color-text-1);color:var(--calcite-color-text-1)}/*!@:host([active]) .button:active*/[active].sc-calcite-action-h .button.sc-calcite-action:active{background-color:var(--calcite-color-foreground-1)}/*!@:host([appearance=transparent]) .button*/[appearance=transparent].sc-calcite-action-h .button.sc-calcite-action{background-color:transparent}/*!@:host([appearance=transparent][active]) .button,\n:host([appearance=transparent]) .button:hover,\n:host([appearance=transparent]) .button:focus*/[appearance=transparent][active].sc-calcite-action-h .button.sc-calcite-action,[appearance=transparent].sc-calcite-action-h .button.sc-calcite-action:hover,[appearance=transparent].sc-calcite-action-h .button.sc-calcite-action:focus{background-color:var(--calcite-action-color-transparent-hover)}/*!@:host([appearance=transparent]) .button:active*/[appearance=transparent].sc-calcite-action-h .button.sc-calcite-action:active{background-color:var(--calcite-action-color-transparent-press)}/*!@:host([appearance=transparent][disabled]) .button*/[appearance=transparent][disabled].sc-calcite-action-h .button.sc-calcite-action{background-color:transparent}/*!@:host([loading][appearance=solid]) .button,\n:host([loading][appearance=solid]) .button:hover,\n:host([loading][appearance=solid]) .button:focus*/[loading][appearance=solid].sc-calcite-action-h .button.sc-calcite-action,[loading][appearance=solid].sc-calcite-action-h .button.sc-calcite-action:hover,[loading][appearance=solid].sc-calcite-action-h .button.sc-calcite-action:focus{background-color:var(--calcite-color-foreground-1)}/*!@:host([loading][appearance=solid]) .button .text-container,\n:host([loading][appearance=solid]) .button:hover .text-container,\n:host([loading][appearance=solid]) .button:focus .text-container*/[loading][appearance=solid].sc-calcite-action-h .button.sc-calcite-action .text-container.sc-calcite-action,[loading][appearance=solid].sc-calcite-action-h .button.sc-calcite-action:hover .text-container.sc-calcite-action,[loading][appearance=solid].sc-calcite-action-h .button.sc-calcite-action:focus .text-container.sc-calcite-action{opacity:var(--calcite-opacity-disabled)}/*!@:host([loading]) calcite-loader[inline]*/[loading].sc-calcite-action-h calcite-loader[inline].sc-calcite-action{color:var(--calcite-color-text-3);margin-inline-end:0px}/*!@:host([disabled]) .button,\n:host([disabled]) .button:hover,\n:host([disabled]) .button:focus*/[disabled].sc-calcite-action-h .button.sc-calcite-action,[disabled].sc-calcite-action-h .button.sc-calcite-action:hover,[disabled].sc-calcite-action-h .button.sc-calcite-action:focus{cursor:default;background-color:var(--calcite-color-foreground-1);opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled][active]) .button,\n:host([disabled][active]) .button:hover,\n:host([disabled][active]) .button:focus*/[disabled][active].sc-calcite-action-h .button.sc-calcite-action,[disabled][active].sc-calcite-action-h .button.sc-calcite-action:hover,[disabled][active].sc-calcite-action-h .button.sc-calcite-action:focus{background-color:var(--calcite-color-foreground-3);opacity:var(--calcite-opacity-disabled)}/*!@:host([appearance=transparent]) .button*/[appearance=transparent].sc-calcite-action-h .button.sc-calcite-action{background-color:transparent;transition-property:box-shadow;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}/*!@.indicator-with-icon*/.indicator-with-icon.sc-calcite-action{position:relative}/*!@.indicator-with-icon::after*/.indicator-with-icon.sc-calcite-action::after{content:\"\";position:absolute;block-size:0.5rem;inline-size:0.5rem;border-radius:9999px;inset-block-end:-0.275rem;inset-inline-end:-0.275rem;background-color:var(--calcite-action-indicator-color)}/*!@.indicator-without-icon*/.indicator-without-icon.sc-calcite-action{margin-inline:0.25rem;inline-size:1rem;position:relative}/*!@.indicator-without-icon::after*/.indicator-without-icon.sc-calcite-action::after{content:\"\";position:absolute;block-size:0.5rem;inline-size:0.5rem;border-radius:9999px;inset-block-end:-0.275rem;inset-inline-end:-0.275rem;background-color:var(--calcite-action-indicator-color)}/*!@.indicator-text*/.indicator-text.sc-calcite-action{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}/*!@:host([hidden])*/[hidden].sc-calcite-action-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-action{display:none}";

/**
 * @slot - A slot for adding a `calcite-icon`.
 * @slot tooltip - A slot for adding a `calcite-tooltip`.
 */
class Action {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.mutationObserver = createObserver();
        this.guid = `calcite-action-${guid()}`;
        this.indicatorId = `${this.guid}-indicator`;
        this.buttonId = `${this.guid}-button`;
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.handleTooltipSlotChange = (event) => {
            const tooltips = event.target
                .assignedElements({
                flatten: true,
            })
                .filter((el) => el?.matches("calcite-tooltip"));
            const tooltip = tooltips[0];
            if (tooltip) {
                tooltip.referenceElement = this.buttonEl;
            }
        };
        this.active = false;
        this.alignment = undefined;
        this.appearance = "solid";
        this.compact = false;
        this.disabled = false;
        this.icon = undefined;
        this.iconFlipRtl = false;
        this.indicator = false;
        this.label = undefined;
        this.loading = false;
        this.scale = "m";
        this.text = undefined;
        this.textEnabled = false;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.effectiveLocale = "";
        this.defaultMessages = undefined;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        this.mutationObserver?.disconnect();
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Methods
    //
    // --------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.buttonEl?.focus();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderTextContainer() {
        const { text, textEnabled } = this;
        const textContainerClasses = {
            [CSS$1m.textContainer]: true,
            [CSS$1m.textContainerVisible]: textEnabled,
        };
        return text ? (hAsync("div", { class: textContainerClasses, key: "text-container" }, text)) : null;
    }
    renderIndicatorText() {
        const { indicator, messages, indicatorId, buttonId } = this;
        return (hAsync("div", { "aria-labelledby": buttonId, "aria-live": "polite", class: CSS$1m.indicatorText, id: indicatorId, role: "region" }, indicator ? messages.indicator : null));
    }
    renderIconContainer() {
        const { loading, icon, scale, el, iconFlipRtl, indicator } = this;
        const loaderScale = scale === "l" ? "l" : "m";
        const calciteLoaderNode = loading ? (hAsync("calcite-loader", { inline: true, label: this.messages.loading, scale: loaderScale })) : null;
        const calciteIconNode = icon ? (hAsync("calcite-icon", { class: { [CSS$1m.indicatorWithIcon]: indicator }, flipRtl: iconFlipRtl, icon: icon, scale: getIconScale(this.scale) })) : null;
        const iconNode = calciteLoaderNode || calciteIconNode;
        const hasIconToDisplay = iconNode || el.children?.length;
        const slotContainerNode = (hAsync("div", { class: {
                [CSS$1m.slotContainer]: true,
                [CSS$1m.slotContainerHidden]: loading,
            } }, hAsync("slot", null)));
        return hasIconToDisplay ? (hAsync("div", { "aria-hidden": "true", class: CSS$1m.iconContainer, key: "icon-container" }, iconNode, slotContainerNode)) : null;
    }
    render() {
        const { active, compact, disabled, icon, loading, textEnabled, label, text, indicator, indicatorId, buttonId, messages, } = this;
        const ariaLabel = `${label || text}${indicator ? ` (${messages.indicator})` : ""}`;
        const buttonClasses = {
            [CSS$1m.button]: true,
            [CSS$1m.buttonTextVisible]: textEnabled,
            [CSS$1m.buttonCompact]: compact,
        };
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: disabled }, hAsync("button", { "aria-busy": toAriaBoolean(loading), "aria-controls": indicator ? indicatorId : null, "aria-disabled": toAriaBoolean(disabled), "aria-label": ariaLabel, "aria-pressed": toAriaBoolean(active), class: buttonClasses, disabled: disabled, id: buttonId,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (buttonEl) => (this.buttonEl = buttonEl) }, this.renderIconContainer(), this.renderTextContainer(), !icon && indicator && hAsync("div", { class: CSS$1m.indicatorWithoutIcon, key: "indicator-no-icon" })), hAsync("slot", { name: SLOTS$y.tooltip, onSlotchange: this.handleTooltipSlotChange }), this.renderIndicatorText())));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return actionCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-action",
        "$members$": {
            "active": [516],
            "alignment": [513],
            "appearance": [513],
            "compact": [516],
            "disabled": [516],
            "icon": [1],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "indicator": [516],
            "label": [1],
            "loading": [516],
            "scale": [513],
            "text": [1],
            "textEnabled": [516, "text-enabled"],
            "messages": [1040],
            "messageOverrides": [1040],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["active", "active"], ["alignment", "alignment"], ["appearance", "appearance"], ["compact", "compact"], ["disabled", "disabled"], ["iconFlipRtl", "icon-flip-rtl"], ["indicator", "indicator"], ["loading", "loading"], ["scale", "scale"], ["textEnabled", "text-enabled"]]
    }; }
}

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$5.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$4.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$3;

  return value === proto;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$1;
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Built-in value references. */
var Buffer = moduleExports$1 ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$1.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now$1 = function() {
  return root.Date.now();
};

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now$1());
  }

  function debounced() {
    var time = now$1(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    reHasRegExpChar = RegExp(reRegExpChar.source);

/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function escapeRegExp(string) {
  string = toString(string);
  return (string && reHasRegExpChar.test(string))
    ? string.replace(reRegExpChar, '\\$&')
    : string;
}

/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */
function forIn(object, iteratee) {
  return object == null
    ? object
    : baseFor(object, castFunction(iteratee), keysIn);
}

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle$1(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

const SLOTS$x = {
    menuActions: "menu-actions",
    menuTooltip: "menu-tooltip",
};
const ICONS$l = {
    menu: "ellipsis",
};
const CSS$1l = {
    container: "container",
};

const CSS$1k = {
    menu: "menu",
    defaultTrigger: "default-trigger",
};
const SLOTS$w = {
    tooltip: "tooltip",
    trigger: "trigger",
};
const ICONS$k = {
    menu: "ellipsis",
};
const activeAttr = "data-active";

const overflowActionsDebounceInMs = 150;
const groupBufferPx = 2;
const getAverage = (arr) => arr.reduce((p, c) => p + c, 0) / arr.length;
const geActionDimensions = (actions) => {
    const actionsNotSlotted = actions.filter((action) => action.slot !== SLOTS$x.menuActions);
    const actionLen = actionsNotSlotted?.length;
    return {
        actionWidth: actionLen ? getAverage(actionsNotSlotted.map((action) => action.clientWidth || 0)) : 0,
        actionHeight: actionLen ? getAverage(actionsNotSlotted.map((action) => action.clientHeight || 0)) : 0,
    };
};
const getMaxActionCount = ({ width, actionWidth, layout, height, actionHeight, groupCount, }) => {
    const maxContainerPx = layout === "horizontal" ? width : height;
    const avgItemPx = layout === "horizontal" ? actionWidth : actionHeight;
    return Math.floor((maxContainerPx - groupCount * groupBufferPx) / avgItemPx);
};
const getOverflowCount = ({ layout, actionCount, actionWidth, width, actionHeight, height, groupCount, }) => {
    return Math.max(actionCount - getMaxActionCount({ width, actionWidth, layout, height, actionHeight, groupCount }), 0);
};
const queryActions = (el) => {
    return Array.from(el.querySelectorAll("calcite-action")).filter((action) => action.closest("calcite-action-menu") ? action.slot === SLOTS$w.trigger : true);
};
const overflowActions = ({ actionGroups, expanded, overflowCount, }) => {
    let needToSlotCount = overflowCount;
    actionGroups.reverse().forEach((group) => {
        let slottedWithinGroupCount = 0;
        const groupActions = queryActions(group).reverse();
        groupActions.forEach((groupAction) => {
            if (groupAction.slot === SLOTS$x.menuActions) {
                groupAction.removeAttribute("slot");
                groupAction.textEnabled = expanded;
            }
        });
        if (needToSlotCount > 0) {
            groupActions.some((groupAction) => {
                const unslottedActions = groupActions.filter((action) => !action.slot);
                if (unslottedActions.length > 1 && groupActions.length > 2 && !groupAction.closest("calcite-action-menu")) {
                    groupAction.textEnabled = true;
                    groupAction.setAttribute("slot", SLOTS$x.menuActions);
                    slottedWithinGroupCount++;
                    if (slottedWithinGroupCount > 1) {
                        needToSlotCount--;
                    }
                }
                return needToSlotCount < 1;
            });
        }
    });
};

const ICONS$j = {
    chevronsLeft: "chevrons-left",
    chevronsRight: "chevrons-right",
};
function getCalcitePosition(position, el) {
    return position || el.closest("calcite-shell-panel")?.position || "start";
}
function toggleChildActionText({ el, expanded, }) {
    queryActions(el)
        .filter((el) => el.slot !== SLOTS$x.menuActions)
        .forEach((action) => (action.textEnabled = expanded));
    el.querySelectorAll("calcite-action-group, calcite-action-menu").forEach((el) => (el.expanded = expanded));
}
const setTooltipReference = ({ tooltip, referenceElement, expanded, ref, }) => {
    if (tooltip) {
        tooltip.referenceElement = !expanded && referenceElement ? referenceElement : null;
    }
    if (ref) {
        ref(referenceElement);
    }
    return referenceElement;
};
const ExpandToggle = ({ expanded, expandText, collapseText, toggle, el, position, tooltip, ref, scale, }) => {
    const rtl = getElementDir(el) === "rtl";
    const text = expanded ? collapseText : expandText;
    const icons = [ICONS$j.chevronsLeft, ICONS$j.chevronsRight];
    if (rtl) {
        icons.reverse();
    }
    const end = getCalcitePosition(position, el) === "end";
    const expandIcon = end ? icons[1] : icons[0];
    const collapseIcon = end ? icons[0] : icons[1];
    const actionNode = (hAsync("calcite-action", { icon: expanded ? expandIcon : collapseIcon, onClick: toggle, scale: scale, text: text, textEnabled: expanded, title: !expanded && !tooltip ? text : null, 
        // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
        ref: (referenceElement) => setTooltipReference({ tooltip, referenceElement, expanded, ref }) }));
    return actionNode;
};

const CSS$1j = {
    actionGroupEnd: "action-group--end",
};
const SLOTS$v = {
    actionsEnd: "actions-end",
    bottomActions: "bottom-actions",
    expandTooltip: "expand-tooltip",
};

const actionBarCss = "/*!@:host*/.sc-calcite-action-bar-h{box-sizing:border-box;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host **/.sc-calcite-action-bar-h *.sc-calcite-action-bar{box-sizing:border-box}/*!@:host*/.sc-calcite-action-bar-h{pointer-events:auto;display:inline-flex;align-self:stretch;--calcite-action-bar-expanded-max-width:auto}/*!@:host([layout=vertical])*/[layout=vertical].sc-calcite-action-bar-h{flex-direction:column}/*!@:host([layout=vertical]) .action-group--end*/[layout=vertical].sc-calcite-action-bar-h .action-group--end.sc-calcite-action-bar{margin-block-start:auto}/*!@:host([layout=horizontal])*/[layout=horizontal].sc-calcite-action-bar-h{flex-direction:row}/*!@:host([layout=horizontal]) .action-group--end*/[layout=horizontal].sc-calcite-action-bar-h .action-group--end.sc-calcite-action-bar{margin-inline-start:auto}/*!@:host([layout=vertical][overflow-actions-disabled])*/[layout=vertical][overflow-actions-disabled].sc-calcite-action-bar-h{overflow-y:auto}/*!@:host([layout=horizontal][overflow-actions-disabled])*/[layout=horizontal][overflow-actions-disabled].sc-calcite-action-bar-h{overflow-x:auto}/*!@:host([layout=vertical][expanded])*/[layout=vertical][expanded].sc-calcite-action-bar-h{max-inline-size:var(--calcite-action-bar-expanded-max-width)}/*!@::slotted(calcite-action-group)*/.sc-calcite-action-bar-s>calcite-action-group{border-block-end:1px solid var(--calcite-color-border-3)}/*!@:host([layout=horizontal]) ::slotted(calcite-action-group)*/.sc-calcite-action-bar-h[layout=horizontal] .sc-calcite-action-bar-s>calcite-action-group{border-block-end:0;border-inline-end:1px solid var(--calcite-color-border-3)}/*!@:host([layout=horizontal][expand-disabled]) ::slotted(calcite-action-group:last-of-type)*/.sc-calcite-action-bar-h[layout=horizontal][expand-disabled] .sc-calcite-action-bar-s>calcite-action-group:last-of-type{border-inline-end:0}/*!@::slotted(calcite-action-group:last-child)*/.sc-calcite-action-bar-s>calcite-action-group:last-child{border-block-end:0;border-inline-end:0}/*!@.action-group--end*/.action-group--end.sc-calcite-action-bar{justify-content:flex-end}/*!@:host([hidden])*/[hidden].sc-calcite-action-bar-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-action-bar{display:none}";

/**
 * @slot - A slot for adding `calcite-action`s that will appear at the top of the component.
 * @slot bottom-actions - [Deprecated] Use the `"actions-end"` slot instead. A slot for adding `calcite-action`s that will appear at the bottom of the component, above the collapse/expand button.
 * @slot actions-end - A slot for adding `calcite-action`s that will appear at the end of the component, prior to the collapse/expand button.
 * @slot expand-tooltip - A slot to set the `calcite-tooltip` for the expand toggle.
 */
class ActionBar {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteActionBarToggle = createEvent(this, "calciteActionBarToggle", 6);
        this.mutationObserver = createObserver();
        this.resizeObserver = createObserver();
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.actionMenuOpenHandler = (event) => {
            if (event.target.menuOpen) {
                const composedPath = event.composedPath();
                Array.from(this.el.querySelectorAll("calcite-action-group")).forEach((group) => {
                    if (!composedPath.includes(group)) {
                        group.menuOpen = false;
                    }
                });
            }
        };
        this.resizeHandlerEntries = (entries) => {
            entries.forEach(this.resizeHandler);
        };
        this.resizeHandler = (entry) => {
            const { width, height } = entry.contentRect;
            this.resize({ width, height });
        };
        this.resize = debounce(({ width, height }) => {
            const { el, expanded, expandDisabled, layout, overflowActionsDisabled } = this;
            if (overflowActionsDisabled ||
                (layout === "vertical" && !height) ||
                (layout === "horizontal" && !width)) {
                return;
            }
            const actions = queryActions(el);
            const actionCount = expandDisabled ? actions.length : actions.length + 1;
            const actionGroups = Array.from(el.querySelectorAll("calcite-action-group"));
            this.setGroupLayout(actionGroups);
            const groupCount = this.hasActionsEnd || this.hasBottomActions || !expandDisabled
                ? actionGroups.length + 1
                : actionGroups.length;
            const { actionHeight, actionWidth } = geActionDimensions(actions);
            const overflowCount = getOverflowCount({
                layout,
                actionCount,
                actionHeight,
                actionWidth,
                height,
                width,
                groupCount,
            });
            overflowActions({
                actionGroups,
                expanded,
                overflowCount,
            });
        }, overflowActionsDebounceInMs);
        this.toggleExpand = () => {
            this.expanded = !this.expanded;
            this.calciteActionBarToggle.emit();
        };
        this.setExpandToggleRef = (el) => {
            this.expandToggleEl = el;
        };
        this.handleDefaultSlotChange = (event) => {
            const groups = slotChangeGetAssignedElements(event).filter((el) => el.matches("calcite-action-group"));
            this.setGroupLayout(groups);
        };
        this.handleActionsEndSlotChange = (event) => {
            this.hasActionsEnd = slotChangeHasAssignedElement(event);
        };
        this.handleBottomActionsSlotChange = (event) => {
            this.hasBottomActions = slotChangeHasAssignedElement(event);
        };
        this.handleTooltipSlotChange = (event) => {
            const tooltips = slotChangeGetAssignedElements(event).filter((el) => el?.matches("calcite-tooltip"));
            this.expandTooltip = tooltips[0];
        };
        this.actionsEndGroupLabel = undefined;
        this.expandDisabled = false;
        this.expanded = false;
        this.layout = "vertical";
        this.overflowActionsDisabled = false;
        this.overlayPositioning = "absolute";
        this.position = undefined;
        this.scale = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.effectiveLocale = undefined;
        this.hasActionsEnd = false;
        this.hasBottomActions = false;
        this.expandTooltip = undefined;
        this.defaultMessages = undefined;
    }
    expandHandler() {
        this.overflowActions();
    }
    expandedHandler() {
        const { el, expanded } = this;
        toggleChildActionText({ el, expanded });
        this.overflowActions();
    }
    layoutHandler() {
        this.updateGroups();
    }
    overflowDisabledHandler(overflowActionsDisabled) {
        if (overflowActionsDisabled) {
            this.resizeObserver?.disconnect();
            return;
        }
        this.resizeObserver?.observe(this.el);
        this.overflowActions();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    componentDidLoad() {
        const { el, expanded } = this;
        setComponentLoaded(this);
        toggleChildActionText({ el, expanded });
        this.overflowActions();
    }
    connectedCallback() {
        const { el, expanded } = this;
        connectLocalized(this);
        connectMessages(this);
        toggleChildActionText({ el, expanded });
        this.mutationObserver?.observe(el, { childList: true, subtree: true });
        if (!this.overflowActionsDisabled) {
            this.resizeObserver?.observe(el);
        }
        this.overflowActions();
        connectConditionalSlotComponent(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
        this.resizeObserver?.disconnect();
        disconnectConditionalSlotComponent(this);
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Overflows actions that won't fit into menus.
     *
     * @internal
     */
    async overflowActions() {
        this.resize({ width: this.el.clientWidth, height: this.el.clientHeight });
    }
    /**
     * Sets focus on the component's first focusable element.
     */
    async setFocus() {
        await componentFocusable(this);
        focusFirstTabbable(this.el);
    }
    updateGroups() {
        this.setGroupLayout(Array.from(this.el.querySelectorAll("calcite-action-group")));
    }
    setGroupLayout(groups) {
        groups.forEach((group) => (group.layout = this.layout));
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderBottomActionGroup() {
        const { expanded, expandDisabled, el, position, toggleExpand, scale, layout, messages, actionsEndGroupLabel, overlayPositioning, } = this;
        const expandToggleNode = !expandDisabled ? (hAsync(ExpandToggle, { collapseText: messages.collapse, el: el, expandText: messages.expand, expanded: expanded, position: position, scale: scale, toggle: toggleExpand, tooltip: this.expandTooltip,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setExpandToggleRef })) : null;
        return (hAsync("calcite-action-group", { class: CSS$1j.actionGroupEnd, hidden: this.expandDisabled && !(this.hasActionsEnd || this.hasBottomActions), label: actionsEndGroupLabel, layout: layout, overlayPositioning: overlayPositioning, scale: scale }, hAsync("slot", { name: SLOTS$v.actionsEnd, onSlotchange: this.handleActionsEndSlotChange }), hAsync("slot", { name: SLOTS$v.bottomActions, onSlotchange: this.handleBottomActionsSlotChange }), hAsync("slot", { name: SLOTS$v.expandTooltip, onSlotchange: this.handleTooltipSlotChange }), expandToggleNode));
    }
    render() {
        return (hAsync(Host, { onCalciteActionMenuOpen: this.actionMenuOpenHandler }, hAsync("slot", { onSlotchange: this.handleDefaultSlotChange }), this.renderBottomActionGroup()));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "expandDisabled": ["expandHandler"],
        "expanded": ["expandedHandler"],
        "layout": ["layoutHandler"],
        "overflowActionsDisabled": ["overflowDisabledHandler"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return actionBarCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-action-bar",
        "$members$": {
            "actionsEndGroupLabel": [1, "actions-end-group-label"],
            "expandDisabled": [516, "expand-disabled"],
            "expanded": [1540],
            "layout": [513],
            "overflowActionsDisabled": [516, "overflow-actions-disabled"],
            "overlayPositioning": [513, "overlay-positioning"],
            "position": [513],
            "scale": [513],
            "messages": [1040],
            "messageOverrides": [1040],
            "effectiveLocale": [32],
            "hasActionsEnd": [32],
            "hasBottomActions": [32],
            "expandTooltip": [32],
            "defaultMessages": [32],
            "overflowActions": [64],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["expandDisabled", "expand-disabled"], ["expanded", "expanded"], ["layout", "layout"], ["overflowActionsDisabled", "overflow-actions-disabled"], ["overlayPositioning", "overlay-positioning"], ["position", "position"], ["scale", "scale"]]
    }; }
}

const actionGroupCss = "/*!@:host*/.sc-calcite-action-group-h{box-sizing:border-box;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host **/.sc-calcite-action-group-h *.sc-calcite-action-group{box-sizing:border-box}/*!@:host*/.sc-calcite-action-group-h{display:flex;flex-direction:column;padding:0px;--calcite-action-group-columns:3;--calcite-action-group-gap:1px;--calcite-action-group-padding:1px}/*!@.container*/.container.sc-calcite-action-group{display:flex;flex-grow:1;flex-direction:column}/*!@:host([columns=\"1\"])*/[columns=\"1\"].sc-calcite-action-group-h{--calcite-action-group-columns:1}/*!@:host([columns=\"2\"])*/[columns=\"2\"].sc-calcite-action-group-h{--calcite-action-group-columns:2}/*!@:host([columns=\"3\"])*/[columns=\"3\"].sc-calcite-action-group-h{--calcite-action-group-columns:3}/*!@:host([columns=\"4\"])*/[columns=\"4\"].sc-calcite-action-group-h{--calcite-action-group-columns:4}/*!@:host([columns=\"5\"])*/[columns=\"5\"].sc-calcite-action-group-h{--calcite-action-group-columns:5}/*!@:host([columns=\"6\"])*/[columns=\"6\"].sc-calcite-action-group-h{--calcite-action-group-columns:6}/*!@:host(:first-child)*/.sc-calcite-action-group-h:first-child{padding-block-start:0px}/*!@:host([layout=horizontal]),\n:host([layout=horizontal]) .container*/[layout=horizontal].sc-calcite-action-group-h,[layout=horizontal].sc-calcite-action-group-h .container.sc-calcite-action-group{flex-direction:row}/*!@:host([layout=grid])*/[layout=grid].sc-calcite-action-group-h{display:grid}/*!@:host([layout=grid]) .container*/[layout=grid].sc-calcite-action-group-h .container.sc-calcite-action-group{display:grid;place-content:stretch;background-color:var(--calcite-color-background);gap:var(--calcite-action-group-gap);padding:var(--calcite-action-group-gap);grid-template-columns:repeat(var(--calcite-action-group-columns), auto)}/*!@:host([hidden])*/[hidden].sc-calcite-action-group-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-action-group{display:none}";

/**
 * @slot - A slot for adding a group of `calcite-action`s.
 * @slot menu-actions - A slot for adding an overflow menu with `calcite-action`s inside a `calcite-dropdown`.
 * @slot menu-tooltip - A slot for adding a `calcite-tooltip` for the menu.
 */
class ActionGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.setMenuOpen = (event) => {
            this.menuOpen = !!event.target.open;
        };
        this.handleMenuActionsSlotChange = (event) => {
            this.hasMenuActions = slotChangeHasAssignedElement(event);
        };
        this.expanded = false;
        this.label = undefined;
        this.layout = "vertical";
        this.columns = undefined;
        this.menuOpen = false;
        this.overlayPositioning = "absolute";
        this.scale = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.effectiveLocale = "";
        this.defaultMessages = undefined;
        this.hasMenuActions = false;
    }
    expandedHandler() {
        this.menuOpen = false;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component's first focusable element. */
    async setFocus() {
        await componentFocusable(this);
        this.el.focus();
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectLocalized(this);
        connectMessages(this);
        connectConditionalSlotComponent(this);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectMessages(this);
        disconnectConditionalSlotComponent(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Component Methods
    //
    // --------------------------------------------------------------------------
    renderMenu() {
        const { expanded, menuOpen, scale, layout, messages, overlayPositioning, hasMenuActions } = this;
        return (hAsync("calcite-action-menu", { expanded: expanded, flipPlacements: ["left", "right"], hidden: !hasMenuActions, label: messages.more, onCalciteActionMenuOpen: this.setMenuOpen, open: menuOpen, overlayPositioning: overlayPositioning, placement: layout === "horizontal" ? "bottom-start" : "leading-start", scale: scale }, hAsync("calcite-action", { icon: ICONS$l.menu, scale: scale, slot: SLOTS$w.trigger, text: messages.more, textEnabled: expanded }), hAsync("slot", { name: SLOTS$x.menuActions, onSlotchange: this.handleMenuActionsSlotChange }), hAsync("slot", { name: SLOTS$x.menuTooltip, slot: SLOTS$w.tooltip })));
    }
    render() {
        return (hAsync("div", { "aria-label": this.label, class: CSS$1l.container, role: "group" }, hAsync("slot", null), this.renderMenu()));
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "expanded": ["expandedHandler"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return actionGroupCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-action-group",
        "$members$": {
            "expanded": [516],
            "label": [1],
            "layout": [513],
            "columns": [514],
            "menuOpen": [1540, "menu-open"],
            "overlayPositioning": [513, "overlay-positioning"],
            "scale": [513],
            "messages": [1040],
            "messageOverrides": [1040],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "hasMenuActions": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["expanded", "expanded"], ["layout", "layout"], ["columns", "columns"], ["menuOpen", "menu-open"], ["overlayPositioning", "overlay-positioning"], ["scale", "scale"]]
    }; }
}

function getRoundRobinIndex(index, total) {
    return (index + total) % total;
}

const actionMenuCss = "/*!@:host*/.sc-calcite-action-menu-h{box-sizing:border-box;display:flex;flex-direction:column;font-size:var(--calcite-font-size-1);color:var(--calcite-color-text-2)}/*!@::slotted(calcite-action-group)*/.sc-calcite-action-menu-s>calcite-action-group{border-block-end:1px solid var(--calcite-color-border-3)}/*!@::slotted(calcite-action-group:last-child)*/.sc-calcite-action-menu-s>calcite-action-group:last-child{border-block-end:0}/*!@.default-trigger*/.default-trigger.sc-calcite-action-menu{position:relative;block-size:100%;flex:0 1 auto;align-self:stretch}/*!@slot[name=trigger]::slotted(calcite-action),\ncalcite-action::slotted([slot=trigger])*/slot[name=trigger].sc-calcite-action-menu-s>calcite-action,calcite-action.sc-calcite-action-menu-s>[slot=trigger]{position:relative;block-size:100%;flex:0 1 auto;align-self:stretch}/*!@.menu*/.menu.sc-calcite-action-menu{max-block-size:45vh;flex-direction:column;flex-wrap:nowrap;overflow-y:auto;overflow-x:hidden;outline:2px solid transparent;outline-offset:2px}/*!@:host([hidden])*/[hidden].sc-calcite-action-menu-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-action-menu{display:none}";

const SUPPORTED_MENU_NAV_KEYS = ["ArrowUp", "ArrowDown", "End", "Home"];
/**
 * @slot - A slot for adding `calcite-action`s.
 * @slot trigger - A slot for adding a `calcite-action` to trigger opening the menu.
 * @slot tooltip - A slot for adding an tooltip for the menu.
 */
class ActionMenu {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteActionMenuOpen = createEvent(this, "calciteActionMenuOpen", 6);
        this.actionElements = [];
        this.guid = `calcite-action-menu-${guid()}`;
        this.menuId = `${this.guid}-menu`;
        this.menuButtonId = `${this.guid}-menu-button`;
        // --------------------------------------------------------------------------
        //
        //  Component Methods
        //
        // --------------------------------------------------------------------------
        this.connectMenuButtonEl = () => {
            const { menuButtonId, menuId, open, label } = this;
            const menuButtonEl = this.slottedMenuButtonEl || this.defaultMenuButtonEl;
            if (this.menuButtonEl === menuButtonEl) {
                return;
            }
            this.disconnectMenuButtonEl();
            this.menuButtonEl = menuButtonEl;
            this.setTooltipReferenceElement();
            if (!menuButtonEl) {
                return;
            }
            menuButtonEl.active = open;
            menuButtonEl.setAttribute("aria-controls", menuId);
            menuButtonEl.setAttribute("aria-expanded", toAriaBoolean(open));
            menuButtonEl.setAttribute("aria-haspopup", "true");
            if (!menuButtonEl.id) {
                menuButtonEl.id = menuButtonId;
            }
            if (!menuButtonEl.label) {
                menuButtonEl.label = label;
            }
            if (!menuButtonEl.text) {
                menuButtonEl.text = label;
            }
            menuButtonEl.addEventListener("pointerdown", this.menuButtonClick);
            menuButtonEl.addEventListener("keydown", this.menuButtonKeyDown);
        };
        this.disconnectMenuButtonEl = () => {
            const { menuButtonEl } = this;
            if (!menuButtonEl) {
                return;
            }
            menuButtonEl.removeEventListener("pointerdown", this.menuButtonClick);
            menuButtonEl.removeEventListener("keydown", this.menuButtonKeyDown);
        };
        this.setMenuButtonEl = (event) => {
            const actions = event.target
                .assignedElements({
                flatten: true,
            })
                .filter((el) => el?.matches("calcite-action"));
            this.slottedMenuButtonEl = actions[0];
            this.connectMenuButtonEl();
        };
        this.setDefaultMenuButtonEl = (el) => {
            this.defaultMenuButtonEl = el;
            this.connectMenuButtonEl();
        };
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.handleCalciteActionClick = () => {
            this.open = false;
            this.setFocus();
        };
        this.menuButtonClick = (event) => {
            if (!isPrimaryPointerButton(event)) {
                return;
            }
            this.toggleOpen();
        };
        this.updateTooltip = (event) => {
            const tooltips = event.target
                .assignedElements({
                flatten: true,
            })
                .filter((el) => el?.matches("calcite-tooltip"));
            this.tooltipEl = tooltips[0];
            this.setTooltipReferenceElement();
        };
        this.setTooltipReferenceElement = () => {
            const { tooltipEl, expanded, menuButtonEl, open } = this;
            if (tooltipEl) {
                tooltipEl.referenceElement = !expanded && !open ? menuButtonEl : null;
            }
        };
        this.updateAction = (action, index) => {
            const { guid, activeMenuItemIndex } = this;
            const id = `${guid}-action-${index}`;
            action.tabIndex = -1;
            action.setAttribute("role", "menuitem");
            if (!action.id) {
                action.id = id;
            }
            // data attribute is used to style the "activeMenuItemIndex" action using token focus styling.
            action.toggleAttribute(activeAttr, index === activeMenuItemIndex);
        };
        this.updateActions = (actions) => {
            actions?.forEach(this.updateAction);
        };
        this.handleDefaultSlotChange = (event) => {
            const actions = event.target
                .assignedElements({
                flatten: true,
            })
                .reduce((previousValue, currentValue) => {
                if (currentValue?.matches("calcite-action")) {
                    previousValue.push(currentValue);
                    return previousValue;
                }
                if (currentValue?.matches("calcite-action-group")) {
                    return previousValue.concat(Array.from(currentValue.querySelectorAll("calcite-action")));
                }
                return previousValue;
            }, []);
            this.actionElements = actions.filter((action) => !action.disabled && !action.hidden);
        };
        this.menuButtonKeyDown = (event) => {
            const { key } = event;
            const { actionElements, activeMenuItemIndex, open } = this;
            if (!actionElements.length) {
                return;
            }
            if (isActivationKey(key)) {
                event.preventDefault();
                if (!open) {
                    this.toggleOpen();
                    return;
                }
                const action = actionElements[activeMenuItemIndex];
                action ? action.click() : this.toggleOpen(false);
            }
            if (key === "Tab") {
                this.open = false;
                return;
            }
            if (key === "Escape") {
                this.toggleOpen(false);
                event.preventDefault();
                return;
            }
            this.handleActionNavigation(event, key, actionElements);
        };
        this.handleActionNavigation = (event, key, actions) => {
            if (!this.isValidKey(key, SUPPORTED_MENU_NAV_KEYS)) {
                return;
            }
            event.preventDefault();
            if (!this.open) {
                this.toggleOpen();
                if (key === "Home" || key === "ArrowDown") {
                    this.activeMenuItemIndex = 0;
                }
                if (key === "End" || key === "ArrowUp") {
                    this.activeMenuItemIndex = actions.length - 1;
                }
                return;
            }
            if (key === "Home") {
                this.activeMenuItemIndex = 0;
            }
            if (key === "End") {
                this.activeMenuItemIndex = actions.length - 1;
            }
            const currentIndex = this.activeMenuItemIndex;
            if (key === "ArrowUp") {
                this.activeMenuItemIndex = getRoundRobinIndex(Math.max(currentIndex - 1, -1), actions.length);
            }
            if (key === "ArrowDown") {
                this.activeMenuItemIndex = getRoundRobinIndex(currentIndex + 1, actions.length);
            }
        };
        this.toggleOpenEnd = () => {
            this.setFocus();
            this.el.removeEventListener("calcitePopoverOpen", this.toggleOpenEnd);
        };
        this.toggleOpen = (value = !this.open) => {
            this.el.addEventListener("calcitePopoverOpen", this.toggleOpenEnd);
            this.open = value;
        };
        this.handlePopoverOpen = () => {
            this.open = true;
        };
        this.handlePopoverClose = () => {
            this.open = false;
        };
        this.appearance = "solid";
        this.expanded = false;
        this.flipPlacements = undefined;
        this.label = undefined;
        this.open = false;
        this.overlayPositioning = "absolute";
        this.placement = "auto";
        this.scale = undefined;
        this.menuButtonEl = undefined;
        this.activeMenuItemIndex = -1;
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        this.connectMenuButtonEl();
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        this.disconnectMenuButtonEl();
    }
    expandedHandler() {
        this.open = false;
        this.setTooltipReferenceElement();
    }
    openHandler(open) {
        this.activeMenuItemIndex = this.open ? 0 : -1;
        if (this.menuButtonEl) {
            this.menuButtonEl.active = open;
        }
        this.calciteActionMenuOpen.emit();
        this.setTooltipReferenceElement();
    }
    activeMenuItemIndexHandler() {
        this.updateActions(this.actionElements);
    }
    // --------------------------------------------------------------------------
    //
    //  Methods
    //
    // --------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        return focusElement(this.menuButtonEl);
    }
    renderMenuButton() {
        const { appearance, label, scale, expanded } = this;
        const menuButtonSlot = (hAsync("slot", { name: SLOTS$w.trigger, onSlotchange: this.setMenuButtonEl }, hAsync("calcite-action", { appearance: appearance, class: CSS$1k.defaultTrigger, icon: ICONS$k.menu, scale: scale, text: label, textEnabled: expanded,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setDefaultMenuButtonEl })));
        return menuButtonSlot;
    }
    renderMenuItems() {
        const { actionElements, activeMenuItemIndex, open, menuId, menuButtonEl, label, placement, overlayPositioning, flipPlacements, } = this;
        const activeAction = actionElements[activeMenuItemIndex];
        const activeDescendantId = activeAction?.id || null;
        return (hAsync("calcite-popover", { autoClose: true, flipPlacements: flipPlacements, focusTrapDisabled: true, label: label, offsetDistance: 0, onCalcitePopoverClose: this.handlePopoverClose, onCalcitePopoverOpen: this.handlePopoverOpen, open: open, overlayPositioning: overlayPositioning, placement: placement, pointerDisabled: true, referenceElement: menuButtonEl }, hAsync("div", { "aria-activedescendant": activeDescendantId, "aria-labelledby": menuButtonEl?.id, class: CSS$1k.menu, id: menuId, onClick: this.handleCalciteActionClick, role: "menu", tabIndex: -1 }, hAsync("slot", { onSlotchange: this.handleDefaultSlotChange }))));
    }
    render() {
        return (hAsync(Fragment, null, this.renderMenuButton(), this.renderMenuItems(), hAsync("slot", { name: SLOTS$w.tooltip, onSlotchange: this.updateTooltip })));
    }
    isValidKey(key, supportedKeys) {
        return !!supportedKeys.find((k) => k === key);
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "expanded": ["expandedHandler"],
        "open": ["openHandler"],
        "activeMenuItemIndex": ["activeMenuItemIndexHandler"]
    }; }
    static get style() { return actionMenuCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-action-menu",
        "$members$": {
            "appearance": [513],
            "expanded": [516],
            "flipPlacements": [16],
            "label": [1],
            "open": [1540],
            "overlayPositioning": [513, "overlay-positioning"],
            "placement": [513],
            "scale": [513],
            "menuButtonEl": [32],
            "activeMenuItemIndex": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["appearance", "appearance"], ["expanded", "expanded"], ["open", "open"], ["overlayPositioning", "overlay-positioning"], ["placement", "placement"], ["scale", "scale"]]
    }; }
}

const CSS$1i = {
    actionGroupEnd: "action-group--end",
    container: "container",
};
const SLOTS$u = {
    expandTooltip: "expand-tooltip",
};

const actionPadCss = "/*!@:host*/.sc-calcite-action-pad-h{box-sizing:border-box;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host **/.sc-calcite-action-pad-h *.sc-calcite-action-pad{box-sizing:border-box}/*!@:host*/.sc-calcite-action-pad-h{display:block}@keyframes in{0%{opacity:0}100%{opacity:1}}/*!@:host*/.sc-calcite-action-pad-h{animation:in var(--calcite-internal-animation-timing-slow) ease-in-out;border-radius:0.125rem;--calcite-action-pad-expanded-max-width:auto;background:transparent}/*!@:host([expanded][layout=vertical]) .container*/[expanded][layout=vertical].sc-calcite-action-pad-h .container.sc-calcite-action-pad{max-inline-size:var(--calcite-action-pad-expanded-max-width)}/*!@::slotted(calcite-action-group)*/.sc-calcite-action-pad-s>calcite-action-group{border-width:0px;border-block-end-width:1px;border-style:solid;border-color:var(--calcite-color-border-3);padding-block:0px}/*!@.container*/.container.sc-calcite-action-pad{display:inline-flex;flex-direction:column;overflow-y:auto;border-radius:0.25rem;background-color:var(--calcite-color-background);--tw-shadow:0 6px 20px -4px rgba(0, 0, 0, 0.1), 0 4px 12px -2px rgba(0, 0, 0, 0.08);--tw-shadow-colored:0 6px 20px -4px var(--tw-shadow-color), 0 4px 12px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@.action-group--bottom*/.action-group--bottom.sc-calcite-action-pad{flex-grow:1;justify-content:flex-end;padding-block-end:0px}/*!@:host([layout=horizontal]) .container*/[layout=horizontal].sc-calcite-action-pad-h .container.sc-calcite-action-pad{flex-direction:row}/*!@:host([layout=horizontal]) .container .action-group--bottom*/[layout=horizontal].sc-calcite-action-pad-h .container.sc-calcite-action-pad .action-group--bottom.sc-calcite-action-pad{padding:0px}/*!@:host([layout=horizontal]) .container ::slotted(calcite-action-group)*/.sc-calcite-action-pad-h[layout=horizontal] .container .sc-calcite-action-pad-s>calcite-action-group{border-width:0px;padding:0px;border-inline-end-width:1px}/*!@::slotted(calcite-action-group:last-child)*/.sc-calcite-action-pad-s>calcite-action-group:last-child{border-block-end-width:0px}/*!@:host([hidden])*/[hidden].sc-calcite-action-pad-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-action-pad{display:none}";

/**
 * @slot - A slot for adding `calcite-action`s to the component.
 * @slot expand-tooltip - A slot to set the `calcite-tooltip` for the expand toggle.
 */
class ActionPad {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteActionPadToggle = createEvent(this, "calciteActionPadToggle", 6);
        this.mutationObserver = createObserver();
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.actionMenuOpenHandler = (event) => {
            if (event.target.menuOpen) {
                const composedPath = event.composedPath();
                Array.from(this.el.querySelectorAll("calcite-action-group")).forEach((group) => {
                    if (!composedPath.includes(group)) {
                        group.menuOpen = false;
                    }
                });
            }
        };
        this.toggleExpand = () => {
            this.expanded = !this.expanded;
            this.calciteActionPadToggle.emit();
        };
        this.setExpandToggleRef = (el) => {
            this.expandToggleEl = el;
        };
        this.handleDefaultSlotChange = (event) => {
            const groups = slotChangeGetAssignedElements(event).filter((el) => el?.matches("calcite-action-group"));
            this.setGroupLayout(groups);
        };
        this.handleTooltipSlotChange = (event) => {
            const tooltips = slotChangeGetAssignedElements(event).filter((el) => el?.matches("calcite-tooltip"));
            this.expandTooltip = tooltips[0];
        };
        this.actionsEndGroupLabel = undefined;
        this.expandDisabled = false;
        this.expanded = false;
        this.layout = "vertical";
        this.position = undefined;
        this.scale = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.overlayPositioning = "absolute";
        this.expandTooltip = undefined;
        this.effectiveLocale = "";
        this.defaultMessages = undefined;
    }
    expandedHandler(expanded) {
        toggleChildActionText({ el: this.el, expanded });
    }
    layoutHandler() {
        this.updateGroups();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectConditionalSlotComponent(this);
        connectLocalized(this);
        connectMessages(this);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectMessages(this);
        disconnectConditionalSlotComponent(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        const { el, expanded } = this;
        toggleChildActionText({ el, expanded });
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Sets focus on the component's first focusable element.
     */
    async setFocus() {
        await componentFocusable(this);
        this.el?.focus();
    }
    updateGroups() {
        this.setGroupLayout(Array.from(this.el.querySelectorAll("calcite-action-group")));
    }
    setGroupLayout(groups) {
        groups.forEach((group) => (group.layout = this.layout));
    }
    // --------------------------------------------------------------------------
    //
    //  Component Methods
    //
    // --------------------------------------------------------------------------
    renderBottomActionGroup() {
        const { expanded, expandDisabled, messages, el, position, toggleExpand, scale, layout, actionsEndGroupLabel, overlayPositioning, } = this;
        const expandToggleNode = !expandDisabled ? (hAsync(ExpandToggle, { collapseText: messages.collapse, el: el, expandText: messages.expand, expanded: expanded, position: position, scale: scale, toggle: toggleExpand, tooltip: this.expandTooltip,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setExpandToggleRef })) : null;
        return expandToggleNode ? (hAsync("calcite-action-group", { class: CSS$1i.actionGroupEnd, label: actionsEndGroupLabel, layout: layout, overlayPositioning: overlayPositioning, scale: scale }, hAsync("slot", { name: SLOTS$u.expandTooltip, onSlotchange: this.handleTooltipSlotChange }), expandToggleNode)) : null;
    }
    render() {
        return (hAsync(Host, { onCalciteActionMenuOpen: this.actionMenuOpenHandler }, hAsync("div", { class: CSS$1i.container }, hAsync("slot", { onSlotchange: this.handleDefaultSlotChange }), this.renderBottomActionGroup())));
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "expanded": ["expandedHandler"],
        "layout": ["layoutHandler"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return actionPadCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-action-pad",
        "$members$": {
            "actionsEndGroupLabel": [1, "actions-end-group-label"],
            "expandDisabled": [516, "expand-disabled"],
            "expanded": [1540],
            "layout": [513],
            "position": [513],
            "scale": [513],
            "messages": [1040],
            "messageOverrides": [1040],
            "overlayPositioning": [513, "overlay-positioning"],
            "expandTooltip": [32],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["expandDisabled", "expand-disabled"], ["expanded", "expanded"], ["layout", "layout"], ["position", "position"], ["scale", "scale"], ["overlayPositioning", "overlay-positioning"]]
    }; }
}

function isOpen(component) {
    return "opened" in component ? component.opened : component.open;
}
function emitImmediately(component, nonOpenCloseComponent = false) {
    (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))
        ? component.onBeforeOpen()
        : component.onBeforeClose();
    (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))
        ? component.onOpen()
        : component.onClose();
}
/**
 * Helper to determine globally set transition duration on the given openTransitionProp, which is imported and set in the @Watch("open").
 * Used to emit (before)open/close events both for when the opacity transition is present and when there is none (transition-duration is set to 0).
 *
 * @example
 * import { onToggleOpenCloseComponent, OpenCloseComponent } from "../../utils/openCloseComponent";
 *
 * async componentWillLoad() {
 * // When component initially renders, if `open` was set we need to trigger on load as watcher doesn't fire.
 * if (this.open) {
 *    onToggleOpenCloseComponent(this);
 * }
 * @Watch("open")
 * async toggleModal(value: boolean): Promise<void> {
 *    onToggleOpenCloseComponent(this);
 * }
 *
 * @param component - OpenCloseComponent uses `open` prop to emit (before)open/close.
 * @param nonOpenCloseComponent - OpenCloseComponent uses `expanded` prop to emit (before)open/close.
 */
function onToggleOpenCloseComponent(component, nonOpenCloseComponent = false) {
    readTask(() => {
        if (component.transitionEl) {
            const { transitionDuration: allDurations, transitionProperty: allProps } = getComputedStyle(component.transitionEl);
            const allTransitionDurationsArray = allDurations.split(",");
            const allTransitionPropsArray = allProps.split(",");
            const openTransitionPropIndex = allTransitionPropsArray.indexOf(component.openTransitionProp);
            const transitionDuration = allTransitionDurationsArray[openTransitionPropIndex] ??
                /* Safari will have a single transition value if multiple props share it,
                so we fall back to it if there's no matching prop duration */
                allTransitionDurationsArray[0];
            if (transitionDuration === "0s") {
                emitImmediately(component, nonOpenCloseComponent);
                return;
            }
            const fallbackTimeoutId = setTimeout(() => {
                component.transitionEl.removeEventListener("transitionstart", onStart);
                component.transitionEl.removeEventListener("transitionend", onEndOrCancel);
                component.transitionEl.removeEventListener("transitioncancel", onEndOrCancel);
                emitImmediately(component, nonOpenCloseComponent);
            }, parseFloat(transitionDuration) * 1000);
            component.transitionEl.addEventListener("transitionstart", onStart);
            component.transitionEl.addEventListener("transitionend", onEndOrCancel);
            component.transitionEl.addEventListener("transitioncancel", onEndOrCancel);
            function onStart(event) {
                if (event.propertyName === component.openTransitionProp && event.target === component.transitionEl) {
                    clearTimeout(fallbackTimeoutId);
                    component.transitionEl.removeEventListener("transitionstart", onStart);
                    (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))
                        ? component.onBeforeOpen()
                        : component.onBeforeClose();
                }
            }
            function onEndOrCancel(event) {
                if (event.propertyName === component.openTransitionProp && event.target === component.transitionEl) {
                    (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))
                        ? component.onOpen()
                        : component.onClose();
                    component.transitionEl.removeEventListener("transitionend", onEndOrCancel);
                    component.transitionEl.removeEventListener("transitioncancel", onEndOrCancel);
                }
            }
        }
    });
}

var KindIcons;
(function (KindIcons) {
    KindIcons["brand"] = "lightbulb";
    KindIcons["danger"] = "exclamationMarkTriangle";
    KindIcons["info"] = "information";
    KindIcons["success"] = "checkCircle";
    KindIcons["warning"] = "exclamationMarkTriangle";
})(KindIcons || (KindIcons = {}));

const DURATIONS = {
    slow: 14000,
    medium: 10000,
    fast: 6000,
};
const SLOTS$t = {
    actionsEnd: "actions-end",
    title: "title",
    message: "message",
    link: "link",
};
const CSS$1h = {
    actionsEnd: "actions-end",
    close: "close",
    container: "container",
    containerBottom: "container--bottom",
    containerBottomEnd: "container--bottom-end",
    containerBottomStart: "container--bottom-start",
    containerQueued: "container--queued",
    containerTop: "container--top",
    containerTopEnd: "container--top-end",
    containerTopStart: "container--top-start",
    content: "content",
    contentContainer: "content-container",
    dismissProgress: "dismiss-progress",
    footer: "footer",
    icon: "icon",
    containerSlottedInShell: "container--slotted-in-shell",
    queueCount: "queue-count",
    queueCountActive: "queue-count--active",
    textContainer: "text-container",
};

const alertCss = "/*!@:host*/.sc-calcite-alert-h{--calcite-alert-edge-distance:2rem;--calcite-alert-dismiss-progress-background:var(--calcite-color-transparent-tint);display:block}/*!@.container*/.container.sc-calcite-alert{pointer-events:none;position:fixed;z-index:var(--calcite-z-index-toast);margin-inline:auto;margin-block:0px;box-sizing:border-box;display:flex;inline-size:100%;min-inline-size:min-content;align-items:center;justify-content:center;background-color:var(--calcite-color-foreground-1);text-align:start;opacity:0;--tw-shadow:0 6px 20px -4px rgba(0, 0, 0, 0.1), 0 4px 12px -2px rgba(0, 0, 0, 0.08);--tw-shadow-colored:0 6px 20px -4px var(--tw-shadow-color), 0 4px 12px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);border-radius:var(--calcite-border-radius);border-block-start:0 solid transparent;border-inline:1px solid var(--calcite-color-border-3);border-block-end:1px solid var(--calcite-color-border-3);inline-size:var(--calcite-alert-width);max-inline-size:calc(100% - var(--calcite-alert-edge-distance) * 2);transition:var(--calcite-internal-animation-timing-slow) cubic-bezier(0.215, 0.44, 0.42, 0.88), opacity var(--calcite-internal-animation-timing-slow) cubic-bezier(0.215, 0.44, 0.42, 0.88), all var(--calcite-animation-timing) ease-in-out}/*!@.container--bottom, .container--top*/.container--bottom.sc-calcite-alert,.container--top.sc-calcite-alert{inset-inline-end:0;inset-inline-start:0}/*!@.container[class*=bottom]*/.container[class*=bottom].sc-calcite-alert{transform:translate3d(0, var(--calcite-alert-edge-distance), 0);inset-block-end:var(--calcite-alert-edge-distance)}/*!@.container[class*=top]*/.container[class*=top].sc-calcite-alert{transform:translate3d(0, calc(-1 * var(--calcite-alert-edge-distance)), 0);inset-block-start:var(--calcite-alert-edge-distance)}/*!@.container[class*=start]*/.container[class*=start].sc-calcite-alert{inset-inline-start:var(--calcite-alert-edge-distance);inset-inline-end:auto}/*!@.container[class*=end]*/.container[class*=end].sc-calcite-alert{inset-inline-end:var(--calcite-alert-edge-distance);inset-inline-start:auto}/*!@.icon*/.icon.sc-calcite-alert{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:0px;margin-block:auto;margin-inline-end:auto;padding-inline-start:var(--calcite-alert-spacing-token-large)}/*!@.close*/.close.sc-calcite-alert{display:flex;cursor:pointer;align-items:center;justify-content:flex-end;align-self:stretch;border-style:none;background-color:transparent;color:var(--calcite-color-text-3);outline:2px solid transparent;outline-offset:2px;-webkit-appearance:none;padding:var(--calcite-alert-spacing-token-large);outline-color:transparent}/*!@.close:focus*/.close.sc-calcite-alert:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.close:hover, .close:focus*/.close.sc-calcite-alert:hover,.close.sc-calcite-alert:focus{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-text-1)}/*!@.close:active*/.close.sc-calcite-alert:active{background-color:var(--calcite-color-foreground-3)}/*!@.queue-count*/.queue-count.sc-calcite-alert{visibility:hidden;display:flex;min-inline-size:min-content;cursor:default;align-items:center;justify-content:space-around;align-self:stretch;overflow:hidden;background-color:var(--calcite-color-foreground-1);text-align:center;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-2);opacity:0;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;border-inline:0 solid transparent;border-start-end-radius:0}/*!@.queue-count--active*/.queue-count--active.sc-calcite-alert{visibility:visible;opacity:1}/*!@.dismiss-progress*/.dismiss-progress.sc-calcite-alert{position:absolute;display:block;inline-size:100%;overflow:hidden;inset-inline:0;inset-block-start:-2px;block-size:2px;border-radius:var(--calcite-border-radius) var(--calcite-border-radius) 0 0}/*!@.dismiss-progress:after*/.dismiss-progress.sc-calcite-alert:after{position:absolute;inset-block-start:0px;display:block;block-size:2px;content:\"\";background-color:var(--calcite-alert-dismiss-progress-background);inset-inline-end:0}/*!@.actions-end*/.actions-end.sc-calcite-alert{display:flex;align-self:stretch}/*!@.text-container*/.text-container.sc-calcite-alert{box-sizing:border-box;display:flex;min-inline-size:0px;flex:1 1 auto;flex-direction:column;overflow-wrap:break-word;padding-block:var(--calcite-alert-spacing-token-small);padding-inline:var(--calcite-alert-spacing-token-large) var(--calcite-alert-spacing-token-small)}/*!@.footer*/.footer.sc-calcite-alert{position:relative;display:flex;inline-size:auto;justify-content:flex-end;align-self:stretch;padding-block-start:1px;block-size:inherit}/*!@:host([scale=s])*/[scale=s].sc-calcite-alert-h{--calcite-alert-width:40em;--calcite-alert-spacing-token-small:0.5rem;--calcite-alert-spacing-token-large:0.75rem;--calcite-alert-footer-height:2rem;--calcite-alert-footer-divider-gap:0.125rem}/*!@:host([scale=s]) slot[name=title]::slotted(*),\n:host([scale=s]) *::slotted([slot=title])*/.sc-calcite-alert-h[scale=s] slot[name=title].sc-calcite-alert-s>*,.sc-calcite-alert-h[scale=s] *.sc-calcite-alert-s>[slot=title]{font-size:var(--calcite-font-size--1);line-height:1.375}/*!@:host([scale=s]) slot[name=message]::slotted(*),\n:host([scale=s]) *::slotted([slot=message])*/.sc-calcite-alert-h[scale=s] slot[name=message].sc-calcite-alert-s>*,.sc-calcite-alert-h[scale=s] *.sc-calcite-alert-s>[slot=message]{font-size:var(--calcite-font-size--2);line-height:1.375}/*!@:host([scale=s]) slot[name=link]::slotted(*),\n:host([scale=s]) *::slotted([slot=link])*/.sc-calcite-alert-h[scale=s] slot[name=link].sc-calcite-alert-s>*,.sc-calcite-alert-h[scale=s] *.sc-calcite-alert-s>[slot=link]{font-size:var(--calcite-font-size--2);line-height:1.375}/*!@:host([scale=s]) .queue-count*/[scale=s].sc-calcite-alert-h .queue-count.sc-calcite-alert{margin-inline:0.5rem}/*!@:host([scale=s]) .container*/[scale=s].sc-calcite-alert-h .container.sc-calcite-alert{--calcite-alert-min-height:3.5rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-alert-h{--calcite-alert-width:50em;--calcite-alert-spacing-token-small:0.75rem;--calcite-alert-spacing-token-large:1rem;--calcite-alert-footer-height:3rem;--calcite-alert-footer-divider-gap:0.25rem}/*!@:host([scale=m]) slot[name=title]::slotted(*),\n:host([scale=m]) *::slotted([slot=title])*/.sc-calcite-alert-h[scale=m] slot[name=title].sc-calcite-alert-s>*,.sc-calcite-alert-h[scale=m] *.sc-calcite-alert-s>[slot=title]{font-size:var(--calcite-font-size-0);line-height:1.375}/*!@:host([scale=m]) slot[name=message]::slotted(*),\n:host([scale=m]) *::slotted([slot=message])*/.sc-calcite-alert-h[scale=m] slot[name=message].sc-calcite-alert-s>*,.sc-calcite-alert-h[scale=m] *.sc-calcite-alert-s>[slot=message]{font-size:var(--calcite-font-size--1);line-height:1.375}/*!@:host([scale=m]) slot[name=link]::slotted(*),\n:host([scale=m]) *::slotted([slot=link])*/.sc-calcite-alert-h[scale=m] slot[name=link].sc-calcite-alert-s>*,.sc-calcite-alert-h[scale=m] *.sc-calcite-alert-s>[slot=link]{font-size:var(--calcite-font-size--1);line-height:1.375}/*!@:host([scale=m]) .queue-count*/[scale=m].sc-calcite-alert-h .queue-count.sc-calcite-alert{margin-inline:0.75rem}/*!@:host([scale=m]) .container*/[scale=m].sc-calcite-alert-h .container.sc-calcite-alert{--calcite-alert-min-height:4.1875rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-alert-h{--calcite-alert-width:60em;--calcite-alert-spacing-token-small:1rem;--calcite-alert-spacing-token-large:1.25rem;--calcite-alert-footer-height:4rem;--calcite-alert-footer-divider-gap:0.5rem}/*!@:host([scale=l]) slot[name=title]::slotted(*),\n:host([scale=l]) *::slotted([slot=title])*/.sc-calcite-alert-h[scale=l] slot[name=title].sc-calcite-alert-s>*,.sc-calcite-alert-h[scale=l] *.sc-calcite-alert-s>[slot=title]{margin-block-end:0.25rem;font-size:var(--calcite-font-size-1);line-height:1.375}/*!@:host([scale=l]) slot[name=message]::slotted(*),\n:host([scale=l]) *::slotted([slot=message])*/.sc-calcite-alert-h[scale=l] slot[name=message].sc-calcite-alert-s>*,.sc-calcite-alert-h[scale=l] *.sc-calcite-alert-s>[slot=message]{font-size:var(--calcite-font-size-0);line-height:1.375}/*!@:host([scale=l]) slot[name=link]::slotted(*),\n:host([scale=l]) *::slotted([slot=link])*/.sc-calcite-alert-h[scale=l] slot[name=link].sc-calcite-alert-s>*,.sc-calcite-alert-h[scale=l] *.sc-calcite-alert-s>[slot=link]{font-size:var(--calcite-font-size-0);line-height:1.375}/*!@:host([scale=l]) .queue-count*/[scale=l].sc-calcite-alert-h .queue-count.sc-calcite-alert{margin-inline:1rem}/*!@:host([scale=l]) .container*/[scale=l].sc-calcite-alert-h .container.sc-calcite-alert{--calcite-alert-min-height:5.625rem}/*!@:host([open]) .container:not(.container--queued)*/[open].sc-calcite-alert-h .container.sc-calcite-alert:not(.container--queued){border-block-start-width:2px;opacity:1;pointer-events:initial}/*!@:host([open]) .container:not(.container--queued)[class*=bottom]*/[open].sc-calcite-alert-h .container.sc-calcite-alert:not(.container--queued)[class*=bottom]{transform:translate3d(0, calc(-1 * var(--calcite-alert-edge-distance)), inherit)}/*!@:host([open]) .container:not(.container--queued)[class*=top]*/[open].sc-calcite-alert-h .container.sc-calcite-alert:not(.container--queued)[class*=top]{transform:translate3d(0, var(--calcite-alert-edge-distance), inherit)}/*!@:host([auto-close]) > .queue-count*/[auto-close].sc-calcite-alert-h>.queue-count.sc-calcite-alert{border-inline-end:0 solid transparent}/*!@slot[name=title]::slotted(*),\n*::slotted([slot=title])*/slot[name=title].sc-calcite-alert-s>*,*.sc-calcite-alert-s>[slot=title]{font-size:var(--calcite-font-size-0);line-height:1.375;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1)}/*!@slot[name=message]::slotted(*),\n*::slotted([slot=message])*/slot[name=message].sc-calcite-alert-s>*,*.sc-calcite-alert-s>[slot=message]{margin:0px;display:inline;font-size:var(--calcite-font-size--1);line-height:1.375;font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-2);margin-inline-end:0.5rem}/*!@slot[name=link]::slotted(*),\n*::slotted([slot=link])*/slot[name=link].sc-calcite-alert-s>*,*.sc-calcite-alert-s>[slot=link]{display:inline-flex;color:var(--calcite-color-text-link)}/*!@:host([kind=brand]) .container*/[kind=brand].sc-calcite-alert-h .container.sc-calcite-alert{border-block-start-color:var(--calcite-color-brand)}/*!@:host([kind=brand]) .container .icon*/[kind=brand].sc-calcite-alert-h .container.sc-calcite-alert .icon.sc-calcite-alert{color:var(--calcite-color-brand)}/*!@:host([kind=info]) .container*/[kind=info].sc-calcite-alert-h .container.sc-calcite-alert{border-block-start-color:var(--calcite-color-status-info)}/*!@:host([kind=info]) .container .icon*/[kind=info].sc-calcite-alert-h .container.sc-calcite-alert .icon.sc-calcite-alert{color:var(--calcite-color-status-info)}/*!@:host([kind=danger]) .container*/[kind=danger].sc-calcite-alert-h .container.sc-calcite-alert{border-block-start-color:var(--calcite-color-status-danger)}/*!@:host([kind=danger]) .container .icon*/[kind=danger].sc-calcite-alert-h .container.sc-calcite-alert .icon.sc-calcite-alert{color:var(--calcite-color-status-danger)}/*!@:host([kind=success]) .container*/[kind=success].sc-calcite-alert-h .container.sc-calcite-alert{border-block-start-color:var(--calcite-color-status-success)}/*!@:host([kind=success]) .container .icon*/[kind=success].sc-calcite-alert-h .container.sc-calcite-alert .icon.sc-calcite-alert{color:var(--calcite-color-status-success)}/*!@:host([kind=warning]) .container*/[kind=warning].sc-calcite-alert-h .container.sc-calcite-alert{border-block-start-color:var(--calcite-color-status-warning)}/*!@:host([kind=warning]) .container .icon*/[kind=warning].sc-calcite-alert-h .container.sc-calcite-alert .icon.sc-calcite-alert{color:var(--calcite-color-status-warning)}/*!@:host([auto-close-duration=fast]) .dismiss-progress:after*/[auto-close-duration=fast].sc-calcite-alert-h .dismiss-progress.sc-calcite-alert:after{animation:dismissProgress 6000ms ease-out}/*!@:host(:hover[auto-close-duration=fast]) .dismiss-progress:after*/.sc-calcite-alert-h:hover[auto-close-duration=fast] .dismiss-progress.sc-calcite-alert:after{animation-play-state:paused}/*!@:host([auto-close-duration=medium]) .dismiss-progress:after*/[auto-close-duration=medium].sc-calcite-alert-h .dismiss-progress.sc-calcite-alert:after{animation:dismissProgress 10000ms ease-out}/*!@:host(:hover[auto-close-duration=medium]) .dismiss-progress:after*/.sc-calcite-alert-h:hover[auto-close-duration=medium] .dismiss-progress.sc-calcite-alert:after{animation-play-state:paused}/*!@:host([auto-close-duration=slow]) .dismiss-progress:after*/[auto-close-duration=slow].sc-calcite-alert-h .dismiss-progress.sc-calcite-alert:after{animation:dismissProgress 14000ms ease-out}/*!@:host(:hover[auto-close-duration=slow]) .dismiss-progress:after*/.sc-calcite-alert-h:hover[auto-close-duration=slow] .dismiss-progress.sc-calcite-alert:after{animation-play-state:paused}@keyframes dismissProgress{0%{inline-size:0px;opacity:0.75}100%{inline-size:100%;opacity:1}}/*!@.container--slotted-in-shell*/.container--slotted-in-shell.sc-calcite-alert{position:absolute}/*!@:host([hidden])*/[hidden].sc-calcite-alert-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-alert{display:none}/*!@:host([calcite-hydrated-hidden])*/[calcite-hydrated-hidden].sc-calcite-alert-h{visibility:hidden !important;pointer-events:none}";

/**
 * Alerts are meant to provide a way to communicate urgent or important information to users, frequently as a result of an action they took in your app. Alerts are positioned
 * at the bottom of the page. Multiple opened alerts will be added to a queue, allowing users to dismiss them in the order they are provided.
 */
/**
 * @slot title - A slot for adding a title to the component.
 * @slot message - A slot for adding main text to the component.
 * @slot link - A slot for adding a `calcite-action` to take from the component such as: "undo", "try again", "link to page", etc.
 * @slot actions-end - A slot for adding `calcite-action`s to the end of the component. It is recommended to use two or fewer actions.
 */
class Alert {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteAlertBeforeClose = createEvent(this, "calciteAlertBeforeClose", 6);
        this.calciteAlertClose = createEvent(this, "calciteAlertClose", 6);
        this.calciteAlertBeforeOpen = createEvent(this, "calciteAlertBeforeOpen", 6);
        this.calciteAlertOpen = createEvent(this, "calciteAlertOpen", 6);
        this.calciteInternalAlertSync = createEvent(this, "calciteInternalAlertSync", 6);
        this.calciteInternalAlertRegister = createEvent(this, "calciteInternalAlertRegister", 6);
        this.autoCloseTimeoutId = null;
        this.totalOpenTime = 0;
        this.totalHoverTime = 0;
        this.openTransitionProp = "opacity";
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.setTransitionEl = (el) => {
            this.transitionEl = el;
        };
        /** close and emit calciteInternalAlertSync event with the updated queue payload */
        this.closeAlert = () => {
            this.autoCloseTimeoutId = null;
            this.queued = false;
            this.open = false;
            this.queue = this.queue.filter((el) => el !== this.el);
            this.determineActiveAlert();
            this.calciteInternalAlertSync.emit({ queue: this.queue });
        };
        this.actionsEndSlotChangeHandler = (event) => {
            this.hasEndActions = slotChangeHasAssignedElement(event);
        };
        this.handleMouseOver = () => {
            window.clearTimeout(this.autoCloseTimeoutId);
            this.totalOpenTime = Date.now() - this.initialOpenTime;
            this.lastMouseOverBegin = Date.now();
        };
        this.handleMouseLeave = () => {
            const hoverDuration = Date.now() - this.lastMouseOverBegin;
            const timeRemaining = DURATIONS[this.autoCloseDuration] - this.totalOpenTime + this.totalHoverTime;
            this.totalHoverTime = this.totalHoverTime ? hoverDuration + this.totalHoverTime : hoverDuration;
            this.autoCloseTimeoutId = window.setTimeout(() => this.closeAlert(), timeRemaining);
        };
        this.open = false;
        this.autoClose = false;
        this.autoCloseDuration = "medium";
        this.kind = "brand";
        this.icon = undefined;
        this.iconFlipRtl = false;
        this.label = undefined;
        this.numberingSystem = undefined;
        this.placement = "bottom";
        this.scale = "m";
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.slottedInShell = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
        this.numberStringFormatter = new NumberStringFormat();
        this.hasEndActions = false;
        this.queue = [];
        this.queueLength = 0;
        this.queued = false;
    }
    openHandler() {
        onToggleOpenCloseComponent(this);
        if (this.open && !this.queued) {
            this.calciteInternalAlertRegister.emit();
        }
        if (!this.open) {
            this.queue = this.queue.filter((el) => el !== this.el);
            this.calciteInternalAlertSync.emit({ queue: this.queue });
        }
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    updateDuration() {
        if (this.autoClose && this.autoCloseTimeoutId) {
            window.clearTimeout(this.autoCloseTimeoutId);
            this.autoCloseTimeoutId = window.setTimeout(() => this.closeAlert(), DURATIONS[this.autoCloseDuration]);
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectLocalized(this);
        connectMessages(this);
        const open = this.open;
        if (open && !this.queued) {
            this.calciteInternalAlertRegister.emit();
        }
        this.numberStringFormatter.numberFormatOptions = {
            locale: this.effectiveLocale,
            numberingSystem: this.numberingSystem,
            signDisplay: "always",
        };
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
        if (this.open) {
            onToggleOpenCloseComponent(this);
        }
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        window.dispatchEvent(new CustomEvent("calciteInternalAlertUnregister", {
            detail: { alert: this.el },
        }));
        window.clearTimeout(this.autoCloseTimeoutId);
        window.clearTimeout(this.queueTimeout);
        disconnectLocalized(this);
        disconnectMessages(this);
        this.slottedInShell = false;
    }
    render() {
        const { open, autoClose, label, placement, queued } = this;
        const role = autoClose ? "alert" : "alertdialog";
        const hidden = !open;
        const effectiveIcon = setRequestedIcon(KindIcons, this.icon, this.kind);
        const hasQueuedAlerts = this.queueLength > 1;
        return (hAsync(Host, { "aria-hidden": toAriaBoolean(hidden), "aria-label": label, "calcite-hydrated-hidden": hidden, role: role }, hAsync("div", { class: {
                [CSS$1h.container]: true,
                [CSS$1h.containerQueued]: queued,
                [`${CSS$1h.container}--${placement}`]: true,
                [CSS$1h.containerSlottedInShell]: this.slottedInShell,
            }, onPointerEnter: this.autoClose && this.autoCloseTimeoutId ? this.handleMouseOver : null, onPointerLeave: this.autoClose && this.autoCloseTimeoutId ? this.handleMouseLeave : null,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setTransitionEl }, effectiveIcon && this.renderIcon(effectiveIcon), hAsync("div", { class: CSS$1h.textContainer }, hAsync("slot", { name: SLOTS$t.title }), hAsync("slot", { name: SLOTS$t.message }), hAsync("slot", { name: SLOTS$t.link })), this.renderActionsEnd(), hasQueuedAlerts ? this.renderQueueCount() : null, this.renderCloseButton(), open && !queued && autoClose ? hAsync("div", { class: CSS$1h.dismissProgress }) : null)));
    }
    renderCloseButton() {
        return (hAsync("button", { "aria-label": this.messages.close, class: CSS$1h.close, key: "close", onClick: this.closeAlert, type: "button",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.closeButton = el) }, hAsync("calcite-icon", { icon: "x", scale: getIconScale(this.scale) })));
    }
    renderQueueCount() {
        const queueNumber = this.queueLength > 2 ? this.queueLength - 1 : 1;
        const queueText = this.numberStringFormatter.numberFormatter.format(queueNumber);
        return (hAsync("div", { class: {
                [CSS$1h.queueCount]: true,
                [CSS$1h.queueCountActive]: this.queueLength > 1,
            }, key: "queue-count" }, hAsync("calcite-chip", { scale: this.scale, value: queueText }, queueText)));
    }
    renderActionsEnd() {
        return (hAsync("div", { class: CSS$1h.actionsEnd }, hAsync("slot", { name: SLOTS$t.actionsEnd, onSlotchange: this.actionsEndSlotChangeHandler })));
    }
    renderIcon(icon) {
        return (hAsync("div", { class: CSS$1h.icon }, hAsync("calcite-icon", { flipRtl: this.iconFlipRtl, icon: icon, scale: getIconScale(this.scale) })));
    }
    // when an alert is opened or closed, update queue and determine active alert
    alertSync(event) {
        if (this.queue !== event.detail.queue) {
            this.queue = event.detail.queue;
        }
        this.queueLength = this.queue.length;
        this.determineActiveAlert();
        event.stopPropagation();
    }
    // when an alert is first registered, trigger a queue sync
    alertRegister() {
        if (this.open && !this.queue.includes(this.el)) {
            this.queued = true;
            this.queue.push(this.el);
        }
        this.calciteInternalAlertSync.emit({ queue: this.queue });
        this.determineActiveAlert();
    }
    // Event is dispatched on the window because the element is not in the DOM so bubbling won't occur.
    alertUnregister(event) {
        const queue = this.queue.filter((el) => el !== event.detail.alert);
        this.queue = queue;
        window.dispatchEvent(new CustomEvent("calciteInternalAlertSync", {
            detail: { queue },
        }));
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component's "close" button, the first focusable item. */
    async setFocus() {
        await componentFocusable(this);
        const alertLinkEl = getSlotted(this.el, { selector: "calcite-link" });
        if (!this.closeButton && !alertLinkEl) {
            return;
        }
        else if (alertLinkEl) {
            return alertLinkEl.setFocus();
        }
        else if (this.closeButton) {
            this.closeButton.focus();
        }
    }
    effectiveLocaleChange() {
        updateMessages(this);
        this.numberStringFormatter.numberFormatOptions = {
            locale: this.effectiveLocale,
            numberingSystem: this.numberingSystem,
            signDisplay: "always",
        };
    }
    numberingSystemChange() {
        this.numberStringFormatter.numberFormatOptions = {
            locale: this.effectiveLocale,
            numberingSystem: this.numberingSystem,
            signDisplay: "always",
        };
    }
    /** determine which alert is active */
    determineActiveAlert() {
        if (this.queue?.[0] === this.el) {
            this.openAlert();
            if (this.autoClose && !this.autoCloseTimeoutId) {
                this.initialOpenTime = Date.now();
                this.autoCloseTimeoutId = window.setTimeout(() => this.closeAlert(), DURATIONS[this.autoCloseDuration]);
            }
        }
        else {
            return;
        }
    }
    onBeforeOpen() {
        this.calciteAlertBeforeOpen.emit();
    }
    onOpen() {
        this.calciteAlertOpen.emit();
    }
    onBeforeClose() {
        this.calciteAlertBeforeClose.emit();
    }
    onClose() {
        this.calciteAlertClose.emit();
    }
    /** remove queued class after animation completes */
    openAlert() {
        window.clearTimeout(this.queueTimeout);
        this.queueTimeout = window.setTimeout(() => (this.queued = false), 300);
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "open": ["openHandler"],
        "messageOverrides": ["onMessagesChange"],
        "autoCloseDuration": ["updateDuration"],
        "effectiveLocale": ["effectiveLocaleChange"],
        "numberingSystem": ["numberingSystemChange"]
    }; }
    static get style() { return alertCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-alert",
        "$members$": {
            "open": [1540],
            "autoClose": [516, "auto-close"],
            "autoCloseDuration": [513, "auto-close-duration"],
            "kind": [513],
            "icon": [520],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "label": [1],
            "numberingSystem": [513, "numbering-system"],
            "placement": [513],
            "scale": [513],
            "messages": [1040],
            "messageOverrides": [1040],
            "slottedInShell": [1028, "slotted-in-shell"],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "numberStringFormatter": [32],
            "hasEndActions": [32],
            "queue": [32],
            "queueLength": [32],
            "queued": [32],
            "setFocus": [64]
        },
        "$listeners$": [[8, "calciteInternalAlertSync", "alertSync"], [8, "calciteInternalAlertRegister", "alertRegister"], [8, "calciteInternalAlertUnregister", "alertUnregister"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["open", "open"], ["autoClose", "auto-close"], ["autoCloseDuration", "auto-close-duration"], ["kind", "kind"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["numberingSystem", "numbering-system"], ["placement", "placement"], ["scale", "scale"]]
    }; }
}

const hexChar = /^[0-9A-F]$/i;
const shorthandHex = /^#[0-9A-F]{3}$/i;
const longhandHex = /^#[0-9A-F]{6}$/i;
const shorthandHexWithAlpha = /^#[0-9A-F]{4}$/i;
const longhandHexWithAlpha = /^#[0-9A-F]{8}$/i;
const alphaToOpacity = (alpha) => Number((alpha * 100).toFixed());
const opacityToAlpha = (opacity) => Number((opacity / 100).toFixed(2));
function isValidHex(hex, hasAlpha = false) {
    return isShorthandHex(hex, hasAlpha) || isLonghandHex(hex, hasAlpha);
}
function evaluateHex(hex, length, pattern) {
    if (!hex) {
        return false;
    }
    return hex.length === length && pattern.test(hex);
}
function isShorthandHex(hex, hasAlpha = false) {
    const hexLength = hasAlpha ? 5 : 4;
    const hexPattern = hasAlpha ? shorthandHexWithAlpha : shorthandHex;
    return evaluateHex(hex, hexLength, hexPattern);
}
function isLonghandHex(hex, hasAlpha = false) {
    const hexLength = hasAlpha ? 9 : 7;
    const hexPattern = hasAlpha ? longhandHexWithAlpha : longhandHex;
    return evaluateHex(hex, hexLength, hexPattern);
}
function normalizeHex(hex, hasAlpha = false, convertFromHexToHexa = false) {
    hex = hex.toLowerCase();
    if (!hex.startsWith("#")) {
        hex = `#${hex}`;
    }
    if (isShorthandHex(hex, hasAlpha)) {
        return rgbToHex(hexToRGB(hex, hasAlpha));
    }
    if (hasAlpha && convertFromHexToHexa && isValidHex(hex, false /* we only care about RGB hex for conversion */)) {
        const isShorthand = isShorthandHex(hex, false);
        return rgbToHex(hexToRGB(`${hex}${isShorthand ? "f" : "ff"}`, true));
    }
    return hex;
}
function hexify(color, hasAlpha = false) {
    return hasAlpha ? color.hexa() : color.hex();
}
function rgbToHex(color) {
    const { r, g, b } = color;
    const rChars = numToHex(r);
    const gChars = numToHex(g);
    const bChars = numToHex(b);
    const alphaChars = "a" in color ? numToHex(color.a * 255) : "";
    return `#${rChars}${gChars}${bChars}${alphaChars}`.toLowerCase();
}
function numToHex(num) {
    return num.toString(16).padStart(2, "0");
}
function normalizeAlpha(colorObject) {
    const normalized = { ...colorObject, a: colorObject.alpha ?? 1 /* Color() will omit alpha if 1 */ };
    delete normalized.alpha;
    return normalized;
}
function normalizeColor(alphaColorObject) {
    const normalized = { ...alphaColorObject, alpha: alphaColorObject.a ?? 1 };
    delete normalized.a;
    return normalized;
}
function hexToRGB(hex, hasAlpha = false) {
    if (!isValidHex(hex, hasAlpha)) {
        return null;
    }
    hex = hex.replace("#", "");
    let r;
    let g;
    let b;
    let a;
    const isShorthand = hex.length === 3 || hex.length === 4;
    if (isShorthand) {
        const [first, second, third, fourth] = hex.split("");
        r = parseInt(`${first}${first}`, 16);
        g = parseInt(`${second}${second}`, 16);
        b = parseInt(`${third}${third}`, 16);
        a = parseInt(`${fourth}${fourth}`, 16) / 255;
    }
    else {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
        a = parseInt(hex.slice(6, 8), 16) / 255;
    }
    return isNaN(a) ? { r, g, b } : { r, g, b, a };
}
// these utils allow users to pass enum values as strings without having to access the enum
// based on the approach suggested by https://github.com/microsoft/TypeScript/issues/17690#issuecomment-321365759,
const enumify = (x) => x;
const CSSColorMode = enumify({
    HEX: "hex",
    HEXA: "hexa",
    RGB_CSS: "rgb-css",
    RGBA_CSS: "rgba-css",
    HSL_CSS: "hsl-css",
    HSLA_CSS: "hsla-css",
});
const ObjectColorMode = enumify({
    RGB: "rgb",
    RGBA: "rgba",
    HSL: "hsl",
    HSLA: "hsla",
    HSV: "hsv",
    HSVA: "hsva",
});
function parseMode(colorValue) {
    if (typeof colorValue === "string") {
        if (colorValue.startsWith("#")) {
            const { length } = colorValue;
            if (length === 4 || length === 7) {
                return CSSColorMode.HEX;
            }
            if (length === 5 || length === 9) {
                return CSSColorMode.HEXA;
            }
        }
        if (colorValue.startsWith("rgba(")) {
            return CSSColorMode.RGBA_CSS;
        }
        if (colorValue.startsWith("rgb(")) {
            return CSSColorMode.RGB_CSS;
        }
        if (colorValue.startsWith("hsl(")) {
            return CSSColorMode.HSL_CSS;
        }
        if (colorValue.startsWith("hsla(")) {
            return CSSColorMode.HSLA_CSS;
        }
    }
    if (typeof colorValue === "object") {
        if (hasChannels(colorValue, "r", "g", "b")) {
            return hasChannels(colorValue, "a") ? ObjectColorMode.RGBA : ObjectColorMode.RGB;
        }
        if (hasChannels(colorValue, "h", "s", "l")) {
            return hasChannels(colorValue, "a") ? ObjectColorMode.HSLA : ObjectColorMode.HSL;
        }
        if (hasChannels(colorValue, "h", "s", "v")) {
            return hasChannels(colorValue, "a") ? ObjectColorMode.HSVA : ObjectColorMode.HSV;
        }
    }
    return null;
}
function hasChannels(colorObject, ...channels) {
    return channels.every((channel) => channel && colorObject && `${channel}` in colorObject);
}
function colorEqual(value1, value2) {
    return value1?.rgb().array().toString() === value2?.rgb().array().toString();
}
function alphaCompatible(mode) {
    return (mode === CSSColorMode.HEXA ||
        mode === CSSColorMode.RGBA_CSS ||
        mode === CSSColorMode.HSLA_CSS ||
        mode === ObjectColorMode.RGBA ||
        mode === ObjectColorMode.HSLA ||
        mode === ObjectColorMode.HSVA);
}
function toAlphaMode(mode) {
    const alphaMode = mode === CSSColorMode.HEX
        ? CSSColorMode.HEXA
        : mode === CSSColorMode.RGB_CSS
            ? CSSColorMode.RGBA_CSS
            : mode === CSSColorMode.HSL_CSS
                ? CSSColorMode.HSLA_CSS
                : mode === ObjectColorMode.RGB
                    ? ObjectColorMode.RGBA
                    : mode === ObjectColorMode.HSL
                        ? ObjectColorMode.HSLA
                        : mode === ObjectColorMode.HSV
                            ? ObjectColorMode.HSVA
                            : mode;
    return alphaMode;
}
function toNonAlphaMode(mode) {
    const nonAlphaMode = mode === CSSColorMode.HEXA
        ? CSSColorMode.HEX
        : mode === CSSColorMode.RGBA_CSS
            ? CSSColorMode.RGB_CSS
            : mode === CSSColorMode.HSLA_CSS
                ? CSSColorMode.HSL_CSS
                : mode === ObjectColorMode.RGBA
                    ? ObjectColorMode.RGB
                    : mode === ObjectColorMode.HSLA
                        ? ObjectColorMode.HSL
                        : mode === ObjectColorMode.HSVA
                            ? ObjectColorMode.HSV
                            : mode;
    return nonAlphaMode;
}

/**
 * Convert a string to a valid hex by hashing its contents
 * and using the hash as a seed for three distinct color values
 *
 * @param str
 */
function stringToHex(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    let hex = "#";
    for (let j = 0; j < 3; j++) {
        const value = (hash >> (j * 8)) & 0xff;
        hex += ("00" + value.toString(16)).substr(-2);
    }
    return hex;
}
/**
 * Find the hue of a color given the separate RGB color channels
 *
 * @param rgb
 */
function rgbToHue(rgb) {
    let { r, g, b } = rgb;
    r /= 255;
    g /= 255;
    b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const delta = max - min;
    if (max === min) {
        return 0;
    }
    let hue = (max + min) / 2;
    switch (max) {
        case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
        case g:
            hue = (b - r) / delta + 2;
            break;
        case b:
            hue = (r - g) / delta + 4;
            break;
    }
    return Math.round(hue * 60);
}
/**
 * For a hex color, find the hue
 *
 * @param hex {string} - form of "#------"
 */
function hexToHue(hex) {
    return rgbToHue(hexToRGB(hex));
}

const avatarCss = "/*!@:host*/.sc-calcite-avatar-h{display:inline-block;overflow:hidden;border-radius:50%}/*!@:host([scale=s])*/[scale=s].sc-calcite-avatar-h{block-size:1.5rem;inline-size:1.5rem;font-size:var(--calcite-font-size--3)}/*!@:host([scale=m])*/[scale=m].sc-calcite-avatar-h{block-size:2rem;inline-size:2rem;font-size:var(--calcite-font-size--2)}/*!@:host([scale=l])*/[scale=l].sc-calcite-avatar-h{block-size:2.75rem;inline-size:2.75rem;font-size:var(--calcite-font-size-0)}/*!@.icon*/.icon.sc-calcite-avatar{display:flex}/*!@.background*/.background.sc-calcite-avatar{display:flex;block-size:100%;inline-size:100%;align-items:center;justify-content:center;border-radius:50%}/*!@.initials*/.initials.sc-calcite-avatar{font-weight:var(--calcite-font-weight-bold);text-transform:uppercase;color:var(--calcite-color-text-2)}/*!@.thumbnail*/.thumbnail.sc-calcite-avatar{block-size:100%;inline-size:100%;border-radius:50%}/*!@:host([hidden])*/[hidden].sc-calcite-avatar-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-avatar{display:none}";

class Avatar {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.scale = "m";
        this.thumbnail = undefined;
        this.fullName = undefined;
        this.username = undefined;
        this.userId = undefined;
        this.label = undefined;
        this.thumbnailFailedToLoad = false;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    render() {
        return this.determineContent();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    determineContent() {
        if (this.thumbnail && !this.thumbnailFailedToLoad) {
            return (hAsync("img", { alt: this.label || "", class: "thumbnail", onError: () => (this.thumbnailFailedToLoad = true), src: this.thumbnail }));
        }
        const initials = this.generateInitials();
        const backgroundColor = this.generateFillColor();
        return (hAsync("span", { "aria-label": this.label || this.fullName, class: "background", role: "figure", style: { backgroundColor } }, initials ? (hAsync("span", { "aria-hidden": "true", class: "initials" }, initials)) : (hAsync("calcite-icon", { class: "icon", icon: "user", scale: this.scale }))));
    }
    /**
     * Generate a valid background color that is consistent and unique to this user
     */
    generateFillColor() {
        const { userId, username, fullName, el } = this;
        const theme = getModeName(el);
        const id = userId && `#${userId.substr(userId.length - 6)}`;
        const name = username || fullName || "";
        const hex = id && isValidHex(id) ? id : stringToHex(name);
        // if there is not unique information, or an invalid hex is produced, return a default
        if ((!userId && !name) || !isValidHex(hex)) {
            return `var(--calcite-color-foreground-2)`;
        }
        const hue = hexToHue(hex);
        const l = theme === "dark" ? 20 : 90;
        return `hsl(${hue}, 60%, ${l}%)`;
    }
    /**
     * Use fullName or username to generate initials
     */
    generateInitials() {
        const { fullName, username } = this;
        if (fullName) {
            return fullName
                .trim()
                .split(" ")
                .map((name) => name.substring(0, 1))
                .join("");
        }
        else if (username) {
            return username.substring(0, 2);
        }
        return false;
    }
    get el() { return getElement(this); }
    static get style() { return avatarCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-avatar",
        "$members$": {
            "scale": [513],
            "thumbnail": [513],
            "fullName": [513, "full-name"],
            "username": [513],
            "userId": [513, "user-id"],
            "label": [1],
            "thumbnailFailedToLoad": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["scale", "scale"], ["thumbnail", "thumbnail"], ["fullName", "full-name"], ["username", "username"], ["userId", "user-id"]]
    }; }
}

function constrainHeadingLevel(level) {
    return Math.min(Math.max(Math.ceil(level), 1), 6);
}
const Heading = (props, children) => {
    const HeadingTag = props.level ? `h${props.level}` : "div";
    delete props.level;
    return hAsync(HeadingTag, { ...props }, children);
};

const IDS$1 = {
    content: "content",
    toggle: "toggle",
    header: "header",
};
const CSS$1g = {
    button: "button",
    container: "container",
    content: "content",
    controlContainer: "control-container",
    description: "description",
    header: "header",
    headerContainer: "header-container",
    heading: "heading",
    icon: "icon",
    invalid: "invalid",
    statusIcon: "status-icon",
    summary: "summary",
    title: "title",
    toggle: "toggle",
    toggleIcon: "toggle-icon",
    valid: "valid",
};
const SLOTS$s = {
    icon: "icon",
    control: "control",
    headerMenuActions: "header-menu-actions",
};
const ICONS$i = {
    opened: "chevron-up",
    closed: "chevron-down",
    valid: "check-circle",
    invalid: "exclamation-mark-triangle",
};

const blockCss = "/*!@:host*/.sc-calcite-block-h{box-sizing:border-box;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host **/.sc-calcite-block-h *.sc-calcite-block{box-sizing:border-box}/*!@:host*/.sc-calcite-block-h{--calcite-icon-size:1rem;--calcite-spacing-eighth:0.125rem;--calcite-spacing-quarter:0.25rem;--calcite-spacing-half:0.5rem;--calcite-spacing-three-quarters:0.75rem;--calcite-spacing:1rem;--calcite-spacing-plus-quarter:1.25rem;--calcite-spacing-plus-half:1.5rem;--calcite-spacing-double:2rem;--calcite-menu-min-width:10rem;--calcite-header-min-height:3rem;--calcite-footer-min-height:3rem}/*!@:host([disabled])*/[disabled].sc-calcite-block-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-block-h *.sc-calcite-block,.sc-calcite-block-h[disabled].sc-calcite-block-s>*,.sc-calcite-block-h[disabled] .sc-calcite-block-s>*{pointer-events:none}/*!@:host*/.sc-calcite-block-h{display:flex;flex-shrink:0;flex-grow:0;flex-direction:column;border-width:0px;border-block-end-width:1px;border-style:solid;border-color:var(--calcite-color-border-3);padding:0px;transition-property:margin;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;transition-timing-function:cubic-bezier(0.215, 0.440, 0.420, 0.880);flex-basis:auto}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-block-h[disabled] .sc-calcite-block-s>[calcite-hydrated][disabled],[disabled].sc-calcite-block-h [calcite-hydrated][disabled].sc-calcite-block{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-block{display:contents}/*!@.header*/.header.sc-calcite-block{margin:0px;display:flex;align-content:space-between;align-items:center;fill:var(--calcite-color-text-2);color:var(--calcite-color-text-2)}/*!@.heading*/.heading.sc-calcite-block{margin:0px;padding:0px;font-weight:var(--calcite-font-weight-medium)}/*!@.header .heading*/.header.sc-calcite-block .heading.sc-calcite-block{flex:1 1 auto;padding:0.5rem}/*!@.header*/.header.sc-calcite-block{justify-content:flex-start;padding:0px}/*!@.header,\n.toggle*/.header.sc-calcite-block,.toggle.sc-calcite-block{grid-area:header}/*!@.header-container*/.header-container.sc-calcite-block{display:grid;align-items:stretch;grid-template:auto/auto 1fr auto auto;grid-template-areas:\"handle header control menu\";grid-column:header-start/menu-end;grid-row:1/2}/*!@.toggle*/.toggle.sc-calcite-block{margin:0px;display:flex;cursor:pointer;flex-wrap:nowrap;align-items:center;justify-content:space-between;border-style:none;padding:0px;font-family:inherit;outline-color:transparent;text-align:initial;background-color:transparent}/*!@.toggle:hover*/.toggle.sc-calcite-block:hover{background-color:var(--calcite-color-foreground-2)}/*!@.toggle:focus*/.toggle.sc-calcite-block:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@calcite-loader[inline]*/calcite-loader[inline].sc-calcite-block{grid-area:control;align-self:center}/*!@calcite-handle*/calcite-handle.sc-calcite-block{grid-area:handle}/*!@.title*/.title.sc-calcite-block{margin:0px;padding:0.75rem}/*!@.header .title .heading*/.header.sc-calcite-block .title.sc-calcite-block .heading.sc-calcite-block{padding:0px;font-size:var(--calcite-font-size--1);font-weight:var(--calcite-font-weight-medium);line-height:1.25;color:var(--calcite-color-text-2);transition-property:color;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);word-wrap:break-word;word-break:break-word}/*!@.description*/.description.sc-calcite-block{margin-block-start:0.125rem;padding:0px;font-size:var(--calcite-font-size--2);line-height:1.375;color:var(--calcite-color-text-3);word-wrap:break-word;word-break:break-word}/*!@.icon*/.icon.sc-calcite-block{display:flex;margin-inline-start:0.75rem;margin-inline-end:0px}/*!@.status-icon.valid*/.status-icon.valid.sc-calcite-block{color:var(--calcite-color-status-success)}/*!@.status-icon.invalid*/.status-icon.invalid.sc-calcite-block{color:var(--calcite-color-status-danger)}@keyframes spin{0%{transform:rotate(0deg)}50%{transform:rotate(180deg)}100%{transform:rotate(360deg)}}/*!@.toggle-icon*/.toggle-icon.sc-calcite-block{margin-block:0.75rem;align-self:center;justify-self:end;color:var(--calcite-color-text-3);transition-property:color;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);margin-inline-end:0.75rem;margin-inline-start:auto}/*!@.toggle:hover .toggle-icon*/.toggle.sc-calcite-block:hover .toggle-icon.sc-calcite-block{color:var(--calcite-color-text-1)}/*!@.container*/.container.sc-calcite-block{position:relative;display:flex;block-size:100%;flex-direction:column}/*!@.content*/.content.sc-calcite-block{position:relative;min-block-size:0px;flex:1 1 0%}@keyframes in{0%{opacity:0}100%{opacity:1}}/*!@.content*/.content.sc-calcite-block{animation:in var(--calcite-internal-animation-timing-slow) ease-in-out;padding-block:var(--calcite-block-padding, 0.5rem);padding-inline:var(--calcite-block-padding, 0.625rem)}/*!@.control-container*/.control-container.sc-calcite-block{margin:0px;display:flex;grid-area:control}/*!@calcite-action-menu*/calcite-action-menu.sc-calcite-block{grid-area:menu}/*!@:host([open])*/[open].sc-calcite-block-h{margin-block:0.5rem}/*!@:host([open]) .header .title .heading*/[open].sc-calcite-block-h .header.sc-calcite-block .title.sc-calcite-block .heading.sc-calcite-block{color:var(--calcite-color-text-1)}/*!@:host([hidden])*/[hidden].sc-calcite-block-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-block{display:none}";

/**
 * @slot - A slot for adding custom content.
 * @slot icon - A slot for adding a leading header icon with `calcite-icon`.
 * @slot control - A slot for adding a single HTML input element in a header.
 * @slot header-menu-actions - A slot for adding an overflow menu with `calcite-action`s inside a dropdown menu.
 */
class Block {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteBlockBeforeClose = createEvent(this, "calciteBlockBeforeClose", 6);
        this.calciteBlockBeforeOpen = createEvent(this, "calciteBlockBeforeOpen", 6);
        this.calciteBlockClose = createEvent(this, "calciteBlockClose", 6);
        this.calciteBlockOpen = createEvent(this, "calciteBlockOpen", 6);
        this.calciteBlockToggle = createEvent(this, "calciteBlockToggle", 6);
        this.openTransitionProp = "opacity";
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.onHeaderClick = () => {
            this.open = !this.open;
            this.calciteBlockToggle.emit();
        };
        this.setTransitionEl = (el) => {
            this.transitionEl = el;
        };
        this.collapsible = false;
        this.disabled = false;
        this.dragHandle = false;
        this.heading = undefined;
        this.headingLevel = undefined;
        this.loading = false;
        this.open = false;
        this.status = undefined;
        this.description = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.overlayPositioning = "absolute";
        this.effectiveLocale = undefined;
        this.defaultMessages = undefined;
    }
    openHandler() {
        onToggleOpenCloseComponent(this);
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Sets focus on the component's first tabbable element.
     *
     */
    async setFocus() {
        await componentFocusable(this);
        focusFirstTabbable(this.el);
    }
    onBeforeOpen() {
        this.calciteBlockBeforeOpen.emit();
    }
    onOpen() {
        this.calciteBlockOpen.emit();
    }
    onBeforeClose() {
        this.calciteBlockBeforeClose.emit();
    }
    onClose() {
        this.calciteBlockClose.emit();
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectConditionalSlotComponent(this);
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        disconnectConditionalSlotComponent(this);
    }
    async componentWillLoad() {
        await setUpMessages(this);
        setUpLoadableComponent(this);
        if (this.open) {
            onToggleOpenCloseComponent(this);
        }
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderScrim() {
        const { loading } = this;
        const defaultSlot = hAsync("slot", null);
        return [loading ? hAsync("calcite-scrim", { loading: loading }) : null, defaultSlot];
    }
    renderIcon() {
        const { loading, messages, status } = this;
        const hasSlottedIcon = !!getSlotted(this.el, SLOTS$s.icon);
        return loading ? (hAsync("div", { class: CSS$1g.icon, key: "loader" }, hAsync("calcite-loader", { inline: true, label: messages.loading }))) : !!status ? (hAsync("div", { class: CSS$1g.icon, key: "status-icon" }, hAsync("calcite-icon", { class: {
                [CSS$1g.statusIcon]: true,
                [CSS$1g.valid]: status == "valid",
                [CSS$1g.invalid]: status == "invalid",
            }, icon: ICONS$i[status], scale: "s" }))) : hasSlottedIcon ? (hAsync("div", { class: CSS$1g.icon, key: "icon-slot" }, hAsync("slot", { key: "icon-slot", name: SLOTS$s.icon }))) : null;
    }
    renderTitle() {
        const { heading, headingLevel, description } = this;
        return heading || description ? (hAsync("div", { class: CSS$1g.title }, hAsync(Heading, { class: CSS$1g.heading, level: headingLevel }, heading), description ? hAsync("div", { class: CSS$1g.description }, description) : null)) : null;
    }
    render() {
        const { collapsible, el, loading, open, heading, messages } = this;
        const toggleLabel = open ? messages.collapse : messages.expand;
        const headerContent = (hAsync("header", { class: CSS$1g.header, id: IDS$1.header }, this.renderIcon(), this.renderTitle()));
        const hasControl = !!getSlotted(el, SLOTS$s.control);
        const hasMenuActions = !!getSlotted(el, SLOTS$s.headerMenuActions);
        const collapseIcon = open ? ICONS$i.opened : ICONS$i.closed;
        const headerNode = (hAsync("div", { class: CSS$1g.headerContainer }, this.dragHandle ? hAsync("calcite-handle", { label: heading }) : null, collapsible ? (hAsync("button", { "aria-controls": IDS$1.content, "aria-describedby": IDS$1.header, "aria-expanded": collapsible ? toAriaBoolean(open) : null, class: CSS$1g.toggle, id: IDS$1.toggle, onClick: this.onHeaderClick, title: toggleLabel }, headerContent, hAsync("calcite-icon", { "aria-hidden": "true", class: CSS$1g.toggleIcon, icon: collapseIcon, scale: "s" }))) : (headerContent), hasControl ? (hAsync("div", { class: CSS$1g.controlContainer }, hAsync("slot", { name: SLOTS$s.control }))) : null, hasMenuActions ? (hAsync("calcite-action-menu", { label: messages.options, overlayPositioning: this.overlayPositioning }, hAsync("slot", { name: SLOTS$s.headerMenuActions }))) : null));
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("article", { "aria-busy": toAriaBoolean(loading), class: {
                [CSS$1g.container]: true,
            } }, headerNode, hAsync("section", { "aria-labelledby": IDS$1.toggle, class: CSS$1g.content, hidden: !open, id: IDS$1.content,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setTransitionEl }, this.renderScrim())))));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "open": ["openHandler"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return blockCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-block",
        "$members$": {
            "collapsible": [516],
            "disabled": [516],
            "dragHandle": [516, "drag-handle"],
            "heading": [1],
            "headingLevel": [514, "heading-level"],
            "loading": [516],
            "open": [1540],
            "status": [513],
            "description": [1],
            "messages": [1040],
            "messageOverrides": [1040],
            "overlayPositioning": [513, "overlay-positioning"],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["collapsible", "collapsible"], ["disabled", "disabled"], ["dragHandle", "drag-handle"], ["headingLevel", "heading-level"], ["loading", "loading"], ["open", "open"], ["status", "status"], ["overlayPositioning", "overlay-positioning"]]
    }; }
}

const IDS = {
    content: "content",
    toggle: "toggle",
};
const CSS$1f = {
    content: "content",
    focusGuard: "focus-guard",
    invalid: "invalid",
    sectionHeader: "section-header",
    sectionHeaderText: "section-header__text",
    statusIcon: "status-icon",
    toggle: "toggle",
    toggleSwitch: "toggle--switch",
    toggleSwitchContainer: "toggle--switch-container",
    toggleSwitchContent: "toggle--switch__content",
    toggleSwitchText: "toggle--switch__text",
    valid: "valid",
};
const ICONS$h = {
    menuOpen: "chevron-down",
    menuClosedLeft: "chevron-left",
    menuClosedRight: "chevron-right",
    valid: "check-circle",
    invalid: "exclamation-mark-triangle",
};

const blockSectionCss = "/*!@:host*/.sc-calcite-block-section-h{box-sizing:border-box;display:block;background-color:var(--calcite-color-foreground-1);font-size:var(--calcite-font-size--1);color:var(--calcite-color-text-2)}/*!@:host([open])*/[open].sc-calcite-block-section-h{border-width:0px;border-block-end-width:1px;border-style:solid;border-block-end-color:var(--calcite-color-border-3)}/*!@:host(:last-child)*/.sc-calcite-block-section-h:last-child{border-block-end-width:0px}/*!@.toggle*/.toggle.sc-calcite-block-section{inline-size:100%;border-width:0px;background-color:transparent;font-family:var(--calcite-sans-family);font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-2)}/*!@.toggle--switch,\n.section-header*/.toggle--switch.sc-calcite-block-section,.section-header.sc-calcite-block-section{margin-inline:0px;margin-block:0.25rem;display:flex;cursor:pointer;-webkit-user-select:none;user-select:none;align-items:center;padding-inline:0px;padding-block:0.5rem;font-size:var(--calcite-font-size--1);outline-color:transparent}/*!@.toggle--switch:focus,\n.section-header:focus*/.toggle--switch.sc-calcite-block-section:focus,.section-header.sc-calcite-block-section:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.toggle--switch:hover,\n.section-header:hover*/.toggle--switch.sc-calcite-block-section:hover,.section-header.sc-calcite-block-section:hover{color:var(--calcite-color-text-1)}/*!@.section-header .status-icon*/.section-header.sc-calcite-block-section .status-icon.sc-calcite-block-section{align-self:flex-end}/*!@.section-header__text*/.section-header__text.sc-calcite-block-section{margin-inline:0.75rem;margin-block:0px;flex:1 1 auto;text-align:initial;word-wrap:anywhere}/*!@.toggle--switch-container*/.toggle--switch-container.sc-calcite-block-section{position:relative;display:flex;inline-size:100%;align-items:center;background-color:transparent;word-break:break-word}/*!@.toggle--switch-container .focus-guard*/.toggle--switch-container.sc-calcite-block-section .focus-guard.sc-calcite-block-section{--calcite-label-margin-bottom:0;pointer-events:none;position:absolute;inset-inline-end:0;margin-inline-start:0.25rem}/*!@.toggle--switch .status-icon*/.toggle--switch.sc-calcite-block-section .status-icon.sc-calcite-block-section{margin-inline-start:0.5rem}/*!@.toggle--switch__content*/.toggle--switch__content.sc-calcite-block-section{display:flex;flex:1 1 auto;align-items:center}/*!@.status-icon.valid*/.status-icon.valid.sc-calcite-block-section{color:var(--calcite-color-status-success)}/*!@.status-icon.invalid*/.status-icon.invalid.sc-calcite-block-section{color:var(--calcite-color-status-danger)}/*!@:host([toggle-display=switch]) .toggle .toggle--switch__content*/[toggle-display=switch].sc-calcite-block-section-h .toggle.sc-calcite-block-section .toggle--switch__content.sc-calcite-block-section{margin-inline-end:1.75rem}/*!@:host([hidden])*/[hidden].sc-calcite-block-section-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-block-section{display:none}";

/**
 * @slot - A slot for adding custom content.
 */
class BlockSection {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteBlockSectionToggle = createEvent(this, "calciteBlockSectionToggle", 6);
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.handleHeaderKeyDown = (event) => {
            if (isActivationKey(event.key)) {
                this.toggleSection();
                event.preventDefault();
                event.stopPropagation();
            }
        };
        this.toggleSection = () => {
            this.open = !this.open;
            this.calciteBlockSectionToggle.emit();
        };
        this.open = false;
        this.status = undefined;
        this.text = undefined;
        this.toggleDisplay = "button";
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.effectiveLocale = undefined;
        this.defaultMessages = undefined;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Sets focus on the component's first tabbable element.
     *
     */
    async setFocus() {
        await componentFocusable(this);
        focusFirstTabbable(this.el);
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectLocalized(this);
        connectMessages(this);
    }
    async componentWillLoad() {
        await setUpMessages(this);
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderStatusIcon() {
        const { status } = this;
        const statusIcon = ICONS$h[status] ?? false;
        const statusIconClasses = {
            [CSS$1f.statusIcon]: true,
            [CSS$1f.valid]: status == "valid",
            [CSS$1f.invalid]: status == "invalid",
        };
        return !!statusIcon ? (hAsync("calcite-icon", { class: statusIconClasses, icon: statusIcon, scale: "s" })) : null;
    }
    render() {
        const { el, messages, open, text, toggleDisplay } = this;
        const dir = getElementDir(el);
        const arrowIcon = open
            ? ICONS$h.menuOpen
            : dir === "rtl"
                ? ICONS$h.menuClosedLeft
                : ICONS$h.menuClosedRight;
        const toggleLabel = open ? messages.collapse : messages.expand;
        const headerNode = toggleDisplay === "switch" ? (hAsync("div", { class: {
                [CSS$1f.toggleSwitchContainer]: true,
            } }, hAsync("div", { "aria-controls": IDS.content, "aria-expanded": toAriaBoolean(open), class: {
                [CSS$1f.toggle]: true,
                [CSS$1f.toggleSwitch]: true,
            }, id: IDS.toggle, onClick: this.toggleSection, onKeyDown: this.handleHeaderKeyDown, role: "button", tabIndex: 0, title: toggleLabel }, hAsync("div", { class: CSS$1f.toggleSwitchContent }, hAsync("span", { class: CSS$1f.toggleSwitchText }, text)), this.renderStatusIcon()), hAsync("calcite-label", { class: CSS$1f.focusGuard, layout: "inline", tabIndex: -1 }, hAsync("calcite-switch", { checked: open, label: toggleLabel, scale: "s" })))) : (hAsync("button", { "aria-controls": IDS.content, "aria-expanded": toAriaBoolean(open), class: {
                [CSS$1f.sectionHeader]: true,
                [CSS$1f.toggle]: true,
            }, id: IDS.toggle, onClick: this.toggleSection }, hAsync("calcite-icon", { icon: arrowIcon, scale: "s" }), hAsync("span", { class: CSS$1f.sectionHeaderText }, text), this.renderStatusIcon()));
        return (hAsync(Host, null, headerNode, hAsync("section", { "aria-labelledby": IDS.toggle, class: CSS$1f.content, hidden: !open, id: IDS.content }, hAsync("slot", null))));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return blockSectionCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-block-section",
        "$members$": {
            "open": [1540],
            "status": [513],
            "text": [1],
            "toggleDisplay": [513, "toggle-display"],
            "messages": [1040],
            "messageOverrides": [1040],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["open", "open"], ["status", "status"], ["toggleDisplay", "toggle-display"]]
    }; }
}

/**
 * Any form <Component> with a `calcite<Component>Input` event needs to be included in this array.
 */
const componentsWithInputEvent = [
    "calcite-input",
    "calcite-input-number",
    "calcite-input-text",
    "calcite-text-area",
];
/**
 * Get the event name to listen for that, when emitted, will clear the
 * validation message that displays after form submission. Only validation
 * messages that are set by the browser will be cleared. If a user sets
 * validationMessage to a custom value, they are responsible for clearing it.
 *
 * Exported for testing purposes.
 *
 * @param componentTag the tag of the component, e.g. "calcite-input"
 * @returns the event name
 */
function getClearValidationEventName(componentTag) {
    const componentTagCamelCase = componentTag
        .split("-")
        .map((part, index) => index === 0 ? part : `${part[0].toUpperCase()}${part.slice(1)}`)
        .join("");
    const clearValidationEvent = `${componentTagCamelCase}${componentsWithInputEvent.includes(componentTag) ? "Input" : "Change"}`;
    return clearValidationEvent;
}
/**
 * Exported for testing purposes.
 */
const hiddenFormInputSlotName = "hidden-form-input";
function isCheckable(component) {
    return "checked" in component;
}
const onFormResetMap = new WeakMap();
const formComponentSet = new WeakSet();
/**
 * This helps determine if our form component is part of a composite form-associated component.
 *
 * @param form
 * @param formComponentEl
 */
function hasRegisteredFormComponentParent(form, formComponentEl) {
    // if we have a parent component using the form ID attribute, we assume it is form-associated
    const hasParentComponentWithFormIdSet = closestElementCrossShadowBoundary(formComponentEl.parentElement, "[form]");
    if (hasParentComponentWithFormIdSet) {
        return true;
    }
    // we use events as a way to test for nested form-associated components across shadow bounds
    const formComponentRegisterEventName = "calciteInternalFormComponentRegister";
    let hasRegisteredFormComponentParent = false;
    form.addEventListener(formComponentRegisterEventName, (event) => {
        hasRegisteredFormComponentParent = event
            .composedPath()
            .some((element) => formComponentSet.has(element));
        event.stopPropagation();
    }, { once: true });
    formComponentEl.dispatchEvent(new CustomEvent(formComponentRegisterEventName, {
        bubbles: true,
        composed: true,
    }));
    return hasRegisteredFormComponentParent;
}
function clearFormValidation(component) {
    "status" in component && (component.status = "idle");
    "validationIcon" in component && (component.validationIcon = false);
    "validationMessage" in component && (component.validationMessage = "");
}
function setInvalidFormValidation(component, message) {
    "status" in component && (component.status = "invalid");
    "validationIcon" in component && !component.validationIcon && (component.validationIcon = true);
    "validationMessage" in component &&
        !component.validationMessage &&
        (component.validationMessage = message);
}
function displayValidationMessage(event) {
    // target is the hidden input, which is slotted in the actual form component
    const hiddenInput = event?.target;
    // not necessarily a calcite-input, but we don't have an HTMLCalciteFormElement type
    const formComponent = hiddenInput?.parentElement;
    const componentTag = formComponent?.nodeName?.toLowerCase();
    const componentTagParts = componentTag?.split("-");
    if (componentTagParts.length < 2 || componentTagParts[0] !== "calcite") {
        return;
    }
    // prevent the browser from showing the native validation popover
    event?.preventDefault();
    setInvalidFormValidation(formComponent, hiddenInput?.validationMessage);
    if (formComponent?.validationMessage !== hiddenInput?.validationMessage) {
        return;
    }
    const clearValidationEvent = getClearValidationEventName(componentTag);
    formComponent.addEventListener(clearValidationEvent, () => clearFormValidation(formComponent), {
        once: true,
    });
}
/**
 * Helper to submit a form.
 *
 * @param component
 * @returns true if its associated form was submitted, false otherwise.
 */
function submitForm(component) {
    const { formEl } = component;
    if (!formEl) {
        return false;
    }
    formEl.addEventListener("invalid", displayValidationMessage, true);
    formEl.requestSubmit();
    formEl.removeEventListener("invalid", displayValidationMessage, true);
    requestAnimationFrame(() => {
        const invalidEls = formEl.querySelectorAll("[status=invalid]");
        // focus the first invalid element that has a validation message
        for (const el of invalidEls) {
            if (el?.validationMessage) {
                el?.setFocus();
                break;
            }
        }
    });
    return true;
}
/**
 * Helper to reset a form.
 *
 * @param component
 */
function resetForm(component) {
    component.formEl?.reset();
}
/**
 * Helper to set up form interactions on connectedCallback.
 *
 * @param component
 */
function connectForm(component) {
    const { el, value } = component;
    const associatedForm = findAssociatedForm(component);
    if (!associatedForm || hasRegisteredFormComponentParent(associatedForm, el)) {
        return;
    }
    component.formEl = associatedForm;
    component.defaultValue = value;
    if (isCheckable(component)) {
        component.defaultChecked = component.checked;
    }
    const boundOnFormReset = (component.onFormReset || onFormReset).bind(component);
    associatedForm.addEventListener("reset", boundOnFormReset);
    onFormResetMap.set(component.el, boundOnFormReset);
    formComponentSet.add(el);
}
/**
 * Utility method to find a form-component's associated form element.
 *
 * @param component
 */
function findAssociatedForm(component) {
    const { el, form } = component;
    return form
        ? queryElementRoots(el, { id: form })
        : closestElementCrossShadowBoundary(el, "form");
}
function onFormReset() {
    clearFormValidation(this);
    if (isCheckable(this)) {
        this.checked = this.defaultChecked;
        return;
    }
    this.value = this.defaultValue;
}
/**
 * Helper to tear down form interactions on disconnectedCallback.
 *
 * @param component
 */
function disconnectForm(component) {
    const { el, formEl } = component;
    if (!formEl) {
        return;
    }
    const boundOnFormReset = onFormResetMap.get(el);
    formEl.removeEventListener("reset", boundOnFormReset);
    onFormResetMap.delete(el);
    component.formEl = null;
    formComponentSet.delete(el);
}
/**
 * Helper for setting the default value on initialization after connectedCallback.
 *
 * Note that this is only needed if the default value cannot be determined on connectedCallback.
 *
 * @param component
 * @param value
 */
function afterConnectDefaultValueSet(component, value) {
    component.defaultValue = value;
}
const internalHiddenInputInputEvent = "calciteInternalHiddenInputInput";
const hiddenInputInputHandler = (event) => {
    event.target.dispatchEvent(new CustomEvent(internalHiddenInputInputEvent, { bubbles: true }));
};
const removeHiddenInputChangeEventListener = (input) => input.removeEventListener("input", hiddenInputInputHandler);
/**
 * Helper for maintaining a form-associated's hidden input in sync with the component.
 *
 * Based on Ionic's approach: https://github.com/ionic-team/ionic-framework/blob/e4bf052794af9aac07f887013b9250d2a045eba3/core/src/utils/helpers.ts#L198
 *
 * @param component
 */
function syncHiddenFormInput$1(component) {
    const { el, formEl, name, value } = component;
    const { ownerDocument } = el;
    const inputs = el.querySelectorAll(`input[slot="${hiddenFormInputSlotName}"]`);
    if (!formEl || !name) {
        inputs.forEach((input) => {
            removeHiddenInputChangeEventListener(input);
            input.remove();
        });
        return;
    }
    const values = Array.isArray(value) ? value : [value];
    const extra = [];
    const seen = new Set();
    inputs.forEach((input) => {
        const valueMatch = values.find((val) => 
        /* intentional non-strict equality check */
        val == input.value);
        if (valueMatch != null) {
            seen.add(valueMatch);
            defaultSyncHiddenFormInput(component, input, valueMatch);
        }
        else {
            extra.push(input);
        }
    });
    let docFrag;
    values.forEach((value) => {
        if (seen.has(value)) {
            return;
        }
        let input = extra.pop();
        if (!input) {
            input = ownerDocument.createElement("input");
            input.slot = hiddenFormInputSlotName;
        }
        if (!docFrag) {
            docFrag = ownerDocument.createDocumentFragment();
        }
        docFrag.append(input);
        // emits when hidden input is autofilled
        input.addEventListener("input", hiddenInputInputHandler);
        defaultSyncHiddenFormInput(component, input, value);
    });
    if (docFrag) {
        el.append(docFrag);
    }
    extra.forEach((input) => {
        removeHiddenInputChangeEventListener(input);
        input.remove();
    });
}
function defaultSyncHiddenFormInput(component, input, value) {
    const { defaultValue, disabled, form, name, required } = component;
    // keep in sync to prevent losing reset value
    input.defaultValue = defaultValue;
    input.disabled = disabled;
    input.name = name;
    input.required = required;
    input.tabIndex = -1;
    // we set the attr as the prop is read-only
    if (form) {
        input.setAttribute("form", form);
    }
    else {
        input.removeAttribute("form");
    }
    if (isCheckable(component)) {
        input.checked = component.checked;
        // keep in sync to prevent losing reset value
        input.defaultChecked = component.defaultChecked;
        // heuristic to support default/on mode from https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default-on
        input.value = component.checked ? value || "on" : "";
    }
    else {
        input.value = value || "";
    }
    component.syncHiddenFormInput?.(input);
}
/**
 * Helper to render the slot for form-associated component's hidden input.
 *
 * If the component has a default slot, this must be placed at the bottom of the component's root container to ensure it is the last child.
 *
 * render(): VNode {
 *   <Host>
 *     <div class={CSS.container}>
 *     // ...
 *     <HiddenFormInputSlot component={this} />
 *     </div>
 *   </Host>
 * }
 *
 * Note that the hidden-form-input Sass mixin must be added to the component's style to apply specific styles.
 *
 * @param root0
 * @param root0.component
 */
const HiddenFormInputSlot = ({ component, }) => {
    syncHiddenFormInput$1(component);
    return hAsync("slot", { name: hiddenFormInputSlotName });
};

/**
 * Exported for testing purposes only
 *
 * @internal
 */
const labelClickEvent = "calciteInternalLabelClick";
const labelConnectedEvent = "calciteInternalLabelConnected";
const labelDisconnectedEvent = "calciteInternalLabelDisconnected";
const labelTagName = "calcite-label";
const labelToLabelables = new WeakMap();
const onLabelClickMap = new WeakMap();
const onLabelConnectedMap = new WeakMap();
const onLabelDisconnectedMap = new WeakMap();
const unlabeledComponents = new Set();
const findLabelForComponent = (componentEl) => {
    const { id } = componentEl;
    const forLabel = id && queryElementRoots(componentEl, { selector: `${labelTagName}[for="${id}"]` });
    if (forLabel) {
        return forLabel;
    }
    const parentLabel = closestElementCrossShadowBoundary(componentEl, labelTagName);
    if (!parentLabel ||
        // labelable components within other custom elements are not considered labelable
        hasAncestorCustomElements(parentLabel, componentEl)) {
        return null;
    }
    return parentLabel;
};
function hasAncestorCustomElements(label, componentEl) {
    let traversedElements;
    const customElementAncestorCheckEventType = "custom-element-ancestor-check";
    const listener = (event) => {
        event.stopImmediatePropagation();
        const composedPath = event.composedPath();
        traversedElements = composedPath.slice(composedPath.indexOf(componentEl), composedPath.indexOf(label));
    };
    label.addEventListener(customElementAncestorCheckEventType, listener, { once: true });
    componentEl.dispatchEvent(new CustomEvent(customElementAncestorCheckEventType, { composed: true, bubbles: true }));
    label.removeEventListener(customElementAncestorCheckEventType, listener);
    const ancestorCustomElements = traversedElements
        .filter((el) => el !== componentEl && el !== label)
        .filter((el) => el.tagName?.includes("-"));
    return ancestorCustomElements.length > 0;
}
/**
 * Helper to set up label interactions on connectedCallback.
 *
 * @param component
 */
function connectLabel(component) {
    if (!component) {
        return;
    }
    const labelEl = findLabelForComponent(component.el);
    if ((onLabelClickMap.has(labelEl) && labelEl === component.labelEl) ||
        (!labelEl && unlabeledComponents.has(component))) {
        return;
    }
    const boundOnLabelDisconnected = onLabelDisconnected.bind(component);
    if (labelEl) {
        component.labelEl = labelEl;
        const labelables = labelToLabelables.get(labelEl) || [];
        labelables.push(component);
        labelToLabelables.set(labelEl, labelables.sort(sortByDOMOrder));
        if (!onLabelClickMap.has(component.labelEl)) {
            onLabelClickMap.set(component.labelEl, onLabelClick);
            component.labelEl.addEventListener(labelClickEvent, onLabelClick);
        }
        unlabeledComponents.delete(component);
        document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));
        onLabelDisconnectedMap.set(component, boundOnLabelDisconnected);
        document.addEventListener(labelDisconnectedEvent, boundOnLabelDisconnected);
    }
    else if (!unlabeledComponents.has(component)) {
        boundOnLabelDisconnected();
        document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));
    }
}
/**
 * Helper to tear down label interactions on disconnectedCallback on labelable components.
 *
 * @param component
 */
function disconnectLabel(component) {
    if (!component) {
        return;
    }
    unlabeledComponents.delete(component);
    document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));
    document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));
    onLabelConnectedMap.delete(component);
    onLabelDisconnectedMap.delete(component);
    if (!component.labelEl) {
        return;
    }
    const labelables = labelToLabelables.get(component.labelEl);
    if (labelables.length === 1) {
        component.labelEl.removeEventListener(labelClickEvent, onLabelClickMap.get(component.labelEl));
        onLabelClickMap.delete(component.labelEl);
    }
    labelToLabelables.set(component.labelEl, labelables.filter((labelable) => labelable !== component).sort(sortByDOMOrder));
    component.labelEl = null;
}
function sortByDOMOrder(a, b) {
    return isBefore(a.el, b.el) ? -1 : 1;
}
/**
 * Helper to get the label text from a component.
 *
 * @param component
 */
function getLabelText(component) {
    return component.label || component.labelEl?.textContent?.trim() || "";
}
function onLabelClick(event) {
    const labelClickTarget = event.detail.sourceEvent.target;
    const labelables = labelToLabelables.get(this);
    const clickedLabelable = labelables.find((labelable) => labelable.el === labelClickTarget);
    const labelableChildClicked = labelables.includes(clickedLabelable);
    if (labelableChildClicked) {
        // no need to forward click as labelable will receive focus
        return;
    }
    const firstLabelable = labelables[0];
    if (firstLabelable.disabled) {
        return;
    }
    firstLabelable.onLabelClick(event);
}
function onLabelConnected() {
    if (unlabeledComponents.has(this)) {
        connectLabel(this);
    }
}
function onLabelDisconnected() {
    unlabeledComponents.add(this);
    const boundOnLabelConnected = onLabelConnectedMap.get(this) || onLabelConnected.bind(this);
    onLabelConnectedMap.set(this, boundOnLabelConnected);
    document.addEventListener(labelConnectedEvent, boundOnLabelConnected);
}
/**
 * Helper to associate an explicit label (i.e., using `for`) with a labelable component that does not have an associated label.
 *
 * @param label - the label element
 */
async function associateExplicitLabelToUnlabeledComponent(label) {
    await componentOnReady(label);
    const alreadyLabeled = labelToLabelables.has(label);
    if (alreadyLabeled) {
        return;
    }
    const forComponentEl = label.ownerDocument?.getElementById(label.for);
    if (!forComponentEl) {
        return;
    }
    requestAnimationFrame(() => {
        for (const labelable of unlabeledComponents) {
            if (labelable.el === forComponentEl) {
                connectLabel(labelable);
                break;
            }
        }
    });
}

const CSS$1e = {
    buttonLoader: "calcite-button--loader",
    content: "content",
    contentSlotted: "content--slotted",
    icon: "icon",
    iconStart: "icon--start",
    iconEnd: "icon--end",
    loadingIn: "loading-in",
    loadingOut: "loading-out",
    iconStartEmpty: "icon-start-empty",
    iconEndEmpty: "icon-end-empty",
    buttonPadding: "button-padding",
    buttonPaddingShrunk: "button-padding--shrunk",
};

const buttonCss = "/*!@:host([disabled])*/[disabled].sc-calcite-button-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-button-h *.sc-calcite-button,.sc-calcite-button-h[disabled].sc-calcite-button-s>*,.sc-calcite-button-h[disabled] .sc-calcite-button-s>*{pointer-events:none}/*!@:host*/.sc-calcite-button-h{display:inline-block;inline-size:auto;vertical-align:middle}/*!@:host([round])*/[round].sc-calcite-button-h{border-radius:50px}/*!@:host([round]) a, :host([round]) button*/[round].sc-calcite-button-h a.sc-calcite-button,[round].sc-calcite-button-h button.sc-calcite-button{border-radius:50px}/*!@:host button,\n:host a*/.sc-calcite-button-h button.sc-calcite-button,.sc-calcite-button-h a.sc-calcite-button{outline-color:transparent}/*!@:host button:focus,\n:host a:focus*/.sc-calcite-button-h button.sc-calcite-button:focus,.sc-calcite-button-h a.sc-calcite-button:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host button,\n:host a*/.sc-calcite-button-h button.sc-calcite-button,.sc-calcite-button-h a.sc-calcite-button{--calcite-button-content-margin-internal:0.5rem;--calcite-button-padding-x-internal:7px;--calcite-button-padding-y-internal:3px;padding-block:var(--calcite-button-padding-y-internal);padding-inline:var(--calcite-button-padding-x-internal);position:relative;box-sizing:border-box;display:flex;block-size:100%;inline-size:100%;cursor:pointer;-webkit-user-select:none;user-select:none;appearance:none;align-items:center;justify-content:center;border-radius:0px;border-style:none;text-align:center;font-family:inherit;font-weight:var(--calcite-font-weight-normal);text-decoration-line:none;transition:color var(--calcite-animation-timing) ease-in-out, background-color var(--calcite-animation-timing) ease-in-out, box-shadow var(--calcite-animation-timing) ease-in-out, outline-color var(--calcite-internal-animation-timing-fast) ease-in-out}/*!@:host button:hover,\n:host a:hover*/.sc-calcite-button-h button.sc-calcite-button:hover,.sc-calcite-button-h a.sc-calcite-button:hover{text-decoration-line:none}/*!@:host button span,\n:host a span*/.sc-calcite-button-h button.sc-calcite-button span.sc-calcite-button,.sc-calcite-button-h a.sc-calcite-button span.sc-calcite-button{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}/*!@.content*/.content.sc-calcite-button{margin-inline:var(--calcite-button-content-margin-internal)}/*!@.icon-start-empty .content*/.icon-start-empty.sc-calcite-button .content.sc-calcite-button{margin-inline-start:unset}/*!@.icon-end-empty .content*/.icon-end-empty.sc-calcite-button .content.sc-calcite-button{margin-inline-end:unset}/*!@:host([scale=m]) button,\n:host([scale=m]) a*/[scale=m].sc-calcite-button-h button.sc-calcite-button,[scale=m].sc-calcite-button-h a.sc-calcite-button{--calcite-button-content-margin-internal:0.75rem}/*!@:host([scale=l]) button,\n:host([scale=l]) a*/[scale=l].sc-calcite-button-h button.sc-calcite-button,[scale=l].sc-calcite-button-h a.sc-calcite-button{--calcite-button-content-margin-internal:1rem}/*!@:host([width=auto])*/[width=auto].sc-calcite-button-h{inline-size:auto}/*!@:host([width=half])*/[width=half].sc-calcite-button-h{inline-size:50%}/*!@:host([width=full])*/[width=full].sc-calcite-button-h{inline-size:100%}/*!@:host([alignment=center]:not([width=auto])) a,\n:host([alignment=center]:not([width=auto])) button*/[alignment=center].sc-calcite-button-h:not([width=auto]) a.sc-calcite-button,[alignment=center].sc-calcite-button-h:not([width=auto]) button.sc-calcite-button{justify-content:center}/*!@:host([alignment=start]:not([width=auto])) a,\n:host([alignment=start]:not([width=auto])) button*/[alignment=start].sc-calcite-button-h:not([width=auto]) a.sc-calcite-button,[alignment=start].sc-calcite-button-h:not([width=auto]) button.sc-calcite-button{justify-content:flex-start}/*!@:host([alignment=end]:not([width=auto])) a,\n:host([alignment=end]:not([width=auto])) button*/[alignment=end].sc-calcite-button-h:not([width=auto]) a.sc-calcite-button,[alignment=end].sc-calcite-button-h:not([width=auto]) button.sc-calcite-button{justify-content:flex-end}/*!@:host([alignment*=space-between]:not([width=auto])) a,\n:host([alignment*=space-between]:not([width=auto])) button*/[alignment*=space-between].sc-calcite-button-h:not([width=auto]) a.sc-calcite-button,[alignment*=space-between].sc-calcite-button-h:not([width=auto]) button.sc-calcite-button{justify-content:space-between}/*!@:host([alignment=icon-start-space-between]:not([width=auto])) .icon--start*/[alignment=icon-start-space-between].sc-calcite-button-h:not([width=auto]) .icon--start.sc-calcite-button{margin-inline-end:auto}/*!@:host([alignment=icon-start-space-between]:not([width=auto])) a,\n:host([alignment=icon-start-space-between]:not([width=auto])) button*/[alignment=icon-start-space-between].sc-calcite-button-h:not([width=auto]) a.sc-calcite-button,[alignment=icon-start-space-between].sc-calcite-button-h:not([width=auto]) button.sc-calcite-button{text-align:unset}/*!@:host([alignment=icon-end-space-between]:not([width=auto])) .icon--end*/[alignment=icon-end-space-between].sc-calcite-button-h:not([width=auto]) .icon--end.sc-calcite-button{margin-inline-start:auto}/*!@:host([alignment=icon-end-space-between]:not([width=auto])) a,\n:host([alignment=icon-end-space-between]:not([width=auto])) button*/[alignment=icon-end-space-between].sc-calcite-button-h:not([width=auto]) a.sc-calcite-button,[alignment=icon-end-space-between].sc-calcite-button-h:not([width=auto]) button.sc-calcite-button{text-align:unset}/*!@:host([alignment=center]) a:not(.content--slotted) .icon--start + .icon--end,\n:host([alignment=center]) button:not(.content--slotted) .icon--start + .icon--end*/[alignment=center].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted) .icon--start.sc-calcite-button+.icon--end.sc-calcite-button,[alignment=center].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted) .icon--start.sc-calcite-button+.icon--end.sc-calcite-button{margin-inline-start:var(--calcite-button-content-margin-internal)}/*!@.icon*/.icon.sc-calcite-button{position:relative;margin:0px;display:inline-flex;font-weight:var(--calcite-font-weight-normal);line-height:inherit}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-button-h[disabled] .sc-calcite-button-s>[calcite-hydrated][disabled],[disabled].sc-calcite-button-h [calcite-hydrated][disabled].sc-calcite-button{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-button{display:contents}@keyframes loader-in{0%{inline-size:0;opacity:0;transform:scale(0.5)}100%{inline-size:1em;opacity:1;transform:scale(1)}}@keyframes loader-out{0%{inline-size:1em;opacity:1;transform:scale(1)}100%{inline-size:0;opacity:0;transform:scale(0.5)}}/*!@.calcite-button--loader*/.calcite-button--loader.sc-calcite-button{display:flex}/*!@.calcite-button--loader calcite-loader*/.calcite-button--loader.sc-calcite-button calcite-loader.sc-calcite-button{margin:0px;transition:inline-size var(--calcite-internal-animation-timing-slow) ease-in-out, opacity var(--calcite-internal-animation-timing-slow) ease-in-out, transform var(--calcite-internal-animation-timing-slow) ease-in-out}/*!@.calcite-button--loader calcite-loader.loading-in*/.calcite-button--loader.sc-calcite-button calcite-loader.loading-in.sc-calcite-button{animation-name:loader-in;animation-duration:var(--calcite-internal-animation-timing-slow)}/*!@.calcite-button--loader calcite-loader.loading-out*/.calcite-button--loader.sc-calcite-button calcite-loader.loading-out.sc-calcite-button{animation-name:loader-out;animation-duration:var(--calcite-internal-animation-timing-slow)}/*!@:host([loading]) button.content--slotted .calcite-button--loader calcite-loader,\n:host([loading]) a.content--slotted .calcite-button--loader calcite-loader*/[loading].sc-calcite-button-h button.content--slotted.sc-calcite-button .calcite-button--loader.sc-calcite-button calcite-loader.sc-calcite-button,[loading].sc-calcite-button-h a.content--slotted.sc-calcite-button .calcite-button--loader.sc-calcite-button calcite-loader.sc-calcite-button{margin-inline-end:var(--calcite-button-content-margin-internal)}/*!@:host([loading]) button:not(.content--slotted) .icon--start,\n:host([loading]) button:not(.content--slotted) .icon--end,\n:host([loading]) a:not(.content--slotted) .icon--start,\n:host([loading]) a:not(.content--slotted) .icon--end*/[loading].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted) .icon--start.sc-calcite-button,[loading].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted) .icon--end.sc-calcite-button,[loading].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted) .icon--start.sc-calcite-button,[loading].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted) .icon--end.sc-calcite-button{display:none}/*!@:host([appearance]) button,\n:host([appearance]) a*/[appearance].sc-calcite-button-h button.sc-calcite-button,[appearance].sc-calcite-button-h a.sc-calcite-button{border-width:1px;border-style:solid;border-color:transparent}/*!@:host([kind=brand]) button,\n:host([kind=brand]) a*/[kind=brand].sc-calcite-button-h button.sc-calcite-button,[kind=brand].sc-calcite-button-h a.sc-calcite-button{background-color:var(--calcite-color-brand);color:var(--calcite-color-text-inverse)}/*!@:host([kind=brand]) button:hover, :host([kind=brand]) button:focus,\n:host([kind=brand]) a:hover,\n:host([kind=brand]) a:focus*/[kind=brand].sc-calcite-button-h button.sc-calcite-button:hover,[kind=brand].sc-calcite-button-h button.sc-calcite-button:focus,[kind=brand].sc-calcite-button-h a.sc-calcite-button:hover,[kind=brand].sc-calcite-button-h a.sc-calcite-button:focus{background-color:var(--calcite-color-brand-hover)}/*!@:host([kind=brand]) button:active,\n:host([kind=brand]) a:active*/[kind=brand].sc-calcite-button-h button.sc-calcite-button:active,[kind=brand].sc-calcite-button-h a.sc-calcite-button:active{background-color:var(--calcite-color-brand-press)}/*!@:host([kind=brand]) button calcite-loader,\n:host([kind=brand]) a calcite-loader*/[kind=brand].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[kind=brand].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-text-inverse)}/*!@:host([kind=danger]) button,\n:host([kind=danger]) a*/[kind=danger].sc-calcite-button-h button.sc-calcite-button,[kind=danger].sc-calcite-button-h a.sc-calcite-button{background-color:var(--calcite-color-status-danger);color:var(--calcite-color-text-inverse)}/*!@:host([kind=danger]) button:hover, :host([kind=danger]) button:focus,\n:host([kind=danger]) a:hover,\n:host([kind=danger]) a:focus*/[kind=danger].sc-calcite-button-h button.sc-calcite-button:hover,[kind=danger].sc-calcite-button-h button.sc-calcite-button:focus,[kind=danger].sc-calcite-button-h a.sc-calcite-button:hover,[kind=danger].sc-calcite-button-h a.sc-calcite-button:focus{background-color:var(--calcite-color-status-danger-hover)}/*!@:host([kind=danger]) button:active,\n:host([kind=danger]) a:active*/[kind=danger].sc-calcite-button-h button.sc-calcite-button:active,[kind=danger].sc-calcite-button-h a.sc-calcite-button:active{background-color:var(--calcite-color-status-danger-press)}/*!@:host([kind=danger]) button calcite-loader,\n:host([kind=danger]) a calcite-loader*/[kind=danger].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[kind=danger].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-text-inverse)}/*!@:host([kind=neutral]) button,\n:host([kind=neutral]) a*/[kind=neutral].sc-calcite-button-h button.sc-calcite-button,[kind=neutral].sc-calcite-button-h a.sc-calcite-button{background-color:var(--calcite-color-foreground-3);color:var(--calcite-color-text-1)}/*!@:host([kind=neutral]) button:hover, :host([kind=neutral]) button:focus,\n:host([kind=neutral]) a:hover,\n:host([kind=neutral]) a:focus*/[kind=neutral].sc-calcite-button-h button.sc-calcite-button:hover,[kind=neutral].sc-calcite-button-h button.sc-calcite-button:focus,[kind=neutral].sc-calcite-button-h a.sc-calcite-button:hover,[kind=neutral].sc-calcite-button-h a.sc-calcite-button:focus{background-color:var(--calcite-color-foreground-2)}/*!@:host([kind=neutral]) button:active,\n:host([kind=neutral]) a:active*/[kind=neutral].sc-calcite-button-h button.sc-calcite-button:active,[kind=neutral].sc-calcite-button-h a.sc-calcite-button:active{background-color:var(--calcite-color-foreground-1)}/*!@:host([kind=neutral]) button calcite-loader,\n:host([kind=neutral]) a calcite-loader*/[kind=neutral].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[kind=neutral].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-text-1)}/*!@:host([kind=inverse]) button,\n:host([kind=inverse]) a*/[kind=inverse].sc-calcite-button-h button.sc-calcite-button,[kind=inverse].sc-calcite-button-h a.sc-calcite-button{color:var(--calcite-color-text-inverse);background-color:var(--calcite-color-inverse)}/*!@:host([kind=inverse]) button:hover, :host([kind=inverse]) button:focus,\n:host([kind=inverse]) a:hover,\n:host([kind=inverse]) a:focus*/[kind=inverse].sc-calcite-button-h button.sc-calcite-button:hover,[kind=inverse].sc-calcite-button-h button.sc-calcite-button:focus,[kind=inverse].sc-calcite-button-h a.sc-calcite-button:hover,[kind=inverse].sc-calcite-button-h a.sc-calcite-button:focus{background-color:var(--calcite-color-inverse-hover)}/*!@:host([kind=inverse]) button:active,\n:host([kind=inverse]) a:active*/[kind=inverse].sc-calcite-button-h button.sc-calcite-button:active,[kind=inverse].sc-calcite-button-h a.sc-calcite-button:active{background-color:var(--calcite-color-inverse-press)}/*!@:host([kind=inverse]) button calcite-loader,\n:host([kind=inverse]) a calcite-loader*/[kind=inverse].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[kind=inverse].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-text-inverse)}/*!@:host([appearance=outline-fill]) button,\n:host([appearance=outline-fill]) a*/[appearance=outline-fill].sc-calcite-button-h button.sc-calcite-button,[appearance=outline-fill].sc-calcite-button-h a.sc-calcite-button{border-width:1px;border-style:solid;background-color:var(--calcite-color-foreground-1);box-shadow:inset 0 0 0 1px transparent}/*!@:host([appearance=outline-fill][kind=brand]) button,\n:host([appearance=outline-fill][kind=brand]) a*/[appearance=outline-fill][kind=brand].sc-calcite-button-h button.sc-calcite-button,[appearance=outline-fill][kind=brand].sc-calcite-button-h a.sc-calcite-button{border-color:var(--calcite-color-brand);background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-brand)}/*!@:host([appearance=outline-fill][kind=brand]) button:hover,\n:host([appearance=outline-fill][kind=brand]) a:hover*/[appearance=outline-fill][kind=brand].sc-calcite-button-h button.sc-calcite-button:hover,[appearance=outline-fill][kind=brand].sc-calcite-button-h a.sc-calcite-button:hover{border-color:var(--calcite-color-brand-hover);color:var(--calcite-color-brand-hover);box-shadow:inset 0 0 0 1px var(--calcite-color-brand-hover)}/*!@:host([appearance=outline-fill][kind=brand]) button:focus,\n:host([appearance=outline-fill][kind=brand]) a:focus*/[appearance=outline-fill][kind=brand].sc-calcite-button-h button.sc-calcite-button:focus,[appearance=outline-fill][kind=brand].sc-calcite-button-h a.sc-calcite-button:focus{border-color:var(--calcite-color-brand);color:var(--calcite-color-brand);box-shadow:inset 0 0 0 2px var(--calcite-color-brand)}/*!@:host([appearance=outline-fill][kind=brand]) button:active,\n:host([appearance=outline-fill][kind=brand]) a:active*/[appearance=outline-fill][kind=brand].sc-calcite-button-h button.sc-calcite-button:active,[appearance=outline-fill][kind=brand].sc-calcite-button-h a.sc-calcite-button:active{border-color:var(--calcite-color-brand-press);color:var(--calcite-color-brand-press);box-shadow:inset 0 0 0 2px var(--calcite-color-brand-press)}/*!@:host([appearance=outline-fill][kind=brand]) button calcite-loader,\n:host([appearance=outline-fill][kind=brand]) a calcite-loader*/[appearance=outline-fill][kind=brand].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[appearance=outline-fill][kind=brand].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-brand)}/*!@:host([appearance=outline-fill][kind=danger]) button,\n:host([appearance=outline-fill][kind=danger]) a*/[appearance=outline-fill][kind=danger].sc-calcite-button-h button.sc-calcite-button,[appearance=outline-fill][kind=danger].sc-calcite-button-h a.sc-calcite-button{border-color:var(--calcite-color-status-danger);background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-status-danger)}/*!@:host([appearance=outline-fill][kind=danger]) button:hover,\n:host([appearance=outline-fill][kind=danger]) a:hover*/[appearance=outline-fill][kind=danger].sc-calcite-button-h button.sc-calcite-button:hover,[appearance=outline-fill][kind=danger].sc-calcite-button-h a.sc-calcite-button:hover{border-color:var(--calcite-color-status-danger-hover);color:var(--calcite-color-status-danger-hover);box-shadow:inset 0 0 0 1px var(--calcite-color-status-danger-hover)}/*!@:host([appearance=outline-fill][kind=danger]) button:focus,\n:host([appearance=outline-fill][kind=danger]) a:focus*/[appearance=outline-fill][kind=danger].sc-calcite-button-h button.sc-calcite-button:focus,[appearance=outline-fill][kind=danger].sc-calcite-button-h a.sc-calcite-button:focus{border-color:var(--calcite-color-status-danger);color:var(--calcite-color-status-danger);box-shadow:inset 0 0 0 2px var(--calcite-color-status-danger)}/*!@:host([appearance=outline-fill][kind=danger]) button:active,\n:host([appearance=outline-fill][kind=danger]) a:active*/[appearance=outline-fill][kind=danger].sc-calcite-button-h button.sc-calcite-button:active,[appearance=outline-fill][kind=danger].sc-calcite-button-h a.sc-calcite-button:active{border-color:var(--calcite-color-status-danger-press);color:var(--calcite-color-status-danger-press);box-shadow:inset 0 0 0 2px var(--calcite-color-status-danger-press)}/*!@:host([appearance=outline-fill][kind=danger]) button calcite-loader,\n:host([appearance=outline-fill][kind=danger]) a calcite-loader*/[appearance=outline-fill][kind=danger].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[appearance=outline-fill][kind=danger].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-status-danger)}/*!@:host([appearance=outline-fill][kind=neutral]) button,\n:host([appearance=outline-fill][kind=neutral]) a*/[appearance=outline-fill][kind=neutral].sc-calcite-button-h button.sc-calcite-button,[appearance=outline-fill][kind=neutral].sc-calcite-button-h a.sc-calcite-button{background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-1);border-color:var(--calcite-color-border-1)}/*!@:host([appearance=outline-fill][kind=neutral]) button:hover,\n:host([appearance=outline-fill][kind=neutral]) a:hover*/[appearance=outline-fill][kind=neutral].sc-calcite-button-h button.sc-calcite-button:hover,[appearance=outline-fill][kind=neutral].sc-calcite-button-h a.sc-calcite-button:hover{box-shadow:inset 0 0 0 1px var(--calcite-color-foreground-3)}/*!@:host([appearance=outline-fill][kind=neutral]) button:focus,\n:host([appearance=outline-fill][kind=neutral]) a:focus*/[appearance=outline-fill][kind=neutral].sc-calcite-button-h button.sc-calcite-button:focus,[appearance=outline-fill][kind=neutral].sc-calcite-button-h a.sc-calcite-button:focus{box-shadow:inset 0 0 0 2px var(--calcite-color-foreground-3)}/*!@:host([appearance=outline-fill][kind=neutral]) button:active,\n:host([appearance=outline-fill][kind=neutral]) a:active*/[appearance=outline-fill][kind=neutral].sc-calcite-button-h button.sc-calcite-button:active,[appearance=outline-fill][kind=neutral].sc-calcite-button-h a.sc-calcite-button:active{box-shadow:inset 0 0 0 2px var(--calcite-color-foreground-3)}/*!@:host([appearance=outline-fill][kind=neutral]) button calcite-loader,\n:host([appearance=outline-fill][kind=neutral]) a calcite-loader*/[appearance=outline-fill][kind=neutral].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[appearance=outline-fill][kind=neutral].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-text-1)}/*!@:host([appearance=outline-fill][kind=inverse]) button,\n:host([appearance=outline-fill][kind=inverse]) a*/[appearance=outline-fill][kind=inverse].sc-calcite-button-h button.sc-calcite-button,[appearance=outline-fill][kind=inverse].sc-calcite-button-h a.sc-calcite-button{background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-1);border-color:var(--calcite-color-inverse)}/*!@:host([appearance=outline-fill][kind=inverse]) button:hover,\n:host([appearance=outline-fill][kind=inverse]) a:hover*/[appearance=outline-fill][kind=inverse].sc-calcite-button-h button.sc-calcite-button:hover,[appearance=outline-fill][kind=inverse].sc-calcite-button-h a.sc-calcite-button:hover{border-color:var(--calcite-color-inverse-hover);box-shadow:inset 0 0 0 1px var(--calcite-color-inverse-hover)}/*!@:host([appearance=outline-fill][kind=inverse]) button:focus,\n:host([appearance=outline-fill][kind=inverse]) a:focus*/[appearance=outline-fill][kind=inverse].sc-calcite-button-h button.sc-calcite-button:focus,[appearance=outline-fill][kind=inverse].sc-calcite-button-h a.sc-calcite-button:focus{border-color:var(--calcite-color-inverse);box-shadow:inset 0 0 0 2px var(--calcite-color-inverse)}/*!@:host([appearance=outline-fill][kind=inverse]) button:active,\n:host([appearance=outline-fill][kind=inverse]) a:active*/[appearance=outline-fill][kind=inverse].sc-calcite-button-h button.sc-calcite-button:active,[appearance=outline-fill][kind=inverse].sc-calcite-button-h a.sc-calcite-button:active{border-color:var(--calcite-color-inverse-press);box-shadow:inset 0 0 0 2px var(--calcite-color-inverse-press)}/*!@:host([appearance=outline-fill][kind=inverse]) button calcite-loader,\n:host([appearance=outline-fill][kind=inverse]) a calcite-loader*/[appearance=outline-fill][kind=inverse].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[appearance=outline-fill][kind=inverse].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-text-1)}/*!@:host([appearance=outline]) button,\n:host([appearance=outline]) a*/[appearance=outline].sc-calcite-button-h button.sc-calcite-button,[appearance=outline].sc-calcite-button-h a.sc-calcite-button{border-width:1px;border-style:solid;background-color:transparent;box-shadow:inset 0 0 0 1px transparent}/*!@:host([appearance=outline][kind=brand]) button,\n:host([appearance=outline][kind=brand]) a*/[appearance=outline][kind=brand].sc-calcite-button-h button.sc-calcite-button,[appearance=outline][kind=brand].sc-calcite-button-h a.sc-calcite-button{border-color:var(--calcite-color-brand);background-color:transparent;color:var(--calcite-color-brand)}/*!@:host([appearance=outline][kind=brand]) button:hover,\n:host([appearance=outline][kind=brand]) a:hover*/[appearance=outline][kind=brand].sc-calcite-button-h button.sc-calcite-button:hover,[appearance=outline][kind=brand].sc-calcite-button-h a.sc-calcite-button:hover{border-color:var(--calcite-color-brand-hover);color:var(--calcite-color-brand-hover);box-shadow:inset 0 0 0 1px var(--calcite-color-brand-hover)}/*!@:host([appearance=outline][kind=brand]) button:focus,\n:host([appearance=outline][kind=brand]) a:focus*/[appearance=outline][kind=brand].sc-calcite-button-h button.sc-calcite-button:focus,[appearance=outline][kind=brand].sc-calcite-button-h a.sc-calcite-button:focus{border-color:var(--calcite-color-brand);color:var(--calcite-color-brand);box-shadow:inset 0 0 0 2px var(--calcite-color-brand)}/*!@:host([appearance=outline][kind=brand]) button:active,\n:host([appearance=outline][kind=brand]) a:active*/[appearance=outline][kind=brand].sc-calcite-button-h button.sc-calcite-button:active,[appearance=outline][kind=brand].sc-calcite-button-h a.sc-calcite-button:active{border-color:var(--calcite-color-brand-press);color:var(--calcite-color-brand-press);box-shadow:inset 0 0 0 2px var(--calcite-color-brand-press)}/*!@:host([appearance=outline][kind=brand]) button calcite-loader,\n:host([appearance=outline][kind=brand]) a calcite-loader*/[appearance=outline][kind=brand].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[appearance=outline][kind=brand].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-brand)}/*!@:host([appearance=outline][kind=danger]) button,\n:host([appearance=outline][kind=danger]) a*/[appearance=outline][kind=danger].sc-calcite-button-h button.sc-calcite-button,[appearance=outline][kind=danger].sc-calcite-button-h a.sc-calcite-button{border-color:var(--calcite-color-status-danger);background-color:transparent;color:var(--calcite-color-status-danger)}/*!@:host([appearance=outline][kind=danger]) button:hover,\n:host([appearance=outline][kind=danger]) a:hover*/[appearance=outline][kind=danger].sc-calcite-button-h button.sc-calcite-button:hover,[appearance=outline][kind=danger].sc-calcite-button-h a.sc-calcite-button:hover{border-color:var(--calcite-color-status-danger-hover);color:var(--calcite-color-status-danger-hover);box-shadow:inset 0 0 0 1px var(--calcite-color-status-danger-hover)}/*!@:host([appearance=outline][kind=danger]) button:focus,\n:host([appearance=outline][kind=danger]) a:focus*/[appearance=outline][kind=danger].sc-calcite-button-h button.sc-calcite-button:focus,[appearance=outline][kind=danger].sc-calcite-button-h a.sc-calcite-button:focus{border-color:var(--calcite-color-status-danger);color:var(--calcite-color-status-danger);box-shadow:inset 0 0 0 2px var(--calcite-color-status-danger)}/*!@:host([appearance=outline][kind=danger]) button:active,\n:host([appearance=outline][kind=danger]) a:active*/[appearance=outline][kind=danger].sc-calcite-button-h button.sc-calcite-button:active,[appearance=outline][kind=danger].sc-calcite-button-h a.sc-calcite-button:active{border-color:var(--calcite-color-status-danger-press);color:var(--calcite-color-status-danger-press);box-shadow:inset 0 0 0 2px var(--calcite-color-status-danger-press)}/*!@:host([appearance=outline][kind=danger]) button calcite-loader,\n:host([appearance=outline][kind=danger]) a calcite-loader*/[appearance=outline][kind=danger].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[appearance=outline][kind=danger].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-status-danger)}/*!@:host([appearance=outline][kind=neutral]) button,\n:host([appearance=outline][kind=neutral]) a*/[appearance=outline][kind=neutral].sc-calcite-button-h button.sc-calcite-button,[appearance=outline][kind=neutral].sc-calcite-button-h a.sc-calcite-button{background-color:transparent;color:var(--calcite-color-text-1);border-color:var(--calcite-color-border-1)}/*!@:host([appearance=outline][kind=neutral]) button:hover,\n:host([appearance=outline][kind=neutral]) a:hover*/[appearance=outline][kind=neutral].sc-calcite-button-h button.sc-calcite-button:hover,[appearance=outline][kind=neutral].sc-calcite-button-h a.sc-calcite-button:hover{box-shadow:inset 0 0 0 1px var(--calcite-color-foreground-3)}/*!@:host([appearance=outline][kind=neutral]) button:focus,\n:host([appearance=outline][kind=neutral]) a:focus*/[appearance=outline][kind=neutral].sc-calcite-button-h button.sc-calcite-button:focus,[appearance=outline][kind=neutral].sc-calcite-button-h a.sc-calcite-button:focus{box-shadow:inset 0 0 0 2px var(--calcite-color-foreground-3)}/*!@:host([appearance=outline][kind=neutral]) button:active,\n:host([appearance=outline][kind=neutral]) a:active*/[appearance=outline][kind=neutral].sc-calcite-button-h button.sc-calcite-button:active,[appearance=outline][kind=neutral].sc-calcite-button-h a.sc-calcite-button:active{box-shadow:inset 0 0 0 2px var(--calcite-color-foreground-3)}/*!@:host([appearance=outline][kind=neutral]) button calcite-loader,\n:host([appearance=outline][kind=neutral]) a calcite-loader*/[appearance=outline][kind=neutral].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[appearance=outline][kind=neutral].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-text-1)}/*!@:host([appearance=outline][kind=inverse]) button,\n:host([appearance=outline][kind=inverse]) a*/[appearance=outline][kind=inverse].sc-calcite-button-h button.sc-calcite-button,[appearance=outline][kind=inverse].sc-calcite-button-h a.sc-calcite-button{background-color:transparent;color:var(--calcite-color-text-1);border-color:var(--calcite-color-inverse)}/*!@:host([appearance=outline][kind=inverse]) button:hover,\n:host([appearance=outline][kind=inverse]) a:hover*/[appearance=outline][kind=inverse].sc-calcite-button-h button.sc-calcite-button:hover,[appearance=outline][kind=inverse].sc-calcite-button-h a.sc-calcite-button:hover{border-color:var(--calcite-color-inverse-hover);box-shadow:inset 0 0 0 1px var(--calcite-color-inverse-hover)}/*!@:host([appearance=outline][kind=inverse]) button:focus,\n:host([appearance=outline][kind=inverse]) a:focus*/[appearance=outline][kind=inverse].sc-calcite-button-h button.sc-calcite-button:focus,[appearance=outline][kind=inverse].sc-calcite-button-h a.sc-calcite-button:focus{border-color:var(--calcite-color-inverse);box-shadow:inset 0 0 0 2px var(--calcite-color-inverse)}/*!@:host([appearance=outline][kind=inverse]) button:active,\n:host([appearance=outline][kind=inverse]) a:active*/[appearance=outline][kind=inverse].sc-calcite-button-h button.sc-calcite-button:active,[appearance=outline][kind=inverse].sc-calcite-button-h a.sc-calcite-button:active{border-color:var(--calcite-color-inverse-press);box-shadow:inset 0 0 0 2px var(--calcite-color-inverse-press)}/*!@:host([appearance=outline][kind=inverse]) button calcite-loader,\n:host([appearance=outline][kind=inverse]) a calcite-loader*/[appearance=outline][kind=inverse].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[appearance=outline][kind=inverse].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-text-1)}/*!@:host([appearance=outline-fill][split-child=primary]) button,\n:host([appearance=outline][split-child=primary]) button*/[appearance=outline-fill][split-child=primary].sc-calcite-button-h button.sc-calcite-button,[appearance=outline][split-child=primary].sc-calcite-button-h button.sc-calcite-button{border-inline-end-width:0;border-inline-start-width:1px}/*!@:host([appearance=outline-fill][split-child=secondary]) button,\n:host([appearance=outline][split-child=secondary]) button*/[appearance=outline-fill][split-child=secondary].sc-calcite-button-h button.sc-calcite-button,[appearance=outline][split-child=secondary].sc-calcite-button-h button.sc-calcite-button{border-inline-start-width:0;border-inline-end-width:1px}/*!@:host([appearance=transparent]:not(.enable-editing-button)) button,\n:host([appearance=transparent]:not(.enable-editing-button)) a*/[appearance=transparent].sc-calcite-button-h:not(.enable-editing-button) button.sc-calcite-button,[appearance=transparent].sc-calcite-button-h:not(.enable-editing-button) a.sc-calcite-button{background-color:transparent}/*!@:host([appearance=transparent]:not(.enable-editing-button)) button:hover, :host([appearance=transparent]:not(.enable-editing-button)) button:focus,\n:host([appearance=transparent]:not(.enable-editing-button)) a:hover,\n:host([appearance=transparent]:not(.enable-editing-button)) a:focus*/[appearance=transparent].sc-calcite-button-h:not(.enable-editing-button) button.sc-calcite-button:hover,[appearance=transparent].sc-calcite-button-h:not(.enable-editing-button) button.sc-calcite-button:focus,[appearance=transparent].sc-calcite-button-h:not(.enable-editing-button) a.sc-calcite-button:hover,[appearance=transparent].sc-calcite-button-h:not(.enable-editing-button) a.sc-calcite-button:focus{background-color:var(--calcite-color-transparent-hover)}/*!@:host([appearance=transparent]:not(.enable-editing-button)) button:active,\n:host([appearance=transparent]:not(.enable-editing-button)) a:active*/[appearance=transparent].sc-calcite-button-h:not(.enable-editing-button) button.sc-calcite-button:active,[appearance=transparent].sc-calcite-button-h:not(.enable-editing-button) a.sc-calcite-button:active{background-color:var(--calcite-color-transparent-press)}/*!@:host([appearance=transparent][kind=brand]) button,\n:host([appearance=transparent][kind=brand]) a*/[appearance=transparent][kind=brand].sc-calcite-button-h button.sc-calcite-button,[appearance=transparent][kind=brand].sc-calcite-button-h a.sc-calcite-button{color:var(--calcite-color-brand)}/*!@:host([appearance=transparent][kind=brand]) button:hover,\n:host([appearance=transparent][kind=brand]) a:hover*/[appearance=transparent][kind=brand].sc-calcite-button-h button.sc-calcite-button:hover,[appearance=transparent][kind=brand].sc-calcite-button-h a.sc-calcite-button:hover{color:var(--calcite-color-brand-hover)}/*!@:host([appearance=transparent][kind=brand]) button:focus,\n:host([appearance=transparent][kind=brand]) a:focus*/[appearance=transparent][kind=brand].sc-calcite-button-h button.sc-calcite-button:focus,[appearance=transparent][kind=brand].sc-calcite-button-h a.sc-calcite-button:focus{color:var(--calcite-color-brand)}/*!@:host([appearance=transparent][kind=brand]) button:active,\n:host([appearance=transparent][kind=brand]) a:active*/[appearance=transparent][kind=brand].sc-calcite-button-h button.sc-calcite-button:active,[appearance=transparent][kind=brand].sc-calcite-button-h a.sc-calcite-button:active{color:var(--calcite-color-brand-press)}/*!@:host([appearance=transparent][kind=brand]) button calcite-loader,\n:host([appearance=transparent][kind=brand]) a calcite-loader*/[appearance=transparent][kind=brand].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[appearance=transparent][kind=brand].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-brand)}/*!@:host([appearance=transparent][kind=danger]) button,\n:host([appearance=transparent][kind=danger]) a*/[appearance=transparent][kind=danger].sc-calcite-button-h button.sc-calcite-button,[appearance=transparent][kind=danger].sc-calcite-button-h a.sc-calcite-button{color:var(--calcite-color-status-danger)}/*!@:host([appearance=transparent][kind=danger]) button:hover,\n:host([appearance=transparent][kind=danger]) a:hover*/[appearance=transparent][kind=danger].sc-calcite-button-h button.sc-calcite-button:hover,[appearance=transparent][kind=danger].sc-calcite-button-h a.sc-calcite-button:hover{color:var(--calcite-color-status-danger-hover)}/*!@:host([appearance=transparent][kind=danger]) button:focus,\n:host([appearance=transparent][kind=danger]) a:focus*/[appearance=transparent][kind=danger].sc-calcite-button-h button.sc-calcite-button:focus,[appearance=transparent][kind=danger].sc-calcite-button-h a.sc-calcite-button:focus{color:var(--calcite-color-status-danger)}/*!@:host([appearance=transparent][kind=danger]) button:active,\n:host([appearance=transparent][kind=danger]) a:active*/[appearance=transparent][kind=danger].sc-calcite-button-h button.sc-calcite-button:active,[appearance=transparent][kind=danger].sc-calcite-button-h a.sc-calcite-button:active{color:var(--calcite-color-status-danger-press)}/*!@:host([appearance=transparent][kind=danger]) button calcite-loader,\n:host([appearance=transparent][kind=danger]) a calcite-loader*/[appearance=transparent][kind=danger].sc-calcite-button-h button.sc-calcite-button calcite-loader.sc-calcite-button,[appearance=transparent][kind=danger].sc-calcite-button-h a.sc-calcite-button calcite-loader.sc-calcite-button{color:var(--calcite-color-status-danger)}/*!@:host([appearance=transparent][kind=neutral]:not(.cancel-editing-button)) button,\n:host([appearance=transparent][kind=neutral]:not(.cancel-editing-button)) a,\n:host([appearance=transparent][kind=neutral]:not(.cancel-editing-button)) calcite-loader*/[appearance=transparent][kind=neutral].sc-calcite-button-h:not(.cancel-editing-button) button.sc-calcite-button,[appearance=transparent][kind=neutral].sc-calcite-button-h:not(.cancel-editing-button) a.sc-calcite-button,[appearance=transparent][kind=neutral].sc-calcite-button-h:not(.cancel-editing-button) calcite-loader.sc-calcite-button{color:var(--calcite-color-text-1)}/*!@:host([appearance=transparent][kind=neutral].cancel-editing-button) button*/[appearance=transparent][kind=neutral].cancel-editing-button.sc-calcite-button-h button.sc-calcite-button{border-block-start-width:1px;border-block-end-width:1px;color:var(--calcite-color-text-3);border-block-start-color:var(--calcite-color-border-input);border-block-end-color:var(--calcite-color-border-input);border-block-style:solid}/*!@:host([appearance=transparent][kind=neutral].cancel-editing-button) button:not(.content--slotted)*/[appearance=transparent][kind=neutral].cancel-editing-button.sc-calcite-button-h button.sc-calcite-button:not(.content--slotted){--calcite-button-padding-y-internal:0}/*!@:host([appearance=transparent][kind=neutral].cancel-editing-button) button:hover*/[appearance=transparent][kind=neutral].cancel-editing-button.sc-calcite-button-h button.sc-calcite-button:hover{color:var(--calcite-color-text-1)}/*!@:host([appearance=transparent][kind=neutral].enable-editing-button) button*/[appearance=transparent][kind=neutral].enable-editing-button.sc-calcite-button-h button.sc-calcite-button{background-color:transparent}/*!@:host(.confirm-changes-button) button:focus,\n:host(.cancel-editing-button) button:focus,\n:host(.enable-editing-button) button:focus*/.confirm-changes-button.sc-calcite-button-h button.sc-calcite-button:focus,.cancel-editing-button.sc-calcite-button-h button.sc-calcite-button:focus,.enable-editing-button.sc-calcite-button-h button.sc-calcite-button:focus{outline-offset:-2px}/*!@:host([appearance=transparent][kind=inverse]) button,\n:host([appearance=transparent][kind=inverse]) a,\n:host([appearance=transparent][kind=inverse]) calcite-loader*/[appearance=transparent][kind=inverse].sc-calcite-button-h button.sc-calcite-button,[appearance=transparent][kind=inverse].sc-calcite-button-h a.sc-calcite-button,[appearance=transparent][kind=inverse].sc-calcite-button-h calcite-loader.sc-calcite-button{color:var(--calcite-color-text-inverse)}/*!@:host([scale=s]) button.content--slotted,\n:host([scale=s]) a.content--slotted*/[scale=s].sc-calcite-button-h button.content--slotted.sc-calcite-button,[scale=s].sc-calcite-button-h a.content--slotted.sc-calcite-button{font-size:var(--calcite-font-size--2);line-height:1rem}/*!@:host([scale=s][appearance=transparent]) button.content--slotted,\n:host([scale=s][appearance=transparent]) a.content--slotted*/[scale=s][appearance=transparent].sc-calcite-button-h button.content--slotted.sc-calcite-button,[scale=s][appearance=transparent].sc-calcite-button-h a.content--slotted.sc-calcite-button{--calcite-button-padding-x-internal:0.5rem}/*!@:host([scale=s]) button,\n:host([scale=s]) a*/[scale=s].sc-calcite-button-h button.sc-calcite-button,[scale=s].sc-calcite-button-h a.sc-calcite-button{--calcite-button-padding-y-internal:3px}/*!@:host([scale=m]) button.content--slotted,\n:host([scale=m]) a.content--slotted*/[scale=m].sc-calcite-button-h button.content--slotted.sc-calcite-button,[scale=m].sc-calcite-button-h a.content--slotted.sc-calcite-button{--calcite-button-padding-x-internal:11px;font-size:var(--calcite-font-size--1);line-height:1rem}/*!@:host([scale=m]) button,\n:host([scale=m]) a*/[scale=m].sc-calcite-button-h button.sc-calcite-button,[scale=m].sc-calcite-button-h a.sc-calcite-button{--calcite-button-padding-y-internal:7px}/*!@:host([scale=m][appearance=transparent]) button.content--slotted,\n:host([scale=m][appearance=transparent]) a.content--slotted*/[scale=m][appearance=transparent].sc-calcite-button-h button.content--slotted.sc-calcite-button,[scale=m][appearance=transparent].sc-calcite-button-h a.content--slotted.sc-calcite-button{--calcite-button-padding-x-internal:0.75rem}/*!@:host([scale=l]) button.content--slotted,\n:host([scale=l]) a.content--slotted*/[scale=l].sc-calcite-button-h button.content--slotted.sc-calcite-button,[scale=l].sc-calcite-button-h a.content--slotted.sc-calcite-button{--calcite-button-padding-x-internal:15px;font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host([scale=l]) .button-padding*/[scale=l].sc-calcite-button-h .button-padding.sc-calcite-button{--calcite-button-padding-x-internal:1rem;--calcite-button-padding-y-internal:11px}/*!@:host([scale=l]) .button-padding--shrunk*/[scale=l].sc-calcite-button-h .button-padding--shrunk.sc-calcite-button{--calcite-button-padding-y-internal:9px}/*!@:host([scale=s]) button:not(.content--slotted),\n:host([scale=s]) a:not(.content--slotted)*/[scale=s].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted),[scale=s].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted){--calcite-button-padding-x-internal:0.125rem;--calcite-button-padding-y-internal:3px;inline-size:1.5rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;min-block-size:1.5rem}/*!@:host([scale=m]) button:not(.content--slotted),\n:host([scale=m]) a:not(.content--slotted)*/[scale=m].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted),[scale=m].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted){--calcite-button-padding-x-internal:0.125rem;--calcite-button-padding-y-internal:7px;inline-size:2rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;min-block-size:2rem}/*!@:host([scale=l]) button:not(.content--slotted),\n:host([scale=l]) a:not(.content--slotted)*/[scale=l].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted),[scale=l].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted){--calcite-button-padding-x-internal:0.125rem;--calcite-button-padding-y-internal:9px;inline-size:2.75rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;min-block-size:2.75rem}/*!@:host([scale=l][appearance=transparent]) button:not(.content--slotted),\n:host([scale=l][appearance=transparent]) a:not(.content--slotted)*/[scale=l][appearance=transparent].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted),[scale=l][appearance=transparent].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted){--calcite-button-padding-y-internal:0.625rem}/*!@:host([scale=s][icon-start][icon-end]) button:not(.content--slotted),\n:host([scale=s][icon-start][icon-end]) a:not(.content--slotted)*/[scale=s][icon-start][icon-end].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted),[scale=s][icon-start][icon-end].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted){--calcite-button-padding-x-internal:23px;block-size:1.5rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host([scale=s][icon-start][icon-end][appearance=transparent]) button:not(.content--slotted),\n:host([scale=s][icon-start][icon-end][appearance=transparent]) a:not(.content--slotted)*/[scale=s][icon-start][icon-end][appearance=transparent].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted),[scale=s][icon-start][icon-end][appearance=transparent].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted){--calcite-button-padding-x-internal:1.5rem}/*!@:host([scale=m][icon-start][icon-end]) button:not(.content--slotted),\n:host([scale=m][icon-start][icon-end]) a:not(.content--slotted)*/[scale=m][icon-start][icon-end].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted),[scale=m][icon-start][icon-end].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted){--calcite-button-padding-x-internal:2rem;block-size:2rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host([scale=m][icon-start][icon-end][appearance=transparent]) button:not(.content--slotted),\n:host([scale=m][icon-start][icon-end][appearance=transparent]) a:not(.content--slotted)*/[scale=m][icon-start][icon-end][appearance=transparent].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted),[scale=m][icon-start][icon-end][appearance=transparent].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted){--calcite-button-padding-x-internal:33px}/*!@:host([scale=l][icon-start][icon-end]) button:not(.content--slotted),\n:host([scale=l][icon-start][icon-end]) a:not(.content--slotted)*/[scale=l][icon-start][icon-end].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted),[scale=l][icon-start][icon-end].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted){--calcite-button-padding-x-internal:43px;block-size:2.75rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host([scale=l][icon-start][icon-end]) button:not(.content--slotted) .icon--start + .icon--end,\n:host([scale=l][icon-start][icon-end]) a:not(.content--slotted) .icon--start + .icon--end*/[scale=l][icon-start][icon-end].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted) .icon--start.sc-calcite-button+.icon--end.sc-calcite-button,[scale=l][icon-start][icon-end].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted) .icon--start.sc-calcite-button+.icon--end.sc-calcite-button{margin-inline-start:1rem}/*!@:host([scale=l][icon-start][icon-end][appearance=transparent]) button:not(.content--slotted),\n:host([scale=l][icon-start][icon-end][appearance=transparent]) a:not(.content--slotted)*/[scale=l][icon-start][icon-end][appearance=transparent].sc-calcite-button-h button.sc-calcite-button:not(.content--slotted),[scale=l][icon-start][icon-end][appearance=transparent].sc-calcite-button-h a.sc-calcite-button:not(.content--slotted){--calcite-button-padding-x-internal:2.75rem}/*!@:host([hidden])*/[hidden].sc-calcite-button-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-button{display:none}";

/** Passing a 'href' will render an anchor link, instead of a button. Role will be set to link, or button, depending on this. */
/** It is the consumers responsibility to add aria information, rel, target, for links, and any button attributes for form submission */
/** @slot - A slot for adding text. */
class Button {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        /** watches for changing text content */
        this.mutationObserver = createObserver();
        this.resizeObserver = createObserver();
        // act on a requested or nearby form based on type
        this.handleClick = () => {
            const { type } = this;
            if (this.href) {
                return;
            }
            // this.type refers to type attribute, not child element type
            if (type === "submit") {
                submitForm(this);
            }
            else if (type === "reset") {
                resetForm(this);
            }
        };
        this.setTooltipText = () => {
            const { contentEl } = this;
            if (contentEl) {
                this.tooltipText =
                    contentEl.offsetWidth < contentEl.scrollWidth ? this.el.innerText || null : null;
            }
        };
        this.setChildEl = (el) => {
            this.childEl = el;
            if (el) {
                this.resizeObserver?.observe(el);
            }
        };
        this.alignment = "center";
        this.appearance = "solid";
        this.label = undefined;
        this.kind = "brand";
        this.disabled = false;
        this.form = undefined;
        this.href = undefined;
        this.iconEnd = undefined;
        this.iconFlipRtl = undefined;
        this.iconStart = undefined;
        this.loading = false;
        this.name = undefined;
        this.rel = undefined;
        this.round = false;
        this.scale = "m";
        this.splitChild = false;
        this.target = undefined;
        this.type = "button";
        this.width = "auto";
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.hasContent = false;
        this.hasLoader = false;
        this.effectiveLocale = "";
        this.defaultMessages = undefined;
        this.tooltipText = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Global attributes
    //
    //--------------------------------------------------------------------------
    handleGlobalAttributesChanged() {
    }
    loadingChanged(newValue, oldValue) {
        if (!!newValue && !oldValue) {
            this.hasLoader = true;
        }
        if (!newValue && !!oldValue) {
            window.setTimeout(() => {
                this.hasLoader = false;
            }, 300);
        }
    }
    onMessagesChange() {
        /** referred in t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
        this.hasLoader = this.loading;
        this.setupTextContentObserver();
        connectLabel(this);
        this.formEl = findAssociatedForm(this);
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        this.resizeObserver?.disconnect();
        this.formEl = null;
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
        this.setTooltipText();
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    render() {
        const childElType = this.href ? "a" : "button";
        const Tag = childElType;
        const loaderNode = this.hasLoader ? (hAsync("div", { class: CSS$1e.buttonLoader }, hAsync("calcite-loader", { class: this.loading ? CSS$1e.loadingIn : CSS$1e.loadingOut, inline: true, label: this.messages.loading, scale: this.scale === "l" ? "m" : "s" }))) : null;
        const noStartEndIcons = !this.iconStart && !this.iconEnd;
        const iconStartEl = (hAsync("calcite-icon", { class: { [CSS$1e.icon]: true, [CSS$1e.iconStart]: true }, flipRtl: this.iconFlipRtl === "start" || this.iconFlipRtl === "both", icon: this.iconStart, scale: getIconScale(this.scale) }));
        const iconEndEl = (hAsync("calcite-icon", { class: { [CSS$1e.icon]: true, [CSS$1e.iconEnd]: true }, flipRtl: this.iconFlipRtl === "end" || this.iconFlipRtl === "both", icon: this.iconEnd, scale: getIconScale(this.scale) }));
        const contentEl = (hAsync("span", { class: CSS$1e.content, ref: (el) => (this.contentEl = el) }, hAsync("slot", null)));
        return (hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync(Tag, { "aria-disabled": childElType === "a" ? toAriaBoolean(this.disabled || this.loading) : null, "aria-expanded": this.el.getAttribute("aria-expanded"), "aria-label": !this.loading ? getLabelText(this) : this.messages.loading, "aria-live": "polite", class: {
                [CSS$1e.buttonPadding]: noStartEndIcons,
                [CSS$1e.buttonPaddingShrunk]: !noStartEndIcons,
                [CSS$1e.contentSlotted]: this.hasContent,
                [CSS$1e.iconStartEmpty]: !this.iconStart,
                [CSS$1e.iconEndEmpty]: !this.iconEnd,
            }, disabled: childElType === "button" ? this.disabled || this.loading : null, href: childElType === "a" && this.href, name: childElType === "button" && this.name, onClick: this.handleClick, rel: childElType === "a" && this.rel, tabIndex: this.disabled ? -1 : null, target: childElType === "a" && this.target, title: this.tooltipText, type: childElType === "button" && this.type,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setChildEl }, loaderNode, this.iconStart ? iconStartEl : null, this.hasContent ? contentEl : null, this.iconEnd ? iconEndEl : null)));
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.childEl?.focus();
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    updateHasContent() {
        const slottedContent = this.el.textContent.trim().length > 0 || this.el.childNodes.length > 0;
        this.hasContent =
            this.el.childNodes.length === 1 && this.el.childNodes[0]?.nodeName === "#text"
                ? this.el.textContent?.trim().length > 0
                : slottedContent;
    }
    setupTextContentObserver() {
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    onLabelClick() {
        this.handleClick();
        this.setFocus();
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "aria-expanded": ["handleGlobalAttributesChanged"],
        "loading": ["loadingChanged"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return buttonCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-button",
        "$members$": {
            "alignment": [513],
            "appearance": [513],
            "label": [1],
            "kind": [513],
            "disabled": [516],
            "form": [513],
            "href": [513],
            "iconEnd": [513, "icon-end"],
            "iconFlipRtl": [513, "icon-flip-rtl"],
            "iconStart": [513, "icon-start"],
            "loading": [516],
            "name": [513],
            "rel": [513],
            "round": [516],
            "scale": [513],
            "splitChild": [520, "split-child"],
            "target": [513],
            "type": [513],
            "width": [513],
            "messages": [1040],
            "messageOverrides": [1040],
            "hasContent": [32],
            "hasLoader": [32],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "tooltipText": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["alignment", "alignment"], ["appearance", "appearance"], ["kind", "kind"], ["disabled", "disabled"], ["form", "form"], ["href", "href"], ["iconEnd", "icon-end"], ["iconFlipRtl", "icon-flip-rtl"], ["iconStart", "icon-start"], ["loading", "loading"], ["name", "name"], ["rel", "rel"], ["round", "round"], ["scale", "scale"], ["splitChild", "split-child"], ["target", "target"], ["type", "type"], ["width", "width"]]
    }; }
}

const menuCss = "/*!@:host*/.sc-calcite-menu-h{display:flex}/*!@ul*/ul.sc-calcite-menu{margin:0px;display:inline-flex;block-size:100%;align-items:center;padding:0px}/*!@:host([layout=vertical]) ul*/[layout=vertical].sc-calcite-menu-h ul.sc-calcite-menu{display:flex;inline-size:100%;flex-direction:column}/*!@:host([hidden])*/[hidden].sc-calcite-menu-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-menu{display:none}";

class CalciteMenu {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.menuItems = [];
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.handleMenuSlotChange = (event) => {
            this.menuItems = slotChangeGetAssignedElements(event);
            this.setMenuItemLayout(this.menuItems, this.layout);
        };
        this.label = undefined;
        this.layout = "horizontal";
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
    }
    //--------------------------------------------------------------------------
    //
    //  Global attributes
    //
    //--------------------------------------------------------------------------
    handleGlobalAttributesChanged() {
        this.setMenuItemLayout(this.menuItems, this.layout);
    }
    handleLayoutChange(value) {
        this.setMenuItemLayout(this.menuItems, value);
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectLocalized(this);
        connectMessages(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component's first focusable element. */
    async setFocus() {
        await componentFocusable(this);
        this.el.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    calciteInternalNavMenuItemKeyEvent(event) {
        const target = event.target;
        const submenuItems = event.detail.children;
        const key = event.detail.event.key;
        event.stopPropagation();
        if (key === "ArrowDown") {
            if (target.layout === "vertical") {
                focusElementInGroup(this.menuItems, target, "next", false);
            }
            else {
                if (event.detail.isSubmenuOpen) {
                    submenuItems[0].setFocus();
                }
            }
        }
        else if (key === "ArrowUp") {
            if (this.layout === "vertical") {
                focusElementInGroup(this.menuItems, target, "previous", false);
            }
            else {
                if (event.detail.isSubmenuOpen) {
                    submenuItems[submenuItems.length - 1].setFocus();
                }
            }
        }
        else if (key === "ArrowRight") {
            if (this.layout === "horizontal") {
                focusElementInGroup(this.menuItems, target, "next", false);
            }
            else {
                if (event.detail.isSubmenuOpen) {
                    submenuItems[0].setFocus();
                }
            }
        }
        else if (key === "ArrowLeft") {
            if (this.layout === "horizontal") {
                focusElementInGroup(this.menuItems, target, "previous", false);
            }
            else {
                if (event.detail.isSubmenuOpen) {
                    this.focusParentElement(event.target);
                }
            }
        }
        else if (key === "Escape") {
            this.focusParentElement(event.target);
        }
        event.preventDefault();
    }
    focusParentElement(el) {
        const parentEl = el.parentElement;
        if (parentEl) {
            focusElement(parentEl);
            parentEl.open = false;
        }
    }
    setMenuItemLayout(items, layout) {
        items.forEach((item) => {
            item.layout = layout;
            if (this.getEffectiveRole() === "menubar") {
                item.isTopLevelItem = true;
                item.topLevelMenuLayout = this.layout;
            }
        });
    }
    getEffectiveRole() {
        return this.el.getAttribute("role") || "menubar";
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        return (hAsync(Host, null, hAsync("ul", { "aria-label": this.label, role: this.getEffectiveRole() }, hAsync("slot", { onSlotchange: this.handleMenuSlotChange }))));
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "role": ["handleGlobalAttributesChanged"],
        "layout": ["handleLayoutChange"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return menuCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-menu",
        "$members$": {
            "label": [1],
            "layout": [513],
            "messageOverrides": [1040],
            "messages": [1040],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteInternalMenuItemKeyEvent", "calciteInternalNavMenuItemKeyEvent"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["layout", "layout"]]
    }; }
}

const CSS$1d = {
    container: "container",
    content: "content",
    dropdownVertical: "dropdown--vertical",
    dropdownMenuItems: "dropdown-menu-items",
    dropdownAction: "dropdown-action",
    layoutVertical: "layout--vertical",
    hoverHrefIcon: "hover-href-icon",
    icon: "icon",
    iconBreadcrumb: "icon--breadcrumb",
    iconDropdown: "icon--dropdown",
    iconEnd: "icon--end",
    iconStart: "icon--start",
    isParentVertical: "parent--vertical",
    itemContent: "item-content",
    open: "open",
    nested: "nested",
    textContainer: "text-container",
};

const menuItemCss = "/*!@:host*/.sc-calcite-menu-item-h{position:relative;box-sizing:border-box;display:flex;align-items:center;flex-shrink:0}/*!@:host .container, :host .item-content, :host .content*/.sc-calcite-menu-item-h .container.sc-calcite-menu-item,.sc-calcite-menu-item-h .item-content.sc-calcite-menu-item,.sc-calcite-menu-item-h .content.sc-calcite-menu-item{min-block-size:3rem}/*!@:host([layout=vertical])*/[layout=vertical].sc-calcite-menu-item-h{inline-size:100%}/*!@:host(:not([layout=vertical]))*/.sc-calcite-menu-item-h:not([layout=vertical]){block-size:100%}/*!@.container,\n.item-content*/.container.sc-calcite-menu-item,.item-content.sc-calcite-menu-item{display:flex;block-size:100%;inline-size:100%;flex-direction:row;align-items:stretch}/*!@.content*/.content.sc-calcite-menu-item{position:relative;box-sizing:border-box;display:flex;block-size:100%;inline-size:100%;cursor:pointer;align-items:center;justify-content:center;background-color:var(--calcite-color-foreground-1);padding-inline:1rem;font-size:var(--calcite-font-size-0);color:var(--calcite-color-text-2);outline:2px solid transparent;outline-offset:2px;text-decoration:none;border-block-end:0.125rem solid transparent;padding-block-start:0.125rem}/*!@.content:hover*/.content.sc-calcite-menu-item:hover{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-text-2)}/*!@.content:focus*/.content.sc-calcite-menu-item:focus{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-text-2);outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.content:active*/.content.sc-calcite-menu-item:active{background-color:var(--calcite-color-foreground-3);color:var(--calcite-color-text-1)}/*!@.content span*/.content.sc-calcite-menu-item span.sc-calcite-menu-item{display:inline-flex}/*!@.content.layout--vertical*/.content.layout--vertical.sc-calcite-menu-item{display:flex;inline-size:100%;justify-content:flex-start;padding-block:1rem;border-block-end:0;border-inline-end:0.25rem solid transparent}/*!@:host([active]) .content*/[active].sc-calcite-menu-item-h .content.sc-calcite-menu-item{color:var(--calcite-color-text-1);border-color:var(--calcite-color-brand)}/*!@:host([active]) .content .icon*/[active].sc-calcite-menu-item-h .content.sc-calcite-menu-item .icon.sc-calcite-menu-item{--calcite-ui-icon-color:var(--calcite-color-brand)}/*!@:host([layout=vertical]) .content*/[layout=vertical].sc-calcite-menu-item-h .content.sc-calcite-menu-item{padding-inline:0.75rem}/*!@.icon--start*/.icon--start.sc-calcite-menu-item{margin-inline-end:0.75rem}/*!@.icon--end*/.icon--end.sc-calcite-menu-item{margin-inline-start:0.75rem}/*!@:host([layout=vertical]) .icon--end*/[layout=vertical].sc-calcite-menu-item-h .icon--end.sc-calcite-menu-item{margin-inline-start:auto;padding-inline-start:0.75rem}/*!@.icon--dropdown*/.icon--dropdown.sc-calcite-menu-item{position:relative;margin-inline-start:auto;margin-inline-end:0px;padding-inline-start:0.5rem;--calcite-ui-icon-color:var(--calcite-color-text-3)}/*!@:host([layout=vertical]) .icon--end ~ .icon--dropdown*/[layout=vertical].sc-calcite-menu-item-h .icon--end.sc-calcite-menu-item~.icon--dropdown.sc-calcite-menu-item{margin-inline-start:0.75rem}/*!@:host([layout=vertical]) .hover-href-icon*/[layout=vertical].sc-calcite-menu-item-h .hover-href-icon.sc-calcite-menu-item{padding-inline-start:0.5rem}/*!@:host([layout=vertical]) .hover-href-icon ~ .icon--end*/[layout=vertical].sc-calcite-menu-item-h .hover-href-icon.sc-calcite-menu-item~.icon--end.sc-calcite-menu-item{margin-inline-start:0.5rem}/*!@:host([layout=vertical]) .hover-href-icon ~ .icon--breadcrumb*/[layout=vertical].sc-calcite-menu-item-h .hover-href-icon.sc-calcite-menu-item~.icon--breadcrumb.sc-calcite-menu-item{margin-inline-start:0.75rem}/*!@.icon--breadcrumb*/.icon--breadcrumb.sc-calcite-menu-item{margin-inline-end:0px;padding-inline-start:0.5rem;--calcite-ui-icon-color:var(--calcite-color-text-3)}/*!@:host([layout=vertical]) .icon--breadcrumb*/[layout=vertical].sc-calcite-menu-item-h .icon--breadcrumb.sc-calcite-menu-item{margin-inline-start:auto}/*!@:host([layout=vertical]) .icon--breadcrumb ~ .icon--dropdown*/[layout=vertical].sc-calcite-menu-item-h .icon--breadcrumb.sc-calcite-menu-item~.icon--dropdown.sc-calcite-menu-item{margin-inline-start:0.5rem}/*!@:host([layout=vertical]) .icon--end ~ .icon--breadcrumb*/[layout=vertical].sc-calcite-menu-item-h .icon--end.sc-calcite-menu-item~.icon--breadcrumb.sc-calcite-menu-item{margin-inline-start:0.5rem}/*!@:host([breadcrumb]) .content*/[breadcrumb].sc-calcite-menu-item-h .content.sc-calcite-menu-item{padding-inline-end:0.75rem}/*!@calcite-action*/calcite-action.sc-calcite-menu-item{position:relative;block-size:auto;border-inline-start:1px solid var(--calcite-color-foreground-1)}/*!@calcite-action:after*/calcite-action.sc-calcite-menu-item:after{position:absolute;inset-inline-start:-1px;display:block;inline-size:1px;content:\"\";inset-block:0.75rem;background-color:var(--calcite-color-border-3)}/*!@calcite-action:hover:after*/calcite-action.sc-calcite-menu-item:hover:after{block-size:100%;inset-block:0}/*!@.content:focus ~ calcite-action,\n.content:hover ~ calcite-action*/.content.sc-calcite-menu-item:focus~calcite-action.sc-calcite-menu-item,.content.sc-calcite-menu-item:hover~calcite-action.sc-calcite-menu-item{color:var(--calcite-color-text-1);border-inline-start:1px solid var(--calcite-color-border-3)}/*!@.container:hover .dropdown-action*/.container.sc-calcite-menu-item:hover .dropdown-action.sc-calcite-menu-item{background-color:var(--calcite-color-foreground-2)}/*!@.dropdown-menu-items*/.dropdown-menu-items.sc-calcite-menu-item{position:absolute;display:none;block-size:auto;min-inline-size:100%;flex-direction:column;overflow:visible;border:1px solid var(--calcite-color-border-3);background:var(--calcite-color-foreground-1);inset-block-start:100%;z-index:var(--calcite-z-index-dropdown)}/*!@.dropdown-menu-items.open*/.dropdown-menu-items.open.sc-calcite-menu-item{display:block}/*!@.dropdown-menu-items.nested*/.dropdown-menu-items.nested.sc-calcite-menu-item{position:absolute;inset-block-start:-1px;transform:translateX(calc(100% - 2px))}/*!@.parent--vertical*/.parent--vertical.sc-calcite-menu-item{flex-direction:column}/*!@.dropdown--vertical.dropdown-menu-items*/.dropdown--vertical.dropdown-menu-items.sc-calcite-menu-item{position:relative;border-radius:0px;box-shadow:none;inset-block-start:0;transform:none}/*!@.dropdown--vertical.dropdown-menu-items:last-of-type*/.dropdown--vertical.dropdown-menu-items.sc-calcite-menu-item:last-of-type{border-inline:0}/*!@:host([layout=vertical]:last-of-type) .dropdown-menu-items*/[layout=vertical].sc-calcite-menu-item-h:last-of-type .dropdown-menu-items.sc-calcite-menu-item{border-block-end:0}/*!@:host([slot=submenu-item]) .parent--vertical*/[slot=submenu-item].sc-calcite-menu-item-h .parent--vertical.sc-calcite-menu-item{padding-inline-start:1.5rem}/*!@.dropdown-menu-items.nested.calcite--rtl*/.dropdown-menu-items.nested.calcite--rtl.sc-calcite-menu-item{transform:translateX(calc(-100% + 2px))}/*!@.dropdown--vertical.dropdown-menu-items.nested.calcite--rtl*/.dropdown--vertical.dropdown-menu-items.nested.calcite--rtl.sc-calcite-menu-item{transform:none}/*!@.hover-href-icon*/.hover-href-icon.sc-calcite-menu-item{position:relative;inset-inline-end:0.25rem;margin-inline-start:auto;opacity:0;transition:all var(--calcite-internal-animation-timing-medium) ease-in-out}/*!@.content:focus .hover-href-icon,\n.content:hover .hover-href-icon*/.content.sc-calcite-menu-item:focus .hover-href-icon.sc-calcite-menu-item,.content.sc-calcite-menu-item:hover .hover-href-icon.sc-calcite-menu-item{inset-inline-end:-0.25rem;opacity:1}/*!@:host([hidden])*/[hidden].sc-calcite-menu-item-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-menu-item{display:none}";

/**
 * @slot submenu-item - A slot for adding `calcite-menu-item`s in a submenu.
 */
class CalciteMenuItem {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalMenuItemKeyEvent = createEvent(this, "calciteInternalMenuItemKeyEvent", 7);
        this.calciteMenuItemSelect = createEvent(this, "calciteMenuItemSelect", 7);
        this.clickHandler = (event) => {
            if ((this.href && event.target === this.dropdownActionEl) || (!this.href && this.hasSubmenu)) {
                this.open = !this.open;
            }
            this.selectMenuItem(event);
        };
        this.handleMenuItemSlotChange = (event) => {
            this.submenuItems = slotChangeGetAssignedElements(event);
            this.submenuItems.forEach((item) => {
                if (!item.topLevelMenuLayout) {
                    item.topLevelMenuLayout = this.topLevelMenuLayout;
                }
            });
            this.hasSubmenu = this.submenuItems.length > 0;
        };
        this.keyDownHandler = async (event) => {
            const { hasSubmenu, href, layout, open, submenuItems } = this;
            const key = event.key;
            const targetIsDropdown = event.target === this.dropdownActionEl;
            if (key === " " || key === "Enter") {
                if (hasSubmenu && (!href || (href && targetIsDropdown))) {
                    this.open = !open;
                }
                if (!(href && targetIsDropdown) && key !== "Enter") {
                    this.selectMenuItem(event);
                }
                if (key === " " || (href && targetIsDropdown)) {
                    event.preventDefault();
                }
            }
            else if (key === "Escape") {
                if (open) {
                    this.open = false;
                    return;
                }
                this.calciteInternalMenuItemKeyEvent.emit({ event });
                event.preventDefault();
            }
            else if (key === "ArrowDown" || key === "ArrowUp") {
                event.preventDefault();
                if ((targetIsDropdown || !href) && hasSubmenu && !open && layout === "horizontal") {
                    this.open = true;
                    return;
                }
                this.calciteInternalMenuItemKeyEvent.emit({
                    event,
                    children: submenuItems,
                    isSubmenuOpen: open && hasSubmenu,
                });
            }
            else if (key === "ArrowLeft") {
                event.preventDefault();
                this.calciteInternalMenuItemKeyEvent.emit({
                    event,
                    children: submenuItems,
                    isSubmenuOpen: true,
                });
            }
            else if (key === "ArrowRight") {
                event.preventDefault();
                if ((targetIsDropdown || !href) && hasSubmenu && !open && layout === "vertical") {
                    this.open = true;
                    return;
                }
                this.calciteInternalMenuItemKeyEvent.emit({
                    event,
                    children: submenuItems,
                    isSubmenuOpen: open && hasSubmenu,
                });
            }
        };
        this.active = undefined;
        this.breadcrumb = undefined;
        this.href = undefined;
        this.iconEnd = undefined;
        this.iconFlipRtl = undefined;
        this.iconStart = undefined;
        this.isTopLevelItem = false;
        this.label = undefined;
        this.layout = undefined;
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.open = false;
        this.rel = undefined;
        this.target = undefined;
        this.text = undefined;
        this.topLevelMenuLayout = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
        this.hasSubmenu = false;
        this.submenuItems = undefined;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.anchorEl.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    handleClickOut(event) {
        if (this.topLevelMenuLayout !== "vertical" &&
            this.hasSubmenu &&
            this.open &&
            !event.composedPath().includes(this.el)) {
            this.open = false;
        }
    }
    handleFocusOut(event) {
        if (this.topLevelMenuLayout !== "vertical" &&
            !this.el.contains(event.relatedTarget)) {
            this.open = false;
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectLocalized(this);
        connectMessages(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    blurHandler() {
        this.isFocused = false;
    }
    focusHandler(event) {
        const target = event.target;
        this.isFocused = true;
        if (target.open && !this.open) {
            target.open = false;
        }
    }
    selectMenuItem(event) {
        if (event.target !== this.dropdownActionEl) {
            this.calciteMenuItemSelect.emit();
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    renderIconStart() {
        return (hAsync("calcite-icon", { class: `${CSS$1d.icon} ${CSS$1d.iconStart}`, flipRtl: this.iconFlipRtl === "start" || this.iconFlipRtl === "both", icon: this.iconStart, key: CSS$1d.iconStart, scale: "s" }));
    }
    renderIconEnd() {
        return (hAsync("calcite-icon", { class: `${CSS$1d.icon} ${CSS$1d.iconEnd}`, flipRtl: this.iconFlipRtl === "end" || this.iconFlipRtl === "both", icon: this.iconEnd, key: CSS$1d.iconEnd, scale: "s" }));
    }
    renderBreadcrumbIcon(dir) {
        return (hAsync("calcite-icon", { class: `${CSS$1d.icon} ${CSS$1d.iconBreadcrumb}`, icon: dir === "rtl" ? "chevron-left" : "chevron-right", key: CSS$1d.iconBreadcrumb, scale: "s" }));
    }
    renderDropdownIcon(dir) {
        const dirChevron = dir === "rtl" ? "chevron-left" : "chevron-right";
        return (hAsync("calcite-icon", { class: `${CSS$1d.icon} ${CSS$1d.iconDropdown}`, icon: this.topLevelMenuLayout === "vertical" || this.isTopLevelItem
                ? this.open
                    ? "chevron-up"
                    : "chevron-down"
                : dirChevron, key: CSS$1d.iconDropdown, scale: "s" }));
    }
    renderDropdownAction(dir) {
        const dirChevron = dir === "rtl" ? "chevron-left" : "chevron-right";
        return (hAsync("calcite-action", { class: CSS$1d.dropdownAction, icon: this.topLevelMenuLayout === "vertical" || this.isTopLevelItem
                ? this.open
                    ? "chevron-up"
                    : "chevron-down"
                : dirChevron, key: CSS$1d.dropdownAction, onClick: this.clickHandler, onKeyDown: this.keyDownHandler, text: this.messages.open,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.dropdownActionEl = el) }));
    }
    renderSubmenuItems(dir) {
        return (hAsync("calcite-menu", { class: {
                [CSS$1d.dropdownMenuItems]: true,
                [CSS$1d.open]: this.open,
                [CSS$1d.nested]: !this.isTopLevelItem,
                [CSS_UTILITY.rtl]: dir === "rtl",
                [CSS$1d.dropdownVertical]: this.topLevelMenuLayout === "vertical",
            }, label: this.messages.submenu, layout: "vertical", role: "menu" }, hAsync("slot", { name: "submenu-item", onSlotchange: this.handleMenuItemSlotChange })));
    }
    renderHrefIcon(dir) {
        return (hAsync("calcite-icon", { class: CSS$1d.hoverHrefIcon, icon: dir === "rtl" ? "arrow-left" : "arrow-right", key: CSS$1d.hoverHrefIcon, scale: "s" }));
    }
    renderItemContent(dir) {
        const hasHref = this.href && (this.topLevelMenuLayout === "vertical" || !this.isTopLevelItem);
        return (hAsync(Fragment, null, this.iconStart && this.renderIconStart(), hAsync("div", { class: CSS$1d.textContainer }, hAsync("span", null, this.text)), hasHref && this.renderHrefIcon(dir), this.iconEnd && this.renderIconEnd(), this.breadcrumb ? this.renderBreadcrumbIcon(dir) : null, !this.href && this.hasSubmenu ? this.renderDropdownIcon(dir) : null));
    }
    render() {
        const dir = getElementDir(this.el);
        return (hAsync(Host, { onBlur: this.blurHandler, onFocus: this.focusHandler }, hAsync("li", { class: {
                [CSS$1d.container]: true,
                [CSS$1d.isParentVertical]: this.topLevelMenuLayout === "vertical",
            }, role: "none" }, hAsync("div", { class: CSS$1d.itemContent }, hAsync("a", { "aria-current": this.isFocused ? "page" : false, "aria-expanded": this.open, "aria-haspopup": this.hasSubmenu, "aria-label": this.label, class: { [CSS$1d.layoutVertical]: this.layout === "vertical", [CSS$1d.content]: true }, href: this.href, onClick: this.clickHandler, onKeyDown: this.keyDownHandler, rel: this.rel, role: "menuitem", tabIndex: this.isTopLevelItem ? 0 : -1, target: this.target,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.anchorEl = el) }, this.renderItemContent(dir)), this.href && this.hasSubmenu ? this.renderDropdownAction(dir) : null), this.renderSubmenuItems(dir))));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return menuItemCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-menu-item",
        "$members$": {
            "active": [516],
            "breadcrumb": [516],
            "href": [1],
            "iconEnd": [513, "icon-end"],
            "iconFlipRtl": [513, "icon-flip-rtl"],
            "iconStart": [513, "icon-start"],
            "isTopLevelItem": [4, "is-top-level-item"],
            "label": [1],
            "layout": [513],
            "messageOverrides": [1040],
            "messages": [1040],
            "open": [1540],
            "rel": [513],
            "target": [513],
            "text": [1],
            "topLevelMenuLayout": [1, "top-level-menu-layout"],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "hasSubmenu": [32],
            "submenuItems": [32],
            "setFocus": [64]
        },
        "$listeners$": [[8, "click", "handleClickOut"], [0, "focusout", "handleFocusOut"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["active", "active"], ["breadcrumb", "breadcrumb"], ["iconEnd", "icon-end"], ["iconFlipRtl", "icon-flip-rtl"], ["iconStart", "icon-start"], ["layout", "layout"], ["open", "open"], ["rel", "rel"], ["target", "target"]]
    }; }
}

const CSS$1c = {
    container: "container",
    containerContent: "container-content",
    hasProgress: "progress-bar",
    hide: "hide",
    primary: "primary",
    secondary: "secondary",
    tertiary: "tertiary",
};
const SLOTS$r = {
    logo: "logo",
    user: "user",
    progress: "progress",
    navigationAction: "navigation-action",
    contentStart: "content-start",
    contentEnd: "content-end",
    contentCenter: "content-center",
    navSecondary: "navigation-secondary",
    navTertiary: "navigation-tertiary",
};
const ICONS$g = {
    hamburger: "hamburger",
};

const navigationCss = "/*!@:host([hidden])*/[hidden].sc-calcite-navigation-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-navigation{display:none}/*!@.container*/.container.sc-calcite-navigation{margin-inline:auto;display:flex;inline-size:100%;flex-direction:column;margin-block:0;margin-inline:auto;background-color:var(--calcite-navigation-background, var(--calcite-color-foreground-1))}/*!@.container.primary, .container.secondary, .container.tertiary*/.container.primary.sc-calcite-navigation,.container.secondary.sc-calcite-navigation,.container.tertiary.sc-calcite-navigation{border-block-end:1px solid;border-block-end-color:var(--calcite-navigation-border-color, var(--calcite-color-border-3))}/*!@.user,\n.logo*/.user.sc-calcite-navigation,.logo.sc-calcite-navigation{display:flex}/*!@.hide*/.hide.sc-calcite-navigation{display:none}/*!@.primary*/.primary.sc-calcite-navigation{block-size:4rem}/*!@.secondary*/.secondary.sc-calcite-navigation{block-size:3rem}/*!@.tertiary*/.tertiary.sc-calcite-navigation{block-size:3rem}/*!@.container-content*/.container-content.sc-calcite-navigation{margin-inline:auto;display:flex;block-size:100%;inline-size:100%;margin-block:0;inline-size:var(--calcite-navigation-width, 100%);max-inline-size:100%}/*!@.container-content.progress-bar*/.container-content.progress-bar.sc-calcite-navigation{margin-block-start:0.125rem}/*!@slot[name]*/slot[name].sc-calcite-navigation{display:flex;flex-direction:row}/*!@slot[name=navigation-secondary]::slotted(calcite-navigation),\nslot[name=navigation-tertiary]::slotted(calcite-navigation)*/slot[name=navigation-secondary].sc-calcite-navigation-s>calcite-navigation,slot[name=navigation-tertiary].sc-calcite-navigation-s>calcite-navigation{inline-size:100%}/*!@slot[name=content-start]::slotted(*),\nslot[name=content-center]::slotted(*),\nslot[name=content-end]::slotted(*)*/slot[name=content-start].sc-calcite-navigation-s>*,slot[name=content-center].sc-calcite-navigation-s>*,slot[name=content-end].sc-calcite-navigation-s>*{display:flex;flex-direction:row;align-items:center}/*!@slot[name=progress],\nslot[name=progress] calcite-progress*/slot[name=progress].sc-calcite-navigation,slot[name=progress].sc-calcite-navigation calcite-progress.sc-calcite-navigation{inset-block-start:0;inset-inline:0}/*!@slot[name=content-end]*/slot[name=content-end].sc-calcite-navigation{margin-inline-start:auto}/*!@slot[name=content-start]*/slot[name=content-start].sc-calcite-navigation{margin-inline-end:auto}/*!@slot[name=content-end],\nslot[name=logo] ~ slot[name=user],\nslot[name=user]:only-child*/slot[name=content-end].sc-calcite-navigation,slot[name=logo].sc-calcite-navigation~slot[name=user].sc-calcite-navigation,slot[name=user].sc-calcite-navigation:only-child{margin-inline-start:auto}/*!@slot[name=content-center]*/slot[name=content-center].sc-calcite-navigation{margin-inline-start:auto;margin-inline-end:auto}/*!@slot[name=content-start] ~ slot[name=content-center]*/slot[name=content-start].sc-calcite-navigation~slot[name=content-center].sc-calcite-navigation{margin-inline-start:0px}/*!@slot[name=content-start] ~ slot[name=content-end],\nslot[name=content-center] ~ slot[name=content-end],\nslot[name=content-center] ~ slot[name=user],\nslot[name=content-end] ~ slot[name=user]*/slot[name=content-start].sc-calcite-navigation~slot[name=content-end].sc-calcite-navigation,slot[name=content-center].sc-calcite-navigation~slot[name=content-end].sc-calcite-navigation,slot[name=content-center].sc-calcite-navigation~slot[name=user].sc-calcite-navigation,slot[name=content-end].sc-calcite-navigation~slot[name=user].sc-calcite-navigation{margin:0px}";

/**
 * @slot logo - A slot for adding a `calcite-logo` component to the primary navigation level.
 * @slot user - A slot for adding a `calcite-user` component to the primary navigation level.
 * @slot progress - A slot for adding a `calcite-progress` component to the primary navigation level.
 * @slot navigation-action - A slot for adding a `calcite-action` component to the primary navigation level.
 * @slot content-start - A slot for adding a `calcite-menu`, `calcite-action`, or other interactive elements in the start position of any navigation level.
 * @slot content-center - A slot for adding a `calcite-menu`, `calcite-action`, or other interactive elements in the center position of the primary navigation level.
 * @slot content-end - A slot for adding a `calcite-menu`, `calcite-action`, or other interactive elements in the end position of any navigation level.
 * @slot navigation-secondary - A slot for adding a `calcite-navigation` component in the secondary navigation level. Components rendered here will not display `calcite-navigation-logo` or `calcite-navigation-user` components.
 * @slot navigation-tertiary - A slot for adding a `calcite-navigation` component in the tertiary navigation level.  Components rendered here will not display `calcite-navigation-logo` or `calcite-navigation-user` components.
 */
class CalciteNavigation {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteNavigationActionSelect = createEvent(this, "calciteNavigationActionSelect", 6);
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.actionClickHandler = () => {
            this.calciteNavigationActionSelect.emit();
        };
        this.handleUserSlotChange = (event) => {
            if (this.isPrimaryLevel()) {
                this.userSlotHasElements = slotChangeHasAssignedElement(event);
            }
        };
        this.handleLogoSlotChange = (event) => {
            if (this.isPrimaryLevel()) {
                this.logoSlotHasElements = slotChangeHasAssignedElement(event);
            }
        };
        this.handleContentStartSlotChange = (event) => {
            if (this.isPrimaryLevel()) {
                this.primaryContentStartSlotHasElements = slotChangeHasAssignedElement(event);
            }
        };
        this.handleContentEndSlotChange = (event) => {
            if (this.isPrimaryLevel()) {
                this.primaryContentEndSlotHasElements = slotChangeHasAssignedElement(event);
            }
        };
        this.handleContentCenterSlotChange = (event) => {
            if (this.isPrimaryLevel()) {
                this.primaryContentCenterSlotHasElements = slotChangeHasAssignedElement(event);
            }
        };
        this.handleSecondarySlotChange = (event) => {
            this.secondarySlotHasElements = slotChangeHasAssignedElement(event);
        };
        this.handleTertiarySlotChange = (event) => {
            this.tertiarySlotHasElements = slotChangeHasAssignedElement(event);
        };
        this.handleMenuActionSlotChange = (event) => {
            if (this.isPrimaryLevel()) {
                this.navigationActionSlotHasElements = slotChangeHasAssignedElement(event);
                if (this.navigationActionSlotHasElements) {
                    this.navigationAction = false;
                }
            }
        };
        this.handleProgressSlotChange = (event) => {
            if (this.isPrimaryLevel()) {
                this.progressSlotHasElement = slotChangeHasAssignedElement(event);
            }
        };
        this.label = undefined;
        this.navigationAction = false;
        this.logoSlotHasElements = undefined;
        this.navigationActionSlotHasElements = undefined;
        this.primaryContentCenterSlotHasElements = undefined;
        this.primaryContentEndSlotHasElements = undefined;
        this.primaryContentStartSlotHasElements = undefined;
        this.progressSlotHasElement = undefined;
        this.secondarySlotHasElements = undefined;
        this.tertiarySlotHasElements = undefined;
        this.userSlotHasElements = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** When `navigationAction` is `true`, sets focus on the component's action element. */
    async setFocus() {
        await componentFocusable(this);
        return this.navigationActionEl?.setFocus();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    isPrimaryLevel() {
        return this.el.slot !== SLOTS$r.navSecondary && this.el.slot !== SLOTS$r.navTertiary;
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    renderMenuAction() {
        return (hAsync("slot", { name: SLOTS$r.navigationAction, onSlotchange: this.handleMenuActionSlotChange }, this.navigationAction && (hAsync("calcite-action", { icon: ICONS$g.hamburger, onClick: this.actionClickHandler, text: this.label,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.navigationActionEl = el) }))));
    }
    render() {
        const primaryLevelHasElements = this.logoSlotHasElements ||
            this.userSlotHasElements ||
            this.navigationActionSlotHasElements ||
            this.primaryContentCenterSlotHasElements ||
            this.primaryContentEndSlotHasElements ||
            this.primaryContentStartSlotHasElements ||
            this.navigationAction;
        const slotName = this.el.slot;
        return (hAsync(Host, null, hAsync("div", { class: {
                [CSS$1c.container]: true,
                [CSS$1c.secondary]: slotName === SLOTS$r.navSecondary,
                [CSS$1c.tertiary]: slotName === SLOTS$r.navTertiary,
                [CSS$1c.primary]: primaryLevelHasElements,
            } }, hAsync("div", { class: { [CSS$1c.hide]: !this.progressSlotHasElement, [SLOTS$r.progress]: true } }, hAsync("slot", { name: SLOTS$r.progress, onSlotchange: this.handleProgressSlotChange })), hAsync("div", { class: { [CSS$1c.containerContent]: true, [CSS$1c.hasProgress]: this.progressSlotHasElement } }, this.renderMenuAction(), hAsync("div", { class: { [CSS$1c.hide]: !this.logoSlotHasElements, [SLOTS$r.logo]: true } }, hAsync("slot", { name: SLOTS$r.logo, onSlotchange: this.handleLogoSlotChange })), hAsync("slot", { name: SLOTS$r.contentStart, onSlotchange: this.handleContentStartSlotChange }), hAsync("slot", { name: SLOTS$r.contentCenter, onSlotchange: this.handleContentCenterSlotChange }), hAsync("slot", { name: SLOTS$r.contentEnd, onSlotchange: this.handleContentEndSlotChange }), hAsync("div", { class: { [CSS$1c.hide]: !this.userSlotHasElements, [SLOTS$r.user]: true } }, hAsync("slot", { name: SLOTS$r.user, onSlotchange: this.handleUserSlotChange })))), hAsync(Fragment, null, hAsync("slot", { name: SLOTS$r.navSecondary, onSlotchange: this.handleSecondarySlotChange }), hAsync("slot", { name: SLOTS$r.navTertiary, onSlotchange: this.handleTertiarySlotChange }))));
    }
    get el() { return getElement(this); }
    static get style() { return navigationCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-navigation",
        "$members$": {
            "label": [1],
            "navigationAction": [516, "navigation-action"],
            "logoSlotHasElements": [32],
            "navigationActionSlotHasElements": [32],
            "primaryContentCenterSlotHasElements": [32],
            "primaryContentEndSlotHasElements": [32],
            "primaryContentStartSlotHasElements": [32],
            "progressSlotHasElement": [32],
            "secondarySlotHasElements": [32],
            "tertiarySlotHasElements": [32],
            "userSlotHasElements": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["navigationAction", "navigation-action"]]
    }; }
}

const CSS$1b = {
    container: "container",
    heading: "heading",
    description: "description",
    anchor: "anchor",
    image: "image",
    standalone: "standalone",
    icon: "icon",
};

const navigationLogoCss = "/*!@:host*/.sc-calcite-navigation-logo-h{display:inline-flex;outline:2px solid transparent;outline-offset:2px}/*!@.anchor*/.anchor.sc-calcite-navigation-logo{margin:0px;display:flex;cursor:pointer;align-items:center;justify-content:center;font-size:var(--calcite-font-size-0);line-height:1.25rem;text-decoration-line:none;outline-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;color:inherit;border-block-end:2px solid transparent}/*!@.anchor:hover,\n.anchor:focus*/.anchor.sc-calcite-navigation-logo:hover,.anchor.sc-calcite-navigation-logo:focus{background-color:var(--calcite-color-foreground-2)}/*!@.anchor:focus*/.anchor.sc-calcite-navigation-logo:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.anchor:active*/.anchor.sc-calcite-navigation-logo:active{background-color:var(--calcite-color-foreground-3)}/*!@.image,\n.icon*/.image.sc-calcite-navigation-logo,.icon.sc-calcite-navigation-logo{margin:0px;display:flex;block-size:1.75rem;padding-inline:1rem}/*!@.image ~ .icon*/.image.sc-calcite-navigation-logo~.icon.sc-calcite-navigation-logo{padding-inline-start:0px}/*!@.image ~ .container,\n.icon ~ .container*/.image.sc-calcite-navigation-logo~.container.sc-calcite-navigation-logo,.icon.sc-calcite-navigation-logo~.container.sc-calcite-navigation-logo{padding-inline-start:0px}/*!@:host(:active) .anchor*/.sc-calcite-navigation-logo-h:active .anchor.sc-calcite-navigation-logo{color:var(--calcite-color-text-1)}/*!@:host([active]) .anchor*/[active].sc-calcite-navigation-logo-h .anchor.sc-calcite-navigation-logo{color:var(--calcite-color-text-1);border-color:var(--calcite-color-brand);--calcite-ui-icon-color:var(--calcite-color-brand)}/*!@.container*/.container.sc-calcite-navigation-logo{margin-block-start:0.125rem;display:flex;flex-direction:column;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-inline:1rem;text-align:start}/*!@.heading*/.heading.sc-calcite-navigation-logo{margin-inline-start:0px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:var(--calcite-font-size-0);font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1)}/*!@.standalone*/.standalone.sc-calcite-navigation-logo{font-size:var(--calcite-font-size-1)}/*!@.description*/.description.sc-calcite-navigation-logo{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host([hidden])*/[hidden].sc-calcite-navigation-logo-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-navigation-logo{display:none}";

class CalciteNavigationLogo {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.active = undefined;
        this.href = undefined;
        this.icon = undefined;
        this.iconFlipRtl = false;
        this.label = undefined;
        this.rel = undefined;
        this.description = undefined;
        this.target = undefined;
        this.heading = undefined;
        this.thumbnail = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        if (this.href) {
            this.el.focus();
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderIcon() {
        /** Icon scale is not variable as the component does not have a scale property */
        return hAsync("calcite-icon", { class: CSS$1b.icon, flipRtl: this.iconFlipRtl, icon: this.icon, scale: "l" });
    }
    render() {
        const { heading, description, thumbnail } = this;
        return (hAsync(Host, null, hAsync("a", { class: CSS$1b.anchor, href: this.href, rel: this.rel, target: this.target }, thumbnail && hAsync("img", { alt: this.label || "", class: CSS$1b.image, src: thumbnail }), this.icon && this.renderIcon(), (heading || description) && (hAsync("div", { class: CSS$1b.container }, heading && (hAsync("span", { "aria-label": this.heading, class: {
                [CSS$1b.heading]: true,
                [CSS$1b.standalone]: !this.description,
            }, key: CSS$1b.heading }, heading)), description && (hAsync("span", { "aria-label": this.description, class: CSS$1b.description, key: CSS$1b.description }, description)))))));
    }
    static get delegatesFocus() { return true; }
    get el() { return getElement(this); }
    static get style() { return navigationLogoCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-navigation-logo",
        "$members$": {
            "active": [516],
            "href": [513],
            "icon": [513],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "label": [1],
            "rel": [513],
            "description": [1],
            "target": [513],
            "heading": [1],
            "thumbnail": [1],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["active", "active"], ["href", "href"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["rel", "rel"], ["target", "target"]]
    }; }
}

const CSS$1a = {
    textContainer: "text-container",
    fullName: "full-name",
    username: "username",
    button: "button",
};

const navigationUserCss = "/*!@:host*/.sc-calcite-navigation-user-h{display:inline-flex;outline:2px solid transparent;outline-offset:2px}/*!@:host .button*/.sc-calcite-navigation-user-h .button.sc-calcite-navigation-user{background-color:transparent;border:none;margin:0px;display:flex;cursor:pointer;align-items:center;justify-content:center;font-family:var(--calcite-sans-family);font-size:var(--calcite-font-size-0);line-height:1.25rem;outline-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;border-block-end:2px solid transparent}/*!@:host(:hover) .button,\n:host(:focus) .button*/.sc-calcite-navigation-user-h:hover .button.sc-calcite-navigation-user,.sc-calcite-navigation-user-h:focus .button.sc-calcite-navigation-user{background-color:var(--calcite-color-foreground-2)}/*!@:host(:focus) .button*/.sc-calcite-navigation-user-h:focus .button.sc-calcite-navigation-user{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host(:active) .button*/.sc-calcite-navigation-user-h:active .button.sc-calcite-navigation-user{background-color:var(--calcite-color-foreground-3);color:var(--calcite-color-text-1)}/*!@calcite-avatar*/calcite-avatar.sc-calcite-navigation-user{padding-inline:1rem}/*!@calcite-avatar ~ .text-container*/calcite-avatar.sc-calcite-navigation-user~.text-container.sc-calcite-navigation-user{padding-inline-start:0px}/*!@:host([active]) .button*/[active].sc-calcite-navigation-user-h .button.sc-calcite-navigation-user{border-color:var(--calcite-color-brand);color:var(--calcite-color-text-1);--calcite-ui-icon-color:var(--calcite-color-brand)}/*!@.text-container*/.text-container.sc-calcite-navigation-user{margin-block-start:0.125rem;display:flex;flex-direction:column;padding-inline:1rem;text-align:start}/*!@.full-name*/.full-name.sc-calcite-navigation-user{margin-inline-start:0px;font-size:var(--calcite-font-size-0);font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1)}/*!@.username*/.username.sc-calcite-navigation-user{color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host([hidden])*/[hidden].sc-calcite-navigation-user-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-navigation-user{display:none}";

class CalciteNavigationUser {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.active = undefined;
        this.fullName = undefined;
        this.label = undefined;
        this.textDisabled = false;
        this.thumbnail = undefined;
        this.userId = undefined;
        this.username = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.el.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        return (hAsync(Host, null, hAsync("button", { "aria-label": this.label, class: CSS$1a.button }, hAsync("calcite-avatar", { "full-name": this.fullName, label: this.label, thumbnail: this.thumbnail, "user-id": this.userId, username: this.username }), (this.fullName || this.username) && !this.textDisabled && (hAsync("div", { class: CSS$1a.textContainer }, this.fullName && (hAsync("span", { class: CSS$1a.fullName, key: CSS$1a.fullName }, this.fullName)), this.username && (hAsync("span", { class: CSS$1a.username, key: CSS$1a.username }, this.username)))))));
    }
    static get delegatesFocus() { return true; }
    get el() { return getElement(this); }
    static get style() { return navigationUserCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-navigation-user",
        "$members$": {
            "active": [516],
            "fullName": [1, "full-name"],
            "label": [1],
            "textDisabled": [516, "text-disabled"],
            "thumbnail": [1],
            "userId": [1, "user-id"],
            "username": [1],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["active", "active"], ["textDisabled", "text-disabled"]]
    }; }
}

const CSS$19 = {
    container: "container",
    contentWrapper: "content-wrapper",
    header: "header",
    footer: "footer",
    heading: "heading",
    description: "description",
    checkboxWrapper: "checkbox-wrapper",
    checkboxWrapperDeprecated: "checkbox-wrapper-deprecated",
    thumbnailWrapper: "thumbnail-wrapper",
    headerTextContainer: "header-text-container",
    cardContent: "card-content",
    hasSlottedContent: "has-slotted-content",
};
const SLOTS$q = {
    thumbnail: "thumbnail",
    heading: "heading",
    description: "description",
    footerStart: "footer-start",
    footerEnd: "footer-end",
    title: "title",
    subtitle: "subtitle",
};
const ICONS$f = {
    selected: "check-square-f",
    unselected: "square",
    selectedSingle: "circle-f",
    unselectedSingle: "circle",
};

const cardCss = "/*!@:host([disabled])*/[disabled].sc-calcite-card-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-card-h *.sc-calcite-card,.sc-calcite-card-h[disabled].sc-calcite-card-s>*,.sc-calcite-card-h[disabled] .sc-calcite-card-s>*{pointer-events:none}/*!@:host*/.sc-calcite-card-h{display:block;max-inline-size:100%;--calcite-card-corner-radius:var(--calcite-corner-radius-sharp);--calcite-card-background-color:var(--calcite-color-foreground-1);--calcite-card-border-color:var(--calcite-color-border-3);--calcite-card-shadow:var(--calcite-shadow-none);--calcite-card-accent-color-selected:var(--calcite-color-brand);--calcite-card-selection-background-color:transparent;--calcite-card-selection-background-color-hover:var(--calcite-color-transparent-hover);--calcite-card-selection-background-color-active:var(--calcite-color-transparent-press);--calcite-card-selection-background-color-selected:transparent;--calcite-card-selection-icon-color:var(--calcite-color-text-3);--calcite-card-selection-icon-color-hover:var(--calcite-color-text-2);--calcite-card-selection-icon-color-selected:var(--calcite-color-brand)}/*!@.content-wrapper*/.content-wrapper.sc-calcite-card{position:relative;display:flex;block-size:100%;flex-direction:column;justify-content:space-between;overflow:hidden;border:var(--calcite-border-width-sm) solid var(--calcite-card-border-color);border-radius:var(--calcite-card-corner-radius);background-color:var(--calcite-card-background-color);box-shadow:var(--calcite-card-shadow);pointer-events:none}/*!@::slotted(*)*/.sc-calcite-card-s>*{pointer-events:auto}/*!@:host(:not([selectable])) .content-wrapper:not(.non-interactive)*/.sc-calcite-card-h:not([selectable]) .content-wrapper.sc-calcite-card:not(.non-interactive){outline-color:transparent}/*!@:host(:not([selectable])) .content-wrapper:not(.non-interactive):focus*/.sc-calcite-card-h:not([selectable]) .content-wrapper.sc-calcite-card:not(.non-interactive):focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.container*/.container.sc-calcite-card{position:relative;display:flex;flex:1 1 auto;flex-direction:column}/*!@:host([loading]) .content-wrapper *:not(calcite-loader):not(.calcite-card-loader-container)*/[loading].sc-calcite-card-h .content-wrapper.sc-calcite-card *.sc-calcite-card:not(calcite-loader):not(.calcite-card-loader-container){pointer-events:none;opacity:0}/*!@:host([loading]) .calcite-card-loader-container*/[loading].sc-calcite-card-h .calcite-card-loader-container.sc-calcite-card{position:absolute;inset:0px;display:flex;align-items:center}/*!@.header*/.header.sc-calcite-card{display:flex;flex-direction:row;align-items:flex-start}/*!@.footer*/.footer.sc-calcite-card{margin-block-start:auto;display:flex;flex-direction:row;align-content:space-between;justify-content:space-between;padding-inline:var(--calcite-spacing-md);padding-block-start:var(--calcite-spacing-xxs);padding-block-end:var(--calcite-spacing-md)}/*!@.header-text-container*/.header-text-container.sc-calcite-card{display:flex;inline-size:100%;flex-direction:column;justify-content:center;padding-inline:0.75rem;padding-block:0.5rem}/*!@.header-text-container:not(:only-child)*/.header-text-container.sc-calcite-card:not(:only-child){padding-inline-end:0.125rem}/*!@.footer*/.footer.sc-calcite-card{margin-block-start:auto;flex-direction:row;align-content:space-between;justify-content:space-between;padding-inline:0.75rem;padding-block:0.25rem 0.75rem}/*!@.card-content*/.card-content.sc-calcite-card{block-size:auto;font-size:var(--calcite-font-size--2);line-height:1.375}/*!@.has-slotted-content*/.has-slotted-content.sc-calcite-card{padding:0.75rem}/*!@:host([selected]) .content-wrapper*/[selected].sc-calcite-card-h .content-wrapper.sc-calcite-card{box-shadow:inset 0 -4px 0 0 var(--calcite-card-accent-color-selected)}/*!@:host([selectable]) .header*/[selectable].sc-calcite-card-h .header.sc-calcite-card{padding-inline-end:var(--calcite-spacing-xxxl)}/*!@slot[name=title]::slotted(*),\n*::slotted([slot=title])*/slot[name=title].sc-calcite-card-s>*,*.sc-calcite-card-s>[slot=title]{margin:0px;font-size:var(--calcite-font-size--1);line-height:1.375;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1)}/*!@slot[name=subtitle]::slotted(*),\n*::slotted([slot=subtitle])*/slot[name=subtitle].sc-calcite-card-s>*,*.sc-calcite-card-s>[slot=subtitle]{margin:0px;margin-block-start:0.125rem;font-size:var(--calcite-font-size--2);line-height:1.375;font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-2)}/*!@slot[name=heading]::slotted(*),\n*::slotted([slot=heading])*/slot[name=heading].sc-calcite-card-s>*,*.sc-calcite-card-s>[slot=heading]{margin:0px;font-size:var(--calcite-font-size--1);line-height:1.375;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1)}/*!@slot[name=description]::slotted(*),\n*::slotted([slot=description])*/slot[name=description].sc-calcite-card-s>*,*.sc-calcite-card-s>[slot=description]{margin:0px;margin-block-start:0.125rem;font-size:var(--calcite-font-size--2);line-height:1.375;font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-2)}/*!@slot[name=thumbnail]::slotted(img),\nimg::slotted([slot=thumbnail])*/slot[name=thumbnail].sc-calcite-card-s>img,img.sc-calcite-card-s>[slot=thumbnail]{min-inline-size:100%;max-inline-size:100%}/*!@slot[name=footer-start]::slotted(*),\n*::slotted([slot=footer-start])*/slot[name=footer-start].sc-calcite-card-s>*,*.sc-calcite-card-s>[slot=footer-start]{align-self:center;font-size:var(--calcite-font-size--2);line-height:1.375;margin-inline-end:auto;color:var(--calcite-color-text-3)}/*!@slot[name=footer-end]::slotted(*),\n*::slotted([slot=footer-end])*/slot[name=footer-end].sc-calcite-card-s>*,*.sc-calcite-card-s>[slot=footer-end]{align-self:center;font-size:var(--calcite-font-size--2);line-height:1.375;color:var(--calcite-color-text-3)}/*!@.checkbox-wrapper-deprecated*/.checkbox-wrapper-deprecated.sc-calcite-card{pointer-events:auto;position:absolute;inset-block-start:var(--calcite-spacing-sm);inset-inline-end:var(--calcite-spacing-sm);margin:0;padding:0}/*!@.checkbox-wrapper*/.checkbox-wrapper.sc-calcite-card{pointer-events:auto;margin:0.5rem;cursor:pointer;padding:0.5rem;outline-color:transparent;background-color:var(--calcite-card-selection-background-color);display:flex;align-items:center;justify-items:center;--calcite-ui-icon-color:var(--calcite-card-selection-icon-color)}/*!@.checkbox-wrapper:hover*/.checkbox-wrapper.sc-calcite-card:hover{background-color:var(--calcite-card-selection-background-color-hover);--calcite-ui-icon-color:var(--calcite-card-selection-icon-color-hover)}/*!@.checkbox-wrapper:active*/.checkbox-wrapper.sc-calcite-card:active{background-color:var(--calcite-card-selection-background-color-active)}/*!@.checkbox-wrapper calcite-icon*/.checkbox-wrapper.sc-calcite-card calcite-icon.sc-calcite-card{pointer-events:none}/*!@:host([selected]) .checkbox-wrapper*/[selected].sc-calcite-card-h .checkbox-wrapper.sc-calcite-card{--calcite-ui-icon-color:var(--calcite-card-selection-icon-color-selected);background-color:var(--calcite-card-selection-background-color-selected)}/*!@:host([selected]) .checkbox-wrapper:hover*/[selected].sc-calcite-card-h .checkbox-wrapper.sc-calcite-card:hover{background-color:var(--calcite-card-selection-background-color-hover)}/*!@:host([selected]) .checkbox-wrapper:active*/[selected].sc-calcite-card-h .checkbox-wrapper.sc-calcite-card:active{background-color:var(--calcite-card-selection-background-color-active)}/*!@:host(:not([selectable])) .content-wrapper:not(.non-interactive):focus .checkbox-wrapper*/.sc-calcite-card-h:not([selectable]) .content-wrapper.sc-calcite-card:not(.non-interactive):focus .checkbox-wrapper.sc-calcite-card{background-color:var(--calcite-card-selection-background-color-hover);--calcite-ui-icon-color:var(--calcite-card-selection-icon-color-hover)}/*!@:host([selected]:not([selectable])) .content-wrapper:not(.non-interactive):focus .checkbox-wrapper*/[selected].sc-calcite-card-h:not([selectable]) .content-wrapper.sc-calcite-card:not(.non-interactive):focus .checkbox-wrapper.sc-calcite-card{background-color:var(--calcite-card-selection-background-color-active);--calcite-ui-icon-color:var(--calcite-card-selection-icon-color-selected)}/*!@.thumbnail-wrapper*/.thumbnail-wrapper.sc-calcite-card{display:flex}/*!@.content-wrapper.inline*/.content-wrapper.inline.sc-calcite-card{flex-direction:row}/*!@.content-wrapper.inline > .container*/.content-wrapper.inline.sc-calcite-card>.container.sc-calcite-card{inline-size:60%}/*!@.content-wrapper.inline > .thumbnail-wrapper*/.content-wrapper.inline.sc-calcite-card>.thumbnail-wrapper.sc-calcite-card{inline-size:40%;align-items:flex-start}/*!@.content-wrapper.inline slot[name=thumbnail]::slotted(img),\n.content-wrapper.inline img::slotted([slot=thumbnail])*/.content-wrapper.inline slot[name=thumbnail].sc-calcite-card-s>img,.content-wrapper.inline img.sc-calcite-card-s>[slot=thumbnail]{inline-size:100%}/*!@slot[name=footer-start]::slotted(*),\nslot[name=footer-end]::slotted(*)*/slot[name=footer-start].sc-calcite-card-s>*,slot[name=footer-end].sc-calcite-card-s>*{display:flex;gap:0.25rem}/*!@:host([hidden])*/[hidden].sc-calcite-card-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-card{display:none}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-card-h[disabled] .sc-calcite-card-s>[calcite-hydrated][disabled],[disabled].sc-calcite-card-h [calcite-hydrated][disabled].sc-calcite-card{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-card{display:contents}";

/**
 * @slot - A slot for adding content.
 * @slot title - [Deprecated] use `heading` instead. A slot for adding a heading.
 * @slot subtitle - [Deprecated] use `description` instead. A slot for adding a description.
 * @slot thumbnail - A slot for adding a thumbnail.
 * @slot heading - A slot for adding a heading.
 * @slot description - A slot for adding a description.
 * @slot footer-start - A slot for adding a leading footer.
 * @slot footer-end - A slot for adding a trailing footer.
 */
class Card {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteCardSelect = createEvent(this, "calciteCardSelect", 6);
        this.calciteInternalCardKeyEvent = createEvent(this, "calciteInternalCardKeyEvent", 6);
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.handleDefaultSlotChange = (event) => {
            this.hasContent = slotChangeHasAssignedElement(event);
        };
        this.keyDownHandler = (event) => {
            if (event.target === this.containerEl && !this.selectable && !this.disabled) {
                if (isActivationKey(event.key) && this.selectionMode !== "none") {
                    this.calciteCardSelect.emit();
                    event.preventDefault();
                }
                else {
                    switch (event.key) {
                        case "ArrowRight":
                        case "ArrowLeft":
                        case "Home":
                        case "End":
                            this.calciteInternalCardKeyEvent.emit(event);
                            event.preventDefault();
                            break;
                    }
                }
            }
        };
        this.cardBodyClickHandler = (event) => {
            const isFromScreenReader = event.target === this.containerEl;
            if (isFromScreenReader && !this.selectable && !this.disabled && this.selectionMode !== "none") {
                this.calciteCardSelect.emit();
            }
        };
        this.cardSelectKeyDownDeprecated = (event) => {
            switch (event.key) {
                case " ":
                case "Enter":
                    this.selectCardDeprecated();
                    event.preventDefault();
                    break;
            }
        };
        this.selectCardDeprecated = () => {
            this.selected = !this.selected;
            this.calciteCardSelect.emit();
        };
        this.cardSelectClick = (event) => {
            if (!this.disabled) {
                event.preventDefault();
                this.calciteCardSelect.emit();
                this.setFocus();
            }
        };
        this.loading = false;
        this.thumbnailPosition = "block-start";
        this.disabled = false;
        this.label = undefined;
        this.selectable = false;
        this.selected = false;
        this.messages = undefined;
        this.selectionMode = "none";
        this.messageOverrides = undefined;
        this.effectiveLocale = undefined;
        this.defaultMessages = undefined;
        this.hasContent = false;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        if (!this.disabled) {
            this.containerEl?.focus();
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    renderCheckboxDeprecated() {
        return (hAsync("calcite-label", { class: CSS$19.checkboxWrapperDeprecated }, hAsync("calcite-checkbox", { checked: this.selected, label: this.messages.select, onClick: this.selectCardDeprecated, onKeyDown: this.cardSelectKeyDownDeprecated })));
    }
    renderThumbnail() {
        return getSlotted(this.el, SLOTS$q.thumbnail) ? (hAsync("section", { class: CSS$19.thumbnailWrapper }, hAsync("slot", { name: SLOTS$q.thumbnail }))) : null;
    }
    renderSelectionIcon() {
        const icon = this.selectionMode === "multiple" && this.selected
            ? ICONS$f.selected
            : this.selectionMode === "multiple"
                ? ICONS$f.unselected
                : this.selected
                    ? ICONS$f.selectedSingle
                    : ICONS$f.unselectedSingle;
        return (hAsync("div", { class: CSS$19.checkboxWrapper, onPointerDown: this.cardSelectClick, tabIndex: -1 }, hAsync("calcite-icon", { icon: icon, scale: "s" })));
    }
    renderHeader() {
        const { el } = this;
        const heading = getSlotted(el, SLOTS$q.heading);
        const description = getSlotted(el, SLOTS$q.description);
        const hasHeader = heading || description;
        const subtitle = getSlotted(el, SLOTS$q.subtitle);
        const title = getSlotted(el, SLOTS$q.title);
        const hasDeprecatedHeader = subtitle || title;
        return hasHeader || hasDeprecatedHeader ? (hAsync("header", { class: CSS$19.header }, this.selectable ? this.renderCheckboxDeprecated() : null, hAsync("div", { class: CSS$19.headerTextContainer }, hAsync("slot", { key: "heading-slot", name: SLOTS$q.heading }), hAsync("slot", { key: "description-slot", name: SLOTS$q.description }), hAsync("slot", { key: "deprecated-title-slot", name: SLOTS$q.title }), hAsync("slot", { key: "deprecated-subtitle-slot", name: SLOTS$q.subtitle })), this.selectionMode !== "none" && this.renderSelectionIcon())) : null;
    }
    renderFooter() {
        const { el } = this;
        const startFooter = getSlotted(el, SLOTS$q.footerStart);
        const endFooter = getSlotted(el, SLOTS$q.footerEnd);
        const hasFooter = startFooter || endFooter;
        return hasFooter ? (hAsync("footer", { class: CSS$19.footer }, hAsync("slot", { name: SLOTS$q.footerStart }), hAsync("slot", { name: SLOTS$q.footerEnd }))) : null;
    }
    render() {
        const thumbnailInline = this.thumbnailPosition.startsWith("inline");
        const thumbnailStart = this.thumbnailPosition.endsWith("start");
        const role = this.selectionMode === "multiple"
            ? "checkbox"
            : this.selectionMode !== "none"
                ? "radio"
                : undefined;
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { "aria-checked": this.selectionMode !== "none" ? toAriaBoolean(this.selected) : undefined, "aria-disabled": this.disabled, "aria-label": this.label, class: { [CSS$19.contentWrapper]: true, inline: thumbnailInline }, onClick: this.cardBodyClickHandler, onKeyDown: this.keyDownHandler, role: role, tabIndex: !this.selectable || this.disabled ? 0 : -1,
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.containerEl = el) }, this.loading ? (hAsync("div", { "aria-live": "polite", class: "calcite-card-loader-container" }, hAsync("calcite-loader", { label: this.messages.loading }))) : null, thumbnailStart && this.renderThumbnail(), hAsync("section", { "aria-busy": toAriaBoolean(this.loading), class: { [CSS$19.container]: true } }, this.renderHeader(), hAsync("div", { class: {
                [CSS$19.cardContent]: true,
                [CSS$19.hasSlottedContent]: this.hasContent,
            } }, hAsync("slot", { onSlotchange: this.handleDefaultSlotChange })), this.renderFooter()), !thumbnailStart && this.renderThumbnail()))));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return cardCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-card",
        "$members$": {
            "loading": [516],
            "thumbnailPosition": [513, "thumbnail-position"],
            "disabled": [516],
            "label": [1],
            "selectable": [516],
            "selected": [1540],
            "messages": [1040],
            "selectionMode": [1, "selection-mode"],
            "messageOverrides": [1040],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "hasContent": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["loading", "loading"], ["thumbnailPosition", "thumbnail-position"], ["disabled", "disabled"], ["selectable", "selectable"], ["selected", "selected"]]
    }; }
}

const cardGroupCss = "/*!@:host([disabled])*/[disabled].sc-calcite-card-group-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-card-group-h *.sc-calcite-card-group,.sc-calcite-card-group-h[disabled].sc-calcite-card-group-s>*,.sc-calcite-card-group-h[disabled] .sc-calcite-card-group-s>*{pointer-events:none}/*!@:host*/.sc-calcite-card-group-h{--calcite-card-group-gap:var(--calcite-size-md);display:block}/*!@.container*/.container.sc-calcite-card-group{display:flex;flex-wrap:wrap;gap:var(--calcite-card-group-gap)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-card-group-h[disabled] .sc-calcite-card-group-s>[calcite-hydrated][disabled],[disabled].sc-calcite-card-group-h [calcite-hydrated][disabled].sc-calcite-card-group{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-card-group{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-card-group-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-card-group{display:none}";

/**
 * @slot - A slot for adding one or more `calcite-card`s.
 */
class CardGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteCardGroupSelect = createEvent(this, "calciteCardGroupSelect", 6);
        //--------------------------------------------------------------------------
        //
        //  Private Properties
        //
        //--------------------------------------------------------------------------
        this.items = [];
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.udpateItemsOnSelectionModeChange = () => {
            this.updateSlottedItems(this.slotRefEl);
            this.updateSelectedItems();
        };
        this.updateItemsOnSlotChange = (event) => {
            this.updateSlottedItems(event.target);
            this.updateSelectedItems();
        };
        this.updateSlottedItems = (target) => {
            this.items = target
                .assignedElements({ flatten: true })
                .filter((el) => el?.matches("calcite-card"));
        };
        this.updateSelectedItems = () => {
            this.items.forEach((el) => {
                el.selectionMode = this.selectionMode;
            });
            this.setSelectedItems(false);
        };
        this.setSelectedItems = (emit, elToMatch) => {
            if (elToMatch) {
                this.items.forEach((el) => {
                    const matchingEl = elToMatch === el;
                    switch (this.selectionMode) {
                        case "multiple":
                            if (matchingEl) {
                                el.selected = !el.selected;
                            }
                            break;
                        case "single":
                            el.selected = matchingEl ? !el.selected : false;
                            break;
                        case "single-persist":
                            el.selected = !!matchingEl;
                            break;
                    }
                });
            }
            this.selectedItems = this.items.filter((el) => el.selected);
            if (emit && this.selectionMode !== "none" && !this.disabled) {
                this.calciteCardGroupSelect.emit();
            }
        };
        this.disabled = false;
        this.label = undefined;
        this.scale = "m";
        this.selectionMode = "none";
        this.selectedItems = [];
    }
    onSelectionModeChange() {
        this.udpateItemsOnSelectionModeChange();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    calciteInternalCardKeyEventListener(event) {
        if (event.composedPath().includes(this.el)) {
            const interactiveItems = this.items.filter((el) => !el.disabled);
            switch (event.detail["key"]) {
                case "ArrowRight":
                    focusElementInGroup(interactiveItems, event.target, "next");
                    break;
                case "ArrowLeft":
                    focusElementInGroup(interactiveItems, event.target, "previous");
                    break;
                case "Home":
                    focusElementInGroup(interactiveItems, event.target, "first");
                    break;
                case "End":
                    focusElementInGroup(interactiveItems, event.target, "last");
                    break;
            }
        }
    }
    calciteCardSelectListener(event) {
        if (event.composedPath().includes(this.el) &&
            !event.target.selectable) {
            this.setSelectedItems(true, event.target);
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Sets focus on the component's first focusable element.
     */
    async setFocus() {
        await componentLoaded(this);
        if (!this.disabled) {
            focusElement(this.items[0]);
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const role = this.selectionMode === "none" || this.selectionMode === "multiple" ? "group" : "radiogroup";
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { "aria-disabled": toAriaBoolean(this.disabled), "aria-label": this.label, class: "container", role: role }, hAsync("slot", { onSlotchange: this.updateItemsOnSlotChange, ref: (el) => (this.slotRefEl = el) })))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "selectionMode": ["onSelectionModeChange"]
    }; }
    static get style() { return cardGroupCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-card-group",
        "$members$": {
            "disabled": [516],
            "label": [1],
            "scale": [513],
            "selectionMode": [513, "selection-mode"],
            "selectedItems": [1040],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteInternalCardKeyEvent", "calciteInternalCardKeyEventListener"], [0, "calciteCardSelect", "calciteCardSelectListener"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["scale", "scale"], ["selectionMode", "selection-mode"]]
    }; }
}

const checkboxCss = "/*!@:host([disabled])*/[disabled].sc-calcite-checkbox-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-checkbox-h *.sc-calcite-checkbox,.sc-calcite-checkbox-h[disabled].sc-calcite-checkbox-s>*,.sc-calcite-checkbox-h[disabled] .sc-calcite-checkbox-s>*{pointer-events:none}/*!@:host([scale=s])*/[scale=s].sc-calcite-checkbox-h{--calcite-checkbox-size:0.75rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-checkbox-h{--calcite-checkbox-size:var(--calcite-font-size--1)}/*!@:host([scale=l])*/[scale=l].sc-calcite-checkbox-h{--calcite-checkbox-size:1rem}/*!@:host*/.sc-calcite-checkbox-h{position:relative;display:inline-flex;cursor:pointer;-webkit-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}/*!@:host .check-svg,\n:host .toggle*/.sc-calcite-checkbox-h .check-svg.sc-calcite-checkbox,.sc-calcite-checkbox-h .toggle.sc-calcite-checkbox{inline-size:var(--calcite-checkbox-size);block-size:var(--calcite-checkbox-size)}/*!@:host .check-svg*/.sc-calcite-checkbox-h .check-svg.sc-calcite-checkbox{pointer-events:none;box-sizing:border-box;display:block;overflow:hidden;background-color:var(--calcite-color-foreground-1);fill:currentColor;stroke:currentColor;stroke-width:1;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;box-shadow:inset 0 0 0 1px var(--calcite-color-border-input);color:var(--calcite-color-background)}/*!@:host([status=invalid]:not([checked])) .check-svg*/[status=invalid].sc-calcite-checkbox-h:not([checked]) .check-svg.sc-calcite-checkbox{box-shadow:inset 0 0 0 1px var(--calcite-color-status-danger)}/*!@:host([status=invalid]:not([checked])) .toggle:focus*/[status=invalid].sc-calcite-checkbox-h:not([checked]) .toggle.sc-calcite-checkbox:focus{outline:2px solid var(--calcite-color-status-danger);outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([checked]) .check-svg,\n:host([indeterminate]) .check-svg*/[checked].sc-calcite-checkbox-h .check-svg.sc-calcite-checkbox,[indeterminate].sc-calcite-checkbox-h .check-svg.sc-calcite-checkbox{background-color:var(--calcite-color-brand);box-shadow:inset 0 0 0 1px var(--calcite-color-brand)}/*!@:host([hovered]) .toggle .check-svg,\n:host .toggle:hover .check-svg*/[hovered].sc-calcite-checkbox-h .toggle.sc-calcite-checkbox .check-svg.sc-calcite-checkbox,.sc-calcite-checkbox-h .toggle.sc-calcite-checkbox:hover .check-svg.sc-calcite-checkbox{box-shadow:inset 0 0 0 2px var(--calcite-color-brand)}/*!@.toggle*/.toggle.sc-calcite-checkbox{position:relative;outline-color:transparent}/*!@.toggle:active, .toggle:focus, .toggle:focus-visible*/.toggle.sc-calcite-checkbox:active,.toggle.sc-calcite-checkbox:focus,.toggle.sc-calcite-checkbox:focus-visible{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.toggle::after*/.toggle.sc-calcite-checkbox::after{content:\"\";inset-block-start:50%;inset-inline-start:50%;min-block-size:1.5rem;min-inline-size:1.5rem;position:absolute;transform:translateX(-50%) translateY(-50%)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-checkbox-h[disabled] .sc-calcite-checkbox-s>[calcite-hydrated][disabled],[disabled].sc-calcite-checkbox-h [calcite-hydrated][disabled].sc-calcite-checkbox{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-checkbox{display:contents}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-checkbox-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([hidden])*/[hidden].sc-calcite-checkbox-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-checkbox{display:none}";

class Checkbox {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalCheckboxBlur = createEvent(this, "calciteInternalCheckboxBlur", 6);
        this.calciteCheckboxChange = createEvent(this, "calciteCheckboxChange", 6);
        this.calciteInternalCheckboxFocus = createEvent(this, "calciteInternalCheckboxFocus", 6);
        this.checkedPath = "M5.5 12L2 8.689l.637-.636L5.5 10.727l8.022-7.87.637.637z";
        this.indeterminatePath = "M13 8v1H3V8z";
        this.getPath = () => this.indeterminate ? this.indeterminatePath : this.checked ? this.checkedPath : "";
        this.toggle = () => {
            if (!this.disabled) {
                this.checked = !this.checked;
                this.setFocus();
                this.indeterminate = false;
                this.calciteCheckboxChange.emit();
            }
        };
        this.keyDownHandler = (event) => {
            if (isActivationKey(event.key)) {
                this.toggle();
                event.preventDefault();
            }
        };
        this.clickHandler = () => {
            if (this.disabled) {
                return;
            }
            this.toggle();
        };
        //--------------------------------------------------------------------------
        //
        //  Event Listeners
        //
        //--------------------------------------------------------------------------
        this.onToggleBlur = () => {
            this.calciteInternalCheckboxBlur.emit(false);
        };
        this.onToggleFocus = () => {
            this.calciteInternalCheckboxFocus.emit(true);
        };
        this.onLabelClick = () => {
            this.toggle();
        };
        this.checked = false;
        this.disabled = false;
        this.form = undefined;
        this.guid = undefined;
        this.hovered = false;
        this.indeterminate = false;
        this.label = undefined;
        this.name = undefined;
        this.required = false;
        this.scale = "m";
        this.status = "idle";
        this.value = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.toggleEl?.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    syncHiddenFormInput(input) {
        input.type = "checkbox";
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.guid = this.el.id || `calcite-checkbox-${guid()}`;
        connectInteractive(this);
        connectLabel(this);
        connectForm(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        return (hAsync(Host, { onClick: this.clickHandler, onKeyDown: this.keyDownHandler }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { "aria-checked": toAriaBoolean(this.checked), "aria-label": getLabelText(this), class: "toggle", onBlur: this.onToggleBlur, onFocus: this.onToggleFocus, role: "checkbox", tabIndex: this.disabled ? undefined : 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (toggleEl) => (this.toggleEl = toggleEl) }, hAsync("svg", { "aria-hidden": "true", class: "check-svg", viewBox: "0 0 16 16" }, hAsync("path", { d: this.getPath() })), hAsync("slot", null)), hAsync(HiddenFormInputSlot, { component: this }))));
    }
    get el() { return getElement(this); }
    static get style() { return checkboxCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-checkbox",
        "$members$": {
            "checked": [1540],
            "disabled": [516],
            "form": [513],
            "guid": [1537],
            "hovered": [516],
            "indeterminate": [1540],
            "label": [1],
            "name": [513],
            "required": [516],
            "scale": [513],
            "status": [513],
            "value": [8],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["checked", "checked"], ["disabled", "disabled"], ["form", "form"], ["guid", "guid"], ["hovered", "hovered"], ["indeterminate", "indeterminate"], ["name", "name"], ["required", "required"], ["scale", "scale"], ["status", "status"]]
    }; }
}

const CSS$18 = {
    title: "title",
    close: "close",
    imageContainer: "image-container",
    chipIcon: "chip-icon",
    textSlotted: "text--slotted",
    container: "container",
    imageSlotted: "image--slotted",
    closable: "closable",
    multiple: "multiple",
    selectable: "selectable",
    selectIcon: "select-icon",
    selectIconActive: "select-icon--active",
    nonInteractive: "non-interactive",
    isCircle: "is-circle",
};
const SLOTS$p = {
    image: "image",
};
const ICONS$e = {
    close: "x",
    unchecked: "circle",
    checkedSingle: "circle-f",
    checked: "check-circle-f",
};

const chipCss = "/*!@:host([disabled])*/[disabled].sc-calcite-chip-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-chip-h *.sc-calcite-chip,.sc-calcite-chip-h[disabled].sc-calcite-chip-s>*,.sc-calcite-chip-h[disabled] .sc-calcite-chip-s>*{pointer-events:none}/*!@:host([scale=s])*/[scale=s].sc-calcite-chip-h{block-size:1.5rem;font-size:var(--calcite-font-size--2);--calcite-chip-spacing-s-internal:0.25rem;--calcite-chip-spacing-l-internal:0.5rem}/*!@:host([scale=s]) .close,\n:host([scale=s]) .select-icon--active*/[scale=s].sc-calcite-chip-h .close.sc-calcite-chip,[scale=s].sc-calcite-chip-h .select-icon--active.sc-calcite-chip{block-size:1rem;inline-size:1rem}/*!@:host([scale=s]) .image-container*/[scale=s].sc-calcite-chip-h .image-container.sc-calcite-chip{block-size:1.25rem;inline-size:1.25rem}/*!@:host([scale=s]) .container.is-circle*/[scale=s].sc-calcite-chip-h .container.is-circle.sc-calcite-chip{block-size:1.5rem;inline-size:1.5rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-chip-h{block-size:2rem;font-size:var(--calcite-font-size--1);--calcite-chip-spacing-s-internal:0.375rem;--calcite-chip-spacing-l-internal:0.5rem}/*!@:host([scale=m]) .close,\n:host([scale=m]) .image-container,\n:host([scale=m]) .select-icon--active*/[scale=m].sc-calcite-chip-h .close.sc-calcite-chip,[scale=m].sc-calcite-chip-h .image-container.sc-calcite-chip,[scale=m].sc-calcite-chip-h .select-icon--active.sc-calcite-chip{block-size:1.5rem;inline-size:1.5rem}/*!@:host([scale=m]) .container.is-circle*/[scale=m].sc-calcite-chip-h .container.is-circle.sc-calcite-chip{block-size:2rem;inline-size:2rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-chip-h{block-size:2.75rem;font-size:var(--calcite-font-size-0);--calcite-chip-spacing-s-internal:0.5rem;--calcite-chip-spacing-l-internal:0.75rem}/*!@:host([scale=l]) .image-container,\n:host([scale=l]) .close,\n:host([scale=l]) .select-icon--active*/[scale=l].sc-calcite-chip-h .image-container.sc-calcite-chip,[scale=l].sc-calcite-chip-h .close.sc-calcite-chip,[scale=l].sc-calcite-chip-h .select-icon--active.sc-calcite-chip{block-size:2rem;inline-size:2rem}/*!@:host([scale=l]) .container.is-circle*/[scale=l].sc-calcite-chip-h .container.is-circle.sc-calcite-chip{block-size:2.75rem;inline-size:2.75rem}/*!@:host*/.sc-calcite-chip-h{display:inline-flex;cursor:default;border-radius:9999px}/*!@.container*/.container.sc-calcite-chip{box-sizing:border-box;display:inline-flex;block-size:100%;max-inline-size:100%;align-items:center;justify-content:center;border-radius:9999px;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-1);font-weight:var(--calcite-font-weight-medium);outline-color:transparent}/*!@.container:not(.is-circle)*/.container.sc-calcite-chip:not(.is-circle){padding-inline:var(--calcite-chip-spacing-s-internal)}/*!@.container.selectable*/.container.selectable.sc-calcite-chip{cursor:pointer}/*!@.container:not(.non-interactive):focus*/.container.sc-calcite-chip:not(.non-interactive):focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([scale=s]) .container.image--slotted*/[scale=s].sc-calcite-chip-h .container.image--slotted.sc-calcite-chip{padding-inline-start:calc(0.125rem / 2)}/*!@:host([scale=s]) .container.is-circle*/[scale=s].sc-calcite-chip-h .container.is-circle.sc-calcite-chip{padding-inline:0}/*!@.container.text--slotted .title*/.container.text--slotted.sc-calcite-chip .title.sc-calcite-chip{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-inline:var(--calcite-chip-spacing-s-internal)}/*!@.container:not(.text--slotted) .title*/.container.sc-calcite-chip:not(.text--slotted) .title.sc-calcite-chip{display:none}/*!@.container:not(.image--slotted) .image-container*/.container.sc-calcite-chip:not(.image--slotted) .image-container.sc-calcite-chip{display:none}/*!@.container.closable*/.container.closable.sc-calcite-chip{padding-inline-end:calc(var(--calcite-chip-spacing-l-internal) / 2)}/*!@.container:not(.is-circle).image--slotted*/.container.sc-calcite-chip:not(.is-circle).image--slotted{padding-inline-start:calc(var(--calcite-chip-spacing-l-internal) / 2)}/*!@.container:not(.is-circle).image--slotted .image-container*/.container.sc-calcite-chip:not(.is-circle).image--slotted .image-container.sc-calcite-chip{margin-inline-end:var(--calcite-chip-spacing-s-internal)}/*!@.container:not(.is-circle).image--slotted .image-container ~ .chip-icon*/.container.sc-calcite-chip:not(.is-circle).image--slotted .image-container.sc-calcite-chip~.chip-icon.sc-calcite-chip{margin-inline-start:var(--calcite-chip-spacing-s-internal)}/*!@.container:not(.is-circle).selectable:not(.text--slotted) .chip-icon*/.container.sc-calcite-chip:not(.is-circle).selectable:not(.text--slotted) .chip-icon.sc-calcite-chip{margin-inline-end:var(--calcite-chip-spacing-s-internal)}/*!@.container:not(.is-circle):not(.selectable):not(.text--slotted) .chip-icon*/.container.sc-calcite-chip:not(.is-circle):not(.selectable):not(.text--slotted) .chip-icon.sc-calcite-chip{margin-inline-start:var(--calcite-chip-spacing-s-internal)}/*!@.container:not(.is-circle):not(.text--slotted) .chip-icon*/.container.sc-calcite-chip:not(.is-circle):not(.text--slotted) .chip-icon.sc-calcite-chip{margin-inline-end:var(--calcite-chip-spacing-s-internal)}/*!@.container:not(.is-circle):not(.text-slotted).image--slotted .image-container*/.container.sc-calcite-chip:not(.is-circle):not(.text-slotted).image--slotted .image-container.sc-calcite-chip{margin-inline-end:var(--calcite-chip-spacing-s-internal)}/*!@.container:not(.is-circle):not(.closable):not(.text--slotted).image--slotted.selectable .image-container*/.container.sc-calcite-chip:not(.is-circle):not(.closable):not(.text--slotted).image--slotted.selectable .image-container.sc-calcite-chip{margin-inline-end:0}/*!@.container:not(.is-circle):not(.closable):not(.text--slotted).image--slotted.selectable .image-container ~ .chip-icon*/.container.sc-calcite-chip:not(.is-circle):not(.closable):not(.text--slotted).image--slotted.selectable .image-container.sc-calcite-chip~.chip-icon.sc-calcite-chip{margin-inline-start:calc(var(--calcite-chip-spacing-s-internal) * 2)}/*!@.chip-icon*/.chip-icon.sc-calcite-chip{position:relative;margin-block:0px;display:inline-flex;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);margin-inline:var(--calcite-chip-spacing-s-internal)}/*!@.image-container*/.image-container.sc-calcite-chip{display:inline-flex;overflow:hidden;align-items:center;justify-content:center;pointer-events:none}/*!@.close*/.close.sc-calcite-chip{margin:0px;cursor:pointer;align-items:center;border-style:none;background-color:transparent;color:var(--calcite-color-text-1);outline-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;-webkit-appearance:none;display:flex;border-radius:50%;align-content:center;justify-content:center;--calcite-chip-transparent-hover:var(--calcite-color-transparent-hover);--calcite-chip-transparent-press:var(--calcite-color-transparent-press)}/*!@.close:hover*/.close.sc-calcite-chip:hover{background-color:var(--calcite-chip-transparent-hover)}/*!@.close:focus*/.close.sc-calcite-chip:focus{background-color:var(--calcite-chip-transparent-hover);outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.close:active*/.close.sc-calcite-chip:active{background-color:var(--calcite-chip-transparent-press)}/*!@.close calcite-icon*/.close.sc-calcite-chip calcite-icon.sc-calcite-chip{color:inherit}/*!@.select-icon*/.select-icon.sc-calcite-chip{align-self:center;justify-content:center;align-items:center;display:flex;inset-block-start:-1px;position:relative;visibility:hidden;inline-size:0;opacity:0;transition:opacity 0.15s ease-in-out, inline-size 0.15s ease-in-out}/*!@.select-icon.select-icon--active*/.select-icon.select-icon--active.sc-calcite-chip{visibility:visible;opacity:0.5}/*!@.container:not(.is-circle).image--slotted .select-icon.select-icon--active*/.container.sc-calcite-chip:not(.is-circle).image--slotted .select-icon.select-icon--active.sc-calcite-chip{margin-inline-end:var(--calcite-chip-spacing-s-internal)}/*!@:host([selected]) .select-icon*/[selected].sc-calcite-chip-h .select-icon.sc-calcite-chip{opacity:1}/*!@.container:hover .select-icon--active*/.container.sc-calcite-chip:hover .select-icon--active.sc-calcite-chip{opacity:1}/*!@slot[name=image]::slotted(*)*/slot[name=image].sc-calcite-chip-s>*{display:flex;block-size:100%;inline-size:100%;overflow:hidden;border-radius:50%}/*!@:host([kind=neutral])*/[kind=neutral].sc-calcite-chip-h{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-text-1)}/*!@:host([kind=neutral]) .container*/[kind=neutral].sc-calcite-chip-h .container.sc-calcite-chip{border-color:transparent}/*!@:host([kind=neutral]) .close*/[kind=neutral].sc-calcite-chip-h .close.sc-calcite-chip{color:var(--calcite-color-text-3)}/*!@:host([kind=neutral]) .chip-icon*/[kind=neutral].sc-calcite-chip-h .chip-icon.sc-calcite-chip{color:var(--calcite-ui-icon-color, var(--calcite-color-text-3))}/*!@:host([kind=inverse])*/[kind=inverse].sc-calcite-chip-h{background-color:var(--calcite-color-inverse);color:var(--calcite-color-text-inverse)}/*!@:host([kind=inverse]) .container*/[kind=inverse].sc-calcite-chip-h .container.sc-calcite-chip{border-color:transparent}/*!@:host([kind=inverse]) .close*/[kind=inverse].sc-calcite-chip-h .close.sc-calcite-chip{color:var(--calcite-color-text-inverse)}/*!@:host([kind=inverse]) .chip-icon*/[kind=inverse].sc-calcite-chip-h .chip-icon.sc-calcite-chip{color:var(--calcite-ui-icon-color, var(--calcite-color-text-inverse))}/*!@:host([kind=brand])*/[kind=brand].sc-calcite-chip-h{background-color:var(--calcite-color-brand);color:var(--calcite-color-text-inverse)}/*!@:host([kind=brand]) .container*/[kind=brand].sc-calcite-chip-h .container.sc-calcite-chip{border-color:transparent}/*!@:host([kind=brand]) .close*/[kind=brand].sc-calcite-chip-h .close.sc-calcite-chip{color:var(--calcite-color-text-inverse)}/*!@:host([kind=brand]) .chip-icon*/[kind=brand].sc-calcite-chip-h .chip-icon.sc-calcite-chip{color:var(--calcite-ui-icon-color, var(--calcite-color-text-inverse))}/*!@:host([appearance=outline-fill]),\n:host([appearance=outline])*/[appearance=outline-fill].sc-calcite-chip-h,[appearance=outline].sc-calcite-chip-h{background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-1)}/*!@:host([appearance=outline-fill]) .close,\n:host([appearance=outline]) .close*/[appearance=outline-fill].sc-calcite-chip-h .close.sc-calcite-chip,[appearance=outline].sc-calcite-chip-h .close.sc-calcite-chip{color:var(--calcite-color-text-3)}/*!@:host([appearance=outline-fill]) .chip-icon,\n:host([appearance=outline]) .chip-icon*/[appearance=outline-fill].sc-calcite-chip-h .chip-icon.sc-calcite-chip,[appearance=outline].sc-calcite-chip-h .chip-icon.sc-calcite-chip{color:var(--calcite-ui-icon-color, var(--calcite-color-text-3))}/*!@:host([appearance=outline-fill])*/[appearance=outline-fill].sc-calcite-chip-h{background-color:var(--calcite-color-foreground-1)}/*!@:host([appearance=outline])*/[appearance=outline].sc-calcite-chip-h{background-color:transparent}/*!@:host([kind=neutral][appearance=outline-fill]) .container,\n:host([kind=neutral][appearance=outline]) .container*/[kind=neutral][appearance=outline-fill].sc-calcite-chip-h .container.sc-calcite-chip,[kind=neutral][appearance=outline].sc-calcite-chip-h .container.sc-calcite-chip{border-color:var(--calcite-color-border-1)}/*!@:host([kind=inverse][appearance=outline-fill]) .container,\n:host([kind=inverse][appearance=outline]) .container*/[kind=inverse][appearance=outline-fill].sc-calcite-chip-h .container.sc-calcite-chip,[kind=inverse][appearance=outline].sc-calcite-chip-h .container.sc-calcite-chip{border-color:var(--calcite-color-border-inverse)}/*!@:host([kind=brand][appearance=outline-fill]) .container,\n:host([kind=brand][appearance=outline]) .container*/[kind=brand][appearance=outline-fill].sc-calcite-chip-h .container.sc-calcite-chip,[kind=brand][appearance=outline].sc-calcite-chip-h .container.sc-calcite-chip{border-color:var(--calcite-color-brand)}/*!@:host([kind=brand][appearance=solid]) button,\n:host([kind=inverse][appearance=solid]) button*/[kind=brand][appearance=solid].sc-calcite-chip-h button.sc-calcite-chip,[kind=inverse][appearance=solid].sc-calcite-chip-h button.sc-calcite-chip{outline-color:var(--calcite-color-text-inverse)}/*!@:host([closed])*/[closed].sc-calcite-chip-h{display:none}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-chip-h[disabled] .sc-calcite-chip-s>[calcite-hydrated][disabled],[disabled].sc-calcite-chip-h [calcite-hydrated][disabled].sc-calcite-chip{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-chip{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-chip-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-chip{display:none}";

/**
 * @slot - A slot for adding text.
 * @slot image - A slot for adding an image.
 */
class Chip {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteChipClose = createEvent(this, "calciteChipClose", 6);
        this.calciteChipSelect = createEvent(this, "calciteChipSelect", 6);
        this.calciteInternalChipKeyEvent = createEvent(this, "calciteInternalChipKeyEvent", 6);
        this.mutationObserver = createObserver();
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.close = () => {
            this.calciteChipClose.emit();
            this.selected = false;
            this.closed = true;
        };
        this.closeButtonKeyDownHandler = (event) => {
            if (isActivationKey(event.key)) {
                event.preventDefault();
                this.close();
            }
        };
        this.handleSlotImageChange = (event) => {
            this.hasImage = slotChangeHasAssignedElement(event);
        };
        this.handleEmittingEvent = () => {
            if (this.interactive) {
                this.calciteChipSelect.emit();
            }
        };
        this.disabled = false;
        this.appearance = "solid";
        this.kind = "neutral";
        this.closable = false;
        this.icon = undefined;
        this.iconFlipRtl = false;
        this.scale = "m";
        this.label = undefined;
        this.value = undefined;
        this.closed = false;
        this.selectionMode = "none";
        this.selected = false;
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.interactive = false;
        this.defaultMessages = undefined;
        this.effectiveLocale = undefined;
        this.hasText = false;
        this.hasImage = false;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectConditionalSlotComponent(this);
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectConditionalSlotComponent(this);
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        this.mutationObserver?.disconnect();
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    keyDownHandler(event) {
        if (event.target === this.el) {
            switch (event.key) {
                case " ":
                case "Enter":
                    this.handleEmittingEvent();
                    event.preventDefault();
                    break;
                case "ArrowRight":
                case "ArrowLeft":
                case "Home":
                case "End":
                    this.calciteInternalChipKeyEvent.emit(event);
                    event.preventDefault();
                    break;
            }
        }
    }
    clickHandler() {
        if (!this.interactive && this.closable) {
            this.closeButtonEl.focus();
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        if (!this.disabled && this.interactive) {
            this.containerEl?.focus();
        }
        else if (!this.disabled && this.closable) {
            this.closeButtonEl?.focus();
        }
    }
    updateHasText() {
        this.hasText = this.el.textContent.trim().length > 0;
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    renderChipImage() {
        return (hAsync("div", { class: CSS$18.imageContainer }, hAsync("slot", { name: SLOTS$p.image, onSlotchange: this.handleSlotImageChange })));
    }
    renderSelectionIcon() {
        const icon = this.selectionMode === "multiple" && this.selected
            ? ICONS$e.checked
            : this.selectionMode === "multiple"
                ? ICONS$e.unchecked
                : this.selected
                    ? ICONS$e.checkedSingle
                    : undefined;
        return (hAsync("div", { class: {
                [CSS$18.selectIcon]: true,
                [CSS$18.selectIconActive]: this.selectionMode === "multiple" || this.selected,
            } }, icon ? hAsync("calcite-icon", { icon: icon, scale: getIconScale(this.scale) }) : null));
    }
    renderCloseButton() {
        return (hAsync("button", { "aria-label": this.messages.dismissLabel, class: CSS$18.close, onClick: this.close, onKeyDown: this.closeButtonKeyDownHandler, tabIndex: this.disabled ? -1 : 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.closeButtonEl = el) }, hAsync("calcite-icon", { icon: ICONS$e.close, scale: getIconScale(this.scale) })));
    }
    renderIcon() {
        return (hAsync("calcite-icon", { class: CSS$18.chipIcon, flipRtl: this.iconFlipRtl, icon: this.icon, scale: getIconScale(this.scale) }));
    }
    render() {
        const { disabled } = this;
        const disableInteraction = disabled || (!disabled && !this.interactive);
        const role = this.selectionMode === "multiple" && this.interactive
            ? "checkbox"
            : this.selectionMode !== "none" && this.interactive
                ? "radio"
                : this.interactive
                    ? "button"
                    : undefined;
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: disabled }, hAsync("div", { "aria-checked": this.selectionMode !== "none" && this.interactive
                ? toAriaBoolean(this.selected)
                : undefined, "aria-disabled": disableInteraction ? toAriaBoolean(disabled) : undefined, "aria-label": this.label, class: {
                [CSS$18.container]: true,
                [CSS$18.textSlotted]: this.hasText,
                [CSS$18.imageSlotted]: this.hasImage,
                [CSS$18.selectable]: this.selectionMode !== "none",
                [CSS$18.multiple]: this.selectionMode === "multiple",
                [CSS$18.closable]: this.closable,
                [CSS$18.nonInteractive]: !this.interactive,
                [CSS$18.isCircle]: !this.closable &&
                    !this.hasText &&
                    (!this.icon || !this.hasImage) &&
                    (this.selectionMode === "none" ||
                        (!!this.selectionMode && this.selectionMode !== "multiple" && !this.selected)),
            }, onClick: this.handleEmittingEvent, role: role, tabIndex: disableInteraction ? -1 : 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.containerEl = el) }, this.selectionMode !== "none" && this.renderSelectionIcon(), this.renderChipImage(), this.icon && this.renderIcon(), hAsync("span", { class: CSS$18.title }, hAsync("slot", null)), this.closable && this.renderCloseButton()))));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return chipCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-chip",
        "$members$": {
            "disabled": [516],
            "appearance": [513],
            "kind": [513],
            "closable": [516],
            "icon": [513],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "scale": [513],
            "label": [1],
            "value": [8],
            "closed": [1540],
            "selectionMode": [1, "selection-mode"],
            "selected": [1540],
            "messageOverrides": [1040],
            "messages": [1040],
            "interactive": [4],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "hasText": [32],
            "hasImage": [32],
            "setFocus": [64]
        },
        "$listeners$": [[0, "keydown", "keyDownHandler"], [0, "click", "clickHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["appearance", "appearance"], ["kind", "kind"], ["closable", "closable"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["scale", "scale"], ["closed", "closed"], ["selected", "selected"]]
    }; }
}

const chipGroupCss = "/*!@:host([disabled])*/[disabled].sc-calcite-chip-group-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-chip-group-h *.sc-calcite-chip-group,.sc-calcite-chip-group-h[disabled].sc-calcite-chip-group-s>*,.sc-calcite-chip-group-h[disabled] .sc-calcite-chip-group-s>*{pointer-events:none}/*!@:host*/.sc-calcite-chip-group-h{display:flex}/*!@.container*/.container.sc-calcite-chip-group{display:flex;inline-size:100%;flex-wrap:wrap;gap:0.5rem}/*!@::slotted(calcite-chip)*/.sc-calcite-chip-group-s>calcite-chip{flex:none}/*!@:host([scale=s]) .container*/[scale=s].sc-calcite-chip-group-h .container.sc-calcite-chip-group{gap:0.25rem}/*!@:host([scale=l]) .container*/[scale=l].sc-calcite-chip-group-h .container.sc-calcite-chip-group{gap:0.75rem}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-chip-group-h[disabled] .sc-calcite-chip-group-s>[calcite-hydrated][disabled],[disabled].sc-calcite-chip-group-h [calcite-hydrated][disabled].sc-calcite-chip-group{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-chip-group{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-chip-group-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-chip-group{display:none}";

/**
 * @slot - A slot for adding one or more `calcite-chip`s.
 */
class ChipGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteChipGroupSelect = createEvent(this, "calciteChipGroupSelect", 6);
        this.mutationObserver = createObserver();
        this.items = [];
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.updateItems = (event) => {
            const target = event ? event.target : this.slotRefEl;
            this.items = target
                ?.assignedElements({ flatten: true })
                .filter((el) => el?.matches("calcite-chip"));
            this.items?.forEach((el) => {
                el.interactive = true;
                el.scale = this.scale;
                el.selectionMode = this.selectionMode;
            });
            this.setSelectedItems(false);
        };
        this.setSelectedItems = (emit, elToMatch) => {
            if (elToMatch) {
                this.items?.forEach((el) => {
                    const matchingEl = elToMatch === el;
                    switch (this.selectionMode) {
                        case "multiple":
                            if (matchingEl) {
                                el.selected = !el.selected;
                            }
                            break;
                        case "single":
                            el.selected = matchingEl ? !el.selected : false;
                            break;
                        case "single-persist":
                            el.selected = !!matchingEl;
                            break;
                    }
                });
            }
            this.selectedItems = this.items?.filter((el) => el.selected);
            if (emit) {
                this.calciteChipGroupSelect.emit();
            }
        };
        this.disabled = false;
        this.label = undefined;
        this.scale = "m";
        this.selectionMode = "none";
        this.selectedItems = [];
    }
    onSelectionModeChange() {
        this.updateItems();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
    }
    componentDidRender() {
        disconnectInteractive(this);
        updateHostInteraction(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    calciteInternalChipKeyEventListener(event) {
        if (event.composedPath().includes(this.el)) {
            const interactiveItems = this.items?.filter((el) => !el.disabled);
            switch (event.detail.key) {
                case "ArrowRight":
                    focusElementInGroup(interactiveItems, event.detail.target, "next");
                    break;
                case "ArrowLeft":
                    focusElementInGroup(interactiveItems, event.detail.target, "previous");
                    break;
                case "Home":
                    focusElementInGroup(interactiveItems, event.detail.target, "first");
                    break;
                case "End":
                    focusElementInGroup(interactiveItems, event.detail.target, "last");
                    break;
            }
        }
    }
    calciteChipCloseListener(event) {
        const item = event.target;
        if (this.items?.includes(item)) {
            if (this.items?.indexOf(item) > 0) {
                focusElementInGroup(this.items, item, "previous");
            }
            else if (this.items?.indexOf(item) === 0) {
                focusElementInGroup(this.items, item, "next");
            }
            else {
                focusElementInGroup(this.items, item, "first");
            }
        }
        this.items = this.items?.filter((el) => el !== item);
    }
    calciteChipSelectListener(event) {
        if (event.composedPath().includes(this.el)) {
            this.setSelectedItems(true, event.target);
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Sets focus on the component's first focusable element.
     */
    async setFocus() {
        await componentFocusable(this);
        if (!this.disabled) {
            return (this.selectedItems[0] || this.items[0])?.setFocus();
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const role = this.selectionMode === "none" || this.selectionMode === "multiple" ? "group" : "radiogroup";
        const { disabled } = this;
        return (hAsync(InteractiveContainer, { disabled: disabled }, hAsync("div", { "aria-disabled": toAriaBoolean(disabled), "aria-label": this.label, class: "container", role: role }, hAsync("slot", { onSlotchange: this.updateItems, ref: (el) => (this.slotRefEl = el) }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "selectionMode": ["onSelectionModeChange"]
    }; }
    static get style() { return chipGroupCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-chip-group",
        "$members$": {
            "disabled": [516],
            "label": [1],
            "scale": [513],
            "selectionMode": [513, "selection-mode"],
            "selectedItems": [1040],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteInternalChipKeyEvent", "calciteInternalChipKeyEventListener"], [0, "calciteChipClose", "calciteChipCloseListener"], [0, "calciteChipSelect", "calciteChipSelectListener"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["scale", "scale"], ["selectionMode", "selection-mode"]]
    }; }
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire();
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var colorName$1 = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var isArrayish = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var simpleSwizzle = createCommonjsModule(function (module) {



var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};
});

var colorString = createCommonjsModule(function (module) {
/* MIT license */


var hasOwnProperty = Object.hasOwnProperty;

var reverseNames = Object.create(null);

// create a list of reverse color names
for (var name in colorName$1) {
	if (hasOwnProperty.call(colorName$1, name)) {
		reverseNames[colorName$1[name]] = name;
	}
}

var cs = module.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var keyword = /^(\w+)$/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		if (!hasOwnProperty.call(colorName$1, match[1])) {
			return null;
		}

		rgb = colorName$1[match[1]];
		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = simpleSwizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = simpleSwizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = simpleSwizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = simpleSwizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = simpleSwizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = Math.round(num).toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}
});

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

/* MIT license */
/* eslint-disable no-mixed-operators */


// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(colorName)) {
	reverseKeywords[colorName[key]] = key;
}

const convert$1 = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

var conversions = convert$1;

// Hide .channels and .labels properties
for (const model of Object.keys(convert$1)) {
	if (!('channels' in convert$1[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert$1[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert$1[model].labels.length !== convert$1[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert$1[model];
	delete convert$1[model].channels;
	delete convert$1[model].labels;
	Object.defineProperty(convert$1[model], 'channels', {value: channels});
	Object.defineProperty(convert$1[model], 'labels', {value: labels});
}

convert$1.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert$1.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert$1.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert$1.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert$1.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert$1.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(colorName)) {
		const value = colorName[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert$1.keyword.rgb = function (keyword) {
	return colorName[keyword];
};

convert$1.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert$1.rgb.lab = function (rgb) {
	const xyz = convert$1.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert$1.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert$1.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert$1.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert$1.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert$1.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert$1.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert$1.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert$1.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert$1.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert$1.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert$1.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert$1.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert$1.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
};

convert$1.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert$1.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert$1.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert$1.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$1.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert$1.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert$1.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert$1.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert$1.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert$1.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert$1.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert$1.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert$1.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert$1.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert$1.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert$1.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert$1.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert$1.gray.hsv = convert$1.gray.hsl;

convert$1.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert$1.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert$1.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert$1.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$1.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

var route = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

var colorConvert = convert;

const skippedModels = [
	// To be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// Gray conflicts with some method names, and has its own method defined.
	'gray',

	// Shouldn't really be in color-convert either...
	'hex',
];

const hashedModelKeys = {};
for (const model of Object.keys(colorConvert)) {
	hashedModelKeys[[...colorConvert[model].labels].sort().join('')] = model;
}

const limiters = {};

function Color(object, model) {
	if (!(this instanceof Color)) {
		return new Color(object, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in colorConvert)) {
		throw new Error('Unknown model: ' + model);
	}

	let i;
	let channels;

	if (object == null) { // eslint-disable-line no-eq-null,eqeqeq
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (object instanceof Color) {
		this.model = object.model;
		this.color = [...object.color];
		this.valpha = object.valpha;
	} else if (typeof object === 'string') {
		const result = colorString.get(object);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + object);
		}

		this.model = result.model;
		channels = colorConvert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (object.length > 0) {
		this.model = model || 'rgb';
		channels = colorConvert[this.model].channels;
		const newArray = Array.prototype.slice.call(object, 0, channels);
		this.color = zeroArray(newArray, channels);
		this.valpha = typeof object[channels] === 'number' ? object[channels] : 1;
	} else if (typeof object === 'number') {
		// This is always RGB - can be converted later on.
		this.model = 'rgb';
		this.color = [
			(object >> 16) & 0xFF,
			(object >> 8) & 0xFF,
			object & 0xFF,
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		const keys = Object.keys(object);
		if ('alpha' in object) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof object.alpha === 'number' ? object.alpha : 0;
		}

		const hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(object));
		}

		this.model = hashedModelKeys[hashedKeys];

		const {labels} = colorConvert[this.model];
		const color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(object[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// Perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = colorConvert[this.model].channels;
		for (i = 0; i < channels; i++) {
			const limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString() {
		return this.string();
	},

	toJSON() {
		return this[this.model]();
	},

	string(places) {
		let self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
		return colorString.to[self.model](args);
	},

	percentString(places) {
		const self = this.rgb().round(typeof places === 'number' ? places : 1);
		const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
		return colorString.to.rgb.percent(args);
	},

	array() {
		return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
	},

	object() {
		const result = {};
		const {channels} = colorConvert[this.model];
		const {labels} = colorConvert[this.model];

		for (let i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray() {
		const rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject() {
		const rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round(places) {
		places = Math.max(places || 0, 0);
		return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
	},

	alpha(value) {
		if (value !== undefined) {
			return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
		}

		return this.valpha;
	},

	// Rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, value => ((value % 360) + 360) % 360),

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(95.047)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(108.833)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword(value) {
		if (value !== undefined) {
			return new Color(value);
		}

		return colorConvert[this.model].keyword(this.color);
	},

	hex(value) {
		if (value !== undefined) {
			return new Color(value);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	hexa(value) {
		if (value !== undefined) {
			return new Color(value);
		}

		const rgbArray = this.rgb().round().color;

		let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
		if (alphaHex.length === 1) {
			alphaHex = '0' + alphaHex;
		}

		return colorString.to.hex(rgbArray) + alphaHex;
	},

	rgbNumber() {
		const rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity() {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		const rgb = this.rgb().color;

		const lum = [];
		for (const [i, element] of rgb.entries()) {
			const chan = element / 255;
			lum[i] = (chan <= 0.04045) ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast(color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		const lum1 = this.luminosity();
		const lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level(color2) {
		// https://www.w3.org/TR/WCAG/#contrast-enhanced
		const contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark() {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		const rgb = this.rgb().color;
		const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 10000;
		return yiq < 128;
	},

	isLight() {
		return !this.isDark();
	},

	negate() {
		const rgb = this.rgb();
		for (let i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}

		return rgb;
	},

	lighten(ratio) {
		const hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken(ratio) {
		const hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate(ratio) {
		const hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate(ratio) {
		const hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten(ratio) {
		const hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken(ratio) {
		const hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale() {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		const rgb = this.rgb().color;
		const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(value, value, value);
	},

	fade(ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer(ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate(degrees) {
		const hsl = this.hsl();
		let hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix(mixinColor, weight) {
		// Ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		if (!mixinColor || !mixinColor.rgb) {
			throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
		}

		const color1 = mixinColor.rgb();
		const color2 = this.rgb();
		const p = weight === undefined ? 0.5 : weight;

		const w = 2 * p - 1;
		const a = color1.alpha() - color2.alpha();

		const w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2;
		const w2 = 1 - w1;

		return Color.rgb(
			w1 * color1.red() + w2 * color2.red(),
			w1 * color1.green() + w2 * color2.green(),
			w1 * color1.blue() + w2 * color2.blue(),
			color1.alpha() * p + color2.alpha() * (1 - p));
	},
};

// Model conversion methods and static constructors
for (const model of Object.keys(colorConvert)) {
	if (skippedModels.includes(model)) {
		continue;
	}

	const {channels} = colorConvert[model];

	// Conversion methods
	Color.prototype[model] = function (...args) {
		if (this.model === model) {
			return new Color(this);
		}

		if (args.length > 0) {
			return new Color(args, model);
		}

		return new Color([...assertArray(colorConvert[this.model][model].raw(this.color)), this.valpha], model);
	};

	// 'static' construction methods
	Color[model] = function (...args) {
		let color = args[0];
		if (typeof color === 'number') {
			color = zeroArray(args, channels);
		}

		return new Color(color, model);
	};
}

function roundTo(number, places) {
	return Number(number.toFixed(places));
}

function roundToPlace(places) {
	return function (number) {
		return roundTo(number, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	for (const m of model) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	}

	model = model[0];

	return function (value) {
		let result;

		if (value !== undefined) {
			if (modifier) {
				value = modifier(value);
			}

			result = this[model]();
			result.color[channel] = value;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(value) {
	return Array.isArray(value) ? value : [value];
}

function zeroArray(array, length) {
	for (let i = 0; i < length; i++) {
		if (typeof array[i] !== 'number') {
			array[i] = 0;
		}
	}

	return array;
}

var color = Color;

const CSS$17 = {
    channel: "channel",
    channels: "channels",
    colorField: "color-field",
    colorFieldScope: "scope--color-field",
    colorMode: "color-mode",
    colorModeContainer: "color-mode-container",
    container: "container",
    control: "control",
    controlAndScope: "control-and-scope",
    controlSection: "control-section",
    deleteColor: "delete-color",
    header: "header",
    hexAndChannelsGroup: "hex-and-channels-group",
    hexOptions: "color-hex-options",
    hueScope: "scope--hue",
    hueSlider: "hue-slider",
    opacityScope: "scope--opacity",
    opacitySlider: "opacity-slider",
    preview: "preview",
    previewAndSliders: "preview-and-sliders",
    saveColor: "save-color",
    savedColor: "saved-color",
    savedColors: "saved-colors",
    savedColorsButtons: "saved-colors-buttons",
    savedColorsSection: "saved-colors-section",
    scope: "scope",
    section: "section",
    slider: "slider",
    sliders: "sliders",
    splitSection: "section--split",
};
const DEFAULT_COLOR$1 = color("#007AC2");
const DEFAULT_STORAGE_KEY_PREFIX = "calcite-color-";
const RGB_LIMITS = {
    r: 255,
    g: 255,
    b: 255,
};
const HSV_LIMITS = {
    h: 360,
    s: 100,
    v: 100,
};
// 0 and 360 represent the same value, so we limit the hue to 359
const HUE_LIMIT_CONSTRAINED = HSV_LIMITS.h - 1;
const OPACITY_LIMITS = {
    min: 0,
    max: 100,
};
const DIMENSIONS = {
    s: {
        slider: {
            height: 12,
            width: 104,
        },
        colorField: {
            height: 80,
            width: 160,
        },
        thumb: {
            radius: 10,
        },
    },
    m: {
        slider: {
            height: 12,
            width: 204,
        },
        colorField: {
            height: 150,
            width: 272,
        },
        thumb: {
            radius: 10,
        },
    },
    l: {
        slider: {
            height: 12,
            width: 384,
        },
        colorField: {
            height: 200,
            width: 464,
        },
        thumb: {
            radius: 10,
        },
    },
};
const SCOPE_SIZE = 1;

const clamp$1 = (value, min, max) => Math.max(min, Math.min(value, max));
const decimalNumberRegex = new RegExp(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
/**
 * Returns the quantity of real decimal places for a number, which excludes trailing zeros.
 *
 * Adapted from {@link https://stackoverflow.com/questions/10454518/javascript-how-to-retrieve-the-number-of-decimals-of-a-string-number}.
 *
 * @param decimal - decimal value
 * @param value
 * @returns {number} the amount of decimal places in a number
 */
const decimalPlaces = (value) => {
    const match = ("" + value).match(decimalNumberRegex);
    if (!match || parseInt(match[1]) === 0) {
        return 0;
    }
    return Math.max(0, 
    // Number of digits right of decimal point.
    (match[1] ? match[1].length : 0) -
        // Adjust for scientific notation.
        (match[2] ? +match[2] : 0));
};
function getDecimals(value) {
    if (decimalPlaces(value) > 0 && value > 0) {
        return parseFloat(`0.${value.toString().split(".")[1]}`);
    }
    return value;
}
function remap(value, fromMin, fromMax, toMin, toMax) {
    return ((value - fromMin) * (toMax - toMin)) / (fromMax - fromMin) + toMin;
}
/**
 * Helper to determine if a value is close to the edge of a range within a threshold.
 *
 * @param value
 * @param range
 * @param threshold
 * @returns -1 if close to lower edge, 1 if close to upper edge, 0 otherwise.
 */
function closeToRangeEdge(value, range, threshold) {
    return value < threshold ? -1 : value > range - threshold ? 1 : 0;
}

const colorPickerCss = "/*!@:host([disabled])*/[disabled].sc-calcite-color-picker-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-color-picker-h *.sc-calcite-color-picker,.sc-calcite-color-picker-h[disabled].sc-calcite-color-picker-s>*,.sc-calcite-color-picker-h[disabled] .sc-calcite-color-picker-s>*{pointer-events:none}/*!@:host*/.sc-calcite-color-picker-h{display:inline-block;font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-normal)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-color-picker-h[disabled] .sc-calcite-color-picker-s>[calcite-hydrated][disabled],[disabled].sc-calcite-color-picker-h [calcite-hydrated][disabled].sc-calcite-color-picker{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-color-picker{display:contents}/*!@:host([scale=s])*/[scale=s].sc-calcite-color-picker-h{--calcite-color-picker-spacing:8px}/*!@:host([scale=s]) .container*/[scale=s].sc-calcite-color-picker-h .container.sc-calcite-color-picker{inline-size:160px}/*!@:host([scale=s]) .saved-colors*/[scale=s].sc-calcite-color-picker-h .saved-colors.sc-calcite-color-picker{gap:0.25rem;grid-template-columns:repeat(auto-fill, 20px)}/*!@:host([scale=m])*/[scale=m].sc-calcite-color-picker-h{--calcite-color-picker-spacing:12px}/*!@:host([scale=m]) .container*/[scale=m].sc-calcite-color-picker-h .container.sc-calcite-color-picker{inline-size:272px}/*!@:host([scale=l])*/[scale=l].sc-calcite-color-picker-h{--calcite-color-picker-spacing:16px;font-size:var(--calcite-font-size--1);line-height:1rem}/*!@:host([scale=l]) .container*/[scale=l].sc-calcite-color-picker-h .container.sc-calcite-color-picker{inline-size:464px}/*!@:host([scale=l]) .section:first-of-type*/[scale=l].sc-calcite-color-picker-h .section.sc-calcite-color-picker:first-of-type{padding-block-start:var(--calcite-color-picker-spacing)}/*!@:host([scale=l]) .saved-colors*/[scale=l].sc-calcite-color-picker-h .saved-colors.sc-calcite-color-picker{grid-template-columns:repeat(auto-fill, 32px)}/*!@:host([scale=l]) .control-section*/[scale=l].sc-calcite-color-picker-h .control-section.sc-calcite-color-picker{flex-wrap:nowrap;align-items:baseline;flex-wrap:wrap}/*!@:host([scale=l]) .color-hex-options*/[scale=l].sc-calcite-color-picker-h .color-hex-options.sc-calcite-color-picker{display:flex;flex-shrink:1;flex-direction:column;justify-content:space-around}/*!@:host([scale=l]) .color-mode-container*/[scale=l].sc-calcite-color-picker-h .color-mode-container.sc-calcite-color-picker{flex-shrink:3}/*!@.container*/.container.sc-calcite-color-picker{background-color:var(--calcite-color-foreground-1);display:inline-block;border:1px solid var(--calcite-color-border-1)}/*!@.control-and-scope*/.control-and-scope.sc-calcite-color-picker{position:relative;display:flex;cursor:pointer;touch-action:none}/*!@.scope*/.scope.sc-calcite-color-picker{pointer-events:none;position:absolute;z-index:var(--calcite-z-index);block-size:1px;inline-size:1px;border-radius:9999px;background-color:transparent;font-size:var(--calcite-font-size--1);outline-color:transparent}/*!@.scope:focus*/.scope.sc-calcite-color-picker:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          );outline-offset:11px}/*!@.hex-and-channels-group*/.hex-and-channels-group.sc-calcite-color-picker{inline-size:100%}/*!@.hex-and-channels-group,\n.control-section*/.hex-and-channels-group.sc-calcite-color-picker,.control-section.sc-calcite-color-picker{display:flex;flex-direction:row;flex-wrap:wrap}/*!@.section*/.section.sc-calcite-color-picker{padding-block:0 var(--calcite-color-picker-spacing);padding-inline:var(--calcite-color-picker-spacing)}/*!@.section:first-of-type*/.section.sc-calcite-color-picker:first-of-type{padding-block-start:var(--calcite-color-picker-spacing)}/*!@.sliders*/.sliders.sc-calcite-color-picker{display:flex;flex-direction:column;justify-content:space-between;margin-inline-start:var(--calcite-color-picker-spacing)}/*!@.preview-and-sliders*/.preview-and-sliders.sc-calcite-color-picker{display:flex;align-items:center;padding:var(--calcite-color-picker-spacing)}/*!@.color-hex-options,\n.section--split*/.color-hex-options.sc-calcite-color-picker,.section--split.sc-calcite-color-picker{flex-grow:1}/*!@.header*/.header.sc-calcite-color-picker{display:flex;align-items:center;justify-content:space-between;color:var(--calcite-color-text-1)}/*!@.color-mode-container*/.color-mode-container.sc-calcite-color-picker{padding-block-start:var(--calcite-color-picker-spacing)}/*!@.channels*/.channels.sc-calcite-color-picker{display:flex;row-gap:0.125rem}/*!@.channel[data-channel-index=\"3\"]*/.channel[data-channel-index=\"3\"].sc-calcite-color-picker{inline-size:159px}/*!@:host([scale=s]) .channels*/[scale=s].sc-calcite-color-picker-h .channels.sc-calcite-color-picker{flex-wrap:wrap}/*!@:host([scale=s]) .channel*/[scale=s].sc-calcite-color-picker-h .channel.sc-calcite-color-picker{flex-basis:30%;flex-grow:1}/*!@:host([scale=s]) .channel[data-channel-index=\"3\"]*/[scale=s].sc-calcite-color-picker-h .channel[data-channel-index=\"3\"].sc-calcite-color-picker{inline-size:unset;margin-inline-start:unset}/*!@:host([scale=l]) .channel[data-channel-index=\"3\"]*/[scale=l].sc-calcite-color-picker-h .channel[data-channel-index=\"3\"].sc-calcite-color-picker{inline-size:131px}/*!@.saved-colors*/.saved-colors.sc-calcite-color-picker{display:grid;gap:0.5rem;padding-block-start:var(--calcite-color-picker-spacing);grid-template-columns:repeat(auto-fill, 24px)}/*!@.saved-colors-buttons*/.saved-colors-buttons.sc-calcite-color-picker{display:flex}/*!@.saved-color*/.saved-color.sc-calcite-color-picker{outline-offset:0;outline-color:transparent;cursor:pointer}/*!@.saved-color:focus*/.saved-color.sc-calcite-color-picker:focus{outline:2px solid var(--calcite-color-brand);outline-offset:2px}/*!@.saved-color:hover*/.saved-color.sc-calcite-color-picker:hover{transition:outline-color var(--calcite-internal-animation-timing-fast) ease-in-out;outline:2px solid var(--calcite-color-border-2);outline-offset:2px}/*!@:host([hidden])*/[hidden].sc-calcite-color-picker-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-color-picker{display:none}";

const throttleFor60FpsInMs = 16;
class ColorPicker {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteColorPickerChange = createEvent(this, "calciteColorPickerChange", 6);
        this.calciteColorPickerInput = createEvent(this, "calciteColorPickerInput", 6);
        this.internalColorUpdateContext = null;
        this.mode = CSSColorMode.HEX;
        this.shiftKeyChannelAdjustment = 0;
        this.handleTabActivate = (event) => {
            this.channelMode = event.currentTarget.getAttribute("data-color-mode");
            this.updateChannelsFromColor(this.color);
        };
        this.handleColorFieldScopeKeyDown = (event) => {
            const { key } = event;
            const arrowKeyToXYOffset = {
                ArrowUp: { x: 0, y: -10 },
                ArrowRight: { x: 10, y: 0 },
                ArrowDown: { x: 0, y: 10 },
                ArrowLeft: { x: -10, y: 0 },
            };
            if (arrowKeyToXYOffset[key]) {
                event.preventDefault();
                this.scopeOrientation = key === "ArrowDown" || key === "ArrowUp" ? "vertical" : "horizontal";
                this.captureColorFieldColor(this.colorFieldScopeLeft + arrowKeyToXYOffset[key].x || 0, this.colorFieldScopeTop + arrowKeyToXYOffset[key].y || 0, false);
            }
        };
        this.handleHueScopeKeyDown = (event) => {
            const modifier = event.shiftKey ? 10 : 1;
            const { key } = event;
            const arrowKeyToXOffset = {
                ArrowUp: 1,
                ArrowRight: 1,
                ArrowDown: -1,
                ArrowLeft: -1,
            };
            if (arrowKeyToXOffset[key]) {
                event.preventDefault();
                const delta = arrowKeyToXOffset[key] * modifier;
                const hue = this.baseColorFieldColor.hue();
                const color = this.baseColorFieldColor.hue(hue + delta);
                this.internalColorSet(color, false);
            }
        };
        this.handleHexInputChange = (event) => {
            event.stopPropagation();
            const { allowEmpty, color: color$1 } = this;
            const input = event.target;
            const hex = input.value;
            if (allowEmpty && !hex) {
                this.internalColorSet(null);
                return;
            }
            const normalizedHex = color$1 && normalizeHex(hexify(color$1, alphaCompatible(this.mode)));
            if (hex !== normalizedHex) {
                this.internalColorSet(color(hex));
            }
        };
        this.handleSavedColorSelect = (event) => {
            const swatch = event.currentTarget;
            this.internalColorSet(color(swatch.color));
        };
        this.handleChannelInput = (event) => {
            const input = event.currentTarget;
            const channelIndex = Number(input.getAttribute("data-channel-index"));
            const isAlphaChannel = channelIndex === 3;
            const limit = isAlphaChannel
                ? OPACITY_LIMITS.max
                : this.channelMode === "rgb"
                    ? RGB_LIMITS[Object.keys(RGB_LIMITS)[channelIndex]]
                    : HSV_LIMITS[Object.keys(HSV_LIMITS)[channelIndex]];
            let inputValue;
            if (this.allowEmpty && !input.value) {
                inputValue = "";
            }
            else {
                const value = Number(input.value);
                const adjustedValue = value + this.shiftKeyChannelAdjustment;
                const clamped = clamp$1(adjustedValue, 0, limit);
                inputValue = clamped.toString();
            }
            input.value = inputValue;
            if (inputValue !== "" && this.shiftKeyChannelAdjustment !== 0) {
                // we treat nudging as a change event since the input won't emit when modifying the value directly
                this.handleChannelChange(event);
            }
        };
        this.handleChannelChange = (event) => {
            const input = event.currentTarget;
            const channelIndex = Number(input.getAttribute("data-channel-index"));
            const channels = [...this.channels];
            const shouldClearChannels = this.allowEmpty && !input.value;
            if (shouldClearChannels) {
                this.channels = [null, null, null, null];
                this.internalColorSet(null);
                return;
            }
            const isAlphaChannel = channelIndex === 3;
            const value = Number(input.value);
            channels[channelIndex] = isAlphaChannel ? opacityToAlpha(value) : value;
            this.updateColorFromChannels(channels);
        };
        this.handleSavedColorKeyDown = (event) => {
            if (isActivationKey(event.key)) {
                event.preventDefault();
                this.handleSavedColorSelect(event);
            }
        };
        this.handleColorFieldPointerDown = (event) => {
            if (!isPrimaryPointerButton(event)) {
                return;
            }
            const { offsetX, offsetY } = event;
            window.addEventListener("pointermove", this.globalPointerMoveHandler);
            window.addEventListener("pointerup", this.globalPointerUpHandler, { once: true });
            this.activeCanvasInfo = {
                context: this.colorFieldRenderingContext,
                bounds: this.colorFieldRenderingContext.canvas.getBoundingClientRect(),
            };
            this.captureColorFieldColor(offsetX, offsetY);
            this.colorFieldScopeNode.focus();
        };
        this.handleHueSliderPointerDown = (event) => {
            if (!isPrimaryPointerButton(event)) {
                return;
            }
            const { offsetX } = event;
            window.addEventListener("pointermove", this.globalPointerMoveHandler);
            window.addEventListener("pointerup", this.globalPointerUpHandler, { once: true });
            this.activeCanvasInfo = {
                context: this.hueSliderRenderingContext,
                bounds: this.hueSliderRenderingContext.canvas.getBoundingClientRect(),
            };
            this.captureHueSliderColor(offsetX);
            this.hueScopeNode.focus();
        };
        this.handleOpacitySliderPointerDown = (event) => {
            if (!isPrimaryPointerButton(event)) {
                return;
            }
            const { offsetX } = event;
            window.addEventListener("pointermove", this.globalPointerMoveHandler);
            window.addEventListener("pointerup", this.globalPointerUpHandler, { once: true });
            this.activeCanvasInfo = {
                context: this.opacitySliderRenderingContext,
                bounds: this.opacitySliderRenderingContext.canvas.getBoundingClientRect(),
            };
            this.captureOpacitySliderValue(offsetX);
            this.opacityScopeNode.focus();
        };
        this.globalPointerUpHandler = (event) => {
            if (!isPrimaryPointerButton(event)) {
                return;
            }
            const previouslyDragging = this.activeCanvasInfo;
            this.activeCanvasInfo = null;
            this.drawColorControls();
            if (previouslyDragging) {
                this.calciteColorPickerChange.emit();
            }
        };
        this.globalPointerMoveHandler = (event) => {
            const { activeCanvasInfo, el } = this;
            if (!el.isConnected || !activeCanvasInfo) {
                return;
            }
            const { context, bounds } = activeCanvasInfo;
            let samplingX;
            let samplingY;
            const { clientX, clientY } = event;
            if (context.canvas.matches(":hover")) {
                samplingX = clientX - bounds.x;
                samplingY = clientY - bounds.y;
            }
            else {
                // snap x and y to the closest edge
                if (clientX < bounds.x + bounds.width && clientX > bounds.x) {
                    samplingX = clientX - bounds.x;
                }
                else if (clientX < bounds.x) {
                    samplingX = 0;
                }
                else {
                    samplingX = bounds.width;
                }
                if (clientY < bounds.y + bounds.height && clientY > bounds.y) {
                    samplingY = clientY - bounds.y;
                }
                else if (clientY < bounds.y) {
                    samplingY = 0;
                }
                else {
                    samplingY = bounds.height;
                }
            }
            if (context === this.colorFieldRenderingContext) {
                this.captureColorFieldColor(samplingX, samplingY, false);
            }
            else if (context === this.hueSliderRenderingContext) {
                this.captureHueSliderColor(samplingX);
            }
            else if (context === this.opacitySliderRenderingContext) {
                this.captureOpacitySliderValue(samplingX);
            }
        };
        this.storeColorFieldScope = (node) => {
            this.colorFieldScopeNode = node;
        };
        this.storeHueScope = (node) => {
            this.hueScopeNode = node;
        };
        this.renderChannelsTabTitle = (channelMode) => {
            const { channelMode: activeChannelMode, messages } = this;
            const selected = channelMode === activeChannelMode;
            const label = channelMode === "rgb" ? messages.rgb : messages.hsv;
            return (hAsync("calcite-tab-title", { class: CSS$17.colorMode, "data-color-mode": channelMode, key: channelMode, onCalciteTabsActivate: this.handleTabActivate, selected: selected }, label));
        };
        this.renderChannelsTab = (channelMode) => {
            const { allowEmpty, channelMode: activeChannelMode, channels, messages, alphaChannel } = this;
            const selected = channelMode === activeChannelMode;
            const isRgb = channelMode === "rgb";
            const channelAriaLabels = isRgb
                ? [messages.red, messages.green, messages.blue]
                : [messages.hue, messages.saturation, messages.value];
            const direction = getElementDir(this.el);
            const channelsToRender = alphaChannel ? channels : channels.slice(0, 3);
            return (hAsync("calcite-tab", { class: CSS$17.control, key: channelMode, selected: selected }, hAsync("div", { class: CSS$17.channels, dir: "ltr" }, channelsToRender.map((channelValue, index) => {
                const isAlphaChannel = index === 3;
                if (isAlphaChannel) {
                    channelValue =
                        allowEmpty && !channelValue ? channelValue : alphaToOpacity(channelValue);
                }
                /* the channel container is ltr, so we apply the host's direction */
                return this.renderChannel(channelValue, index, channelAriaLabels[index], direction, isAlphaChannel ? "%" : "");
            }))));
        };
        this.renderChannel = (value, index, ariaLabel, direction, suffix) => {
            return (hAsync("calcite-input-number", { class: CSS$17.channel, "data-channel-index": index, dir: direction, key: index, label: ariaLabel, lang: this.effectiveLocale, numberButtonType: "none", numberingSystem: this.numberingSystem, onCalciteInputNumberChange: this.handleChannelChange, onCalciteInputNumberInput: this.handleChannelInput, onKeyDown: this.handleKeyDown, scale: this.scale === "l" ? "m" : "s",
                // workaround to ensure input borders overlap as desired
                // this is because the build transforms margin-left to its
                // logical-prop, which is undesired as channels are always ltr
                style: {
                    marginLeft: index > 0 && !(this.scale === "s" && this.alphaChannel && index === 3) ? "-1px" : "",
                }, suffixText: suffix, value: value?.toString() }));
        };
        this.deleteColor = () => {
            const colorToDelete = hexify(this.color, this.alphaChannel);
            const inStorage = this.savedColors.indexOf(colorToDelete) > -1;
            if (!inStorage) {
                return;
            }
            const savedColors = this.savedColors.filter((color) => color !== colorToDelete);
            this.savedColors = savedColors;
            const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;
            if (this.storageId) {
                localStorage.setItem(storageKey, JSON.stringify(savedColors));
            }
        };
        this.saveColor = () => {
            const colorToSave = hexify(this.color, this.alphaChannel);
            const alreadySaved = this.savedColors.indexOf(colorToSave) > -1;
            if (alreadySaved) {
                return;
            }
            const savedColors = [...this.savedColors, colorToSave];
            this.savedColors = savedColors;
            const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;
            if (this.storageId) {
                localStorage.setItem(storageKey, JSON.stringify(savedColors));
            }
        };
        this.drawColorControls = throttle$1((type = "all") => {
            if ((type === "all" || type === "color-field") && this.colorFieldRenderingContext) {
                this.drawColorField();
            }
            if ((type === "all" || type === "hue-slider") && this.hueSliderRenderingContext) {
                this.drawHueSlider();
            }
            if (this.alphaChannel &&
                (type === "all" || type === "opacity-slider") &&
                this.opacitySliderRenderingContext) {
                this.drawOpacitySlider();
            }
        }, throttleFor60FpsInMs);
        this.captureColorFieldColor = (x, y, skipEqual = true) => {
            const { dimensions: { colorField: { height, width }, }, } = this;
            const saturation = Math.round((HSV_LIMITS.s / width) * x);
            const value = Math.round((HSV_LIMITS.v / height) * (height - y));
            this.internalColorSet(this.baseColorFieldColor.hsv().saturationv(saturation).value(value), skipEqual);
        };
        this.initColorField = (canvas) => {
            this.colorFieldRenderingContext = canvas.getContext("2d");
            this.updateCanvasSize("color-field");
            this.drawColorControls();
        };
        this.initHueSlider = (canvas) => {
            this.hueSliderRenderingContext = canvas.getContext("2d");
            this.updateCanvasSize("hue-slider");
            this.drawHueSlider();
        };
        this.initOpacitySlider = (canvas) => {
            if (!canvas) {
                return;
            }
            this.opacitySliderRenderingContext = canvas.getContext("2d");
            this.updateCanvasSize("opacity-slider");
            this.drawOpacitySlider();
        };
        this.storeOpacityScope = (node) => {
            this.opacityScopeNode = node;
        };
        this.handleOpacityScopeKeyDown = (event) => {
            const modifier = event.shiftKey ? 10 : 1;
            const { key } = event;
            const arrowKeyToXOffset = {
                ArrowUp: 0.01,
                ArrowRight: 0.01,
                ArrowDown: -0.01,
                ArrowLeft: -0.01,
            };
            if (arrowKeyToXOffset[key]) {
                event.preventDefault();
                const delta = arrowKeyToXOffset[key] * modifier;
                const alpha = this.baseColorFieldColor.alpha();
                const color = this.baseColorFieldColor.alpha(alpha + delta);
                this.internalColorSet(color, false);
            }
        };
        this.allowEmpty = false;
        this.alphaChannel = false;
        this.channelsDisabled = false;
        this.color = DEFAULT_COLOR$1;
        this.disabled = false;
        this.format = "auto";
        this.hideChannels = false;
        this.hexDisabled = false;
        this.hideHex = false;
        this.hideSaved = false;
        this.savedDisabled = false;
        this.scale = "m";
        this.storageId = undefined;
        this.messageOverrides = undefined;
        this.numberingSystem = undefined;
        this.value = normalizeHex(hexify(DEFAULT_COLOR$1, this.alphaChannel));
        this.defaultMessages = undefined;
        this.channelMode = "rgb";
        this.channels = this.toChannels(DEFAULT_COLOR$1);
        this.dimensions = DIMENSIONS.m;
        this.effectiveLocale = "";
        this.messages = undefined;
        this.savedColors = [];
        this.colorFieldScopeTop = undefined;
        this.colorFieldScopeLeft = undefined;
        this.hueScopeLeft = undefined;
        this.opacityScopeLeft = undefined;
        this.scopeOrientation = undefined;
    }
    handleAlphaChannelChange(alphaChannel) {
        const { format } = this;
        if (alphaChannel && format !== "auto" && !alphaCompatible(format)) {
            console.warn(`ignoring alphaChannel as the current format (${format}) does not support alpha`);
            this.alphaChannel = false;
        }
    }
    handleColorChange(color, oldColor) {
        this.drawColorControls();
        this.updateChannelsFromColor(color);
        this.previousColor = oldColor;
    }
    handleFormatOrAlphaChannelChange() {
        this.setMode(this.format);
        this.internalColorSet(this.color, false, "internal");
    }
    handleScaleChange(scale = "m") {
        this.updateDimensions(scale);
        this.updateCanvasSize("all");
        this.drawColorControls();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    handleValueChange(value, oldValue) {
        const { allowEmpty, format } = this;
        const checkMode = !allowEmpty || value;
        let modeChanged = false;
        if (checkMode) {
            const nextMode = parseMode(value);
            if (!nextMode || (format !== "auto" && nextMode !== format)) {
                this.showIncompatibleColorWarning(value, format);
                this.value = oldValue;
                return;
            }
            modeChanged = this.mode !== nextMode;
            this.setMode(nextMode, this.internalColorUpdateContext === null);
        }
        const dragging = this.activeCanvasInfo;
        if (this.internalColorUpdateContext === "initial") {
            return;
        }
        if (this.internalColorUpdateContext === "user-interaction") {
            this.calciteColorPickerInput.emit();
            if (!dragging) {
                this.calciteColorPickerChange.emit();
            }
            return;
        }
        const color$1 = allowEmpty && !value
            ? null
            : color(value != null && typeof value === "object" && alphaCompatible(this.mode)
                ? normalizeColor(value)
                : value);
        const colorChanged = !colorEqual(color$1, this.color);
        if (modeChanged || colorChanged) {
            this.internalColorSet(color$1, this.alphaChannel && !(this.mode.endsWith("a") || this.mode.endsWith("a-css")), "internal");
        }
    }
    get baseColorFieldColor() {
        return this.color || this.previousColor || DEFAULT_COLOR$1;
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // using @Listen as a workaround for VDOM listener not firing
    handleChannelKeyUpOrDown(event) {
        this.shiftKeyChannelAdjustment = 0;
        const { key } = event;
        if ((key !== "ArrowUp" && key !== "ArrowDown") ||
            !event.composedPath().some((node) => node.classList?.contains(CSS$17.channel))) {
            return;
        }
        const { shiftKey } = event;
        event.preventDefault();
        if (!this.color) {
            this.internalColorSet(this.previousColor);
            event.stopPropagation();
            return;
        }
        // this gets applied to the input's up/down arrow increment/decrement
        const complementaryBump = 9;
        this.shiftKeyChannelAdjustment =
            key === "ArrowUp" && shiftKey
                ? complementaryBump
                : key === "ArrowDown" && shiftKey
                    ? -complementaryBump
                    : 0;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component's first focusable element. */
    async setFocus() {
        await componentFocusable(this);
        this.el.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        setUpLoadableComponent(this);
        const { allowEmpty, color: color$1, format, value } = this;
        const willSetNoColor = allowEmpty && !value;
        const parsedMode = parseMode(value);
        const valueIsCompatible = willSetNoColor || (format === "auto" && parsedMode) || format === parsedMode;
        const initialColor = willSetNoColor ? null : valueIsCompatible ? color(value) : color$1;
        if (!valueIsCompatible) {
            this.showIncompatibleColorWarning(value, format);
        }
        this.setMode(format, false);
        this.internalColorSet(initialColor, false, "initial");
        this.updateDimensions(this.scale);
        const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;
        if (this.storageId && localStorage.getItem(storageKey)) {
            this.savedColors = JSON.parse(localStorage.getItem(storageKey));
        }
        await setUpMessages(this);
    }
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        window.removeEventListener("pointermove", this.globalPointerMoveHandler);
        window.removeEventListener("pointerup", this.globalPointerUpHandler);
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { allowEmpty, channelsDisabled, color, colorFieldScopeLeft, colorFieldScopeTop, dimensions: { slider: { width: sliderWidth }, thumb: { radius: thumbRadius }, }, hexDisabled, hideChannels, hideHex, hideSaved, hueScopeLeft, messages, alphaChannel, opacityScopeLeft, savedColors, savedDisabled, scale, scopeOrientation, } = this;
        const selectedColorInHex = color ? hexify(color, alphaChannel) : null;
        const hueTop = thumbRadius;
        const hueLeft = hueScopeLeft ?? (sliderWidth * DEFAULT_COLOR$1.hue()) / HSV_LIMITS.h;
        const opacityTop = thumbRadius;
        const opacityLeft = opacityScopeLeft ??
            (sliderWidth * alphaToOpacity(DEFAULT_COLOR$1.alpha())) / OPACITY_LIMITS.max;
        const noColor = color === null;
        const vertical = scopeOrientation === "vertical";
        const noHex = hexDisabled || hideHex;
        const noChannels = channelsDisabled || hideChannels;
        const noSaved = savedDisabled || hideSaved;
        const [adjustedColorFieldScopeLeft, adjustedColorFieldScopeTop] = this.getAdjustedScopePosition(colorFieldScopeLeft, colorFieldScopeTop);
        const [adjustedHueScopeLeft, adjustedHueScopeTop] = this.getAdjustedScopePosition(hueLeft, hueTop);
        const [adjustedOpacityScopeLeft, adjustedOpacityScopeTop] = this.getAdjustedScopePosition(opacityLeft, opacityTop);
        return (hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: CSS$17.container }, hAsync("div", { class: CSS$17.controlAndScope }, hAsync("canvas", { class: CSS$17.colorField, onPointerDown: this.handleColorFieldPointerDown,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.initColorField }), hAsync("div", { "aria-label": vertical ? messages.value : messages.saturation, "aria-valuemax": vertical ? HSV_LIMITS.v : HSV_LIMITS.s, "aria-valuemin": "0", "aria-valuenow": (vertical ? color?.saturationv() : color?.value()) || "0", class: { [CSS$17.scope]: true, [CSS$17.colorFieldScope]: true }, onKeyDown: this.handleColorFieldScopeKeyDown, role: "slider", style: {
                top: `${adjustedColorFieldScopeTop || 0}px`,
                left: `${adjustedColorFieldScopeLeft || 0}px`,
            }, tabindex: "0",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeColorFieldScope })), hAsync("div", { class: CSS$17.previewAndSliders }, hAsync("calcite-color-picker-swatch", { class: CSS$17.preview, color: selectedColorInHex, scale: "l" }), hAsync("div", { class: CSS$17.sliders }, hAsync("div", { class: CSS$17.controlAndScope }, hAsync("canvas", { class: { [CSS$17.slider]: true, [CSS$17.hueSlider]: true }, onPointerDown: this.handleHueSliderPointerDown,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.initHueSlider }), hAsync("div", { "aria-label": messages.hue, "aria-valuemax": HSV_LIMITS.h, "aria-valuemin": "0", "aria-valuenow": color?.round().hue() || DEFAULT_COLOR$1.round().hue(), class: { [CSS$17.scope]: true, [CSS$17.hueScope]: true }, onKeyDown: this.handleHueScopeKeyDown, role: "slider", style: {
                top: `${adjustedHueScopeTop}px`,
                left: `${adjustedHueScopeLeft}px`,
            }, tabindex: "0",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeHueScope })), alphaChannel ? (hAsync("div", { class: CSS$17.controlAndScope }, hAsync("canvas", { class: { [CSS$17.slider]: true, [CSS$17.opacitySlider]: true }, onPointerDown: this.handleOpacitySliderPointerDown,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.initOpacitySlider }), hAsync("div", { "aria-label": messages.opacity, "aria-valuemax": OPACITY_LIMITS.max, "aria-valuemin": OPACITY_LIMITS.min, "aria-valuenow": (color || DEFAULT_COLOR$1).round().alpha(), class: { [CSS$17.scope]: true, [CSS$17.opacityScope]: true }, onKeyDown: this.handleOpacityScopeKeyDown, role: "slider", style: {
                top: `${adjustedOpacityScopeTop}px`,
                left: `${adjustedOpacityScopeLeft}px`,
            }, tabindex: "0",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeOpacityScope }))) : null)), noHex && noChannels ? null : (hAsync("div", { class: {
                [CSS$17.controlSection]: true,
                [CSS$17.section]: true,
            } }, hAsync("div", { class: CSS$17.hexAndChannelsGroup }, noHex ? null : (hAsync("div", { class: CSS$17.hexOptions }, hAsync("calcite-color-picker-hex-input", { allowEmpty: allowEmpty, alphaChannel: alphaChannel, class: CSS$17.control, messages: messages, numberingSystem: this.numberingSystem, onCalciteColorPickerHexInputChange: this.handleHexInputChange, scale: scale, value: selectedColorInHex }))), noChannels ? null : (hAsync("calcite-tabs", { class: {
                [CSS$17.colorModeContainer]: true,
                [CSS$17.splitSection]: true,
            }, scale: scale === "l" ? "m" : "s" }, hAsync("calcite-tab-nav", { slot: "title-group" }, this.renderChannelsTabTitle("rgb"), this.renderChannelsTabTitle("hsv")), this.renderChannelsTab("rgb"), this.renderChannelsTab("hsv")))))), noSaved ? null : (hAsync("div", { class: { [CSS$17.savedColorsSection]: true, [CSS$17.section]: true } }, hAsync("div", { class: CSS$17.header }, hAsync("label", null, messages.saved), hAsync("div", { class: CSS$17.savedColorsButtons }, hAsync("calcite-button", { appearance: "transparent", class: CSS$17.deleteColor, disabled: noColor, iconStart: "minus", kind: "neutral", label: messages.deleteColor, onClick: this.deleteColor, scale: scale, type: "button" }), hAsync("calcite-button", { appearance: "transparent", class: CSS$17.saveColor, disabled: noColor, iconStart: "plus", kind: "neutral", label: messages.saveColor, onClick: this.saveColor, scale: scale, type: "button" }))), savedColors.length > 0 ? (hAsync("div", { class: CSS$17.savedColors }, [
            ...savedColors.map((color) => (hAsync("calcite-color-picker-swatch", { class: CSS$17.savedColor, color: color, key: color, onClick: this.handleSavedColorSelect, onKeyDown: this.handleSavedColorKeyDown, scale: scale, tabIndex: 0 }))),
        ])) : null)))));
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    handleKeyDown(event) {
        if (event.key === "Enter") {
            event.preventDefault();
        }
    }
    showIncompatibleColorWarning(value, format) {
        console.warn(`ignoring color value (${value}) as it is not compatible with the current format (${format})`);
    }
    setMode(format, warn = true) {
        const mode = format === "auto" ? this.mode : format;
        this.mode = this.ensureCompatibleMode(mode, warn);
    }
    ensureCompatibleMode(mode, warn) {
        const { alphaChannel } = this;
        const isAlphaCompatible = alphaCompatible(mode);
        if (alphaChannel && !isAlphaCompatible) {
            const alphaMode = toAlphaMode(mode);
            if (warn) {
                console.warn(`setting format to (${alphaMode}) as the provided one (${mode}) does not support alpha`);
            }
            return alphaMode;
        }
        if (!alphaChannel && isAlphaCompatible) {
            const nonAlphaMode = toNonAlphaMode(mode);
            if (warn) {
                console.warn(`setting format to (${nonAlphaMode}) as the provided one (${mode}) does not support alpha`);
            }
            return nonAlphaMode;
        }
        return mode;
    }
    captureHueSliderColor(x) {
        const { dimensions: { slider: { width }, }, } = this;
        const hue = (HUE_LIMIT_CONSTRAINED / width) * x;
        this.internalColorSet(this.baseColorFieldColor.hue(hue), false);
    }
    captureOpacitySliderValue(x) {
        const { dimensions: { slider: { width }, }, } = this;
        const alpha = opacityToAlpha((OPACITY_LIMITS.max / width) * x);
        this.internalColorSet(this.baseColorFieldColor.alpha(alpha), false);
    }
    internalColorSet(color, skipEqual = true, context = "user-interaction") {
        if (skipEqual && colorEqual(color, this.color)) {
            return;
        }
        this.internalColorUpdateContext = context;
        this.color = color;
        this.value = this.toValue(color);
        this.internalColorUpdateContext = null;
    }
    toValue(color, format = this.mode) {
        if (!color) {
            return null;
        }
        const hexMode = "hex";
        if (format.includes(hexMode)) {
            const hasAlpha = format === CSSColorMode.HEXA;
            return normalizeHex(hexify(color.round(), hasAlpha), hasAlpha);
        }
        if (format.includes("-css")) {
            const value = color[format.replace("-css", "").replace("a", "")]().round().string();
            // Color omits alpha values when alpha is 1
            const needToInjectAlpha = (format.endsWith("a") || format.endsWith("a-css")) && color.alpha() === 1;
            if (needToInjectAlpha) {
                const model = value.slice(0, 3);
                const values = value.slice(4, -1);
                return `${model}a(${values}, ${color.alpha()})`;
            }
            return value;
        }
        const colorObject = 
        /* Color() does not support hsva, hsla nor rgba, so we use the non-alpha mode */
        color[toNonAlphaMode(format)]().round().object();
        if (format.endsWith("a")) {
            return normalizeAlpha(colorObject);
        }
        return colorObject;
    }
    getSliderCapSpacing() {
        const { dimensions: { slider: { height }, thumb: { radius }, }, } = this;
        return radius * 2 - height;
    }
    updateDimensions(scale = "m") {
        this.dimensions = DIMENSIONS[scale];
    }
    drawColorField() {
        const context = this.colorFieldRenderingContext;
        const { dimensions: { colorField: { height, width }, }, } = this;
        context.fillStyle = this.baseColorFieldColor
            .hsv()
            .saturationv(100)
            .value(100)
            .alpha(1)
            .string();
        context.fillRect(0, 0, width, height);
        const whiteGradient = context.createLinearGradient(0, 0, width, 0);
        whiteGradient.addColorStop(0, "rgba(255,255,255,1)");
        whiteGradient.addColorStop(1, "rgba(255,255,255,0)");
        context.fillStyle = whiteGradient;
        context.fillRect(0, 0, width, height);
        const blackGradient = context.createLinearGradient(0, 0, 0, height);
        blackGradient.addColorStop(0, "rgba(0,0,0,0)");
        blackGradient.addColorStop(1, "rgba(0,0,0,1)");
        context.fillStyle = blackGradient;
        context.fillRect(0, 0, width, height);
        this.drawActiveColorFieldColor();
    }
    setCanvasContextSize(canvas, { height, width }) {
        if (!canvas) {
            return;
        }
        const devicePixelRatio = window.devicePixelRatio || 1;
        canvas.width = width * devicePixelRatio;
        canvas.height = height * devicePixelRatio;
        canvas.style.height = `${height}px`;
        canvas.style.width = `${width}px`;
        const context = canvas.getContext("2d");
        context.scale(devicePixelRatio, devicePixelRatio);
    }
    updateCanvasSize(context = "all") {
        const { dimensions } = this;
        if (context === "all" || context === "color-field") {
            this.setCanvasContextSize(this.colorFieldRenderingContext?.canvas, dimensions.colorField);
        }
        const adjustedSliderDimensions = {
            width: dimensions.slider.width,
            height: dimensions.slider.height + (dimensions.thumb.radius - dimensions.slider.height / 2) * 2,
        };
        if (context === "all" || context === "hue-slider") {
            this.setCanvasContextSize(this.hueSliderRenderingContext?.canvas, adjustedSliderDimensions);
        }
        if (context === "all" || context === "opacity-slider") {
            this.setCanvasContextSize(this.opacitySliderRenderingContext?.canvas, adjustedSliderDimensions);
        }
    }
    drawActiveColorFieldColor() {
        const { color } = this;
        if (!color) {
            return;
        }
        const hsvColor = color.hsv();
        const { dimensions: { colorField: { height, width }, thumb: { radius }, }, } = this;
        const x = hsvColor.saturationv() / (HSV_LIMITS.s / width);
        const y = height - hsvColor.value() / (HSV_LIMITS.v / height);
        requestAnimationFrame(() => {
            this.colorFieldScopeLeft = x;
            this.colorFieldScopeTop = y;
        });
        this.drawThumb(this.colorFieldRenderingContext, radius, x, y, hsvColor, false);
    }
    drawThumb(context, radius, x, y, color, applyAlpha) {
        const startAngle = 0;
        const endAngle = 2 * Math.PI;
        const outlineWidth = 1;
        context.beginPath();
        context.arc(x, y, radius, startAngle, endAngle);
        context.fillStyle = "#fff";
        context.fill();
        context.strokeStyle = "rgba(0,0,0,0.3)";
        context.lineWidth = outlineWidth;
        context.stroke();
        if (applyAlpha && color.alpha() < 1) {
            const pattern = context.createPattern(this.getCheckeredBackgroundPattern(), "repeat");
            context.beginPath();
            context.arc(x, y, radius - 3, startAngle, endAngle);
            context.fillStyle = pattern;
            context.fill();
        }
        context.globalCompositeOperation = "source-atop";
        context.beginPath();
        context.arc(x, y, radius - 3, startAngle, endAngle);
        const alpha = applyAlpha ? color.alpha() : 1;
        context.fillStyle = color.rgb().alpha(alpha).string();
        context.fill();
        context.globalCompositeOperation = "source-over";
    }
    drawActiveHueSliderColor() {
        const { color } = this;
        if (!color) {
            return;
        }
        const hsvColor = color.hsv().saturationv(100).value(100);
        const { dimensions: { slider: { width }, thumb: { radius }, }, } = this;
        const x = hsvColor.hue() / (HUE_LIMIT_CONSTRAINED / width);
        const y = radius;
        const sliderBoundX = this.getSliderBoundX(x, width, radius);
        requestAnimationFrame(() => {
            this.hueScopeLeft = sliderBoundX;
        });
        this.drawThumb(this.hueSliderRenderingContext, radius, sliderBoundX, y, hsvColor, false);
    }
    drawHueSlider() {
        const context = this.hueSliderRenderingContext;
        const { dimensions: { slider: { height, width }, thumb: { radius: thumbRadius }, }, } = this;
        const x = 0;
        const y = thumbRadius - height / 2;
        const gradient = context.createLinearGradient(0, 0, width, 0);
        const hueSliderColorStopKeywords = [
            "red",
            "yellow",
            "lime",
            "cyan",
            "blue",
            "magenta",
            "#ff0004" /* 1 unit less than #ff0 to avoid duplicate values within range */,
        ];
        const offset = 1 / (hueSliderColorStopKeywords.length - 1);
        let currentOffset = 0;
        hueSliderColorStopKeywords.forEach((keyword) => {
            gradient.addColorStop(currentOffset, color(keyword).string());
            currentOffset += offset;
        });
        context.clearRect(0, 0, width, height + this.getSliderCapSpacing() * 2);
        this.drawSliderPath(context, height, width, x, y);
        context.fillStyle = gradient;
        context.fill();
        context.strokeStyle = "rgba(0,0,0,0.3)";
        context.lineWidth = 1;
        context.stroke();
        this.drawActiveHueSliderColor();
    }
    drawOpacitySlider() {
        const context = this.opacitySliderRenderingContext;
        const { baseColorFieldColor: previousColor, dimensions: { slider: { height, width }, thumb: { radius: thumbRadius }, }, } = this;
        const x = 0;
        const y = thumbRadius - height / 2;
        context.clearRect(0, 0, width, height + this.getSliderCapSpacing() * 2);
        const gradient = context.createLinearGradient(0, y, width, 0);
        const startColor = previousColor.rgb().alpha(0);
        const midColor = previousColor.rgb().alpha(0.5);
        const endColor = previousColor.rgb().alpha(1);
        gradient.addColorStop(0, startColor.string());
        gradient.addColorStop(0.5, midColor.string());
        gradient.addColorStop(1, endColor.string());
        this.drawSliderPath(context, height, width, x, y);
        const pattern = context.createPattern(this.getCheckeredBackgroundPattern(), "repeat");
        context.fillStyle = pattern;
        context.fill();
        context.fillStyle = gradient;
        context.fill();
        context.strokeStyle = "rgba(0,0,0,0.3)";
        context.lineWidth = 1;
        context.stroke();
        this.drawActiveOpacitySliderColor();
    }
    drawSliderPath(context, height, width, x, y) {
        const radius = height / 2 + 1;
        context.beginPath();
        context.moveTo(x + radius, y);
        context.lineTo(x + width - radius, y);
        context.quadraticCurveTo(x + width, y, x + width, y + radius);
        context.lineTo(x + width, y + height - radius);
        context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        context.lineTo(x + radius, y + height);
        context.quadraticCurveTo(x, y + height, x, y + height - radius);
        context.lineTo(x, y + radius);
        context.quadraticCurveTo(x, y, x + radius, y);
        context.closePath();
    }
    getCheckeredBackgroundPattern() {
        if (this.checkerPattern) {
            return this.checkerPattern;
        }
        const pattern = document.createElement("canvas");
        pattern.width = 10;
        pattern.height = 10;
        const patternContext = pattern.getContext("2d");
        patternContext.fillStyle = "#ccc";
        patternContext.fillRect(0, 0, 10, 10);
        patternContext.fillStyle = "#fff";
        patternContext.fillRect(0, 0, 5, 5);
        patternContext.fillRect(5, 5, 5, 5);
        this.checkerPattern = pattern;
        return pattern;
    }
    drawActiveOpacitySliderColor() {
        const { color } = this;
        if (!color) {
            return;
        }
        const hsvColor = color;
        const { dimensions: { slider: { width }, thumb: { radius }, }, } = this;
        const x = alphaToOpacity(hsvColor.alpha()) / (OPACITY_LIMITS.max / width);
        const y = radius;
        const sliderBoundX = this.getSliderBoundX(x, width, radius);
        requestAnimationFrame(() => {
            this.opacityScopeLeft = sliderBoundX;
        });
        this.drawThumb(this.opacitySliderRenderingContext, radius, sliderBoundX, y, hsvColor, true);
    }
    getSliderBoundX(x, width, radius) {
        const closeToEdge = closeToRangeEdge(x, width, radius);
        return closeToEdge === 0
            ? x
            : closeToEdge === -1
                ? remap(x, 0, width, radius, radius * 2)
                : remap(x, 0, width, width - radius * 2, width - radius);
    }
    updateColorFromChannels(channels) {
        this.internalColorSet(color(channels, this.channelMode));
    }
    updateChannelsFromColor(color) {
        this.channels = color ? this.toChannels(color) : [null, null, null, null];
    }
    toChannels(color) {
        const { channelMode } = this;
        const channels = color[channelMode]()
            .array()
            .map((value, index) => {
            const isAlpha = index === 3;
            return isAlpha ? value : Math.floor(value);
        });
        if (channels.length === 3) {
            channels.push(1); // Color omits alpha when 1
        }
        return channels;
    }
    getAdjustedScopePosition(left, top) {
        return [left - SCOPE_SIZE / 2, top - SCOPE_SIZE / 2];
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "alphaChannel": ["handleAlphaChannelChange", "handleFormatOrAlphaChannelChange"],
        "color": ["handleColorChange"],
        "format": ["handleFormatOrAlphaChannelChange"],
        "scale": ["handleScaleChange"],
        "messageOverrides": ["onMessagesChange"],
        "value": ["handleValueChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return colorPickerCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-color-picker",
        "$members$": {
            "allowEmpty": [516, "allow-empty"],
            "alphaChannel": [4, "alpha-channel"],
            "channelsDisabled": [4, "channels-disabled"],
            "color": [1040],
            "disabled": [516],
            "format": [513],
            "hideChannels": [516, "hide-channels"],
            "hexDisabled": [4, "hex-disabled"],
            "hideHex": [516, "hide-hex"],
            "hideSaved": [516, "hide-saved"],
            "savedDisabled": [516, "saved-disabled"],
            "scale": [513],
            "storageId": [513, "storage-id"],
            "messageOverrides": [1040],
            "numberingSystem": [513, "numbering-system"],
            "value": [1025],
            "messages": [1040],
            "defaultMessages": [32],
            "channelMode": [32],
            "channels": [32],
            "dimensions": [32],
            "effectiveLocale": [32],
            "savedColors": [32],
            "colorFieldScopeTop": [32],
            "colorFieldScopeLeft": [32],
            "hueScopeLeft": [32],
            "opacityScopeLeft": [32],
            "scopeOrientation": [32],
            "setFocus": [64]
        },
        "$listeners$": [[2, "keydown", "handleChannelKeyUpOrDown"], [2, "keyup", "handleChannelKeyUpOrDown"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["allowEmpty", "allow-empty"], ["disabled", "disabled"], ["format", "format"], ["hideChannels", "hide-channels"], ["hideHex", "hide-hex"], ["hideSaved", "hide-saved"], ["savedDisabled", "saved-disabled"], ["scale", "scale"], ["storageId", "storage-id"], ["numberingSystem", "numbering-system"]]
    }; }
}

const CSS$16 = {
    container: "container",
    hexInput: "hex-input",
    opacityInput: "opacity-input",
};

const colorPickerHexInputCss = "/*!@:host*/.sc-calcite-color-picker-hex-input-h{display:block}/*!@.container*/.container.sc-calcite-color-picker-hex-input{display:flex;inline-size:100%;flex-wrap:nowrap;align-items:center}/*!@.hex-input*/.hex-input.sc-calcite-color-picker-hex-input{flex-grow:1;text-transform:uppercase}/*!@.opacity-input*/.opacity-input.sc-calcite-color-picker-hex-input{inline-size:68px;margin-inline-start:-1px}/*!@:host([scale=s]) .container*/[scale=s].sc-calcite-color-picker-hex-input-h .container.sc-calcite-color-picker-hex-input{flex-wrap:wrap;row-gap:0.125rem}/*!@:host([scale=s]) .opacity-input*/[scale=s].sc-calcite-color-picker-hex-input-h .opacity-input.sc-calcite-color-picker-hex-input{inline-size:unset;margin-inline-start:unset}/*!@:host([scale=l]) .opacity-input*/[scale=l].sc-calcite-color-picker-hex-input-h .opacity-input.sc-calcite-color-picker-hex-input{inline-size:88px}/*!@:host([hidden])*/[hidden].sc-calcite-color-picker-hex-input-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-color-picker-hex-input{display:none}";

const DEFAULT_COLOR = color();
class ColorPickerHexInput {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteColorPickerHexInputChange = createEvent(this, "calciteColorPickerHexInputChange", 6);
        this.onHexInputBlur = () => {
            const node = this.hexInputNode;
            const inputValue = node.value;
            const hex = `#${inputValue}`;
            const { allowEmpty, internalColor } = this;
            const willClearValue = allowEmpty && !inputValue;
            const isLonghand = isLonghandHex(hex);
            // ensure modified pasted hex values are committed since we prevent default to remove the # char.
            this.onHexInputChange();
            if (willClearValue || (isValidHex(hex) && isLonghand)) {
                return;
            }
            // manipulating DOM directly since rerender doesn't update input value
            node.value =
                allowEmpty && !internalColor
                    ? ""
                    : this.formatHexForInternalInput(rgbToHex(
                    // always display hex input in RRGGBB format
                    internalColor.object()));
        };
        this.onOpacityInputBlur = () => {
            const node = this.opacityInputNode;
            const inputValue = node.value;
            const { allowEmpty, internalColor } = this;
            const willClearValue = allowEmpty && !inputValue;
            if (willClearValue) {
                return;
            }
            // manipulating DOM directly since rerender doesn't update input value
            node.value =
                allowEmpty && !internalColor ? "" : this.formatOpacityForInternalInput(internalColor);
        };
        this.onHexInputChange = () => {
            const nodeValue = this.hexInputNode.value;
            let value = nodeValue;
            if (value) {
                const normalized = normalizeHex(value, false);
                const preserveExistingAlpha = isValidHex(normalized) && this.alphaChannel;
                if (preserveExistingAlpha && this.internalColor) {
                    const alphaHex = normalizeHex(this.internalColor.hexa(), true).slice(-2);
                    value = `${normalized + alphaHex}`;
                }
            }
            this.internalSetValue(value, this.value);
        };
        this.onOpacityInputChange = () => {
            const node = this.opacityInputNode;
            let value;
            if (!node.value) {
                value = node.value;
            }
            else {
                const alpha = opacityToAlpha(Number(node.value));
                value = this.internalColor?.alpha(alpha).hexa();
            }
            this.internalSetValue(value, this.value);
        };
        this.onInputKeyDown = (event) => {
            const { altKey, ctrlKey, metaKey, shiftKey } = event;
            const { alphaChannel, hexInputNode, internalColor, value } = this;
            const { key } = event;
            const composedPath = event.composedPath();
            if (key === "Tab" || key === "Enter") {
                if (composedPath.includes(hexInputNode)) {
                    this.onHexInputChange();
                }
                else {
                    this.onOpacityInputChange();
                }
                if (key === "Enter") {
                    event.preventDefault();
                }
                return;
            }
            const isNudgeKey = key === "ArrowDown" || key === "ArrowUp";
            const oldValue = this.value;
            if (isNudgeKey) {
                if (!value) {
                    this.internalSetValue(this.previousNonNullValue, oldValue);
                    event.preventDefault();
                    return;
                }
                const direction = key === "ArrowUp" ? 1 : -1;
                const bump = shiftKey ? 10 : 1;
                this.internalSetValue(hexify(this.nudgeRGBChannels(internalColor, bump * direction, composedPath.includes(hexInputNode) ? "rgb" : "a"), alphaChannel), oldValue);
                event.preventDefault();
                return;
            }
            const withModifiers = altKey || ctrlKey || metaKey;
            const singleChar = key.length === 1;
            const validHexChar = hexChar.test(key);
            if (singleChar && !withModifiers && !validHexChar) {
                event.preventDefault();
            }
        };
        this.onHexInputPaste = (event) => {
            const hex = event.clipboardData.getData("text");
            if (isValidHex(hex)) {
                event.preventDefault();
                this.hexInputNode.value = hex.slice(1);
            }
        };
        this.previousNonNullValue = this.value;
        this.storeHexInputRef = (node) => {
            this.hexInputNode = node;
        };
        this.storeOpacityInputRef = (node) => {
            this.opacityInputNode = node;
        };
        this.allowEmpty = false;
        this.alphaChannel = false;
        this.hexLabel = "Hex";
        this.messages = undefined;
        this.numberingSystem = undefined;
        this.scale = "m";
        this.value = normalizeHex(hexify(DEFAULT_COLOR, this.alphaChannel), this.alphaChannel, true);
        this.internalColor = DEFAULT_COLOR;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        const { allowEmpty, alphaChannel, value } = this;
        if (value) {
            const normalized = normalizeHex(value, alphaChannel);
            if (isValidHex(normalized, alphaChannel)) {
                this.internalSetValue(normalized, normalized, false);
            }
            return;
        }
        if (allowEmpty) {
            this.internalSetValue(null, null, false);
        }
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    handleValueChange(value, oldValue) {
        this.internalSetValue(value, oldValue, false);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    render() {
        const { alphaChannel, hexLabel, internalColor, messages, scale, value } = this;
        const hexInputValue = this.formatHexForInternalInput(value);
        const opacityInputValue = this.formatOpacityForInternalInput(internalColor);
        const inputScale = scale === "l" ? "m" : "s";
        return (hAsync("div", { class: CSS$16.container }, hAsync("calcite-input-text", { class: CSS$16.hexInput, label: messages?.hex || hexLabel, maxLength: 6, onCalciteInputTextChange: this.onHexInputChange, onCalciteInternalInputTextBlur: this.onHexInputBlur, onKeyDown: this.onInputKeyDown, onPaste: this.onHexInputPaste, prefixText: "#", scale: inputScale, value: hexInputValue,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeHexInputRef }), alphaChannel ? (hAsync("calcite-input-number", { class: CSS$16.opacityInput, key: "opacity-input", label: messages?.opacity, max: OPACITY_LIMITS.max, maxLength: 3, min: OPACITY_LIMITS.min, numberButtonType: "none", numberingSystem: this.numberingSystem, onCalciteInputNumberChange: this.onOpacityInputChange, onCalciteInternalInputNumberBlur: this.onOpacityInputBlur, onKeyDown: this.onInputKeyDown, scale: inputScale, suffixText: "%", value: opacityInputValue,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeOpacityInputRef })) : null));
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        return focusElement(this.hexInputNode);
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    internalSetValue(value, oldValue, emit = true) {
        if (value) {
            const { alphaChannel } = this;
            const normalized = normalizeHex(value, alphaChannel, alphaChannel);
            if (isValidHex(normalized, alphaChannel)) {
                const { internalColor: currentColor } = this;
                const nextColor = color(normalized);
                const normalizedLonghand = normalizeHex(hexify(nextColor, alphaChannel), alphaChannel);
                const changed = !currentColor ||
                    normalizedLonghand !== normalizeHex(hexify(currentColor, alphaChannel), alphaChannel);
                this.internalColor = nextColor;
                this.previousNonNullValue = normalizedLonghand;
                this.value = normalizedLonghand;
                if (changed && emit) {
                    this.calciteColorPickerHexInputChange.emit();
                }
                return;
            }
        }
        else if (this.allowEmpty) {
            this.internalColor = null;
            this.value = null;
            if (emit) {
                this.calciteColorPickerHexInputChange.emit();
            }
            return;
        }
        this.value = oldValue;
    }
    formatHexForInternalInput(hex) {
        return hex ? hex.replace("#", "").slice(0, 6) : "";
    }
    formatOpacityForInternalInput(color) {
        return color ? `${alphaToOpacity(color.alpha())}` : "";
    }
    nudgeRGBChannels(color$1, amount, context) {
        let nudgedChannels;
        const channels = color$1.array();
        const rgbChannels = channels.slice(0, 3);
        if (context === "rgb") {
            const nudgedRGBChannels = rgbChannels.map((channel) => channel + amount);
            nudgedChannels = [
                ...nudgedRGBChannels,
                this.alphaChannel ? channels[3] : undefined,
            ];
        }
        else {
            const nudgedAlpha = opacityToAlpha(alphaToOpacity(color$1.alpha()) + amount);
            nudgedChannels = [...rgbChannels, nudgedAlpha];
        }
        return color(nudgedChannels);
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "value": ["handleValueChange"]
    }; }
    static get style() { return colorPickerHexInputCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-color-picker-hex-input",
        "$members$": {
            "allowEmpty": [4, "allow-empty"],
            "alphaChannel": [4, "alpha-channel"],
            "hexLabel": [1, "hex-label"],
            "messages": [16],
            "numberingSystem": [1, "numbering-system"],
            "scale": [513],
            "value": [1537],
            "internalColor": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["scale", "scale"], ["value", "value"]]
    }; }
}

const CSS$15 = {
    swatch: "swatch",
    noColorSwatch: "swatch--no-color",
    checker: "checker",
};
const COLORS = {
    borderLight: "rgba(0, 0, 0, 0.3)",
    borderDark: "rgba(255, 255, 255, 0.15)",
};
const checkerSquareSize = 4;
const CHECKER_DIMENSIONS = {
    squareSize: checkerSquareSize,
    size: checkerSquareSize * 2,
};

const colorPickerSwatchCss = "/*!@:host*/.sc-calcite-color-picker-swatch-h{position:relative;display:inline-flex}/*!@:host([scale=s])*/[scale=s].sc-calcite-color-picker-swatch-h{block-size:1.25rem;inline-size:1.25rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-color-picker-swatch-h{block-size:1.5rem;inline-size:1.5rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-color-picker-swatch-h{block-size:2rem;inline-size:2rem}/*!@.swatch*/.swatch.sc-calcite-color-picker-swatch{overflow:hidden;block-size:inherit;inline-size:inherit}/*!@.swatch rect*/.swatch.sc-calcite-color-picker-swatch rect.sc-calcite-color-picker-swatch{transition-property:all;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}/*!@.swatch--no-color rect*/.swatch--no-color.sc-calcite-color-picker-swatch rect.sc-calcite-color-picker-swatch{fill:var(--calcite-color-foreground-1)}/*!@.swatch--no-color line*/.swatch--no-color.sc-calcite-color-picker-swatch line.sc-calcite-color-picker-swatch{stroke:var(--calcite-color-status-danger)}/*!@.checker*/.checker.sc-calcite-color-picker-swatch{fill:#cacaca}/*!@:host([hidden])*/[hidden].sc-calcite-color-picker-swatch-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-color-picker-swatch{display:none}";

class ColorPickerSwatch {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.active = false;
        this.color = undefined;
        this.scale = "m";
    }
    handleColorChange(color$1) {
        this.internalColor = color$1 ? color(color$1) : null;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentWillLoad() {
        this.handleColorChange(this.color);
    }
    render() {
        const isEmpty = !this.internalColor;
        const classes = {
            [CSS$15.swatch]: true,
            [CSS$15.noColorSwatch]: isEmpty,
        };
        return (hAsync("svg", { class: classes, xmlns: "http://www.w3.org/2000/svg" }, this.renderSwatch()));
    }
    renderSwatch() {
        const { active, el, internalColor } = this;
        const borderRadius = active ? "100%" : "0";
        const theme = getModeName(el);
        const borderColor = theme === "light" ? COLORS.borderLight : COLORS.borderDark;
        const commonSwatchProps = {
            height: "100%",
            rx: borderRadius,
            stroke: borderColor,
            // stroke-width and clip-path are needed to hide overflowing portion of stroke
            // see https://stackoverflow.com/a/7273346/194216
            // using attribute to work around Stencil using the prop name vs the attribute when rendering
            ["stroke-width"]: "2",
            width: "100%",
        };
        const isEmpty = !internalColor;
        if (isEmpty) {
            return (hAsync(Fragment, null, hAsync("clipPath", { id: "shape" }, hAsync("rect", { height: "100%", rx: borderRadius, width: "100%" })), hAsync("rect", { "clip-path": `inset(0 round ${borderRadius})`, rx: borderRadius, ...commonSwatchProps }), hAsync("line", { "clip-path": "url(#shape)", "stroke-width": "3", x1: "100%", x2: "0", y1: "0", y2: "100%" })));
        }
        const alpha = internalColor.alpha();
        const hex = hexify(internalColor);
        const hexa = hexify(internalColor, alpha < 1);
        return (hAsync(Fragment, null, hAsync("title", null, hexa), hAsync("defs", null, hAsync("pattern", { height: CHECKER_DIMENSIONS.size, id: "checker", patternUnits: "userSpaceOnUse", width: CHECKER_DIMENSIONS.size, x: "0", y: "0" }, hAsync("rect", { class: CSS$15.checker, height: CHECKER_DIMENSIONS.squareSize, width: CHECKER_DIMENSIONS.squareSize, x: "0", y: "0" }), hAsync("rect", { class: CSS$15.checker, height: CHECKER_DIMENSIONS.squareSize, width: CHECKER_DIMENSIONS.squareSize, x: CHECKER_DIMENSIONS.squareSize, y: CHECKER_DIMENSIONS.squareSize }))), hAsync("rect", { fill: "url(#checker)", height: "100%", rx: borderRadius, width: "100%" }), hAsync("rect", { fill: hex, style: {
                "clip-path": alpha < 1 ? "polygon(100% 0, 0 0, 0 100%)" : `inset(0 round ${borderRadius})`,
            }, ...commonSwatchProps }), alpha < 1 ? (hAsync("rect", { fill: hexa, key: "opacity-fill", style: { "clip-path": "polygon(100% 0, 100% 100%, 0 100%)" }, ...commonSwatchProps })) : null));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "color": ["handleColorChange"]
    }; }
    static get style() { return colorPickerSwatchCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-color-picker-swatch",
        "$members$": {
            "active": [516],
            "color": [1],
            "scale": [513]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["active", "active"], ["scale", "scale"]]
    }; }
}

const filter = (data, value) => {
    const escapedValue = escapeRegExp(value);
    const regex = new RegExp(escapedValue, "i");
    if (data.length === 0) {
        console.warn(`No data was passed to the filter function.
    The data argument should be an array of objects`);
    }
    const find = (input, RE) => {
        if (input?.constant || input?.filterDisabled) {
            return true;
        }
        let found = false;
        forIn(input, (val) => {
            if (typeof val === "function" || val == null /* intentional == to catch undefined */) {
                return;
            }
            if (Array.isArray(val) || (typeof val === "object" && val !== null)) {
                if (find(val, RE)) {
                    found = true;
                }
            }
            else if (RE.test(val)) {
                found = true;
            }
        });
        return found;
    };
    const result = data.filter((item) => {
        return find(item, regex);
    });
    return result;
};

/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */

const sides = ['top', 'right', 'bottom', 'left'];
const alignments = ['start', 'end'];
const placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const createCoords = v => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getOppositeAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
  return axis === 'y' ? 'height' : 'width';
}
function getSideAxis(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === 'y';
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow$1 = options => ({
  name: 'arrow',
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    // Since `element` is required, we don't Partial<> the type.
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === 'y';
    const minProp = isYAxis ? 'top' : 'left';
    const maxProp = isYAxis ? 'bottom' : 'right';
    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

    // DOM platform can return `window` as the `offsetParent`.
    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // If the padding is large enough that it causes the arrow to no longer be
    // centered, modify the padding so that it is centered.
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds.
    const min$1 = minPadding;
    const max = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = clamp(min$1, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. To ensure `shift()` continues to take action,
    // a single reset is performed when this is true.
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset
        })
      },
      reset: shouldAddOffset
    };
  }
});

function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter(placement => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'autoPlacement',
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

      // Make `computeCoords` start from the right place.
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];

      // There are more placements to check.
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map(d => {
        const alignment = getAlignment(d.placement);
        return [d.placement, alignment && crossAxis ?
        // Check along the mainAxis and main crossAxis side.
        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :
        // Check only the mainAxis.
        d.overflows[0], d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,
      // Aligned placements should not check their opposite crossAxis
      // side.
      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);

      // If a reset by the arrow was caused due to an alignment offset being
      // added, we should skip any logic now since `flip()` has already done its
      // work.
      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle.
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$map$so;
                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some(side => overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'hide',
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = 'referenceHidden',
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
        case 'escaped':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
        default:
          {
            return {};
          }
      }
    }
  };
};

// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.

async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === 'y';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: 'offset',
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);

      // If the placement is the same and the arrow caused an alignment offset
      // then we don't need to change the positioning coordinates.
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};

function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || '').toLowerCase();
  }
  // Mocked nodes in testing environments may not be instances of Node. By
  // returning `#document` an infinite loop won't occur.
  // https://github.com/floating-ui/floating-ui/issues/2317
  return '#document';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  // Browsers without `ShadowRoot` support.
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle$1(element);

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  // In testing environments, the `width` and `height` properties are empty
  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}

function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}

function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

const noOffsets = /*#__PURE__*/createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}

const topLayerSelectors = [':popover-open', ':modal'];
function isTopLayer(floating) {
  return topLayerSelectors.some(selector => {
    try {
      return floating.matches(selector);
    } catch (e) {
      return false;
    }
  });
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === 'fixed';
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}

function getClientRects(element) {
  return Array.from(element.getClientRects());
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === 'rtl') {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';
  let currentNode = elementIsFixed ? getParentNode(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === 'fixed';
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x = rect.left + scroll.scrollLeft - offsets.x;
  const y = rect.top + scroll.scrollTop - offsets.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}

function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const window = getWindow(element);
  if (!isHTMLElement(element) || isTopLayer(element)) {
    return window;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}

const getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      ...(await getDimensionsFn(data.floating))
    }
  };
};

function isRTL(element) {
  return getComputedStyle$1(element).direction === 'rtl';
}

const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};

/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = autoPlacement$1;

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = shift$1;

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = flip$1;

/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = hide$1;

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = arrow$1;

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

function roundByDPR(value) {
    const dpr = window.devicePixelRatio || 1;
    return Math.round(value * dpr) / dpr;
}
/**
 * Positions the floating element relative to the reference element.
 *
 * **Note:** exported for testing purposes only
 *
 * @param root0
 * @param root0.referenceEl
 * @param root0.floatingEl
 * @param root0.overlayPositioning
 * @param root0.placement
 * @param root0.flipDisabled
 * @param root0.flipPlacements
 * @param root0.offsetDistance
 * @param root0.offsetSkidding
 * @param root0.arrowEl
 * @param root0.type
 * @param component
 * @param root0.referenceEl.referenceEl
 * @param root0.referenceEl.floatingEl
 * @param root0.referenceEl.overlayPositioning
 * @param root0.referenceEl.placement
 * @param root0.referenceEl.flipDisabled
 * @param root0.referenceEl.flipPlacements
 * @param root0.referenceEl.offsetDistance
 * @param root0.referenceEl.offsetSkidding
 * @param root0.referenceEl.arrowEl
 * @param root0.referenceEl.type
 * @param component.referenceEl
 * @param component.floatingEl
 * @param component.overlayPositioning
 * @param component.placement
 * @param component.flipDisabled
 * @param component.flipPlacements
 * @param component.offsetDistance
 * @param component.offsetSkidding
 * @param component.arrowEl
 * @param component.type
 */
const positionFloatingUI = 
/* we export arrow function to allow us to spy on it during testing */
async (component, { referenceEl, floatingEl, overlayPositioning = "absolute", placement, flipDisabled, flipPlacements, offsetDistance, offsetSkidding, arrowEl, type, }) => {
    if (!referenceEl || !floatingEl) {
        return null;
    }
    const { x, y, placement: effectivePlacement, strategy: position, middlewareData, } = await computePosition(referenceEl, floatingEl, {
        strategy: overlayPositioning,
        placement: placement === "auto" || placement === "auto-start" || placement === "auto-end"
            ? undefined
            : getEffectivePlacement(floatingEl, placement),
        middleware: getMiddleware({
            placement,
            flipDisabled,
            flipPlacements,
            offsetDistance,
            offsetSkidding,
            arrowEl,
            type,
        }),
    });
    if (arrowEl && middlewareData.arrow) {
        const { x, y } = middlewareData.arrow;
        const side = effectivePlacement.split("-")[0];
        const alignment = x != null ? "left" : "top";
        const transform = ARROW_CSS_TRANSFORM[side];
        const reset = { left: "", top: "", bottom: "", right: "" };
        if ("floatingLayout" in component) {
            component.floatingLayout = side === "left" || side === "right" ? "horizontal" : "vertical";
        }
        Object.assign(arrowEl.style, {
            ...reset,
            [alignment]: `${alignment == "left" ? x : y}px`,
            [side]: "100%",
            transform,
        });
    }
    const referenceHidden = middlewareData.hide?.referenceHidden;
    const visibility = referenceHidden ? "hidden" : null;
    const pointerEvents = visibility ? "none" : null;
    floatingEl.setAttribute(placementDataAttribute, effectivePlacement);
    const { open } = component;
    Object.assign(floatingEl.style, {
        visibility,
        pointerEvents,
        position,
        transform: open ? `translate(${roundByDPR(x)}px,${roundByDPR(y)}px)` : "",
        top: 0,
        left: 0,
    });
};
/**
 * Exported for testing purposes only
 */
const placementDataAttribute = "data-placement";
/**
 * Exported for testing purposes only
 */
const repositionDebounceTimeout = 100;
const effectivePlacements = [
    "top",
    "bottom",
    "right",
    "left",
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "right-start",
    "right-end",
    "left-start",
    "left-end",
];
const defaultMenuPlacement = "bottom-start";
const FloatingCSS = {
    animation: "calcite-floating-ui-anim",
    animationActive: "calcite-floating-ui-anim--active",
};
function getMiddleware({ placement, flipDisabled, flipPlacements, offsetDistance, offsetSkidding, arrowEl, type, }) {
    const defaultMiddleware = [shift(), hide()];
    if (type === "menu") {
        return [
            ...defaultMiddleware,
            flip({
                fallbackPlacements: flipPlacements || ["top-start", "top", "top-end", "bottom-start", "bottom", "bottom-end"],
            }),
        ];
    }
    if (type === "popover" || type === "tooltip") {
        const middleware = [
            ...defaultMiddleware,
            offset({
                mainAxis: typeof offsetDistance === "number" ? offsetDistance : 0,
                crossAxis: typeof offsetSkidding === "number" ? offsetSkidding : 0,
            }),
        ];
        if (placement === "auto" || placement === "auto-start" || placement === "auto-end") {
            middleware.push(autoPlacement({ alignment: placement === "auto-start" ? "start" : placement === "auto-end" ? "end" : null }));
        }
        else if (!flipDisabled) {
            middleware.push(flip(flipPlacements ? { fallbackPlacements: flipPlacements } : {}));
        }
        if (arrowEl) {
            middleware.push(arrow({
                element: arrowEl,
            }));
        }
        return middleware;
    }
    return [];
}
function filterComputedPlacements(placements, el) {
    const filteredPlacements = placements.filter((placement) => effectivePlacements.includes(placement));
    if (filteredPlacements.length !== placements.length) {
        console.warn(`${el.tagName}: Invalid value found in: flipPlacements. Try any of these: ${effectivePlacements
            .map((placement) => `"${placement}"`)
            .join(", ")
            .trim()}`, { el });
    }
    return filteredPlacements;
}
function getEffectivePlacement(floatingEl, placement) {
    const placements = ["left", "right"];
    if (getElementDir(floatingEl) === "rtl") {
        placements.reverse();
    }
    return placement.replace(/leading/gi, placements[0]).replace(/trailing/gi, placements[1]);
}
/**
 * Convenience function to manage `reposition` calls for FloatingUIComponents that use `positionFloatingUI.
 *
 * Note: this is not needed for components that use `calcite-popover`.
 *
 * @param component - A floating-ui component.
 * @param options - Reposition parameters.
 * @param options.referenceEl - The `referenceElement` used to position the component according to its `placement` value.
 * @param options.floatingEl - The `floatingElement` containing the floating ui.
 * @param options.overlayPositioning - type of positioning to use for the overlaid content.
 * @param options.placement - Determines where the component will be positioned relative to the `referenceElement`.
 * @param options.flipDisabled - Prevents flipping the component's placement when overlapping its `referenceElement`.
 * @param options.flipPlacements - Defines the available placements that can be used when a flip occurs.
 * @param options.offsetDistance - Offsets the position of the popover away from the `referenceElement`.
 * @param options.offsetSkidding - Offsets the position of the component along the `referenceElement`.
 * @param options.arrowEl - A customizable arrow element.
 * @param options.type - The type of floating UI.
 * @param delayed - Reposition the component after a delay.
 * @returns {Promise<void>}
 */
async function reposition(component, options, delayed = false) {
    if (!component.open) {
        return;
    }
    const positionFunction = delayed ? getDebouncedReposition(component) : positionFloatingUI;
    return positionFunction(component, options);
}
function getDebouncedReposition(component) {
    let debounced = componentToDebouncedRepositionMap.get(component);
    if (debounced) {
        return debounced;
    }
    debounced = debounce(positionFloatingUI, repositionDebounceTimeout, {
        leading: true,
        maxWait: repositionDebounceTimeout,
    });
    componentToDebouncedRepositionMap.set(component, debounced);
    return debounced;
}
const ARROW_CSS_TRANSFORM = {
    top: "",
    left: "rotate(-90deg)",
    bottom: "rotate(180deg)",
    right: "rotate(90deg)",
};
/**
 * Exported for testing purposes only
 *
 * @internal
 */
const cleanupMap = new WeakMap();
const componentToDebouncedRepositionMap = new WeakMap();
/**
 * Helper to set up floating element interactions on connectedCallback.
 *
 * @param component - A floating-ui component.
 * @param referenceEl - The `referenceElement` used to position the component according to its `placement` value.
 * @param floatingEl - The `floatingElement` containing the floating ui.
 */
function connectFloatingUI(component, referenceEl, floatingEl) {
    if (!floatingEl || !referenceEl) {
        return;
    }
    disconnectFloatingUI(component, referenceEl, floatingEl);
    Object.assign(floatingEl.style, {
        visibility: "hidden",
        pointerEvents: "none",
        // initial positioning based on https://floating-ui.com/docs/computePosition#initial-layout
        position: component.overlayPositioning,
    });
    const runAutoUpdate = (_refEl, _floatingEl, updateCallback) => {
            updateCallback();
            return () => {
                /* noop */
            };
        };
    cleanupMap.set(component, runAutoUpdate(referenceEl, floatingEl, () => component.reposition()));
}
/**
 * Helper to tear down floating element interactions on disconnectedCallback.
 *
 * @param component - A floating-ui component.
 * @param referenceEl - The `referenceElement` used to position the component according to its `placement` value.
 * @param floatingEl - The `floatingElement` containing the floating ui.
 */
function disconnectFloatingUI(component, referenceEl, floatingEl) {
    if (!floatingEl || !referenceEl) {
        return;
    }
    cleanupMap.get(component)?.();
    cleanupMap.delete(component);
    componentToDebouncedRepositionMap.get(component)?.cancel();
    componentToDebouncedRepositionMap.delete(component);
}
const visiblePointerSize = 4;
/**
 * Default offset the position of the floating element away from the reference element.
 *
 * @default 6
 */
const defaultOffsetDistance = Math.ceil(Math.hypot(visiblePointerSize, visiblePointerSize));

const ComboboxItem$1 = "CALCITE-COMBOBOX-ITEM";
const ComboboxItemGroup$1 = "CALCITE-COMBOBOX-ITEM-GROUP";
const ComboboxChildSelector = `${ComboboxItem$1}, ${ComboboxItemGroup$1}`;
const CSS$14 = {
    chipInvisible: "chip--invisible",
    selectionDisplayFit: "selection-display-fit",
    selectionDisplaySingle: "selection-display-single",
    listContainer: "list-container",
};

function getAncestors(element) {
    const parent = element.parentElement?.closest(ComboboxChildSelector);
    const grandparent = parent?.parentElement?.closest(ComboboxChildSelector);
    return [parent, grandparent].filter((el) => el);
}
function getItemAncestors(item) {
    return (item.ancestors?.filter((el) => el.nodeName === "CALCITE-COMBOBOX-ITEM") || []);
}
function getItemChildren(item) {
    return nodeListToArray(item.querySelectorAll("calcite-combobox-item"));
}
function hasActiveChildren(node) {
    const items = nodeListToArray(node.querySelectorAll("calcite-combobox-item"));
    return items.filter((item) => item.selected).length > 0;
}
function getDepth$1(element) {
    {
        return 0;
    }
}
function isSingleLike(selectionMode) {
    return selectionMode.includes("single");
}

const CSS$13 = {
    button: "x-button",
};
function XButton({ disabled, key, label, onClick, ref, scale, }) {
    return (hAsync("button", { "aria-label": label, class: CSS$13.button, disabled: disabled, key: key, onClick: onClick, tabIndex: -1, type: "button", 
        // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
        ref: ref },
        hAsync("calcite-icon", { icon: "x", scale: getIconScale(scale) })));
}

/**
 * Do not edit directly
 * Generated on Tue, 27 Feb 2024 18:51:10 GMT
 */
const calciteSize48 = "48px";

const CSS$12 = {
    validationContainer: "validation-container",
};
const Validation = ({ scale, status, icon, message, }) => (hAsync("div", { class: CSS$12.validationContainer },
    hAsync("calcite-input-message", { icon: icon, scale: scale, status: status }, message)));

const comboboxCss = "/*!@:host([disabled])*/[disabled].sc-calcite-combobox-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-combobox-h *.sc-calcite-combobox,.sc-calcite-combobox-h[disabled].sc-calcite-combobox-s>*,.sc-calcite-combobox-h[disabled] .sc-calcite-combobox-s>*{pointer-events:none}/*!@:host*/.sc-calcite-combobox-h{position:relative;display:block}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-combobox-h[disabled] .sc-calcite-combobox-s>[calcite-hydrated][disabled],[disabled].sc-calcite-combobox-h [calcite-hydrated][disabled].sc-calcite-combobox{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-combobox{display:contents}/*!@:host([scale=s]) .x-button*/[scale=s].sc-calcite-combobox-h .x-button.sc-calcite-combobox{inline-size:1rem;block-size:1rem}/*!@:host([scale=m]) .x-button*/[scale=m].sc-calcite-combobox-h .x-button.sc-calcite-combobox{inline-size:1.5rem;block-size:1.5rem}/*!@:host([scale=l]) .x-button*/[scale=l].sc-calcite-combobox-h .x-button.sc-calcite-combobox{inline-size:2rem;block-size:2rem}/*!@.x-button*/.x-button.sc-calcite-combobox{margin:0px;display:flex;cursor:pointer;appearance:none;align-content:center;align-items:center;justify-content:center;align-self:center;border-width:2px;background-color:transparent;color:var(--calcite-color-text-3);outline-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;border-radius:50%;border-color:transparent;background-color:var(--calcite-color-foreground-2)}/*!@.x-button:active, .x-button:hover*/.x-button.sc-calcite-combobox:active,.x-button.sc-calcite-combobox:hover{color:var(--calcite-color-text-1);background-color:var(--calcite-color-foreground-3)}/*!@.x-button:active*/.x-button.sc-calcite-combobox:active{border-style:solid;border-color:var(--calcite-color-brand)}/*!@.x-button calcite-icon*/.x-button.sc-calcite-combobox calcite-icon.sc-calcite-combobox{color:inherit}/*!@:host([scale=s])*/[scale=s].sc-calcite-combobox-h{font-size:var(--calcite-font-size--2);--calcite-combobox-item-spacing-unit-l:0.5rem;--calcite-combobox-item-spacing-unit-s:0.25rem;--calcite-combobox-input-height:1rem;--calcite-internal-combobox-input-margin-block:calc(0.25rem - 1px)}/*!@:host([scale=s]) .x-button*/[scale=s].sc-calcite-combobox-h .x-button.sc-calcite-combobox{margin-inline:0.5rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-combobox-h{font-size:var(--calcite-font-size--1);--calcite-combobox-item-spacing-unit-l:0.75rem;--calcite-combobox-item-spacing-unit-s:0.5rem;--calcite-combobox-input-height:1rem;--calcite-internal-combobox-input-margin-block:calc(0.5rem - 1px)}/*!@:host([scale=m]) .x-button*/[scale=m].sc-calcite-combobox-h .x-button.sc-calcite-combobox{margin-inline-end:0.75rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-combobox-h{font-size:var(--calcite-font-size-0);--calcite-combobox-item-spacing-unit-l:1rem;--calcite-combobox-item-spacing-unit-s:0.75rem;--calcite-combobox-input-height:1.5rem;--calcite-internal-combobox-input-margin-block:calc(0.625rem - 1px)}/*!@:host([scale=l]) .x-button*/[scale=l].sc-calcite-combobox-h .x-button.sc-calcite-combobox{margin-inline-end:1rem}/*!@.wrapper*/.wrapper.sc-calcite-combobox{display:flex;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-1);outline-color:transparent;padding-block:calc(var(--calcite-combobox-item-spacing-unit-s) / 4);padding-inline:var(--calcite-combobox-item-spacing-unit-l)}/*!@:host(:focus-within) .wrapper,\n.wrapper--active*/.sc-calcite-combobox-h:focus-within .wrapper.sc-calcite-combobox,.wrapper--active.sc-calcite-combobox{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([status=invalid]) .wrapper*/[status=invalid].sc-calcite-combobox-h .wrapper.sc-calcite-combobox{border-color:var(--calcite-color-status-danger)}/*!@:host([status=invalid]:focus-within) .wrapper*/[status=invalid].sc-calcite-combobox-h:focus-within .wrapper.sc-calcite-combobox{outline:2px solid var(--calcite-color-status-danger);outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.wrapper--single*/.wrapper--single.sc-calcite-combobox{padding-block:0;padding-inline:var(--calcite-combobox-item-spacing-unit-l);cursor:pointer;flex-wrap:nowrap}/*!@.grid-input*/.grid-input.sc-calcite-combobox{position:relative;display:flex;flex-grow:1;flex-wrap:wrap;align-items:center;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding:0px;gap:var(--calcite-combobox-item-spacing-unit-s);margin-inline-end:var(--calcite-combobox-item-spacing-unit-s)}/*!@.grid-input.selection-display-fit, .grid-input.selection-display-single*/.grid-input.selection-display-fit.sc-calcite-combobox,.grid-input.selection-display-single.sc-calcite-combobox{flex-wrap:nowrap;overflow:hidden}/*!@.input*/.input.sc-calcite-combobox{flex-grow:1;appearance:none;overflow:hidden;text-overflow:ellipsis;border-style:none;background-color:transparent;padding:0px;font-family:inherit;color:var(--calcite-color-text-1);font-size:inherit;block-size:var(--calcite-combobox-input-height);line-height:var(--calcite-combobox-input-height);inline-size:100%;margin-block-end:var(--calcite-combobox-item-spacing-unit-s);min-inline-size:4.8125rem}/*!@.input:focus*/.input.sc-calcite-combobox:focus{outline:2px solid transparent;outline-offset:2px}/*!@.input:placeholder-shown*/.input.sc-calcite-combobox:placeholder-shown{text-overflow:ellipsis}/*!@.input--transparent*/.input--transparent.sc-calcite-combobox{opacity:0}/*!@.input--single*/.input--single.sc-calcite-combobox{padding:0px;margin-block:var(--calcite-internal-combobox-input-margin-block)}/*!@.wrapper--active .input-single*/.wrapper--active.sc-calcite-combobox .input-single.sc-calcite-combobox{cursor:text}/*!@.input--hidden*/.input--hidden.sc-calcite-combobox{pointer-events:none;inline-size:0px;min-inline-size:0px;opacity:0}/*!@.input--icon*/.input--icon.sc-calcite-combobox{padding-block:0;padding-inline:var(--calcite-combobox-item-spacing-unit-l)}/*!@.input-wrap*/.input-wrap.sc-calcite-combobox{display:flex;flex-grow:1;align-items:center}/*!@.input-wrap--single*/.input-wrap--single.sc-calcite-combobox{flex:1 1 0%;overflow:hidden}/*!@.label*/.label.sc-calcite-combobox{pointer-events:none;max-inline-size:100%;flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding:0px;font-weight:var(--calcite-font-weight-normal);block-size:var(--calcite-combobox-input-height);line-height:var(--calcite-combobox-input-height)}/*!@.label--icon*/.label--icon.sc-calcite-combobox{padding-inline:var(--calcite-combobox-item-spacing-unit-l)}/*!@.icon-end,\n.icon-start*/.icon-end.sc-calcite-combobox,.icon-start.sc-calcite-combobox{display:flex;cursor:pointer;align-items:center}/*!@.icon-end*/.icon-end.sc-calcite-combobox{flex:none}/*!@.floating-ui-container*/.floating-ui-container.sc-calcite-combobox{--calcite-floating-ui-z-index:var(--calcite-z-index-dropdown);display:block;position:absolute;z-index:var(--calcite-floating-ui-z-index);visibility:hidden}/*!@.floating-ui-container .calcite-floating-ui-anim*/.floating-ui-container.sc-calcite-combobox .calcite-floating-ui-anim.sc-calcite-combobox{position:relative;transition:var(--calcite-floating-ui-transition);transition-property:transform, visibility, opacity;opacity:0;box-shadow:0 0 16px 0 rgba(0, 0, 0, 0.16);z-index:var(--calcite-z-index);border-radius:0.25rem}/*!@.floating-ui-container[data-placement^=bottom] .calcite-floating-ui-anim*/.floating-ui-container[data-placement^=bottom].sc-calcite-combobox .calcite-floating-ui-anim.sc-calcite-combobox{transform:translateY(-5px)}/*!@.floating-ui-container[data-placement^=top] .calcite-floating-ui-anim*/.floating-ui-container[data-placement^=top].sc-calcite-combobox .calcite-floating-ui-anim.sc-calcite-combobox{transform:translateY(5px)}/*!@.floating-ui-container[data-placement^=left] .calcite-floating-ui-anim*/.floating-ui-container[data-placement^=left].sc-calcite-combobox .calcite-floating-ui-anim.sc-calcite-combobox{transform:translateX(5px)}/*!@.floating-ui-container[data-placement^=right] .calcite-floating-ui-anim*/.floating-ui-container[data-placement^=right].sc-calcite-combobox .calcite-floating-ui-anim.sc-calcite-combobox{transform:translateX(-5px)}/*!@.floating-ui-container[data-placement] .calcite-floating-ui-anim--active*/.floating-ui-container[data-placement].sc-calcite-combobox .calcite-floating-ui-anim--active.sc-calcite-combobox{opacity:1;transform:translate(0)}/*!@.floating-ui-container--active*/.floating-ui-container--active.sc-calcite-combobox{visibility:visible}@media (forced-colors: active){/*!@.wrapper,\n  .floating-ui-container--active*/.wrapper.sc-calcite-combobox,.floating-ui-container--active.sc-calcite-combobox{border:1px solid canvasText}}/*!@.screen-readers-only*/.screen-readers-only.sc-calcite-combobox{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}/*!@.list-container*/.list-container.sc-calcite-combobox{max-block-size:45vh;overflow-y:auto;background-color:var(--calcite-color-foreground-1);inline-size:var(--calcite-dropdown-width)}/*!@.list*/.list.sc-calcite-combobox{margin:0px;display:block;padding:0px}/*!@.list--hide*/.list--hide.sc-calcite-combobox{block-size:0px;overflow:hidden}/*!@calcite-chip*/calcite-chip.sc-calcite-combobox{--calcite-animation-timing:0}/*!@.chip*/.chip.sc-calcite-combobox{margin-block:calc(var(--calcite-combobox-item-spacing-unit-s) / 4);max-inline-size:100%}/*!@.chip--active*/.chip--active.sc-calcite-combobox{background-color:var(--calcite-color-foreground-3)}/*!@.chip--invisible*/.chip--invisible.sc-calcite-combobox{visibility:hidden;position:absolute}/*!@.item*/.item.sc-calcite-combobox{display:block}/*!@.validation-container*/.validation-container.sc-calcite-combobox{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}/*!@:host([scale=m]) .validation-container,\n:host([scale=l]) .validation-container*/[scale=m].sc-calcite-combobox-h .validation-container.sc-calcite-combobox,[scale=l].sc-calcite-combobox-h .validation-container.sc-calcite-combobox{padding-block-start:0.5rem}/*!@:host([scale=s]) .validation-container*/[scale=s].sc-calcite-combobox-h .validation-container.sc-calcite-combobox{padding-block-start:0.25rem}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-combobox-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([hidden])*/[hidden].sc-calcite-combobox-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-combobox{display:none}/*!@::slotted(calcite-combobox-item-group:not(:first-child))*/.sc-calcite-combobox-s>calcite-combobox-item-group:not(:first-child){padding-block-start:var(--calcite-combobox-item-spacing-unit-l)}";

const isGroup = (el) => el.tagName === ComboboxItemGroup$1;
const itemUidPrefix = "combobox-item-";
const chipUidPrefix = "combobox-chip-";
const labelUidPrefix = "combobox-label-";
const listboxUidPrefix = "combobox-listbox-";
const inputUidPrefix = "combobox-input-";
/**
 * @slot - A slot for adding `calcite-combobox-item`s.
 */
class Combobox {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteComboboxChange = createEvent(this, "calciteComboboxChange", 6);
        this.calciteComboboxFilterChange = createEvent(this, "calciteComboboxFilterChange", 6);
        this.calciteComboboxChipClose = createEvent(this, "calciteComboboxChipClose", 6);
        this.calciteComboboxBeforeClose = createEvent(this, "calciteComboboxBeforeClose", 6);
        this.calciteComboboxClose = createEvent(this, "calciteComboboxClose", 6);
        this.calciteComboboxBeforeOpen = createEvent(this, "calciteComboboxBeforeOpen", 6);
        this.calciteComboboxOpen = createEvent(this, "calciteComboboxOpen", 6);
        this.placement = defaultMenuPlacement;
        this.internalValueChangeFlag = false;
        this.textInput = null;
        this.mutationObserver = createObserver();
        this.resizeObserver = createObserver();
        this.guid = guid();
        this.inputHeight = 0;
        this.ignoreSelectedEventsFlag = false;
        this.openTransitionProp = "opacity";
        this.setFilteredPlacements = () => {
            const { el, flipPlacements } = this;
            this.filteredFlipPlacements = flipPlacements
                ? filterComputedPlacements(flipPlacements, el)
                : null;
        };
        this.getValue = () => {
            const items = this.selectedItems.map((item) => item?.value?.toString());
            return items?.length ? (items.length > 1 ? items : items[0]) : "";
        };
        this.onLabelClick = () => {
            this.setFocus();
        };
        this.keyDownHandler = (event) => {
            const { key } = event;
            switch (key) {
                case "Tab":
                    this.activeChipIndex = -1;
                    this.activeItemIndex = -1;
                    if (this.allowCustomValues && this.text) {
                        this.addCustomChip(this.text, true);
                        event.preventDefault();
                    }
                    else if (this.open) {
                        this.open = false;
                        event.preventDefault();
                    }
                    else if (!this.allowCustomValues && this.text) {
                        this.clearInputValue();
                        this.filterItems("");
                        this.updateActiveItemIndex(-1);
                    }
                    break;
                case "ArrowLeft":
                    this.previousChip();
                    event.preventDefault();
                    break;
                case "ArrowRight":
                    this.nextChip();
                    event.preventDefault();
                    break;
                case "ArrowUp":
                    event.preventDefault();
                    if (this.open) {
                        this.shiftActiveItemIndex(-1);
                    }
                    if (!this.comboboxInViewport()) {
                        this.el.scrollIntoView();
                    }
                    break;
                case "ArrowDown":
                    event.preventDefault();
                    if (this.open) {
                        this.shiftActiveItemIndex(1);
                    }
                    else {
                        this.open = true;
                        this.ensureRecentSelectedItemIsActive();
                    }
                    if (!this.comboboxInViewport()) {
                        this.el.scrollIntoView();
                    }
                    break;
                case " ":
                    if (!this.textInput.value) {
                        if (!this.open) {
                            this.open = true;
                            this.shiftActiveItemIndex(1);
                        }
                        event.preventDefault();
                    }
                    break;
                case "Home":
                    if (!this.open) {
                        return;
                    }
                    event.preventDefault();
                    this.updateActiveItemIndex(0);
                    this.scrollToActiveItem();
                    if (!this.comboboxInViewport()) {
                        this.el.scrollIntoView();
                    }
                    break;
                case "End":
                    if (!this.open) {
                        return;
                    }
                    event.preventDefault();
                    this.updateActiveItemIndex(this.filteredItems.length - 1);
                    this.scrollToActiveItem();
                    if (!this.comboboxInViewport()) {
                        this.el.scrollIntoView();
                    }
                    break;
                case "Escape":
                    if (!this.clearDisabled && !this.open) {
                        this.clearValue();
                    }
                    this.open = false;
                    event.preventDefault();
                    break;
                case "Enter":
                    if (this.activeItemIndex > -1) {
                        this.toggleSelection(this.filteredItems[this.activeItemIndex]);
                        event.preventDefault();
                    }
                    else if (this.activeChipIndex > -1) {
                        this.removeActiveChip();
                        event.preventDefault();
                    }
                    else if (this.allowCustomValues && this.text) {
                        this.addCustomChip(this.text, true);
                        event.preventDefault();
                    }
                    else if (!event.defaultPrevented) {
                        if (submitForm(this)) {
                            event.preventDefault();
                        }
                    }
                    break;
                case "Delete":
                case "Backspace":
                    const notDeletable = this.selectionDisplay === "single" ||
                        (this.selectionDisplay === "fit" && this.selectedHiddenChipsCount > 0);
                    if (notDeletable) {
                        return;
                    }
                    if (this.activeChipIndex > -1) {
                        event.preventDefault();
                        this.removeActiveChip();
                    }
                    else if (!this.text && this.isMulti()) {
                        event.preventDefault();
                        this.removeLastChip();
                    }
                    break;
            }
        };
        this.toggleCloseEnd = () => {
            this.open = false;
            this.el.removeEventListener("calciteComboboxClose", this.toggleCloseEnd);
        };
        this.toggleOpenEnd = () => {
            this.open = false;
            this.el.removeEventListener("calciteComboboxOpen", this.toggleOpenEnd);
        };
        this.setMaxScrollerHeight = async () => {
            const { listContainerEl, open, referenceEl } = this;
            if (!listContainerEl || !open) {
                return;
            }
            await this.reposition(true);
            const maxScrollerHeight = this.getMaxScrollerHeight();
            listContainerEl.style.maxHeight = maxScrollerHeight > 0 ? `${maxScrollerHeight}px` : "";
            listContainerEl.style.minWidth = `${referenceEl.clientWidth}px`;
            await this.reposition(true);
        };
        this.calciteChipCloseHandler = (comboboxItem) => {
            this.open = false;
            const selection = this.items.find((item) => item === comboboxItem);
            if (selection) {
                this.toggleSelection(selection, false);
            }
            this.calciteComboboxChipClose.emit();
        };
        this.clickHandler = (event) => {
            const composedPath = event.composedPath();
            if (composedPath.some((node) => node.tagName === "CALCITE-CHIP")) {
                this.open = false;
                event.preventDefault();
                return;
            }
            if (composedPath.some((node) => node.classList?.contains(CSS$13.button))) {
                this.clearValue();
                event.preventDefault();
                return;
            }
            this.open = !this.open;
            this.ensureRecentSelectedItemIsActive();
        };
        this.refreshSelectionDisplay = async () => {
            await componentLoaded(this);
            if (isSingleLike(this.selectionMode)) {
                return;
            }
            if (!this.textInput) {
                return;
            }
            const { allSelectedIndicatorChipEl, chipContainerEl, selectionDisplay, placeholder, selectedIndicatorChipEl, textInput, } = this;
            const chipContainerElGap = parseInt(getComputedStyle(chipContainerEl).gap.replace("px", ""));
            const chipContainerElWidth = getElementWidth(chipContainerEl);
            const { fontSize, fontFamily } = getComputedStyle(textInput);
            const inputTextWidth = getTextWidth(placeholder, `${fontSize} ${fontFamily}`);
            const inputWidth = (inputTextWidth || parseInt(calciteSize48)) + chipContainerElGap;
            const allSelectedIndicatorChipElWidth = getElementWidth(allSelectedIndicatorChipEl);
            const selectedIndicatorChipElWidth = getElementWidth(selectedIndicatorChipEl);
            const largestSelectedIndicatorChipWidth = Math.max(allSelectedIndicatorChipElWidth, selectedIndicatorChipElWidth);
            this.setCompactSelectionDisplay({
                chipContainerElGap,
                chipContainerElWidth,
                inputWidth,
                largestSelectedIndicatorChipWidth,
            });
            if (selectionDisplay === "fit") {
                const chipEls = Array.from(this.el.shadowRoot.querySelectorAll("calcite-chip")).filter((chipEl) => chipEl.closable);
                const availableHorizontalChipElSpace = Math.round(chipContainerElWidth -
                    ((this.selectedHiddenChipsCount > 0 ? selectedIndicatorChipElWidth : 0) +
                        chipContainerElGap +
                        inputWidth +
                        chipContainerElGap));
                this.refreshChipDisplay({ availableHorizontalChipElSpace, chipContainerElGap, chipEls });
                this.setVisibleAndHiddenChips(chipEls);
            }
        };
        this.setFloatingEl = (el) => {
            this.floatingEl = el;
            connectFloatingUI(this, this.referenceEl, this.floatingEl);
        };
        this.setContainerEl = (el) => {
            this.resizeObserver.observe(el);
            this.listContainerEl = el;
            this.transitionEl = el;
        };
        this.setChipContainerEl = (el) => {
            this.resizeObserver.observe(el);
            this.chipContainerEl = el;
        };
        this.setReferenceEl = (el) => {
            this.referenceEl = el;
            connectFloatingUI(this, this.referenceEl, this.floatingEl);
        };
        this.setAllSelectedIndicatorChipEl = (el) => {
            this.allSelectedIndicatorChipEl = el;
        };
        this.setSelectedIndicatorChipEl = (el) => {
            this.selectedIndicatorChipEl = el;
        };
        this.inputHandler = (event) => {
            const value = event.target.value;
            this.text = value;
            this.filterItems(value);
            if (value) {
                this.activeChipIndex = -1;
            }
        };
        this.filterItems = (() => {
            const find = (item, filteredData) => item &&
                filteredData.some(({ label, value }) => isGroup(item) ? label === item.label : value === item.value && label === item.textLabel);
            return debounce((text) => {
                const filteredData = filter(this.data, text);
                const itemsAndGroups = this.getItemsAndGroups();
                itemsAndGroups.forEach((item) => {
                    const hidden = !find(item, filteredData);
                    item.hidden = hidden;
                    const [parent, grandparent] = item.ancestors;
                    if (find(parent, filteredData) || find(grandparent, filteredData)) {
                        item.hidden = false;
                    }
                    if (!hidden) {
                        item.ancestors.forEach((ancestor) => (ancestor.hidden = false));
                    }
                });
                this.filteredItems = this.getFilteredItems();
                this.calciteComboboxFilterChange.emit();
            }, 100);
        })();
        this.internalComboboxChangeEvent = () => {
            this.calciteComboboxChange.emit();
        };
        this.emitComboboxChange = debounce(this.internalComboboxChangeEvent, 0);
        this.getSelectedItems = () => {
            if (!this.isMulti()) {
                const match = this.items.find(({ selected }) => selected);
                return match ? [match] : [];
            }
            return (this.items
                .filter((item) => item.selected && (this.selectionMode !== "ancestors" || !hasActiveChildren(item)))
                /** Preserve order of entered tags */
                .sort((a, b) => {
                const aIdx = this.selectedItems.indexOf(a);
                const bIdx = this.selectedItems.indexOf(b);
                if (aIdx > -1 && bIdx > -1) {
                    return aIdx - bIdx;
                }
                return bIdx - aIdx;
            }));
        };
        this.updateItems = () => {
            this.items = this.getItems();
            this.groupItems = this.getGroupItems();
            this.data = this.getData();
            this.selectedItems = this.getSelectedItems();
            this.filteredItems = this.getFilteredItems();
            this.needsIcon = this.getNeedsIcon();
            this.items.forEach((item) => {
                item.selectionMode = this.selectionMode;
                item.scale = this.scale;
            });
            if (!this.allowCustomValues) {
                this.setMaxScrollerHeight();
            }
            this.groupItems.forEach((groupItem, index, items) => {
                if (index === 0) {
                    groupItem.afterEmptyGroup = false;
                }
                const nextGroupItem = items[index + 1];
                if (nextGroupItem) {
                    nextGroupItem.afterEmptyGroup = groupItem.children.length === 0;
                }
            });
        };
        this.scrollToActiveItem = () => {
            const activeItem = this.filteredItems[this.activeItemIndex];
            if (!activeItem) {
                return;
            }
            const height = this.calculateSingleItemHeight(activeItem);
            const { offsetHeight, scrollTop } = this.listContainerEl;
            if (offsetHeight + scrollTop < activeItem.offsetTop + height) {
                this.listContainerEl.scrollTop = activeItem.offsetTop - offsetHeight + height;
            }
            else if (activeItem.offsetTop < scrollTop) {
                this.listContainerEl.scrollTop = activeItem.offsetTop;
            }
        };
        this.comboboxFocusHandler = () => {
            if (this.disabled) {
                return;
            }
            this.textInput?.focus();
        };
        this.clearDisabled = false;
        this.selectionDisplay = "all";
        this.open = false;
        this.disabled = false;
        this.form = undefined;
        this.label = undefined;
        this.placeholder = undefined;
        this.placeholderIcon = undefined;
        this.placeholderIconFlipRtl = false;
        this.maxItems = 0;
        this.validationMessage = undefined;
        this.validationIcon = undefined;
        this.name = undefined;
        this.allowCustomValues = undefined;
        this.overlayPositioning = "absolute";
        this.required = false;
        this.selectionMode = "multiple";
        this.scale = "m";
        this.status = "idle";
        this.value = null;
        this.flipPlacements = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.selectedItems = [];
        this.filteredItems = [];
        this.items = [];
        this.groupItems = [];
        this.needsIcon = undefined;
        this.activeItemIndex = -1;
        this.activeChipIndex = -1;
        this.activeDescendant = "";
        this.compactSelectionDisplay = false;
        this.selectedHiddenChipsCount = 0;
        this.selectedVisibleChipsCount = 0;
        this.text = "";
        this.effectiveLocale = undefined;
        this.defaultMessages = undefined;
    }
    openHandler() {
        onToggleOpenCloseComponent(this);
        if (this.disabled) {
            this.open = false;
            return;
        }
        this.setMaxScrollerHeight();
    }
    handleDisabledChange(value) {
        if (!value) {
            this.open = false;
        }
    }
    maxItemsHandler() {
        this.setMaxScrollerHeight();
    }
    overlayPositioningHandler() {
        this.reposition(true);
    }
    handlePropsChange() {
        this.updateItems();
    }
    valueHandler(value) {
        if (!this.internalValueChangeFlag) {
            const items = this.getItems();
            if (Array.isArray(value)) {
                items.forEach((item) => (item.selected = value.includes(item.value)));
            }
            else if (value) {
                items.forEach((item) => (item.selected = value === item.value));
            }
            else {
                items.forEach((item) => (item.selected = false));
            }
            this.updateItems();
        }
    }
    onMessagesChange() {
        /*  wired up by t9n util */
    }
    flipPlacementsHandler() {
        this.setFilteredPlacements();
        this.reposition(true);
    }
    selectedItemsHandler() {
        this.internalValueChangeFlag = true;
        this.value = this.getValue();
        this.internalValueChangeFlag = false;
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    documentClickHandler(event) {
        if (this.disabled || !isPrimaryPointerButton(event)) {
            return;
        }
        const composedPath = event.composedPath();
        if (composedPath.includes(this.el) || composedPath.includes(this.referenceEl)) {
            return;
        }
        if (!this.allowCustomValues && this.textInput.value) {
            this.clearInputValue();
            this.filterItems("");
            this.updateActiveItemIndex(-1);
        }
        if (this.allowCustomValues && this.text.trim().length) {
            this.addCustomChip(this.text);
        }
        this.open = false;
    }
    calciteComboboxItemChangeHandler(event) {
        if (this.ignoreSelectedEventsFlag) {
            return;
        }
        const target = event.target;
        const newIndex = this.filteredItems.indexOf(target);
        this.updateActiveItemIndex(newIndex);
        this.toggleSelection(target, target.selected);
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Updates the position of the component.
     *
     * @param delayed Reposition the component after a delay
     * @returns Promise
     */
    async reposition(delayed = false) {
        const { floatingEl, referenceEl, placement, overlayPositioning, filteredFlipPlacements } = this;
        return reposition(this, {
            floatingEl,
            referenceEl,
            overlayPositioning,
            placement,
            flipPlacements: filteredFlipPlacements,
            type: "menu",
        }, delayed);
    }
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.textInput?.focus();
        this.activeChipIndex = -1;
        this.activeItemIndex = -1;
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
        connectLabel(this);
        connectForm(this);
        this.internalValueChangeFlag = true;
        this.value = this.getValue();
        this.internalValueChangeFlag = false;
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
        this.updateItems();
        this.setFilteredPlacements();
        this.reposition(true);
        if (this.open) {
            this.openHandler();
            onToggleOpenCloseComponent(this);
        }
        connectFloatingUI(this, this.referenceEl, this.floatingEl);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        this.updateItems();
        await setUpMessages(this);
    }
    componentDidLoad() {
        afterConnectDefaultValueSet(this, this.getValue());
        this.reposition(true);
        setComponentLoaded(this);
    }
    componentDidRender() {
        if (this.el.offsetHeight !== this.inputHeight) {
            this.reposition(true);
            this.inputHeight = this.el.offsetHeight;
        }
        updateHostInteraction(this);
    }
    componentDidUpdate() {
        this.refreshSelectionDisplay();
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
        this.resizeObserver?.disconnect();
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
        disconnectFloatingUI(this, this.referenceEl, this.floatingEl);
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    /** when search text is cleared, reset active to  */
    textHandler() {
        this.updateActiveItemIndex(-1);
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    clearValue() {
        this.ignoreSelectedEventsFlag = true;
        this.items.forEach((el) => (el.selected = false));
        this.ignoreSelectedEventsFlag = false;
        this.selectedItems = [];
        this.emitComboboxChange();
        this.open = false;
        this.updateActiveItemIndex(-1);
        this.resetText();
        this.filterItems("");
        this.setFocus();
    }
    clearInputValue() {
        this.textInput.value = "";
        this.text = "";
    }
    comboboxInViewport() {
        const bounding = this.el.getBoundingClientRect();
        return (bounding.top >= 0 &&
            bounding.left >= 0 &&
            bounding.right <= (window.innerWidth || document.documentElement.clientWidth) &&
            bounding.bottom <= (window.innerHeight || document.documentElement.clientHeight));
    }
    onBeforeOpen() {
        this.scrollToActiveItem();
        this.calciteComboboxBeforeOpen.emit();
    }
    onOpen() {
        this.calciteComboboxOpen.emit();
    }
    onBeforeClose() {
        this.calciteComboboxBeforeClose.emit();
    }
    onClose() {
        this.calciteComboboxClose.emit();
    }
    ensureRecentSelectedItemIsActive() {
        const { selectedItems } = this;
        const targetIndex = selectedItems.length === 0 ? 0 : this.items.indexOf(selectedItems[selectedItems.length - 1]);
        this.updateActiveItemIndex(targetIndex);
    }
    hideChip(chipEl) {
        chipEl.classList.add(CSS$14.chipInvisible);
    }
    showChip(chipEl) {
        chipEl.classList.remove(CSS$14.chipInvisible);
    }
    refreshChipDisplay({ chipEls, availableHorizontalChipElSpace, chipContainerElGap, }) {
        chipEls.forEach((chipEl) => {
            if (!chipEl.selected) {
                this.hideChip(chipEl);
            }
            else {
                const chipElWidth = getElementWidth(chipEl);
                if (chipElWidth && chipElWidth < availableHorizontalChipElSpace) {
                    availableHorizontalChipElSpace -= chipElWidth + chipContainerElGap;
                    this.showChip(chipEl);
                    return;
                }
            }
            this.hideChip(chipEl);
        });
    }
    setCompactSelectionDisplay({ chipContainerElGap, chipContainerElWidth, inputWidth, largestSelectedIndicatorChipWidth, }) {
        const newCompactBreakpoint = Math.round(largestSelectedIndicatorChipWidth + chipContainerElGap + inputWidth);
        if (!this.maxCompactBreakpoint || this.maxCompactBreakpoint < newCompactBreakpoint) {
            this.maxCompactBreakpoint = newCompactBreakpoint;
        }
        this.compactSelectionDisplay = chipContainerElWidth < this.maxCompactBreakpoint;
    }
    setVisibleAndHiddenChips(chipEls) {
        let newSelectedVisibleChipsCount = 0;
        chipEls.forEach((chipEl) => {
            if (chipEl.selected && !chipEl.classList.contains(CSS$14.chipInvisible)) {
                newSelectedVisibleChipsCount++;
            }
        });
        if (newSelectedVisibleChipsCount !== this.selectedVisibleChipsCount) {
            this.selectedVisibleChipsCount = newSelectedVisibleChipsCount;
        }
        const newSelectedHiddenChipsCount = this.getSelectedItems().length - newSelectedVisibleChipsCount;
        if (newSelectedHiddenChipsCount !== this.selectedHiddenChipsCount) {
            this.selectedHiddenChipsCount = newSelectedHiddenChipsCount;
        }
    }
    getMaxScrollerHeight() {
        const items = this.getItemsAndGroups().filter((item) => !item.hidden);
        const { maxItems } = this;
        let itemsToProcess = 0;
        let maxScrollerHeight = 0;
        if (items.length > maxItems) {
            items.forEach((item) => {
                if (itemsToProcess < maxItems && maxItems > 0) {
                    const height = this.calculateSingleItemHeight(item);
                    if (height > 0) {
                        maxScrollerHeight += height;
                        itemsToProcess++;
                    }
                }
            });
        }
        return maxScrollerHeight;
    }
    calculateSingleItemHeight(item) {
        if (!item) {
            return;
        }
        let height = item.offsetHeight;
        // if item has children items, don't count their height twice
        const children = Array.from(item.querySelectorAll(ComboboxChildSelector));
        children
            .map((child) => child?.offsetHeight)
            .forEach((offsetHeight) => {
            height -= offsetHeight;
        });
        return height;
    }
    getItemsAndGroups() {
        return [...this.groupItems, ...this.items];
    }
    toggleSelection(item, value = !item.selected) {
        if (!item ||
            (this.selectionMode === "single-persist" && item.selected && item.value === this.value)) {
            return;
        }
        if (this.isMulti()) {
            item.selected = value;
            this.updateAncestors(item);
            this.selectedItems = this.getSelectedItems();
            this.emitComboboxChange();
            this.resetText();
            this.filterItems("");
        }
        else {
            this.ignoreSelectedEventsFlag = true;
            this.items.forEach((el) => (el.selected = el === item ? value : false));
            this.ignoreSelectedEventsFlag = false;
            this.selectedItems = this.getSelectedItems();
            this.emitComboboxChange();
            if (this.textInput) {
                this.textInput.value = item.textLabel;
            }
            this.open = false;
            this.updateActiveItemIndex(-1);
            this.resetText();
            this.filterItems("");
        }
    }
    updateAncestors(item) {
        if (this.selectionMode !== "ancestors") {
            return;
        }
        const ancestors = getItemAncestors(item);
        const children = getItemChildren(item);
        if (item.selected) {
            ancestors.forEach((el) => {
                el.selected = true;
            });
        }
        else {
            children.forEach((el) => (el.selected = false));
            [...ancestors].forEach((el) => {
                if (!hasActiveChildren(el)) {
                    el.selected = false;
                }
            });
        }
    }
    getFilteredItems() {
        return this.items.filter((item) => !item.hidden);
    }
    getData() {
        return this.items.map((item) => ({
            filterDisabled: item.filterDisabled,
            value: item.value,
            label: item.textLabel,
        }));
    }
    getNeedsIcon() {
        return isSingleLike(this.selectionMode) && this.items.some((item) => item.icon);
    }
    resetText() {
        if (this.textInput) {
            this.textInput.value = "";
        }
        this.text = "";
    }
    getItems() {
        const items = Array.from(this.el.querySelectorAll(ComboboxItem$1));
        return items.filter((item) => !item.disabled);
    }
    getGroupItems() {
        return Array.from(this.el.querySelectorAll(ComboboxItemGroup$1));
    }
    addCustomChip(value, focus) {
        const existingItem = this.items.find((el) => el.textLabel === value);
        if (existingItem) {
            this.toggleSelection(existingItem, true);
        }
        else {
            if (!this.isMulti()) {
                this.toggleSelection(this.selectedItems[this.selectedItems.length - 1], false);
            }
            const item = document.createElement("calcite-combobox-item");
            item.value = value;
            item.textLabel = value;
            item.selected = true;
            this.el.appendChild(item);
            this.resetText();
            if (focus) {
                this.setFocus();
            }
            this.updateItems();
            this.filterItems("");
            this.emitComboboxChange();
        }
    }
    removeActiveChip() {
        this.toggleSelection(this.selectedItems[this.activeChipIndex], false);
        this.setFocus();
    }
    removeLastChip() {
        this.toggleSelection(this.selectedItems[this.selectedItems.length - 1], false);
        this.setFocus();
    }
    previousChip() {
        if (this.text) {
            return;
        }
        const length = this.selectedItems.length - 1;
        const active = this.activeChipIndex;
        this.activeChipIndex = active === -1 ? length : Math.max(active - 1, 0);
        this.updateActiveItemIndex(-1);
        this.focusChip();
    }
    nextChip() {
        if (this.text || this.activeChipIndex === -1) {
            return;
        }
        const last = this.selectedItems.length - 1;
        const newIndex = this.activeChipIndex + 1;
        if (newIndex > last) {
            this.activeChipIndex = -1;
            this.setFocus();
        }
        else {
            this.activeChipIndex = newIndex;
            this.focusChip();
        }
        this.updateActiveItemIndex(-1);
    }
    focusChip() {
        const guid = this.selectedItems[this.activeChipIndex]?.guid;
        const chip = guid
            ? this.referenceEl.querySelector(`#${chipUidPrefix}${guid}`)
            : null;
        chip?.setFocus();
    }
    shiftActiveItemIndex(delta) {
        const { length } = this.filteredItems;
        const newIndex = (this.activeItemIndex + length + delta) % length;
        this.updateActiveItemIndex(newIndex);
        this.scrollToActiveItem();
    }
    updateActiveItemIndex(index) {
        this.activeItemIndex = index;
        let activeDescendant = null;
        this.filteredItems.forEach((el, i) => {
            if (i === index) {
                el.active = true;
                activeDescendant = `${itemUidPrefix}${el.guid}`;
            }
            else {
                el.active = false;
            }
        });
        this.activeDescendant = activeDescendant;
        if (this.activeItemIndex > -1) {
            this.activeChipIndex = -1;
        }
    }
    isAllSelected() {
        return this.getItems().length === this.getSelectedItems().length;
    }
    isMulti() {
        return !isSingleLike(this.selectionMode);
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    renderChips() {
        const { activeChipIndex, scale, selectionMode, messages } = this;
        return this.selectedItems.map((item, i) => {
            const chipClasses = {
                chip: true,
                "chip--active": activeChipIndex === i,
            };
            const ancestors = [...getItemAncestors(item)].reverse();
            const pathLabel = [...ancestors, item].map((el) => el.textLabel);
            const label = selectionMode !== "ancestors" ? item.textLabel : pathLabel.join(" / ");
            return (hAsync("calcite-chip", { class: chipClasses, closable: true, icon: item.icon, iconFlipRtl: item.iconFlipRtl, id: item.guid ? `${chipUidPrefix}${item.guid}` : null, key: item.textLabel, messageOverrides: { dismissLabel: messages.removeTag }, onCalciteChipClose: () => this.calciteChipCloseHandler(item), scale: scale, selected: item.selected, title: label, value: item.value }, label));
        });
    }
    renderAllSelectedIndicatorChip() {
        const { compactSelectionDisplay, scale, selectedVisibleChipsCount, setAllSelectedIndicatorChipEl, } = this;
        const label = this.messages.allSelected;
        return (hAsync("calcite-chip", { class: {
                chip: true,
                [CSS$14.chipInvisible]: !(this.isAllSelected() &&
                    !selectedVisibleChipsCount &&
                    !compactSelectionDisplay),
            }, scale: scale, title: label, value: "",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: setAllSelectedIndicatorChipEl }, label));
    }
    renderAllSelectedIndicatorChipCompact() {
        const { compactSelectionDisplay, scale, selectedVisibleChipsCount } = this;
        const label = this.messages.all || "All";
        return (hAsync("calcite-chip", { class: {
                chip: true,
                [CSS$14.chipInvisible]: !(this.isAllSelected() &&
                    !selectedVisibleChipsCount &&
                    compactSelectionDisplay),
            }, scale: scale, title: label, value: "" }, label));
    }
    renderSelectedIndicatorChip() {
        const { compactSelectionDisplay, selectionDisplay, getSelectedItems, scale, selectedHiddenChipsCount, selectedVisibleChipsCount, setSelectedIndicatorChipEl, } = this;
        let chipInvisible;
        let label;
        if (compactSelectionDisplay) {
            chipInvisible = true;
        }
        else {
            if (selectionDisplay === "single") {
                const selectedItemsCount = getSelectedItems().length;
                if (this.isAllSelected()) {
                    chipInvisible = true;
                }
                else if (selectedItemsCount > 0) {
                    chipInvisible = false;
                }
                else {
                    chipInvisible = true;
                }
                label = `${selectedItemsCount} ${this.messages.selected}`;
            }
            else if (selectionDisplay === "fit") {
                chipInvisible = !!((this.isAllSelected() && selectedVisibleChipsCount === 0) ||
                    selectedHiddenChipsCount === 0);
                label =
                    selectedVisibleChipsCount > 0
                        ? `+${selectedHiddenChipsCount}`
                        : `${selectedHiddenChipsCount} ${this.messages.selected}`;
            }
        }
        return (hAsync("calcite-chip", { class: {
                chip: true,
                [CSS$14.chipInvisible]: chipInvisible,
            }, scale: scale, title: label, value: "",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: setSelectedIndicatorChipEl }, label));
    }
    renderSelectedIndicatorChipCompact() {
        const { compactSelectionDisplay, selectionDisplay, getSelectedItems, scale, selectedHiddenChipsCount, } = this;
        let chipInvisible;
        let label;
        if (compactSelectionDisplay) {
            const selectedItemsCount = getSelectedItems().length;
            if (this.isAllSelected()) {
                chipInvisible = true;
            }
            else if (selectionDisplay === "fit") {
                chipInvisible = !(selectedHiddenChipsCount > 0);
                label = `${selectedHiddenChipsCount || 0}`;
            }
            else if (selectionDisplay === "single") {
                chipInvisible = !(selectedItemsCount > 0);
                label = `${selectedItemsCount}`;
            }
        }
        else {
            chipInvisible = true;
        }
        return (hAsync("calcite-chip", { class: {
                chip: true,
                [CSS$14.chipInvisible]: chipInvisible,
            }, scale: scale, title: label, value: "" }, label));
    }
    get showingInlineIcon() {
        const { placeholderIcon, selectionMode, selectedItems, open } = this;
        const selectedItem = selectedItems[0];
        const selectedIcon = selectedItem?.icon;
        const singleSelectionMode = isSingleLike(selectionMode);
        return !open && selectedItem
            ? !!selectedIcon && singleSelectionMode
            : !!placeholderIcon && (!selectedItem || singleSelectionMode);
    }
    renderInput() {
        const { guid, disabled, placeholder, selectionMode, selectedItems, open } = this;
        const single = isSingleLike(selectionMode);
        const selectedItem = selectedItems[0];
        const showLabel = !open && single && !!selectedItem;
        return (hAsync("span", { class: {
                "input-wrap": true,
                "input-wrap--single": single,
            } }, showLabel && (hAsync("span", { class: {
                label: true,
                "label--icon": !!selectedItem?.icon,
            }, key: "label" }, selectedItem.textLabel)), hAsync("input", { "aria-activedescendant": this.activeDescendant, "aria-autocomplete": "list", "aria-controls": `${listboxUidPrefix}${guid}`, "aria-label": getLabelText(this), class: {
                input: true,
                "input--single": true,
                "input--transparent": this.activeChipIndex > -1,
                "input--hidden": showLabel,
                "input--icon": this.showingInlineIcon && !!this.placeholderIcon,
            }, disabled: disabled, id: `${inputUidPrefix}${guid}`, key: "input", onFocus: this.comboboxFocusHandler, onInput: this.inputHandler, placeholder: placeholder, type: "text",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.textInput = el) })));
    }
    renderListBoxOptions() {
        return this.filteredItems.map((item) => (hAsync("li", { "aria-selected": toAriaBoolean(item.selected), id: item.guid ? `${itemUidPrefix}${item.guid}` : null, role: "option", tabindex: "-1" }, item.textLabel)));
    }
    renderFloatingUIContainer() {
        const { setFloatingEl, setContainerEl, open } = this;
        const classes = {
            [CSS$14.listContainer]: true,
            [FloatingCSS.animation]: true,
            [FloatingCSS.animationActive]: open,
        };
        return (hAsync("div", { "aria-hidden": "true", class: {
                "floating-ui-container": true,
                "floating-ui-container--active": open,
            },
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: setFloatingEl }, hAsync("div", { class: classes,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: setContainerEl }, hAsync("ul", { class: { list: true, "list--hide": !open } }, hAsync("slot", null)))));
    }
    renderSelectedOrPlaceholderIcon() {
        const { selectedItems, placeholderIcon, placeholderIconFlipRtl } = this;
        const selectedItem = selectedItems[0];
        const selectedIcon = selectedItem?.icon;
        return (this.showingInlineIcon && (hAsync("span", { class: "icon-start", key: "selected-placeholder-icon" }, hAsync("calcite-icon", { class: "selected-icon", flipRtl: this.open && selectedItem ? selectedItem.iconFlipRtl : placeholderIconFlipRtl, icon: !this.open && selectedItem ? selectedIcon : placeholderIcon, scale: getIconScale(this.scale) }))));
    }
    renderChevronIcon() {
        const { open } = this;
        return (hAsync("span", { class: "icon-end", key: "chevron" }, hAsync("calcite-icon", { icon: open ? "chevron-up" : "chevron-down", scale: getIconScale(this.scale) })));
    }
    render() {
        const { selectionDisplay, guid, label, open } = this;
        const singleSelectionMode = isSingleLike(this.selectionMode);
        const allSelectionDisplay = selectionDisplay === "all";
        const singleSelectionDisplay = selectionDisplay === "single";
        const fitSelectionDisplay = !singleSelectionMode && selectionDisplay === "fit";
        const isClearable = !this.clearDisabled && this.value?.length > 0;
        return (hAsync(Host, { onClick: this.comboboxFocusHandler }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { "aria-autocomplete": "list", "aria-controls": `${listboxUidPrefix}${guid}`, "aria-expanded": toAriaBoolean(open), "aria-haspopup": "listbox", "aria-label": getLabelText(this), "aria-live": "polite", "aria-owns": `${listboxUidPrefix}${guid}`, class: {
                wrapper: true,
                "wrapper--single": singleSelectionMode || !this.selectedItems.length,
                "wrapper--active": open,
            }, onClick: this.clickHandler, onKeyDown: this.keyDownHandler, role: "combobox",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setReferenceEl }, this.renderSelectedOrPlaceholderIcon(), hAsync("div", { class: {
                "grid-input": true,
                [CSS$14.selectionDisplayFit]: fitSelectionDisplay,
                [CSS$14.selectionDisplaySingle]: singleSelectionDisplay,
            }, key: "grid", ref: this.setChipContainerEl }, !singleSelectionMode && !singleSelectionDisplay && this.renderChips(), !singleSelectionMode &&
            !allSelectionDisplay && [
            this.renderSelectedIndicatorChip(),
            this.renderSelectedIndicatorChipCompact(),
            this.renderAllSelectedIndicatorChip(),
            this.renderAllSelectedIndicatorChipCompact(),
        ], hAsync("label", { class: "screen-readers-only", htmlFor: `${inputUidPrefix}${guid}`, id: `${labelUidPrefix}${guid}` }, label), this.renderInput()), isClearable ? (hAsync(XButton, { disabled: this.disabled, key: "close-button", label: this.messages.clear, scale: this.scale })) : null, this.renderChevronIcon()), hAsync("ul", { "aria-labelledby": `${labelUidPrefix}${guid}`, "aria-multiselectable": "true", class: "screen-readers-only", id: `${listboxUidPrefix}${guid}`, role: "listbox", tabIndex: -1 }, this.renderListBoxOptions()), this.renderFloatingUIContainer(), hAsync(HiddenFormInputSlot, { component: this }), this.validationMessage && this.status === "invalid" ? (hAsync(Validation, { icon: this.validationIcon, message: this.validationMessage, scale: this.scale, status: this.status })) : null)));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "open": ["openHandler"],
        "disabled": ["handleDisabledChange"],
        "maxItems": ["maxItemsHandler"],
        "overlayPositioning": ["overlayPositioningHandler"],
        "selectionMode": ["handlePropsChange"],
        "scale": ["handlePropsChange"],
        "value": ["valueHandler"],
        "messageOverrides": ["onMessagesChange"],
        "flipPlacements": ["flipPlacementsHandler"],
        "selectedItems": ["selectedItemsHandler"],
        "text": ["textHandler"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return comboboxCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-combobox",
        "$members$": {
            "clearDisabled": [516, "clear-disabled"],
            "selectionDisplay": [513, "selection-display"],
            "open": [1540],
            "disabled": [516],
            "form": [513],
            "label": [1],
            "placeholder": [1],
            "placeholderIcon": [513, "placeholder-icon"],
            "placeholderIconFlipRtl": [516, "placeholder-icon-flip-rtl"],
            "maxItems": [514, "max-items"],
            "validationMessage": [1, "validation-message"],
            "validationIcon": [520, "validation-icon"],
            "name": [513],
            "allowCustomValues": [516, "allow-custom-values"],
            "overlayPositioning": [513, "overlay-positioning"],
            "required": [516],
            "selectionMode": [513, "selection-mode"],
            "scale": [513],
            "status": [513],
            "value": [1025],
            "flipPlacements": [16],
            "messages": [1040],
            "messageOverrides": [1040],
            "selectedItems": [1040],
            "filteredItems": [1040],
            "items": [32],
            "groupItems": [32],
            "needsIcon": [32],
            "activeItemIndex": [32],
            "activeChipIndex": [32],
            "activeDescendant": [32],
            "compactSelectionDisplay": [32],
            "selectedHiddenChipsCount": [32],
            "selectedVisibleChipsCount": [32],
            "text": [32],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "reposition": [64],
            "setFocus": [64]
        },
        "$listeners$": [[5, "pointerdown", "documentClickHandler"], [0, "calciteComboboxItemChange", "calciteComboboxItemChangeHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["clearDisabled", "clear-disabled"], ["selectionDisplay", "selection-display"], ["open", "open"], ["disabled", "disabled"], ["form", "form"], ["placeholderIcon", "placeholder-icon"], ["placeholderIconFlipRtl", "placeholder-icon-flip-rtl"], ["maxItems", "max-items"], ["validationIcon", "validation-icon"], ["name", "name"], ["allowCustomValues", "allow-custom-values"], ["overlayPositioning", "overlay-positioning"], ["required", "required"], ["selectionMode", "selection-mode"], ["scale", "scale"], ["status", "status"]]
    }; }
}

const CSS$11 = {
    icon: "icon",
    iconActive: "icon--active",
    iconIndent: "icon--indent",
    custom: "icon--custom",
    dot: "icon--dot",
    single: "label--single",
    label: "label",
    active: "label--active",
    selected: "label--selected",
    title: "title",
    textContainer: "text-container",
};

const comboboxItemCss = "@charset \"UTF-8\";/*!@:host([disabled])*/[disabled].sc-calcite-combobox-item-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-combobox-item-h *.sc-calcite-combobox-item,.sc-calcite-combobox-item-h[disabled].sc-calcite-combobox-item-s>*,.sc-calcite-combobox-item-h[disabled] .sc-calcite-combobox-item-s>*{pointer-events:none}/*!@:host([hidden])*/[hidden].sc-calcite-combobox-item-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-combobox-item{display:none}/*!@.scale--s*/.scale--s.sc-calcite-combobox-item{font-size:var(--calcite-font-size--2);line-height:1rem;--calcite-combobox-item-spacing-unit-l:0.5rem;--calcite-combobox-item-spacing-unit-s:0.25rem;--calcite-combobox-item-spacing-indent:0.5rem;--calcite-combobox-item-selector-icon-size:1rem}/*!@.scale--m*/.scale--m.sc-calcite-combobox-item{font-size:var(--calcite-font-size--1);line-height:1rem;--calcite-combobox-item-spacing-unit-l:0.75rem;--calcite-combobox-item-spacing-unit-s:0.5rem;--calcite-combobox-item-spacing-indent:0.75rem;--calcite-combobox-item-selector-icon-size:1rem}/*!@.scale--l*/.scale--l.sc-calcite-combobox-item{font-size:var(--calcite-font-size-0);line-height:1.25rem;--calcite-combobox-item-spacing-unit-l:1rem;--calcite-combobox-item-spacing-unit-s:0.625rem;--calcite-combobox-item-spacing-indent:1rem;--calcite-combobox-item-selector-icon-size:1.5rem}/*!@.container*/.container.sc-calcite-combobox-item{--calcite-combobox-item-indent-value:calc(\n    var(--calcite-combobox-item-spacing-indent) * var(--calcite-combobox-item-spacing-indent-multiplier)\n  )}/*!@:host(:focus)*/.sc-calcite-combobox-item-h:focus{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-combobox-item-h[disabled] .sc-calcite-combobox-item-s>[calcite-hydrated][disabled],[disabled].sc-calcite-combobox-item-h [calcite-hydrated][disabled].sc-calcite-combobox-item{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-combobox-item{display:contents}/*!@:host,\nul*/.sc-calcite-combobox-item-h,ul.sc-calcite-combobox-item{margin:0px;display:flex;flex-direction:column;padding:0px}/*!@:host(:focus),\nul:focus*/.sc-calcite-combobox-item-h:focus,ul.sc-calcite-combobox-item:focus{outline:2px solid transparent;outline-offset:2px}/*!@.label*/.label.sc-calcite-combobox-item{position:relative;box-sizing:border-box;display:flex;inline-size:100%;min-inline-size:100%;cursor:pointer;align-items:center;color:var(--calcite-color-text-3);text-decoration-line:none;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);outline-color:transparent;word-wrap:break-word;word-break:break-word;padding-block:var(--calcite-combobox-item-spacing-unit-s);padding-inline:var(--calcite-combobox-item-spacing-unit-l)}/*!@:host([disabled]) .label*/[disabled].sc-calcite-combobox-item-h .label.sc-calcite-combobox-item{cursor:default}/*!@.label--selected*/.label--selected.sc-calcite-combobox-item{font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1)}/*!@.label--active*/.label--active.sc-calcite-combobox-item{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.label:hover,\n.label:active*/.label.sc-calcite-combobox-item:hover,.label.sc-calcite-combobox-item:active{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-text-1);text-decoration-line:none;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@.title*/.title.sc-calcite-combobox-item{padding-block:0;padding-inline:var(--calcite-combobox-item-spacing-unit-l)}/*!@.icon*/.icon.sc-calcite-combobox-item{display:inline-flex;opacity:0;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);color:var(--calcite-color-border-1)}/*!@.icon--indent*/.icon--indent.sc-calcite-combobox-item{padding-inline-start:var(--calcite-combobox-item-indent-value)}/*!@.icon--custom*/.icon--custom.sc-calcite-combobox-item{margin-block-start:-1px;padding-inline-start:var(--calcite-combobox-item-spacing-unit-l);color:var(--calcite-color-text-3)}/*!@.icon--active*/.icon--active.sc-calcite-combobox-item{color:var(--calcite-color-text-1)}/*!@.icon--dot*/.icon--dot.sc-calcite-combobox-item{display:flex;justify-content:center;min-inline-size:var(--calcite-combobox-item-selector-icon-size)}/*!@.icon--dot:before*/.icon--dot.sc-calcite-combobox-item:before{text-align:start;content:\"•\"}/*!@.label--active .icon*/.label--active.sc-calcite-combobox-item .icon.sc-calcite-combobox-item{opacity:1}/*!@.label--selected .icon*/.label--selected.sc-calcite-combobox-item .icon.sc-calcite-combobox-item{opacity:1;color:var(--calcite-color-brand)}/*!@:host(:hover[disabled]) .icon*/.sc-calcite-combobox-item-h:hover[disabled] .icon.sc-calcite-combobox-item{opacity:1}";

/**
 * @slot - A slot for adding nested `calcite-combobox-item`s.
 */
class ComboboxItem {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteComboboxItemChange = createEvent(this, "calciteComboboxItemChange", 6);
        this.itemClickHandler = () => {
            this.toggleSelected();
        };
        this.disabled = false;
        this.selected = false;
        this.active = false;
        this.ancestors = undefined;
        this.guid = guid();
        this.icon = undefined;
        this.iconFlipRtl = false;
        this.textLabel = undefined;
        this.value = undefined;
        this.filterDisabled = undefined;
        this.selectionMode = "multiple";
        this.scale = "m";
    }
    selectedWatchHandler() {
        this.calciteComboboxItemChange.emit();
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        this.ancestors = getAncestors(this.el);
        connectConditionalSlotComponent(this);
        connectInteractive(this);
    }
    disconnectedCallback() {
        disconnectConditionalSlotComponent(this);
        disconnectInteractive(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    toggleSelected() {
        const isSinglePersistSelect = this.selectionMode === "single-persist";
        if (this.disabled || (isSinglePersistSelect && this.selected)) {
            return;
        }
        this.selected = !this.selected;
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderIcon(iconPath) {
        return this.icon ? (hAsync("calcite-icon", { class: {
                [CSS$11.custom]: !!this.icon,
                [CSS$11.iconActive]: this.icon && this.selected,
                [CSS$11.iconIndent]: true,
            }, flipRtl: this.iconFlipRtl, icon: this.icon || iconPath, key: "icon", scale: getIconScale(this.scale) })) : null;
    }
    renderSelectIndicator(showDot, iconPath) {
        return showDot ? (hAsync("span", { class: {
                [CSS$11.icon]: true,
                [CSS$11.dot]: true,
                [CSS$11.iconIndent]: true,
            } })) : (hAsync("calcite-icon", { class: {
                [CSS$11.icon]: true,
                [CSS$11.iconActive]: this.selected,
                [CSS$11.iconIndent]: true,
            }, flipRtl: this.iconFlipRtl, icon: iconPath, key: "indicator", scale: getIconScale(this.scale) }));
    }
    renderChildren() {
        if (getSlotted(this.el)) {
            return (hAsync("ul", { key: "default-slot-container" }, hAsync("slot", null)));
        }
        return null;
    }
    render() {
        const { disabled } = this;
        const isSingleSelect = isSingleLike(this.selectionMode);
        const showDot = isSingleSelect && !disabled;
        const defaultIcon = isSingleSelect ? "dot" : "check";
        const iconPath = disabled ? "" : defaultIcon;
        const classes = {
            [CSS$11.label]: true,
            [CSS$11.selected]: this.selected,
            [CSS$11.active]: this.active,
            [CSS$11.single]: isSingleSelect,
        };
        const depth = getDepth$1();
        return (hAsync(Host, { "aria-hidden": "true" }, hAsync(InteractiveContainer, { disabled: disabled }, hAsync("div", { class: `container scale--${this.scale}`, style: { "--calcite-combobox-item-spacing-indent-multiplier": `${depth}` } }, hAsync("li", { class: classes, id: this.guid, onClick: this.itemClickHandler }, this.renderSelectIndicator(showDot, iconPath), this.renderIcon(iconPath), hAsync("span", { class: "title" }, this.textLabel)), this.renderChildren()))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "selected": ["selectedWatchHandler"]
    }; }
    static get style() { return comboboxItemCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-combobox-item",
        "$members$": {
            "disabled": [516],
            "selected": [1540],
            "active": [516],
            "ancestors": [1040],
            "guid": [513],
            "icon": [513],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "textLabel": [513, "text-label"],
            "value": [8],
            "filterDisabled": [516, "filter-disabled"],
            "selectionMode": [513, "selection-mode"],
            "scale": [1]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["selected", "selected"], ["active", "active"], ["guid", "guid"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["textLabel", "text-label"], ["filterDisabled", "filter-disabled"], ["selectionMode", "selection-mode"]]
    }; }
}

const CSS$10 = {
    list: "list",
    label: "label",
    title: "title",
};

const comboboxItemGroupCss = "/*!@.scale--s*/.scale--s.sc-calcite-combobox-item-group{font-size:var(--calcite-font-size--2);line-height:1rem;--calcite-combobox-item-spacing-unit-l:0.5rem;--calcite-combobox-item-spacing-unit-s:0.25rem;--calcite-combobox-item-spacing-indent:0.5rem}/*!@.scale--m*/.scale--m.sc-calcite-combobox-item-group{font-size:var(--calcite-font-size--1);line-height:1rem;--calcite-combobox-item-spacing-unit-l:0.75rem;--calcite-combobox-item-spacing-unit-s:0.5rem;--calcite-combobox-item-spacing-indent:0.75rem}/*!@.scale--l*/.scale--l.sc-calcite-combobox-item-group{font-size:var(--calcite-font-size-0);line-height:1.25rem;--calcite-combobox-item-spacing-unit-l:1rem;--calcite-combobox-item-spacing-unit-s:0.75rem;--calcite-combobox-item-spacing-indent:1rem}/*!@:host,\n.list*/.sc-calcite-combobox-item-group-h,.list.sc-calcite-combobox-item-group{margin:0px;display:flex;flex-direction:column;padding:0px}/*!@:host(:focus),\n.list:focus*/.sc-calcite-combobox-item-group-h:focus,.list.sc-calcite-combobox-item-group:focus{outline:2px solid transparent;outline-offset:2px}/*!@.label*/.label.sc-calcite-combobox-item-group{box-sizing:border-box;display:flex;inline-size:100%;min-inline-size:0px;max-inline-size:100%;color:var(--calcite-color-text-3)}/*!@.title*/.title.sc-calcite-combobox-item-group{--calcite-combobox-item-indent-value:calc(\n    var(--calcite-combobox-item-spacing-indent) * var(--calcite-combobox-item-spacing-indent-multiplier)\n  );border:0 solid;display:block;flex:1 1 0%;border-block-end-width:1px;font-weight:var(--calcite-font-weight-bold);color:var(--calcite-color-text-2);word-wrap:break-word;word-break:break-word;border-block-end-color:var(--calcite-color-border-3);padding-block:var(--calcite-combobox-item-spacing-unit-l);padding-inline:var(--calcite-combobox-item-spacing-unit-s);margin-inline-start:var(--calcite-combobox-item-indent-value)}/*!@::slotted(calcite-combobox-item-group:not([after-empty-group]))*/.sc-calcite-combobox-item-group-s>calcite-combobox-item-group:not([after-empty-group]){padding-block-start:var(--calcite-combobox-item-spacing-unit-l)}/*!@:host([hidden])*/[hidden].sc-calcite-combobox-item-group-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-combobox-item-group{display:none}";

/**
 * @slot - A slot for adding `calcite-combobox-item`s.
 */
class ComboboxItemGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.guid = guid();
        this.afterEmptyGroup = false;
        this.ancestors = undefined;
        this.label = undefined;
        this.scale = "m";
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        this.ancestors = getAncestors(this.el);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const { el, scale } = this;
        const depth = getDepth$1();
        return (hAsync("ul", { "aria-labelledby": this.guid, class: { [CSS$10.list]: true, [`scale--${scale}`]: true }, role: "group" }, hAsync("li", { class: { [CSS$10.label]: true }, id: this.guid, role: "presentation", style: { "--calcite-combobox-item-spacing-indent-multiplier": `${depth}` } }, hAsync("span", { class: CSS$10.title }, this.label)), hAsync("slot", null)));
    }
    get el() { return getElement(this); }
    static get style() { return comboboxItemGroupCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-combobox-item-group",
        "$members$": {
            "afterEmptyGroup": [516, "after-empty-group"],
            "ancestors": [1040],
            "label": [1],
            "scale": [1]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["afterEmptyGroup", "after-empty-group"]]
    }; }
}

/**
 * Check if date is within a min and max
 *
 * @param date
 * @param min
 * @param max
 */
function inRange(date, min, max) {
    if (!date) {
        return;
    }
    const time = date.getTime();
    const afterMin = !(min instanceof Date) || time >= min.getTime();
    const beforeMax = !(max instanceof Date) || time <= max.getTime();
    return afterMin && beforeMax;
}
/**
 * Ensures date is within range,
 * returns min or max if out of bounds
 *
 * @param date
 * @param min
 * @param max
 */
function dateFromRange(date, min, max) {
    if (!(date instanceof Date)) {
        return null;
    }
    const time = date.getTime();
    const beforeMin = min instanceof Date && time < min.getTime();
    const afterMax = max instanceof Date && time > max.getTime();
    if (beforeMin) {
        return min;
    }
    if (afterMax) {
        return max;
    }
    return date;
}
/**
 * Parse an iso8601 string (YYYY-mm-dd) into a valid date.
 * TODO: handle time when time of day UI is added
 *
 * @param iso8601
 * @param isEndDate
 */
function dateFromISO(iso8601, isEndDate = false) {
    if (iso8601 instanceof Date) {
        return iso8601;
    }
    if (!iso8601 || typeof iso8601 !== "string") {
        return null;
    }
    const d = iso8601.split(/[: T-]/).map(parseFloat);
    const date = new Date(d[0], (d[1] || 1) - 1, d[2] || 1);
    date.setFullYear(d[0]);
    if (isNaN(date.getTime())) {
        throw new Error(`Invalid ISO 8601 date: "${iso8601}"`);
    }
    if (isEndDate) {
        return setEndOfDay(date);
    }
    return date;
}
/**
 * Parse a localized date string into a valid Date.
 * return false if date is invalid, or out of range
 *
 * @param value
 * @param localeData
 */
function dateFromLocalizedString(value, localeData) {
    if (!localeData) {
        return null;
    }
    const { separator } = localeData;
    const parts = parseDateString(value, localeData);
    const { day, month } = parts;
    const year = parseCalendarYear(parts.year, localeData);
    const date = new Date(year, month, day);
    date.setFullYear(year);
    const validDay = day > 0;
    const validMonth = month > -1;
    const validDate = !isNaN(date.getTime());
    const validLength = value.split(separator).filter((c) => c).length > 2;
    const validYear = year.toString().length > 0;
    if (validDay && validMonth && validDate && validLength && validYear) {
        return date;
    }
    return null;
}
function parseCalendarYear(year, localeData) {
    return processCalendarYear(year, localeData, "read");
}
function formatCalendarYear(year, localeData) {
    return processCalendarYear(year, localeData, "write");
}
function processCalendarYear(year, localeData, mode) {
    if (localeData["default-calendar"] !== "buddhist") {
        return year;
    }
    const BUDDHIST_CALENDAR_YEAR_OFFSET = 543;
    const yearOffset = BUDDHIST_CALENDAR_YEAR_OFFSET * (mode === "read" ? -1 : 1);
    return year + yearOffset;
}
/**
 * Retrieve day, month, and year strings from a localized string
 *
 * @param string
 * @param localeData
 */
function datePartsFromLocalizedString(string, localeData) {
    const { separator, unitOrder } = localeData;
    const order = getOrder(unitOrder);
    const values = string.split(separator).map((part) => numberStringFormatter.delocalize(part));
    const day = values[order.indexOf("d")];
    const month = values[order.indexOf("m")];
    const year = values[order.indexOf("y")];
    return { day, month, year };
}
/**
 * Return first portion of ISO string (YYYY-mm-dd)
 *
 * @param date
 */
function dateToISO(date) {
    if (date instanceof Date) {
        return new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().split("T")[0];
    }
    return "";
}
/**
 * Retrieve day, month, and year strings from a ISO string (YYYY-mm-dd)
 *
 * @param string
 * @param isoDate
 */
function datePartsFromISO(isoDate) {
    const dateParts = isoDate.split("-");
    return { day: dateParts[2], month: dateParts[1], year: dateParts[0] };
}
/**
 * Check if two dates are the same day, month, year
 *
 * @param d1
 * @param d2
 */
function sameDate(d1, d2) {
    return (d1 instanceof Date &&
        d2 instanceof Date &&
        d1.getDate() === d2.getDate() &&
        d1.getMonth() === d2.getMonth() &&
        d1.getFullYear() === d2.getFullYear());
}
/**
 * Get a date one month in the past
 *
 * @param date
 */
function prevMonth(date) {
    const month = date.getMonth();
    const nextDate = new Date(date);
    nextDate.setMonth(month - 1);
    // date doesn't exist in new month, use last day
    if (month === nextDate.getMonth()) {
        return new Date(date.getFullYear(), month, 0);
    }
    return nextDate;
}
/**
 * Get a date one month in the future
 *
 * @param date
 */
function nextMonth(date) {
    const month = date.getMonth();
    const nextDate = new Date(date);
    nextDate.setMonth(month + 1);
    // date doesn't exist in new month, use last day
    if ((month + 2) % 7 === nextDate.getMonth() % 7) {
        return new Date(date.getFullYear(), month + 2, 0);
    }
    return nextDate;
}
/**
 * Parse numeric units for day, month, and year from a localized string
 * month starts at 0 (can pass to date constructor)
 * can return values as number or string
 *
 * @param string
 * @param localeData
 */
function parseDateString(string, localeData) {
    const { day, month, year } = datePartsFromLocalizedString(string, localeData);
    return {
        day: parseInt(day),
        month: parseInt(month) - 1,
        year: parseInt(year),
    };
}
/**
 * Based on the unitOrder string, find order of month, day, and year for locale
 *
 * @param unitOrder
 */
function getOrder(unitOrder) {
    const signifiers = ["d", "m", "y"];
    const order = unitOrder.toLowerCase();
    return signifiers.sort((a, b) => order.indexOf(a) - order.indexOf(b));
}
/**
 * Get number of days between two dates
 *
 * @param date1
 * @param date2
 */
function getDaysDiff(date1, date2) {
    const ts1 = date1.getTime();
    const ts2 = date2.getTime();
    return (ts1 - ts2) / (1000 * 3600 * 24);
}
/**
 * Set time of the day to the end.
 *
 * @param {Date} date Date.
 * @returns {Date} Date with time set to end of day .
 */
function setEndOfDay(date) {
    date.setHours(23, 59, 59, 999);
    return date;
}

const HEADING_LEVEL = 2;

/**
 *  Maps value to valueAsDate
 *
 * @param value
 */
function getValueAsDateRange(value) {
    return value.map((v, index) => dateFromISO(v, index === 1));
}

const datePickerCss = "/*!@:host*/.sc-calcite-date-picker-h{box-sizing:border-box;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host **/.sc-calcite-date-picker-h *.sc-calcite-date-picker{box-sizing:border-box}/*!@:host*/.sc-calcite-date-picker-h{display:inline-block;inline-size:auto;overflow:visible;border-radius:0px;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-1);vertical-align:top}/*!@:host([scale=s])*/[scale=s].sc-calcite-date-picker-h{inline-size:234px;min-inline-size:216px;max-inline-size:380px}/*!@:host([scale=m])*/[scale=m].sc-calcite-date-picker-h{inline-size:304px;min-inline-size:272px;max-inline-size:480px}/*!@:host([scale=l])*/[scale=l].sc-calcite-date-picker-h{inline-size:370px;min-inline-size:320px;max-inline-size:600px}/*!@:host([hidden])*/[hidden].sc-calcite-date-picker-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-date-picker{display:none}";

class DatePicker {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteDatePickerChange = createEvent(this, "calciteDatePickerChange", 6);
        this.calciteDatePickerRangeChange = createEvent(this, "calciteDatePickerRangeChange", 6);
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.keyDownHandler = (event) => {
            if (event.key === "Escape") {
                this.resetActiveDates();
            }
        };
        this.monthHeaderSelectChange = (event) => {
            const date = new Date(event.detail);
            if (!this.range) {
                this.activeDate = date;
            }
            else {
                if (this.activeRange === "end") {
                    this.activeEndDate = date;
                }
                else {
                    this.activeStartDate = date;
                }
                this.mostRecentRangeValue = date;
            }
        };
        this.monthActiveDateChange = (event) => {
            const date = new Date(event.detail);
            if (!this.range) {
                this.activeDate = date;
            }
            else {
                if (this.activeRange === "end") {
                    this.activeEndDate = date;
                }
                else {
                    this.activeStartDate = date;
                }
                this.mostRecentRangeValue = date;
            }
        };
        this.monthHoverChange = (event) => {
            if (!this.range) {
                this.hoverRange = undefined;
                return;
            }
            const { valueAsDate } = this;
            const start = Array.isArray(valueAsDate) && valueAsDate[0];
            const end = Array.isArray(valueAsDate) && valueAsDate[1];
            const date = new Date(event.detail);
            this.hoverRange = {
                focused: this.activeRange || "start",
                start,
                end,
            };
            if (!this.proximitySelectionDisabled) {
                if (start && end) {
                    const startDiff = getDaysDiff(date, start);
                    const endDiff = getDaysDiff(date, end);
                    if (endDiff > 0) {
                        this.hoverRange.end = date;
                        this.hoverRange.focused = "end";
                    }
                    else if (startDiff < 0) {
                        this.hoverRange.start = date;
                        this.hoverRange.focused = "start";
                    }
                    else if (startDiff > endDiff) {
                        this.hoverRange.start = date;
                        this.hoverRange.focused = "start";
                    }
                    else {
                        this.hoverRange.end = date;
                        this.hoverRange.focused = "end";
                    }
                }
                else {
                    if (start) {
                        if (date < start) {
                            this.hoverRange = {
                                focused: "start",
                                start: date,
                                end: start,
                            };
                        }
                        else {
                            this.hoverRange.end = date;
                            this.hoverRange.focused = "end";
                        }
                    }
                }
            }
            else {
                if (!end) {
                    if (date < start) {
                        this.hoverRange = {
                            focused: "start",
                            start: date,
                            end: start,
                        };
                    }
                    else {
                        this.hoverRange.end = date;
                        this.hoverRange.focused = "end";
                    }
                }
                else {
                    this.hoverRange = undefined;
                }
            }
            event.stopPropagation();
        };
        this.monthMouseOutChange = () => {
            if (this.hoverRange) {
                this.hoverRange = undefined;
            }
        };
        this.resetActiveDates = () => {
            const { valueAsDate } = this;
            if (!Array.isArray(valueAsDate) && valueAsDate && valueAsDate !== this.activeDate) {
                this.activeDate = new Date(valueAsDate);
            }
            if (Array.isArray(valueAsDate)) {
                if (valueAsDate[0] && valueAsDate[0] !== this.activeStartDate) {
                    this.activeStartDate = new Date(valueAsDate[0]);
                }
                if (valueAsDate[1] && valueAsDate[1] !== this.activeEndDate) {
                    this.activeEndDate = new Date(valueAsDate[1]);
                }
            }
        };
        /**
         * Event handler for when the selected date changes
         *
         * @param event
         */
        this.monthDateChange = (event) => {
            const date = new Date(event.detail);
            const isoDate = dateToISO(date);
            if (!this.range && isoDate === dateToISO(this.valueAsDate)) {
                return;
            }
            if (!this.range) {
                this.value = isoDate || "";
                this.valueAsDate = date || null;
                this.activeDate = date || null;
                this.calciteDatePickerChange.emit();
                return;
            }
            const start = this.getStartDate();
            const end = this.getEndDate();
            if (!start || (!end && date < start)) {
                if (start) {
                    this.setEndDate(new Date(start));
                }
                if (this.activeRange == "end") {
                    this.setEndDate(date);
                }
                else {
                    this.setStartDate(date);
                }
            }
            else if (!end) {
                this.setEndDate(date);
            }
            else {
                if (!this.proximitySelectionDisabled) {
                    if (this.activeRange) {
                        if (this.activeRange == "end") {
                            this.setEndDate(date);
                        }
                        else {
                            this.setStartDate(date);
                        }
                    }
                    else {
                        const startDiff = getDaysDiff(date, start);
                        const endDiff = getDaysDiff(date, end);
                        if (endDiff === 0 || startDiff < 0) {
                            this.setStartDate(date);
                        }
                        else if (startDiff === 0 || endDiff < 0) {
                            this.setEndDate(date);
                        }
                        else if (startDiff < endDiff) {
                            this.setStartDate(date);
                        }
                        else {
                            this.setEndDate(date);
                        }
                    }
                }
                else {
                    this.setStartDate(date);
                }
            }
            this.calciteDatePickerChange.emit();
        };
        this.activeDate = undefined;
        this.activeRange = undefined;
        this.value = undefined;
        this.headingLevel = undefined;
        this.valueAsDate = undefined;
        this.minAsDate = undefined;
        this.maxAsDate = undefined;
        this.min = undefined;
        this.max = undefined;
        this.numberingSystem = undefined;
        this.scale = "m";
        this.range = false;
        this.proximitySelectionDisabled = false;
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.activeEndDate = undefined;
        this.activeStartDate = undefined;
        this.dateTimeFormat = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
        this.endAsDate = undefined;
        this.hoverRange = undefined;
        this.localeData = undefined;
        this.mostRecentRangeValue = undefined;
        this.startAsDate = undefined;
    }
    activeDateWatcher(newActiveDate) {
        if (this.activeRange === "end") {
            this.activeEndDate = newActiveDate;
        }
    }
    valueAsDateWatcher(newValueAsDate) {
        if (this.range && Array.isArray(newValueAsDate)) {
            const { activeStartDate, activeEndDate } = this;
            const newActiveStartDate = newValueAsDate[0];
            const newActiveEndDate = newValueAsDate[1];
            this.activeStartDate = activeStartDate !== newActiveStartDate && newActiveStartDate;
            this.activeEndDate = activeEndDate !== newActiveEndDate && newActiveEndDate;
        }
        else if (newValueAsDate && newValueAsDate !== this.activeDate) {
            this.activeDate = newValueAsDate;
        }
    }
    onMinChanged(min) {
        if (min) {
            this.minAsDate = dateFromISO(min);
        }
    }
    onMaxChanged(max) {
        if (max) {
            this.maxAsDate = dateFromISO(max);
        }
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component's first focusable element. */
    async setFocus() {
        await componentFocusable(this);
        this.el.focus();
    }
    /**
     * Resets active date state.
     * @internal
     */
    async reset() {
        this.resetActiveDates();
        this.mostRecentRangeValue = undefined;
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectLocalized(this);
        connectMessages(this);
        if (Array.isArray(this.value)) {
            this.valueAsDate = getValueAsDateRange(this.value);
        }
        else if (this.value) {
            this.valueAsDate = dateFromISO(this.value);
        }
        if (this.min) {
            this.minAsDate = dateFromISO(this.min);
        }
        if (this.max) {
            this.maxAsDate = dateFromISO(this.max);
        }
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await this.loadLocaleData();
        this.onMinChanged(this.min);
        this.onMaxChanged(this.max);
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    render() {
        const date = dateFromRange(this.range && Array.isArray(this.valueAsDate) ? this.valueAsDate[0] : this.valueAsDate, this.minAsDate, this.maxAsDate);
        let activeDate = this.getActiveDate(date, this.minAsDate, this.maxAsDate);
        const endDate = this.range && Array.isArray(this.valueAsDate)
            ? dateFromRange(this.valueAsDate[1], this.minAsDate, this.maxAsDate)
            : null;
        const activeEndDate = this.getActiveEndDate(endDate, this.minAsDate, this.maxAsDate);
        if ((this.activeRange === "end" ||
            (this.hoverRange?.focused === "end" && (!this.proximitySelectionDisabled || endDate))) &&
            activeEndDate) {
            activeDate = activeEndDate;
        }
        if (this.range && this.mostRecentRangeValue) {
            activeDate = this.mostRecentRangeValue;
        }
        const minDate = this.range && this.activeRange
            ? this.activeRange === "start"
                ? this.minAsDate
                : date || this.minAsDate
            : this.minAsDate;
        const maxDate = this.range && this.activeRange
            ? this.activeRange === "start"
                ? endDate || this.maxAsDate
                : this.maxAsDate
            : this.maxAsDate;
        return (hAsync(Host, { onBlur: this.resetActiveDates, onKeyDown: this.keyDownHandler }, this.renderCalendar(activeDate, maxDate, minDate, date, endDate)));
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    valueHandler(value) {
        if (Array.isArray(value)) {
            this.valueAsDate = getValueAsDateRange(value);
        }
        else if (value) {
            this.valueAsDate = dateFromISO(value);
        }
    }
    async loadLocaleData() {
        {
            return;
        }
    }
    /**
     * Render calcite-date-picker-month-header and calcite-date-picker-month
     *
     * @param activeDate
     * @param maxDate
     * @param minDate
     * @param date
     * @param endDate
     */
    renderCalendar(activeDate, maxDate, minDate, date, endDate) {
        return (this.localeData && [
            hAsync("calcite-date-picker-month-header", { activeDate: activeDate, headingLevel: this.headingLevel || HEADING_LEVEL, localeData: this.localeData, max: maxDate, messages: this.messages, min: minDate, onCalciteInternalDatePickerSelect: this.monthHeaderSelectChange, scale: this.scale, selectedDate: this.activeRange === "end" ? endDate : date || new Date() }),
            hAsync("calcite-date-picker-month", { activeDate: activeDate, dateTimeFormat: this.dateTimeFormat, endDate: this.range ? endDate : undefined, hoverRange: this.hoverRange, localeData: this.localeData, max: maxDate, min: minDate, onCalciteInternalDatePickerActiveDateChange: this.monthActiveDateChange, onCalciteInternalDatePickerHover: this.monthHoverChange, onCalciteInternalDatePickerMouseOut: this.monthMouseOutChange, onCalciteInternalDatePickerSelect: this.monthDateChange, scale: this.scale, selectedDate: this.activeRange === "end" ? endDate : date, startDate: this.range ? date : undefined }),
        ]);
    }
    getEndDate() {
        return (Array.isArray(this.valueAsDate) && this.valueAsDate[1]) || undefined;
    }
    setEndDate(date) {
        const startDate = this.getStartDate();
        const newEndDate = date ? setEndOfDay(date) : date;
        this.value = [dateToISO(startDate), dateToISO(date)];
        this.valueAsDate = [startDate, date];
        this.mostRecentRangeValue = newEndDate;
        this.calciteDatePickerRangeChange.emit();
        this.activeEndDate = date || null;
    }
    getStartDate() {
        return Array.isArray(this.valueAsDate) && this.valueAsDate[0];
    }
    setStartDate(date) {
        const endDate = this.getEndDate();
        this.value = [dateToISO(date), dateToISO(endDate)];
        this.valueAsDate = [date, endDate];
        this.mostRecentRangeValue = date;
        this.calciteDatePickerRangeChange.emit();
        this.activeStartDate = date || null;
    }
    /**
     * Get an active date using the value, or current date as default
     *
     * @param value
     * @param min
     * @param max
     */
    getActiveDate(value, min, max) {
        return dateFromRange(this.activeDate, min, max) || value || dateFromRange(new Date(), min, max);
    }
    getActiveEndDate(value, min, max) {
        return (dateFromRange(this.activeEndDate, min, max) || value || dateFromRange(new Date(), min, max));
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "activeDate": ["activeDateWatcher"],
        "valueAsDate": ["valueAsDateWatcher"],
        "min": ["onMinChanged"],
        "max": ["onMaxChanged"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange", "loadLocaleData"],
        "value": ["valueHandler"]
    }; }
    static get style() { return datePickerCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-date-picker",
        "$members$": {
            "activeDate": [1040],
            "activeRange": [513, "active-range"],
            "value": [1025],
            "headingLevel": [514, "heading-level"],
            "valueAsDate": [1040],
            "minAsDate": [1040],
            "maxAsDate": [1040],
            "min": [513],
            "max": [513],
            "numberingSystem": [513, "numbering-system"],
            "scale": [513],
            "range": [516],
            "proximitySelectionDisabled": [516, "proximity-selection-disabled"],
            "messageOverrides": [1040],
            "messages": [1040],
            "activeEndDate": [32],
            "activeStartDate": [32],
            "dateTimeFormat": [32],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "endAsDate": [32],
            "hoverRange": [32],
            "localeData": [32],
            "mostRecentRangeValue": [32],
            "startAsDate": [32],
            "setFocus": [64],
            "reset": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["activeRange", "active-range"], ["headingLevel", "heading-level"], ["min", "min"], ["max", "max"], ["numberingSystem", "numbering-system"], ["scale", "scale"], ["range", "range"], ["proximitySelectionDisabled", "proximity-selection-disabled"]]
    }; }
}

const datePickerDayCss = "/*!@:host([disabled])*/[disabled].sc-calcite-date-picker-day-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-date-picker-day-h *.sc-calcite-date-picker-day,.sc-calcite-date-picker-day-h[disabled].sc-calcite-date-picker-day-s>*,.sc-calcite-date-picker-day-h[disabled] .sc-calcite-date-picker-day-s>*{pointer-events:none}/*!@:host*/.sc-calcite-date-picker-day-h{position:relative;display:flex;cursor:pointer;color:var(--calcite-color-text-3)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-date-picker-day-h[disabled] .sc-calcite-date-picker-day-s>[calcite-hydrated][disabled],[disabled].sc-calcite-date-picker-day-h [calcite-hydrated][disabled].sc-calcite-date-picker-day{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-date-picker-day{display:contents}/*!@.day-v-wrapper*/.day-v-wrapper.sc-calcite-date-picker-day{flex:1 1 auto}/*!@.day-wrapper*/.day-wrapper.sc-calcite-date-picker-day{position:relative;display:flex;flex-direction:column;align-items:center}/*!@:host([range]) .day-wrapper:before, :host([range]) .day-wrapper:after,\n:host([range-hover]) .day-wrapper:before,\n:host([range-hover]) .day-wrapper:after*/[range].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[range].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[range-hover].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[range-hover].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after{pointer-events:none;position:absolute;inset-block:0;content:\"\";block-size:var(--calcite-internal-day-size);inline-size:var(--calcite-internal-day-size)}/*!@.day*/.day.sc-calcite-date-picker-day{z-index:var(--calcite-z-index);display:flex;align-items:center;justify-content:center;border-radius:9999px;font-size:var(--calcite-font-size--2);line-height:1rem;line-height:1;color:var(--calcite-color-text-3);outline-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;background:none;box-shadow:0 0 0 2px transparent;block-size:var(--calcite-internal-day-size);inline-size:var(--calcite-internal-day-size)}/*!@.text*/.text.sc-calcite-date-picker-day{margin-block:1px 0px;margin-inline-start:0px}/*!@:host([scale=s])*/[scale=s].sc-calcite-date-picker-day-h{--calcite-internal-day-size:27px}/*!@:host([scale=s]) .day-v-wrapper*/[scale=s].sc-calcite-date-picker-day-h .day-v-wrapper.sc-calcite-date-picker-day{padding-block:0.125rem}/*!@:host([scale=s]) .day-wrapper*/[scale=s].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day{padding:0px}/*!@:host([scale=s]) .day*/[scale=s].sc-calcite-date-picker-day-h .day.sc-calcite-date-picker-day{font-size:var(--calcite-font-size--2)}/*!@:host([scale=m])*/[scale=m].sc-calcite-date-picker-day-h{--calcite-internal-day-size:33px}/*!@:host([scale=m]) .day-v-wrapper*/[scale=m].sc-calcite-date-picker-day-h .day-v-wrapper.sc-calcite-date-picker-day{padding-block:0.25rem}/*!@:host([scale=m]) .day-wrapper*/[scale=m].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day{padding:0px}/*!@:host([scale=m]) .day*/[scale=m].sc-calcite-date-picker-day-h .day.sc-calcite-date-picker-day{font-size:var(--calcite-font-size--1)}/*!@:host([scale=l])*/[scale=l].sc-calcite-date-picker-day-h{--calcite-internal-day-size:43px}/*!@:host([scale=l]) .day-v-wrapper*/[scale=l].sc-calcite-date-picker-day-h .day-v-wrapper.sc-calcite-date-picker-day{padding-block:0.25rem}/*!@:host([scale=l]) .day-wrapper*/[scale=l].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day{padding-inline:0.25rem}/*!@:host([scale=l]) .day*/[scale=l].sc-calcite-date-picker-day-h .day.sc-calcite-date-picker-day{font-size:var(--calcite-font-size-0)}/*!@:host(:not([current-month])) .day*/.sc-calcite-date-picker-day-h:not([current-month]) .day.sc-calcite-date-picker-day{opacity:var(--calcite-opacity-disabled)}/*!@:host(:hover:not([disabled]):not([selected])) .day,\n:host([active]:not([range]):not([selected])) .day*/.sc-calcite-date-picker-day-h:hover:not([disabled]):not([selected]) .day.sc-calcite-date-picker-day,[active].sc-calcite-date-picker-day-h:not([range]):not([selected]) .day.sc-calcite-date-picker-day{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-text-1)}/*!@:host(:focus),\n:host([active])*/.sc-calcite-date-picker-day-h:focus,[active].sc-calcite-date-picker-day-h{outline:2px solid transparent;outline-offset:2px}/*!@:host(:focus:not([disabled])) .day*/.sc-calcite-date-picker-day-h:focus:not([disabled]) .day.sc-calcite-date-picker-day{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([selected]) .day*/[selected].sc-calcite-date-picker-day-h .day.sc-calcite-date-picker-day{font-weight:var(--calcite-font-weight-medium);background-color:var(--calcite-color-brand);color:var(--calcite-color-foreground-1)}/*!@:host(:focus:not([disabled])) .day,\n:host([start-of-range]:not(:focus)) .day,\n:host([end-of-range]:not(:focus)) .day*/.sc-calcite-date-picker-day-h:focus:not([disabled]) .day.sc-calcite-date-picker-day,[start-of-range].sc-calcite-date-picker-day-h:not(:focus) .day.sc-calcite-date-picker-day,[end-of-range].sc-calcite-date-picker-day-h:not(:focus) .day.sc-calcite-date-picker-day{box-shadow:0 0 0 2px var(--calcite-color-foreground-1)}/*!@:host([range-hover]:not([selected])) .day-wrapper:before,\n:host([highlighted]:not([selected])) .day-wrapper:before*/[range-hover].sc-calcite-date-picker-day-h:not([selected]) .day-wrapper.sc-calcite-date-picker-day:before,[highlighted].sc-calcite-date-picker-day-h:not([selected]) .day-wrapper.sc-calcite-date-picker-day:before{inset-inline-end:50%;border-radius:0}/*!@:host([range-hover]:not([selected])) .day-wrapper:after,\n:host([highlighted]:not([selected])) .day-wrapper:after*/[range-hover].sc-calcite-date-picker-day-h:not([selected]) .day-wrapper.sc-calcite-date-picker-day:after,[highlighted].sc-calcite-date-picker-day-h:not([selected]) .day-wrapper.sc-calcite-date-picker-day:after{inset-inline-start:50%;border-radius:0}/*!@:host([range-hover]:not([selected])) .day,\n:host([highlighted]:not([selected])) .day*/[range-hover].sc-calcite-date-picker-day-h:not([selected]) .day.sc-calcite-date-picker-day,[highlighted].sc-calcite-date-picker-day-h:not([selected]) .day.sc-calcite-date-picker-day{color:var(--calcite-color-text-1)}/*!@:host([highlighted]) .day-wrapper:before, :host([highlighted]) .day-wrapper:after,\n:host([selected]:not(.hover--outside-range)) .day-wrapper:before,\n:host([selected]:not(.hover--outside-range)) .day-wrapper:after*/[highlighted].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[highlighted].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[selected].sc-calcite-date-picker-day-h:not(.hover--outside-range) .day-wrapper.sc-calcite-date-picker-day:before,[selected].sc-calcite-date-picker-day-h:not(.hover--outside-range) .day-wrapper.sc-calcite-date-picker-day:after{background-color:var(--calcite-color-foreground-current)}/*!@:host([range-hover]:not([selected])) .day-wrapper:before, :host([range-hover]:not([selected])) .day-wrapper:after*/[range-hover].sc-calcite-date-picker-day-h:not([selected]) .day-wrapper.sc-calcite-date-picker-day:before,[range-hover].sc-calcite-date-picker-day-h:not([selected]) .day-wrapper.sc-calcite-date-picker-day:after{background-color:var(--calcite-color-foreground-2)}/*!@:host(:hover[range-hover]:not([selected]).focused--end) .day-wrapper:before,\n:host([highlighted][end-of-range]) .day-wrapper:before,\n:host([highlighted][range-edge=end]) .day-wrapper:before,\n:host([range-hover][range-edge=end]) .day-wrapper:before,\n:host(:hover[range-hover].focused--end.hover--outside-range) .day-wrapper:before*/.sc-calcite-date-picker-day-h:hover[range-hover]:not([selected]).focused--end .day-wrapper.sc-calcite-date-picker-day:before,[highlighted][end-of-range].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[highlighted][range-edge=end].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[range-hover][range-edge=end].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,.sc-calcite-date-picker-day-h:hover[range-hover].focused--end.hover--outside-range .day-wrapper.sc-calcite-date-picker-day:before{inset-inline-end:50%}/*!@:host(:hover[range-hover]:not([selected]).focused--end) .day-wrapper:after,\n:host([highlighted][end-of-range]) .day-wrapper:after,\n:host([highlighted][range-edge=end]) .day-wrapper:after,\n:host([range-hover][range-edge=end]) .day-wrapper:after,\n:host(:hover[range-hover].focused--end.hover--outside-range) .day-wrapper:after*/.sc-calcite-date-picker-day-h:hover[range-hover]:not([selected]).focused--end .day-wrapper.sc-calcite-date-picker-day:after,[highlighted][end-of-range].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[highlighted][range-edge=end].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[range-hover][range-edge=end].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,.sc-calcite-date-picker-day-h:hover[range-hover].focused--end.hover--outside-range .day-wrapper.sc-calcite-date-picker-day:after{inset-inline-start:50%;border-start-end-radius:var(--calcite-internal-day-size);border-end-end-radius:var(--calcite-internal-day-size);inline-size:calc(var(--calcite-internal-day-size) / 2)}/*!@:host([highlighted][start-of-range]) .day-wrapper:before,\n:host([highlighted][range-edge=start]) .day-wrapper:before,\n:host([range-hover][range-edge=start]) .day-wrapper:before,\n:host(:hover[range-hover]:not([selected]).focused--start) .day-wrapper:before,\n:host([start-of-range].hover--inside-range) .day-wrapper:before,\n:host(:hover[range-hover].focused--start.hover--outside-range) .day-wrapper:before*/[highlighted][start-of-range].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[highlighted][range-edge=start].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[range-hover][range-edge=start].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,.sc-calcite-date-picker-day-h:hover[range-hover]:not([selected]).focused--start .day-wrapper.sc-calcite-date-picker-day:before,[start-of-range].hover--inside-range.sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,.sc-calcite-date-picker-day-h:hover[range-hover].focused--start.hover--outside-range .day-wrapper.sc-calcite-date-picker-day:before{inset-inline-end:50%;border-start-start-radius:var(--calcite-internal-day-size);border-end-start-radius:var(--calcite-internal-day-size);inline-size:calc(var(--calcite-internal-day-size) / 2)}/*!@:host([highlighted][start-of-range]) .day-wrapper:after,\n:host([highlighted][range-edge=start]) .day-wrapper:after,\n:host([range-hover][range-edge=start]) .day-wrapper:after,\n:host(:hover[range-hover]:not([selected]).focused--start) .day-wrapper:after,\n:host([start-of-range].hover--inside-range) .day-wrapper:after,\n:host(:hover[range-hover].focused--start.hover--outside-range) .day-wrapper:after*/[highlighted][start-of-range].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[highlighted][range-edge=start].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[range-hover][range-edge=start].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,.sc-calcite-date-picker-day-h:hover[range-hover]:not([selected]).focused--start .day-wrapper.sc-calcite-date-picker-day:after,[start-of-range].hover--inside-range.sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,.sc-calcite-date-picker-day-h:hover[range-hover].focused--start.hover--outside-range .day-wrapper.sc-calcite-date-picker-day:after{inset-inline-start:50%}/*!@:host([range-hover][start-of-range][range-edge=end]) .day-wrapper:after, :host([range-hover][start-of-range][range-edge=end]) .day-wrapper:before,\n:host([range-hover][end-of-range][range-edge=start]) .day-wrapper:after,\n:host([range-hover][end-of-range][range-edge=start]) .day-wrapper:before,\n:host([start-of-range][range-edge=end].hover--inside-range) .day-wrapper:after,\n:host([start-of-range][range-edge=end].hover--inside-range) .day-wrapper:before,\n:host([end-of-range]) .day-wrapper:after,\n:host([end-of-range]) .day-wrapper:before*/[range-hover][start-of-range][range-edge=end].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[range-hover][start-of-range][range-edge=end].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[range-hover][end-of-range][range-edge=start].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[range-hover][end-of-range][range-edge=start].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[start-of-range][range-edge=end].hover--inside-range.sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[start-of-range][range-edge=end].hover--inside-range.sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[end-of-range].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[end-of-range].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before{content:unset}/*!@:host(:hover[range-hover]:not([selected]).focused--start) .day,\n:host(:hover[range-hover]:not([selected]).focused--end) .day,\n:host(:hover[range-hover]:not([selected]).focused--start.hover--outside-range) .day,\n:host(:hover[range-hover]:not([selected]).focused--end.hover--outside-range) .day*/.sc-calcite-date-picker-day-h:hover[range-hover]:not([selected]).focused--start .day.sc-calcite-date-picker-day,.sc-calcite-date-picker-day-h:hover[range-hover]:not([selected]).focused--end .day.sc-calcite-date-picker-day,.sc-calcite-date-picker-day-h:hover[range-hover]:not([selected]).focused--start.hover--outside-range .day.sc-calcite-date-picker-day,.sc-calcite-date-picker-day-h:hover[range-hover]:not([selected]).focused--end.hover--outside-range .day.sc-calcite-date-picker-day{box-shadow:0 0 0 2px var(--calcite-color-foreground-1)}@media (forced-colors: active){/*!@.day*/.day.sc-calcite-date-picker-day{border-radius:0px}/*!@:host([selected])*/[selected].sc-calcite-date-picker-day-h{outline:2px solid canvasText}/*!@:host(:hover:not([selected])) .day*/.sc-calcite-date-picker-day-h:hover:not([selected]) .day.sc-calcite-date-picker-day{border-radius:50%}/*!@:host([range][selected]) .day-wrapper:before, :host([range][selected]) .day-wrapper:after,\n  :host([highlighted]) .day-wrapper:before,\n  :host([highlighted]) .day-wrapper:after,\n  :host([range-hover]:not([selected])) .day-wrapper:before,\n  :host([range-hover]:not([selected])) .day-wrapper:after*/[range][selected].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[range][selected].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[highlighted].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[highlighted].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[range-hover].sc-calcite-date-picker-day-h:not([selected]) .day-wrapper.sc-calcite-date-picker-day:before,[range-hover].sc-calcite-date-picker-day-h:not([selected]) .day-wrapper.sc-calcite-date-picker-day:after{background-color:highlight}/*!@:host([range-hover]) .day-wrapper:before, :host([range-hover]) .day-wrapper:after,\n  :host([range][selected][start-of-range]) .day-wrapper:before,\n  :host([range][selected][start-of-range]) .day-wrapper:after,\n  :host([range][selected][end-of-range]) .day-wrapper:before,\n  :host([range][selected][end-of-range]) .day-wrapper:after*/[range-hover].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[range-hover].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[range][selected][start-of-range].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[range][selected][start-of-range].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after,[range][selected][end-of-range].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:before,[range][selected][end-of-range].sc-calcite-date-picker-day-h .day-wrapper.sc-calcite-date-picker-day:after{background-color:canvas}}/*!@:host([hidden])*/[hidden].sc-calcite-date-picker-day-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-date-picker-day{display:none}";

class DatePickerDay {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteDaySelect = createEvent(this, "calciteDaySelect", 6);
        this.calciteInternalDayHover = createEvent(this, "calciteInternalDayHover", 6);
        //--------------------------------------------------------------------------
        //
        //  Event Listeners
        //
        //--------------------------------------------------------------------------
        this.onClick = () => {
            if (this.disabled) {
                return;
            }
            this.calciteDaySelect.emit();
        };
        this.keyDownHandler = (event) => {
            if (isActivationKey(event.key)) {
                !this.disabled && this.calciteDaySelect.emit();
                event.preventDefault();
            }
        };
        this.day = undefined;
        this.dateTimeFormat = undefined;
        this.disabled = false;
        this.currentMonth = false;
        this.selected = false;
        this.highlighted = false;
        this.range = false;
        this.rangeEdge = undefined;
        this.startOfRange = false;
        this.endOfRange = false;
        this.rangeHover = false;
        this.active = false;
        this.scale = undefined;
        this.value = undefined;
    }
    pointerOverHandler() {
        if (this.disabled) {
            return;
        }
        this.calciteInternalDayHover.emit();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentWillLoad() {
        this.parentDatePickerEl = closestElementCrossShadowBoundary(this.el, "calcite-date-picker");
    }
    render() {
        const dayId = dateToISO(this.value).replaceAll("-", "");
        if (this.parentDatePickerEl) {
            const { numberingSystem, lang: locale } = this.parentDatePickerEl;
            numberStringFormatter.numberFormatOptions = {
                useGrouping: false,
                ...(numberingSystem && { numberingSystem }),
                ...(locale && { locale }),
            };
        }
        const formattedDay = numberStringFormatter.localize(String(this.day));
        const dayLabel = this.dateTimeFormat.format(this.value);
        return (hAsync(Host, { "aria-disabled": toAriaBoolean(this.disabled), "aria-label": dayLabel, "aria-selected": toAriaBoolean(this.active), id: dayId, onClick: this.onClick, onKeyDown: this.keyDownHandler, role: "button", tabIndex: this.active && !this.disabled ? 0 : -1 }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { "aria-hidden": "true", class: { "day-v-wrapper": true } }, hAsync("div", { class: "day-wrapper" }, hAsync("span", { class: "day" }, hAsync("span", { class: "text" }, formattedDay)))))));
    }
    connectedCallback() {
        connectInteractive(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
    }
    get el() { return getElement(this); }
    static get style() { return datePickerDayCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-date-picker-day",
        "$members$": {
            "day": [2],
            "dateTimeFormat": [16],
            "disabled": [516],
            "currentMonth": [516, "current-month"],
            "selected": [516],
            "highlighted": [516],
            "range": [516],
            "rangeEdge": [513, "range-edge"],
            "startOfRange": [516, "start-of-range"],
            "endOfRange": [516, "end-of-range"],
            "rangeHover": [516, "range-hover"],
            "active": [516],
            "scale": [513],
            "value": [16]
        },
        "$listeners$": [[1, "pointerover", "pointerOverHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["currentMonth", "current-month"], ["selected", "selected"], ["highlighted", "highlighted"], ["range", "range"], ["rangeEdge", "range-edge"], ["startOfRange", "start-of-range"], ["endOfRange", "end-of-range"], ["rangeHover", "range-hover"], ["active", "active"], ["scale", "scale"]]
    }; }
}

const datePickerMonthCss = "/*!@:host([hidden])*/[hidden].sc-calcite-date-picker-month-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-date-picker-month{display:none}/*!@.calendar*/.calendar.sc-calcite-date-picker-month{margin-block-end:0.25rem}/*!@.week-headers*/.week-headers.sc-calcite-date-picker-month{display:flex;border-width:0px;border-block-start-width:1px;border-style:solid;border-color:var(--calcite-color-border-3);padding-block:0px;padding-inline:0.25rem}/*!@.week-header*/.week-header.sc-calcite-date-picker-month{text-align:center;font-weight:var(--calcite-font-weight-bold);color:var(--calcite-color-text-3);inline-size:14.2857142857%}/*!@.day*/.day.sc-calcite-date-picker-month{display:flex;min-inline-size:0px;justify-content:center;inline-size:14.2857142857%}/*!@.day calcite-date-picker-day*/.day.sc-calcite-date-picker-month calcite-date-picker-day.sc-calcite-date-picker-month{inline-size:100%}/*!@:host([scale=s]) .week-header*/[scale=s].sc-calcite-date-picker-month-h .week-header.sc-calcite-date-picker-month{padding-inline:0px;padding-block:0.5rem 0.75rem;font-size:var(--calcite-font-size--2);line-height:1rem}/*!@:host([scale=m]) .week-header*/[scale=m].sc-calcite-date-picker-month-h .week-header.sc-calcite-date-picker-month{padding-inline:0px;padding-block:0.75rem 1rem;font-size:var(--calcite-font-size--2);line-height:1rem}/*!@:host([scale=l]) .week-header*/[scale=l].sc-calcite-date-picker-month-h .week-header.sc-calcite-date-picker-month{padding-inline:0px;padding-block:1rem 1.25rem;font-size:var(--calcite-font-size--1);line-height:1rem}/*!@.week-days*/.week-days.sc-calcite-date-picker-month{display:flex;flex-direction:row;padding-block:0px;padding-inline:6px}/*!@.week-days:focus*/.week-days.sc-calcite-date-picker-month:focus{outline:2px solid transparent;outline-offset:2px}";

const DAYS_PER_WEEK = 7;
const DAYS_MAXIMUM_INDEX = 6;
class DatePickerMonth {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalDatePickerSelect = createEvent(this, "calciteInternalDatePickerSelect", 6);
        this.calciteInternalDatePickerHover = createEvent(this, "calciteInternalDatePickerHover", 6);
        this.calciteInternalDatePickerActiveDateChange = createEvent(this, "calciteInternalDatePickerActiveDateChange", 6);
        this.calciteInternalDatePickerMouseOut = createEvent(this, "calciteInternalDatePickerMouseOut", 6);
        //--------------------------------------------------------------------------
        //
        //  Event Listeners
        //
        //--------------------------------------------------------------------------
        this.keyDownHandler = (event) => {
            if (event.defaultPrevented) {
                return;
            }
            const isRTL = this.el.dir === "rtl";
            switch (event.key) {
                case "ArrowUp":
                    event.preventDefault();
                    this.addDays(-7);
                    break;
                case "ArrowRight":
                    event.preventDefault();
                    this.addDays(isRTL ? -1 : 1);
                    break;
                case "ArrowDown":
                    event.preventDefault();
                    this.addDays(7);
                    break;
                case "ArrowLeft":
                    event.preventDefault();
                    this.addDays(isRTL ? 1 : -1);
                    break;
                case "PageUp":
                    event.preventDefault();
                    this.addMonths(-1);
                    break;
                case "PageDown":
                    event.preventDefault();
                    this.addMonths(1);
                    break;
                case "Home":
                    event.preventDefault();
                    this.activeDate.setDate(1);
                    this.addDays();
                    break;
                case "End":
                    event.preventDefault();
                    this.activeDate.setDate(new Date(this.activeDate.getFullYear(), this.activeDate.getMonth() + 1, 0).getDate());
                    this.addDays();
                    break;
                case "Enter":
                case " ":
                    event.preventDefault();
                    break;
                case "Tab":
                    this.activeFocus = false;
            }
        };
        /**
         * Once user is not interacting via keyboard,
         * disable auto focusing of active date
         */
        this.disableActiveFocus = () => {
            this.activeFocus = false;
        };
        this.dayHover = (event) => {
            const target = event.target;
            if (target.disabled) {
                this.calciteInternalDatePickerMouseOut.emit();
            }
            else {
                this.calciteInternalDatePickerHover.emit(target.value);
            }
            event.stopPropagation();
        };
        this.daySelect = (event) => {
            const target = event.target;
            this.calciteInternalDatePickerSelect.emit(target.value);
        };
        this.dateTimeFormat = undefined;
        this.selectedDate = undefined;
        this.activeDate = new Date();
        this.startDate = undefined;
        this.endDate = undefined;
        this.min = undefined;
        this.max = undefined;
        this.scale = undefined;
        this.localeData = undefined;
        this.hoverRange = undefined;
    }
    pointerOutHandler() {
        this.calciteInternalDatePickerMouseOut.emit();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    render() {
        const month = this.activeDate.getMonth();
        const year = this.activeDate.getFullYear();
        const startOfWeek = this.localeData.weekStart % 7;
        const { abbreviated, short, narrow } = this.localeData.days;
        const weekDays = this.scale === "s" ? narrow || short || abbreviated : short || abbreviated || narrow;
        const adjustedWeekDays = [...weekDays.slice(startOfWeek, 7), ...weekDays.slice(0, startOfWeek)];
        const curMonDays = this.getCurrentMonthDays(month, year);
        const prevMonDays = this.getPreviousMonthDays(month, year, startOfWeek);
        const nextMonDays = this.getNextMonthDays(month, year, startOfWeek);
        let dayInWeek = 0;
        const getDayInWeek = () => dayInWeek++ % 7;
        const days = [
            ...prevMonDays.map((day) => {
                return {
                    active: false,
                    day,
                    dayInWeek: getDayInWeek(),
                    date: new Date(year, month - 1, day),
                };
            }),
            ...curMonDays.map((day) => {
                const date = new Date(year, month, day);
                const active = sameDate(date, this.activeDate);
                return {
                    active,
                    currentMonth: true,
                    day,
                    dayInWeek: getDayInWeek(),
                    date,
                    ref: true,
                };
            }),
            ...nextMonDays.map((day) => {
                return {
                    active: false,
                    day,
                    dayInWeek: getDayInWeek(),
                    date: new Date(year, month + 1, day),
                };
            }),
        ];
        const weeks = [];
        for (let i = 0; i < days.length; i += 7) {
            weeks.push(days.slice(i, i + 7));
        }
        return (hAsync(Host, { onFocusOut: this.disableActiveFocus, onKeyDown: this.keyDownHandler }, hAsync("div", { class: "calendar", role: "grid" }, hAsync("div", { class: "week-headers", role: "row" }, adjustedWeekDays.map((weekday) => (hAsync("span", { class: "week-header", role: "columnheader" }, weekday)))), weeks.map((days) => (hAsync("div", { class: "week-days", role: "row" }, days.map((day) => this.renderDateDay(day))))))));
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Add n months to the current month
     *
     * @param step
     */
    addMonths(step) {
        const nextDate = new Date(this.activeDate);
        nextDate.setMonth(this.activeDate.getMonth() + step);
        this.calciteInternalDatePickerActiveDateChange.emit(dateFromRange(nextDate, this.min, this.max));
        this.activeFocus = true;
    }
    /**
     * Add n days to the current date
     *
     * @param step
     */
    addDays(step = 0) {
        const nextDate = new Date(this.activeDate);
        nextDate.setDate(this.activeDate.getDate() + step);
        this.calciteInternalDatePickerActiveDateChange.emit(dateFromRange(nextDate, this.min, this.max));
        this.activeFocus = true;
    }
    /**
     * Get dates for last days of the previous month
     *
     * @param month
     * @param year
     * @param startOfWeek
     */
    getPreviousMonthDays(month, year, startOfWeek) {
        const lastDate = new Date(year, month, 0);
        const date = lastDate.getDate();
        const startDay = lastDate.getDay();
        const days = [];
        if (startDay === (startOfWeek + DAYS_MAXIMUM_INDEX) % DAYS_PER_WEEK) {
            return days;
        }
        if (startDay === startOfWeek) {
            return [date];
        }
        for (let i = (DAYS_PER_WEEK + startDay - startOfWeek) % DAYS_PER_WEEK; i >= 0; i--) {
            days.push(date - i);
        }
        return days;
    }
    /**
     * Get dates for the current month
     *
     * @param month
     * @param year
     */
    getCurrentMonthDays(month, year) {
        const num = new Date(year, month + 1, 0).getDate();
        const days = [];
        for (let i = 0; i < num; i++) {
            days.push(i + 1);
        }
        return days;
    }
    /**
     * Get dates for first days of the next month
     *
     * @param month
     * @param year
     * @param startOfWeek
     */
    getNextMonthDays(month, year, startOfWeek) {
        const endDay = new Date(year, month + 1, 0).getDay();
        const days = [];
        if (endDay === (startOfWeek + DAYS_MAXIMUM_INDEX) % DAYS_PER_WEEK) {
            return days;
        }
        for (let i = 0; i < (DAYS_MAXIMUM_INDEX - (endDay - startOfWeek)) % DAYS_PER_WEEK; i++) {
            days.push(i + 1);
        }
        return days;
    }
    /**
     * Determine if the date is in between the start and end dates
     *
     * @param date
     */
    betweenSelectedRange(date) {
        return !!(this.startDate &&
            this.endDate &&
            date > this.startDate &&
            date < this.endDate &&
            !this.isRangeHover(date));
    }
    /**
     * Determine if the date should be in selected state
     *
     * @param date
     */
    isSelected(date) {
        return !!(sameDate(date, this.selectedDate) ||
            (this.startDate && sameDate(date, this.startDate)) ||
            (this.endDate && sameDate(date, this.endDate)));
    }
    /**
     * Determine if the date is the start of the date range
     *
     * @param date
     */
    isStartOfRange(date) {
        return !!(this.startDate &&
            !sameDate(this.startDate, this.endDate) &&
            sameDate(this.startDate, date) &&
            !this.isEndOfRange(date));
    }
    isEndOfRange(date) {
        return !!((this.endDate && !sameDate(this.startDate, this.endDate) && sameDate(this.endDate, date)) ||
            (!this.endDate &&
                this.hoverRange &&
                sameDate(this.startDate, this.hoverRange.end) &&
                sameDate(date, this.hoverRange.end)));
    }
    /**
     * Render calcite-date-picker-day
     *
     * @param active.active
     * @param active
     * @param day
     * @param dayInWeek
     * @param date
     * @param currentMonth
     * @param ref
     * @param active.currentMonth
     * @param active.date
     * @param active.day
     * @param active.dayInWeek
     * @param active.ref
     */
    renderDateDay({ active, currentMonth, date, day, dayInWeek, ref }) {
        const isFocusedOnStart = this.isFocusedOnStart();
        const isHoverInRange = this.isHoverInRange() ||
            (!this.endDate && this.hoverRange && sameDate(this.hoverRange?.end, this.startDate));
        return (hAsync("div", { class: "day", key: date.toDateString(), role: "gridcell" }, hAsync("calcite-date-picker-day", { active: active, class: {
                "hover--inside-range": this.startDate && isHoverInRange,
                "hover--outside-range": this.startDate && !isHoverInRange,
                "focused--start": isFocusedOnStart,
                "focused--end": !isFocusedOnStart,
            }, currentMonth: currentMonth, dateTimeFormat: this.dateTimeFormat, day: day, disabled: !inRange(date, this.min, this.max), endOfRange: this.isEndOfRange(date), highlighted: this.betweenSelectedRange(date), onCalciteDaySelect: this.daySelect, onCalciteInternalDayHover: this.dayHover, range: !!this.startDate && !!this.endDate && !sameDate(this.startDate, this.endDate), rangeEdge: dayInWeek === 0 ? "start" : dayInWeek === 6 ? "end" : undefined, rangeHover: this.isRangeHover(date), scale: this.scale, selected: this.isSelected(date), startOfRange: this.isStartOfRange(date), value: date,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => {
                // when moving via keyboard, focus must be updated on active date
                if (ref && active && this.activeFocus) {
                    el?.focus();
                }
            } })));
    }
    isFocusedOnStart() {
        return this.hoverRange?.focused === "start";
    }
    isHoverInRange() {
        if (!this.hoverRange) {
            return false;
        }
        const { start, end } = this.hoverRange;
        return !!((!this.isFocusedOnStart() && this.startDate && (!this.endDate || end < this.endDate)) ||
            (this.isFocusedOnStart() && this.startDate && start > this.startDate));
    }
    isRangeHover(date) {
        if (!this.hoverRange) {
            return false;
        }
        const { start, end } = this.hoverRange;
        const isStart = this.isFocusedOnStart();
        const insideRange = this.isHoverInRange();
        const cond1 = insideRange &&
            ((!isStart && date > this.startDate && (date < end || sameDate(date, end))) ||
                (isStart && date < this.endDate && (date > start || sameDate(date, start))));
        const cond2 = !insideRange &&
            ((!isStart && date >= this.endDate && (date < end || sameDate(date, end))) ||
                (isStart &&
                    ((this.startDate && date < this.startDate) ||
                        (this.endDate && sameDate(date, this.startDate))) &&
                    ((start && date > start) || sameDate(date, start))));
        return cond1 || cond2;
    }
    get el() { return getElement(this); }
    static get style() { return datePickerMonthCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-date-picker-month",
        "$members$": {
            "dateTimeFormat": [16],
            "selectedDate": [16],
            "activeDate": [16],
            "startDate": [16],
            "endDate": [16],
            "min": [16],
            "max": [16],
            "scale": [513],
            "localeData": [16],
            "hoverRange": [16]
        },
        "$listeners$": [[1, "pointerout", "pointerOutHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["scale", "scale"]]
    }; }
}

const CSS$$ = {
    header: "header",
    month: "month",
    chevron: "chevron",
    suffix: "suffix",
    yearSuffix: "year--suffix",
    yearWrap: "year-wrap",
    textReverse: "text--reverse",
};
const ICON = {
    chevronLeft: "chevron-left",
    chevronRight: "chevron-right",
};

const datePickerMonthHeaderCss = "/*!@:host*/.sc-calcite-date-picker-month-header-h{display:block}/*!@.header*/.header.sc-calcite-date-picker-month-header{display:flex;justify-content:space-between;padding-block:0px;padding-inline:0.25rem}/*!@:host([scale=s]) .text*/[scale=s].sc-calcite-date-picker-month-header-h .text.sc-calcite-date-picker-month-header{margin-block:0.5rem;font-size:var(--calcite-font-size--1);line-height:1rem}/*!@:host([scale=s]) .chevron*/[scale=s].sc-calcite-date-picker-month-header-h .chevron.sc-calcite-date-picker-month-header{block-size:2.25rem}/*!@:host([scale=m]) .text*/[scale=m].sc-calcite-date-picker-month-header-h .text.sc-calcite-date-picker-month-header{margin-block:0.75rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host([scale=m]) .chevron*/[scale=m].sc-calcite-date-picker-month-header-h .chevron.sc-calcite-date-picker-month-header{block-size:3rem}/*!@:host([scale=l]) .text*/[scale=l].sc-calcite-date-picker-month-header-h .text.sc-calcite-date-picker-month-header{margin-block:1rem;font-size:var(--calcite-font-size-1);line-height:1.5rem}/*!@:host([scale=l]) .chevron*/[scale=l].sc-calcite-date-picker-month-header-h .chevron.sc-calcite-date-picker-month-header{block-size:3.5rem}/*!@.chevron*/.chevron.sc-calcite-date-picker-month-header{margin-inline:-0.25rem;box-sizing:content-box;display:flex;flex-grow:0;cursor:pointer;align-items:center;justify-content:center;border-style:none;background-color:var(--calcite-color-foreground-1);padding-inline:0.25rem;color:var(--calcite-color-text-3);outline:2px solid transparent;outline-offset:2px;outline-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;inline-size:14.2857142857%}/*!@.chevron:focus*/.chevron.sc-calcite-date-picker-month-header:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.chevron:hover, .chevron:focus*/.chevron.sc-calcite-date-picker-month-header:hover,.chevron.sc-calcite-date-picker-month-header:focus{background-color:var(--calcite-color-foreground-2);fill:var(--calcite-color-text-1);color:var(--calcite-color-text-1)}/*!@.chevron:active*/.chevron.sc-calcite-date-picker-month-header:active{background-color:var(--calcite-color-foreground-3)}/*!@.chevron[aria-disabled=true]*/.chevron[aria-disabled=true].sc-calcite-date-picker-month-header{pointer-events:none;opacity:0}/*!@.text*/.text.sc-calcite-date-picker-month-header{margin-block:auto;display:flex;inline-size:100%;flex:1 1 auto;align-items:center;justify-content:center;text-align:center;line-height:1}/*!@.text--reverse*/.text--reverse.sc-calcite-date-picker-month-header{flex-direction:row-reverse}/*!@.month,\n.year,\n.suffix*/.month.sc-calcite-date-picker-month-header,.year.sc-calcite-date-picker-month-header,.suffix.sc-calcite-date-picker-month-header{margin-inline:0.25rem;margin-block:auto;display:inline-block;background-color:var(--calcite-color-foreground-1);font-weight:var(--calcite-font-weight-medium);line-height:1.25;color:var(--calcite-color-text-1);font-size:inherit}/*!@.year*/.year.sc-calcite-date-picker-month-header{position:relative;inline-size:2.5rem;border-style:none;background-color:transparent;text-align:center;font-family:inherit;outline-color:transparent}/*!@.year:hover*/.year.sc-calcite-date-picker-month-header:hover{transition-duration:100ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-property:outline-color;outline:2px solid var(--calcite-color-border-2);outline-offset:2px}/*!@.year:focus*/.year.sc-calcite-date-picker-month-header:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.year--suffix*/.year--suffix.sc-calcite-date-picker-month-header{text-align:start}/*!@.year-wrap*/.year-wrap.sc-calcite-date-picker-month-header{position:relative}/*!@.suffix*/.suffix.sc-calcite-date-picker-month-header{inset-block-start:0px;white-space:nowrap;text-align:start;inset-inline-start:0}/*!@:host([hidden])*/[hidden].sc-calcite-date-picker-month-header-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-date-picker-month-header{display:none}";

class DatePickerMonthHeader {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalDatePickerSelect = createEvent(this, "calciteInternalDatePickerSelect", 6);
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        /**
         * Increment year on UP/DOWN keys
         *
         * @param event
         */
        this.onYearKey = (event) => {
            const localizedYear = this.parseCalendarYear(event.target.value);
            switch (event.key) {
                case "ArrowDown":
                    event.preventDefault();
                    this.setYear({ localizedYear, offset: -1 });
                    break;
                case "ArrowUp":
                    event.preventDefault();
                    this.setYear({ localizedYear, offset: 1 });
                    break;
            }
        };
        this.onYearChange = (event) => {
            this.setYear({
                localizedYear: this.parseCalendarYear(event.target.value),
            });
        };
        this.onYearInput = (event) => {
            this.setYear({
                localizedYear: this.parseCalendarYear(event.target.value),
                commit: false,
            });
        };
        this.prevMonthClick = (event) => {
            this.handleArrowClick(event, this.prevMonthDate);
        };
        this.prevMonthKeydown = (event) => {
            if (isActivationKey(event.key)) {
                this.prevMonthClick(event);
            }
        };
        this.nextMonthClick = (event) => {
            this.handleArrowClick(event, this.nextMonthDate);
        };
        this.nextMonthKeydown = (event) => {
            if (isActivationKey(event.key)) {
                this.nextMonthClick(event);
            }
        };
        /*
         * Update active month on clicks of left/right arrows
         */
        this.handleArrowClick = (event, date) => {
            event.preventDefault();
            this.calciteInternalDatePickerSelect.emit(date);
        };
        this.selectedDate = undefined;
        this.activeDate = undefined;
        this.headingLevel = undefined;
        this.min = undefined;
        this.max = undefined;
        this.scale = undefined;
        this.localeData = undefined;
        this.messages = undefined;
        this.nextMonthDate = undefined;
        this.prevMonthDate = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentWillLoad() {
        this.parentDatePickerEl = closestElementCrossShadowBoundary(this.el, "calcite-date-picker");
    }
    connectedCallback() {
        this.setNextPrevMonthDates();
    }
    render() {
        return hAsync("div", { class: CSS$$.header }, this.renderContent());
    }
    renderContent() {
        const { messages, localeData, activeDate } = this;
        if (!activeDate || !localeData) {
            return null;
        }
        if (this.parentDatePickerEl) {
            const { numberingSystem, lang: locale } = this.parentDatePickerEl;
            numberStringFormatter.numberFormatOptions = {
                useGrouping: false,
                ...(numberingSystem && { numberingSystem }),
                ...(locale && { locale }),
            };
        }
        const activeMonth = activeDate.getMonth();
        const { months, unitOrder } = localeData;
        const localizedMonth = (months.wide || months.narrow || months.abbreviated)[activeMonth];
        const localizedYear = this.formatCalendarYear(activeDate.getFullYear());
        const order = getOrder(unitOrder);
        const reverse = order.indexOf("y") < order.indexOf("m");
        const suffix = localeData.year?.suffix;
        return (hAsync(Fragment, null, hAsync("a", { "aria-disabled": `${this.prevMonthDate.getMonth() === activeMonth}`, "aria-label": messages.prevMonth, class: CSS$$.chevron, href: "#", onClick: this.prevMonthClick, onKeyDown: this.prevMonthKeydown, role: "button", tabindex: this.prevMonthDate.getMonth() === activeMonth ? -1 : 0 }, hAsync("calcite-icon", { "flip-rtl": true, icon: ICON.chevronLeft, scale: getIconScale(this.scale) })), hAsync("div", { class: { text: true, [CSS$$.textReverse]: reverse } }, hAsync(Heading, { class: CSS$$.month, level: this.headingLevel }, localizedMonth), hAsync("span", { class: CSS$$.yearWrap }, hAsync("input", { "aria-label": messages.year, class: {
                year: true,
                [CSS$$.yearSuffix]: !!suffix,
            }, inputmode: "numeric", maxlength: "4", minlength: "1", onChange: this.onYearChange, onInput: this.onYearInput, onKeyDown: this.onYearKey, pattern: "\\d*", type: "text", value: localizedYear,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.yearInput = el) }), suffix && hAsync("span", { class: CSS$$.suffix }, suffix))), hAsync("a", { "aria-disabled": `${this.nextMonthDate.getMonth() === activeMonth}`, "aria-label": messages.nextMonth, class: CSS$$.chevron, href: "#", onClick: this.nextMonthClick, onKeyDown: this.nextMonthKeydown, role: "button", tabindex: this.nextMonthDate.getMonth() === activeMonth ? -1 : 0 }, hAsync("calcite-icon", { "flip-rtl": true, icon: ICON.chevronRight, scale: getIconScale(this.scale) }))));
    }
    setNextPrevMonthDates() {
        if (!this.activeDate) {
            return;
        }
        this.nextMonthDate = dateFromRange(nextMonth(this.activeDate), this.min, this.max);
        this.prevMonthDate = dateFromRange(prevMonth(this.activeDate), this.min, this.max);
    }
    formatCalendarYear(year) {
        return numberStringFormatter.localize(`${formatCalendarYear(year, this.localeData)}`);
    }
    parseCalendarYear(year) {
        return numberStringFormatter.localize(`${parseCalendarYear(Number(numberStringFormatter.delocalize(year)), this.localeData)}`);
    }
    getInRangeDate({ localizedYear, offset = 0, }) {
        const { min, max, activeDate } = this;
        const parsedYear = Number(numberStringFormatter.delocalize(localizedYear));
        const length = parsedYear.toString().length;
        const year = isNaN(parsedYear) ? false : parsedYear + offset;
        const inRange = year && (!min || min.getFullYear() <= year) && (!max || max.getFullYear() >= year);
        // if you've supplied a year and it's in range
        if (year && inRange && length === localizedYear.length) {
            const nextDate = new Date(activeDate);
            nextDate.setFullYear(year);
            return dateFromRange(nextDate, min, max);
        }
    }
    /**
     * Parse localized year string from input,
     * set to active if in range
     *
     * @param root0
     * @param root0.localizedYear
     * @param root0.commit
     * @param root0.offset
     */
    setYear({ localizedYear, commit = true, offset = 0, }) {
        const { yearInput, activeDate } = this;
        const inRangeDate = this.getInRangeDate({ localizedYear, offset });
        // if you've supplied a year and it's in range, update active date
        if (inRangeDate) {
            this.calciteInternalDatePickerSelect.emit(inRangeDate);
        }
        if (commit) {
            yearInput.value = this.formatCalendarYear((inRangeDate || activeDate).getFullYear());
        }
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "min": ["setNextPrevMonthDates"],
        "max": ["setNextPrevMonthDates"],
        "activeDate": ["setNextPrevMonthDates"]
    }; }
    static get style() { return datePickerMonthHeaderCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-date-picker-month-header",
        "$members$": {
            "selectedDate": [16],
            "activeDate": [16],
            "headingLevel": [2, "heading-level"],
            "min": [16],
            "max": [16],
            "scale": [513],
            "localeData": [16],
            "messages": [1040],
            "nextMonthDate": [32],
            "prevMonthDate": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["scale", "scale"]]
    }; }
}

const SLOTS$o = {
    dropdownTrigger: "trigger",
};

const dropdownCss = "/*!@:host([disabled])*/[disabled].sc-calcite-dropdown-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-dropdown-h *.sc-calcite-dropdown,.sc-calcite-dropdown-h[disabled].sc-calcite-dropdown-s>*,.sc-calcite-dropdown-h[disabled] .sc-calcite-dropdown-s>*{pointer-events:none}/*!@:host*/.sc-calcite-dropdown-h{display:inline-block}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-dropdown-h[disabled] .sc-calcite-dropdown-s>[calcite-hydrated][disabled],[disabled].sc-calcite-dropdown-h [calcite-hydrated][disabled].sc-calcite-dropdown{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-dropdown{display:contents}/*!@:host .calcite-dropdown-wrapper*/.sc-calcite-dropdown-h .calcite-dropdown-wrapper.sc-calcite-dropdown{--calcite-floating-ui-z-index:var(--calcite-z-index-dropdown);display:block;position:absolute;z-index:var(--calcite-floating-ui-z-index);visibility:hidden}/*!@.calcite-dropdown-wrapper .calcite-floating-ui-anim*/.calcite-dropdown-wrapper.sc-calcite-dropdown .calcite-floating-ui-anim.sc-calcite-dropdown{position:relative;transition:var(--calcite-floating-ui-transition);transition-property:transform, visibility, opacity;opacity:0;box-shadow:0 0 16px 0 rgba(0, 0, 0, 0.16);z-index:var(--calcite-z-index);border-radius:0.25rem}/*!@.calcite-dropdown-wrapper[data-placement^=bottom] .calcite-floating-ui-anim*/.calcite-dropdown-wrapper[data-placement^=bottom].sc-calcite-dropdown .calcite-floating-ui-anim.sc-calcite-dropdown{transform:translateY(-5px)}/*!@.calcite-dropdown-wrapper[data-placement^=top] .calcite-floating-ui-anim*/.calcite-dropdown-wrapper[data-placement^=top].sc-calcite-dropdown .calcite-floating-ui-anim.sc-calcite-dropdown{transform:translateY(5px)}/*!@.calcite-dropdown-wrapper[data-placement^=left] .calcite-floating-ui-anim*/.calcite-dropdown-wrapper[data-placement^=left].sc-calcite-dropdown .calcite-floating-ui-anim.sc-calcite-dropdown{transform:translateX(5px)}/*!@.calcite-dropdown-wrapper[data-placement^=right] .calcite-floating-ui-anim*/.calcite-dropdown-wrapper[data-placement^=right].sc-calcite-dropdown .calcite-floating-ui-anim.sc-calcite-dropdown{transform:translateX(-5px)}/*!@.calcite-dropdown-wrapper[data-placement] .calcite-floating-ui-anim--active*/.calcite-dropdown-wrapper[data-placement].sc-calcite-dropdown .calcite-floating-ui-anim--active.sc-calcite-dropdown{opacity:1;transform:translate(0)}/*!@:host([open]) .calcite-dropdown-wrapper*/[open].sc-calcite-dropdown-h .calcite-dropdown-wrapper.sc-calcite-dropdown{visibility:visible}/*!@:host .calcite-dropdown-content*/.sc-calcite-dropdown-h .calcite-dropdown-content.sc-calcite-dropdown{max-block-size:45vh;inline-size:auto;overflow-y:auto;overflow-x:hidden;background-color:var(--calcite-color-foreground-1);inline-size:var(--calcite-dropdown-width)}/*!@.calcite-trigger-container*/.calcite-trigger-container.sc-calcite-dropdown{position:relative;display:flex;block-size:100%;flex:1 1 auto;word-wrap:break-word;word-break:break-word}@media (forced-colors: active){/*!@:host([open]) .calcite-dropdown-wrapper*/[open].sc-calcite-dropdown-h .calcite-dropdown-wrapper.sc-calcite-dropdown{border:1px solid canvasText}}/*!@:host([width-scale=s])*/[width-scale=s].sc-calcite-dropdown-h{--calcite-dropdown-width:12rem}/*!@:host([width-scale=m])*/[width-scale=m].sc-calcite-dropdown-h{--calcite-dropdown-width:14rem}/*!@:host([width-scale=l])*/[width-scale=l].sc-calcite-dropdown-h{--calcite-dropdown-width:16rem}/*!@:host([hidden])*/[hidden].sc-calcite-dropdown-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-dropdown{display:none}";

/**
 * @slot - A slot for adding `calcite-dropdown-group` elements. Every `calcite-dropdown-item` must have a parent `calcite-dropdown-group`, even if the `groupTitle` property is not set.
 * @slot trigger - A slot for the element that triggers the `calcite-dropdown`.
 */
class Dropdown {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteDropdownSelect = createEvent(this, "calciteDropdownSelect", 6);
        this.calciteDropdownBeforeClose = createEvent(this, "calciteDropdownBeforeClose", 6);
        this.calciteDropdownClose = createEvent(this, "calciteDropdownClose", 6);
        this.calciteDropdownBeforeOpen = createEvent(this, "calciteDropdownBeforeOpen", 6);
        this.calciteDropdownOpen = createEvent(this, "calciteDropdownOpen", 6);
        this.items = [];
        this.groups = [];
        this.mutationObserver = createObserver();
        this.resizeObserver = createObserver();
        this.openTransitionProp = "opacity";
        this.guid = `calcite-dropdown-${guid()}`;
        this.defaultAssignedElements = [];
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.slotChangeHandler = (event) => {
            this.defaultAssignedElements = event.target.assignedElements({
                flatten: true,
            });
            this.updateItems();
        };
        this.setFilteredPlacements = () => {
            const { el, flipPlacements } = this;
            this.filteredFlipPlacements = flipPlacements
                ? filterComputedPlacements(flipPlacements, el)
                : null;
        };
        this.updateTriggers = (event) => {
            this.triggers = event.target.assignedElements({
                flatten: true,
            });
            this.reposition(true);
        };
        this.updateItems = () => {
            this.items = this.groups
                .map((group) => Array.from(group?.querySelectorAll("calcite-dropdown-item")))
                .reduce((previousValue, currentValue) => [...previousValue, ...currentValue], []);
            this.updateSelectedItems();
            this.reposition(true);
            this.items.forEach((item) => (item.scale = this.scale));
        };
        this.updateGroups = (event) => {
            const groups = event.target
                .assignedElements({ flatten: true })
                .filter((el) => el?.matches("calcite-dropdown-group"));
            this.groups = groups;
            this.updateItems();
        };
        this.resizeObserverCallback = (entries) => {
            entries.forEach((entry) => {
                const { target } = entry;
                if (target === this.referenceEl) {
                    this.setDropdownWidth();
                }
                else if (target === this.scrollerEl) {
                    this.setMaxScrollerHeight();
                }
            });
        };
        this.setDropdownWidth = () => {
            const { referenceEl, scrollerEl } = this;
            const referenceElWidth = referenceEl?.clientWidth;
            if (!referenceElWidth || !scrollerEl) {
                return;
            }
            scrollerEl.style.minWidth = `${referenceElWidth}px`;
        };
        this.setMaxScrollerHeight = () => {
            const { scrollerEl } = this;
            if (!scrollerEl) {
                return;
            }
            this.reposition(true);
            const maxScrollerHeight = this.getMaxScrollerHeight();
            scrollerEl.style.maxHeight = maxScrollerHeight > 0 ? `${maxScrollerHeight}px` : "";
            this.reposition(true);
        };
        this.setScrollerAndTransitionEl = (el) => {
            this.resizeObserver.observe(el);
            this.scrollerEl = el;
            this.transitionEl = el;
        };
        this.setReferenceEl = (el) => {
            this.referenceEl = el;
            connectFloatingUI(this, this.referenceEl, this.floatingEl);
            this.resizeObserver.observe(el);
        };
        this.setFloatingEl = (el) => {
            this.floatingEl = el;
            connectFloatingUI(this, this.referenceEl, this.floatingEl);
        };
        this.keyDownHandler = (event) => {
            if (!event.composedPath().includes(this.referenceEl)) {
                return;
            }
            const { defaultPrevented, key } = event;
            if (defaultPrevented) {
                return;
            }
            if (this.open) {
                if (key === "Escape") {
                    this.closeCalciteDropdown();
                    event.preventDefault();
                    return;
                }
                else if (event.shiftKey && key === "Tab") {
                    this.closeCalciteDropdown();
                    event.preventDefault();
                    return;
                }
            }
            if (isActivationKey(key)) {
                this.openCalciteDropdown();
                event.preventDefault();
            }
            else if (key === "Escape") {
                this.closeCalciteDropdown();
                event.preventDefault();
            }
        };
        this.focusOnFirstActiveOrFirstItem = () => {
            this.getFocusableElement(this.getTraversableItems().find((item) => item.selected) || this.items[0]);
        };
        this.toggleOpenEnd = () => {
            this.focusOnFirstActiveOrFirstItem();
            this.el.removeEventListener("calciteDropdownOpen", this.toggleOpenEnd);
        };
        this.openCalciteDropdown = () => {
            this.open = !this.open;
            if (this.open) {
                this.el.addEventListener("calciteDropdownOpen", this.toggleOpenEnd);
            }
        };
        this.open = false;
        this.closeOnSelectDisabled = false;
        this.disabled = false;
        this.flipPlacements = undefined;
        this.maxItems = 0;
        this.overlayPositioning = "absolute";
        this.placement = defaultMenuPlacement;
        this.selectedItems = [];
        this.type = "click";
        this.widthScale = undefined;
        this.scale = "m";
    }
    openHandler() {
        onToggleOpenCloseComponent(this);
        if (this.disabled) {
            this.open = false;
            return;
        }
        this.reposition(true);
    }
    handleDisabledChange(value) {
        if (!value) {
            this.open = false;
        }
    }
    flipPlacementsHandler() {
        this.setFilteredPlacements();
        this.reposition(true);
    }
    maxItemsHandler() {
        this.setMaxScrollerHeight();
    }
    overlayPositioningHandler() {
        this.reposition(true);
    }
    placementHandler() {
        this.reposition(true);
    }
    handlePropsChange() {
        this.updateItems();
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component's first focusable element. */
    async setFocus() {
        await componentFocusable(this);
        this.el.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
        this.setFilteredPlacements();
        this.reposition(true);
        if (this.open) {
            this.openHandler();
            onToggleOpenCloseComponent(this);
        }
        connectInteractive(this);
        this.updateItems();
        connectFloatingUI(this, this.referenceEl, this.floatingEl);
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
        this.reposition(true);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
        this.resizeObserver?.disconnect();
        disconnectInteractive(this);
        disconnectFloatingUI(this, this.referenceEl, this.floatingEl);
    }
    render() {
        const { open, guid } = this;
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: "calcite-trigger-container", id: `${guid}-menubutton`, onClick: this.openCalciteDropdown, onKeyDown: this.keyDownHandler,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setReferenceEl }, hAsync("slot", { "aria-controls": `${guid}-menu`, "aria-expanded": toAriaBoolean(open), "aria-haspopup": "menu", name: SLOTS$o.dropdownTrigger, onSlotchange: this.updateTriggers })), hAsync("div", { "aria-hidden": toAriaBoolean(!open), class: "calcite-dropdown-wrapper",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setFloatingEl }, hAsync("div", { "aria-labelledby": `${guid}-menubutton`, class: {
                ["calcite-dropdown-content"]: true,
                [FloatingCSS.animation]: true,
                [FloatingCSS.animationActive]: open,
            }, id: `${guid}-menu`, role: "menu",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setScrollerAndTransitionEl }, hAsync("slot", { onSlotchange: this.updateGroups }))))));
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Updates the position of the component.
     *
     * @param delayed
     */
    async reposition(delayed = false) {
        const { floatingEl, referenceEl, placement, overlayPositioning, filteredFlipPlacements } = this;
        return reposition(this, {
            floatingEl,
            referenceEl,
            overlayPositioning,
            placement,
            flipPlacements: filteredFlipPlacements,
            type: "menu",
        }, delayed);
    }
    closeCalciteDropdownOnClick(event) {
        if (this.disabled ||
            !isPrimaryPointerButton(event) ||
            !this.open ||
            event.composedPath().includes(this.el)) {
            return;
        }
        this.closeCalciteDropdown(false);
    }
    closeCalciteDropdownOnEvent(event) {
        this.closeCalciteDropdown();
        event.stopPropagation();
    }
    closeCalciteDropdownOnOpenEvent(event) {
        if (event.composedPath().includes(this.el)) {
            return;
        }
        this.open = false;
    }
    pointerEnterHandler() {
        if (this.disabled || this.type !== "hover") {
            return;
        }
        this.openCalciteDropdown();
    }
    pointerLeaveHandler() {
        if (this.disabled || this.type !== "hover") {
            return;
        }
        this.closeCalciteDropdown();
    }
    getTraversableItems() {
        return this.items.filter((item) => !item.disabled && !item.hidden);
    }
    calciteInternalDropdownItemKeyEvent(event) {
        const { keyboardEvent } = event.detail;
        const target = keyboardEvent.target;
        const traversableItems = this.getTraversableItems();
        switch (keyboardEvent.key) {
            case "Tab":
                this.open = false;
                this.updateTabIndexOfItems(target);
                break;
            case "ArrowDown":
                focusElementInGroup(traversableItems, target, "next");
                break;
            case "ArrowUp":
                focusElementInGroup(traversableItems, target, "previous");
                break;
            case "Home":
                focusElementInGroup(traversableItems, target, "first");
                break;
            case "End":
                focusElementInGroup(traversableItems, target, "last");
                break;
        }
        event.stopPropagation();
    }
    handleItemSelect(event) {
        this.updateSelectedItems();
        event.stopPropagation();
        this.calciteDropdownSelect.emit();
        if (!this.closeOnSelectDisabled ||
            event.detail.requestedDropdownGroup.selectionMode === "none") {
            this.closeCalciteDropdown();
        }
        event.stopPropagation();
    }
    onBeforeOpen() {
        this.calciteDropdownBeforeOpen.emit();
    }
    onOpen() {
        this.calciteDropdownOpen.emit();
    }
    onBeforeClose() {
        this.calciteDropdownBeforeClose.emit();
    }
    onClose() {
        this.calciteDropdownClose.emit();
    }
    updateSelectedItems() {
        this.selectedItems = this.items.filter((item) => item.selected);
    }
    getMaxScrollerHeight() {
        const { maxItems, items } = this;
        let itemsToProcess = 0;
        let maxScrollerHeight = 0;
        let groupHeaderHeight;
        this.groups.forEach((group) => {
            if (maxItems > 0 && itemsToProcess < maxItems) {
                Array.from(group.children).forEach((item, index) => {
                    if (index === 0) {
                        if (isNaN(groupHeaderHeight)) {
                            groupHeaderHeight = item.offsetTop;
                        }
                        maxScrollerHeight += groupHeaderHeight;
                    }
                    if (itemsToProcess < maxItems) {
                        maxScrollerHeight += item.offsetHeight;
                        itemsToProcess += 1;
                    }
                });
            }
        });
        return items.length > maxItems ? maxScrollerHeight : 0;
    }
    closeCalciteDropdown(focusTrigger = true) {
        this.open = false;
        if (focusTrigger) {
            focusElement(this.triggers[0]);
        }
    }
    getFocusableElement(item) {
        if (!item) {
            return;
        }
        focusElement(item);
    }
    updateTabIndexOfItems(target) {
        this.items.forEach((item) => {
            item.tabIndex = target !== item ? -1 : 0;
        });
    }
    static get delegatesFocus() { return true; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "open": ["openHandler"],
        "disabled": ["handleDisabledChange"],
        "flipPlacements": ["flipPlacementsHandler"],
        "maxItems": ["maxItemsHandler"],
        "overlayPositioning": ["overlayPositioningHandler"],
        "placement": ["placementHandler"],
        "scale": ["handlePropsChange"]
    }; }
    static get style() { return dropdownCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-dropdown",
        "$members$": {
            "open": [1540],
            "closeOnSelectDisabled": [516, "close-on-select-disabled"],
            "disabled": [516],
            "flipPlacements": [16],
            "maxItems": [514, "max-items"],
            "overlayPositioning": [513, "overlay-positioning"],
            "placement": [513],
            "selectedItems": [1040],
            "type": [513],
            "widthScale": [513, "width-scale"],
            "scale": [513],
            "setFocus": [64],
            "reposition": [64]
        },
        "$listeners$": [[9, "pointerdown", "closeCalciteDropdownOnClick"], [0, "calciteInternalDropdownCloseRequest", "closeCalciteDropdownOnEvent"], [8, "calciteDropdownOpen", "closeCalciteDropdownOnOpenEvent"], [1, "pointerenter", "pointerEnterHandler"], [1, "pointerleave", "pointerLeaveHandler"], [0, "calciteInternalDropdownItemKeyEvent", "calciteInternalDropdownItemKeyEvent"], [0, "calciteInternalDropdownItemSelect", "handleItemSelect"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["open", "open"], ["closeOnSelectDisabled", "close-on-select-disabled"], ["disabled", "disabled"], ["maxItems", "max-items"], ["overlayPositioning", "overlay-positioning"], ["placement", "placement"], ["type", "type"], ["widthScale", "width-scale"], ["scale", "scale"]]
    }; }
}

const CSS$_ = {
    container: "container",
    containerLink: "container--link",
    containerMulti: "container--multi-selection",
    containerSingle: "container--single-selection",
    containerNone: "container--none-selection",
    icon: "dropdown-item-icon",
    iconEnd: "dropdown-item-icon-end",
    iconStart: "dropdown-item-icon-start",
    itemContent: "dropdown-item-content",
    link: "dropdown-link",
};

const dropdownGroupCss = "/*!@:host*/.sc-calcite-dropdown-group-h{position:relative;display:block}/*!@.container*/.container.sc-calcite-dropdown-group{text-align:start}/*!@.container--s*/.container--s.sc-calcite-dropdown-group{font-size:var(--calcite-font-size--2);line-height:1rem}/*!@.container--s .dropdown-title*/.container--s.sc-calcite-dropdown-group .dropdown-title.sc-calcite-dropdown-group{padding:0.5rem}/*!@.container--m*/.container--m.sc-calcite-dropdown-group{font-size:var(--calcite-font-size--1);line-height:1rem}/*!@.container--m .dropdown-title*/.container--m.sc-calcite-dropdown-group .dropdown-title.sc-calcite-dropdown-group{padding:0.75rem}/*!@.container--l*/.container--l.sc-calcite-dropdown-group{font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@.container--l .dropdown-title*/.container--l.sc-calcite-dropdown-group .dropdown-title.sc-calcite-dropdown-group{padding:1rem}/*!@.dropdown-title*/.dropdown-title.sc-calcite-dropdown-group{margin-block-end:-1px;display:block;cursor:default;overflow-wrap:break-word;border-width:0px;border-block-end-width:1px;border-style:solid;border-color:var(--calcite-color-border-3);font-weight:var(--calcite-font-weight-bold);color:var(--calcite-color-text-2)}/*!@.dropdown-separator*/.dropdown-separator.sc-calcite-dropdown-group{display:block;block-size:1px;background-color:var(--calcite-color-border-3)}/*!@:host([hidden])*/[hidden].sc-calcite-dropdown-group-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-dropdown-group{display:none}";

/**
 * @slot - A slot for adding `calcite-dropdown-item`s.
 */
class DropdownGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalDropdownItemChange = createEvent(this, "calciteInternalDropdownItemChange", 6);
        this.updateItems = () => {
            Array.from(this.el.querySelectorAll("calcite-dropdown-item")).forEach((item) => (item.selectionMode = this.selectionMode));
        };
        this.mutationObserver = createObserver();
        this.groupTitle = undefined;
        this.scale = "m";
        this.selectionMode = "single";
    }
    handlePropsChange() {
        this.updateItems();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.updateItems();
        this.mutationObserver?.observe(this.el, { childList: true });
    }
    componentWillLoad() {
        this.groupPosition = this.getGroupPosition();
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
    }
    render() {
        const groupTitle = this.groupTitle ? (hAsync("span", { "aria-hidden": "true", class: "dropdown-title" }, this.groupTitle)) : null;
        const dropdownSeparator = this.groupPosition > 0 ? hAsync("div", { class: "dropdown-separator", role: "separator" }) : null;
        return (hAsync(Host, { "aria-label": this.groupTitle, role: "group" }, hAsync("div", { class: {
                [CSS$_.container]: true,
                [`${CSS$_.container}--${this.scale}`]: true,
            } }, dropdownSeparator, groupTitle, hAsync("slot", null))));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    updateActiveItemOnChange(event) {
        this.requestedDropdownGroup = event.detail.requestedDropdownGroup;
        this.requestedDropdownItem = event.detail.requestedDropdownItem;
        this.calciteInternalDropdownItemChange.emit({
            requestedDropdownGroup: this.requestedDropdownGroup,
            requestedDropdownItem: this.requestedDropdownItem,
        });
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    getGroupPosition() {
        return Array.prototype.indexOf.call(this.el.parentElement.querySelectorAll("calcite-dropdown-group"), this.el);
    }
    static get delegatesFocus() { return true; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "selectionMode": ["handlePropsChange"]
    }; }
    static get style() { return dropdownGroupCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-dropdown-group",
        "$members$": {
            "groupTitle": [513, "group-title"],
            "scale": [1],
            "selectionMode": [513, "selection-mode"]
        },
        "$listeners$": [[0, "calciteInternalDropdownItemSelect", "updateActiveItemOnChange"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["groupTitle", "group-title"], ["selectionMode", "selection-mode"]]
    }; }
}

const dropdownItemCss = "/*!@:host([disabled])*/[disabled].sc-calcite-dropdown-item-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-dropdown-item-h *.sc-calcite-dropdown-item,.sc-calcite-dropdown-item-h[disabled].sc-calcite-dropdown-item-s>*,.sc-calcite-dropdown-item-h[disabled] .sc-calcite-dropdown-item-s>*{pointer-events:none}/*!@.container--s*/.container--s.sc-calcite-dropdown-item{padding-block:0.25rem;font-size:var(--calcite-font-size--2);line-height:1rem;padding-inline-end:0.5rem;padding-inline-start:1.5rem}/*!@.container--m*/.container--m.sc-calcite-dropdown-item{padding-block:0.5rem;font-size:var(--calcite-font-size--1);line-height:1rem;padding-inline-end:0.75rem;padding-inline-start:2rem}/*!@.container--l*/.container--l.sc-calcite-dropdown-item{padding-block:0.625rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;padding-inline-end:1rem;padding-inline-start:2.5rem}/*!@.container--s.container--none-selection*/.container--s.container--none-selection.sc-calcite-dropdown-item{padding-inline-start:0.25rem}/*!@.container--s.container--none-selection .dropdown-link*/.container--s.container--none-selection.sc-calcite-dropdown-item .dropdown-link.sc-calcite-dropdown-item{padding-inline-start:0px}/*!@.container--m.container--none-selection*/.container--m.container--none-selection.sc-calcite-dropdown-item{padding-inline-start:0.5rem}/*!@.container--m.container--none-selection .dropdown-link*/.container--m.container--none-selection.sc-calcite-dropdown-item .dropdown-link.sc-calcite-dropdown-item{padding-inline-start:0px}/*!@.container--l.container--none-selection*/.container--l.container--none-selection.sc-calcite-dropdown-item{padding-inline-start:0.75rem}/*!@.container--l.container--none-selection .dropdown-link*/.container--l.container--none-selection.sc-calcite-dropdown-item .dropdown-link.sc-calcite-dropdown-item{padding-inline-start:0px}/*!@:host*/.sc-calcite-dropdown-item-h{position:relative;display:flex;flex-grow:1;align-items:center}/*!@.container*/.container.sc-calcite-dropdown-item{position:relative;display:flex;flex-grow:1;cursor:pointer;align-items:center;color:var(--calcite-color-text-3);text-decoration-line:none;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);text-align:start}/*!@.dropdown-item-content*/.dropdown-item-content.sc-calcite-dropdown-item{flex:1 1 auto;padding-block:0.125rem;padding-inline-end:auto;padding-inline-start:0.25rem}/*!@:host,\n.container--link a*/.sc-calcite-dropdown-item-h,.container--link.sc-calcite-dropdown-item a.sc-calcite-dropdown-item{outline-color:transparent}/*!@:host(:focus)*/.sc-calcite-dropdown-item-h:focus{outline:2px solid transparent;outline-offset:2px;outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.container--link*/.container--link.sc-calcite-dropdown-item{padding:0px}/*!@.container--link a*/.container--link.sc-calcite-dropdown-item a.sc-calcite-dropdown-item{position:relative;display:flex;flex-grow:1;cursor:pointer;align-items:center;color:var(--calcite-color-text-3);text-decoration-line:none;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}/*!@.container--s .dropdown-link*/.container--s.sc-calcite-dropdown-item .dropdown-link.sc-calcite-dropdown-item{padding-block:0.25rem;font-size:var(--calcite-font-size--2);line-height:1rem;padding-inline-end:0.5rem;padding-inline-start:1.5rem}/*!@.container--m .dropdown-link*/.container--m.sc-calcite-dropdown-item .dropdown-link.sc-calcite-dropdown-item{padding-block:0.5rem;font-size:var(--calcite-font-size--1);line-height:1rem;padding-inline-end:0.75rem;padding-inline-start:2rem}/*!@.container--l .dropdown-link*/.container--l.sc-calcite-dropdown-item .dropdown-link.sc-calcite-dropdown-item{padding-block:0.75rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;padding-inline-end:1rem;padding-inline-start:2.5rem}/*!@:host(:hover:not([disabled])) .container,\n:host(:active:not([disabled])) .container*/.sc-calcite-dropdown-item-h:hover:not([disabled]) .container.sc-calcite-dropdown-item,.sc-calcite-dropdown-item-h:active:not([disabled]) .container.sc-calcite-dropdown-item{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-text-1);text-decoration-line:none}/*!@:host(:hover:not([disabled])) .container--link .dropdown-link,\n:host(:active:not([disabled])) .container--link .dropdown-link*/.sc-calcite-dropdown-item-h:hover:not([disabled]) .container--link.sc-calcite-dropdown-item .dropdown-link.sc-calcite-dropdown-item,.sc-calcite-dropdown-item-h:active:not([disabled]) .container--link.sc-calcite-dropdown-item .dropdown-link.sc-calcite-dropdown-item{color:var(--calcite-color-text-1)}/*!@:host(:active:not([disabled])) .container*/.sc-calcite-dropdown-item-h:active:not([disabled]) .container.sc-calcite-dropdown-item{background-color:var(--calcite-color-foreground-3)}/*!@:host(:focus) .container*/.sc-calcite-dropdown-item-h:focus .container.sc-calcite-dropdown-item{color:var(--calcite-color-text-1);text-decoration-line:none}/*!@:host([selected]) .container:not(.container--none-selection),\n:host([selected]) .container--link .dropdown-link*/[selected].sc-calcite-dropdown-item-h .container.sc-calcite-dropdown-item:not(.container--none-selection),[selected].sc-calcite-dropdown-item-h .container--link.sc-calcite-dropdown-item .dropdown-link.sc-calcite-dropdown-item{font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1)}/*!@:host([selected]) .container:not(.container--none-selection) calcite-icon,\n:host([selected]) .container--link .dropdown-link calcite-icon*/[selected].sc-calcite-dropdown-item-h .container.sc-calcite-dropdown-item:not(.container--none-selection) calcite-icon.sc-calcite-dropdown-item,[selected].sc-calcite-dropdown-item-h .container--link.sc-calcite-dropdown-item .dropdown-link.sc-calcite-dropdown-item calcite-icon.sc-calcite-dropdown-item{color:var(--calcite-color-brand)}/*!@.dropdown-item-icon*/.dropdown-item-icon.sc-calcite-dropdown-item{position:absolute;opacity:0;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:scale(0.9)}/*!@.container--s .dropdown-item-icon*/.container--s.sc-calcite-dropdown-item .dropdown-item-icon.sc-calcite-dropdown-item{inset-inline-start:0.25rem}/*!@.container--m .dropdown-item-icon*/.container--m.sc-calcite-dropdown-item .dropdown-item-icon.sc-calcite-dropdown-item{inset-inline-start:0.5rem}/*!@.container--l .dropdown-item-icon*/.container--l.sc-calcite-dropdown-item .dropdown-item-icon.sc-calcite-dropdown-item{inset-inline-start:0.75rem}/*!@:host(:hover:not([disabled])) .dropdown-item-icon*/.sc-calcite-dropdown-item-h:hover:not([disabled]) .dropdown-item-icon.sc-calcite-dropdown-item{color:var(--calcite-color-border-1);opacity:1}/*!@:host([selected]) .dropdown-item-icon*/[selected].sc-calcite-dropdown-item-h .dropdown-item-icon.sc-calcite-dropdown-item{color:var(--calcite-color-brand);opacity:1}/*!@.container--s .dropdown-item-icon-start*/.container--s.sc-calcite-dropdown-item .dropdown-item-icon-start.sc-calcite-dropdown-item{margin-inline-end:0.5rem;margin-inline-start:0.25rem}/*!@.container--s .dropdown-item-icon-end*/.container--s.sc-calcite-dropdown-item .dropdown-item-icon-end.sc-calcite-dropdown-item{margin-inline-start:0.5rem}/*!@.container--m .dropdown-item-icon-start*/.container--m.sc-calcite-dropdown-item .dropdown-item-icon-start.sc-calcite-dropdown-item{margin-inline-end:0.75rem;margin-inline-start:0.25rem}/*!@.container--m .dropdown-item-icon-end*/.container--m.sc-calcite-dropdown-item .dropdown-item-icon-end.sc-calcite-dropdown-item{margin-inline-start:0.75rem}/*!@.container--l .dropdown-item-icon-start*/.container--l.sc-calcite-dropdown-item .dropdown-item-icon-start.sc-calcite-dropdown-item{margin-inline-end:1rem;margin-inline-start:0.25rem}/*!@.container--l .dropdown-item-icon-end*/.container--l.sc-calcite-dropdown-item .dropdown-item-icon-end.sc-calcite-dropdown-item{margin-inline-start:1rem}/*!@:host([hidden])*/[hidden].sc-calcite-dropdown-item-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-dropdown-item{display:none}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-dropdown-item-h[disabled] .sc-calcite-dropdown-item-s>[calcite-hydrated][disabled],[disabled].sc-calcite-dropdown-item-h [calcite-hydrated][disabled].sc-calcite-dropdown-item{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-dropdown-item{display:contents}";

/**
 * @slot - A slot for adding text.
 */
class DropdownItem {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteDropdownItemSelect = createEvent(this, "calciteDropdownItemSelect", 6);
        this.calciteInternalDropdownItemSelect = createEvent(this, "calciteInternalDropdownItemSelect", 6);
        this.calciteInternalDropdownItemKeyEvent = createEvent(this, "calciteInternalDropdownItemKeyEvent", 6);
        this.calciteInternalDropdownCloseRequest = createEvent(this, "calciteInternalDropdownCloseRequest", 6);
        this.disabled = false;
        this.href = undefined;
        this.iconFlipRtl = undefined;
        this.iconStart = undefined;
        this.iconEnd = undefined;
        this.label = undefined;
        this.rel = undefined;
        this.selected = false;
        this.target = undefined;
        this.selectionMode = "single";
        this.scale = "m";
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.el?.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentWillLoad() {
        setUpLoadableComponent(this);
        this.initialize();
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    connectedCallback() {
        this.initialize();
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    render() {
        const { href, selectionMode, label, iconFlipRtl, scale } = this;
        const iconStartEl = (hAsync("calcite-icon", { class: CSS$_.iconStart, flipRtl: iconFlipRtl === "start" || iconFlipRtl === "both", icon: this.iconStart, scale: getIconScale(this.scale) }));
        const contentNode = (hAsync("span", { class: CSS$_.itemContent }, hAsync("slot", null)));
        const iconEndEl = (hAsync("calcite-icon", { class: CSS$_.iconEnd, flipRtl: iconFlipRtl === "end" || iconFlipRtl === "both", icon: this.iconEnd, scale: getIconScale(this.scale) }));
        const slottedContent = this.iconStart && this.iconEnd
            ? [iconStartEl, contentNode, iconEndEl]
            : this.iconStart
                ? [iconStartEl, contentNode]
                : this.iconEnd
                    ? [contentNode, iconEndEl]
                    : contentNode;
        const contentEl = !href ? (slottedContent) : (hAsync("a", { "aria-label": label, class: CSS$_.link, href: href, rel: this.rel, tabIndex: -1, target: this.target,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.childLink = el) }, slottedContent));
        const itemRole = href
            ? null
            : selectionMode === "single"
                ? "menuitemradio"
                : selectionMode === "multiple"
                    ? "menuitemcheckbox"
                    : "menuitem";
        const itemAria = selectionMode !== "none" ? toAriaBoolean(this.selected) : null;
        const { disabled } = this;
        return (hAsync(Host, { "aria-checked": itemAria, "aria-label": !href ? label : "", role: itemRole, tabIndex: disabled ? -1 : 0 }, hAsync(InteractiveContainer, { disabled: disabled }, hAsync("div", { class: {
                [CSS$_.container]: true,
                [CSS$_.containerLink]: !!href,
                [`${CSS$_.container}--${scale}`]: true,
                [CSS$_.containerMulti]: selectionMode === "multiple",
                [CSS$_.containerSingle]: selectionMode === "single",
                [CSS$_.containerNone]: selectionMode === "none",
            } }, selectionMode !== "none" ? (hAsync("calcite-icon", { class: CSS$_.icon, icon: selectionMode === "multiple" ? "check" : "bullet-point", scale: getIconScale(this.scale) })) : null, contentEl))));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    onClick() {
        this.emitRequestedItem();
    }
    keyDownHandler(event) {
        switch (event.key) {
            case " ":
            case "Enter":
                this.emitRequestedItem();
                if (this.href) {
                    this.childLink.click();
                }
                event.preventDefault();
                break;
            case "Escape":
                this.calciteInternalDropdownCloseRequest.emit();
                event.preventDefault();
                break;
            case "Tab":
                this.calciteInternalDropdownItemKeyEvent.emit({ keyboardEvent: event });
                break;
            case "ArrowUp":
            case "ArrowDown":
            case "Home":
            case "End":
                event.preventDefault();
                this.calciteInternalDropdownItemKeyEvent.emit({ keyboardEvent: event });
                break;
        }
    }
    updateActiveItemOnChange(event) {
        const parentEmittedChange = event.composedPath().includes(this.parentDropdownGroupEl);
        if (parentEmittedChange) {
            this.requestedDropdownGroup = event.detail.requestedDropdownGroup;
            this.requestedDropdownItem = event.detail.requestedDropdownItem;
            this.determineActiveItem();
        }
        event.stopPropagation();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    initialize() {
        this.parentDropdownGroupEl = this.el.closest("calcite-dropdown-group");
        if (this.selectionMode === "none") {
            this.selected = false;
        }
    }
    determineActiveItem() {
        switch (this.selectionMode) {
            case "multiple":
                if (this.el === this.requestedDropdownItem) {
                    this.selected = !this.selected;
                }
                break;
            case "single":
                if (this.el === this.requestedDropdownItem) {
                    this.selected = true;
                }
                else if (this.requestedDropdownGroup === this.parentDropdownGroupEl) {
                    this.selected = false;
                }
                break;
            case "none":
                this.selected = false;
                break;
        }
    }
    emitRequestedItem() {
        this.calciteDropdownItemSelect.emit();
        this.calciteInternalDropdownItemSelect.emit({
            requestedDropdownItem: this.el,
            requestedDropdownGroup: this.parentDropdownGroupEl,
        });
    }
    get el() { return getElement(this); }
    static get style() { return dropdownItemCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-dropdown-item",
        "$members$": {
            "disabled": [516],
            "href": [513],
            "iconFlipRtl": [513, "icon-flip-rtl"],
            "iconStart": [513, "icon-start"],
            "iconEnd": [513, "icon-end"],
            "label": [1],
            "rel": [513],
            "selected": [1540],
            "target": [513],
            "selectionMode": [1, "selection-mode"],
            "scale": [1],
            "setFocus": [64]
        },
        "$listeners$": [[0, "click", "onClick"], [0, "keydown", "keyDownHandler"], [16, "calciteInternalDropdownItemChange", "updateActiveItemOnChange"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["href", "href"], ["iconFlipRtl", "icon-flip-rtl"], ["iconStart", "icon-start"], ["iconEnd", "icon-end"], ["rel", "rel"], ["selected", "selected"], ["target", "target"]]
    }; }
}

const CSS$Z = {
    button: "button",
};
const ICONS$d = {
    plus: "plus",
};

const fabCss = "/*!@:host([disabled])*/[disabled].sc-calcite-fab-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-fab-h *.sc-calcite-fab,.sc-calcite-fab-h[disabled].sc-calcite-fab-s>*,.sc-calcite-fab-h[disabled] .sc-calcite-fab-s>*{pointer-events:none}/*!@:host*/.sc-calcite-fab-h{display:flex;background-color:transparent}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-fab-h[disabled] .sc-calcite-fab-s>[calcite-hydrated][disabled],[disabled].sc-calcite-fab-h [calcite-hydrated][disabled].sc-calcite-fab{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-fab{display:contents}/*!@calcite-button*/calcite-button.sc-calcite-fab{--tw-shadow:0 6px 20px -4px rgba(0, 0, 0, 0.1), 0 4px 12px -2px rgba(0, 0, 0, 0.08);--tw-shadow-colored:0 6px 20px -4px var(--tw-shadow-color), 0 4px 12px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@calcite-button:hover*/calcite-button.sc-calcite-fab:hover{--tw-shadow:var(--calcite-shadow-md);--tw-shadow-colored:var(--calcite-shadow-md);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@calcite-button:active*/calcite-button.sc-calcite-fab:active{--tw-shadow:0 2px 12px -4px rgba(0, 0, 0, 0.2), 0 2px 4px -2px rgba(0, 0, 0, 0.16);--tw-shadow-colored:0 2px 12px -4px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@:host([hidden])*/[hidden].sc-calcite-fab-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-fab{display:none}";

class Fab {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.appearance = "solid";
        this.kind = "brand";
        this.disabled = false;
        this.icon = ICONS$d.plus;
        this.iconFlipRtl = false;
        this.label = undefined;
        this.loading = false;
        this.scale = "m";
        this.text = undefined;
        this.textEnabled = false;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Methods
    //
    // --------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        focusElement(this.buttonEl);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const { appearance, kind, disabled, loading, scale, textEnabled, icon, label, text, iconFlipRtl, } = this;
        const title = !textEnabled ? label || text || null : null;
        return (hAsync(InteractiveContainer, { disabled: disabled }, hAsync("calcite-button", { appearance: appearance === "solid" ? "solid" : "outline-fill", class: CSS$Z.button, disabled: disabled, iconFlipRtl: iconFlipRtl ? "start" : null, iconStart: icon, kind: kind, label: label, loading: loading, round: true, scale: scale, title: title, type: "button", width: "auto",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (buttonEl) => {
                this.buttonEl = buttonEl;
            } }, this.textEnabled ? this.text : null)));
    }
    get el() { return getElement(this); }
    static get style() { return fabCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-fab",
        "$members$": {
            "appearance": [513],
            "kind": [513],
            "disabled": [516],
            "icon": [513],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "label": [1],
            "loading": [516],
            "scale": [513],
            "text": [1],
            "textEnabled": [516, "text-enabled"],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["appearance", "appearance"], ["kind", "kind"], ["disabled", "disabled"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["loading", "loading"], ["scale", "scale"], ["textEnabled", "text-enabled"]]
    }; }
}

const CSS$Y = {
    container: "container",
    searchIcon: "search-icon",
};
const ICONS$c = {
    search: "search",
    close: "x",
};
const DEBOUNCE_TIMEOUT = 250;

const filterCss = "/*!@:host*/.sc-calcite-filter-h{box-sizing:border-box;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host **/.sc-calcite-filter-h *.sc-calcite-filter{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-calcite-filter-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-filter-h *.sc-calcite-filter,.sc-calcite-filter-h[disabled].sc-calcite-filter-s>*,.sc-calcite-filter-h[disabled] .sc-calcite-filter-s>*{pointer-events:none}/*!@:host*/.sc-calcite-filter-h{display:flex;inline-size:100%}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-filter-h[disabled] .sc-calcite-filter-s>[calcite-hydrated][disabled],[disabled].sc-calcite-filter-h [calcite-hydrated][disabled].sc-calcite-filter{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-filter{display:contents}/*!@.container*/.container.sc-calcite-filter{display:flex;inline-size:100%;padding:0.5rem}/*!@label*/label.sc-calcite-filter{position:relative;margin-inline:0.25rem;margin-block:0px;display:flex;inline-size:100%;align-items:center;overflow:hidden}/*!@input[type=text]*/input[type=text].sc-calcite-filter{margin-block-end:0.25rem;inline-size:100%;border-style:none;background-color:transparent;padding-block:0.25rem;font-family:inherit;font-size:var(--calcite-font-size--2);line-height:1rem;color:var(--calcite-color-text-1);padding-inline-end:0.25rem;padding-inline-start:1.5rem;transition:padding var(--calcite-animation-timing), box-shadow var(--calcite-animation-timing)}/*!@input[type=text]::-ms-clear*/input[type=text].sc-calcite-filter::-ms-clear{display:none}/*!@calcite-input*/calcite-input.sc-calcite-filter{inline-size:100%}/*!@.search-icon*/.search-icon.sc-calcite-filter{position:absolute;display:flex;color:var(--calcite-color-text-2);inset-inline-start:0;transition:inset-inline-start var(--calcite-animation-timing), inset-inline-end var(--calcite-animation-timing), opacity var(--calcite-animation-timing)}/*!@input[type=text]:focus*/input[type=text].sc-calcite-filter:focus{border-color:var(--calcite-color-brand);outline:2px solid transparent;outline-offset:2px;padding-inline:0.25rem}/*!@input[type=text]:focus ~ .search-icon*/input[type=text].sc-calcite-filter:focus~.search-icon.sc-calcite-filter{inset-inline-start:calc(1rem * -1);opacity:0}/*!@.clear-button*/.clear-button.sc-calcite-filter{display:flex;cursor:pointer;align-items:center;border-width:0px;background-color:transparent;color:var(--calcite-color-text-2)}/*!@.clear-button:hover, .clear-button:focus*/.clear-button.sc-calcite-filter:hover,.clear-button.sc-calcite-filter:focus{color:var(--calcite-color-text-1)}/*!@:host([hidden])*/[hidden].sc-calcite-filter-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-filter{display:none}";

class Filter {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteFilterChange = createEvent(this, "calciteFilterChange", 6);
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.filterDebounced = debounce((value, emit = false, onFilter) => this.items.length && this.updateFiltered(filter(this.items, value), emit, onFilter), DEBOUNCE_TIMEOUT);
        this.inputHandler = (event) => {
            const target = event.target;
            this.value = target.value;
            this.filterDebounced(target.value, true);
        };
        this.keyDownHandler = (event) => {
            if (event.key === "Escape") {
                this.clear();
                event.preventDefault();
            }
            if (event.key === "Enter") {
                event.preventDefault();
            }
        };
        this.clear = () => {
            this.value = "";
            this.filterDebounced("", true);
            this.setFocus();
        };
        this.items = [];
        this.disabled = false;
        this.filteredItems = [];
        this.placeholder = undefined;
        this.scale = "m";
        this.value = "";
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.effectiveLocale = undefined;
        this.defaultMessages = undefined;
    }
    watchItemsHandler() {
        this.filterDebounced(this.value);
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    valueHandler(value) {
        this.filterDebounced(value);
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        setUpLoadableComponent(this);
        if (this.items.length) {
            this.updateFiltered(filter(this.items, this.value));
        }
        await setUpMessages(this);
    }
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        this.filterDebounced.cancel();
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Performs a filter on the component.
     *
     * This method can be useful because filtering is delayed and asynchronous.
     *
     * @param {string} value - The filter text value.
     * @returns {Promise<void>}
     */
    async filter(value = this.value) {
        return new Promise((resolve) => {
            this.value = value;
            this.filterDebounced(value, false, resolve);
        });
    }
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.el?.focus();
    }
    updateFiltered(filtered, emit = false, callback) {
        this.filteredItems = filtered;
        if (emit) {
            this.calciteFilterChange.emit();
        }
        callback?.();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const { disabled, scale } = this;
        return (hAsync(InteractiveContainer, { disabled: disabled }, hAsync("div", { class: CSS$Y.container }, hAsync("label", null, hAsync("calcite-input", { clearable: true, disabled: disabled, icon: ICONS$c.search, label: this.messages.label, messageOverrides: { clear: this.messages.clear }, onCalciteInputInput: this.inputHandler, onKeyDown: this.keyDownHandler, placeholder: this.placeholder, scale: scale, type: "text", value: this.value,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => {
                this.textInput = el;
            } })))));
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "items": ["watchItemsHandler"],
        "messageOverrides": ["onMessagesChange"],
        "value": ["valueHandler"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return filterCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-filter",
        "$members$": {
            "items": [16],
            "disabled": [516],
            "filteredItems": [1040],
            "placeholder": [1],
            "scale": [513],
            "value": [1025],
            "messages": [1040],
            "messageOverrides": [1040],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "filter": [64],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["scale", "scale"]]
    }; }
}

const CSS$X = {
    frame: "frame",
    frameAdvancing: "frame--advancing",
    frameRetreating: "frame--retreating",
};

const flowCss = "/*!@:host*/.sc-calcite-flow-h{box-sizing:border-box;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host **/.sc-calcite-flow-h *.sc-calcite-flow{box-sizing:border-box}/*!@:host*/.sc-calcite-flow-h{position:relative;display:flex;inline-size:100%;flex:1 1 auto;align-items:stretch;overflow:hidden;background-color:transparent}/*!@:host .frame*/.sc-calcite-flow-h .frame.sc-calcite-flow{position:relative;margin:0px;display:flex;inline-size:100%;flex:1 1 auto;flex-direction:column;align-items:stretch;padding:0px}/*!@:host ::slotted(calcite-flow-item),\n:host ::slotted(calcite-panel)*/.sc-calcite-flow-h .sc-calcite-flow-s>calcite-flow-item,.sc-calcite-flow-h.sc-calcite-flow-s>calcite-panel,.sc-calcite-flow-h .sc-calcite-flow-s>calcite-panel{block-size:100%}/*!@:host ::slotted(.calcite-match-height:last-child)*/.sc-calcite-flow-h .sc-calcite-flow-s>.calcite-match-height:last-child{display:flex;flex:1 1 auto;overflow:hidden}/*!@:host .frame--advancing*/.sc-calcite-flow-h .frame--advancing.sc-calcite-flow{animation:calcite-frame-advance var(--calcite-animation-timing)}/*!@:host .frame--retreating*/.sc-calcite-flow-h .frame--retreating.sc-calcite-flow{animation:calcite-frame-retreat var(--calcite-animation-timing)}@keyframes calcite-frame-advance{0%{--tw-bg-opacity:0.5;transform:translate3d(50px, 0, 0)}100%{--tw-bg-opacity:1;transform:translate3d(0, 0, 0)}}@keyframes calcite-frame-retreat{0%{--tw-bg-opacity:0.5;transform:translate3d(-50px, 0, 0)}100%{--tw-bg-opacity:1;transform:translate3d(0, 0, 0)}}/*!@:host([hidden])*/[hidden].sc-calcite-flow-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-flow{display:none}";

/**
 * @slot - A slot for adding `calcite-flow-item` elements to the component.
 */
class Flow {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.itemMutationObserver = createObserver();
        this.getFlowDirection = (oldFlowItemCount, newFlowItemCount) => {
            const allowRetreatingDirection = oldFlowItemCount > 1;
            const allowAdvancingDirection = oldFlowItemCount && newFlowItemCount > 1;
            if (!allowAdvancingDirection && !allowRetreatingDirection) {
                return null;
            }
            return newFlowItemCount < oldFlowItemCount ? "retreating" : "advancing";
        };
        this.updateFlowProps = () => {
            const { customItemSelectors, el, items } = this;
            const newItems = Array.from(el.querySelectorAll(`calcite-flow-item${customItemSelectors ? `,${customItemSelectors}` : ""}`)).filter((flowItem) => flowItem.closest("calcite-flow") === el);
            const oldItemCount = items.length;
            const newItemCount = newItems.length;
            const activeItem = newItems[newItemCount - 1];
            const previousItem = newItems[newItemCount - 2];
            if (newItemCount && activeItem) {
                newItems.forEach((itemNode) => {
                    itemNode.showBackButton = itemNode === activeItem && newItemCount > 1;
                    itemNode.hidden = itemNode !== activeItem;
                });
            }
            if (previousItem) {
                previousItem.menuOpen = false;
            }
            this.items = newItems;
            if (oldItemCount !== newItemCount) {
                const flowDirection = this.getFlowDirection(oldItemCount, newItemCount);
                this.itemCount = newItemCount;
                this.flowDirection = flowDirection;
            }
        };
        this.customItemSelectors = undefined;
        this.flowDirection = null;
        this.itemCount = 0;
        this.items = [];
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Removes the currently active `calcite-flow-item`.
     */
    async back() {
        const { items } = this;
        const lastItem = items[items.length - 1];
        if (!lastItem) {
            return;
        }
        const beforeBack = lastItem.beforeBack
            ? lastItem.beforeBack
            : () => Promise.resolve();
        try {
            await beforeBack.call(lastItem);
        }
        catch (_error) {
            // back prevented
            return;
        }
        lastItem.remove();
        return lastItem;
    }
    /**
     * Sets focus on the component.
     */
    async setFocus() {
        await componentFocusable(this);
        const { items } = this;
        const activeItem = items[items.length - 1];
        return activeItem?.setFocus();
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        this.itemMutationObserver?.observe(this.el, { childList: true, subtree: true });
        this.updateFlowProps();
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        this.itemMutationObserver?.disconnect();
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    async handleItemBackClick(event) {
        if (event.defaultPrevented) {
            return;
        }
        await this.back();
        return this.setFocus();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const { flowDirection } = this;
        const frameDirectionClasses = {
            [CSS$X.frame]: true,
            [CSS$X.frameAdvancing]: flowDirection === "advancing",
            [CSS$X.frameRetreating]: flowDirection === "retreating",
        };
        return (hAsync("div", { class: frameDirectionClasses }, hAsync("slot", null)));
    }
    get el() { return getElement(this); }
    static get style() { return flowCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-flow",
        "$members$": {
            "customItemSelectors": [1, "custom-item-selectors"],
            "flowDirection": [32],
            "itemCount": [32],
            "items": [32],
            "back": [64],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteFlowItemBack", "handleItemBackClick"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

const CSS$W = {
    actionBarContainer: "action-bar-container",
    backButton: "back-button",
    container: "container",
    header: "header",
    headerContainer: "header-container",
    headerContainerBorderEnd: "header-container--border-end",
    heading: "heading",
    summary: "summary",
    description: "description",
    headerContent: "header-content",
    headerActions: "header-actions",
    headerActionsEnd: "header-actions--end",
    headerActionsStart: "header-actions--start",
    contentWrapper: "content-wrapper",
    fabContainer: "fab-container",
    footer: "footer",
};
const ICONS$b = {
    close: "x",
    menu: "ellipsis",
    backLeft: "chevron-left",
    backRight: "chevron-right",
    expand: "chevron-down",
    collapse: "chevron-up",
};
const SLOTS$n = {
    actionBar: "action-bar",
    headerActionsStart: "header-actions-start",
    headerActionsEnd: "header-actions-end",
    headerMenuActions: "header-menu-actions",
    headerContent: "header-content",
    fab: "fab",
    footer: "footer",
    footerActions: "footer-actions",
};

const CSS$V = {
    backButton: "back-button",
};
const ICONS$a = {
    backLeft: "chevron-left",
    backRight: "chevron-right",
};
const SLOTS$m = {
    actionBar: "action-bar",
    headerActionsStart: "header-actions-start",
    headerActionsEnd: "header-actions-end",
    headerMenuActions: "header-menu-actions",
    headerContent: "header-content",
    fab: "fab",
    footer: "footer",
    footerActions: "footer-actions",
};

const flowItemCss = "/*!@:host*/.sc-calcite-flow-item-h{box-sizing:border-box;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host **/.sc-calcite-flow-item-h *.sc-calcite-flow-item{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-calcite-flow-item-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-flow-item-h *.sc-calcite-flow-item,.sc-calcite-flow-item-h[disabled].sc-calcite-flow-item-s>*,.sc-calcite-flow-item-h[disabled] .sc-calcite-flow-item-s>*{pointer-events:none}/*!@:host*/.sc-calcite-flow-item-h{position:relative;display:flex;inline-size:100%;flex:1 1 auto;overflow:hidden}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-flow-item-h[disabled] .sc-calcite-flow-item-s>[calcite-hydrated][disabled],[disabled].sc-calcite-flow-item-h [calcite-hydrated][disabled].sc-calcite-flow-item{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-flow-item{display:contents}/*!@.back-button*/.back-button.sc-calcite-flow-item{border-width:0px;border-style:solid;border-color:var(--calcite-color-border-3);border-inline-end-width:1px}/*!@calcite-panel*/calcite-panel.sc-calcite-flow-item{--calcite-panel-footer-padding:var(--calcite-flow-item-footer-padding);--calcite-panel-header-border-block-end:var(--calcite-flow-item-header-border-block-end)}/*!@:host([hidden])*/[hidden].sc-calcite-flow-item-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-flow-item{display:none}";

/**
 * @slot - A slot for adding custom content.
 * @slot action-bar - A slot for adding a `calcite-action-bar` to the component.
 * @slot header-actions-start - A slot for adding `calcite-action`s or content to the start side of the component's header.
 * @slot header-actions-end - A slot for adding `calcite-action`s or content to the end side of the component's header.
 * @slot header-content - A slot for adding custom content to the component's header.
 * @slot header-menu-actions - A slot for adding an overflow menu with `calcite-action`s inside a `calcite-dropdown`.
 * @slot fab - A slot for adding a `calcite-fab` (floating action button) to perform an action.
 * @slot footer-actions - [Deprecated] Use the `"footer"` slot instead. A slot for adding `calcite-button`s to the component's footer.
 * @slot footer - A slot for adding custom content to the component's footer.
 */
class FlowItem {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteFlowItemBack = createEvent(this, "calciteFlowItemBack", 7);
        this.calciteFlowItemScroll = createEvent(this, "calciteFlowItemScroll", 6);
        this.calciteFlowItemClose = createEvent(this, "calciteFlowItemClose", 6);
        this.calciteFlowItemToggle = createEvent(this, "calciteFlowItemToggle", 6);
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.handlePanelScroll = (event) => {
            event.stopPropagation();
            this.calciteFlowItemScroll.emit();
        };
        this.handlePanelClose = (event) => {
            event.stopPropagation();
            this.calciteFlowItemClose.emit();
        };
        this.handlePanelToggle = (event) => {
            event.stopPropagation();
            this.collapsed = event.target.collapsed;
            this.calciteFlowItemToggle.emit();
        };
        this.backButtonClick = () => {
            this.calciteFlowItemBack.emit();
        };
        this.setBackRef = (node) => {
            this.backButtonEl = node;
        };
        this.setContainerRef = (node) => {
            this.containerEl = node;
        };
        this.closable = false;
        this.closed = false;
        this.collapsed = false;
        this.collapseDirection = "down";
        this.collapsible = false;
        this.beforeBack = undefined;
        this.description = undefined;
        this.disabled = false;
        this.heading = undefined;
        this.headingLevel = undefined;
        this.loading = false;
        this.menuOpen = false;
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.overlayPositioning = "absolute";
        this.showBackButton = false;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
    }
    async componentWillLoad() {
        await setUpMessages(this);
        setUpLoadableComponent(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Sets focus on the component.
     *
     * @returns promise.
     */
    async setFocus() {
        await componentFocusable(this);
        const { backButtonEl, containerEl } = this;
        if (backButtonEl) {
            return backButtonEl.setFocus();
        }
        else if (containerEl) {
            return containerEl.setFocus();
        }
    }
    /**
     * Scrolls the component's content to a specified set of coordinates.
     *
     * @example
     * myCalciteFlowItem.scrollContentTo({
     *   left: 0, // Specifies the number of pixels along the X axis to scroll the window or element.
     *   top: 0, // Specifies the number of pixels along the Y axis to scroll the window or element
     *   behavior: "auto" // Specifies whether the scrolling should animate smoothly (smooth), or happen instantly in a single jump (auto, the default value).
     * });
     * @param options - allows specific coordinates to be defined.
     * @returns - promise that resolves once the content is scrolled to.
     */
    async scrollContentTo(options) {
        await this.containerEl?.scrollContentTo(options);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderBackButton() {
        const { el } = this;
        const rtl = getElementDir(el) === "rtl";
        const { showBackButton, backButtonClick, messages } = this;
        const label = messages.back;
        const icon = rtl ? ICONS$a.backRight : ICONS$a.backLeft;
        return showBackButton ? (hAsync("calcite-action", { "aria-label": label, class: CSS$V.backButton, icon: icon, key: "flow-back-button", onClick: backButtonClick, scale: "s", slot: "header-actions-start", text: label, title: label,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setBackRef })) : null;
    }
    render() {
        const { collapsed, collapseDirection, collapsible, closable, closed, description, disabled, heading, headingLevel, loading, menuOpen, messages, overlayPositioning, } = this;
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: disabled }, hAsync("calcite-panel", { closable: closable, closed: closed, collapseDirection: collapseDirection, collapsed: collapsed, collapsible: collapsible, description: description, disabled: disabled, heading: heading, headingLevel: headingLevel, loading: loading, menuOpen: menuOpen, messageOverrides: messages, onCalcitePanelClose: this.handlePanelClose, onCalcitePanelScroll: this.handlePanelScroll, onCalcitePanelToggle: this.handlePanelToggle, overlayPositioning: overlayPositioning,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setContainerRef }, this.renderBackButton(), hAsync("slot", { name: SLOTS$m.actionBar, slot: SLOTS$n.actionBar }), hAsync("slot", { name: SLOTS$m.headerActionsStart, slot: SLOTS$n.headerActionsStart }), hAsync("slot", { name: SLOTS$m.headerActionsEnd, slot: SLOTS$n.headerActionsEnd }), hAsync("slot", { name: SLOTS$m.headerContent, slot: SLOTS$n.headerContent }), hAsync("slot", { name: SLOTS$m.headerMenuActions, slot: SLOTS$n.headerMenuActions }), hAsync("slot", { name: SLOTS$m.fab, slot: SLOTS$n.fab }), hAsync("slot", { name: SLOTS$m.footerActions, slot: SLOTS$n.footerActions }), hAsync("slot", { name: SLOTS$m.footer, slot: SLOTS$n.footer }), hAsync("slot", null)))));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return flowItemCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-flow-item",
        "$members$": {
            "closable": [516],
            "closed": [516],
            "collapsed": [516],
            "collapseDirection": [1, "collapse-direction"],
            "collapsible": [516],
            "beforeBack": [16],
            "description": [1],
            "disabled": [516],
            "heading": [1],
            "headingLevel": [514, "heading-level"],
            "loading": [516],
            "menuOpen": [516, "menu-open"],
            "messageOverrides": [1040],
            "messages": [1040],
            "overlayPositioning": [513, "overlay-positioning"],
            "showBackButton": [4, "show-back-button"],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "setFocus": [64],
            "scrollContentTo": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["closable", "closable"], ["closed", "closed"], ["collapsed", "collapsed"], ["collapsible", "collapsible"], ["disabled", "disabled"], ["headingLevel", "heading-level"], ["loading", "loading"], ["menuOpen", "menu-open"], ["overlayPositioning", "overlay-positioning"]]
    }; }
}

/**
 * Calculate slope of the tangents
 * uses Steffen interpolation as it's monotonic
 * http://jrwalsh1.github.io/posts/interpolations/
 *
 * @param p0
 * @param p1
 * @param p2
 */
function slope(p0, p1, p2) {
    const dx = p1[0] - p0[0];
    const dx1 = p2[0] - p1[0];
    const dy = p1[1] - p0[1];
    const dy1 = p2[1] - p1[1];
    const m = dy / (dx || (dx1 < 0 && 0));
    const m1 = dy1 / (dx1 || (dx < 0 && 0));
    const p = (m * dx1 + m1 * dx) / (dx + dx1);
    return (Math.sign(m) + Math.sign(m1)) * Math.min(Math.abs(m), Math.abs(m1), 0.5 * Math.abs(p)) || 0;
}
/**
 * Calculate slope for just one tangent (single-sided)
 *
 * @param p0
 * @param p1
 * @param m
 */
function slopeSingle(p0, p1, m) {
    const dx = p1[0] - p0[0];
    const dy = p1[1] - p0[1];
    return dx ? ((3 * dy) / dx - m) / 2 : m;
}
/**
 * Given two points and their tangent slopes,
 * calculate the bezier handle coordinates and return draw command.
 *
 * Translates Hermite Spline to Bézier curve:
 * https://stackoverflow.com/questions/42574940/
 *
 * @param p0
 * @param p1
 * @param m0
 * @param m1
 * @param t
 */
function bezier(p0, p1, m0, m1, t) {
    const [x0, y0] = p0;
    const [x1, y1] = p1;
    const dx = (x1 - x0) / 3;
    const h1 = t([x0 + dx, y0 + dx * m0]).join(",");
    const h2 = t([x1 - dx, y1 - dx * m1]).join(",");
    const p = t([x1, y1]).join(",");
    return `C ${h1} ${h2} ${p}`;
}
/**
 * Generate a function which will translate a point
 * from the data coordinate space to svg viewbox oriented pixels
 *
 * @param root0
 * @param root0.width
 * @param root0.height
 * @param root0.min
 * @param root0.max
 */
function translate$4({ width, height, min, max }) {
    const rangeX = max[0] - min[0];
    const rangeY = max[1] - min[1];
    return (point) => {
        const x = ((point[0] - min[0]) / rangeX) * width;
        const y = height - (point[1] / rangeY) * height;
        return [x, y];
    };
}
/**
 * Get the min and max values from the dataset
 *
 * @param data
 */
function range(data) {
    const [startX, startY] = data[0];
    const min = [startX, startY];
    const max = [startX, startY];
    return data.reduce(({ min, max }, [x, y]) => ({
        min: [Math.min(min[0], x), Math.min(min[1], y)],
        max: [Math.max(max[0], x), Math.max(max[1], y)],
    }), { min, max });
}
/**
 * Generate drawing commands for an area graph
 * returns a string can can be passed directly to a path element's `d` attribute
 *
 * @param root0
 * @param root0.data
 * @param root0.min
 * @param root0.max
 * @param root0.t
 */
function area({ data, min, max, t }) {
    if (data.length === 0) {
        return "";
    }
    // important points for beginning and ending the path
    const [startX, startY] = t(data[0]);
    const [minX, minY] = t(min);
    const [maxX] = t(max);
    // keep track of previous slope/points
    let m;
    let p0;
    let p1;
    // iterate over data points, calculating command for each
    const commands = data.reduce((acc, point, i) => {
        p0 = data[i - 2];
        p1 = data[i - 1];
        if (i > 1) {
            const m1 = slope(p0, p1, point);
            const m0 = m === undefined ? slopeSingle(p0, p1, m1) : m;
            const command = bezier(p0, p1, m0, m1, t);
            m = m1;
            return `${acc} ${command}`;
        }
        return acc;
    }, `M ${minX},${minY} L ${minX},${startY} L ${startX},${startY}`);
    // close the path
    const last = data[data.length - 1];
    const end = bezier(p1, last, m, slopeSingle(p1, last, m), t);
    return `${commands} ${end} L ${maxX},${minY} Z`;
}

const graphCss = "/*!@:host*/.sc-calcite-graph-h{display:block;block-size:100%}/*!@.svg*/.svg.sc-calcite-graph{fill:currentColor;stroke:transparent;margin:0px;display:block;block-size:100%;inline-size:100%;padding:0px}/*!@.svg .graph-path--highlight*/.svg.sc-calcite-graph .graph-path--highlight.sc-calcite-graph{fill:var(--calcite-color-brand);opacity:0.5}/*!@:host([hidden])*/[hidden].sc-calcite-graph-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-graph{display:none}";

class Graph {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.graphId = `calcite-graph-${guid()}`;
        this.resizeObserver = createObserver();
        this.data = [];
        this.colorStops = undefined;
        this.highlightMin = undefined;
        this.highlightMax = undefined;
        this.min = undefined;
        this.max = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.resizeObserver?.observe(this.el);
    }
    disconnectedCallback() {
        this.resizeObserver?.disconnect();
    }
    render() {
        const { data, colorStops, el, highlightMax, highlightMin, min, max } = this;
        const id = this.graphId;
        const { clientHeight: height, clientWidth: width } = el;
        // if we have no data, return empty svg
        if (!data || data.length === 0) {
            return (hAsync("svg", { "aria-hidden": "true", class: "svg", height: height, preserveAspectRatio: "none", viewBox: `0 0 ${width} ${height}`, width: width }));
        }
        const { min: rangeMin, max: rangeMax } = range(data);
        let currentMin = rangeMin;
        let currentMax = rangeMax;
        if (min < rangeMin[0] || min > rangeMin[0]) {
            currentMin = [min, 0];
        }
        if (max > rangeMax[0] || max < rangeMax[0]) {
            currentMax = [max, rangeMax[1]];
        }
        const t = translate$4({ min: currentMin, max: currentMax, width, height });
        const [hMinX] = t([highlightMin, currentMax[1]]);
        const [hMaxX] = t([highlightMax, currentMax[1]]);
        const areaPath = area({ data, min: rangeMin, max: rangeMax, t });
        const fill = colorStops ? `url(#linear-gradient-${id})` : undefined;
        return (hAsync("svg", { "aria-hidden": "true", class: "svg", height: height, preserveAspectRatio: "none", viewBox: `0 0 ${width} ${height}`, width: width }, colorStops ? (hAsync("defs", null, hAsync("linearGradient", { id: `linear-gradient-${id}`, x1: "0", x2: "1", y1: "0", y2: "0" }, colorStops.map(({ offset, color, opacity }) => (hAsync("stop", { offset: `${offset * 100}%`, "stop-color": color, "stop-opacity": opacity })))))) : null, highlightMin !== undefined ? ([
            hAsync("mask", { height: "100%", id: `${id}1`, width: "100%", x: "0%", y: "0%" }, hAsync("path", { d: `
            M 0,0
            L ${hMinX - 1},0
            L ${hMinX - 1},${height}
            L 0,${height}
            Z
          `, fill: "white" })),
            hAsync("mask", { height: "100%", id: `${id}2`, width: "100%", x: "0%", y: "0%" }, hAsync("path", { d: `
            M ${hMinX + 1},0
            L ${hMaxX - 1},0
            L ${hMaxX - 1},${height}
            L ${hMinX + 1}, ${height}
            Z
          `, fill: "white" })),
            hAsync("mask", { height: "100%", id: `${id}3`, width: "100%", x: "0%", y: "0%" }, hAsync("path", { d: `
                M ${hMaxX + 1},0
                L ${width},0
                L ${width},${height}
                L ${hMaxX + 1}, ${height}
                Z
              `, fill: "white" })),
            hAsync("path", { class: "graph-path", d: areaPath, fill: fill, mask: `url(#${id}1)` }),
            hAsync("path", { class: "graph-path--highlight", d: areaPath, fill: fill, mask: `url(#${id}2)` }),
            hAsync("path", { class: "graph-path", d: areaPath, fill: fill, mask: `url(#${id}3)` }),
        ]) : (hAsync("path", { class: "graph-path", d: areaPath, fill: fill }))));
    }
    get el() { return getElement(this); }
    static get style() { return graphCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-graph",
        "$members$": {
            "data": [16],
            "colorStops": [16],
            "highlightMin": [2, "highlight-min"],
            "highlightMax": [2, "highlight-max"],
            "min": [514],
            "max": [514]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["min", "min"], ["max", "max"]]
    }; }
}

const CSS$U = {
    handle: "handle",
    handleSelected: "handle--selected",
};
const ICONS$9 = {
    drag: "drag",
};
const SUBSTITUTIONS = {
    itemLabel: "{itemLabel}",
    position: "{position}",
    total: "{total}",
};

const handleCss = "/*!@:host([disabled])*/[disabled].sc-calcite-handle-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-handle-h *.sc-calcite-handle,.sc-calcite-handle-h[disabled].sc-calcite-handle-s>*,.sc-calcite-handle-h[disabled] .sc-calcite-handle-s>*{pointer-events:none}/*!@:host*/.sc-calcite-handle-h{display:flex}/*!@.handle*/.handle.sc-calcite-handle{display:flex;align-items:center;justify-content:center;align-self:stretch;border-style:none;background-color:transparent;outline-color:transparent;color:var(--calcite-color-border-input);padding-block:0.75rem;padding-inline:0.25rem;line-height:0}/*!@.handle calcite-icon*/.handle.sc-calcite-handle calcite-icon.sc-calcite-handle{color:inherit}/*!@:host(:not([disabled])) .handle*/.sc-calcite-handle-h:not([disabled]) .handle.sc-calcite-handle{cursor:move}/*!@:host(:not([disabled])) .handle:hover*/.sc-calcite-handle-h:not([disabled]) .handle.sc-calcite-handle:hover{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-text-1)}/*!@:host(:not([disabled])) .handle:focus*/.sc-calcite-handle-h:not([disabled]) .handle.sc-calcite-handle:focus{color:var(--calcite-color-text-1);outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host(:not([disabled])) .handle--selected*/.sc-calcite-handle-h:not([disabled]) .handle--selected.sc-calcite-handle{background-color:var(--calcite-color-foreground-3);color:var(--calcite-color-text-1)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-handle-h[disabled] .sc-calcite-handle-s>[calcite-hydrated][disabled],[disabled].sc-calcite-handle-h [calcite-hydrated][disabled].sc-calcite-handle{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-handle{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-handle-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-handle{display:none}";

class Handle {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteHandleChange = createEvent(this, "calciteHandleChange", 6);
        this.calciteHandleNudge = createEvent(this, "calciteHandleNudge", 6);
        this.calciteInternalAssistiveTextChange = createEvent(this, "calciteInternalAssistiveTextChange", 6);
        this.handleKeyDown = (event) => {
            if (this.disabled) {
                return;
            }
            switch (event.key) {
                case " ":
                    this.selected = !this.selected;
                    this.calciteHandleChange.emit();
                    event.preventDefault();
                    break;
                case "ArrowUp":
                    if (!this.selected) {
                        return;
                    }
                    event.preventDefault();
                    this.calciteHandleNudge.emit({ direction: "up" });
                    break;
                case "ArrowDown":
                    if (!this.selected) {
                        return;
                    }
                    event.preventDefault();
                    this.calciteHandleNudge.emit({ direction: "down" });
                    break;
            }
        };
        this.handleBlur = () => {
            if (this.blurUnselectDisabled || this.disabled) {
                return;
            }
            if (this.selected) {
                this.selected = false;
                this.calciteHandleChange.emit();
            }
        };
        this.selected = false;
        this.disabled = false;
        this.dragHandle = undefined;
        this.messages = undefined;
        this.setPosition = undefined;
        this.setSize = undefined;
        this.label = undefined;
        this.blurUnselectDisabled = false;
        this.messageOverrides = undefined;
        this.effectiveLocale = undefined;
        this.defaultMessages = undefined;
    }
    handleAriaTextChange() {
        const message = this.getAriaText("live");
        if (message) {
            this.calciteInternalAssistiveTextChange.emit({
                message,
            });
        }
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectMessages(this);
        connectLocalized(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectMessages(this);
        disconnectLocalized(this);
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Methods
    //
    // --------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.handleButton?.focus();
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    getTooltip() {
        const { label, messages } = this;
        if (!messages) {
            return "";
        }
        if (!label) {
            return messages.dragHandleUntitled;
        }
        return messages.dragHandle.replace(SUBSTITUTIONS.itemLabel, label);
    }
    getAriaText(type) {
        const { setPosition, setSize, label, messages, selected } = this;
        if (!messages || !label || typeof setSize !== "number" || typeof setPosition !== "number") {
            return null;
        }
        const text = type === "label"
            ? selected
                ? messages.dragHandleChange
                : messages.dragHandleIdle
            : selected
                ? messages.dragHandleActive
                : messages.dragHandleCommit;
        const replacePosition = text.replace(SUBSTITUTIONS.position, setPosition.toString());
        const replaceLabel = replacePosition.replace(SUBSTITUTIONS.itemLabel, label);
        return replaceLabel.replace(SUBSTITUTIONS.total, setSize.toString());
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        return (
        // Needs to be a span because of https://github.com/SortableJS/Sortable/issues/1486
        hAsync("span", { "aria-disabled": this.disabled ? toAriaBoolean(this.disabled) : null, "aria-label": this.disabled ? null : this.getAriaText("label"), "aria-pressed": this.disabled ? null : toAriaBoolean(this.selected), class: { [CSS$U.handle]: true, [CSS$U.handleSelected]: !this.disabled && this.selected }, onBlur: this.handleBlur, onKeyDown: this.handleKeyDown, role: "button", tabIndex: this.disabled ? null : 0, title: this.getTooltip(),
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => {
                this.handleButton = el;
            } }, hAsync("calcite-icon", { icon: ICONS$9.drag, scale: "s" })));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messages": ["handleAriaTextChange"],
        "label": ["handleAriaTextChange"],
        "selected": ["handleAriaTextChange"],
        "setPosition": ["handleAriaTextChange"],
        "setSize": ["handleAriaTextChange"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return handleCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-handle",
        "$members$": {
            "selected": [1540],
            "disabled": [516],
            "dragHandle": [513, "drag-handle"],
            "messages": [16],
            "setPosition": [2, "set-position"],
            "setSize": [2, "set-size"],
            "label": [1],
            "blurUnselectDisabled": [4, "blur-unselect-disabled"],
            "messageOverrides": [16],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["selected", "selected"], ["disabled", "disabled"], ["dragHandle", "drag-handle"]]
    }; }
}

const CSS$T = {
    icon: "icon",
    flipRtl: "flip-rtl",
};

const scaleToPx = {
    s: 16,
    m: 24,
    l: 32,
};

const iconCss = "/*!@:host*/.sc-calcite-icon-h{display:inline-flex;color:var(--calcite-ui-icon-color)}/*!@:host([scale=s])*/[scale=s].sc-calcite-icon-h{inline-size:16px;block-size:16px;min-inline-size:16px;min-block-size:16px}/*!@:host([scale=m])*/[scale=m].sc-calcite-icon-h{inline-size:24px;block-size:24px;min-inline-size:24px;min-block-size:24px}/*!@:host([scale=l])*/[scale=l].sc-calcite-icon-h{inline-size:32px;block-size:32px;min-inline-size:32px;min-block-size:32px}/*!@.flip-rtl*/.flip-rtl.sc-calcite-icon{transform:scaleX(-1)}/*!@.svg*/.svg.sc-calcite-icon{display:block}/*!@:host([hidden])*/[hidden].sc-calcite-icon-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-icon{display:none}";

class Icon {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.icon = null;
        this.flipRtl = false;
        this.scale = "m";
        this.textLabel = undefined;
        this.pathData = undefined;
        this.visible = false;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.waitUntilVisible(() => {
            this.visible = true;
            this.loadIconPathData();
        });
    }
    disconnectedCallback() {
        this.intersectionObserver?.disconnect();
        this.intersectionObserver = null;
    }
    async componentWillLoad() {
        this.loadIconPathData();
    }
    render() {
        const { el, flipRtl, pathData, scale, textLabel } = this;
        const dir = getElementDir(el);
        const size = scaleToPx[scale];
        const semantic = !!textLabel;
        const paths = [].concat(pathData || "");
        return (hAsync(Host, { "aria-hidden": toAriaBoolean(!semantic), "aria-label": semantic ? textLabel : null, role: semantic ? "img" : null }, hAsync("svg", { "aria-hidden": "true", class: {
                [CSS$T.flipRtl]: dir === "rtl" && flipRtl,
                svg: true,
            }, fill: "currentColor", height: "100%", viewBox: `0 0 ${size} ${size}`, width: "100%", xmlns: "http://www.w3.org/2000/svg" }, paths.map((path) => typeof path === "string" ? (hAsync("path", { d: path })) : (hAsync("path", { d: path.d, opacity: "opacity" in path ? path.opacity : 1 }))))));
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    async loadIconPathData() {
        {
            return;
        }
    }
    waitUntilVisible(callback) {
        this.intersectionObserver = createObserver();
        if (!this.intersectionObserver) {
            callback();
            return;
        }
        this.intersectionObserver.observe(this.el);
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "icon": ["loadIconPathData"],
        "scale": ["loadIconPathData"]
    }; }
    static get style() { return iconCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-icon",
        "$members$": {
            "icon": [513],
            "flipRtl": [516, "flip-rtl"],
            "scale": [513],
            "textLabel": [1, "text-label"],
            "pathData": [32],
            "visible": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["icon", "icon"], ["flipRtl", "flip-rtl"], ["scale", "scale"]]
    }; }
}

const CSS$S = {
    wrapper: "wrapper",
    confirmChangesButton: "confirm-changes-button",
    cancelEditingButton: "cancel-editing-button",
    inputWrapper: "input-wrapper",
    cancelEditingButtonWrapper: "cancel-editing-button-wrapper",
    enableEditingButton: "enable-editing-button",
    controlsWrapper: "controls-wrapper",
};

const inlineEditableCss = "/*!@:host([disabled])*/[disabled].sc-calcite-inline-editable-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-inline-editable-h *.sc-calcite-inline-editable,.sc-calcite-inline-editable-h[disabled].sc-calcite-inline-editable-s>*,.sc-calcite-inline-editable-h[disabled] .sc-calcite-inline-editable-s>*{pointer-events:none}/*!@:host*/.sc-calcite-inline-editable-h{display:block}/*!@:host([scale=s]) .controls-wrapper*/[scale=s].sc-calcite-inline-editable-h .controls-wrapper.sc-calcite-inline-editable{block-size:1.5rem}/*!@:host([scale=m]) .controls-wrapper*/[scale=m].sc-calcite-inline-editable-h .controls-wrapper.sc-calcite-inline-editable{block-size:2rem}/*!@:host([scale=l]) .controls-wrapper*/[scale=l].sc-calcite-inline-editable-h .controls-wrapper.sc-calcite-inline-editable{block-size:2.75rem}/*!@:host(:not([editing-enabled]):not([disabled])) .wrapper:hover*/.sc-calcite-inline-editable-h:not([editing-enabled]):not([disabled]) .wrapper.sc-calcite-inline-editable:hover{background-color:var(--calcite-color-foreground-2)}/*!@.wrapper*/.wrapper.sc-calcite-inline-editable{box-sizing:border-box;display:flex;justify-content:space-between;background-color:var(--calcite-color-foreground-1);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.wrapper .input-wrapper*/.wrapper.sc-calcite-inline-editable .input-wrapper.sc-calcite-inline-editable{flex:1 1 0%}/*!@.controls-wrapper*/.controls-wrapper.sc-calcite-inline-editable{display:flex}/*!@:host([disabled]) .cancel-editing-button-wrapper*/[disabled].sc-calcite-inline-editable-h .cancel-editing-button-wrapper.sc-calcite-inline-editable{border-color:var(--calcite-color-border-2)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-inline-editable-h[disabled] .sc-calcite-inline-editable-s>[calcite-hydrated][disabled],[disabled].sc-calcite-inline-editable-h [calcite-hydrated][disabled].sc-calcite-inline-editable{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-inline-editable{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-inline-editable-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-inline-editable{display:none}";

/**
 * @slot - A slot for adding a `calcite-input`.
 */
class InlineEditable {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInlineEditableEditCancel = createEvent(this, "calciteInlineEditableEditCancel", 6);
        this.calciteInlineEditableEditConfirm = createEvent(this, "calciteInlineEditableEditConfirm", 6);
        this.calciteInternalInlineEditableEnableEditingChange = createEvent(this, "calciteInternalInlineEditableEnableEditingChange", 6);
        this.mutationObserver = createObserver();
        this.enableEditing = () => {
            this.valuePriorToEditing = this.inputElement?.value;
            this.editingEnabled = true;
            this.inputElement?.setFocus();
            this.calciteInternalInlineEditableEnableEditingChange.emit();
        };
        this.disableEditing = () => {
            this.editingEnabled = false;
        };
        this.cancelEditing = () => {
            if (this.inputElement) {
                this.inputElement.value = this.valuePriorToEditing;
            }
            this.disableEditing();
            this.enableEditingButton.setFocus();
            if (!this.editingEnabled && !!this.shouldEmitCancel) {
                this.calciteInlineEditableEditCancel.emit();
            }
        };
        this.escapeKeyHandler = async (event) => {
            if (event.defaultPrevented) {
                return;
            }
            if (event.key === "Escape") {
                event.preventDefault();
                this.cancelEditing();
            }
            if (event.key === "Tab" && this.shouldShowControls) {
                if (!event.shiftKey && event.target === this.inputElement) {
                    event.preventDefault();
                    this.cancelEditingButton.setFocus();
                }
                if (!!event.shiftKey && event.target === this.cancelEditingButton) {
                    event.preventDefault();
                    this.inputElement?.setFocus();
                }
            }
        };
        this.cancelEditingHandler = async (event) => {
            event.preventDefault();
            this.cancelEditing();
        };
        this.enableEditingHandler = async (event) => {
            if (this.disabled ||
                event.target === this.cancelEditingButton ||
                event.target === this.confirmEditingButton) {
                return;
            }
            event.preventDefault();
            if (!this.editingEnabled) {
                this.enableEditing();
            }
        };
        this.confirmChangesHandler = async (event) => {
            event.preventDefault();
            this.calciteInlineEditableEditConfirm.emit();
            try {
                if (this.afterConfirm) {
                    this.loading = true;
                    await this.afterConfirm();
                    this.disableEditing();
                    this.enableEditingButton.setFocus();
                }
            }
            catch (error) {
            }
            finally {
                this.loading = false;
            }
        };
        this.disabled = false;
        this.editingEnabled = false;
        this.loading = false;
        this.controls = false;
        this.scale = undefined;
        this.afterConfirm = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = undefined;
    }
    disabledWatcher(disabled) {
        if (this.inputElement) {
            this.inputElement.disabled = disabled;
        }
    }
    editingEnabledWatcher(newValue, oldValue) {
        if (this.inputElement) {
            this.inputElement.editingEnabled = newValue;
        }
        if (!newValue && !!oldValue) {
            this.shouldEmitCancel = true;
        }
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLabel(this);
        connectLocalized(this);
        connectMessages(this);
        this.mutationObserver?.observe(this.el, { childList: true });
        this.mutationObserverCallback();
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        this.mutationObserver?.disconnect();
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    render() {
        return (hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: CSS$S.wrapper, onClick: this.enableEditingHandler, onKeyDown: this.escapeKeyHandler }, hAsync("div", { class: CSS$S.inputWrapper }, hAsync("slot", null)), hAsync("div", { class: CSS$S.controlsWrapper }, hAsync("calcite-button", { appearance: "transparent", class: CSS$S.enableEditingButton, disabled: this.disabled, iconStart: "pencil", kind: "neutral", label: this.messages.enableEditing, onClick: this.enableEditingHandler, scale: this.scale, style: {
                opacity: this.editingEnabled ? "0" : "1",
                width: this.editingEnabled ? "0" : "inherit",
            }, type: "button",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.enableEditingButton = el) }), this.shouldShowControls && [
            hAsync("div", { class: CSS$S.cancelEditingButtonWrapper }, hAsync("calcite-button", { appearance: "transparent", class: CSS$S.cancelEditingButton, disabled: this.disabled, iconStart: "x", kind: "neutral", label: this.messages.cancelEditing, onClick: this.cancelEditingHandler, scale: this.scale, type: "button",
                // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
                ref: (el) => (this.cancelEditingButton = el) })),
            hAsync("calcite-button", { appearance: "solid", class: CSS$S.confirmChangesButton, disabled: this.disabled, iconStart: "check", kind: "brand", label: this.messages.confirmChanges, loading: this.loading, onClick: this.confirmChangesHandler, scale: this.scale, type: "button",
                // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
                ref: (el) => (this.confirmEditingButton = el) }),
        ]))));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    blurHandler() {
        if (!this.controls) {
            this.disableEditing();
        }
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.el?.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    mutationObserverCallback() {
        this.updateSlottedInput();
        this.scale = this.scale || this.inputElement?.scale;
    }
    onLabelClick() {
        this.setFocus();
    }
    updateSlottedInput() {
        const inputElement = getSlotted(this.el, {
            matches: "calcite-input",
        });
        this.inputElement = inputElement;
        if (!inputElement) {
            return;
        }
        this.inputElement.disabled = this.disabled;
        this.inputElement.label = this.inputElement.label || getLabelText(this);
    }
    get shouldShowControls() {
        return this.editingEnabled && this.controls;
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "disabled": ["disabledWatcher"],
        "editingEnabled": ["editingEnabledWatcher"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return inlineEditableCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-inline-editable",
        "$members$": {
            "disabled": [516],
            "editingEnabled": [1540, "editing-enabled"],
            "loading": [1540],
            "controls": [516],
            "scale": [1537],
            "afterConfirm": [16],
            "messages": [1040],
            "messageOverrides": [1040],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteInternalInputBlur", "blurHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["editingEnabled", "editing-enabled"], ["loading", "loading"], ["controls", "controls"], ["scale", "scale"]]
    }; }
}

const CSS$R = {
    loader: "loader",
    clearButton: "clear-button",
    editingEnabled: "editing-enabled",
    inlineChild: "inline-child",
    inputIcon: "icon",
    prefix: "prefix",
    suffix: "suffix",
    numberButtonWrapper: "number-button-wrapper",
    buttonItemHorizontal: "number-button-item--horizontal",
    wrapper: "element-wrapper",
    inputWrapper: "wrapper",
    actionWrapper: "action-wrapper",
    resizeIconWrapper: "resize-icon-wrapper",
    numberButtonItem: "number-button-item",
};
const INPUT_TYPE_ICONS = {
    tel: "phone",
    password: "lock",
    email: "email-address",
    date: "calendar",
    time: "clock",
    search: "search",
};
const SLOTS$l = {
    action: "action",
};

/**
 * Exported for testing purposes only
 */
const minMaxStepTypes = ["date", "datetime-local", "month", "number", "range", "time", "week"];
/**
 * Exported for testing purposes only
 */
const patternTypes = ["email", "password", "search", "tel", "text", "url"];
/**
 * Exported for testing purposes only
 */
const minMaxLengthTypes = ["email", "password", "search", "tel", "text", "textarea", "url"];
function updateConstraintValidation(inputComponent, input, propName, matchesType) {
    const attributeName = propName.toLowerCase();
    const value = inputComponent[propName];
    if (matchesType && value != null) {
        input.setAttribute(attributeName, `${value}`);
    }
    else {
        // we remove the attribute to ensure validation-constraints are properly reset
        input.removeAttribute(attributeName);
    }
}
/**
 * Synchronizes the hidden form input with the validation-related input properties.
 *
 * Note: loss of precision is expected due to the hidden input's value and validation-constraint props being strings.
 *
 * @param type - The input type.
 * @param inputComponent
 * @param hiddenFormInput
 */
function syncHiddenFormInput(type, inputComponent, hiddenFormInput) {
    hiddenFormInput.type = type === "textarea" ? "text" : type;
    const isMinMaxStepType = minMaxStepTypes.includes(type);
    const numericInputComponent = inputComponent;
    updateConstraintValidation(numericInputComponent, hiddenFormInput, "min", isMinMaxStepType);
    updateConstraintValidation(numericInputComponent, hiddenFormInput, "max", isMinMaxStepType);
    updateConstraintValidation(numericInputComponent, hiddenFormInput, "step", isMinMaxStepType);
    const isMinMaxLengthType = minMaxLengthTypes.includes(type);
    const textualInputComponent = inputComponent;
    updateConstraintValidation(textualInputComponent, hiddenFormInput, "minLength", isMinMaxLengthType);
    updateConstraintValidation(textualInputComponent, hiddenFormInput, "maxLength", isMinMaxLengthType);
    const isPatternType = patternTypes.includes(type);
    updateConstraintValidation(textualInputComponent, hiddenFormInput, "pattern", isPatternType);
}

const inputCss = "/*!@:host([disabled])*/[disabled].sc-calcite-input-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-input-h *.sc-calcite-input,.sc-calcite-input-h[disabled].sc-calcite-input-s>*,.sc-calcite-input-h[disabled] .sc-calcite-input-s>*{pointer-events:none}/*!@:host*/.sc-calcite-input-h{display:block}/*!@:host([scale=s]) input, :host([scale=s]) .prefix, :host([scale=s]) .suffix*/[scale=s].sc-calcite-input-h input.sc-calcite-input,[scale=s].sc-calcite-input-h .prefix.sc-calcite-input,[scale=s].sc-calcite-input-h .suffix.sc-calcite-input{block-size:1.5rem;padding-inline:0.5rem;font-size:var(--calcite-font-size--2);line-height:1rem}/*!@:host([scale=s]) textarea*/[scale=s].sc-calcite-input-h textarea.sc-calcite-input{block-size:1.5rem;min-block-size:1.5rem}/*!@:host([scale=s]) .number-button-wrapper, :host([scale=s]) .action-wrapper calcite-button, :host([scale=s]) .action-wrapper calcite-button button*/[scale=s].sc-calcite-input-h .number-button-wrapper.sc-calcite-input,[scale=s].sc-calcite-input-h .action-wrapper.sc-calcite-input calcite-button.sc-calcite-input,[scale=s].sc-calcite-input-h .action-wrapper.sc-calcite-input calcite-button.sc-calcite-input button.sc-calcite-input{block-size:1.5rem}/*!@:host([scale=s]) input[type=file]*/[scale=s].sc-calcite-input-h input[type=file].sc-calcite-input{block-size:1.5rem}/*!@:host([scale=s]) .clear-button*/[scale=s].sc-calcite-input-h .clear-button.sc-calcite-input{min-block-size:1.5rem;min-inline-size:1.5rem}/*!@:host([scale=s]) textarea*/[scale=s].sc-calcite-input-h textarea.sc-calcite-input{block-size:auto;padding-block:0.25rem;padding-inline:0.5rem;font-size:var(--calcite-font-size--2);line-height:1rem}/*!@:host([scale=m]) input, :host([scale=m]) .prefix, :host([scale=m]) .suffix*/[scale=m].sc-calcite-input-h input.sc-calcite-input,[scale=m].sc-calcite-input-h .prefix.sc-calcite-input,[scale=m].sc-calcite-input-h .suffix.sc-calcite-input{block-size:2rem;padding-inline:0.75rem;font-size:var(--calcite-font-size--1);line-height:1rem}/*!@:host([scale=m]) textarea*/[scale=m].sc-calcite-input-h textarea.sc-calcite-input{min-block-size:2rem}/*!@:host([scale=m]) .number-button-wrapper, :host([scale=m]) .action-wrapper calcite-button, :host([scale=m]) .action-wrapper calcite-button button*/[scale=m].sc-calcite-input-h .number-button-wrapper.sc-calcite-input,[scale=m].sc-calcite-input-h .action-wrapper.sc-calcite-input calcite-button.sc-calcite-input,[scale=m].sc-calcite-input-h .action-wrapper.sc-calcite-input calcite-button.sc-calcite-input button.sc-calcite-input{block-size:2rem}/*!@:host([scale=m]) input[type=file]*/[scale=m].sc-calcite-input-h input[type=file].sc-calcite-input{block-size:2rem}/*!@:host([scale=m]) .clear-button*/[scale=m].sc-calcite-input-h .clear-button.sc-calcite-input{min-block-size:2rem;min-inline-size:2rem}/*!@:host([scale=m]) textarea*/[scale=m].sc-calcite-input-h textarea.sc-calcite-input{block-size:auto;padding-block:0.5rem;padding-inline:0.75rem;font-size:var(--calcite-font-size--1);line-height:1rem}/*!@:host([scale=l]) input, :host([scale=l]) .prefix, :host([scale=l]) .suffix*/[scale=l].sc-calcite-input-h input.sc-calcite-input,[scale=l].sc-calcite-input-h .prefix.sc-calcite-input,[scale=l].sc-calcite-input-h .suffix.sc-calcite-input{block-size:2.75rem;padding-inline:1rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host([scale=l]) textarea*/[scale=l].sc-calcite-input-h textarea.sc-calcite-input{min-block-size:2.75rem}/*!@:host([scale=l]) .number-button-wrapper, :host([scale=l]) .action-wrapper calcite-button, :host([scale=l]) .action-wrapper calcite-button button*/[scale=l].sc-calcite-input-h .number-button-wrapper.sc-calcite-input,[scale=l].sc-calcite-input-h .action-wrapper.sc-calcite-input calcite-button.sc-calcite-input,[scale=l].sc-calcite-input-h .action-wrapper.sc-calcite-input calcite-button.sc-calcite-input button.sc-calcite-input{block-size:2.75rem}/*!@:host([scale=l]) input[type=file]*/[scale=l].sc-calcite-input-h input[type=file].sc-calcite-input{block-size:2.75rem}/*!@:host([scale=l]) .clear-button*/[scale=l].sc-calcite-input-h .clear-button.sc-calcite-input{min-block-size:2.75rem;min-inline-size:2.75rem}/*!@:host([scale=l]) textarea*/[scale=l].sc-calcite-input-h textarea.sc-calcite-input{block-size:auto;padding-block:0.75rem;padding-inline:1rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host([disabled]) textarea*/[disabled].sc-calcite-input-h textarea.sc-calcite-input{resize:none}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-input-h[disabled] .sc-calcite-input-s>[calcite-hydrated][disabled],[disabled].sc-calcite-input-h [calcite-hydrated][disabled].sc-calcite-input{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-input{display:contents}/*!@textarea,\ninput*/textarea.sc-calcite-input,input.sc-calcite-input{transition:var(--calcite-animation-timing), block-size 0, outline-offset 0s;-webkit-appearance:none;position:relative;margin:0px;box-sizing:border-box;display:flex;max-block-size:100%;inline-size:100%;max-inline-size:100%;flex:1 1 0%;border-radius:0px;background-color:var(--calcite-color-foreground-1);font-family:inherit;font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-1)}/*!@input[type=search]::-webkit-search-decoration*/input[type=search].sc-calcite-input::-webkit-search-decoration{-webkit-appearance:none}/*!@input,\ntextarea*/input.sc-calcite-input,textarea.sc-calcite-input{text-overflow:ellipsis;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);color:var(--calcite-color-text-1)}/*!@input:placeholder-shown,\ntextarea:placeholder-shown*/input.sc-calcite-input:placeholder-shown,textarea.sc-calcite-input:placeholder-shown{text-overflow:ellipsis}/*!@input:focus,\ntextarea:focus*/input.sc-calcite-input:focus,textarea.sc-calcite-input:focus{border-color:var(--calcite-color-brand);color:var(--calcite-color-text-1)}/*!@input[readonly],\ntextarea[readonly]*/input[readonly].sc-calcite-input,textarea[readonly].sc-calcite-input{background-color:var(--calcite-color-background);font-weight:var(--calcite-font-weight-medium)}/*!@input[readonly]:focus,\ntextarea[readonly]:focus*/input[readonly].sc-calcite-input:focus,textarea[readonly].sc-calcite-input:focus{color:var(--calcite-color-text-1)}/*!@calcite-icon*/calcite-icon.sc-calcite-input{color:var(--calcite-color-text-3)}/*!@textarea,\ninput*/textarea.sc-calcite-input,input.sc-calcite-input{outline-color:transparent}/*!@textarea:focus,\ninput:focus*/textarea.sc-calcite-input:focus,input.sc-calcite-input:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([status=invalid]) input, :host([status=invalid]) textarea*/[status=invalid].sc-calcite-input-h input.sc-calcite-input,[status=invalid].sc-calcite-input-h textarea.sc-calcite-input{border-color:var(--calcite-color-status-danger)}/*!@:host([status=invalid]) input:focus, :host([status=invalid]) textarea:focus*/[status=invalid].sc-calcite-input-h input.sc-calcite-input:focus,[status=invalid].sc-calcite-input-h textarea.sc-calcite-input:focus{outline:2px solid var(--calcite-color-status-danger);outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([scale=s]) .icon*/[scale=s].sc-calcite-input-h .icon.sc-calcite-input{inset-inline-start:0.5rem}/*!@:host([scale=m]) .icon*/[scale=m].sc-calcite-input-h .icon.sc-calcite-input{inset-inline-start:0.75rem}/*!@:host([scale=l]) .icon*/[scale=l].sc-calcite-input-h .icon.sc-calcite-input{inset-inline-start:1rem}/*!@:host([icon][scale=s]) input*/[icon][scale=s].sc-calcite-input-h input.sc-calcite-input{padding-inline-start:2rem}/*!@:host([icon][scale=m]) input*/[icon][scale=m].sc-calcite-input-h input.sc-calcite-input{padding-inline-start:2.5rem}/*!@:host([icon][scale=l]) input*/[icon][scale=l].sc-calcite-input-h input.sc-calcite-input{padding-inline-start:3.5rem}/*!@.element-wrapper*/.element-wrapper.sc-calcite-input{position:relative;order:3;display:inline-flex;flex:1 1 0%;align-items:center}/*!@.icon*/.icon.sc-calcite-input{pointer-events:none;position:absolute;display:block;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.icon,\n.resize-icon-wrapper*/.icon.sc-calcite-input,.resize-icon-wrapper.sc-calcite-input{z-index:var(--calcite-z-index)}/*!@input[type=text]::-ms-clear,\ninput[type=text]::-ms-reveal*/input[type=text].sc-calcite-input::-ms-clear,input[type=text].sc-calcite-input::-ms-reveal{display:none;block-size:0px;inline-size:0px}/*!@input[type=search]::-webkit-search-decoration,\ninput[type=search]::-webkit-search-cancel-button,\ninput[type=search]::-webkit-search-results-button,\ninput[type=search]::-webkit-search-results-decoration,\ninput[type=date]::-webkit-clear-button,\ninput[type=time]::-webkit-clear-button*/input[type=search].sc-calcite-input::-webkit-search-decoration,input[type=search].sc-calcite-input::-webkit-search-cancel-button,input[type=search].sc-calcite-input::-webkit-search-results-button,input[type=search].sc-calcite-input::-webkit-search-results-decoration,input[type=date].sc-calcite-input::-webkit-clear-button,input[type=time].sc-calcite-input::-webkit-clear-button{display:none}/*!@.clear-button*/.clear-button.sc-calcite-input{pointer-events:initial;order:4;margin:0px;box-sizing:border-box;display:flex;min-block-size:100%;cursor:pointer;align-items:center;justify-content:center;align-self:stretch;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-foreground-1);outline-color:transparent;border-inline-start-width:0px}/*!@.clear-button:hover*/.clear-button.sc-calcite-input:hover{background-color:var(--calcite-color-foreground-2);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.clear-button:hover calcite-icon*/.clear-button.sc-calcite-input:hover calcite-icon.sc-calcite-input{color:var(--calcite-color-text-1);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.clear-button:active*/.clear-button.sc-calcite-input:active{background-color:var(--calcite-color-foreground-3)}/*!@.clear-button:active calcite-icon*/.clear-button.sc-calcite-input:active calcite-icon.sc-calcite-input{color:var(--calcite-color-text-1)}/*!@.clear-button:focus*/.clear-button.sc-calcite-input:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.clear-button:disabled*/.clear-button.sc-calcite-input:disabled{opacity:var(--calcite-opacity-disabled)}/*!@.loader*/.loader.sc-calcite-input{inset-block-start:1px;inset-inline:1px;pointer-events:none;position:absolute;display:block}/*!@.action-wrapper*/.action-wrapper.sc-calcite-input{order:7;display:flex}/*!@.prefix,\n.suffix*/.prefix.sc-calcite-input,.suffix.sc-calcite-input{box-sizing:border-box;display:flex;block-size:auto;min-block-size:100%;-webkit-user-select:none;user-select:none;align-content:center;align-items:center;overflow-wrap:break-word;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-background);font-weight:var(--calcite-font-weight-medium);line-height:1;color:var(--calcite-color-text-2)}/*!@.prefix*/.prefix.sc-calcite-input{order:2;border-inline-end-width:0px}/*!@.suffix*/.suffix.sc-calcite-input{order:5;border-inline-start-width:0px}/*!@:host([alignment=start]) textarea, :host([alignment=start]) input*/[alignment=start].sc-calcite-input-h textarea.sc-calcite-input,[alignment=start].sc-calcite-input-h input.sc-calcite-input{text-align:start}/*!@:host([alignment=end]) textarea, :host([alignment=end]) input*/[alignment=end].sc-calcite-input-h textarea.sc-calcite-input,[alignment=end].sc-calcite-input-h input.sc-calcite-input{text-align:end}/*!@input[type=number]*/input[type=number].sc-calcite-input{-moz-appearance:textfield}/*!@input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button*/input[type=number].sc-calcite-input::-webkit-inner-spin-button,input[type=number].sc-calcite-input::-webkit-outer-spin-button{-webkit-appearance:none;-moz-appearance:textfield;margin:0px}/*!@.number-button-wrapper*/.number-button-wrapper.sc-calcite-input{pointer-events:none;order:6;box-sizing:border-box;display:flex;flex-direction:column;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@:host([number-button-type=vertical]) .wrapper*/[number-button-type=vertical].sc-calcite-input-h .wrapper.sc-calcite-input{flex-direction:row;display:flex}/*!@:host([number-button-type=vertical]) input,\n:host([number-button-type=vertical]) textarea*/[number-button-type=vertical].sc-calcite-input-h input.sc-calcite-input,[number-button-type=vertical].sc-calcite-input-h textarea.sc-calcite-input{order:2}/*!@:host([number-button-type=horizontal]) .calcite--rtl .number-button-item[data-adjustment=down] calcite-icon*/[number-button-type=horizontal].sc-calcite-input-h .calcite--rtl.sc-calcite-input .number-button-item[data-adjustment=down].sc-calcite-input calcite-icon.sc-calcite-input{transform:rotate(-90deg)}/*!@:host([number-button-type=horizontal]) .calcite--rtl .number-button-item[data-adjustment=up] calcite-icon*/[number-button-type=horizontal].sc-calcite-input-h .calcite--rtl.sc-calcite-input .number-button-item[data-adjustment=up].sc-calcite-input calcite-icon.sc-calcite-input{transform:rotate(-90deg)}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=down], .number-button-item.number-button-item--horizontal[data-adjustment=up]*/.number-button-item.number-button-item--horizontal[data-adjustment=down].sc-calcite-input,.number-button-item.number-button-item--horizontal[data-adjustment=up].sc-calcite-input{order:1;max-block-size:100%;min-block-size:100%;align-self:stretch}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=down] calcite-icon, .number-button-item.number-button-item--horizontal[data-adjustment=up] calcite-icon*/.number-button-item.number-button-item--horizontal[data-adjustment=down].sc-calcite-input calcite-icon.sc-calcite-input,.number-button-item.number-button-item--horizontal[data-adjustment=up].sc-calcite-input calcite-icon.sc-calcite-input{transform:rotate(90deg)}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=down]*/.number-button-item.number-button-item--horizontal[data-adjustment=down].sc-calcite-input{border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);border-inline-end-width:0px}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=down]:hover*/.number-button-item.number-button-item--horizontal[data-adjustment=down].sc-calcite-input:hover{background-color:var(--calcite-color-foreground-2)}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=down]:hover calcite-icon*/.number-button-item.number-button-item--horizontal[data-adjustment=down].sc-calcite-input:hover calcite-icon.sc-calcite-input{color:var(--calcite-color-text-1)}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=up]*/.number-button-item.number-button-item--horizontal[data-adjustment=up].sc-calcite-input{order:5}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=up]:hover*/.number-button-item.number-button-item--horizontal[data-adjustment=up].sc-calcite-input:hover{background-color:var(--calcite-color-foreground-2)}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=up]:hover calcite-icon*/.number-button-item.number-button-item--horizontal[data-adjustment=up].sc-calcite-input:hover calcite-icon.sc-calcite-input{color:var(--calcite-color-text-1)}/*!@:host([number-button-type=vertical]) .number-button-item[data-adjustment=down]:hover*/[number-button-type=vertical].sc-calcite-input-h .number-button-item[data-adjustment=down].sc-calcite-input:hover{background-color:var(--calcite-color-foreground-2)}/*!@:host([number-button-type=vertical]) .number-button-item[data-adjustment=down]:hover calcite-icon*/[number-button-type=vertical].sc-calcite-input-h .number-button-item[data-adjustment=down].sc-calcite-input:hover calcite-icon.sc-calcite-input{color:var(--calcite-color-text-1)}/*!@:host([number-button-type=vertical]) .number-button-item[data-adjustment=up]:hover*/[number-button-type=vertical].sc-calcite-input-h .number-button-item[data-adjustment=up].sc-calcite-input:hover{background-color:var(--calcite-color-foreground-2)}/*!@:host([number-button-type=vertical]) .number-button-item[data-adjustment=up]:hover calcite-icon*/[number-button-type=vertical].sc-calcite-input-h .number-button-item[data-adjustment=up].sc-calcite-input:hover calcite-icon.sc-calcite-input{color:var(--calcite-color-text-1)}/*!@:host([number-button-type=vertical]) .number-button-item[data-adjustment=down]*/[number-button-type=vertical].sc-calcite-input-h .number-button-item[data-adjustment=down].sc-calcite-input{border-block-start-width:0px}/*!@.number-button-item*/.number-button-item.sc-calcite-input{max-block-size:50%;min-block-size:50%;pointer-events:initial;margin:0px;box-sizing:border-box;display:flex;cursor:pointer;align-items:center;align-self:center;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-foreground-1);padding-block:0px;padding-inline:0.5rem;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;border-inline-start-width:0px}/*!@.number-button-item calcite-icon*/.number-button-item.sc-calcite-input calcite-icon.sc-calcite-input{pointer-events:none;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.number-button-item:focus*/.number-button-item.sc-calcite-input:focus{background-color:var(--calcite-color-foreground-2)}/*!@.number-button-item:focus calcite-icon*/.number-button-item.sc-calcite-input:focus calcite-icon.sc-calcite-input{color:var(--calcite-color-text-1)}/*!@.number-button-item:active*/.number-button-item.sc-calcite-input:active{background-color:var(--calcite-color-foreground-3)}/*!@.number-button-item:disabled*/.number-button-item.sc-calcite-input:disabled{pointer-events:none}/*!@.wrapper*/.wrapper.sc-calcite-input{position:relative;display:flex;flex-direction:row;align-items:center}/*!@:input::-webkit-calendar-picker-indicator*/.sc-calcite-input:input::-webkit-calendar-picker-indicator{display:none}/*!@input[type=date]::-webkit-input-placeholder*/input[type=date].sc-calcite-input::-webkit-input-placeholder{visibility:hidden !important}/*!@textarea::-webkit-resizer*/textarea.sc-calcite-input::-webkit-resizer{position:absolute;inset-block-end:0px;box-sizing:border-box;padding-block:0px;padding-inline:0.25rem;inset-inline-end:0}/*!@.resize-icon-wrapper*/.resize-icon-wrapper.sc-calcite-input{inset-block-end:2px;inset-inline-end:2px;pointer-events:none;position:absolute;block-size:0.75rem;inline-size:0.75rem;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-3)}/*!@.resize-icon-wrapper calcite-icon*/.resize-icon-wrapper.sc-calcite-input calcite-icon.sc-calcite-input{inset-block-end:0.25rem;inset-inline-end:0.25rem;transform:rotate(-45deg)}/*!@.calcite--rtl .resize-icon-wrapper calcite-icon*/.calcite--rtl.sc-calcite-input .resize-icon-wrapper.sc-calcite-input calcite-icon.sc-calcite-input{transform:rotate(45deg)}/*!@:host([type=color]) input*/[type=color].sc-calcite-input-h input.sc-calcite-input{padding:0.25rem}/*!@:host([type=file]) input*/[type=file].sc-calcite-input-h input.sc-calcite-input{cursor:pointer;border-width:1px;border-style:dashed;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-foreground-1);text-align:center}/*!@:host([type=file][scale=s]) input*/[type=file][scale=s].sc-calcite-input-h input.sc-calcite-input{padding-block:1px;padding-inline:0.5rem}/*!@:host([type=file][scale=m]) input*/[type=file][scale=m].sc-calcite-input-h input.sc-calcite-input{padding-block:0.25rem;padding-inline:0.75rem}/*!@:host([type=file][scale=l]) input*/[type=file][scale=l].sc-calcite-input-h input.sc-calcite-input{padding-block:0.5rem;padding-inline:1rem}/*!@:host(.no-bottom-border) input*/.no-bottom-border.sc-calcite-input-h input.sc-calcite-input{border-block-end-width:0px}/*!@:host(.border-top-color-one) input*/.border-top-color-one.sc-calcite-input-h input.sc-calcite-input{border-block-start-color:var(--calcite-color-border-1)}/*!@input.inline-child*/input.inline-child.sc-calcite-input{background-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@input.inline-child .editing-enabled*/input.inline-child.sc-calcite-input .editing-enabled.sc-calcite-input{background-color:inherit}/*!@input.inline-child:not(.editing-enabled)*/input.inline-child.sc-calcite-input:not(.editing-enabled){display:flex;cursor:pointer;text-overflow:ellipsis;border-color:transparent;padding-inline-start:0}/*!@.validation-container*/.validation-container.sc-calcite-input{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}/*!@:host([scale=m]) .validation-container,\n:host([scale=l]) .validation-container*/[scale=m].sc-calcite-input-h .validation-container.sc-calcite-input,[scale=l].sc-calcite-input-h .validation-container.sc-calcite-input{padding-block-start:0.5rem}/*!@:host([scale=s]) .validation-container*/[scale=s].sc-calcite-input-h .validation-container.sc-calcite-input{padding-block-start:0.25rem}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-input-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([hidden])*/[hidden].sc-calcite-input-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-input{display:none}";

/**
 * @slot action - A slot for positioning a `calcite-button` next to the component.
 */
class Input {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalInputFocus = createEvent(this, "calciteInternalInputFocus", 6);
        this.calciteInternalInputBlur = createEvent(this, "calciteInternalInputBlur", 6);
        this.calciteInputInput = createEvent(this, "calciteInputInput", 7);
        this.calciteInputChange = createEvent(this, "calciteInputChange", 6);
        /** keep track of the rendered child type */
        this.childElType = "input";
        this.previousValueOrigin = "initial";
        this.mutationObserver = createObserver();
        this.userChangedValue = false;
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.keyDownHandler = (event) => {
            if (this.readOnly || this.disabled) {
                return;
            }
            if (this.isClearable && event.key === "Escape") {
                this.clearInputValue(event);
                event.preventDefault();
            }
            if (event.key === "Enter" && !event.defaultPrevented) {
                if (submitForm(this)) {
                    event.preventDefault();
                }
            }
        };
        this.clearInputValue = (nativeEvent) => {
            this.setValue({
                committing: true,
                nativeEvent,
                origin: "user",
                value: "",
            });
        };
        this.emitChangeIfUserModified = () => {
            if (this.previousValueOrigin === "user" && this.value !== this.previousEmittedValue) {
                this.calciteInputChange.emit();
                this.setPreviousEmittedValue(this.value);
            }
        };
        this.inputBlurHandler = () => {
            window.clearInterval(this.nudgeNumberValueIntervalId);
            this.calciteInternalInputBlur.emit();
            this.emitChangeIfUserModified();
        };
        this.clickHandler = (event) => {
            if (this.disabled) {
                return;
            }
            const slottedActionEl = getSlotted(this.el, "action");
            if (event.target !== slottedActionEl) {
                this.setFocus();
            }
        };
        this.inputFocusHandler = () => {
            this.calciteInternalInputFocus.emit();
        };
        this.inputChangeHandler = () => {
            if (this.type === "file") {
                this.files = this.childEl.files;
            }
        };
        this.inputInputHandler = (nativeEvent) => {
            if (this.disabled || this.readOnly) {
                return;
            }
            this.setValue({
                nativeEvent,
                origin: "user",
                value: nativeEvent.target.value,
            });
        };
        this.inputKeyDownHandler = (event) => {
            if (this.disabled || this.readOnly) {
                return;
            }
            if (event.key === "Enter") {
                this.emitChangeIfUserModified();
            }
        };
        this.inputNumberInputHandler = (nativeEvent) => {
            if (this.disabled || this.readOnly) {
                return;
            }
            if (this.value === "Infinity" || this.value === "-Infinity") {
                return;
            }
            const value = nativeEvent.target.value;
            numberStringFormatter.numberFormatOptions = {
                locale: this.effectiveLocale,
                numberingSystem: this.numberingSystem,
                useGrouping: this.groupSeparator,
            };
            const delocalizedValue = numberStringFormatter.delocalize(value);
            if (nativeEvent.inputType === "insertFromPaste") {
                if (!isValidNumber(delocalizedValue)) {
                    nativeEvent.preventDefault();
                }
                this.setValue({
                    nativeEvent,
                    origin: "user",
                    value: parseNumberString(delocalizedValue),
                });
                this.childNumberEl.value = this.displayedValue;
            }
            else {
                this.setValue({
                    nativeEvent,
                    origin: "user",
                    value: delocalizedValue,
                });
            }
        };
        this.inputNumberKeyDownHandler = (event) => {
            if (this.type !== "number" || this.disabled || this.readOnly) {
                return;
            }
            if (this.value === "Infinity" || this.value === "-Infinity") {
                event.preventDefault();
                if (event.key === "Backspace" || event.key === "Delete") {
                    this.clearInputValue(event);
                }
                return;
            }
            if (event.key === "ArrowUp") {
                /* prevent default behavior of moving cursor to the beginning of the input when holding down ArrowUp */
                event.preventDefault();
                this.nudgeNumberValue("up", event);
                return;
            }
            if (event.key === "ArrowDown") {
                this.nudgeNumberValue("down", event);
                return;
            }
            const supportedKeys = [
                ...numberKeys,
                "ArrowLeft",
                "ArrowRight",
                "Backspace",
                "Delete",
                "Enter",
                "Escape",
                "Tab",
            ];
            if (event.altKey || event.ctrlKey || event.metaKey) {
                return;
            }
            const isShiftTabEvent = event.shiftKey && event.key === "Tab";
            if (supportedKeys.includes(event.key) || isShiftTabEvent) {
                if (event.key === "Enter") {
                    this.emitChangeIfUserModified();
                }
                return;
            }
            numberStringFormatter.numberFormatOptions = {
                locale: this.effectiveLocale,
                numberingSystem: this.numberingSystem,
                useGrouping: this.groupSeparator,
            };
            if (event.key === numberStringFormatter.decimal) {
                if (!this.value && !this.childNumberEl.value) {
                    return;
                }
                if (this.value && this.childNumberEl.value.indexOf(numberStringFormatter.decimal) === -1) {
                    return;
                }
            }
            if (/[eE]/.test(event.key)) {
                if (!this.value && !this.childNumberEl.value) {
                    return;
                }
                if (this.value && !/[eE]/.test(this.childNumberEl.value)) {
                    return;
                }
            }
            if (event.key === "-") {
                if (!this.value && !this.childNumberEl.value) {
                    return;
                }
                if (this.value && this.childNumberEl.value.split("-").length <= 2) {
                    return;
                }
            }
            event.preventDefault();
        };
        this.nudgeNumberValue = (direction, nativeEvent) => {
            if ((nativeEvent instanceof KeyboardEvent && nativeEvent.repeat) || this.type !== "number") {
                return;
            }
            const inputMax = this.maxString ? parseFloat(this.maxString) : null;
            const inputMin = this.minString ? parseFloat(this.minString) : null;
            const valueNudgeDelayInMs = 150;
            this.incrementOrDecrementNumberValue(direction, inputMax, inputMin, nativeEvent);
            if (this.nudgeNumberValueIntervalId) {
                window.clearInterval(this.nudgeNumberValueIntervalId);
            }
            let firstValueNudge = true;
            this.nudgeNumberValueIntervalId = window.setInterval(() => {
                if (firstValueNudge) {
                    firstValueNudge = false;
                    return;
                }
                this.incrementOrDecrementNumberValue(direction, inputMax, inputMin, nativeEvent);
            }, valueNudgeDelayInMs);
        };
        this.numberButtonPointerUpAndOutHandler = () => {
            window.clearInterval(this.nudgeNumberValueIntervalId);
        };
        this.numberButtonPointerDownHandler = (event) => {
            if (!isPrimaryPointerButton(event)) {
                return;
            }
            event.preventDefault();
            const direction = event.target.dataset.adjustment;
            if (!this.disabled) {
                this.nudgeNumberValue(direction, event);
            }
        };
        this.onHiddenFormInputInput = (event) => {
            if (event.target.name === this.name) {
                this.setValue({
                    value: event.target.value,
                    origin: "direct",
                });
            }
            this.setFocus();
            event.stopPropagation();
        };
        this.setChildElRef = (el) => {
            this.childEl = el;
        };
        this.setChildNumberElRef = (el) => {
            this.childNumberEl = el;
        };
        this.setInputValue = (newInputValue) => {
            if (this.type === "text" && !this.childEl) {
                return;
            }
            if (this.type === "number" && !this.childNumberEl) {
                return;
            }
            this[`child${this.type === "number" ? "Number" : ""}El`].value = newInputValue;
        };
        this.setPreviousEmittedValue = (value) => {
            this.previousEmittedValue = this.normalizeValue(value);
        };
        this.setPreviousValue = (value) => {
            this.previousValue = this.normalizeValue(value);
        };
        this.setValue = ({ committing = false, nativeEvent, origin, previousValue, value, }) => {
            this.setPreviousValue(previousValue ?? this.value);
            this.previousValueOrigin = origin;
            if (this.type === "number") {
                numberStringFormatter.numberFormatOptions = {
                    locale: this.effectiveLocale,
                    numberingSystem: this.numberingSystem,
                    useGrouping: this.groupSeparator,
                    signDisplay: "never",
                };
                const isValueDeleted = this.previousValue?.length > value.length || this.value?.length > value.length;
                const hasTrailingDecimalSeparator = value.charAt(value.length - 1) === ".";
                const sanitizedValue = hasTrailingDecimalSeparator && isValueDeleted ? value : sanitizeNumberString(value);
                const newValue = value && !sanitizedValue
                    ? isValidNumber(this.previousValue)
                        ? this.previousValue
                        : ""
                    : sanitizedValue;
                let newLocalizedValue = numberStringFormatter.localize(newValue);
                if (origin !== "connected" && !hasTrailingDecimalSeparator) {
                    newLocalizedValue = addLocalizedTrailingDecimalZeros(newLocalizedValue, newValue, numberStringFormatter);
                }
                // adds localized trailing decimal separator
                this.displayedValue =
                    hasTrailingDecimalSeparator && isValueDeleted
                        ? `${newLocalizedValue}${numberStringFormatter.decimal}`
                        : newLocalizedValue;
                this.userChangedValue = origin === "user" && this.value !== newValue;
                // don't sanitize the start of negative/decimal numbers, but
                // don't set value to an invalid number
                this.value = ["-", "."].includes(newValue) ? "" : newValue;
            }
            else {
                this.userChangedValue = origin === "user" && this.value !== value;
                this.value = value;
            }
            if (origin === "direct") {
                this.setInputValue(value);
                this.previousEmittedValue = value;
            }
            if (nativeEvent) {
                const calciteInputInputEvent = this.calciteInputInput.emit();
                if (calciteInputInputEvent.defaultPrevented) {
                    this.value = this.previousValue;
                    this.displayedValue =
                        this.type === "number"
                            ? numberStringFormatter.localize(this.previousValue)
                            : this.previousValue;
                }
                else if (committing) {
                    this.emitChangeIfUserModified();
                }
            }
        };
        this.inputKeyUpHandler = () => {
            window.clearInterval(this.nudgeNumberValueIntervalId);
        };
        this.alignment = "start";
        this.autofocus = false;
        this.clearable = false;
        this.disabled = false;
        this.form = undefined;
        this.groupSeparator = false;
        this.icon = undefined;
        this.iconFlipRtl = false;
        this.label = undefined;
        this.loading = false;
        this.numberingSystem = undefined;
        this.localeFormat = false;
        this.max = undefined;
        this.min = undefined;
        this.maxLength = undefined;
        this.minLength = undefined;
        this.validationMessage = undefined;
        this.validationIcon = undefined;
        this.name = undefined;
        this.numberButtonType = "vertical";
        this.placeholder = undefined;
        this.prefixText = undefined;
        this.readOnly = false;
        this.required = false;
        this.scale = "m";
        this.status = "idle";
        this.step = undefined;
        this.autocomplete = undefined;
        this.pattern = undefined;
        this.accept = undefined;
        this.multiple = false;
        this.inputMode = "text";
        this.enterKeyHint = undefined;
        this.suffixText = undefined;
        this.editingEnabled = false;
        this.type = "text";
        this.value = "";
        this.files = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
        this.displayedValue = undefined;
        this.slottedActionElDisabledInternally = false;
    }
    disabledWatcher() {
        this.setDisabledAction();
    }
    /** watcher to update number-to-string for max */
    maxWatcher() {
        this.maxString = this.max?.toString() || null;
    }
    /** watcher to update number-to-string for min */
    minWatcher() {
        this.minString = this.min?.toString() || null;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    valueWatcher(newValue, previousValue) {
        if (!this.userChangedValue) {
            if (this.type === "number" && (newValue === "Infinity" || newValue === "-Infinity")) {
                this.displayedValue = newValue;
                this.previousEmittedValue = newValue;
                return;
            }
            this.setValue({
                origin: "direct",
                previousValue,
                value: newValue == null || newValue == ""
                    ? ""
                    : this.type === "number"
                        ? isValidNumber(newValue)
                            ? newValue
                            : this.previousValue || ""
                        : newValue,
            });
            this.warnAboutInvalidNumberValue(newValue);
        }
        this.userChangedValue = false;
    }
    updateRequestedIcon() {
        this.requestedIcon = setRequestedIcon(INPUT_TYPE_ICONS, this.icon, this.type);
    }
    get isClearable() {
        return !this.isTextarea && (this.clearable || this.type === "search") && this.value?.length > 0;
    }
    get isTextarea() {
        return this.childElType === "textarea";
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
        this.inlineEditableEl = this.el.closest("calcite-inline-editable");
        if (this.inlineEditableEl) {
            this.editingEnabled = this.inlineEditableEl.editingEnabled || false;
        }
        connectLabel(this);
        connectForm(this);
        this.setPreviousEmittedValue(this.value);
        this.setPreviousValue(this.value);
        if (this.type === "number") {
            if (this.value === "Infinity" || this.value === "-Infinity") {
                this.displayedValue = this.value;
                this.previousEmittedValue = this.value;
            }
            else {
                this.warnAboutInvalidNumberValue(this.value);
                this.setValue({
                    origin: "connected",
                    value: isValidNumber(this.value) ? this.value : "",
                });
            }
        }
        this.mutationObserver?.observe(this.el, { childList: true });
        this.setDisabledAction();
        this.el.addEventListener(internalHiddenInputInputEvent, this.onHiddenFormInputInput);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        this.mutationObserver?.disconnect();
        this.el.removeEventListener(internalHiddenInputInputEvent, this.onHiddenFormInputInput);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        this.childElType = this.type === "textarea" ? "textarea" : "input";
        this.maxString = this.max?.toString();
        this.minString = this.min?.toString();
        this.requestedIcon = setRequestedIcon(INPUT_TYPE_ICONS, this.icon, this.type);
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentShouldUpdate(newValue, oldValue, property) {
        if (this.type === "number" && property === "value" && newValue && !isValidNumber(newValue)) {
            this.setValue({
                origin: "reset",
                value: oldValue,
            });
            return false;
        }
        return true;
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        if (this.type === "number") {
            this.childNumberEl?.focus();
        }
        else {
            this.childEl?.focus();
        }
    }
    /** Selects the text of the component's `value`. */
    async selectText() {
        if (this.type === "number") {
            this.childNumberEl?.select();
        }
        else {
            this.childEl?.select();
        }
    }
    onLabelClick() {
        this.setFocus();
    }
    incrementOrDecrementNumberValue(direction, inputMax, inputMin, nativeEvent) {
        const { value } = this;
        if (value === "Infinity" || value === "-Infinity") {
            return;
        }
        const adjustment = direction === "up" ? 1 : -1;
        const inputStep = this.step === "any" ? 1 : Math.abs(this.step || 1);
        const inputVal = new BigDecimal(value !== "" ? value : "0");
        const nudgedValue = inputVal.add(`${inputStep * adjustment}`);
        const nudgedValueBelowInputMin = () => typeof inputMin === "number" &&
            !isNaN(inputMin) &&
            nudgedValue.subtract(`${inputMin}`).isNegative;
        const nudgedValueAboveInputMax = () => typeof inputMax === "number" &&
            !isNaN(inputMax) &&
            !nudgedValue.subtract(`${inputMax}`).isNegative;
        const finalValue = nudgedValueBelowInputMin()
            ? `${inputMin}`
            : nudgedValueAboveInputMax()
                ? `${inputMax}`
                : nudgedValue.toString();
        this.setValue({
            committing: true,
            nativeEvent,
            origin: "user",
            value: finalValue,
        });
    }
    syncHiddenFormInput(input) {
        syncHiddenFormInput(this.type, this, input);
    }
    setDisabledAction() {
        const slottedActionEl = getSlotted(this.el, "action");
        if (!slottedActionEl) {
            return;
        }
        if (this.disabled) {
            if (slottedActionEl.getAttribute("disabled") == null) {
                this.slottedActionElDisabledInternally = true;
            }
            slottedActionEl.setAttribute("disabled", "");
        }
        else if (this.slottedActionElDisabledInternally) {
            slottedActionEl.removeAttribute("disabled");
            this.slottedActionElDisabledInternally = false;
        }
    }
    normalizeValue(value) {
        return this.type === "number" ? (isValidNumber(value) ? value : "") : value;
    }
    warnAboutInvalidNumberValue(value) {
        if (this.type === "number" && value && !isValidNumber(value)) {
            console.warn(`The specified value "${value}" cannot be parsed, or is out of range.`);
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const dir = getElementDir(this.el);
        const loader = (hAsync("div", { class: CSS$R.loader }, hAsync("calcite-progress", { label: this.messages.loading, type: "indeterminate" })));
        const inputClearButton = (hAsync("button", { "aria-label": this.messages.clear, class: CSS$R.clearButton, disabled: this.disabled || this.readOnly, onClick: this.clearInputValue, tabIndex: -1, type: "button" }, hAsync("calcite-icon", { icon: "x", scale: getIconScale(this.scale) })));
        const iconEl = (hAsync("calcite-icon", { class: CSS$R.inputIcon, flipRtl: this.iconFlipRtl, icon: this.requestedIcon, scale: getIconScale(this.scale) }));
        const isHorizontalNumberButton = this.numberButtonType === "horizontal";
        const numberButtonsHorizontalUp = (hAsync("button", { "aria-hidden": "true", class: {
                [CSS$R.numberButtonItem]: true,
                [CSS$R.buttonItemHorizontal]: isHorizontalNumberButton,
            }, "data-adjustment": "up", disabled: this.disabled || this.readOnly, onPointerDown: this.numberButtonPointerDownHandler, onPointerOut: this.numberButtonPointerUpAndOutHandler, onPointerUp: this.numberButtonPointerUpAndOutHandler, tabIndex: -1, type: "button" }, hAsync("calcite-icon", { icon: "chevron-up", scale: getIconScale(this.scale) })));
        const numberButtonsHorizontalDown = (hAsync("button", { "aria-hidden": "true", class: {
                [CSS$R.numberButtonItem]: true,
                [CSS$R.buttonItemHorizontal]: isHorizontalNumberButton,
            }, "data-adjustment": "down", disabled: this.disabled || this.readOnly, onPointerDown: this.numberButtonPointerDownHandler, onPointerOut: this.numberButtonPointerUpAndOutHandler, onPointerUp: this.numberButtonPointerUpAndOutHandler, tabIndex: -1, type: "button" }, hAsync("calcite-icon", { icon: "chevron-down", scale: getIconScale(this.scale) })));
        const numberButtonsVertical = (hAsync("div", { class: CSS$R.numberButtonWrapper }, numberButtonsHorizontalUp, numberButtonsHorizontalDown));
        const prefixText = hAsync("div", { class: CSS$R.prefix }, this.prefixText);
        const suffixText = hAsync("div", { class: CSS$R.suffix }, this.suffixText);
        const localeNumberInput = this.type === "number" ? (hAsync("input", { accept: this.accept, "aria-label": getLabelText(this), autocomplete: this.autocomplete, autofocus: this.autofocus ? true : null, defaultValue: this.defaultValue, disabled: this.disabled ? true : null, enterKeyHint: this.enterKeyHint, inputMode: this.inputMode, key: "localized-input", maxLength: this.maxLength, minLength: this.minLength, multiple: this.multiple, name: undefined, onBlur: this.inputBlurHandler, onFocus: this.inputFocusHandler, onInput: this.inputNumberInputHandler, onKeyDown: this.inputNumberKeyDownHandler, onKeyUp: this.inputKeyUpHandler, pattern: this.pattern, placeholder: this.placeholder || "", readOnly: this.readOnly, type: "text", value: this.displayedValue,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setChildNumberElRef })) : null;
        const childEl = this.type !== "number"
            ? [
                hAsync(this.childElType, { accept: this.accept, "aria-label": getLabelText(this), autocomplete: this.autocomplete, autofocus: this.autofocus ? true : null, class: {
                        [CSS$R.editingEnabled]: this.editingEnabled,
                        [CSS$R.inlineChild]: !!this.inlineEditableEl,
                    }, defaultValue: this.defaultValue, disabled: this.disabled ? true : null, enterKeyHint: this.enterKeyHint, inputMode: this.inputMode, max: this.maxString, maxLength: this.maxLength, min: this.minString, minLength: this.minLength, multiple: this.multiple, name: this.name, onBlur: this.inputBlurHandler, onChange: this.inputChangeHandler, onFocus: this.inputFocusHandler, onInput: this.inputInputHandler, onKeyDown: this.inputKeyDownHandler, onKeyUp: this.inputKeyUpHandler, pattern: this.pattern, placeholder: this.placeholder || "", readOnly: this.readOnly, required: this.required ? true : null, step: this.step, tabIndex: this.disabled || (this.inlineEditableEl && !this.editingEnabled) ? -1 : null, type: this.type, value: this.value,
                    // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
                    ref: this.setChildElRef }),
                this.isTextarea ? (hAsync("div", { class: CSS$R.resizeIconWrapper }, hAsync("calcite-icon", { icon: "chevron-down", scale: getIconScale(this.scale) }))) : null,
            ]
            : null;
        return (hAsync(Host, { onClick: this.clickHandler, onKeyDown: this.keyDownHandler }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: { [CSS$R.inputWrapper]: true, [CSS_UTILITY.rtl]: dir === "rtl" } }, this.type === "number" && this.numberButtonType === "horizontal" && !this.readOnly
            ? numberButtonsHorizontalDown
            : null, this.prefixText ? prefixText : null, hAsync("div", { class: CSS$R.wrapper }, localeNumberInput, childEl, this.isClearable ? inputClearButton : null, this.requestedIcon ? iconEl : null, this.loading ? loader : null), hAsync("div", { class: CSS$R.actionWrapper }, hAsync("slot", { name: SLOTS$l.action })), this.type === "number" && this.numberButtonType === "vertical" && !this.readOnly
            ? numberButtonsVertical
            : null, this.suffixText ? suffixText : null, this.type === "number" && this.numberButtonType === "horizontal" && !this.readOnly
            ? numberButtonsHorizontalUp
            : null, hAsync(HiddenFormInputSlot, { component: this })), this.validationMessage && this.status === "invalid" ? (hAsync(Validation, { icon: this.validationIcon, message: this.validationMessage, scale: this.scale, status: this.status })) : null)));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "disabled": ["disabledWatcher"],
        "max": ["maxWatcher"],
        "min": ["minWatcher"],
        "messageOverrides": ["onMessagesChange"],
        "value": ["valueWatcher"],
        "icon": ["updateRequestedIcon"],
        "type": ["updateRequestedIcon"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return inputCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-input",
        "$members$": {
            "alignment": [513],
            "autofocus": [516],
            "clearable": [516],
            "disabled": [516],
            "form": [513],
            "groupSeparator": [516, "group-separator"],
            "icon": [520],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "label": [1],
            "loading": [516],
            "numberingSystem": [513, "numbering-system"],
            "localeFormat": [4, "locale-format"],
            "max": [514],
            "min": [514],
            "maxLength": [514, "max-length"],
            "minLength": [514, "min-length"],
            "validationMessage": [1, "validation-message"],
            "validationIcon": [520, "validation-icon"],
            "name": [513],
            "numberButtonType": [513, "number-button-type"],
            "placeholder": [1],
            "prefixText": [1, "prefix-text"],
            "readOnly": [516, "read-only"],
            "required": [516],
            "scale": [513],
            "status": [513],
            "step": [520],
            "autocomplete": [1],
            "pattern": [1],
            "accept": [1],
            "multiple": [4],
            "inputMode": [1, "input-mode"],
            "enterKeyHint": [1, "enter-key-hint"],
            "suffixText": [1, "suffix-text"],
            "editingEnabled": [1540, "editing-enabled"],
            "type": [513],
            "value": [1025],
            "files": [16],
            "messages": [1040],
            "messageOverrides": [1040],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "displayedValue": [32],
            "slottedActionElDisabledInternally": [32],
            "setFocus": [64],
            "selectText": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["alignment", "alignment"], ["autofocus", "autofocus"], ["clearable", "clearable"], ["disabled", "disabled"], ["form", "form"], ["groupSeparator", "group-separator"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["loading", "loading"], ["numberingSystem", "numbering-system"], ["max", "max"], ["min", "min"], ["maxLength", "max-length"], ["minLength", "min-length"], ["validationIcon", "validation-icon"], ["name", "name"], ["numberButtonType", "number-button-type"], ["readOnly", "read-only"], ["required", "required"], ["scale", "scale"], ["status", "status"], ["step", "step"], ["editingEnabled", "editing-enabled"], ["type", "type"]]
    }; }
}

const CSS$Q = {
    assistiveText: "assistive-text",
    calendarWrapper: "calendar-wrapper",
    calendarWrapperEnd: "calendar-wrapper--end",
    horizontalArrowContainer: "horizontal-arrow-container",
    inputBorderTopColorOne: "border-top-color-one",
    inputContainer: "input-container",
    inputNoBottomBorder: "no-bottom-border",
    inputWrapper: "input-wrapper",
    input: "input",
    menu: "menu-container",
    menuActive: "menu-container--active",
    toggleIcon: "toggle-icon",
    verticalArrowContainer: "vertical-arrow-container",
};

/*!
* focus-trap 7.5.4
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/

function ownKeys$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) {
      _defineProperty$1(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      // move this existing trap to the front of the queue
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var isSelectableInput = function isSelectableInput(node) {
  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
};
var isEscapeEvent = function isEscapeEvent(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;
};
var isTabEvent = function isTabEvent(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;
};

// checks for TAB by default
var isKeyForward = function isKeyForward(e) {
  return isTabEvent(e) && !e.shiftKey;
};

// checks for SHIFT+TAB by default
var isKeyBackward = function isKeyBackward(e) {
  return isTabEvent(e) && e.shiftKey;
};
var delay = function delay(fn) {
  return setTimeout(fn, 0);
};

// Array.find/findIndex() are not supported on IE; this replicates enough
//  of Array.findIndex() for our needs
var findIndex = function findIndex(arr, fn) {
  var idx = -1;
  arr.every(function (value, i) {
    if (fn(value)) {
      idx = i;
      return false; // break
    }

    return true; // next
  });

  return idx;
};

/**
 * Get an option's value when it could be a plain value, or a handler that provides
 *  the value.
 * @param {*} value Option's value to check.
 * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.
 * @returns {*} The `value`, or the handler's returned value.
 */
var valueOrHandler = function valueOrHandler(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === 'function' ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget(event) {
  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the
  //  shadow host. However, event.target.composedPath() will be an array of
  //  nodes "clicked" from inner-most (the actual element inside the shadow) to
  //  outer-most (the host HTML document). If we have access to composedPath(),
  //  then use its first element; otherwise, fall back to event.target (and
  //  this only works for an _open_ shadow DOM; otherwise,
  //  composedPath()[0] === event.target always).
  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;
};

// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this
//  current instance use the same stack if `userOptions.trapStack` isn't specified
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap(elements, userOptions) {
  // SSR: a live trap shouldn't be created in this type of environment so this
  //  should be safe code to execute if the `document` option isn't specified
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2$1({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward: isKeyForward,
    isKeyBackward: isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list

    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: undefined,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: undefined
  };
  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later

  /**
   * Gets a configuration option value.
   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,
   *  value will be taken from this object. Otherwise, value will be taken from base configuration.
   * @param {string} optionName Name of the option whose value is sought.
   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`
   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.
   */
  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };

  /**
   * Finds the index of the container that contains the element.
   * @param {HTMLElement} element
   * @param {Event} [event] If available, and `element` isn't directly found in any container,
   *  the event's composed path is used to see if includes any known trap containers in the
   *  case where the element is inside a Shadow DOM.
   * @returns {number} Index of the container in either `state.containers` or
   *  `state.containerGroups` (the order/length of these lists are the same); -1
   *  if the element isn't found.
   */
  var findContainerIndex = function findContainerIndex(element, event) {
    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;
    // NOTE: search `containerGroups` because it's possible a group contains no tabbable
    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)
    //  and we still need to find the element in there
    return state.containerGroups.findIndex(function (_ref) {
      var container = _ref.container,
        tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || ( // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {
        return node === element;
      });
    });
  };

  /**
   * Gets the node for the given option, which is expected to be an option that
   *  can be either a DOM node, a string that is a selector to get a node, `false`
   *  (if a node is explicitly NOT given), or a function that returns any of these
   *  values.
   * @param {string} optionName
   * @returns {undefined | false | HTMLElement | SVGElement} Returns
   *  `undefined` if the option is not specified; `false` if the option
   *  resolved to `false` (node explicitly not given); otherwise, the resolved
   *  DOM node.
   * @throws {Error} If the option is set, not `false`, and is not, or does not
   *  resolve to a node.
   */
  var getNodeForOption = function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === 'function') {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = undefined; // use default value
    }

    if (!optionValue) {
      if (optionValue === undefined || optionValue === false) {
        return optionValue;
      }
      // else, empty string (invalid), null (invalid), 0 (invalid)

      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point

    if (typeof optionValue === 'string') {
      node = doc.querySelector(optionValue); // resolve to node, or null if fails
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode() {
    var node = getNodeForOption('initialFocus');

    // false explicitly indicates we want no initialFocus at all
    if (node === false) {
      return false;
    }
    if (node === undefined || !isFocusable(node, config.tabbableOptions)) {
      // option not specified nor focusable: use fallback options
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;

        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)
        node = firstTabbableNode || getNodeForOption('fallbackFocus');
      }
    }
    if (!node) {
      throw new Error('Your focus-trap needs to have at least one focusable element');
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes() {
    state.containerGroups = state.containers.map(function (container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);

      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes
      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes
      //  are focusable but not tabbable
      var focusableNodes = focusable(container, config.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;
      var firstDomTabbableNode = focusableNodes.find(function (node) {
        return isTabbable(node);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {
        return isTabbable(node);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function (node) {
        return getTabIndex(node) > 0;
      });
      return {
        container: container,
        tabbableNodes: tabbableNodes,
        focusableNodes: focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound: posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode: firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode: lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode: firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode: lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node);
          if (nodeIdx < 0) {
            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):
            //  since `node` should at least have been focusable, we assume that's the case and mimic
            //  what browsers do, which is set focus to the next node in __document position order__,
            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE
            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to
            //  basic DOM order
            if (forward) {
              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {
                return isTabbable(el);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {
              return isTabbable(el);
            });
          }
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function (group) {
      return group.tabbableNodes.length > 0;
    });

    // throw if no groups have tabbable nodes and we don't have a fallback focus node either
    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option
    ) {
      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');
    }

    // NOTE: Positive tabindexes are only properly supported in single-container traps because
    //  doing it across multiple containers where tabindexes could be all over the place
    //  would require Tabbable to support multiple containers, would require additional
    //  specialized Shadow DOM support, and would require Tabbable's multi-container support
    //  to look at those containers in document position order rather than user-provided
    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on
    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.
    if (state.containerGroups.find(function (g) {
      return g.posTabIndexesFound;
    }) && state.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };

  /**
   * Gets the current activeElement. If it's a web-component and has open shadow-root
   * it will recursively search inside shadow roots for the "true" activeElement.
   *
   * @param {Document | ShadowRoot} el
   *
   * @returns {HTMLElement} The element that currently has the focus
   **/
  var getActiveElement = function getActiveElement(el) {
    var activeElement = el.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var tryFocus = function tryFocus(node) {
    if (node === false) {
      return;
    }
    if (node === getActiveElement(document)) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    // NOTE: focus() API does not trigger focusIn event so set MRU node manually
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {
    var node = getNodeForOption('setReturnFocus', previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };

  /**
   * Finds the next node (in either direction) where focus should move according to a
   *  keyboard focus-in event.
   * @param {Object} params
   * @param {Node} [params.target] Known target __from which__ to navigate, if any.
   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event
   *  will be used to determine the `target`). Ignored if `target` is specified.
   * @param {boolean} [params.isBackward] True if focus should move backward.
   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be
   *  determined given the current state of the trap.
   */
  var findNextNavNode = function findNextNavNode(_ref2) {
    var target = _ref2.target,
      event = _ref2.event,
      _ref2$isBackward = _ref2.isBackward,
      isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
    target = target || getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      // make sure the target is actually contained in a group
      // NOTE: the target may also be the container itself if it's focusable
      //  with tabIndex='-1' and was given initial focus
      var containerIndex = findContainerIndex(target, event);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;
      if (containerIndex < 0) {
        // target not found in any group: quite possible focus has escaped the trap,
        //  so bring it back into...
        if (isBackward) {
          // ...the last node in the last group
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          // ...the first node in the first group
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        // REVERSE

        // is the target the first tabbable node in a group?
        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {
          var firstTabbableNode = _ref3.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          // an exception case where the target is either the container itself, or
          //  a non-tabbable node that was given focus (i.e. tabindex is negative
          //  and user clicked on it or node was programmatically given focus)
          //  and is not followed by any other tabbable node, in which
          //  case, we should handle shift+tab as if focus were on the container's
          //  first tabbable node, and go to the last tabbable node of the LAST group
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          // YES: then shift+tab should go to the last tabbable node in the
          //  previous group (and wrap around to the last tabbable node of
          //  the LAST group if it's the first tabbable node of the FIRST group)
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event)) {
          // user must have customized the nav keys so we have to move focus manually _within_
          //  the active group: do this based on the order determined by tabbable()
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        // FORWARD

        // is the target the last tabbable node in a group?
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref4) {
          var lastTabbableNode = _ref4.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          // an exception case where the target is the container itself, or
          //  a non-tabbable node that was given focus (i.e. tabindex is negative
          //  and user clicked on it or node was programmatically given focus)
          //  and is not followed by any other tabbable node, in which
          //  case, we should handle tab as if focus were on the container's
          //  last tabbable node, and go to the first tabbable node of the FIRST group
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          // YES: then tab should go to the first tabbable node in the next
          //  group (and wrap around to the first tabbable node of the FIRST
          //  group if it's the last tabbable node of the LAST group)
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event)) {
          // user must have customized the nav keys so we have to move focus manually _within_
          //  the active group: do this based on the order determined by tabbable()
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      // no groups available
      // NOTE: the fallbackFocus option does not support returning false to opt-out
      destinationNode = getNodeForOption('fallbackFocus');
    }
    return destinationNode;
  };

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event.
  var checkPointerDown = function checkPointerDown(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      // allow the click since it ocurred inside the trap
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      // immediately deactivate the trap
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config.returnFocusOnDeactivate
      });
      return;
    }

    // This is needed for mobile devices.
    // (If we'll only let `click` events through,
    // then on mobile they will be blocked anyways if `touchstart` is blocked.)
    if (valueOrHandler(config.allowOutsideClick, e)) {
      // allow the click outside the trap to take place
      return;
    }

    // otherwise, prevent the click
    e.preventDefault();
  };

  // In case focus escapes the trap for some strange reason, pull it back in.
  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected
  //  scrolling if the node that got focused was out of view; there's nothing we can do to
  //  prevent that from happening by the time we discover that focus escaped
  var checkFocusIn = function checkFocusIn(event) {
    var target = getActualTarget(event);
    var targetContained = findContainerIndex(target, event) >= 0;

    // In Firefox when you Tab out of an iframe the Document is briefly focused.
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      // escaped! pull it back in to where it just left
      event.stopImmediatePropagation();

      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;
      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward
      //  toward a node with a positive tab index
      var nextNode; // next node to focus, if we find one
      var navAcrossContainers = true;
      if (state.mostRecentlyFocusedNode) {
        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...
          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
          // there MAY not be any tabbable nodes in the container if there are at least 2 containers
          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container
          //  with at least one tabbable node in order to function, so this could be the other container
          //  with nothing tabbable in it)
          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable
            var mruTabIdx = tabbableNodes.findIndex(function (node) {
              return node === state.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config.isKeyForward(state.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
                // else, don't wrap within the container as focus should move to next/previous
                //  container
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
                // else, don't wrap within the container as focus should move to next/previous
                //  container
              }
              // else, don't find in container order without considering direction too
            }
          }
          // else, no tabbable nodes in that container (which means we must have at least one other
          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown
          //  an error the last time updateTabbableNodes() was run): find next node among all known
          //  containers
        } else {
          // check to see if there's at least one tabbable node with a positive tab index inside
          //  the trap because focus seems to escape when navigating backward from a tabbable node
          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with
          //  the greatest positive tab index like it should)
          if (!state.containerGroups.some(function (g) {
            return g.tabbableNodes.some(function (n) {
              return getTabIndex(n) > 0;
            });
          })) {
            // no containers with tabbable nodes with positive tab indexes which means the focus
            //  escaped for some other reason and we should just execute the fallback to the
            //  MRU node or initial focus node, if any
            navAcrossContainers = false;
          }
        }
      } else {
        // no MRU node means we're likely in some initial condition when the trap has just
        //  been activated and initial focus hasn't been given yet, in which case we should
        //  fall through to trying to focus the initial focus node, which is what should
        //  happen below at this point in the logic
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state.mostRecentlyFocusedNode,
          isBackward: config.isKeyBackward(state.recentNavEvent)
        });
      }
      if (nextNode) {
        tryFocus(nextNode);
      } else {
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state.recentNavEvent = undefined; // clear
  };

  // Hijack key nav events on the first and last focusable nodes of the trap,
  // in order to prevent focus from escaping. If it escapes for even a
  // moment it can end up scrolling the page and causing confusion so we
  // kind of need to capture the action at the keydown phase.
  var checkKeyNav = function checkKeyNav(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    state.recentNavEvent = event;
    var destinationNode = findNextNavNode({
      event: event,
      isBackward: isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event)) {
        // since tab natively moves focus, we wouldn't have a destination node unless we
        //  were on the edge of a container and had to move to the next/previous edge, in
        //  which case we want to prevent default to keep the browser from moving focus
        //  to where it normally would
        event.preventDefault();
      }
      tryFocus(destinationNode);
    }
    // else, let the browser take care of [shift+]tab and move the focus
  };

  var checkKey = function checkKey(event) {
    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
      return;
    }
    if (config.isKeyForward(event) || config.isKeyBackward(event)) {
      checkKeyNav(event, config.isKeyBackward(event));
    }
  };
  var checkClick = function checkClick(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };

  //
  // EVENT LISTENERS
  //

  var addListeners = function addListeners() {
    if (!state.active) {
      return;
    }

    // There can be only one listening focus trap at a time
    activeFocusTraps.activateTrap(trapStack, trap);

    // Delay ensures that the focused element doesn't capture the event
    // that caused the focus trap activation.
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener('focusin', checkFocusIn, true);
    doc.addEventListener('mousedown', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('touchstart', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('click', checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener('keydown', checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener('focusin', checkFocusIn, true);
    doc.removeEventListener('mousedown', checkPointerDown, true);
    doc.removeEventListener('touchstart', checkPointerDown, true);
    doc.removeEventListener('click', checkClick, true);
    doc.removeEventListener('keydown', checkKey, true);
    return trap;
  };

  //
  // MUTATION OBSERVER
  //

  var checkDomRemoval = function checkDomRemoval(mutations) {
    var isFocusedNodeRemoved = mutations.some(function (mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function (node) {
        return node === state.mostRecentlyFocusedNode;
      });
    });

    // If the currently focused is removed then browsers will move focus to the
    // <body> element. If this happens, try to move focus back into the trap.
    if (isFocusedNodeRemoved) {
      tryFocus(getInitialFocusNode());
    }
  };

  // Use MutationObserver - if supported - to detect if focused node is removed
  // from the DOM.
  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;
  var updateObservedNodes = function updateObservedNodes() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state.active && !state.paused) {
      state.containers.map(function (container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };

  //
  // TRAP DEFINITION
  //

  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, 'onActivate');
      var onPostActivate = getOption(activateOptions, 'onPostActivate');
      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      onActivate === null || onActivate === void 0 || onActivate();
      var finishActivation = function finishActivation() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 || onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2$1({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer); // noop if undefined
      state.delayInitialFocusTimer = undefined;
      removeListeners();
      state.active = false;
      state.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, 'onDeactivate');
      var onPostDeactivate = getOption(options, 'onPostDeactivate');
      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');
      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation() {
        delay(function () {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (state.paused || !state.active) {
        return this;
      }
      var onPause = getOption(pauseOptions, 'onPause');
      var onPostPause = getOption(pauseOptions, 'onPostPause');
      state.paused = true;
      onPause === null || onPause === void 0 || onPause();
      removeListeners();
      updateObservedNodes();
      onPostPause === null || onPostPause === void 0 || onPostPause();
      return this;
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.paused || !state.active) {
        return this;
      }
      var onUnpause = getOption(unpauseOptions, 'onUnpause');
      var onPostUnpause = getOption(unpauseOptions, 'onPostUnpause');
      state.paused = false;
      onUnpause === null || onUnpause === void 0 || onUnpause();
      updateTabbableNodes();
      addListeners();
      updateObservedNodes();
      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function (element) {
        return typeof element === 'string' ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };

  // initialize container elements
  trap.updateContainerElements(elements);
  return trap;
};

/**
 * This module allows custom configuration for components.
 */
const customConfig = globalThis["calciteConfig"];
const focusTrapStack = customConfig?.focusTrapStack || [];

/**
 * Helper to set up the FocusTrap component.
 *
 * @param {FocusTrapComponent} component The FocusTrap component.
 * @param options
 */
function connectFocusTrap(component, options) {
    const { el } = component;
    const focusTrapNode = options?.focusTrapEl || el;
    if (!focusTrapNode) {
        return;
    }
    const focusTrapOptions = {
        clickOutsideDeactivates: true,
        escapeDeactivates: false,
        fallbackFocus: focusTrapNode,
        setReturnFocus: (el) => {
            focusElement(el);
            return false;
        },
        ...options?.focusTrapOptions,
        // the following options are not overridable
        document: el.ownerDocument,
        tabbableOptions,
        trapStack: focusTrapStack,
    };
    component.focusTrap = createFocusTrap(focusTrapNode, focusTrapOptions);
}
/**
 * Helper to activate the FocusTrap component.
 *
 * @param {FocusTrapComponent} component The FocusTrap component.
 * @param [options] The FocusTrap activate options.
 */
function activateFocusTrap(component, options) {
    if (!component.focusTrapDisabled) {
        component.focusTrap?.activate(options);
    }
}
/**
 * Helper to deactivate the FocusTrap component.
 *
 * @param {FocusTrapComponent} component The FocusTrap component.
 * @param [options] The FocusTrap deactivate options.
 */
function deactivateFocusTrap(component, options) {
    component.focusTrap?.deactivate(options);
}
/**
 * Helper to update the element(s) that are used within the FocusTrap component.
 *
 * @param {FocusTrapComponent} component The FocusTrap component.
 * @example
 * const modal = document.querySelector("calcite-modal");
 * const input = document.createElement("calcite-input");
 * content.appendChild(input);
 * await input.componentOnReady();
 * await modal.updateFocusTrapElements();
 * requestAnimationFrame(() => input.setFocus());
 */
function updateFocusTrapElements(component) {
    component.focusTrap?.updateContainerElements(component.el);
}

/**
 * Specifies if an ISO string date (YYYY-MM-DD) has two digit year.
 *
 * @param {string} value
 * @returns {boolean}
 */
function isTwoDigitYear(value) {
    if (!value) {
        return false;
    }
    const { year } = datePartsFromISO(value);
    return Number(year) < 100;
}
/**
 * Returns a normalized year to current century from a given two digit year number.
 *
 * @param {number} twoDigitYear
 * @returns {string}
 */
function normalizeToCurrentCentury(twoDigitYear) {
    const currentYear = new Date().getFullYear();
    const normalizedYear = Math.floor(currentYear / 100) * 100 + twoDigitYear;
    return normalizedYear;
}

const inputDatePickerCss = "/*!@:host*/.sc-calcite-input-date-picker-h{--calcite-icon-size:1rem;--calcite-spacing-eighth:0.125rem;--calcite-spacing-quarter:0.25rem;--calcite-spacing-half:0.5rem;--calcite-spacing-three-quarters:0.75rem;--calcite-spacing:1rem;--calcite-spacing-plus-quarter:1.25rem;--calcite-spacing-plus-half:1.5rem;--calcite-spacing-double:2rem;--calcite-menu-min-width:10rem;--calcite-header-min-height:3rem;--calcite-footer-min-height:3rem}/*!@:host([disabled])*/[disabled].sc-calcite-input-date-picker-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-input-date-picker-h *.sc-calcite-input-date-picker,.sc-calcite-input-date-picker-h[disabled].sc-calcite-input-date-picker-s>*,.sc-calcite-input-date-picker-h[disabled] .sc-calcite-input-date-picker-s>*{pointer-events:none}/*!@:host*/.sc-calcite-input-date-picker-h{position:relative;display:inline-block;inline-size:100%;overflow:visible;vertical-align:top;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@:host .menu-container .calcite-floating-ui-anim*/.sc-calcite-input-date-picker-h .menu-container.sc-calcite-input-date-picker .calcite-floating-ui-anim.sc-calcite-input-date-picker{position:relative;transition:var(--calcite-floating-ui-transition);transition-property:transform, visibility, opacity;opacity:0;box-shadow:0 0 16px 0 rgba(0, 0, 0, 0.16);z-index:var(--calcite-z-index);border-radius:0.25rem}/*!@:host .menu-container[data-placement^=bottom] .calcite-floating-ui-anim*/.sc-calcite-input-date-picker-h .menu-container[data-placement^=bottom].sc-calcite-input-date-picker .calcite-floating-ui-anim.sc-calcite-input-date-picker{transform:translateY(-5px)}/*!@:host .menu-container[data-placement^=top] .calcite-floating-ui-anim*/.sc-calcite-input-date-picker-h .menu-container[data-placement^=top].sc-calcite-input-date-picker .calcite-floating-ui-anim.sc-calcite-input-date-picker{transform:translateY(5px)}/*!@:host .menu-container[data-placement^=left] .calcite-floating-ui-anim*/.sc-calcite-input-date-picker-h .menu-container[data-placement^=left].sc-calcite-input-date-picker .calcite-floating-ui-anim.sc-calcite-input-date-picker{transform:translateX(5px)}/*!@:host .menu-container[data-placement^=right] .calcite-floating-ui-anim*/.sc-calcite-input-date-picker-h .menu-container[data-placement^=right].sc-calcite-input-date-picker .calcite-floating-ui-anim.sc-calcite-input-date-picker{transform:translateX(-5px)}/*!@:host .menu-container[data-placement] .calcite-floating-ui-anim--active*/.sc-calcite-input-date-picker-h .menu-container[data-placement].sc-calcite-input-date-picker .calcite-floating-ui-anim--active.sc-calcite-input-date-picker{opacity:1;transform:translate(0)}/*!@:host([scale=s])*/[scale=s].sc-calcite-input-date-picker-h{--calcite-toggle-spacing:0.5rem;--calcite-internal-input-text-input-padding-inline-end:calc(var(--calcite-toggle-spacing) + 1rem)}/*!@:host([scale=m])*/[scale=m].sc-calcite-input-date-picker-h{--calcite-toggle-spacing:0.75rem;--calcite-internal-input-text-input-padding-inline-end:calc(var(--calcite-toggle-spacing) + 1.5rem)}/*!@:host([scale=l])*/[scale=l].sc-calcite-input-date-picker-h{--calcite-toggle-spacing:1rem;--calcite-internal-input-text-input-padding-inline-end:calc(var(--calcite-toggle-spacing) + 2rem)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-input-date-picker-h[disabled] .sc-calcite-input-date-picker-s>[calcite-hydrated][disabled],[disabled].sc-calcite-input-date-picker-h [calcite-hydrated][disabled].sc-calcite-input-date-picker{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-input-date-picker{display:contents}/*!@.calendar-wrapper*/.calendar-wrapper.sc-calcite-input-date-picker{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);transform:translate3d(0, 0, 0)}/*!@.input-wrapper*/.input-wrapper.sc-calcite-input-date-picker{position:relative}/*!@.toggle-icon*/.toggle-icon.sc-calcite-input-date-picker{position:absolute;display:flex;cursor:pointer;align-items:center;inset-inline-end:0;inset-block:0;padding-inline:var(--calcite-toggle-spacing)}/*!@:host([range]) .input-container*/[range].sc-calcite-input-date-picker-h .input-container.sc-calcite-input-date-picker{display:flex}/*!@:host([range]) .input-wrapper*/[range].sc-calcite-input-date-picker-h .input-wrapper.sc-calcite-input-date-picker{flex:1 1 auto}/*!@:host([range]) .horizontal-arrow-container*/[range].sc-calcite-input-date-picker-h .horizontal-arrow-container.sc-calcite-input-date-picker{display:flex;align-items:center;border-width:1px;border-inline-start-width:0px;border-inline-end-width:0px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-background);padding-block:0px;padding-inline:0.25rem}/*!@:host([range][layout=vertical]) .input-wrapper*/[range][layout=vertical].sc-calcite-input-date-picker-h .input-wrapper.sc-calcite-input-date-picker{inline-size:100%}/*!@:host([range][layout=vertical]) .input-container*/[range][layout=vertical].sc-calcite-input-date-picker-h .input-container.sc-calcite-input-date-picker{flex-direction:column;align-items:flex-start}/*!@:host([range][layout=vertical]) .calendar-wrapper--end*/[range][layout=vertical].sc-calcite-input-date-picker-h .calendar-wrapper--end.sc-calcite-input-date-picker{transform:translate3d(0, 0, 0)}/*!@:host([range][layout=vertical]) .vertical-arrow-container*/[range][layout=vertical].sc-calcite-input-date-picker-h .vertical-arrow-container.sc-calcite-input-date-picker{inset-block-start:1.5rem;position:absolute;z-index:var(--calcite-z-index);margin-inline:1px;background-color:var(--calcite-color-foreground-1);padding-inline:0.625rem;inset-inline-start:0}/*!@.menu-container*/.menu-container.sc-calcite-input-date-picker{--calcite-floating-ui-z-index:var(--calcite-z-index-dropdown);display:block;position:absolute;z-index:var(--calcite-floating-ui-z-index);visibility:hidden}/*!@.menu-container .calcite-floating-ui-anim*/.menu-container.sc-calcite-input-date-picker .calcite-floating-ui-anim.sc-calcite-input-date-picker{position:relative;transition:var(--calcite-floating-ui-transition);transition-property:transform, visibility, opacity;opacity:0;box-shadow:0 0 16px 0 rgba(0, 0, 0, 0.16);z-index:var(--calcite-z-index);border-radius:0.25rem}/*!@.menu-container[data-placement^=bottom] .calcite-floating-ui-anim*/.menu-container[data-placement^=bottom].sc-calcite-input-date-picker .calcite-floating-ui-anim.sc-calcite-input-date-picker{transform:translateY(-5px)}/*!@.menu-container[data-placement^=top] .calcite-floating-ui-anim*/.menu-container[data-placement^=top].sc-calcite-input-date-picker .calcite-floating-ui-anim.sc-calcite-input-date-picker{transform:translateY(5px)}/*!@.menu-container[data-placement^=left] .calcite-floating-ui-anim*/.menu-container[data-placement^=left].sc-calcite-input-date-picker .calcite-floating-ui-anim.sc-calcite-input-date-picker{transform:translateX(5px)}/*!@.menu-container[data-placement^=right] .calcite-floating-ui-anim*/.menu-container[data-placement^=right].sc-calcite-input-date-picker .calcite-floating-ui-anim.sc-calcite-input-date-picker{transform:translateX(-5px)}/*!@.menu-container[data-placement] .calcite-floating-ui-anim--active*/.menu-container[data-placement].sc-calcite-input-date-picker .calcite-floating-ui-anim--active.sc-calcite-input-date-picker{opacity:1;transform:translate(0)}/*!@:host([open]) .menu-container*/[open].sc-calcite-input-date-picker-h .menu-container.sc-calcite-input-date-picker{visibility:visible}/*!@.menu-container--active*/.menu-container--active.sc-calcite-input-date-picker{visibility:visible}/*!@.input .calcite-input__wrapper*/.input.sc-calcite-input-date-picker .calcite-input__wrapper.sc-calcite-input-date-picker{margin-block-start:0px}/*!@:host([range][layout=vertical][scale=m]) .vertical-arrow-container*/[range][layout=vertical][scale=m].sc-calcite-input-date-picker-h .vertical-arrow-container.sc-calcite-input-date-picker{inset-block-start:1.5rem;padding-inline-start:0.75rem}/*!@:host([range][layout=vertical][scale=m]) .vertical-arrow-container calcite-icon*/[range][layout=vertical][scale=m].sc-calcite-input-date-picker-h .vertical-arrow-container.sc-calcite-input-date-picker calcite-icon.sc-calcite-input-date-picker{block-size:0.75rem;inline-size:0.75rem;min-inline-size:0px}/*!@:host([range][layout=vertical][scale=l]) .vertical-arrow-container*/[range][layout=vertical][scale=l].sc-calcite-input-date-picker-h .vertical-arrow-container.sc-calcite-input-date-picker{inset-block-start:2.25rem;padding-inline:0.875rem}/*!@:host([range][layout=vertical][open]) .vertical-arrow-container*/[range][layout=vertical][open].sc-calcite-input-date-picker-h .vertical-arrow-container.sc-calcite-input-date-picker{display:none}/*!@.validation-container*/.validation-container.sc-calcite-input-date-picker{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}/*!@:host([scale=m]) .validation-container,\n:host([scale=l]) .validation-container*/[scale=m].sc-calcite-input-date-picker-h .validation-container.sc-calcite-input-date-picker,[scale=l].sc-calcite-input-date-picker-h .validation-container.sc-calcite-input-date-picker{padding-block-start:0.5rem}/*!@:host([scale=s]) .validation-container*/[scale=s].sc-calcite-input-date-picker-h .validation-container.sc-calcite-input-date-picker{padding-block-start:0.25rem}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-input-date-picker-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@.assistive-text*/.assistive-text.sc-calcite-input-date-picker{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}/*!@:host([hidden])*/[hidden].sc-calcite-input-date-picker-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-input-date-picker{display:none}";

class InputDatePicker {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInputDatePickerChange = createEvent(this, "calciteInputDatePickerChange", 6);
        this.calciteInputDatePickerBeforeClose = createEvent(this, "calciteInputDatePickerBeforeClose", 6);
        this.calciteInputDatePickerClose = createEvent(this, "calciteInputDatePickerClose", 6);
        this.calciteInputDatePickerBeforeOpen = createEvent(this, "calciteInputDatePickerBeforeOpen", 6);
        this.calciteInputDatePickerOpen = createEvent(this, "calciteInputDatePickerOpen", 6);
        this.calciteInternalInputInputHandler = (event) => {
            const target = event.target;
            const value = target.value;
            const parsedValue = this.parseNumerals(value);
            const formattedValue = this.formatNumerals(parsedValue);
            target.value = formattedValue;
            const { year } = datePartsFromLocalizedString(value, this.localeData);
            if (year && year.length < 4) {
                return;
            }
            const date = dateFromLocalizedString(value, this.localeData);
            if (inRange(date, this.min, this.max)) {
                this.datePickerActiveDate = date;
            }
        };
        this.calciteInternalInputBlurHandler = () => {
            this.commitValue();
        };
        this.dialogId = `date-picker-dialog--${guid()}`;
        this.focusOnOpen = false;
        this.userChangedValue = false;
        this.openTransitionProp = "opacity";
        this.valueAsDateChangedExternally = false;
        this.placeholderTextId = `calcite-input-date-picker-placeholder-${guid()}`;
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.onInputWrapperPointerDown = () => {
            this.currentOpenInput = this.focusedInput;
        };
        this.onInputWrapperClick = (event) => {
            const { range, endInput, startInput, currentOpenInput } = this;
            const currentTarget = event.currentTarget;
            const position = currentTarget.getAttribute("data-position");
            const path = event.composedPath();
            const wasToggleClicked = path.find((el) => el.classList?.contains(CSS$Q.toggleIcon));
            if (wasToggleClicked) {
                const targetInput = position === "start" ? startInput : endInput;
                targetInput.setFocus();
            }
            if (!range || !this.open || currentOpenInput === position) {
                this.open = !this.open;
            }
        };
        this.setFilteredPlacements = () => {
            const { el, flipPlacements } = this;
            this.filteredFlipPlacements = flipPlacements
                ? filterComputedPlacements(flipPlacements, el)
                : null;
        };
        this.setTransitionEl = (el) => {
            this.transitionEl = el;
        };
        this.setStartInput = (el) => {
            this.startInput = el;
        };
        this.setEndInput = (el) => {
            this.endInput = el;
        };
        this.blurHandler = () => {
            this.open = false;
        };
        this.keyDownHandler = (event) => {
            const { defaultPrevented, key } = event;
            if (defaultPrevented) {
                return;
            }
            if (key === "Enter") {
                this.commitValue();
                if (this.shouldFocusRangeEnd()) {
                    this.endInput?.setFocus();
                }
                else if (this.shouldFocusRangeStart()) {
                    this.startInput?.setFocus();
                }
                if (submitForm(this)) {
                    event.preventDefault();
                    this.restoreInputFocus();
                }
            }
            else if (key === "ArrowDown") {
                this.open = true;
                this.focusOnOpen = true;
                event.preventDefault();
            }
            else if (key === "Escape") {
                this.open = false;
                event.preventDefault();
                this.restoreInputFocus();
            }
        };
        this.startInputFocus = () => {
            this.focusedInput = "start";
        };
        this.endInputFocus = () => {
            this.focusedInput = "end";
        };
        this.setFloatingEl = (el) => {
            this.floatingEl = el;
            connectFloatingUI(this, this.referenceEl, this.floatingEl);
        };
        this.setStartWrapper = (el) => {
            this.startWrapper = el;
            this.setReferenceEl();
        };
        this.setEndWrapper = (el) => {
            this.endWrapper = el;
            this.setReferenceEl();
        };
        this.setDatePickerRef = (el) => {
            this.datePickerEl = el;
            connectFocusTrap(this, {
                focusTrapEl: el,
                focusTrapOptions: {
                    initialFocus: false,
                    setReturnFocus: false,
                },
            });
        };
        /**
         * Event handler for when the selected date changes
         *
         * @param event CalciteDatePicker custom change event
         */
        this.handleDateChange = (event) => {
            if (this.range) {
                return;
            }
            event.stopPropagation();
            this.setValue(event.target.valueAsDate);
            this.localizeInputValues();
            this.restoreInputFocus();
        };
        this.handleDateRangeChange = (event) => {
            if (!this.range) {
                return;
            }
            event.stopPropagation();
            const value = event.target.valueAsDate;
            this.setRangeValue(value);
            this.localizeInputValues();
            this.restoreInputFocus();
        };
        this.setInputValue = (newValue, input = "start") => {
            const inputEl = this[`${input}Input`];
            if (!inputEl) {
                return;
            }
            inputEl.value = newValue;
        };
        this.setRangeValue = (valueAsDate) => {
            if (!this.range) {
                return;
            }
            const { value: oldValue } = this;
            const oldValueIsArray = Array.isArray(oldValue);
            const valueIsArray = Array.isArray(valueAsDate);
            const newStartDate = valueIsArray ? valueAsDate[0] : null;
            let newStartDateISO = valueIsArray ? dateToISO(newStartDate) : "";
            if (newStartDateISO) {
                newStartDateISO = this.getNormalizedDate(newStartDateISO);
            }
            const newEndDate = valueIsArray ? valueAsDate[1] : null;
            let newEndDateISO = valueIsArray ? dateToISO(newEndDate) : "";
            if (newEndDateISO) {
                newEndDateISO = this.getNormalizedDate(newEndDateISO);
            }
            const newValue = newStartDateISO || newEndDateISO ? [newStartDateISO, newEndDateISO] : "";
            if (newValue === oldValue) {
                return;
            }
            this.userChangedValue = true;
            this.value = newValue;
            this.valueAsDate = newValue ? getValueAsDateRange(newValue) : undefined;
            const changeEvent = this.calciteInputDatePickerChange.emit();
            if (changeEvent && changeEvent.defaultPrevented) {
                this.value = oldValue;
                if (oldValueIsArray) {
                    this.setInputValue(oldValue[0], "start");
                    this.setInputValue(oldValue[1], "end");
                }
                else {
                    this.value = oldValue;
                    this.setInputValue(oldValue);
                }
            }
        };
        this.setValue = (value) => {
            if (this.range) {
                return;
            }
            const oldValue = this.value;
            let newValue = dateToISO(value);
            newValue = this.getNormalizedDate(newValue);
            if (newValue === oldValue) {
                return;
            }
            this.userChangedValue = true;
            this.valueAsDate = newValue ? dateFromISO(newValue) : undefined;
            this.value = newValue || "";
            const changeEvent = this.calciteInputDatePickerChange.emit();
            if (changeEvent.defaultPrevented) {
                this.value = oldValue;
                this.setInputValue(oldValue);
            }
        };
        this.commonDateSeparators = [".", "-", "/"];
        this.formatNumerals = (value) => value
            ? value
                .split("")
                .map((char) => this.commonDateSeparators?.includes(char)
                ? this.localeData?.separator
                : numberKeys?.includes(char)
                    ? numberStringFormatter?.numberFormatter?.format(Number(char))
                    : char)
                .join("")
            : "";
        this.parseNumerals = (value) => value
            ? value
                .split("")
                .map((char) => numberKeys.includes(char) ? numberStringFormatter.delocalize(char) : char)
                .join("")
            : "";
        this.disabled = false;
        this.focusTrapDisabled = false;
        this.form = undefined;
        this.readOnly = false;
        this.value = "";
        this.flipPlacements = undefined;
        this.headingLevel = undefined;
        this.valueAsDate = undefined;
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.minAsDate = undefined;
        this.maxAsDate = undefined;
        this.min = undefined;
        this.max = undefined;
        this.open = false;
        this.validationMessage = undefined;
        this.validationIcon = undefined;
        this.name = undefined;
        this.numberingSystem = undefined;
        this.scale = "m";
        this.status = "idle";
        this.placement = defaultMenuPlacement;
        this.range = false;
        this.required = false;
        this.overlayPositioning = "absolute";
        this.proximitySelectionDisabled = false;
        this.layout = "horizontal";
        this.datePickerActiveDate = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
        this.focusedInput = "start";
        this.localeData = undefined;
    }
    handleFocusTrapDisabled(focusTrapDisabled) {
        if (!this.open) {
            return;
        }
        focusTrapDisabled ? deactivateFocusTrap(this) : activateFocusTrap(this);
    }
    handleDisabledAndReadOnlyChange(value) {
        if (!value) {
            this.open = false;
        }
    }
    valueWatcher(newValue) {
        if (!this.userChangedValue) {
            let newValueAsDate;
            if (Array.isArray(newValue)) {
                newValueAsDate = getValueAsDateRange(newValue);
            }
            else if (newValue) {
                newValueAsDate = dateFromISO(newValue);
            }
            else {
                newValueAsDate = undefined;
            }
            if (!this.valueAsDateChangedExternally && newValueAsDate !== this.valueAsDate) {
                this.valueAsDate = newValueAsDate;
            }
            this.localizeInputValues();
        }
        this.userChangedValue = false;
    }
    valueAsDateWatcher(valueAsDate) {
        this.datePickerActiveDate = valueAsDate;
        const newValue = this.range && Array.isArray(valueAsDate)
            ? [dateToISO(valueAsDate[0]), dateToISO(valueAsDate[1])]
            : dateToISO(valueAsDate);
        if (this.value !== newValue) {
            this.valueAsDateChangedExternally = true;
            this.value = newValue;
            this.valueAsDateChangedExternally = false;
        }
    }
    flipPlacementsHandler() {
        this.setFilteredPlacements();
        this.reposition(true);
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    onMinChanged(min) {
        if (min) {
            this.minAsDate = dateFromISO(min);
        }
    }
    onMaxChanged(max) {
        if (max) {
            this.maxAsDate = dateFromISO(max);
        }
    }
    openHandler() {
        onToggleOpenCloseComponent(this);
        if (this.disabled || this.readOnly) {
            this.open = false;
            return;
        }
        this.reposition(true);
    }
    overlayPositioningHandler() {
        this.reposition(true);
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    calciteDaySelectHandler() {
        if (this.shouldFocusRangeStart() || this.shouldFocusRangeEnd()) {
            return;
        }
        this.open = false;
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.el.focus();
    }
    /**
     * Updates the position of the component.
     *
     * @param delayed
     */
    async reposition(delayed = false) {
        const { floatingEl, referenceEl, placement, overlayPositioning, filteredFlipPlacements } = this;
        return reposition(this, {
            floatingEl,
            referenceEl,
            overlayPositioning,
            placement,
            flipPlacements: filteredFlipPlacements,
            type: "menu",
        }, delayed);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        const { open } = this;
        open && this.openHandler();
        if (Array.isArray(this.value)) {
            this.valueAsDate = getValueAsDateRange(this.value);
        }
        else if (this.value) {
            try {
                this.valueAsDate = dateFromISO(this.value);
            }
            catch (error) {
                this.warnAboutInvalidValue(this.value);
                this.value = "";
            }
        }
        else if (this.valueAsDate) {
            if (this.range) {
                this.setRangeValue(this.valueAsDate);
            }
            else if (!Array.isArray(this.valueAsDate)) {
                this.value = dateToISO(this.valueAsDate);
            }
        }
        if (this.min) {
            this.minAsDate = dateFromISO(this.min);
        }
        if (this.max) {
            this.maxAsDate = dateFromISO(this.max);
        }
        connectLabel(this);
        connectForm(this);
        connectMessages(this);
        this.setFilteredPlacements();
        this.reposition(true);
        numberStringFormatter.numberFormatOptions = {
            numberingSystem: this.numberingSystem,
            locale: this.effectiveLocale,
            useGrouping: false,
        };
        if (this.open) {
            onToggleOpenCloseComponent(this);
        }
        connectFloatingUI(this, this.referenceEl, this.floatingEl);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await Promise.all([this.loadLocaleData(), setUpMessages(this)]);
        this.onMinChanged(this.min);
        this.onMaxChanged(this.max);
    }
    componentDidLoad() {
        setComponentLoaded(this);
        this.localizeInputValues();
        this.reposition(true);
    }
    disconnectedCallback() {
        deactivateFocusTrap(this);
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
        disconnectFloatingUI(this, this.referenceEl, this.floatingEl);
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    render() {
        const { disabled, effectiveLocale, messages, numberingSystem, readOnly } = this;
        numberStringFormatter.numberFormatOptions = {
            numberingSystem,
            locale: effectiveLocale,
            useGrouping: false,
        };
        return (hAsync(Host, { onBlur: this.blurHandler, onKeyDown: this.keyDownHandler }, hAsync(InteractiveContainer, { disabled: this.disabled }, this.localeData && (hAsync("div", { class: CSS$Q.inputContainer }, hAsync("div", { class: CSS$Q.inputWrapper, "data-position": "start", onClick: this.onInputWrapperClick, onPointerDown: this.onInputWrapperPointerDown,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setStartWrapper }, hAsync("calcite-input-text", { "aria-autocomplete": "none", "aria-controls": this.dialogId, "aria-describedby": this.placeholderTextId, "aria-expanded": toAriaBoolean(this.open), "aria-haspopup": "dialog", class: {
                [CSS$Q.input]: true,
                [CSS$Q.inputNoBottomBorder]: this.layout === "vertical" && this.range,
            }, disabled: disabled, icon: "calendar", onCalciteInputTextInput: this.calciteInternalInputInputHandler, onCalciteInternalInputTextBlur: this.calciteInternalInputBlurHandler, onCalciteInternalInputTextFocus: this.startInputFocus, placeholder: this.localeData?.placeholder, readOnly: readOnly, role: "combobox", scale: this.scale, status: this.status,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setStartInput }), !this.readOnly &&
            this.renderToggleIcon(this.open && this.focusedInput === "start"), hAsync("span", { "aria-hidden": "true", class: CSS$Q.assistiveText, id: this.placeholderTextId }, "Date Format: ", this.localeData?.placeholder)), hAsync("div", { "aria-hidden": toAriaBoolean(!this.open), "aria-label": messages.chooseDate, "aria-live": "polite", "aria-modal": "true", class: {
                [CSS$Q.menu]: true,
                [CSS$Q.menuActive]: this.open,
            }, id: this.dialogId, role: "dialog",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setFloatingEl }, hAsync("div", { class: {
                [CSS$Q.calendarWrapper]: true,
                [CSS$Q.calendarWrapperEnd]: this.focusedInput === "end",
                [FloatingCSS.animation]: true,
                [FloatingCSS.animationActive]: this.open,
            },
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setTransitionEl }, hAsync("calcite-date-picker", { activeDate: this.datePickerActiveDate, activeRange: this.focusedInput, headingLevel: this.headingLevel, max: this.max, maxAsDate: this.maxAsDate, messageOverrides: this.messageOverrides, min: this.min, minAsDate: this.minAsDate, numberingSystem: numberingSystem, onCalciteDatePickerChange: this.handleDateChange, onCalciteDatePickerRangeChange: this.handleDateRangeChange, proximitySelectionDisabled: this.proximitySelectionDisabled, range: this.range, scale: this.scale, tabIndex: this.open ? undefined : -1, valueAsDate: this.valueAsDate,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setDatePickerRef }))), this.range && this.layout === "horizontal" && (hAsync("div", { class: CSS$Q.horizontalArrowContainer }, hAsync("calcite-icon", { flipRtl: true, icon: "arrow-right", scale: getIconScale(this.scale) }))), this.range && this.layout === "vertical" && this.scale !== "s" && (hAsync("div", { class: CSS$Q.verticalArrowContainer }, hAsync("calcite-icon", { icon: "arrow-down", scale: getIconScale(this.scale) }))), this.range && (hAsync("div", { class: CSS$Q.inputWrapper, "data-position": "end", onClick: this.onInputWrapperClick, onPointerDown: this.onInputWrapperPointerDown,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setEndWrapper }, hAsync("calcite-input-text", { "aria-autocomplete": "none", "aria-controls": this.dialogId, "aria-expanded": toAriaBoolean(this.open), "aria-haspopup": "dialog", class: {
                [CSS$Q.input]: true,
                [CSS$Q.inputBorderTopColorOne]: this.layout === "vertical" && this.range,
            }, disabled: disabled, icon: "calendar", onCalciteInputTextInput: this.calciteInternalInputInputHandler, onCalciteInternalInputTextBlur: this.calciteInternalInputBlurHandler, onCalciteInternalInputTextFocus: this.endInputFocus, placeholder: this.localeData?.placeholder, readOnly: readOnly, role: "combobox", scale: this.scale, status: this.status,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setEndInput }), !this.readOnly &&
            this.renderToggleIcon(this.open && this.focusedInput === "end"))))), hAsync(HiddenFormInputSlot, { component: this }), this.validationMessage && this.status === "invalid" ? (hAsync(Validation, { icon: this.validationIcon, message: this.validationMessage, scale: this.scale, status: this.status })) : null)));
    }
    renderToggleIcon(open) {
        return (
        // we set tab index to -1 to prevent delegatesFocus from stealing focus before we can set it
        hAsync("span", { class: CSS$Q.toggleIcon, tabIndex: -1 }, hAsync("calcite-icon", { icon: open ? "chevron-up" : "chevron-down", scale: getIconScale(this.scale) })));
    }
    setReferenceEl() {
        const { focusedInput, layout, endWrapper, startWrapper } = this;
        this.referenceEl =
            focusedInput === "end" || layout === "vertical"
                ? endWrapper || startWrapper
                : startWrapper || endWrapper;
        requestAnimationFrame(() => connectFloatingUI(this, this.referenceEl, this.floatingEl));
    }
    onLabelClick() {
        this.setFocus();
    }
    onBeforeOpen() {
        this.calciteInputDatePickerBeforeOpen.emit();
    }
    onOpen() {
        activateFocusTrap(this, {
            onActivate: () => {
                if (this.focusOnOpen) {
                    this.datePickerEl.setFocus();
                    this.focusOnOpen = false;
                }
            },
        });
        this.calciteInputDatePickerOpen.emit();
    }
    onBeforeClose() {
        this.calciteInputDatePickerBeforeClose.emit();
    }
    onClose() {
        this.calciteInputDatePickerClose.emit();
        deactivateFocusTrap(this);
        this.restoreInputFocus();
        this.focusOnOpen = false;
        this.datePickerEl.reset();
    }
    commitValue() {
        const { focusedInput, value } = this;
        const focusedInputName = `${focusedInput}Input`;
        const focusedInputValue = this[focusedInputName].value;
        const date = dateFromLocalizedString(focusedInputValue, this.localeData);
        const dateAsISO = dateToISO(date);
        const valueIsArray = Array.isArray(value);
        if (this.range) {
            const focusedInputValueIndex = focusedInput === "start" ? 0 : 1;
            if (valueIsArray) {
                if (dateAsISO === value[focusedInputValueIndex]) {
                    return;
                }
                if (date) {
                    this.setRangeValue([
                        focusedInput === "start" ? date : dateFromISO(value[0]),
                        focusedInput === "end" ? date : dateFromISO(value[1]),
                    ]);
                    this.localizeInputValues();
                }
                else {
                    this.setRangeValue([
                        focusedInput === "end" && dateFromISO(value[0]),
                        focusedInput === "start" && dateFromISO(value[1]),
                    ]);
                }
            }
            else {
                if (date) {
                    this.setRangeValue([
                        focusedInput === "start" ? date : dateFromISO(value[0]),
                        focusedInput === "end" ? date : dateFromISO(value[1]),
                    ]);
                    this.localizeInputValues();
                }
            }
        }
        else {
            if (dateAsISO === value) {
                return;
            }
            this.setValue(date);
            this.localizeInputValues();
        }
    }
    async loadLocaleData() {
        {
            return;
        }
    }
    shouldFocusRangeStart() {
        const startValue = this.value[0];
        const endValue = this.value[1];
        return !!(endValue && !startValue && this.focusedInput === "end" && this.startInput);
    }
    shouldFocusRangeEnd() {
        const startValue = this.value[0];
        const endValue = this.value[1];
        return !!(startValue && !endValue && this.focusedInput === "start" && this.endInput);
    }
    restoreInputFocus() {
        if (!this.range) {
            this.startInput.setFocus();
            return;
        }
        const focusedInput = this.focusedInput === "start" ? this.startInput : this.endInput;
        focusedInput.setFocus();
    }
    localizeInputValues() {
        const date = dateFromRange((this.range
            ? (Array.isArray(this.valueAsDate) && this.valueAsDate[0]) || undefined
            : this.valueAsDate), this.minAsDate, this.maxAsDate);
        const endDate = this.range
            ? dateFromRange((Array.isArray(this.valueAsDate) && this.valueAsDate[1]) || undefined, this.minAsDate, this.maxAsDate)
            : null;
        const formattingOptions = {
            // we explicitly set numberingSystem to prevent the browser-inferred value
            // see https://github.com/Esri/calcite-design-system/issues/3079#issuecomment-1168964195 for more info
            numberingSystem: getSupportedNumberingSystem(this.numberingSystem),
        };
        const localizedDate = date && date.toLocaleDateString(this.effectiveLocale, formattingOptions);
        const localizedEndDate = endDate && endDate.toLocaleDateString(this.effectiveLocale, formattingOptions);
        this.setInputValue(localizedDate ?? "", "start");
        this.setInputValue((this.range && localizedEndDate) ?? "", "end");
    }
    warnAboutInvalidValue(value) {
        console.warn(`The specified value "${value}" does not conform to the required format, "YYYY-MM-DD".`);
    }
    getNormalizedDate(value) {
        if (!value) {
            return "";
        }
        if (!isTwoDigitYear(value)) {
            return value;
        }
        const { day, month, year } = datePartsFromISO(value);
        const normalizedYear = normalizeToCurrentCentury(Number(year));
        return `${normalizedYear}-${month}-${day}`;
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "focusTrapDisabled": ["handleFocusTrapDisabled"],
        "disabled": ["handleDisabledAndReadOnlyChange"],
        "readOnly": ["handleDisabledAndReadOnlyChange"],
        "value": ["valueWatcher"],
        "valueAsDate": ["valueAsDateWatcher"],
        "flipPlacements": ["flipPlacementsHandler"],
        "messageOverrides": ["onMessagesChange"],
        "min": ["onMinChanged"],
        "max": ["onMaxChanged"],
        "open": ["openHandler"],
        "overlayPositioning": ["overlayPositioningHandler"],
        "layout": ["setReferenceEl"],
        "focusedInput": ["setReferenceEl"],
        "effectiveLocale": ["loadLocaleData"]
    }; }
    static get style() { return inputDatePickerCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-input-date-picker",
        "$members$": {
            "disabled": [516],
            "focusTrapDisabled": [516, "focus-trap-disabled"],
            "form": [513],
            "readOnly": [516, "read-only"],
            "value": [1025],
            "flipPlacements": [16],
            "headingLevel": [514, "heading-level"],
            "valueAsDate": [1040],
            "messageOverrides": [1040],
            "messages": [1040],
            "minAsDate": [1040],
            "maxAsDate": [1040],
            "min": [1],
            "max": [1],
            "open": [1540],
            "validationMessage": [1, "validation-message"],
            "validationIcon": [520, "validation-icon"],
            "name": [513],
            "numberingSystem": [513, "numbering-system"],
            "scale": [513],
            "status": [513],
            "placement": [513],
            "range": [516],
            "required": [516],
            "overlayPositioning": [513, "overlay-positioning"],
            "proximitySelectionDisabled": [4, "proximity-selection-disabled"],
            "layout": [513],
            "datePickerActiveDate": [32],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "focusedInput": [32],
            "localeData": [32],
            "setFocus": [64],
            "reposition": [64]
        },
        "$listeners$": [[0, "calciteDaySelect", "calciteDaySelectHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["focusTrapDisabled", "focus-trap-disabled"], ["form", "form"], ["readOnly", "read-only"], ["headingLevel", "heading-level"], ["open", "open"], ["validationIcon", "validation-icon"], ["name", "name"], ["numberingSystem", "numbering-system"], ["scale", "scale"], ["status", "status"], ["placement", "placement"], ["range", "range"], ["required", "required"], ["overlayPositioning", "overlay-positioning"], ["layout", "layout"]]
    }; }
}

var StatusIconDefaults;
(function (StatusIconDefaults) {
    StatusIconDefaults["valid"] = "check-circle";
    StatusIconDefaults["invalid"] = "exclamation-mark-triangle";
    StatusIconDefaults["idle"] = "information";
})(StatusIconDefaults || (StatusIconDefaults = {}));

const inputMessageCss = "/*!@:host*/.sc-calcite-input-message-h{box-sizing:border-box;display:flex;block-size:auto;inline-size:100%;align-items:center;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1);opacity:1;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;--calcite-input-message-spacing-value:0.25rem;margin-block-start:var(--calcite-input-message-spacing-value)}/*!@.calcite-input-message-icon*/.calcite-input-message-icon.sc-calcite-input-message{pointer-events:none;display:inline-flex;flex-shrink:0;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;margin-inline-end:0.5rem}/*!@:host([status=invalid]) .calcite-input-message-icon*/[status=invalid].sc-calcite-input-message-h .calcite-input-message-icon.sc-calcite-input-message{color:var(--calcite-color-status-danger)}/*!@:host([status=warning]) .calcite-input-message-icon*/[status=warning].sc-calcite-input-message-h .calcite-input-message-icon.sc-calcite-input-message{color:var(--calcite-color-status-warning)}/*!@:host([status=valid]) .calcite-input-message-icon*/[status=valid].sc-calcite-input-message-h .calcite-input-message-icon.sc-calcite-input-message{color:var(--calcite-color-status-success)}/*!@:host([status=idle]) .calcite-input-message-icon*/[status=idle].sc-calcite-input-message-h .calcite-input-message-icon.sc-calcite-input-message{color:var(--calcite-color-brand)}/*!@:host([scale=s])*/[scale=s].sc-calcite-input-message-h{font-size:var(--calcite-font-size--3);line-height:0.75rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-input-message-h{font-size:var(--calcite-font-size--2);line-height:1rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-input-message-h{font-size:var(--calcite-font-size--1);line-height:1rem}/*!@:host([hidden])*/[hidden].sc-calcite-input-message-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-input-message{display:none}";

/**
 * @slot - A slot for adding text.
 */
class InputMessage {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.icon = undefined;
        this.iconFlipRtl = false;
        this.scale = "m";
        this.status = "idle";
    }
    handleIconEl() {
        this.requestedIcon = setRequestedIcon(StatusIconDefaults, this.icon, this.status);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.requestedIcon = setRequestedIcon(StatusIconDefaults, this.icon, this.status);
    }
    render() {
        const hidden = this.el.hidden;
        return (hAsync(Host, { "calcite-hydrated-hidden": hidden }, this.renderIcon(this.requestedIcon), hAsync("slot", null)));
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    renderIcon(iconName) {
        if (iconName) {
            return (hAsync("calcite-icon", { class: "calcite-input-message-icon", flipRtl: this.iconFlipRtl, icon: iconName, scale: "s" }));
        }
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "status": ["handleIconEl"],
        "icon": ["handleIconEl"]
    }; }
    static get style() { return inputMessageCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-input-message",
        "$members$": {
            "icon": [520],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "scale": [513],
            "status": [513]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["scale", "scale"], ["status", "status"]]
    }; }
}

const CSS$P = {
    loader: "loader",
    clearButton: "clear-button",
    editingEnabled: "editing-enabled",
    inlineChild: "inline-child",
    inputIcon: "icon",
    prefix: "prefix",
    suffix: "suffix",
    numberButtonWrapper: "number-button-wrapper",
    buttonItemHorizontal: "number-button-item--horizontal",
    wrapper: "element-wrapper",
    inputWrapper: "wrapper",
    actionWrapper: "action-wrapper",
    resizeIconWrapper: "resize-icon-wrapper",
    numberButtonItem: "number-button-item",
};
const SLOTS$k = {
    action: "action",
};

const inputNumberCss = "/*!@:host([disabled])*/[disabled].sc-calcite-input-number-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-input-number-h *.sc-calcite-input-number,.sc-calcite-input-number-h[disabled].sc-calcite-input-number-s>*,.sc-calcite-input-number-h[disabled] .sc-calcite-input-number-s>*{pointer-events:none}/*!@:host*/.sc-calcite-input-number-h{display:block}/*!@:host([scale=s]) input, :host([scale=s]) .prefix, :host([scale=s]) .suffix*/[scale=s].sc-calcite-input-number-h input.sc-calcite-input-number,[scale=s].sc-calcite-input-number-h .prefix.sc-calcite-input-number,[scale=s].sc-calcite-input-number-h .suffix.sc-calcite-input-number{block-size:1.5rem;padding-inline:0.5rem;font-size:var(--calcite-font-size--2);line-height:1rem}/*!@:host([scale=s]) .number-button-wrapper, :host([scale=s]) .action-wrapper calcite-button, :host([scale=s]) .action-wrapper calcite-button button*/[scale=s].sc-calcite-input-number-h .number-button-wrapper.sc-calcite-input-number,[scale=s].sc-calcite-input-number-h .action-wrapper.sc-calcite-input-number calcite-button.sc-calcite-input-number,[scale=s].sc-calcite-input-number-h .action-wrapper.sc-calcite-input-number calcite-button.sc-calcite-input-number button.sc-calcite-input-number{block-size:1.5rem}/*!@:host([scale=s]) .clear-button*/[scale=s].sc-calcite-input-number-h .clear-button.sc-calcite-input-number{min-block-size:1.5rem;min-inline-size:1.5rem}/*!@:host([scale=m]) input, :host([scale=m]) .prefix, :host([scale=m]) .suffix*/[scale=m].sc-calcite-input-number-h input.sc-calcite-input-number,[scale=m].sc-calcite-input-number-h .prefix.sc-calcite-input-number,[scale=m].sc-calcite-input-number-h .suffix.sc-calcite-input-number{block-size:2rem;padding-inline:0.75rem;font-size:var(--calcite-font-size--1);line-height:1rem}/*!@:host([scale=m]) .number-button-wrapper, :host([scale=m]) .action-wrapper calcite-button, :host([scale=m]) .action-wrapper calcite-button button*/[scale=m].sc-calcite-input-number-h .number-button-wrapper.sc-calcite-input-number,[scale=m].sc-calcite-input-number-h .action-wrapper.sc-calcite-input-number calcite-button.sc-calcite-input-number,[scale=m].sc-calcite-input-number-h .action-wrapper.sc-calcite-input-number calcite-button.sc-calcite-input-number button.sc-calcite-input-number{block-size:2rem}/*!@:host([scale=m]) .clear-button*/[scale=m].sc-calcite-input-number-h .clear-button.sc-calcite-input-number{min-block-size:2rem;min-inline-size:2rem}/*!@:host([scale=l]) input, :host([scale=l]) .prefix, :host([scale=l]) .suffix*/[scale=l].sc-calcite-input-number-h input.sc-calcite-input-number,[scale=l].sc-calcite-input-number-h .prefix.sc-calcite-input-number,[scale=l].sc-calcite-input-number-h .suffix.sc-calcite-input-number{block-size:2.75rem;padding-inline:1rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host([scale=l]) .number-button-wrapper, :host([scale=l]) .action-wrapper calcite-button, :host([scale=l]) .action-wrapper calcite-button button*/[scale=l].sc-calcite-input-number-h .number-button-wrapper.sc-calcite-input-number,[scale=l].sc-calcite-input-number-h .action-wrapper.sc-calcite-input-number calcite-button.sc-calcite-input-number,[scale=l].sc-calcite-input-number-h .action-wrapper.sc-calcite-input-number calcite-button.sc-calcite-input-number button.sc-calcite-input-number{block-size:2.75rem}/*!@:host([scale=l]) .clear-button*/[scale=l].sc-calcite-input-number-h .clear-button.sc-calcite-input-number{min-block-size:2.75rem;min-inline-size:2.75rem}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-input-number-h[disabled] .sc-calcite-input-number-s>[calcite-hydrated][disabled],[disabled].sc-calcite-input-number-h [calcite-hydrated][disabled].sc-calcite-input-number{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-input-number{display:contents}/*!@input*/input.sc-calcite-input-number{transition:var(--calcite-animation-timing), block-size 0, outline-offset 0s;-webkit-appearance:none;position:relative;margin:0px;box-sizing:border-box;display:flex;max-block-size:100%;inline-size:100%;max-inline-size:100%;flex:1 1 0%;text-overflow:ellipsis;border-radius:0px;background-color:var(--calcite-color-foreground-1);font-family:inherit;font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-1)}/*!@input:placeholder-shown*/input.sc-calcite-input-number:placeholder-shown{text-overflow:ellipsis}/*!@input*/input.sc-calcite-input-number{border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);color:var(--calcite-color-text-1)}/*!@input::placeholder, input:-ms-input-placeholder, input::-ms-input-placeholder*/input.sc-calcite-input-number::placeholder,input.sc-calcite-input-number:-ms-input-placeholder,input.sc-calcite-input-number::-ms-input-placeholder{font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-3)}/*!@input:focus*/input.sc-calcite-input-number:focus{border-color:var(--calcite-color-brand);color:var(--calcite-color-text-1)}/*!@input[readonly]*/input[readonly].sc-calcite-input-number{background-color:var(--calcite-color-background);font-weight:var(--calcite-font-weight-medium)}/*!@input[readonly]:focus*/input[readonly].sc-calcite-input-number:focus{color:var(--calcite-color-text-1)}/*!@calcite-icon*/calcite-icon.sc-calcite-input-number{color:var(--calcite-color-text-3)}/*!@input*/input.sc-calcite-input-number{outline-color:transparent}/*!@input:focus*/input.sc-calcite-input-number:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([status=invalid]) input*/[status=invalid].sc-calcite-input-number-h input.sc-calcite-input-number{border-color:var(--calcite-color-status-danger)}/*!@:host([status=invalid]) input:focus*/[status=invalid].sc-calcite-input-number-h input.sc-calcite-input-number:focus{outline:2px solid var(--calcite-color-status-danger);outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([scale=s]) .icon*/[scale=s].sc-calcite-input-number-h .icon.sc-calcite-input-number{inset-inline-start:0.5rem}/*!@:host([scale=m]) .icon*/[scale=m].sc-calcite-input-number-h .icon.sc-calcite-input-number{inset-inline-start:0.75rem}/*!@:host([scale=l]) .icon*/[scale=l].sc-calcite-input-number-h .icon.sc-calcite-input-number{inset-inline-start:1rem}/*!@:host([icon][scale=s]) input*/[icon][scale=s].sc-calcite-input-number-h input.sc-calcite-input-number{padding-inline-start:2rem}/*!@:host([icon][scale=m]) input*/[icon][scale=m].sc-calcite-input-number-h input.sc-calcite-input-number{padding-inline-start:2.5rem}/*!@:host([icon][scale=l]) input*/[icon][scale=l].sc-calcite-input-number-h input.sc-calcite-input-number{padding-inline-start:3.5rem}/*!@.element-wrapper*/.element-wrapper.sc-calcite-input-number{position:relative;order:3;display:inline-flex;flex:1 1 0%;align-items:center}/*!@.icon*/.icon.sc-calcite-input-number{pointer-events:none;position:absolute;z-index:var(--calcite-z-index);display:block;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.clear-button*/.clear-button.sc-calcite-input-number{pointer-events:initial;order:4;margin:0px;box-sizing:border-box;display:flex;min-block-size:100%;cursor:pointer;align-items:center;justify-content:center;align-self:stretch;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-foreground-1);outline-color:transparent;border-inline-start-width:0px}/*!@.clear-button:hover*/.clear-button.sc-calcite-input-number:hover{background-color:var(--calcite-color-foreground-2);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.clear-button:hover calcite-icon*/.clear-button.sc-calcite-input-number:hover calcite-icon.sc-calcite-input-number{color:var(--calcite-color-text-1);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.clear-button:active*/.clear-button.sc-calcite-input-number:active{background-color:var(--calcite-color-foreground-3)}/*!@.clear-button:active calcite-icon*/.clear-button.sc-calcite-input-number:active calcite-icon.sc-calcite-input-number{color:var(--calcite-color-text-1)}/*!@.clear-button:focus*/.clear-button.sc-calcite-input-number:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.clear-button:disabled*/.clear-button.sc-calcite-input-number:disabled{opacity:var(--calcite-opacity-disabled)}/*!@.loader*/.loader.sc-calcite-input-number{inset-block-start:1px;inset-inline:1px;pointer-events:none;position:absolute;display:block}/*!@.action-wrapper*/.action-wrapper.sc-calcite-input-number{order:7;display:flex}/*!@.prefix,\n.suffix*/.prefix.sc-calcite-input-number,.suffix.sc-calcite-input-number{box-sizing:border-box;display:flex;block-size:auto;min-block-size:100%;-webkit-user-select:none;user-select:none;align-content:center;align-items:center;overflow-wrap:break-word;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-background);font-weight:var(--calcite-font-weight-medium);line-height:1;color:var(--calcite-color-text-2)}/*!@.prefix*/.prefix.sc-calcite-input-number{order:2;border-inline-end-width:0px}/*!@.suffix*/.suffix.sc-calcite-input-number{order:5;border-inline-start-width:0px}/*!@:host([alignment=start]) input*/[alignment=start].sc-calcite-input-number-h input.sc-calcite-input-number{text-align:start}/*!@:host([alignment=end]) input*/[alignment=end].sc-calcite-input-number-h input.sc-calcite-input-number{text-align:end}/*!@.number-button-wrapper*/.number-button-wrapper.sc-calcite-input-number{pointer-events:none;order:6;box-sizing:border-box;display:flex;flex-direction:column;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@:host([number-button-type=vertical]) .wrapper*/[number-button-type=vertical].sc-calcite-input-number-h .wrapper.sc-calcite-input-number{flex-direction:row;display:flex}/*!@:host([number-button-type=vertical]) input*/[number-button-type=vertical].sc-calcite-input-number-h input.sc-calcite-input-number{order:2}/*!@:host([number-button-type=horizontal]) .calcite--rtl .number-button-item[data-adjustment=down] calcite-icon*/[number-button-type=horizontal].sc-calcite-input-number-h .calcite--rtl.sc-calcite-input-number .number-button-item[data-adjustment=down].sc-calcite-input-number calcite-icon.sc-calcite-input-number{transform:rotate(-90deg)}/*!@:host([number-button-type=horizontal]) .calcite--rtl .number-button-item[data-adjustment=up] calcite-icon*/[number-button-type=horizontal].sc-calcite-input-number-h .calcite--rtl.sc-calcite-input-number .number-button-item[data-adjustment=up].sc-calcite-input-number calcite-icon.sc-calcite-input-number{transform:rotate(-90deg)}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=down], .number-button-item.number-button-item--horizontal[data-adjustment=up]*/.number-button-item.number-button-item--horizontal[data-adjustment=down].sc-calcite-input-number,.number-button-item.number-button-item--horizontal[data-adjustment=up].sc-calcite-input-number{order:1;max-block-size:100%;min-block-size:100%;align-self:stretch}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=down] calcite-icon, .number-button-item.number-button-item--horizontal[data-adjustment=up] calcite-icon*/.number-button-item.number-button-item--horizontal[data-adjustment=down].sc-calcite-input-number calcite-icon.sc-calcite-input-number,.number-button-item.number-button-item--horizontal[data-adjustment=up].sc-calcite-input-number calcite-icon.sc-calcite-input-number{transform:rotate(90deg)}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=down]*/.number-button-item.number-button-item--horizontal[data-adjustment=down].sc-calcite-input-number{border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);border-inline-end-width:0px}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=down]:hover*/.number-button-item.number-button-item--horizontal[data-adjustment=down].sc-calcite-input-number:hover{background-color:var(--calcite-color-foreground-2)}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=down]:hover calcite-icon*/.number-button-item.number-button-item--horizontal[data-adjustment=down].sc-calcite-input-number:hover calcite-icon.sc-calcite-input-number{color:var(--calcite-color-text-1)}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=up]*/.number-button-item.number-button-item--horizontal[data-adjustment=up].sc-calcite-input-number{order:5}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=up]:hover*/.number-button-item.number-button-item--horizontal[data-adjustment=up].sc-calcite-input-number:hover{background-color:var(--calcite-color-foreground-2)}/*!@.number-button-item.number-button-item--horizontal[data-adjustment=up]:hover calcite-icon*/.number-button-item.number-button-item--horizontal[data-adjustment=up].sc-calcite-input-number:hover calcite-icon.sc-calcite-input-number{color:var(--calcite-color-text-1)}/*!@:host([number-button-type=vertical]) .number-button-item[data-adjustment=down]:hover*/[number-button-type=vertical].sc-calcite-input-number-h .number-button-item[data-adjustment=down].sc-calcite-input-number:hover{background-color:var(--calcite-color-foreground-2)}/*!@:host([number-button-type=vertical]) .number-button-item[data-adjustment=down]:hover calcite-icon*/[number-button-type=vertical].sc-calcite-input-number-h .number-button-item[data-adjustment=down].sc-calcite-input-number:hover calcite-icon.sc-calcite-input-number{color:var(--calcite-color-text-1)}/*!@:host([number-button-type=vertical]) .number-button-item[data-adjustment=up]:hover*/[number-button-type=vertical].sc-calcite-input-number-h .number-button-item[data-adjustment=up].sc-calcite-input-number:hover{background-color:var(--calcite-color-foreground-2)}/*!@:host([number-button-type=vertical]) .number-button-item[data-adjustment=up]:hover calcite-icon*/[number-button-type=vertical].sc-calcite-input-number-h .number-button-item[data-adjustment=up].sc-calcite-input-number:hover calcite-icon.sc-calcite-input-number{color:var(--calcite-color-text-1)}/*!@:host([number-button-type=vertical]) .number-button-item[data-adjustment=down]*/[number-button-type=vertical].sc-calcite-input-number-h .number-button-item[data-adjustment=down].sc-calcite-input-number{border-block-start-width:0px}/*!@.number-button-item*/.number-button-item.sc-calcite-input-number{max-block-size:50%;min-block-size:50%;pointer-events:initial;margin:0px;box-sizing:border-box;display:flex;cursor:pointer;align-items:center;align-self:center;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-foreground-1);padding-block:0px;padding-inline:0.5rem;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;border-inline-start-width:0px}/*!@.number-button-item calcite-icon*/.number-button-item.sc-calcite-input-number calcite-icon.sc-calcite-input-number{pointer-events:none;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.number-button-item:focus*/.number-button-item.sc-calcite-input-number:focus{background-color:var(--calcite-color-foreground-2)}/*!@.number-button-item:focus calcite-icon*/.number-button-item.sc-calcite-input-number:focus calcite-icon.sc-calcite-input-number{color:var(--calcite-color-text-1)}/*!@.number-button-item:active*/.number-button-item.sc-calcite-input-number:active{background-color:var(--calcite-color-foreground-3)}/*!@.number-button-item:disabled*/.number-button-item.sc-calcite-input-number:disabled{pointer-events:none}/*!@.wrapper*/.wrapper.sc-calcite-input-number{position:relative;display:flex;flex-direction:row;align-items:center}/*!@:host(.no-bottom-border) input*/.no-bottom-border.sc-calcite-input-number-h input.sc-calcite-input-number{border-block-end-width:0px}/*!@:host(.border-top-color-one) input*/.border-top-color-one.sc-calcite-input-number-h input.sc-calcite-input-number{border-block-start-color:var(--calcite-color-border-1)}/*!@input.inline-child*/input.inline-child.sc-calcite-input-number{background-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@input.inline-child .editing-enabled*/input.inline-child.sc-calcite-input-number .editing-enabled.sc-calcite-input-number{background-color:inherit}/*!@input.inline-child:not(.editing-enabled)*/input.inline-child.sc-calcite-input-number:not(.editing-enabled){display:flex;cursor:pointer;text-overflow:ellipsis;border-color:transparent;padding-inline-start:0}/*!@.validation-container*/.validation-container.sc-calcite-input-number{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}/*!@:host([scale=m]) .validation-container,\n:host([scale=l]) .validation-container*/[scale=m].sc-calcite-input-number-h .validation-container.sc-calcite-input-number,[scale=l].sc-calcite-input-number-h .validation-container.sc-calcite-input-number{padding-block-start:0.5rem}/*!@:host([scale=s]) .validation-container*/[scale=s].sc-calcite-input-number-h .validation-container.sc-calcite-input-number{padding-block-start:0.25rem}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-input-number-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([hidden])*/[hidden].sc-calcite-input-number-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-input-number{display:none}";

/**
 * @slot action - A slot for positioning a button next to the component.
 */
class InputNumber {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalInputNumberFocus = createEvent(this, "calciteInternalInputNumberFocus", 6);
        this.calciteInternalInputNumberBlur = createEvent(this, "calciteInternalInputNumberBlur", 6);
        this.calciteInputNumberInput = createEvent(this, "calciteInputNumberInput", 7);
        this.calciteInputNumberChange = createEvent(this, "calciteInputNumberChange", 6);
        this.previousValueOrigin = "initial";
        this.mutationObserver = createObserver();
        this.userChangedValue = false;
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.keyDownHandler = (event) => {
            if (this.readOnly || this.disabled) {
                return;
            }
            if (this.isClearable && event.key === "Escape") {
                this.clearInputValue(event);
                event.preventDefault();
            }
            if (event.key === "Enter" && !event.defaultPrevented) {
                if (submitForm(this)) {
                    event.preventDefault();
                }
            }
        };
        this.clearInputValue = (nativeEvent) => {
            this.setNumberValue({
                committing: true,
                nativeEvent,
                origin: "user",
                value: "",
            });
        };
        this.emitChangeIfUserModified = () => {
            if (this.previousValueOrigin === "user" && this.value !== this.previousEmittedNumberValue) {
                this.calciteInputNumberChange.emit();
                this.setPreviousEmittedNumberValue(this.value);
            }
        };
        this.inputNumberBlurHandler = () => {
            window.clearInterval(this.nudgeNumberValueIntervalId);
            this.calciteInternalInputNumberBlur.emit();
            this.emitChangeIfUserModified();
        };
        this.clickHandler = (event) => {
            if (this.disabled) {
                return;
            }
            const slottedActionEl = getSlotted(this.el, "action");
            if (event.target !== slottedActionEl) {
                this.setFocus();
            }
        };
        this.inputNumberFocusHandler = () => {
            this.calciteInternalInputNumberFocus.emit();
        };
        this.inputNumberInputHandler = (nativeEvent) => {
            if (this.disabled || this.readOnly) {
                return;
            }
            if (this.value === "Infinity" || this.value === "-Infinity") {
                return;
            }
            const value = nativeEvent.target.value;
            numberStringFormatter.numberFormatOptions = {
                locale: this.effectiveLocale,
                numberingSystem: this.numberingSystem,
                useGrouping: this.groupSeparator,
            };
            const delocalizedValue = numberStringFormatter.delocalize(value);
            if (nativeEvent.inputType === "insertFromPaste") {
                if (!isValidNumber(delocalizedValue) ||
                    (this.integer && (delocalizedValue.includes("e") || delocalizedValue.includes(".")))) {
                    nativeEvent.preventDefault();
                }
                this.setNumberValue({
                    nativeEvent,
                    origin: "user",
                    value: parseNumberString(delocalizedValue),
                });
                this.childNumberEl.value = this.displayedValue;
            }
            else {
                this.setNumberValue({
                    nativeEvent,
                    origin: "user",
                    value: delocalizedValue,
                });
            }
        };
        this.inputNumberKeyDownHandler = (event) => {
            if (this.disabled || this.readOnly) {
                return;
            }
            if (this.value === "Infinity" || this.value === "-Infinity") {
                event.preventDefault();
                if (event.key === "Backspace" || event.key === "Delete") {
                    this.clearInputValue(event);
                }
                return;
            }
            if (event.key === "ArrowUp") {
                /* prevent default behavior of moving cursor to the beginning of the input when holding down ArrowUp */
                event.preventDefault();
                this.nudgeNumberValue("up", event);
                return;
            }
            if (event.key === "ArrowDown") {
                this.nudgeNumberValue("down", event);
                return;
            }
            const supportedKeys = [
                ...numberKeys,
                "ArrowLeft",
                "ArrowRight",
                "Backspace",
                "Delete",
                "Enter",
                "Escape",
                "Tab",
            ];
            if (event.altKey || event.ctrlKey || event.metaKey) {
                return;
            }
            const isShiftTabEvent = event.shiftKey && event.key === "Tab";
            if (supportedKeys.includes(event.key) || isShiftTabEvent) {
                if (event.key === "Enter") {
                    this.emitChangeIfUserModified();
                }
                return;
            }
            numberStringFormatter.numberFormatOptions = {
                locale: this.effectiveLocale,
                numberingSystem: this.numberingSystem,
                useGrouping: this.groupSeparator,
            };
            if (event.key === numberStringFormatter.decimal && !this.integer) {
                if (!this.value && !this.childNumberEl.value) {
                    return;
                }
                if (this.value && this.childNumberEl.value.indexOf(numberStringFormatter.decimal) === -1) {
                    return;
                }
            }
            if (/[eE]/.test(event.key) && !this.integer) {
                if (!this.value && !this.childNumberEl.value) {
                    return;
                }
                if (this.value && !/[eE]/.test(this.childNumberEl.value)) {
                    return;
                }
            }
            if (event.key === "-") {
                if (!this.value && !this.childNumberEl.value) {
                    return;
                }
                if (this.value && this.childNumberEl.value.split("-").length <= 2) {
                    return;
                }
            }
            event.preventDefault();
        };
        this.nudgeNumberValue = (direction, nativeEvent) => {
            if (nativeEvent instanceof KeyboardEvent && nativeEvent.repeat) {
                return;
            }
            const inputMax = this.maxString ? parseFloat(this.maxString) : null;
            const inputMin = this.minString ? parseFloat(this.minString) : null;
            const valueNudgeDelayInMs = 150;
            this.incrementOrDecrementNumberValue(direction, inputMax, inputMin, nativeEvent);
            if (this.nudgeNumberValueIntervalId) {
                window.clearInterval(this.nudgeNumberValueIntervalId);
            }
            let firstValueNudge = true;
            this.nudgeNumberValueIntervalId = window.setInterval(() => {
                if (firstValueNudge) {
                    firstValueNudge = false;
                    return;
                }
                this.incrementOrDecrementNumberValue(direction, inputMax, inputMin, nativeEvent);
            }, valueNudgeDelayInMs);
        };
        this.nudgeButtonPointerUpHandler = (event) => {
            if (!isPrimaryPointerButton(event)) {
                return;
            }
            window.clearInterval(this.nudgeNumberValueIntervalId);
        };
        this.nudgeButtonPointerOutHandler = () => {
            window.clearInterval(this.nudgeNumberValueIntervalId);
        };
        this.nudgeButtonPointerDownHandler = (event) => {
            if (!isPrimaryPointerButton(event)) {
                return;
            }
            event.preventDefault();
            const direction = event.target.dataset.adjustment;
            if (!this.disabled) {
                this.nudgeNumberValue(direction, event);
            }
        };
        this.onHiddenFormInputInput = (event) => {
            if (event.target.name === this.name) {
                this.setNumberValue({
                    value: event.target.value,
                    origin: "direct",
                });
            }
            this.setFocus();
            event.stopPropagation();
        };
        this.setChildNumberElRef = (el) => {
            this.childNumberEl = el;
        };
        this.setInputNumberValue = (newInputValue) => {
            if (!this.childNumberEl) {
                return;
            }
            this.childNumberEl.value = newInputValue;
        };
        this.setPreviousEmittedNumberValue = (value) => {
            this.previousEmittedNumberValue = this.normalizeValue(value);
        };
        this.setPreviousNumberValue = (value) => {
            this.previousValue = this.normalizeValue(value);
        };
        this.setNumberValue = ({ committing = false, nativeEvent, origin, previousValue, value, }) => {
            numberStringFormatter.numberFormatOptions = {
                locale: this.effectiveLocale,
                numberingSystem: this.numberingSystem,
                useGrouping: this.groupSeparator,
            };
            const isValueDeleted = this.previousValue?.length > value.length || this.value?.length > value.length;
            const valueHandleInteger = this.integer ? value.replace(/[e.]/g, "") : value;
            const hasTrailingDecimalSeparator = valueHandleInteger.charAt(valueHandleInteger.length - 1) === ".";
            const sanitizedValue = hasTrailingDecimalSeparator && isValueDeleted
                ? valueHandleInteger
                : sanitizeNumberString(valueHandleInteger);
            const newValue = value && !sanitizedValue
                ? isValidNumber(this.previousValue)
                    ? this.previousValue
                    : ""
                : sanitizedValue;
            let newLocalizedValue = numberStringFormatter.localize(newValue);
            if (origin !== "connected" && !hasTrailingDecimalSeparator) {
                newLocalizedValue = addLocalizedTrailingDecimalZeros(newLocalizedValue, newValue, numberStringFormatter);
            }
            // adds localized trailing decimal separator
            this.displayedValue =
                hasTrailingDecimalSeparator && isValueDeleted
                    ? `${newLocalizedValue}${numberStringFormatter.decimal}`
                    : newLocalizedValue;
            this.setPreviousNumberValue(previousValue ?? this.value);
            this.previousValueOrigin = origin;
            this.userChangedValue = origin === "user" && this.value !== newValue;
            // don't sanitize the start of negative/decimal numbers, but
            // don't set value to an invalid number
            this.value = ["-", "."].includes(newValue) ? "" : newValue;
            if (origin === "direct") {
                this.setInputNumberValue(newLocalizedValue);
                this.setPreviousEmittedNumberValue(newLocalizedValue);
            }
            if (nativeEvent) {
                const calciteInputNumberInputEvent = this.calciteInputNumberInput.emit();
                if (calciteInputNumberInputEvent.defaultPrevented) {
                    this.value = this.previousValue;
                    this.displayedValue = numberStringFormatter.localize(this.previousValue);
                }
                else if (committing) {
                    this.emitChangeIfUserModified();
                }
            }
        };
        this.inputNumberKeyUpHandler = () => {
            window.clearInterval(this.nudgeNumberValueIntervalId);
        };
        this.alignment = "start";
        this.autofocus = false;
        this.clearable = false;
        this.disabled = false;
        this.form = undefined;
        this.groupSeparator = false;
        this.icon = undefined;
        this.iconFlipRtl = false;
        this.integer = false;
        this.label = undefined;
        this.loading = false;
        this.numberingSystem = undefined;
        this.localeFormat = false;
        this.max = undefined;
        this.min = undefined;
        this.maxLength = undefined;
        this.minLength = undefined;
        this.validationMessage = undefined;
        this.validationIcon = undefined;
        this.name = undefined;
        this.numberButtonType = "vertical";
        this.placeholder = undefined;
        this.prefixText = undefined;
        this.readOnly = false;
        this.required = false;
        this.scale = "m";
        this.status = "idle";
        this.step = undefined;
        this.autocomplete = undefined;
        this.inputMode = "decimal";
        this.enterKeyHint = undefined;
        this.suffixText = undefined;
        this.editingEnabled = false;
        this.value = "";
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.effectiveLocale = "";
        this.defaultMessages = undefined;
        this.displayedValue = undefined;
        this.slottedActionElDisabledInternally = false;
    }
    disabledWatcher() {
        this.setDisabledAction();
    }
    /** watcher to update number-to-string for max */
    maxWatcher() {
        this.maxString = this.max?.toString() || null;
    }
    /** watcher to update number-to-string for min */
    minWatcher() {
        this.minString = this.min?.toString() || null;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    valueWatcher(newValue, previousValue) {
        if (!this.userChangedValue) {
            if (newValue === "Infinity" || newValue === "-Infinity") {
                this.displayedValue = newValue;
                this.previousEmittedNumberValue = newValue;
                return;
            }
            this.setNumberValue({
                origin: "direct",
                previousValue,
                value: newValue == null || newValue == ""
                    ? ""
                    : isValidNumber(newValue)
                        ? newValue
                        : this.previousValue || "",
            });
            this.warnAboutInvalidNumberValue(newValue);
        }
        this.userChangedValue = false;
    }
    updateRequestedIcon() {
        this.requestedIcon = setRequestedIcon({}, this.icon, "number");
    }
    get isClearable() {
        return this.clearable && this.value.length > 0;
    }
    effectiveLocaleWatcher(locale) {
        updateMessages(this);
        numberStringFormatter.numberFormatOptions = {
            locale,
            numberingSystem: this.numberingSystem,
            useGrouping: false,
        };
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
        this.inlineEditableEl = this.el.closest("calcite-inline-editable");
        if (this.inlineEditableEl) {
            this.editingEnabled = this.inlineEditableEl.editingEnabled || false;
        }
        connectLabel(this);
        connectForm(this);
        this.setPreviousEmittedNumberValue(this.value);
        this.setPreviousNumberValue(this.value);
        this.warnAboutInvalidNumberValue(this.value);
        if (this.value === "Infinity" || this.value === "-Infinity") {
            this.displayedValue = this.value;
            this.previousEmittedNumberValue = this.value;
        }
        else {
            this.setNumberValue({
                origin: "connected",
                value: isValidNumber(this.value) ? this.value : "",
            });
        }
        this.mutationObserver?.observe(this.el, { childList: true });
        this.setDisabledAction();
        this.el.addEventListener(internalHiddenInputInputEvent, this.onHiddenFormInputInput);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        this.mutationObserver?.disconnect();
        this.el.removeEventListener(internalHiddenInputInputEvent, this.onHiddenFormInputInput);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        this.maxString = this.max?.toString();
        this.minString = this.min?.toString();
        this.requestedIcon = setRequestedIcon({}, this.icon, "number");
        await setUpMessages(this);
    }
    componentShouldUpdate(newValue, oldValue, property) {
        if (property === "value" && newValue && !isValidNumber(newValue)) {
            this.setNumberValue({
                origin: "reset",
                value: oldValue,
            });
            return false;
        }
        return true;
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.childNumberEl?.focus();
    }
    /** Selects the text of the component's `value`. */
    async selectText() {
        this.childNumberEl?.select();
    }
    onLabelClick() {
        this.setFocus();
    }
    incrementOrDecrementNumberValue(direction, inputMax, inputMin, nativeEvent) {
        const { value } = this;
        if (value === "Infinity" || value === "-Infinity") {
            return;
        }
        const adjustment = direction === "up" ? 1 : -1;
        const stepHandleInteger = this.integer && this.step !== "any" ? Math.round(this.step) : this.step;
        const inputStep = stepHandleInteger === "any" ? 1 : Math.abs(stepHandleInteger || 1);
        const inputVal = new BigDecimal(value !== "" ? value : "0");
        const nudgedValue = inputVal.add(`${inputStep * adjustment}`);
        const nudgedValueBelowInputMin = () => typeof inputMin === "number" &&
            !isNaN(inputMin) &&
            nudgedValue.subtract(`${inputMin}`).isNegative;
        const nudgedValueAboveInputMax = () => typeof inputMax === "number" &&
            !isNaN(inputMax) &&
            !nudgedValue.subtract(`${inputMax}`).isNegative;
        const finalValue = nudgedValueBelowInputMin()
            ? `${inputMin}`
            : nudgedValueAboveInputMax()
                ? `${inputMax}`
                : nudgedValue.toString();
        this.setNumberValue({
            committing: true,
            nativeEvent,
            origin: "user",
            value: finalValue,
        });
    }
    syncHiddenFormInput(input) {
        syncHiddenFormInput("number", this, input);
    }
    setDisabledAction() {
        const slottedActionEl = getSlotted(this.el, "action");
        if (!slottedActionEl) {
            return;
        }
        if (this.disabled) {
            if (slottedActionEl.getAttribute("disabled") == null) {
                this.slottedActionElDisabledInternally = true;
            }
            slottedActionEl.setAttribute("disabled", "");
        }
        else if (this.slottedActionElDisabledInternally) {
            slottedActionEl.removeAttribute("disabled");
            this.slottedActionElDisabledInternally = false;
        }
    }
    normalizeValue(value) {
        return isValidNumber(value) ? value : "";
    }
    warnAboutInvalidNumberValue(value) {
        if (value && !isValidNumber(value)) {
            console.warn(`The specified value "${value}" cannot be parsed, or is out of range.`);
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const dir = getElementDir(this.el);
        const loader = (hAsync("div", { class: CSS$P.loader }, hAsync("calcite-progress", { label: this.messages.loading, type: "indeterminate" })));
        const inputClearButton = (hAsync("button", { "aria-label": this.messages.clear, class: CSS$P.clearButton, disabled: this.disabled || this.readOnly, onClick: this.clearInputValue, tabIndex: -1, type: "button" }, hAsync("calcite-icon", { icon: "x", scale: getIconScale(this.scale) })));
        const iconEl = (hAsync("calcite-icon", { class: CSS$P.inputIcon, flipRtl: this.iconFlipRtl, icon: this.requestedIcon, scale: getIconScale(this.scale) }));
        const isHorizontalNumberButton = this.numberButtonType === "horizontal";
        const numberButtonsHorizontalUp = (hAsync("button", { "aria-hidden": "true", class: {
                [CSS$P.numberButtonItem]: true,
                [CSS$P.buttonItemHorizontal]: isHorizontalNumberButton,
            }, "data-adjustment": "up", disabled: this.disabled || this.readOnly, onPointerDown: this.nudgeButtonPointerDownHandler, onPointerOut: this.nudgeButtonPointerOutHandler, onPointerUp: this.nudgeButtonPointerUpHandler, tabIndex: -1, type: "button" }, hAsync("calcite-icon", { icon: "chevron-up", scale: getIconScale(this.scale) })));
        const numberButtonsHorizontalDown = (hAsync("button", { "aria-hidden": "true", class: {
                [CSS$P.numberButtonItem]: true,
                [CSS$P.buttonItemHorizontal]: isHorizontalNumberButton,
            }, "data-adjustment": "down", disabled: this.disabled || this.readOnly, onPointerDown: this.nudgeButtonPointerDownHandler, onPointerOut: this.nudgeButtonPointerOutHandler, onPointerUp: this.nudgeButtonPointerUpHandler, tabIndex: -1, type: "button" }, hAsync("calcite-icon", { icon: "chevron-down", scale: getIconScale(this.scale) })));
        const numberButtonsVertical = (hAsync("div", { class: CSS$P.numberButtonWrapper }, numberButtonsHorizontalUp, numberButtonsHorizontalDown));
        const prefixText = hAsync("div", { class: CSS$P.prefix }, this.prefixText);
        const suffixText = hAsync("div", { class: CSS$P.suffix }, this.suffixText);
        const childEl = (hAsync("input", { "aria-label": getLabelText(this), autocomplete: this.autocomplete, autofocus: this.autofocus ? true : null, defaultValue: this.defaultValue, disabled: this.disabled ? true : null, enterKeyHint: this.enterKeyHint, inputMode: this.inputMode, key: "localized-input", maxLength: this.maxLength, minLength: this.minLength, name: undefined, onBlur: this.inputNumberBlurHandler, onFocus: this.inputNumberFocusHandler, onInput: this.inputNumberInputHandler, onKeyDown: this.inputNumberKeyDownHandler, onKeyUp: this.inputNumberKeyUpHandler, placeholder: this.placeholder || "", readOnly: this.readOnly, type: "text", value: this.displayedValue,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setChildNumberElRef }));
        return (hAsync(Host, { onClick: this.clickHandler, onKeyDown: this.keyDownHandler }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: { [CSS$P.inputWrapper]: true, [CSS_UTILITY.rtl]: dir === "rtl" } }, this.numberButtonType === "horizontal" && !this.readOnly
            ? numberButtonsHorizontalDown
            : null, this.prefixText ? prefixText : null, hAsync("div", { class: CSS$P.wrapper }, childEl, this.isClearable ? inputClearButton : null, this.requestedIcon ? iconEl : null, this.loading ? loader : null), hAsync("div", { class: CSS$P.actionWrapper }, hAsync("slot", { name: SLOTS$k.action })), this.numberButtonType === "vertical" && !this.readOnly ? numberButtonsVertical : null, this.suffixText ? suffixText : null, this.numberButtonType === "horizontal" && !this.readOnly
            ? numberButtonsHorizontalUp
            : null, hAsync(HiddenFormInputSlot, { component: this })), this.validationMessage && this.status === "invalid" ? (hAsync(Validation, { icon: this.validationIcon, message: this.validationMessage, scale: this.scale, status: this.status })) : null)));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "disabled": ["disabledWatcher"],
        "max": ["maxWatcher"],
        "min": ["minWatcher"],
        "messageOverrides": ["onMessagesChange"],
        "value": ["valueWatcher"],
        "icon": ["updateRequestedIcon"],
        "effectiveLocale": ["effectiveLocaleWatcher"]
    }; }
    static get style() { return inputNumberCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-input-number",
        "$members$": {
            "alignment": [513],
            "autofocus": [516],
            "clearable": [516],
            "disabled": [516],
            "form": [513],
            "groupSeparator": [516, "group-separator"],
            "icon": [520],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "integer": [4],
            "label": [1],
            "loading": [516],
            "numberingSystem": [513, "numbering-system"],
            "localeFormat": [4, "locale-format"],
            "max": [514],
            "min": [514],
            "maxLength": [514, "max-length"],
            "minLength": [514, "min-length"],
            "validationMessage": [1, "validation-message"],
            "validationIcon": [520, "validation-icon"],
            "name": [513],
            "numberButtonType": [513, "number-button-type"],
            "placeholder": [1],
            "prefixText": [1, "prefix-text"],
            "readOnly": [516, "read-only"],
            "required": [516],
            "scale": [513],
            "status": [513],
            "step": [520],
            "autocomplete": [1],
            "inputMode": [1, "input-mode"],
            "enterKeyHint": [1, "enter-key-hint"],
            "suffixText": [1, "suffix-text"],
            "editingEnabled": [1540, "editing-enabled"],
            "value": [1025],
            "messages": [1040],
            "messageOverrides": [1040],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "displayedValue": [32],
            "slottedActionElDisabledInternally": [32],
            "setFocus": [64],
            "selectText": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["alignment", "alignment"], ["autofocus", "autofocus"], ["clearable", "clearable"], ["disabled", "disabled"], ["form", "form"], ["groupSeparator", "group-separator"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["loading", "loading"], ["numberingSystem", "numbering-system"], ["max", "max"], ["min", "min"], ["maxLength", "max-length"], ["minLength", "min-length"], ["validationIcon", "validation-icon"], ["name", "name"], ["numberButtonType", "number-button-type"], ["readOnly", "read-only"], ["required", "required"], ["scale", "scale"], ["status", "status"], ["step", "step"], ["editingEnabled", "editing-enabled"]]
    }; }
}

const CSS$O = {
    loader: "loader",
    clearButton: "clear-button",
    editingEnabled: "editing-enabled",
    inlineChild: "inline-child",
    inputIcon: "icon",
    prefix: "prefix",
    suffix: "suffix",
    wrapper: "element-wrapper",
    inputWrapper: "wrapper",
    actionWrapper: "action-wrapper",
    resizeIconWrapper: "resize-icon-wrapper",
};
const SLOTS$j = {
    action: "action",
};

const inputTextCss = "/*!@:host([disabled])*/[disabled].sc-calcite-input-text-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-input-text-h *.sc-calcite-input-text,.sc-calcite-input-text-h[disabled].sc-calcite-input-text-s>*,.sc-calcite-input-text-h[disabled] .sc-calcite-input-text-s>*{pointer-events:none}/*!@:host*/.sc-calcite-input-text-h{display:block}/*!@:host([scale=s]) input*/[scale=s].sc-calcite-input-text-h input.sc-calcite-input-text{padding-inline-start:0.5rem;padding-inline-end:var(--calcite-internal-input-text-input-padding-inline-end, 0.5rem)}/*!@:host([scale=s]) input, :host([scale=s]) .prefix, :host([scale=s]) .suffix*/[scale=s].sc-calcite-input-text-h input.sc-calcite-input-text,[scale=s].sc-calcite-input-text-h .prefix.sc-calcite-input-text,[scale=s].sc-calcite-input-text-h .suffix.sc-calcite-input-text{block-size:1.5rem;font-size:var(--calcite-font-size--2);line-height:1rem}/*!@:host([scale=s]) .prefix, :host([scale=s]) .suffix*/[scale=s].sc-calcite-input-text-h .prefix.sc-calcite-input-text,[scale=s].sc-calcite-input-text-h .suffix.sc-calcite-input-text{padding-inline:0.5rem}/*!@:host([scale=s]) .action-wrapper calcite-button, :host([scale=s]) .action-wrapper calcite-button button*/[scale=s].sc-calcite-input-text-h .action-wrapper.sc-calcite-input-text calcite-button.sc-calcite-input-text,[scale=s].sc-calcite-input-text-h .action-wrapper.sc-calcite-input-text calcite-button.sc-calcite-input-text button.sc-calcite-input-text{block-size:1.5rem}/*!@:host([scale=s]) .clear-button*/[scale=s].sc-calcite-input-text-h .clear-button.sc-calcite-input-text{min-block-size:1.5rem;min-inline-size:1.5rem}/*!@:host([scale=m]) input*/[scale=m].sc-calcite-input-text-h input.sc-calcite-input-text{padding-inline-start:0.75rem;padding-inline-end:var(--calcite-internal-input-text-input-padding-inline-end, 0.75rem)}/*!@:host([scale=m]) input, :host([scale=m]) .prefix, :host([scale=m]) .suffix*/[scale=m].sc-calcite-input-text-h input.sc-calcite-input-text,[scale=m].sc-calcite-input-text-h .prefix.sc-calcite-input-text,[scale=m].sc-calcite-input-text-h .suffix.sc-calcite-input-text{block-size:2rem;font-size:var(--calcite-font-size--1);line-height:1rem}/*!@:host([scale=m]) .prefix, :host([scale=m]) .suffix*/[scale=m].sc-calcite-input-text-h .prefix.sc-calcite-input-text,[scale=m].sc-calcite-input-text-h .suffix.sc-calcite-input-text{padding-inline:0.75rem}/*!@:host([scale=m]) .action-wrapper calcite-button, :host([scale=m]) .action-wrapper calcite-button button*/[scale=m].sc-calcite-input-text-h .action-wrapper.sc-calcite-input-text calcite-button.sc-calcite-input-text,[scale=m].sc-calcite-input-text-h .action-wrapper.sc-calcite-input-text calcite-button.sc-calcite-input-text button.sc-calcite-input-text{block-size:2rem}/*!@:host([scale=m]) .clear-button*/[scale=m].sc-calcite-input-text-h .clear-button.sc-calcite-input-text{min-block-size:2rem;min-inline-size:2rem}/*!@:host([scale=l]) input*/[scale=l].sc-calcite-input-text-h input.sc-calcite-input-text{padding-inline-start:1rem;padding-inline-end:var(--calcite-internal-input-text-input-padding-inline-end, 1rem)}/*!@:host([scale=l]) input, :host([scale=l]) .prefix, :host([scale=l]) .suffix*/[scale=l].sc-calcite-input-text-h input.sc-calcite-input-text,[scale=l].sc-calcite-input-text-h .prefix.sc-calcite-input-text,[scale=l].sc-calcite-input-text-h .suffix.sc-calcite-input-text{block-size:2.75rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host([scale=l]) .prefix, :host([scale=l]) .suffix*/[scale=l].sc-calcite-input-text-h .prefix.sc-calcite-input-text,[scale=l].sc-calcite-input-text-h .suffix.sc-calcite-input-text{padding-inline:1rem}/*!@:host([scale=l]) .action-wrapper calcite-button, :host([scale=l]) .action-wrapper calcite-button button*/[scale=l].sc-calcite-input-text-h .action-wrapper.sc-calcite-input-text calcite-button.sc-calcite-input-text,[scale=l].sc-calcite-input-text-h .action-wrapper.sc-calcite-input-text calcite-button.sc-calcite-input-text button.sc-calcite-input-text{block-size:2.75rem}/*!@:host([scale=l]) .clear-button*/[scale=l].sc-calcite-input-text-h .clear-button.sc-calcite-input-text{min-block-size:2.75rem;min-inline-size:2.75rem}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-input-text-h[disabled] .sc-calcite-input-text-s>[calcite-hydrated][disabled],[disabled].sc-calcite-input-text-h [calcite-hydrated][disabled].sc-calcite-input-text{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-input-text{display:contents}/*!@input*/input.sc-calcite-input-text{transition:var(--calcite-animation-timing), block-size 0, outline-offset 0s;-webkit-appearance:none;position:relative;margin:0px;box-sizing:border-box;display:flex;max-block-size:100%;inline-size:100%;max-inline-size:100%;flex:1 1 0%;text-overflow:ellipsis;border-radius:0px;background-color:var(--calcite-color-foreground-1);font-family:inherit;font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-1)}/*!@input:placeholder-shown*/input.sc-calcite-input-text:placeholder-shown{text-overflow:ellipsis}/*!@input*/input.sc-calcite-input-text{border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);color:var(--calcite-color-text-1)}/*!@input::placeholder, input:-ms-input-placeholder, input::-ms-input-placeholder*/input.sc-calcite-input-text::placeholder,input.sc-calcite-input-text:-ms-input-placeholder,input.sc-calcite-input-text::-ms-input-placeholder{font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-3)}/*!@input:focus*/input.sc-calcite-input-text:focus{border-color:var(--calcite-color-brand);color:var(--calcite-color-text-1)}/*!@input[readonly]*/input[readonly].sc-calcite-input-text{background-color:var(--calcite-color-background);font-weight:var(--calcite-font-weight-medium)}/*!@input[readonly]:focus*/input[readonly].sc-calcite-input-text:focus{color:var(--calcite-color-text-1)}/*!@calcite-icon*/calcite-icon.sc-calcite-input-text{color:var(--calcite-color-text-3)}/*!@input*/input.sc-calcite-input-text{outline-color:transparent}/*!@input:focus*/input.sc-calcite-input-text:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([status=invalid]) input*/[status=invalid].sc-calcite-input-text-h input.sc-calcite-input-text{border-color:var(--calcite-color-status-danger)}/*!@:host([status=invalid]) input:focus*/[status=invalid].sc-calcite-input-text-h input.sc-calcite-input-text:focus{outline:2px solid var(--calcite-color-status-danger);outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([scale=s]) .icon*/[scale=s].sc-calcite-input-text-h .icon.sc-calcite-input-text{inset-inline-start:0.5rem}/*!@:host([scale=m]) .icon*/[scale=m].sc-calcite-input-text-h .icon.sc-calcite-input-text{inset-inline-start:0.75rem}/*!@:host([scale=l]) .icon*/[scale=l].sc-calcite-input-text-h .icon.sc-calcite-input-text{inset-inline-start:1rem}/*!@:host([icon][scale=s]) input*/[icon][scale=s].sc-calcite-input-text-h input.sc-calcite-input-text{padding-inline-start:2rem}/*!@:host([icon][scale=m]) input*/[icon][scale=m].sc-calcite-input-text-h input.sc-calcite-input-text{padding-inline-start:2.5rem}/*!@:host([icon][scale=l]) input*/[icon][scale=l].sc-calcite-input-text-h input.sc-calcite-input-text{padding-inline-start:3.5rem}/*!@.element-wrapper*/.element-wrapper.sc-calcite-input-text{position:relative;order:3;display:inline-flex;flex:1 1 0%;align-items:center}/*!@.icon*/.icon.sc-calcite-input-text{pointer-events:none;position:absolute;z-index:var(--calcite-z-index);display:block;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@input[type=text]::-ms-clear,\ninput[type=text]::-ms-reveal*/input[type=text].sc-calcite-input-text::-ms-clear,input[type=text].sc-calcite-input-text::-ms-reveal{display:none;block-size:0px;inline-size:0px}/*!@.clear-button*/.clear-button.sc-calcite-input-text{pointer-events:initial;order:4;margin:0px;box-sizing:border-box;display:flex;min-block-size:100%;cursor:pointer;align-items:center;justify-content:center;align-self:stretch;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-foreground-1);outline-color:transparent;border-inline-start-width:0px}/*!@.clear-button:hover*/.clear-button.sc-calcite-input-text:hover{background-color:var(--calcite-color-foreground-2);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.clear-button:hover calcite-icon*/.clear-button.sc-calcite-input-text:hover calcite-icon.sc-calcite-input-text{color:var(--calcite-color-text-1);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.clear-button:active*/.clear-button.sc-calcite-input-text:active{background-color:var(--calcite-color-foreground-3)}/*!@.clear-button:active calcite-icon*/.clear-button.sc-calcite-input-text:active calcite-icon.sc-calcite-input-text{color:var(--calcite-color-text-1)}/*!@.clear-button:focus*/.clear-button.sc-calcite-input-text:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.clear-button:disabled*/.clear-button.sc-calcite-input-text:disabled{opacity:var(--calcite-opacity-disabled)}/*!@.loader*/.loader.sc-calcite-input-text{inset-block-start:1px;inset-inline:1px;pointer-events:none;position:absolute;display:block}/*!@.action-wrapper*/.action-wrapper.sc-calcite-input-text{order:7;display:flex}/*!@.prefix,\n.suffix*/.prefix.sc-calcite-input-text,.suffix.sc-calcite-input-text{box-sizing:border-box;display:flex;block-size:auto;min-block-size:100%;-webkit-user-select:none;user-select:none;align-content:center;align-items:center;overflow-wrap:break-word;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-background);font-weight:var(--calcite-font-weight-medium);line-height:1;color:var(--calcite-color-text-2)}/*!@.prefix*/.prefix.sc-calcite-input-text{order:2;border-inline-end-width:0px}/*!@.suffix*/.suffix.sc-calcite-input-text{order:5;border-inline-start-width:0px}/*!@:host([alignment=start]) input*/[alignment=start].sc-calcite-input-text-h input.sc-calcite-input-text{text-align:start}/*!@:host([alignment=end]) input*/[alignment=end].sc-calcite-input-text-h input.sc-calcite-input-text{text-align:end}/*!@.wrapper*/.wrapper.sc-calcite-input-text{position:relative;display:flex;flex-direction:row;align-items:center}/*!@:host(.no-bottom-border) input*/.no-bottom-border.sc-calcite-input-text-h input.sc-calcite-input-text{border-block-end-width:0px}/*!@:host(.border-top-color-one) input*/.border-top-color-one.sc-calcite-input-text-h input.sc-calcite-input-text{border-block-start-color:var(--calcite-color-border-1)}/*!@input.inline-child*/input.inline-child.sc-calcite-input-text{background-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@input.inline-child .editing-enabled*/input.inline-child.sc-calcite-input-text .editing-enabled.sc-calcite-input-text{background-color:inherit}/*!@input.inline-child:not(.editing-enabled)*/input.inline-child.sc-calcite-input-text:not(.editing-enabled){display:flex;cursor:pointer;text-overflow:ellipsis;border-color:transparent;padding-inline-start:0}/*!@.validation-container*/.validation-container.sc-calcite-input-text{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}/*!@:host([scale=m]) .validation-container,\n:host([scale=l]) .validation-container*/[scale=m].sc-calcite-input-text-h .validation-container.sc-calcite-input-text,[scale=l].sc-calcite-input-text-h .validation-container.sc-calcite-input-text{padding-block-start:0.5rem}/*!@:host([scale=s]) .validation-container*/[scale=s].sc-calcite-input-text-h .validation-container.sc-calcite-input-text{padding-block-start:0.25rem}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-input-text-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([hidden])*/[hidden].sc-calcite-input-text-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-input-text{display:none}";

/**
 * @slot action - A slot for positioning a button next to the component.
 */
class InputText {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalInputTextFocus = createEvent(this, "calciteInternalInputTextFocus", 7);
        this.calciteInternalInputTextBlur = createEvent(this, "calciteInternalInputTextBlur", 7);
        this.calciteInputTextInput = createEvent(this, "calciteInputTextInput", 7);
        this.calciteInputTextChange = createEvent(this, "calciteInputTextChange", 7);
        this.previousValueOrigin = "initial";
        this.mutationObserver = createObserver();
        this.userChangedValue = false;
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.keyDownHandler = (event) => {
            if (this.readOnly || this.disabled) {
                return;
            }
            if (this.isClearable && event.key === "Escape") {
                this.clearInputTextValue(event);
                event.preventDefault();
            }
            if (event.key === "Enter" && !event.defaultPrevented) {
                if (submitForm(this)) {
                    event.preventDefault();
                }
            }
        };
        this.clearInputTextValue = (nativeEvent) => {
            this.setValue({
                committing: true,
                nativeEvent,
                origin: "user",
                value: "",
            });
        };
        this.emitChangeIfUserModified = () => {
            if (this.previousValueOrigin === "user" && this.value !== this.previousEmittedValue) {
                this.calciteInputTextChange.emit();
                this.setPreviousEmittedValue(this.value);
            }
        };
        this.inputTextBlurHandler = () => {
            this.calciteInternalInputTextBlur.emit({
                element: this.childEl,
                value: this.value,
            });
            this.emitChangeIfUserModified();
        };
        this.clickHandler = (event) => {
            if (this.disabled) {
                return;
            }
            const slottedActionEl = getSlotted(this.el, "action");
            if (event.target !== slottedActionEl) {
                this.setFocus();
            }
        };
        this.inputTextFocusHandler = () => {
            this.calciteInternalInputTextFocus.emit({
                element: this.childEl,
                value: this.value,
            });
        };
        this.inputTextInputHandler = (nativeEvent) => {
            if (this.disabled || this.readOnly) {
                return;
            }
            this.setValue({
                nativeEvent,
                origin: "user",
                value: nativeEvent.target.value,
            });
        };
        this.inputTextKeyDownHandler = (event) => {
            if (this.disabled || this.readOnly) {
                return;
            }
            if (event.key === "Enter") {
                this.emitChangeIfUserModified();
            }
        };
        this.onHiddenFormInputInput = (event) => {
            if (event.target.name === this.name) {
                this.setValue({
                    value: event.target.value,
                    origin: "direct",
                });
            }
            this.setFocus();
            event.stopPropagation();
        };
        this.setChildElRef = (el) => {
            this.childEl = el;
        };
        this.setInputValue = (newInputValue) => {
            if (!this.childEl) {
                return;
            }
            this.childEl.value = newInputValue;
        };
        this.setPreviousEmittedValue = (value) => {
            this.previousEmittedValue = value;
        };
        this.setPreviousValue = (value) => {
            this.previousValue = value;
        };
        this.setValue = ({ committing = false, nativeEvent, origin, previousValue, value, }) => {
            this.setPreviousValue(previousValue ?? this.value);
            this.previousValueOrigin = origin;
            this.userChangedValue = origin === "user" && value !== this.value;
            this.value = value;
            if (origin === "direct") {
                this.setInputValue(value);
                this.setPreviousEmittedValue(value);
            }
            if (nativeEvent) {
                const calciteInputTextInputEvent = this.calciteInputTextInput.emit();
                if (calciteInputTextInputEvent.defaultPrevented) {
                    this.value = this.previousValue;
                }
                else if (committing) {
                    this.emitChangeIfUserModified();
                }
            }
        };
        this.alignment = "start";
        this.autofocus = false;
        this.clearable = false;
        this.disabled = false;
        this.form = undefined;
        this.icon = undefined;
        this.iconFlipRtl = false;
        this.label = undefined;
        this.loading = false;
        this.maxLength = undefined;
        this.minLength = undefined;
        this.validationMessage = undefined;
        this.validationIcon = undefined;
        this.name = undefined;
        this.placeholder = undefined;
        this.prefixText = undefined;
        this.readOnly = false;
        this.required = false;
        this.scale = "m";
        this.status = "idle";
        this.autocomplete = undefined;
        this.inputMode = "text";
        this.enterKeyHint = undefined;
        this.pattern = undefined;
        this.suffixText = undefined;
        this.editingEnabled = false;
        this.value = "";
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.effectiveLocale = undefined;
        this.defaultMessages = undefined;
        this.slottedActionElDisabledInternally = false;
    }
    disabledWatcher() {
        this.setDisabledAction();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    valueWatcher(newValue, previousValue) {
        if (!this.userChangedValue) {
            this.setValue({
                origin: "direct",
                previousValue,
                value: !newValue ? "" : newValue,
            });
        }
        this.userChangedValue = false;
    }
    updateRequestedIcon() {
        this.requestedIcon = setRequestedIcon({}, this.icon, "text");
    }
    get isClearable() {
        return this.clearable && this.value.length > 0;
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
        this.inlineEditableEl = this.el.closest("calcite-inline-editable");
        if (this.inlineEditableEl) {
            this.editingEnabled = this.inlineEditableEl.editingEnabled || false;
        }
        this.setPreviousEmittedValue(this.value);
        this.setPreviousValue(this.value);
        connectLabel(this);
        connectForm(this);
        this.mutationObserver?.observe(this.el, { childList: true });
        this.setDisabledAction();
        this.el.addEventListener(internalHiddenInputInputEvent, this.onHiddenFormInputInput);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        this.mutationObserver?.disconnect();
        this.el.removeEventListener(internalHiddenInputInputEvent, this.onHiddenFormInputInput);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        this.requestedIcon = setRequestedIcon({}, this.icon, "text");
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.childEl?.focus();
    }
    /** Selects the text of the component's `value`. */
    async selectText() {
        this.childEl?.select();
    }
    onLabelClick() {
        this.setFocus();
    }
    syncHiddenFormInput(input) {
        syncHiddenFormInput("text", this, input);
    }
    setDisabledAction() {
        const slottedActionEl = getSlotted(this.el, "action");
        if (!slottedActionEl) {
            return;
        }
        if (this.disabled) {
            if (slottedActionEl.getAttribute("disabled") == null) {
                this.slottedActionElDisabledInternally = true;
            }
            slottedActionEl.setAttribute("disabled", "");
        }
        else if (this.slottedActionElDisabledInternally) {
            slottedActionEl.removeAttribute("disabled");
            this.slottedActionElDisabledInternally = false;
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const dir = getElementDir(this.el);
        const loader = (hAsync("div", { class: CSS$O.loader }, hAsync("calcite-progress", { label: this.messages.loading, type: "indeterminate" })));
        const inputClearButton = (hAsync("button", { "aria-label": this.messages.clear, class: CSS$O.clearButton, disabled: this.disabled || this.readOnly, onClick: this.clearInputTextValue, tabIndex: -1, type: "button" }, hAsync("calcite-icon", { icon: "x", scale: getIconScale(this.scale) })));
        const iconEl = (hAsync("calcite-icon", { class: CSS$O.inputIcon, flipRtl: this.iconFlipRtl, icon: this.requestedIcon, scale: getIconScale(this.scale) }));
        const prefixText = hAsync("div", { class: CSS$O.prefix }, this.prefixText);
        const suffixText = hAsync("div", { class: CSS$O.suffix }, this.suffixText);
        const childEl = (hAsync("input", { "aria-label": getLabelText(this), autocomplete: this.autocomplete, autofocus: this.autofocus ? true : null, class: {
                [CSS$O.editingEnabled]: this.editingEnabled,
                [CSS$O.inlineChild]: !!this.inlineEditableEl,
            }, defaultValue: this.defaultValue, disabled: this.disabled ? true : null, enterKeyHint: this.enterKeyHint, inputMode: this.inputMode, maxLength: this.maxLength, minLength: this.minLength, name: this.name, onBlur: this.inputTextBlurHandler, onFocus: this.inputTextFocusHandler, onInput: this.inputTextInputHandler, onKeyDown: this.inputTextKeyDownHandler, pattern: this.pattern, placeholder: this.placeholder || "", readOnly: this.readOnly, required: this.required ? true : null, tabIndex: this.disabled || (this.inlineEditableEl && !this.editingEnabled) ? -1 : null, type: "text", value: this.value,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setChildElRef }));
        return (hAsync(Host, { onClick: this.clickHandler, onKeyDown: this.keyDownHandler }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: { [CSS$O.inputWrapper]: true, [CSS_UTILITY.rtl]: dir === "rtl" } }, this.prefixText ? prefixText : null, hAsync("div", { class: CSS$O.wrapper }, childEl, this.isClearable ? inputClearButton : null, this.requestedIcon ? iconEl : null, this.loading ? loader : null), hAsync("div", { class: CSS$O.actionWrapper }, hAsync("slot", { name: SLOTS$j.action })), this.suffixText ? suffixText : null, hAsync(HiddenFormInputSlot, { component: this })), this.validationMessage && this.status === "invalid" ? (hAsync(Validation, { icon: this.validationIcon, message: this.validationMessage, scale: this.scale, status: this.status })) : null)));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "disabled": ["disabledWatcher"],
        "messageOverrides": ["onMessagesChange"],
        "value": ["valueWatcher"],
        "icon": ["updateRequestedIcon"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return inputTextCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-input-text",
        "$members$": {
            "alignment": [513],
            "autofocus": [516],
            "clearable": [516],
            "disabled": [516],
            "form": [513],
            "icon": [520],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "label": [1],
            "loading": [516],
            "maxLength": [514, "max-length"],
            "minLength": [514, "min-length"],
            "validationMessage": [1, "validation-message"],
            "validationIcon": [520, "validation-icon"],
            "name": [513],
            "placeholder": [1],
            "prefixText": [1, "prefix-text"],
            "readOnly": [516, "read-only"],
            "required": [516],
            "scale": [513],
            "status": [513],
            "autocomplete": [1],
            "inputMode": [1, "input-mode"],
            "enterKeyHint": [1, "enter-key-hint"],
            "pattern": [1],
            "suffixText": [1, "suffix-text"],
            "editingEnabled": [1540, "editing-enabled"],
            "value": [1025],
            "messages": [1040],
            "messageOverrides": [1040],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "slottedActionElDisabledInternally": [32],
            "setFocus": [64],
            "selectText": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["alignment", "alignment"], ["autofocus", "autofocus"], ["clearable", "clearable"], ["disabled", "disabled"], ["form", "form"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["loading", "loading"], ["maxLength", "max-length"], ["minLength", "min-length"], ["validationIcon", "validation-icon"], ["name", "name"], ["readOnly", "read-only"], ["required", "required"], ["scale", "scale"], ["status", "status"], ["editingEnabled", "editing-enabled"]]
    }; }
}

const maxTenthForMinuteAndSecond = 5;
function createLocaleDateTimeFormatter(locale, numberingSystem, includeSeconds = true, fractionalSecondDigits) {
    const options = {
        hour: "2-digit",
        minute: "2-digit",
        timeZone: "UTC",
        numberingSystem: getSupportedNumberingSystem(numberingSystem),
    };
    if (includeSeconds) {
        options.second = "2-digit";
        if (fractionalSecondDigits) {
            options.fractionalSecondDigits = fractionalSecondDigits;
        }
    }
    return getDateTimeFormat(locale, options);
}
function formatTimePart(number, minLength) {
    if (number === null || number === undefined) {
        return;
    }
    const numberAsString = number.toString();
    const numberDecimalPlaces = decimalPlaces(number);
    if (number < 1 && numberDecimalPlaces > 0 && numberDecimalPlaces < 4) {
        const fractionalDigits = numberAsString.replace("0.", "");
        if (!minLength || fractionalDigits.length === minLength) {
            return fractionalDigits;
        }
        if (fractionalDigits.length < minLength) {
            return fractionalDigits.padEnd(minLength, "0");
        }
        return fractionalDigits;
    }
    if (number >= 0 && number < 10) {
        return numberAsString.padStart(2, "0");
    }
    if (number >= 10) {
        return numberAsString;
    }
}
function formatTimeString(value) {
    if (!isValidTime(value)) {
        return null;
    }
    const { hour, minute, second, fractionalSecond } = parseTimeString(value);
    let formattedValue = `${formatTimePart(parseInt(hour))}:${formatTimePart(parseInt(minute))}`;
    if (second) {
        formattedValue += `:${formatTimePart(parseInt(second))}`;
        if (fractionalSecond) {
            formattedValue += `.${fractionalSecond}`;
        }
    }
    return formattedValue;
}
function fractionalSecondPartToMilliseconds(fractionalSecondPart) {
    return parseInt((parseFloat(`0.${fractionalSecondPart}`) / 0.001).toFixed(3));
}
function getLocaleHourCycle(locale, numberingSystem) {
    const formatter = createLocaleDateTimeFormatter(locale, numberingSystem);
    const parts = formatter.formatToParts(new Date(Date.UTC(0, 0, 0, 0, 0, 0)));
    return getLocalizedTimePart("meridiem", parts) ? "12" : "24";
}
function getLocalizedDecimalSeparator(locale, numberingSystem) {
    numberStringFormatter.numberFormatOptions = {
        locale,
        numberingSystem,
    };
    return numberStringFormatter.localize("1.1").split("")[1];
}
function getLocalizedTimePartSuffix(part, locale, numberingSystem = "latn") {
    const formatter = createLocaleDateTimeFormatter(locale, numberingSystem);
    const parts = formatter.formatToParts(new Date(Date.UTC(0, 0, 0, 0, 0, 0)));
    return getLocalizedTimePart(`${part}Suffix`, parts);
}
function getLocalizedTimePart(part, parts) {
    if (!part || !parts) {
        return null;
    }
    if (part === "hourSuffix") {
        const hourIndex = parts.indexOf(parts.find(({ type }) => type === "hour"));
        const minuteIndex = parts.indexOf(parts.find(({ type }) => type === "minute"));
        const hourSuffix = parts[hourIndex + 1];
        return hourSuffix && hourSuffix.type === "literal" && minuteIndex - hourIndex === 2
            ? hourSuffix.value?.trim() || null
            : null;
    }
    if (part === "minuteSuffix") {
        const minuteIndex = parts.indexOf(parts.find(({ type }) => type === "minute"));
        const secondIndex = parts.indexOf(parts.find(({ type }) => type === "second"));
        const minuteSuffix = parts[minuteIndex + 1];
        return minuteSuffix && minuteSuffix.type === "literal" && secondIndex - minuteIndex === 2
            ? minuteSuffix.value?.trim() || null
            : null;
    }
    if (part === "secondSuffix") {
        const secondIndex = parts.indexOf(parts.find(({ type }) => type === "second"));
        const secondSuffix = parts[secondIndex + 1];
        return secondSuffix && secondSuffix.type === "literal" ? secondSuffix.value?.trim() || null : null;
    }
    return parts.find(({ type }) => (part == "meridiem" ? type === "dayPeriod" : type === part))?.value || null;
}
function getMeridiem(hour) {
    if (!isValidNumber(hour)) {
        return null;
    }
    const hourAsNumber = parseInt(hour);
    return hourAsNumber >= 0 && hourAsNumber <= 11 ? "AM" : "PM";
}
function isValidTime(value) {
    if (!value || value.startsWith(":") || value.endsWith(":")) {
        return false;
    }
    const splitValue = value.split(":");
    const validLength = splitValue.length > 1 && splitValue.length < 4;
    if (!validLength) {
        return false;
    }
    const [hour, minute, second] = splitValue;
    const hourAsNumber = parseInt(splitValue[0]);
    const minuteAsNumber = parseInt(splitValue[1]);
    const secondAsNumber = parseInt(splitValue[2]);
    const hourValid = isValidNumber(hour) && hourAsNumber >= 0 && hourAsNumber < 24;
    const minuteValid = isValidNumber(minute) && minuteAsNumber >= 0 && minuteAsNumber < 60;
    const secondValid = isValidNumber(second) && secondAsNumber >= 0 && secondAsNumber < 60;
    if ((hourValid && minuteValid && !second) || (hourValid && minuteValid && secondValid)) {
        return true;
    }
}
function isValidTimePart(value, part) {
    if (part === "meridiem") {
        return value === "AM" || value === "PM";
    }
    if (!isValidNumber(value)) {
        return false;
    }
    const valueAsNumber = Number(value);
    return part === "hour" ? valueAsNumber >= 0 && valueAsNumber < 24 : valueAsNumber >= 0 && valueAsNumber < 60;
}
function localizeTimePart({ value, part, locale, numberingSystem }) {
    if (part === "fractionalSecond") {
        const localizedDecimalSeparator = getLocalizedDecimalSeparator(locale, numberingSystem);
        let localizedFractionalSecond = null;
        if (value) {
            numberStringFormatter.numberFormatOptions = {
                locale,
                numberingSystem,
            };
            const localizedZero = numberStringFormatter.localize("0");
            if (parseInt(value) === 0) {
                localizedFractionalSecond = "".padStart(value.length, localizedZero);
            }
            else {
                localizedFractionalSecond = numberStringFormatter
                    .localize(`0.${value}`)
                    .replace(`${localizedZero}${localizedDecimalSeparator}`, "");
                if (localizedFractionalSecond.length < value.length) {
                    localizedFractionalSecond = localizedFractionalSecond.padEnd(value.length, localizedZero);
                }
            }
        }
        return localizedFractionalSecond;
    }
    if (!isValidTimePart(value, part)) {
        return;
    }
    const valueAsNumber = parseInt(value);
    const date = new Date(Date.UTC(0, 0, 0, part === "hour" ? valueAsNumber : part === "meridiem" ? (value === "AM" ? 0 : 12) : 0, part === "minute" ? valueAsNumber : 0, part === "second" ? valueAsNumber : 0));
    if (!date) {
        return;
    }
    const formatter = createLocaleDateTimeFormatter(locale, numberingSystem);
    const parts = formatter.formatToParts(date);
    return getLocalizedTimePart(part, parts);
}
function localizeTimeString({ value, locale, numberingSystem, includeSeconds = true, fractionalSecondDigits, }) {
    if (!isValidTime(value)) {
        return null;
    }
    const { hour, minute, second = "0", fractionalSecond } = parseTimeString(value);
    const dateFromTimeString = new Date(Date.UTC(0, 0, 0, parseInt(hour), parseInt(minute), parseInt(second), fractionalSecond && fractionalSecondPartToMilliseconds(fractionalSecond)));
    const formatter = createLocaleDateTimeFormatter(locale, numberingSystem, includeSeconds, fractionalSecondDigits);
    return formatter.format(dateFromTimeString) || null;
}
function localizeTimeStringToParts({ value, locale, numberingSystem = "latn", }) {
    if (!isValidTime(value)) {
        return null;
    }
    const { hour, minute, second = "0", fractionalSecond } = parseTimeString(value);
    const dateFromTimeString = new Date(Date.UTC(0, 0, 0, parseInt(hour), parseInt(minute), parseInt(second)));
    if (dateFromTimeString) {
        const formatter = createLocaleDateTimeFormatter(locale, numberingSystem);
        const parts = formatter.formatToParts(dateFromTimeString);
        return {
            localizedHour: getLocalizedTimePart("hour", parts),
            localizedHourSuffix: getLocalizedTimePart("hourSuffix", parts),
            localizedMinute: getLocalizedTimePart("minute", parts),
            localizedMinuteSuffix: getLocalizedTimePart("minuteSuffix", parts),
            localizedSecond: getLocalizedTimePart("second", parts),
            localizedDecimalSeparator: getLocalizedDecimalSeparator(locale, numberingSystem),
            localizedFractionalSecond: localizeTimePart({
                value: fractionalSecond,
                part: "fractionalSecond",
                locale,
                numberingSystem,
            }),
            localizedSecondSuffix: getLocalizedTimePart("secondSuffix", parts),
            localizedMeridiem: getLocalizedTimePart("meridiem", parts),
        };
    }
    return null;
}
function getTimeParts({ value, locale, numberingSystem }) {
    if (!isValidTime(value)) {
        return null;
    }
    const { hour, minute, second = "0" } = parseTimeString(value);
    const dateFromTimeString = new Date(Date.UTC(0, 0, 0, parseInt(hour), parseInt(minute), parseInt(second)));
    if (dateFromTimeString) {
        const formatter = createLocaleDateTimeFormatter(locale, numberingSystem);
        const parts = formatter.formatToParts(dateFromTimeString);
        return parts;
    }
    return null;
}
function parseTimeString(value) {
    if (isValidTime(value)) {
        const [hour, minute, secondDecimal] = value.split(":");
        let second = secondDecimal;
        let fractionalSecond = null;
        if (secondDecimal?.includes(".")) {
            [second, fractionalSecond] = secondDecimal.split(".");
        }
        return {
            fractionalSecond,
            hour,
            minute,
            second,
        };
    }
    return {
        fractionalSecond: null,
        hour: null,
        minute: null,
        second: null,
    };
}
function toISOTimeString(value, includeSeconds = true) {
    if (!isValidTime(value)) {
        return "";
    }
    const { hour, minute, second, fractionalSecond } = parseTimeString(value);
    let isoTimeString = `${formatTimePart(parseInt(hour))}:${formatTimePart(parseInt(minute))}`;
    if (includeSeconds) {
        isoTimeString += `:${formatTimePart(parseInt((includeSeconds && second) || "0"))}`;
        if (fractionalSecond) {
            isoTimeString += `.${fractionalSecond}`;
        }
    }
    return isoTimeString;
}

const CSS$N = {
    toggleIcon: "toggle-icon",
};

var SECONDS_A_MINUTE = 60;
var SECONDS_A_HOUR = SECONDS_A_MINUTE * 60;
var SECONDS_A_DAY = SECONDS_A_HOUR * 24;
var SECONDS_A_WEEK = SECONDS_A_DAY * 7;
var MILLISECONDS_A_SECOND = 1e3;
var MILLISECONDS_A_MINUTE = SECONDS_A_MINUTE * MILLISECONDS_A_SECOND;
var MILLISECONDS_A_HOUR = SECONDS_A_HOUR * MILLISECONDS_A_SECOND;
var MILLISECONDS_A_DAY = SECONDS_A_DAY * MILLISECONDS_A_SECOND;
var MILLISECONDS_A_WEEK = SECONDS_A_WEEK * MILLISECONDS_A_SECOND; // English locales

var MS = 'millisecond';
var S = 'second';
var MIN = 'minute';
var H = 'hour';
var D = 'day';
var W = 'week';
var M = 'month';
var Q = 'quarter';
var Y = 'year';
var DATE = 'date';
var FORMAT_DEFAULT = 'YYYY-MM-DDTHH:mm:ssZ';
var INVALID_DATE_STRING = 'Invalid Date'; // regex

var REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/;
var REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g;

// English [en]
// We don't need weekdaysShort, weekdaysMin, monthsShort in en.js locale
var en = {
  name: 'en',
  weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
  months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
  ordinal: function ordinal(n) {
    var s = ['th', 'st', 'nd', 'rd'];
    var v = n % 100;
    return "[" + n + (s[(v - 20) % 10] || s[v] || s[0]) + "]";
  }
};

var en$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': en
});

var padStart = function padStart(string, length, pad) {
  var s = String(string);
  if (!s || s.length >= length) return string;
  return "" + Array(length + 1 - s.length).join(pad) + string;
};

var padZoneStr = function padZoneStr(instance) {
  var negMinutes = -instance.utcOffset();
  var minutes = Math.abs(negMinutes);
  var hourOffset = Math.floor(minutes / 60);
  var minuteOffset = minutes % 60;
  return "" + (negMinutes <= 0 ? '+' : '-') + padStart(hourOffset, 2, '0') + ":" + padStart(minuteOffset, 2, '0');
};

var monthDiff = function monthDiff(a, b) {
  // function from moment.js in order to keep the same result
  if (a.date() < b.date()) return -monthDiff(b, a);
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month());
  var anchor = a.clone().add(wholeMonthDiff, M);
  var c = b - anchor < 0;
  var anchor2 = a.clone().add(wholeMonthDiff + (c ? -1 : 1), M);
  return +(-(wholeMonthDiff + (b - anchor) / (c ? anchor - anchor2 : anchor2 - anchor)) || 0);
};

var absFloor = function absFloor(n) {
  return n < 0 ? Math.ceil(n) || 0 : Math.floor(n);
};

var prettyUnit = function prettyUnit(u) {
  var special = {
    M: M,
    y: Y,
    w: W,
    d: D,
    D: DATE,
    h: H,
    m: MIN,
    s: S,
    ms: MS,
    Q: Q
  };
  return special[u] || String(u || '').toLowerCase().replace(/s$/, '');
};

var isUndefined = function isUndefined(s) {
  return s === undefined;
};

var U = {
  s: padStart,
  z: padZoneStr,
  m: monthDiff,
  a: absFloor,
  p: prettyUnit,
  u: isUndefined
};

var L = 'en'; // global locale

var Ls = {}; // global loaded locale

Ls[L] = en;
var IS_DAYJS = '$isDayjsObject'; // eslint-disable-next-line no-use-before-define

var isDayjs = function isDayjs(d) {
  return d instanceof Dayjs || !!(d && d[IS_DAYJS]);
};

var parseLocale = function parseLocale(preset, object, isLocal) {
  var l;
  if (!preset) return L;

  if (typeof preset === 'string') {
    var presetLower = preset.toLowerCase();

    if (Ls[presetLower]) {
      l = presetLower;
    }

    if (object) {
      Ls[presetLower] = object;
      l = presetLower;
    }

    var presetSplit = preset.split('-');

    if (!l && presetSplit.length > 1) {
      return parseLocale(presetSplit[0]);
    }
  } else {
    var name = preset.name;
    Ls[name] = preset;
    l = name;
  }

  if (!isLocal && l) L = l;
  return l || !isLocal && L;
};

var dayjs = function dayjs(date, c) {
  if (isDayjs(date)) {
    return date.clone();
  } // eslint-disable-next-line no-nested-ternary


  var cfg = typeof c === 'object' ? c : {};
  cfg.date = date;
  cfg.args = arguments; // eslint-disable-line prefer-rest-params

  return new Dayjs(cfg); // eslint-disable-line no-use-before-define
};

var wrapper = function wrapper(date, instance) {
  return dayjs(date, {
    locale: instance.$L,
    utc: instance.$u,
    x: instance.$x,
    $offset: instance.$offset // todo: refactor; do not use this.$offset in you code

  });
};

var Utils = U; // for plugin use

Utils.l = parseLocale;
Utils.i = isDayjs;
Utils.w = wrapper;

var parseDate = function parseDate(cfg) {
  var date = cfg.date,
      utc = cfg.utc;
  if (date === null) return new Date(NaN); // null is invalid

  if (Utils.u(date)) return new Date(); // today

  if (date instanceof Date) return new Date(date);

  if (typeof date === 'string' && !/Z$/i.test(date)) {
    var d = date.match(REGEX_PARSE);

    if (d) {
      var m = d[2] - 1 || 0;
      var ms = (d[7] || '0').substring(0, 3);

      if (utc) {
        return new Date(Date.UTC(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms));
      }

      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
    }
  }

  return new Date(date); // everything else
};

var Dayjs = /*#__PURE__*/function () {
  function Dayjs(cfg) {
    this.$L = parseLocale(cfg.locale, null, true);
    this.parse(cfg); // for plugin

    this.$x = this.$x || cfg.x || {};
    this[IS_DAYJS] = true;
  }

  var _proto = Dayjs.prototype;

  _proto.parse = function parse(cfg) {
    this.$d = parseDate(cfg);
    this.init();
  };

  _proto.init = function init() {
    var $d = this.$d;
    this.$y = $d.getFullYear();
    this.$M = $d.getMonth();
    this.$D = $d.getDate();
    this.$W = $d.getDay();
    this.$H = $d.getHours();
    this.$m = $d.getMinutes();
    this.$s = $d.getSeconds();
    this.$ms = $d.getMilliseconds();
  } // eslint-disable-next-line class-methods-use-this
  ;

  _proto.$utils = function $utils() {
    return Utils;
  };

  _proto.isValid = function isValid() {
    return !(this.$d.toString() === INVALID_DATE_STRING);
  };

  _proto.isSame = function isSame(that, units) {
    var other = dayjs(that);
    return this.startOf(units) <= other && other <= this.endOf(units);
  };

  _proto.isAfter = function isAfter(that, units) {
    return dayjs(that) < this.startOf(units);
  };

  _proto.isBefore = function isBefore(that, units) {
    return this.endOf(units) < dayjs(that);
  };

  _proto.$g = function $g(input, get, set) {
    if (Utils.u(input)) return this[get];
    return this.set(set, input);
  };

  _proto.unix = function unix() {
    return Math.floor(this.valueOf() / 1000);
  };

  _proto.valueOf = function valueOf() {
    // timezone(hour) * 60 * 60 * 1000 => ms
    return this.$d.getTime();
  };

  _proto.startOf = function startOf(units, _startOf) {
    var _this = this;

    // startOf -> endOf
    var isStartOf = !Utils.u(_startOf) ? _startOf : true;
    var unit = Utils.p(units);

    var instanceFactory = function instanceFactory(d, m) {
      var ins = Utils.w(_this.$u ? Date.UTC(_this.$y, m, d) : new Date(_this.$y, m, d), _this);
      return isStartOf ? ins : ins.endOf(D);
    };

    var instanceFactorySet = function instanceFactorySet(method, slice) {
      var argumentStart = [0, 0, 0, 0];
      var argumentEnd = [23, 59, 59, 999];
      return Utils.w(_this.toDate()[method].apply( // eslint-disable-line prefer-spread
      _this.toDate('s'), (isStartOf ? argumentStart : argumentEnd).slice(slice)), _this);
    };

    var $W = this.$W,
        $M = this.$M,
        $D = this.$D;
    var utcPad = "set" + (this.$u ? 'UTC' : '');

    switch (unit) {
      case Y:
        return isStartOf ? instanceFactory(1, 0) : instanceFactory(31, 11);

      case M:
        return isStartOf ? instanceFactory(1, $M) : instanceFactory(0, $M + 1);

      case W:
        {
          var weekStart = this.$locale().weekStart || 0;
          var gap = ($W < weekStart ? $W + 7 : $W) - weekStart;
          return instanceFactory(isStartOf ? $D - gap : $D + (6 - gap), $M);
        }

      case D:
      case DATE:
        return instanceFactorySet(utcPad + "Hours", 0);

      case H:
        return instanceFactorySet(utcPad + "Minutes", 1);

      case MIN:
        return instanceFactorySet(utcPad + "Seconds", 2);

      case S:
        return instanceFactorySet(utcPad + "Milliseconds", 3);

      default:
        return this.clone();
    }
  };

  _proto.endOf = function endOf(arg) {
    return this.startOf(arg, false);
  };

  _proto.$set = function $set(units, _int) {
    var _C$D$C$DATE$C$M$C$Y$C;

    // private set
    var unit = Utils.p(units);
    var utcPad = "set" + (this.$u ? 'UTC' : '');
    var name = (_C$D$C$DATE$C$M$C$Y$C = {}, _C$D$C$DATE$C$M$C$Y$C[D] = utcPad + "Date", _C$D$C$DATE$C$M$C$Y$C[DATE] = utcPad + "Date", _C$D$C$DATE$C$M$C$Y$C[M] = utcPad + "Month", _C$D$C$DATE$C$M$C$Y$C[Y] = utcPad + "FullYear", _C$D$C$DATE$C$M$C$Y$C[H] = utcPad + "Hours", _C$D$C$DATE$C$M$C$Y$C[MIN] = utcPad + "Minutes", _C$D$C$DATE$C$M$C$Y$C[S] = utcPad + "Seconds", _C$D$C$DATE$C$M$C$Y$C[MS] = utcPad + "Milliseconds", _C$D$C$DATE$C$M$C$Y$C)[unit];
    var arg = unit === D ? this.$D + (_int - this.$W) : _int;

    if (unit === M || unit === Y) {
      // clone is for badMutable plugin
      var date = this.clone().set(DATE, 1);
      date.$d[name](arg);
      date.init();
      this.$d = date.set(DATE, Math.min(this.$D, date.daysInMonth())).$d;
    } else if (name) this.$d[name](arg);

    this.init();
    return this;
  };

  _proto.set = function set(string, _int2) {
    return this.clone().$set(string, _int2);
  };

  _proto.get = function get(unit) {
    return this[Utils.p(unit)]();
  };

  _proto.add = function add(number, units) {
    var _this2 = this,
        _C$MIN$C$H$C$S$unit;

    number = Number(number); // eslint-disable-line no-param-reassign

    var unit = Utils.p(units);

    var instanceFactorySet = function instanceFactorySet(n) {
      var d = dayjs(_this2);
      return Utils.w(d.date(d.date() + Math.round(n * number)), _this2);
    };

    if (unit === M) {
      return this.set(M, this.$M + number);
    }

    if (unit === Y) {
      return this.set(Y, this.$y + number);
    }

    if (unit === D) {
      return instanceFactorySet(1);
    }

    if (unit === W) {
      return instanceFactorySet(7);
    }

    var step = (_C$MIN$C$H$C$S$unit = {}, _C$MIN$C$H$C$S$unit[MIN] = MILLISECONDS_A_MINUTE, _C$MIN$C$H$C$S$unit[H] = MILLISECONDS_A_HOUR, _C$MIN$C$H$C$S$unit[S] = MILLISECONDS_A_SECOND, _C$MIN$C$H$C$S$unit)[unit] || 1; // ms

    var nextTimeStamp = this.$d.getTime() + number * step;
    return Utils.w(nextTimeStamp, this);
  };

  _proto.subtract = function subtract(number, string) {
    return this.add(number * -1, string);
  };

  _proto.format = function format(formatStr) {
    var _this3 = this;

    var locale = this.$locale();
    if (!this.isValid()) return locale.invalidDate || INVALID_DATE_STRING;
    var str = formatStr || FORMAT_DEFAULT;
    var zoneStr = Utils.z(this);
    var $H = this.$H,
        $m = this.$m,
        $M = this.$M;
    var weekdays = locale.weekdays,
        months = locale.months,
        meridiem = locale.meridiem;

    var getShort = function getShort(arr, index, full, length) {
      return arr && (arr[index] || arr(_this3, str)) || full[index].slice(0, length);
    };

    var get$H = function get$H(num) {
      return Utils.s($H % 12 || 12, num, '0');
    };

    var meridiemFunc = meridiem || function (hour, minute, isLowercase) {
      var m = hour < 12 ? 'AM' : 'PM';
      return isLowercase ? m.toLowerCase() : m;
    };

    var matches = function matches(match) {
      switch (match) {
        case 'YY':
          return String(_this3.$y).slice(-2);

        case 'YYYY':
          return Utils.s(_this3.$y, 4, '0');

        case 'M':
          return $M + 1;

        case 'MM':
          return Utils.s($M + 1, 2, '0');

        case 'MMM':
          return getShort(locale.monthsShort, $M, months, 3);

        case 'MMMM':
          return getShort(months, $M);

        case 'D':
          return _this3.$D;

        case 'DD':
          return Utils.s(_this3.$D, 2, '0');

        case 'd':
          return String(_this3.$W);

        case 'dd':
          return getShort(locale.weekdaysMin, _this3.$W, weekdays, 2);

        case 'ddd':
          return getShort(locale.weekdaysShort, _this3.$W, weekdays, 3);

        case 'dddd':
          return weekdays[_this3.$W];

        case 'H':
          return String($H);

        case 'HH':
          return Utils.s($H, 2, '0');

        case 'h':
          return get$H(1);

        case 'hh':
          return get$H(2);

        case 'a':
          return meridiemFunc($H, $m, true);

        case 'A':
          return meridiemFunc($H, $m, false);

        case 'm':
          return String($m);

        case 'mm':
          return Utils.s($m, 2, '0');

        case 's':
          return String(_this3.$s);

        case 'ss':
          return Utils.s(_this3.$s, 2, '0');

        case 'SSS':
          return Utils.s(_this3.$ms, 3, '0');

        case 'Z':
          return zoneStr;
      }

      return null;
    };

    return str.replace(REGEX_FORMAT, function (match, $1) {
      return $1 || matches(match) || zoneStr.replace(':', '');
    }); // 'ZZ'
  };

  _proto.utcOffset = function utcOffset() {
    // Because a bug at FF24, we're rounding the timezone offset around 15 minutes
    // https://github.com/moment/moment/pull/1871
    return -Math.round(this.$d.getTimezoneOffset() / 15) * 15;
  };

  _proto.diff = function diff(input, units, _float) {
    var _this4 = this;

    var unit = Utils.p(units);
    var that = dayjs(input);
    var zoneDelta = (that.utcOffset() - this.utcOffset()) * MILLISECONDS_A_MINUTE;
    var diff = this - that;

    var getMonth = function getMonth() {
      return Utils.m(_this4, that);
    };

    var result;

    switch (unit) {
      case Y:
        result = getMonth() / 12;
        break;

      case M:
        result = getMonth();
        break;

      case Q:
        result = getMonth() / 3;
        break;

      case W:
        result = (diff - zoneDelta) / MILLISECONDS_A_WEEK;
        break;

      case D:
        result = (diff - zoneDelta) / MILLISECONDS_A_DAY;
        break;

      case H:
        result = diff / MILLISECONDS_A_HOUR;
        break;

      case MIN:
        result = diff / MILLISECONDS_A_MINUTE;
        break;

      case S:
        result = diff / MILLISECONDS_A_SECOND;
        break;

      default:
        result = diff; // milliseconds

        break;
    }

    return _float ? result : Utils.a(result);
  };

  _proto.daysInMonth = function daysInMonth() {
    return this.endOf(M).$D;
  };

  _proto.$locale = function $locale() {
    // get locale object
    return Ls[this.$L];
  };

  _proto.locale = function locale(preset, object) {
    if (!preset) return this.$L;
    var that = this.clone();
    var nextLocaleName = parseLocale(preset, object, true);
    if (nextLocaleName) that.$L = nextLocaleName;
    return that;
  };

  _proto.clone = function clone() {
    return Utils.w(this.$d, this);
  };

  _proto.toDate = function toDate() {
    return new Date(this.valueOf());
  };

  _proto.toJSON = function toJSON() {
    return this.isValid() ? this.toISOString() : null;
  };

  _proto.toISOString = function toISOString() {
    // ie 8 return
    // new Dayjs(this.valueOf() + this.$d.getTimezoneOffset() * 60000)
    // .format('YYYY-MM-DDTHH:mm:ss.SSS[Z]')
    return this.$d.toISOString();
  };

  _proto.toString = function toString() {
    return this.$d.toUTCString();
  };

  return Dayjs;
}();

var proto = Dayjs.prototype;
dayjs.prototype = proto;
[['$ms', MS], ['$s', S], ['$m', MIN], ['$H', H], ['$W', D], ['$M', M], ['$y', Y], ['$D', DATE]].forEach(function (g) {
  proto[g[1]] = function (input) {
    return this.$g(input, g[0], g[1]);
  };
});

dayjs.extend = function (plugin, option) {
  if (!plugin.$i) {
    // install plugin only once
    plugin(option, Dayjs, dayjs);
    plugin.$i = true;
  }

  return dayjs;
};

dayjs.locale = parseLocale;
dayjs.isDayjs = isDayjs;

dayjs.unix = function (timestamp) {
  return dayjs(timestamp * 1e3);
};

dayjs.en = Ls[L];
dayjs.Ls = Ls;
dayjs.p = {};

// eslint-disable-next-line import/prefer-default-export
var t = function t(format) {
  return format.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (_, a, b) {
    return a || b.slice(1);
  });
};
var englishFormats = {
  LTS: 'h:mm:ss A',
  LT: 'h:mm A',
  L: 'MM/DD/YYYY',
  LL: 'MMMM D, YYYY',
  LLL: 'MMMM D, YYYY h:mm A',
  LLLL: 'dddd, MMMM D, YYYY h:mm A'
};
var u = function u(formatStr, formats) {
  return formatStr.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (_, a, b) {
    var B = b && b.toUpperCase();
    return a || formats[b] || englishFormats[b] || t(formats[B]);
  });
};

var formattingTokens = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g;
var match1 = /\d/; // 0 - 9

var match2 = /\d\d/; // 00 - 99

var match3 = /\d{3}/; // 000 - 999

var match4 = /\d{4}/; // 0000 - 9999

var match1to2 = /\d\d?/; // 0 - 99

var matchSigned = /[+-]?\d+/; // -inf - inf

var matchOffset = /[+-]\d\d:?(\d\d)?|Z/; // +00:00 -00:00 +0000 or -0000 +00 or Z

var matchWord = /\d*[^-_:/,()\s\d]+/; // Word

var locale$N = {};

var parseTwoDigitYear = function parseTwoDigitYear(input) {
  input = +input;
  return input + (input > 68 ? 1900 : 2000);
};

function offsetFromString(string) {
  if (!string) return 0;
  if (string === 'Z') return 0;
  var parts = string.match(/([+-]|\d\d)/g);
  var minutes = +(parts[1] * 60) + (+parts[2] || 0);
  return minutes === 0 ? 0 : parts[0] === '+' ? -minutes : minutes; // eslint-disable-line no-nested-ternary
}

var addInput = function addInput(property) {
  return function (input) {
    this[property] = +input;
  };
};

var zoneExpressions = [matchOffset, function (input) {
  var zone = this.zone || (this.zone = {});
  zone.offset = offsetFromString(input);
}];

var getLocalePart = function getLocalePart(name) {
  var part = locale$N[name];
  return part && (part.indexOf ? part : part.s.concat(part.f));
};

var meridiemMatch = function meridiemMatch(input, isLowerCase) {
  var isAfternoon;
  var _locale = locale$N,
      meridiem = _locale.meridiem;

  if (!meridiem) {
    isAfternoon = input === (isLowerCase ? 'pm' : 'PM');
  } else {
    for (var i = 1; i <= 24; i += 1) {
      // todo: fix input === meridiem(i, 0, isLowerCase)
      if (input.indexOf(meridiem(i, 0, isLowerCase)) > -1) {
        isAfternoon = i > 12;
        break;
      }
    }
  }

  return isAfternoon;
};

var expressions = {
  A: [matchWord, function (input) {
    this.afternoon = meridiemMatch(input, false);
  }],
  a: [matchWord, function (input) {
    this.afternoon = meridiemMatch(input, true);
  }],
  S: [match1, function (input) {
    this.milliseconds = +input * 100;
  }],
  SS: [match2, function (input) {
    this.milliseconds = +input * 10;
  }],
  SSS: [match3, function (input) {
    this.milliseconds = +input;
  }],
  s: [match1to2, addInput('seconds')],
  ss: [match1to2, addInput('seconds')],
  m: [match1to2, addInput('minutes')],
  mm: [match1to2, addInput('minutes')],
  H: [match1to2, addInput('hours')],
  h: [match1to2, addInput('hours')],
  HH: [match1to2, addInput('hours')],
  hh: [match1to2, addInput('hours')],
  D: [match1to2, addInput('day')],
  DD: [match2, addInput('day')],
  Do: [matchWord, function (input) {
    var _locale2 = locale$N,
        ordinal = _locale2.ordinal;

    var _input$match = input.match(/\d+/);

    this.day = _input$match[0];
    if (!ordinal) return;

    for (var i = 1; i <= 31; i += 1) {
      if (ordinal(i).replace(/\[|\]/g, '') === input) {
        this.day = i;
      }
    }
  }],
  M: [match1to2, addInput('month')],
  MM: [match2, addInput('month')],
  MMM: [matchWord, function (input) {
    var months = getLocalePart('months');
    var monthsShort = getLocalePart('monthsShort');
    var matchIndex = (monthsShort || months.map(function (_) {
      return _.slice(0, 3);
    })).indexOf(input) + 1;

    if (matchIndex < 1) {
      throw new Error();
    }

    this.month = matchIndex % 12 || matchIndex;
  }],
  MMMM: [matchWord, function (input) {
    var months = getLocalePart('months');
    var matchIndex = months.indexOf(input) + 1;

    if (matchIndex < 1) {
      throw new Error();
    }

    this.month = matchIndex % 12 || matchIndex;
  }],
  Y: [matchSigned, addInput('year')],
  YY: [match2, function (input) {
    this.year = parseTwoDigitYear(input);
  }],
  YYYY: [match4, addInput('year')],
  Z: zoneExpressions,
  ZZ: zoneExpressions
};

function correctHours(time) {
  var afternoon = time.afternoon;

  if (afternoon !== undefined) {
    var hours = time.hours;

    if (afternoon) {
      if (hours < 12) {
        time.hours += 12;
      }
    } else if (hours === 12) {
      time.hours = 0;
    }

    delete time.afternoon;
  }
}

function makeParser(format) {
  format = u(format, locale$N && locale$N.formats);
  var array = format.match(formattingTokens);
  var length = array.length;

  for (var i = 0; i < length; i += 1) {
    var token = array[i];
    var parseTo = expressions[token];
    var regex = parseTo && parseTo[0];
    var parser = parseTo && parseTo[1];

    if (parser) {
      array[i] = {
        regex: regex,
        parser: parser
      };
    } else {
      array[i] = token.replace(/^\[|\]$/g, '');
    }
  }

  return function (input) {
    var time = {};

    for (var _i = 0, start = 0; _i < length; _i += 1) {
      var _token = array[_i];

      if (typeof _token === 'string') {
        start += _token.length;
      } else {
        var _regex = _token.regex,
            _parser = _token.parser;
        var part = input.slice(start);

        var match = _regex.exec(part);

        var value = match[0];

        _parser.call(time, value);

        input = input.replace(value, '');
      }
    }

    correctHours(time);
    return time;
  };
}

var parseFormattedInput = function parseFormattedInput(input, format, utc) {
  try {
    if (['x', 'X'].indexOf(format) > -1) return new Date((format === 'X' ? 1000 : 1) * input);
    var parser = makeParser(format);

    var _parser2 = parser(input),
        year = _parser2.year,
        month = _parser2.month,
        day = _parser2.day,
        hours = _parser2.hours,
        minutes = _parser2.minutes,
        seconds = _parser2.seconds,
        milliseconds = _parser2.milliseconds,
        zone = _parser2.zone;

    var now = new Date();
    var d = day || (!year && !month ? now.getDate() : 1);
    var y = year || now.getFullYear();
    var M = 0;

    if (!(year && !month)) {
      M = month > 0 ? month - 1 : now.getMonth();
    }

    var h = hours || 0;
    var m = minutes || 0;
    var s = seconds || 0;
    var ms = milliseconds || 0;

    if (zone) {
      return new Date(Date.UTC(y, M, d, h, m, s, ms + zone.offset * 60 * 1000));
    }

    if (utc) {
      return new Date(Date.UTC(y, M, d, h, m, s, ms));
    }

    return new Date(y, M, d, h, m, s, ms);
  } catch (e) {
    return new Date(''); // Invalid Date
  }
};

var customParseFormat = (function (o, C, d) {
  d.p.customParseFormat = true;

  if (o && o.parseTwoDigitYear) {
    parseTwoDigitYear = o.parseTwoDigitYear;
  }

  var proto = C.prototype;
  var oldParse = proto.parse;

  proto.parse = function (cfg) {
    var date = cfg.date,
        utc = cfg.utc,
        args = cfg.args;
    this.$u = utc;
    var format = args[1];

    if (typeof format === 'string') {
      var isStrictWithoutLocale = args[2] === true;
      var isStrictWithLocale = args[3] === true;
      var isStrict = isStrictWithoutLocale || isStrictWithLocale;
      var pl = args[2];

      if (isStrictWithLocale) {
        pl = args[2];
      }

      locale$N = this.$locale();

      if (!isStrictWithoutLocale && pl) {
        locale$N = d.Ls[pl];
      }

      this.$d = parseFormattedInput(date, format, utc);
      this.init();
      if (pl && pl !== true) this.$L = this.locale(pl).$L; // use != to treat
      // input number 1410715640579 and format string '1410715640579' equal
      // eslint-disable-next-line eqeqeq

      if (isStrict && date != this.format(format)) {
        this.$d = new Date('');
      } // reset global locale to make parallel unit test


      locale$N = {};
    } else if (format instanceof Array) {
      var len = format.length;

      for (var i = 1; i <= len; i += 1) {
        args[1] = format[i - 1];
        var result = d.apply(this, args);

        if (result.isValid()) {
          this.$d = result.$d;
          this.$L = result.$L;
          this.init();
          break;
        }

        if (i === len) this.$d = new Date('');
      }
    } else {
      oldParse.call(this, cfg);
    }
  };
});

var localeData = (function (o, c, dayjs) {
  // locale needed later
  var proto = c.prototype;

  var getLocalePart = function getLocalePart(part) {
    return part && (part.indexOf ? part : part.s);
  };

  var getShort = function getShort(ins, target, full, num, localeOrder) {
    var locale = ins.name ? ins : ins.$locale();
    var targetLocale = getLocalePart(locale[target]);
    var fullLocale = getLocalePart(locale[full]);
    var result = targetLocale || fullLocale.map(function (f) {
      return f.slice(0, num);
    });
    if (!localeOrder) return result;
    var weekStart = locale.weekStart;
    return result.map(function (_, index) {
      return result[(index + (weekStart || 0)) % 7];
    });
  };

  var getDayjsLocaleObject = function getDayjsLocaleObject() {
    return dayjs.Ls[dayjs.locale()];
  };

  var getLongDateFormat = function getLongDateFormat(l, format) {
    return l.formats[format] || t(l.formats[format.toUpperCase()]);
  };

  var localeData = function localeData() {
    var _this = this;

    return {
      months: function months(instance) {
        return instance ? instance.format('MMMM') : getShort(_this, 'months');
      },
      monthsShort: function monthsShort(instance) {
        return instance ? instance.format('MMM') : getShort(_this, 'monthsShort', 'months', 3);
      },
      firstDayOfWeek: function firstDayOfWeek() {
        return _this.$locale().weekStart || 0;
      },
      weekdays: function weekdays(instance) {
        return instance ? instance.format('dddd') : getShort(_this, 'weekdays');
      },
      weekdaysMin: function weekdaysMin(instance) {
        return instance ? instance.format('dd') : getShort(_this, 'weekdaysMin', 'weekdays', 2);
      },
      weekdaysShort: function weekdaysShort(instance) {
        return instance ? instance.format('ddd') : getShort(_this, 'weekdaysShort', 'weekdays', 3);
      },
      longDateFormat: function longDateFormat(format) {
        return getLongDateFormat(_this.$locale(), format);
      },
      meridiem: this.$locale().meridiem,
      ordinal: this.$locale().ordinal
    };
  };

  proto.localeData = function () {
    return localeData.bind(this)();
  };

  dayjs.localeData = function () {
    var localeObject = getDayjsLocaleObject();
    return {
      firstDayOfWeek: function firstDayOfWeek() {
        return localeObject.weekStart || 0;
      },
      weekdays: function weekdays() {
        return dayjs.weekdays();
      },
      weekdaysShort: function weekdaysShort() {
        return dayjs.weekdaysShort();
      },
      weekdaysMin: function weekdaysMin() {
        return dayjs.weekdaysMin();
      },
      months: function months() {
        return dayjs.months();
      },
      monthsShort: function monthsShort() {
        return dayjs.monthsShort();
      },
      longDateFormat: function longDateFormat(format) {
        return getLongDateFormat(localeObject, format);
      },
      meridiem: localeObject.meridiem,
      ordinal: localeObject.ordinal
    };
  };

  dayjs.months = function () {
    return getShort(getDayjsLocaleObject(), 'months');
  };

  dayjs.monthsShort = function () {
    return getShort(getDayjsLocaleObject(), 'monthsShort', 'months', 3);
  };

  dayjs.weekdays = function (localeOrder) {
    return getShort(getDayjsLocaleObject(), 'weekdays', null, null, localeOrder);
  };

  dayjs.weekdaysShort = function (localeOrder) {
    return getShort(getDayjsLocaleObject(), 'weekdaysShort', 'weekdays', 3, localeOrder);
  };

  dayjs.weekdaysMin = function (localeOrder) {
    return getShort(getDayjsLocaleObject(), 'weekdaysMin', 'weekdays', 2, localeOrder);
  };
});

var localizedFormat = (function (o, c, d) {
  var proto = c.prototype;
  var oldFormat = proto.format;
  d.en.formats = englishFormats;

  proto.format = function (formatStr) {
    if (formatStr === void 0) {
      formatStr = FORMAT_DEFAULT;
    }

    var _this$$locale = this.$locale(),
        _this$$locale$formats = _this$$locale.formats,
        formats = _this$$locale$formats === void 0 ? {} : _this$$locale$formats;

    var result = u(formatStr, formats);
    return oldFormat.call(this, result);
  };
});

// Plugin template from https://day.js.org/docs/en/plugin/plugin
var preParsePostFormat = (function (option, dayjsClass) {
  var oldParse = dayjsClass.prototype.parse;

  dayjsClass.prototype.parse = function (cfg) {
    if (typeof cfg.date === 'string') {
      var locale = this.$locale();
      cfg.date = locale && locale.preparse ? locale.preparse(cfg.date) : cfg.date;
    } // original parse result


    return oldParse.bind(this)(cfg);
  }; // // overriding existing API
  // // e.g. extend dayjs().format()


  var oldFormat = dayjsClass.prototype.format;

  dayjsClass.prototype.format = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // original format result
    var result = oldFormat.call.apply(oldFormat, [this].concat(args)); // return modified result

    var locale = this.$locale();
    return locale && locale.postformat ? locale.postformat(result) : result;
  };

  var oldFromTo = dayjsClass.prototype.fromToBase;

  if (oldFromTo) {
    dayjsClass.prototype.fromToBase = function (input, withoutSuffix, instance, isFrom) {
      var locale = this.$locale() || instance.$locale(); // original format result

      return oldFromTo.call(this, input, withoutSuffix, instance, isFrom, locale && locale.postformat);
    };
  }
});

var updateLocale = (function (option, Dayjs, dayjs) {
  dayjs.updateLocale = function (locale, customConfig) {
    var localeList = dayjs.Ls;
    var localeConfig = localeList[locale];
    if (!localeConfig) return;
    var customConfigKeys = customConfig ? Object.keys(customConfig) : [];
    customConfigKeys.forEach(function (c) {
      localeConfig[c] = customConfig[c];
    });
    return localeConfig; // eslint-disable-line consistent-return
  };
});

const inputTimePickerCss = "/*!@:host([disabled])*/[disabled].sc-calcite-input-time-picker-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-input-time-picker-h *.sc-calcite-input-time-picker,.sc-calcite-input-time-picker-h[disabled].sc-calcite-input-time-picker-s>*,.sc-calcite-input-time-picker-h[disabled] .sc-calcite-input-time-picker-s>*{pointer-events:none}/*!@:host*/.sc-calcite-input-time-picker-h{display:inline-block;-webkit-user-select:none;user-select:none}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-input-time-picker-h[disabled] .sc-calcite-input-time-picker-s>[calcite-hydrated][disabled],[disabled].sc-calcite-input-time-picker-h [calcite-hydrated][disabled].sc-calcite-input-time-picker{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-input-time-picker{display:contents}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-input-time-picker-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([scale=s])*/[scale=s].sc-calcite-input-time-picker-h{--calcite-toggle-spacing:0.5rem;--calcite-internal-input-text-input-padding-inline-end:calc(var(--calcite-toggle-spacing) + 1rem)}/*!@:host([scale=m])*/[scale=m].sc-calcite-input-time-picker-h{--calcite-toggle-spacing:0.75rem;--calcite-internal-input-text-input-padding-inline-end:calc(var(--calcite-toggle-spacing) + 1.5rem)}/*!@:host([scale=l])*/[scale=l].sc-calcite-input-time-picker-h{--calcite-toggle-spacing:1rem;--calcite-internal-input-text-input-padding-inline-end:calc(var(--calcite-toggle-spacing) + 2rem)}/*!@.input-wrapper*/.input-wrapper.sc-calcite-input-time-picker{position:relative}/*!@.toggle-icon*/.toggle-icon.sc-calcite-input-time-picker{position:absolute;display:flex;cursor:pointer;align-items:center;inset-inline-end:0;inset-block:0;padding-inline:var(--calcite-toggle-spacing)}/*!@.validation-container*/.validation-container.sc-calcite-input-time-picker{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}/*!@:host([scale=m]) .validation-container,\n:host([scale=l]) .validation-container*/[scale=m].sc-calcite-input-time-picker-h .validation-container.sc-calcite-input-time-picker,[scale=l].sc-calcite-input-time-picker-h .validation-container.sc-calcite-input-time-picker{padding-block-start:0.5rem}/*!@:host([scale=s]) .validation-container*/[scale=s].sc-calcite-input-time-picker-h .validation-container.sc-calcite-input-time-picker{padding-block-start:0.25rem}/*!@:host([hidden])*/[hidden].sc-calcite-input-time-picker-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-input-time-picker{display:none}";

// some bundlers (e.g., Webpack) need dynamic import paths to be static
const supportedDayjsLocaleToLocaleConfigImport = new Map([
    ["ar", () => Promise.resolve().then(function () { return ar; })],
    ["bg", () => Promise.resolve().then(function () { return bg; })],
    ["bs", () => Promise.resolve().then(function () { return bs; })],
    ["ca", () => Promise.resolve().then(function () { return ca; })],
    ["cs", () => Promise.resolve().then(function () { return cs; })],
    ["da", () => Promise.resolve().then(function () { return da; })],
    ["de", () => Promise.resolve().then(function () { return de; })],
    ["de-at", () => Promise.resolve().then(function () { return deAt; })],
    ["de-ch", () => Promise.resolve().then(function () { return deCh; })],
    ["el", () => Promise.resolve().then(function () { return el; })],
    ["en", () => Promise.resolve().then(function () { return en$1; })],
    ["en-au", () => Promise.resolve().then(function () { return enAu; })],
    ["en-ca", () => Promise.resolve().then(function () { return enCa; })],
    ["en-gb", () => Promise.resolve().then(function () { return enGb; })],
    ["es", () => Promise.resolve().then(function () { return es; })],
    ["es-mx", () => Promise.resolve().then(function () { return esMx; })],
    ["et", () => Promise.resolve().then(function () { return et; })],
    ["fi", () => Promise.resolve().then(function () { return fi; })],
    ["fr", () => Promise.resolve().then(function () { return fr; })],
    ["fr-ch", () => Promise.resolve().then(function () { return frCh; })],
    ["he", () => Promise.resolve().then(function () { return he; })],
    ["hi", () => Promise.resolve().then(function () { return hi; })],
    ["hr", () => Promise.resolve().then(function () { return hr; })],
    ["hu", () => Promise.resolve().then(function () { return hu; })],
    ["id", () => Promise.resolve().then(function () { return id; })],
    ["it", () => Promise.resolve().then(function () { return it; })],
    ["it-ch", () => Promise.resolve().then(function () { return itCh; })],
    ["ja", () => Promise.resolve().then(function () { return ja; })],
    ["ko", () => Promise.resolve().then(function () { return ko; })],
    ["lt", () => Promise.resolve().then(function () { return lt; })],
    ["lv", () => Promise.resolve().then(function () { return lv; })],
    ["mk", () => Promise.resolve().then(function () { return mk; })],
    ["nl", () => Promise.resolve().then(function () { return nl; })],
    ["nb", () => Promise.resolve().then(function () { return nb; })],
    ["pl", () => Promise.resolve().then(function () { return pl; })],
    ["pt", () => Promise.resolve().then(function () { return pt; })],
    ["pt-br", () => Promise.resolve().then(function () { return ptBr; })],
    ["ro", () => Promise.resolve().then(function () { return ro; })],
    ["ru", () => Promise.resolve().then(function () { return ru; })],
    ["sk", () => Promise.resolve().then(function () { return sk; })],
    ["sl", () => Promise.resolve().then(function () { return sl; })],
    ["sr", () => Promise.resolve().then(function () { return sr; })],
    ["sv", () => Promise.resolve().then(function () { return sv; })],
    ["th", () => Promise.resolve().then(function () { return th; })],
    ["tr", () => Promise.resolve().then(function () { return tr; })],
    ["uk", () => Promise.resolve().then(function () { return uk; })],
    ["vi", () => Promise.resolve().then(function () { return vi; })],
    ["zh-cn", () => Promise.resolve().then(function () { return zhCn; })],
    ["zh-hk", () => Promise.resolve().then(function () { return zhHk; })],
    ["zh-tw", () => Promise.resolve().then(function () { return zhTw; })],
]);
dayjs.extend(customParseFormat);
dayjs.extend(localeData);
dayjs.extend(localizedFormat);
dayjs.extend(preParsePostFormat);
dayjs.extend(updateLocale);
class InputTimePicker {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInputTimePickerBeforeClose = createEvent(this, "calciteInputTimePickerBeforeClose", 6);
        this.calciteInputTimePickerBeforeOpen = createEvent(this, "calciteInputTimePickerBeforeOpen", 6);
        this.calciteInputTimePickerChange = createEvent(this, "calciteInputTimePickerChange", 7);
        this.calciteInputTimePickerClose = createEvent(this, "calciteInputTimePickerClose", 6);
        this.calciteInputTimePickerOpen = createEvent(this, "calciteInputTimePickerOpen", 6);
        this.focusOnOpen = false;
        this.dialogId = `time-picker-dialog--${guid()}`;
        /** whether the value of the input was changed as a result of user typing or not */
        this.userChangedValue = false;
        this.referenceElementId = `input-time-picker-${guid()}`;
        this.openTransitionProp = "opacity";
        //--------------------------------------------------------------------------
        //
        //  Event Listeners
        //
        //--------------------------------------------------------------------------
        this.hostBlurHandler = () => {
            const inputValue = this.calciteInputEl.value;
            const delocalizedInputValue = this.delocalizeTimeString(inputValue);
            if (!delocalizedInputValue) {
                this.setValue("");
                return;
            }
            if (delocalizedInputValue !== this.value) {
                this.setValue(delocalizedInputValue);
            }
            const localizedTimeString = localizeTimeString({
                value: this.value,
                locale: this.effectiveLocale,
                numberingSystem: this.numberingSystem,
                includeSeconds: this.shouldIncludeSeconds(),
                fractionalSecondDigits: decimalPlaces(this.step),
            });
            if (localizedTimeString !== inputValue) {
                this.setInputValue(localizedTimeString);
            }
            this.deactivate();
        };
        this.calciteInternalInputFocusHandler = (event) => {
            if (!this.readOnly) {
                event.stopPropagation();
            }
        };
        this.calciteInternalInputInputHandler = (event) => {
            const { effectiveLocale: locale, numberingSystem } = this;
            if (numberingSystem && numberingSystem !== "latn") {
                const target = event.target;
                numberStringFormatter.numberFormatOptions = {
                    locale,
                    numberingSystem,
                    useGrouping: false,
                };
                const valueInNumberingSystem = numberStringFormatter
                    .delocalize(target.value)
                    .split("")
                    .map((char) => numberKeys.includes(char)
                    ? numberStringFormatter.numberFormatter.format(Number(char))
                    : char)
                    .join("");
                this.setInputValue(valueInNumberingSystem);
            }
        };
        this.timePickerChangeHandler = (event) => {
            event.stopPropagation();
            const target = event.target;
            const value = target.value;
            const includeSeconds = this.shouldIncludeSeconds();
            this.setValue(toISOTimeString(value, includeSeconds));
            this.setInputValue(localizeTimeString({
                value,
                locale: this.effectiveLocale,
                numberingSystem: this.numberingSystem,
                includeSeconds,
                fractionalSecondDigits: decimalPlaces(this.step),
            }));
        };
        this.popoverCloseHandler = () => {
            deactivateFocusTrap(this, {
                onDeactivate: () => {
                    this.calciteInputEl.setFocus();
                    this.focusOnOpen = false;
                },
            });
            this.open = false;
        };
        this.popoverOpenHandler = () => {
            activateFocusTrap(this, {
                onActivate: () => {
                    if (this.focusOnOpen) {
                        this.calciteTimePickerEl.setFocus();
                        this.focusOnOpen = false;
                    }
                },
            });
        };
        this.keyDownHandler = (event) => {
            const { defaultPrevented, key } = event;
            if (defaultPrevented) {
                return;
            }
            if (key === "Enter") {
                if (submitForm(this)) {
                    event.preventDefault();
                    this.calciteInputEl.setFocus();
                }
                if (event.composedPath().includes(this.calciteTimePickerEl)) {
                    return;
                }
                const newValue = this.delocalizeTimeString(this.calciteInputEl.value);
                if (isValidTime(newValue)) {
                    this.setValue(newValue);
                    const localizedTimeString = localizeTimeString({
                        value: this.value,
                        locale: this.effectiveLocale,
                        numberingSystem: this.numberingSystem,
                        includeSeconds: this.shouldIncludeSeconds(),
                        fractionalSecondDigits: decimalPlaces(this.step),
                    });
                    if (newValue && this.calciteInputEl.value !== localizedTimeString) {
                        this.setInputValue(localizedTimeString);
                    }
                }
            }
            else if (key === "ArrowDown") {
                this.open = true;
                this.focusOnOpen = true;
                event.preventDefault();
            }
            else if (key === "Escape" && this.open) {
                this.open = false;
                event.preventDefault();
                this.calciteInputEl.setFocus();
            }
        };
        this.setCalcitePopoverEl = (el) => {
            this.popoverEl = el;
        };
        this.setInputAndTransitionEl = (el) => {
            this.calciteInputEl = el;
            this.transitionEl = el;
        };
        this.setCalciteTimePickerEl = (el) => {
            this.calciteTimePickerEl = el;
            connectFocusTrap(this, {
                focusTrapEl: el,
                focusTrapOptions: {
                    initialFocus: false,
                    setReturnFocus: false,
                },
            });
        };
        this.setInputValue = (newInputValue) => {
            if (!this.calciteInputEl) {
                return;
            }
            this.calciteInputEl.value = newInputValue;
        };
        /**
         * Sets the value and emits a change event.
         * This is used to update the value as a result of user interaction.
         *
         * @param value
         */
        this.setValue = (value) => {
            const oldValue = this.value;
            const newValue = formatTimeString(value) || "";
            if (newValue === oldValue) {
                return;
            }
            this.userChangedValue = true;
            this.value = newValue || "";
            const changeEvent = this.calciteInputTimePickerChange.emit();
            if (changeEvent.defaultPrevented) {
                this.userChangedValue = false;
                this.value = oldValue;
                this.setInputValue(localizeTimeString({
                    value: oldValue,
                    locale: this.effectiveLocale,
                    numberingSystem: this.numberingSystem,
                    includeSeconds: this.shouldIncludeSeconds(),
                    fractionalSecondDigits: decimalPlaces(this.step),
                }));
            }
        };
        /**
         * Sets the value directly without emitting a change event.
         * This is used to update the value on initial load and when props change that are not the result of user interaction.
         *
         * @param value
         */
        this.setValueDirectly = (value) => {
            const includeSeconds = this.shouldIncludeSeconds();
            this.value = toISOTimeString(value, includeSeconds);
            this.setInputValue(this.value
                ? localizeTimeString({
                    value: this.value,
                    includeSeconds,
                    locale: this.effectiveLocale,
                    numberingSystem: this.numberingSystem,
                    fractionalSecondDigits: decimalPlaces(this.step),
                })
                : "");
        };
        this.onInputWrapperClick = () => {
            this.open = !this.open;
        };
        this.deactivate = () => {
            this.open = false;
        };
        this.open = false;
        this.disabled = false;
        this.focusTrapDisabled = false;
        this.form = undefined;
        this.readOnly = false;
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.validationMessage = undefined;
        this.validationIcon = undefined;
        this.name = undefined;
        this.numberingSystem = undefined;
        this.required = false;
        this.scale = "m";
        this.status = "idle";
        this.overlayPositioning = "absolute";
        this.placement = "auto";
        this.step = 60;
        this.value = null;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
    }
    openHandler() {
        onToggleOpenCloseComponent(this);
        if (this.disabled || this.readOnly) {
            this.open = false;
            return;
        }
        this.reposition(true);
    }
    handleFocusTrapDisabled(focusTrapDisabled) {
        if (!this.open) {
            return;
        }
        focusTrapDisabled ? deactivateFocusTrap(this) : activateFocusTrap(this);
    }
    handleDisabledAndReadOnlyChange(value) {
        if (!value) {
            this.open = false;
        }
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    numberingSystemWatcher(numberingSystem) {
        this.setInputValue(localizeTimeString({
            value: this.value,
            locale: this.effectiveLocale,
            numberingSystem,
            includeSeconds: this.shouldIncludeSeconds(),
            fractionalSecondDigits: decimalPlaces(this.step),
        }));
    }
    stepWatcher(newStep, oldStep) {
        if ((oldStep >= 60 && newStep > 0 && newStep < 60) ||
            (newStep >= 60 && oldStep > 0 && oldStep < 60)) {
            this.setValueDirectly(this.value);
        }
    }
    valueWatcher(newValue) {
        if (!this.userChangedValue) {
            this.setValueDirectly(newValue);
        }
        this.userChangedValue = false;
    }
    async effectiveLocaleWatcher(locale) {
        await this.loadDateTimeLocaleData();
        this.setInputValue(localizeTimeString({
            value: this.value,
            locale,
            numberingSystem: this.numberingSystem,
            includeSeconds: this.shouldIncludeSeconds(),
            fractionalSecondDigits: decimalPlaces(this.step),
        }));
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.el.focus();
    }
    /**
     * Updates the position of the component.
     *
     * @param delayed
     */
    async reposition(delayed = false) {
        this.popoverEl?.reposition(delayed);
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    onBeforeOpen() {
        this.calciteInputTimePickerBeforeOpen.emit();
    }
    onOpen() {
        this.calciteInputTimePickerOpen.emit();
    }
    onBeforeClose() {
        this.calciteInputTimePickerBeforeClose.emit();
    }
    onClose() {
        this.calciteInputTimePickerClose.emit();
    }
    delocalizeTimeString(value) {
        // we need to set the corresponding locale before parsing, otherwise it defaults to English (possible dayjs bug)
        dayjs.locale(this.effectiveLocale.toLowerCase());
        const nonFractionalSecondParts = this.delocalizeTimeStringToParts(value);
        let delocalizedTimeString;
        if (this.shouldIncludeFractionalSeconds()) {
            const stepPrecision = decimalPlaces(this.step);
            const centisecondParts = this.delocalizeTimeStringToParts(value, "S");
            if (stepPrecision === 1) {
                delocalizedTimeString =
                    centisecondParts.millisecond !== 0
                        ? this.getTimeStringFromParts(centisecondParts)
                        : this.getTimeStringFromParts(nonFractionalSecondParts);
            }
            else {
                const decisecondParts = this.delocalizeTimeStringToParts(value, "SS");
                if (stepPrecision === 2) {
                    if (decisecondParts.millisecond !== 0) {
                        delocalizedTimeString = this.getTimeStringFromParts(decisecondParts);
                    }
                    else if (centisecondParts.millisecond !== 0) {
                        delocalizedTimeString = this.getTimeStringFromParts(centisecondParts);
                    }
                    else {
                        delocalizedTimeString = this.getTimeStringFromParts(nonFractionalSecondParts);
                    }
                }
                else if (stepPrecision >= 3) {
                    const millisecondParts = this.delocalizeTimeStringToParts(value, "SSS");
                    if (millisecondParts.millisecond !== 0) {
                        delocalizedTimeString = this.getTimeStringFromParts(millisecondParts);
                    }
                    else if (decisecondParts.millisecond !== 0) {
                        delocalizedTimeString = this.getTimeStringFromParts(decisecondParts);
                    }
                    else if (centisecondParts.millisecond !== 0) {
                        delocalizedTimeString = this.getTimeStringFromParts(centisecondParts);
                    }
                    else {
                        delocalizedTimeString = this.getTimeStringFromParts(nonFractionalSecondParts);
                    }
                }
            }
        }
        else {
            delocalizedTimeString = this.getTimeStringFromParts(nonFractionalSecondParts);
        }
        return delocalizedTimeString;
    }
    delocalizeTimeStringToParts(localizedTimeString, fractionalSecondFormatToken) {
        const ltsFormatString = this.localeConfig?.formats?.LTS;
        const fractionalSecondTokenMatch = ltsFormatString.match(/ss\.*(S+)/g);
        if (fractionalSecondFormatToken && this.shouldIncludeFractionalSeconds()) {
            const secondFormatToken = `ss.${fractionalSecondFormatToken}`;
            this.localeConfig.formats.LTS = fractionalSecondTokenMatch
                ? ltsFormatString.replace(fractionalSecondTokenMatch[0], secondFormatToken)
                : ltsFormatString.replace("ss", secondFormatToken);
        }
        else if (fractionalSecondTokenMatch) {
            this.localeConfig.formats.LTS = ltsFormatString.replace(fractionalSecondTokenMatch[0], "ss");
        }
        dayjs.updateLocale(this.getSupportedDayjsLocale(getSupportedLocale(this.effectiveLocale)), this.localeConfig);
        const dayjsParseResult = dayjs(localizedTimeString, ["LTS", "LT"]);
        if (dayjsParseResult.isValid()) {
            return {
                hour: dayjsParseResult.get("hour"),
                minute: dayjsParseResult.get("minute"),
                second: dayjsParseResult.get("second"),
                millisecond: dayjsParseResult.get("millisecond"),
            };
        }
        return {
            hour: null,
            minute: null,
            second: null,
            millisecond: null,
        };
    }
    getTimeStringFromParts(parts) {
        let timeString = "";
        if (!parts) {
            return timeString;
        }
        if (parts.hour !== null && parts.minute !== null) {
            timeString = `${formatTimePart(parts.hour)}:${formatTimePart(parts.minute)}`;
            if (this.shouldIncludeSeconds() && parts.second !== null) {
                timeString += `:${formatTimePart(parts.second)}`;
                if (this.shouldIncludeFractionalSeconds() && parts.millisecond !== null) {
                    const second = (parts.millisecond * 0.001).toFixed(decimalPlaces(this.step));
                    timeString += `.${second.toString().replace("0.", "")}`;
                }
            }
        }
        return timeString;
    }
    getSupportedDayjsLocale(locale) {
        const dayjsLocale = locale.toLowerCase();
        if (dayjsLocale === "no") {
            return "nb";
        }
        if (dayjsLocale === "pt-pt") {
            return "pt";
        }
        return dayjsLocale;
    }
    async loadDateTimeLocaleData() {
        let supportedLocale = getSupportedLocale(this.effectiveLocale).toLowerCase();
        supportedLocale = this.getSupportedDayjsLocale(supportedLocale);
        const { default: localeConfig } = await supportedDayjsLocaleToLocaleConfigImport.get(supportedLocale)();
        this.localeConfig = localeConfig;
        dayjs.locale(this.localeConfig, null, true);
        dayjs.updateLocale(supportedLocale, this.getExtendedLocaleConfig(supportedLocale));
    }
    getExtendedLocaleConfig(locale) {
        if (locale === "ar") {
            return {
                meridiem: (hour) => (hour > 12 ? "م" : "ص"),
                formats: {
                    LT: "HH:mm A",
                    LTS: "HH:mm:ss A",
                    L: "DD/MM/YYYY",
                    LL: "D MMMM YYYY",
                    LLL: "D MMMM YYYY HH:mm A",
                    LLLL: "dddd D MMMM YYYY HH:mm A",
                },
            };
        }
        if (locale === "en-au") {
            return {
                meridiem: (hour) => (hour > 12 ? "pm" : "am"),
            };
        }
        if (locale === "en-ca") {
            return {
                meridiem: (hour) => (hour > 12 ? "p.m." : "a.m."),
            };
        }
        if (locale === "el") {
            return {
                meridiem: (hour) => (hour > 12 ? "μ.μ." : "π.μ."),
            };
        }
        if (locale === "hi") {
            return {
                formats: {
                    LT: "h:mm A",
                    LTS: "h:mm:ss A",
                    L: "DD/MM/YYYY",
                    LL: "D MMMM YYYY",
                    LLL: "D MMMM YYYY, h:mm A",
                    LLLL: "dddd, D MMMM YYYY, h:mm A",
                },
                meridiem: (hour) => (hour > 12 ? "pm" : "am"),
            };
        }
        if (locale === "ko") {
            return {
                meridiem: (hour) => (hour > 12 ? "오후" : "오전"),
            };
        }
        if (locale === "zh-tw") {
            return {
                formats: {
                    LT: "AHH:mm",
                    LTS: "AHH:mm:ss",
                },
            };
        }
        if (locale === "zh-hk") {
            return {
                formats: {
                    LT: "AHH:mm",
                    LTS: "AHH:mm:ss",
                },
                meridiem: (hour) => (hour > 12 ? "下午" : "上午"),
            };
        }
    }
    onLabelClick() {
        this.setFocus();
    }
    shouldIncludeSeconds() {
        return this.step < 60;
    }
    shouldIncludeFractionalSeconds() {
        return decimalPlaces(this.step) > 0;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        if (isValidTime(this.value)) {
            this.setValueDirectly(this.value);
        }
        else {
            this.value = undefined;
        }
        connectLabel(this);
        connectForm(this);
        connectMessages(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await Promise.all([setUpMessages(this), this.loadDateTimeLocaleData()]);
        if (this.open) {
            onToggleOpenCloseComponent(this);
        }
    }
    componentDidLoad() {
        setComponentLoaded(this);
        if (isValidTime(this.value)) {
            this.setInputValue(localizeTimeString({
                value: this.value,
                locale: this.effectiveLocale,
                numberingSystem: this.numberingSystem,
                includeSeconds: this.shouldIncludeSeconds(),
                fractionalSecondDigits: decimalPlaces(this.step),
            }));
        }
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
        disconnectLocalized(this);
        deactivateFocusTrap(this);
        disconnectMessages(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const { disabled, messages, readOnly, dialogId } = this;
        return (hAsync(Host, { onBlur: this.hostBlurHandler, onKeyDown: this.keyDownHandler }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: "input-wrapper", onClick: this.onInputWrapperClick }, hAsync("calcite-input-text", { "aria-autocomplete": "none", "aria-haspopup": "dialog", disabled: disabled, icon: "clock", id: this.referenceElementId, label: getLabelText(this), lang: this.effectiveLocale, onCalciteInputTextInput: this.calciteInternalInputInputHandler, onCalciteInternalInputTextFocus: this.calciteInternalInputFocusHandler, readOnly: readOnly, role: "combobox", scale: this.scale, status: this.status,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setInputAndTransitionEl }), !this.readOnly && this.renderToggleIcon(this.open)), hAsync("calcite-popover", { focusTrapDisabled: true, id: dialogId, label: messages.chooseTime, lang: this.effectiveLocale, onCalcitePopoverClose: this.popoverCloseHandler, onCalcitePopoverOpen: this.popoverOpenHandler, open: this.open, overlayPositioning: this.overlayPositioning, placement: this.placement, referenceElement: this.referenceElementId, triggerDisabled: true,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setCalcitePopoverEl }, hAsync("calcite-time-picker", { lang: this.effectiveLocale, messageOverrides: this.messageOverrides, numberingSystem: this.numberingSystem, onCalciteInternalTimePickerChange: this.timePickerChangeHandler, scale: this.scale, step: this.step, tabIndex: this.open ? undefined : -1, value: this.value,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setCalciteTimePickerEl })), hAsync(HiddenFormInputSlot, { component: this }), this.validationMessage && this.status === "invalid" ? (hAsync(Validation, { icon: this.validationIcon, message: this.validationMessage, scale: this.scale, status: this.status })) : null)));
    }
    renderToggleIcon(open) {
        return (hAsync("span", { class: CSS$N.toggleIcon }, hAsync("calcite-icon", { icon: open ? "chevron-up" : "chevron-down", scale: getIconScale(this.scale) })));
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "open": ["openHandler"],
        "focusTrapDisabled": ["handleFocusTrapDisabled"],
        "disabled": ["handleDisabledAndReadOnlyChange"],
        "readOnly": ["handleDisabledAndReadOnlyChange"],
        "messageOverrides": ["onMessagesChange"],
        "numberingSystem": ["numberingSystemWatcher"],
        "step": ["stepWatcher"],
        "value": ["valueWatcher"],
        "effectiveLocale": ["effectiveLocaleWatcher"]
    }; }
    static get style() { return inputTimePickerCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-input-time-picker",
        "$members$": {
            "open": [1540],
            "disabled": [516],
            "focusTrapDisabled": [516, "focus-trap-disabled"],
            "form": [513],
            "readOnly": [516, "read-only"],
            "messageOverrides": [1040],
            "messages": [1040],
            "validationMessage": [1, "validation-message"],
            "validationIcon": [520, "validation-icon"],
            "name": [1],
            "numberingSystem": [1, "numbering-system"],
            "required": [516],
            "scale": [513],
            "status": [513],
            "overlayPositioning": [1, "overlay-positioning"],
            "placement": [513],
            "step": [2],
            "value": [1025],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "setFocus": [64],
            "reposition": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["open", "open"], ["disabled", "disabled"], ["focusTrapDisabled", "focus-trap-disabled"], ["form", "form"], ["readOnly", "read-only"], ["validationIcon", "validation-icon"], ["required", "required"], ["scale", "scale"], ["status", "status"], ["placement", "placement"]]
    }; }
}

const hourToMinutes = 60;
const timeZoneNameBlockList = [
    "CET",
    "CST6CDT",
    "EET",
    "EST",
    "EST5EDT",
    "Factory",
    "HST",
    "MET",
    "MST",
    "MST7MDT",
    "PST8PDT",
    "UTC",
    "WET",
];
function timeZoneOffsetToDecimal(shortOffsetTimeZoneName) {
    const minusSign = "−";
    const hyphen = "-";
    return (shortOffsetTimeZoneName
        .replace(":15", ".25")
        .replace(":30", ".5")
        .replace(":45", ".75")
        // ensures decimal string representation is parseable
        .replace(minusSign, hyphen));
}
function toOffsetValue(timeZoneName, referenceDateInMs) {
    // we use "en-US" to allow us to reliably remove the standard time token
    const offset = getTimeZoneShortOffset(timeZoneName, "en-US", referenceDateInMs).replace("GMT", "");
    if (offset === "") {
        return 0;
    }
    return Number(timeZoneOffsetToDecimal(offset)) * hourToMinutes;
}
function getUserTimeZoneOffset() {
    const localDate = new Date();
    return localDate.getTimezoneOffset() * -1;
}
function getUserTimeZoneName() {
    const dateFormatter = new Intl.DateTimeFormat();
    return dateFormatter.resolvedOptions().timeZone;
}
/**
 * The lazy-loaded timezone-groups lib to be used across instances.
 */
let timeZoneGroups;
async function createTimeZoneItems(locale, messages, mode, referenceDate) {
    const referenceDateInMs = referenceDate.getTime();
    const timeZoneNames = Intl.supportedValuesOf("timeZone");
    if (mode === "offset") {
        if (!timeZoneGroups) {
            timeZoneGroups = Promise.all([
                Promise.resolve().then(function () { return index$1; }),
                Promise.resolve().then(function () { return index; }),
            ]);
        }
        return timeZoneGroups.then(async ([{ groupTimeZones }, { DateEngine }]) => {
            const timeZoneGroups = await groupTimeZones({
                dateEngine: new DateEngine(),
                groupDateRange: 1,
                startDate: new Date(referenceDateInMs).toISOString(),
            });
            const listFormatter = new Intl.ListFormat(locale, { style: "long", type: "conjunction" });
            // we remove blocked entries from tzs and adjust label indices accordingly
            timeZoneGroups.forEach((group) => {
                const indexOffsets = [];
                let removedSoFar = 0;
                group.tzs.forEach((tz, index) => {
                    if (timeZoneNameBlockList.includes(tz)) {
                        removedSoFar++;
                    }
                    indexOffsets[index] = removedSoFar;
                });
                group.tzs = group.tzs.filter((tz) => !timeZoneNameBlockList.includes(tz));
                group.labelTzIndices = group.labelTzIndices
                    .map((index) => index - indexOffsets[index])
                    .filter((index) => index >= 0 && index < group.tzs.length);
            });
            return timeZoneGroups
                .map(({ labelTzIndices, tzs }) => {
                const groupRepTz = tzs[0];
                const decimalOffset = timeZoneOffsetToDecimal(getTimeZoneShortOffset(groupRepTz, locale, referenceDateInMs));
                const value = toOffsetValue(groupRepTz, referenceDateInMs);
                const tzLabels = labelTzIndices.map((index) => {
                    const timeZone = tzs[index];
                    const timeZoneLabel = messages[timeZone];
                    return (timeZoneLabel ||
                        // get city token
                        timeZone.split("/").pop());
                });
                const label = createTimeZoneOffsetLabel(messages, decimalOffset, listFormatter.format(tzLabels));
                return {
                    label,
                    value,
                    filterValue: tzs.map((tz) => toUserFriendlyName(tz)),
                };
            })
                .filter((group) => !!group)
                .sort((groupA, groupB) => groupA.value - groupB.value);
        });
    }
    return timeZoneNames
        .map((timeZone) => {
        const label = toUserFriendlyName(timeZone);
        const value = timeZone;
        return {
            label,
            value,
            filterValue: timeZone,
        };
    })
        .filter((group) => !!group)
        .sort();
}
/**
 * Exported for testing purposes only
 *
 * @internal
 */
function toUserFriendlyName(timeZoneName) {
    return timeZoneName.replace(/_/g, " ");
}
function createTimeZoneOffsetLabel(messages, offsetLabel, groupLabel) {
    return messages.timeZoneLabel.replace("{offset}", offsetLabel).replace("{cities}", groupLabel);
}
function getTimeZoneShortOffset(timeZone, locale, referenceDateInMs = Date.now()) {
    const dateTimeFormat = getDateTimeFormat(locale, { timeZone, timeZoneName: "shortOffset" });
    const parts = dateTimeFormat.formatToParts(referenceDateInMs);
    return parts.find(({ type }) => type === "timeZoneName").value;
}

const inputTimeZoneCss = "/*!@:host([disabled])*/[disabled].sc-calcite-input-time-zone-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-input-time-zone-h *.sc-calcite-input-time-zone,.sc-calcite-input-time-zone-h[disabled].sc-calcite-input-time-zone-s>*,.sc-calcite-input-time-zone-h[disabled] .sc-calcite-input-time-zone-s>*{pointer-events:none}/*!@:host*/.sc-calcite-input-time-zone-h{display:block}/*!@:host([hidden])*/[hidden].sc-calcite-input-time-zone-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-input-time-zone{display:none}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-input-time-zone-h[disabled] .sc-calcite-input-time-zone-s>[calcite-hydrated][disabled],[disabled].sc-calcite-input-time-zone-h [calcite-hydrated][disabled].sc-calcite-input-time-zone{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-input-time-zone{display:contents}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-input-time-zone-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}";

class InputTimeZone {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInputTimeZoneBeforeClose = createEvent(this, "calciteInputTimeZoneBeforeClose", 6);
        this.calciteInputTimeZoneBeforeOpen = createEvent(this, "calciteInputTimeZoneBeforeOpen", 6);
        this.calciteInputTimeZoneChange = createEvent(this, "calciteInputTimeZoneChange", 6);
        this.calciteInputTimeZoneClose = createEvent(this, "calciteInputTimeZoneClose", 6);
        this.calciteInputTimeZoneOpen = createEvent(this, "calciteInputTimeZoneOpen", 6);
        this.setComboboxRef = (el) => {
            this.comboboxEl = el;
        };
        this.onComboboxBeforeClose = (event) => {
            event.stopPropagation();
            this.calciteInputTimeZoneBeforeClose.emit();
        };
        this.onComboboxBeforeOpen = (event) => {
            event.stopPropagation();
            this.calciteInputTimeZoneBeforeOpen.emit();
        };
        this.onComboboxChange = (event) => {
            event.stopPropagation();
            const combobox = event.target;
            const selected = this.findTimeZoneItem(combobox.selectedItems[0].getAttribute("data-value"));
            const selectedValue = `${selected.value}`;
            if (this.value === selectedValue) {
                return;
            }
            this.value = selectedValue;
            this.selectedTimeZoneItem = selected;
            this.calciteInputTimeZoneChange.emit();
        };
        this.onComboboxClose = (event) => {
            event.stopPropagation();
            this.open = false;
            this.calciteInputTimeZoneClose.emit();
        };
        this.onComboboxOpen = (event) => {
            this.open = true;
            event.stopPropagation();
            this.calciteInputTimeZoneOpen.emit();
        };
        this.disabled = false;
        this.form = undefined;
        this.maxItems = 0;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.mode = "offset";
        this.validationMessage = undefined;
        this.validationIcon = undefined;
        this.name = undefined;
        this.open = false;
        this.overlayPositioning = "absolute";
        this.referenceDate = undefined;
        this.required = false;
        this.scale = "m";
        this.status = "idle";
        this.value = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    handleTimeZoneItemPropsChange() {
        this.updateTimeZoneItemsAndSelection();
    }
    handleValueChange(value, oldValue) {
        const timeZoneItem = this.findTimeZoneItem(value);
        if (!timeZoneItem) {
            this.value = oldValue;
            return;
        }
        this.selectedTimeZoneItem = timeZoneItem;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    async setFocus() {
        await componentFocusable(this);
        await this.comboboxEl.setFocus();
    }
    effectiveLocaleWatcher() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    onLabelClick() {
        this.setFocus();
    }
    findTimeZoneItem(value) {
        const valueToMatch = value;
        return this.timeZoneItems.find(({ value }) => 
        // intentional == to match string to number
        value == valueToMatch);
    }
    async updateTimeZoneItemsAndSelection() {
        this.timeZoneItems = await this.createTimeZoneItems();
        const fallbackValue = this.mode === "offset" ? getUserTimeZoneOffset() : getUserTimeZoneName();
        const valueToMatch = this.value ?? fallbackValue;
        this.selectedTimeZoneItem = this.findTimeZoneItem(valueToMatch);
        if (!this.selectedTimeZoneItem) {
            this.selectedTimeZoneItem = this.findTimeZoneItem(fallbackValue);
        }
    }
    async createTimeZoneItems() {
        if (!this.effectiveLocale || !this.messages) {
            return [];
        }
        return createTimeZoneItems(this.effectiveLocale, this.messages, this.mode, this.referenceDate instanceof Date
            ? this.referenceDate
            : new Date(this.referenceDate ?? Date.now()));
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectForm(this);
        connectLabel(this);
        connectLocalized(this);
        connectMessages(this);
    }
    disconnectedCallback() {
        disconnectForm(this);
        disconnectLabel(this);
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
        await this.updateTimeZoneItemsAndSelection();
        const selectedValue = `${this.selectedTimeZoneItem.value}`;
        afterConnectDefaultValueSet(this, selectedValue);
        this.value = selectedValue;
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    render() {
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("calcite-combobox", { clearDisabled: true, disabled: this.disabled, label: this.messages.chooseTimeZone, lang: this.effectiveLocale, maxItems: this.maxItems, onCalciteComboboxBeforeClose: this.onComboboxBeforeClose, onCalciteComboboxBeforeOpen: this.onComboboxBeforeOpen, onCalciteComboboxChange: this.onComboboxChange, onCalciteComboboxClose: this.onComboboxClose, onCalciteComboboxOpen: this.onComboboxOpen, open: this.open, overlayPositioning: this.overlayPositioning, scale: this.scale, selectionMode: "single-persist", status: this.status, "validation-icon": this.validationIcon, "validation-message": this.validationMessage,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setComboboxRef }, this.timeZoneItems.map((group) => {
            const selected = this.selectedTimeZoneItem === group;
            const { label, value } = group;
            return (hAsync("calcite-combobox-item", { "data-value": value, key: label, selected: selected, textLabel: label, value: `${group.filterValue}` }));
        })), hAsync(HiddenFormInputSlot, { component: this }))));
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "messages": ["handleTimeZoneItemPropsChange"],
        "mode": ["handleTimeZoneItemPropsChange"],
        "referenceDate": ["handleTimeZoneItemPropsChange"],
        "value": ["handleValueChange"],
        "effectiveLocale": ["effectiveLocaleWatcher"]
    }; }
    static get style() { return inputTimeZoneCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-input-time-zone",
        "$members$": {
            "disabled": [516],
            "form": [513],
            "maxItems": [514, "max-items"],
            "messages": [1040],
            "messageOverrides": [1040],
            "mode": [513],
            "validationMessage": [1, "validation-message"],
            "validationIcon": [520, "validation-icon"],
            "name": [513],
            "open": [1540],
            "overlayPositioning": [513, "overlay-positioning"],
            "referenceDate": [1, "reference-date"],
            "required": [516],
            "scale": [513],
            "status": [513],
            "value": [1025],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["form", "form"], ["maxItems", "max-items"], ["mode", "mode"], ["validationIcon", "validation-icon"], ["name", "name"], ["open", "open"], ["overlayPositioning", "overlay-positioning"], ["required", "required"], ["scale", "scale"], ["status", "status"]]
    }; }
}

const CSS$M = {
    container: "container",
};

const labelCss = "/*!@:host([disabled])*/[disabled].sc-calcite-label-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-label-h *.sc-calcite-label,.sc-calcite-label-h[disabled].sc-calcite-label-s>*,.sc-calcite-label-h[disabled] .sc-calcite-label-s>*{pointer-events:none}/*!@:host*/.sc-calcite-label-h{display:flex}/*!@:host([alignment=start])*/[alignment=start].sc-calcite-label-h{text-align:start}/*!@:host([alignment=end])*/[alignment=end].sc-calcite-label-h{text-align:end}/*!@:host([alignment=center])*/[alignment=center].sc-calcite-label-h{text-align:center}/*!@:host([scale=s]) .container*/[scale=s].sc-calcite-label-h .container.sc-calcite-label{gap:0.25rem;font-size:var(--calcite-font-size--2);line-height:1rem;margin-block-end:var(--calcite-label-margin-bottom, 0.5rem)}/*!@:host([scale=m]) .container*/[scale=m].sc-calcite-label-h .container.sc-calcite-label{gap:0.5rem;font-size:var(--calcite-font-size--1);line-height:1rem;margin-block-end:var(--calcite-label-margin-bottom, 0.75rem)}/*!@:host([scale=l]) .container*/[scale=l].sc-calcite-label-h .container.sc-calcite-label{gap:0.5rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;margin-block-end:var(--calcite-label-margin-bottom, 1rem)}/*!@:host .container*/.sc-calcite-label-h .container.sc-calcite-label{margin-inline:0px;margin-block-start:0px;inline-size:100%;line-height:1.375;color:var(--calcite-color-text-1)}/*!@:host([layout=default]) .container*/[layout=default].sc-calcite-label-h .container.sc-calcite-label{display:flex;flex-direction:column}/*!@:host([layout=inline]) .container,\n:host([layout=inline-space-between]) .container*/[layout=inline].sc-calcite-label-h .container.sc-calcite-label,[layout=inline-space-between].sc-calcite-label-h .container.sc-calcite-label{display:flex;flex-direction:row;align-items:center;gap:0.5rem}/*!@:host([layout=inline][scale=l]) .container*/[layout=inline][scale=l].sc-calcite-label-h .container.sc-calcite-label{gap:0.75rem}/*!@:host([layout=inline-space-between]) .container*/[layout=inline-space-between].sc-calcite-label-h .container.sc-calcite-label{justify-content:space-between}/*!@:host([disabled]) > .container*/[disabled].sc-calcite-label-h>.container.sc-calcite-label{opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) ::slotted(*[disabled]),\n:host([disabled]) ::slotted(*[disabled] *)*/.sc-calcite-label-h[disabled].sc-calcite-label-s>*,.sc-calcite-label-h[disabled] .sc-calcite-label-s>*[disabled],.sc-calcite-label-h[disabled].sc-calcite-label-s>*[disabled] *,.sc-calcite-label-h[disabled] .sc-calcite-label-s>*[disabled] *{--tw-bg-opacity:1}/*!@:host([disabled]) ::slotted(calcite-input-message:not([active]))*/.sc-calcite-label-h[disabled] .sc-calcite-label-s>calcite-input-message:not([active]){--tw-bg-opacity:0}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-label-h[disabled] .sc-calcite-label-s>[calcite-hydrated][disabled],[disabled].sc-calcite-label-h [calcite-hydrated][disabled].sc-calcite-label{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-label{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-label-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-label{display:none}";

/**
 * @slot - A slot for adding text and a component that can be labeled.
 */
class Label {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalLabelClick = createEvent(this, "calciteInternalLabelClick", 2);
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.labelClickHandler = (event) => {
            this.calciteInternalLabelClick.emit({
                sourceEvent: event,
            });
        };
        this.alignment = "start";
        this.for = undefined;
        this.scale = "m";
        this.layout = "default";
    }
    handleForChange() {
        associateExplicitLabelToUnlabeledComponent(this.el);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        document.dispatchEvent(new CustomEvent(labelConnectedEvent));
    }
    disconnectedCallback() {
        document.dispatchEvent(new CustomEvent(labelDisconnectedEvent));
    }
    render() {
        return (hAsync(Host, { onClick: this.labelClickHandler }, hAsync("div", { class: CSS$M.container }, hAsync("slot", null))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "for": ["handleForChange"]
    }; }
    static get style() { return labelCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-label",
        "$members$": {
            "alignment": [513],
            "for": [513],
            "scale": [513],
            "layout": [513]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["alignment", "alignment"], ["for", "for"], ["scale", "scale"], ["layout", "layout"]]
    }; }
}

const linkCss = "/*!@:host([disabled])*/[disabled].sc-calcite-link-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-link-h *.sc-calcite-link,.sc-calcite-link-h[disabled].sc-calcite-link-s>*,.sc-calcite-link-h[disabled] .sc-calcite-link-s>*{pointer-events:none}/*!@:host*/.sc-calcite-link-h{display:inline}/*!@:host a,\n:host span*/.sc-calcite-link-h a.sc-calcite-link,.sc-calcite-link-h span.sc-calcite-link{position:relative;display:flex;cursor:pointer;align-items:center;justify-content:center;border-radius:0px;border-style:none;font-family:inherit;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;text-decoration:none;line-height:inherit;font-size:inherit;-webkit-appearance:none}/*!@:host a:hover,\n:host span:hover*/.sc-calcite-link-h a.sc-calcite-link:hover,.sc-calcite-link-h span.sc-calcite-link:hover{text-decoration:none}/*!@:host a,\n:host span*/.sc-calcite-link-h a.sc-calcite-link,.sc-calcite-link-h span.sc-calcite-link{outline-color:transparent}/*!@:host a:focus,\n:host span:focus*/.sc-calcite-link-h a.sc-calcite-link:focus,.sc-calcite-link-h span.sc-calcite-link:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@calcite-icon*/calcite-icon.sc-calcite-link{inline-size:1em;block-size:1em;min-inline-size:unset;min-block-size:unset}/*!@.calcite-link--icon*/.calcite-link--icon.sc-calcite-link{vertical-align:middle;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;margin-block-start:-0.25em}/*!@:host .calcite-link--icon.icon-start*/.sc-calcite-link-h .calcite-link--icon.icon-start.sc-calcite-link{margin-inline-end:0.5rem}/*!@:host .calcite-link--icon.icon-end*/.sc-calcite-link-h .calcite-link--icon.icon-end.sc-calcite-link{margin-inline-start:0.5rem}/*!@:host span,\n:host a*/.sc-calcite-link-h span.sc-calcite-link,.sc-calcite-link-h a.sc-calcite-link{position:relative;display:inline;border-style:none;background-color:transparent;padding:0px;color:var(--calcite-color-text-link);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;line-height:inherit;white-space:initial;background-image:linear-gradient(currentColor, currentColor), linear-gradient(var(--calcite-color-brand-underline), var(--calcite-color-brand-underline));background-position-x:0%, 100%;background-position-y:min(1.5em, 100%);background-repeat:no-repeat, no-repeat;background-size:0% 1px, 100% 1px}/*!@:host span:hover, :host span:focus,\n:host a:hover,\n:host a:focus*/.sc-calcite-link-h span.sc-calcite-link:hover,.sc-calcite-link-h span.sc-calcite-link:focus,.sc-calcite-link-h a.sc-calcite-link:hover,.sc-calcite-link-h a.sc-calcite-link:focus{background-size:100% 1px, 100% 1px}/*!@:host span:active,\n:host a:active*/.sc-calcite-link-h span.sc-calcite-link:active,.sc-calcite-link-h a.sc-calcite-link:active{background-size:100% 2px, 100% 2px}/*!@:host span.calcite--rtl,\n:host a.calcite--rtl*/.sc-calcite-link-h span.calcite--rtl.sc-calcite-link,.sc-calcite-link-h a.calcite--rtl.sc-calcite-link{background-position:100% 100%, 100% 100%}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-link-h[disabled] .sc-calcite-link-s>[calcite-hydrated][disabled],[disabled].sc-calcite-link-h [calcite-hydrated][disabled].sc-calcite-link{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-link{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-link-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-link{display:none}";

/** Any attributes placed on <calcite-link> component will propagate to the rendered child */
/** Passing a 'href' will render an anchor link, instead of a span. Role will be set to link, or link, depending on this. */
/** It is the consumers responsibility to add aria information, rel, target, for links, and any link attributes for form submission */
/** @slot - A slot for adding text. */
class Link {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.childElClickHandler = (event) => {
            if (!event.isTrusted) {
                // click was invoked internally, we stop it here
                event.stopPropagation();
            }
        };
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.storeTagRef = (el) => {
            this.childEl = el;
        };
        this.disabled = false;
        this.download = false;
        this.href = undefined;
        this.iconEnd = undefined;
        this.iconFlipRtl = undefined;
        this.iconStart = undefined;
        this.rel = undefined;
        this.target = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
    }
    render() {
        const { download, el } = this;
        const dir = getElementDir(el);
        const childElType = this.href ? "a" : "span";
        const iconStartEl = (hAsync("calcite-icon", { class: "calcite-link--icon icon-start", flipRtl: this.iconFlipRtl === "start" || this.iconFlipRtl === "both", icon: this.iconStart, scale: "s" }));
        const iconEndEl = (hAsync("calcite-icon", { class: "calcite-link--icon icon-end", flipRtl: this.iconFlipRtl === "end" || this.iconFlipRtl === "both", icon: this.iconEnd, scale: "s" }));
        const Tag = childElType;
        const role = childElType === "span" ? "link" : null;
        const tabIndex = childElType === "span" ? 0 : null;
        return (hAsync(Host, { role: "presentation" }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync(Tag, { class: { [CSS_UTILITY.rtl]: dir === "rtl" },
            /*
          When the 'download' property of type 'boolean | string' is set to true, the value is "".
          This works around that issue for now.
          */
            download: Tag === "a" && (download === "" || download) ? download : null, href: Tag === "a" && this.href, onClick: this.childElClickHandler, rel: Tag === "a" && this.rel, role: role, tabIndex: tabIndex, target: Tag === "a" && this.target,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeTagRef }, this.iconStart ? iconStartEl : null, hAsync("slot", null), this.iconEnd ? iconEndEl : null))));
    }
    //--------------------------------------------------------------------------
    //
    //  Events
    //
    //--------------------------------------------------------------------------
    clickHandler(event) {
        if (this.disabled) {
            return;
        }
        // forwards the click() to the internal link for non user-initiated events
        if (!event.isTrusted) {
            this.childEl.click();
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        focusElement(this.childEl);
    }
    get el() { return getElement(this); }
    static get style() { return linkCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-link",
        "$members$": {
            "disabled": [516],
            "download": [520],
            "href": [513],
            "iconEnd": [513, "icon-end"],
            "iconFlipRtl": [513, "icon-flip-rtl"],
            "iconStart": [513, "icon-start"],
            "rel": [1],
            "target": [1],
            "setFocus": [64]
        },
        "$listeners$": [[0, "click", "clickHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["download", "download"], ["href", "href"], ["iconEnd", "icon-end"], ["iconFlipRtl", "icon-flip-rtl"], ["iconStart", "icon-start"]]
    }; }
}

const CSS$L = {
    container: "container",
    containerHover: "container--hover",
    containerBorder: "container--border",
    containerBorderSelected: "container--border-selected",
    containerBorderUnselected: "container--border-unselected",
    contentContainer: "content-container",
    contentContainerSelectable: "content-container--selectable",
    contentContainerHasCenterContent: "content-container--has-center-content",
    nestedContainer: "nested-container",
    nestedContainerHidden: "nested-container--hidden",
    content: "content",
    customContent: "custom-content",
    actionsStart: "actions-start",
    contentStart: "content-start",
    label: "label",
    description: "description",
    contentEnd: "content-end",
    contentBottom: "content-bottom",
    actionsEnd: "actions-end",
    selectionContainer: "selection-container",
    selectionContainerSingle: "selection-container--single",
    openContainer: "open-container",
    dragContainer: "drag-container",
};
const SLOTS$i = {
    actionsStart: "actions-start",
    contentStart: "content-start",
    content: "content",
    contentBottom: "content-bottom",
    contentEnd: "content-end",
    actionsEnd: "actions-end",
};
// Set to zero to extend until the end of the table section.
const MAX_COLUMNS = 0;
const ICONS$8 = {
    selectedMultiple: "check-square-f",
    selectedSingle: "bullet-point-large",
    unselectedMultiple: "square",
    unselectedSingle: "bullet-point-large",
    closedLTR: "chevron-right",
    closedRTL: "chevron-left",
    open: "chevron-down",
    blank: "blank",
    close: "x",
};
const activeCellTestAttribute = "data-test-active";

const listSelector$1 = "calcite-list";
const listItemGroupSelector = "calcite-list-item-group";
const listItemSelector$1 = "calcite-list-item";
function getListItemChildLists(slotEl) {
    return Array.from(slotEl.assignedElements({ flatten: true }).filter((el) => el.matches(listSelector$1)));
}
function getListItemChildren(slotEl) {
    const assignedElements = slotEl.assignedElements({ flatten: true });
    const listItemGroupChildren = assignedElements.filter((el) => el?.matches(listItemGroupSelector))
        .map((group) => Array.from(group.querySelectorAll(listItemSelector$1)))
        .reduce((previousValue, currentValue) => [...previousValue, ...currentValue], []);
    const listItemChildren = assignedElements.filter((el) => el?.matches(listItemSelector$1));
    const listItemListChildren = assignedElements.filter((el) => el?.matches(listSelector$1))
        .map((list) => Array.from(list.querySelectorAll(listItemSelector$1)))
        .reduce((previousValue, currentValue) => [...previousValue, ...currentValue], []);
    return [...listItemListChildren, ...listItemGroupChildren, ...listItemChildren];
}
function updateListItemChildren(listItemChildren) {
    listItemChildren.forEach((listItem) => {
        listItem.setPosition = listItemChildren.indexOf(listItem) + 1;
        listItem.setSize = listItemChildren.length;
    });
}
function getDepth(element, includeGroup = false) {
    {
        return 0;
    }
}

const CSS$K = {
    container: "container",
    table: "table",
    scrim: "scrim",
    stack: "stack",
    tableContainer: "table-container",
    sticky: "sticky-pos",
    assistiveText: "assistive-text",
};
const debounceTimeout = 0;
const SLOTS$h = {
    filterNoResults: "filter-no-results",
    filterActionsStart: "filter-actions-start",
    filterActionsEnd: "filter-actions-end",
};

/**!
 * Sortable 1.15.1
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

var version = "1.15.1";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches( /**HTMLElement*/el, /**String*/selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest( /**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }
      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = '';
  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');
      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
      i = 0,
      n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}

/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode;

    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect();

          // Set relative to edges of padding box of container
          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
      scaleX = elMatrix && elMatrix.a,
      scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}

/**
 * Returns the content rect of the element (bounding rect minus border and padding)
 * @param {HTMLElement} el 
 */
function getContentRect(el) {
  var rect = getRect(el);
  var paddingLeft = parseInt(css(el, 'padding-left')),
    paddingTop = parseInt(css(el, 'padding-top')),
    paddingRight = parseInt(css(el, 'padding-right')),
    paddingBottom = parseInt(css(el, 'padding-bottom'));
  rect.top += paddingTop + parseInt(css(el, 'border-top-width'));
  rect.left += paddingLeft + parseInt(css(el, 'border-left-width'));
  // Client Width/Height includes padding only
  rect.width = el.clientWidth - paddingLeft - paddingRight;
  rect.height = el.clientHeight - paddingTop - paddingBottom;
  rect.bottom = rect.top + rect.height;
  rect.right = rect.left + rect.width;
  return rect;
}

/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
    elSideVal = getRect(el)[elSide];

  /* jshint boss:true */
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
      visible = void 0;
    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}

/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
    i = 0,
    children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}

/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}

/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */
function index$2(el, selector) {
  var index = 0;
  if (!el || !el.parentNode) {
    return -1;
  }

  /* jshint boss:true */
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }
  return index;
}

/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */
function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
    offsetTop = 0,
    winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el),
        scaleX = elMatrix.a,
        scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}

/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
        _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
    animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);

        // If animating: compensate for current animation
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }
      var animating = false,
        animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
          target = state.target,
          fromRect = target.fromRect,
          toRect = getRect(target),
          prevFromRect = target.prevFromRect,
          prevToRect = target.prevToRect,
          animatingRect = state.rect,
          targetMatrix = matrix(target, true);
        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&
          // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }

        // if fromRect != toRect: animate
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d,
          translateX = (currentRect.left - toRect.left) / (scaleX || 1),
          translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }
    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function () {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return;
      // Fire global events if it exists in this sortable
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      }

      // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;

      // Add default options from plugin
      _extends(defaults, initialized.defaults);
    });
    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);
      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return;

      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
    rootEl = _ref.rootEl,
    name = _ref.name,
    targetEl = _ref.targetEl,
    cloneEl = _ref.cloneEl,
    toEl = _ref.toEl,
    fromEl = _ref.fromEl,
    oldIndex = _ref.oldIndex,
    newIndex = _ref.newIndex,
    oldDraggableIndex = _ref.oldDraggableIndex,
    newDraggableIndex = _ref.newDraggableIndex,
    originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
    options = sortable.options,
    onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }
  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];
var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    originalEvent = _ref.evt,
    data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}
var dragEl,
  parentEl,
  ghostEl,
  rootEl,
  nextEl,
  lastDownEl,
  cloneEl,
  cloneHidden,
  oldIndex,
  newIndex,
  oldDraggableIndex,
  newDraggableIndex,
  activeGroup,
  putSortable,
  awaitingDragStarted = false,
  ignoreNextClick = false,
  sortables = [],
  tapEvt,
  touchEvt,
  lastDx,
  lastDy,
  tapDistanceLeft,
  tapDistanceTop,
  moved,
  lastTarget,
  lastDirection,
  pastFirstInvertThresh = false,
  isCircumstantialInvert = false,
  targetMoveDistance,
  // For positioning ghost absolutely
  ghostRelativeParent,
  ghostRelativeParentInitialScroll = [],
  // (left, top)

  _silent = false,
  savedInputChecked = [];

/** @const */
var documentExists = typeof document !== 'undefined',
  PositionGhostAbsolutely = IOS,
  CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
  // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
  supportCssPointerEvents = function () {
    if (!documentExists) return;
    // false when <= IE11
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
  _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }
    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }
    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
  _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },
  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
  _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
  _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
  _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  };

// #1184 fix - Prevent click event on fallback if dragged but item not changed position
if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      // Create imitation event
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};

/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el; // root element
  this.options = options = _extends({}, options);

  // Export instance
  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults);

  // Set default options
  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }
  _prepareGroup(options);

  // Bind all private methods
  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  }

  // Setup drag mode
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  }

  // Bind events
  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }
  sortables.push(this.el);

  // Restore sorting
  options.store && options.store.get && this.sort(options.store.get(this) || []);

  // Add animation state manager
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {
    if (!evt.cancelable) return;
    var _this = this,
      el = this.el,
      options = this.options,
      preventOnFilter = options.preventOnFilter,
      type = evt.type,
      touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
      target = (touch || evt).target,
      originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
      filter = options.filter;
    _saveInputCheckedState(el);

    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    }

    // cancel dnd if original target is content editable
    if (originalTarget.isContentEditable) {
      return;
    }

    // Safari ignores further event handling after mousedown
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    }

    // Get the index of the dragged element within its parent
    oldIndex = index$2(target);
    oldDraggableIndex = index$2(target, options.draggable);

    // Check filter
    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }

    // Prepare `dragstart`
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {
    var _this = this,
      el = _this.el,
      options = _this.options,
      ownerDocument = el.ownerDocument,
      dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';
      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }

        // Bind the events: dragstart/dragend
        _this._triggerDragStart(evt, touch);

        // Drag start event
        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        });

        // Chosen item
        toggleClass(dragEl, options.chosenClass, true);
      };

      // Disable "draggable"
      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop);

      // Make dragEl draggable (must be before delay for FireFox)
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent('delayStart', this, {
        evt: evt
      });

      // Delay is impossible for native DnD in Edge or IE
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag
        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart( /** Event */evt, /** Touch */touch) {
    touch = touch || evt.pointerType == 'touch' && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }
    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });
      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }
      var options = this.options;

      // Apply effect
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();

      // Drag start event
      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        const host = target.getRootNode().host;
        if (host) {
          target = host;
        }
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent; // store last element
        }
        /* jshint boss:true */ while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove( /**TouchEvent*/evt) {
    if (tapEvt) {
      var options = this.options,
        fallbackTolerance = options.fallbackTolerance,
        fallbackOffset = options.fallbackOffset,
        touch = evt.touches ? evt.touches[0] : evt,
        ghostMatrix = ghostEl && matrix(ghostEl, true),
        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);

      // only set the status to dragging, when we are actually dragging
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
        options = this.options;

      // Position absolutely
      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);

      // Set transform-origin
      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart( /**Event*/evt, /**boolean*/fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent('setupClone', this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }

    // #1143: IFrame support workaround
    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);

    // Set proper drop events
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, 'drop', _this);

      // #1276 fix:
      css(dragEl, 'transform', 'translateZ(0)');
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;
    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver( /**Event*/evt) {
    var el = this.el,
      target = evt.target,
      dragRect,
      targetRect,
      revert,
      options = this.options,
      group = options.group,
      activeSortable = Sortable.active,
      isOwner = activeGroup === group,
      canSort = options.sort,
      fromSortable = putSortable || activeSortable,
      vertical,
      _this = this,
      completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    }

    // Capture animation state
    function capture() {
      dragOverEvent('dragOverAnimationCapture');
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }

    // Return invocation when dragEl is inserted (or completed)
    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }

        // Animation
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }

      // Null lastTarget if it is not inside a previously swapped element
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }

      // no bubbling and not fallback
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);

        // Do not detect for empty insert if already inserted
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }

    // Call when dragEl has been inserted
    function changed() {
      newIndex = index$2(dragEl);
      newDraggableIndex = index$2(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl; // actualization
        capture();
        this._hideClone();
        dragOverEvent('revert');
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list

        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        }

        // if there is a last element, it is the target
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
          targetBeforeFirstSwap,
          differentLevel = dragEl.parentNode !== el,
          differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
          side1 = vertical ? 'top' : 'left',
          scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index$2(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        }
        // If dragEl is already beside target: Do not insert
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
          after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }

          // Undo chrome's scroll adjustment (has no effect on other browsers)
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode; // actualization

          // must be done before animation
          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop( /**Event*/evt) {
    var el = this.el,
      options = this.options;

    // Get the index of the dragged element within its parent
    newIndex = index$2(dragEl);
    newDraggableIndex = index$2(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode;

    // Get again after plugin event
    newIndex = index$2(dragEl);
    newDraggableIndex = index$2(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);

    // Unbind events
    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, 'user-select', '');
    }
    css(dragEl, 'transform', '');
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }
        _disableDraggable(dragEl);
        dragEl.style['will-change'] = '';

        // Remove classes
        // ghostClass is added in dragStarted
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);

        // Drag stop event
        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            // Remove event
            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            });

            // drag from one list and drop into another
            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          });

          // Save sorting
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent( /**Event*/evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);
        break;
      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
      el,
      children = this.el.children,
      i = 0,
      n = children.length,
      options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
      rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];
      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);
    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    }
    // Remove draggable attributes
    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return;

      // show clone at dragEl or original position
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};
function _globalDragOver( /**Event*/evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
    sortable = fromEl[expando],
    onMoveFn = sortable.options.onMove,
    retVal;
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var sortableContentRect = getContentRect(sortable.el);
  var spacer = 10;
  return vertical ? evt.clientX < sortableContentRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < sortableContentRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var sortableContentRect = getContentRect(sortable.el);
  var spacer = 10;
  return vertical ? evt.clientX > sortableContentRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > sortableContentRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
    targetLength = vertical ? targetRect.height : targetRect.width,
    targetS1 = vertical ? targetRect.top : targetRect.left,
    targetS2 = vertical ? targetRect.bottom : targetRect.right,
    invert = false;
  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}

/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */
function _getInsertDirection(target) {
  if (index$2(dragEl) < index$2(target)) {
    return 1;
  } else {
    return -1;
  }
}

/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
    i = str.length,
    sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}

// Fixed #973:
if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}

// Export utils
Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index$2,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};

/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */
Sortable.get = function (element) {
  return element[expando];
};

/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */
Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }
  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};

/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */
Sortable.create = function (el, options) {
  return new Sortable(el, options);
};

// Export
Sortable.version = version;

var autoScrolls = [],
  scrollEl,
  scrollRootEl,
  scrolling = false,
  lastAutoScrollX,
  lastAutoScrollY,
  touchEvt$1,
  pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };

    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;

      // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);

        // Listener for pointer element change
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          // Detect for pointer elem change, emulating native DnD behaviour
          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
    y = (evt.touches ? evt.touches[0] : evt).clientY,
    sens = options.scrollSensitivity,
    speed = options.scrollSpeed,
    winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
    scrollCustomFn;

  // New scroll root, set scrollEl
  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent,
      rect = getRect(el),
      top = rect.top,
      bottom = rect.bottom,
      left = rect.left,
      right = rect.right,
      width = rect.width,
      height = rect.height,
      canScrollX = void 0,
      canScrollY = void 0,
      scrollWidth = el.scrollWidth,
      scrollHeight = el.scrollHeight,
      elCSS = css(el),
      scrollPosX = el.scrollLeft,
      scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */
        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    dragEl = _ref.dragEl,
    activeSortable = _ref.activeSortable,
    dispatchSortableEvent = _ref.dispatchSortableEvent,
    hideGhostForTarget = _ref.hideGhostForTarget,
    unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};
function Revert() {}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
      putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable) {
      putSortable.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }
    this.sortable.animateAll();
    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};
_extends(Revert, {
  pluginName: 'revertOnSpill'
});
function Remove() {}
Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
      putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};
_extends(Remove, {
  pluginName: 'removeOnSpill'
});

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

const sortableComponentSet = new Set();
const CSS$J = {
    ghostClass: "calcite-sortable--ghost",
    chosenClass: "calcite-sortable--chosen",
    dragClass: "calcite-sortable--drag",
    fallbackClass: "calcite-sortable--fallback",
};
/**
 * Helper to keep track of a SortableComponent. This should be called in the `connectedCallback` lifecycle method as well as any other method necessary to rebuild the sortable instance.
 *
 * @param {SortableComponent} component - The sortable component.
 */
function connectSortableComponent(component) {
    disconnectSortableComponent(component);
    sortableComponentSet.add(component);
    const dataIdAttr = "id";
    const { group, handleSelector: handle, dragSelector: draggable } = component;
    component.sortable = Sortable.create(component.el, {
        dataIdAttr,
        ...CSS$J,
        ...(!!draggable && { draggable }),
        ...(!!group && {
            group: {
                name: group,
                ...(!!component.canPull && {
                    pull: (to, from, dragEl, { newIndex, oldIndex }) => component.canPull({ toEl: to.el, fromEl: from.el, dragEl, newIndex, oldIndex }),
                }),
                ...(!!component.canPut && {
                    put: (to, from, dragEl, { newIndex, oldIndex }) => component.canPut({ toEl: to.el, fromEl: from.el, dragEl, newIndex, oldIndex }),
                }),
            },
        }),
        handle,
        filter: "[drag-disabled]",
        onStart: ({ from: fromEl, item: dragEl, to: toEl, newIndex, oldIndex }) => {
            dragState.active = true;
            onGlobalDragStart();
            component.onDragStart({ fromEl, dragEl, toEl, newIndex, oldIndex });
        },
        onEnd: ({ from: fromEl, item: dragEl, to: toEl, newIndex, oldIndex }) => {
            dragState.active = false;
            onGlobalDragEnd();
            component.onDragEnd({ fromEl, dragEl, toEl, newIndex, oldIndex });
        },
        onSort: ({ from: fromEl, item: dragEl, to: toEl, newIndex, oldIndex }) => {
            component.onDragSort({ fromEl, dragEl, toEl, newIndex, oldIndex });
        },
    });
}
/**
 * Helper to remove track of a SortableComponent. This should be called in the `disconnectedCallback` lifecycle method.
 *
 * @param {SortableComponent} component - The sortable component.
 */
function disconnectSortableComponent(component) {
    sortableComponentSet.delete(component);
    component.sortable?.destroy();
    component.sortable = null;
}
const dragState = { active: false };
/**
 * Helper to determine if dragging is currently active.
 *
 * @param component The sortable component.
 * @returns {boolean} a boolean value.
 */
function dragActive(component) {
    return component.dragEnabled && dragState.active;
}
function onGlobalDragStart() {
    Array.from(sortableComponentSet).forEach((component) => component.onGlobalDragStart());
}
function onGlobalDragEnd() {
    Array.from(sortableComponentSet).forEach((component) => component.onGlobalDragEnd());
}

const CSS$I = {
    container: "container",
    actionsStart: "actions-start",
    contentStart: "content-start",
    content: "content",
    contentEnd: "content-end",
    actionsEnd: "actions-end",
};
const SLOTS$g = {
    actionsStart: "actions-start",
    contentStart: "content-start",
    contentEnd: "content-end",
    actionsEnd: "actions-end",
};

const listCss = "/*!@:host([disabled])*/[disabled].sc-calcite-list-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-list-h *.sc-calcite-list,.sc-calcite-list-h[disabled].sc-calcite-list-s>*,.sc-calcite-list-h[disabled] .sc-calcite-list-s>*{pointer-events:none}/*!@:host*/.sc-calcite-list-h{display:block}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-list-h[disabled] .sc-calcite-list-s>[calcite-hydrated][disabled],[disabled].sc-calcite-list-h [calcite-hydrated][disabled].sc-calcite-list{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-list{display:contents}/*!@.container*/.container.sc-calcite-list{position:relative}/*!@.table-container*/.table-container.sc-calcite-list{box-sizing:border-box;display:flex;inline-size:100%;flex-direction:column;background-color:transparent}/*!@.table-container **/.table-container.sc-calcite-list *.sc-calcite-list{box-sizing:border-box}/*!@.table*/.table.sc-calcite-list{inline-size:100%;border-collapse:collapse}/*!@.stack*/.stack.sc-calcite-list{--calcite-stack-padding-inline:0;--calcite-stack-padding-block:0}/*!@::slotted(calcite-list-item)*/.sc-calcite-list-s>calcite-list-item{--tw-shadow:0 -1px 0 var(--calcite-color-border-3);--tw-shadow-colored:0 -1px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);margin-block-start:1px}/*!@::slotted(calcite-list-item:first-of-type)*/.sc-calcite-list-s>calcite-list-item:first-of-type{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@::slotted(calcite-list-item[data-filter])*/.sc-calcite-list-s>calcite-list-item[data-filter]{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);margin-block-start:0px}/*!@.sticky-pos*/.sticky-pos.sc-calcite-list{position:sticky;inset-block-start:0px;z-index:var(--calcite-z-index-sticky);background-color:var(--calcite-color-foreground-1)}/*!@.sticky-pos th*/.sticky-pos.sc-calcite-list th.sc-calcite-list{padding:0px}/*!@.assistive-text*/.assistive-text.sc-calcite-list{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}/*!@:host([hidden])*/[hidden].sc-calcite-list-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-list{display:none}";

const listItemSelector = "calcite-list-item";
const listItemSelectorDirect = `:scope > calcite-list-item`;
const parentSelector = "calcite-list-item-group, calcite-list-item";
/**
 * A general purpose list that enables users to construct list items that conform to Calcite styling.
 *
 * @slot - A slot for adding `calcite-list-item` elements.
 * @slot filter-actions-start - A slot for adding actionable `calcite-action` elements before the filter component.
 * @slot filter-actions-end - A slot for adding actionable `calcite-action` elements after the filter component.
 */
class List$1 {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteListChange = createEvent(this, "calciteListChange", 6);
        this.calciteListDragEnd = createEvent(this, "calciteListDragEnd", 6);
        this.calciteListDragStart = createEvent(this, "calciteListDragStart", 6);
        this.calciteListFilter = createEvent(this, "calciteListFilter", 6);
        this.calciteListOrderChange = createEvent(this, "calciteListOrderChange", 6);
        this.calciteInternalListDefaultSlotChange = createEvent(this, "calciteInternalListDefaultSlotChange", 6);
        this.dragSelector = listItemSelector;
        this.focusableItems = [];
        this.handleSelector = "calcite-handle";
        this.listItems = [];
        this.mutationObserver = createObserver();
        this.visibleItems = [];
        this.handleDefaultSlotChange = (event) => {
            updateListItemChildren(getListItemChildren(event.target));
            if (this.parentListEl) {
                this.calciteInternalListDefaultSlotChange.emit();
            }
        };
        this.handleFilterActionsStartSlotChange = (event) => {
            this.hasFilterActionsStart = slotChangeHasAssignedElement(event);
        };
        this.handleFilterActionsEndSlotChange = (event) => {
            this.hasFilterActionsEnd = slotChangeHasAssignedElement(event);
        };
        this.handleFilterNoResultsSlotChange = (event) => {
            this.hasFilterNoResults = slotChangeHasAssignedElement(event);
        };
        this.setActiveListItem = () => {
            const { focusableItems } = this;
            if (!focusableItems.some((item) => item.active)) {
                if (focusableItems[0]) {
                    focusableItems[0].active = true;
                }
            }
        };
        this.updateSelectedItems = (emit = false) => {
            this.selectedItems = this.visibleItems.filter((item) => item.selected);
            if (emit) {
                this.calciteListChange.emit();
            }
        };
        this.updateFilteredItems = (emit = false) => {
            const { visibleItems, filteredData, filterText } = this;
            const values = filteredData.map((item) => item.value);
            const lastDescendantItems = visibleItems?.filter((listItem) => visibleItems.every((li) => li === listItem || !listItem.contains(li)));
            const filteredItems = visibleItems.filter((item) => !filterText || values.includes(item.value)) || [];
            const visibleParents = new WeakSet();
            lastDescendantItems.forEach((listItem) => this.filterElements({ el: listItem, filteredItems, visibleParents }));
            if (filteredItems.length > 0) {
                this.findAncestorOfFirstFilteredItem(filteredItems);
            }
            this.filteredItems = filteredItems;
            if (emit) {
                this.calciteListFilter.emit();
            }
        };
        this.setFilterEl = (el) => {
            this.filterEl = el;
            this.performFilter();
        };
        this.handleFilterChange = (event) => {
            event.stopPropagation();
            const { value } = event.currentTarget;
            this.filterText = value;
            this.updateFilteredData(true);
        };
        this.getItemData = () => {
            return this.listItems.map((item) => ({
                label: item.label,
                description: item.description,
                metadata: item.metadata,
                value: item.value,
            }));
        };
        this.updateListItems = debounce((emit = false) => {
            const { selectionAppearance, selectionMode, dragEnabled } = this;
            if (!!this.parentListEl) {
                const items = this.queryListItems(true);
                items.forEach((item) => {
                    item.dragHandle = dragEnabled;
                });
                this.setUpSorting();
                return;
            }
            const items = this.queryListItems();
            items.forEach((item) => {
                item.selectionAppearance = selectionAppearance;
                item.selectionMode = selectionMode;
            });
            const dragItems = this.queryListItems(true);
            dragItems.forEach((item) => {
                item.dragHandle = dragEnabled;
            });
            this.listItems = items;
            if (this.filterEnabled) {
                this.dataForFilter = this.getItemData();
                if (this.filterEl) {
                    this.filterEl.items = this.dataForFilter;
                }
            }
            this.visibleItems = this.listItems.filter((item) => !item.closed && !item.hidden);
            this.updateFilteredItems(emit);
            this.focusableItems = this.filteredItems.filter((item) => !item.disabled);
            this.setActiveListItem();
            this.updateSelectedItems(emit);
            this.setUpSorting();
        }, debounceTimeout);
        this.queryListItems = (direct = false) => {
            return Array.from(this.el.querySelectorAll(direct ? listItemSelectorDirect : listItemSelector));
        };
        this.focusRow = (focusEl) => {
            const { focusableItems } = this;
            if (!focusEl) {
                return;
            }
            focusableItems.forEach((listItem) => (listItem.active = listItem === focusEl));
            focusEl.setFocus();
        };
        this.isNavigable = (listItem) => {
            const parentListItemEl = listItem.parentElement?.closest(listItemSelector);
            if (!parentListItemEl) {
                return true;
            }
            return parentListItemEl.open && this.isNavigable(parentListItemEl);
        };
        this.handleListKeydown = (event) => {
            if (event.defaultPrevented || !!this.parentListEl) {
                return;
            }
            const { key } = event;
            const navigableItems = this.focusableItems.filter((listItem) => this.isNavigable(listItem));
            const currentIndex = navigableItems.findIndex((listItem) => listItem.active);
            if (key === "ArrowDown") {
                event.preventDefault();
                const nextIndex = event.target === this.filterEl ? 0 : currentIndex + 1;
                if (navigableItems[nextIndex]) {
                    this.focusRow(navigableItems[nextIndex]);
                }
            }
            else if (key === "ArrowUp") {
                event.preventDefault();
                if (currentIndex === 0 && this.filterEnabled) {
                    this.filterEl?.setFocus();
                    return;
                }
                const prevIndex = currentIndex - 1;
                if (navigableItems[prevIndex]) {
                    this.focusRow(navigableItems[prevIndex]);
                }
            }
            else if (key === "Home") {
                event.preventDefault();
                const homeItem = navigableItems[0];
                if (homeItem) {
                    this.focusRow(homeItem);
                }
            }
            else if (key === "End") {
                event.preventDefault();
                const endItem = navigableItems[navigableItems.length - 1];
                if (endItem) {
                    this.focusRow(endItem);
                }
            }
        };
        this.findAncestorOfFirstFilteredItem = (filteredItems) => {
            this.ancestorOfFirstFilteredItem?.removeAttribute("data-filter");
            filteredItems.forEach((item) => {
                item.removeAttribute("data-filter");
            });
            this.ancestorOfFirstFilteredItem = this.getTopLevelAncestorItemElement(filteredItems[0]);
            filteredItems[0].setAttribute("data-filter", "0");
            this.ancestorOfFirstFilteredItem?.setAttribute("data-filter", "0");
        };
        this.getTopLevelAncestorItemElement = (el) => {
            let closestParent = el.parentElement.closest(listItemSelector);
            while (closestParent) {
                const closestListItemAncestor = closestParent.parentElement.closest(listItemSelector);
                if (closestListItemAncestor) {
                    closestParent = closestListItemAncestor;
                }
                else {
                    return closestParent;
                }
            }
            return null;
        };
        this.disabled = false;
        this.canPull = undefined;
        this.canPut = undefined;
        this.dragEnabled = false;
        this.group = undefined;
        this.filterEnabled = false;
        this.filteredItems = [];
        this.filteredData = [];
        this.filterPlaceholder = undefined;
        this.filterText = undefined;
        this.label = undefined;
        this.loading = false;
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.numberingSystem = undefined;
        this.openable = false;
        this.selectedItems = [];
        this.selectionMode = "none";
        this.selectionAppearance = "icon";
        this.effectiveLocale = "";
        this.defaultMessages = undefined;
        this.assistiveText = undefined;
        this.dataForFilter = [];
        this.hasFilterActionsEnd = false;
        this.hasFilterActionsStart = false;
        this.hasFilterNoResults = false;
    }
    async handleFilterTextChange() {
        this.performFilter();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    handleListItemChange() {
        this.updateListItems();
    }
    handleCalciteInternalFocusPreviousItem(event) {
        if (this.parentListEl) {
            return;
        }
        event.stopPropagation();
        const { focusableItems } = this;
        const currentIndex = focusableItems.findIndex((listItem) => listItem.active);
        const prevIndex = currentIndex - 1;
        if (focusableItems[prevIndex]) {
            this.focusRow(focusableItems[prevIndex]);
        }
    }
    handleCalciteInternalListItemActive(event) {
        if (!!this.parentListEl) {
            return;
        }
        event.stopPropagation();
        const target = event.target;
        const { listItems } = this;
        listItems.forEach((listItem) => {
            listItem.active = listItem === target;
        });
    }
    handleCalciteListItemSelect() {
        if (!!this.parentListEl) {
            return;
        }
        this.updateSelectedItems(true);
    }
    handleCalciteInternalAssistiveTextChange(event) {
        this.assistiveText = event.detail.message;
        event.stopPropagation();
    }
    handleCalciteHandleNudge(event) {
        if (!!this.parentListEl) {
            return;
        }
        this.handleNudgeEvent(event);
    }
    handleCalciteInternalListItemSelect(event) {
        if (!!this.parentListEl) {
            return;
        }
        event.stopPropagation();
        const target = event.target;
        const { listItems, selectionMode } = this;
        if (target.selected && (selectionMode === "single" || selectionMode === "single-persist")) {
            listItems.forEach((listItem) => (listItem.selected = listItem === target));
        }
        this.updateSelectedItems();
    }
    handleCalciteInternalListItemSelectMultiple(event) {
        if (!!this.parentListEl) {
            return;
        }
        event.stopPropagation();
        const { target, detail } = event;
        const { focusableItems, lastSelectedInfo } = this;
        const selectedItem = target;
        if (detail.selectMultiple && !!lastSelectedInfo) {
            const currentIndex = focusableItems.indexOf(selectedItem);
            const lastSelectedIndex = focusableItems.indexOf(lastSelectedInfo.selectedItem);
            const startIndex = Math.min(lastSelectedIndex, currentIndex);
            const endIndex = Math.max(lastSelectedIndex, currentIndex);
            focusableItems
                .slice(startIndex, endIndex + 1)
                .forEach((item) => (item.selected = lastSelectedInfo.selected));
        }
        else {
            this.lastSelectedInfo = { selectedItem, selected: selectedItem.selected };
        }
    }
    handleCalciteInternalListItemChange(event) {
        if (!!this.parentListEl) {
            return;
        }
        event.stopPropagation();
        this.updateListItems();
    }
    handleCalciteInternalListItemGroupDefaultSlotChange(event) {
        event.stopPropagation();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        if (dragActive(this)) {
            return;
        }
        connectMessages(this);
        this.connectObserver();
        this.updateListItems();
        this.setUpSorting();
        connectInteractive(this);
        this.setParentList();
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        if (dragActive(this)) {
            return;
        }
        this.disconnectObserver();
        disconnectSortableComponent(this);
        disconnectInteractive(this);
        disconnectMessages(this);
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Sets focus on the component's first focusable element.
     *
     * @returns {Promise<void>}
     */
    async setFocus() {
        await componentFocusable(this);
        if (this.filterEnabled) {
            return this.filterEl?.setFocus();
        }
        return this.focusableItems.find((listItem) => listItem.active)?.setFocus();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const { loading, label, disabled, dataForFilter, filterEnabled, filterPlaceholder, filterText, filteredItems, hasFilterActionsStart, hasFilterActionsEnd, hasFilterNoResults, } = this;
        return (hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: CSS$K.container }, this.dragEnabled ? (hAsync("span", { "aria-live": "assertive", class: CSS$K.assistiveText }, this.assistiveText)) : null, this.renderItemAriaLive(), loading ? hAsync("calcite-scrim", { class: CSS$K.scrim, loading: loading }) : null, hAsync("table", { "aria-busy": toAriaBoolean(loading), "aria-label": label || "", class: CSS$K.table, onKeyDown: this.handleListKeydown, role: "treegrid" }, filterEnabled || hasFilterActionsStart || hasFilterActionsEnd ? (hAsync("thead", null, hAsync("tr", { class: { [CSS$K.sticky]: true } }, hAsync("th", { colSpan: MAX_COLUMNS }, hAsync("calcite-stack", { class: CSS$K.stack }, hAsync("slot", { name: SLOTS$h.filterActionsStart, onSlotchange: this.handleFilterActionsStartSlotChange, slot: SLOTS$g.actionsStart }), hAsync("calcite-filter", { "aria-label": filterPlaceholder, disabled: disabled, items: dataForFilter, onCalciteFilterChange: this.handleFilterChange, placeholder: filterPlaceholder, value: filterText,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setFilterEl }), hAsync("slot", { name: SLOTS$h.filterActionsEnd, onSlotchange: this.handleFilterActionsEndSlotChange, slot: SLOTS$g.actionsEnd })))))) : null, hAsync("tbody", { class: CSS$K.tableContainer }, hAsync("slot", { onSlotchange: this.handleDefaultSlotChange }))), hAsync("div", { "aria-live": "polite", "data-test-id": "no-results-container", hidden: !(hasFilterNoResults && filterEnabled && filterText && !filteredItems.length) }, hAsync("slot", { name: SLOTS$h.filterNoResults, onSlotchange: this.handleFilterNoResultsSlotChange })))));
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    renderItemAriaLive() {
        const { messages, filteredItems, parentListEl, effectiveLocale, numberingSystem, filterEnabled, filterText, filteredData, } = this;
        numberStringFormatter.numberFormatOptions = {
            locale: effectiveLocale,
            numberingSystem,
        };
        return !parentListEl ? (hAsync("div", { "aria-live": "polite", class: CSS$K.assistiveText }, filterEnabled && filterText && filteredData?.length ? (hAsync("div", { key: "aria-filter-enabled" }, messages.filterEnabled)) : null, hAsync("div", { key: "aria-item-count" }, messages.total.replace("{count}", numberStringFormatter.localize(filteredItems.length.toString()))), filteredItems.length ? (hAsync("ol", { key: "aria-item-list" }, filteredItems.map((item) => (hAsync("li", null, item.label))))) : null)) : null;
    }
    connectObserver() {
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
    }
    disconnectObserver() {
        this.mutationObserver?.disconnect();
    }
    setUpSorting() {
        const { dragEnabled } = this;
        if (!dragEnabled) {
            return;
        }
        connectSortableComponent(this);
    }
    onGlobalDragStart() {
        this.disconnectObserver();
    }
    onGlobalDragEnd() {
        this.connectObserver();
    }
    onDragEnd(detail) {
        this.calciteListDragEnd.emit(detail);
    }
    onDragStart(detail) {
        this.calciteListDragStart.emit(detail);
    }
    onDragSort(detail) {
        this.setParentList();
        this.updateListItems();
        this.calciteListOrderChange.emit(detail);
    }
    setParentList() {
        this.parentListEl = this.el.parentElement?.closest("calcite-list");
    }
    filterElements({ el, filteredItems, visibleParents, }) {
        const filterHidden = !visibleParents.has(el) && !filteredItems.includes(el);
        el.filterHidden = filterHidden;
        const closestParent = el.parentElement.closest(parentSelector);
        if (!closestParent) {
            return;
        }
        if (!filterHidden) {
            visibleParents.add(closestParent);
        }
        this.filterElements({
            el: closestParent,
            filteredItems,
            visibleParents,
        });
    }
    updateFilteredData(emit = false) {
        const { filterEl } = this;
        if (!filterEl) {
            return;
        }
        if (filterEl.filteredItems) {
            this.filteredData = filterEl.filteredItems;
        }
        this.updateListItems(emit);
    }
    async performFilter() {
        const { filterEl, filterText } = this;
        if (!filterEl) {
            return;
        }
        filterEl.value = filterText;
        await filterEl.filter(filterText);
        this.updateFilteredData();
    }
    handleNudgeEvent(event) {
        const { handleSelector, dragSelector } = this;
        const { direction } = event.detail;
        const composedPath = event.composedPath();
        const handle = composedPath.find((el) => el?.tagName && el.matches(handleSelector));
        const dragEl = composedPath.find((el) => el?.tagName && el.matches(dragSelector));
        const parentEl = dragEl?.parentElement;
        if (!parentEl) {
            return;
        }
        const { filteredItems } = this;
        const sameParentItems = filteredItems.filter((item) => item.parentElement === parentEl);
        const lastIndex = sameParentItems.length - 1;
        const oldIndex = sameParentItems.indexOf(dragEl);
        let newIndex;
        if (direction === "up") {
            newIndex = oldIndex === 0 ? lastIndex : oldIndex - 1;
        }
        else {
            newIndex = oldIndex === lastIndex ? 0 : oldIndex + 1;
        }
        this.disconnectObserver();
        handle.blurUnselectDisabled = true;
        const referenceEl = (direction === "up" && newIndex !== lastIndex) || (direction === "down" && newIndex === 0)
            ? sameParentItems[newIndex]
            : sameParentItems[newIndex].nextSibling;
        parentEl.insertBefore(dragEl, referenceEl);
        this.updateListItems();
        this.connectObserver();
        this.calciteListOrderChange.emit({
            dragEl,
            fromEl: parentEl,
            toEl: parentEl,
            newIndex,
            oldIndex,
        });
        handle.setFocus().then(() => (handle.blurUnselectDisabled = false));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "filterText": ["handleFilterTextChange"],
        "messageOverrides": ["onMessagesChange"],
        "filterEnabled": ["handleListItemChange"],
        "group": ["handleListItemChange"],
        "dragEnabled": ["handleListItemChange"],
        "selectionMode": ["handleListItemChange"],
        "selectionAppearance": ["handleListItemChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return listCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-list",
        "$members$": {
            "disabled": [516],
            "canPull": [16],
            "canPut": [16],
            "dragEnabled": [516, "drag-enabled"],
            "group": [513],
            "filterEnabled": [516, "filter-enabled"],
            "filteredItems": [1040],
            "filteredData": [1040],
            "filterPlaceholder": [513, "filter-placeholder"],
            "filterText": [1537, "filter-text"],
            "label": [1],
            "loading": [516],
            "messageOverrides": [1040],
            "messages": [1040],
            "numberingSystem": [1, "numbering-system"],
            "openable": [4],
            "selectedItems": [1040],
            "selectionMode": [513, "selection-mode"],
            "selectionAppearance": [513, "selection-appearance"],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "assistiveText": [32],
            "dataForFilter": [32],
            "hasFilterActionsEnd": [32],
            "hasFilterActionsStart": [32],
            "hasFilterNoResults": [32],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteInternalFocusPreviousItem", "handleCalciteInternalFocusPreviousItem"], [0, "calciteInternalListItemActive", "handleCalciteInternalListItemActive"], [0, "calciteListItemSelect", "handleCalciteListItemSelect"], [0, "calciteInternalAssistiveTextChange", "handleCalciteInternalAssistiveTextChange"], [0, "calciteHandleNudge", "handleCalciteHandleNudge"], [0, "calciteInternalListItemSelect", "handleCalciteInternalListItemSelect"], [0, "calciteInternalListItemSelectMultiple", "handleCalciteInternalListItemSelectMultiple"], [0, "calciteInternalListItemChange", "handleCalciteInternalListItemChange"], [0, "calciteInternalListItemGroupDefaultSlotChange", "handleCalciteInternalListItemGroupDefaultSlotChange"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["dragEnabled", "drag-enabled"], ["group", "group"], ["filterEnabled", "filter-enabled"], ["filterPlaceholder", "filter-placeholder"], ["filterText", "filter-text"], ["loading", "loading"], ["selectionMode", "selection-mode"], ["selectionAppearance", "selection-appearance"]]
    }; }
}

const listItemCss = "/*!@:host([disabled])*/[disabled].sc-calcite-list-item-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-list-item-h *.sc-calcite-list-item,.sc-calcite-list-item-h[disabled].sc-calcite-list-item-s>*,.sc-calcite-list-item-h[disabled] .sc-calcite-list-item-s>*{pointer-events:none}/*!@:host*/.sc-calcite-list-item-h{display:flex;flex-direction:column;--calcite-list-item-icon-color:var(--calcite-color-brand);--calcite-list-item-spacing-indent:1rem}/*!@:host([filter-hidden])*/[filter-hidden].sc-calcite-list-item-h{display:none}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-list-item-h[disabled] .sc-calcite-list-item-s>[calcite-hydrated][disabled],[disabled].sc-calcite-list-item-h [calcite-hydrated][disabled].sc-calcite-list-item{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-list-item{display:contents}/*!@.container*/.container.sc-calcite-list-item{box-sizing:border-box;display:flex;flex:1 1 0%;background-color:var(--calcite-color-foreground-1);font-family:var(--calcite-sans-family);padding-inline-start:calc(var(--calcite-list-item-spacing-indent) * var(--calcite-list-item-spacing-indent-multiplier))}/*!@.container **/.container.sc-calcite-list-item *.sc-calcite-list-item{box-sizing:border-box}/*!@.container--hover:hover*/.container--hover.sc-calcite-list-item:hover{cursor:pointer;background-color:var(--calcite-color-foreground-2)}/*!@.container:active*/.container.sc-calcite-list-item:active{background-color:var(--calcite-color-foreground-1)}/*!@.container--border*/.container--border.sc-calcite-list-item{border-inline-start-width:4px;border-inline-start-style:solid}/*!@.container--border-selected*/.container--border-selected.sc-calcite-list-item{border-inline-start-color:var(--calcite-color-brand)}/*!@.container--border-unselected*/.container--border-unselected.sc-calcite-list-item{border-inline-start-color:transparent}/*!@.container:hover.container--border-unselected*/.container.sc-calcite-list-item:hover.container--border-unselected{border-color:var(--calcite-color-border-1)}/*!@.nested-container*/.nested-container.sc-calcite-list-item{display:flex;flex-direction:column;background-color:var(--calcite-color-foreground-1)}/*!@.nested-container--hidden*/.nested-container--hidden.sc-calcite-list-item{display:none}/*!@.content-container*/.content-container.sc-calcite-list-item{display:flex;flex:1 1 auto;-webkit-user-select:none;user-select:none;align-items:stretch;padding:0px;font-family:var(--calcite-sans-family);font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-2)}/*!@tr,\ntd*/tr.sc-calcite-list-item,td.sc-calcite-list-item{outline-color:transparent}/*!@tr:focus,\ntd:focus*/tr.sc-calcite-list-item:focus,td.sc-calcite-list-item:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.content,\n.custom-content*/.content.sc-calcite-list-item,.custom-content.sc-calcite-list-item{display:flex;flex:1 1 auto;flex-direction:column;justify-content:center;padding-inline:0.75rem;padding-block:0.5rem;font-size:var(--calcite-font-size--2);line-height:1.375}/*!@.label,\n.description,\n.content-bottom*/.label.sc-calcite-list-item,.description.sc-calcite-list-item,.content-bottom.sc-calcite-list-item{font-family:var(--calcite-sans-family);font-size:var(--calcite-font-size--2);font-weight:var(--calcite-font-weight-normal);word-wrap:break-word;word-break:break-word}/*!@.label:only-child,\n.description:only-child,\n.content-bottom:only-child*/.label.sc-calcite-list-item:only-child,.description.sc-calcite-list-item:only-child,.content-bottom.sc-calcite-list-item:only-child{margin:0px;padding-block:0.25rem}/*!@.label*/.label.sc-calcite-list-item{color:var(--calcite-color-text-1)}/*!@:host([selected]) .label*/[selected].sc-calcite-list-item-h .label.sc-calcite-list-item{font-weight:var(--calcite-font-weight-medium)}/*!@.description*/.description.sc-calcite-list-item{margin-block-start:0.125rem;color:var(--calcite-color-text-3)}/*!@:host([selected]) .description*/[selected].sc-calcite-list-item-h .description.sc-calcite-list-item{color:var(--calcite-color-text-2)}/*!@.content-start*/.content-start.sc-calcite-list-item{justify-content:flex-start}/*!@.content-end*/.content-end.sc-calcite-list-item{justify-content:flex-end}/*!@.content-start,\n.content-end*/.content-start.sc-calcite-list-item,.content-end.sc-calcite-list-item{flex:1 1 auto}/*!@.content-bottom*/.content-bottom.sc-calcite-list-item{display:flex;flex-direction:column;background-color:var(--calcite-color-foreground-1);padding-inline-start:calc(var(--calcite-list-item-spacing-indent) * var(--calcite-list-item-spacing-indent-multiplier))}/*!@.content-container--has-center-content .content-start,\n.content-container--has-center-content .content-end*/.content-container--has-center-content.sc-calcite-list-item .content-start.sc-calcite-list-item,.content-container--has-center-content.sc-calcite-list-item .content-end.sc-calcite-list-item{flex:0 1 auto}/*!@.selection-container*/.selection-container.sc-calcite-list-item{display:flex;padding-inline:0.75rem;color:var(--calcite-color-border-input)}/*!@.selection-container--single*/.selection-container--single.sc-calcite-list-item{color:transparent}/*!@:host(:not([disabled]):not([selected])) .container:hover .selection-container--single*/.sc-calcite-list-item-h:not([disabled]):not([selected]) .container.sc-calcite-list-item:hover .selection-container--single.sc-calcite-list-item{color:var(--calcite-color-border-1)}/*!@:host([selected]:hover) .selection-container,\n:host([selected]:hover) .selection-container--single,\n:host([selected]) .selection-container*/[selected].sc-calcite-list-item-h:hover .selection-container.sc-calcite-list-item,[selected].sc-calcite-list-item-h:hover .selection-container--single.sc-calcite-list-item,[selected].sc-calcite-list-item-h .selection-container.sc-calcite-list-item{color:var(--calcite-list-item-icon-color)}/*!@.open-container*/.open-container.sc-calcite-list-item{color:var(--calcite-color-text-3)}/*!@:host(:not([disabled])) .container:hover .open-container*/.sc-calcite-list-item-h:not([disabled]) .container.sc-calcite-list-item:hover .open-container.sc-calcite-list-item{color:var(--calcite-color-text-1)}/*!@.actions-start,\n.actions-end,\n.content-start,\n.content-end,\n.selection-container,\n.drag-container,\n.open-container*/.actions-start.sc-calcite-list-item,.actions-end.sc-calcite-list-item,.content-start.sc-calcite-list-item,.content-end.sc-calcite-list-item,.selection-container.sc-calcite-list-item,.drag-container.sc-calcite-list-item,.open-container.sc-calcite-list-item{display:flex;align-items:center}/*!@.open-container,\n.selection-container*/.open-container.sc-calcite-list-item,.selection-container.sc-calcite-list-item{cursor:pointer}/*!@.content-start ::slotted(calcite-icon),\n.content-end ::slotted(calcite-icon)*/.content-start .sc-calcite-list-item-s>calcite-icon,.content-end.sc-calcite-list-item-s>calcite-icon,.content-end .sc-calcite-list-item-s>calcite-icon{margin-inline:0.75rem;align-self:center}/*!@.actions-start ::slotted(calcite-action),\n.actions-start ::slotted(calcite-action-menu),\n.actions-start ::slotted(calcite-handle),\n.actions-start ::slotted(calcite-dropdown),\n.actions-end ::slotted(calcite-action),\n.actions-end ::slotted(calcite-action-menu),\n.actions-end ::slotted(calcite-handle),\n.actions-end ::slotted(calcite-dropdown)*/.actions-start .sc-calcite-list-item-s>calcite-action,.actions-start.sc-calcite-list-item-s>calcite-action-menu,.actions-start .sc-calcite-list-item-s>calcite-action-menu,.actions-start.sc-calcite-list-item-s>calcite-handle,.actions-start .sc-calcite-list-item-s>calcite-handle,.actions-start.sc-calcite-list-item-s>calcite-dropdown,.actions-start .sc-calcite-list-item-s>calcite-dropdown,.actions-end.sc-calcite-list-item-s>calcite-action,.actions-end .sc-calcite-list-item-s>calcite-action,.actions-end.sc-calcite-list-item-s>calcite-action-menu,.actions-end .sc-calcite-list-item-s>calcite-action-menu,.actions-end.sc-calcite-list-item-s>calcite-handle,.actions-end .sc-calcite-list-item-s>calcite-handle,.actions-end.sc-calcite-list-item-s>calcite-dropdown,.actions-end .sc-calcite-list-item-s>calcite-dropdown{align-self:stretch;color:inherit}/*!@::slotted(calcite-list-item),\n::slotted(calcite-list)*/.sc-calcite-list-item-s>calcite-list-item,.sc-calcite-list-item-s>calcite-list{border-width:0px;border-block-start-width:1px;border-style:solid;border-color:var(--calcite-color-border-3)}/*!@::slotted(calcite-list:empty)*/.sc-calcite-list-item-s>calcite-list:empty{padding-block:0.75rem}/*!@:host([hidden])*/[hidden].sc-calcite-list-item-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-list-item{display:none}";

const focusMap = new Map();
const listSelector = "calcite-list";
/**
 * @slot - A slot for adding `calcite-list-item` and `calcite-list-item-group` elements.
 * @slot actions-start - A slot for adding actionable `calcite-action` elements before the content of the component.
 * @slot content-start - A slot for adding non-actionable elements before the label and description of the component.
 * @slot content - A slot for adding non-actionable, centered content in place of the `label` and `description` of the component.
 * @slot content-end - A slot for adding non-actionable elements after the label and description of the component.
 * @slot actions-end - A slot for adding actionable `calcite-action` elements after the content of the component.
 * @slot content-bottom - A slot for adding content below the component's `label` and `description`.
 */
class ListItem {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteListItemSelect = createEvent(this, "calciteListItemSelect", 6);
        this.calciteListItemClose = createEvent(this, "calciteListItemClose", 6);
        this.calciteListItemDragHandleChange = createEvent(this, "calciteListItemDragHandleChange", 6);
        this.calciteListItemToggle = createEvent(this, "calciteListItemToggle", 6);
        this.calciteInternalListItemSelect = createEvent(this, "calciteInternalListItemSelect", 6);
        this.calciteInternalListItemSelectMultiple = createEvent(this, "calciteInternalListItemSelectMultiple", 6);
        this.calciteInternalListItemActive = createEvent(this, "calciteInternalListItemActive", 6);
        this.calciteInternalFocusPreviousItem = createEvent(this, "calciteInternalFocusPreviousItem", 6);
        this.calciteInternalListItemChange = createEvent(this, "calciteInternalListItemChange", 6);
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.dragHandleSelectedChangeHandler = (event) => {
            this.dragSelected = event.target.selected;
            this.calciteListItemDragHandleChange.emit();
            event.stopPropagation();
        };
        this.emitInternalListItemActive = () => {
            this.calciteInternalListItemActive.emit();
        };
        this.focusCellHandle = () => {
            this.handleCellFocusIn(this.handleGridEl);
        };
        this.focusCellActionsStart = () => {
            this.handleCellFocusIn(this.actionsStartEl);
        };
        this.focusCellContent = () => {
            this.handleCellFocusIn(this.contentEl);
        };
        this.focusCellActionsEnd = () => {
            this.handleCellFocusIn(this.actionsEndEl);
        };
        this.handleCloseClick = () => {
            this.closed = true;
            this.calciteListItemClose.emit();
        };
        this.handleContentSlotChange = (event) => {
            this.hasCustomContent = slotChangeHasAssignedElement(event);
        };
        this.handleActionsStartSlotChange = (event) => {
            this.hasActionsStart = slotChangeHasAssignedElement(event);
        };
        this.handleActionsEndSlotChange = (event) => {
            this.hasActionsEnd = slotChangeHasAssignedElement(event);
        };
        this.handleContentStartSlotChange = (event) => {
            this.hasContentStart = slotChangeHasAssignedElement(event);
        };
        this.handleContentEndSlotChange = (event) => {
            this.hasContentEnd = slotChangeHasAssignedElement(event);
        };
        this.handleContentBottomSlotChange = (event) => {
            this.hasContentBottom = slotChangeHasAssignedElement(event);
        };
        this.handleDefaultSlotChange = (event) => {
            this.handleOpenableChange(event.target);
        };
        this.handleToggleClick = () => {
            this.toggle();
        };
        this.toggle = (value = !this.open) => {
            this.open = value;
            this.calciteListItemToggle.emit();
        };
        this.handleItemClick = (event) => {
            if (event.defaultPrevented) {
                return;
            }
            this.toggleSelected(event.shiftKey);
        };
        this.toggleSelected = (shiftKey) => {
            const { selectionMode, selected } = this;
            if (this.disabled) {
                return;
            }
            if (selectionMode === "multiple" || selectionMode === "single") {
                this.selected = !selected;
            }
            else if (selectionMode === "single-persist") {
                this.selected = true;
            }
            this.calciteInternalListItemSelectMultiple.emit({
                selectMultiple: shiftKey && selectionMode === "multiple",
            });
            this.calciteListItemSelect.emit();
        };
        this.handleItemKeyDown = (event) => {
            if (event.defaultPrevented) {
                return;
            }
            const { key } = event;
            const composedPath = event.composedPath();
            const { containerEl, actionsStartEl, actionsEndEl, open, openable } = this;
            const cells = this.getGridCells();
            const currentIndex = cells.findIndex((cell) => composedPath.includes(cell));
            if (key === "Enter" &&
                !composedPath.includes(actionsStartEl) &&
                !composedPath.includes(actionsEndEl)) {
                event.preventDefault();
                this.toggleSelected(event.shiftKey);
            }
            else if (key === "ArrowRight") {
                event.preventDefault();
                const nextIndex = currentIndex + 1;
                if (currentIndex === -1) {
                    if (!open && openable) {
                        this.toggle(true);
                        this.focusCell(null);
                    }
                    else if (cells[0]) {
                        this.focusCell(cells[0]);
                    }
                }
                else if (cells[currentIndex] && cells[nextIndex]) {
                    this.focusCell(cells[nextIndex]);
                }
            }
            else if (key === "ArrowLeft") {
                event.preventDefault();
                const prevIndex = currentIndex - 1;
                if (currentIndex === -1) {
                    this.focusCell(null);
                    if (open && openable) {
                        this.toggle(false);
                    }
                    else {
                        this.calciteInternalFocusPreviousItem.emit();
                    }
                }
                else if (currentIndex === 0) {
                    this.focusCell(null);
                    containerEl.focus();
                }
                else if (cells[currentIndex] && cells[prevIndex]) {
                    this.focusCell(cells[prevIndex]);
                }
            }
        };
        this.focusCellNull = () => {
            this.focusCell(null);
        };
        this.handleCellFocusIn = (focusEl) => {
            this.setFocusCell(focusEl, getFirstTabbable(focusEl), true);
        };
        // Only one cell within a list-item should be focusable at a time. Ensures the active cell is focusable.
        this.setFocusCell = (focusEl, focusedEl, saveFocusIndex) => {
            const { parentListEl } = this;
            if (saveFocusIndex) {
                focusMap.set(parentListEl, null);
            }
            const gridCells = this.getGridCells();
            gridCells.forEach((tableCell) => {
                tableCell.tabIndex = -1;
                tableCell.removeAttribute(activeCellTestAttribute);
            });
            if (!focusEl) {
                return;
            }
            focusEl.tabIndex = focusEl === focusedEl ? 0 : -1;
            focusEl.setAttribute(activeCellTestAttribute, "");
            if (saveFocusIndex) {
                focusMap.set(parentListEl, gridCells.indexOf(focusEl));
            }
        };
        this.focusCell = (focusEl, saveFocusIndex = true) => {
            const focusedEl = getFirstTabbable(focusEl);
            this.setFocusCell(focusEl, focusedEl, saveFocusIndex);
            focusedEl?.focus();
        };
        this.active = false;
        this.closable = false;
        this.closed = false;
        this.description = undefined;
        this.disabled = false;
        this.dragDisabled = false;
        this.dragHandle = false;
        this.dragSelected = false;
        this.filterHidden = false;
        this.label = undefined;
        this.metadata = undefined;
        this.open = false;
        this.setSize = null;
        this.setPosition = null;
        this.selected = false;
        this.value = undefined;
        this.selectionMode = null;
        this.selectionAppearance = null;
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.effectiveLocale = "";
        this.defaultMessages = undefined;
        this.level = null;
        this.visualLevel = null;
        this.parentListEl = undefined;
        this.openable = false;
        this.hasActionsStart = false;
        this.hasActionsEnd = false;
        this.hasCustomContent = false;
        this.hasContentStart = false;
        this.hasContentEnd = false;
        this.hasContentBottom = false;
    }
    activeHandler(active) {
        if (!active) {
            this.focusCell(null, false);
        }
    }
    handleClosedChange() {
        this.emitCalciteInternalListItemChange();
    }
    handleDisabledChange() {
        this.emitCalciteInternalListItemChange();
    }
    handleSelectedChange() {
        this.calciteInternalListItemSelect.emit();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    handleCalciteInternalListDefaultSlotChanges(event) {
        event.stopPropagation();
        this.handleOpenableChange(this.defaultSlotEl);
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
        const { el } = this;
        this.parentListEl = el.closest(listSelector);
        this.level = getDepth() + 1;
        this.visualLevel = getDepth(el, true);
        this.setSelectionDefaults();
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        const { containerEl, parentListEl } = this;
        const focusIndex = focusMap.get(parentListEl);
        if (typeof focusIndex === "number") {
            const cells = this.getGridCells();
            if (cells[focusIndex]) {
                this.focusCell(cells[focusIndex]);
            }
            else {
                containerEl?.focus();
            }
            return;
        }
        containerEl?.focus();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderSelected() {
        const { selected, selectionMode, selectionAppearance } = this;
        if (selectionMode === "none" || selectionAppearance === "border") {
            return null;
        }
        return (hAsync("td", { class: {
                [CSS$L.selectionContainer]: true,
                [CSS$L.selectionContainerSingle]: selectionMode === "single" || selectionMode === "single-persist",
            }, key: "selection-container", onClick: this.handleItemClick }, hAsync("calcite-icon", { icon: selected
                ? selectionMode === "multiple"
                    ? ICONS$8.selectedMultiple
                    : ICONS$8.selectedSingle
                : selectionMode === "multiple"
                    ? ICONS$8.unselectedMultiple
                    : ICONS$8.unselectedSingle, scale: "s" })));
    }
    renderDragHandle() {
        const { label, dragHandle, dragSelected, dragDisabled, setPosition, setSize } = this;
        return dragHandle ? (hAsync("td", { "aria-label": label, class: CSS$L.dragContainer, key: "drag-handle-container", onFocusin: this.focusCellHandle, role: "gridcell",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.handleGridEl = el) }, hAsync("calcite-handle", { disabled: dragDisabled, label: label, onCalciteHandleChange: this.dragHandleSelectedChangeHandler, selected: dragSelected, setPosition: setPosition, setSize: setSize }))) : null;
    }
    renderOpen() {
        const { el, open, openable, messages } = this;
        const dir = getElementDir(el);
        const icon = open ? ICONS$8.open : dir === "rtl" ? ICONS$8.closedRTL : ICONS$8.closedLTR;
        const tooltip = open ? messages.collapse : messages.expand;
        return openable ? (hAsync("td", { class: CSS$L.openContainer, key: "open-container", onClick: this.handleToggleClick, title: tooltip }, hAsync("calcite-icon", { icon: icon, key: icon, scale: "s" }))) : null;
    }
    renderActionsStart() {
        const { label, hasActionsStart } = this;
        return (hAsync("td", { "aria-label": label, class: CSS$L.actionsStart, hidden: !hasActionsStart, key: "actions-start-container", onFocusin: this.focusCellActionsStart, role: "gridcell",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.actionsStartEl = el) }, hAsync("slot", { name: SLOTS$i.actionsStart, onSlotchange: this.handleActionsStartSlotChange })));
    }
    renderActionsEnd() {
        const { label, hasActionsEnd, closable, messages } = this;
        return (hAsync("td", { "aria-label": label, class: CSS$L.actionsEnd, hidden: !(hasActionsEnd || closable), key: "actions-end-container", onFocusin: this.focusCellActionsEnd, role: "gridcell",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.actionsEndEl = el) }, hAsync("slot", { name: SLOTS$i.actionsEnd, onSlotchange: this.handleActionsEndSlotChange }), closable ? (hAsync("calcite-action", { appearance: "transparent", icon: ICONS$8.close, key: "close-action", label: messages.close, onClick: this.handleCloseClick, text: messages.close })) : null));
    }
    renderContentStart() {
        const { hasContentStart } = this;
        return (hAsync("div", { class: CSS$L.contentStart, hidden: !hasContentStart }, hAsync("slot", { name: SLOTS$i.contentStart, onSlotchange: this.handleContentStartSlotChange })));
    }
    renderCustomContent() {
        const { hasCustomContent } = this;
        return (hAsync("div", { class: CSS$L.customContent, hidden: !hasCustomContent }, hAsync("slot", { name: SLOTS$i.content, onSlotchange: this.handleContentSlotChange })));
    }
    renderContentEnd() {
        const { hasContentEnd } = this;
        return (hAsync("div", { class: CSS$L.contentEnd, hidden: !hasContentEnd }, hAsync("slot", { name: SLOTS$i.contentEnd, onSlotchange: this.handleContentEndSlotChange })));
    }
    renderContentBottom() {
        const { hasContentBottom, visualLevel } = this;
        return (hAsync("div", { class: CSS$L.contentBottom, hidden: !hasContentBottom, style: { "--calcite-list-item-spacing-indent-multiplier": `${visualLevel}` } }, hAsync("slot", { name: SLOTS$i.contentBottom, onSlotchange: this.handleContentBottomSlotChange })));
    }
    renderDefaultContainer() {
        return (hAsync("div", { class: {
                [CSS$L.nestedContainer]: true,
                [CSS$L.nestedContainerHidden]: this.openable && !this.open,
            } }, hAsync("slot", { onSlotchange: this.handleDefaultSlotChange, ref: (el) => (this.defaultSlotEl = el) })));
    }
    renderContentProperties() {
        const { label, description, hasCustomContent } = this;
        return !hasCustomContent && (!!label || !!description) ? (hAsync("div", { class: CSS$L.content, key: "content" }, label ? (hAsync("div", { class: CSS$L.label, key: "label" }, label)) : null, description ? (hAsync("div", { class: CSS$L.description, key: "description" }, description)) : null)) : null;
    }
    renderContentContainer() {
        const { description, label, selectionMode, hasCustomContent } = this;
        const hasCenterContent = hasCustomContent || !!label || !!description;
        const content = [
            this.renderContentStart(),
            this.renderCustomContent(),
            this.renderContentProperties(),
            this.renderContentEnd(),
        ];
        return (hAsync("td", { "aria-label": label, class: {
                [CSS$L.contentContainer]: true,
                [CSS$L.contentContainerSelectable]: selectionMode !== "none",
                [CSS$L.contentContainerHasCenterContent]: hasCenterContent,
            }, key: "content-container", onClick: this.handleItemClick, onFocusin: this.focusCellContent, role: "gridcell",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.contentEl = el) }, content));
    }
    render() {
        const { openable, open, level, setPosition, setSize, active, label, selected, selectionAppearance, selectionMode, closed, visualLevel, } = this;
        const showBorder = selectionMode !== "none" && selectionAppearance === "border";
        const borderSelected = showBorder && selected;
        const borderUnselected = showBorder && !selected;
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("tr", { "aria-expanded": openable ? toAriaBoolean(open) : null, "aria-label": label, "aria-level": level, "aria-posinset": setPosition, "aria-selected": toAriaBoolean(selected), "aria-setsize": setSize, class: {
                [CSS$L.container]: true,
                [CSS$L.containerHover]: true,
                [CSS$L.containerBorder]: showBorder,
                [CSS$L.containerBorderSelected]: borderSelected,
                [CSS$L.containerBorderUnselected]: borderUnselected,
            }, hidden: closed, onFocus: this.focusCellNull, onFocusin: this.emitInternalListItemActive, onKeyDown: this.handleItemKeyDown, role: "row", style: { "--calcite-list-item-spacing-indent-multiplier": `${visualLevel}` }, tabIndex: active ? 0 : -1,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.containerEl = el) }, this.renderDragHandle(), this.renderSelected(), this.renderOpen(), this.renderActionsStart(), this.renderContentContainer(), this.renderActionsEnd()), this.renderContentBottom(), this.renderDefaultContainer())));
    }
    emitCalciteInternalListItemChange() {
        this.calciteInternalListItemChange.emit();
    }
    setSelectionDefaults() {
        const { parentListEl, selectionMode, selectionAppearance } = this;
        if (!parentListEl) {
            return;
        }
        if (!selectionMode) {
            this.selectionMode = parentListEl.selectionMode;
        }
        if (!selectionAppearance) {
            this.selectionAppearance = parentListEl.selectionAppearance;
        }
    }
    handleOpenableChange(slotEl) {
        if (!slotEl) {
            return;
        }
        const listItemChildren = getListItemChildren(slotEl);
        const listItemChildLists = getListItemChildLists(slotEl);
        updateListItemChildren(listItemChildren);
        this.openable = !!listItemChildren.length || !!listItemChildLists.length;
    }
    getGridCells() {
        return [this.handleGridEl, this.actionsStartEl, this.contentEl, this.actionsEndEl].filter((el) => el && !el.hidden);
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "active": ["activeHandler"],
        "closed": ["handleClosedChange"],
        "disabled": ["handleDisabledChange"],
        "selected": ["handleSelectedChange"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return listItemCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-list-item",
        "$members$": {
            "active": [4],
            "closable": [516],
            "closed": [1540],
            "description": [1],
            "disabled": [516],
            "dragDisabled": [516, "drag-disabled"],
            "dragHandle": [4, "drag-handle"],
            "dragSelected": [1540, "drag-selected"],
            "filterHidden": [516, "filter-hidden"],
            "label": [1],
            "metadata": [16],
            "open": [1540],
            "setSize": [2, "set-size"],
            "setPosition": [2, "set-position"],
            "selected": [1540],
            "value": [8],
            "selectionMode": [1025, "selection-mode"],
            "selectionAppearance": [1025, "selection-appearance"],
            "messageOverrides": [1040],
            "messages": [1040],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "level": [32],
            "visualLevel": [32],
            "parentListEl": [32],
            "openable": [32],
            "hasActionsStart": [32],
            "hasActionsEnd": [32],
            "hasCustomContent": [32],
            "hasContentStart": [32],
            "hasContentEnd": [32],
            "hasContentBottom": [32],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteInternalListItemGroupDefaultSlotChange", "handleCalciteInternalListDefaultSlotChanges"], [0, "calciteInternalListDefaultSlotChange", "handleCalciteInternalListDefaultSlotChanges"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["closable", "closable"], ["closed", "closed"], ["disabled", "disabled"], ["dragDisabled", "drag-disabled"], ["dragSelected", "drag-selected"], ["filterHidden", "filter-hidden"], ["open", "open"], ["selected", "selected"]]
    }; }
}

const CSS$H = {
    container: "container",
    heading: "heading",
};

const listItemGroupCss = "/*!@:host([disabled])*/[disabled].sc-calcite-list-item-group-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-list-item-group-h *.sc-calcite-list-item-group,.sc-calcite-list-item-group-h[disabled].sc-calcite-list-item-group-s>*,.sc-calcite-list-item-group-h[disabled] .sc-calcite-list-item-group-s>*{pointer-events:none}/*!@:host*/.sc-calcite-list-item-group-h{display:flex;flex-direction:column;background-color:var(--calcite-color-foreground-1);--calcite-list-item-spacing-indent:1rem}/*!@:host([filter-hidden])*/[filter-hidden].sc-calcite-list-item-group-h{display:none}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-list-item-group-h[disabled] .sc-calcite-list-item-group-s>[calcite-hydrated][disabled],[disabled].sc-calcite-list-item-group-h [calcite-hydrated][disabled].sc-calcite-list-item-group{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-list-item-group{display:contents}/*!@.container*/.container.sc-calcite-list-item-group{margin:0px;display:flex;flex:1 1 0%;background-color:var(--calcite-color-foreground-2);padding:0.75rem;font-family:var(--calcite-sans-family);font-size:var(--calcite-font-size--1);font-weight:var(--calcite-font-weight-bold);color:var(--calcite-color-text-2)}/*!@.heading*/.heading.sc-calcite-list-item-group{padding-inline-start:calc(var(--calcite-list-item-spacing-indent) * var(--calcite-list-item-spacing-indent-multiplier))}/*!@::slotted(calcite-list-item)*/.sc-calcite-list-item-group-s>calcite-list-item{--tw-shadow:0 -1px 0 var(--calcite-color-border-3);--tw-shadow-colored:0 -1px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);margin-block-start:1px}/*!@::slotted(calcite-list-item:nth-child(1 of :not([hidden])))*/(calcite-list-item.sc-calcite-list-item-group-h:nth-child(1 of :not(__ph-0__))){--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);margin-block-start:0px}/*!@:host([hidden])*/[hidden].sc-calcite-list-item-group-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-list-item-group{display:none}";

/**
 * @slot - A slot for adding `calcite-list-item` and `calcite-list-item-group` elements.
 */
class ListItemGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalListItemGroupDefaultSlotChange = createEvent(this, "calciteInternalListItemGroupDefaultSlotChange", 6);
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.handleDefaultSlotChange = () => {
            this.calciteInternalListItemGroupDefaultSlotChange.emit();
        };
        this.disabled = false;
        this.filterHidden = false;
        this.heading = undefined;
        this.visualLevel = null;
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        const { el } = this;
        this.visualLevel = getDepth(el, true);
        connectInteractive(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const { disabled, heading, visualLevel } = this;
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: disabled }, hAsync("tr", { class: CSS$H.container, style: { "--calcite-list-item-spacing-indent-multiplier": `${visualLevel}` } }, hAsync("td", { class: CSS$H.heading, colSpan: MAX_COLUMNS }, heading)), hAsync("slot", { onSlotchange: this.handleDefaultSlotChange }))));
    }
    get el() { return getElement(this); }
    static get style() { return listItemGroupCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-list-item-group",
        "$members$": {
            "disabled": [516],
            "filterHidden": [516, "filter-hidden"],
            "heading": [513],
            "visualLevel": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["filterHidden", "filter-hidden"], ["heading", "heading"]]
    }; }
}

const loaderCss = "@charset \"UTF-8\";@media (prefers-reduced-motion: reduce){/*!@:root*/.sc-calcite-loader:root{--calcite-internal-duration-factor:0}}/*!@:host*/.sc-calcite-loader-h{position:relative;margin-inline:auto;display:none;align-items:center;justify-content:center;opacity:1;min-block-size:var(--calcite-loader-size);font-size:var(--calcite-loader-font-size);stroke:var(--calcite-color-brand);stroke-width:3;fill:none;transform:scale(1, 1);animation:loader-color-shift calc(var(--calcite-internal-animation-timing-slow) / var(--calcite-internal-duration-factor) * 2 / var(--calcite-internal-duration-factor)) alternate-reverse infinite linear;padding-block:var(--calcite-loader-padding, 4rem);will-change:contents}/*!@:host([scale=s])*/[scale=s].sc-calcite-loader-h{--calcite-loader-font-size:var(--calcite-font-size--2);--calcite-loader-size:2rem;--calcite-loader-size-inline:0.75rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-loader-h{--calcite-loader-font-size:var(--calcite-font-size-0);--calcite-loader-size:4rem;--calcite-loader-size-inline:1rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-loader-h{--calcite-loader-font-size:var(--calcite-font-size-2);--calcite-loader-size:6rem;--calcite-loader-size-inline:1.5rem}/*!@:host([no-padding])*/[no-padding].sc-calcite-loader-h{padding-block:0px}/*!@:host*/.sc-calcite-loader-h{display:flex}/*!@.loader__text*/.loader__text.sc-calcite-loader{display:block;text-align:center;font-size:var(--calcite-font-size--2);line-height:1rem;color:var(--calcite-color-text-1);margin-block-start:calc(var(--calcite-loader-size) + 1.5rem)}/*!@.loader__percentage*/.loader__percentage.sc-calcite-loader{position:absolute;display:block;text-align:center;color:var(--calcite-color-text-1);font-size:var(--calcite-loader-font-size);inline-size:var(--calcite-loader-size);inset-inline-start:50%;margin-inline-start:calc(var(--calcite-loader-size) / 2 * -1);line-height:0.25;transform:scale(1, 1)}/*!@.loader__svgs*/.loader__svgs.sc-calcite-loader{position:absolute;overflow:visible;opacity:1;inline-size:var(--calcite-loader-size);block-size:var(--calcite-loader-size);inset-inline-start:50%;margin-inline-start:calc(var(--calcite-loader-size) / 2 * -1);animation-iteration-count:infinite;animation-timing-function:linear;animation-duration:calc(var(--calcite-internal-animation-timing-slow) / var(--calcite-internal-duration-factor) * 6.66 / var(--calcite-internal-duration-factor));animation-name:loader-clockwise}/*!@.loader__svg*/.loader__svg.sc-calcite-loader{position:absolute;inset-block-start:0px;transform-origin:center;overflow:visible;inset-inline-start:0;inline-size:var(--calcite-loader-size);block-size:var(--calcite-loader-size);animation-iteration-count:infinite;animation-timing-function:linear}@supports (display: grid){/*!@.loader__svg--1*/.loader__svg--1.sc-calcite-loader{animation-name:loader-offset-1}/*!@.loader__svg--2*/.loader__svg--2.sc-calcite-loader{animation-name:loader-offset-2}/*!@.loader__svg--3*/.loader__svg--3.sc-calcite-loader{animation-name:loader-offset-3}}/*!@:host([type=determinate])*/[type=determinate].sc-calcite-loader-h{animation:none;stroke:var(--calcite-color-border-3)}/*!@:host([type=determinate]) .loader__svgs*/[type=determinate].sc-calcite-loader-h .loader__svgs.sc-calcite-loader{animation:none}/*!@:host([type=determinate]) .loader__svg--3*/[type=determinate].sc-calcite-loader-h .loader__svg--3.sc-calcite-loader{animation:none;stroke:var(--calcite-color-brand);stroke-dasharray:150.79632;transform:rotate(-90deg);transition:all var(--calcite-internal-animation-timing-fast) linear}/*!@:host([inline])*/[inline].sc-calcite-loader-h{position:relative;margin:0px;animation:none;stroke:currentColor;stroke-width:2;padding-block:0px;block-size:var(--calcite-loader-size-inline);min-block-size:var(--calcite-loader-size-inline);inline-size:var(--calcite-loader-size-inline);margin-inline-end:calc(var(--calcite-loader-size-inline) * 0.5);vertical-align:calc(var(--calcite-loader-size-inline) * -1 * 0.2)}/*!@:host([inline]) .loader__svgs*/[inline].sc-calcite-loader-h .loader__svgs.sc-calcite-loader{inset-block-start:0px;margin:0px;inset-inline-start:0;inline-size:var(--calcite-loader-size-inline);block-size:var(--calcite-loader-size-inline)}/*!@:host([inline]) .loader__svg*/[inline].sc-calcite-loader-h .loader__svg.sc-calcite-loader{inline-size:var(--calcite-loader-size-inline);block-size:var(--calcite-loader-size-inline)}/*!@:host([complete])*/[complete].sc-calcite-loader-h{opacity:0;transform:scale(0.75, 0.75);transform-origin:center;transition:opacity var(--calcite-internal-animation-timing-medium) linear 1000ms, transform var(--calcite-internal-animation-timing-medium) linear 1000ms}/*!@:host([complete]) .loader__svgs*/[complete].sc-calcite-loader-h .loader__svgs.sc-calcite-loader{opacity:0;transform:scale(0.75, 0.75);transform-origin:center;transition:opacity calc(180ms * var(--calcite-internal-duration-factor)) linear 800ms, transform calc(180ms * var(--calcite-internal-duration-factor)) linear 800ms}/*!@:host([complete]) .loader__percentage*/[complete].sc-calcite-loader-h .loader__percentage.sc-calcite-loader{color:var(--calcite-color-brand);transform:scale(1.05, 1.05);transform-origin:center;transition:color var(--calcite-internal-animation-timing-medium) linear, transform var(--calcite-internal-animation-timing-medium) linear}/*!@.loader__svg--1*/.loader__svg--1.sc-calcite-loader{stroke-dasharray:27.9252444444 139.6262222222;animation-duration:calc(var(--calcite-internal-animation-timing-slow) / var(--calcite-internal-duration-factor) * 4.8 / var(--calcite-internal-duration-factor))}@keyframes loader-offset-1{0%{stroke-dasharray:27.9252444444 251.3272;stroke-dashoffset:0}50%{stroke-dasharray:139.6262222222 139.6262222222;stroke-dashoffset:-83.7757333333}100%{stroke-dasharray:27.9252444444 251.3272;stroke-dashoffset:-279.2524444444}}/*!@.loader__svg--2*/.loader__svg--2.sc-calcite-loader{stroke-dasharray:55.8504888889 139.6262222222;animation-duration:calc(var(--calcite-internal-animation-timing-slow) / var(--calcite-internal-duration-factor) * 6.4 / var(--calcite-internal-duration-factor))}@keyframes loader-offset-2{0%{stroke-dasharray:55.8504888889 223.4019555556;stroke-dashoffset:0}50%{stroke-dasharray:139.6262222222 139.6262222222;stroke-dashoffset:-97.7383555556}100%{stroke-dasharray:55.8504888889 223.4019555556;stroke-dashoffset:-279.2524444444}}/*!@.loader__svg--3*/.loader__svg--3.sc-calcite-loader{stroke-dasharray:13.9626222222 139.6262222222;animation-duration:calc(var(--calcite-internal-animation-timing-slow) / var(--calcite-internal-duration-factor) * 7.734 / var(--calcite-internal-duration-factor))}@keyframes loader-offset-3{0%{stroke-dasharray:13.9626222222 265.2898222222;stroke-dashoffset:0}50%{stroke-dasharray:139.6262222222 139.6262222222;stroke-dashoffset:-76.7944222222}100%{stroke-dasharray:13.9626222222 265.2898222222;stroke-dashoffset:-279.2524444444}}@keyframes loader-color-shift{0%{stroke:var(--calcite-color-brand)}33%{stroke:var(--calcite-color-brand-press)}66%{stroke:var(--calcite-color-brand-hover)}100%{stroke:var(--calcite-color-brand)}}@keyframes loader-clockwise{100%{transform:rotate(360deg)}}/*!@:host([hidden])*/[hidden].sc-calcite-loader-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-loader{display:none}";

class Loader {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.inline = false;
        this.label = undefined;
        this.scale = "m";
        this.type = undefined;
        this.value = 0;
        this.text = "";
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    render() {
        const { el, inline, label, scale, text, type, value } = this;
        const id = el.id || guid();
        const radiusRatio = 0.45;
        const size = inline ? this.getInlineSize(scale) : this.getSize(scale);
        const radius = size * radiusRatio;
        const viewbox = `0 0 ${size} ${size}`;
        const isDeterminate = type === "determinate";
        const circumference = 2 * radius * Math.PI;
        const progress = (value / 100) * circumference;
        const remaining = circumference - progress;
        const valueNow = Math.floor(value);
        const hostAttributes = {
            "aria-valuenow": valueNow,
            "aria-valuemin": 0,
            "aria-valuemax": 100,
            complete: valueNow === 100,
        };
        const svgAttributes = { r: radius, cx: size / 2, cy: size / 2 };
        const determinateStyle = { "stroke-dasharray": `${progress} ${remaining}` };
        return (hAsync(Host, { "aria-label": label, id: id, role: "progressbar", ...(isDeterminate ? hostAttributes : {}) }, hAsync("div", { class: "loader__svgs" }, hAsync("svg", { "aria-hidden": "true", class: "loader__svg loader__svg--1", viewBox: viewbox }, hAsync("circle", { ...svgAttributes })), hAsync("svg", { "aria-hidden": "true", class: "loader__svg loader__svg--2", viewBox: viewbox }, hAsync("circle", { ...svgAttributes })), hAsync("svg", { "aria-hidden": "true", class: "loader__svg loader__svg--3", viewBox: viewbox, ...(isDeterminate ? { style: determinateStyle } : {}) }, hAsync("circle", { ...svgAttributes }))), text && hAsync("div", { class: "loader__text" }, text), isDeterminate && hAsync("div", { class: "loader__percentage" }, value)));
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Return the proper sizes based on the scale property
     *
     * @param scale
     */
    getSize(scale) {
        return {
            s: 32,
            m: 56,
            l: 80,
        }[scale];
    }
    getInlineSize(scale) {
        return {
            s: 12,
            m: 16,
            l: 20,
        }[scale];
    }
    get el() { return getElement(this); }
    static get style() { return loaderCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-loader",
        "$members$": {
            "inline": [516],
            "label": [1],
            "scale": [513],
            "type": [513],
            "value": [2],
            "text": [1]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["inline", "inline"], ["scale", "scale"], ["type", "type"]]
    }; }
}

const CSS$G = {
    container: "container",
    fill: "fill",
    stepLine: "step-line",
    label: "label",
    labelHidden: "label-hidden",
    labelRange: "label-range",
    labelValue: "label-value",
    unitLabel: "unit-label",
    stepsVisible: "steps-visible",
    valueVisible: "value-visible",
    success: "fill-success",
    warning: "fill-warning",
    danger: "fill-danger",
};

const meterCss = "/*!@:host([disabled])*/[disabled].sc-calcite-meter-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-meter-h *.sc-calcite-meter,.sc-calcite-meter-h[disabled].sc-calcite-meter-s>*,.sc-calcite-meter-h[disabled] .sc-calcite-meter-s>*{pointer-events:none}/*!@:host([hidden])*/[hidden].sc-calcite-meter-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-meter{display:none}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-meter-h[disabled] .sc-calcite-meter-s>[calcite-hydrated][disabled],[disabled].sc-calcite-meter-h [calcite-hydrated][disabled].sc-calcite-meter{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-meter{display:contents}/*!@:host*/.sc-calcite-meter-h{display:flex;--calcite-meter-space-internal:0.125rem;--calcite-meter-height-internal:1rem;--calcite-meter-font-size-internal:var(--calcite-font-size--1)}/*!@:host([scale=s])*/[scale=s].sc-calcite-meter-h{--calcite-meter-height-internal:0.75rem;--calcite-meter-font-size-internal:var(--calcite-font-size--2)}/*!@:host([scale=l])*/[scale=l].sc-calcite-meter-h{--calcite-meter-height-internal:1.5rem;--calcite-meter-font-size-internal:var(--calcite-font-size-0)}/*!@.container*/.container.sc-calcite-meter{position:relative;margin:0px;display:flex;inline-size:100%;align-items:center;block-size:var(--calcite-meter-height-internal);background-color:var(--calcite-color-foreground-2);border:1px solid var(--calcite-color-border-3);border-radius:var(--calcite-meter-height-internal)}/*!@.solid*/.solid.sc-calcite-meter{border:1px solid var(--calcite-color-foreground-3);background-color:var(--calcite-color-foreground-3)}/*!@.outline*/.outline.sc-calcite-meter{background-color:transparent}/*!@.value-visible*/.value-visible.sc-calcite-meter{margin-block-start:1.5rem}/*!@.steps-visible*/.steps-visible.sc-calcite-meter{margin-block-end:1.5rem}/*!@.step-line*/.step-line.sc-calcite-meter{position:absolute;inset-block:0px;display:block;inline-size:var(--calcite-meter-space-internal);background-color:var(--calcite-color-border-3)}/*!@.label*/.label.sc-calcite-meter{position:absolute;font-size:var(--calcite-meter-font-size-internal)}/*!@.label-hidden*/.label-hidden.sc-calcite-meter{visibility:hidden;opacity:0}/*!@.label-value*/.label-value.sc-calcite-meter{inset-block-end:calc(100% + 0.5em);font-weight:var(--calcite-font-weight-bold);color:var(--calcite-color-text-1)}/*!@.label-range*/.label-range.sc-calcite-meter{color:var(--calcite-color-text-3);inset-block-start:calc(100% + 0.5em)}/*!@.unit-label*/.unit-label.sc-calcite-meter{font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-3)}/*!@.label-value .unit-label*/.label-value.sc-calcite-meter .unit-label.sc-calcite-meter{font-weight:var(--calcite-font-weight-bold);color:var(--calcite-color-text-2)}/*!@.fill*/.fill.sc-calcite-meter{position:absolute;z-index:var(--calcite-z-index);display:block;background-color:var(--calcite-color-brand);transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);inset-inline-start:var(--calcite-meter-space-internal);inset-block:var(--calcite-meter-space-internal);border-radius:var(--calcite-meter-height-internal);max-inline-size:calc(100% - var(--calcite-meter-space-internal) * 2);min-inline-size:calc(var(--calcite-meter-height-internal) - var(--calcite-meter-space-internal) * 2);transition-property:inline-size, background-color, box-shadow}/*!@.fill-danger*/.fill-danger.sc-calcite-meter{background-color:var(--calcite-color-status-danger)}/*!@.fill-success*/.fill-success.sc-calcite-meter{background-color:var(--calcite-color-status-success)}/*!@.fill-warning*/.fill-warning.sc-calcite-meter{background-color:var(--calcite-color-status-warning)}/*!@.solid .fill*/.solid.sc-calcite-meter .fill.sc-calcite-meter{inset-block:0;inset-inline-start:0;max-inline-size:100%;min-inline-size:calc(var(--calcite-meter-height-internal));box-shadow:0 0 0 1px var(--calcite-color-brand)}/*!@.solid .fill-danger*/.solid.sc-calcite-meter .fill-danger.sc-calcite-meter{box-shadow:0 0 0 1px var(--calcite-color-status-danger)}/*!@.solid .fill-success*/.solid.sc-calcite-meter .fill-success.sc-calcite-meter{box-shadow:0 0 0 1px var(--calcite-color-status-success)}/*!@.solid .fill-warning*/.solid.sc-calcite-meter .fill-warning.sc-calcite-meter{box-shadow:0 0 0 1px var(--calcite-color-status-warning)}";

class Meter {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.labelFlipMax = 0.8;
        this.labelFlipProximity = 0.15;
        this.maxPercent = 100;
        this.minPercent = 0;
        this.resizeObserver = createObserver();
        this.formatLabel = (value, labelType) => {
            if (labelType === "percent") {
                if (!this.percentFormatting) {
                    const locale = getSupportedLocale(this.effectiveLocale);
                    const formatter = new Intl.NumberFormat(locale, {
                        useGrouping: this.groupSeparator,
                        style: "percent",
                    });
                    this.percentFormatting = { formatter, locale };
                }
                return this.percentFormatting.formatter.format(value);
            }
            else {
                numberStringFormatter.numberFormatOptions = {
                    locale: this.effectiveLocale,
                    numberingSystem: this.numberingSystem,
                    useGrouping: this.groupSeparator,
                };
                return numberStringFormatter.localize(value.toString());
            }
        };
        this.appearance = "outline-fill";
        this.disabled = false;
        this.fillType = "range";
        this.form = undefined;
        this.groupSeparator = false;
        this.high = undefined;
        this.label = undefined;
        this.low = undefined;
        this.max = 100;
        this.min = 0;
        this.name = undefined;
        this.numberingSystem = undefined;
        this.rangeLabels = false;
        this.rangeLabelType = "percent";
        this.scale = "m";
        this.unitLabel = "";
        this.value = undefined;
        this.valueLabel = false;
        this.valueLabelType = "percent";
        this.currentPercent = undefined;
        this.effectiveLocale = undefined;
        this.highActive = undefined;
        this.highPercent = undefined;
        this.lowActive = undefined;
        this.lowPercent = undefined;
    }
    handleRangeChange() {
        this.calculateValues();
        this.updateLabels();
    }
    handleLabelChange() {
        this.updateLabels();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        setUpLoadableComponent(this);
        this.calculateValues();
        afterConnectDefaultValueSet(this, this.value);
    }
    componentDidLoad() {
        setComponentLoaded(this);
        this.updateLabels();
    }
    connectedCallback() {
        connectLocalized(this);
        connectForm(this);
        this.resizeObserver?.observe(this.el);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectForm(this);
        this.resizeObserver?.disconnect();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    resizeHandler() {
        this.updateLabels();
    }
    updateLabels() {
        if (this.valueLabelEl) {
            this.determineValueLabelPosition();
        }
        if (this.rangeLabels) {
            this.determineVisibleLabels();
        }
    }
    calculateValues() {
        const { min, max, low, high, value } = this;
        const lowPercent = (100 * (low - min)) / (max - min);
        const highPercent = (100 * (high - min)) / (max - min);
        const currentPercent = (100 * (value - min)) / (max - min);
        if (!low || low < min || low > high || low > max) {
            this.low = min;
        }
        if (!high || high > max || high < low || high < min) {
            this.high = max;
        }
        if (!value) {
            this.value = min;
        }
        this.lowPercent = lowPercent;
        this.highPercent = highPercent;
        this.currentPercent = value ? currentPercent : 0;
        this.lowActive = !!low && low > min && (!value || low > value) && (!high || low < high);
        this.highActive =
            !!high && min <= high && high < max && (!value || high > value) && (!low || high > low);
    }
    getMeterKindCssClass() {
        const { low, high, min, max, value } = this;
        const lowest = low ? low : min;
        const highest = high ? high : max;
        const aboveLowest = value >= lowest;
        const belowLowest = value < lowest;
        const aboveHighest = value >= highest;
        const belowHighest = value < highest;
        if (!value || (!low && belowHighest) || belowLowest) {
            return CSS$G.success;
        }
        else if (aboveLowest && belowHighest) {
            return CSS$G.warning;
        }
        else if (aboveHighest) {
            return CSS$G.danger;
        }
        else {
            return CSS$G.success;
        }
    }
    intersects(el1, el2) {
        return el1 && el2 && intersects(el1.getBoundingClientRect(), el2.getBoundingClientRect());
    }
    determineVisibleLabels() {
        const { minLabelEl, lowLabelEl, highLabelEl, maxLabelEl } = this;
        const highMaxOverlap = this.intersects(highLabelEl, maxLabelEl);
        const lowHighOverlap = this.intersects(lowLabelEl, highLabelEl);
        const lowMaxOverlap = this.intersects(lowLabelEl, maxLabelEl);
        const minHighOverlap = this.intersects(minLabelEl, highLabelEl);
        const minLowOverlap = this.intersects(minLabelEl, lowLabelEl);
        const minMaxOverlap = this.intersects(minLabelEl, maxLabelEl);
        const hiddenClass = CSS$G.labelHidden;
        if (lowLabelEl) {
            if (minLowOverlap || lowMaxOverlap || lowHighOverlap) {
                lowLabelEl.classList.add(hiddenClass);
            }
            else {
                lowLabelEl.classList.remove(hiddenClass);
            }
        }
        if (highLabelEl) {
            if (minHighOverlap || lowMaxOverlap || highMaxOverlap) {
                highLabelEl.classList.add(hiddenClass);
            }
            else {
                highLabelEl.classList.remove(hiddenClass);
            }
        }
        if (minLabelEl && maxLabelEl) {
            if (minMaxOverlap) {
                maxLabelEl.classList.add(hiddenClass);
            }
            else {
                maxLabelEl.classList.remove(hiddenClass);
            }
        }
    }
    determineValueLabelPosition() {
        const { valueLabelEl, meterContainerEl, currentPercent } = this;
        const valuePosition = currentPercent > 100 ? 100 : currentPercent > 0 ? currentPercent : 0;
        const valueLabelWidth = valueLabelEl.getBoundingClientRect().width;
        const containerWidth = meterContainerEl.getBoundingClientRect().width;
        const labelWidthPercent = (100 * (valueLabelWidth - 0)) / (containerWidth - 0);
        if (valuePosition + labelWidthPercent >= 100) {
            valueLabelEl.style.insetInlineEnd = "0%";
            valueLabelEl.style.removeProperty("inset-inline-start");
        }
        else {
            valueLabelEl.style.insetInlineStart = `${valuePosition}% `;
            valueLabelEl.style.removeProperty("inset-inline-end");
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    renderMeterFill() {
        const { currentPercent, fillType } = this;
        const kindClass = this.getMeterKindCssClass();
        return (hAsync("div", { class: { [CSS$G.fill]: true, [kindClass]: fillType !== "single" }, style: { width: `${currentPercent}%` } }));
    }
    renderRangeLine(position) {
        const style = { insetInlineStart: `${position}%` };
        return hAsync("div", { class: CSS$G.stepLine, style: style });
    }
    renderValueLabel() {
        const { currentPercent, valueLabelType, unitLabel, value } = this;
        const label = this.formatLabel(valueLabelType === "percent" ? currentPercent / 100 : value || 0, valueLabelType);
        return (hAsync("div", { class: { [CSS$G.label]: true, [CSS$G.labelValue]: true }, key: "low-label-line",
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.valueLabelEl = el) }, label, unitLabel && valueLabelType !== "percent" && (hAsync("span", { class: CSS$G.unitLabel }, "\u00A0", unitLabel))));
    }
    renderMinLabel() {
        const { rangeLabelType, min, minPercent, unitLabel } = this;
        const style = { insetInlineStart: `${minPercent}%` };
        const labelMin = this.formatLabel(rangeLabelType === "percent" ? minPercent : min, rangeLabelType);
        return (hAsync("div", { class: { [CSS$G.label]: true, [CSS$G.labelRange]: true }, key: "min-label-line", style: style,
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.minLabelEl = el) }, labelMin, unitLabel && rangeLabelType !== "percent" && (hAsync("span", { class: CSS$G.unitLabel }, "\u00A0", unitLabel))));
    }
    renderLowLabel() {
        const { rangeLabelType, low, lowPercent, highPercent, labelFlipProximity } = this;
        const label = low
            ? this.formatLabel(rangeLabelType === "percent" ? lowPercent / 100 : low, rangeLabelType)
            : "";
        const styleDefault = { insetInlineStart: `${lowPercent}%` };
        const styleFlipped = { insetInlineEnd: `${100 - lowPercent}%` };
        const style = (highPercent - lowPercent) / 100 < labelFlipProximity ? styleFlipped : styleDefault;
        return (hAsync("div", { class: { [CSS$G.label]: true, [CSS$G.labelRange]: true }, key: "low-label-line", style: style,
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.lowLabelEl = el) }, label));
    }
    renderHighLabel() {
        const { rangeLabelType, high, highPercent, labelFlipMax } = this;
        const label = high
            ? this.formatLabel(rangeLabelType === "percent" ? highPercent / 100 : high, rangeLabelType)
            : "";
        const styleDefault = { insetInlineStart: `${highPercent}%` };
        const styleFlipped = { insetInlineEnd: `${100 - highPercent}%` };
        const style = highPercent / 100 >= labelFlipMax ? styleFlipped : styleDefault;
        return (hAsync("div", { class: { [CSS$G.label]: true, [CSS$G.labelRange]: true }, key: "high-label-line", style: style,
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.highLabelEl = el) }, label));
    }
    renderMaxLabel() {
        const { rangeLabelType, max, maxPercent } = this;
        const style = { insetInlineEnd: `${100 - maxPercent}%` };
        const labelMax = this.formatLabel(rangeLabelType === "percent" ? maxPercent / 100 : max, rangeLabelType);
        return (hAsync("div", { class: { [CSS$G.label]: true, [CSS$G.labelRange]: true }, key: "max-label-line", style: style,
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.maxLabelEl = el) }, labelMax));
    }
    render() {
        const { appearance, currentPercent, highActive, highPercent, label, lowActive, lowPercent, max, maxPercent, min, minPercent, rangeLabels, rangeLabelType, unitLabel, value, valueLabel, valueLabelType, } = this;
        const textPercentLabelWithPercent = this.formatLabel(currentPercent / 100, "percent");
        const textUnitLabel = `${value} ${unitLabel}`;
        const valueText = valueLabelType === "percent"
            ? textPercentLabelWithPercent
            : unitLabel
                ? textUnitLabel
                : undefined;
        return (hAsync(Host, null, hAsync("div", { "aria-label": label, "aria-valuemax": rangeLabelType === "percent" ? maxPercent : max, "aria-valuemin": rangeLabelType === "percent" ? minPercent : min, "aria-valuenow": valueLabelType === "percent" ? currentPercent : value, "aria-valuetext": valueText, class: {
                [CSS$G.container]: true,
                [CSS$G.stepsVisible]: rangeLabels,
                [CSS$G.valueVisible]: valueLabel,
                [appearance]: appearance !== "outline-fill",
            }, role: "meter",
            // eslint-disable-next-line react/jsx-sort-props
            ref: (el) => (this.meterContainerEl = el) }, this.renderMeterFill(), valueLabel && this.renderValueLabel(), lowActive && this.renderRangeLine(lowPercent), highActive && this.renderRangeLine(highPercent), rangeLabels && this.renderMinLabel(), rangeLabels && lowActive && this.renderLowLabel(), rangeLabels && highActive && this.renderHighLabel(), rangeLabels && this.renderMaxLabel())));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "min": ["handleRangeChange"],
        "max": ["handleRangeChange"],
        "low": ["handleRangeChange"],
        "high": ["handleRangeChange"],
        "value": ["handleRangeChange"],
        "rangeLabels": ["handleLabelChange"],
        "rangeLabelType": ["handleLabelChange"],
        "unitLabel": ["handleLabelChange"],
        "valueLabel": ["handleLabelChange"],
        "valueLabelType": ["handleLabelChange"]
    }; }
    static get style() { return meterCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-meter",
        "$members$": {
            "appearance": [513],
            "disabled": [516],
            "fillType": [513, "fill-type"],
            "form": [513],
            "groupSeparator": [516, "group-separator"],
            "high": [1538],
            "label": [1],
            "low": [1538],
            "max": [514],
            "min": [514],
            "name": [513],
            "numberingSystem": [1, "numbering-system"],
            "rangeLabels": [516, "range-labels"],
            "rangeLabelType": [513, "range-label-type"],
            "scale": [513],
            "unitLabel": [1, "unit-label"],
            "value": [1026],
            "valueLabel": [516, "value-label"],
            "valueLabelType": [513, "value-label-type"],
            "currentPercent": [32],
            "effectiveLocale": [32],
            "highActive": [32],
            "highPercent": [32],
            "lowActive": [32],
            "lowPercent": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["appearance", "appearance"], ["disabled", "disabled"], ["fillType", "fill-type"], ["form", "form"], ["groupSeparator", "group-separator"], ["high", "high"], ["low", "low"], ["max", "max"], ["min", "min"], ["name", "name"], ["rangeLabels", "range-labels"], ["rangeLabelType", "range-label-type"], ["scale", "scale"], ["valueLabel", "value-label"], ["valueLabelType", "value-label-type"]]
    }; }
}

const CSS$F = {
    modal: "modal",
    title: "title",
    header: "header",
    footer: "footer",
    scrim: "scrim",
    back: "back",
    close: "close",
    secondary: "secondary",
    primary: "primary",
    container: "container",
    containerOpen: "container--open",
    content: "content",
    contentNoFooter: "content--no-footer",
    contentBottom: "content-bottom",
    contentTop: "content-top",
    slottedInShell: "slotted-in-shell",
    // these classes help apply the animation in phases to only set transform on open/close
    // this helps avoid a positioning issue for any floating-ui-owning children
    openingIdle: "modal--opening-idle",
    openingActive: "modal--opening-active",
    closingIdle: "modal--closing-idle",
    closingActive: "modal--closing-active",
};
const ICONS$7 = {
    close: "x",
};
const SLOTS$f = {
    content: "content",
    contentBottom: "content-bottom",
    contentTop: "content-top",
    header: "header",
    back: "back",
    secondary: "secondary",
    primary: "primary",
};

const modalCss = "/*!@:host*/.sc-calcite-modal-h{--calcite-modal-scrim-background:rgba(0, 0, 0, 0.85);position:absolute;inset:0px;z-index:var(--calcite-z-index-overlay);display:flex;opacity:0;visibility:hidden !important;transition:visibility 0ms linear var(--calcite-internal-animation-timing-slow), opacity var(--calcite-internal-animation-timing-slow) cubic-bezier(0.215, 0.44, 0.42, 0.88);--calcite-modal-scrim-background-internal:rgba(0, 0, 0, 0.85)}/*!@.content-top[hidden],\n.content-bottom[hidden]*/.content-top[hidden].sc-calcite-modal,.content-bottom[hidden].sc-calcite-modal{display:none}/*!@.container*/.container.sc-calcite-modal{position:fixed;inset:0px;z-index:var(--calcite-z-index-overlay);display:flex;align-items:center;justify-content:center;overflow-y:hidden;color:var(--calcite-color-text-2);opacity:0;visibility:hidden !important;transition:visibility 0ms linear var(--calcite-internal-animation-timing-slow), opacity var(--calcite-internal-animation-timing-slow) cubic-bezier(0.215, 0.44, 0.42, 0.88)}/*!@:host([scale=s])*/[scale=s].sc-calcite-modal-h{--calcite-modal-padding-internal:0.75rem;--calcite-modal-padding-large-internal:1rem;--calcite-modal-title-text-internal:var(--calcite-font-size-1);--calcite-modal-content-text-internal:var(--calcite-font-size--1)}/*!@:host([scale=m])*/[scale=m].sc-calcite-modal-h{--calcite-modal-padding-internal:1rem;--calcite-modal-padding-large-internal:1.25rem;--calcite-modal-title-text-internal:var(--calcite-font-size-2);--calcite-modal-content-text-internal:var(--calcite-font-size-0)}/*!@:host([scale=l])*/[scale=l].sc-calcite-modal-h{--calcite-modal-padding-internal:1.25rem;--calcite-modal-padding-large-internal:1.5rem;--calcite-modal-title-text-internal:var(--calcite-font-size-3);--calcite-modal-content-text-internal:var(--calcite-font-size-1)}/*!@.scrim*/.scrim.sc-calcite-modal{--calcite-scrim-background:var(--calcite-modal-scrim-background, var(--calcite-color-transparent-scrim));position:fixed;inset:0px;display:flex;overflow-y:hidden}/*!@.modal*/.modal.sc-calcite-modal{pointer-events:none;z-index:var(--calcite-z-index-modal);float:none;margin:1.5rem;box-sizing:border-box;display:flex;inline-size:100%;flex-direction:column;overflow:hidden;border-radius:0.25rem;background-color:var(--calcite-color-foreground-1);opacity:0;--tw-shadow:0 2px 12px -4px rgba(0, 0, 0, 0.2), 0 2px 4px -2px rgba(0, 0, 0, 0.16);--tw-shadow-colored:0 2px 12px -4px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);-webkit-overflow-scrolling:touch;visibility:hidden;transition:transform var(--calcite-internal-animation-timing-slow) cubic-bezier(0.215, 0.44, 0.42, 0.88), visibility 0ms linear var(--calcite-internal-animation-timing-slow), opacity var(--calcite-internal-animation-timing-slow) cubic-bezier(0.215, 0.44, 0.42, 0.88);--calcite-modal-hidden-position:translate3d(0, 20px, 0);--calcite-modal-shown-position:translate3d(0, 0, 0)}/*!@.modal--opening-idle*/.modal--opening-idle.sc-calcite-modal{transform:var(--calcite-modal-hidden-position)}/*!@.modal--opening-active*/.modal--opening-active.sc-calcite-modal{transform:var(--calcite-modal-shown-position)}/*!@.modal--closing-idle*/.modal--closing-idle.sc-calcite-modal{transform:var(--calcite-modal-shown-position)}/*!@.modal--closing-active*/.modal--closing-active.sc-calcite-modal{transform:var(--calcite-modal-hidden-position)}/*!@:host([opened])*/[opened].sc-calcite-modal-h{opacity:1;visibility:visible !important;transition-delay:0ms}/*!@.container--open*/.container--open.sc-calcite-modal{opacity:1;visibility:visible !important;transition-delay:0ms}/*!@.container--open .modal*/.container--open.sc-calcite-modal .modal.sc-calcite-modal{pointer-events:auto;visibility:visible;opacity:1;transition:transform var(--calcite-internal-animation-timing-slow) cubic-bezier(0.215, 0.44, 0.42, 0.88), visibility 0ms linear, opacity var(--calcite-internal-animation-timing-slow) cubic-bezier(0.215, 0.44, 0.42, 0.88), max-inline-size var(--calcite-internal-animation-timing-slow) cubic-bezier(0.215, 0.44, 0.42, 0.88), max-block-size var(--calcite-internal-animation-timing-slow) cubic-bezier(0.215, 0.44, 0.42, 0.88);transition-delay:0ms}/*!@.header*/.header.sc-calcite-modal{z-index:var(--calcite-z-index-header);display:flex;min-inline-size:0px;max-inline-size:100%;border-start-start-radius:0.25rem;border-start-end-radius:0.25rem;border-width:0px;border-block-end-width:1px;border-style:solid;border-color:var(--calcite-color-border-3);background-color:var(--calcite-color-foreground-1);flex:0 0 auto}/*!@.close*/.close.sc-calcite-modal{order:2;margin:0px;cursor:pointer;appearance:none;border-style:none;background-color:transparent;color:var(--calcite-color-text-3);outline-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;padding-block:var(--calcite-modal-padding-internal);padding-inline:var(--calcite-modal-padding-internal);flex:0 0 auto}/*!@.close calcite-icon*/.close.sc-calcite-modal calcite-icon.sc-calcite-modal{pointer-events:none;vertical-align:-2px}/*!@.close:focus*/.close.sc-calcite-modal:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.close:hover, .close:focus, .close:active*/.close.sc-calcite-modal:hover,.close.sc-calcite-modal:focus,.close.sc-calcite-modal:active{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-text-1)}/*!@.title*/.title.sc-calcite-modal{order:1;display:flex;min-inline-size:0px;align-items:center;flex:1 1 auto;padding-block:var(--calcite-modal-padding-internal);padding-inline:var(--calcite-modal-padding-large-internal)}/*!@slot[name=header]::slotted(*),\n*::slotted([slot=header])*/slot[name=header].sc-calcite-modal-s>*,*.sc-calcite-modal-s>[slot=header]{margin:0px;font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-1);font-size:var(--calcite-modal-title-text-internal)}/*!@.content*/.content.sc-calcite-modal{position:relative;box-sizing:border-box;display:block;block-size:100%;overflow:auto;padding:0px;background-color:var(--calcite-modal-content-background, var(--calcite-color-foreground-1));max-block-size:100%;padding:var(--calcite-modal-content-padding, var(--calcite-modal-padding-internal))}/*!@.content-top,\n.content-bottom*/.content-top.sc-calcite-modal,.content-bottom.sc-calcite-modal{z-index:var(--calcite-z-index-header);display:flex;border-width:0px;border-style:solid;border-color:var(--calcite-color-border-3);background-color:var(--calcite-color-foreground-1);flex:0 0 auto;padding:var(--calcite-modal-padding-internal)}/*!@.content-top*/.content-top.sc-calcite-modal{min-inline-size:0px;max-inline-size:100%;border-block-end-width:1px}/*!@.content-bottom*/.content-bottom.sc-calcite-modal{margin-block-start:auto;box-sizing:border-box;inline-size:100%;justify-content:space-between;border-block-start-width:1px}/*!@.content-top:not(.header ~ .content-top)*/.content-top.sc-calcite-modal:not(.header~.content-top).sc-calcite-modal{border-start-start-radius:0.25rem;border-start-end-radius:0.25rem}/*!@.content-bottom:not(.content-bottom ~ .footer),\n.content--no-footer*/.content-bottom.sc-calcite-modal:not(.content-bottom~.footer).sc-calcite-modal,.content--no-footer.sc-calcite-modal{border-end-end-radius:0.25rem;border-end-start-radius:0.25rem}/*!@slot[name=content]::slotted(*),\n*::slotted([slot=content])*/slot[name=content].sc-calcite-modal-s>*,*.sc-calcite-modal-s>[slot=content]{font-size:var(--calcite-modal-context-text-internal)}/*!@.footer*/.footer.sc-calcite-modal{z-index:var(--calcite-z-index-header);margin-block-start:auto;box-sizing:border-box;display:flex;inline-size:100%;justify-content:space-between;border-end-end-radius:0.25rem;border-end-start-radius:0.25rem;border-width:0px;border-block-start-width:1px;border-style:solid;border-color:var(--calcite-color-border-3);background-color:var(--calcite-color-foreground-1);flex:0 0 auto;padding-block:var(--calcite-modal-padding-internal);padding-inline:var(--calcite-modal-padding-large-internal)}/*!@.footer--hide-back .back,\n.footer--hide-secondary .secondary*/.footer--hide-back.sc-calcite-modal .back.sc-calcite-modal,.footer--hide-secondary.sc-calcite-modal .secondary.sc-calcite-modal{display:none}/*!@.back*/.back.sc-calcite-modal{display:block;margin-inline-end:auto}/*!@.secondary*/.secondary.sc-calcite-modal{margin-inline:0.25rem;display:block}/*!@slot[name=primary]*/slot[name=primary].sc-calcite-modal{display:block}/*!@:host([width=small]) .modal*/[width=small].sc-calcite-modal-h .modal.sc-calcite-modal{inline-size:auto}/*!@:host([width-scale=s]) .modal*/[width-scale=s].sc-calcite-modal-h .modal.sc-calcite-modal{max-block-size:100%;max-inline-size:100%;inline-size:var(--calcite-modal-width, 32rem);block-size:var(--calcite-modal-height, auto)}@media screen and (max-width: 35rem){/*!@:host([width-scale=s]) .modal*/[width-scale=s].sc-calcite-modal-h .modal.sc-calcite-modal{margin:0px;block-size:100%;max-block-size:100%;inline-size:100%;max-inline-size:100%}/*!@:host([width-scale=s]) .content*/[width-scale=s].sc-calcite-modal-h .content.sc-calcite-modal{flex:1 1 auto;max-block-size:unset}/*!@:host([width-scale=s][docked]) .container*/[width-scale=s][docked].sc-calcite-modal-h .container.sc-calcite-modal{align-items:flex-end}}/*!@:host([width-scale=m]) .modal*/[width-scale=m].sc-calcite-modal-h .modal.sc-calcite-modal{max-block-size:100%;max-inline-size:100%;inline-size:var(--calcite-modal-width, 48rem);block-size:var(--calcite-modal-height, auto)}@media screen and (max-width: 51rem){/*!@:host([width-scale=m]) .modal*/[width-scale=m].sc-calcite-modal-h .modal.sc-calcite-modal{margin:0px;block-size:100%;max-block-size:100%;inline-size:100%;max-inline-size:100%}/*!@:host([width-scale=m]) .content*/[width-scale=m].sc-calcite-modal-h .content.sc-calcite-modal{flex:1 1 auto;max-block-size:unset}/*!@:host([width-scale=m][docked]) .container*/[width-scale=m][docked].sc-calcite-modal-h .container.sc-calcite-modal{align-items:flex-end}}/*!@:host([width-scale=l]) .modal*/[width-scale=l].sc-calcite-modal-h .modal.sc-calcite-modal{max-block-size:100%;max-inline-size:100%;inline-size:var(--calcite-modal-width, 94rem);block-size:var(--calcite-modal-height, auto)}@media screen and (max-width: 97rem){/*!@:host([width-scale=l]) .modal*/[width-scale=l].sc-calcite-modal-h .modal.sc-calcite-modal{margin:0px;block-size:100%;max-block-size:100%;inline-size:100%;max-inline-size:100%}/*!@:host([width-scale=l]) .content*/[width-scale=l].sc-calcite-modal-h .content.sc-calcite-modal{flex:1 1 auto;max-block-size:unset}/*!@:host([width-scale=l][docked]) .container*/[width-scale=l][docked].sc-calcite-modal-h .container.sc-calcite-modal{align-items:flex-end}}/*!@:host([fullscreen]) .modal*/[fullscreen].sc-calcite-modal-h .modal.sc-calcite-modal{margin:0px;block-size:100%;max-block-size:100%;inline-size:100%;max-inline-size:100%;border-radius:0px;--calcite-modal-hidden-position:translate3D(0, 20px, 0) scale(0.95);--calcite-modal-shown-position:translate3D(0, 0, 0) scale(1)}/*!@:host([fullscreen]) .content*/[fullscreen].sc-calcite-modal-h .content.sc-calcite-modal{max-block-size:100%;flex:1 1 auto}/*!@:host([opened][fullscreen]) .header,\n:host([opened][fullscreen]) .footer,\n:host([opened][fullscreen]) .content-top,\n:host([opened][fullscreen]) .content-bottom*/[opened][fullscreen].sc-calcite-modal-h .header.sc-calcite-modal,[opened][fullscreen].sc-calcite-modal-h .footer.sc-calcite-modal,[opened][fullscreen].sc-calcite-modal-h .content-top.sc-calcite-modal,[opened][fullscreen].sc-calcite-modal-h .content-bottom.sc-calcite-modal{border-radius:0}/*!@:host([docked]) .modal*/[docked].sc-calcite-modal-h .modal.sc-calcite-modal{block-size:var(--calcite-modal-height, auto)}/*!@:host([docked]) .content*/[docked].sc-calcite-modal-h .content.sc-calcite-modal{block-size:auto;flex:1 1 auto}/*!@:host([kind=brand]) .modal*/[kind=brand].sc-calcite-modal-h .modal.sc-calcite-modal{border-color:var(--calcite-color-brand)}/*!@:host([kind=danger]) .modal*/[kind=danger].sc-calcite-modal-h .modal.sc-calcite-modal{border-color:var(--calcite-color-status-danger)}/*!@:host([kind=info]) .modal*/[kind=info].sc-calcite-modal-h .modal.sc-calcite-modal{border-color:var(--calcite-color-status-info)}/*!@:host([kind=success]) .modal*/[kind=success].sc-calcite-modal-h .modal.sc-calcite-modal{border-color:var(--calcite-color-status-success)}/*!@:host([kind=warning]) .modal*/[kind=warning].sc-calcite-modal-h .modal.sc-calcite-modal{border-color:var(--calcite-color-status-warning)}/*!@:host([kind=brand]) .modal,\n:host([kind=danger]) .modal,\n:host([kind=info]) .modal,\n:host([kind=success]) .modal,\n:host([kind=warning]) .modal*/[kind=brand].sc-calcite-modal-h .modal.sc-calcite-modal,[kind=danger].sc-calcite-modal-h .modal.sc-calcite-modal,[kind=info].sc-calcite-modal-h .modal.sc-calcite-modal,[kind=success].sc-calcite-modal-h .modal.sc-calcite-modal,[kind=warning].sc-calcite-modal-h .modal.sc-calcite-modal{border-width:0px;border-block-start-width:4px;border-style:solid}/*!@:host([kind=brand]) .header,\n:host([kind=brand]) .content-top,\n:host([kind=danger]) .header,\n:host([kind=danger]) .content-top,\n:host([kind=info]) .header,\n:host([kind=info]) .content-top,\n:host([kind=success]) .header,\n:host([kind=success]) .content-top,\n:host([kind=warning]) .header,\n:host([kind=warning]) .content-top*/[kind=brand].sc-calcite-modal-h .header.sc-calcite-modal,[kind=brand].sc-calcite-modal-h .content-top.sc-calcite-modal,[kind=danger].sc-calcite-modal-h .header.sc-calcite-modal,[kind=danger].sc-calcite-modal-h .content-top.sc-calcite-modal,[kind=info].sc-calcite-modal-h .header.sc-calcite-modal,[kind=info].sc-calcite-modal-h .content-top.sc-calcite-modal,[kind=success].sc-calcite-modal-h .header.sc-calcite-modal,[kind=success].sc-calcite-modal-h .content-top.sc-calcite-modal,[kind=warning].sc-calcite-modal-h .header.sc-calcite-modal,[kind=warning].sc-calcite-modal-h .content-top.sc-calcite-modal{border-radius:0.25rem;border-end-end-radius:0px;border-end-start-radius:0px}@media screen and (max-width: 860px){/*!@* slot[name=header]::slotted(content-top),\n  * content-top::slotted([slot=header])*/* slot[name=header].sc-calcite-modal-s>content-top,* content-top.sc-calcite-modal-s>[slot=header]{font-size:var(--calcite-font-size-1)}/*!@.footer,\n  .content-bottom*/.footer.sc-calcite-modal,.content-bottom.sc-calcite-modal{position:sticky;inset-block-end:0px}}@media screen and (max-width: 480px){/*!@.footer,\n  .content-bottom*/.footer.sc-calcite-modal,.content-bottom.sc-calcite-modal{flex-direction:column}/*!@.back,\n  .secondary*/.back.sc-calcite-modal,.secondary.sc-calcite-modal{margin:0px;margin-block-end:0.25rem}}/*!@.container.slotted-in-shell*/.container.slotted-in-shell.sc-calcite-modal{position:absolute;pointer-events:auto}/*!@.container.slotted-in-shell calcite-scrim*/.container.slotted-in-shell.sc-calcite-modal calcite-scrim.sc-calcite-modal{position:absolute}/*!@:host([hidden])*/[hidden].sc-calcite-modal-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-modal{display:none}";

let totalOpenModals = 0;
let initialDocumentOverflowStyle = "";
/**
 * @slot header - A slot for adding header text.
 * @slot content - A slot for adding the component's content.
 * @slot content-top - A slot for adding content to the component's sticky header, where content remains at the top of the component when scrolling up and down.
 * @slot content-bottom - A slot for adding content to the component's sticky footer, where content remains at the bottom of the component when scrolling up and down.
 * @slot primary - A slot for adding a primary button.
 * @slot secondary - A slot for adding a secondary button.
 * @slot back - A slot for adding a back button.
 */
class Modal {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteModalBeforeClose = createEvent(this, "calciteModalBeforeClose", 6);
        this.calciteModalClose = createEvent(this, "calciteModalClose", 6);
        this.calciteModalBeforeOpen = createEvent(this, "calciteModalBeforeOpen", 6);
        this.calciteModalOpen = createEvent(this, "calciteModalOpen", 6);
        //--------------------------------------------------------------------------
        //
        //  Private Properties/ State
        //
        //--------------------------------------------------------------------------
        this.ignoreOpenChange = false;
        this.mutationObserver = createObserver();
        this.cssVarObserver = createObserver();
        this.openTransitionProp = "opacity";
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.setTransitionEl = (el) => {
            this.transitionEl = el;
        };
        this.openEnd = () => {
            this.setFocus();
            this.el.removeEventListener("calciteModalOpen", this.openEnd);
        };
        this.handleCloseClick = () => {
            this.open = false;
        };
        this.handleOutsideClose = () => {
            if (this.outsideCloseDisabled) {
                return;
            }
            this.open = false;
        };
        this.closeModal = async () => {
            if (this.beforeClose) {
                try {
                    await this.beforeClose(this.el);
                }
                catch (_error) {
                    // close prevented
                    requestAnimationFrame(() => {
                        this.ignoreOpenChange = true;
                        this.open = true;
                        this.ignoreOpenChange = false;
                    });
                    return;
                }
            }
            totalOpenModals--;
            this.opened = false;
            this.removeOverflowHiddenClass();
        };
        this.handleMutationObserver = () => {
            this.updateFooterVisibility();
            this.updateFocusTrapElements();
        };
        this.updateFooterVisibility = () => {
            this.hasFooter = !!getSlotted(this.el, [SLOTS$f.back, SLOTS$f.primary, SLOTS$f.secondary]);
        };
        this.updateSizeCssVars = () => {
            this.cssWidth = getComputedStyle(this.el).getPropertyValue("--calcite-modal-width");
            this.cssHeight = getComputedStyle(this.el).getPropertyValue("--calcite-modal-height");
        };
        this.contentTopSlotChangeHandler = (event) => {
            this.hasContentTop = slotChangeHasAssignedElement(event);
        };
        this.contentBottomSlotChangeHandler = (event) => {
            this.hasContentBottom = slotChangeHasAssignedElement(event);
        };
        this.open = false;
        this.opened = false;
        this.beforeClose = undefined;
        this.closeButtonDisabled = false;
        this.focusTrapDisabled = false;
        this.outsideCloseDisabled = false;
        this.docked = undefined;
        this.escapeDisabled = false;
        this.scale = "m";
        this.widthScale = "m";
        this.fullscreen = undefined;
        this.kind = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.slottedInShell = undefined;
        this.cssWidth = undefined;
        this.cssHeight = undefined;
        this.hasFooter = true;
        this.hasContentTop = false;
        this.hasContentBottom = false;
        this.effectiveLocale = undefined;
        this.defaultMessages = undefined;
    }
    handleFocusTrapDisabled(focusTrapDisabled) {
        if (!this.open) {
            return;
        }
        focusTrapDisabled ? deactivateFocusTrap(this) : activateFocusTrap(this);
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        await setUpMessages(this);
        setUpLoadableComponent(this);
        // when modal initially renders, if active was set we need to open as watcher doesn't fire
        if (this.open) {
            this.openModal();
        }
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    connectedCallback() {
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
        this.cssVarObserver?.observe(this.el, { attributeFilter: ["style"] });
        this.updateSizeCssVars();
        this.updateFooterVisibility();
        connectConditionalSlotComponent(this);
        connectLocalized(this);
        connectMessages(this);
        connectFocusTrap(this);
    }
    disconnectedCallback() {
        this.removeOverflowHiddenClass();
        this.mutationObserver?.disconnect();
        this.cssVarObserver?.disconnect();
        disconnectConditionalSlotComponent(this);
        deactivateFocusTrap(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        this.slottedInShell = false;
    }
    render() {
        return (hAsync(Host, { "aria-describedby": this.contentId, "aria-labelledby": this.titleId, "aria-modal": "true", role: "dialog" }, hAsync("div", { class: {
                [CSS$F.container]: true,
                [CSS$F.containerOpen]: this.opened,
                [CSS$F.slottedInShell]: this.slottedInShell,
            } }, hAsync("calcite-scrim", { class: CSS$F.scrim, onClick: this.handleOutsideClose }), this.renderStyle(), hAsync("div", { class: {
                [CSS$F.modal]: true,
            },
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setTransitionEl }, hAsync("div", { class: CSS$F.header }, this.renderCloseButton(), hAsync("header", { class: CSS$F.title }, hAsync("slot", { name: CSS$F.header }))), this.renderContentTop(), hAsync("div", { class: {
                [CSS$F.content]: true,
                [CSS$F.contentNoFooter]: !this.hasFooter,
            },
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.modalContent = el) }, hAsync("slot", { name: SLOTS$f.content })), this.renderContentBottom(), this.renderFooter()))));
    }
    renderFooter() {
        return this.hasFooter ? (hAsync("div", { class: CSS$F.footer, key: "footer" }, hAsync("span", { class: CSS$F.back }, hAsync("slot", { name: SLOTS$f.back })), hAsync("span", { class: CSS$F.secondary }, hAsync("slot", { name: SLOTS$f.secondary })), hAsync("span", { class: CSS$F.primary }, hAsync("slot", { name: SLOTS$f.primary })))) : null;
    }
    renderContentTop() {
        return (hAsync("div", { class: CSS$F.contentTop, hidden: !this.hasContentTop }, hAsync("slot", { name: SLOTS$f.contentTop, onSlotchange: this.contentTopSlotChangeHandler })));
    }
    renderContentBottom() {
        return (hAsync("div", { class: CSS$F.contentBottom, hidden: !this.hasContentBottom }, hAsync("slot", { name: SLOTS$f.contentBottom, onSlotchange: this.contentBottomSlotChangeHandler })));
    }
    renderCloseButton() {
        return !this.closeButtonDisabled ? (hAsync("button", { "aria-label": this.messages.close, class: CSS$F.close, key: "button", onClick: this.handleCloseClick, title: this.messages.close,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.closeButtonEl = el) }, hAsync("calcite-icon", { icon: ICONS$7.close, scale: getIconScale(this.scale) }))) : null;
    }
    renderStyle() {
        if (!this.fullscreen && (this.cssWidth || this.cssHeight)) {
            return (hAsync("style", null, `.${CSS$F.container} {
              ${this.docked && this.cssWidth ? `align-items: center !important;` : ""}
            }
            .${CSS$F.modal} {
              block-size: ${this.cssHeight ? this.cssHeight : "auto"} !important;
              ${this.cssWidth ? `inline-size: ${this.cssWidth} !important;` : ""}
              ${this.cssWidth ? `max-inline-size: ${this.cssWidth} !important;` : ""}
              ${this.docked ? `border-radius: var(--calcite-border-radius) !important;` : ""}
            }
            @media screen and (max-width: ${this.cssWidth}) {
              .${CSS$F.container} {
                ${this.docked ? `align-items: flex-end !important;` : ""}
              }
              .${CSS$F.modal} {
                max-block-size: 100% !important;
                inline-size: 100% !important;
                max-inline-size: 100% !important;
                min-inline-size: 100% !important;
                margin: 0 !important;
                ${!this.docked ? `block-size: 100% !important;` : ""}
                ${!this.docked ? `border-radius: 0 !important;` : ""}
                ${this.docked
                ? `border-radius: var(--calcite-border-radius) var(--calcite-border-radius) 0 0 !important;`
                : ""}
              }
            }
          `));
        }
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    handleEscape(event) {
        if (this.open && !this.escapeDisabled && event.key === "Escape" && !event.defaultPrevented) {
            this.open = false;
            event.preventDefault();
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Sets focus on the component's "close" button (the first focusable item).
     *
     */
    async setFocus() {
        await componentFocusable(this);
        focusFirstTabbable(this.el);
    }
    /**
     * Updates the element(s) that are used within the focus-trap of the component.
     */
    async updateFocusTrapElements() {
        updateFocusTrapElements(this);
    }
    /**
     * Sets the scroll top of the component's content.
     *
     * @param top
     * @param left
     */
    async scrollContent(top = 0, left = 0) {
        if (this.modalContent) {
            if (this.modalContent.scrollTo) {
                this.modalContent.scrollTo({ top, left, behavior: "smooth" });
            }
            else {
                this.modalContent.scrollTop = top;
                this.modalContent.scrollLeft = left;
            }
        }
    }
    onBeforeOpen() {
        this.transitionEl.classList.add(CSS$F.openingActive);
        this.calciteModalBeforeOpen.emit();
    }
    onOpen() {
        this.transitionEl.classList.remove(CSS$F.openingIdle, CSS$F.openingActive);
        this.calciteModalOpen.emit();
        activateFocusTrap(this);
    }
    onBeforeClose() {
        this.transitionEl.classList.add(CSS$F.closingActive);
        this.calciteModalBeforeClose.emit();
    }
    onClose() {
        this.transitionEl.classList.remove(CSS$F.closingIdle, CSS$F.closingActive);
        this.calciteModalClose.emit();
        deactivateFocusTrap(this);
    }
    toggleModal(value) {
        if (this.ignoreOpenChange) {
            return;
        }
        if (value) {
            this.openModal();
        }
        else {
            this.closeModal();
        }
    }
    handleOpenedChange(value) {
        const idleClass = value ? CSS$F.openingIdle : CSS$F.closingIdle;
        this.transitionEl.classList.add(idleClass);
        onToggleOpenCloseComponent(this);
    }
    async openModal() {
        await componentOnReady(this.el);
        this.el.addEventListener("calciteModalOpen", this.openEnd);
        this.opened = true;
        const titleEl = getSlotted(this.el, SLOTS$f.header);
        const contentEl = getSlotted(this.el, SLOTS$f.content);
        this.titleId = ensureId(titleEl);
        this.contentId = ensureId(contentEl);
        if (!this.slottedInShell) {
            if (totalOpenModals === 0) {
                initialDocumentOverflowStyle = document.documentElement.style.overflow;
            }
            totalOpenModals++;
            // use an inline style instead of a utility class to avoid global class declarations.
            document.documentElement.style.setProperty("overflow", "hidden");
        }
    }
    removeOverflowHiddenClass() {
        document.documentElement.style.setProperty("overflow", initialDocumentOverflowStyle);
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "focusTrapDisabled": ["handleFocusTrapDisabled"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"],
        "open": ["toggleModal"],
        "opened": ["handleOpenedChange"]
    }; }
    static get style() { return modalCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-modal",
        "$members$": {
            "open": [1540],
            "opened": [1540],
            "beforeClose": [16],
            "closeButtonDisabled": [516, "close-button-disabled"],
            "focusTrapDisabled": [516, "focus-trap-disabled"],
            "outsideCloseDisabled": [516, "outside-close-disabled"],
            "docked": [516],
            "escapeDisabled": [516, "escape-disabled"],
            "scale": [513],
            "widthScale": [513, "width-scale"],
            "fullscreen": [516],
            "kind": [513],
            "messages": [1040],
            "messageOverrides": [1040],
            "slottedInShell": [1028, "slotted-in-shell"],
            "cssWidth": [32],
            "cssHeight": [32],
            "hasFooter": [32],
            "hasContentTop": [32],
            "hasContentBottom": [32],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "setFocus": [64],
            "updateFocusTrapElements": [64],
            "scrollContent": [64]
        },
        "$listeners$": [[8, "keydown", "handleEscape"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["open", "open"], ["opened", "opened"], ["closeButtonDisabled", "close-button-disabled"], ["focusTrapDisabled", "focus-trap-disabled"], ["outsideCloseDisabled", "outside-close-disabled"], ["docked", "docked"], ["escapeDisabled", "escape-disabled"], ["scale", "scale"], ["widthScale", "width-scale"], ["fullscreen", "fullscreen"], ["kind", "kind"]]
    }; }
}

const SLOTS$e = {
    title: "title",
    message: "message",
    link: "link",
    actionsEnd: "actions-end",
};
const CSS$E = {
    actionsEnd: "actions-end",
    close: "notice-close",
    container: "container",
    content: "notice-content",
    icon: "notice-icon",
};

const noticeCss = "/*!@:host([scale=s])*/[scale=s].sc-calcite-notice-h{--calcite-notice-spacing-token-small:0.5rem;--calcite-notice-spacing-token-large:0.75rem}/*!@:host([scale=s]) .container slot[name=title]::slotted(*),\n:host([scale=s]) .container *::slotted([slot=title])*/.sc-calcite-notice-h[scale=s] .container slot[name=title].sc-calcite-notice-s>*,.sc-calcite-notice-h[scale=s] .container *.sc-calcite-notice-s>[slot=title]{margin-block:0.125rem;font-size:var(--calcite-font-size--1);line-height:1.375}/*!@:host([scale=s]) .container slot[name=message]::slotted(*),\n:host([scale=s]) .container *::slotted([slot=message])*/.sc-calcite-notice-h[scale=s] .container slot[name=message].sc-calcite-notice-s>*,.sc-calcite-notice-h[scale=s] .container *.sc-calcite-notice-s>[slot=message]{margin-block:0.125rem;font-size:var(--calcite-font-size--2);line-height:1.375}/*!@:host([scale=s]) ::slotted(calcite-link)*/.sc-calcite-notice-h[scale=s] .sc-calcite-notice-s>calcite-link{margin-block:0.125rem;font-size:var(--calcite-font-size--2);line-height:1.375}/*!@:host([scale=s]) .notice-close*/[scale=s].sc-calcite-notice-h .notice-close.sc-calcite-notice{padding:0.5rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-notice-h{--calcite-notice-spacing-token-small:0.75rem;--calcite-notice-spacing-token-large:1rem}/*!@:host([scale=m]) .container slot[name=title]::slotted(*),\n:host([scale=m]) .container *::slotted([slot=title])*/.sc-calcite-notice-h[scale=m] .container slot[name=title].sc-calcite-notice-s>*,.sc-calcite-notice-h[scale=m] .container *.sc-calcite-notice-s>[slot=title]{margin-block:0.125rem;font-size:var(--calcite-font-size-0);line-height:1.375}/*!@:host([scale=m]) .container slot[name=message]::slotted(*),\n:host([scale=m]) .container *::slotted([slot=message])*/.sc-calcite-notice-h[scale=m] .container slot[name=message].sc-calcite-notice-s>*,.sc-calcite-notice-h[scale=m] .container *.sc-calcite-notice-s>[slot=message]{margin-block:0.125rem;font-size:var(--calcite-font-size--1);line-height:1.375}/*!@:host([scale=m]) ::slotted(calcite-link)*/.sc-calcite-notice-h[scale=m] .sc-calcite-notice-s>calcite-link{margin-block:0.125rem;font-size:var(--calcite-font-size--1);line-height:1.375}/*!@:host([scale=l])*/[scale=l].sc-calcite-notice-h{--calcite-notice-spacing-token-small:1rem;--calcite-notice-spacing-token-large:1.25rem}/*!@:host([scale=l]) .container slot[name=title]::slotted(*),\n:host([scale=l]) .container *::slotted([slot=title])*/.sc-calcite-notice-h[scale=l] .container slot[name=title].sc-calcite-notice-s>*,.sc-calcite-notice-h[scale=l] .container *.sc-calcite-notice-s>[slot=title]{margin-block:0.125rem;font-size:var(--calcite-font-size-1);line-height:1.375}/*!@:host([scale=l]) .container slot[name=message]::slotted(*),\n:host([scale=l]) .container *::slotted([slot=message])*/.sc-calcite-notice-h[scale=l] .container slot[name=message].sc-calcite-notice-s>*,.sc-calcite-notice-h[scale=l] .container *.sc-calcite-notice-s>[slot=message]{margin-block:0.125rem;font-size:var(--calcite-font-size-0);line-height:1.375}/*!@:host([scale=l]) ::slotted(calcite-link)*/.sc-calcite-notice-h[scale=l] .sc-calcite-notice-s>calcite-link{margin-block:0.125rem;font-size:var(--calcite-font-size-0);line-height:1.375}/*!@:host([width=auto])*/[width=auto].sc-calcite-notice-h{--calcite-notice-width:auto}/*!@:host([width=half])*/[width=half].sc-calcite-notice-h{--calcite-notice-width:50%}/*!@:host([width=full])*/[width=full].sc-calcite-notice-h{--calcite-notice-width:100%}/*!@:host*/.sc-calcite-notice-h{margin-inline:auto;display:none;max-inline-size:100%;align-items:center;inline-size:var(--calcite-notice-width)}/*!@.container*/.container.sc-calcite-notice{pointer-events:none;margin-block:0px;box-sizing:border-box;display:none;inline-size:100%;background-color:var(--calcite-color-foreground-1);opacity:0;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;max-block-size:0;text-align:start;border-inline-start:0px solid;box-shadow:0 0 0 0 transparent}/*!@.notice-close*/.notice-close.sc-calcite-notice{outline-color:transparent}/*!@.notice-close:focus*/.notice-close.sc-calcite-notice:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host*/.sc-calcite-notice-h{display:flex}/*!@:host([open]) .container*/[open].sc-calcite-notice-h .container.sc-calcite-notice{pointer-events:auto;display:flex;max-block-size:100%;align-items:center;border-width:2px;opacity:1;--tw-shadow:0 4px 8px -1px rgba(0, 0, 0, 0.08), 0 2px 4px -1px rgba(0, 0, 0, 0.04);--tw-shadow-colored:0 4px 8px -1px var(--tw-shadow-color), 0 2px 4px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@.container slot[name=title]::slotted(*),\n.container *::slotted([slot=title])*/.container slot[name=title].sc-calcite-notice-s>*,.container *.sc-calcite-notice-s>[slot=title]{margin:0px;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1)}/*!@.container slot[name=message]::slotted(*),\n.container *::slotted([slot=message])*/.container slot[name=message].sc-calcite-notice-s>*,.container *.sc-calcite-notice-s>[slot=message]{margin:0px;display:inline;font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-2);margin-inline-end:var(--calcite-notice-spacing-token-small)}/*!@.notice-content*/.notice-content.sc-calcite-notice{box-sizing:border-box;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;padding-inline:var(--calcite-notice-spacing-token-large);flex:0 0 auto;display:flex;min-inline-size:0px;flex-direction:column;overflow-wrap:break-word;flex:1 1 0;padding-block:var(--calcite-notice-spacing-token-small);padding-inline:0 var(--calcite-notice-spacing-token-small)}/*!@.notice-content:first-of-type:not(:only-child)*/.notice-content.sc-calcite-notice:first-of-type:not(:only-child){padding-inline-start:var(--calcite-notice-spacing-token-large)}/*!@.notice-content:only-of-type*/.notice-content.sc-calcite-notice:only-of-type{padding-block:var(--calcite-notice-spacing-token-small);padding-inline:var(--calcite-notice-spacing-token-large)}/*!@.notice-icon*/.notice-icon.sc-calcite-notice{display:flex;align-items:center;box-sizing:border-box;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;padding-block:var(--calcite-notice-spacing-token-small);padding-inline:var(--calcite-notice-spacing-token-large);flex:0 0 auto}/*!@.notice-close*/.notice-close.sc-calcite-notice{display:flex;cursor:pointer;align-items:center;align-self:stretch;border-style:none;background-color:transparent;color:var(--calcite-color-text-3);outline:2px solid transparent;outline-offset:2px;box-sizing:border-box;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;padding-block:var(--calcite-notice-spacing-token-small);padding-inline:var(--calcite-notice-spacing-token-large);flex:0 0 auto;-webkit-appearance:none}/*!@.notice-close:hover, .notice-close:focus*/.notice-close.sc-calcite-notice:hover,.notice-close.sc-calcite-notice:focus{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-text-1)}/*!@.notice-close:active*/.notice-close.sc-calcite-notice:active{background-color:var(--calcite-color-foreground-3)}/*!@.actions-end*/.actions-end.sc-calcite-notice{display:flex;align-self:stretch}/*!@:host([kind=brand]) .container*/[kind=brand].sc-calcite-notice-h .container.sc-calcite-notice{border-color:var(--calcite-color-brand)}/*!@:host([kind=brand]) .container .notice-icon*/[kind=brand].sc-calcite-notice-h .container.sc-calcite-notice .notice-icon.sc-calcite-notice{color:var(--calcite-color-brand)}/*!@:host([kind=info]) .container*/[kind=info].sc-calcite-notice-h .container.sc-calcite-notice{border-color:var(--calcite-color-status-info)}/*!@:host([kind=info]) .container .notice-icon*/[kind=info].sc-calcite-notice-h .container.sc-calcite-notice .notice-icon.sc-calcite-notice{color:var(--calcite-color-status-info)}/*!@:host([kind=danger]) .container*/[kind=danger].sc-calcite-notice-h .container.sc-calcite-notice{border-color:var(--calcite-color-status-danger)}/*!@:host([kind=danger]) .container .notice-icon*/[kind=danger].sc-calcite-notice-h .container.sc-calcite-notice .notice-icon.sc-calcite-notice{color:var(--calcite-color-status-danger)}/*!@:host([kind=success]) .container*/[kind=success].sc-calcite-notice-h .container.sc-calcite-notice{border-color:var(--calcite-color-status-success)}/*!@:host([kind=success]) .container .notice-icon*/[kind=success].sc-calcite-notice-h .container.sc-calcite-notice .notice-icon.sc-calcite-notice{color:var(--calcite-color-status-success)}/*!@:host([kind=warning]) .container*/[kind=warning].sc-calcite-notice-h .container.sc-calcite-notice{border-color:var(--calcite-color-status-warning)}/*!@:host([kind=warning]) .container .notice-icon*/[kind=warning].sc-calcite-notice-h .container.sc-calcite-notice .notice-icon.sc-calcite-notice{color:var(--calcite-color-status-warning)}/*!@:host([hidden])*/[hidden].sc-calcite-notice-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-notice{display:none}";

/**
 * Notices are intended to be used to present users with important-but-not-crucial contextual tips or copy. Because
 * notices are displayed inline, a common use case is displaying them on page-load to present users with short hints or contextual copy.
 * They are optionally closable - useful for keeping track of whether or not a user has closed the notice. You can also choose not
 * to display a notice on page load and set the "active" attribute as needed to contextually provide inline messaging to users.
 */
/**
 * @slot title - A slot for adding the title.
 * @slot message - A slot for adding the message.
 * @slot link - A slot for adding a `calcite-action` to take, such as: "undo", "try again", "link to page", etc.
 * @slot actions-end - A slot for adding `calcite-action`s to the end of the component. It is recommended to use two or less actions.
 */
class Notice {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteNoticeBeforeClose = createEvent(this, "calciteNoticeBeforeClose", 6);
        this.calciteNoticeBeforeOpen = createEvent(this, "calciteNoticeBeforeOpen", 6);
        this.calciteNoticeClose = createEvent(this, "calciteNoticeClose", 6);
        this.calciteNoticeOpen = createEvent(this, "calciteNoticeOpen", 6);
        this.setTransitionEl = (el) => {
            this.transitionEl = el;
        };
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.close = () => {
            this.open = false;
        };
        this.openTransitionProp = "opacity";
        this.open = false;
        this.kind = "brand";
        this.closable = false;
        this.icon = undefined;
        this.iconFlipRtl = false;
        this.scale = "m";
        this.width = "auto";
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.effectiveLocale = undefined;
        this.defaultMessages = undefined;
    }
    openHandler() {
        onToggleOpenCloseComponent(this);
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    updateRequestedIcon() {
        this.requestedIcon = setRequestedIcon(KindIcons, this.icon, this.kind);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectConditionalSlotComponent(this);
        connectLocalized(this);
        connectMessages(this);
    }
    disconnectedCallback() {
        disconnectConditionalSlotComponent(this);
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        this.requestedIcon = setRequestedIcon(KindIcons, this.icon, this.kind);
        await setUpMessages(this);
        if (this.open) {
            onToggleOpenCloseComponent(this);
        }
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    render() {
        const { el } = this;
        const closeButton = (hAsync("button", { "aria-label": this.messages.close, class: CSS$E.close, onClick: this.close,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.closeButton = el) }, hAsync("calcite-icon", { icon: "x", scale: getIconScale(this.scale) })));
        const hasActionEnd = getSlotted(el, SLOTS$e.actionsEnd);
        return (hAsync("div", { class: CSS$E.container,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setTransitionEl }, this.requestedIcon ? (hAsync("div", { class: CSS$E.icon }, hAsync("calcite-icon", { flipRtl: this.iconFlipRtl, icon: this.requestedIcon, scale: getIconScale(this.scale) }))) : null, hAsync("div", { class: CSS$E.content }, hAsync("slot", { name: SLOTS$e.title }), hAsync("slot", { name: SLOTS$e.message }), hAsync("slot", { name: SLOTS$e.link })), hasActionEnd ? (hAsync("div", { class: CSS$E.actionsEnd }, hAsync("slot", { name: SLOTS$e.actionsEnd }))) : null, this.closable ? closeButton : null));
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component's first focusable element. */
    async setFocus() {
        await componentFocusable(this);
        const noticeLinkEl = this.el.querySelector("calcite-link");
        if (!this.closeButton && !noticeLinkEl) {
            return;
        }
        if (noticeLinkEl) {
            return noticeLinkEl.setFocus();
        }
        else if (this.closeButton) {
            this.closeButton.focus();
        }
    }
    onBeforeClose() {
        this.calciteNoticeBeforeClose.emit();
    }
    onBeforeOpen() {
        this.calciteNoticeBeforeOpen.emit();
    }
    onClose() {
        this.calciteNoticeClose.emit();
    }
    onOpen() {
        this.calciteNoticeOpen.emit();
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "open": ["openHandler"],
        "messageOverrides": ["onMessagesChange"],
        "icon": ["updateRequestedIcon"],
        "kind": ["updateRequestedIcon"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return noticeCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-notice",
        "$members$": {
            "open": [1540],
            "kind": [513],
            "closable": [516],
            "icon": [520],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "scale": [513],
            "width": [513],
            "messages": [1040],
            "messageOverrides": [1040],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["open", "open"], ["kind", "kind"], ["closable", "closable"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["scale", "scale"], ["width", "width"]]
    }; }
}

const optionCss = "/*!@:host*/.sc-calcite-option-h{display:block}/*!@:host([hidden])*/[hidden].sc-calcite-option-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-option{display:none}";

class Option {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalOptionChange = createEvent(this, "calciteInternalOptionChange", 6);
        this.mutationObserver = createObserver();
        this.disabled = false;
        this.label = undefined;
        this.selected = undefined;
        this.value = undefined;
    }
    handlePropChange(_newValue, _oldValue, propName) {
        if (propName === "label" || propName === "value") {
            this.ensureTextContentDependentProps();
        }
        this.calciteInternalOptionChange.emit();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    ensureTextContentDependentProps() {
        const { el: { textContent }, internallySetLabel, internallySetValue, label, value, } = this;
        if (!label || label === internallySetLabel) {
            this.label = textContent;
            this.internallySetLabel = textContent;
        }
        if (value == null /* intentional loose equals to handle both undefined & null */ ||
            value === internallySetValue) {
            this.value = textContent;
            this.internallySetValue = textContent;
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.ensureTextContentDependentProps();
        this.mutationObserver?.observe(this.el, {
            attributeFilter: ["label", "value"],
            characterData: true,
            childList: true,
            subtree: true,
        });
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        return hAsync("slot", null, this.label);
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "disabled": ["handlePropChange"],
        "label": ["handlePropChange"],
        "selected": ["handlePropChange"],
        "value": ["handlePropChange"]
    }; }
    static get style() { return optionCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-option",
        "$members$": {
            "disabled": [516],
            "label": [1025],
            "selected": [516],
            "value": [1032]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["selected", "selected"]]
    }; }
}

const optionGroupCss = "/*!@:host*/.sc-calcite-option-group-h{display:block}/*!@:host([hidden])*/[hidden].sc-calcite-option-group-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-option-group{display:none}";

/**
 * @slot - A slot for adding `calcite-option`s.
 */
class OptionGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalOptionGroupChange = createEvent(this, "calciteInternalOptionGroupChange", 6);
        this.disabled = false;
        this.label = undefined;
    }
    handlePropChange() {
        this.calciteInternalOptionGroupChange.emit();
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        return (hAsync(Fragment, null, hAsync("div", null, this.label), hAsync("slot", null)));
    }
    static get watchers() { return {
        "disabled": ["handlePropChange"],
        "label": ["handlePropChange"]
    }; }
    static get style() { return optionGroupCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-option-group",
        "$members$": {
            "disabled": [516],
            "label": [1]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"]]
    }; }
}

const CSS$D = {
    page: "page",
    selected: "selected",
    chevron: "chevron",
    disabled: "disabled",
    ellipsis: "ellipsis",
};
const ICONS$6 = {
    next: "chevron-right",
    previous: "chevron-left",
    first: "chevron-start",
    last: "chevron-end",
};

/**
 * Do not edit directly
 * Generated on Tue, 27 Feb 2024 18:51:12 GMT
 */
const calciteContainerSizeWidthXxs = {"min":"0","max":"320px"}; // Small handheld devices and mini-windows
const calciteContainerSizeWidthXs = {"min":"321px","max":"476px"}; // Handheld devices
const calciteContainerSizeWidthSm = {"min":"477px","max":"768px"}; // Small tablets
const calciteContainerSizeWidthMd = {"min":"769px","max":"1152px"}; // Small laptops
const calciteContainerSizeWidthLg = {"min":"1153px","max":"1440px"}; // Large laptops and desktop computers

/**
 * A breakpoints lookup object.
 */
const breakpoints = {
    width: {
        large: cssLengthToNumber(calciteContainerSizeWidthLg.max),
        medium: cssLengthToNumber(calciteContainerSizeWidthMd.max),
        small: cssLengthToNumber(calciteContainerSizeWidthSm.max),
        xsmall: cssLengthToNumber(calciteContainerSizeWidthXs.max),
        xxsmall: cssLengthToNumber(calciteContainerSizeWidthXxs.max),
    },
};
function cssLengthToNumber(length) {
    return parseInt(length);
}

const paginationCss = "/*!@:host*/.sc-calcite-pagination-h{display:flex;writing-mode:horizontal-tb}/*!@:host([scale=s]) .chevron, :host([scale=s]) .page, :host([scale=s]) .ellipsis*/[scale=s].sc-calcite-pagination-h .chevron.sc-calcite-pagination,[scale=s].sc-calcite-pagination-h .page.sc-calcite-pagination,[scale=s].sc-calcite-pagination-h .ellipsis.sc-calcite-pagination{block-size:1.5rem;padding-inline:0.25rem;font-size:var(--calcite-font-size--2);line-height:1rem;min-inline-size:1.5rem}/*!@:host([scale=m]) .chevron, :host([scale=m]) .page, :host([scale=m]) .ellipsis*/[scale=m].sc-calcite-pagination-h .chevron.sc-calcite-pagination,[scale=m].sc-calcite-pagination-h .page.sc-calcite-pagination,[scale=m].sc-calcite-pagination-h .ellipsis.sc-calcite-pagination{block-size:2rem;padding-inline:0.5rem;font-size:var(--calcite-font-size--1);line-height:1rem;min-inline-size:2rem}/*!@:host([scale=l]) .chevron, :host([scale=l]) .page, :host([scale=l]) .ellipsis*/[scale=l].sc-calcite-pagination-h .chevron.sc-calcite-pagination,[scale=l].sc-calcite-pagination-h .page.sc-calcite-pagination,[scale=l].sc-calcite-pagination-h .ellipsis.sc-calcite-pagination{block-size:2.75rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;min-inline-size:2.75rem}/*!@:host([scale=l]) .chevron*/[scale=l].sc-calcite-pagination-h .chevron.sc-calcite-pagination{padding-inline:0.625rem}/*!@:host([scale=l]) .page, :host([scale=l]) .ellipsis*/[scale=l].sc-calcite-pagination-h .page.sc-calcite-pagination,[scale=l].sc-calcite-pagination-h .ellipsis.sc-calcite-pagination{padding-inline:0.75rem}/*!@:host button*/.sc-calcite-pagination-h button.sc-calcite-pagination{outline-color:transparent}/*!@:host button:focus*/.sc-calcite-pagination-h button.sc-calcite-pagination:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.chevron,\n.page,\n.ellipsis*/.chevron.sc-calcite-pagination,.page.sc-calcite-pagination,.ellipsis.sc-calcite-pagination{margin:0px;box-sizing:border-box;display:flex;align-items:center;justify-content:center;border-style:none;--tw-border-opacity:0;background-color:transparent;padding:0px;vertical-align:baseline;font-family:inherit;font-size:var(--calcite-font-size-0);line-height:1.25rem;color:var(--calcite-color-text-3)}/*!@.chevron,\n.page*/.chevron.sc-calcite-pagination,.page.sc-calcite-pagination{cursor:pointer;border-block:2px solid transparent}/*!@.chevron:hover,\n.page:hover*/.chevron.sc-calcite-pagination:hover,.page.sc-calcite-pagination:hover{color:var(--calcite-color-text-1);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.page:hover*/.page.sc-calcite-pagination:hover{border-block-end-color:var(--calcite-color-border-2)}/*!@.page.selected*/.page.selected.sc-calcite-pagination{font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1);border-block-end-color:var(--calcite-color-brand)}/*!@.chevron:hover*/.chevron.sc-calcite-pagination:hover{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-brand)}/*!@.chevron:active*/.chevron.sc-calcite-pagination:active{background-color:var(--calcite-color-foreground-3)}/*!@.chevron.disabled*/.chevron.disabled.sc-calcite-pagination{pointer-events:none;background-color:transparent}/*!@.chevron.disabled > calcite-icon*/.chevron.disabled.sc-calcite-pagination>calcite-icon.sc-calcite-pagination{opacity:var(--calcite-opacity-disabled)}/*!@:host([hidden])*/[hidden].sc-calcite-pagination-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-pagination{display:none}";

const firstAndLastPageCount = 2;
const ellipsisCount = 2;
const maxItemBreakpoints = {
    large: 11,
    medium: 9,
    small: 7,
    xsmall: 5,
    xxsmall: 1,
};
class Pagination {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calcitePaginationChange = createEvent(this, "calcitePaginationChange", 6);
        this.resizeObserver = createObserver();
        this.resizeHandler = ({ contentRect: { width } }) => this.setMaxItemsToBreakpoint(width);
        this.firstClicked = () => {
            this.startItem = 1;
            this.emitUpdate();
        };
        this.lastClicked = () => {
            this.startItem = this.lastStartItem;
            this.emitUpdate();
        };
        this.previousClicked = async () => {
            await this.previousPage();
            this.emitUpdate();
        };
        this.nextClicked = async () => {
            await this.nextPage();
            this.emitUpdate();
        };
        this.handlePageClick = (event) => {
            const target = event.target;
            this.startItem = parseInt(target.value, 10);
            this.emitUpdate();
        };
        this.groupSeparator = false;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.numberingSystem = undefined;
        this.pageSize = 20;
        this.scale = "m";
        this.startItem = 1;
        this.totalItems = 0;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
        this.maxItems = maxItemBreakpoints.xxsmall;
        this.totalPages = undefined;
        this.lastStartItem = undefined;
        this.isXXSmall = undefined;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    handleTotalPages() {
        if (this.pageSize < 1) {
            this.pageSize = 1;
        }
        this.totalPages = this.totalItems / this.pageSize;
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    effectiveLocaleWatcher() {
        numberStringFormatter.numberFormatOptions = {
            locale: this.effectiveLocale,
            numberingSystem: this.numberingSystem,
            useGrouping: this.groupSeparator,
        };
    }
    handleLastStartItemChange() {
        const { totalItems, pageSize, totalPages } = this;
        this.lastStartItem =
            (totalItems % pageSize === 0 ? totalItems - pageSize : Math.floor(totalPages) * pageSize) + 1;
    }
    handleIsXXSmall() {
        this.isXXSmall = this.maxItems === maxItemBreakpoints.xxsmall;
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectLocalized(this);
        connectMessages(this);
        this.resizeObserver?.observe(this.el);
    }
    async componentWillLoad() {
        await setUpMessages(this);
        setUpLoadableComponent(this);
        this.handleTotalPages();
        this.handleLastStartItemChange();
        this.handleIsXXSmall();
    }
    componentDidLoad() {
        setComponentLoaded(this);
        this.setMaxItemsToBreakpoint(this.el.clientWidth);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectMessages(this);
        this.resizeObserver?.disconnect();
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /** Sets focus on the component's first focusable element. */
    async setFocus() {
        await componentFocusable(this);
        this.el.focus();
    }
    /** Go to the next page of results. */
    async nextPage() {
        this.startItem = Math.min(this.lastStartItem, this.startItem + this.pageSize);
    }
    /** Go to the previous page of results. */
    async previousPage() {
        this.startItem = Math.max(1, this.startItem - this.pageSize);
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    setMaxItemsToBreakpoint(width) {
        if (!breakpoints || !width) {
            return;
        }
        if (width >= breakpoints.width.medium) {
            this.maxItems = maxItemBreakpoints.large;
            return;
        }
        if (width >= breakpoints.width.small) {
            this.maxItems = maxItemBreakpoints.medium;
            return;
        }
        if (width >= breakpoints.width.xsmall) {
            this.maxItems = maxItemBreakpoints.small;
            return;
        }
        if (width >= breakpoints.width.xxsmall) {
            this.maxItems = maxItemBreakpoints.xsmall;
            return;
        }
        this.maxItems = maxItemBreakpoints.xxsmall;
    }
    showStartEllipsis() {
        return (this.totalPages > this.maxItems &&
            Math.floor(this.startItem / this.pageSize) >
                this.maxItems - firstAndLastPageCount - ellipsisCount);
    }
    showEndEllipsis() {
        return (this.totalPages > this.maxItems &&
            (this.totalItems - this.startItem) / this.pageSize >
                this.maxItems - firstAndLastPageCount - (ellipsisCount - 1));
    }
    emitUpdate() {
        this.calcitePaginationChange.emit();
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    renderEllipsis(type) {
        return (hAsync("span", { class: CSS$D.ellipsis, "data-test-ellipsis": type, key: type }, "\u2026"));
    }
    renderItems() {
        const { totalItems, pageSize, startItem, maxItems, totalPages, lastStartItem, isXXSmall } = this;
        const items = [];
        if (isXXSmall) {
            items.push(this.renderPage(startItem));
            return items;
        }
        const renderFirstPage = totalItems > pageSize;
        const renderStartEllipsis = this.showStartEllipsis();
        const renderEndEllipsis = this.showEndEllipsis();
        if (renderFirstPage) {
            items.push(this.renderPage(1));
        }
        if (renderStartEllipsis) {
            items.push(this.renderEllipsis("start"));
        }
        const remainingItems = maxItems -
            firstAndLastPageCount -
            (renderEndEllipsis ? 1 : 0) -
            (renderStartEllipsis ? 1 : 0);
        let end;
        let nextStart;
        // if we don't need ellipses render the whole set
        if (totalPages - 1 <= remainingItems) {
            nextStart = 1 + pageSize;
            end = lastStartItem - pageSize;
        }
        else {
            // if we're within max pages of page 1
            if (startItem / pageSize < remainingItems) {
                nextStart = 1 + pageSize;
                end = 1 + remainingItems * pageSize;
            }
            else {
                // if we're within max pages of last page
                if (startItem + remainingItems * pageSize >= totalItems) {
                    nextStart = lastStartItem - remainingItems * pageSize;
                    end = lastStartItem - pageSize;
                }
                else {
                    // if we're within the center pages
                    nextStart = startItem - pageSize * ((remainingItems - 1) / 2);
                    end = startItem + pageSize * ((remainingItems - 1) / 2);
                }
            }
        }
        for (let i = 0; i < remainingItems && nextStart <= end; i++) {
            items.push(this.renderPage(nextStart));
            nextStart = nextStart + pageSize;
        }
        if (renderEndEllipsis) {
            items.push(this.renderEllipsis("end"));
        }
        items.push(this.renderPage(lastStartItem));
        return items;
    }
    renderPage(start) {
        const { pageSize } = this;
        const page = Math.floor(start / pageSize) + (pageSize === 1 ? 0 : 1);
        numberStringFormatter.numberFormatOptions = {
            locale: this.effectiveLocale,
            numberingSystem: this.numberingSystem,
            useGrouping: this.groupSeparator,
        };
        const displayedPage = numberStringFormatter.localize(page.toString());
        const selected = start === this.startItem;
        return (hAsync("button", { "aria-current": selected ? "page" : "false", class: {
                [CSS$D.page]: true,
                [CSS$D.selected]: selected,
            }, onClick: this.handlePageClick, value: start }, displayedPage));
    }
    renderPreviousChevron() {
        const { pageSize, startItem, messages } = this;
        const disabled = pageSize === 1 ? startItem <= pageSize : startItem < pageSize;
        return (hAsync("button", { "aria-label": messages.previous, class: {
                [CSS$D.chevron]: true,
                [CSS$D.disabled]: disabled,
            }, "data-test-chevron": "previous", disabled: disabled, key: "previous", onClick: this.previousClicked }, hAsync("calcite-icon", { flipRtl: true, icon: ICONS$6.previous, scale: getIconScale(this.scale) })));
    }
    renderNextChevron() {
        const { totalItems, pageSize, startItem, messages } = this;
        const disabled = pageSize === 1 ? startItem + pageSize > totalItems : startItem + pageSize > totalItems;
        return (hAsync("button", { "aria-label": messages.next, class: {
                [CSS$D.chevron]: true,
                [CSS$D.disabled]: disabled,
            }, "data-test-chevron": "next", disabled: disabled, key: "next-button", onClick: this.nextClicked }, hAsync("calcite-icon", { flipRtl: true, icon: ICONS$6.next, scale: getIconScale(this.scale) })));
    }
    renderFirstChevron() {
        const { messages, startItem, isXXSmall } = this;
        const disabled = startItem === 1;
        return isXXSmall ? (hAsync("button", { "aria-label": messages.first, class: {
                [CSS$D.chevron]: true,
                [CSS$D.disabled]: disabled,
            }, disabled: disabled, key: "first-button", onClick: this.firstClicked }, hAsync("calcite-icon", { flipRtl: true, icon: ICONS$6.first, scale: getIconScale(this.scale) }))) : null;
    }
    renderLastChevron() {
        const { messages, startItem, isXXSmall, lastStartItem } = this;
        const disabled = startItem === lastStartItem;
        return isXXSmall ? (hAsync("button", { "aria-label": messages.last, class: {
                [CSS$D.chevron]: true,
                [CSS$D.disabled]: disabled,
            }, disabled: disabled, key: "last-button", onClick: this.lastClicked }, hAsync("calcite-icon", { flipRtl: true, icon: ICONS$6.last, scale: getIconScale(this.scale) }))) : null;
    }
    render() {
        return (hAsync(Fragment, null, this.renderFirstChevron(), this.renderPreviousChevron(), this.renderItems(), this.renderNextChevron(), this.renderLastChevron()));
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "totalItems": ["handleTotalPages", "handleLastStartItemChange"],
        "pageSize": ["handleTotalPages", "handleLastStartItemChange"],
        "effectiveLocale": ["effectiveLocaleChange", "effectiveLocaleWatcher"],
        "totalPages": ["handleLastStartItemChange"],
        "maxItems": ["handleIsXXSmall"]
    }; }
    static get style() { return paginationCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-pagination",
        "$members$": {
            "groupSeparator": [516, "group-separator"],
            "messages": [1040],
            "messageOverrides": [1040],
            "numberingSystem": [1, "numbering-system"],
            "pageSize": [1538, "page-size"],
            "scale": [513],
            "startItem": [1538, "start-item"],
            "totalItems": [514, "total-items"],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "maxItems": [32],
            "totalPages": [32],
            "lastStartItem": [32],
            "isXXSmall": [32],
            "setFocus": [64],
            "nextPage": [64],
            "previousPage": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["groupSeparator", "group-separator"], ["pageSize", "page-size"], ["scale", "scale"], ["startItem", "start-item"], ["totalItems", "total-items"]]
    }; }
}

const panelCss = "/*!@:host*/.sc-calcite-panel-h{box-sizing:border-box;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host **/.sc-calcite-panel-h *.sc-calcite-panel{box-sizing:border-box}/*!@:host([disabled])*/[disabled].sc-calcite-panel-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-panel-h *.sc-calcite-panel,.sc-calcite-panel-h[disabled].sc-calcite-panel-s>*,.sc-calcite-panel-h[disabled] .sc-calcite-panel-s>*{pointer-events:none}/*!@:host*/.sc-calcite-panel-h{position:relative;display:flex;block-size:100%;inline-size:100%;flex:1 1 auto;overflow:hidden;--calcite-min-header-height:calc(var(--calcite-icon-size) * 3)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-panel-h[disabled] .sc-calcite-panel-s>[calcite-hydrated][disabled],[disabled].sc-calcite-panel-h [calcite-hydrated][disabled].sc-calcite-panel{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-panel{display:contents}/*!@.header*/.header.sc-calcite-panel{margin:0px;display:flex;align-content:space-between;align-items:center;fill:var(--calcite-color-text-2);color:var(--calcite-color-text-2)}/*!@.heading*/.heading.sc-calcite-panel{margin:0px;padding:0px;font-weight:var(--calcite-font-weight-medium)}/*!@.header .heading*/.header.sc-calcite-panel .heading.sc-calcite-panel{flex:1 1 auto;padding:0.5rem}/*!@.container*/.container.sc-calcite-panel{margin:0px;display:flex;inline-size:100%;flex:1 1 auto;flex-direction:column;align-items:stretch;background-color:var(--calcite-color-background);padding:0px;transition:max-block-size var(--calcite-animation-timing), inline-size var(--calcite-animation-timing)}/*!@.container[hidden]*/.container[hidden].sc-calcite-panel{display:none}/*!@.header*/.header.sc-calcite-panel{z-index:var(--calcite-z-index-header);display:flex;flex-direction:column;background-color:var(--calcite-color-foreground-1);border-block-end:var(--calcite-panel-header-border-block-end, 1px solid var(--calcite-color-border-3))}/*!@.header-container*/.header-container.sc-calcite-panel{display:flex;inline-size:100%;flex-direction:row;align-items:stretch;justify-content:flex-start;flex:0 0 auto}/*!@.header-container--border-end*/.header-container--border-end.sc-calcite-panel{border-block-end:1px solid var(--calcite-color-border-3)}/*!@.action-bar-container*/.action-bar-container.sc-calcite-panel{inline-size:100%}/*!@.action-bar-container ::slotted(calcite-action-bar)*/.action-bar-container .sc-calcite-panel-s>calcite-action-bar{inline-size:100%}/*!@.header-content*/.header-content.sc-calcite-panel{display:flex;flex-direction:column;overflow:hidden;padding-inline:0.75rem;padding-block:0.875rem;margin-inline-end:auto}/*!@.header-content .heading,\n.header-content .description*/.header-content.sc-calcite-panel .heading.sc-calcite-panel,.header-content.sc-calcite-panel .description.sc-calcite-panel{display:block;overflow-wrap:break-word;padding:0px}/*!@.header-content .heading*/.header-content.sc-calcite-panel .heading.sc-calcite-panel{margin-inline:0px;margin-block:0px 0.25rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;font-weight:var(--calcite-font-weight-medium)}/*!@.header-content .heading:only-child*/.header-content.sc-calcite-panel .heading.sc-calcite-panel:only-child{margin-block-end:0px}/*!@.header-content .description*/.header-content.sc-calcite-panel .description.sc-calcite-panel{font-size:var(--calcite-font-size--1);line-height:1rem;color:var(--calcite-color-text-2)}/*!@.back-button*/.back-button.sc-calcite-panel{border-width:0px;border-style:solid;border-color:var(--calcite-color-border-3);border-inline-end-width:1px}/*!@.header-actions*/.header-actions.sc-calcite-panel{display:flex;flex-direction:row;flex-wrap:nowrap;align-items:stretch}/*!@.header-actions--end*/.header-actions--end.sc-calcite-panel{margin-inline-start:auto}/*!@.content-wrapper*/.content-wrapper.sc-calcite-panel{display:flex;block-size:100%;flex:1 1 auto;flex-direction:column;flex-wrap:nowrap;align-items:stretch;overflow:auto;background-color:var(--calcite-color-background)}/*!@.footer*/.footer.sc-calcite-panel{display:flex;inline-size:100%;justify-content:space-evenly;background-color:var(--calcite-color-foreground-1);flex:0 0 auto;padding:var(--calcite-panel-footer-padding, 0.5rem);border-block-start:1px solid var(--calcite-color-border-3)}/*!@.fab-container*/.fab-container.sc-calcite-panel{position:sticky;inset-block-end:0px;z-index:var(--calcite-z-index-sticky);margin-block:0px;margin-inline:auto;display:block;padding:0.5rem;inset-inline:0;inline-size:-moz-fit-content;inline-size:fit-content}/*!@:host([hidden])*/[hidden].sc-calcite-panel-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-panel{display:none}";

/**
 * @slot - A slot for adding custom content.
 * @slot action-bar - A slot for adding a `calcite-action-bar` to the component.
 * @slot header-actions-start - A slot for adding actions or content to the start side of the header.
 * @slot header-actions-end - A slot for adding actions or content to the end side of the header.
 * @slot header-content - A slot for adding custom content to the header.
 * @slot header-menu-actions - A slot for adding an overflow menu with actions inside a `calcite-dropdown`.
 * @slot fab - A slot for adding a `calcite-fab` (floating action button) to perform an action.
 * @slot footer-actions - [Deprecated] Use the `"footer"` slot instead. A slot for adding `calcite-button`s to the component's footer.
 * @slot footer - A slot for adding custom content to the footer.
 */
class Panel {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calcitePanelClose = createEvent(this, "calcitePanelClose", 6);
        this.calcitePanelToggle = createEvent(this, "calcitePanelToggle", 6);
        this.calcitePanelScroll = createEvent(this, "calcitePanelScroll", 6);
        this.resizeObserver = createObserver();
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.resizeHandler = () => {
            const { panelScrollEl } = this;
            if (!panelScrollEl ||
                typeof panelScrollEl.scrollHeight !== "number" ||
                typeof panelScrollEl.offsetHeight !== "number") {
                return;
            }
            panelScrollEl.tabIndex = panelScrollEl.scrollHeight > panelScrollEl.offsetHeight ? 0 : -1;
        };
        this.setContainerRef = (node) => {
            this.containerEl = node;
        };
        this.panelKeyDownHandler = (event) => {
            if (this.closable && event.key === "Escape" && !event.defaultPrevented) {
                this.close();
                event.preventDefault();
            }
        };
        this.close = () => {
            this.closed = true;
            this.calcitePanelClose.emit();
        };
        this.collapse = () => {
            this.collapsed = !this.collapsed;
            this.calcitePanelToggle.emit();
        };
        this.panelScrollHandler = () => {
            this.calcitePanelScroll.emit();
        };
        this.handleHeaderActionsStartSlotChange = (event) => {
            this.hasStartActions = slotChangeHasAssignedElement(event);
        };
        this.handleHeaderActionsEndSlotChange = (event) => {
            this.hasEndActions = slotChangeHasAssignedElement(event);
        };
        this.handleHeaderMenuActionsSlotChange = (event) => {
            this.hasMenuItems = slotChangeHasAssignedElement(event);
        };
        this.handleActionBarSlotChange = (event) => {
            const actionBars = slotChangeGetAssignedElements(event).filter((el) => el?.matches("calcite-action-bar"));
            actionBars.forEach((actionBar) => (actionBar.layout = "horizontal"));
            this.hasActionBar = !!actionBars.length;
        };
        this.handleHeaderContentSlotChange = (event) => {
            this.hasHeaderContent = slotChangeHasAssignedElement(event);
        };
        this.handleFooterSlotChange = (event) => {
            this.hasFooterContent = slotChangeHasAssignedElement(event);
        };
        this.handleFooterActionsSlotChange = (event) => {
            this.hasFooterActions = slotChangeHasAssignedElement(event);
        };
        this.handleFabSlotChange = (event) => {
            this.hasFab = slotChangeHasAssignedElement(event);
        };
        this.setPanelScrollEl = (el) => {
            this.panelScrollEl = el;
            this.resizeObserver?.disconnect();
            if (el) {
                this.resizeObserver?.observe(el);
                this.resizeHandler();
            }
        };
        this.closed = false;
        this.disabled = false;
        this.closable = false;
        this.collapsed = false;
        this.collapseDirection = "down";
        this.collapsible = false;
        this.headingLevel = undefined;
        this.loading = false;
        this.heading = undefined;
        this.description = undefined;
        this.menuOpen = false;
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.overlayPositioning = "absolute";
        this.hasStartActions = false;
        this.hasEndActions = false;
        this.hasMenuItems = false;
        this.hasHeaderContent = false;
        this.hasActionBar = false;
        this.hasFooterContent = false;
        this.hasFooterActions = false;
        this.hasFab = false;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
        this.showHeaderContent = false;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        this.resizeObserver?.disconnect();
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Sets focus on the component's first focusable element.
     */
    async setFocus() {
        await componentFocusable(this);
        focusFirstTabbable(this.containerEl);
    }
    /**
     * Scrolls the component's content to a specified set of coordinates.
     *
     * @example
     * myCalciteFlowItem.scrollContentTo({
     *   left: 0, // Specifies the number of pixels along the X axis to scroll the window or element.
     *   top: 0, // Specifies the number of pixels along the Y axis to scroll the window or element
     *   behavior: "auto" // Specifies whether the scrolling should animate smoothly (smooth), or happen instantly in a single jump (auto, the default value).
     * });
     * @param options - allows specific coordinates to be defined.
     * @returns - promise that resolves once the content is scrolled to.
     */
    async scrollContentTo(options) {
        this.panelScrollEl?.scrollTo(options);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderHeaderContent() {
        const { heading, headingLevel, description, hasHeaderContent } = this;
        const headingNode = heading ? (hAsync(Heading, { class: CSS$W.heading, level: headingLevel }, heading)) : null;
        const descriptionNode = description ? hAsync("span", { class: CSS$W.description }, description) : null;
        return !hasHeaderContent && (headingNode || descriptionNode) ? (hAsync("div", { class: CSS$W.headerContent, key: "header-content" }, headingNode, descriptionNode)) : null;
    }
    renderActionBar() {
        return (hAsync("div", { class: CSS$W.actionBarContainer, hidden: !this.hasActionBar }, hAsync("slot", { name: SLOTS$n.actionBar, onSlotchange: this.handleActionBarSlotChange })));
    }
    renderHeaderSlottedContent() {
        return (hAsync("div", { class: CSS$W.headerContent, hidden: !this.hasHeaderContent, key: "slotted-header-content" }, hAsync("slot", { name: SLOTS$n.headerContent, onSlotchange: this.handleHeaderContentSlotChange })));
    }
    renderHeaderStartActions() {
        const { hasStartActions } = this;
        return (hAsync("div", { class: { [CSS$W.headerActionsStart]: true, [CSS$W.headerActions]: true }, hidden: !hasStartActions, key: "header-actions-start" }, hAsync("slot", { name: SLOTS$n.headerActionsStart, onSlotchange: this.handleHeaderActionsStartSlotChange })));
    }
    renderHeaderActionsEnd() {
        const { hasEndActions, messages, closable, collapsed, collapseDirection, collapsible, hasMenuItems, } = this;
        const { collapse, expand, close } = messages;
        const icons = [ICONS$b.expand, ICONS$b.collapse];
        if (collapseDirection === "up") {
            icons.reverse();
        }
        const collapseNode = collapsible ? (hAsync("calcite-action", { "aria-expanded": toAriaBoolean(!collapsed), "aria-label": collapse, "data-test": "collapse", icon: collapsed ? icons[0] : icons[1], onClick: this.collapse, text: collapse, title: collapsed ? expand : collapse })) : null;
        const closeNode = closable ? (hAsync("calcite-action", { "aria-label": close, "data-test": "close", icon: ICONS$b.close, onClick: this.close, text: close, title: close })) : null;
        const slotNode = (hAsync("slot", { name: SLOTS$n.headerActionsEnd, onSlotchange: this.handleHeaderActionsEndSlotChange }));
        const showContainer = hasEndActions || collapseNode || closeNode || hasMenuItems;
        return (hAsync("div", { class: { [CSS$W.headerActionsEnd]: true, [CSS$W.headerActions]: true }, hidden: !showContainer, key: "header-actions-end" }, slotNode, this.renderMenu(), collapseNode, closeNode));
    }
    renderMenu() {
        const { hasMenuItems, messages, menuOpen } = this;
        return (hAsync("calcite-action-menu", { flipPlacements: ["top", "bottom"], hidden: !hasMenuItems, key: "menu", label: messages.options, open: menuOpen, overlayPositioning: this.overlayPositioning, placement: "bottom-end" }, hAsync("calcite-action", { icon: ICONS$b.menu, slot: SLOTS$w.trigger, text: messages.options }), hAsync("slot", { name: SLOTS$n.headerMenuActions, onSlotchange: this.handleHeaderMenuActionsSlotChange })));
    }
    renderHeaderNode() {
        const { hasHeaderContent, hasStartActions, hasEndActions, closable, collapsible, hasMenuItems, hasActionBar, } = this;
        const headerContentNode = this.renderHeaderContent();
        const showHeaderContent = hasHeaderContent ||
            !!headerContentNode ||
            hasStartActions ||
            hasEndActions ||
            collapsible ||
            closable ||
            hasMenuItems;
        this.showHeaderContent = showHeaderContent;
        return (hAsync("header", { class: CSS$W.header, hidden: !(showHeaderContent || hasActionBar) }, hAsync("div", { class: { [CSS$W.headerContainer]: true, [CSS$W.headerContainerBorderEnd]: hasActionBar }, hidden: !showHeaderContent }, this.renderHeaderStartActions(), this.renderHeaderSlottedContent(), headerContentNode, this.renderHeaderActionsEnd()), this.renderActionBar()));
    }
    renderFooterNode() {
        const { hasFooterContent, hasFooterActions } = this;
        const showFooter = hasFooterContent || hasFooterActions;
        return (hAsync("footer", { class: CSS$W.footer, hidden: !showFooter }, hAsync("slot", { key: "footer-slot", name: SLOTS$n.footer, onSlotchange: this.handleFooterSlotChange }), hAsync("slot", { key: "footer-actions-slot", name: SLOTS$n.footerActions, onSlotchange: this.handleFooterActionsSlotChange })));
    }
    renderContent() {
        return (hAsync("div", { class: CSS$W.contentWrapper, hidden: this.collapsible && this.collapsed, onScroll: this.panelScrollHandler,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setPanelScrollEl }, hAsync("slot", null), this.renderFab()));
    }
    renderFab() {
        return (hAsync("div", { class: CSS$W.fabContainer, hidden: !this.hasFab }, hAsync("slot", { name: SLOTS$n.fab, onSlotchange: this.handleFabSlotChange })));
    }
    render() {
        const { disabled, loading, panelKeyDownHandler, closed, closable } = this;
        const panelNode = (hAsync("article", { "aria-busy": toAriaBoolean(loading), class: CSS$W.container, hidden: closed, onKeyDown: panelKeyDownHandler, tabIndex: closable ? 0 : -1,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setContainerRef }, this.renderHeaderNode(), this.renderContent(), this.renderFooterNode()));
        return (hAsync(InteractiveContainer, { disabled: disabled }, loading ? hAsync("calcite-scrim", { loading: loading }) : null, panelNode));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return panelCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-panel",
        "$members$": {
            "closed": [1540],
            "disabled": [516],
            "closable": [516],
            "collapsed": [516],
            "collapseDirection": [1, "collapse-direction"],
            "collapsible": [516],
            "headingLevel": [514, "heading-level"],
            "loading": [516],
            "heading": [1],
            "description": [1],
            "menuOpen": [516, "menu-open"],
            "messageOverrides": [1040],
            "messages": [1040],
            "overlayPositioning": [513, "overlay-positioning"],
            "hasStartActions": [32],
            "hasEndActions": [32],
            "hasMenuItems": [32],
            "hasHeaderContent": [32],
            "hasActionBar": [32],
            "hasFooterContent": [32],
            "hasFooterActions": [32],
            "hasFab": [32],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "showHeaderContent": [32],
            "setFocus": [64],
            "scrollContentTo": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["closed", "closed"], ["disabled", "disabled"], ["closable", "closable"], ["collapsed", "collapsed"], ["collapsible", "collapsible"], ["headingLevel", "heading-level"], ["loading", "loading"], ["menuOpen", "menu-open"], ["overlayPositioning", "overlay-positioning"]]
    }; }
}

const CSS$C = {
    sticky: "sticky-pos",
};
var ICON_TYPES$1;
(function (ICON_TYPES) {
    ICON_TYPES["circle"] = "circle";
    ICON_TYPES["square"] = "square";
    ICON_TYPES["grip"] = "grip";
})(ICON_TYPES$1 || (ICON_TYPES$1 = {}));
const SLOTS$d = {
    menuActions: "menu-actions",
};

const CSS$B = {
    heading: "heading",
    container: "container",
    indented: "container--indented",
};
const SLOTS$c = {
    parentItem: "parent-item",
};

function mutationObserverCallback() {
    this.setUpItems();
    this.setUpFilter();
    this.deselectRemovedItems();
}
const SUPPORTED_ARROW_KEYS = ["ArrowUp", "ArrowDown"];
// --------------------------------------------------------------------------
//
//  Lifecycle
//
// --------------------------------------------------------------------------
function initialize() {
    this.setUpItems();
    this.setUpFilter();
    this.emitCalciteListChange = debounce(internalCalciteListChangeEvent.bind(this), 0);
    this.emitCalciteListFilter = debounce(internalCalciteListFilterEvent.bind(this), 0);
}
function initializeObserver() {
    this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
}
function cleanUpObserver() {
    this.mutationObserver?.disconnect();
}
// --------------------------------------------------------------------------
//
//  Listeners
//
// --------------------------------------------------------------------------
function calciteListItemChangeHandler(event) {
    const { selectedValues } = this;
    const { item, value, selected, shiftPressed } = event.detail;
    if (selected) {
        if (this.multiple && shiftPressed) {
            this.selectSiblings(item);
        }
        if (!this.multiple) {
            this.deselectSiblingItems(item);
        }
        selectedValues.set(value, item);
    }
    else {
        selectedValues.delete(value);
        if (this.multiple && shiftPressed) {
            this.selectSiblings(item, true);
        }
    }
    if (!this.multiple) {
        toggleSingleSelectItemTabbing(item, selected);
        if (selected) {
            focusElement(item);
        }
    }
    this.lastSelectedItem = item;
    this.emitCalciteListChange();
}
function calciteInternalListItemValueChangeHandler(event) {
    const oldValue = event.detail.oldValue;
    const selectedValues = this.selectedValues;
    if (selectedValues.has(oldValue)) {
        const item = selectedValues.get(oldValue);
        selectedValues.delete(oldValue);
        selectedValues.set(event.detail.newValue, item);
    }
    event.stopPropagation();
}
// --------------------------------------------------------------------------
//
//  Private Methods
//
// --------------------------------------------------------------------------
function isValidNavigationKey(key) {
    return !!SUPPORTED_ARROW_KEYS.find((k) => k === key);
}
function calciteListFocusOutHandler(event) {
    const { el, items, multiple, selectedValues } = this;
    if (multiple) {
        return;
    }
    const focusedInside = el.contains(event.relatedTarget);
    if (focusedInside) {
        return;
    }
    filterOutDisabled(items).forEach((item) => {
        toggleSingleSelectItemTabbing(item, selectedValues.size === 0 ? item.contains(event.target) || event.target === item : item.selected);
    });
}
function keyDownHandler(event) {
    const { key, target } = event;
    if (!isValidNavigationKey(key)) {
        return;
    }
    const { items, multiple, selectionFollowsFocus } = this;
    const { length: totalItems } = items;
    const currentIndex = items.indexOf(target);
    if (!totalItems || currentIndex === -1) {
        return;
    }
    event.preventDefault();
    const index = moveItemIndex(this, target, key === "ArrowUp" ? "up" : "down");
    const item = items[index];
    items.forEach((i) => toggleSingleSelectItemTabbing(i, i === item));
    if (!multiple && selectionFollowsFocus) {
        item.selected = true;
    }
    focusElement(item);
}
function moveItemIndex(list, item, direction) {
    const { items } = list;
    const { length: totalItems } = items;
    const currentIndex = items.indexOf(item);
    const directionFactor = direction === "up" ? -1 : 1;
    let moveOffset = 1;
    let index = getRoundRobinIndex(currentIndex + directionFactor * moveOffset++, totalItems);
    const firstMovedIndex = index;
    while (items[index].disabled) {
        index = getRoundRobinIndex(currentIndex + directionFactor * moveOffset++, totalItems);
        if (index === firstMovedIndex) {
            break;
        }
    }
    return index;
}
function getItemIndex(list, item) {
    const { items } = list;
    return items.indexOf(item);
}
function filterOutDisabled(items) {
    return items.filter((item) => !item.disabled);
}
function internalCalciteListFilterEvent() {
    this.calciteListFilter.emit();
}
function internalCalciteListChangeEvent() {
    this.calciteListChange.emit(this.selectedValues);
}
function removeItem(event) {
    if (event.defaultPrevented) {
        return;
    }
    const item = event.target;
    const selectedValues = this.selectedValues;
    if (item.parentElement.tagName === "CALCITE-PICK-LIST-GROUP" && item.slot === SLOTS$c.parentItem) {
        item.parentElement.remove();
        Array.from(item.parentElement.children).forEach((item) => selectedValues.delete(item.value));
    }
    else {
        item.remove();
        selectedValues.delete(item.value);
    }
    this.emitCalciteListChange();
}
function toggleSingleSelectItemTabbing(item, selectable) {
    if (item.disabled) {
        return;
    }
    // using attribute intentionally
    if (selectable) {
        item.removeAttribute("tabindex");
    }
    else {
        item.setAttribute("tabindex", "-1");
    }
}
async function setFocus(focusId) {
    if (this.filterEnabled && focusId === "filter") {
        await focusElement(this.filterEl);
        return;
    }
    const { items, multiple, selectionFollowsFocus } = this;
    if (items.length === 0) {
        return;
    }
    if (multiple) {
        return filterOutDisabled(items)[0]?.setFocus();
    }
    const filtered = filterOutDisabled(items);
    const focusTarget = filtered.find((item) => item.selected) || filtered[0];
    if (selectionFollowsFocus && focusTarget) {
        focusTarget.selected = true;
    }
    return focusTarget.setFocus();
}
function setUpItems(tagName) {
    this.items = Array.from(this.el.querySelectorAll(tagName));
    let hasSelected = false;
    const { items } = this;
    items.forEach((item) => {
        item.icon = this.getIconType();
        if (!this.multiple) {
            item.deselectDisabled = true;
            toggleSingleSelectItemTabbing(item, false);
        }
        if (item.selected) {
            hasSelected = true;
            toggleSingleSelectItemTabbing(item, true);
            this.selectedValues.set(item.value, item);
        }
    });
    const [first] = items;
    if (!hasSelected && first && !first.disabled) {
        toggleSingleSelectItemTabbing(first, true);
    }
}
function deselectRemovedItems() {
    const selectedValues = this.selectedValues;
    const itemValues = this.items.map(({ value }) => value);
    selectedValues.forEach((selectedItem) => {
        if (!itemValues.includes(selectedItem.value)) {
            this.selectedValues.delete(selectedItem.value);
        }
    });
}
function deselectSiblingItems(item) {
    this.items.forEach((currentItem) => {
        if (currentItem.value !== item.value) {
            currentItem.toggleSelected(false);
            if (this.selectedValues.has(currentItem.value)) {
                this.selectedValues.delete(currentItem.value);
            }
        }
    });
}
function selectSiblings(item, deselect = false) {
    if (!this.lastSelectedItem) {
        return;
    }
    const { items } = this;
    const start = items.findIndex((currentItem) => {
        return currentItem.value === this.lastSelectedItem.value;
    });
    const end = items.findIndex((currentItem) => {
        return currentItem.value === item.value;
    });
    items.slice(Math.min(start, end), Math.max(start, end)).forEach((currentItem) => {
        currentItem.toggleSelected(!deselect);
        if (!deselect) {
            this.selectedValues.set(currentItem.value, currentItem);
        }
        else {
            this.selectedValues.delete(currentItem.value);
        }
    });
}
let groups;
function handleFilter(emit = false) {
    const { filteredData, filterText } = this;
    const values = filteredData.map((item) => item.value);
    let hasSelectedMatch = false;
    if (!groups) {
        groups = new Set();
    }
    const matchedItems = this.items?.filter((item) => {
        const parent = item.parentElement;
        const grouped = parent.matches("calcite-pick-list-group");
        if (grouped) {
            groups.add(parent);
        }
        const matches = filterText ? values.includes(item.value) : true;
        item.hidden = !matches;
        if (!hasSelectedMatch) {
            hasSelectedMatch = matches && item.selected;
        }
        return matches;
    }) || [];
    groups.forEach((group) => {
        const hasAtLeastOneMatch = matchedItems.some((item) => group.contains(item));
        group.hidden = !hasAtLeastOneMatch;
        if (!hasAtLeastOneMatch) {
            return;
        }
        const parentItem = getSlotted(group, "parent-item");
        if (parentItem) {
            parentItem.hidden = false;
            if (matchedItems.includes(parentItem)) {
                Array.from(group.children).forEach((child) => (child.hidden = false));
            }
        }
    });
    groups.clear();
    if (matchedItems.length > 0 && !hasSelectedMatch && !this.multiple) {
        toggleSingleSelectItemTabbing(matchedItems[0], true);
    }
    this.setFilteredItems(matchedItems);
    if (emit) {
        this.emitCalciteListFilter();
    }
}
function handleInitialFilter() {
    const filteredItems = this.filterEl?.filteredItems;
    if (filteredItems) {
        this.filteredData = filteredItems;
    }
    this.handleFilter();
}
function handleFilterEvent(event) {
    event.stopPropagation();
    const { filteredItems, value } = event.currentTarget;
    this.filterText = value;
    this.filteredData = filteredItems;
    this.handleFilter(true);
}
function getItemData() {
    return this.items.map((item) => ({
        label: item.label,
        description: item.description,
        metadata: item.metadata,
        value: item.value,
    }));
}

const List = ({ props: { disabled, loading, filterEnabled, dataForFilter, handleFilterEvent, filterPlaceholder, filterText, setFilterEl, dragEnabled, storeAssistiveEl, }, ...rest }) => {
    const defaultSlot = hAsync("slot", null);
    return (hAsync(Host, { "aria-busy": toAriaBoolean(loading), role: "menu", ...rest },
        hAsync(InteractiveContainer, { disabled: disabled },
            hAsync("section", null,
                dragEnabled ? (hAsync("span", { "aria-live": "assertive", class: "assistive-text", 
                    // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
                    ref: storeAssistiveEl })) : null,
                hAsync("header", { class: { [CSS$C.sticky]: true } },
                    filterEnabled ? (hAsync("calcite-filter", { "aria-label": filterPlaceholder, disabled: disabled, items: dataForFilter, onCalciteFilterChange: handleFilterEvent, placeholder: filterPlaceholder, value: filterText, 
                        // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
                        ref: setFilterEl })) : null,
                    hAsync("slot", { name: SLOTS$d.menuActions })),
                loading ? hAsync("calcite-scrim", { loading: loading }) : null,
                defaultSlot))));
};

const pickListCss = "/*!@:host([disabled])*/[disabled].sc-calcite-pick-list-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-pick-list-h *.sc-calcite-pick-list,.sc-calcite-pick-list-h[disabled].sc-calcite-pick-list-s>*,.sc-calcite-pick-list-h[disabled] .sc-calcite-pick-list-s>*{pointer-events:none}/*!@:host*/.sc-calcite-pick-list-h{position:relative;box-sizing:border-box;display:flex;flex-shrink:0;flex-grow:1;flex-direction:column;align-items:stretch;background-color:transparent;font-size:var(--calcite-font-size--1);line-height:1rem;color:var(--calcite-color-text-2)}/*!@:host **/.sc-calcite-pick-list-h *.sc-calcite-pick-list{box-sizing:border-box}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-pick-list-h[disabled] .sc-calcite-pick-list-s>[calcite-hydrated][disabled],[disabled].sc-calcite-pick-list-h [calcite-hydrated][disabled].sc-calcite-pick-list{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-pick-list{display:contents}/*!@:host([filter-enabled]) header*/[filter-enabled].sc-calcite-pick-list-h header.sc-calcite-pick-list{margin-block-end:0.25rem;display:flex;align-items:stretch;justify-content:flex-end;background-color:var(--calcite-color-foreground-1);--tw-shadow:0 1px 0 var(--calcite-color-border-3);--tw-shadow-colored:0 1px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@:host([filter-enabled]) header.sticky-pos*/[filter-enabled].sc-calcite-pick-list-h header.sticky-pos.sc-calcite-pick-list{position:sticky;inset-block-start:0px;z-index:var(--calcite-z-index)}/*!@calcite-filter*/calcite-filter.sc-calcite-pick-list{margin-block-end:0px}/*!@:host([loading][disabled])*/[loading][disabled].sc-calcite-pick-list-h{min-block-size:2rem}/*!@:host([hidden])*/[hidden].sc-calcite-pick-list-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-pick-list{display:none}";

/**
 * @deprecated Use the `list` component instead.
 * @slot - A slot for adding `calcite-pick-list-item` or `calcite-pick-list-group` elements. Items are displayed as a vertical list.
 * @slot menu-actions - A slot for adding a button and menu combination for performing actions, such as sorting.
 */
class PickList {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteListChange = createEvent(this, "calciteListChange", 6);
        this.calciteListFilter = createEvent(this, "calciteListFilter", 6);
        this.lastSelectedItem = null;
        this.mutationObserver = createObserver("mutation", mutationObserverCallback.bind(this));
        this.setFilterEl = (el) => {
            this.filterEl = el;
        };
        this.setFilteredItems = (filteredItems) => {
            this.filteredItems = filteredItems;
        };
        this.deselectRemovedItems = deselectRemovedItems.bind(this);
        this.deselectSiblingItems = deselectSiblingItems.bind(this);
        this.selectSiblings = selectSiblings.bind(this);
        this.handleFilter = handleFilter.bind(this);
        this.handleFilterEvent = handleFilterEvent.bind(this);
        this.getItemData = getItemData.bind(this);
        this.keyDownHandler = keyDownHandler.bind(this);
        this.disabled = false;
        this.filteredItems = [];
        this.filteredData = [];
        this.filterEnabled = false;
        this.filterPlaceholder = undefined;
        this.filterText = undefined;
        this.headingLevel = undefined;
        this.loading = false;
        this.multiple = false;
        this.selectionFollowsFocus = false;
        this.selectedValues = new Map();
        this.dataForFilter = [];
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        initialize.call(this);
        initializeObserver.call(this);
        connectInteractive(this);
    }
    disconnectedCallback() {
        cleanUpObserver.call(this);
        disconnectInteractive(this);
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
        handleInitialFilter.call(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    calciteListItemRemoveHandler(event) {
        removeItem.call(this, event);
    }
    calciteListItemChangeHandler(event) {
        calciteListItemChangeHandler.call(this, event);
    }
    calciteInternalListItemPropsChangeHandler(event) {
        event.stopPropagation();
        this.setUpFilter();
    }
    calciteInternalListItemValueChangeHandler(event) {
        calciteInternalListItemValueChangeHandler.call(this, event);
        event.stopPropagation();
    }
    calciteListFocusOutHandler(event) {
        calciteListFocusOutHandler.call(this, event);
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    setUpItems() {
        setUpItems.call(this, "calcite-pick-list-item");
    }
    setUpFilter() {
        if (this.filterEnabled) {
            this.dataForFilter = this.getItemData();
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /** Returns the component's selected `calcite-pick-list-item`s. */
    async getSelectedItems() {
        return this.selectedValues;
    }
    /**
     * Sets focus on the component's first focusable element.
     *
     * @param focusId
     */
    async setFocus(focusId) {
        await componentFocusable(this);
        return setFocus.call(this, focusId);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    getIconType() {
        return this.multiple ? ICON_TYPES$1.square : ICON_TYPES$1.circle;
    }
    render() {
        return hAsync(List, { onKeyDown: this.keyDownHandler, props: this });
    }
    get el() { return getElement(this); }
    static get style() { return pickListCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-pick-list",
        "$members$": {
            "disabled": [516],
            "filteredItems": [1040],
            "filteredData": [1040],
            "filterEnabled": [516, "filter-enabled"],
            "filterPlaceholder": [513, "filter-placeholder"],
            "filterText": [1537, "filter-text"],
            "headingLevel": [514, "heading-level"],
            "loading": [516],
            "multiple": [516],
            "selectionFollowsFocus": [516, "selection-follows-focus"],
            "selectedValues": [32],
            "dataForFilter": [32],
            "getSelectedItems": [64],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteListItemRemove", "calciteListItemRemoveHandler"], [0, "calciteListItemChange", "calciteListItemChangeHandler"], [0, "calciteInternalListItemPropsChange", "calciteInternalListItemPropsChangeHandler"], [0, "calciteInternalListItemValueChange", "calciteInternalListItemValueChangeHandler"], [0, "focusout", "calciteListFocusOutHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["filterEnabled", "filter-enabled"], ["filterPlaceholder", "filter-placeholder"], ["filterText", "filter-text"], ["headingLevel", "heading-level"], ["loading", "loading"], ["multiple", "multiple"], ["selectionFollowsFocus", "selection-follows-focus"]]
    }; }
}

const pickListGroupCss = "/*!@:host*/.sc-calcite-pick-list-group-h{margin-block-end:0.25rem;box-sizing:border-box;display:block;background-color:transparent;font-size:var(--calcite-font-size--1);color:var(--calcite-color-text-2)}/*!@:host **/.sc-calcite-pick-list-group-h *.sc-calcite-pick-list-group{box-sizing:border-box}/*!@:host(:last-child)*/.sc-calcite-pick-list-group-h:last-child{margin-block-end:0px}/*!@.header*/.header.sc-calcite-pick-list-group{margin:0px;display:flex;align-content:space-between;align-items:center;fill:var(--calcite-color-text-2);color:var(--calcite-color-text-2)}/*!@.heading*/.heading.sc-calcite-pick-list-group{margin:0px;padding:0px;font-weight:var(--calcite-font-weight-medium)}/*!@.header .heading*/.header.sc-calcite-pick-list-group .heading.sc-calcite-pick-list-group{flex:1 1 auto;padding:0.5rem}/*!@.heading*/.heading.sc-calcite-pick-list-group{margin-block:0.5rem;margin-inline:1rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;font-size:var(--calcite-font-size--1);line-height:1.375;color:var(--calcite-color-text-3)}/*!@.container--indented*/.container--indented.sc-calcite-pick-list-group{margin-inline-start:1.5rem}/*!@:host([hidden])*/[hidden].sc-calcite-pick-list-group-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-pick-list-group{display:none}";

/**
 * @deprecated Use the `list` component instead.
 * @slot - A slot for adding `calcite-pick-list-item` elements.
 */
class PickListGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.groupTitle = undefined;
        this.headingLevel = undefined;
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectConditionalSlotComponent(this);
    }
    disconnectedCallback() {
        disconnectConditionalSlotComponent(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const { el, groupTitle, headingLevel } = this;
        const hasParentItem = getSlotted(el, SLOTS$c.parentItem) !== null;
        const sectionClasses = {
            [CSS$B.container]: true,
            [CSS$B.indented]: hasParentItem,
        };
        const title = groupTitle;
        const parentLevel = el.closest("calcite-pick-list")?.headingLevel;
        const relativeLevel = parentLevel ? constrainHeadingLevel(parentLevel + 1) : null;
        const level = headingLevel || relativeLevel;
        return (hAsync(Fragment, null, title ? (hAsync(Heading, { class: CSS$B.heading, level: level }, title)) : null, hAsync("slot", { name: SLOTS$c.parentItem }), hAsync("section", { class: sectionClasses }, hAsync("slot", null))));
    }
    get el() { return getElement(this); }
    static get style() { return pickListGroupCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-pick-list-group",
        "$members$": {
            "groupTitle": [513, "group-title"],
            "headingLevel": [514, "heading-level"]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["groupTitle", "group-title"], ["headingLevel", "heading-level"]]
    }; }
}

const CSS$A = {
    actions: "actions",
    actionsEnd: "actions--end",
    actionsStart: "actions--start",
    description: "description",
    handle: "handle",
    handleActivated: "handle--activated",
    highlight: "highlight",
    icon: "icon",
    iconDot: "icon-dot",
    label: "label",
    remove: "remove",
    title: "title",
    textContainer: "text-container",
};
const ICONS$5 = {
    checked: "check",
    remove: "x",
};
const SLOTS$b = {
    actionsEnd: "actions-end",
    actionsStart: "actions-start",
};

const pickListItemCss = "@charset \"UTF-8\";/*!@:host([disabled])*/[disabled].sc-calcite-pick-list-item-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-pick-list-item-h *.sc-calcite-pick-list-item,.sc-calcite-pick-list-item-h[disabled].sc-calcite-pick-list-item-s>*,.sc-calcite-pick-list-item-h[disabled] .sc-calcite-pick-list-item-s>*{pointer-events:none}/*!@:host*/.sc-calcite-pick-list-item-h{margin:0px;margin-block-end:1px;box-sizing:border-box;display:flex;align-items:stretch;background-color:var(--calcite-color-foreground-1);font-size:var(--calcite-font-size--1);line-height:1rem;color:var(--calcite-color-text-1);--tw-shadow:0 1px 0 var(--calcite-color-border-3);--tw-shadow-colored:0 1px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);transition:background-color var(--calcite-animation-timing);animation:calcite-fade-in var(--calcite-animation-timing)}/*!@:host **/.sc-calcite-pick-list-item-h *.sc-calcite-pick-list-item{box-sizing:border-box}/*!@.label*/.label.sc-calcite-pick-list-item{display:flex;flex:1 1 auto;cursor:pointer;align-items:center;background-color:transparent;outline-color:transparent}/*!@.label:focus*/.label.sc-calcite-pick-list-item:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.label:hover*/.label.sc-calcite-pick-list-item:hover{background-color:var(--calcite-color-foreground-2)}/*!@:host([non-interactive]:hover)*/[non-interactive].sc-calcite-pick-list-item-h:hover{background-color:var(--calcite-color-foreground-1)}/*!@:host([non-interactive]) .label,\n:host([non-interactive]) .icon*/[non-interactive].sc-calcite-pick-list-item-h .label.sc-calcite-pick-list-item,[non-interactive].sc-calcite-pick-list-item-h .icon.sc-calcite-pick-list-item{pointer-events:none}/*!@.icon*/.icon.sc-calcite-pick-list-item{margin-block:0px;display:flex;cursor:pointer;align-items:center;padding:0.25rem;color:var(--calcite-color-brand);flex:0 0 auto;line-height:0}/*!@.icon:hover*/.icon.sc-calcite-pick-list-item:hover{background-color:var(--calcite-color-foreground-2)}/*!@.icon-dot*/.icon-dot.sc-calcite-pick-list-item{display:flex;inline-size:1.5rem;align-items:center;padding:0.5rem}/*!@.icon-dot:before*/.icon-dot.sc-calcite-pick-list-item:before{opacity:0;content:\"•\"}/*!@.icon calcite-icon*/.icon.sc-calcite-pick-list-item calcite-icon.sc-calcite-pick-list-item{opacity:0}/*!@:host([selected]) .icon-dot:before,\n:host([selected]) .icon calcite-icon*/[selected].sc-calcite-pick-list-item-h .icon-dot.sc-calcite-pick-list-item:before,[selected].sc-calcite-pick-list-item-h .icon.sc-calcite-pick-list-item calcite-icon.sc-calcite-pick-list-item{transition:opacity var(--calcite-animation-timing);opacity:1}/*!@.text-container*/.text-container.sc-calcite-pick-list-item{pointer-events:none;display:flex;flex-direction:column;flex-wrap:nowrap;overflow:hidden;padding-block:0.5rem;padding-inline:0.75rem;font-size:var(--calcite-font-size--2);line-height:1.375;word-wrap:break-word;word-break:break-word}/*!@.title*/.title.sc-calcite-pick-list-item{font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-1)}/*!@.description*/.description.sc-calcite-pick-list-item{margin-block-start:0.125rem;font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-3)}/*!@.actions*/.actions.sc-calcite-pick-list-item{margin:0px;display:flex;flex:0 1 auto;align-items:stretch;justify-content:flex-end}/*!@.actions--start ~ .label*/.actions--start.sc-calcite-pick-list-item~.label.sc-calcite-pick-list-item{padding-inline-start:0.25rem}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-pick-list-item-h[disabled] .sc-calcite-pick-list-item-s>[calcite-hydrated][disabled],[disabled].sc-calcite-pick-list-item-h [calcite-hydrated][disabled].sc-calcite-pick-list-item{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-pick-list-item{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-pick-list-item-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-pick-list-item{display:none}";

/**
 * @deprecated Use the `list` component instead.
 * @slot actions-end - A slot for adding `calcite-action`s or content to the end side of the component.
 * @slot actions-start - A slot for adding `calcite-action`s or content to the start side of the component.
 */
class PickListItem {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteListItemChange = createEvent(this, "calciteListItemChange", 6);
        this.calciteListItemRemove = createEvent(this, "calciteListItemRemove", 7);
        this.calciteInternalListItemPropsChange = createEvent(this, "calciteInternalListItemPropsChange", 6);
        this.calciteInternalListItemValueChange = createEvent(this, "calciteInternalListItemValueChange", 6);
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.pickListClickHandler = (event) => {
            if (this.disabled || (this.deselectDisabled && this.selected) || this.nonInteractive) {
                return;
            }
            this.shiftPressed = event.shiftKey;
            this.selected = !this.selected;
        };
        this.pickListKeyDownHandler = (event) => {
            if (event.key === " ") {
                event.preventDefault();
                if ((this.deselectDisabled && this.selected) || this.nonInteractive) {
                    return;
                }
                this.selected = !this.selected;
            }
        };
        this.removeClickHandler = () => {
            this.calciteListItemRemove.emit();
        };
        this.description = undefined;
        this.disabled = false;
        this.deselectDisabled = false;
        this.nonInteractive = false;
        this.icon = null;
        this.iconFlipRtl = false;
        this.label = undefined;
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.metadata = undefined;
        this.removable = false;
        this.selected = false;
        this.value = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
    }
    descriptionWatchHandler() {
        this.calciteInternalListItemPropsChange.emit();
    }
    labelWatchHandler() {
        this.calciteInternalListItemPropsChange.emit();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    metadataWatchHandler() {
        this.calciteInternalListItemPropsChange.emit();
    }
    selectedWatchHandler() {
        this.calciteListItemChange.emit({
            item: this.el,
            value: this.value,
            selected: this.selected,
            shiftPressed: this.shiftPressed,
        });
        this.shiftPressed = false;
    }
    valueWatchHandler(newValue, oldValue) {
        this.calciteInternalListItemValueChange.emit({ oldValue, newValue });
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
        connectConditionalSlotComponent(this);
    }
    async componentWillLoad() {
        await setUpMessages(this);
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        disconnectConditionalSlotComponent(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Toggles the selection state. By default this won't trigger an event.
     * The first argument allows the value to be coerced, rather than swapping values.
     *
     * @param coerce
     */
    async toggleSelected(coerce) {
        this.selected = typeof coerce === "boolean" ? coerce : !this.selected;
    }
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.focusEl?.focus();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderIcon() {
        const { icon, iconFlipRtl } = this;
        if (!icon) {
            return null;
        }
        return (hAsync("span", { class: {
                [CSS$A.icon]: true,
                [CSS$A.iconDot]: icon === ICON_TYPES$1.circle,
            }, onClick: this.pickListClickHandler }, icon === ICON_TYPES$1.square ? (hAsync("calcite-icon", { flipRtl: iconFlipRtl, icon: ICONS$5.checked, scale: "s" })) : null));
    }
    renderRemoveAction() {
        return this.removable ? (hAsync("calcite-action", { class: CSS$A.remove, icon: ICONS$5.remove, onClick: this.removeClickHandler, slot: SLOTS$b.actionsEnd, text: this.messages.remove })) : null;
    }
    renderActionsStart() {
        const { el } = this;
        const hasActionsStart = getSlotted(el, SLOTS$b.actionsStart);
        return hasActionsStart ? (hAsync("div", { class: { [CSS$A.actions]: true, [CSS$A.actionsStart]: true } }, hAsync("slot", { name: SLOTS$b.actionsStart }))) : null;
    }
    renderActionsEnd() {
        const { el, removable } = this;
        const hasActionsEnd = getSlotted(el, SLOTS$b.actionsEnd);
        return hasActionsEnd || removable ? (hAsync("div", { class: { [CSS$A.actions]: true, [CSS$A.actionsEnd]: true } }, hAsync("slot", { name: SLOTS$b.actionsEnd }), this.renderRemoveAction())) : null;
    }
    render() {
        const { description, label } = this;
        return (hAsync(InteractiveContainer, { disabled: this.disabled }, this.renderIcon(), this.renderActionsStart(), hAsync("label", { "aria-label": label, class: CSS$A.label, onClick: this.pickListClickHandler, onKeyDown: this.pickListKeyDownHandler, tabIndex: 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (focusEl) => (this.focusEl = focusEl) }, hAsync("div", { "aria-checked": toAriaBoolean(this.selected), class: CSS$A.textContainer, role: "menuitemcheckbox" }, hAsync("span", { class: CSS$A.title }, label), description ? hAsync("span", { class: CSS$A.description }, description) : null)), this.renderActionsEnd()));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "description": ["descriptionWatchHandler"],
        "label": ["labelWatchHandler"],
        "defaultMessages": ["onMessagesChange"],
        "messageOverrides": ["onMessagesChange"],
        "metadata": ["metadataWatchHandler"],
        "selected": ["selectedWatchHandler"],
        "value": ["valueWatchHandler"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return pickListItemCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-pick-list-item",
        "$members$": {
            "description": [513],
            "disabled": [516],
            "deselectDisabled": [516, "deselect-disabled"],
            "nonInteractive": [516, "non-interactive"],
            "icon": [513],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "label": [513],
            "messageOverrides": [1040],
            "messages": [1040],
            "metadata": [16],
            "removable": [516],
            "selected": [1540],
            "value": [8],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "toggleSelected": [64],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["description", "description"], ["disabled", "disabled"], ["deselectDisabled", "deselect-disabled"], ["nonInteractive", "non-interactive"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["label", "label"], ["removable", "removable"], ["selected", "selected"]]
    }; }
}

const CSS$z = {
    container: "container",
    imageContainer: "image-container",
    closeButtonContainer: "close-button-container",
    closeButton: "close-button",
    content: "content",
    hasHeader: "has-header",
    header: "header",
    headerContent: "header-content",
    heading: "heading",
};
const defaultPopoverPlacement = "auto";
const ARIA_CONTROLS = "aria-controls";
const ARIA_EXPANDED = "aria-expanded";

class PopoverManager {
    constructor() {
        // --------------------------------------------------------------------------
        //
        //  Private Properties
        //
        // --------------------------------------------------------------------------
        this.registeredElements = new Map();
        this.registeredElementCount = 0;
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.queryPopover = (composedPath) => {
            const { registeredElements } = this;
            const registeredElement = composedPath.find((pathEl) => registeredElements.has(pathEl));
            return registeredElements.get(registeredElement);
        };
        this.togglePopovers = (event) => {
            const composedPath = event.composedPath();
            const togglePopover = this.queryPopover(composedPath);
            if (togglePopover && !togglePopover.triggerDisabled) {
                togglePopover.open = !togglePopover.open;
            }
            Array.from(this.registeredElements.values())
                .filter((popover) => popover !== togglePopover && popover.autoClose && popover.open && !composedPath.includes(popover))
                .forEach((popover) => (popover.open = false));
        };
        this.keyHandler = (event) => {
            if (event.defaultPrevented) {
                return;
            }
            if (event.key === "Escape") {
                this.closeAllPopovers();
            }
            else if (isActivationKey(event.key)) {
                this.togglePopovers(event);
            }
        };
        this.clickHandler = (event) => {
            if (isPrimaryPointerButton(event)) {
                this.togglePopovers(event);
            }
        };
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    registerElement(referenceEl, popover) {
        this.registeredElementCount++;
        this.registeredElements.set(referenceEl, popover);
        if (this.registeredElementCount === 1) {
            this.addListeners();
        }
    }
    unregisterElement(referenceEl) {
        if (this.registeredElements.delete(referenceEl)) {
            this.registeredElementCount--;
        }
        if (this.registeredElementCount === 0) {
            this.removeListeners();
        }
    }
    closeAllPopovers() {
        Array.from(this.registeredElements.values()).forEach((popover) => (popover.open = false));
    }
    addListeners() {
        window.addEventListener("pointerdown", this.clickHandler, { capture: true });
        window.addEventListener("keydown", this.keyHandler, { capture: true });
    }
    removeListeners() {
        window.removeEventListener("pointerdown", this.clickHandler, { capture: true });
        window.removeEventListener("keydown", this.keyHandler, { capture: true });
    }
}

const CSS$y = {
    arrow: "calcite-floating-ui-arrow",
    arrowStroke: "calcite-floating-ui-arrow__stroke",
};
const DEFAULTS = {
    width: 12,
    height: 6,
    strokeWidth: 1,
};
/**
 * Renders a SVG element to be used as a floating-ui arrow.
 *
 * This functional component should be rendered inside a `FloatingUIComponent` when it needs an arrow element.
 *
 * @param floatingLayout.floatingLayout
 * @param floatingLayout – The effective floating layout to render the arrow vertically or horizontally. Possible values: `vertical` or `horizontal`.
 *
 * See [floating-ui](https://github.com/Esri/calcite-design-system/blob/main/src/utils/floating-ui.ts)
 * @param floatingLayout.key
 * @param floatingLayout.ref
 */
const FloatingArrow = ({ floatingLayout, key, ref, }) => {
    const { width, height, strokeWidth } = DEFAULTS;
    const svgX = width / 2;
    const isVertical = floatingLayout === "vertical";
    const dValue = "M0,0" +
        ` H${width}` +
        ` L${width - svgX},${height}` +
        ` Q${svgX},${height} ${svgX},${height}` +
        " Z";
    return (hAsync("svg", { "aria-hidden": "true", class: CSS$y.arrow, height: width, key: key, viewBox: `0 0 ${width} ${width + (!isVertical ? strokeWidth : 0)}`, width: width + (isVertical ? strokeWidth : 0), 
        // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
        ref: ref },
        strokeWidth > 0 && (hAsync("path", { class: CSS$y.arrowStroke, d: dValue, fill: "none", "stroke-width": strokeWidth + 1 })),
        hAsync("path", { d: dValue, stroke: "none" })));
};

const popoverCss = "/*!@:host*/.sc-calcite-popover-h{--calcite-floating-ui-z-index:var(--calcite-popover-z-index, var(--calcite-z-index-popup));display:block;position:absolute;z-index:var(--calcite-floating-ui-z-index)}/*!@.calcite-floating-ui-anim*/.calcite-floating-ui-anim.sc-calcite-popover{position:relative;transition:var(--calcite-floating-ui-transition);transition-property:transform, visibility, opacity;opacity:0;box-shadow:0 0 16px 0 rgba(0, 0, 0, 0.16);z-index:var(--calcite-z-index);border-radius:0.25rem}/*!@:host([data-placement^=bottom]) .calcite-floating-ui-anim*/[data-placement^=bottom].sc-calcite-popover-h .calcite-floating-ui-anim.sc-calcite-popover{transform:translateY(-5px)}/*!@:host([data-placement^=top]) .calcite-floating-ui-anim*/[data-placement^=top].sc-calcite-popover-h .calcite-floating-ui-anim.sc-calcite-popover{transform:translateY(5px)}/*!@:host([data-placement^=left]) .calcite-floating-ui-anim*/[data-placement^=left].sc-calcite-popover-h .calcite-floating-ui-anim.sc-calcite-popover{transform:translateX(5px)}/*!@:host([data-placement^=right]) .calcite-floating-ui-anim*/[data-placement^=right].sc-calcite-popover-h .calcite-floating-ui-anim.sc-calcite-popover{transform:translateX(-5px)}/*!@:host([data-placement]) .calcite-floating-ui-anim--active*/[data-placement].sc-calcite-popover-h .calcite-floating-ui-anim--active.sc-calcite-popover{opacity:1;transform:translate(0)}/*!@:host([calcite-hydrated-hidden])*/[calcite-hydrated-hidden].sc-calcite-popover-h{visibility:hidden !important;pointer-events:none}/*!@.calcite-floating-ui-arrow*/.calcite-floating-ui-arrow.sc-calcite-popover{pointer-events:none;position:absolute;z-index:calc(var(--calcite-z-index) * -1);fill:var(--calcite-color-foreground-1)}/*!@.calcite-floating-ui-arrow__stroke*/.calcite-floating-ui-arrow__stroke.sc-calcite-popover{stroke:var(--calcite-color-border-3)}/*!@:host([scale=s]) .heading*/[scale=s].sc-calcite-popover-h .heading.sc-calcite-popover{padding-inline:0.75rem;padding-block:0.5rem;font-size:var(--calcite-font-size--1);line-height:1.375}/*!@:host([scale=m]) .heading*/[scale=m].sc-calcite-popover-h .heading.sc-calcite-popover{padding-inline:1rem;padding-block:0.75rem;font-size:var(--calcite-font-size-0);line-height:1.375}/*!@:host([scale=l]) .heading*/[scale=l].sc-calcite-popover-h .heading.sc-calcite-popover{padding-inline:1.25rem;padding-block:1rem;font-size:var(--calcite-font-size-1);line-height:1.375}/*!@:host*/.sc-calcite-popover-h{pointer-events:none}/*!@:host([open])*/[open].sc-calcite-popover-h{pointer-events:initial}/*!@.calcite-floating-ui-anim*/.calcite-floating-ui-anim.sc-calcite-popover{border-radius:0.25rem;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-3);background-color:var(--calcite-color-foreground-1)}/*!@.arrow::before*/.arrow.sc-calcite-popover::before{outline:1px solid var(--calcite-color-border-3)}/*!@.header*/.header.sc-calcite-popover{display:flex;flex:1 1 auto;align-items:stretch;justify-content:flex-start;border-width:0px;border-block-end-width:1px;border-style:solid;border-block-end-color:var(--calcite-color-border-3)}/*!@.heading*/.heading.sc-calcite-popover{margin:0px;display:block;flex:1 1 auto;align-self:center;white-space:normal;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1);word-wrap:break-word;word-break:break-word}/*!@.container*/.container.sc-calcite-popover{position:relative;display:flex;block-size:100%;flex-direction:row;flex-wrap:nowrap;border-radius:0.25rem;color:var(--calcite-color-text-1)}/*!@.container.has-header*/.container.has-header.sc-calcite-popover{flex-direction:column}/*!@.content*/.content.sc-calcite-popover{display:flex;block-size:100%;inline-size:100%;flex-direction:column;flex-wrap:nowrap;align-self:center;word-wrap:break-word;word-break:break-word}/*!@.close-button-container*/.close-button-container.sc-calcite-popover{display:flex;overflow:hidden;flex:0 0 auto;border-start-end-radius:0.25rem;border-end-end-radius:0.25rem}/*!@::slotted(calcite-panel),\n::slotted(calcite-flow)*/.sc-calcite-popover-s>calcite-panel,.sc-calcite-popover-s>calcite-flow{block-size:100%}/*!@:host([hidden])*/[hidden].sc-calcite-popover-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-popover{display:none}";

const manager$1 = new PopoverManager();
/**
 * @slot - A slot for adding custom content.
 */
class Popover {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calcitePopoverBeforeClose = createEvent(this, "calcitePopoverBeforeClose", 6);
        this.calcitePopoverClose = createEvent(this, "calcitePopoverClose", 6);
        this.calcitePopoverBeforeOpen = createEvent(this, "calcitePopoverBeforeOpen", 6);
        this.calcitePopoverOpen = createEvent(this, "calcitePopoverOpen", 6);
        this.mutationObserver = createObserver();
        this.guid = `calcite-popover-${guid()}`;
        this.openTransitionProp = "opacity";
        this.hasLoaded = false;
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.setTransitionEl = (el) => {
            this.transitionEl = el;
        };
        this.setFilteredPlacements = () => {
            const { el, flipPlacements } = this;
            this.filteredFlipPlacements = flipPlacements
                ? filterComputedPlacements(flipPlacements, el)
                : null;
        };
        this.setUpReferenceElement = (warn = true) => {
            this.removeReferences();
            this.effectiveReferenceElement = this.getReferenceElement();
            connectFloatingUI(this, this.effectiveReferenceElement, this.el);
            const { el, referenceElement, effectiveReferenceElement } = this;
            if (warn && referenceElement && !effectiveReferenceElement) {
                console.warn(`${el.tagName}: reference-element id "${referenceElement}" was not found.`, {
                    el,
                });
            }
            this.addReferences();
        };
        this.getId = () => {
            return this.el.id || this.guid;
        };
        this.setExpandedAttr = () => {
            const { effectiveReferenceElement, open } = this;
            if (!effectiveReferenceElement) {
                return;
            }
            if ("setAttribute" in effectiveReferenceElement) {
                effectiveReferenceElement.setAttribute(ARIA_EXPANDED, toAriaBoolean(open));
            }
        };
        this.addReferences = () => {
            const { effectiveReferenceElement } = this;
            if (!effectiveReferenceElement) {
                return;
            }
            const id = this.getId();
            if ("setAttribute" in effectiveReferenceElement) {
                effectiveReferenceElement.setAttribute(ARIA_CONTROLS, id);
            }
            manager$1.registerElement(effectiveReferenceElement, this.el);
            this.setExpandedAttr();
        };
        this.removeReferences = () => {
            const { effectiveReferenceElement } = this;
            if (!effectiveReferenceElement) {
                return;
            }
            if ("removeAttribute" in effectiveReferenceElement) {
                effectiveReferenceElement.removeAttribute(ARIA_CONTROLS);
                effectiveReferenceElement.removeAttribute(ARIA_EXPANDED);
            }
            manager$1.unregisterElement(effectiveReferenceElement);
        };
        this.hide = () => {
            this.open = false;
        };
        this.storeArrowEl = (el) => {
            this.arrowEl = el;
            this.reposition(true);
        };
        this.autoClose = false;
        this.closable = false;
        this.flipDisabled = false;
        this.focusTrapDisabled = false;
        this.pointerDisabled = false;
        this.flipPlacements = undefined;
        this.heading = undefined;
        this.headingLevel = undefined;
        this.label = undefined;
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.offsetDistance = defaultOffsetDistance;
        this.offsetSkidding = 0;
        this.open = false;
        this.overlayPositioning = "absolute";
        this.placement = defaultPopoverPlacement;
        this.referenceElement = undefined;
        this.scale = "m";
        this.triggerDisabled = false;
        this.effectiveLocale = "";
        this.floatingLayout = "vertical";
        this.effectiveReferenceElement = undefined;
        this.defaultMessages = undefined;
    }
    handleFocusTrapDisabled(focusTrapDisabled) {
        if (!this.open) {
            return;
        }
        focusTrapDisabled ? deactivateFocusTrap(this) : activateFocusTrap(this);
    }
    flipPlacementsHandler() {
        this.setFilteredPlacements();
        this.reposition(true);
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    offsetDistanceOffsetHandler() {
        this.reposition(true);
    }
    offsetSkiddingHandler() {
        this.reposition(true);
    }
    openHandler() {
        onToggleOpenCloseComponent(this);
        this.reposition(true);
        this.setExpandedAttr();
    }
    overlayPositioningHandler() {
        this.reposition(true);
    }
    placementHandler() {
        this.reposition(true);
    }
    referenceElementHandler() {
        this.setUpReferenceElement();
        this.reposition(true);
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        this.setFilteredPlacements();
        connectLocalized(this);
        connectMessages(this);
        this.setUpReferenceElement(this.hasLoaded);
        connectFocusTrap(this);
        if (this.open) {
            onToggleOpenCloseComponent(this);
        }
        connectFloatingUI(this, this.effectiveReferenceElement, this.el);
    }
    async componentWillLoad() {
        await setUpMessages(this);
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
        if (this.referenceElement && !this.effectiveReferenceElement) {
            this.setUpReferenceElement();
        }
        this.reposition();
        this.hasLoaded = true;
    }
    disconnectedCallback() {
        this.removeReferences();
        disconnectLocalized(this);
        disconnectMessages(this);
        disconnectFloatingUI(this, this.effectiveReferenceElement, this.el);
        deactivateFocusTrap(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Updates the position of the component.
     *
     * @param delayed
     */
    async reposition(delayed = false) {
        const { el, effectiveReferenceElement, placement, overlayPositioning, flipDisabled, filteredFlipPlacements, offsetDistance, offsetSkidding, arrowEl, } = this;
        return reposition(this, {
            floatingEl: el,
            referenceEl: effectiveReferenceElement,
            overlayPositioning,
            placement,
            flipDisabled,
            flipPlacements: filteredFlipPlacements,
            offsetDistance,
            offsetSkidding,
            arrowEl,
            type: "popover",
        }, delayed);
    }
    /**
     * Sets focus on the component's first focusable element.
     */
    async setFocus() {
        await componentFocusable(this);
        focusFirstTabbable(this.el);
    }
    /**
     * Updates the element(s) that are used within the focus-trap of the component.
     */
    async updateFocusTrapElements() {
        updateFocusTrapElements(this);
    }
    getReferenceElement() {
        const { referenceElement, el } = this;
        return ((typeof referenceElement === "string"
            ? queryElementRoots(el, { id: referenceElement })
            : referenceElement) || null);
    }
    onBeforeOpen() {
        this.calcitePopoverBeforeOpen.emit();
    }
    onOpen() {
        this.calcitePopoverOpen.emit();
        activateFocusTrap(this);
    }
    onBeforeClose() {
        this.calcitePopoverBeforeClose.emit();
    }
    onClose() {
        this.calcitePopoverClose.emit();
        deactivateFocusTrap(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderCloseButton() {
        const { messages, closable } = this;
        return closable ? (hAsync("div", { class: CSS$z.closeButtonContainer, key: CSS$z.closeButtonContainer }, hAsync("calcite-action", { appearance: "transparent", class: CSS$z.closeButton, onClick: this.hide, scale: this.scale, text: messages.close,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (closeButtonEl) => (this.closeButtonEl = closeButtonEl) }, hAsync("calcite-icon", { icon: "x", scale: getIconScale(this.scale) })))) : null;
    }
    renderHeader() {
        const { heading, headingLevel } = this;
        const headingNode = heading ? (hAsync(Heading, { class: CSS$z.heading, level: headingLevel }, heading)) : null;
        return headingNode ? (hAsync("div", { class: CSS$z.header, key: CSS$z.header }, headingNode, this.renderCloseButton())) : null;
    }
    render() {
        const { effectiveReferenceElement, heading, label, open, pointerDisabled, floatingLayout } = this;
        const displayed = effectiveReferenceElement && open;
        const hidden = !displayed;
        const arrowNode = !pointerDisabled ? (hAsync(FloatingArrow, { floatingLayout: floatingLayout, key: "floating-arrow",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeArrowEl })) : null;
        return (hAsync(Host, { "aria-hidden": toAriaBoolean(hidden), "aria-label": label, "aria-live": "polite", "calcite-hydrated-hidden": hidden, id: this.getId(), role: "dialog" }, hAsync("div", { class: {
                [FloatingCSS.animation]: true,
                [FloatingCSS.animationActive]: displayed,
            },
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setTransitionEl }, arrowNode, hAsync("div", { class: {
                [CSS$z.hasHeader]: !!heading,
                [CSS$z.container]: true,
            } }, this.renderHeader(), hAsync("div", { class: CSS$z.content }, hAsync("slot", null)), !heading ? this.renderCloseButton() : null))));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "focusTrapDisabled": ["handleFocusTrapDisabled"],
        "flipPlacements": ["flipPlacementsHandler"],
        "messageOverrides": ["onMessagesChange"],
        "offsetDistance": ["offsetDistanceOffsetHandler"],
        "offsetSkidding": ["offsetSkiddingHandler"],
        "open": ["openHandler"],
        "overlayPositioning": ["overlayPositioningHandler"],
        "placement": ["placementHandler"],
        "referenceElement": ["referenceElementHandler"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return popoverCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-popover",
        "$members$": {
            "autoClose": [516, "auto-close"],
            "closable": [516],
            "flipDisabled": [516, "flip-disabled"],
            "focusTrapDisabled": [516, "focus-trap-disabled"],
            "pointerDisabled": [516, "pointer-disabled"],
            "flipPlacements": [16],
            "heading": [1],
            "headingLevel": [514, "heading-level"],
            "label": [1],
            "messageOverrides": [1040],
            "messages": [1040],
            "offsetDistance": [514, "offset-distance"],
            "offsetSkidding": [514, "offset-skidding"],
            "open": [1540],
            "overlayPositioning": [513, "overlay-positioning"],
            "placement": [513],
            "referenceElement": [1, "reference-element"],
            "scale": [513],
            "triggerDisabled": [516, "trigger-disabled"],
            "effectiveLocale": [32],
            "floatingLayout": [32],
            "effectiveReferenceElement": [32],
            "defaultMessages": [32],
            "reposition": [64],
            "setFocus": [64],
            "updateFocusTrapElements": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["autoClose", "auto-close"], ["closable", "closable"], ["flipDisabled", "flip-disabled"], ["focusTrapDisabled", "focus-trap-disabled"], ["pointerDisabled", "pointer-disabled"], ["headingLevel", "heading-level"], ["offsetDistance", "offset-distance"], ["offsetSkidding", "offset-skidding"], ["open", "open"], ["overlayPositioning", "overlay-positioning"], ["placement", "placement"], ["scale", "scale"], ["triggerDisabled", "trigger-disabled"]]
    }; }
}

const progressCss = "/*!@:host*/.sc-calcite-progress-h{position:relative;display:block;inline-size:100%}/*!@.track,\n.bar*/.track.sc-calcite-progress,.bar.sc-calcite-progress{position:absolute;inset-block-start:0px;block-size:2px}/*!@.track*/.track.sc-calcite-progress{z-index:var(--calcite-z-index);inline-size:100%;overflow:hidden;background:var(--calcite-color-border-3)}/*!@.bar*/.bar.sc-calcite-progress{z-index:var(--calcite-z-index);background-color:var(--calcite-color-brand)}@media (forced-colors: active){/*!@.track*/.track.sc-calcite-progress{background-color:highlightText}/*!@.bar*/.bar.sc-calcite-progress{background-color:linkText}}/*!@.indeterminate*/.indeterminate.sc-calcite-progress{inline-size:20%;animation:looping-progress-bar-ani calc(var(--calcite-internal-animation-timing-medium) / var(--calcite-internal-duration-factor) * 11 / var(--calcite-internal-duration-factor)) linear infinite}/*!@.indeterminate.calcite--rtl*/.indeterminate.calcite--rtl.sc-calcite-progress{animation-name:looping-progress-bar-ani-rtl}/*!@.reversed*/.reversed.sc-calcite-progress{animation-direction:reverse}/*!@.text*/.text.sc-calcite-progress{padding-inline:0px;padding-block:1rem 0px;text-align:center;font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-2)}@keyframes looping-progress-bar-ani{0%{transform:translate3d(-100%, 0, 0)}50%{inline-size:40%}100%{transform:translate3d(600%, 0, 0)}}@keyframes looping-progress-bar-ani-rtl{0%{transform:translate3d(100%, 0, 0)}50%{inline-size:40%}100%{transform:translate3d(-600%, 0, 0)}}/*!@:host([hidden])*/[hidden].sc-calcite-progress-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-progress{display:none}";

class Progress {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.type = "determinate";
        this.value = 0;
        this.label = undefined;
        this.text = undefined;
        this.reversed = false;
    }
    render() {
        const isDeterminate = this.type === "determinate";
        const barStyles = isDeterminate ? { width: `${this.value * 100}%` } : {};
        const dir = getElementDir(this.el);
        return (hAsync("div", { "aria-label": this.label || this.text, "aria-valuemax": 1, "aria-valuemin": 0, "aria-valuenow": this.value, role: "progressbar" }, hAsync("div", { class: "track" }, hAsync("div", { class: {
                bar: true,
                indeterminate: this.type === "indeterminate",
                [CSS_UTILITY.rtl]: dir === "rtl",
                reversed: this.reversed,
            }, style: barStyles })), this.text ? hAsync("div", { class: "text" }, this.text) : null));
    }
    get el() { return getElement(this); }
    static get style() { return progressCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-progress",
        "$members$": {
            "type": [513],
            "value": [2],
            "label": [1],
            "text": [1],
            "reversed": [516]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["type", "type"], ["reversed", "reversed"]]
    }; }
}

const CSS$x = {
    container: "container",
};

const radioButtonCss = "/*!@:host([disabled])*/[disabled].sc-calcite-radio-button-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-radio-button-h *.sc-calcite-radio-button,.sc-calcite-radio-button-h[disabled].sc-calcite-radio-button-s>*,.sc-calcite-radio-button-h[disabled] .sc-calcite-radio-button-s>*{pointer-events:none}/*!@:host*/.sc-calcite-radio-button-h{display:block;cursor:pointer}/*!@:host .container*/.sc-calcite-radio-button-h .container.sc-calcite-radio-button{position:relative;outline:2px solid transparent;outline-offset:2px}/*!@:host .radio*/.sc-calcite-radio-button-h .radio.sc-calcite-radio-button{cursor:pointer;border-radius:9999px;background-color:var(--calcite-color-foreground-1);outline-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;box-shadow:inset 0 0 0 1px var(--calcite-color-border-input)}/*!@:host([hovered]) .radio,\n:host(:not([checked])[focused]:not([disabled])) .radio*/[hovered].sc-calcite-radio-button-h .radio.sc-calcite-radio-button,.sc-calcite-radio-button-h:not([checked])[focused]:not([disabled]) .radio.sc-calcite-radio-button{box-shadow:inset 0 0 0 2px var(--calcite-color-brand)}/*!@:host([focused]) .radio*/[focused].sc-calcite-radio-button-h .radio.sc-calcite-radio-button{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([disabled]) .radio*/[disabled].sc-calcite-radio-button-h .radio.sc-calcite-radio-button{cursor:default;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-radio-button-h[disabled] .sc-calcite-radio-button-s>[calcite-hydrated][disabled],[disabled].sc-calcite-radio-button-h [calcite-hydrated][disabled].sc-calcite-radio-button{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-radio-button{display:contents}/*!@:host([hovered][disabled]) .radio*/[hovered][disabled].sc-calcite-radio-button-h .radio.sc-calcite-radio-button{box-shadow:inset 0 0 0 1px var(--calcite-color-border-input)}/*!@:host([scale=s])*/[scale=s].sc-calcite-radio-button-h{--calcite-radio-size:var(--calcite-font-size--2)}/*!@:host([scale=m])*/[scale=m].sc-calcite-radio-button-h{--calcite-radio-size:var(--calcite-font-size--1)}/*!@:host([scale=l])*/[scale=l].sc-calcite-radio-button-h{--calcite-radio-size:var(--calcite-font-size-0)}/*!@.radio*/.radio.sc-calcite-radio-button{block-size:var(--calcite-radio-size);max-inline-size:var(--calcite-radio-size);min-inline-size:var(--calcite-radio-size)}/*!@:host([scale=s][checked]) .radio,\n:host([hovered][scale=s][checked][disabled]) .radio*/[scale=s][checked].sc-calcite-radio-button-h .radio.sc-calcite-radio-button,[hovered][scale=s][checked][disabled].sc-calcite-radio-button-h .radio.sc-calcite-radio-button{box-shadow:inset 0 0 0 4px var(--calcite-color-brand)}/*!@:host([scale=s][focused][checked]:not([disabled])) .radio*/[scale=s][focused][checked].sc-calcite-radio-button-h:not([disabled]) .radio.sc-calcite-radio-button{box-shadow:inset 0 0 0 4px var(--calcite-color-brand), 0 0 0 2px var(--calcite-color-foreground-1)}/*!@:host([scale=m][checked]) .radio,\n:host([hovered][scale=m][checked][disabled]) .radio*/[scale=m][checked].sc-calcite-radio-button-h .radio.sc-calcite-radio-button,[hovered][scale=m][checked][disabled].sc-calcite-radio-button-h .radio.sc-calcite-radio-button{box-shadow:inset 0 0 0 5px var(--calcite-color-brand)}/*!@:host([scale=m][focused][checked]:not([disabled])) .radio*/[scale=m][focused][checked].sc-calcite-radio-button-h:not([disabled]) .radio.sc-calcite-radio-button{box-shadow:inset 0 0 0 5px var(--calcite-color-brand), 0 0 0 2px var(--calcite-color-foreground-1)}/*!@:host([scale=l][checked]) .radio,\n:host([hovered][scale=l][checked][disabled]) .radio*/[scale=l][checked].sc-calcite-radio-button-h .radio.sc-calcite-radio-button,[hovered][scale=l][checked][disabled].sc-calcite-radio-button-h .radio.sc-calcite-radio-button{box-shadow:inset 0 0 0 6px var(--calcite-color-brand)}/*!@:host([scale=l][focused][checked]:not([disabled])) .radio*/[scale=l][focused][checked].sc-calcite-radio-button-h:not([disabled]) .radio.sc-calcite-radio-button{box-shadow:inset 0 0 0 6px var(--calcite-color-brand), 0 0 0 2px var(--calcite-color-foreground-1)}@media (forced-colors: active){/*!@:host([checked]) .radio::after,\n  :host([checked][disabled]) .radio::after*/[checked].sc-calcite-radio-button-h .radio.sc-calcite-radio-button::after,[checked][disabled].sc-calcite-radio-button-h .radio.sc-calcite-radio-button::after{content:\"\";inline-size:var(--calcite-radio-size);block-size:var(--calcite-radio-size);background-color:windowText;display:block}}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-radio-button-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([hidden])*/[hidden].sc-calcite-radio-button-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-radio-button{display:none}";

class RadioButton {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalRadioButtonBlur = createEvent(this, "calciteInternalRadioButtonBlur", 6);
        this.calciteRadioButtonChange = createEvent(this, "calciteRadioButtonChange", 6);
        this.calciteInternalRadioButtonCheckedChange = createEvent(this, "calciteInternalRadioButtonCheckedChange", 6);
        this.calciteInternalRadioButtonFocus = createEvent(this, "calciteInternalRadioButtonFocus", 6);
        this.selectItem = (items, selectedIndex) => {
            items[selectedIndex].click();
        };
        this.queryButtons = () => {
            return Array.from(this.rootNode.querySelectorAll("calcite-radio-button:not([hidden])")).filter((radioButton) => radioButton.name === this.name);
        };
        this.isFocusable = () => {
            const radioButtons = this.queryButtons();
            const firstFocusable = radioButtons.find((radioButton) => !radioButton.disabled);
            const checked = radioButtons.find((radioButton) => radioButton.checked);
            return firstFocusable === this.el && !checked;
        };
        this.check = () => {
            if (this.disabled) {
                return;
            }
            this.focused = true;
            this.setFocus();
            if (this.checked) {
                return;
            }
            this.uncheckAllRadioButtonsInGroup();
            this.checked = true;
            this.calciteRadioButtonChange.emit();
        };
        this.clickHandler = () => {
            if (this.disabled) {
                return;
            }
            this.check();
        };
        this.setContainerEl = (el) => {
            this.containerEl = el;
        };
        this.handleKeyDown = (event) => {
            const keys = ["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", " "];
            const { key } = event;
            const { el } = this;
            if (keys.indexOf(key) === -1) {
                return;
            }
            if (key === " ") {
                this.check();
                event.preventDefault();
                return;
            }
            let adjustedKey = key;
            if (getElementDir(el) === "rtl") {
                if (key === "ArrowRight") {
                    adjustedKey = "ArrowLeft";
                }
                if (key === "ArrowLeft") {
                    adjustedKey = "ArrowRight";
                }
            }
            const radioButtons = Array.from(this.rootNode.querySelectorAll("calcite-radio-button:not([hidden])")).filter((radioButton) => radioButton.name === this.name);
            let currentIndex = 0;
            const radioButtonsLength = radioButtons.length;
            radioButtons.some((item, index) => {
                if (item.checked) {
                    currentIndex = index;
                    return true;
                }
            });
            switch (adjustedKey) {
                case "ArrowLeft":
                case "ArrowUp":
                    event.preventDefault();
                    this.selectItem(radioButtons, getRoundRobinIndex(Math.max(currentIndex - 1, -1), radioButtonsLength));
                    return;
                case "ArrowRight":
                case "ArrowDown":
                    event.preventDefault();
                    this.selectItem(radioButtons, getRoundRobinIndex(currentIndex + 1, radioButtonsLength));
                    return;
                default:
                    return;
            }
        };
        this.onContainerBlur = () => {
            this.focused = false;
            this.calciteInternalRadioButtonBlur.emit();
        };
        this.onContainerFocus = () => {
            if (!this.disabled) {
                this.focused = true;
                this.calciteInternalRadioButtonFocus.emit();
            }
        };
        this.checked = false;
        this.disabled = false;
        this.focused = false;
        this.form = undefined;
        this.guid = undefined;
        this.hovered = false;
        this.label = undefined;
        this.name = undefined;
        this.required = false;
        this.scale = "m";
        this.value = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Global attributes
    //
    //--------------------------------------------------------------------------
    handleHiddenChange() {
        this.updateTabIndexOfOtherRadioButtonsInGroup();
    }
    checkedChanged(newChecked) {
        if (newChecked) {
            this.uncheckOtherRadioButtonsInGroup();
        }
        this.calciteInternalRadioButtonCheckedChange.emit();
    }
    disabledChanged() {
        this.updateTabIndexOfOtherRadioButtonsInGroup();
    }
    nameChanged() {
        this.checkLastRadioButton();
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        if (!this.disabled) {
            focusElement(this.containerEl);
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    syncHiddenFormInput(input) {
        input.type = "radio";
    }
    onLabelClick(event) {
        if (this.disabled || this.el.hidden) {
            return;
        }
        const label = event.currentTarget;
        const radioButton = label.for
            ? this.rootNode.querySelector(`calcite-radio-button[id="${label.for}"]`)
            : label.querySelector(`calcite-radio-button[name="${this.name}"]`);
        if (!radioButton) {
            return;
        }
        radioButton.focused = true;
        this.setFocus();
        if (radioButton.checked) {
            return;
        }
        this.uncheckOtherRadioButtonsInGroup();
        radioButton.checked = true;
        this.calciteRadioButtonChange.emit();
    }
    checkLastRadioButton() {
        const radioButtons = this.queryButtons();
        const checkedRadioButtons = radioButtons.filter((radioButton) => radioButton.checked);
        if (checkedRadioButtons?.length > 1) {
            const lastCheckedRadioButton = checkedRadioButtons[checkedRadioButtons.length - 1];
            checkedRadioButtons
                .filter((checkedRadioButton) => checkedRadioButton !== lastCheckedRadioButton)
                .forEach((checkedRadioButton) => {
                checkedRadioButton.checked = false;
                checkedRadioButton.emitCheckedChange();
            });
        }
    }
    /** @internal */
    async emitCheckedChange() {
        this.calciteInternalRadioButtonCheckedChange.emit();
    }
    uncheckAllRadioButtonsInGroup() {
        const radioButtons = this.queryButtons();
        radioButtons.forEach((radioButton) => {
            if (radioButton.checked) {
                radioButton.checked = false;
                radioButton.focused = false;
            }
        });
    }
    uncheckOtherRadioButtonsInGroup() {
        const radioButtons = this.queryButtons();
        const otherRadioButtons = radioButtons.filter((radioButton) => radioButton.guid !== this.guid);
        otherRadioButtons.forEach((otherRadioButton) => {
            if (otherRadioButton.checked) {
                otherRadioButton.checked = false;
                otherRadioButton.focused = false;
            }
        });
    }
    updateTabIndexOfOtherRadioButtonsInGroup() {
        const radioButtons = this.queryButtons();
        const otherFocusableRadioButtons = radioButtons.filter((radioButton) => radioButton.guid !== this.guid && !radioButton.disabled);
        otherFocusableRadioButtons.forEach((radioButton) => {
        });
    }
    getTabIndex() {
        if (this.disabled) {
            return undefined;
        }
        return this.checked || this.isFocusable() ? 0 : -1;
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    pointerEnterHandler() {
        if (this.disabled) {
            return;
        }
        this.hovered = true;
    }
    pointerLeaveHandler() {
        if (this.disabled) {
            return;
        }
        this.hovered = false;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.rootNode = this.el.getRootNode();
        this.guid = this.el.id || `calcite-radio-button-${guid()}`;
        if (this.name) {
            this.checkLastRadioButton();
        }
        connectInteractive(this);
        connectLabel(this);
        connectForm(this);
        this.updateTabIndexOfOtherRadioButtonsInGroup();
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
        if (this.focused && !this.disabled) {
            this.setFocus();
        }
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
        this.updateTabIndexOfOtherRadioButtonsInGroup();
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const tabIndex = this.getTabIndex();
        return (hAsync(Host, { onClick: this.clickHandler, onKeyDown: this.handleKeyDown }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { "aria-checked": toAriaBoolean(this.checked), "aria-label": getLabelText(this), class: CSS$x.container, onBlur: this.onContainerBlur, onFocus: this.onContainerFocus, role: "radio", tabIndex: tabIndex,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setContainerEl }, hAsync("div", { class: "radio" })), hAsync(HiddenFormInputSlot, { component: this }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "hidden": ["handleHiddenChange"],
        "checked": ["checkedChanged"],
        "disabled": ["disabledChanged"],
        "name": ["nameChanged"]
    }; }
    static get style() { return radioButtonCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-radio-button",
        "$members$": {
            "checked": [1540],
            "disabled": [516],
            "focused": [1540],
            "form": [513],
            "guid": [1537],
            "hovered": [1540],
            "label": [1],
            "name": [513],
            "required": [516],
            "scale": [513],
            "value": [1032],
            "setFocus": [64],
            "emitCheckedChange": [64]
        },
        "$listeners$": [[1, "pointerenter", "pointerEnterHandler"], [1, "pointerleave", "pointerLeaveHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["checked", "checked"], ["disabled", "disabled"], ["focused", "focused"], ["form", "form"], ["guid", "guid"], ["hovered", "hovered"], ["name", "name"], ["required", "required"], ["scale", "scale"]]
    }; }
}

const CSS$w = {
    itemWrapper: "item-wrapper",
};

const radioButtonGroupCss = "/*!@:host*/.sc-calcite-radio-button-group-h{display:flex;flex-direction:column}/*!@:host > .item-wrapper*/.sc-calcite-radio-button-group-h>.item-wrapper.sc-calcite-radio-button-group{display:flex;max-inline-size:100vw}/*!@:host([layout=horizontal]) > .item-wrapper*/[layout=horizontal].sc-calcite-radio-button-group-h>.item-wrapper.sc-calcite-radio-button-group{flex-direction:row;flex-wrap:wrap}/*!@:host([layout=horizontal][scale=s]) > .item-wrapper*/[layout=horizontal][scale=s].sc-calcite-radio-button-group-h>.item-wrapper.sc-calcite-radio-button-group{column-gap:1rem}/*!@:host([layout=horizontal][scale=m]) > .item-wrapper*/[layout=horizontal][scale=m].sc-calcite-radio-button-group-h>.item-wrapper.sc-calcite-radio-button-group{column-gap:1.25rem}/*!@:host([layout=horizontal][scale=l]) > .item-wrapper*/[layout=horizontal][scale=l].sc-calcite-radio-button-group-h>.item-wrapper.sc-calcite-radio-button-group{column-gap:1.5rem}/*!@:host([layout=vertical]) > .item-wrapper*/[layout=vertical].sc-calcite-radio-button-group-h>.item-wrapper.sc-calcite-radio-button-group{flex-direction:column}/*!@:host([scale=s]) calcite-input-message*/[scale=s].sc-calcite-radio-button-group-h calcite-input-message.sc-calcite-radio-button-group{--calcite-input-message-spacing-value:calc(var(--calcite-spacing-xxs) * -1)}/*!@:host([scale=m]) calcite-input-message*/[scale=m].sc-calcite-radio-button-group-h calcite-input-message.sc-calcite-radio-button-group{--calcite-input-message-spacing-value:calc(var(--calcite-spacing-sm) * -1)}/*!@:host([scale=l]) calcite-input-message*/[scale=l].sc-calcite-radio-button-group-h calcite-input-message.sc-calcite-radio-button-group{--calcite-input-message-spacing-value:calc(var(--calcite-spacing-md) * -1)}/*!@.validation-container*/.validation-container.sc-calcite-radio-button-group{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}/*!@:host([scale=m]) .validation-container,\n:host([scale=l]) .validation-container*/[scale=m].sc-calcite-radio-button-group-h .validation-container.sc-calcite-radio-button-group,[scale=l].sc-calcite-radio-button-group-h .validation-container.sc-calcite-radio-button-group{padding-block-start:0.5rem}/*!@:host([scale=s]) .validation-container*/[scale=s].sc-calcite-radio-button-group-h .validation-container.sc-calcite-radio-button-group{padding-block-start:0.25rem}/*!@:host([hidden])*/[hidden].sc-calcite-radio-button-group-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-radio-button-group{display:none}";

/**
 * @slot - A slot for adding `calcite-radio-button`s.
 */
class RadioButtonGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteRadioButtonGroupChange = createEvent(this, "calciteRadioButtonGroupChange", 6);
        this.mutationObserver = createObserver();
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.passPropsToRadioButtons = () => {
            this.radioButtons = Array.from(this.el.querySelectorAll("calcite-radio-button"));
            this.selectedItem =
                Array.from(this.radioButtons).find((radioButton) => radioButton.checked) || null;
            if (this.radioButtons.length > 0) {
                this.radioButtons.forEach((radioButton) => {
                    radioButton.disabled = this.disabled || radioButton.disabled;
                    radioButton.hidden = this.el.hidden;
                    radioButton.name = this.name;
                    radioButton.required = this.required;
                    radioButton.scale = this.scale;
                });
            }
        };
        this.disabled = false;
        this.layout = "horizontal";
        this.name = undefined;
        this.required = false;
        this.selectedItem = null;
        this.scale = "m";
        this.status = "idle";
        this.validationMessage = undefined;
        this.validationIcon = undefined;
        this.radioButtons = [];
    }
    //--------------------------------------------------------------------------
    //
    //  Global attributes
    //
    //--------------------------------------------------------------------------
    handleHiddenChange() {
        this.passPropsToRadioButtons();
    }
    onDisabledChange() {
        this.passPropsToRadioButtons();
    }
    onLayoutChange() {
        this.passPropsToRadioButtons();
    }
    onScaleChange() {
        this.passPropsToRadioButtons();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.passPropsToRadioButtons();
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
    }
    getFocusableRadioButton() {
        return this.radioButtons.find((radiobutton) => !radiobutton.disabled) ?? null;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Method
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the fist focusable `calcite-radio-button` element in the component. */
    async setFocus() {
        await componentFocusable(this);
        if (this.selectedItem && !this.selectedItem.disabled) {
            return this.selectedItem.setFocus();
        }
        if (this.radioButtons.length > 0) {
            return this.getFocusableRadioButton()?.setFocus();
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    radioButtonChangeHandler(event) {
        this.selectedItem = event.target;
        this.calciteRadioButtonGroupChange.emit();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        return (hAsync(Host, { role: "radiogroup" }, hAsync("div", { class: CSS$w.itemWrapper }, hAsync("slot", null)), this.validationMessage && this.status === "invalid" ? (hAsync(Validation, { icon: this.validationIcon, message: this.validationMessage, scale: this.scale, status: this.status })) : null));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "hidden": ["handleHiddenChange"],
        "disabled": ["onDisabledChange"],
        "layout": ["onLayoutChange"],
        "scale": ["onScaleChange"]
    }; }
    static get style() { return radioButtonGroupCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-radio-button-group",
        "$members$": {
            "disabled": [516],
            "layout": [513],
            "name": [513],
            "required": [516],
            "selectedItem": [1040],
            "scale": [513],
            "status": [513],
            "validationMessage": [1, "validation-message"],
            "validationIcon": [520, "validation-icon"],
            "radioButtons": [32],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteRadioButtonChange", "radioButtonChangeHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["layout", "layout"], ["name", "name"], ["required", "required"], ["scale", "scale"], ["status", "status"], ["validationIcon", "validation-icon"]]
    }; }
}

const StarIcon = ({ full, scale, partial }) => (hAsync("calcite-icon", { class: partial ? undefined : "icon",
    icon: full ? "star-f" : "star",
    scale }));

const ratingCss = "/*!@:host([disabled])*/[disabled].sc-calcite-rating-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([read-only]) *, :host([disabled]) *,\n:host([read-only]) ::slotted(*),\n:host([disabled]) ::slotted(*)*/[read-only].sc-calcite-rating-h *.sc-calcite-rating,[disabled].sc-calcite-rating-h *.sc-calcite-rating,.sc-calcite-rating-h[read-only].sc-calcite-rating-s>*,.sc-calcite-rating-h[read-only] .sc-calcite-rating-s>*,.sc-calcite-rating-h[disabled].sc-calcite-rating-s>*,.sc-calcite-rating-h[disabled] .sc-calcite-rating-s>*{pointer-events:none}/*!@:host*/.sc-calcite-rating-h{position:relative;display:flex;align-items:center;inline-size:-moz-fit-content;inline-size:fit-content}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-rating-h[disabled] .sc-calcite-rating-s>[calcite-hydrated][disabled],[disabled].sc-calcite-rating-h [calcite-hydrated][disabled].sc-calcite-rating{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-rating{display:contents}/*!@:host([scale=s])*/[scale=s].sc-calcite-rating-h{block-size:1.5rem;--calcite-rating-spacing-unit:0.25rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-rating-h{block-size:2rem;--calcite-rating-spacing-unit:0.5rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-rating-h{block-size:2.75rem;--calcite-rating-spacing-unit:0.75rem}/*!@.fieldset*/.fieldset.sc-calcite-rating{margin:0;display:flex;border-width:0;padding:0;align-items:center;gap:var(--calcite-rating-spacing-unit)}/*!@.wrapper*/.wrapper.sc-calcite-rating{display:inline-block}/*!@.star*/.star.sc-calcite-rating{transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;position:relative;display:flex;flex-direction:column;cursor:pointer;color:var(--calcite-color-border-input)}/*!@.star:focus*/.star.sc-calcite-rating:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.average,\n.fraction*/.average.sc-calcite-rating,.fraction.sc-calcite-rating{color:var(--calcite-color-status-warning)}/*!@.hovered,\n.selected*/.hovered.sc-calcite-rating,.selected.sc-calcite-rating{color:var(--calcite-color-brand)}/*!@.fraction*/.fraction.sc-calcite-rating{transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;position:absolute;pointer-events:none;inset-block-start:0;overflow:hidden;inset-inline-start:0}/*!@calcite-chip*/calcite-chip.sc-calcite-rating{pointer-events:none;cursor:default}/*!@.number--average*/.number--average.sc-calcite-rating{font-weight:bold}/*!@.number--count*/.number--count.sc-calcite-rating{color:var(--calcite-color-text-2);font-style:italic}/*!@.number--count:not(:first-child)*/.number--count.sc-calcite-rating:not(:first-child){margin-inline-start:var(--calcite-rating-spacing-unit)}/*!@.visually-hidden*/.visually-hidden.sc-calcite-rating{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-rating-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([hidden])*/[hidden].sc-calcite-rating-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-rating{display:none}";

class Rating {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteRatingChange = createEvent(this, "calciteRatingChange", 6);
        this.handleRatingPointerOver = () => {
            this.isKeyboardInteraction = false;
        };
        this.handleRatingPointerOut = () => {
            this.isKeyboardInteraction = true;
            this.hoverValue = null;
        };
        this.handleHostKeyDown = () => {
            this.isKeyboardInteraction = true;
        };
        this.handleLabelKeyDown = (event) => {
            const inputValue = this.getValueFromLabelEvent(event);
            const key = event.key;
            const numberKey = key == " " ? undefined : Number(key);
            this.emit = true;
            if (isNaN(numberKey)) {
                switch (key) {
                    case "Enter":
                    case " ":
                        this.value = !this.required && this.value === inputValue ? 0 : inputValue;
                        break;
                    case "ArrowLeft":
                        this.value = this.getPreviousRatingValue(inputValue);
                        this.updateFocus();
                        event.preventDefault();
                        break;
                    case "ArrowRight":
                        this.value = this.getNextRatingValue(inputValue);
                        this.updateFocus();
                        event.preventDefault();
                        break;
                    case "Tab":
                        this.hoverValue = null;
                }
            }
            else {
                if (!this.required && numberKey >= 0 && numberKey <= this.max) {
                    this.value = numberKey;
                }
                else if (this.required && numberKey > 0 && numberKey <= this.max) {
                    this.value = numberKey;
                }
                this.updateFocus();
            }
        };
        this.handleInputChange = (event) => {
            if (this.isKeyboardInteraction === true) {
                const inputVal = Number(event.target["value"]);
                this.hoverValue = inputVal;
                this.value = inputVal;
            }
        };
        this.handleLabelPointerOver = (event) => {
            this.hoverValue = this.getValueFromLabelEvent(event);
        };
        this.handleLabelPointerDown = (event) => {
            const target = event.currentTarget;
            const inputValue = this.getValueFromLabelEvent(event);
            this.hoverValue = inputValue;
            this.emit = true;
            this.value = !this.required && this.value === inputValue ? 0 : inputValue;
            target.focus();
        };
        this.handleLabelClick = (event) => {
            //preventing pointerdown event will supress any compatability mouse events except for click event.
            event.preventDefault();
        };
        this.handleLabelFocus = (event) => {
            const inputValue = this.getValueFromLabelEvent(event);
            this.hoverValue = inputValue;
        };
        this.setLabelEl = (el) => {
            this.labelElements.push(el);
        };
        this.emit = false;
        this.guid = `calcite-ratings-${guid()}`;
        this.isKeyboardInteraction = true;
        this.labelElements = [];
        this.max = 5;
        this.average = undefined;
        this.count = undefined;
        this.disabled = false;
        this.form = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.name = undefined;
        this.readOnly = false;
        this.required = false;
        this.scale = "m";
        this.showChip = false;
        this.value = 0;
        this.effectiveLocale = "";
        this.defaultMessages = undefined;
        this.hoverValue = undefined;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    handleValueUpdate(newValue) {
        this.hoverValue = newValue;
        if (this.emit) {
            this.calciteRatingChange.emit();
        }
        this.emit = false;
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
        connectLabel(this);
        connectForm(this);
    }
    async componentWillLoad() {
        await setUpMessages(this);
        setUpLoadableComponent(this);
    }
    componentWillRender() {
        this.starsMap = Array.from({ length: this.max }, (_, i) => {
            const value = i + 1;
            const average = !this.hoverValue && this.average && !this.value && value <= this.average;
            const checked = value === this.value;
            const fraction = this.average && this.average + 1 - value;
            const hovered = value <= this.hoverValue;
            const id = `${this.guid}-${value}`;
            const partial = !this.hoverValue && !this.value && !hovered && fraction > 0 && fraction < 1;
            const selected = this.value >= value;
            const tabIndex = this.getTabIndex(value);
            return {
                average,
                checked,
                fraction,
                hovered,
                id,
                partial,
                selected,
                value,
                tabIndex,
            };
        });
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        disconnectLabel(this);
        disconnectForm(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    render() {
        return (hAsync(Host, { onKeyDown: this.handleHostKeyDown, onPointerOut: this.handleRatingPointerOut, onPointerOver: this.handleRatingPointerOver }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("span", { class: "wrapper" }, hAsync("fieldset", { class: "fieldset", disabled: this.disabled }, hAsync("legend", { class: "visually-hidden" }, this.messages.rating), this.starsMap.map(({ average, checked, fraction, hovered, id, partial, selected, value, tabIndex, }) => {
            return (hAsync("label", { class: {
                    star: true,
                    selected,
                    hovered,
                    average,
                    partial,
                }, "data-value": value, htmlFor: id, onClick: this.handleLabelClick, onFocus: this.handleLabelFocus, onKeyDown: this.handleLabelKeyDown, onPointerDown: this.handleLabelPointerDown, onPointerOver: this.handleLabelPointerOver, tabIndex: tabIndex,
                // eslint-disable-next-line react/jsx-sort-props
                ref: this.setLabelEl }, hAsync("input", { checked: checked, class: "visually-hidden", disabled: this.disabled || this.readOnly, id: id, name: this.guid, onChange: this.handleInputChange, tabIndex: -1, type: "radio", value: value }), hAsync(StarIcon, { full: selected || average, scale: this.scale }), partial && (hAsync("div", { class: "fraction", style: { width: `${fraction * 100}%` } }, hAsync(StarIcon, { full: true, partial: true, scale: this.scale }))), hAsync("span", { class: "visually-hidden" }, this.messages.stars.replace("{num}", `${value}`))));
        }), (this.count || this.average) && this.showChip ? (hAsync("calcite-chip", { scale: this.scale, value: this.count?.toString() }, !!this.average && hAsync("span", { class: "number--average" }, this.average.toString()), !!this.count && hAsync("span", { class: "number--count" }, "(", this.count?.toString(), ")"))) : null), hAsync(HiddenFormInputSlot, { component: this })))));
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    onLabelClick() {
        this.setFocus();
    }
    updateFocus() {
        this.hoverValue = this.value;
        this.labelElements[this.value - 1].focus();
    }
    getTabIndex(value) {
        if (this.readOnly || (this.value !== value && (this.value || value !== 1))) {
            return -1;
        }
        return 0;
    }
    getValueFromLabelEvent(event) {
        const target = event.currentTarget;
        return Number(target.getAttribute("data-value"));
    }
    getNextRatingValue(currentValue) {
        return currentValue === 5 ? 1 : currentValue + 1;
    }
    getPreviousRatingValue(currentValue) {
        return currentValue === 1 ? 5 : currentValue - 1;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        focusFirstTabbable(this.el);
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "value": ["handleValueUpdate"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return ratingCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-rating",
        "$members$": {
            "average": [514],
            "count": [514],
            "disabled": [516],
            "form": [513],
            "messages": [1040],
            "messageOverrides": [1040],
            "name": [513],
            "readOnly": [516, "read-only"],
            "required": [516],
            "scale": [513],
            "showChip": [516, "show-chip"],
            "value": [1538],
            "effectiveLocale": [32],
            "defaultMessages": [32],
            "hoverValue": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["average", "average"], ["count", "count"], ["disabled", "disabled"], ["form", "form"], ["name", "name"], ["readOnly", "read-only"], ["required", "required"], ["scale", "scale"], ["showChip", "show-chip"], ["value", "value"]]
    }; }
}

const CSS$v = {
    scrim: "scrim",
    content: "content",
};
const BREAKPOINTS = {
    s: 72,
    // medium is assumed default.
    l: 480, // Greater than or equal to 480px.
};

const scrimCss = "/*!@:host*/.sc-calcite-scrim-h{--calcite-scrim-background:var(--calcite-color-transparent-scrim);position:absolute;inset:0px;z-index:var(--calcite-z-index-overlay);display:flex;block-size:100%;inline-size:100%;flex-direction:column;align-items:stretch}@keyframes calcite-scrim-fade-in{0%{--tw-bg-opacity:0}100%{--tw-text-opacity:1}}/*!@.scrim*/.scrim.sc-calcite-scrim{position:absolute;inset:0px;display:flex;flex-direction:column;align-content:center;align-items:center;justify-content:center;overflow:hidden;animation:calcite-scrim-fade-in var(--calcite-internal-animation-timing-medium) ease-in-out;background-color:var(--calcite-scrim-background, var(--calcite-color-transparent-scrim))}/*!@.content*/.content.sc-calcite-scrim{padding:1rem}/*!@:host([hidden])*/[hidden].sc-calcite-scrim-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-scrim{display:none}";

/**
 * @slot - A slot for adding custom content, primarily loading information.
 */
class Scrim {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.resizeObserver = createObserver();
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.handleDefaultSlotChange = (event) => {
            this.hasContent = slotChangeHasContent(event);
        };
        this.storeLoaderEl = (el) => {
            this.loaderEl = el;
            this.handleResize();
        };
        this.loading = false;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.loaderScale = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
        this.hasContent = false;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectLocalized(this);
        connectMessages(this);
        this.resizeObserver?.observe(this.el);
    }
    async componentWillLoad() {
        await setUpMessages(this);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectMessages(this);
        this.resizeObserver?.disconnect();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Method
    //
    // --------------------------------------------------------------------------
    render() {
        const { hasContent, loading, messages } = this;
        return (hAsync("div", { class: CSS$v.scrim }, loading ? (hAsync("calcite-loader", { label: messages.loading, scale: this.loaderScale,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeLoaderEl })) : null, hAsync("div", { class: CSS$v.content, hidden: !hasContent }, hAsync("slot", { onSlotchange: this.handleDefaultSlotChange }))));
    }
    getScale(size) {
        if (size < BREAKPOINTS.s) {
            return "s";
        }
        else if (size >= BREAKPOINTS.l) {
            return "l";
        }
        else {
            return "m";
        }
    }
    handleResize() {
        const { loaderEl, el } = this;
        if (!loaderEl) {
            return;
        }
        this.loaderScale = this.getScale(Math.min(el.clientHeight, el.clientWidth) ?? 0);
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return scrimCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-scrim",
        "$members$": {
            "loading": [516],
            "messages": [1040],
            "messageOverrides": [1040],
            "loaderScale": [32],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "hasContent": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["loading", "loading"]]
    }; }
}

const CSS$u = {
    itemWrapper: "item-wrapper",
};

const segmentedControlCss = "/*!@:host([disabled])*/[disabled].sc-calcite-segmented-control-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-segmented-control-h *.sc-calcite-segmented-control,.sc-calcite-segmented-control-h[disabled].sc-calcite-segmented-control-s>*,.sc-calcite-segmented-control-h[disabled] .sc-calcite-segmented-control-s>*{pointer-events:none}/*!@:host*/.sc-calcite-segmented-control-h{display:flex;flex-direction:column}/*!@.item-wrapper*/.item-wrapper.sc-calcite-segmented-control{display:flex;background-color:var(--calcite-color-foreground-1);inline-size:-moz-fit-content;inline-size:fit-content;outline:1px solid var(--calcite-color-border-input);outline-offset:-1px}/*!@:host([appearance=outline]) > .item-wrapper*/[appearance=outline].sc-calcite-segmented-control-h>.item-wrapper.sc-calcite-segmented-control{background-color:transparent}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-segmented-control-h[disabled] .sc-calcite-segmented-control-s>[calcite-hydrated][disabled],[disabled].sc-calcite-segmented-control-h [calcite-hydrated][disabled].sc-calcite-segmented-control{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-segmented-control{display:contents}/*!@:host([layout=vertical]) > .item-wrapper*/[layout=vertical].sc-calcite-segmented-control-h>.item-wrapper.sc-calcite-segmented-control{flex-direction:column;align-items:flex-start;align-self:flex-start}/*!@:host([width=full]) > .item-wrapper*/[width=full].sc-calcite-segmented-control-h>.item-wrapper.sc-calcite-segmented-control{inline-size:100%;min-inline-size:-moz-fit-content;min-inline-size:fit-content}/*!@:host([width=full]) > .item-wrapper ::slotted(calcite-segmented-control-item)*/.sc-calcite-segmented-control-h[width=full]>.item-wrapper .sc-calcite-segmented-control-s>calcite-segmented-control-item{flex:1 1 auto}/*!@:host([width=full][layout=vertical]) > .item-wrapper ::slotted(calcite-segmented-control-item)*/.sc-calcite-segmented-control-h[width=full][layout=vertical]>.item-wrapper .sc-calcite-segmented-control-s>calcite-segmented-control-item{justify-content:flex-start}/*!@.validation-container*/.validation-container.sc-calcite-segmented-control{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}/*!@:host([scale=m]) .validation-container,\n:host([scale=l]) .validation-container*/[scale=m].sc-calcite-segmented-control-h .validation-container.sc-calcite-segmented-control,[scale=l].sc-calcite-segmented-control-h .validation-container.sc-calcite-segmented-control{padding-block-start:0.5rem}/*!@:host([scale=s]) .validation-container*/[scale=s].sc-calcite-segmented-control-h .validation-container.sc-calcite-segmented-control{padding-block-start:0.25rem}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-segmented-control-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([hidden])*/[hidden].sc-calcite-segmented-control-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-segmented-control{display:none}";

/**
 * @slot - A slot for adding `calcite-segmented-control-item`s.
 */
class SegmentedControl {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteSegmentedControlChange = createEvent(this, "calciteSegmentedControlChange", 6);
        //--------------------------------------------------------------------------
        //
        //  Event Listeners
        //
        //--------------------------------------------------------------------------
        this.handleClick = (event) => {
            if (this.disabled) {
                return;
            }
            if (event.target.localName === "calcite-segmented-control-item") {
                this.selectItem(event.target, true);
            }
        };
        this.mutationObserver = createObserver();
        this.appearance = "solid";
        this.disabled = false;
        this.form = undefined;
        this.required = false;
        this.name = undefined;
        this.layout = "horizontal";
        this.scale = "m";
        this.value = null;
        this.selectedItem = undefined;
        this.status = "idle";
        this.validationMessage = undefined;
        this.validationIcon = undefined;
        this.width = "auto";
    }
    handlePropsChange() {
        this.handleItemPropChange();
    }
    valueHandler(value) {
        const items = this.getItems();
        items.forEach((item) => (item.checked = item.value === value));
    }
    handleSelectedItemChange(newItem, oldItem) {
        this.value = newItem?.value;
        if (newItem === oldItem) {
            return;
        }
        const items = this.getItems();
        const match = items.filter((item) => item === newItem).pop();
        if (match) {
            this.selectItem(match);
        }
        else if (items[0]) {
            items[0].tabIndex = 0;
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentWillLoad() {
        setUpLoadableComponent(this);
        this.setUpItems();
    }
    componentDidLoad() {
        afterConnectDefaultValueSet(this, this.value);
        setComponentLoaded(this);
    }
    connectedCallback() {
        connectInteractive(this);
        connectLabel(this);
        connectForm(this);
        this.mutationObserver?.observe(this.el, { childList: true });
        this.handleItemPropChange();
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
        this.mutationObserver?.unobserve(this.el);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    render() {
        return (hAsync(Host, { onClick: this.handleClick, role: "radiogroup" }, hAsync("div", { class: CSS$u.itemWrapper }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("slot", null), hAsync(HiddenFormInputSlot, { component: this }))), this.validationMessage && this.status === "invalid" ? (hAsync(Validation, { icon: this.validationIcon, message: this.validationMessage, scale: this.scale, status: this.status })) : null));
    }
    handleSelected(event) {
        event.preventDefault();
        this.selectItem(event.target);
        event.stopPropagation();
    }
    handleKeyDown(event) {
        const keys = ["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", " "];
        const { key } = event;
        const { el, selectedItem } = this;
        if (keys.indexOf(key) === -1) {
            return;
        }
        let adjustedKey = key;
        if (getElementDir(el) === "rtl") {
            if (key === "ArrowRight") {
                adjustedKey = "ArrowLeft";
            }
            if (key === "ArrowLeft") {
                adjustedKey = "ArrowRight";
            }
        }
        const items = this.getItems();
        let selectedIndex = -1;
        items.forEach((item, index) => {
            if (item === selectedItem) {
                selectedIndex = index;
            }
        });
        switch (adjustedKey) {
            case "ArrowLeft":
            case "ArrowUp":
                event.preventDefault();
                const previous = selectedIndex < 1 ? items[items.length - 1] : items[selectedIndex - 1];
                this.selectItem(previous, true);
                return;
            case "ArrowRight":
            case "ArrowDown":
                event.preventDefault();
                const next = selectedIndex === -1 ? items[1] : items[selectedIndex + 1] || items[0];
                this.selectItem(next, true);
                return;
            case " ":
                event.preventDefault();
                this.selectItem(event.target, true);
                return;
            default:
                return;
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Methods
    //
    // --------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        (this.selectedItem || this.getItems()[0])?.focus();
    }
    handleItemPropChange() {
        const items = this.getItems();
        items.forEach((item) => {
            item.appearance = this.appearance;
            item.layout = this.layout;
            item.scale = this.scale;
        });
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    onLabelClick() {
        this.setFocus();
    }
    getItems() {
        return Array.from(this.el.querySelectorAll("calcite-segmented-control-item"));
    }
    selectItem(selected, emit = false) {
        if (selected === this.selectedItem) {
            return;
        }
        const items = this.getItems();
        let match = null;
        items.forEach((item) => {
            const matches = item === selected;
            if ((matches && !item.checked) || (!matches && item.checked)) {
                item.checked = matches;
            }
            item.tabIndex = matches ? 0 : -1;
            if (matches) {
                match = item;
                if (emit) {
                    this.calciteSegmentedControlChange.emit();
                }
            }
        });
        this.selectedItem = match;
    }
    setUpItems() {
        const items = this.getItems();
        const lastChecked = items.filter((item) => item.checked).pop();
        if (lastChecked) {
            this.selectItem(lastChecked);
        }
        else if (items[0]) {
            items[0].tabIndex = 0;
        }
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "appearance": ["handlePropsChange"],
        "layout": ["handlePropsChange"],
        "scale": ["handlePropsChange"],
        "value": ["valueHandler"],
        "selectedItem": ["handleSelectedItemChange"]
    }; }
    static get style() { return segmentedControlCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-segmented-control",
        "$members$": {
            "appearance": [513],
            "disabled": [516],
            "form": [513],
            "required": [516],
            "name": [513],
            "layout": [513],
            "scale": [513],
            "value": [1025],
            "selectedItem": [1040],
            "status": [513],
            "validationMessage": [1, "validation-message"],
            "validationIcon": [520, "validation-icon"],
            "width": [513],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteInternalSegmentedControlItemChange", "handleSelected"], [0, "keydown", "handleKeyDown"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["appearance", "appearance"], ["disabled", "disabled"], ["form", "form"], ["required", "required"], ["name", "name"], ["layout", "layout"], ["scale", "scale"], ["status", "status"], ["validationIcon", "validation-icon"], ["width", "width"]]
    }; }
}

const SLOTS$a = {
    input: "input",
};
const CSS$t = {
    segmentedControlItemIcon: "segmented-control-item-icon",
};

const segmentedControlItemCss = "/*!@:host*/.sc-calcite-segmented-control-item-h{display:flex;cursor:pointer;align-self:stretch;font-weight:var(--calcite-font-weight-normal);transition:background-color var(--calcite-internal-animation-timing-fast) ease-in-out, border-color var(--calcite-animation-timing) ease-in-out}/*!@:host label*/.sc-calcite-segmented-control-item-h label.sc-calcite-segmented-control-item{pointer-events:none;margin:0.125rem;box-sizing:border-box;display:flex;flex:1 1 0%;align-items:center;color:var(--calcite-color-text-3);transition:background-color var(--calcite-internal-animation-timing-fast) ease-in-out, border-color var(--calcite-internal-animation-timing-fast) ease-in-out, color var(--calcite-internal-animation-timing-fast) ease-in-out}/*!@.label--horizontal*/.label--horizontal.sc-calcite-segmented-control-item{justify-content:center}/*!@:host*/.sc-calcite-segmented-control-item-h{outline-color:transparent}/*!@:host(:focus)*/.sc-calcite-segmented-control-item-h:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          );outline-offset:-1px}/*!@.label--scale-s*/.label--scale-s.sc-calcite-segmented-control-item{padding-inline:0.5rem;font-size:var(--calcite-font-size--2);line-height:1rem;padding-block:0.125rem}/*!@.label--scale-m*/.label--scale-m.sc-calcite-segmented-control-item{padding-inline:0.75rem;font-size:var(--calcite-font-size--1);line-height:1rem;padding-block:0.375rem}/*!@.label--scale-l*/.label--scale-l.sc-calcite-segmented-control-item{padding-inline:1rem;padding-block:0.625rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host(:hover) label*/.sc-calcite-segmented-control-item-h:hover label.sc-calcite-segmented-control-item{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-text-1)}/*!@:host(:active) label*/.sc-calcite-segmented-control-item-h:active label.sc-calcite-segmented-control-item{background-color:var(--calcite-color-foreground-3)}/*!@:host([checked]) label*/[checked].sc-calcite-segmented-control-item-h label.sc-calcite-segmented-control-item{cursor:default;border-color:var(--calcite-color-brand);background-color:var(--calcite-color-brand);color:var(--calcite-color-text-inverse)}/*!@:host([checked]) .label--outline,\n:host([checked]) .label--outline-fill*/[checked].sc-calcite-segmented-control-item-h .label--outline.sc-calcite-segmented-control-item,[checked].sc-calcite-segmented-control-item-h .label--outline-fill.sc-calcite-segmented-control-item{border-color:var(--calcite-color-brand);background-color:var(--calcite-color-foreground-1);box-shadow:inset 0 0 0 1px var(--calcite-color-brand);color:var(--calcite-color-brand)}/*!@:host([checked]) .label--outline*/[checked].sc-calcite-segmented-control-item-h .label--outline.sc-calcite-segmented-control-item{background-color:transparent}/*!@::slotted(input)*/.sc-calcite-segmented-control-item-s>input{display:none}@media (forced-colors: active){/*!@:host([checked]) label*/[checked].sc-calcite-segmented-control-item-h label.sc-calcite-segmented-control-item{background-color:highlight}/*!@:host([checked]) .label--outline,\n  :host([checked]) .label--outline-fill*/[checked].sc-calcite-segmented-control-item-h .label--outline.sc-calcite-segmented-control-item,[checked].sc-calcite-segmented-control-item-h .label--outline-fill.sc-calcite-segmented-control-item{outline:2px solid transparent;outline-offset:2px}/*!@:host([checked]) label:not([class~=label--outline]) .segmented-control-item-icon*/[checked].sc-calcite-segmented-control-item-h label.sc-calcite-segmented-control-item:not([class~=label--outline]) .segmented-control-item-icon.sc-calcite-segmented-control-item{color:highlightText}}/*!@.segmented-control-item-icon*/.segmented-control-item-icon.sc-calcite-segmented-control-item{position:relative;margin:0px;display:inline-flex;line-height:inherit}/*!@:host([icon-start]) .label--scale-s .segmented-control-item-icon*/[icon-start].sc-calcite-segmented-control-item-h .label--scale-s.sc-calcite-segmented-control-item .segmented-control-item-icon.sc-calcite-segmented-control-item{margin-inline-end:0.5rem}/*!@:host([icon-end]) .label--scale-s .segmented-control-item-icon*/[icon-end].sc-calcite-segmented-control-item-h .label--scale-s.sc-calcite-segmented-control-item .segmented-control-item-icon.sc-calcite-segmented-control-item{margin-inline-start:0.5rem}/*!@:host([icon-start]) .label--scale-m .segmented-control-item-icon*/[icon-start].sc-calcite-segmented-control-item-h .label--scale-m.sc-calcite-segmented-control-item .segmented-control-item-icon.sc-calcite-segmented-control-item{margin-inline-end:0.75rem}/*!@:host([icon-end]) .label--scale-m .segmented-control-item-icon*/[icon-end].sc-calcite-segmented-control-item-h .label--scale-m.sc-calcite-segmented-control-item .segmented-control-item-icon.sc-calcite-segmented-control-item{margin-inline-start:0.75rem}/*!@:host([icon-start]) .label--scale-l .segmented-control-item-icon*/[icon-start].sc-calcite-segmented-control-item-h .label--scale-l.sc-calcite-segmented-control-item .segmented-control-item-icon.sc-calcite-segmented-control-item{margin-inline-end:1rem}/*!@:host([icon-end]) .label--scale-l .segmented-control-item-icon*/[icon-end].sc-calcite-segmented-control-item-h .label--scale-l.sc-calcite-segmented-control-item .segmented-control-item-icon.sc-calcite-segmented-control-item{margin-inline-start:1rem}/*!@:host([hidden])*/[hidden].sc-calcite-segmented-control-item-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-segmented-control-item{display:none}";

class SegmentedControlItem {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalSegmentedControlItemChange = createEvent(this, "calciteInternalSegmentedControlItemChange", 6);
        this.checked = false;
        this.iconFlipRtl = false;
        this.iconStart = undefined;
        this.iconEnd = undefined;
        this.value = undefined;
        this.appearance = "solid";
        this.layout = "horizontal";
        this.scale = "m";
    }
    handleCheckedChange() {
        this.calciteInternalSegmentedControlItemChange.emit();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    render() {
        const { appearance, checked, layout, scale, value } = this;
        const iconStartEl = this.iconStart ? (hAsync("calcite-icon", { class: CSS$t.segmentedControlItemIcon, flipRtl: this.iconFlipRtl, icon: this.iconStart, key: "icon-start", scale: "s" })) : null;
        const iconEndEl = this.iconEnd ? (hAsync("calcite-icon", { class: CSS$t.segmentedControlItemIcon, flipRtl: this.iconFlipRtl, icon: this.iconEnd, key: "icon-end", scale: "s" })) : null;
        return (hAsync(Host, { "aria-checked": toAriaBoolean(checked), "aria-label": value, role: "radio" }, hAsync("label", { class: {
                "label--scale-s": scale === "s",
                "label--scale-m": scale === "m",
                "label--scale-l": scale === "l",
                "label--horizontal": layout === "horizontal",
                "label--outline": appearance === "outline",
                "label--outline-fill": appearance === "outline-fill",
            } }, this.iconStart ? iconStartEl : null, hAsync("slot", null, value), hAsync("slot", { name: SLOTS$a.input }), this.iconEnd ? iconEndEl : null)));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "checked": ["handleCheckedChange"]
    }; }
    static get style() { return segmentedControlItemCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-segmented-control-item",
        "$members$": {
            "checked": [1540],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "iconStart": [513, "icon-start"],
            "iconEnd": [513, "icon-end"],
            "value": [1032],
            "appearance": [1],
            "layout": [1],
            "scale": [1]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["checked", "checked"], ["iconFlipRtl", "icon-flip-rtl"], ["iconStart", "icon-start"], ["iconEnd", "icon-end"]]
    }; }
}

const CSS$s = {
    icon: "icon",
    iconContainer: "icon-container",
    select: "select",
    wrapper: "wrapper",
};

const selectCss = "/*!@:host*/.sc-calcite-select-h{--calcite-icon-size:1rem;--calcite-spacing-eighth:0.125rem;--calcite-spacing-quarter:0.25rem;--calcite-spacing-half:0.5rem;--calcite-spacing-three-quarters:0.75rem;--calcite-spacing:1rem;--calcite-spacing-plus-quarter:1.25rem;--calcite-spacing-plus-half:1.5rem;--calcite-spacing-double:2rem;--calcite-menu-min-width:10rem;--calcite-header-min-height:3rem;--calcite-footer-min-height:3rem}/*!@:host([disabled])*/[disabled].sc-calcite-select-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-select-h *.sc-calcite-select,.sc-calcite-select-h[disabled].sc-calcite-select-s>*,.sc-calcite-select-h[disabled] .sc-calcite-select-s>*{pointer-events:none}/*!@:host*/.sc-calcite-select-h{display:flex;flex-direction:column}/*!@.wrapper*/.wrapper.sc-calcite-select{position:relative;display:flex;align-items:stretch;inline-size:var(--select-width)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-select-h[disabled] .sc-calcite-select-s>[calcite-hydrated][disabled],[disabled].sc-calcite-select-h [calcite-hydrated][disabled].sc-calcite-select{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-select{display:contents}/*!@:host([scale=s])*/[scale=s].sc-calcite-select-h{--calcite-select-font-size:var(--calcite-font-size--2);--calcite-select-spacing-inline:0.5rem 2rem}/*!@:host([scale=s]) .wrapper*/[scale=s].sc-calcite-select-h .wrapper.sc-calcite-select{block-size:1.5rem}/*!@:host([scale=s]) .icon-container*/[scale=s].sc-calcite-select-h .icon-container.sc-calcite-select{padding-inline:0.5rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-select-h{--calcite-select-font-size:var(--calcite-font-size--1);--calcite-select-spacing-inline:0.75rem 2.5rem}/*!@:host([scale=m]) .wrapper*/[scale=m].sc-calcite-select-h .wrapper.sc-calcite-select{block-size:2rem}/*!@:host([scale=m]) .icon-container*/[scale=m].sc-calcite-select-h .icon-container.sc-calcite-select{padding-inline:0.75rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-select-h{--calcite-select-font-size:var(--calcite-font-size-0);--calcite-select-spacing-inline:1rem 3rem}/*!@:host([scale=l]) .wrapper*/[scale=l].sc-calcite-select-h .wrapper.sc-calcite-select{block-size:44px}/*!@:host([scale=l]) .icon-container*/[scale=l].sc-calcite-select-h .icon-container.sc-calcite-select{padding-inline:1rem}/*!@:host([width=auto])*/[width=auto].sc-calcite-select-h{inline-size:auto}/*!@:host([width=half])*/[width=half].sc-calcite-select-h{inline-size:50%}/*!@:host([width=full])*/[width=full].sc-calcite-select-h{inline-size:100%}/*!@.select*/.select.sc-calcite-select{margin:0px;box-sizing:border-box;inline-size:100%;cursor:pointer;appearance:none;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;border-radius:0px;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-foreground-1);font-family:inherit;color:var(--calcite-color-text-2);outline-color:transparent;font-size:var(--calcite-select-font-size);padding-inline:var(--calcite-select-spacing-inline);border-inline-end-width:0px}/*!@.select:focus*/.select.sc-calcite-select:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.select:hover*/.select.sc-calcite-select:hover{background-color:var(--calcite-color-foreground-2)}/*!@select:disabled*/select.sc-calcite-select:disabled{border-color:var(--calcite-color-border-input);--tw-bg-opacity:1}/*!@.icon-container*/.icon-container.sc-calcite-select{pointer-events:none;position:absolute;inset-block:0px;display:flex;align-items:center;border-width:0px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:transparent;color:var(--calcite-color-text-2);inset-inline-end:0px;border-inline-width:0px 1px}/*!@:host([status=invalid]) select,\n:host([status=invalid]) .icon-container*/[status=invalid].sc-calcite-select-h select.sc-calcite-select,[status=invalid].sc-calcite-select-h .icon-container.sc-calcite-select{border-color:var(--calcite-color-status-danger)}/*!@:host([status=invalid]) select:focus,\n:host([status=invalid]) .icon-container:focus*/[status=invalid].sc-calcite-select-h select.sc-calcite-select:focus,[status=invalid].sc-calcite-select-h .icon-container.sc-calcite-select:focus{outline:2px solid var(--calcite-color-status-danger);outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.select:focus ~ .icon-container*/.select.sc-calcite-select:focus~.icon-container.sc-calcite-select{border-color:transparent}/*!@.validation-container*/.validation-container.sc-calcite-select{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}/*!@:host([scale=m]) .validation-container,\n:host([scale=l]) .validation-container*/[scale=m].sc-calcite-select-h .validation-container.sc-calcite-select,[scale=l].sc-calcite-select-h .validation-container.sc-calcite-select{padding-block-start:0.5rem}/*!@:host([scale=s]) .validation-container*/[scale=s].sc-calcite-select-h .validation-container.sc-calcite-select{padding-block-start:0.25rem}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-select-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([hidden])*/[hidden].sc-calcite-select-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-select{display:none}";

function isOption(optionOrGroup) {
    return optionOrGroup.tagName === "CALCITE-OPTION";
}
function isOptionGroup(optionOrGroup) {
    return optionOrGroup.tagName === "CALCITE-OPTION-GROUP";
}
/**
 * @slot - A slot for adding `calcite-option`s.
 */
class Select {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteSelectChange = createEvent(this, "calciteSelectChange", 6);
        this.componentToNativeEl = new Map();
        this.mutationObserver = createObserver();
        this.handleInternalSelectChange = () => {
            const selected = this.selectEl.selectedOptions[0];
            this.selectFromNativeOption(selected);
            requestAnimationFrame(() => this.emitChangeEvent());
        };
        this.populateInternalSelect = () => {
            const optionsAndGroups = Array.from(this.el.children).filter((child) => child.tagName === "CALCITE-OPTION" || child.tagName === "CALCITE-OPTION-GROUP");
            this.clearInternalSelect();
            optionsAndGroups.forEach((optionOrGroup) => this.selectEl?.append(this.toNativeElement(optionOrGroup)));
        };
        this.storeSelectRef = (node) => {
            this.selectEl = node;
            this.populateInternalSelect();
            const selected = this.selectEl.selectedOptions[0];
            this.selectFromNativeOption(selected);
        };
        this.emitChangeEvent = () => {
            this.calciteSelectChange.emit();
        };
        this.disabled = false;
        this.form = undefined;
        this.label = undefined;
        this.validationMessage = undefined;
        this.validationIcon = undefined;
        this.name = undefined;
        this.required = false;
        this.scale = "m";
        this.status = "idle";
        this.value = null;
        this.selectedOption = undefined;
        this.width = "auto";
    }
    valueHandler(value) {
        const items = this.el.querySelectorAll("calcite-option");
        items.forEach((item) => (item.selected = item.value === value));
    }
    selectedOptionHandler(selectedOption) {
        this.value = selectedOption?.value;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        const { el } = this;
        this.mutationObserver?.observe(el, {
            subtree: true,
            childList: true,
        });
        connectInteractive(this);
        connectLabel(this);
        connectForm(this);
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
        afterConnectDefaultValueSet(this, this.selectedOption?.value ?? "");
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        focusElement(this.selectEl);
    }
    handleOptionOrGroupChange(event) {
        event.stopPropagation();
        const optionOrGroup = event.target;
        const nativeEl = this.componentToNativeEl.get(optionOrGroup);
        if (!nativeEl) {
            return;
        }
        this.updateNativeElement(optionOrGroup, nativeEl);
        if (isOption(optionOrGroup) && optionOrGroup.selected) {
            this.deselectAllExcept(optionOrGroup);
            this.selectedOption = optionOrGroup;
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    onLabelClick() {
        this.setFocus();
    }
    updateNativeElement(optionOrGroup, nativeOptionOrGroup) {
        nativeOptionOrGroup.disabled = optionOrGroup.disabled;
        nativeOptionOrGroup.label = optionOrGroup.label;
        if (isOption(optionOrGroup)) {
            const option = nativeOptionOrGroup;
            option.selected = optionOrGroup.selected;
            option.value = optionOrGroup.value;
            // need to set innerText for mobile
            // see https://stackoverflow.com/questions/35021620/ios-safari-not-showing-all-options-for-select-menu/41749701
            option.innerText = optionOrGroup.label;
        }
    }
    clearInternalSelect() {
        this.componentToNativeEl.forEach((value) => value.remove());
        this.componentToNativeEl.clear();
    }
    selectFromNativeOption(nativeOption) {
        if (!nativeOption) {
            return;
        }
        let futureSelected;
        this.componentToNativeEl.forEach((nativeOptionOrGroup, optionOrGroup) => {
            if (isOption(optionOrGroup) && nativeOptionOrGroup === nativeOption) {
                optionOrGroup.selected = true;
                futureSelected = optionOrGroup;
                this.deselectAllExcept(optionOrGroup);
            }
        });
        if (futureSelected) {
            this.selectedOption = futureSelected;
        }
    }
    toNativeElement(optionOrGroup) {
        if (isOption(optionOrGroup)) {
            const option = document.createElement("option");
            this.updateNativeElement(optionOrGroup, option);
            this.componentToNativeEl.set(optionOrGroup, option);
            return option;
        }
        if (isOptionGroup(optionOrGroup)) {
            const group = document.createElement("optgroup");
            this.updateNativeElement(optionOrGroup, group);
            Array.from(optionOrGroup.children).forEach((option) => {
                const nativeOption = this.toNativeElement(option);
                group.append(nativeOption);
                this.componentToNativeEl.set(optionOrGroup, nativeOption);
            });
            this.componentToNativeEl.set(optionOrGroup, group);
            return group;
        }
        throw new Error("unsupported element child provided");
    }
    deselectAllExcept(except) {
        this.el.querySelectorAll("calcite-option").forEach((option) => {
            if (option === except) {
                return;
            }
            option.selected = false;
        });
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    renderChevron() {
        return (hAsync("div", { class: CSS$s.iconContainer }, hAsync("calcite-icon", { class: CSS$s.icon, icon: "chevron-down", scale: getIconScale(this.scale) })));
    }
    render() {
        const { disabled } = this;
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: disabled }, hAsync("div", { class: CSS$s.wrapper }, hAsync("select", { "aria-label": getLabelText(this), class: CSS$s.select, disabled: disabled, onChange: this.handleInternalSelectChange,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeSelectRef }, hAsync("slot", null)), this.renderChevron(), hAsync(HiddenFormInputSlot, { component: this })), this.validationMessage && this.status === "invalid" ? (hAsync(Validation, { icon: this.validationIcon, message: this.validationMessage, scale: this.scale, status: this.status })) : null)));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "value": ["valueHandler"],
        "selectedOption": ["selectedOptionHandler"]
    }; }
    static get style() { return selectCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-select",
        "$members$": {
            "disabled": [516],
            "form": [513],
            "label": [1],
            "validationMessage": [1, "validation-message"],
            "validationIcon": [520, "validation-icon"],
            "name": [513],
            "required": [516],
            "scale": [513],
            "status": [513],
            "value": [1025],
            "selectedOption": [1040],
            "width": [513],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteInternalOptionChange", "handleOptionOrGroupChange"], [0, "calciteInternalOptionGroupChange", "handleOptionOrGroupChange"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["form", "form"], ["validationIcon", "validation-icon"], ["name", "name"], ["required", "required"], ["scale", "scale"], ["status", "status"], ["width", "width"]]
    }; }
}

const CSS$r = {
    scrim: "scrim",
    container: "container",
    containerOpen: "container--open",
    content: "content",
    containerSlottedInShell: "container--slotted-in-shell",
};

const sheetCss = "/*!@:host*/.sc-calcite-sheet-h{position:absolute;inset:0px;z-index:var(--calcite-z-index-overlay);display:flex;visibility:hidden !important;--calcite-sheet-scrim-background-internal:rgba(0, 0, 0, 0.85);--calcite-scrim-shadow-block-start-internal:0 4px 8px -1px rgba(0, 0, 0, 0.08), 0 2px 4px -1px rgba(0, 0, 0, 0.04);--calcite-scrim-shadow-block-end-internal:0 -4px 8px -1px rgba(0, 0, 0, 0.08), 0 -2px 4px -1px rgba(0, 0, 0, 0.04);--calcite-scrim-shadow-inline-start-internal:4px 0 8px -1px rgba(0, 0, 0, 0.08), 2px 0 4px -1px rgba(0, 0, 0, 0.04);--calcite-scrim-shadow-inline-end-internal:-4px 0 8px -1px rgba(0, 0, 0, 0.08), -2px 0 4px -1px rgba(0, 0, 0, 0.04)}/*!@.calcite--rtl*/.calcite--rtl.sc-calcite-sheet{--calcite-scrim-shadow-inline-start-internal:-4px 0 8px -1px rgba(0, 0, 0, 0.08), -2px 0 4px -1px rgba(0, 0, 0, 0.04);--calcite-scrim-shadow-inline-end-internal:4px 0 8px -1px rgba(0, 0, 0, 0.08), 2px 0 4px -1px rgba(0, 0, 0, 0.04)}/*!@.container*/.container.sc-calcite-sheet{visibility:hidden;position:fixed;z-index:var(--calcite-z-index-overlay);display:flex;overflow-y:hidden;color:var(--calcite-color-text-2);opacity:0;transition:visibility 0ms linear var(--calcite-internal-animation-timing-medium), opacity var(--calcite-internal-animation-timing-medium) cubic-bezier(0.215, 0.44, 0.42, 0.88)}/*!@:host([position=inline-start]) .container*/[position=inline-start].sc-calcite-sheet-h .container.sc-calcite-sheet{justify-content:flex-start;inset-block:0;inset-inline:0 auto;--calcite-sheet-hidden-position-internal:translate3d(-1rem, 0, 0)}/*!@:host([position=inline-end]) .container*/[position=inline-end].sc-calcite-sheet-h .container.sc-calcite-sheet{justify-content:flex-end;inset-block:0;inset-inline:auto 0;--calcite-sheet-hidden-position-internal:translate3d(1rem, 0, 0)}/*!@:host([position=block-start]) .container*/[position=block-start].sc-calcite-sheet-h .container.sc-calcite-sheet{align-items:flex-start;inset-block:0 auto;inset-inline:0;--calcite-sheet-hidden-position-internal:translate3d(0, -1rem, 0)}/*!@:host([position=block-end]) .container*/[position=block-end].sc-calcite-sheet-h .container.sc-calcite-sheet{align-items:flex-end;inset-block:auto 0;inset-inline:0;--calcite-sheet-hidden-position-internal:translate3d(0, 1rem, 0)}/*!@:host([display-mode=float]) .content*/[display-mode=float].sc-calcite-sheet-h .content.sc-calcite-sheet{--tw-shadow:0 2px 12px -4px rgba(0, 0, 0, 0.2), 0 2px 4px -2px rgba(0, 0, 0, 0.16);--tw-shadow-colored:0 2px 12px -4px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@:host([display-mode=overlay][position=inline-start]) .container*/[display-mode=overlay][position=inline-start].sc-calcite-sheet-h .container.sc-calcite-sheet{box-shadow:var(--calcite-scrim-shadow-inline-start-internal)}/*!@:host([display-mode=overlay][position=inline-end]) .container*/[display-mode=overlay][position=inline-end].sc-calcite-sheet-h .container.sc-calcite-sheet{box-shadow:var(--calcite-scrim-shadow-inline-end-internal)}/*!@:host([display-mode=overlay][position=block-start]) .container*/[display-mode=overlay][position=block-start].sc-calcite-sheet-h .container.sc-calcite-sheet{box-shadow:var(--calcite-scrim-shadow-block-start-internal)}/*!@:host([display-mode=overlay][position=block-end]) .container*/[display-mode=overlay][position=block-end].sc-calcite-sheet-h .container.sc-calcite-sheet{box-shadow:var(--calcite-scrim-shadow-block-end-internal)}/*!@:host([position^=inline]) .container,\n:host([position^=inline]) .content*/[position^=inline].sc-calcite-sheet-h .container.sc-calcite-sheet,[position^=inline].sc-calcite-sheet-h .content.sc-calcite-sheet{inline-size:var(--calcite-sheet-width-internal);max-inline-size:var(--calcite-sheet-max-width-internal);min-inline-size:var(--calcite-sheet-min-width-internal)}/*!@:host([position^=block]) .container,\n:host([position^=block]) .content*/[position^=block].sc-calcite-sheet-h .container.sc-calcite-sheet,[position^=block].sc-calcite-sheet-h .content.sc-calcite-sheet{block-size:var(--calcite-sheet-height-internal);max-block-size:var(--calcite-sheet-max-height-internal);min-block-size:var(--calcite-sheet-min-height-internal)}/*!@:host([display-mode=float][position^=inline]) .container*/[display-mode=float][position^=inline].sc-calcite-sheet-h .container.sc-calcite-sheet{block-size:calc(100% - 1.5rem);max-block-size:calc(100% - 1.5rem);min-block-size:calc(100% - 1.5rem)}/*!@:host([display-mode=float][position^=block]) .container*/[display-mode=float][position^=block].sc-calcite-sheet-h .container.sc-calcite-sheet{inline-size:calc(100% - 1.5rem);max-inline-size:calc(100% - 1.5rem);min-inline-size:calc(100% - 1.5rem)}/*!@:host([position^=inline][width-scale=s])*/[position^=inline][width-scale=s].sc-calcite-sheet-h{--calcite-sheet-width-internal:var(--calcite-sheet-width, 15vw);--calcite-sheet-max-width-internal:var(--calcite-sheet-max-width, 360px);--calcite-sheet-min-width-internal:var(--calcite-sheet-min-width, 260px)}/*!@:host([position^=inline][width-scale=m])*/[position^=inline][width-scale=m].sc-calcite-sheet-h{--calcite-sheet-width-internal:var(--calcite-sheet-width, 25vw);--calcite-sheet-max-width-internal:var(--calcite-sheet-max-width, 420px);--calcite-sheet-min-width-internal:var(--calcite-sheet-min-width, 300px)}/*!@:host([position^=inline][width-scale=l])*/[position^=inline][width-scale=l].sc-calcite-sheet-h{--calcite-sheet-width-internal:var(--calcite-sheet-width, 45vw);--calcite-sheet-max-width-internal:var(--calcite-sheet-max-width, 680px);--calcite-sheet-min-width-internal:var(--calcite-sheet-min-width, 340px)}/*!@:host([position^=block][height-scale=s])*/[position^=block][height-scale=s].sc-calcite-sheet-h{--calcite-sheet-min-height-internal:var(--calcite-sheet-min-height, 160px);--calcite-sheet-height-internal:var(--calcite-sheet-height, 30vh);--calcite-sheet-max-height-internal:var(--calcite-sheet-max-height, 30vh)}/*!@:host([position^=block][height-scale=m])*/[position^=block][height-scale=m].sc-calcite-sheet-h{--calcite-sheet-min-height-internal:var(--calcite-sheet-min-height, 200px);--calcite-sheet-height-internal:var(--calcite-sheet-height, 45vh);--calcite-sheet-max-height-internal:var(--calcite-sheet-max-height, 50vh)}/*!@:host([position^=block][height-scale=l])*/[position^=block][height-scale=l].sc-calcite-sheet-h{--calcite-sheet-min-height-internal:var(--calcite-sheet-min-height, 240px);--calcite-sheet-height-internal:var(--calcite-sheet-height, 60vh);--calcite-sheet-max-height-internal:var(--calcite-sheet-max-height, 70vh)}/*!@.scrim*/.scrim.sc-calcite-sheet{--calcite-scrim-background:var(--calcite-sheet-scrim-background, var(--calcite-sheet-scrim-background-internal));position:fixed;inset:0px;display:flex;overflow-y:hidden}/*!@:host([opened])*/[opened].sc-calcite-sheet-h{visibility:visible !important}/*!@.content*/.content.sc-calcite-sheet{position:relative;z-index:var(--calcite-z-index-modal);box-sizing:border-box;display:block;max-block-size:100%;max-inline-size:100%;overflow-y:hidden;padding:0px;background-color:var(--calcite-color-foreground-1);max-block-size:100%;visibility:hidden;transition:transform var(--calcite-internal-animation-timing-medium) cubic-bezier(0.215, 0.44, 0.42, 0.88), visibility 0ms linear var(--calcite-internal-animation-timing-medium), opacity var(--calcite-internal-animation-timing-medium) cubic-bezier(0.215, 0.44, 0.42, 0.88);transform:var(--calcite-sheet-hidden-position-internal)}/*!@.container--open .content*/.container--open.sc-calcite-sheet .content.sc-calcite-sheet{transform:translate3d(0, 0, 0)}/*!@:host([display-mode=float]) .content,\n:host([display-mode=float]) .container*/[display-mode=float].sc-calcite-sheet-h .content.sc-calcite-sheet,[display-mode=float].sc-calcite-sheet-h .container.sc-calcite-sheet{border-radius:0.25rem}/*!@:host([display-mode=float]) .container*/[display-mode=float].sc-calcite-sheet-h .container.sc-calcite-sheet{padding:0.75rem}/*!@.container--open*/.container--open.sc-calcite-sheet{visibility:visible;opacity:1;transition-delay:0ms}/*!@.container--open .content*/.container--open.sc-calcite-sheet .content.sc-calcite-sheet{pointer-events:auto;visibility:visible;opacity:1;transition:transform var(--calcite-internal-animation-timing-medium) cubic-bezier(0.215, 0.44, 0.42, 0.88), visibility 0ms linear, opacity var(--calcite-internal-animation-timing-medium) cubic-bezier(0.215, 0.44, 0.42, 0.88), max-inline-size var(--calcite-internal-animation-timing-medium) cubic-bezier(0.215, 0.44, 0.42, 0.88), max-block-size var(--calcite-internal-animation-timing-medium) cubic-bezier(0.215, 0.44, 0.42, 0.88);transition-delay:0ms}/*!@:host([position=inline-start]) .content,\n:host([position=inline-end]) .content*/[position=inline-start].sc-calcite-sheet-h .content.sc-calcite-sheet,[position=inline-end].sc-calcite-sheet-h .content.sc-calcite-sheet{block-size:100%}/*!@:host([position=block-start]) .content,\n:host([position=block-end]) .content*/[position=block-start].sc-calcite-sheet-h .content.sc-calcite-sheet,[position=block-end].sc-calcite-sheet-h .content.sc-calcite-sheet{inline-size:100%}/*!@:host([position]) .container--slotted-in-shell*/[position].sc-calcite-sheet-h .container--slotted-in-shell.sc-calcite-sheet{pointer-events:auto;position:absolute;inline-size:100%;max-inline-size:100%;min-inline-size:100%;block-size:100%;max-block-size:100%;min-block-size:100%}/*!@:host([position]) .container--slotted-in-shell calcite-scrim*/[position].sc-calcite-sheet-h .container--slotted-in-shell.sc-calcite-sheet calcite-scrim.sc-calcite-sheet{position:absolute}/*!@:host([hidden])*/[hidden].sc-calcite-sheet-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-sheet{display:none}";

class Sheet {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteSheetBeforeClose = createEvent(this, "calciteSheetBeforeClose", 6);
        this.calciteSheetClose = createEvent(this, "calciteSheetClose", 6);
        this.calciteSheetBeforeOpen = createEvent(this, "calciteSheetBeforeOpen", 6);
        this.calciteSheetOpen = createEvent(this, "calciteSheetOpen", 6);
        //--------------------------------------------------------------------------
        //
        //  Private Properties/ State
        //
        //--------------------------------------------------------------------------
        this.openTransitionProp = "opacity";
        this.ignoreOpenChange = false;
        this.mutationObserver = createObserver();
        this.setTransitionEl = (el) => {
            this.transitionEl = el;
            this.contentId = ensureId(el);
        };
        this.openEnd = () => {
            this.setFocus();
            this.el.removeEventListener("calciteSheetOpen", this.openEnd);
        };
        this.handleOutsideClose = () => {
            if (this.outsideCloseDisabled) {
                return;
            }
            this.open = false;
        };
        this.closeSheet = async () => {
            if (this.beforeClose) {
                try {
                    await this.beforeClose(this.el);
                }
                catch (_error) {
                    // close prevented
                    requestAnimationFrame(() => {
                        this.ignoreOpenChange = true;
                        this.open = true;
                        this.ignoreOpenChange = false;
                    });
                    return;
                }
            }
            this.opened = false;
            this.removeOverflowHiddenClass();
        };
        this.beforeClose = undefined;
        this.displayMode = "overlay";
        this.escapeDisabled = false;
        this.heightScale = "m";
        this.focusTrapDisabled = false;
        this.label = undefined;
        this.open = false;
        this.opened = false;
        this.outsideCloseDisabled = false;
        this.position = "inline-start";
        this.slottedInShell = undefined;
        this.widthScale = "m";
    }
    handleFocusTrapDisabled(focusTrapDisabled) {
        if (!this.open) {
            return;
        }
        focusTrapDisabled ? deactivateFocusTrap(this) : activateFocusTrap(this);
    }
    toggleSheet(value) {
        if (this.ignoreOpenChange) {
            return;
        }
        if (value) {
            this.openSheet();
        }
        else {
            this.closeSheet();
        }
    }
    handleOpenedChange() {
        onToggleOpenCloseComponent(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        setUpLoadableComponent(this);
        // when sheet initially renders, if active was set we need to open as watcher doesn't fire
        if (this.open) {
            requestAnimationFrame(() => this.openSheet());
        }
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    connectedCallback() {
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
        connectFocusTrap(this);
    }
    disconnectedCallback() {
        this.removeOverflowHiddenClass();
        this.mutationObserver?.disconnect();
        deactivateFocusTrap(this);
        this.slottedInShell = false;
    }
    render() {
        const dir = getElementDir(this.el);
        return (hAsync(Host, { "aria-describedby": this.contentId, "aria-label": this.label, "aria-modal": "true", role: "dialog" }, hAsync("div", { class: {
                [CSS$r.container]: true,
                [CSS$r.containerOpen]: this.opened,
                [CSS$r.containerSlottedInShell]: this.slottedInShell,
                [CSS_UTILITY.rtl]: dir === "rtl",
            } }, hAsync("calcite-scrim", { class: CSS$r.scrim, onClick: this.handleOutsideClose }), hAsync("div", { class: {
                [CSS$r.content]: true,
            },
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setTransitionEl }, hAsync("slot", null)))));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    handleEscape(event) {
        if (this.open && !this.escapeDisabled && event.key === "Escape" && !event.defaultPrevented) {
            this.open = false;
            event.preventDefault();
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Sets focus on the component's "close" button - the first focusable item.
     *
     */
    async setFocus() {
        await componentFocusable(this);
        focusFirstTabbable(this.el);
    }
    /**
     * Updates the element(s) that are used within the focus-trap of the component.
     */
    async updateFocusTrapElements() {
        updateFocusTrapElements(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    onBeforeOpen() {
        this.calciteSheetBeforeOpen.emit();
    }
    onOpen() {
        this.calciteSheetOpen.emit();
        activateFocusTrap(this);
    }
    onBeforeClose() {
        this.calciteSheetBeforeClose.emit();
    }
    onClose() {
        this.calciteSheetClose.emit();
        deactivateFocusTrap(this);
    }
    openSheet() {
        this.el.addEventListener("calciteSheetOpen", this.openEnd);
        this.opened = true;
        if (!this.slottedInShell) {
            this.initialOverflowCSS = document.documentElement.style.overflow;
            // use an inline style instead of a utility class to avoid global class declarations.
            document.documentElement.style.setProperty("overflow", "hidden");
        }
    }
    removeOverflowHiddenClass() {
        document.documentElement.style.setProperty("overflow", this.initialOverflowCSS);
    }
    handleMutationObserver() {
        this.updateFocusTrapElements();
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "focusTrapDisabled": ["handleFocusTrapDisabled"],
        "open": ["toggleSheet"],
        "opened": ["handleOpenedChange"]
    }; }
    static get style() { return sheetCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-sheet",
        "$members$": {
            "beforeClose": [16],
            "displayMode": [513, "display-mode"],
            "escapeDisabled": [516, "escape-disabled"],
            "heightScale": [513, "height-scale"],
            "focusTrapDisabled": [516, "focus-trap-disabled"],
            "label": [1],
            "open": [1540],
            "opened": [1540],
            "outsideCloseDisabled": [516, "outside-close-disabled"],
            "position": [513],
            "slottedInShell": [4, "slotted-in-shell"],
            "widthScale": [513, "width-scale"],
            "setFocus": [64],
            "updateFocusTrapElements": [64]
        },
        "$listeners$": [[8, "keydown", "handleEscape"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["displayMode", "display-mode"], ["escapeDisabled", "escape-disabled"], ["heightScale", "height-scale"], ["focusTrapDisabled", "focus-trap-disabled"], ["open", "open"], ["opened", "opened"], ["outsideCloseDisabled", "outside-close-disabled"], ["position", "position"], ["widthScale", "width-scale"]]
    }; }
}

const CSS$q = {
    main: "main",
    content: "content",
    contentBehind: "content--behind",
    contentNonInteractive: "content--non-interactive",
    footer: "footer",
    positionedSlotWrapper: "positioned-slot-wrapper",
    container: "container",
    contentBehindCenterContent: "center-content",
};
const SLOTS$9 = {
    centerRow: "center-row",
    panelStart: "panel-start",
    panelEnd: "panel-end",
    panelTop: "panel-top",
    panelBottom: "panel-bottom",
    header: "header",
    footer: "footer",
    alerts: "alerts",
    sheets: "sheets",
    modals: "modals",
};

const shellCss = "/*!@:host*/.sc-calcite-shell-h{box-sizing:border-box;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host **/.sc-calcite-shell-h *.sc-calcite-shell{box-sizing:border-box}/*!@:host*/.sc-calcite-shell-h{position:absolute;inset:0px;display:flex;block-size:100%;inline-size:100%;flex-direction:column;overflow:hidden;--calcite-shell-tip-spacing:26vw}/*!@.main*/.main.sc-calcite-shell{position:relative;display:flex;block-size:100%;inline-size:100%;flex:1 1 auto;flex-direction:row;justify-content:space-between;overflow:hidden}/*!@.content,\n.content--non-interactive*/.content.sc-calcite-shell,.content--non-interactive.sc-calcite-shell{display:flex;block-size:100%;inline-size:100%;flex-direction:column;flex-wrap:nowrap}/*!@.content*/.content.sc-calcite-shell{overflow:auto}/*!@.content ::slotted(calcite-shell-center-row),\n.content ::slotted(calcite-panel),\n.content ::slotted(calcite-flow)*/.content .sc-calcite-shell-s>calcite-shell-center-row,.content.sc-calcite-shell-s>calcite-panel,.content .sc-calcite-shell-s>calcite-panel,.content.sc-calcite-shell-s>calcite-flow,.content .sc-calcite-shell-s>calcite-flow{flex:1 1 auto;align-self:stretch;max-block-size:unset}/*!@.content--behind*/.content--behind.sc-calcite-shell{position:absolute;inset:0px;border-width:0px;z-index:calc(var(--calcite-z-index) - 1);display:initial}/*!@.content--non-interactive*/.content--non-interactive.sc-calcite-shell{pointer-events:none}/*!@::slotted(calcite-shell-center-row)*/.sc-calcite-shell-s>calcite-shell-center-row{inline-size:unset}/*!@::slotted(.header .heading)*/.sc-calcite-shell-s>.header .heading{font-size:var(--calcite-font-size--2);line-height:1.375;font-weight:var(--calcite-font-weight-normal)}/*!@slot[name=panel-end]::slotted(calcite-shell-panel)*/slot[name=panel-end].sc-calcite-shell-s>calcite-shell-panel{margin-inline-start:auto}/*!@::slotted(calcite-panel),\n::slotted(calcite-flow)*/.sc-calcite-shell-s>calcite-panel,.sc-calcite-shell-s>calcite-flow{border-width:1px;border-inline-start-width:0px;border-inline-end-width:0px;border-style:solid;border-color:var(--calcite-color-border-3)}/*!@slot[name=center-row]::slotted(calcite-shell-center-row:not([detached])),\nslot[name=panel-top]::slotted(calcite-shell-center-row:not([detached])),\nslot[name=panel-bottom]::slotted(calcite-shell-center-row:not([detached]))*/slot[name=center-row].sc-calcite-shell-s>calcite-shell-center-row:not([detached]),slot[name=panel-top].sc-calcite-shell-s>calcite-shell-center-row:not([detached]),slot[name=panel-bottom].sc-calcite-shell-s>calcite-shell-center-row:not([detached]){border-inline-start-width:1px;border-inline-end-width:1px;border-color:var(--calcite-color-border-3)}/*!@.center-content*/.center-content.sc-calcite-shell{display:flex;flex-direction:column;justify-content:space-between;block-size:100%;inline-size:100%;min-inline-size:0}/*!@::slotted(calcite-shell-center-row)*/.sc-calcite-shell-s>calcite-shell-center-row{flex:none;align-self:stretch}/*!@::slotted(calcite-tip-manager)*/.sc-calcite-shell-s>calcite-tip-manager{position:absolute;z-index:var(--calcite-z-index-toast);box-sizing:border-box}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}/*!@::slotted(calcite-tip-manager)*/.sc-calcite-shell-s>calcite-tip-manager{animation:in-up var(--calcite-internal-animation-timing-slow) ease-in-out;border-radius:0.25rem;--tw-shadow:0 6px 20px -4px rgba(0, 0, 0, 0.1), 0 4px 12px -2px rgba(0, 0, 0, 0.08);--tw-shadow-colored:0 6px 20px -4px var(--tw-shadow-color), 0 4px 12px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);inset-block-end:0.5rem;inset-inline:var(--calcite-shell-tip-spacing)}/*!@slot[name=center-row]::slotted(calcite-shell-center-row),\nslot[name=panel-bottom]::slotted(calcite-shell-center-row)*/slot[name=center-row].sc-calcite-shell-s>calcite-shell-center-row,slot[name=panel-bottom].sc-calcite-shell-s>calcite-shell-center-row{margin-block-start:auto}/*!@slot[name=panel-top]::slotted(calcite-shell-center-row)*/slot[name=panel-top].sc-calcite-shell-s>calcite-shell-center-row{margin-block-end:auto}/*!@.position-wrapper*/.position-wrapper.sc-calcite-shell{position:absolute;pointer-events:none;inset:0}/*!@:host([hidden])*/[hidden].sc-calcite-shell-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-shell{display:none}";

/**
 * @slot - A slot for adding custom content. This content will appear between any leading and trailing panels added to the component, such as a map.
 * @slot header - A slot for adding header content. This content will be positioned at the top of the component.
 * @slot footer - A slot for adding footer content. This content will be positioned at the bottom of the component.
 * @slot panel-start - A slot for adding the starting `calcite-shell-panel`.
 * @slot panel-end - A slot for adding the ending `calcite-shell-panel`.
 * @slot panel-top - A slot for adding the top `calcite-shell-center-row`.
 * @slot panel-bottom - A slot for adding the bottom `calcite-shell-center-row`.
 * @slot center-row - [Deprecated] Use the `"panel-bottom"` slot instead. A slot for adding the bottom `calcite-shell-center-row`.
 * @slot modals - A slot for adding `calcite-modal` components. When placed in this slot, the modal position will be constrained to the extent of the shell.
 * @slot alerts - A slot for adding `calcite-alert` components. When placed in this slot, the alert position will be constrained to the extent of the shell.
 * @slot sheets - A slot for adding `calcite-sheet` components. When placed in this slot, the sheet position will be constrained to the extent of the shell.
 */
class Shell {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.handleHeaderSlotChange = (event) => {
            this.hasHeader = !!slotChangeHasAssignedElement(event);
        };
        this.handleFooterSlotChange = (event) => {
            this.hasFooter = !!slotChangeHasAssignedElement(event);
        };
        this.handleAlertsSlotChange = (event) => {
            this.hasAlerts = !!slotChangeHasAssignedElement(event);
            slotChangeGetAssignedElements(event)?.map((el) => {
                if (el.nodeName === "CALCITE-ALERT") {
                    el.slottedInShell = true;
                }
            });
        };
        this.handleSheetsSlotChange = (event) => {
            this.hasSheets = !!slotChangeHasAssignedElement(event);
            slotChangeGetAssignedElements(event)?.map((el) => {
                if (el.nodeName === "CALCITE-SHEET") {
                    el.slottedInShell = true;
                }
            });
        };
        this.handleModalsSlotChange = (event) => {
            this.hasModals = !!slotChangeHasAssignedElement(event);
            slotChangeGetAssignedElements(event)?.map((el) => {
                if (el.nodeName === "CALCITE-MODAL") {
                    el.slottedInShell = true;
                }
            });
        };
        this.contentBehind = false;
        this.hasHeader = false;
        this.hasFooter = false;
        this.hasAlerts = false;
        this.hasModals = false;
        this.hasSheets = false;
        this.panelIsResizing = false;
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    handleCalciteInternalShellPanelResizeStart(event) {
        this.panelIsResizing = true;
        event.stopPropagation();
    }
    handleCalciteInternalShellPanelResizeEnd(event) {
        this.panelIsResizing = false;
        event.stopPropagation();
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectConditionalSlotComponent(this);
    }
    disconnectedCallback() {
        disconnectConditionalSlotComponent(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderHeader() {
        return (hAsync("div", { hidden: !this.hasHeader }, hAsync("slot", { key: "header", name: SLOTS$9.header, onSlotchange: this.handleHeaderSlotChange })));
    }
    renderFooter() {
        return (hAsync("div", { class: CSS$q.footer, hidden: !this.hasFooter, key: "footer" }, hAsync("slot", { name: SLOTS$9.footer, onSlotchange: this.handleFooterSlotChange })));
    }
    renderAlerts() {
        return (hAsync("div", { hidden: !this.hasAlerts }, hAsync("slot", { key: "alerts", name: SLOTS$9.alerts, onSlotchange: this.handleAlertsSlotChange })));
    }
    renderSheets() {
        return (hAsync("div", { hidden: !this.hasSheets }, hAsync("slot", { key: "sheets", name: SLOTS$9.sheets, onSlotchange: this.handleSheetsSlotChange })));
    }
    renderModals() {
        return (hAsync("div", { hidden: !this.hasModals }, hAsync("slot", { key: "modals", name: SLOTS$9.modals, onSlotchange: this.handleModalsSlotChange })));
    }
    renderContent() {
        const { panelIsResizing } = this;
        const defaultSlotNode = hAsync("slot", { key: "default-slot" });
        const defaultSlotContainerNode = panelIsResizing ? (hAsync("div", { class: CSS$q.contentNonInteractive }, defaultSlotNode)) : (defaultSlotNode);
        const deprecatedCenterRowSlotNode = (hAsync("slot", { key: "center-row-slot", name: SLOTS$9.centerRow }));
        const panelBottomSlotNode = hAsync("slot", { key: "panel-bottom-slot", name: SLOTS$9.panelBottom });
        const panelTopSlotNode = hAsync("slot", { key: "panel-top-slot", name: SLOTS$9.panelTop });
        const contentContainerKey = "content-container";
        const content = !!this.contentBehind
            ? [
                hAsync("div", { class: {
                        [CSS$q.content]: true,
                        [CSS$q.contentBehind]: true,
                    }, key: contentContainerKey }, defaultSlotContainerNode),
                hAsync("div", { class: CSS$q.contentBehindCenterContent }, panelTopSlotNode, panelBottomSlotNode, deprecatedCenterRowSlotNode),
            ]
            : [
                hAsync("div", { class: CSS$q.content, key: contentContainerKey }, panelTopSlotNode, defaultSlotContainerNode, panelBottomSlotNode, deprecatedCenterRowSlotNode),
            ];
        return content;
    }
    renderMain() {
        return (hAsync("div", { class: CSS$q.main }, hAsync("slot", { name: SLOTS$9.panelStart }), this.renderContent(), hAsync("slot", { name: SLOTS$9.panelEnd })));
    }
    renderPositionedSlots() {
        return (hAsync("div", { class: CSS$q.positionedSlotWrapper }, this.renderAlerts(), this.renderModals(), this.renderSheets()));
    }
    render() {
        return (hAsync(Fragment, null, this.renderHeader(), this.renderMain(), this.renderFooter(), this.renderPositionedSlots()));
    }
    get el() { return getElement(this); }
    static get style() { return shellCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-shell",
        "$members$": {
            "contentBehind": [516, "content-behind"],
            "hasHeader": [32],
            "hasFooter": [32],
            "hasAlerts": [32],
            "hasModals": [32],
            "hasSheets": [32],
            "panelIsResizing": [32]
        },
        "$listeners$": [[0, "calciteInternalShellPanelResizeStart", "handleCalciteInternalShellPanelResizeStart"], [0, "calciteInternalShellPanelResizeEnd", "handleCalciteInternalShellPanelResizeEnd"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["contentBehind", "content-behind"]]
    }; }
}

const CSS$p = {
    actionBarContainer: "action-bar-container",
    content: "content",
};
const SLOTS$8 = {
    actionBar: "action-bar",
};

const shellCenterRowCss = "/*!@:host*/.sc-calcite-shell-center-row-h{box-sizing:border-box;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-2);font-size:var(--calcite-font-size--1)}/*!@:host **/.sc-calcite-shell-center-row-h *.sc-calcite-shell-center-row{box-sizing:border-box}/*!@:host*/.sc-calcite-shell-center-row-h{z-index:var(--calcite-z-index);display:flex;flex:1 1 auto;overflow:hidden;background-color:transparent}/*!@.content*/.content.sc-calcite-shell-center-row{margin:0px;display:flex;block-size:100%;inline-size:100%;overflow:hidden;flex:1 0 0}/*!@.action-bar-container*/.action-bar-container.sc-calcite-shell-center-row{display:flex}/*!@:host([detached])*/[detached].sc-calcite-shell-center-row-h{margin-inline:0.5rem;margin-block:0.5rem 1.5rem}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}/*!@:host([detached])*/[detached].sc-calcite-shell-center-row-h{animation:in-up var(--calcite-internal-animation-timing-slow) ease-in-out;border-radius:0.25rem;border-width:0px;--tw-shadow:0 4px 8px -1px rgba(0, 0, 0, 0.08), 0 2px 4px -1px rgba(0, 0, 0, 0.04);--tw-shadow-colored:0 4px 8px -1px var(--tw-shadow-color), 0 2px 4px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@:host([position=end])*/[position=end].sc-calcite-shell-center-row-h{align-self:flex-end}/*!@:host([position=start])*/[position=start].sc-calcite-shell-center-row-h{align-self:flex-start}/*!@:host([height-scale=s])*/[height-scale=s].sc-calcite-shell-center-row-h{block-size:33.333333%}/*!@:host([height-scale=m])*/[height-scale=m].sc-calcite-shell-center-row-h{block-size:70%}/*!@:host([height-scale=l])*/[height-scale=l].sc-calcite-shell-center-row-h{block-size:100%}/*!@:host([height-scale=l][detached])*/[height-scale=l][detached].sc-calcite-shell-center-row-h{block-size:calc(100% - 2rem)}/*!@::slotted(calcite-panel)*/.sc-calcite-shell-center-row-s>calcite-panel{block-size:100%;inline-size:100%}/*!@::slotted(calcite-action-bar),\n::slotted(calcite-action-bar[position=end])*/.sc-calcite-shell-center-row-s>calcite-action-bar,.sc-calcite-shell-center-row-s>calcite-action-bar[position=end]{border-inline-end:1px solid;border-color:var(--calcite-color-border-3)}/*!@:host([hidden])*/[hidden].sc-calcite-shell-center-row-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-shell-center-row{display:none}";

/**
 * @slot - A slot for adding content to the `calcite-shell-panel`.
 * @slot action-bar - A slot for adding a `calcite-action-bar` to the `calcite-shell-panel`.
 */
class ShellCenterRow {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.detached = false;
        this.heightScale = "s";
        this.position = "end";
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectConditionalSlotComponent(this);
    }
    disconnectedCallback() {
        disconnectConditionalSlotComponent(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const { el } = this;
        const contentNode = (hAsync("div", { class: CSS$p.content }, hAsync("slot", null)));
        const actionBar = getSlotted(el, SLOTS$8.actionBar);
        const actionBarNode = actionBar ? (hAsync("div", { class: CSS$p.actionBarContainer, key: "action-bar" }, hAsync("slot", { name: SLOTS$8.actionBar }))) : null;
        const children = [actionBarNode, contentNode];
        if (actionBar?.position === "end") {
            children.reverse();
        }
        return hAsync(Fragment, null, children);
    }
    get el() { return getElement(this); }
    static get style() { return shellCenterRowCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-shell-center-row",
        "$members$": {
            "detached": [516],
            "heightScale": [513, "height-scale"],
            "position": [513]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["detached", "detached"], ["heightScale", "height-scale"], ["position", "position"]]
    }; }
}

const CSS$o = {
    container: "container",
    content: "content",
    contentHeader: "content__header",
    contentBody: "content__body",
    contentFloat: "content--float",
    contentOverlay: "content--overlay",
    separator: "separator",
};
const SLOTS$7 = {
    actionBar: "action-bar",
    header: "header",
};

const shellPanelCss = "/*!@:host*/.sc-calcite-shell-panel-h{pointer-events:none;position:relative;display:flex;flex:0 1 auto;align-items:stretch;z-index:var(--calcite-shell-panel-z-index, var(--calcite-z-index));--calcite-shell-panel-detached-max-height:unset;--calcite-shell-panel-max-height:unset;--calcite-shell-panel-shadow-block-start-internal:0 4px 8px -1px rgba(0, 0, 0, 0.08),\n    0 2px 4px -1px rgba(0, 0, 0, 0.04);--calcite-shell-panel-shadow-block-end-internal:0 -4px 8px -1px rgba(0, 0, 0, 0.08),\n    0 -2px 4px -1px rgba(0, 0, 0, 0.04);--calcite-shell-panel-shadow-inline-start-internal:4px 0 8px -1px rgba(0, 0, 0, 0.08),\n    2px 0 4px -1px rgba(0, 0, 0, 0.04);--calcite-shell-panel-shadow-inline-end-internal:-4px 0 8px -1px rgba(0, 0, 0, 0.08),\n    -2px 0 4px -1px rgba(0, 0, 0, 0.04)}/*!@.calcite--rtl.content--overlay*/.calcite--rtl.content--overlay.sc-calcite-shell-panel{--calcite-shell-panel-shadow-inline-start-internal:-4px 0 8px -1px rgba(0, 0, 0, 0.08),\n    -2px 0 4px -1px rgba(0, 0, 0, 0.04);--calcite-shell-panel-shadow-inline-end-internal:4px 0 8px -1px rgba(0, 0, 0, 0.08),\n    2px 0 4px -1px rgba(0, 0, 0, 0.04)}/*!@:host([layout=vertical])*/[layout=vertical].sc-calcite-shell-panel-h{z-index:var(--calcite-shell-panel-z-index, calc(var(--calcite-z-index) + 1))}/*!@:host([layout=vertical][display-mode=overlay])*/[layout=vertical][display-mode=overlay].sc-calcite-shell-panel-h{z-index:var(--calcite-shell-panel-z-index, calc(var(--calcite-z-index-header) + 1))}/*!@:host([layout=vertical][width-scale=s]) .content*/[layout=vertical][width-scale=s].sc-calcite-shell-panel-h .content.sc-calcite-shell-panel{--calcite-shell-panel-width-internal:var(--calcite-shell-panel-width, 12vw);--calcite-shell-panel-max-width-internal:var(--calcite-shell-panel-max-width, 300px);--calcite-shell-panel-min-width-internal:var(--calcite-shell-panel-min-width, 150px)}/*!@:host([layout=vertical][width-scale=m]) .content*/[layout=vertical][width-scale=m].sc-calcite-shell-panel-h .content.sc-calcite-shell-panel{--calcite-shell-panel-width-internal:var(--calcite-shell-panel-width, 20vw);--calcite-shell-panel-max-width-internal:var(--calcite-shell-panel-max-width, 420px);--calcite-shell-panel-min-width-internal:var(--calcite-shell-panel-min-width, 240px)}/*!@:host([layout=vertical][width-scale=l]) .content*/[layout=vertical][width-scale=l].sc-calcite-shell-panel-h .content.sc-calcite-shell-panel{--calcite-shell-panel-width-internal:var(--calcite-shell-panel-width, 45vw);--calcite-shell-panel-max-width-internal:var(--calcite-shell-panel-max-width, 680px);--calcite-shell-panel-min-width-internal:var(--calcite-shell-panel-min-width, 340px)}/*!@:host([layout=horizontal][height-scale=s]) .content*/[layout=horizontal][height-scale=s].sc-calcite-shell-panel-h .content.sc-calcite-shell-panel{--calcite-shell-panel-max-height-internal:var(\n    --calcite-shell-panel-max-height,\n    var(--calcite-shell-panel-detached-max-height, 20vh)\n  )}/*!@:host([layout=horizontal]) .content*/[layout=horizontal].sc-calcite-shell-panel-h .content.sc-calcite-shell-panel{--calcite-shell-panel-min-height-internal:var(--calcite-shell-panel-min-height, 5vh);--calcite-shell-panel-max-height-internal:var(\n    --calcite-shell-panel-max-height,\n    var(--calcite-shell-panel-detached-max-height, 30vh)\n  )}/*!@:host([layout=horizontal][height-scale=l]) .content*/[layout=horizontal][height-scale=l].sc-calcite-shell-panel-h .content.sc-calcite-shell-panel{--calcite-shell-panel-max-height-internal:var(\n    --calcite-shell-panel-max-height,\n    var(--calcite-shell-panel-detached-max-height, 40vh)\n  )}/*!@.container*/.container.sc-calcite-shell-panel{pointer-events:none;box-sizing:border-box;display:flex;flex:1 1 auto;align-items:stretch;background-color:transparent;font-size:var(--calcite-font-size--1);color:var(--calcite-color-text-2)}/*!@.container **/.container.sc-calcite-shell-panel *.sc-calcite-shell-panel{box-sizing:border-box}/*!@:host([layout=horizontal]) .container*/[layout=horizontal].sc-calcite-shell-panel-h .container.sc-calcite-shell-panel{flex-direction:column}/*!@:host(:hover) .separator:not(:hover):not(:focus),\n:host(:focus-within) .separator:not(:hover):not(:focus)*/.sc-calcite-shell-panel-h:hover .separator.sc-calcite-shell-panel:not(:hover):not(:focus),.sc-calcite-shell-panel-h:focus-within .separator.sc-calcite-shell-panel:not(:hover):not(:focus){opacity:1;background-color:var(--calcite-color-border-3)}/*!@.separator*/.separator.sc-calcite-shell-panel{pointer-events:auto;position:absolute;display:flex;background-color:transparent;opacity:0;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;cursor:col-resize;outline:none}/*!@.separator:hover*/.separator.sc-calcite-shell-panel:hover{opacity:1;background-color:var(--calcite-color-border-2)}/*!@.separator:focus*/.separator.sc-calcite-shell-panel:focus{background-color:var(--calcite-color-brand);opacity:1}/*!@:host([layout=vertical]) .separator*/[layout=vertical].sc-calcite-shell-panel-h .separator.sc-calcite-shell-panel{inset-block:0px;block-size:100%;inline-size:0.125rem;cursor:col-resize}/*!@:host([layout=horizontal][position=start]) .separator*/[layout=horizontal][position=start].sc-calcite-shell-panel-h .separator.sc-calcite-shell-panel{inset-block-end:0px}/*!@:host([layout=horizontal][position=end]) .separator*/[layout=horizontal][position=end].sc-calcite-shell-panel-h .separator.sc-calcite-shell-panel{inset-block-start:0px}/*!@:host([layout=horizontal]) .separator*/[layout=horizontal].sc-calcite-shell-panel-h .separator.sc-calcite-shell-panel{inset-inline-end:0px;block-size:0.125rem;inline-size:100%;cursor:row-resize}/*!@:host([layout=vertical][position=start]) .separator*/[layout=vertical][position=start].sc-calcite-shell-panel-h .separator.sc-calcite-shell-panel{inset-inline-end:-2px}/*!@:host([layout=horizontal][position=start]) .separator*/[layout=horizontal][position=start].sc-calcite-shell-panel-h .separator.sc-calcite-shell-panel{inset-block-end:-2px}/*!@:host([layout=vertical][position=end]) .separator*/[layout=vertical][position=end].sc-calcite-shell-panel-h .separator.sc-calcite-shell-panel{inset-inline-start:-2px}/*!@:host([layout=horizontal][position=end]) .separator*/[layout=horizontal][position=end].sc-calcite-shell-panel-h .separator.sc-calcite-shell-panel{inset-block-start:-2px}/*!@::slotted(calcite-panel),\n::slotted(calcite-flow)*/.sc-calcite-shell-panel-s>calcite-panel,.sc-calcite-shell-panel-s>calcite-flow{block-size:100%;inline-size:100%;flex:1 1 auto;max-block-size:unset;max-inline-size:unset}/*!@::slotted(.calcite-match-height)*/.sc-calcite-shell-panel-s>.calcite-match-height{display:flex;flex:1 1 auto;overflow:hidden}/*!@.content*/.content.sc-calcite-shell-panel{pointer-events:auto;display:flex;flex-direction:column;flex-wrap:nowrap;align-items:stretch;align-self:stretch;background-color:var(--calcite-color-background);padding:0px;transition:max-block-size var(--calcite-animation-timing), max-inline-size var(--calcite-animation-timing)}/*!@:host([layout=vertical]) .content*/[layout=vertical].sc-calcite-shell-panel-h .content.sc-calcite-shell-panel{inline-size:var(--calcite-shell-panel-width-internal);max-inline-size:var(--calcite-shell-panel-max-width-internal);min-inline-size:var(--calcite-shell-panel-min-width-internal)}/*!@:host([layout=horizontal]) .content*/[layout=horizontal].sc-calcite-shell-panel-h .content.sc-calcite-shell-panel{block-size:var(--calcite-shell-panel-height-internal);max-block-size:var(--calcite-shell-panel-max-height-internal);min-block-size:var(--calcite-shell-panel-min-height-internal)}/*!@.content__header*/.content__header.sc-calcite-shell-panel{display:flex;flex:0 1 auto;flex-direction:column;flex-wrap:nowrap;align-items:stretch}/*!@.content__body*/.content__body.sc-calcite-shell-panel{display:flex;flex:1 1 auto;flex-direction:column;overflow:hidden}/*!@.content--overlay*/.content--overlay.sc-calcite-shell-panel{position:absolute;--tw-shadow:0 4px 8px -1px rgba(0, 0, 0, 0.08), 0 2px 4px -1px rgba(0, 0, 0, 0.04);--tw-shadow-colored:0 4px 8px -1px var(--tw-shadow-color), 0 2px 4px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@:host([layout=vertical]) .content--overlay*/[layout=vertical].sc-calcite-shell-panel-h .content--overlay.sc-calcite-shell-panel{inset-block-start:0px;block-size:100%}/*!@:host([layout=horizontal]) .content--overlay*/[layout=horizontal].sc-calcite-shell-panel-h .content--overlay.sc-calcite-shell-panel{inset-inline-start:0px;inline-size:100%}/*!@:host([layout=vertical][position=start]) .content--overlay*/[layout=vertical][position=start].sc-calcite-shell-panel-h .content--overlay.sc-calcite-shell-panel{inset-inline-start:100%;box-shadow:var(--calcite-shell-panel-shadow-inline-start-internal)}/*!@:host([layout=vertical][position=end]) .content--overlay*/[layout=vertical][position=end].sc-calcite-shell-panel-h .content--overlay.sc-calcite-shell-panel{inset-inline-end:100%;box-shadow:var(--calcite-shell-panel-shadow-inline-end-internal)}/*!@:host([layout=horizontal][position=start]) .content--overlay*/[layout=horizontal][position=start].sc-calcite-shell-panel-h .content--overlay.sc-calcite-shell-panel{inset-block-start:100%;box-shadow:var(--calcite-shell-panel-shadow-block-start-internal)}/*!@:host([layout=horizontal][position=end]) .content--overlay*/[layout=horizontal][position=end].sc-calcite-shell-panel-h .content--overlay.sc-calcite-shell-panel{inset-block-end:100%;box-shadow:var(--calcite-shell-panel-shadow-block-end-internal)}/*!@.content--float*/.content--float.sc-calcite-shell-panel{margin-inline:0.5rem;margin-block:0.5rem auto;block-size:auto;overflow:hidden;border-radius:0.25rem;--tw-shadow:0 4px 8px -1px rgba(0, 0, 0, 0.08), 0 2px 4px -1px rgba(0, 0, 0, 0.04);--tw-shadow-colored:0 4px 8px -1px var(--tw-shadow-color), 0 2px 4px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);max-block-size:var(--calcite-shell-panel-max-height-internal, calc(100% - 1rem))}/*!@.content--float ::slotted(calcite-panel),\n.content--float ::slotted(calcite-flow)*/.content--float .sc-calcite-shell-panel-s>calcite-panel,.content--float.sc-calcite-shell-panel-s>calcite-flow,.content--float .sc-calcite-shell-panel-s>calcite-flow{max-block-size:unset}/*!@:host([layout=horizontal]) .content--float*/[layout=horizontal].sc-calcite-shell-panel-h .content--float.sc-calcite-shell-panel{margin-block:0.5rem}/*!@:host([position=start]) .content--float ::slotted(calcite-panel),\n:host([position=start]) .content--float ::slotted(calcite-flow),\n:host([position=end]) .content--float ::slotted(calcite-panel),\n:host([position=end]) .content--float ::slotted(calcite-flow)*/.sc-calcite-shell-panel-h[position=start] .content--float .sc-calcite-shell-panel-s>calcite-panel,.sc-calcite-shell-panel-h[position=start] .content--float.sc-calcite-shell-panel-s>calcite-flow,.content--float .sc-calcite-shell-panel-s>calcite-flow,.sc-calcite-shell-panel-h[position=end] .content--float.sc-calcite-shell-panel-s>calcite-panel,.sc-calcite-shell-panel-h[position=end] .content--float .sc-calcite-shell-panel-s>calcite-panel,.sc-calcite-shell-panel-h[position=end] .content--float.sc-calcite-shell-panel-s>calcite-flow{border-style:none}/*!@.content[hidden]*/.content[hidden].sc-calcite-shell-panel{display:none}/*!@slot[name=action-bar]::slotted(calcite-action-bar),\n.content ::slotted(calcite-flow),\n.content ::slotted(calcite-panel:not([closed]))*/slot[name=action-bar].sc-calcite-shell-panel-s>calcite-action-bar,.content.sc-calcite-shell-panel-s>calcite-flow,.content .sc-calcite-shell-panel-s>calcite-flow,.content.sc-calcite-shell-panel-s>calcite-panel:not([closed]),.content .sc-calcite-shell-panel-s>calcite-panel:not([closed]){border-width:1px;border-style:solid;border-color:var(--calcite-color-border-3)}/*!@:host([position=start]:not([slot=panel-end])) slot[name=action-bar]::slotted(calcite-action-bar),\n:host([position=start]:not([slot=panel-end])) .content ::slotted(calcite-flow),\n:host([position=start]:not([slot=panel-end])) .content ::slotted(calcite-panel),\n:host([position=end][slot=panel-start]) slot[name=action-bar]::slotted(calcite-action-bar),\n:host([position=end][slot=panel-start]) .content ::slotted(calcite-flow),\n:host([position=end][slot=panel-start]) .content ::slotted(calcite-panel)*/.sc-calcite-shell-panel-h[position=start]:not([slot=panel-end]) slot[name=action-bar].sc-calcite-shell-panel-s>calcite-action-bar,.sc-calcite-shell-panel-h[position=start]:not([slot=panel-end]) .content.sc-calcite-shell-panel-s>calcite-flow,.content .sc-calcite-shell-panel-s>calcite-flow,.sc-calcite-shell-panel-h[position=start]:not([slot=panel-end]) .content.sc-calcite-shell-panel-s>calcite-panel,.sc-calcite-shell-panel-h[position=start]:not([slot=panel-end]) .content .sc-calcite-shell-panel-s>calcite-panel,.sc-calcite-shell-panel-h[position=end][slot=panel-start] slot[name=action-bar].sc-calcite-shell-panel-s>calcite-action-bar,.sc-calcite-shell-panel-h[position=end][slot=panel-start] .content.sc-calcite-shell-panel-s>calcite-flow,.sc-calcite-shell-panel-h[position=end][slot=panel-start] .content.sc-calcite-shell-panel-s>calcite-panel,.sc-calcite-shell-panel-h[position=end][slot=panel-start] .content .sc-calcite-shell-panel-s>calcite-panel{border-inline-start:none}/*!@:host([position=end]:not([slot=panel-start])) slot[name=action-bar]::slotted(calcite-action-bar),\n:host([position=end]:not([slot=panel-start])) .content ::slotted(calcite-flow),\n:host([position=end]:not([slot=panel-start])) .content ::slotted(calcite-panel),\n:host([position=start][slot=panel-end]) slot[name=action-bar]::slotted(calcite-action-bar),\n:host([position=start][slot=panel-end]) .content ::slotted(calcite-flow),\n:host([position=start][slot=panel-end]) .content ::slotted(calcite-panel)*/.sc-calcite-shell-panel-h[position=end]:not([slot=panel-start]) slot[name=action-bar].sc-calcite-shell-panel-s>calcite-action-bar,.sc-calcite-shell-panel-h[position=end]:not([slot=panel-start]) .content.sc-calcite-shell-panel-s>calcite-flow,.content .sc-calcite-shell-panel-s>calcite-flow,.sc-calcite-shell-panel-h[position=end]:not([slot=panel-start]) .content.sc-calcite-shell-panel-s>calcite-panel,.sc-calcite-shell-panel-h[position=end]:not([slot=panel-start]) .content .sc-calcite-shell-panel-s>calcite-panel,.sc-calcite-shell-panel-h[position=start][slot=panel-end] slot[name=action-bar].sc-calcite-shell-panel-s>calcite-action-bar,.sc-calcite-shell-panel-h[position=start][slot=panel-end] .content.sc-calcite-shell-panel-s>calcite-flow,.sc-calcite-shell-panel-h[position=start][slot=panel-end] .content.sc-calcite-shell-panel-s>calcite-panel,.sc-calcite-shell-panel-h[position=start][slot=panel-end] .content .sc-calcite-shell-panel-s>calcite-panel{border-inline-end:none}/*!@:host([layout=horizontal]) slot[name=action-bar]::slotted(calcite-action-bar)*/.sc-calcite-shell-panel-h[layout=horizontal] slot[name=action-bar].sc-calcite-shell-panel-s>calcite-action-bar{border-inline:0}/*!@:host([layout=horizontal][position=start]) .content ::slotted(calcite-flow),\n:host([layout=horizontal][position=start]) .content ::slotted(calcite-panel)*/.sc-calcite-shell-panel-h[layout=horizontal][position=start] .content.sc-calcite-shell-panel-s>calcite-flow,.content .sc-calcite-shell-panel-s>calcite-flow,.sc-calcite-shell-panel-h[layout=horizontal][position=start] .content.sc-calcite-shell-panel-s>calcite-panel,.sc-calcite-shell-panel-h[layout=horizontal][position=start] .content .sc-calcite-shell-panel-s>calcite-panel{border-inline:0;border-block-start:0}/*!@:host([layout=horizontal][position=end]) .content ::slotted(calcite-flow),\n:host([layout=horizontal][position=end]) .content ::slotted(calcite-panel)*/.sc-calcite-shell-panel-h[layout=horizontal][position=end] .content.sc-calcite-shell-panel-s>calcite-flow,.content .sc-calcite-shell-panel-s>calcite-flow,.sc-calcite-shell-panel-h[layout=horizontal][position=end] .content.sc-calcite-shell-panel-s>calcite-panel,.sc-calcite-shell-panel-h[layout=horizontal][position=end] .content .sc-calcite-shell-panel-s>calcite-panel{border-inline:0;border-block-end:0}/*!@:host([hidden])*/[hidden].sc-calcite-shell-panel-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-shell-panel{display:none}";

/**
 * @slot - A slot for adding custom content.
 * @slot action-bar - A slot for adding a `calcite-action-bar` to the component.
 */
class ShellPanel {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalShellPanelResizeStart = createEvent(this, "calciteInternalShellPanelResizeStart", 6);
        this.calciteInternalShellPanelResizeEnd = createEvent(this, "calciteInternalShellPanelResizeEnd", 6);
        this.initialContentWidth = null;
        this.initialContentHeight = null;
        this.initialClientX = null;
        this.initialClientY = null;
        this.contentWidthMax = null;
        this.contentWidthMin = null;
        this.contentHeightMax = null;
        this.contentHeightMin = null;
        this.step = 1;
        this.stepMultiplier = 10;
        this.actionBars = [];
        this.storeContentEl = (contentEl) => {
            this.contentEl = contentEl;
        };
        this.getKeyAdjustedSize = (event) => {
            const { key } = event;
            const { el, step, stepMultiplier, layout, contentWidthMin, contentWidthMax, initialContentWidth, initialContentHeight, contentHeightMin, contentHeightMax, position, } = this;
            const multipliedStep = step * stepMultiplier;
            const MOVEMENT_KEYS = [
                "ArrowUp",
                "ArrowDown",
                "ArrowLeft",
                "ArrowRight",
                "Home",
                "End",
                "PageUp",
                "PageDown",
            ];
            if (MOVEMENT_KEYS.indexOf(key) > -1) {
                event.preventDefault();
            }
            const dir = getElementDir(el);
            const horizontalKeys = ["ArrowLeft", "ArrowRight"];
            const verticalKeys = ["ArrowDown", "ArrowUp"];
            const directionFactor = dir === "rtl" && horizontalKeys.includes(key) ? -1 : 1;
            const increaseKeys = layout === "horizontal"
                ? position === "end"
                    ? key === verticalKeys[1] || key === horizontalKeys[0]
                    : key === verticalKeys[0] || key === horizontalKeys[1]
                : key === verticalKeys[1] ||
                    (position === "end" ? key === horizontalKeys[0] : key === horizontalKeys[1]);
            if (increaseKeys) {
                const stepValue = event.shiftKey ? multipliedStep : step;
                return layout === "horizontal"
                    ? initialContentHeight + directionFactor * stepValue
                    : initialContentWidth + directionFactor * stepValue;
            }
            const decreaseKeys = layout === "horizontal"
                ? position === "end"
                    ? key === verticalKeys[0] || key === horizontalKeys[0]
                    : key === verticalKeys[1] || key === horizontalKeys[1]
                : key === verticalKeys[0] ||
                    (position === "end" ? key === horizontalKeys[1] : key === horizontalKeys[0]);
            if (decreaseKeys) {
                const stepValue = event.shiftKey ? multipliedStep : step;
                return layout === "horizontal"
                    ? initialContentHeight - directionFactor * stepValue
                    : initialContentWidth - directionFactor * stepValue;
            }
            if (key === "Home" && layout === "horizontal" && typeof contentHeightMin === "number") {
                return contentHeightMin;
            }
            if (key === "Home" && layout === "vertical" && typeof contentWidthMin === "number") {
                return contentWidthMin;
            }
            if (key === "End" && layout === "horizontal" && typeof contentHeightMax === "number") {
                return contentHeightMax;
            }
            if (key === "End" && layout === "vertical" && typeof contentWidthMax === "number") {
                return contentWidthMax;
            }
            if (key === "PageDown") {
                return layout === "horizontal"
                    ? initialContentHeight - multipliedStep
                    : initialContentWidth - multipliedStep;
            }
            if (key === "PageUp") {
                return layout === "horizontal"
                    ? initialContentHeight + multipliedStep
                    : initialContentWidth + multipliedStep;
            }
            return null;
        };
        this.initialKeydownWidth = (event) => {
            this.setInitialContentWidth();
            const width = this.getKeyAdjustedSize(event);
            if (typeof width === "number") {
                this.setContentWidth(width);
            }
        };
        this.initialKeydownHeight = (event) => {
            this.setInitialContentHeight();
            const height = this.getKeyAdjustedSize(event);
            if (typeof height === "number") {
                this.setContentHeight(height);
            }
        };
        this.separatorKeyDown = (event) => {
            this.layout === "horizontal"
                ? this.initialKeydownHeight(event)
                : this.initialKeydownWidth(event);
        };
        this.separatorPointerMove = (event) => {
            event.preventDefault();
            const { el, layout, initialContentWidth, initialContentHeight, position, initialClientX, initialClientY, } = this;
            const offset = layout === "horizontal" ? event.clientY - initialClientY : event.clientX - initialClientX;
            const adjustmentDirection = layout === "vertical" && getElementDir(el) === "rtl" ? -1 : 1;
            const adjustedOffset = layout === "horizontal"
                ? position === "end"
                    ? -adjustmentDirection * offset
                    : adjustmentDirection * offset
                : position === "end"
                    ? -adjustmentDirection * offset
                    : adjustmentDirection * offset;
            layout === "horizontal"
                ? this.setContentHeight(initialContentHeight + adjustedOffset)
                : this.setContentWidth(initialContentWidth + adjustedOffset);
        };
        this.separatorPointerUp = (event) => {
            if (!isPrimaryPointerButton(event)) {
                return;
            }
            this.calciteInternalShellPanelResizeEnd.emit();
            event.preventDefault();
            window.removeEventListener("pointerup", this.separatorPointerUp);
            window.removeEventListener("pointermove", this.separatorPointerMove);
        };
        this.setInitialContentHeight = () => {
            this.initialContentHeight = this.contentEl?.getBoundingClientRect().height;
        };
        this.setInitialContentWidth = () => {
            this.initialContentWidth = this.contentEl?.getBoundingClientRect().width;
        };
        this.separatorPointerDown = (event) => {
            if (!isPrimaryPointerButton(event)) {
                return;
            }
            this.calciteInternalShellPanelResizeStart.emit();
            event.preventDefault();
            const { separatorEl } = this;
            separatorEl && document.activeElement !== separatorEl && separatorEl.focus();
            if (this.layout === "horizontal") {
                this.setInitialContentHeight();
                this.initialClientY = event.clientY;
            }
            else {
                this.setInitialContentWidth();
                this.initialClientX = event.clientX;
            }
            window.addEventListener("pointerup", this.separatorPointerUp);
            window.addEventListener("pointermove", this.separatorPointerMove);
        };
        this.connectSeparator = (separatorEl) => {
            this.disconnectSeparator();
            this.separatorEl = separatorEl;
            separatorEl?.addEventListener("pointerdown", this.separatorPointerDown);
        };
        this.disconnectSeparator = () => {
            this.separatorEl?.removeEventListener("pointerdown", this.separatorPointerDown);
        };
        this.setActionBarsLayout = (actionBars) => {
            actionBars.forEach((actionBar) => (actionBar.layout = this.layout));
        };
        this.handleActionBarSlotChange = (event) => {
            const actionBars = slotChangeGetAssignedElements(event).filter((el) => el?.matches("calcite-action-bar"));
            this.actionBars = actionBars;
            this.setActionBarsLayout(actionBars);
        };
        this.handleHeaderSlotChange = (event) => {
            this.hasHeader = slotChangeHasAssignedElement(event);
        };
        this.collapsed = false;
        this.detached = false;
        this.displayMode = "dock";
        this.detachedHeightScale = undefined;
        this.heightScale = undefined;
        this.widthScale = "m";
        this.layout = "vertical";
        this.position = "start";
        this.resizable = false;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.contentWidth = null;
        this.contentHeight = null;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
        this.hasHeader = false;
    }
    handleDetached(value) {
        if (value) {
            this.displayMode = "float";
        }
        else if (this.displayMode === "float") {
            this.displayMode = "dock";
        }
    }
    handleDisplayMode(value) {
        this.detached = value === "float";
    }
    handleDetachedHeightScale(value) {
        this.heightScale = value;
    }
    handleHeightScale(value) {
        this.detachedHeightScale = value;
    }
    layoutHandler() {
        this.setActionBarsLayout(this.actionBars);
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectConditionalSlotComponent(this);
        connectLocalized(this);
        connectMessages(this);
    }
    async componentWillLoad() {
        await setUpMessages(this);
    }
    disconnectedCallback() {
        disconnectConditionalSlotComponent(this);
        this.disconnectSeparator();
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    componentDidLoad() {
        this.updateAriaValues();
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderHeader() {
        return (hAsync("div", { class: CSS$o.contentHeader, hidden: !this.hasHeader, key: "header" }, hAsync("slot", { name: SLOTS$7.header, onSlotchange: this.handleHeaderSlotChange })));
    }
    render() {
        const { collapsed, position, initialContentWidth, initialContentHeight, contentWidth, contentWidthMax, contentWidthMin, contentHeight, contentHeightMax, contentHeightMin, resizable, layout, displayMode, } = this;
        const dir = getElementDir(this.el);
        const allowResizing = displayMode !== "float" && resizable;
        const style = allowResizing
            ? layout === "horizontal"
                ? contentHeight
                    ? { height: `${contentHeight}px` }
                    : null
                : contentWidth
                    ? { width: `${contentWidth}px` }
                    : null
            : null;
        const separatorNode = !collapsed && allowResizing ? (hAsync("div", { "aria-label": this.messages.resize, "aria-orientation": layout === "horizontal" ? "vertical" : "horizontal", "aria-valuemax": layout == "horizontal" ? contentHeightMax : contentWidthMax, "aria-valuemin": layout == "horizontal" ? contentHeightMin : contentWidthMin, "aria-valuenow": layout == "horizontal"
                ? contentHeight ?? initialContentHeight
                : contentWidth ?? initialContentWidth, class: CSS$o.separator, key: "separator", onKeyDown: this.separatorKeyDown, role: "separator", tabIndex: 0, "touch-action": "none",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.connectSeparator })) : null;
        const getAnimationDir = () => {
            if (layout === "horizontal") {
                return position === "start"
                    ? CSS_UTILITY.calciteAnimateInDown
                    : CSS_UTILITY.calciteAnimateInUp;
            }
            else {
                const isStart = (dir === "ltr" && position === "end") || (dir === "rtl" && position === "start");
                return isStart ? CSS_UTILITY.calciteAnimateInLeft : CSS_UTILITY.calciteAnimateInRight;
            }
        };
        const contentNode = (hAsync("div", { class: {
                [CSS_UTILITY.rtl]: dir === "rtl",
                [CSS$o.content]: true,
                [CSS$o.contentOverlay]: displayMode === "overlay",
                [CSS$o.contentFloat]: displayMode === "float",
                [CSS_UTILITY.calciteAnimate]: displayMode === "overlay",
                [getAnimationDir()]: displayMode === "overlay",
            }, hidden: collapsed, key: "content", style: style,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeContentEl }, this.renderHeader(), hAsync("div", { class: CSS$o.contentBody }, hAsync("slot", null)), separatorNode));
        const actionBarNode = (hAsync("slot", { key: "action-bar", name: SLOTS$7.actionBar, onSlotchange: this.handleActionBarSlotChange }));
        const mainNodes = [actionBarNode, contentNode];
        if (position === "end") {
            mainNodes.reverse();
        }
        return hAsync("div", { class: { [CSS$o.container]: true } }, mainNodes);
    }
    // --------------------------------------------------------------------------
    //
    //  private Methods
    //
    // --------------------------------------------------------------------------
    setContentWidth(width) {
        const { contentWidthMax, contentWidthMin } = this;
        const roundedWidth = Math.round(width);
        this.contentWidth =
            typeof contentWidthMax === "number" && typeof contentWidthMin === "number"
                ? clamp$1(roundedWidth, contentWidthMin, contentWidthMax)
                : roundedWidth;
    }
    updateAriaValues() {
        const { contentEl } = this;
        const computedStyle = contentEl && getComputedStyle(contentEl);
        if (!computedStyle) {
            return;
        }
        this.layout === "horizontal"
            ? this.updateHeights(computedStyle)
            : this.updateWidths(computedStyle);
    }
    setContentHeight(height) {
        const { contentHeightMax, contentHeightMin } = this;
        const roundedWidth = Math.round(height);
        this.contentHeight =
            typeof contentHeightMax === "number" && typeof contentHeightMin === "number"
                ? clamp$1(roundedWidth, contentHeightMin, contentHeightMax)
                : roundedWidth;
    }
    updateWidths(computedStyle) {
        const max = parseInt(computedStyle.getPropertyValue("max-width"), 10);
        const min = parseInt(computedStyle.getPropertyValue("min-width"), 10);
        const valueNow = parseInt(computedStyle.getPropertyValue("width"), 10);
        if (typeof valueNow === "number" && !isNaN(valueNow)) {
            this.initialContentWidth = valueNow;
        }
        if (typeof max === "number" && !isNaN(max)) {
            this.contentWidthMax = max;
        }
        if (typeof min === "number" && !isNaN(min)) {
            this.contentWidthMin = min;
        }
    }
    updateHeights(computedStyle) {
        const max = parseInt(computedStyle.getPropertyValue("max-height"), 10);
        const min = parseInt(computedStyle.getPropertyValue("min-height"), 10);
        const valueNow = parseInt(computedStyle.getPropertyValue("height"), 10);
        if (typeof valueNow === "number" && !isNaN(valueNow)) {
            this.initialContentHeight = valueNow;
        }
        if (typeof max === "number" && !isNaN(max)) {
            this.contentHeightMax = max;
        }
        if (typeof min === "number" && !isNaN(min)) {
            this.contentHeightMin = min;
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "detached": ["handleDetached"],
        "displayMode": ["handleDisplayMode"],
        "detachedHeightScale": ["handleDetachedHeightScale"],
        "heightScale": ["handleHeightScale"],
        "layout": ["layoutHandler"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return shellPanelCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-shell-panel",
        "$members$": {
            "collapsed": [516],
            "detached": [516],
            "displayMode": [513, "display-mode"],
            "detachedHeightScale": [513, "detached-height-scale"],
            "heightScale": [513, "height-scale"],
            "widthScale": [513, "width-scale"],
            "layout": [513],
            "position": [513],
            "resizable": [516],
            "messages": [1040],
            "messageOverrides": [1040],
            "contentWidth": [32],
            "contentHeight": [32],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "hasHeader": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["collapsed", "collapsed"], ["detached", "detached"], ["displayMode", "display-mode"], ["detachedHeightScale", "detached-height-scale"], ["heightScale", "height-scale"], ["widthScale", "width-scale"], ["layout", "layout"], ["position", "position"], ["resizable", "resizable"]]
    }; }
}

const CSS$n = {
    container: "container",
    containerRange: "container--range",
    graph: "graph",
    handle: "handle",
    handleExtension: "handle-extension",
    handleLabel: "handle__label",
    handleLabelMinValue: "handle__label--minValue",
    handleLabelValue: "handle__label--value",
    hyphen: "hyphen",
    hyphenWrap: "hyphen--wrap",
    static: "static",
    thumb: "thumb",
    thumbActive: "thumb--active",
    thumbContainer: "thumb-container",
    thumbMinValue: "thumb--minValue",
    thumbPrecise: "thumb--precise",
    thumbValue: "thumb--value",
    tick: "tick",
    tickActive: "tick--active",
    tickLabel: "tick__label",
    tickMax: "tick__label--max",
    tickMin: "tick__label--min",
    ticks: "ticks",
    track: "track",
    trackRange: "track__range",
    transformed: "transformed",
};
const maxTickElementThreshold = 250;

const sliderCss = "@charset \"UTF-8\";/*!@:host([disabled])*/[disabled].sc-calcite-slider-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-slider-h *.sc-calcite-slider,.sc-calcite-slider-h[disabled].sc-calcite-slider-s>*,.sc-calcite-slider-h[disabled] .sc-calcite-slider-s>*{pointer-events:none}/*!@.scale--s*/.scale--s.sc-calcite-slider{--calcite-slider-handle-size:0.625rem;--calcite-slider-handle-extension-height:0.4rem;--calcite-slider-container-font-size:var(--calcite-font-size--3)}/*!@.scale--s .handle__label,\n.scale--s .tick__label*/.scale--s.sc-calcite-slider .handle__label.sc-calcite-slider,.scale--s.sc-calcite-slider .tick__label.sc-calcite-slider{line-height:.75rem}/*!@.scale--m*/.scale--m.sc-calcite-slider{--calcite-slider-handle-size:0.875rem;--calcite-slider-handle-extension-height:0.5rem;--calcite-slider-container-font-size:var(--calcite-font-size--2)}/*!@.scale--m .handle__label,\n.scale--m .tick__label*/.scale--m.sc-calcite-slider .handle__label.sc-calcite-slider,.scale--m.sc-calcite-slider .tick__label.sc-calcite-slider{line-height:1rem}/*!@.scale--l*/.scale--l.sc-calcite-slider{--calcite-slider-handle-size:1rem;--calcite-slider-handle-extension-height:0.65rem;--calcite-slider-container-font-size:var(--calcite-font-size--1)}/*!@.scale--l .handle__label,\n.scale--l .tick__label*/.scale--l.sc-calcite-slider .handle__label.sc-calcite-slider,.scale--l.sc-calcite-slider .tick__label.sc-calcite-slider{line-height:1rem}/*!@.handle__label,\n.tick__label*/.handle__label.sc-calcite-slider,.tick__label.sc-calcite-slider{font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-2);font-size:var(--calcite-slider-container-font-size)}/*!@:host*/.sc-calcite-slider-h{display:block}/*!@.container*/.container.sc-calcite-slider{position:relative;display:block;overflow-wrap:normal;word-break:normal;padding-inline:calc(var(--calcite-slider-handle-size) * 0.5);padding-block:calc(var(--calcite-slider-handle-size) * 0.5);margin-block:calc(var(--calcite-slider-handle-size) * 0.5);margin-inline:0;--calcite-slider-full-handle-height:calc(\n    var(--calcite-slider-handle-size) + var(--calcite-slider-handle-extension-height)\n  );touch-action:none}/*!@:host([disabled]) .track__range,\n:host([disabled]) .tick--active*/[disabled].sc-calcite-slider-h .track__range.sc-calcite-slider,[disabled].sc-calcite-slider-h .tick--active.sc-calcite-slider{background-color:var(--calcite-color-text-3)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-slider-h[disabled] .sc-calcite-slider-s>[calcite-hydrated][disabled],[disabled].sc-calcite-slider-h [calcite-hydrated][disabled].sc-calcite-slider{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-slider{display:contents}/*!@.scale--s .thumb:not(.thumb--precise)*/.scale--s.sc-calcite-slider .thumb.sc-calcite-slider:not(.thumb--precise){--calcite-slider-thumb-y-offset:-0.375rem}/*!@.scale--m .thumb:not(.thumb--precise)*/.scale--m.sc-calcite-slider .thumb.sc-calcite-slider:not(.thumb--precise){--calcite-slider-thumb-y-offset:-0.5rem}/*!@.scale--l .thumb:not(.thumb--precise)*/.scale--l.sc-calcite-slider .thumb.sc-calcite-slider:not(.thumb--precise){--calcite-slider-thumb-y-offset:-0.55rem}/*!@:host([precise]:not([has-histogram])) .container .thumb--value*/[precise].sc-calcite-slider-h:not([has-histogram]) .container.sc-calcite-slider .thumb--value.sc-calcite-slider{--calcite-slider-thumb-y-offset:calc(var(--calcite-slider-full-handle-height) * -1)}/*!@.thumb-container*/.thumb-container.sc-calcite-slider{position:relative;max-inline-size:100%}/*!@.thumb*/.thumb.sc-calcite-slider{--calcite-slider-thumb-x-offset:calc(var(--calcite-slider-handle-size) * 0.5);position:absolute;margin:0px;display:flex;cursor:pointer;flex-direction:column;align-items:center;border-style:none;background-color:transparent;padding:0px;font-family:inherit;outline:2px solid transparent;outline-offset:2px;transform:translate(var(--calcite-slider-thumb-x-offset), var(--calcite-slider-thumb-y-offset))}/*!@.thumb .handle__label.static, .thumb .handle__label.transformed*/.thumb.sc-calcite-slider .handle__label.static.sc-calcite-slider,.thumb.sc-calcite-slider .handle__label.transformed.sc-calcite-slider{position:absolute;inset-block:0px;opacity:0}/*!@.thumb .handle__label.hyphen::after*/.thumb.sc-calcite-slider .handle__label.hyphen.sc-calcite-slider::after{content:\"—\";display:inline-block;inline-size:1em}/*!@.thumb .handle__label.hyphen--wrap*/.thumb.sc-calcite-slider .handle__label.hyphen--wrap.sc-calcite-slider{display:flex}/*!@.thumb .handle*/.thumb.sc-calcite-slider .handle.sc-calcite-slider{box-sizing:border-box;border-radius:9999px;background-color:var(--calcite-color-foreground-1);outline-color:transparent;block-size:var(--calcite-slider-handle-size);inline-size:var(--calcite-slider-handle-size);box-shadow:0 0 0 2px var(--calcite-color-text-3) inset;transition:border var(--calcite-internal-animation-timing-medium) ease, background-color var(--calcite-internal-animation-timing-medium) ease, box-shadow var(--calcite-animation-timing) ease}/*!@.thumb .handle-extension*/.thumb.sc-calcite-slider .handle-extension.sc-calcite-slider{inline-size:0.125rem;block-size:var(--calcite-slider-handle-extension-height);background-color:var(--calcite-color-text-3)}/*!@.thumb:hover .handle*/.thumb.sc-calcite-slider:hover .handle.sc-calcite-slider{box-shadow:0 0 0 3px var(--calcite-color-brand) inset}/*!@.thumb:hover .handle-extension*/.thumb.sc-calcite-slider:hover .handle-extension.sc-calcite-slider{background-color:var(--calcite-color-brand)}/*!@.thumb:focus .handle*/.thumb.sc-calcite-slider:focus .handle.sc-calcite-slider{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.thumb:focus .handle-extension*/.thumb.sc-calcite-slider:focus .handle-extension.sc-calcite-slider{background-color:var(--calcite-color-brand)}/*!@.thumb.thumb--minValue*/.thumb.thumb--minValue.sc-calcite-slider{transform:translate(calc(var(--calcite-slider-thumb-x-offset) * -1), var(--calcite-slider-thumb-y-offset))}/*!@.thumb.thumb--precise*/.thumb.thumb--precise.sc-calcite-slider{--calcite-slider-thumb-y-offset:-0.125rem}/*!@:host([label-handles]) .thumb*/[label-handles].sc-calcite-slider-h .thumb.sc-calcite-slider{--calcite-slider-thumb-x-offset:50%}/*!@:host([label-handles]):host(:not([has-histogram])) .scale--s .thumb:not(.thumb--precise)*/[label-handles].sc-calcite-slider-h(.sc-calcite-slider-h:not([has-histogram])) .scale--s.sc-calcite-slider .thumb.sc-calcite-slider:not(.thumb--precise){--calcite-slider-thumb-y-offset:-1.4375rem}/*!@:host([label-handles]):host(:not([has-histogram])) .scale--m .thumb:not(.thumb--precise)*/[label-handles].sc-calcite-slider-h(.sc-calcite-slider-h:not([has-histogram])) .scale--m.sc-calcite-slider .thumb.sc-calcite-slider:not(.thumb--precise){--calcite-slider-thumb-y-offset:-1.875rem}/*!@:host([label-handles]):host(:not([has-histogram])) .scale--l .thumb:not(.thumb--precise)*/[label-handles].sc-calcite-slider-h(.sc-calcite-slider-h:not([has-histogram])) .scale--l.sc-calcite-slider .thumb.sc-calcite-slider:not(.thumb--precise){--calcite-slider-thumb-y-offset:-2rem}/*!@:host([has-histogram][label-handles]) .handle__label,\n:host([label-handles]:not([has-histogram])) .thumb--minValue.thumb--precise .handle__label*/[has-histogram][label-handles].sc-calcite-slider-h .handle__label.sc-calcite-slider,[label-handles].sc-calcite-slider-h:not([has-histogram]) .thumb--minValue.thumb--precise.sc-calcite-slider .handle__label.sc-calcite-slider{margin-block-start:0.5em}/*!@:host(:not([has-histogram]):not([precise])) .handle__label,\n:host([label-handles]:not([has-histogram])) .thumb--value .handle__label*/.sc-calcite-slider-h:not([has-histogram]):not([precise]) .handle__label.sc-calcite-slider,[label-handles].sc-calcite-slider-h:not([has-histogram]) .thumb--value.sc-calcite-slider .handle__label.sc-calcite-slider{margin-block-end:0.5em}/*!@:host([label-handles][precise]):host(:not([has-histogram])) .scale--s .thumb--value*/[label-handles][precise].sc-calcite-slider-h(.sc-calcite-slider-h:not([has-histogram])) .scale--s.sc-calcite-slider .thumb--value.sc-calcite-slider{--calcite-slider-thumb-y-offset:-2.075rem}/*!@:host([label-handles][precise]):host(:not([has-histogram])) .scale--m .thumb--value*/[label-handles][precise].sc-calcite-slider-h(.sc-calcite-slider-h:not([has-histogram])) .scale--m.sc-calcite-slider .thumb--value.sc-calcite-slider{--calcite-slider-thumb-y-offset:-2.75rem}/*!@:host([label-handles][precise]):host(:not([has-histogram])) .scale--l .thumb--value*/[label-handles][precise].sc-calcite-slider-h(.sc-calcite-slider-h:not([has-histogram])) .scale--l.sc-calcite-slider .thumb--value.sc-calcite-slider{--calcite-slider-thumb-y-offset:-3.0625rem}/*!@.thumb:focus .handle,\n.thumb--active .handle*/.thumb.sc-calcite-slider:focus .handle.sc-calcite-slider,.thumb--active.sc-calcite-slider .handle.sc-calcite-slider{background-color:var(--calcite-color-brand);box-shadow:0 0 8px 0 rgba(0, 0, 0, 0.16)}/*!@.thumb:hover.thumb--precise:after,\n.thumb:focus.thumb--precise:after,\n.thumb--active.thumb--precise:after*/.thumb.sc-calcite-slider:hover.thumb--precise:after,.thumb.sc-calcite-slider:focus.thumb--precise:after,.thumb--active.thumb--precise.sc-calcite-slider:after{background-color:var(--calcite-color-brand)}/*!@.track*/.track.sc-calcite-slider{position:relative;block-size:0.125rem;border-radius:0px;background-color:var(--calcite-color-border-2);transition:all var(--calcite-internal-animation-timing-medium) ease-in}/*!@.track__range*/.track__range.sc-calcite-slider{position:absolute;inset-block-start:0px;block-size:0.125rem;background-color:var(--calcite-color-brand)}/*!@.container--range .track__range:hover*/.container--range.sc-calcite-slider .track__range.sc-calcite-slider:hover{cursor:ew-resize}/*!@.container--range .track__range:after*/.container--range.sc-calcite-slider .track__range.sc-calcite-slider:after{position:absolute;inline-size:100%;content:\"\";inset-block-start:calc(var(--calcite-slider-full-handle-height) * 0.5 * -1);block-size:calc(var(--calcite-slider-handle-size) + var(--calcite-slider-handle-extension-height))}@media (forced-colors: active){/*!@.thumb*/.thumb.sc-calcite-slider{outline-width:0;outline-offset:0}/*!@.handle*/.handle.sc-calcite-slider{outline:2px solid transparent;outline-offset:2px}/*!@.thumb:focus .handle,\n  .thumb .handle-extension,\n  .thumb:hover .handle-extension,\n  .thumb:focus .handle-extension,\n  .thumb:active .handle-extension*/.thumb.sc-calcite-slider:focus .handle.sc-calcite-slider,.thumb.sc-calcite-slider .handle-extension.sc-calcite-slider,.thumb.sc-calcite-slider:hover .handle-extension.sc-calcite-slider,.thumb.sc-calcite-slider:focus .handle-extension.sc-calcite-slider,.thumb.sc-calcite-slider:active .handle-extension.sc-calcite-slider{background-color:canvasText}/*!@.track*/.track.sc-calcite-slider{background-color:canvasText}/*!@.track__range*/.track__range.sc-calcite-slider{background-color:highlight}}/*!@.tick*/.tick.sc-calcite-slider{position:absolute;block-size:0.25rem;inline-size:0.125rem;border-width:1px;border-style:solid;background-color:var(--calcite-color-border-input);border-color:var(--calcite-color-foreground-1);inset-block-start:-2px;pointer-events:none;margin-inline-start:calc(-1 * 0.125rem)}/*!@.tick--active*/.tick--active.sc-calcite-slider{background-color:var(--calcite-color-brand)}/*!@.tick__label*/.tick__label.sc-calcite-slider{pointer-events:none;margin-block-start:0.875rem;display:flex;justify-content:center}/*!@.tick__label--min*/.tick__label--min.sc-calcite-slider{transition:opacity var(--calcite-animation-timing)}/*!@.tick__label--max*/.tick__label--max.sc-calcite-slider{transition:opacity var(--calcite-internal-animation-timing-fast)}/*!@:host([has-histogram][label-handles]) .tick__label--min,\n:host([has-histogram][label-handles]) .tick__label--max,\n:host([has-histogram][precise]) .tick__label--min,\n:host([has-histogram][precise]) .tick__label--max*/[has-histogram][label-handles].sc-calcite-slider-h .tick__label--min.sc-calcite-slider,[has-histogram][label-handles].sc-calcite-slider-h .tick__label--max.sc-calcite-slider,[has-histogram][precise].sc-calcite-slider-h .tick__label--min.sc-calcite-slider,[has-histogram][precise].sc-calcite-slider-h .tick__label--max.sc-calcite-slider{font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-3)}/*!@.graph*/.graph.sc-calcite-slider{color:var(--calcite-color-foreground-3);block-size:48px}/*!@:host([label-ticks][ticks]) .container*/[label-ticks][ticks].sc-calcite-slider-h .container.sc-calcite-slider{padding-block-end:calc(0.875rem + var(--calcite-slider-container-font-size))}/*!@:host([has-histogram]):host([precise][label-handles]) .container*/[has-histogram].sc-calcite-slider-h([precise][label-handles]).sc-calcite-slider-h .container.sc-calcite-slider{padding-block-end:calc(var(--calcite-slider-full-handle-height) + 1em)}/*!@:host([has-histogram]):host([label-handles]:not([precise])) .container*/[has-histogram].sc-calcite-slider-h([label-handles].sc-calcite-slider-h:not([precise])) .container.sc-calcite-slider{padding-block-end:calc(var(--calcite-slider-handle-size) * 0.5 + 1em)}/*!@:host([has-histogram]):host([precise]:not([label-handles])) .container*/[has-histogram].sc-calcite-slider-h([precise].sc-calcite-slider-h:not([label-handles])) .container.sc-calcite-slider{padding-block-end:var(--calcite-slider-full-handle-height)}/*!@:host(:not([has-histogram])):host([precise]:not([label-handles])) .container*/.sc-calcite-slider-h:not([has-histogram]).sc-calcite-slider-h([precise]:not([label-handles])) .container.sc-calcite-slider{padding-block-start:var(--calcite-slider-full-handle-height)}/*!@:host(:not([has-histogram])):host([precise]:not([label-handles])) .container--range*/.sc-calcite-slider-h:not([has-histogram]).sc-calcite-slider-h([precise]:not([label-handles])) .container--range.sc-calcite-slider{padding-block-end:var(--calcite-slider-full-handle-height)}/*!@:host(:not([has-histogram])):host([label-handles]:not([precise])) .container*/.sc-calcite-slider-h:not([has-histogram]).sc-calcite-slider-h([label-handles]:not([precise])) .container.sc-calcite-slider{padding-block-start:calc(var(--calcite-slider-full-handle-height) + 4px)}/*!@:host(:not([has-histogram])):host([label-handles][precise]) .container*/.sc-calcite-slider-h:not([has-histogram]).sc-calcite-slider-h([label-handles][precise]) .container.sc-calcite-slider{padding-block-start:calc(var(--calcite-slider-full-handle-height) + var(--calcite-slider-container-font-size) + 4px)}/*!@:host(:not([has-histogram])):host([label-handles][precise]) .container--range*/.sc-calcite-slider-h:not([has-histogram]).sc-calcite-slider-h([label-handles][precise]) .container--range.sc-calcite-slider{padding-block-end:calc(var(--calcite-slider-full-handle-height) + var(--calcite-slider-container-font-size) + 4px)}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-slider-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([hidden])*/[hidden].sc-calcite-slider-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-slider{display:none}";

function isRange(value) {
    return Array.isArray(value);
}
class Slider {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteSliderInput = createEvent(this, "calciteSliderInput", 6);
        this.calciteSliderChange = createEvent(this, "calciteSliderChange", 6);
        this.activeProp = "value";
        this.guid = `calcite-slider-${guid()}`;
        this.onThumbBlur = () => {
            this.activeProp = null;
        };
        this.onThumbFocus = (event) => {
            const thumb = event.currentTarget;
            this.activeProp = thumb.getAttribute("data-value-prop");
        };
        this.onThumbPointerDown = (event) => {
            const thumb = event.currentTarget;
            this.pointerDownDragStart(event, thumb.getAttribute("data-value-prop"));
        };
        this.onTrackPointerDown = (event) => {
            this.pointerDownDragStart(event, "minMaxValue");
        };
        this.dragUpdate = (event) => {
            if (this.disabled) {
                return;
            }
            event.preventDefault();
            if (this.dragProp) {
                const value = this.translate(event.clientX || event.pageX);
                if (isRange(this.value) && this.dragProp === "minMaxValue") {
                    if (this.minValueDragRange && this.maxValueDragRange && this.minMaxValueRange) {
                        const newMinValue = value - this.minValueDragRange;
                        const newMaxValue = value + this.maxValueDragRange;
                        if (newMaxValue <= this.max &&
                            newMinValue >= this.min &&
                            newMaxValue - newMinValue === this.minMaxValueRange) {
                            this.setValue({
                                minValue: this.clamp(newMinValue, "minValue"),
                                maxValue: this.clamp(newMaxValue, "maxValue"),
                            });
                        }
                    }
                    else {
                        this.minValueDragRange = value - this.minValue;
                        this.maxValueDragRange = this.maxValue - value;
                        this.minMaxValueRange = this.maxValue - this.minValue;
                    }
                }
                else {
                    this.setValue({ [this.dragProp]: this.clamp(value, this.dragProp) });
                }
            }
        };
        this.pointerUpDragEnd = (event) => {
            if (this.disabled || !isPrimaryPointerButton(event)) {
                return;
            }
            this.dragEnd(event);
        };
        this.dragEnd = (event) => {
            if (this.disabled) {
                return;
            }
            this.removeDragListeners();
            this.focusActiveHandle(event.clientX);
            if (this.lastDragPropValue != this[this.dragProp]) {
                this.emitChange();
            }
            this.dragProp = null;
            this.lastDragPropValue = null;
            this.minValueDragRange = null;
            this.maxValueDragRange = null;
            this.minMaxValueRange = null;
        };
        this.storeTrackRef = (node) => {
            this.trackEl = node;
        };
        this.storeThumbRef = (el) => {
            if (!el) {
                return;
            }
            const valueProp = el.getAttribute("data-value-prop");
            valueProp === "minValue" ? (this.minHandle = el) : (this.maxHandle = el);
        };
        /**
         * Returns a string representing the localized label value based if the groupSeparator prop is parsed.
         *
         * @param value
         */
        this.formatValue = (value) => {
            numberStringFormatter.numberFormatOptions = {
                locale: this.effectiveLocale,
                numberingSystem: this.numberingSystem,
                useGrouping: this.groupSeparator,
            };
            return numberStringFormatter.localize(value.toString());
        };
        this.disabled = false;
        this.form = undefined;
        this.groupSeparator = false;
        this.hasHistogram = false;
        this.histogram = undefined;
        this.histogramStops = undefined;
        this.labelHandles = false;
        this.labelTicks = false;
        this.max = 100;
        this.maxLabel = undefined;
        this.maxValue = undefined;
        this.min = 0;
        this.minLabel = undefined;
        this.minValue = undefined;
        this.mirrored = false;
        this.name = undefined;
        this.numberingSystem = undefined;
        this.pageStep = undefined;
        this.precise = false;
        this.required = false;
        this.snap = false;
        this.step = 1;
        this.ticks = undefined;
        this.value = 0;
        this.scale = "m";
        this.effectiveLocale = "";
        this.minMaxValueRange = null;
        this.minValueDragRange = null;
        this.maxValueDragRange = null;
        this.tickValues = [];
    }
    histogramWatcher(newHistogram) {
        this.hasHistogram = !!newHistogram;
    }
    ticksWatcher() {
        this.tickValues = this.generateTickValues();
    }
    valueHandler() {
        this.setMinMaxFromValue();
    }
    minMaxValueHandler() {
        this.setValueFromMinMax();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        this.setMinMaxFromValue();
        this.setValueFromMinMax();
        connectLabel(this);
        connectForm(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
        disconnectLocalized(this);
        this.removeDragListeners();
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
        if (!isRange(this.value)) {
            this.value = this.snap ? this.getClosestStep(this.value) : this.clamp(this.value);
        }
        this.ticksWatcher();
        this.histogramWatcher(this.histogram);
        afterConnectDefaultValueSet(this, this.value);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        if (this.labelHandles) {
            this.adjustHostObscuredHandleLabel("value");
            if (isRange(this.value)) {
                this.adjustHostObscuredHandleLabel("minValue");
                if (!(this.precise && !this.hasHistogram)) {
                    this.hyphenateCollidingRangeHandleLabels();
                }
            }
        }
        this.hideObscuredBoundingTickLabels();
        updateHostInteraction(this);
    }
    render() {
        const id = this.el.id || this.guid;
        const value = isRange(this.value) ? this.maxValue : this.value;
        const min = this.minValue || this.min;
        const useMinValue = this.shouldUseMinValue();
        const minInterval = this.getUnitInterval(useMinValue ? this.minValue : min) * 100;
        const maxInterval = this.getUnitInterval(value) * 100;
        const mirror = this.shouldMirror();
        const valueIsRange = isRange(this.value);
        const thumbTypes = this.buildThumbType("max");
        const thumb = this.renderThumb({
            type: thumbTypes,
            thumbPlacement: thumbTypes.includes("histogram") ? "below" : "above",
            maxInterval,
            minInterval,
            mirror,
        });
        const minThumbTypes = this.buildThumbType("min");
        const minThumb = valueIsRange &&
            this.renderThumb({
                type: minThumbTypes,
                thumbPlacement: minThumbTypes.includes("histogram") || minThumbTypes.includes("precise")
                    ? "below"
                    : "above",
                maxInterval,
                minInterval,
                mirror,
            });
        return (hAsync(Host, { id: id, onTouchStart: this.handleTouchStart }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { "aria-label": getLabelText(this), class: {
                [CSS$n.container]: true,
                [CSS$n.containerRange]: valueIsRange,
                [`scale--${this.scale}`]: true,
            } }, this.renderGraph(), hAsync("div", { class: CSS$n.track,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeTrackRef }, hAsync("div", { class: CSS$n.trackRange, onPointerDown: this.onTrackPointerDown, style: {
                left: `${mirror ? 100 - maxInterval : minInterval}%`,
                right: `${mirror ? minInterval : 100 - maxInterval}%`,
            } }), hAsync("div", { class: CSS$n.ticks }, this.tickValues.map((tick) => {
            const tickOffset = `${this.getUnitInterval(tick) * 100}%`;
            let activeTicks = tick >= min && tick <= value;
            if (useMinValue) {
                activeTicks = tick >= this.minValue && tick <= this.maxValue;
            }
            return (hAsync("span", { class: {
                    [CSS$n.tick]: true,
                    [CSS$n.tickActive]: activeTicks,
                }, style: {
                    left: mirror ? "" : tickOffset,
                    right: mirror ? tickOffset : "",
                } }, this.renderTickLabel(tick)));
        }))), hAsync("div", { class: CSS$n.thumbContainer }, minThumb, thumb, hAsync(HiddenFormInputSlot, { component: this }))))));
    }
    renderThumb({ type, mirror, thumbPlacement, minInterval, maxInterval, }) {
        const isLabeled = type.includes("labeled");
        const isPrecise = type.includes("precise");
        const isMinThumb = type.includes("min");
        const valueIsRange = isRange(this.value);
        const value = isMinThumb
            ? this.minValue
            : valueIsRange
                ? this.maxValue
                : this.value;
        const valueProp = isMinThumb ? "minValue" : valueIsRange ? "maxValue" : "value";
        const ariaLabel = isMinThumb ? this.minLabel : valueIsRange ? this.maxLabel : this.minLabel;
        const ariaValuenow = isMinThumb ? this.minValue : value;
        const displayedValue = isMinThumb ? this.formatValue(this.minValue) : this.formatValue(value);
        const thumbStyle = isMinThumb
            ? { left: `${mirror ? 100 - minInterval : minInterval}%` }
            : { right: `${mirror ? maxInterval : 100 - maxInterval}%` };
        const thumbLabelClasses = `${CSS$n.handleLabel} ${isMinThumb ? CSS$n.handleLabelMinValue : CSS$n.handleLabelValue}`;
        const labels = isLabeled
            ? [
                hAsync("span", { "aria-hidden": "true", class: thumbLabelClasses }, displayedValue),
                hAsync("span", { "aria-hidden": "true", class: `${thumbLabelClasses} ${CSS$n.static}` }, displayedValue),
                hAsync("span", { "aria-hidden": "true", class: `${thumbLabelClasses} ${CSS$n.transformed}` }, displayedValue),
            ]
            : [];
        const thumbContent = [
            ...labels,
            hAsync("div", { class: CSS$n.handle }),
            isPrecise && hAsync("div", { class: CSS$n.handleExtension }),
        ];
        if (thumbPlacement === "below") {
            thumbContent.reverse();
        }
        return (hAsync("div", { "aria-disabled": this.disabled, "aria-label": ariaLabel, "aria-orientation": "horizontal", "aria-valuemax": this.max, "aria-valuemin": this.min, "aria-valuenow": ariaValuenow, class: {
                [CSS$n.thumb]: true,
                [CSS$n.thumbValue]: !isMinThumb,
                [CSS$n.thumbActive]: this.lastDragProp !== "minMaxValue" && this.dragProp === valueProp,
                [CSS$n.thumbPrecise]: isPrecise,
                [CSS$n.thumbMinValue]: isMinThumb,
            }, "data-value-prop": valueProp, key: type, onBlur: this.onThumbBlur, onFocus: this.onThumbFocus, onPointerDown: this.onThumbPointerDown, role: "slider", style: thumbStyle, tabIndex: 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeThumbRef }, thumbContent));
    }
    renderGraph() {
        return this.histogram ? (hAsync("calcite-graph", { class: CSS$n.graph, colorStops: this.histogramStops, data: this.histogram, highlightMax: isRange(this.value) ? this.maxValue : this.value, highlightMin: isRange(this.value) ? this.minValue : this.min, max: this.max, min: this.min })) : null;
    }
    renderTickLabel(tick) {
        const { hasHistogram, labelHandles, labelTicks, max, min, precise, value } = this;
        const valueIsRange = isRange(value);
        const isMinTickLabel = tick === min;
        const isMaxTickLabel = tick === max;
        const isAtEdge = isMinTickLabel || isMaxTickLabel;
        const shouldDisplayLabel = labelTicks &&
            ((!hasHistogram && (isAtEdge || !precise || !valueIsRange)) ||
                (hasHistogram && (isAtEdge || (!precise && !labelHandles))));
        return shouldDisplayLabel ? (hAsync("span", { class: {
                [CSS$n.tickLabel]: true,
                [CSS$n.tickMin]: isMinTickLabel,
                [CSS$n.tickMax]: isMaxTickLabel,
            } }, this.formatValue(tick))) : null;
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    keyDownHandler(event) {
        const mirror = this.shouldMirror();
        const { activeProp, max, min, pageStep, step } = this;
        const value = this[activeProp];
        const { key } = event;
        if (isActivationKey(key)) {
            event.preventDefault();
            return;
        }
        let adjustment;
        if (key === "ArrowUp" || key === "ArrowRight") {
            const directionFactor = mirror && key === "ArrowRight" ? -1 : 1;
            adjustment = value + step * directionFactor;
        }
        else if (key === "ArrowDown" || key === "ArrowLeft") {
            const directionFactor = mirror && key === "ArrowLeft" ? -1 : 1;
            adjustment = value - step * directionFactor;
        }
        else if (key === "PageUp") {
            if (pageStep) {
                adjustment = value + pageStep;
            }
        }
        else if (key === "PageDown") {
            if (pageStep) {
                adjustment = value - pageStep;
            }
        }
        else if (key === "Home") {
            adjustment = min;
        }
        else if (key === "End") {
            adjustment = max;
        }
        if (isNaN(adjustment)) {
            return;
        }
        event.preventDefault();
        const fixedDecimalAdjustment = Number(adjustment.toFixed(decimalPlaces(step)));
        this.setValue({
            [activeProp]: this.clamp(fixedDecimalAdjustment, activeProp),
        });
    }
    pointerDownHandler(event) {
        if (this.disabled || !isPrimaryPointerButton(event)) {
            return;
        }
        const x = event.clientX || event.pageX;
        const position = this.translate(x);
        let prop = "value";
        if (isRange(this.value)) {
            const inRange = position >= this.minValue && position <= this.maxValue;
            if (inRange && this.lastDragProp === "minMaxValue") {
                prop = "minMaxValue";
            }
            else {
                const closerToMax = Math.abs(this.maxValue - position) < Math.abs(this.minValue - position);
                prop = closerToMax || position > this.maxValue ? "maxValue" : "minValue";
            }
        }
        this.lastDragPropValue = this[prop];
        this.dragStart(prop);
        const isThumbActive = this.el.shadowRoot.querySelector(`.${CSS$n.thumb}:active`);
        if (!isThumbActive) {
            this.setValue({ [prop]: this.clamp(position, prop) });
        }
        this.focusActiveHandle(x);
    }
    handleTouchStart(event) {
        // needed to prevent extra click at the end of a handle drag
        event.preventDefault();
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        const handle = this.minHandle ? this.minHandle : this.maxHandle;
        handle?.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    buildThumbType(type) {
        const thumbTypeParts = [type];
        if (this.labelHandles) {
            thumbTypeParts.push("labeled");
        }
        if (this.precise) {
            thumbTypeParts.push("precise");
        }
        if (this.hasHistogram) {
            thumbTypeParts.push("histogram");
        }
        return thumbTypeParts.join("-");
    }
    setValueFromMinMax() {
        const { minValue, maxValue } = this;
        if (typeof minValue === "number" && typeof maxValue === "number") {
            this.value = [minValue, maxValue];
        }
    }
    setMinMaxFromValue() {
        const { value } = this;
        if (isRange(value)) {
            this.minValue = value[0];
            this.maxValue = value[1];
        }
    }
    onLabelClick() {
        this.setFocus();
    }
    shouldMirror() {
        return this.mirrored && !this.hasHistogram;
    }
    shouldUseMinValue() {
        if (!isRange(this.value)) {
            return false;
        }
        return ((this.hasHistogram && this.maxValue === 0) || (!this.hasHistogram && this.minValue === 0));
    }
    getTickDensity() {
        const density = (this.max - this.min) / this.ticks / maxTickElementThreshold;
        return density < 1 ? 1 : density;
    }
    generateTickValues() {
        const tickInterval = this.ticks ?? 0;
        if (tickInterval <= 0) {
            return [];
        }
        const ticks = [this.min];
        const density = this.getTickDensity();
        const tickOffset = tickInterval * density;
        let current = this.min;
        while (current < this.max) {
            current += tickOffset;
            ticks.push(Math.min(current, this.max));
        }
        if (!ticks.includes(this.max)) {
            ticks.push(this.max);
        }
        return ticks;
    }
    pointerDownDragStart(event, prop) {
        if (!isPrimaryPointerButton(event)) {
            return;
        }
        this.dragStart(prop);
    }
    dragStart(prop) {
        this.dragProp = prop;
        this.lastDragProp = this.dragProp;
        this.activeProp = prop;
        window.addEventListener("pointermove", this.dragUpdate);
        window.addEventListener("pointerup", this.pointerUpDragEnd);
        window.addEventListener("pointercancel", this.dragEnd);
    }
    focusActiveHandle(valueX) {
        switch (this.dragProp) {
            case "minValue":
                this.minHandle.focus();
                break;
            case "maxValue":
            case "value":
                this.maxHandle.focus();
                break;
            case "minMaxValue":
                this.getClosestHandle(valueX).focus();
                break;
        }
    }
    emitInput() {
        this.calciteSliderInput.emit();
    }
    emitChange() {
        this.calciteSliderChange.emit();
    }
    removeDragListeners() {
        window.removeEventListener("pointermove", this.dragUpdate);
        window.removeEventListener("pointerup", this.pointerUpDragEnd);
        window.removeEventListener("pointercancel", this.dragEnd);
    }
    /**
     * Set prop value(s) if changed at the component level
     *
     * @param {object} values - a set of key/value pairs delineating what properties in the component to update
     */
    setValue(values) {
        let valueChanged;
        Object.keys(values).forEach((propName) => {
            const newValue = values[propName];
            if (!valueChanged) {
                const oldValue = this[propName];
                valueChanged = oldValue !== newValue;
            }
            this[propName] = newValue;
        });
        if (!valueChanged) {
            return;
        }
        const dragging = this.dragProp;
        if (!dragging) {
            this.emitChange();
        }
        this.emitInput();
    }
    /**
     * If number is outside range, constrain to min or max
     *
     * @param value
     * @param prop
     * @internal
     */
    clamp(value, prop) {
        value = clamp$1(value, this.min, this.max);
        // ensure that maxValue and minValue don't swap positions
        if (prop === "maxValue") {
            value = Math.max(value, this.minValue);
        }
        if (prop === "minValue") {
            value = Math.min(value, this.maxValue);
        }
        return value;
    }
    /**
     * Translate a pixel position to value along the range
     *
     * @param x
     * @internal
     */
    translate(x) {
        const range = this.max - this.min;
        const { left, width } = this.trackEl.getBoundingClientRect();
        const percent = (x - left) / width;
        const mirror = this.shouldMirror();
        const clampedValue = this.clamp(this.min + range * (mirror ? 1 - percent : percent));
        let value = Number(clampedValue.toFixed(decimalPlaces(this.step)));
        if (this.snap && this.step) {
            value = this.getClosestStep(value);
        }
        return value;
    }
    /**
     * Get closest allowed value along stepped values
     *
     * @param num
     * @internal
     */
    getClosestStep(num) {
        num = Number(this.clamp(num).toFixed(decimalPlaces(this.step)));
        if (this.step) {
            const step = Math.round(num / this.step) * this.step;
            num = Number(this.clamp(step).toFixed(decimalPlaces(this.step)));
        }
        return num;
    }
    getClosestHandle(valueX) {
        return this.getDistanceX(this.maxHandle, valueX) > this.getDistanceX(this.minHandle, valueX)
            ? this.minHandle
            : this.maxHandle;
    }
    getDistanceX(el, valueX) {
        return Math.abs(el.getBoundingClientRect().left - valueX);
    }
    getFontSizeForElement(element) {
        return Number(window.getComputedStyle(element).getPropertyValue("font-size").match(/\d+/)[0]);
    }
    /**
     * Get position of value along range as fractional value
     *
     * @param num
     * @return {number} number in the unit interval [0,1]
     * @internal
     */
    getUnitInterval(num) {
        num = this.clamp(num);
        const range = this.max - this.min;
        return (num - this.min) / range;
    }
    adjustHostObscuredHandleLabel(name) {
        const label = this.el.shadowRoot.querySelector(`.handle__label--${name}`);
        const labelStatic = this.el.shadowRoot.querySelector(`.handle__label--${name}.static`);
        const labelTransformed = this.el.shadowRoot.querySelector(`.handle__label--${name}.transformed`);
        const labelStaticBounds = labelStatic.getBoundingClientRect();
        const labelStaticOffset = this.getHostOffset(labelStaticBounds.left, labelStaticBounds.right);
        label.style.transform = `translateX(${labelStaticOffset}px)`;
        labelTransformed.style.transform = `translateX(${labelStaticOffset}px)`;
    }
    hyphenateCollidingRangeHandleLabels() {
        const { shadowRoot } = this.el;
        const mirror = this.shouldMirror();
        const leftModifier = mirror ? "value" : "minValue";
        const rightModifier = mirror ? "minValue" : "value";
        const leftValueLabel = shadowRoot.querySelector(`.handle__label--${leftModifier}`);
        const leftValueLabelStatic = shadowRoot.querySelector(`.handle__label--${leftModifier}.static`);
        const leftValueLabelTransformed = shadowRoot.querySelector(`.handle__label--${leftModifier}.transformed`);
        const leftValueLabelStaticHostOffset = this.getHostOffset(leftValueLabelStatic.getBoundingClientRect().left, leftValueLabelStatic.getBoundingClientRect().right);
        const rightValueLabel = shadowRoot.querySelector(`.handle__label--${rightModifier}`);
        const rightValueLabelStatic = shadowRoot.querySelector(`.handle__label--${rightModifier}.static`);
        const rightValueLabelTransformed = shadowRoot.querySelector(`.handle__label--${rightModifier}.transformed`);
        const rightValueLabelStaticHostOffset = this.getHostOffset(rightValueLabelStatic.getBoundingClientRect().left, rightValueLabelStatic.getBoundingClientRect().right);
        const labelFontSize = this.getFontSizeForElement(leftValueLabel);
        const labelTransformedOverlap = this.getRangeLabelOverlap(leftValueLabelTransformed, rightValueLabelTransformed);
        const hyphenLabel = leftValueLabel;
        const labelOffset = labelFontSize / 2;
        if (labelTransformedOverlap > 0) {
            hyphenLabel.classList.add(CSS$n.hyphen, CSS$n.hyphenWrap);
            if (rightValueLabelStaticHostOffset === 0 && leftValueLabelStaticHostOffset === 0) {
                // Neither handle overlaps the host boundary
                let leftValueLabelTranslate = labelTransformedOverlap / 2 - labelOffset;
                leftValueLabelTranslate =
                    Math.sign(leftValueLabelTranslate) === -1
                        ? Math.abs(leftValueLabelTranslate)
                        : -leftValueLabelTranslate;
                const leftValueLabelTransformedHostOffset = this.getHostOffset(leftValueLabelTransformed.getBoundingClientRect().left +
                    leftValueLabelTranslate -
                    labelOffset, leftValueLabelTransformed.getBoundingClientRect().right +
                    leftValueLabelTranslate -
                    labelOffset);
                let rightValueLabelTranslate = labelTransformedOverlap / 2;
                const rightValueLabelTransformedHostOffset = this.getHostOffset(rightValueLabelTransformed.getBoundingClientRect().left + rightValueLabelTranslate, rightValueLabelTransformed.getBoundingClientRect().right + rightValueLabelTranslate);
                if (leftValueLabelTransformedHostOffset !== 0) {
                    leftValueLabelTranslate += leftValueLabelTransformedHostOffset;
                    rightValueLabelTranslate += leftValueLabelTransformedHostOffset;
                }
                if (rightValueLabelTransformedHostOffset !== 0) {
                    leftValueLabelTranslate += rightValueLabelTransformedHostOffset;
                    rightValueLabelTranslate += rightValueLabelTransformedHostOffset;
                }
                leftValueLabel.style.transform = `translateX(${leftValueLabelTranslate}px)`;
                leftValueLabelTransformed.style.transform = `translateX(${leftValueLabelTranslate - labelOffset}px)`;
                rightValueLabel.style.transform = `translateX(${rightValueLabelTranslate}px)`;
                rightValueLabelTransformed.style.transform = `translateX(${rightValueLabelTranslate}px)`;
            }
            else if (leftValueLabelStaticHostOffset > 0 || rightValueLabelStaticHostOffset > 0) {
                // labels overlap host boundary on the left side
                leftValueLabel.style.transform = `translateX(${leftValueLabelStaticHostOffset + labelOffset}px)`;
                rightValueLabel.style.transform = `translateX(${labelTransformedOverlap + rightValueLabelStaticHostOffset}px)`;
                rightValueLabelTransformed.style.transform = `translateX(${labelTransformedOverlap + rightValueLabelStaticHostOffset}px)`;
            }
            else if (leftValueLabelStaticHostOffset < 0 || rightValueLabelStaticHostOffset < 0) {
                // labels overlap host boundary on the right side
                let leftValueLabelTranslate = Math.abs(leftValueLabelStaticHostOffset) + labelTransformedOverlap - labelOffset;
                leftValueLabelTranslate =
                    Math.sign(leftValueLabelTranslate) === -1
                        ? Math.abs(leftValueLabelTranslate)
                        : -leftValueLabelTranslate;
                leftValueLabel.style.transform = `translateX(${leftValueLabelTranslate}px)`;
                leftValueLabelTransformed.style.transform = `translateX(${leftValueLabelTranslate - labelOffset}px)`;
            }
        }
        else {
            hyphenLabel.classList.remove(CSS$n.hyphen, CSS$n.hyphenWrap);
            leftValueLabel.style.transform = `translateX(${leftValueLabelStaticHostOffset}px)`;
            leftValueLabelTransformed.style.transform = `translateX(${leftValueLabelStaticHostOffset}px)`;
            rightValueLabel.style.transform = `translateX(${rightValueLabelStaticHostOffset}px)`;
            rightValueLabelTransformed.style.transform = `translateX(${rightValueLabelStaticHostOffset}px)`;
        }
    }
    /**
     * Hides bounding tick labels that are obscured by either handle.
     */
    hideObscuredBoundingTickLabels() {
        const valueIsRange = isRange(this.value);
        if (!this.hasHistogram && !valueIsRange && !this.labelHandles && !this.precise) {
            return;
        }
        if (!this.hasHistogram && !valueIsRange && this.labelHandles && !this.precise) {
            return;
        }
        if (!this.hasHistogram && !valueIsRange && !this.labelHandles && this.precise) {
            return;
        }
        if (!this.hasHistogram && !valueIsRange && this.labelHandles && this.precise) {
            return;
        }
        if (!this.hasHistogram && valueIsRange && !this.precise) {
            return;
        }
        if (this.hasHistogram && !this.precise && !this.labelHandles) {
            return;
        }
        const minHandle = this.el.shadowRoot.querySelector(`.${CSS$n.thumbMinValue}`);
        const maxHandle = this.el.shadowRoot.querySelector(`.${CSS$n.thumbValue}`);
        const minTickLabel = this.el.shadowRoot.querySelector(`.${CSS$n.tickMin}`);
        const maxTickLabel = this.el.shadowRoot.querySelector(`.${CSS$n.tickMax}`);
        if (!minHandle && maxHandle && minTickLabel && maxTickLabel) {
            minTickLabel.style.opacity = this.isMinTickLabelObscured(minTickLabel, maxHandle) ? "0" : "1";
            maxTickLabel.style.opacity = this.isMaxTickLabelObscured(maxTickLabel, maxHandle) ? "0" : "1";
        }
        if (minHandle && maxHandle && minTickLabel && maxTickLabel) {
            minTickLabel.style.opacity =
                this.isMinTickLabelObscured(minTickLabel, minHandle) ||
                    this.isMinTickLabelObscured(minTickLabel, maxHandle)
                    ? "0"
                    : "1";
            maxTickLabel.style.opacity =
                this.isMaxTickLabelObscured(maxTickLabel, minHandle) ||
                    (this.isMaxTickLabelObscured(maxTickLabel, maxHandle) && this.hasHistogram)
                    ? "0"
                    : "1";
        }
    }
    /**
     * Returns an integer representing the number of pixels to offset on the left or right side based on desired position behavior.
     *
     * @param leftBounds
     * @param rightBounds
     * @internal
     */
    getHostOffset(leftBounds, rightBounds) {
        const hostBounds = this.el.getBoundingClientRect();
        const buffer = 7;
        if (leftBounds + buffer < hostBounds.left) {
            return hostBounds.left - leftBounds - buffer;
        }
        if (rightBounds - buffer > hostBounds.right) {
            return -(rightBounds - hostBounds.right) + buffer;
        }
        return 0;
    }
    /**
     * Returns an integer representing the number of pixels that the two given span elements are overlapping, taking into account
     * a space in between the two spans equal to the font-size set on them to account for the space needed to render a hyphen.
     *
     * @param leftLabel
     * @param rightLabel
     */
    getRangeLabelOverlap(leftLabel, rightLabel) {
        const leftLabelBounds = leftLabel.getBoundingClientRect();
        const rightLabelBounds = rightLabel.getBoundingClientRect();
        const leftLabelFontSize = this.getFontSizeForElement(leftLabel);
        const rangeLabelOverlap = leftLabelBounds.right + leftLabelFontSize - rightLabelBounds.left;
        return Math.max(rangeLabelOverlap, 0);
    }
    /**
     * Returns a boolean value representing if the minLabel span element is obscured (being overlapped) by the given handle div element.
     *
     * @param minLabel
     * @param handle
     */
    isMinTickLabelObscured(minLabel, handle) {
        const minLabelBounds = minLabel.getBoundingClientRect();
        const handleBounds = handle.getBoundingClientRect();
        return intersects(minLabelBounds, handleBounds);
    }
    /**
     * Returns a boolean value representing if the maxLabel span element is obscured (being overlapped) by the given handle div element.
     *
     * @param maxLabel
     * @param handle
     */
    isMaxTickLabelObscured(maxLabel, handle) {
        const maxLabelBounds = maxLabel.getBoundingClientRect();
        const handleBounds = handle.getBoundingClientRect();
        return intersects(maxLabelBounds, handleBounds);
    }
    static get delegatesFocus() { return true; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "histogram": ["histogramWatcher"],
        "ticks": ["ticksWatcher"],
        "value": ["valueHandler"],
        "minValue": ["minMaxValueHandler"],
        "maxValue": ["minMaxValueHandler"]
    }; }
    static get style() { return sliderCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-slider",
        "$members$": {
            "disabled": [516],
            "form": [513],
            "groupSeparator": [516, "group-separator"],
            "hasHistogram": [1540, "has-histogram"],
            "histogram": [16],
            "histogramStops": [16],
            "labelHandles": [516, "label-handles"],
            "labelTicks": [516, "label-ticks"],
            "max": [514],
            "maxLabel": [1, "max-label"],
            "maxValue": [1026, "max-value"],
            "min": [514],
            "minLabel": [1, "min-label"],
            "minValue": [1026, "min-value"],
            "mirrored": [516],
            "name": [513],
            "numberingSystem": [1, "numbering-system"],
            "pageStep": [514, "page-step"],
            "precise": [516],
            "required": [516],
            "snap": [516],
            "step": [514],
            "ticks": [514],
            "value": [1538],
            "scale": [513],
            "effectiveLocale": [32],
            "minMaxValueRange": [32],
            "minValueDragRange": [32],
            "maxValueDragRange": [32],
            "tickValues": [32],
            "setFocus": [64]
        },
        "$listeners$": [[0, "keydown", "keyDownHandler"], [1, "pointerdown", "pointerDownHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["form", "form"], ["groupSeparator", "group-separator"], ["hasHistogram", "has-histogram"], ["labelHandles", "label-handles"], ["labelTicks", "label-ticks"], ["max", "max"], ["min", "min"], ["mirrored", "mirrored"], ["name", "name"], ["pageStep", "page-step"], ["precise", "precise"], ["required", "required"], ["snap", "snap"], ["step", "step"], ["ticks", "ticks"], ["value", "value"], ["scale", "scale"]]
    }; }
}

const CSS$m = {
    sortItem: "sort-item",
    container: "container",
    containerHorizontal: "container--horizontal",
    containerVertical: "container--vertical",
};

const sortableListCss = "/*!@:host([disabled])*/[disabled].sc-calcite-sortable-list-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-sortable-list-h *.sc-calcite-sortable-list,.sc-calcite-sortable-list-h[disabled].sc-calcite-sortable-list-s>*,.sc-calcite-sortable-list-h[disabled] .sc-calcite-sortable-list-s>*{pointer-events:none}/*!@:host*/.sc-calcite-sortable-list-h{display:flex}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-sortable-list-h[disabled] .sc-calcite-sortable-list-s>[calcite-hydrated][disabled],[disabled].sc-calcite-sortable-list-h [calcite-hydrated][disabled].sc-calcite-sortable-list{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-sortable-list{display:contents}/*!@.container*/.container.sc-calcite-sortable-list{display:flex;flex:1 1 auto}/*!@.container--vertical*/.container--vertical.sc-calcite-sortable-list{flex-direction:column}/*!@.container--horizontal*/.container--horizontal.sc-calcite-sortable-list{flex-direction:row}/*!@:host([hidden])*/[hidden].sc-calcite-sortable-list-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-sortable-list{display:none}";

/**
 * @slot - A slot for adding sortable items.
 */
class SortableList {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteListOrderChange = createEvent(this, "calciteListOrderChange", 6);
        this.items = [];
        this.mutationObserver = createObserver();
        this.dragEnabled = true;
        this.canPull = undefined;
        this.canPut = undefined;
        this.dragSelector = undefined;
        this.group = undefined;
        this.handleSelector = "calcite-handle";
        this.layout = "vertical";
        this.disabled = false;
        this.loading = false;
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        if (dragActive(this)) {
            return;
        }
        this.setUpSorting();
        this.beginObserving();
        connectInteractive(this);
    }
    disconnectedCallback() {
        if (dragActive(this)) {
            return;
        }
        disconnectInteractive(this);
        disconnectSortableComponent(this);
        this.endObserving();
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    calciteHandleNudgeNextHandler(event) {
        this.handleNudgeEvent(event);
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    onGlobalDragStart() {
        this.endObserving();
    }
    onGlobalDragEnd() {
        this.beginObserving();
    }
    onDragEnd() { }
    onDragStart() { }
    onDragSort() {
        this.items = Array.from(this.el.children);
        this.calciteListOrderChange.emit();
    }
    handleNudgeEvent(event) {
        const { direction } = event.detail;
        const handle = event
            .composedPath()
            .find((el) => el.matches(this.handleSelector));
        const sortItem = this.items.find((item) => {
            return item.contains(handle) || event.composedPath().includes(item);
        });
        const lastIndex = this.items.length - 1;
        const startingIndex = this.items.indexOf(sortItem);
        let appendInstead = false;
        let buddyIndex;
        if (direction === "up") {
            if (startingIndex === 0) {
                appendInstead = true;
            }
            else {
                buddyIndex = startingIndex - 1;
            }
        }
        else {
            if (startingIndex === lastIndex) {
                buddyIndex = 0;
            }
            else if (startingIndex === lastIndex - 1) {
                appendInstead = true;
            }
            else {
                buddyIndex = startingIndex + 2;
            }
        }
        this.endObserving();
        if (appendInstead) {
            sortItem.parentElement.appendChild(sortItem);
        }
        else {
            sortItem.parentElement.insertBefore(sortItem, this.items[buddyIndex]);
        }
        this.items = Array.from(this.el.children);
        this.beginObserving();
        requestAnimationFrame(() => focusElement(handle));
        if ("selected" in handle) {
            handle.selected = true;
        }
    }
    setUpSorting() {
        this.items = Array.from(this.el.children);
        connectSortableComponent(this);
    }
    beginObserving() {
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
    }
    endObserving() {
        this.mutationObserver?.disconnect();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const { disabled, layout } = this;
        const horizontal = layout === "horizontal" || false;
        return (hAsync(InteractiveContainer, { disabled: disabled }, hAsync("div", { class: {
                [CSS$m.container]: true,
                [CSS$m.containerVertical]: !horizontal,
                [CSS$m.containerHorizontal]: horizontal,
            } }, hAsync("slot", null))));
    }
    get el() { return getElement(this); }
    static get style() { return sortableListCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-sortable-list",
        "$members$": {
            "canPull": [16],
            "canPut": [16],
            "dragSelector": [513, "drag-selector"],
            "group": [513],
            "handleSelector": [513, "handle-selector"],
            "layout": [513],
            "disabled": [516],
            "loading": [516]
        },
        "$listeners$": [[0, "calciteHandleNudge", "calciteHandleNudgeNextHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["dragSelector", "drag-selector"], ["group", "group"], ["handleSelector", "handle-selector"], ["layout", "layout"], ["disabled", "disabled"], ["loading", "loading"]]
    }; }
}

const CSS$l = {
    container: "container",
    dividerContainer: "divider-container",
    divider: "divider",
    widthAuto: "width-auto",
    widthHalf: "width-half",
    widthFull: "width-full",
};

const splitButtonCss = "/*!@:host([disabled])*/[disabled].sc-calcite-split-button-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-split-button-h *.sc-calcite-split-button,.sc-calcite-split-button-h[disabled].sc-calcite-split-button-s>*,.sc-calcite-split-button-h[disabled] .sc-calcite-split-button-s>*{pointer-events:none}/*!@:host*/.sc-calcite-split-button-h{display:inline-block}/*!@:host([width=auto])*/[width=auto].sc-calcite-split-button-h{inline-size:auto}/*!@:host([width=half])*/[width=half].sc-calcite-split-button-h{inline-size:50%}/*!@:host([width=full])*/[width=full].sc-calcite-split-button-h{inline-size:100%}/*!@:host:host([kind=brand])*/.sc-calcite-split-button-h([kind=brand]).sc-calcite-split-button-h{--calcite-split-button-background:var(--calcite-color-brand);--calcite-split-button-divider:var(--calcite-color-foreground-1)}/*!@:host:host([kind=danger])*/.sc-calcite-split-button-h([kind=danger]).sc-calcite-split-button-h{--calcite-split-button-background:var(--calcite-color-status-danger);--calcite-split-button-divider:var(--calcite-color-foreground-1)}/*!@:host:host([kind=neutral])*/.sc-calcite-split-button-h([kind=neutral]).sc-calcite-split-button-h{--calcite-split-button-background:var(--calcite-color-foreground-3);--calcite-split-button-divider:var(--calcite-color-text-1)}/*!@:host:host([kind=inverse])*/.sc-calcite-split-button-h([kind=inverse]).sc-calcite-split-button-h{--calcite-split-button-background:var(--calcite-color-inverse);--calcite-split-button-divider:var(--calcite-color-foreground-1)}/*!@:host([appearance=transparent]):host([kind=brand])*/[appearance=transparent].sc-calcite-split-button-h([kind=brand]).sc-calcite-split-button-h{--calcite-split-button-divider:var(--calcite-color-brand);--calcite-split-button-background:transparent}/*!@:host([appearance=transparent]):host([kind=danger])*/[appearance=transparent].sc-calcite-split-button-h([kind=danger]).sc-calcite-split-button-h{--calcite-split-button-divider:var(--calcite-color-status-danger);--calcite-split-button-background:transparent}/*!@:host([appearance=transparent]):host([kind=neutral])*/[appearance=transparent].sc-calcite-split-button-h([kind=neutral]).sc-calcite-split-button-h{--calcite-split-button-divider:var(--calcite-color-text-1);--calcite-split-button-background:transparent}/*!@:host([appearance=transparent]):host([kind=inverse])*/[appearance=transparent].sc-calcite-split-button-h([kind=inverse]).sc-calcite-split-button-h{--calcite-split-button-divider:var(--calcite-color-foreground-1);--calcite-split-button-background:transparent}/*!@:host([appearance=outline])*/[appearance=outline].sc-calcite-split-button-h{--calcite-split-button-background:transparent}/*!@:host([appearance=outline-fill])*/[appearance=outline-fill].sc-calcite-split-button-h{--calcite-split-button-background:var(--calcite-color-foreground-1)}/*!@:host([appearance=outline]):host([kind=brand]),\n:host([appearance=outline-fill]):host([kind=brand])*/[appearance=outline].sc-calcite-split-button-h([kind=brand]).sc-calcite-split-button-h,[appearance=outline-fill].sc-calcite-split-button-h([kind=brand]).sc-calcite-split-button-h{--calcite-split-button-divider:var(--calcite-color-brand)}/*!@:host([appearance=outline]):host([kind=danger]),\n:host([appearance=outline-fill]):host([kind=danger])*/[appearance=outline].sc-calcite-split-button-h([kind=danger]).sc-calcite-split-button-h,[appearance=outline-fill].sc-calcite-split-button-h([kind=danger]).sc-calcite-split-button-h{--calcite-split-button-divider:var(--calcite-color-status-danger)}/*!@:host([appearance=outline]):host([kind=neutral]),\n:host([appearance=outline-fill]):host([kind=neutral])*/[appearance=outline].sc-calcite-split-button-h([kind=neutral]).sc-calcite-split-button-h,[appearance=outline-fill].sc-calcite-split-button-h([kind=neutral]).sc-calcite-split-button-h{--calcite-split-button-divider:var(--calcite-color-border-1);--calcite-split-button-background:var(--calcite-color-border-1)}/*!@:host([appearance=outline]):host([kind=inverse]),\n:host([appearance=outline-fill]):host([kind=inverse])*/[appearance=outline].sc-calcite-split-button-h([kind=inverse]).sc-calcite-split-button-h,[appearance=outline-fill].sc-calcite-split-button-h([kind=inverse]).sc-calcite-split-button-h{--calcite-split-button-divider:var(--calcite-color-inverse)}/*!@.container*/.container.sc-calcite-split-button{display:flex;align-items:stretch}/*!@.container > calcite-dropdown > calcite-button*/.container.sc-calcite-split-button>calcite-dropdown.sc-calcite-split-button>calcite-button.sc-calcite-split-button{block-size:100%;vertical-align:top}/*!@.divider-container*/.divider-container.sc-calcite-split-button{display:flex;inline-size:1px;align-items:stretch;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;background-color:var(--calcite-split-button-background)}/*!@.divider*/.divider.sc-calcite-split-button{margin-block:0.25rem;display:inline-block;inline-size:1px;background-color:var(--calcite-split-button-divider)}/*!@:host([appearance=outline-fill]) .divider-container,\n:host([appearance=outline]) .divider-container*/[appearance=outline-fill].sc-calcite-split-button-h .divider-container.sc-calcite-split-button,[appearance=outline].sc-calcite-split-button-h .divider-container.sc-calcite-split-button{border-block:1px solid var(--calcite-split-button-divider)}/*!@:host([appearance=outline-fill]):hover .divider-container,\n:host([appearance=outline]):hover .divider-container*/[appearance=outline-fill].sc-calcite-split-button-h:hover .divider-container.sc-calcite-split-button,[appearance=outline].sc-calcite-split-button-h:hover .divider-container.sc-calcite-split-button{background-color:var(--calcite-split-button-divider)}/*!@:host([appearance=outline-fill]:hover) .divider-container,\n:host([appearance=outline]:hover) .divider-container*/[appearance=outline-fill].sc-calcite-split-button-h:hover .divider-container.sc-calcite-split-button,[appearance=outline].sc-calcite-split-button-h:hover .divider-container.sc-calcite-split-button{background-color:var(--calcite-split-button-divider)}/*!@:host([appearance=outline-fill]:focus-within):host([kind=brand]),\n:host([appearance=outline]:focus-within):host([kind=brand])*/[appearance=outline-fill].sc-calcite-split-button-h:focus-within.sc-calcite-split-button-h([kind=brand]),[appearance=outline].sc-calcite-split-button-h:focus-within.sc-calcite-split-button-h([kind=brand]){--calcite-split-button-divider:var(--calcite-color-brand-press)}/*!@:host([appearance=outline-fill]:focus-within):host([kind=danger]),\n:host([appearance=outline]:focus-within):host([kind=danger])*/[appearance=outline-fill].sc-calcite-split-button-h:focus-within.sc-calcite-split-button-h([kind=danger]),[appearance=outline].sc-calcite-split-button-h:focus-within.sc-calcite-split-button-h([kind=danger]){--calcite-split-button-divider:var(--calcite-color-status-danger-press)}/*!@:host([appearance=outline-fill]:focus-within) .divider-container,\n:host([appearance=outline]:focus-within) .divider-container*/[appearance=outline-fill].sc-calcite-split-button-h:focus-within .divider-container.sc-calcite-split-button,[appearance=outline].sc-calcite-split-button-h:focus-within .divider-container.sc-calcite-split-button{background-color:var(--calcite-split-button-divider)}/*!@:host([disabled]) .divider-container*/[disabled].sc-calcite-split-button-h .divider-container.sc-calcite-split-button{opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) calcite-dropdown > calcite-button*/[disabled].sc-calcite-split-button-h calcite-dropdown.sc-calcite-split-button>calcite-button.sc-calcite-split-button{pointer-events:none}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-split-button-h[disabled] .sc-calcite-split-button-s>[calcite-hydrated][disabled],[disabled].sc-calcite-split-button-h [calcite-hydrated][disabled].sc-calcite-split-button{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-split-button{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-split-button-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-split-button{display:none}";

/**
 * @slot - A slot for adding `calcite-dropdown` content.
 */
class SplitButton {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteSplitButtonPrimaryClick = createEvent(this, "calciteSplitButtonPrimaryClick", 6);
        this.calciteSplitButtonSecondaryClick = createEvent(this, "calciteSplitButtonSecondaryClick", 6);
        this.calciteSplitButtonPrimaryClickHandler = () => this.calciteSplitButtonPrimaryClick.emit();
        this.calciteSplitButtonSecondaryClickHandler = () => this.calciteSplitButtonSecondaryClick.emit();
        this.appearance = "solid";
        this.kind = "brand";
        this.disabled = false;
        this.active = false;
        this.dropdownIconType = "chevron";
        this.dropdownLabel = undefined;
        this.loading = false;
        this.overlayPositioning = "absolute";
        this.primaryIconEnd = undefined;
        this.primaryIconFlipRtl = undefined;
        this.primaryIconStart = undefined;
        this.primaryLabel = undefined;
        this.primaryText = undefined;
        this.scale = "m";
        this.width = "auto";
    }
    handleDisabledChange(value) {
        if (!value) {
            this.active = false;
        }
    }
    activeHandler() {
        if (this.disabled) {
            this.active = false;
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component's first focusable element. */
    async setFocus() {
        await componentFocusable(this);
        this.el.focus();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
    }
    render() {
        const buttonWidth = this.width === "auto" ? "auto" : "full";
        return (hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: CSS$l.container }, hAsync("calcite-button", { appearance: this.appearance, disabled: this.disabled, "icon-end": this.primaryIconEnd ? this.primaryIconEnd : null, "icon-start": this.primaryIconStart ? this.primaryIconStart : null, iconFlipRtl: this.primaryIconFlipRtl ? this.primaryIconFlipRtl : null, kind: this.kind, label: this.primaryLabel, loading: this.loading, onClick: this.calciteSplitButtonPrimaryClickHandler, scale: this.scale, splitChild: "primary", type: "button", width: buttonWidth }, this.primaryText), hAsync("div", { class: CSS$l.dividerContainer }, hAsync("div", { class: CSS$l.divider })), hAsync("calcite-dropdown", { disabled: this.disabled, onClick: this.calciteSplitButtonSecondaryClickHandler, open: this.active, overlayPositioning: this.overlayPositioning, placement: "bottom-end", scale: this.scale, "width-scale": this.scale }, hAsync("calcite-button", { appearance: this.appearance, disabled: this.disabled, "icon-start": this.dropdownIcon, kind: this.kind, label: this.dropdownLabel, scale: this.scale, slot: "trigger", splitChild: "secondary", type: "button" }), hAsync("slot", null)))));
    }
    get dropdownIcon() {
        return this.dropdownIconType === "chevron"
            ? "chevronDown"
            : this.dropdownIconType === "caret"
                ? "caretDown"
                : this.dropdownIconType === "ellipsis"
                    ? "ellipsis"
                    : "handle-vertical";
    }
    static get delegatesFocus() { return true; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "disabled": ["handleDisabledChange"],
        "active": ["activeHandler"]
    }; }
    static get style() { return splitButtonCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-split-button",
        "$members$": {
            "appearance": [513],
            "kind": [513],
            "disabled": [516],
            "active": [1540],
            "dropdownIconType": [513, "dropdown-icon-type"],
            "dropdownLabel": [513, "dropdown-label"],
            "loading": [516],
            "overlayPositioning": [513, "overlay-positioning"],
            "primaryIconEnd": [513, "primary-icon-end"],
            "primaryIconFlipRtl": [513, "primary-icon-flip-rtl"],
            "primaryIconStart": [513, "primary-icon-start"],
            "primaryLabel": [513, "primary-label"],
            "primaryText": [513, "primary-text"],
            "scale": [513],
            "width": [513],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["appearance", "appearance"], ["kind", "kind"], ["disabled", "disabled"], ["active", "active"], ["dropdownIconType", "dropdown-icon-type"], ["dropdownLabel", "dropdown-label"], ["loading", "loading"], ["overlayPositioning", "overlay-positioning"], ["primaryIconEnd", "primary-icon-end"], ["primaryIconFlipRtl", "primary-icon-flip-rtl"], ["primaryIconStart", "primary-icon-start"], ["primaryLabel", "primary-label"], ["primaryText", "primary-text"], ["scale", "scale"], ["width", "width"]]
    }; }
}

const stackCss = "/*!@:host([disabled]) .content*/[disabled].sc-calcite-stack-h .content.sc-calcite-stack{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) .content *,\n:host([disabled]) .content ::slotted(*)*/[disabled].sc-calcite-stack-h .content.sc-calcite-stack *.sc-calcite-stack,.sc-calcite-stack-h[disabled] .content.sc-calcite-stack-s>*,.sc-calcite-stack-h[disabled] .content .sc-calcite-stack-s>*{pointer-events:none}/*!@:host*/.sc-calcite-stack-h{display:flex;flex:1 1 0%;flex-direction:column}/*!@.container*/.container.sc-calcite-stack{display:flex;flex:1 1 auto;align-items:stretch;font-family:var(--calcite-sans-family);font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-2)}/*!@.content*/.content.sc-calcite-stack{display:flex;flex:1 1 auto;flex-direction:column;justify-content:center;font-size:var(--calcite-font-size--2);line-height:1.375;padding-inline:var(--calcite-stack-padding-inline, 0.75rem);padding-block:var(--calcite-stack-padding-block, 0.5rem)}/*!@.content-start*/.content-start.sc-calcite-stack{justify-content:flex-start}/*!@.content-end*/.content-end.sc-calcite-stack{justify-content:flex-end}/*!@.content-start,\n.content-end*/.content-start.sc-calcite-stack,.content-end.sc-calcite-stack{flex:0 1 auto}/*!@.actions-start,\n.actions-end,\n.content-start,\n.content-end*/.actions-start.sc-calcite-stack,.actions-end.sc-calcite-stack,.content-start.sc-calcite-stack,.content-end.sc-calcite-stack{display:flex;align-items:center}/*!@.content-start ::slotted(calcite-icon),\n.content-end ::slotted(calcite-icon)*/.content-start .sc-calcite-stack-s>calcite-icon,.content-end.sc-calcite-stack-s>calcite-icon,.content-end .sc-calcite-stack-s>calcite-icon{margin-inline:0.75rem;align-self:center}/*!@.actions-start ::slotted(calcite-action),\n.actions-start ::slotted(calcite-action-menu),\n.actions-start ::slotted(calcite-handle),\n.actions-start ::slotted(calcite-dropdown),\n.actions-end ::slotted(calcite-action),\n.actions-end ::slotted(calcite-action-menu),\n.actions-end ::slotted(calcite-handle),\n.actions-end ::slotted(calcite-dropdown)*/.actions-start .sc-calcite-stack-s>calcite-action,.actions-start.sc-calcite-stack-s>calcite-action-menu,.actions-start .sc-calcite-stack-s>calcite-action-menu,.actions-start.sc-calcite-stack-s>calcite-handle,.actions-start .sc-calcite-stack-s>calcite-handle,.actions-start.sc-calcite-stack-s>calcite-dropdown,.actions-start .sc-calcite-stack-s>calcite-dropdown,.actions-end.sc-calcite-stack-s>calcite-action,.actions-end .sc-calcite-stack-s>calcite-action,.actions-end.sc-calcite-stack-s>calcite-action-menu,.actions-end .sc-calcite-stack-s>calcite-action-menu,.actions-end.sc-calcite-stack-s>calcite-handle,.actions-end .sc-calcite-stack-s>calcite-handle,.actions-end.sc-calcite-stack-s>calcite-dropdown,.actions-end .sc-calcite-stack-s>calcite-dropdown{align-self:stretch;color:inherit}/*!@:host([hidden])*/[hidden].sc-calcite-stack-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-stack{display:none}";

/**
 * @slot - A slot for adding content.
 * @slot actions-start - A slot for adding actionable `calcite-action` elements before the content of the component.
 * @slot content-start - A slot for adding non-actionable elements before content of the component.
 * @slot content-end - A slot for adding non-actionable elements after content of the component.
 * @slot actions-end - A slot for adding actionable `calcite-action` elements after the content of the component.
 */
class Stack {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.handleActionsStartSlotChange = (event) => {
            this.hasActionsStart = slotChangeHasAssignedElement(event);
        };
        this.handleActionsEndSlotChange = (event) => {
            this.hasActionsEnd = slotChangeHasAssignedElement(event);
        };
        this.handleContentStartSlotChange = (event) => {
            this.hasContentStart = slotChangeHasAssignedElement(event);
        };
        this.handleContentEndSlotChange = (event) => {
            this.hasContentEnd = slotChangeHasAssignedElement(event);
        };
        this.disabled = false;
        this.hasActionsStart = false;
        this.hasActionsEnd = false;
        this.hasContentStart = false;
        this.hasContentEnd = false;
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderActionsStart() {
        const { hasActionsStart } = this;
        return (hAsync("div", { class: CSS$I.actionsStart, hidden: !hasActionsStart, key: "actions-start-container" }, hAsync("slot", { name: SLOTS$g.actionsStart, onSlotchange: this.handleActionsStartSlotChange })));
    }
    renderActionsEnd() {
        const { hasActionsEnd } = this;
        return (hAsync("div", { class: CSS$I.actionsEnd, hidden: !hasActionsEnd, key: "actions-end-container" }, hAsync("slot", { name: SLOTS$g.actionsEnd, onSlotchange: this.handleActionsEndSlotChange })));
    }
    renderContentStart() {
        const { hasContentStart } = this;
        return (hAsync("div", { class: CSS$I.contentStart, hidden: !hasContentStart }, hAsync("slot", { name: SLOTS$g.contentStart, onSlotchange: this.handleContentStartSlotChange })));
    }
    renderDefaultContent() {
        return (hAsync("div", { class: CSS$I.content }, hAsync("slot", null)));
    }
    renderContentEnd() {
        const { hasContentEnd } = this;
        return (hAsync("div", { class: CSS$I.contentEnd, hidden: !hasContentEnd }, hAsync("slot", { name: SLOTS$g.contentEnd, onSlotchange: this.handleContentEndSlotChange })));
    }
    render() {
        return (hAsync(Host, null, hAsync("div", { class: CSS$I.container }, this.renderActionsStart(), this.renderContentStart(), this.renderDefaultContent(), this.renderContentEnd(), this.renderActionsEnd())));
    }
    static get style() { return stackCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-stack",
        "$members$": {
            "disabled": [516],
            "hasActionsStart": [32],
            "hasActionsEnd": [32],
            "hasContentStart": [32],
            "hasContentEnd": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"]]
    }; }
}

const CSS$k = {
    stepBar: "step-bar",
    stepBarActive: "step-bar--active",
    stepBarComplete: "step-bar--complete",
    stepBarDisabled: "step-bar--disabled",
    stepBarError: "step-bar--error",
    stepBarInActive: "step-bar--inactive",
};
const StepBar = ({ disabled, active, complete, error, key, }) => (hAsync("svg", { class: {
        [CSS$k.stepBar]: true,
    }, key: key },
    hAsync("rect", { class: {
            [CSS$k.stepBarActive]: active,
            [CSS$k.stepBarComplete]: complete,
            [CSS$k.stepBarDisabled]: disabled,
            [CSS$k.stepBarError]: error,
            [CSS$k.stepBarInActive]: true,
        }, width: "100%", x: "0", y: "0" })));

const CSS$j = {
    actionIcon: "action-icon",
    actionIconStart: "action-icon--start",
    actionIconEnd: "action-icon--end",
    actionContainer: "action-container",
    stepBarContainer: "step-bar-container",
    singleView: "single-view",
};

const stepperCss = "/*!@:host([scale=s])*/[scale=s].sc-calcite-stepper-h{--calcite-internal-stepper-item-spacing-unit-s:0.25rem;--calcite-internal-stepper-action-block-size:2.75rem;--calcite-internal-stepper-action-inline-size:2rem;--calcite-internal-step-bar-gap:0.25rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-stepper-h{--calcite-internal-stepper-item-spacing-unit-s:0.5rem;--calcite-internal-stepper-action-block-size:3.25rem;--calcite-internal-stepper-action-inline-size:2.5rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-stepper-h{--calcite-internal-stepper-item-spacing-unit-s:0.75rem;--calcite-internal-stepper-action-block-size:4rem;--calcite-internal-stepper-action-inline-size:3rem;--calcite-internal-step-bar-gap:0.75rem}/*!@:host*/.sc-calcite-stepper-h{display:flex}/*!@.container*/.container.sc-calcite-stepper{position:relative;display:flex;inline-size:100%;min-inline-size:-moz-fit-content;min-inline-size:fit-content;flex-direction:row;flex-wrap:wrap;align-items:stretch;justify-content:space-between}/*!@:host([layout=vertical]) .container*/[layout=vertical].sc-calcite-stepper-h .container.sc-calcite-stepper{flex:1 1 auto;flex-direction:column}/*!@:host([layout=horizontal]) .container,\n:host([layout=horizontal-single]) .container*/[layout=horizontal].sc-calcite-stepper-h .container.sc-calcite-stepper,[layout=horizontal-single].sc-calcite-stepper-h .container.sc-calcite-stepper{display:grid;grid-template-areas:\"items\" \"content\";gap:0.5rem var(--calcite-internal-stepper-item-spacing-unit-s)}/*!@:host([layout=horizontal][scale=s]) .container,\n:host([layout=horizontal-single][scale=s]) .container*/[layout=horizontal][scale=s].sc-calcite-stepper-h .container.sc-calcite-stepper,[layout=horizontal-single][scale=s].sc-calcite-stepper-h .container.sc-calcite-stepper{gap:0.25rem var(--calcite-internal-stepper-item-spacing-unit-s)}/*!@:host([layout=horizontal][scale=l]) .container,\n:host([layout=horizontal-single][scale=l]) .container*/[layout=horizontal][scale=l].sc-calcite-stepper-h .container.sc-calcite-stepper,[layout=horizontal-single][scale=l].sc-calcite-stepper-h .container.sc-calcite-stepper{gap:0.75rem var(--calcite-internal-stepper-item-spacing-unit-s)}/*!@:host([layout=horizontal]) .container.single-view*/[layout=horizontal].sc-calcite-stepper-h .container.single-view.sc-calcite-stepper{display:flex;grid-template-columns:none}/*!@.action-icon*/.action-icon.sc-calcite-stepper{position:relative;display:flex;flex-grow:0;block-size:var(--calcite-internal-stepper-action-block-size);inline-size:var(--calcite-internal-stepper-action-inline-size)}/*!@.action-container*/.action-container.sc-calcite-stepper{position:absolute;display:flex;justify-content:space-between;padding-block:0.25rem;inline-size:100%}/*!@.step-bar*/.step-bar.sc-calcite-stepper{display:flex;block-size:100%;inline-size:100%}/*!@.step-bar-container*/.step-bar-container.sc-calcite-stepper{position:absolute;display:flex;align-items:flex-start;justify-content:space-between;block-size:0.125rem;inline-size:100%;gap:var(--calcite-internal-step-bar-gap, 0.5rem)}/*!@.step-bar--inactive*/.step-bar--inactive.sc-calcite-stepper{fill:var(--calcite-color-border-3, #dfdfdf);fill-opacity:1;block-size:100%}/*!@.step-bar--active*/.step-bar--active.sc-calcite-stepper{fill:var(--calcite-color-brand)}/*!@.step-bar--complete*/.step-bar--complete.sc-calcite-stepper{fill:var(--calcite-color-brand);fill-opacity:0.5}/*!@.step-bar--error*/.step-bar--error.sc-calcite-stepper{fill:var(--calcite-color-status-danger)}/*!@.step-bar--disabled*/.step-bar--disabled.sc-calcite-stepper{opacity:0.5}/*!@:host([hidden])*/[hidden].sc-calcite-stepper-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-stepper{display:none}";

/**
 * @slot - A slot for adding `calcite-stepper-item` elements.
 */
class Stepper {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteStepperItemChange = createEvent(this, "calciteStepperItemChange", 6);
        this.calciteInternalStepperItemChange = createEvent(this, "calciteInternalStepperItemChange", 6);
        this.enabledItems = [];
        this.itemMap = new Map();
        this.items = [];
        this.mutationObserver = createObserver();
        /** Specifies if the user is viewing one `stepper-item` at a time when the page width is less than sum of min-width of each item. */
        this.multipleViewMode = false;
        this.guid = `calcite-stepper-action-${guid()}`;
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.resizeObserver = createObserver();
        this.handleActionClick = (event) => {
            const currentActivePosition = this.currentActivePosition;
            const target = event.target;
            if (target.getAttribute("data-position") === "start") {
                this.prevStep();
            }
            else {
                this.nextStep();
            }
            if (typeof this.currentActivePosition === "number" &&
                currentActivePosition !== this.currentActivePosition &&
                !this.items[this.currentActivePosition].disabled) {
                this.calciteStepperItemChange.emit();
            }
        };
        this.setContainerEl = (el) => {
            this.containerEl = el;
        };
        this.handleDefaultSlotChange = (event) => {
            const items = slotChangeGetAssignedElements(event).filter((el) => el?.tagName === "CALCITE-STEPPER-ITEM");
            this.items = items;
            const spacing = Array(items.length).fill("1fr").join(" ");
            this.containerEl.style.gridTemplateAreas = spacing;
            this.containerEl.style.gridTemplateColumns = spacing;
            this.setStepperItemNumberingSystem();
        };
        this.icon = false;
        this.layout = "horizontal";
        this.numbered = false;
        this.scale = "m";
        this.messages = undefined;
        this.numberingSystem = undefined;
        this.selectedItem = null;
        this.messageOverrides = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
        this.currentActivePosition = undefined;
        this.elWidth = undefined;
    }
    handleItemPropChange() {
        this.updateItems();
    }
    numberingSystemChange() {
        this.setStepperItemNumberingSystem();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.mutationObserver?.observe(this.el, { childList: true });
        this.updateItems();
        connectMessages(this);
        connectLocalized(this);
    }
    async componentWillLoad() {
        await setUpMessages(this);
    }
    componentDidLoad() {
        this.resizeObserver?.observe(this.containerEl);
        // if no stepper items are set as active, default to the first one
        if (typeof this.currentActivePosition !== "number") {
            const enabledStepIndex = this.getFirstEnabledStepperPosition();
            if (enabledStepIndex === 0) {
                this.currentActivePosition = enabledStepIndex;
            }
            this.calciteInternalStepperItemChange.emit({
                position: enabledStepIndex,
            });
        }
    }
    disconnectedCallback() {
        this.resizeObserver?.disconnect();
        disconnectMessages(this);
        disconnectLocalized(this);
        this.mutationObserver?.disconnect();
    }
    render() {
        return (hAsync(Host, { "aria-label": this.messages.label, role: "region" }, hAsync("div", { class: { container: true, [CSS$j.singleView]: this.layout === "horizontal-single" }, ref: this.setContainerEl }, this.layout === "horizontal-single" && (hAsync("div", { class: { [CSS$j.stepBarContainer]: true } }, this.items.map((item, index) => (hAsync(StepBar, { active: index === this.currentActivePosition, complete: item.complete && index !== this.currentActivePosition && !item.error, disabled: item.disabled && index !== this.currentActivePosition, error: item.error && index !== this.currentActivePosition, key: index }))))), this.layout === "horizontal-single" && (hAsync("div", { class: { [CSS$j.actionContainer]: true } }, this.renderAction("start"), this.renderAction("end"))), hAsync("slot", { onSlotchange: this.handleDefaultSlotChange }))));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    calciteInternalStepperItemKeyEvent(event) {
        const item = event.detail.item;
        const itemToFocus = event.target;
        switch (item.key) {
            case "ArrowDown":
            case "ArrowRight":
                focusElementInGroup(this.enabledItems, itemToFocus, "next");
                break;
            case "ArrowUp":
            case "ArrowLeft":
                focusElementInGroup(this.enabledItems, itemToFocus, "previous");
                break;
            case "Home":
                focusElementInGroup(this.enabledItems, itemToFocus, "first");
                break;
            case "End":
                focusElementInGroup(this.enabledItems, itemToFocus, "last");
                break;
        }
        event.stopPropagation();
    }
    registerItem(event) {
        const item = event.target;
        const { content, position } = event.detail;
        this.itemMap.set(item, { position, content });
        this.enabledItems = this.filterItems();
        event.stopPropagation();
    }
    updateItem(event) {
        const { position } = event.detail;
        if (typeof position === "number") {
            this.currentActivePosition = position;
            this.selectedItem = event.target;
        }
        this.calciteInternalStepperItemChange.emit({
            position,
        });
    }
    handleUserRequestedStepperItemSelect() {
        this.calciteStepperItemChange.emit();
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Set the next `calcite-stepper-item` as active. */
    async nextStep() {
        const enabledStepIndex = this.getEnabledStepIndex(this.currentActivePosition + 1, "next");
        if (typeof enabledStepIndex !== "number") {
            return;
        }
        this.updateStep(enabledStepIndex);
    }
    /** Set the previous `calcite-stepper-item` as active. */
    async prevStep() {
        const enabledStepIndex = this.getEnabledStepIndex(this.currentActivePosition - 1, "previous");
        if (typeof enabledStepIndex !== "number") {
            return;
        }
        this.updateStep(enabledStepIndex);
    }
    /**
     * Set a specified `calcite-stepper-item` as active.
     *
     * @param step
     */
    async goToStep(step) {
        const position = step - 1;
        if (this.currentActivePosition !== position) {
            this.updateStep(position);
        }
    }
    /** Set the first `calcite-stepper-item` as active. */
    async startStep() {
        const enabledStepIndex = this.getEnabledStepIndex(0, "next");
        if (typeof enabledStepIndex !== "number") {
            return;
        }
        this.updateStep(enabledStepIndex);
    }
    /** Set the last `calcite-stepper-item` as active. */
    async endStep() {
        const enabledStepIndex = this.getEnabledStepIndex(this.items.length - 1, "previous");
        if (typeof enabledStepIndex !== "number") {
            return;
        }
        this.updateStep(enabledStepIndex);
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    handlePositionChange() {
        readTask(() => {
            this.determineActiveStepper();
        });
    }
    handleElWidthChange() {
        readTask(() => {
            this.determineActiveStepper();
        });
    }
    updateItems() {
        this.el.querySelectorAll("calcite-stepper-item").forEach((item) => {
            item.icon = this.icon;
            item.numbered = this.numbered;
            item.layout = this.layout;
            item.scale = this.scale;
        });
    }
    determineActiveStepper() {
        const totalItems = this.items.length;
        if (!this.elWidth || !totalItems || this.layout !== "horizontal-single" || totalItems === 1) {
            return;
        }
        const activePosition = this.currentActivePosition || 0;
        if (this.layout === "horizontal-single") {
            this.multipleViewMode = false;
            this.items.forEach((item, index) => {
                item.hidden = index !== activePosition;
            });
        }
    }
    getEnabledStepIndex(startIndex, direction = "next") {
        const { items, currentActivePosition } = this;
        let newIndex = startIndex;
        while (items[newIndex]?.disabled && this.layout !== "horizontal-single") {
            newIndex = newIndex + (direction === "previous" ? -1 : 1);
        }
        return newIndex !== currentActivePosition && newIndex < items.length && newIndex >= 0
            ? newIndex
            : null;
    }
    updateStep(position) {
        this.currentActivePosition = position;
        this.calciteInternalStepperItemChange.emit({
            position,
        });
    }
    filterItems() {
        return this.items.filter((item) => !item.disabled);
    }
    setStepperItemNumberingSystem() {
        this.items.forEach((item) => {
            item.numberingSystem = this.numberingSystem;
        });
    }
    renderAction(position) {
        const isPositionStart = position === "start";
        const path = isPositionStart ? "chevron-left" : "chevron-right";
        const { currentActivePosition, multipleViewMode, layout } = this;
        const totalItems = this.items.length;
        const id = `${this.guid}-${isPositionStart ? "start" : "end"}`;
        return layout === "horizontal-single" && !multipleViewMode ? (hAsync("calcite-action", { alignment: "center", appearance: "transparent", class: {
                [CSS$j.actionIcon]: true,
            }, compact: true, "data-position": position, disabled: (currentActivePosition === 0 && isPositionStart) ||
                (currentActivePosition === totalItems - 1 && !isPositionStart), icon: path, iconFlipRtl: true, id: id, onClick: this.handleActionClick, scale: this.scale, text: isPositionStart ? this.messages.previousStep : this.messages.nextStep })) : null;
    }
    getFirstEnabledStepperPosition() {
        const enabledStepIndex = this.items.findIndex((item) => !item.disabled);
        if (enabledStepIndex > -1) {
            return enabledStepIndex;
        }
        return 0;
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "icon": ["handleItemPropChange"],
        "layout": ["handleItemPropChange"],
        "numbered": ["handleItemPropChange"],
        "scale": ["handleItemPropChange"],
        "numberingSystem": ["numberingSystemChange"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"],
        "currentActivePosition": ["handlePositionChange"],
        "elWidth": ["handleElWidthChange"]
    }; }
    static get style() { return stepperCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-stepper",
        "$members$": {
            "icon": [516],
            "layout": [513],
            "numbered": [516],
            "scale": [513],
            "messages": [1040],
            "numberingSystem": [513, "numbering-system"],
            "selectedItem": [1040],
            "messageOverrides": [1040],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "currentActivePosition": [32],
            "elWidth": [32],
            "nextStep": [64],
            "prevStep": [64],
            "goToStep": [64],
            "startStep": [64],
            "endStep": [64]
        },
        "$listeners$": [[0, "calciteInternalStepperItemKeyEvent", "calciteInternalStepperItemKeyEvent"], [0, "calciteInternalStepperItemRegister", "registerItem"], [0, "calciteInternalStepperItemSelect", "updateItem"], [0, "calciteInternalUserRequestedStepperItemSelect", "handleUserRequestedStepperItemSelect"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["icon", "icon"], ["layout", "layout"], ["numbered", "numbered"], ["scale", "scale"], ["numberingSystem", "numbering-system"]]
    }; }
}

const CSS$i = {
    container: "container",
    stepperItemContent: "stepper-item-content",
    stepperItemDescription: "stepper-item-description",
    stepperItemHeader: "stepper-item-header",
    stepperItemHeading: "stepper-item-heading",
    stepperItemHeaderText: "stepper-item-header-text",
    stepperItemNumber: "stepper-item-number",
    visuallyHidden: "visually-hidden",
};

const stepperItemCss = "/*!@:host([layout=horizontal][disabled]) .stepper-item-header,\n:host([layout=horizontal-single][disabled]) .stepper-item-header, :host([disabled])*/[layout=horizontal][disabled].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal-single][disabled].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item,[disabled].sc-calcite-stepper-item-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([layout=horizontal][disabled]) .stepper-item-header *,\n:host([layout=horizontal-single][disabled]) .stepper-item-header *, :host([disabled]) *,\n:host([layout=horizontal][disabled]) .stepper-item-header ::slotted(*),\n:host([layout=horizontal-single][disabled]) .stepper-item-header ::slotted(*),\n:host([disabled]) ::slotted(*)*/[layout=horizontal][disabled].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item *.sc-calcite-stepper-item,[layout=horizontal-single][disabled].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item *.sc-calcite-stepper-item,[disabled].sc-calcite-stepper-item-h *.sc-calcite-stepper-item,.sc-calcite-stepper-item-h[layout=horizontal][disabled] .stepper-item-header.sc-calcite-stepper-item-s>*,.sc-calcite-stepper-item-h[layout=horizontal][disabled] .stepper-item-header .sc-calcite-stepper-item-s>*,.sc-calcite-stepper-item-h[layout=horizontal-single][disabled] .stepper-item-header.sc-calcite-stepper-item-s>*,.sc-calcite-stepper-item-h[layout=horizontal-single][disabled] .stepper-item-header .sc-calcite-stepper-item-s>*,.sc-calcite-stepper-item-h[disabled].sc-calcite-stepper-item-s>*,.sc-calcite-stepper-item-h[disabled] .sc-calcite-stepper-item-s>*{pointer-events:none}/*!@:host([scale=s])*/[scale=s].sc-calcite-stepper-item-h{--calcite-stepper-item-spacing-unit-s:0.25rem;--calcite-stepper-item-spacing-unit-m:0.75rem;--calcite-stepper-item-spacing-unit-l:1rem;--calcite-internal-stepper-action-inline-size:2rem;font-size:var(--calcite-font-size--1);line-height:1rem;margin-inline-end:0.25rem}/*!@:host([scale=s]) .stepper-item-description*/[scale=s].sc-calcite-stepper-item-h .stepper-item-description.sc-calcite-stepper-item{font-size:var(--calcite-font-size--2);line-height:1rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-stepper-item-h{--calcite-stepper-item-spacing-unit-s:0.5rem;--calcite-stepper-item-spacing-unit-m:1rem;--calcite-stepper-item-spacing-unit-l:1.25rem;--calcite-internal-stepper-action-inline-size:2.5rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;margin-inline-end:0.5rem}/*!@:host([scale=m]) .stepper-item-description*/[scale=m].sc-calcite-stepper-item-h .stepper-item-description.sc-calcite-stepper-item{font-size:var(--calcite-font-size--1);line-height:1rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-stepper-item-h{--calcite-stepper-item-spacing-unit-s:0.75rem;--calcite-stepper-item-spacing-unit-m:1.25rem;--calcite-stepper-item-spacing-unit-l:1.5rem;--calcite-internal-stepper-action-inline-size:3rem;font-size:var(--calcite-font-size-1);line-height:1.5rem;margin-inline-end:0.75rem}/*!@:host([scale=l]) .stepper-item-description*/[scale=l].sc-calcite-stepper-item-h .stepper-item-description.sc-calcite-stepper-item{font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host*/.sc-calcite-stepper-item-h{position:relative;display:flex;flex-grow:1;flex-direction:column;align-self:flex-start;margin-block-end:var(--calcite-stepper-item-spacing-unit-s)}/*!@:host .container*/.sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{position:relative;display:flex;flex-grow:1;cursor:pointer;flex-direction:column;border-width:0px;border-block-start-width:2px;border-style:solid;border-color:var(--calcite-color-border-3);color:var(--calcite-color-text-3);text-decoration-line:none;outline:2px solid transparent;outline-offset:2px;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}/*!@:host*/.sc-calcite-stepper-item-h{outline-color:transparent}/*!@:host(:focus)*/.sc-calcite-stepper-item-h:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host .stepper-item-header*/.sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item{display:flex;cursor:pointer;align-items:flex-start}/*!@:host .stepper-item-content,\n:host .stepper-item-header*/.sc-calcite-stepper-item-h .stepper-item-content.sc-calcite-stepper-item,.sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item{transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);padding-block:var(--calcite-stepper-item-spacing-unit-l);padding-inline-end:var(--calcite-stepper-item-spacing-unit-m);text-align:start}/*!@:host .stepper-item-header **/.sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item *.sc-calcite-stepper-item{display:inline-flex;align-items:center;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}/*!@:host .stepper-item-content*/.sc-calcite-stepper-item-h .stepper-item-content.sc-calcite-stepper-item{display:none;inline-size:100%;flex-direction:column;font-size:var(--calcite-font-size--2);line-height:1.375}/*!@:host .stepper-item-icon*/.sc-calcite-stepper-item-h .stepper-item-icon.sc-calcite-stepper-item{margin-inline-end:var(--calcite-stepper-item-spacing-unit-m);margin-block-start:1px;display:inline-flex;block-size:0.75rem;flex-shrink:0;align-self:flex-start;color:var(--calcite-color-text-3);opacity:var(--calcite-opacity-disabled);transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}/*!@:host .stepper-item-header-text*/.sc-calcite-stepper-item-h .stepper-item-header-text.sc-calcite-stepper-item{flex-direction:column;text-align:initial;margin-inline-end:auto}/*!@:host .stepper-item-heading,\n:host .stepper-item-description*/.sc-calcite-stepper-item-h .stepper-item-heading.sc-calcite-stepper-item,.sc-calcite-stepper-item-h .stepper-item-description.sc-calcite-stepper-item{display:flex;inline-size:100%}/*!@:host .stepper-item-heading*/.sc-calcite-stepper-item-h .stepper-item-heading.sc-calcite-stepper-item{margin-block-end:0.25rem;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-2)}/*!@:host .stepper-item-description*/.sc-calcite-stepper-item-h .stepper-item-description.sc-calcite-stepper-item{color:var(--calcite-color-text-3)}/*!@:host .stepper-item-number*/.sc-calcite-stepper-item-h .stepper-item-number.sc-calcite-stepper-item{font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-3);transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);margin-inline-end:var(--calcite-stepper-item-spacing-unit-m)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-stepper-item-h[disabled] .sc-calcite-stepper-item-s>[calcite-hydrated][disabled],[disabled].sc-calcite-stepper-item-h [calcite-hydrated][disabled].sc-calcite-stepper-item{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-stepper-item{display:contents}/*!@:host([complete]) .container*/[complete].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{border-color:rgba(0, 122, 194, 0.5)}/*!@:host([complete]) .container .stepper-item-icon*/[complete].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-icon.sc-calcite-stepper-item{color:var(--calcite-color-brand)}/*!@:host([error]) .container*/[error].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{border-block-start-color:var(--calcite-color-status-danger)}/*!@:host([error]) .container .stepper-item-number*/[error].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-number.sc-calcite-stepper-item{color:var(--calcite-color-status-danger)}/*!@:host([error]) .container .stepper-item-icon*/[error].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-icon.sc-calcite-stepper-item{opacity:1;color:var(--calcite-color-status-danger)}/*!@:host(:hover:not([disabled]):not([selected])) .container,\n:host(:focus:not([disabled]):not([selected])) .container*/.sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .container.sc-calcite-stepper-item,.sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .container.sc-calcite-stepper-item{border-block-start-color:var(--calcite-color-brand)}/*!@:host(:hover:not([disabled]):not([selected])) .container .stepper-item-heading,\n:host(:focus:not([disabled]):not([selected])) .container .stepper-item-heading*/.sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .container.sc-calcite-stepper-item .stepper-item-heading.sc-calcite-stepper-item,.sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .container.sc-calcite-stepper-item .stepper-item-heading.sc-calcite-stepper-item{color:var(--calcite-color-text-1)}/*!@:host(:hover:not([disabled]):not([selected])) .container .stepper-item-description,\n:host(:focus:not([disabled]):not([selected])) .container .stepper-item-description*/.sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .container.sc-calcite-stepper-item .stepper-item-description.sc-calcite-stepper-item,.sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .container.sc-calcite-stepper-item .stepper-item-description.sc-calcite-stepper-item{color:var(--calcite-color-text-2)}/*!@:host([error]:hover:not([disabled]):not([selected])) .container,\n:host([error]:focus:not([disabled]):not([selected])) .container*/[error].sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .container.sc-calcite-stepper-item,[error].sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .container.sc-calcite-stepper-item{border-block-start-color:var(--calcite-color-status-danger-hover)}/*!@:host([selected]) .container*/[selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{border-block-start-color:var(--calcite-color-brand)}/*!@:host([selected]) .container .stepper-item-heading*/[selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-heading.sc-calcite-stepper-item{color:var(--calcite-color-text-1)}/*!@:host([selected]) .container .stepper-item-description*/[selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-description.sc-calcite-stepper-item{color:var(--calcite-color-text-2)}/*!@:host([selected]) .container .stepper-item-number*/[selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-number.sc-calcite-stepper-item{color:var(--calcite-color-brand)}/*!@:host([selected]) .container .stepper-item-icon*/[selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-icon.sc-calcite-stepper-item{color:var(--calcite-color-brand);opacity:1}/*!@:host([selected]) .container .stepper-item-content*/[selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-content.sc-calcite-stepper-item{display:flex}/*!@:host([layout=vertical]) .container*/[layout=vertical].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{margin-inline:0px;margin-block-start:0px;flex:1 1 auto;border-block-start-width:0px;border-style:solid;border-color:var(--calcite-color-border-3);padding-block:0px;border-inline-start-width:2px;padding-inline-start:var(--calcite-stepper-item-spacing-unit-l)}/*!@:host([layout=vertical]) .container .stepper-item-icon*/[layout=vertical].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-icon.sc-calcite-stepper-item{order:3;margin-block:1px 0px;padding-inline-start:var(--calcite-stepper-item-spacing-unit-s);margin-inline-start:auto}/*!@:host([layout=vertical]) .container .stepper-item-header*/[layout=vertical].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-header.sc-calcite-stepper-item{padding-inline-end:0px}/*!@:host([layout=vertical]) .container .stepper-item-content*/[layout=vertical].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-content.sc-calcite-stepper-item{padding:0px}/*!@:host([layout=vertical][complete]) .container*/[layout=vertical][complete].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{border-color:rgba(0, 122, 194, 0.5)}/*!@:host([layout=vertical][complete]:hover:not([disabled]):not([selected])) .container,\n:host([layout=vertical][complete]:focus:not([disabled]):not([selected])) .container*/[layout=vertical][complete].sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .container.sc-calcite-stepper-item,[layout=vertical][complete].sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .container.sc-calcite-stepper-item{border-color:var(--calcite-color-brand)}/*!@:host([layout=vertical][error]) .container*/[layout=vertical][error].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{border-color:var(--calcite-color-status-danger)}/*!@:host([layout=vertical][selected]) .container*/[layout=vertical][selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{border-color:var(--calcite-color-brand)}/*!@:host([layout=vertical][selected]) .container .stepper-item-content:not(:empty)*/[layout=vertical][selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-content.sc-calcite-stepper-item:not(:empty){margin-block-end:var(--calcite-stepper-item-spacing-unit-l)}/*!@:host([layout=vertical]:hover:not([disabled]):not([selected])) .container,\n:host([layout=vertical]:focus:not([disabled]):not([selected])) .container*/[layout=vertical].sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .container.sc-calcite-stepper-item,[layout=vertical].sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .container.sc-calcite-stepper-item{border-color:rgba(0, 122, 194, 0.5)}/*!@:host([layout=vertical][error]:hover:not([disabled]):not([selected])) .container,\n:host([layout=vertical][error]:focus:not([disabled]):not([selected])) .container*/[layout=vertical][error].sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .container.sc-calcite-stepper-item,[layout=vertical][error].sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .container.sc-calcite-stepper-item{border-color:var(--calcite-color-status-danger-hover)}/*!@:host([layout=horizontal]),\n:host([layout=horizontal-single])*/[layout=horizontal].sc-calcite-stepper-item-h,[layout=horizontal-single].sc-calcite-stepper-item-h{display:contents}/*!@:host([layout=horizontal]) .container,\n:host([layout=horizontal-single]) .container*/[layout=horizontal].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item,[layout=horizontal-single].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{display:contents}/*!@:host([layout=horizontal]) .stepper-item-header,\n:host([layout=horizontal-single]) .stepper-item-header*/[layout=horizontal].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal-single].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item{border-width:0px;border-block-start-width:2px;border-style:solid;border-color:var(--calcite-color-border-3);outline-color:transparent;grid-row:items}/*!@:host([layout=horizontal]) .stepper-item-header:focus,\n:host([layout=horizontal-single]) .stepper-item-header:focus*/[layout=horizontal].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item:focus,[layout=horizontal-single].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host([layout=horizontal]) .stepper-item-content,\n:host([layout=horizontal-single]) .stepper-item-content*/[layout=horizontal].sc-calcite-stepper-item-h .stepper-item-content.sc-calcite-stepper-item,[layout=horizontal-single].sc-calcite-stepper-item-h .stepper-item-content.sc-calcite-stepper-item{cursor:auto;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);padding-block:0;padding-inline-end:var(--calcite-stepper-item-spacing-unit-m);text-align:start}/*!@:host([layout=horizontal-single]) .stepper-item-header*/[layout=horizontal-single].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item{grid-area:1/1/1/-1}/*!@:host([layout=horizontal]) .stepper-item-content,\n:host([layout=horizontal-single]) .stepper-item-content*/[layout=horizontal].sc-calcite-stepper-item-h .stepper-item-content.sc-calcite-stepper-item,[layout=horizontal-single].sc-calcite-stepper-item-h .stepper-item-content.sc-calcite-stepper-item{grid-area:2/1/2/-1}/*!@:host([layout=horizontal][complete]) .stepper-item-header,\n:host([layout=horizontal-single][complete]) .stepper-item-header*/[layout=horizontal][complete].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal-single][complete].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item{border-color:rgba(0, 122, 194, 0.5)}/*!@:host([layout=horizontal][complete]:hover:not([disabled]):not([selected])) .stepper-item-header,\n:host([layout=horizontal][complete]:focus:not([disabled]):not([selected])) .stepper-item-header,\n:host([layout=horizontal-single][complete]:hover:not([disabled]):not([selected])) .stepper-item-header,\n:host([layout=horizontal-single][complete]:focus:not([disabled]):not([selected])) .stepper-item-header*/[layout=horizontal][complete].sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal][complete].sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal-single][complete].sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal-single][complete].sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .stepper-item-header.sc-calcite-stepper-item{border-color:var(--calcite-color-brand)}/*!@:host([layout=horizontal][error]) .stepper-item-header,\n:host([layout=horizontal-single][error]) .stepper-item-header*/[layout=horizontal][error].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal-single][error].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item{border-color:var(--calcite-color-status-danger)}/*!@:host([layout=horizontal][selected]) .stepper-item-header,\n:host([layout=horizontal-single][selected]) .stepper-item-header*/[layout=horizontal][selected].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal-single][selected].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item{border-color:var(--calcite-color-brand)}/*!@:host([layout=horizontal]:hover:not([disabled]):not([selected])) .stepper-item-header,\n:host([layout=horizontal]:focus:not([disabled]):not([selected])) .stepper-item-header,\n:host([layout=horizontal-single]:hover:not([disabled]):not([selected])) .stepper-item-header,\n:host([layout=horizontal-single]:focus:not([disabled]):not([selected])) .stepper-item-header*/[layout=horizontal].sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal].sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal-single].sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal-single].sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .stepper-item-header.sc-calcite-stepper-item{border-color:rgba(0, 122, 194, 0.5)}/*!@:host([layout=horizontal][error]:hover:not([disabled]):not([selected])) .stepper-item-header,\n:host([layout=horizontal][error]:focus:not([disabled]):not([selected])) .stepper-item-header,\n:host([layout=horizontal-single][error]:hover:not([disabled]):not([selected])) .stepper-item-header,\n:host([layout=horizontal-single][error]:focus:not([disabled]):not([selected])) .stepper-item-header*/[layout=horizontal][error].sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal][error].sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal-single][error].sc-calcite-stepper-item-h:hover:not([disabled]):not([selected]) .stepper-item-header.sc-calcite-stepper-item,[layout=horizontal-single][error].sc-calcite-stepper-item-h:focus:not([disabled]):not([selected]) .stepper-item-header.sc-calcite-stepper-item{border-color:var(--calcite-color-status-danger-hover)}@media (forced-colors: active){/*!@:host .container*/.sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{outline-width:0;outline-offset:0}/*!@:host(:focus),\n  :host(:focus-visible)*/.sc-calcite-stepper-item-h:focus,.sc-calcite-stepper-item-h:focus-visible{outline-color:canvasText}/*!@:host([selected]) .container*/[selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{border-block-start-color:highlight}/*!@:host([selected]) .container .stepper-item-number*/[selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-number.sc-calcite-stepper-item{color:highlight}/*!@:host([selected]) .container .stepper-item-icon*/[selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-icon.sc-calcite-stepper-item{color:highlight}/*!@:host([layout=vertical][selected]) .container*/[layout=vertical][selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{border-color:highlight}}/*!@:host([layout=horizontal-single]) .stepper-item-header*/[layout=horizontal-single].sc-calcite-stepper-item-h .stepper-item-header.sc-calcite-stepper-item{margin-inline-end:0px;box-sizing:border-box;border-style:none;inline-size:100%;padding-inline:calc(var(--calcite-internal-stepper-action-inline-size) + 0.5rem)}/*!@:host([layout=horizontal-single][error]) .container .stepper-item-number*/[layout=horizontal-single][error].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-number.sc-calcite-stepper-item{color:var(--calcite-color-status-danger)}/*!@:host([layout=horizontal-single][error]) .container .stepper-item-icon*/[layout=horizontal-single][error].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-icon.sc-calcite-stepper-item{opacity:1;color:var(--calcite-color-status-danger)}/*!@:host([layout=horizontal-single][error][selected]),\n:host([layout=horizontal-single][complete][selected]) .container*/[layout=horizontal-single][error][selected].sc-calcite-stepper-item-h,[layout=horizontal-single][complete][selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item{color:var(--calcite-color-text-3)}/*!@:host([layout=horizontal-single][error][selected]) .stepper-item-heading,\n:host([layout=horizontal-single][complete][selected]) .container .stepper-item-heading*/[layout=horizontal-single][error][selected].sc-calcite-stepper-item-h .stepper-item-heading.sc-calcite-stepper-item,[layout=horizontal-single][complete][selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-heading.sc-calcite-stepper-item{color:var(--calcite-color-text-2)}/*!@:host([layout=horizontal-single][complete][selected]) .container .stepper-item-icon*/[layout=horizontal-single][complete][selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-icon.sc-calcite-stepper-item{opacity:var(--calcite-opacity-disabled)}/*!@:host([layout=horizontal-single][complete][selected]) .container .stepper-item-number*/[layout=horizontal-single][complete][selected].sc-calcite-stepper-item-h .container.sc-calcite-stepper-item .stepper-item-number.sc-calcite-stepper-item{color:var(--calcite-color-text-3)}/*!@.visually-hidden*/.visually-hidden.sc-calcite-stepper-item{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}/*!@:host([hidden])*/[hidden].sc-calcite-stepper-item-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-stepper-item{display:none}";

/**
 * @slot - A slot for adding custom content.
 */
class StepperItem {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalStepperItemKeyEvent = createEvent(this, "calciteInternalStepperItemKeyEvent", 6);
        this.calciteInternalStepperItemSelect = createEvent(this, "calciteInternalStepperItemSelect", 6);
        this.calciteInternalUserRequestedStepperItemSelect = createEvent(this, "calciteInternalUserRequestedStepperItemSelect", 6);
        this.calciteInternalStepperItemRegister = createEvent(this, "calciteInternalStepperItemRegister", 6);
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.keyDownHandler = (event) => {
            if (!this.disabled && event.target === this.el) {
                switch (event.key) {
                    case " ":
                    case "Enter":
                        this.emitUserRequestedItem();
                        event.preventDefault();
                        break;
                    case "ArrowUp":
                    case "ArrowDown":
                    case "ArrowLeft":
                    case "ArrowRight":
                    case "Home":
                    case "End":
                        this.calciteInternalStepperItemKeyEvent.emit({ item: event });
                        event.preventDefault();
                        break;
                }
            }
        };
        this.handleItemClick = (event) => {
            if (this.disabled ||
                (this.layout === "horizontal" &&
                    event
                        .composedPath()
                        .some((el) => el.classList?.contains("stepper-item-content")))) {
                return;
            }
            this.emitUserRequestedItem();
        };
        this.emitUserRequestedItem = () => {
            this.emitRequestedItem();
            if (!this.disabled) {
                const position = this.itemPosition;
                this.calciteInternalUserRequestedStepperItemSelect.emit({
                    position,
                });
            }
        };
        this.emitRequestedItem = () => {
            if (!this.disabled) {
                const position = this.itemPosition;
                this.calciteInternalStepperItemSelect.emit({
                    position,
                });
            }
        };
        this.selected = false;
        this.complete = false;
        this.error = false;
        this.disabled = false;
        this.heading = undefined;
        this.description = undefined;
        this.iconFlipRtl = false;
        this.numberingSystem = undefined;
        this.icon = false;
        this.layout = undefined;
        this.messages = undefined;
        this.numbered = false;
        this.scale = "m";
        this.messageOverrides = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
    }
    selectedHandler() {
        if (this.selected) {
            this.emitRequestedItem();
        }
    }
    // watch for removal of disabled to register step
    disabledWatcher() {
        this.registerStepperItem();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleWatcher(locale) {
        numberStringFormatter.numberFormatOptions = {
            locale,
            numberingSystem: this.numberingSystem,
            useGrouping: false,
        };
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        this.parentStepperEl = this.el.parentElement;
        this.itemPosition = this.getItemPosition();
        this.registerStepperItem();
        if (this.selected) {
            this.emitRequestedItem();
        }
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    render() {
        return (hAsync(Host, { "aria-current": this.selected ? "step" : "false", onClick: this.handleItemClick, onKeyDown: this.keyDownHandler, tabIndex: this.disabled ? -1 : 0 }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: CSS$i.container }, this.complete && (hAsync("span", { "aria-live": "polite", class: CSS$i.visuallyHidden }, this.messages.complete)), hAsync("div", { class: CSS$i.stepperItemHeader, tabIndex: 
            /* additional tab index logic needed because of display: contents */
            this.layout === "horizontal" && !this.disabled ? 0 : null,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.headerEl = el) }, this.icon ? this.renderIcon() : null, this.numbered ? (hAsync("div", { class: CSS$i.stepperItemNumber }, this.renderNumbers(), ".")) : null, hAsync("div", { class: CSS$i.stepperItemHeaderText }, hAsync("span", { class: CSS$i.stepperItemHeading }, this.heading), hAsync("span", { class: CSS$i.stepperItemDescription }, this.description))), hAsync("div", { class: CSS$i.stepperItemContent }, hAsync("slot", null))))));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    updateActiveItemOnChange(event) {
        if (event.target === this.parentStepperEl ||
            event.composedPath().includes(this.parentStepperEl)) {
            this.selectedPosition = event.detail.position;
            this.determineSelectedItem();
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        (this.layout === "vertical" ? this.el : this.headerEl)?.focus();
    }
    renderIcon() {
        let path = "circle";
        if (this.selected && (this.layout !== "horizontal-single" || (!this.error && !this.complete))) {
            path = "circleF";
        }
        else if (this.error) {
            path = "exclamationMarkCircleF";
        }
        else if (this.complete) {
            path = "checkCircleF";
        }
        return (hAsync("calcite-icon", { class: "stepper-item-icon", flipRtl: this.iconFlipRtl, icon: path, scale: "s" }));
    }
    determineSelectedItem() {
        this.selected = !this.disabled && this.itemPosition === this.selectedPosition;
    }
    registerStepperItem() {
        this.calciteInternalStepperItemRegister.emit({
            position: this.itemPosition,
        });
    }
    getItemPosition() {
        return Array.from(this.parentStepperEl?.querySelectorAll("calcite-stepper-item")).indexOf(this.el);
    }
    renderNumbers() {
        numberStringFormatter.numberFormatOptions = {
            locale: this.effectiveLocale,
            numberingSystem: this.numberingSystem,
            useGrouping: false,
        };
        return numberStringFormatter.numberFormatter.format(this.itemPosition + 1);
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "selected": ["selectedHandler"],
        "disabled": ["disabledWatcher"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleWatcher"]
    }; }
    static get style() { return stepperItemCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-stepper-item",
        "$members$": {
            "selected": [1540],
            "complete": [516],
            "error": [516],
            "disabled": [516],
            "heading": [1],
            "description": [1],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "numberingSystem": [1, "numbering-system"],
            "icon": [4],
            "layout": [513],
            "messages": [1040],
            "numbered": [4],
            "scale": [513],
            "messageOverrides": [1040],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "setFocus": [64]
        },
        "$listeners$": [[16, "calciteInternalStepperItemChange", "updateActiveItemOnChange"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["selected", "selected"], ["complete", "complete"], ["error", "error"], ["disabled", "disabled"], ["iconFlipRtl", "icon-flip-rtl"], ["layout", "layout"], ["scale", "scale"]]
    }; }
}

const switchCss = "/*!@:host([disabled])*/[disabled].sc-calcite-switch-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-switch-h *.sc-calcite-switch,.sc-calcite-switch-h[disabled].sc-calcite-switch-s>*,.sc-calcite-switch-h[disabled] .sc-calcite-switch-s>*{pointer-events:none}/*!@:host([scale=s]) .container*/[scale=s].sc-calcite-switch-h .container.sc-calcite-switch{block-size:0.75rem}/*!@:host([scale=s]) .track*/[scale=s].sc-calcite-switch-h .track.sc-calcite-switch{block-size:0.75rem;inline-size:1.5rem}/*!@:host([scale=s]) .handle*/[scale=s].sc-calcite-switch-h .handle.sc-calcite-switch{block-size:0.5rem;inline-size:0.5rem}/*!@:host([scale=m]) .container*/[scale=m].sc-calcite-switch-h .container.sc-calcite-switch{block-size:1rem}/*!@:host([scale=m]) .track*/[scale=m].sc-calcite-switch-h .track.sc-calcite-switch{block-size:1rem;inline-size:2rem}/*!@:host([scale=m]) .handle*/[scale=m].sc-calcite-switch-h .handle.sc-calcite-switch{block-size:0.75rem;inline-size:0.75rem}/*!@:host([scale=l]) .container*/[scale=l].sc-calcite-switch-h .container.sc-calcite-switch{block-size:1.5rem}/*!@:host([scale=l]) .track*/[scale=l].sc-calcite-switch-h .track.sc-calcite-switch{block-size:1.5rem;inline-size:3rem}/*!@:host([scale=l]) .handle*/[scale=l].sc-calcite-switch-h .handle.sc-calcite-switch{block-size:1.25rem;inline-size:1.25rem}/*!@:host*/.sc-calcite-switch-h{position:relative;display:inline-block;inline-size:auto;cursor:pointer;-webkit-user-select:none;user-select:none;vertical-align:middle;tap-highlight-color:transparent}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-switch-h[disabled] .sc-calcite-switch-s>[calcite-hydrated][disabled],[disabled].sc-calcite-switch-h [calcite-hydrated][disabled].sc-calcite-switch{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-switch{display:contents}/*!@.container*/.container.sc-calcite-switch{outline-width:0px}/*!@.track*/.track.sc-calcite-switch{pointer-events:none;position:relative;box-sizing:border-box;display:inline-block;border-radius:9999px;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-2);background-color:var(--calcite-color-foreground-2);vertical-align:top;outline-color:transparent}/*!@:host(:focus) .track*/.sc-calcite-switch-h:focus .track.sc-calcite-switch{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.handle*/.handle.sc-calcite-switch{pointer-events:none;position:absolute;display:block;border-radius:9999px;border-width:2px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-foreground-1);transition-property:all;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);inset-block-start:-1px;inset-inline:-1px auto}/*!@:host(:hover) .handle,\n:host(:focus) .handle*/.sc-calcite-switch-h:hover .handle.sc-calcite-switch,.sc-calcite-switch-h:focus .handle.sc-calcite-switch{border-color:var(--calcite-color-brand);box-shadow:inset 0 0 0 1px var(--calcite-color-brand)}/*!@:host([checked]) .track*/[checked].sc-calcite-switch-h .track.sc-calcite-switch{border-color:var(--calcite-color-brand-hover);background-color:var(--calcite-color-brand)}/*!@:host([checked]) .handle*/[checked].sc-calcite-switch-h .handle.sc-calcite-switch{border-color:var(--calcite-color-brand);inset-inline:auto -1px}/*!@:host([checked]:hover) .track*/[checked].sc-calcite-switch-h:hover .track.sc-calcite-switch{border-color:var(--calcite-color-brand-hover);background-color:var(--calcite-color-brand)}/*!@:host([checked]:hover) .handle*/[checked].sc-calcite-switch-h:hover .handle.sc-calcite-switch{border-color:var(--calcite-color-brand-hover);box-shadow:inset 0 0 0 1px var(--calcite-color-brand-hover)}@media (forced-colors: active){/*!@:host([checked]) .track*/[checked].sc-calcite-switch-h .track.sc-calcite-switch{background-color:canvasText}}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-switch-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([hidden])*/[hidden].sc-calcite-switch-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-switch{display:none}";

class Switch {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteSwitchChange = createEvent(this, "calciteSwitchChange", 6);
        this.keyDownHandler = (event) => {
            if (!this.disabled && isActivationKey(event.key)) {
                this.toggle();
                event.preventDefault();
            }
        };
        this.clickHandler = () => {
            if (this.disabled) {
                return;
            }
            this.toggle();
        };
        this.setSwitchEl = (el) => {
            this.switchEl = el;
        };
        this.disabled = false;
        this.form = undefined;
        this.label = undefined;
        this.name = undefined;
        this.scale = "m";
        this.checked = false;
        this.value = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        focusElement(this.switchEl);
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    syncHiddenFormInput(input) {
        input.type = "checkbox";
    }
    onLabelClick() {
        if (!this.disabled) {
            this.toggle();
            this.setFocus();
        }
    }
    toggle() {
        this.checked = !this.checked;
        this.calciteSwitchChange.emit();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLabel(this);
        connectForm(this);
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        return (hAsync(Host, { onClick: this.clickHandler, onKeyDown: this.keyDownHandler }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { "aria-checked": toAriaBoolean(this.checked), "aria-label": getLabelText(this), class: "container", role: "switch", tabIndex: 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setSwitchEl }, hAsync("div", { class: "track" }, hAsync("div", { class: "handle" })), hAsync(HiddenFormInputSlot, { component: this })))));
    }
    get el() { return getElement(this); }
    static get style() { return switchCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-switch",
        "$members$": {
            "disabled": [516],
            "form": [513],
            "label": [1],
            "name": [513],
            "scale": [513],
            "checked": [1540],
            "value": [8],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["form", "form"], ["name", "name"], ["scale", "scale"], ["checked", "checked"]]
    }; }
}

const CSS$h = {
    container: "container",
    content: "content",
};

const tabCss = "/*!@:host([selected]) section,\n:host([selected]) .container*/[selected].sc-calcite-tab-h section.sc-calcite-tab,[selected].sc-calcite-tab-h .container.sc-calcite-tab{display:block}/*!@:host*/.sc-calcite-tab-h{display:none;block-size:100%;inline-size:100%}/*!@:host([selected])*/[selected].sc-calcite-tab-h{display:block;block-size:100%;inline-size:100%;overflow:auto}/*!@.content*/.content.sc-calcite-tab{box-sizing:border-box;padding-block:var(--calcite-internal-tab-content-block-padding)}/*!@.scale-s*/.scale-s.sc-calcite-tab{--calcite-internal-tab-content-block-padding:var(--calcite-tab-content-block-padding, 0.25rem);font-size:var(--calcite-font-size--2);line-height:1rem}/*!@.scale-m*/.scale-m.sc-calcite-tab{--calcite-internal-tab-content-block-padding:var(--calcite-tab-content-block-padding, 0.5rem);font-size:var(--calcite-font-size--1);line-height:1rem}/*!@.scale-l*/.scale-l.sc-calcite-tab{--calcite-internal-tab-content-block-padding:var(--calcite-tab-content-block-padding, 0.625rem);font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@section,\n.container*/section.sc-calcite-tab,.container.sc-calcite-tab{display:none;block-size:100%;inline-size:100%}/*!@:host([hidden])*/[hidden].sc-calcite-tab-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tab{display:none}";

/**
 * @slot - A slot for adding custom content.
 */
class Tab {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalTabRegister = createEvent(this, "calciteInternalTabRegister", 6);
        this.guid = `calcite-tab-title-${guid()}`;
        this.tab = undefined;
        this.selected = false;
        this.scale = "m";
        this.labeledBy = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    render() {
        const id = this.el.id || this.guid;
        return (hAsync(Host, { "aria-labelledby": this.labeledBy, id: id }, hAsync("div", { class: { [CSS$h.container]: true, [`scale-${this.scale}`]: true }, role: "tabpanel", tabIndex: this.selected ? 0 : -1 }, hAsync("section", { class: CSS$h.content }, hAsync("slot", null)))));
    }
    connectedCallback() {
        this.parentTabsEl = this.el.closest("calcite-tabs");
    }
    componentDidLoad() {
        this.calciteInternalTabRegister.emit();
    }
    disconnectedCallback() {
        // Dispatching to body in order to be listened by other elements that are still connected to the DOM.
        document.body?.dispatchEvent(new CustomEvent("calciteTabUnregister", {
            detail: this.el,
        }));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    internalTabChangeHandler(event) {
        const targetTabsEl = event
            .composedPath()
            .find((el) => el.tagName === "CALCITE-TABS");
        // to allow `<calcite-tabs>` to be nested we need to make sure this
        // `calciteTabChange` event was actually fired from a within the same
        // `<calcite-tabs>` that is the a parent of this tab.
        if (targetTabsEl !== this.parentTabsEl) {
            return;
        }
        if (this.tab) {
            this.selected = this.tab === event.detail.tab;
        }
        else {
            this.getTabIndex().then((index) => {
                this.selected = index === event.detail.tab;
            });
        }
        event.stopPropagation();
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Returns the index of the component item within the tab array.
     */
    async getTabIndex() {
        return Array.prototype.indexOf.call(nodeListToArray(this.el.parentElement.children).filter((el) => el.matches("calcite-tab")), this.el);
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    /**
     * @param tabIds
     * @param titleIds
     * @internal
     */
    async updateAriaInfo(tabIds = [], titleIds = []) {
        this.labeledBy = titleIds[tabIds.indexOf(this.el.id)] || null;
    }
    get el() { return getElement(this); }
    static get style() { return tabCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tab",
        "$members$": {
            "tab": [513],
            "selected": [1540],
            "scale": [1],
            "labeledBy": [32],
            "getTabIndex": [64],
            "updateAriaInfo": [64]
        },
        "$listeners$": [[16, "calciteInternalTabChange", "internalTabChangeHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["tab", "tab"], ["selected", "selected"]]
    }; }
}

const CSS$g = {
    container: "tab-nav",
};

const tabNavCss = "/*!@:host*/.sc-calcite-tab-nav-h{position:relative;display:flex}/*!@.scale-s*/.scale-s.sc-calcite-tab-nav{min-block-size:1.5rem}/*!@.scale-m*/.scale-m.sc-calcite-tab-nav{min-block-size:2rem}/*!@.scale-l*/.scale-l.sc-calcite-tab-nav{min-block-size:2.75rem}/*!@:host([layout=center]:not([bordered]))*/[layout=center].sc-calcite-tab-nav-h:not([bordered]){padding-inline:1.25rem}/*!@:host([layout=center]:not([bordered])) .tab-nav ::slotted(calcite-tab-title:last-child)*/.sc-calcite-tab-nav-h[layout=center]:not([bordered]) .tab-nav .sc-calcite-tab-nav-s>calcite-tab-title:last-child{margin-inline-end:0px}/*!@:host(:not([bordered])) .scale-l ::slotted(calcite-tab-title)*/.sc-calcite-tab-nav-h:not([bordered]) .scale-l .sc-calcite-tab-nav-s>calcite-tab-title{margin-inline-end:1.5rem}/*!@:host(:not([bordered])) .scale-m ::slotted(calcite-tab-title)*/.sc-calcite-tab-nav-h:not([bordered]) .scale-m .sc-calcite-tab-nav-s>calcite-tab-title{margin-inline-end:1.25rem}/*!@:host(:not([bordered])) .scale-s ::slotted(calcite-tab-title)*/.sc-calcite-tab-nav-h:not([bordered]) .scale-s .sc-calcite-tab-nav-s>calcite-tab-title{margin-inline-end:1rem}/*!@.tab-nav*/.tab-nav.sc-calcite-tab-nav{display:flex;inline-size:100%;justify-content:flex-start;overflow:auto}/*!@.tab-nav-active-indicator-container*/.tab-nav-active-indicator-container.sc-calcite-tab-nav{position:absolute;inset-inline:0px;inset-block-end:0px;block-size:0.125rem;inline-size:100%;overflow:hidden}/*!@.tab-nav-active-indicator*/.tab-nav-active-indicator.sc-calcite-tab-nav{position:absolute;inset-block-end:0px;display:block;block-size:0.125rem;background-color:var(--calcite-color-brand);transition-property:all;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;transition-timing-function:cubic-bezier(0, 0, 0.2, 1)}/*!@:host([layout=center]) .tab-nav*/[layout=center].sc-calcite-tab-nav-h .tab-nav.sc-calcite-tab-nav{justify-content:space-evenly}/*!@:host .position-bottom .tab-nav-active-indicator*/.sc-calcite-tab-nav-h .position-bottom.sc-calcite-tab-nav .tab-nav-active-indicator.sc-calcite-tab-nav{inset-block-end:unset;inset-block-start:0px}/*!@:host .position-bottom .tab-nav-active-indicator-container*/.sc-calcite-tab-nav-h .position-bottom.sc-calcite-tab-nav .tab-nav-active-indicator-container.sc-calcite-tab-nav{inset-block-end:unset;inset-block-start:0px}/*!@:host([bordered]) .tab-nav-active-indicator-container*/[bordered].sc-calcite-tab-nav-h .tab-nav-active-indicator-container.sc-calcite-tab-nav{inset-block-end:unset}/*!@:host([bordered]) .position-bottom .tab-nav-active-indicator-container*/[bordered].sc-calcite-tab-nav-h .position-bottom.sc-calcite-tab-nav .tab-nav-active-indicator-container.sc-calcite-tab-nav{inset-block-end:0;inset-block-start:unset}@media (forced-colors: active){/*!@.tab-nav-active-indicator*/.tab-nav-active-indicator.sc-calcite-tab-nav{background-color:highlight}}/*!@:host([hidden])*/[hidden].sc-calcite-tab-nav-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tab-nav{display:none}";

/**
 * @slot - A slot for adding `calcite-tab-title`s.
 */
class TabNav {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteTabChange = createEvent(this, "calciteTabChange", 6);
        this.calciteInternalTabChange = createEvent(this, "calciteInternalTabChange", 6);
        this.animationActiveDuration = 0.3;
        this.resizeObserver = createObserver();
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.handleTabFocus = (event, el, destination) => {
            focusElementInGroup(this.enabledTabTitles, el, destination);
            event.stopPropagation();
        };
        this.handleContainerScroll = () => {
            // remove active indicator transition duration while container is scrolling to prevent wobble
            this.activeIndicatorEl.style.transitionDuration = "0s";
            this.updateOffsetPosition();
        };
        this.storageId = undefined;
        this.syncId = undefined;
        this.selectedTitle = null;
        this.scale = "m";
        this.layout = "inline";
        this.position = "bottom";
        this.bordered = false;
        this.indicatorOffset = undefined;
        this.indicatorWidth = undefined;
        this.selectedTabId = undefined;
    }
    async selectedTabIdChanged() {
        if (localStorage &&
            this.storageId &&
            this.selectedTabId !== undefined &&
            this.selectedTabId !== null) {
            localStorage.setItem(`calcite-tab-nav-${this.storageId}`, JSON.stringify(this.selectedTabId));
        }
        this.calciteInternalTabChange.emit({
            tab: this.selectedTabId,
        });
        this.selectedTitle = await this.getTabTitleById(this.selectedTabId);
    }
    selectedTitleChanged() {
        this.updateOffsetPosition();
        this.updateActiveWidth();
        // reset the animation time on tab selection
        this.activeIndicatorEl.style.transitionDuration = `${this.animationActiveDuration}s`;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.parentTabsEl = this.el.closest("calcite-tabs");
        this.resizeObserver?.observe(this.el);
    }
    componentWillLoad() {
        const storageKey = `calcite-tab-nav-${this.storageId}`;
        if (localStorage && this.storageId && localStorage.getItem(storageKey)) {
            const storedTab = JSON.parse(localStorage.getItem(storageKey));
            this.selectedTabId = storedTab;
        }
    }
    componentWillRender() {
        const { parentTabsEl } = this;
        this.layout = parentTabsEl?.layout;
        this.bordered = parentTabsEl?.bordered;
        // fix issue with active tab-title not lining up with blue indicator
        if (this.selectedTitle) {
            this.updateOffsetPosition();
        }
    }
    componentDidRender() {
        // if every tab title is active select the first tab.
        if (this.tabTitles.length &&
            this.tabTitles.every((title) => !title.selected) &&
            !this.selectedTabId) {
            this.tabTitles[0].getTabIdentifier().then((tab) => {
                this.calciteInternalTabChange.emit({
                    tab,
                });
            });
        }
    }
    disconnectedCallback() {
        this.resizeObserver?.disconnect();
    }
    render() {
        const dir = getElementDir(this.el);
        const width = `${this.indicatorWidth}px`;
        const offset = `${this.indicatorOffset}px`;
        const indicatorStyle = dir !== "rtl" ? { width, left: offset } : { width, right: offset };
        return (hAsync(Host, { role: "tablist" }, hAsync("div", { class: {
                [CSS$g.container]: true,
                [`scale-${this.scale}`]: true,
                [`position-${this.position}`]: true,
            }, onScroll: this.handleContainerScroll,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.tabNavEl = el) }, hAsync("slot", null), hAsync("div", { class: "tab-nav-active-indicator-container",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.activeIndicatorContainerEl = el) }, hAsync("div", { class: "tab-nav-active-indicator", style: indicatorStyle,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.activeIndicatorEl = el) })))));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    focusPreviousTabHandler(event) {
        this.handleTabFocus(event, event.target, "previous");
    }
    focusNextTabHandler(event) {
        this.handleTabFocus(event, event.target, "next");
    }
    focusFirstTabHandler(event) {
        this.handleTabFocus(event, event.target, "first");
    }
    focusLastTabHandler(event) {
        this.handleTabFocus(event, event.target, "last");
    }
    internalActivateTabHandler(event) {
        this.selectedTabId = event.detail.tab
            ? event.detail.tab
            : this.getIndexOfTabTitle(event.target);
        event.stopPropagation();
    }
    activateTabHandler(event) {
        this.calciteTabChange.emit();
        event.stopPropagation();
    }
    internalCloseTabHandler(event) {
        const closedTabTitleEl = event.target;
        this.handleTabTitleClose(closedTabTitleEl);
        event.stopPropagation();
    }
    /**
     * Check for active tabs on register and update selected
     *
     * @param event
     */
    updateTabTitles(event) {
        if (event.target.selected) {
            this.selectedTabId = event.detail;
        }
    }
    globalInternalTabChangeHandler(event) {
        if (this.syncId &&
            event.target !== this.el &&
            event.target.syncId === this.syncId &&
            this.selectedTabId !== event.detail.tab) {
            this.selectedTabId = event.detail.tab;
        }
        event.stopPropagation();
    }
    iconStartChangeHandler() {
        this.updateActiveWidth();
        this.updateOffsetPosition();
    }
    updateOffsetPosition() {
        const dir = getElementDir(this.el);
        const navWidth = this.activeIndicatorContainerEl?.offsetWidth;
        const tabLeft = this.selectedTitle?.offsetLeft;
        const tabWidth = this.selectedTitle?.offsetWidth;
        const offsetRight = navWidth - (tabLeft + tabWidth);
        this.indicatorOffset =
            dir !== "rtl" ? tabLeft - this.tabNavEl?.scrollLeft : offsetRight + this.tabNavEl?.scrollLeft;
    }
    updateActiveWidth() {
        this.indicatorWidth = this.selectedTitle?.offsetWidth;
    }
    getIndexOfTabTitle(el, tabTitles = this.tabTitles) {
        // In most cases, since these indexes correlate with tab contents, we want to consider all tab titles.
        // However, when doing relative index operations, it makes sense to pass in this.enabledTabTitles as the 2nd arg.
        return tabTitles.indexOf(el);
    }
    async getTabTitleById(id) {
        return Promise.all(this.tabTitles.map((el) => el.getTabIdentifier())).then((ids) => {
            return this.tabTitles[ids.indexOf(id)];
        });
    }
    get tabTitles() {
        return filterDirectChildren(this.el, "calcite-tab-title");
    }
    get enabledTabTitles() {
        return filterDirectChildren(this.el, "calcite-tab-title:not([disabled])").filter((tabTitle) => !tabTitle.closed);
    }
    handleTabTitleClose(closedTabTitleEl) {
        const { tabTitles } = this;
        const selectionModified = closedTabTitleEl.selected;
        const visibleTabTitlesIndices = tabTitles.reduce((tabTitleIndices, tabTitle, index) => !tabTitle.closed ? [...tabTitleIndices, index] : tabTitleIndices, []);
        const totalVisibleTabTitles = visibleTabTitlesIndices.length;
        if (totalVisibleTabTitles === 1 && tabTitles[visibleTabTitlesIndices[0]].closable) {
            tabTitles[visibleTabTitlesIndices[0]].closable = false;
            this.selectedTabId = visibleTabTitlesIndices[0];
            if (selectionModified) {
                tabTitles[visibleTabTitlesIndices[0]].activateTab();
            }
        }
        else if (totalVisibleTabTitles > 1) {
            const closedTabTitleIndex = tabTitles.findIndex((el) => el === closedTabTitleEl);
            const nextTabTitleIndex = visibleTabTitlesIndices.find((value) => value > closedTabTitleIndex);
            if (this.selectedTabId === closedTabTitleIndex) {
                this.selectedTabId = nextTabTitleIndex ? nextTabTitleIndex : totalVisibleTabTitles - 1;
                tabTitles[this.selectedTabId].activateTab();
            }
        }
        requestAnimationFrame(() => {
            this.updateOffsetPosition();
            this.updateActiveWidth();
            tabTitles[this.selectedTabId].focus();
        });
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "selectedTabId": ["selectedTabIdChanged"],
        "selectedTitle": ["selectedTitleChanged"]
    }; }
    static get style() { return tabNavCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tab-nav",
        "$members$": {
            "storageId": [513, "storage-id"],
            "syncId": [513, "sync-id"],
            "selectedTitle": [1040],
            "scale": [1],
            "layout": [1537],
            "position": [1],
            "bordered": [1540],
            "indicatorOffset": [1026, "indicator-offset"],
            "indicatorWidth": [1026, "indicator-width"],
            "selectedTabId": [32]
        },
        "$listeners$": [[0, "calciteInternalTabsFocusPrevious", "focusPreviousTabHandler"], [0, "calciteInternalTabsFocusNext", "focusNextTabHandler"], [0, "calciteInternalTabsFocusFirst", "focusFirstTabHandler"], [0, "calciteInternalTabsFocusLast", "focusLastTabHandler"], [0, "calciteInternalTabsActivate", "internalActivateTabHandler"], [0, "calciteTabsActivate", "activateTabHandler"], [0, "calciteInternalTabsClose", "internalCloseTabHandler"], [0, "calciteInternalTabTitleRegister", "updateTabTitles"], [16, "calciteInternalTabChange", "globalInternalTabChangeHandler"], [0, "calciteInternalTabIconChanged", "iconStartChangeHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["storageId", "storage-id"], ["syncId", "sync-id"], ["layout", "layout"], ["bordered", "bordered"]]
    }; }
}

const CSS$f = {
    closeButton: "close-button",
    container: "container",
    content: "content",
    contentHasText: "content--has-text",
    iconEnd: "icon-end",
    iconPresent: "icon-present",
    iconStart: "icon-start",
    titleIcon: "calcite-tab-title--icon",
};
const ICONS$4 = {
    close: "x",
};

const tabTitleCss = "/*!@:host([disabled])*/[disabled].sc-calcite-tab-title-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-tab-title-h *.sc-calcite-tab-title,.sc-calcite-tab-title-h[disabled].sc-calcite-tab-title-s>*,.sc-calcite-tab-title-h[disabled] .sc-calcite-tab-title-s>*{pointer-events:none}/*!@:host*/.sc-calcite-tab-title-h{display:block;outline:2px solid transparent;outline-offset:2px;margin-inline-start:0px}/*!@:host([layout=inline])*/[layout=inline].sc-calcite-tab-title-h{flex:0 1 auto}/*!@:host([layout=center])*/[layout=center].sc-calcite-tab-title-h{flex:1 1 auto}/*!@:host([layout=center]) .scale-s,\n:host([layout=center]) .scale-m,\n:host([layout=center]) .scale-l*/[layout=center].sc-calcite-tab-title-h .scale-s.sc-calcite-tab-title,[layout=center].sc-calcite-tab-title-h .scale-m.sc-calcite-tab-title,[layout=center].sc-calcite-tab-title-h .scale-l.sc-calcite-tab-title{margin-block:0px;text-align:center;flex-basis:12rem}/*!@:host([layout=center]) .scale-s .content,\n:host([layout=center]) .scale-m .content,\n:host([layout=center]) .scale-l .content*/[layout=center].sc-calcite-tab-title-h .scale-s.sc-calcite-tab-title .content.sc-calcite-tab-title,[layout=center].sc-calcite-tab-title-h .scale-m.sc-calcite-tab-title .content.sc-calcite-tab-title,[layout=center].sc-calcite-tab-title-h .scale-l.sc-calcite-tab-title .content.sc-calcite-tab-title{margin:auto}/*!@:host([layout=center][closable]) .content*/[layout=center][closable].sc-calcite-tab-title-h .content.sc-calcite-tab-title{padding-inline-start:32px}/*!@:host([layout=center][bordered][closable]) .scale-s .content*/[layout=center][bordered][closable].sc-calcite-tab-title-h .scale-s.sc-calcite-tab-title .content.sc-calcite-tab-title{padding-inline-start:36px}/*!@:host([layout=center][bordered][closable]) .scale-m .content*/[layout=center][bordered][closable].sc-calcite-tab-title-h .scale-m.sc-calcite-tab-title .content.sc-calcite-tab-title{padding-inline-start:40px}/*!@:host([layout=center][closable]) .scale-l .content*/[layout=center][closable].sc-calcite-tab-title-h .scale-l.sc-calcite-tab-title .content.sc-calcite-tab-title{padding-inline-start:40px}/*!@:host([layout=center][closable][bordered]) .scale-s .content*/[layout=center][closable][bordered].sc-calcite-tab-title-h .scale-s.sc-calcite-tab-title .content.sc-calcite-tab-title{padding-inline-start:52px}/*!@:host([position=bottom]) .container*/[position=bottom].sc-calcite-tab-title-h .container.sc-calcite-tab-title{border-block-end-width:0px;border-block-start-width:2px;border-block-start-color:transparent;border-block-start-style:solid}/*!@:host([closed])*/[closed].sc-calcite-tab-title-h{display:none}/*!@.container*/.container.sc-calcite-tab-title{outline-color:transparent}/*!@:host(:focus) .container*/.sc-calcite-tab-title-h:focus .container.sc-calcite-tab-title{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host(:focus) .container:focus-within*/.sc-calcite-tab-title-h:focus .container.sc-calcite-tab-title:focus-within{outline-color:transparent}/*!@:host(:active) a,\n:host(:focus) a,\n:host(:hover) a*/.sc-calcite-tab-title-h:active a.sc-calcite-tab-title,.sc-calcite-tab-title-h:focus a.sc-calcite-tab-title,.sc-calcite-tab-title-h:hover a.sc-calcite-tab-title{border-color:var(--calcite-color-border-2);color:var(--calcite-color-text-1);text-decoration-line:none}/*!@:host([selected]) .container*/[selected].sc-calcite-tab-title-h .container.sc-calcite-tab-title{border-color:transparent;color:var(--calcite-color-text-1)}/*!@:host([disabled]) .container*/[disabled].sc-calcite-tab-title-h .container.sc-calcite-tab-title{pointer-events:none;opacity:0.5}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-tab-title-h[disabled] .sc-calcite-tab-title-s>[calcite-hydrated][disabled],[disabled].sc-calcite-tab-title-h [calcite-hydrated][disabled].sc-calcite-tab-title{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-tab-title{display:contents}/*!@.scale-s .content*/.scale-s.sc-calcite-tab-title .content.sc-calcite-tab-title{padding-block:0.25rem;font-size:var(--calcite-font-size--2);line-height:1rem}/*!@.scale-m .content*/.scale-m.sc-calcite-tab-title .content.sc-calcite-tab-title{padding-block:0.5rem;font-size:var(--calcite-font-size--1);line-height:1rem}/*!@.scale-l .content*/.scale-l.sc-calcite-tab-title .content.sc-calcite-tab-title{padding-block:0.625rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@.container*/.container.sc-calcite-tab-title{box-sizing:border-box;display:flex;block-size:100%;inline-size:100%;cursor:pointer;align-content:center;justify-content:space-between;border-block-end-width:2px;padding-inline:0px;font-size:var(--calcite-font-size--1);line-height:1rem;color:var(--calcite-color-text-3);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;border-block-end-color:transparent;border-block-end-style:solid}/*!@.content*/.content.sc-calcite-tab-title{display:flex;align-items:center;justify-content:center}/*!@.calcite-tab-title--icon*/.calcite-tab-title--icon.sc-calcite-tab-title{position:relative;margin:0px;display:inline-flex;align-self:center}/*!@.calcite-tab-title--icon svg*/.calcite-tab-title--icon.sc-calcite-tab-title svg.sc-calcite-tab-title{transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@.content--has-text*/.content--has-text.sc-calcite-tab-title{padding:0.25rem}/*!@.content--has-text .calcite-tab-title--icon.icon-start*/.content--has-text.sc-calcite-tab-title .calcite-tab-title--icon.icon-start.sc-calcite-tab-title{margin-inline-end:0.5rem}/*!@.content--has-text .calcite-tab-title--icon.icon-end*/.content--has-text.sc-calcite-tab-title .calcite-tab-title--icon.icon-end.sc-calcite-tab-title{margin-inline-start:0.5rem}/*!@.close-button*/.close-button.sc-calcite-tab-title{display:flex;cursor:pointer;appearance:none;align-content:center;align-items:center;justify-content:center;align-self:center;border-style:none;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-3);outline-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;block-size:calc(100% - 2px);background-color:var(--calcite-button-transparent-1);margin-inline-start:auto}/*!@.close-button:focus*/.close-button.sc-calcite-tab-title:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          );outline-offset:-1px}/*!@.close-button:focus, .close-button:hover*/.close-button.sc-calcite-tab-title:focus,.close-button.sc-calcite-tab-title:hover{color:var(--calcite-color-text-1);background-color:var(--calcite-color-foreground-2)}/*!@.close-button:active*/.close-button.sc-calcite-tab-title:active{color:var(--calcite-color-text-1);background-color:var(--calcite-color-foreground-3)}/*!@.close-button calcite-icon*/.close-button.sc-calcite-tab-title calcite-icon.sc-calcite-tab-title{color:inherit}/*!@:host([icon-start][icon-end]) .calcite-tab-title--icon:first-child*/[icon-start][icon-end].sc-calcite-tab-title-h .calcite-tab-title--icon.sc-calcite-tab-title:first-child{margin-inline-end:0.5rem}/*!@:host([bordered])*/[bordered].sc-calcite-tab-title-h{margin-inline-end:0}/*!@:host([bordered][selected])*/[bordered][selected].sc-calcite-tab-title-h{box-shadow:inset 0px -2px var(--calcite-color-foreground-1)}/*!@:host([bordered][selected][position=bottom])*/[bordered][selected][position=bottom].sc-calcite-tab-title-h{box-shadow:inset 0 2px 0 var(--calcite-color-foreground-1)}/*!@:host([bordered]:hover) .container,\n:host([bordered]:focus) .container,\n:host([bordered]:active) .container*/[bordered].sc-calcite-tab-title-h:hover .container.sc-calcite-tab-title,[bordered].sc-calcite-tab-title-h:focus .container.sc-calcite-tab-title,[bordered].sc-calcite-tab-title-h:active .container.sc-calcite-tab-title{position:relative}/*!@:host([bordered]:hover) .container*/[bordered].sc-calcite-tab-title-h:hover .container.sc-calcite-tab-title{background-color:var(--calcite-color-transparent-hover)}/*!@:host([closable]) .container,\n:host([bordered]) .container*/[closable].sc-calcite-tab-title-h .container.sc-calcite-tab-title,[bordered].sc-calcite-tab-title-h .container.sc-calcite-tab-title{border-inline-start:1px solid transparent;border-inline-end:1px solid transparent}/*!@:host([closable]) .container .close-button,\n:host([bordered]) .container .close-button*/[closable].sc-calcite-tab-title-h .container.sc-calcite-tab-title .close-button.sc-calcite-tab-title,[bordered].sc-calcite-tab-title-h .container.sc-calcite-tab-title .close-button.sc-calcite-tab-title{margin-inline:0}/*!@:host([closable]) .content*/[closable].sc-calcite-tab-title-h .content.sc-calcite-tab-title{box-sizing:border-box;block-size:100%;border-block-end-color:transparent}/*!@:host([closable][position=bottom]) .container,\n:host([bordered][position=bottom]) .container*/[closable][position=bottom].sc-calcite-tab-title-h .container.sc-calcite-tab-title,[bordered][position=bottom].sc-calcite-tab-title-h .container.sc-calcite-tab-title{border-block-start-style:unset}/*!@:host([selected][bordered]) .container*/[selected][bordered].sc-calcite-tab-title-h .container.sc-calcite-tab-title{border-inline-start-color:var(--calcite-color-border-1);border-inline-end-color:var(--calcite-color-border-1)}/*!@:host([bordered]) .content*/[bordered].sc-calcite-tab-title-h .content.sc-calcite-tab-title{padding-inline:0.75rem}/*!@:host([bordered]) .scale-s .content*/[bordered].sc-calcite-tab-title-h .scale-s.sc-calcite-tab-title .content.sc-calcite-tab-title{padding-inline:0.5rem}/*!@:host([bordered]) .scale-l .content*/[bordered].sc-calcite-tab-title-h .scale-l.sc-calcite-tab-title .content.sc-calcite-tab-title{padding-inline:1rem}@media (forced-colors: active){/*!@:host*/.sc-calcite-tab-title-h{outline-width:0;outline-offset:0}/*!@:host(:focus) .container*/.sc-calcite-tab-title-h:focus .container.sc-calcite-tab-title{outline-color:highlight}/*!@:host([bordered]) .container*/[bordered].sc-calcite-tab-title-h .container.sc-calcite-tab-title{border-block-end-style:solid}/*!@:host([bordered][position=bottom]) .container*/[bordered][position=bottom].sc-calcite-tab-title-h .container.sc-calcite-tab-title{border-block-start-style:solid}/*!@:host([bordered][selected]) .container*/[bordered][selected].sc-calcite-tab-title-h .container.sc-calcite-tab-title{border-block-end-style:none}/*!@:host([bordered][position=bottom][selected]) .container*/[bordered][position=bottom][selected].sc-calcite-tab-title-h .container.sc-calcite-tab-title{border-block-start-style:none}/*!@.close-button*/.close-button.sc-calcite-tab-title{z-index:var(--calcite-z-index)}}/*!@:host([hidden])*/[hidden].sc-calcite-tab-title-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tab-title{display:none}";

/**
 * Tab-titles are optionally individually closable.
 */
/**
 * @slot - A slot for adding text.
 */
class TabTitle {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteTabsActivate = createEvent(this, "calciteTabsActivate", 6);
        this.calciteInternalTabsActivate = createEvent(this, "calciteInternalTabsActivate", 6);
        this.calciteTabsClose = createEvent(this, "calciteTabsClose", 6);
        this.calciteInternalTabsClose = createEvent(this, "calciteInternalTabsClose", 6);
        this.calciteInternalTabsFocusNext = createEvent(this, "calciteInternalTabsFocusNext", 6);
        this.calciteInternalTabsFocusPrevious = createEvent(this, "calciteInternalTabsFocusPrevious", 6);
        this.calciteInternalTabsFocusFirst = createEvent(this, "calciteInternalTabsFocusFirst", 6);
        this.calciteInternalTabsFocusLast = createEvent(this, "calciteInternalTabsFocusLast", 6);
        this.calciteInternalTabTitleRegister = createEvent(this, "calciteInternalTabTitleRegister", 6);
        this.calciteInternalTabIconChanged = createEvent(this, "calciteInternalTabIconChanged", 6);
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.closeClickHandler = () => {
            this.closeTabTitleAndNotify();
        };
        /** watches for changing text content */
        this.mutationObserver = createObserver();
        this.resizeObserver = createObserver();
        this.guid = `calcite-tab-title-${guid()}`;
        this.selected = false;
        this.closable = false;
        this.closed = false;
        this.disabled = false;
        this.iconEnd = undefined;
        this.iconFlipRtl = undefined;
        this.iconStart = undefined;
        this.layout = undefined;
        this.position = "top";
        this.scale = "m";
        this.bordered = false;
        this.tab = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.controls = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = undefined;
        this.hasText = false;
    }
    selectedHandler() {
        if (this.selected) {
            this.activateTab(false);
        }
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
        this.setupTextContentObserver();
        this.parentTabNavEl = this.el.closest("calcite-tab-nav");
        this.parentTabsEl = this.el.closest("calcite-tabs");
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
        // Dispatching to body in order to be listened by other elements that are still connected to the DOM.
        document.body?.dispatchEvent(new CustomEvent("calciteTabTitleUnregister", {
            detail: this.el,
        }));
        this.resizeObserver?.disconnect();
        disconnectInteractive(this);
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    async componentWillLoad() {
        await setUpMessages(this);
        if (this.tab && this.selected) {
            this.activateTab(false);
        }
    }
    componentWillRender() {
        if (this.parentTabsEl) {
            this.layout = this.parentTabsEl.layout;
            this.bordered = this.parentTabsEl.bordered;
        }
    }
    render() {
        const { el, closed } = this;
        const id = el.id || this.guid;
        const iconStartEl = (hAsync("calcite-icon", { class: { [CSS$f.titleIcon]: true, [CSS$f.iconStart]: true }, flipRtl: this.iconFlipRtl === "start" || this.iconFlipRtl === "both", icon: this.iconStart, scale: getIconScale(this.scale) }));
        const iconEndEl = (hAsync("calcite-icon", { class: { [CSS$f.titleIcon]: true, [CSS$f.iconEnd]: true }, flipRtl: this.iconFlipRtl === "end" || this.iconFlipRtl === "both", icon: this.iconEnd, scale: getIconScale(this.scale) }));
        return (hAsync(Host, { "aria-controls": this.controls, "aria-selected": toAriaBoolean(this.selected), id: id, role: "tab", tabIndex: this.selected && !this.disabled ? 0 : -1 }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: {
                container: true,
                [CSS$f.iconPresent]: !!this.iconStart || !!this.iconEnd,
                [`scale-${this.scale}`]: true,
            }, hidden: closed,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => this.resizeObserver?.observe(el) }, hAsync("div", { class: { [CSS$f.content]: true, [CSS$f.contentHasText]: this.hasText } }, this.iconStart ? iconStartEl : null, hAsync("slot", null), this.iconEnd ? iconEndEl : null), this.renderCloseButton()))));
    }
    renderCloseButton() {
        const { closable, messages } = this;
        return closable ? (hAsync("button", { "aria-label": messages.close, class: CSS$f.closeButton, disabled: false, key: CSS$f.closeButton, onClick: this.closeClickHandler, title: messages.close, type: "button",
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.closeButtonEl = el) }, hAsync("calcite-icon", { icon: ICONS$4.close, scale: getIconScale(this.scale) }))) : null;
    }
    async componentDidLoad() {
        this.calciteInternalTabTitleRegister.emit(await this.getTabIdentifier());
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    internalTabChangeHandler(event) {
        const targetTabsEl = event
            .composedPath()
            .find((el) => el.tagName === "CALCITE-TABS");
        if (targetTabsEl !== this.parentTabsEl) {
            return;
        }
        if (this.tab) {
            this.selected = this.tab === event.detail.tab;
        }
        else {
            this.getTabIndex().then((index) => {
                this.selected = index === event.detail.tab;
            });
        }
        event.stopPropagation();
    }
    onClick() {
        this.activateTab();
    }
    keyDownHandler(event) {
        switch (event.key) {
            case " ":
            case "Enter":
                if (!event.composedPath().includes(this.closeButtonEl)) {
                    this.activateTab();
                    event.preventDefault();
                }
                break;
            case "ArrowRight":
                event.preventDefault();
                if (getElementDir(this.el) === "ltr") {
                    this.calciteInternalTabsFocusNext.emit();
                }
                else {
                    this.calciteInternalTabsFocusPrevious.emit();
                }
                break;
            case "ArrowLeft":
                event.preventDefault();
                if (getElementDir(this.el) === "ltr") {
                    this.calciteInternalTabsFocusPrevious.emit();
                }
                else {
                    this.calciteInternalTabsFocusNext.emit();
                }
                break;
            case "Home":
                event.preventDefault();
                this.calciteInternalTabsFocusFirst.emit();
                break;
            case "End":
                event.preventDefault();
                this.calciteInternalTabsFocusLast.emit();
                break;
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Returns the index of the title within the `calcite-tab-nav`.
     */
    async getTabIndex() {
        return Array.prototype.indexOf.call(nodeListToArray(this.el.parentElement.children).filter((el) => el.matches("calcite-tab-title")), this.el);
    }
    /**
     * @internal
     */
    async getTabIdentifier() {
        return this.tab ? this.tab : this.getTabIndex();
    }
    /**
     * @param tabIds
     * @param titleIds
     * @internal
     */
    async updateAriaInfo(tabIds = [], titleIds = []) {
        this.controls = tabIds[titleIds.indexOf(this.el.id)] || null;
    }
    /**
     * This activates a tab in order for it and its associated tab-title be selected.
     *
     * @param userTriggered - when `true`, user-interaction events will be emitted in addition to internal events
     * @internal
     */
    async activateTab(userTriggered = true) {
        if (this.disabled || this.closed) {
            return;
        }
        const payload = { tab: this.tab };
        this.calciteInternalTabsActivate.emit(payload);
        if (userTriggered) {
            // emit in the next frame to let internal events sync up
            requestAnimationFrame(() => this.calciteTabsActivate.emit());
        }
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    updateHasText() {
        this.hasText = this.el.textContent.trim().length > 0;
    }
    setupTextContentObserver() {
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
    }
    closeTabTitleAndNotify() {
        this.closed = true;
        this.calciteInternalTabsClose.emit({ tab: this.tab });
        this.calciteTabsClose.emit();
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "selected": ["selectedHandler"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return tabTitleCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tab-title",
        "$members$": {
            "selected": [1540],
            "closable": [516],
            "closed": [1540],
            "disabled": [516],
            "iconEnd": [513, "icon-end"],
            "iconFlipRtl": [513, "icon-flip-rtl"],
            "iconStart": [513, "icon-start"],
            "layout": [1537],
            "position": [1],
            "scale": [1],
            "bordered": [1540],
            "tab": [513],
            "messages": [1040],
            "messageOverrides": [1040],
            "controls": [32],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "hasText": [32],
            "getTabIndex": [64],
            "getTabIdentifier": [64],
            "updateAriaInfo": [64],
            "activateTab": [64]
        },
        "$listeners$": [[16, "calciteInternalTabChange", "internalTabChangeHandler"], [0, "click", "onClick"], [0, "keydown", "keyDownHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["selected", "selected"], ["closable", "closable"], ["closed", "closed"], ["disabled", "disabled"], ["iconEnd", "icon-end"], ["iconFlipRtl", "icon-flip-rtl"], ["iconStart", "icon-start"], ["layout", "layout"], ["bordered", "bordered"], ["tab", "tab"]]
    }; }
}

const CSS$e = {
    bordered: "bordered",
    striped: "striped",
    selectionArea: "selection-area",
    paginationArea: "pagination-area",
    container: "container",
    tableContainer: "table-container",
    tableFixed: "table--fixed",
    assistiveText: "assistive-text",
    selectionActions: "selection-actions",
};
const SLOTS$6 = {
    selectionActions: "selection-actions",
    tableHeader: "table-header",
    tableFooter: "table-footer",
};

const tableCss = "/*!@:host([scale=s])*/[scale=s].sc-calcite-table-h{--calcite-internal-table-cell-padding:0.25rem;--calcite-internal-table-cell-font-size:var(--calcite-font-size--2);--calcite-internal-table-cell-font-size-secondary:var(--calcite-font-size--3)}/*!@:host([scale=m])*/[scale=m].sc-calcite-table-h{--calcite-internal-table-cell-padding:0.5rem;--calcite-internal-table-cell-font-size:var(--calcite-font-size--1);--calcite-internal-table-cell-font-size-secondary:var(--calcite-font-size--2)}/*!@:host([scale=l])*/[scale=l].sc-calcite-table-h{--calcite-internal-table-cell-padding:1rem;--calcite-internal-table-cell-font-size:var(--calcite-font-size-0);--calcite-internal-table-cell-font-size-secondary:var(--calcite-font-size--1)}/*!@:host*/.sc-calcite-table-h{display:flex}/*!@.container*/.container.sc-calcite-table{display:flex;block-size:100%;inline-size:100%;flex-direction:column}/*!@.table-container*/.table-container.sc-calcite-table{overflow:auto;white-space:nowrap;border:1px solid var(--calcite-color-border-3)}/*!@.assistive-text*/.assistive-text.sc-calcite-table{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}/*!@table*/table.sc-calcite-table{inline-size:100%;border-collapse:collapse;overflow-x:scroll}/*!@.table--fixed*/.table--fixed.sc-calcite-table{table-layout:fixed}/*!@.bordered ::slotted(calcite-table-row)*/.bordered .sc-calcite-table-s>calcite-table-row{--calcite-table-row-border-color:var(--calcite-color-border-3)}/*!@.striped ::slotted(calcite-table-row:nth-child(2n+1))*/.striped .sc-calcite-table-s>calcite-table-row:nth-child(2n+1){--calcite-table-row-background:var(--calcite-color-foreground-2)}/*!@.selection-actions*/.selection-actions.sc-calcite-table{display:flex;flex-direction:row;margin-inline-start:auto}/*!@.selection-area*/.selection-area.sc-calcite-table{display:flex;flex-direction:row;align-items:center;padding-block:var(--calcite-internal-table-cell-padding)}/*!@.selection-area calcite-chip:last-of-type*/.selection-area.sc-calcite-table calcite-chip.sc-calcite-table:last-of-type{margin-inline-end:0.5rem}/*!@.selection-area calcite-chip:last-of-type:not(:first-of-type)*/.selection-area.sc-calcite-table calcite-chip.sc-calcite-table:last-of-type:not(:first-of-type){margin-inline-start:0.5rem}/*!@.selection-area calcite-button*/.selection-area.sc-calcite-table calcite-button.sc-calcite-table{margin-inline-end:1rem}/*!@.pagination-area*/.pagination-area.sc-calcite-table{display:flex;inline-size:100%;flex-direction:row;justify-content:center;padding-block:var(--calcite-internal-table-cell-padding)}/*!@calcite-pagination*/calcite-pagination.sc-calcite-table{flex:1;justify-content:center}/*!@:host([hidden])*/[hidden].sc-calcite-table-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-table{display:none}";

/**
 * @slot - A slot for adding `calcite-table-row` elements containing `calcite-table-cell` and/or `calcite-table-header` elements.
 * @slot table-header - A slot for adding `calcite-table-row` elements containing `calcite-table-header` elements.
 * @slot table-footer - A slot for adding `calcite-table-row` elements containing `calcite-table-cell` and/or `calcite-table-header` elements.
 * @slot selection-actions - A slot for adding a `calcite-action-bar` or other elements to display when `selectionMode` is not `"none"`.
 */
class Table {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteTableSelect = createEvent(this, "calciteTableSelect", 6);
        this.calciteTablePageChange = createEvent(this, "calciteTablePageChange", 6);
        this.calciteInternalTableRowFocusChange = createEvent(this, "calciteInternalTableRowFocusChange", 6);
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.getSlottedRows = (el) => {
            return el
                ?.assignedElements({ flatten: true })
                ?.filter((el) => el?.matches("calcite-table-row"));
        };
        this.updateRows = () => {
            const headRows = this.getSlottedRows(this.tableHeadSlotEl) || [];
            const bodyRows = this.getSlottedRows(this.tableBodySlotEl) || [];
            const footRows = this.getSlottedRows(this.tableFootSlotEl) || [];
            const allRows = [...headRows, ...bodyRows, ...footRows];
            headRows?.forEach((row) => {
                const position = headRows?.indexOf(row);
                row.rowType = "head";
                row.positionSection = position;
                row.positionSectionLocalized = this.localizeNumber((position + 1).toString());
            });
            bodyRows?.forEach((row) => {
                const position = bodyRows?.indexOf(row);
                row.rowType = "body";
                row.positionSection = position;
                row.positionSectionLocalized = this.localizeNumber((position + 1).toString());
            });
            footRows?.forEach((row) => {
                const position = footRows?.indexOf(row);
                row.rowType = "foot";
                row.positionSection = position;
                row.positionSectionLocalized = this.localizeNumber((position + 1).toString());
            });
            allRows?.forEach((row) => {
                row.interactionMode = this.interactionMode;
                row.selectionMode = this.selectionMode;
                row.bodyRowCount = bodyRows?.length;
                row.positionAll = allRows?.indexOf(row);
                row.numbered = this.numbered;
                row.scale = this.scale;
                row.readCellContentsToAT = this.readCellContentsToAT;
                row.lastVisibleRow = allRows?.indexOf(row) === allRows.length - 1;
            });
            const colCount = headRows[0]?.cellCount || headRows[0]?.querySelectorAll("calcite-table-header")?.length;
            this.colCount = colCount;
            this.headRows = headRows;
            this.bodyRows = bodyRows;
            this.footRows = footRows;
            this.allRows = allRows;
            this.updateSelectedItems();
            this.paginateRows();
        };
        this.handlePaginationChange = () => {
            const requestedItem = this.paginationEl?.startItem;
            this.pageStartRow = requestedItem || 1;
            this.calciteTablePageChange.emit();
            this.updateRows();
        };
        this.paginateRows = () => {
            this.bodyRows?.forEach((row) => {
                const rowPos = row.positionSection + 1;
                const inView = rowPos >= this.pageStartRow && rowPos < this.pageStartRow + this.pageSize;
                row.hidden = this.pageSize > 0 && !inView && !this.footRows.includes(row);
                row.lastVisibleRow =
                    rowPos === this.pageStartRow + this.pageSize - 1 || rowPos === this.bodyRows.length;
            });
        };
        this.updateSelectedItems = (emit) => {
            const selectedItems = this.bodyRows?.filter((el) => el.selected);
            this.selectedItems = selectedItems;
            this.selectedCount = selectedItems?.length;
            this.allRows?.forEach((row) => {
                row.selectedRowCount = this.selectedCount;
                row.selectedRowCountLocalized = this.localizeNumber(this.selectedCount);
            });
            if (emit) {
                this.calciteTableSelect.emit();
            }
        };
        this.handleDeselectAllRows = () => {
            this.bodyRows?.forEach((row) => {
                row.selected = false;
            });
            this.updateSelectedItems(true);
        };
        this.setSelectedItems = (elToMatch) => {
            this.bodyRows?.forEach((el) => {
                if (elToMatch?.rowType === "head") {
                    el.selected = this.selectedCount !== this.bodyRows?.length;
                }
                else {
                    el.selected =
                        elToMatch === el ? !el.selected : this.selectionMode === "multiple" ? el.selected : false;
                }
            });
            this.updateSelectedItems(true);
        };
        this.localizeNumber = (value) => {
            numberStringFormatter.numberFormatOptions = {
                locale: this.effectiveLocale,
                numberingSystem: this.numberingSystem,
                useGrouping: this.groupSeparator,
            };
            return numberStringFormatter.localize(value.toString());
        };
        this.bordered = false;
        this.caption = undefined;
        this.groupSeparator = false;
        this.interactionMode = "interactive";
        this.layout = "auto";
        this.numbered = false;
        this.numberingSystem = undefined;
        this.pageSize = 0;
        this.scale = "m";
        this.selectionMode = "none";
        this.zebra = false;
        this.striped = false;
        this.selectedItems = [];
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.colCount = 0;
        this.pageStartRow = 1;
        this.selectedCount = 0;
        this.readCellContentsToAT = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
    }
    handleNumberedChange() {
        this.updateRows();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
        this.readCellContentsToAT = /safari/i.test(getUserAgentString());
        this.updateRows();
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    connectedCallback() {
        connectLocalized(this);
        connectMessages(this);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    calciteChipSelectListener(event) {
        if (event.composedPath().includes(this.el)) {
            this.setSelectedItems(event.target);
        }
    }
    calciteInternalTableRowFocusEvent(event) {
        const cellPosition = event["detail"].cellPosition;
        const rowPos = event["detail"].rowPosition;
        const destination = event["detail"].destination;
        const lastCell = event["detail"].lastCell;
        const visibleBody = this.bodyRows?.filter((row) => !row.hidden);
        const visibleAll = this.allRows?.filter((row) => !row.hidden);
        const lastHeadRow = this.headRows[this.headRows.length - 1]?.positionAll;
        const firstBodyRow = visibleBody[0]?.positionAll;
        const lastBodyRow = visibleBody[visibleBody.length - 1]?.positionAll;
        const firstFootRow = this.footRows[0]?.positionAll;
        const lastTableRow = visibleAll[visibleAll.length - 1]?.positionAll;
        const leavingHeader = destination === "next" && rowPos === lastHeadRow;
        const leavingFooter = destination === "previous" && rowPos === firstFootRow;
        const enteringHeader = destination === "previous" && rowPos === firstBodyRow;
        const enteringFooter = destination === "next" && rowPos === lastBodyRow;
        let rowPosition;
        switch (destination) {
            case "first":
                rowPosition = 0;
                break;
            case "last":
                rowPosition = lastTableRow;
                break;
            case "next":
                rowPosition = leavingHeader ? firstBodyRow : enteringFooter ? firstFootRow : rowPos + 1;
                break;
            case "previous":
                rowPosition = leavingFooter ? lastBodyRow : enteringHeader ? lastHeadRow : rowPos - 1;
                break;
        }
        const destinationCount = this.allRows?.find((row) => row.positionAll === rowPosition)
            ?.cellCount;
        const adjustedPos = cellPosition > destinationCount ? destinationCount : cellPosition;
        if (rowPosition !== undefined) {
            this.calciteInternalTableRowFocusChange.emit({
                cellPosition: adjustedPos,
                rowPosition,
                destination,
                lastCell,
            });
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderSelectionArea() {
        const outOfViewCount = this.selectedItems?.filter((el) => el.hidden)?.length;
        const localizedOutOfView = this.localizeNumber(outOfViewCount?.toString());
        const localizedSelectedCount = this.localizeNumber(this.selectedCount?.toString());
        const selectionText = `${localizedSelectedCount} ${this.messages.selected}`;
        const outOfView = `${localizedOutOfView} ${this.messages.hiddenSelected}`;
        return (hAsync("div", { class: CSS$e.selectionArea }, hAsync("calcite-chip", { kind: this.selectedCount > 0 ? "brand" : "neutral", scale: this.scale, value: selectionText }, selectionText), outOfViewCount > 0 && (hAsync("calcite-chip", { icon: "hide-empty", scale: this.scale, title: outOfView, value: outOfView }, localizedOutOfView)), this.selectedCount > 0 && (hAsync("calcite-button", { "icon-start": "x", kind: "neutral", onClick: this.handleDeselectAllRows, round: true, scale: this.scale, title: `${this.messages.clear} ${selectionText} ${this.messages.row}` }, this.messages.clear)), hAsync("div", { class: CSS$e.selectionActions }, hAsync("slot", { name: SLOTS$6.selectionActions }))));
    }
    renderPaginationArea() {
        return (hAsync("div", { class: CSS$e.paginationArea }, hAsync("calcite-pagination", { groupSeparator: this.groupSeparator, numberingSystem: this.numberingSystem, onCalcitePaginationChange: this.handlePaginationChange, pageSize: this.pageSize, scale: this.scale, startItem: 1, totalItems: this.bodyRows?.length,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.paginationEl = el) })));
    }
    renderTHead() {
        return (hAsync("thead", null, hAsync("slot", { name: SLOTS$6.tableHeader, onSlotchange: this.updateRows, ref: (el) => (this.tableHeadSlotEl = el) })));
    }
    renderTBody() {
        return (hAsync("tbody", null, hAsync("slot", { onSlotchange: this.updateRows, ref: (el) => (this.tableBodySlotEl = el) })));
    }
    renderTFoot() {
        return (hAsync("tfoot", null, hAsync("slot", { name: SLOTS$6.tableFooter, onSlotchange: this.updateRows, ref: (el) => (this.tableFootSlotEl = el) })));
    }
    render() {
        return (hAsync(Host, null, hAsync("div", { class: CSS$e.container }, this.selectionMode !== "none" && this.renderSelectionArea(), hAsync("div", { class: {
                [CSS$e.bordered]: this.bordered,
                [CSS$e.striped]: this.striped || this.zebra,
                [CSS$e.tableContainer]: true,
            } }, hAsync("table", { "aria-colcount": this.colCount, "aria-multiselectable": this.selectionMode === "multiple", "aria-rowcount": this.allRows?.length, class: { [CSS$e.tableFixed]: this.layout === "fixed" }, role: this.interactionMode === "interactive" ? "grid" : "table" }, hAsync("caption", { class: CSS$e.assistiveText }, this.caption), this.renderTHead(), this.renderTBody(), this.renderTFoot())), this.pageSize > 0 && this.renderPaginationArea())));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "groupSeparator": ["handleNumberedChange"],
        "interactionMode": ["handleNumberedChange"],
        "numbered": ["handleNumberedChange"],
        "numberingSystem": ["handleNumberedChange"],
        "pageSize": ["handleNumberedChange"],
        "scale": ["handleNumberedChange"],
        "selectionMode": ["handleNumberedChange"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return tableCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-table",
        "$members$": {
            "bordered": [516],
            "caption": [1],
            "groupSeparator": [516, "group-separator"],
            "interactionMode": [513, "interaction-mode"],
            "layout": [513],
            "numbered": [516],
            "numberingSystem": [513, "numbering-system"],
            "pageSize": [514, "page-size"],
            "scale": [513],
            "selectionMode": [513, "selection-mode"],
            "zebra": [516],
            "striped": [516],
            "selectedItems": [1040],
            "messages": [1040],
            "messageOverrides": [1040],
            "colCount": [32],
            "pageStartRow": [32],
            "selectedCount": [32],
            "readCellContentsToAT": [32],
            "defaultMessages": [32],
            "effectiveLocale": [32]
        },
        "$listeners$": [[0, "calciteTableRowSelect", "calciteChipSelectListener"], [0, "calciteInternalTableRowFocusRequest", "calciteInternalTableRowFocusEvent"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["bordered", "bordered"], ["groupSeparator", "group-separator"], ["interactionMode", "interaction-mode"], ["layout", "layout"], ["numbered", "numbered"], ["numberingSystem", "numbering-system"], ["pageSize", "page-size"], ["scale", "scale"], ["selectionMode", "selection-mode"], ["zebra", "zebra"], ["striped", "striped"]]
    }; }
}

const CSS$d = {
    numberCell: "number-cell",
    footerCell: "footer-cell",
    selectionCell: "selection-cell",
    selectedCell: "selected-cell",
    assistiveText: "assistive-text",
    lastCell: "last-cell",
    staticCell: "static-cell",
};

const tableCellCss = "/*!@:host([disabled])*/[disabled].sc-calcite-table-cell-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-table-cell-h *.sc-calcite-table-cell,.sc-calcite-table-cell-h[disabled].sc-calcite-table-cell-s>*,.sc-calcite-table-cell-h[disabled] .sc-calcite-table-cell-s>*{pointer-events:none}/*!@:host*/.sc-calcite-table-cell-h{--calcite-internal-table-cell-background:var(--calcite-table-cell-background, transparent);display:contents}/*!@:host([alignment=center]) td*/[alignment=center].sc-calcite-table-cell-h td.sc-calcite-table-cell{text-align:center}/*!@:host([alignment=end]) td*/[alignment=end].sc-calcite-table-cell-h td.sc-calcite-table-cell{text-align:end}/*!@.assistive-text*/.assistive-text.sc-calcite-table-cell{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}/*!@td*/td.sc-calcite-table-cell{white-space:normal;text-align:start;vertical-align:middle;color:var(--calcite-color-text-1);background:var(--calcite-internal-table-cell-background);font-size:var(--calcite-internal-table-cell-font-size);border-inline-end:1px solid var(--calcite-color-border-3);padding:var(--calcite-internal-table-cell-padding)}/*!@td:not(.static-cell)*/td.sc-calcite-table-cell:not(.static-cell){outline-color:transparent}/*!@td:not(.static-cell):focus*/td.sc-calcite-table-cell:not(.static-cell):focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@td.last-cell*/td.last-cell.sc-calcite-table-cell{border-inline-end:0}/*!@.number-cell*/.number-cell.sc-calcite-table-cell{background-color:var(--calcite-color-foreground-2)}/*!@.footer-cell*/.footer-cell.sc-calcite-table-cell{background-color:var(--calcite-color-background);font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1);border-block-start:1px solid var(--calcite-color-border-3)}/*!@.number-cell,\n.selection-cell*/.number-cell.sc-calcite-table-cell,.selection-cell.sc-calcite-table-cell{border-inline-end:1px solid var(--calcite-color-border-3);inline-size:2rem;min-inline-size:2rem}/*!@.selection-cell*/.selection-cell.sc-calcite-table-cell{color:var(--calcite-color-text-3);inset-inline-start:2rem}/*!@.selection-cell:not(.footer-cell)*/.selection-cell.sc-calcite-table-cell:not(.footer-cell){cursor:pointer}/*!@.selected-cell:not(.number-cell):not(.footer-cell)*/.selected-cell.sc-calcite-table-cell:not(.number-cell):not(.footer-cell){--calcite-internal-table-cell-background:var(--calcite-color-foreground-current)}/*!@.selection-cell.selected-cell*/.selection-cell.selected-cell.sc-calcite-table-cell{box-shadow:inset 0.25rem 0 0 0 var(--calcite-color-brand);color:var(--calcite-color-brand)}/*!@.selection-cell.selected-cell calcite-icon*/.selection-cell.selected-cell.sc-calcite-table-cell calcite-icon.sc-calcite-table-cell{color:var(--calcite-color-brand)}/*!@.calcite--rtl.selection-cell.selected-cell*/.calcite--rtl.selection-cell.selected-cell.sc-calcite-table-cell{box-shadow:inset -0.25rem 0 0 0 var(--calcite-color-brand)}/*!@.selection-cell*/.selection-cell.sc-calcite-table-cell{vertical-align:middle}/*!@.selection-cell ::slotted(calcite-icon)*/.selection-cell .sc-calcite-table-cell-s>calcite-icon{pointer-events:none;margin-block-start:0.25rem}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-table-cell-h[disabled] .sc-calcite-table-cell-s>[calcite-hydrated][disabled],[disabled].sc-calcite-table-cell-h [calcite-hydrated][disabled].sc-calcite-table-cell{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-table-cell{display:contents}";

/**
 * @slot - A slot for adding content, usually text content.
 */
class TableCell {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.updateScreenReaderContentsText = () => {
            this.contentsText = this.el.textContent;
        };
        this.onContainerBlur = () => {
            this.focused = false;
        };
        this.onContainerFocus = () => {
            this.focused = true;
        };
        this.alignment = "start";
        this.colSpan = undefined;
        this.rowSpan = undefined;
        this.disabled = undefined;
        this.interactionMode = "interactive";
        this.lastCell = undefined;
        this.numberCell = undefined;
        this.parentRowIsSelected = undefined;
        this.parentRowPositionLocalized = undefined;
        this.parentRowType = undefined;
        this.positionInRow = undefined;
        this.readCellContentsToAT = undefined;
        this.scale = "m";
        this.selectionCell = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.contentsText = "";
        this.defaultMessages = undefined;
        this.focused = false;
        this.selectionText = "";
        this.effectiveLocale = "";
    }
    onSelectedChange() {
        this.updateScreenReaderSelectionText();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
        this.updateScreenReaderContentsText();
        this.updateScreenReaderSelectionText();
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    connectedCallback() {
        connectLocalized(this);
        connectMessages(this);
        connectInteractive(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectMessages(this);
        disconnectInteractive(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.containerEl.focus();
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    updateScreenReaderSelectionText() {
        const selectedText = `${this.messages?.row} ${this.parentRowPositionLocalized} ${this.messages?.selected} ${this.messages?.keyboardDeselect}`;
        const unselectedText = `${this.messages?.row} ${this.parentRowPositionLocalized} ${this.messages?.unselected} ${this.messages?.keyboardSelect}`;
        this.selectionText = this.parentRowIsSelected ? selectedText : unselectedText;
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const dir = getElementDir(this.el);
        const staticCell = this.disabled ||
            (this.interactionMode === "static" &&
                (!this.selectionCell || (this.selectionCell && this.parentRowType === "foot")));
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("td", { "aria-disabled": this.disabled, class: {
                [CSS$d.footerCell]: this.parentRowType === "foot",
                [CSS$d.numberCell]: this.numberCell,
                [CSS$d.selectionCell]: this.selectionCell,
                [CSS$d.selectedCell]: this.parentRowIsSelected,
                [CSS$d.lastCell]: this.lastCell && (!this.rowSpan || (this.colSpan && !!this.rowSpan)),
                [CSS_UTILITY.rtl]: dir === "rtl",
                [CSS$d.staticCell]: staticCell,
            }, colSpan: this.colSpan, onBlur: this.onContainerBlur, onFocus: this.onContainerFocus, role: this.interactionMode === "interactive" ? "gridcell" : "cell", rowSpan: this.rowSpan, tabIndex: staticCell ? -1 : 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.containerEl = el) }, hAsync("span", { "aria-hidden": true, "aria-live": this.focused ? "polite" : "off", class: CSS$d.assistiveText }, (this.selectionCell || this.readCellContentsToAT) && (hAsync(Fragment, null, this.selectionCell && this.selectionText, this.readCellContentsToAT && !this.selectionCell && this.contentsText))), hAsync("slot", { onSlotchange: this.updateScreenReaderContentsText })))));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "parentRowIsSelected": ["onSelectedChange"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return tableCellCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-table-cell",
        "$members$": {
            "alignment": [513],
            "colSpan": [514, "col-span"],
            "rowSpan": [514, "row-span"],
            "disabled": [4],
            "interactionMode": [1, "interaction-mode"],
            "lastCell": [4, "last-cell"],
            "numberCell": [4, "number-cell"],
            "parentRowIsSelected": [4, "parent-row-is-selected"],
            "parentRowPositionLocalized": [1, "parent-row-position-localized"],
            "parentRowType": [1, "parent-row-type"],
            "positionInRow": [2, "position-in-row"],
            "readCellContentsToAT": [4, "read-cell-contents-to-a-t"],
            "scale": [1],
            "selectionCell": [4, "selection-cell"],
            "messages": [1040],
            "messageOverrides": [1040],
            "contentsText": [32],
            "defaultMessages": [32],
            "focused": [32],
            "selectionText": [32],
            "effectiveLocale": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["alignment", "alignment"], ["colSpan", "col-span"], ["rowSpan", "row-span"]]
    }; }
}

const CSS$c = {
    numberCell: "number-cell",
    selectionCell: "selection-cell",
    bodyRow: "body-row",
    footerRow: "footer-row",
    heading: "heading",
    description: "description",
    multipleSelectionCell: "cell--multiple-selection",
    assistiveText: "assistive-text",
    active: "active",
    selectedCell: "selected-cell",
    lastCell: "last-cell",
    staticCell: "static-cell",
};

const tableHeaderCss = "/*!@:host*/.sc-calcite-table-header-h{--calcite-internal-table-header-background:var(--calcite-table-header-background, var(--calcite-color-foreground-2));--calcite-internal-table-header-border-color:var(--calcite-table-border-color, var(--calcite-color-border-3));display:contents}/*!@:host([alignment=center]) th*/[alignment=center].sc-calcite-table-header-h th.sc-calcite-table-header{text-align:center}/*!@:host([alignment=end]) th*/[alignment=end].sc-calcite-table-header-h th.sc-calcite-table-header{text-align:end}/*!@.assistive-text*/.assistive-text.sc-calcite-table-header{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}/*!@th*/th.sc-calcite-table-header{white-space:normal;text-align:start;vertical-align:top;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1);font-size:var(--calcite-internal-table-cell-font-size);border-inline-end:1px solid var(--calcite-internal-table-header-border-color);border-block-end:1px solid var(--calcite-internal-table-header-border-color);padding-block:calc(var(--calcite-internal-table-cell-padding) * 1.5);padding-inline:var(--calcite-internal-table-cell-padding);background-color:var(--calcite-internal-table-header-background)}/*!@th:not(.static-cell)*/th.sc-calcite-table-header:not(.static-cell){outline-color:transparent}/*!@th:not(.static-cell):not(.static-cell):focus-within*/th.sc-calcite-table-header:not(.static-cell):not(.static-cell):focus-within{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@th.last-cell*/th.last-cell.sc-calcite-table-header{border-inline-end:0}/*!@th.body-row,\nth.footer-row*/th.body-row.sc-calcite-table-header,th.footer-row.sc-calcite-table-header{vertical-align:middle;border-block-end:0}/*!@th.footer-row*/th.footer-row.sc-calcite-table-header{border-block-start:1px solid var(--calcite-internal-table-header-border-color)}/*!@.cell--multiple-selection*/.cell--multiple-selection.sc-calcite-table-header{cursor:pointer;vertical-align:middle;color:var(--calcite-color-text-3)}/*!@.selected-cell:not(.number-cell):not(.footer-cell)*/.selected-cell.sc-calcite-table-header:not(.number-cell):not(.footer-cell){--calcite-internal-table-header-background:var(--calcite-color-foreground-current)}/*!@.number-cell,\n.selection-cell*/.number-cell.sc-calcite-table-header,.selection-cell.sc-calcite-table-header{color:var(--calcite-color-text-2);inline-size:2rem;min-inline-size:2rem}/*!@.selection-cell calcite-icon.active*/.selection-cell.sc-calcite-table-header calcite-icon.active.sc-calcite-table-header{color:var(--calcite-color-brand)}/*!@.number-cell calcite-icon,\n.selection-cell calcite-icon*/.number-cell.sc-calcite-table-header calcite-icon.sc-calcite-table-header,.selection-cell.sc-calcite-table-header calcite-icon.sc-calcite-table-header{margin-inline-start:auto;margin-inline-end:auto;vertical-align:middle}/*!@.heading*/.heading.sc-calcite-table-header{color:var(--calcite-color-text-1)}/*!@.description*/.description.sc-calcite-table-header{color:var(--calcite-color-text-3);font-size:var(--calcite-internal-table-cell-font-size-secondary)}";

class TableHeader {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.onContainerBlur = () => {
            this.focused = false;
        };
        this.onContainerFocus = () => {
            this.focused = true;
        };
        this.alignment = "start";
        this.colSpan = undefined;
        this.description = undefined;
        this.heading = undefined;
        this.rowSpan = undefined;
        this.interactionMode = "interactive";
        this.lastCell = undefined;
        this.numberCell = false;
        this.parentRowIsSelected = undefined;
        this.parentRowType = undefined;
        this.positionInRow = undefined;
        this.scale = undefined;
        this.selectedRowCount = undefined;
        this.selectedRowCountLocalized = undefined;
        this.selectionCell = false;
        this.selectionMode = undefined;
        this.bodyRowCount = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.defaultMessages = undefined;
        this.focused = false;
        this.screenReaderText = "";
        this.effectiveLocale = "";
    }
    onSelectedChange() {
        this.updateScreenReaderText();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
        this.updateScreenReaderText();
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    connectedCallback() {
        connectLocalized(this);
        connectMessages(this);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.containerEl.focus();
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    updateScreenReaderText() {
        let text = "";
        const sharedText = `${this.selectedRowCountLocalized} ${this.messages?.selected}`;
        if (this.numberCell) {
            text = this.messages?.rowNumber;
        }
        else if (this.selectionMode === "single") {
            text = `${this.messages?.selectionColumn}. ${sharedText}`;
        }
        else if (this.bodyRowCount === this.selectedRowCount) {
            text = `${this.messages?.selectionColumn}. ${this.messages?.all} ${sharedText} ${this.messages?.keyboardDeselectAll}`;
        }
        else {
            text = `${this.messages?.selectionColumn}. ${sharedText} ${this.messages?.keyboardSelectAll}`;
        }
        this.screenReaderText = text;
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const scope = this.rowSpan
            ? "rowgroup"
            : this.colSpan
                ? "colgroup"
                : this.parentRowType === "body"
                    ? "row"
                    : "col";
        const allSelected = this.selectedRowCount === this.bodyRowCount;
        const selectionIcon = allSelected ? "check-square-f" : "check-square";
        const staticCell = this.interactionMode === "static" && !this.selectionCell;
        return (hAsync(Host, null, hAsync("th", { "aria-colindex": this.parentRowType === "head" ? this.positionInRow : undefined, class: {
                [CSS$c.bodyRow]: this.parentRowType === "body",
                [CSS$c.footerRow]: this.parentRowType === "foot",
                [CSS$c.numberCell]: this.numberCell,
                [CSS$c.selectionCell]: this.selectionCell,
                [CSS$c.selectedCell]: this.parentRowIsSelected,
                [CSS$c.multipleSelectionCell]: this.selectionMode === "multiple",
                [CSS$c.staticCell]: staticCell,
                [CSS$c.lastCell]: this.lastCell && (!this.rowSpan || (this.colSpan && !!this.rowSpan)),
            }, colSpan: this.colSpan, onBlur: this.onContainerBlur, onFocus: this.onContainerFocus, role: this.parentRowType === "head" ? "columnheader" : "rowheader", rowSpan: this.rowSpan, scope: scope, tabIndex: this.selectionCell ? 0 : staticCell ? -1 : 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.containerEl = el) }, this.heading && hAsync("div", { class: CSS$c.heading }, this.heading), this.description && hAsync("div", { class: CSS$c.description }, this.description), this.selectionCell && this.selectionMode === "multiple" && (hAsync("calcite-icon", { class: { [CSS$c.active]: allSelected }, icon: selectionIcon, scale: getIconScale(this.scale) })), hAsync("span", { "aria-hidden": true, "aria-live": this.focused ? "polite" : "off", class: CSS$c.assistiveText }, (this.selectionCell || this.numberCell) && this.screenReaderText))));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "selectedRowCount": ["onSelectedChange"],
        "selectedRowCountLocalized": ["onSelectedChange"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return tableHeaderCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-table-header",
        "$members$": {
            "alignment": [513],
            "colSpan": [514, "col-span"],
            "description": [513],
            "heading": [513],
            "rowSpan": [514, "row-span"],
            "interactionMode": [1, "interaction-mode"],
            "lastCell": [4, "last-cell"],
            "numberCell": [4, "number-cell"],
            "parentRowIsSelected": [4, "parent-row-is-selected"],
            "parentRowType": [1, "parent-row-type"],
            "positionInRow": [2, "position-in-row"],
            "scale": [1],
            "selectedRowCount": [2, "selected-row-count"],
            "selectedRowCountLocalized": [1, "selected-row-count-localized"],
            "selectionCell": [4, "selection-cell"],
            "selectionMode": [1, "selection-mode"],
            "bodyRowCount": [2, "body-row-count"],
            "messages": [1040],
            "messageOverrides": [1040],
            "defaultMessages": [32],
            "focused": [32],
            "screenReaderText": [32],
            "effectiveLocale": [32],
            "setFocus": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["alignment", "alignment"], ["colSpan", "col-span"], ["description", "description"], ["heading", "heading"], ["rowSpan", "row-span"]]
    }; }
}

const CSS$b = {
    lastVisibleRow: "last-visible-row",
};

const tableRowCss = "/*!@:host([disabled])*/[disabled].sc-calcite-table-row-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-table-row-h *.sc-calcite-table-row,.sc-calcite-table-row-h[disabled].sc-calcite-table-row-s>*,.sc-calcite-table-row-h[disabled] .sc-calcite-table-row-s>*{pointer-events:none}/*!@:host*/.sc-calcite-table-row-h{--calcite-internal-table-row-background:var(--calcite-table-row-background, var(--calcite-color-foreground-1));--calcite-internal-table-row-border-color:var(--calcite-table-row-border-color, transparent);display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-table-row-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-table-row{display:none}/*!@:host([disabled]) tr*/[disabled].sc-calcite-table-row-h tr.sc-calcite-table-row{pointer-events:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-table-row-h[disabled] .sc-calcite-table-row-s>[calcite-hydrated][disabled],[disabled].sc-calcite-table-row-h [calcite-hydrated][disabled].sc-calcite-table-row{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-table-row{display:contents}/*!@tr*/tr.sc-calcite-table-row{border-block-end:1px solid var(--calcite-internal-table-row-border-color);background-color:var(--calcite-internal-table-row-background)}/*!@tr.last-visible-row*/tr.last-visible-row.sc-calcite-table-row{border-block-end:0}";

/**
 * @slot - A slot for adding `calcite-table-cell` or `calcite-table-header` elements.
 */
class TableRow {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteTableRowSelect = createEvent(this, "calciteTableRowSelect", 6);
        this.calciteInternalTableRowFocusRequest = createEvent(this, "calciteInternalTableRowFocusRequest", 6);
        this.rowCells = [];
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.keyDownHandler = (event) => {
            if (this.interactionMode !== "interactive") {
                return;
            }
            const el = event.target;
            const key = event.key;
            const isControl = event.ctrlKey;
            const cells = this.rowCells;
            if (el.matches("calcite-table-cell") || el.matches("calcite-table-header")) {
                switch (key) {
                    case "ArrowUp":
                        this.emitTableRowFocusRequest(el.positionInRow, this.positionAll, "previous");
                        event.preventDefault();
                        break;
                    case "ArrowDown":
                        this.emitTableRowFocusRequest(el.positionInRow, this.positionAll, "next");
                        event.preventDefault();
                        break;
                    case "PageUp":
                        this.emitTableRowFocusRequest(el.positionInRow, this.positionAll, "first");
                        event.preventDefault();
                        break;
                    case "PageDown":
                        this.emitTableRowFocusRequest(el.positionInRow, this.positionAll, "last");
                        event.preventDefault();
                        break;
                    case "ArrowLeft":
                        focusElementInGroup(cells, el, "previous", false);
                        event.preventDefault();
                        break;
                    case "ArrowRight":
                        focusElementInGroup(cells, el, "next", false);
                        event.preventDefault();
                        break;
                    case "Home":
                        if (isControl) {
                            this.emitTableRowFocusRequest(1, this.positionAll, "first");
                            event.preventDefault();
                        }
                        else {
                            focusElementInGroup(cells, el, "first", false);
                            event.preventDefault();
                        }
                        break;
                    case "End":
                        if (isControl) {
                            this.emitTableRowFocusRequest(this.rowCells?.length, this.positionAll, "last", true);
                            event.preventDefault();
                        }
                        else {
                            focusElementInGroup(cells, el, "last", false);
                            event.preventDefault();
                        }
                        break;
                }
            }
        };
        this.emitTableRowFocusRequest = (cellPosition, rowPosition, destination, lastCell) => {
            this.calciteInternalTableRowFocusRequest.emit({
                cellPosition,
                rowPosition,
                destination,
                lastCell,
            });
        };
        this.updateCells = () => {
            const slottedCells = this.tableRowSlotEl
                ?.assignedElements({ flatten: true })
                ?.filter((el) => el.matches("calcite-table-cell") || el.matches("calcite-table-header"));
            const renderedCells = Array.from(this.tableRowEl?.querySelectorAll("calcite-table-header, calcite-table-cell"))?.filter((el) => el.numberCell || el.selectionCell);
            const cells = renderedCells ? renderedCells.concat(slottedCells) : slottedCells;
            if (cells.length > 0) {
                cells?.forEach((cell, index) => {
                    cell.interactionMode = this.interactionMode;
                    cell.positionInRow = index + 1;
                    cell.parentRowType = this.rowType;
                    cell.parentRowIsSelected = this.selected;
                    cell.scale = this.scale;
                    cell.lastCell = index === cells.length - 1;
                    if (cell.nodeName === "CALCITE-TABLE-CELL") {
                        cell.readCellContentsToAT = this.readCellContentsToAT;
                        cell.disabled = this.disabled;
                    }
                });
            }
            this.rowCells =
                cells || [];
            this.cellCount = cells?.length;
        };
        this.handleSelectionOfRow = () => {
            this.calciteTableRowSelect.emit();
        };
        this.handleKeyboardSelection = (event) => {
            if (isActivationKey(event.key)) {
                if (event.key === " ") {
                    event.preventDefault();
                }
                this.handleSelectionOfRow();
            }
        };
        this.disabled = false;
        this.selected = false;
        this.cellCount = undefined;
        this.interactionMode = "interactive";
        this.lastVisibleRow = undefined;
        this.rowType = undefined;
        this.numbered = false;
        this.positionSection = undefined;
        this.positionSectionLocalized = undefined;
        this.positionAll = undefined;
        this.readCellContentsToAT = undefined;
        this.scale = undefined;
        this.selectionMode = "none";
        this.selectedRowCount = undefined;
        this.selectedRowCountLocalized = undefined;
        this.bodyRowCount = undefined;
        this.effectiveLocale = "";
    }
    handleCellChanges() {
        if (this.tableRowEl && this.rowCells.length > 0) {
            this.updateCells();
        }
    }
    handleDelayedCellChanges() {
        if (this.tableRowEl && this.rowCells.length > 0) {
            requestAnimationFrame(() => this.updateCells());
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentDidLoad() {
        if (this.tableRowEl && this.rowCells.length > 0) {
            this.updateCells();
        }
    }
    connectedCallback() {
        connectInteractive(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    calciteInternalTableRowFocusChangeHandler(event) {
        if (event.target.contains(this.el)) {
            const position = event.detail.cellPosition;
            const rowPosition = event.detail.rowPosition;
            const destination = event.detail.destination;
            const lastCell = event.detail.lastCell;
            if (rowPosition === this.positionAll) {
                if (this.disabled) {
                    const deflectDirection = destination === "last" ? "previous" : destination === "first" ? "next" : destination;
                    this.emitTableRowFocusRequest(position, this.positionAll, deflectDirection);
                    return;
                }
                const cellPosition = lastCell
                    ? this.rowCells[this.rowCells.length - 1]
                    : this.rowCells?.find((_, index) => index + 1 === position);
                if (cellPosition) {
                    cellPosition.setFocus();
                }
            }
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    renderSelectionIcon() {
        const icon = this.selectionMode === "multiple" && this.selected
            ? "check-square-f"
            : this.selectionMode === "multiple"
                ? "square"
                : this.selected
                    ? "circle-f"
                    : "circle";
        return hAsync("calcite-icon", { icon: icon, scale: getIconScale(this.scale) });
    }
    renderSelectableCell() {
        return this.rowType === "head" ? (hAsync("calcite-table-header", { alignment: "center", bodyRowCount: this.bodyRowCount, key: "selection-head", onClick: this.selectionMode === "multiple" && this.handleSelectionOfRow, onKeyDown: this.selectionMode === "multiple" && this.handleKeyboardSelection, selectedRowCount: this.selectedRowCount, selectedRowCountLocalized: this.selectedRowCountLocalized, selectionCell: true, selectionMode: this.selectionMode })) : this.rowType === "body" ? (hAsync("calcite-table-cell", { alignment: "center", key: "selection-body", onClick: this.handleSelectionOfRow, onKeyDown: this.handleKeyboardSelection, parentRowIsSelected: this.selected, parentRowPositionLocalized: this.positionSectionLocalized, selectionCell: true }, this.renderSelectionIcon())) : (hAsync("calcite-table-cell", { alignment: "center", key: "selection-foot", selectionCell: true }));
    }
    renderNumberedCell() {
        return this.rowType === "head" ? (hAsync("calcite-table-header", { alignment: "center", key: "numbered-head", numberCell: true })) : this.rowType === "body" ? (hAsync("calcite-table-cell", { alignment: "center", key: "numbered-body", numberCell: true }, this.positionSectionLocalized)) : (hAsync("calcite-table-cell", { alignment: "center", key: "numbered-foot", numberCell: true }));
    }
    render() {
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("tr", { "aria-disabled": this.disabled, "aria-rowindex": this.positionAll + 1, "aria-selected": this.selected, class: { [CSS$b.lastVisibleRow]: this.lastVisibleRow }, onKeyDown: this.keyDownHandler,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.tableRowEl = el) }, this.numbered && this.renderNumberedCell(), this.selectionMode !== "none" && this.renderSelectableCell(), hAsync("slot", { onSlotchange: this.updateCells, ref: (el) => (this.tableRowSlotEl = el) })))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "bodyRowCount": ["handleCellChanges"],
        "scale": ["handleCellChanges"],
        "selected": ["handleCellChanges"],
        "selectedRowCount": ["handleCellChanges"],
        "interactionMode": ["handleCellChanges"],
        "numbered": ["handleDelayedCellChanges"],
        "selectionMode": ["handleDelayedCellChanges"]
    }; }
    static get style() { return tableRowCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-table-row",
        "$members$": {
            "disabled": [516],
            "selected": [516],
            "cellCount": [1026, "cell-count"],
            "interactionMode": [1, "interaction-mode"],
            "lastVisibleRow": [4, "last-visible-row"],
            "rowType": [1, "row-type"],
            "numbered": [4],
            "positionSection": [2, "position-section"],
            "positionSectionLocalized": [1, "position-section-localized"],
            "positionAll": [2, "position-all"],
            "readCellContentsToAT": [4, "read-cell-contents-to-a-t"],
            "scale": [1],
            "selectionMode": [1, "selection-mode"],
            "selectedRowCount": [2, "selected-row-count"],
            "selectedRowCountLocalized": [1, "selected-row-count-localized"],
            "bodyRowCount": [2, "body-row-count"],
            "effectiveLocale": [32]
        },
        "$listeners$": [[4, "calciteInternalTableRowFocusChange", "calciteInternalTableRowFocusChangeHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["selected", "selected"]]
    }; }
}

const SLOTS$5 = {
    titleGroup: "title-group",
};

const tabsCss = "/*!@:host*/.sc-calcite-tabs-h{display:flex;flex-direction:column}/*!@:host([bordered])*/[bordered].sc-calcite-tabs-h{box-shadow:inset 0 1px 0 var(--calcite-color-border-1);background-color:var(--calcite-color-foreground-1)}/*!@:host([bordered]:not([position=bottom])) ::slotted(calcite-tab-nav)*/.sc-calcite-tabs-h[bordered]:not([position=bottom]) .sc-calcite-tabs-s>calcite-tab-nav{margin-block-end:-1px}/*!@:host([bordered][position=bottom])*/[bordered][position=bottom].sc-calcite-tabs-h{box-shadow:inset 0 1px 0 var(--calcite-color-border-1), inset 0 -1px 0 var(--calcite-color-border-1)}/*!@:host([bordered]) section*/[bordered].sc-calcite-tabs-h section.sc-calcite-tabs{border-width:1px;border-style:solid;border-color:var(--calcite-color-border-1)}/*!@:host([bordered][scale=s]) section*/[bordered][scale=s].sc-calcite-tabs-h section.sc-calcite-tabs{padding:0.75rem}/*!@:host([bordered][scale=m]) section*/[bordered][scale=m].sc-calcite-tabs-h section.sc-calcite-tabs{padding:0.5rem}/*!@:host([bordered][scale=l]) section*/[bordered][scale=l].sc-calcite-tabs-h section.sc-calcite-tabs{padding:1rem}/*!@:host([position=bottom])*/[position=bottom].sc-calcite-tabs-h{flex-direction:column-reverse}/*!@section*/section.sc-calcite-tabs{display:flex;flex-grow:1;overflow:hidden;border-block-start-width:1px;border-block-start-color:var(--calcite-color-border-1);border-block-start-style:solid}/*!@:host([position=bottom]) section*/[position=bottom].sc-calcite-tabs-h section.sc-calcite-tabs{flex-direction:column-reverse;border-block-start-width:0px;border-block-end-width:1px;border-block-end-color:var(--calcite-color-border-1)}/*!@:host([position=bottom]:not([bordered])) section*/[position=bottom].sc-calcite-tabs-h:not([bordered]) section.sc-calcite-tabs{border-block-end-style:solid}@media (forced-colors: active){/*!@:host([bordered]) section*/[bordered].sc-calcite-tabs-h section.sc-calcite-tabs{border-block-start-width:0px;border-block-end-width:1px}/*!@:host([position=bottom][bordered]) section*/[position=bottom][bordered].sc-calcite-tabs-h section.sc-calcite-tabs{border-block-start-width:1px;border-block-end-width:0px}}/*!@:host([hidden])*/[hidden].sc-calcite-tabs-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tabs{display:none}";

/**
 * @slot - A slot for adding `calcite-tab`s.
 * @slot title-group - A slot for adding a `calcite-tab-nav`.
 */
class Tabs {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.mutationObserver = createObserver();
        this.layout = "inline";
        this.position = "top";
        this.scale = "m";
        this.bordered = false;
        this.titles = [];
        this.tabs = [];
    }
    handleInheritableProps() {
        this.updateItems();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.mutationObserver.observe(this.el, { childList: true });
        this.updateItems();
    }
    async componentWillLoad() {
        this.updateItems();
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
    }
    render() {
        return (hAsync(Fragment, null, hAsync("slot", { name: SLOTS$5.titleGroup }), hAsync("section", null, hAsync("slot", null))));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    /**
     * @param event
     * @internal
     */
    calciteInternalTabTitleRegister(event) {
        this.titles = [...this.titles, event.target];
        this.registryHandler();
        event.stopPropagation();
    }
    /**
     * @param event
     * @internal
     */
    calciteTabTitleUnregister(event) {
        this.titles = this.titles.filter((el) => el !== event.detail);
        this.registryHandler();
        event.stopPropagation();
    }
    /**
     * @param event
     * @internal
     */
    calciteInternalTabRegister(event) {
        this.tabs = [...this.tabs, event.target];
        this.registryHandler();
        event.stopPropagation();
    }
    /**
     * @param event
     * @internal
     */
    calciteTabUnregister(event) {
        this.tabs = this.tabs.filter((el) => el !== event.detail);
        this.registryHandler();
        event.stopPropagation();
    }
    updateItems() {
        const { position, scale } = this;
        const nav = this.el.querySelector("calcite-tab-nav");
        if (nav) {
            nav.position = position;
            nav.scale = scale;
        }
        Array.from(this.el.querySelectorAll("calcite-tab")).forEach((tab) => {
            if (tab.parentElement === this.el) {
                tab.scale = scale;
            }
        });
        Array.from(this.el.querySelectorAll("calcite-tab-nav > calcite-tab-title")).forEach((title) => {
            title.position = position;
            title.scale = scale;
        });
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    /**
     *
     * Matches up elements from the internal `tabs` and `titles` to automatically
     * update the ARIA attributes and link `<calcite-tab>` and
     * `<calcite-tab-title>` components.
     */
    async registryHandler() {
        let tabIds;
        let titleIds;
        // determine if we are using `tab` based or `index` based tab identifiers.
        if (this.tabs.some((el) => el.tab) || this.titles.some((el) => el.tab)) {
            // if we are using `tab` based identifiers sort by `tab` to account for
            // possible out of order tabs and get the id of each tab
            tabIds = this.tabs.sort((a, b) => a.tab.localeCompare(b.tab)).map((el) => el.id);
            titleIds = this.titles.sort((a, b) => a.tab.localeCompare(b.tab)).map((el) => el.id);
        }
        else {
            // if we are using index based tabs then the `<calcite-tab>` and
            // `<calcite-tab-title>` might have been rendered out of order so the
            // order of `this.tabs` and `this.titles` might not reflect the DOM state,
            // and might not match each other so we need to get the index of all the
            // tabs and titles in the DOM order to match them up as a source of truth
            const tabDomIndexes = await Promise.all(this.tabs.map((el) => el.getTabIndex()));
            const titleDomIndexes = await Promise.all(this.titles.map((el) => el.getTabIndex()));
            // once we have the DOM order as a source of truth we can build the
            // matching tabIds and titleIds arrays
            tabIds = tabDomIndexes.reduce((ids, indexInDOM, registryIndex) => {
                ids[indexInDOM] = this.tabs[registryIndex].id;
                return ids;
            }, []);
            titleIds = titleDomIndexes.reduce((ids, indexInDOM, registryIndex) => {
                ids[indexInDOM] = this.titles[registryIndex].id;
                return ids;
            }, []);
        }
        // pass all our new aria information to each `<calcite-tab>` and
        // `<calcite-tab-title>` which will check if they can update their internal
        // `controlled` or `labeledBy` states and re-render if necessary
        this.tabs.forEach((el) => el.updateAriaInfo(tabIds, titleIds));
        this.titles.forEach((el) => el.updateAriaInfo(tabIds, titleIds));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "position": ["handleInheritableProps"],
        "scale": ["handleInheritableProps"]
    }; }
    static get style() { return tabsCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tabs",
        "$members$": {
            "layout": [513],
            "position": [513],
            "scale": [513],
            "bordered": [4],
            "titles": [32],
            "tabs": [32]
        },
        "$listeners$": [[0, "calciteInternalTabTitleRegister", "calciteInternalTabTitleRegister"], [16, "calciteTabTitleUnregister", "calciteTabTitleUnregister"], [0, "calciteInternalTabRegister", "calciteInternalTabRegister"], [16, "calciteTabUnregister", "calciteTabUnregister"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["layout", "layout"], ["position", "position"], ["scale", "scale"]]
    }; }
}

const CSS$a = {
    assistiveText: "assistive-text",
    characterLimit: "character-limit",
    content: "content",
    container: "container",
    footer: "footer",
    resizeDisabled: "resize--disabled",
    resizeDisabledX: "resize--disabled-x",
    resizeDisabledY: "resize--disabled-y",
    characterOverLimit: "character--over-limit",
    readOnly: "readonly",
    textAreaInvalid: "text-area--invalid",
    footerSlotted: "footer--slotted",
    borderColor: "border--color",
    hide: "hide",
    blockSizeFull: "block-size--full",
    footerEndSlotOnly: "footer--end-only",
};
const SLOTS$4 = {
    footerStart: "footer-start",
    footerEnd: "footer-end",
};
const RESIZE_TIMEOUT = 100;

const textAreaCss = "/*!@:host([disabled])*/[disabled].sc-calcite-text-area-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-text-area-h *.sc-calcite-text-area,.sc-calcite-text-area-h[disabled].sc-calcite-text-area-s>*,.sc-calcite-text-area-h[disabled] .sc-calcite-text-area-s>*{pointer-events:none}/*!@:host*/.sc-calcite-text-area-h{position:relative;display:inline-block;block-size:100%;inline-size:100%}/*!@textarea*/textarea.sc-calcite-text-area{position:relative;margin:0px;box-sizing:border-box;display:block;inline-size:100%;border-width:1px;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-foreground-1);font-family:var(--calcite-sans-family);color:var(--calcite-color-text-1);min-inline-size:12rem;border-block-end:1px solid var(--calcite-color-border-3)}@media screen and (max-width: 480px){/*!@textarea*/textarea.sc-calcite-text-area{resize:none}}/*!@textarea:focus*/textarea.sc-calcite-text-area:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@textarea.text-area--invalid*/textarea.text-area--invalid.sc-calcite-text-area{border-width:1px;border-block-end-width:1px;border-style:solid;border-color:var(--calcite-color-status-danger)}/*!@textarea.text-area--invalid:focus*/textarea.text-area--invalid.sc-calcite-text-area:focus{outline:2px solid var(--calcite-color-status-danger);outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@textarea.footer--slotted*/textarea.footer--slotted.sc-calcite-text-area{min-inline-size:18rem}/*!@.footer*/.footer.sc-calcite-text-area{box-sizing:border-box;display:flex;align-items:center;border-width:1px;border-block-start-width:0px;border-style:solid;border-color:var(--calcite-color-border-input);background-color:var(--calcite-color-foreground-1)}/*!@.character-limit*/.character-limit.sc-calcite-text-area{display:flex;align-items:center;justify-content:flex-end;white-space:nowrap;font-weight:var(--calcite-font-weight-normal);color:var(--calcite-color-text-2)}/*!@.character--over-limit*/.character--over-limit.sc-calcite-text-area{font-weight:var(--calcite-font-weight-bold);color:var(--calcite-color-status-danger)}/*!@:host([resize=none]) textarea*/[resize=none].sc-calcite-text-area-h textarea.sc-calcite-text-area{resize:none}/*!@:host([resize=horizontal]) textarea*/[resize=horizontal].sc-calcite-text-area-h textarea.sc-calcite-text-area{resize:horizontal}/*!@:host([resize=vertical]) textarea*/[resize=vertical].sc-calcite-text-area-h textarea.sc-calcite-text-area{resize:vertical}/*!@:host([scale=s])*/[scale=s].sc-calcite-text-area-h{font-size:var(--calcite-font-size--2)}/*!@:host([scale=s]) .footer*/[scale=s].sc-calcite-text-area-h .footer.sc-calcite-text-area{padding-block:0.25rem;padding-inline:0.5rem;min-block-size:1.75rem}/*!@:host([scale=s]) textarea*/[scale=s].sc-calcite-text-area-h textarea.sc-calcite-text-area{padding-block:0.25rem;padding-inline:0.5rem}/*!@:host([scale=s]) textarea,\n:host([scale=s]) .footer,\n:host([scale=s]) .character-limit*/[scale=s].sc-calcite-text-area-h textarea.sc-calcite-text-area,[scale=s].sc-calcite-text-area-h .footer.sc-calcite-text-area,[scale=s].sc-calcite-text-area-h .character-limit.sc-calcite-text-area{padding-inline-start:0.5rem;font-size:var(--calcite-font-size--2)}/*!@:host([scale=m]) textarea*/[scale=m].sc-calcite-text-area-h textarea.sc-calcite-text-area{padding-block:0.5rem;padding-inline:0.75rem}/*!@:host([scale=m]) .footer*/[scale=m].sc-calcite-text-area-h .footer.sc-calcite-text-area{padding-block:0.5rem;padding-inline:0.75rem;min-block-size:2.25rem}/*!@:host([scale=m]) textarea,\n:host([scale=m]) .footer,\n:host([scale=m]) .character-limit*/[scale=m].sc-calcite-text-area-h textarea.sc-calcite-text-area,[scale=m].sc-calcite-text-area-h .footer.sc-calcite-text-area,[scale=m].sc-calcite-text-area-h .character-limit.sc-calcite-text-area{padding-inline-start:0.75rem;font-size:var(--calcite-font-size--1)}/*!@:host([scale=l])*/[scale=l].sc-calcite-text-area-h{font-size:var(--calcite-font-size-0)}/*!@:host([scale=l]) textarea*/[scale=l].sc-calcite-text-area-h textarea.sc-calcite-text-area{padding-block:0.75rem;padding-inline:1rem}/*!@:host([scale=l]) .footer*/[scale=l].sc-calcite-text-area-h .footer.sc-calcite-text-area{padding-block:0.75rem;padding-inline:1rem;min-block-size:2.75rem}/*!@:host([scale=l]) textarea,\n:host([scale=l]) .footer,\n:host([scale=l]) .character-limit*/[scale=l].sc-calcite-text-area-h textarea.sc-calcite-text-area,[scale=l].sc-calcite-text-area-h .footer.sc-calcite-text-area,[scale=l].sc-calcite-text-area-h .character-limit.sc-calcite-text-area{padding-inline-start:1rem;font-size:var(--calcite-font-size-0)}/*!@:host([status=invalid]) textarea*/[status=invalid].sc-calcite-text-area-h textarea.sc-calcite-text-area{border-color:var(--calcite-color-status-danger)}/*!@:host([status=invalid]) textarea:focus*/[status=invalid].sc-calcite-text-area-h textarea.sc-calcite-text-area:focus{outline:2px solid var(--calcite-color-status-danger);outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.readonly*/.readonly.sc-calcite-text-area{background-color:var(--calcite-color-background);font-weight:var(--calcite-font-weight-medium)}/*!@:host([disabled]) textarea,\n:host([disabled]) footer*/[disabled].sc-calcite-text-area-h textarea.sc-calcite-text-area,[disabled].sc-calcite-text-area-h footer.sc-calcite-text-area{opacity:0.5}/*!@.border--color*/.border--color.sc-calcite-text-area{border-block-end-width:1px;border-color:var(--calcite-color-border-input)}/*!@.border--color:focus*/.border--color.sc-calcite-text-area:focus{border-block-end-width:2px}/*!@textarea.block-size--full*/textarea.block-size--full.sc-calcite-text-area{block-size:100%}/*!@.content,\n.hide*/.content.sc-calcite-text-area,.hide.sc-calcite-text-area{display:none}/*!@.container*/.container.sc-calcite-text-area{display:flex;inline-size:100%;justify-content:space-between}/*!@.footer--end-only*/.footer--end-only.sc-calcite-text-area{justify-content:flex-end}/*!@.assistive-text*/.assistive-text.sc-calcite-text-area{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}/*!@.validation-container*/.validation-container.sc-calcite-text-area{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}/*!@:host([scale=m]) .validation-container,\n:host([scale=l]) .validation-container*/[scale=m].sc-calcite-text-area-h .validation-container.sc-calcite-text-area,[scale=l].sc-calcite-text-area-h .validation-container.sc-calcite-text-area{padding-block-start:0.5rem}/*!@:host([scale=s]) .validation-container*/[scale=s].sc-calcite-text-area-h .validation-container.sc-calcite-text-area{padding-block-start:0.25rem}/*!@::slotted(input[slot=hidden-form-input])*/.sc-calcite-text-area-s>input[slot=hidden-form-input]{margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-text-area-h[disabled] .sc-calcite-text-area-s>[calcite-hydrated][disabled],[disabled].sc-calcite-text-area-h [calcite-hydrated][disabled].sc-calcite-text-area{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-text-area{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-text-area-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-text-area{display:none}";

/**
 * @slot - A slot for adding text.
 * @slot footer-start - A slot for adding content to the start of the component's footer.
 * @slot footer-end - A slot for adding content to the end of the component's footer.
 */
class TextArea {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteTextAreaInput = createEvent(this, "calciteTextAreaInput", 7);
        this.calciteTextAreaChange = createEvent(this, "calciteTextAreaChange", 7);
        this.guid = guid();
        this.handleInput = (event) => {
            this.value = event.target["value"];
            this.calciteTextAreaInput.emit();
        };
        this.handleChange = () => {
            this.calciteTextAreaChange.emit();
        };
        this.contentSlotChangeHandler = () => {
            if (!this.value) {
                const nodes = this.el.childNodes;
                nodes.forEach((el) => {
                    if (el.nodeName === "#text") {
                        this.value = el.nodeValue.trim();
                    }
                });
            }
        };
        this.renderCharacterLimit = () => {
            if (this.maxLength) {
                this.localizedCharacterLengthObj = this.getLocalizedCharacterLength();
                return (hAsync("span", { class: CSS$a.characterLimit }, hAsync("span", { class: { [CSS$a.characterOverLimit]: this.isCharacterLimitExceeded() } }, this.localizedCharacterLengthObj.currentLength), "/", this.localizedCharacterLengthObj.maxLength));
            }
            return null;
        };
        this.resizeObserver = createObserver();
        this.setTextAreaEl = (el) => {
            this.textAreaEl = el;
            this.resizeObserver.observe(el);
        };
        // height and width are set to auto here to avoid overlapping on to neighboring elements in the layout when user starts resizing.
        // throttle is used to avoid flashing of textarea when user resizes.
        this.setHeightAndWidthToAuto = throttle$1(() => {
            if (this.resize === "vertical" || this.resize === "both") {
                this.el.style.height = "auto";
            }
            if (this.resize === "horizontal" || this.resize === "both") {
                this.el.style.width = "auto";
            }
        }, RESIZE_TIMEOUT, { leading: false });
        this.autofocus = false;
        this.columns = undefined;
        this.disabled = false;
        this.form = undefined;
        this.groupSeparator = false;
        this.label = undefined;
        this.minLength = undefined;
        this.maxLength = undefined;
        this.messages = undefined;
        this.validationMessage = undefined;
        this.validationIcon = undefined;
        this.name = undefined;
        this.numberingSystem = undefined;
        this.placeholder = undefined;
        this.readOnly = false;
        this.required = false;
        this.resize = "both";
        this.rows = undefined;
        this.scale = "m";
        this.status = "idle";
        this.value = "";
        this.wrap = "soft";
        this.messageOverrides = undefined;
        this.defaultMessages = undefined;
        this.endSlotHasElements = undefined;
        this.startSlotHasElements = undefined;
        this.effectiveLocale = "";
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        connectLabel(this);
        connectForm(this);
        connectLocalized(this);
        connectMessages(this);
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
        this.setTextAreaHeight();
    }
    disconnectedCallback() {
        disconnectInteractive(this);
        disconnectLabel(this);
        disconnectForm(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        this.resizeObserver?.disconnect();
    }
    render() {
        const hasFooter = this.startSlotHasElements || this.endSlotHasElements || !!this.maxLength;
        return (hAsync(Host, null, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("textarea", { "aria-describedby": this.guid, "aria-invalid": toAriaBoolean(this.isCharacterLimitExceeded()), "aria-label": getLabelText(this), autofocus: this.autofocus, class: {
                [CSS$a.readOnly]: this.readOnly,
                [CSS$a.textAreaInvalid]: this.isCharacterLimitExceeded(),
                [CSS$a.footerSlotted]: this.endSlotHasElements && this.startSlotHasElements,
                [CSS$a.blockSizeFull]: !hasFooter,
                [CSS$a.borderColor]: !hasFooter,
            }, cols: this.columns, disabled: this.disabled, name: this.name, onChange: this.handleChange, onInput: this.handleInput, placeholder: this.placeholder, readonly: this.readOnly, required: this.required, rows: this.rows, value: this.value, wrap: this.wrap,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setTextAreaEl }), hAsync("span", { class: { [CSS$a.content]: true } }, hAsync("slot", { onSlotchange: this.contentSlotChangeHandler })), hAsync("footer", { class: {
                [CSS$a.footer]: true,
                [CSS$a.readOnly]: this.readOnly,
                [CSS$a.hide]: !hasFooter,
            }, ref: (el) => (this.footerEl = el) }, hAsync("div", { class: {
                [CSS$a.container]: true,
                [CSS$a.footerEndSlotOnly]: !this.startSlotHasElements && this.endSlotHasElements,
            } }, hAsync("slot", { name: SLOTS$4.footerStart, onSlotchange: (event) => (this.startSlotHasElements = slotChangeHasAssignedElement(event)) }), hAsync("slot", { name: SLOTS$4.footerEnd, onSlotchange: (event) => (this.endSlotHasElements = slotChangeHasAssignedElement(event)) })), this.renderCharacterLimit()), hAsync(HiddenFormInputSlot, { component: this }), this.isCharacterLimitExceeded() && (hAsync("span", { "aria-hidden": true, "aria-live": "polite", class: CSS$a.assistiveText, id: this.guid }, this.replacePlaceHoldersInMessages())), this.validationMessage && this.status === "invalid" ? (hAsync(Validation, { icon: this.validationIcon, message: this.validationMessage, scale: this.scale, status: this.status })) : null)));
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        this.textAreaEl.focus();
    }
    /** Selects the text of the component's `value`. */
    async selectText() {
        await componentLoaded(this);
        this.textAreaEl.select();
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    onLabelClick() {
        this.setFocus();
    }
    getLocalizedCharacterLength() {
        const currentLength = this.value ? this.value.length.toString() : "0";
        const maxLength = this.maxLength.toString();
        if (this.numberingSystem === "latn") {
            return { currentLength, maxLength };
        }
        numberStringFormatter.numberFormatOptions = {
            locale: this.effectiveLocale,
            numberingSystem: this.numberingSystem,
            signDisplay: "never",
            useGrouping: this.groupSeparator,
        };
        return {
            currentLength: numberStringFormatter.localize(currentLength),
            maxLength: numberStringFormatter.localize(maxLength),
        };
    }
    syncHiddenFormInput(input) {
        input.setCustomValidity("");
        if (this.isCharacterLimitExceeded()) {
            input.setCustomValidity(this.replacePlaceHoldersInMessages());
        }
        syncHiddenFormInput("textarea", this, input);
    }
    setTextAreaHeight() {
        const { textAreaHeight, elHeight, footerHeight } = this.getHeightAndWidthOfElements();
        if (footerHeight > 0 && textAreaHeight + footerHeight != elHeight) {
            this.textAreaEl.style.height = `${elHeight - footerHeight}px`;
        }
    }
    getHeightAndWidthOfElements() {
        const { height: textAreaHeight, width: textAreaWidth } = this.textAreaEl.getBoundingClientRect();
        const { height: elHeight, width: elWidth } = this.el.getBoundingClientRect();
        const { height: footerHeight, width: footerWidth } = this.footerEl?.getBoundingClientRect();
        return {
            textAreaHeight,
            textAreaWidth,
            elHeight,
            elWidth,
            footerHeight,
            footerWidth,
        };
    }
    replacePlaceHoldersInMessages() {
        return this.messages.tooLong
            .replace("{maxLength}", this.localizedCharacterLengthObj.maxLength)
            .replace("{currentLength}", this.localizedCharacterLengthObj.currentLength);
    }
    isCharacterLimitExceeded() {
        return this.value?.length > this.maxLength;
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return textAreaCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-text-area",
        "$members$": {
            "autofocus": [516],
            "columns": [514],
            "disabled": [516],
            "form": [513],
            "groupSeparator": [516, "group-separator"],
            "label": [1],
            "minLength": [514, "min-length"],
            "maxLength": [514, "max-length"],
            "messages": [1040],
            "validationMessage": [1, "validation-message"],
            "validationIcon": [520, "validation-icon"],
            "name": [513],
            "numberingSystem": [1, "numbering-system"],
            "placeholder": [1],
            "readOnly": [516, "read-only"],
            "required": [516],
            "resize": [513],
            "rows": [514],
            "scale": [513],
            "status": [513],
            "value": [1025],
            "wrap": [513],
            "messageOverrides": [1040],
            "defaultMessages": [32],
            "endSlotHasElements": [32],
            "startSlotHasElements": [32],
            "effectiveLocale": [32],
            "setFocus": [64],
            "selectText": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["autofocus", "autofocus"], ["columns", "columns"], ["disabled", "disabled"], ["form", "form"], ["groupSeparator", "group-separator"], ["minLength", "min-length"], ["maxLength", "max-length"], ["validationIcon", "validation-icon"], ["name", "name"], ["readOnly", "read-only"], ["required", "required"], ["resize", "resize"], ["rows", "rows"], ["scale", "scale"], ["status", "status"], ["wrap", "wrap"]]
    }; }
}

const CSS$9 = {
    container: "container",
    content: "content",
    contentContainer: "content-container",
    contentSlotContainer: "content-slot-container",
    description: "description",
    heading: "heading",
    largeVisual: "large-visual",
};
const SLOTS$3 = {
    contentStart: "content-start",
    contentEnd: "content-end",
};

const tileCss = "/*!@:host([disabled])*/[disabled].sc-calcite-tile-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-tile-h *.sc-calcite-tile,.sc-calcite-tile-h[disabled].sc-calcite-tile-s>*,.sc-calcite-tile-h[disabled] .sc-calcite-tile-s>*{pointer-events:none}/*!@:host*/.sc-calcite-tile-h{--calcite-tile-background-color:var(--calcite-color-foreground-1);--calcite-tile-border-color:var(--calcite-color-border-2);--calcite-tile-description-text-color:var(--calcite-color-text-3);--calcite-tile-heading-text-color:var(--calcite-color-text-2);box-sizing:border-box;display:inline-block;max-inline-size:460px;min-inline-size:140px}/*!@:host .container*/.sc-calcite-tile-h .container.sc-calcite-tile{background-color:var(--calcite-tile-background-color);block-size:var(--calcite-container-size-content-fluid);box-sizing:border-box;display:flex;flex-direction:column;gap:var(--calcite-spacing-md);inline-size:var(--calcite-container-size-content-fluid);pointer-events:none;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-user-select:none;user-select:none}/*!@:host .content-container*/.sc-calcite-tile-h .content-container.sc-calcite-tile{display:flex;outline-color:transparent;padding:0;inline-size:100%}/*!@:host .content-slot-container*/.sc-calcite-tile-h .content-slot-container.sc-calcite-tile{align-items:center;display:flex}/*!@:host .content-slot-container:first-child*/.sc-calcite-tile-h .content-slot-container.sc-calcite-tile:first-child{padding-inline:0 0.75rem}/*!@:host .content-slot-container:last-child*/.sc-calcite-tile-h .content-slot-container.sc-calcite-tile:last-child{padding-inline:0.75rem 0}/*!@:host .heading*/.sc-calcite-tile-h .heading.sc-calcite-tile{color:var(--calcite-tile-heading-text-color);font-size:var(--calcite-font-size--1);font-weight:var(--calcite-font-weight-medium);line-height:1.20313rem;overflow-wrap:break-word}/*!@:host .large-visual*/.sc-calcite-tile-h .large-visual.sc-calcite-tile{align-items:center;justify-content:center;min-block-size:12rem;text-align:center}/*!@:host .large-visual calcite-icon*/.sc-calcite-tile-h .large-visual.sc-calcite-tile calcite-icon.sc-calcite-tile{block-size:64px;inline-size:64px}/*!@:host .large-visual .content-container*/.sc-calcite-tile-h .large-visual.sc-calcite-tile .content-container.sc-calcite-tile{justify-content:center}/*!@:host .description*/.sc-calcite-tile-h .description.sc-calcite-tile{color:var(--calcite-tile-description-text-color);font-size:var(--calcite-font-size--2);font-weight:var(--calcite-font-weight-regular);line-height:1.03125rem;overflow-wrap:break-word}/*!@:host([alignment=center]) .container*/[alignment=center].sc-calcite-tile-h .container.sc-calcite-tile{align-items:center;text-align:center}/*!@:host([scale=s])*/[scale=s].sc-calcite-tile-h{max-inline-size:400px;min-inline-size:100px}/*!@:host([scale=s]) .container*/[scale=s].sc-calcite-tile-h .container.sc-calcite-tile{gap:var(--calcite-spacing-sm)}/*!@:host([scale=s]) .heading*/[scale=s].sc-calcite-tile-h .heading.sc-calcite-tile{font-size:var(--calcite-font-size--2);line-height:1.03125rem}/*!@:host([scale=s]) .description*/[scale=s].sc-calcite-tile-h .description.sc-calcite-tile{font-size:var(--calcite-font-size--3);line-height:0.85938rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-tile-h{max-inline-size:520px;min-inline-size:160px}/*!@:host([scale=l]) .container*/[scale=l].sc-calcite-tile-h .container.sc-calcite-tile{gap:var(--calcite-spacing-xl)}/*!@:host([scale=l]) .heading*/[scale=l].sc-calcite-tile-h .heading.sc-calcite-tile{font-size:var(--calcite-font-size-0);line-height:1.375rem}/*!@:host([scale=l]) .description*/[scale=l].sc-calcite-tile-h .description.sc-calcite-tile{font-size:var(--calcite-font-size--1);line-height:1.20313rem}/*!@:host(:not([href]))*/.sc-calcite-tile-h:not([href]){--calcite-ui-icon-color:var(--calcite-color-text-3)}/*!@:host([href]),\n:host([href]:hover)*/[href].sc-calcite-tile-h,[href].sc-calcite-tile-h:hover{--calcite-tile-heading-text-color:var(--calcite-color-text-link)}/*!@:host([href]) .heading,\n:host([href]:hover) .heading*/[href].sc-calcite-tile-h .heading.sc-calcite-tile,[href].sc-calcite-tile-h:hover .heading.sc-calcite-tile{text-decoration-line:underline}/*!@:host(:not([embed])) .container*/.sc-calcite-tile-h:not([embed]) .container.sc-calcite-tile{box-shadow:0 0 0 1px var(--calcite-tile-border-color);padding:var(--calcite-spacing-md)}/*!@:host(:not([embed])[scale=s]) .container*/.sc-calcite-tile-h:not([embed])[scale=s] .container.sc-calcite-tile{padding:var(--calcite-spacing-sm)}/*!@:host(:not([embed])[scale=l]) .container*/.sc-calcite-tile-h:not([embed])[scale=l] .container.sc-calcite-tile{padding:var(--calcite-spacing-xl)}/*!@:host(:not([embed])[href]:hover),\n:host(:not([embed])[href]:focus)*/.sc-calcite-tile-h:not([embed])[href]:hover,.sc-calcite-tile-h:not([embed])[href]:focus{--calcite-tile-border-color:var(--calcite-color-brand)}/*!@:host(:not([embed])[href]:hover) .container,\n:host(:not([embed])[href]:focus) .container*/.sc-calcite-tile-h:not([embed])[href]:hover .container.sc-calcite-tile,.sc-calcite-tile-h:not([embed])[href]:focus .container.sc-calcite-tile{box-shadow:0 0 0 2px var(--calcite-tile-border-color);cursor:pointer;position:relative;z-index:var(--calcite-z-index)}/*!@:host(:not([embed])[href]:active)*/.sc-calcite-tile-h:not([embed])[href]:active{--calcite-tile-border-color:var(--calcite-color-brand)}/*!@:host(:not([embed])[href]:active) .container*/.sc-calcite-tile-h:not([embed])[href]:active .container.sc-calcite-tile{box-shadow:0 0 0 3px var(--calcite-tile-border-color)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-tile-h[disabled] .sc-calcite-tile-s>[calcite-hydrated][disabled],[disabled].sc-calcite-tile-h [calcite-hydrated][disabled].sc-calcite-tile{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-tile{display:contents}/*!@:host(:hover),\n:host([active])*/.sc-calcite-tile-h:hover,[active].sc-calcite-tile-h{--calcite-tile-description-text-color:var(--calcite-color-text-2);--calcite-tile-heading-text-color:var(--calcite-color-text-1)}/*!@:host([hidden])*/[hidden].sc-calcite-tile-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tile{display:none}";

/**
 * @slot content-start - A slot for adding non-actionable elements before the component's content.
 * @slot content-end - A slot for adding non-actionable elements after the component's content.
 */
class Tile {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.handleContentStartSlotChange = (event) => {
            this.hasContentStart = slotChangeHasAssignedElement(event);
        };
        this.handleContentEndSlotChange = (event) => {
            this.hasContentEnd = slotChangeHasAssignedElement(event);
        };
        this.active = false;
        this.alignment = "start";
        this.description = undefined;
        this.disabled = false;
        this.embed = false;
        this.focused = false;
        this.heading = undefined;
        this.href = undefined;
        this.icon = undefined;
        this.iconFlipRtl = false;
        this.scale = "m";
        this.hasContentStart = false;
        this.hasContentEnd = false;
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderTile() {
        const { icon, hasContentStart, hasContentEnd, heading, description, iconFlipRtl } = this;
        const isLargeVisual = heading && icon && !description;
        return (hAsync("div", { class: { [CSS$9.container]: true, [CSS$9.largeVisual]: isLargeVisual } }, icon && hAsync("calcite-icon", { flipRtl: iconFlipRtl, icon: icon, scale: "l" }), hAsync("div", { class: CSS$9.contentContainer }, hAsync("div", { class: { [CSS$9.contentSlotContainer]: hasContentStart } }, hAsync("slot", { name: SLOTS$3.contentStart, onSlotchange: this.handleContentStartSlotChange })), hAsync("div", { class: CSS$9.content }, heading && hAsync("div", { class: CSS$9.heading }, heading), description && hAsync("div", { class: CSS$9.description }, description)), hAsync("div", { class: { [CSS$9.contentSlotContainer]: hasContentEnd } }, hAsync("slot", { name: SLOTS$3.contentEnd, onSlotchange: this.handleContentEndSlotChange })))));
    }
    render() {
        const { disabled } = this;
        return (hAsync(InteractiveContainer, { disabled: disabled }, this.href ? (hAsync("calcite-link", { disabled: disabled, href: this.href }, this.renderTile())) : (this.renderTile())));
    }
    get el() { return getElement(this); }
    static get style() { return tileCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tile",
        "$members$": {
            "active": [516],
            "alignment": [513],
            "description": [513],
            "disabled": [516],
            "embed": [516],
            "focused": [516],
            "heading": [513],
            "href": [513],
            "icon": [513],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "scale": [513],
            "hasContentStart": [32],
            "hasContentEnd": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["active", "active"], ["alignment", "alignment"], ["description", "description"], ["disabled", "disabled"], ["embed", "embed"], ["focused", "focused"], ["heading", "heading"], ["href", "href"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["scale", "scale"]]
    }; }
}

const CSS$8 = {
    container: "container",
};

const tileGroupCss = "/*!@:host([disabled])*/[disabled].sc-calcite-tile-group-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-tile-group-h *.sc-calcite-tile-group,.sc-calcite-tile-group-h[disabled].sc-calcite-tile-group-s>*,.sc-calcite-tile-group-h[disabled] .sc-calcite-tile-group-s>*{pointer-events:none}/*!@:host*/.sc-calcite-tile-group-h{box-sizing:border-box;display:inline-block}/*!@:host ::slotted(calcite-tile)*/.sc-calcite-tile-group-h .sc-calcite-tile-group-s>calcite-tile{margin-block-end:var(--calcite-spacing-px);margin-inline-end:var(--calcite-spacing-px)}/*!@.container*/.container.sc-calcite-tile-group{display:grid;grid-auto-rows:minmax(auto, 1fr)}/*!@:host([scale=s]) .container*/[scale=s].sc-calcite-tile-group-h .container.sc-calcite-tile-group{grid-template-columns:repeat(auto-fit, minmax(100px, 1fr))}/*!@:host([scale=m]) .container*/[scale=m].sc-calcite-tile-group-h .container.sc-calcite-tile-group{grid-template-columns:repeat(auto-fit, minmax(140px, 1fr))}/*!@:host([scale=l]) .container*/[scale=l].sc-calcite-tile-group-h .container.sc-calcite-tile-group{grid-template-columns:repeat(auto-fit, minmax(160px, 1fr))}/*!@:host([layout=vertical]) .container*/[layout=vertical].sc-calcite-tile-group-h .container.sc-calcite-tile-group{display:flex;flex-direction:column}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-tile-group-h[disabled] .sc-calcite-tile-group-s>[calcite-hydrated][disabled],[disabled].sc-calcite-tile-group-h [calcite-hydrated][disabled].sc-calcite-tile-group{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-tile-group{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-tile-group-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tile-group{display:none}";

/**
 * @slot - A slot for adding `calcite-tile` elements.
 */
class TileGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this.updateTiles = () => {
            this.el.querySelectorAll("calcite-tile").forEach((item) => (item.scale = this.scale));
        };
        this.disabled = false;
        this.layout = "horizontal";
        this.scale = "m";
    }
    scaleWatcher() {
        this.updateTiles();
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
        this.updateTiles();
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
    }
    render() {
        return (hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: CSS$8.container }, hAsync("slot", { onSlotchange: this.updateTiles }))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "scale": ["scaleWatcher"]
    }; }
    static get style() { return tileGroupCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tile-group",
        "$members$": {
            "disabled": [516],
            "layout": [513],
            "scale": [513]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["layout", "layout"], ["scale", "scale"]]
    }; }
}

const CSS$7 = {
    checked: "checked",
    description: "description",
    descriptionOnly: "description-only",
    disabled: "disabled",
    heading: "heading",
    headingOnly: "heading-only",
    icon: "icon",
    iconOnly: "icon-only",
    inputAlignmentEnd: "input-alignment-end",
    inputAlignmentStart: "input-alignment-start",
    inputEnabled: "input-enabled",
    largeVisual: "large-visual",
    tile: "tile",
    tileContentContainer: "tile-content-container",
    tileContent: "tile-content",
    tileDescription: "tile-description",
    tileHeading: "tile-heading",
    tileLargeVisual: "tile--large-visual",
    widthAuto: "width-auto",
    widthFull: "width-full",
};

const tileSelectCss = "/*!@:host([disabled])*/[disabled].sc-calcite-tile-select-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-tile-select-h *.sc-calcite-tile-select,.sc-calcite-tile-select-h[disabled].sc-calcite-tile-select-s>*,.sc-calcite-tile-select-h[disabled] .sc-calcite-tile-select-s>*{pointer-events:none}/*!@:host*/.sc-calcite-tile-select-h{display:block}/*!@:host .container*/.sc-calcite-tile-select-h .container.sc-calcite-tile-select{background-color:var(--calcite-color-foreground-1);box-shadow:0 0 0 1px var(--calcite-color-border-2);box-sizing:border-box;cursor:pointer;display:inline-block;block-size:100%;max-inline-size:300px;padding:0.75rem;position:relative;vertical-align:top;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}/*!@:host .container.checked*/.sc-calcite-tile-select-h .container.checked.sc-calcite-tile-select{z-index:var(--calcite-z-index);box-shadow:0 0 0 1px var(--calcite-color-brand)}/*!@:host .container.heading-only*/.sc-calcite-tile-select-h .container.heading-only.sc-calcite-tile-select{align-items:center}/*!@:host .container:not(.input-enabled) ::slotted(calcite-checkbox),\n:host .container:not(.input-enabled) ::slotted(calcite-radio-button)*/.sc-calcite-tile-select-h .container:not(.input-enabled) .sc-calcite-tile-select-s>calcite-checkbox,.sc-calcite-tile-select-h .container:not(.input-enabled).sc-calcite-tile-select-s>calcite-radio-button,.sc-calcite-tile-select-h .container:not(.input-enabled) .sc-calcite-tile-select-s>calcite-radio-button{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}/*!@:host .container.focused*/.sc-calcite-tile-select-h .container.focused.sc-calcite-tile-select{outline-color:transparent}/*!@:host .container.focused:not(.disabled):not(.input-enabled)*/.sc-calcite-tile-select-h .container.focused.sc-calcite-tile-select:not(.disabled):not(.input-enabled){outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          );outline-offset:-4px;box-shadow:0 0 0 1px var(--calcite-color-brand), inset 0 0 0 2px var(--calcite-color-foreground-1)}/*!@:host .container.input-enabled.input-alignment-start.width-auto.heading-only, :host .container.input-enabled.input-alignment-start.width-auto.icon-only, :host .container.input-enabled.input-alignment-start.width-auto.description-only, :host .container.input-enabled.input-alignment-start.width-auto.heading.description, :host .container.input-enabled.input-alignment-start.width-auto.icon.description, :host .container.input-enabled.input-alignment-start.width-auto.heading.icon.description*/.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.width-auto.heading-only.sc-calcite-tile-select,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.width-auto.icon-only.sc-calcite-tile-select,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.width-auto.description-only.sc-calcite-tile-select,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.width-auto.heading.description.sc-calcite-tile-select,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.width-auto.icon.description.sc-calcite-tile-select,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.width-auto.heading.icon.description.sc-calcite-tile-select{display:inline-grid;grid-template-columns:max-content 1fr}/*!@:host .container.input-enabled.input-alignment-start.heading-only, :host .container.input-enabled.input-alignment-start.icon-only, :host .container.input-enabled.input-alignment-start.description-only, :host .container.input-enabled.input-alignment-start.heading.description, :host .container.input-enabled.input-alignment-start.icon.description, :host .container.input-enabled.input-alignment-start.heading.icon.description*/.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.heading-only.sc-calcite-tile-select,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.icon-only.sc-calcite-tile-select,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.description-only.sc-calcite-tile-select,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.heading.description.sc-calcite-tile-select,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.icon.description.sc-calcite-tile-select,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.heading.icon.description.sc-calcite-tile-select{gap:0.75rem}/*!@:host .container.input-enabled.input-alignment-start .tile*/.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.sc-calcite-tile-select .tile.sc-calcite-tile-select{order:1}/*!@:host .container.input-enabled.input-alignment-start.large-visual ::slotted(calcite-checkbox),\n:host .container.input-enabled.input-alignment-start.large-visual ::slotted(calcite-radio-button)*/.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.large-visual .sc-calcite-tile-select-s>calcite-checkbox,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.large-visual.sc-calcite-tile-select-s>calcite-radio-button,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-start.large-visual .sc-calcite-tile-select-s>calcite-radio-button{position:absolute;inset-block-start:0.75rem;inset-inline-start:0.75rem}/*!@:host .container.input-enabled.input-alignment-end.width-auto.heading-only, :host .container.input-enabled.input-alignment-end.width-auto.icon-only*/.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.width-auto.heading-only.sc-calcite-tile-select,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.width-auto.icon-only.sc-calcite-tile-select{display:inline-grid;grid-gap:0.75rem;grid-template-columns:max-content 1fr}/*!@:host .container.input-enabled.input-alignment-end.heading-only, :host .container.input-enabled.input-alignment-end.icon-only*/.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.heading-only.sc-calcite-tile-select,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.icon-only.sc-calcite-tile-select{gap:0.75rem}/*!@:host .container.input-enabled.input-alignment-end.description-only ::slotted(calcite-checkbox),\n:host .container.input-enabled.input-alignment-end.description-only ::slotted(calcite-radio-button), :host .container.input-enabled.input-alignment-end.heading.description ::slotted(calcite-checkbox),\n:host .container.input-enabled.input-alignment-end.heading.description ::slotted(calcite-radio-button), :host .container.input-enabled.input-alignment-end.icon.description ::slotted(calcite-checkbox),\n:host .container.input-enabled.input-alignment-end.icon.description ::slotted(calcite-radio-button), :host .container.input-enabled.input-alignment-end.heading.icon.description ::slotted(calcite-checkbox),\n:host .container.input-enabled.input-alignment-end.heading.icon.description ::slotted(calcite-radio-button)*/.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.description-only .sc-calcite-tile-select-s>calcite-checkbox,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.description-only.sc-calcite-tile-select-s>calcite-radio-button,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.description-only .sc-calcite-tile-select-s>calcite-radio-button,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.heading.description.sc-calcite-tile-select-s>calcite-checkbox,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.heading.description .sc-calcite-tile-select-s>calcite-checkbox,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.heading.description.sc-calcite-tile-select-s>calcite-radio-button,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.heading.description .sc-calcite-tile-select-s>calcite-radio-button,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.icon.description.sc-calcite-tile-select-s>calcite-checkbox,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.icon.description .sc-calcite-tile-select-s>calcite-checkbox,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.icon.description.sc-calcite-tile-select-s>calcite-radio-button,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.icon.description .sc-calcite-tile-select-s>calcite-radio-button,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.heading.icon.description.sc-calcite-tile-select-s>calcite-checkbox,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.heading.icon.description .sc-calcite-tile-select-s>calcite-checkbox,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.heading.icon.description.sc-calcite-tile-select-s>calcite-radio-button,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.heading.icon.description .sc-calcite-tile-select-s>calcite-radio-button{position:absolute;inset-block-start:0.75rem;inset-inline-end:0.75rem}/*!@:host .container.input-enabled.input-alignment-end.large-visual ::slotted(calcite-checkbox),\n:host .container.input-enabled.input-alignment-end.large-visual ::slotted(calcite-radio-button)*/.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.large-visual .sc-calcite-tile-select-s>calcite-checkbox,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.large-visual.sc-calcite-tile-select-s>calcite-radio-button,.sc-calcite-tile-select-h .container.input-enabled.input-alignment-end.large-visual .sc-calcite-tile-select-s>calcite-radio-button{position:absolute;inset-block-start:0.75rem;inset-inline-end:0.75rem}/*!@:host .container.width-full*/.sc-calcite-tile-select-h .container.width-full.sc-calcite-tile-select{display:flex;max-inline-size:none}/*!@:host .container.width-full .tile*/.sc-calcite-tile-select-h .container.width-full.sc-calcite-tile-select .tile.sc-calcite-tile-select{flex:1 1 auto}/*!@.tile*/.tile.sc-calcite-tile-select{pointer-events:none;box-sizing:border-box;display:flex;-webkit-user-select:none;user-select:none;flex-direction:column;gap:0.5rem;background-color:var(--calcite-color-foreground-1);color:var(--calcite-color-text-3);transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}/*!@.tile-content-container*/.tile-content-container.sc-calcite-tile-select{display:flex;inline-size:100%;align-items:stretch;padding:0px;color:var(--calcite-color-text-2);outline-color:transparent}/*!@.tile-content*/.tile-content.sc-calcite-tile-select{display:flex;flex:1 1 auto;flex-direction:column;gap:0.5rem;inline-size:10%}/*!@.tile-heading*/.tile-heading.sc-calcite-tile-select{pointer-events:none;overflow-wrap:break-word;font-size:var(--calcite-font-size--1);line-height:1.375;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-2);transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}/*!@.tile-description*/.tile-description.sc-calcite-tile-select{pointer-events:none;overflow-wrap:break-word;font-size:var(--calcite-font-size--2);line-height:1.375;color:var(--calcite-color-text-3);transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}/*!@.tile--large-visual*/.tile--large-visual.sc-calcite-tile-select{display:grid;justify-content:center;text-align:center;min-block-size:12rem}/*!@.tile--large-visual .icon*/.tile--large-visual.sc-calcite-tile-select .icon.sc-calcite-tile-select{align-self:flex-end}/*!@.tile--large-visual calcite-icon*/.tile--large-visual.sc-calcite-tile-select calcite-icon.sc-calcite-tile-select{block-size:64px;inline-size:64px}/*!@.tile--large-visual .tile-content-container*/.tile--large-visual.sc-calcite-tile-select .tile-content-container.sc-calcite-tile-select{align-self:center}/*!@:host(:hover) .container:not(.input-enabled)*/.sc-calcite-tile-select-h:hover .container.sc-calcite-tile-select:not(.input-enabled){box-shadow:0 0 0 1px var(--calcite-color-brand)}/*!@:host(:hover) .tile-heading,\n.checked .tile-heading*/.sc-calcite-tile-select-h:hover .tile-heading.sc-calcite-tile-select,.checked.sc-calcite-tile-select .tile-heading.sc-calcite-tile-select{color:var(--calcite-color-text-1)}/*!@:host(:hover) .tile-description,\n.checked .tile-description*/.sc-calcite-tile-select-h:hover .tile-description.sc-calcite-tile-select,.checked.sc-calcite-tile-select .tile-description.sc-calcite-tile-select{color:var(--calcite-color-text-2)}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-tile-select-h[disabled] .sc-calcite-tile-select-s>[calcite-hydrated][disabled],[disabled].sc-calcite-tile-select-h [calcite-hydrated][disabled].sc-calcite-tile-select{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-tile-select{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-tile-select-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tile-select{display:none}";

/**
 * @slot - A slot for adding custom content.
 */
class TileSelect {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteTileSelectChange = createEvent(this, "calciteTileSelectChange", 6);
        this.guid = `calcite-tile-select-${guid()}`;
        this.checked = false;
        this.description = undefined;
        this.disabled = false;
        this.heading = undefined;
        this.icon = undefined;
        this.iconFlipRtl = false;
        this.name = undefined;
        this.inputEnabled = false;
        this.inputAlignment = "start";
        this.type = "radio";
        this.value = undefined;
        this.width = "auto";
        this.focused = false;
    }
    checkedChanged(newChecked) {
        this.input.checked = newChecked;
    }
    nameChanged(newName) {
        this.input.name = newName;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /** Sets focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        return this.input?.setFocus();
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    checkboxChangeHandler(event) {
        const checkbox = event.target;
        if (checkbox === this.input) {
            this.checked = checkbox.checked;
        }
        event.stopPropagation();
        this.calciteTileSelectChange.emit();
    }
    checkboxFocusBlurHandler(event) {
        const checkbox = event.target;
        if (checkbox === this.input) {
            this.focused = event.detail;
        }
        event.stopPropagation();
    }
    radioButtonChangeHandler(event) {
        const radioButton = event.target;
        if (radioButton === this.input) {
            this.checked = radioButton.checked;
        }
        event.stopPropagation();
        this.calciteTileSelectChange.emit();
    }
    radioButtonCheckedChangeHandler(event) {
        const radioButton = event.target;
        if (radioButton === this.input) {
            this.checked = radioButton.checked;
        }
        event.stopPropagation();
    }
    radioButtonFocusBlurHandler(event) {
        const radioButton = event.target;
        if (radioButton === this.input) {
            this.focused = radioButton.focused;
        }
        event.stopPropagation();
    }
    clickHandler(event) {
        if (this.disabled) {
            return;
        }
        const target = event.target;
        const targets = ["calcite-tile", "calcite-tile-select"];
        if (targets.includes(target.localName)) {
            this.input.click();
        }
    }
    pointerEnterHandler() {
        if (this.disabled) {
            return;
        }
        const { localName } = this.input;
        if (localName === "calcite-radio-button" || localName === "calcite-checkbox") {
            this.input.hovered = true;
        }
    }
    pointerLeaveHandler() {
        if (this.disabled) {
            return;
        }
        const { localName } = this.input;
        if (localName === "calcite-radio-button" || localName === "calcite-checkbox") {
            this.input.hovered = false;
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.renderInput();
        connectInteractive(this);
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        this.input.parentNode.removeChild(this.input);
        disconnectInteractive(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderInput() {
        this.input =
            this.type === "radio"
                ? /* we need to call createElement(x) separately to ensure supporting components are properly bundled */
                    document.createElement("calcite-radio-button")
                : document.createElement("calcite-checkbox");
        this.input.checked = this.checked;
        this.input.disabled = this.disabled;
        this.input.hidden = this.el.hidden;
        this.input.id = this.guid;
        this.input.label = this.heading || this.name || "";
        if (this.name) {
            this.input.name = this.name;
        }
        if (this.value) {
            this.input.value = this.value != null ? this.value.toString() : "";
        }
        this.el.insertAdjacentElement("beforeend", this.input);
    }
    render() {
        const { checked, description, disabled, focused, heading, icon, inputAlignment, inputEnabled, width, iconFlipRtl, } = this;
        const isLargeVisual = heading && icon && !description;
        const renderIcon = Boolean(icon);
        return (hAsync(InteractiveContainer, { disabled: disabled }, hAsync("div", { class: {
                checked,
                container: true,
                [CSS$7.description]: Boolean(description),
                [CSS$7.descriptionOnly]: Boolean(!heading && !icon && description),
                disabled,
                focused,
                [CSS$7.heading]: Boolean(heading),
                [CSS$7.headingOnly]: heading && !icon && !description,
                [CSS$7.icon]: renderIcon,
                [CSS$7.iconOnly]: !heading && icon && !description,
                [CSS$7.inputAlignmentEnd]: inputAlignment === "end",
                [CSS$7.inputAlignmentStart]: inputAlignment === "start",
                [CSS$7.inputEnabled]: inputEnabled,
                [CSS$7.largeVisual]: isLargeVisual,
                [CSS$7.widthAuto]: width === "auto",
                [CSS$7.widthFull]: width === "full",
            } }, hAsync("div", { class: { [CSS$7.tile]: true, [CSS$7.tileLargeVisual]: isLargeVisual } }, icon && (hAsync("div", { class: { [CSS$7.icon]: renderIcon } }, hAsync("calcite-icon", { flipRtl: iconFlipRtl, icon: icon, scale: "l" }))), hAsync("div", { class: CSS$7.tileContentContainer }, hAsync("div", { class: CSS$7.tileContent }, heading && hAsync("div", { class: CSS$7.tileHeading }, heading), description && hAsync("div", { class: CSS$7.tileDescription }, description)))), hAsync("slot", null))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "checked": ["checkedChanged"],
        "name": ["nameChanged"]
    }; }
    static get style() { return tileSelectCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tile-select",
        "$members$": {
            "checked": [1540],
            "description": [513],
            "disabled": [516],
            "heading": [513],
            "icon": [513],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "name": [520],
            "inputEnabled": [516, "input-enabled"],
            "inputAlignment": [513, "input-alignment"],
            "type": [513],
            "value": [8],
            "width": [513],
            "focused": [32],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteCheckboxChange", "checkboxChangeHandler"], [0, "calciteInternalCheckboxFocus", "checkboxFocusBlurHandler"], [0, "calciteInternalCheckboxBlur", "checkboxFocusBlurHandler"], [0, "calciteRadioButtonChange", "radioButtonChangeHandler"], [0, "calciteInternalRadioButtonCheckedChange", "radioButtonCheckedChangeHandler"], [0, "calciteInternalRadioButtonFocus", "radioButtonFocusBlurHandler"], [0, "calciteInternalRadioButtonBlur", "radioButtonFocusBlurHandler"], [0, "click", "clickHandler"], [1, "pointerenter", "pointerEnterHandler"], [1, "pointerleave", "pointerLeaveHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["checked", "checked"], ["description", "description"], ["disabled", "disabled"], ["heading", "heading"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["name", "name"], ["inputEnabled", "input-enabled"], ["inputAlignment", "input-alignment"], ["type", "type"], ["width", "width"]]
    }; }
}

const tileSelectGroupCss = "/*!@:host([disabled])*/[disabled].sc-calcite-tile-select-group-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-tile-select-group-h *.sc-calcite-tile-select-group,.sc-calcite-tile-select-group-h[disabled].sc-calcite-tile-select-group-s>*,.sc-calcite-tile-select-group-h[disabled] .sc-calcite-tile-select-group-s>*{pointer-events:none}/*!@:host*/.sc-calcite-tile-select-group-h{display:flex;flex-wrap:wrap}/*!@:host ::slotted(calcite-tile-select)*/.sc-calcite-tile-select-group-h .sc-calcite-tile-select-group-s>calcite-tile-select{margin-block-end:1px;margin-inline-end:1px}/*!@:host([layout=vertical])*/[layout=vertical].sc-calcite-tile-select-group-h{flex-direction:column}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-tile-select-group-h[disabled] .sc-calcite-tile-select-group-s>[calcite-hydrated][disabled],[disabled].sc-calcite-tile-select-group-h [calcite-hydrated][disabled].sc-calcite-tile-select-group{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-tile-select-group{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-tile-select-group-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tile-select-group{display:none}";

/**
 * @slot - A slot for adding `calcite-tile-select` elements.
 */
class TileSelectGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.disabled = false;
        this.layout = "horizontal";
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        connectInteractive(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        disconnectInteractive(this);
    }
    render() {
        return (hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("slot", null)));
    }
    get el() { return getElement(this); }
    static get style() { return tileSelectGroupCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tile-select-group",
        "$members$": {
            "disabled": [516],
            "layout": [513]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["layout", "layout"]]
    }; }
}

const CSS$6 = {
    button: "button",
    buttonBottomLeft: "button--bottom-left",
    buttonBottomRight: "button--bottom-right",
    buttonFractionalSecondDown: "button--fractionalSecond-down",
    buttonFractionalSecondUp: "button--fractionalSecond-up",
    buttonHourDown: "button--hour-down",
    buttonHourUp: "button--hour-up",
    buttonMeridiemDown: "button--meridiem-down",
    buttonMeridiemUp: "button--meridiem-up",
    buttonMinuteDown: "button--minute-down",
    buttonMinuteUp: "button--minute-up",
    buttonSecondDown: "button--second-down",
    buttonSecondUp: "button--second-up",
    buttonTopLeft: "button--top-left",
    buttonTopRight: "button--top-right",
    column: "column",
    delimiter: "delimiter",
    fractionalSecond: "fractionalSecond",
    hour: "hour",
    input: "input",
    inputFocus: "inputFocus",
    meridiem: "meridiem",
    minute: "minute",
    second: "second",
    showMeridiem: "show-meridiem",
    showSecond: "show-second",
    "scale-s": "scale-s",
    "scale-m": "scale-m",
    "scale-l": "scale-l",
    timePicker: "time-picker",
    meridiemStart: "meridiem--start",
};

const timePickerCss = "/*!@:host*/.sc-calcite-time-picker-h{display:inline-block}/*!@.time-picker*/.time-picker.sc-calcite-time-picker{display:flex;-webkit-user-select:none;user-select:none;align-items:center;background-color:var(--calcite-color-foreground-1);font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1);--tw-shadow:0 6px 20px -4px rgba(0, 0, 0, 0.1), 0 4px 12px -2px rgba(0, 0, 0, 0.08);--tw-shadow-colored:0 6px 20px -4px var(--tw-shadow-color), 0 4px 12px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);border-radius:var(--calcite-border-radius)}/*!@.time-picker .column*/.time-picker.sc-calcite-time-picker .column.sc-calcite-time-picker{display:flex;flex-direction:column}/*!@.time-picker .meridiem--start*/.time-picker.sc-calcite-time-picker .meridiem--start.sc-calcite-time-picker{order:-1}/*!@.time-picker .button*/.time-picker.sc-calcite-time-picker .button.sc-calcite-time-picker{display:inline-flex;cursor:pointer;align-items:center;justify-content:center;background-color:var(--calcite-color-foreground-1)}/*!@.time-picker .button:hover, .time-picker .button:focus*/.time-picker.sc-calcite-time-picker .button.sc-calcite-time-picker:hover,.time-picker.sc-calcite-time-picker .button.sc-calcite-time-picker:focus{background-color:var(--calcite-color-foreground-2);outline:2px solid transparent;outline-offset:2px;z-index:var(--calcite-z-index-header);outline-offset:0}/*!@.time-picker .button:active*/.time-picker.sc-calcite-time-picker .button.sc-calcite-time-picker:active{background-color:var(--calcite-color-foreground-3)}/*!@.time-picker .button.top-left*/.time-picker.sc-calcite-time-picker .button.top-left.sc-calcite-time-picker{border-start-start-radius:var(--calcite-border-radius)}/*!@.time-picker .button.bottom-left*/.time-picker.sc-calcite-time-picker .button.bottom-left.sc-calcite-time-picker{border-end-start-radius:var(--calcite-border-radius)}/*!@.time-picker .button.top-right*/.time-picker.sc-calcite-time-picker .button.top-right.sc-calcite-time-picker{border-start-end-radius:var(--calcite-border-radius)}/*!@.time-picker .button.bottom-right*/.time-picker.sc-calcite-time-picker .button.bottom-right.sc-calcite-time-picker{border-end-end-radius:var(--calcite-border-radius)}/*!@.time-picker .button calcite-icon*/.time-picker.sc-calcite-time-picker .button.sc-calcite-time-picker calcite-icon.sc-calcite-time-picker{color:var(--calcite-color-text-3)}/*!@.time-picker .input*/.time-picker.sc-calcite-time-picker .input.sc-calcite-time-picker{display:inline-flex;cursor:pointer;align-items:center;justify-content:center;background-color:var(--calcite-color-foreground-1);font-weight:var(--calcite-font-weight-medium)}/*!@.time-picker .input:hover*/.time-picker.sc-calcite-time-picker .input.sc-calcite-time-picker:hover{box-shadow:inset 0 0 0 2px var(--calcite-color-foreground-2);z-index:var(--calcite-z-index-header)}/*!@.time-picker .input:focus, .time-picker .input:hover:focus*/.time-picker.sc-calcite-time-picker .input.sc-calcite-time-picker:focus,.time-picker.sc-calcite-time-picker .input.sc-calcite-time-picker:hover:focus{outline:2px solid transparent;outline-offset:2px;outline-offset:0}/*!@.time-picker .input.inputFocus, .time-picker .input:hover.inputFocus*/.time-picker.sc-calcite-time-picker .input.inputFocus.sc-calcite-time-picker,.time-picker.sc-calcite-time-picker .input.sc-calcite-time-picker:hover.inputFocus{box-shadow:inset 0 0 0 2px var(--calcite-color-brand);z-index:var(--calcite-z-index-header)}/*!@.time-picker.scale-s*/.time-picker.scale-s.sc-calcite-time-picker{font-size:var(--calcite-font-size--1)}/*!@.time-picker.scale-s .button,\n.time-picker.scale-s .input*/.time-picker.scale-s.sc-calcite-time-picker .button.sc-calcite-time-picker,.time-picker.scale-s.sc-calcite-time-picker .input.sc-calcite-time-picker{padding-inline:0.75rem;padding-block:0.25rem}/*!@.time-picker.scale-s:not(.show-meridiem) .delimiter:last-child*/.time-picker.scale-s.sc-calcite-time-picker:not(.show-meridiem) .delimiter.sc-calcite-time-picker:last-child{padding-inline-end:0.75rem}/*!@.time-picker.scale-m*/.time-picker.scale-m.sc-calcite-time-picker{font-size:var(--calcite-font-size-0)}/*!@.time-picker.scale-m .button,\n.time-picker.scale-m .input*/.time-picker.scale-m.sc-calcite-time-picker .button.sc-calcite-time-picker,.time-picker.scale-m.sc-calcite-time-picker .input.sc-calcite-time-picker{padding-inline:1rem;padding-block:0.5rem}/*!@.time-picker.scale-m:not(.show-meridiem) .delimiter:last-child*/.time-picker.scale-m.sc-calcite-time-picker:not(.show-meridiem) .delimiter.sc-calcite-time-picker:last-child{padding-inline-end:1rem}/*!@.time-picker.scale-l*/.time-picker.scale-l.sc-calcite-time-picker{font-size:var(--calcite-font-size-1)}/*!@.time-picker.scale-l .button,\n.time-picker.scale-l .input*/.time-picker.scale-l.sc-calcite-time-picker .button.sc-calcite-time-picker,.time-picker.scale-l.sc-calcite-time-picker .input.sc-calcite-time-picker{padding-inline:1.25rem;padding-block:0.75rem}/*!@.time-picker.scale-l:not(.show-meridiem) .delimiter:last-child*/.time-picker.scale-l.sc-calcite-time-picker:not(.show-meridiem) .delimiter.sc-calcite-time-picker:last-child{padding-inline-end:1.25rem}/*!@:host([hidden])*/[hidden].sc-calcite-time-picker-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-time-picker{display:none}";

function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
class TimePicker {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalTimePickerBlur = createEvent(this, "calciteInternalTimePickerBlur", 6);
        this.calciteInternalTimePickerChange = createEvent(this, "calciteInternalTimePickerChange", 6);
        this.calciteInternalTimePickerFocus = createEvent(this, "calciteInternalTimePickerFocus", 6);
        this.pointerActivated = false;
        this.decrementHour = () => {
            const newHour = !this.hour ? 0 : this.hour === "00" ? 23 : parseInt(this.hour) - 1;
            this.setValuePart("hour", newHour);
        };
        this.decrementMeridiem = () => {
            const newMeridiem = this.meridiem === "PM" ? "AM" : "PM";
            this.setValuePart("meridiem", newMeridiem);
        };
        this.decrementMinuteOrSecond = (key) => {
            let newValue;
            if (isValidNumber(this[key])) {
                const valueAsNumber = parseInt(this[key]);
                newValue = valueAsNumber === 0 ? 59 : valueAsNumber - 1;
            }
            else {
                newValue = 59;
            }
            this.setValuePart(key, newValue);
        };
        this.decrementMinute = () => {
            this.decrementMinuteOrSecond("minute");
        };
        this.decrementSecond = () => {
            this.decrementMinuteOrSecond("second");
        };
        this.focusHandler = (event) => {
            if (this.pointerActivated) {
                return;
            }
            this.activeEl = event.currentTarget;
        };
        this.fractionalSecondKeyDownHandler = (event) => {
            const { key } = event;
            if (numberKeys.includes(key)) {
                const stepPrecision = decimalPlaces(this.step);
                const fractionalSecondAsInteger = parseInt(this.fractionalSecond);
                const fractionalSecondAsIntegerLength = fractionalSecondAsInteger.toString().length;
                let newFractionalSecondAsIntegerString;
                if (fractionalSecondAsIntegerLength >= stepPrecision) {
                    newFractionalSecondAsIntegerString = key.padStart(stepPrecision, "0");
                }
                else if (fractionalSecondAsIntegerLength < stepPrecision) {
                    newFractionalSecondAsIntegerString = `${fractionalSecondAsInteger}${key}`.padStart(stepPrecision, "0");
                }
                this.setValuePart("fractionalSecond", parseFloat(`0.${newFractionalSecondAsIntegerString}`));
            }
            else {
                switch (key) {
                    case "Backspace":
                    case "Delete":
                        this.setValuePart("fractionalSecond", null);
                        break;
                    case "ArrowDown":
                        event.preventDefault();
                        this.nudgeFractionalSecond("down");
                        break;
                    case "ArrowUp":
                        event.preventDefault();
                        this.nudgeFractionalSecond("up");
                        break;
                    case " ":
                        event.preventDefault();
                        break;
                }
            }
        };
        this.fractionalSecondDownClickHandler = () => {
            this.activeEl = this.fractionalSecondEl;
            this.fractionalSecondEl.focus();
            this.nudgeFractionalSecond("down");
        };
        this.fractionalSecondUpClickHandler = () => {
            this.activeEl = this.fractionalSecondEl;
            this.fractionalSecondEl.focus();
            this.nudgeFractionalSecond("up");
        };
        this.hourDownClickHandler = () => {
            this.activeEl = this.hourEl;
            this.hourEl.focus();
            this.decrementHour();
        };
        this.hourKeyDownHandler = (event) => {
            const { key } = event;
            if (numberKeys.includes(key)) {
                const keyAsNumber = parseInt(key);
                let newHour;
                if (isValidNumber(this.hour)) {
                    switch (this.hourCycle) {
                        case "12":
                            newHour =
                                this.hour === "01" && keyAsNumber >= 0 && keyAsNumber <= 2
                                    ? `1${keyAsNumber}`
                                    : keyAsNumber;
                            break;
                        case "24":
                            if (this.hour === "01") {
                                newHour = `1${keyAsNumber}`;
                            }
                            else if (this.hour === "02" && keyAsNumber >= 0 && keyAsNumber <= 3) {
                                newHour = `2${keyAsNumber}`;
                            }
                            else {
                                newHour = keyAsNumber;
                            }
                            break;
                    }
                }
                else {
                    newHour = keyAsNumber;
                }
                this.setValuePart("hour", newHour);
            }
            else {
                switch (key) {
                    case "Backspace":
                    case "Delete":
                        this.setValuePart("hour", null);
                        break;
                    case "ArrowDown":
                        event.preventDefault();
                        this.decrementHour();
                        break;
                    case "ArrowUp":
                        event.preventDefault();
                        this.incrementHour();
                        break;
                    case " ":
                        event.preventDefault();
                        break;
                }
            }
        };
        this.hourUpClickHandler = () => {
            this.activeEl = this.hourEl;
            this.hourEl.focus();
            this.incrementHour();
        };
        this.incrementMeridiem = () => {
            const newMeridiem = this.meridiem === "AM" ? "PM" : "AM";
            this.setValuePart("meridiem", newMeridiem);
        };
        this.incrementHour = () => {
            const newHour = isValidNumber(this.hour)
                ? this.hour === "23"
                    ? 0
                    : parseInt(this.hour) + 1
                : 1;
            this.setValuePart("hour", newHour);
        };
        this.incrementMinuteOrSecond = (key) => {
            const newValue = isValidNumber(this[key])
                ? this[key] === "59"
                    ? 0
                    : parseInt(this[key]) + 1
                : 0;
            this.setValuePart(key, newValue);
        };
        this.incrementMinute = () => {
            this.incrementMinuteOrSecond("minute");
        };
        this.incrementSecond = () => {
            this.incrementMinuteOrSecond("second");
        };
        this.inputClickHandler = (event) => {
            this.activeEl = event.target;
        };
        this.meridiemUpClickHandler = () => {
            this.activeEl = this.meridiemEl;
            this.meridiemEl.focus();
            this.incrementMeridiem();
        };
        this.meridiemKeyDownHandler = (event) => {
            switch (event.key) {
                case "a":
                    this.setValuePart("meridiem", "AM");
                    break;
                case "p":
                    this.setValuePart("meridiem", "PM");
                    break;
                case "Backspace":
                case "Delete":
                    this.setValuePart("meridiem", null);
                    break;
                case "ArrowUp":
                    event.preventDefault();
                    this.incrementMeridiem();
                    break;
                case "ArrowDown":
                    event.preventDefault();
                    this.decrementMeridiem();
                    break;
                case " ":
                    event.preventDefault();
                    break;
            }
        };
        this.meridiemDownClickHandler = () => {
            this.activeEl = this.meridiemEl;
            this.meridiemEl.focus();
            this.decrementMeridiem();
        };
        this.minuteDownClickHandler = () => {
            this.activeEl = this.minuteEl;
            this.minuteEl.focus();
            this.decrementMinute();
        };
        this.minuteUpClickHandler = () => {
            this.activeEl = this.minuteEl;
            this.minuteEl.focus();
            this.incrementMinute();
        };
        this.minuteKeyDownHandler = (event) => {
            const { key } = event;
            if (numberKeys.includes(key)) {
                const keyAsNumber = parseInt(key);
                let newMinute;
                if (isValidNumber(this.minute) && this.minute.startsWith("0")) {
                    const minuteAsNumber = parseInt(this.minute);
                    newMinute =
                        minuteAsNumber > maxTenthForMinuteAndSecond
                            ? keyAsNumber
                            : `${minuteAsNumber}${keyAsNumber}`;
                }
                else {
                    newMinute = keyAsNumber;
                }
                this.setValuePart("minute", newMinute);
            }
            else {
                switch (key) {
                    case "Backspace":
                    case "Delete":
                        this.setValuePart("minute", null);
                        break;
                    case "ArrowDown":
                        event.preventDefault();
                        this.decrementMinute();
                        break;
                    case "ArrowUp":
                        event.preventDefault();
                        this.incrementMinute();
                        break;
                    case " ":
                        event.preventDefault();
                        break;
                }
            }
        };
        this.nudgeFractionalSecond = (direction) => {
            const stepDecimal = getDecimals(this.step);
            const stepPrecision = decimalPlaces(this.step);
            const fractionalSecondAsInteger = parseInt(this.fractionalSecond);
            const fractionalSecondAsFloat = parseFloat(`0.${this.fractionalSecond}`);
            let nudgedValue;
            let nudgedValueRounded;
            let nudgedValueRoundedDecimals;
            let newFractionalSecond;
            if (direction === "up") {
                nudgedValue = isNaN(fractionalSecondAsInteger) ? 0 : fractionalSecondAsFloat + stepDecimal;
                nudgedValueRounded = parseFloat(nudgedValue.toFixed(stepPrecision));
                nudgedValueRoundedDecimals = getDecimals(nudgedValueRounded);
                newFractionalSecond =
                    nudgedValueRounded < 1 && decimalPlaces(nudgedValueRoundedDecimals) > 0
                        ? formatTimePart(nudgedValueRoundedDecimals, stepPrecision)
                        : "".padStart(stepPrecision, "0");
            }
            if (direction === "down") {
                nudgedValue =
                    isNaN(fractionalSecondAsInteger) || fractionalSecondAsInteger === 0
                        ? 1 - stepDecimal
                        : fractionalSecondAsFloat - stepDecimal;
                nudgedValueRounded = parseFloat(nudgedValue.toFixed(stepPrecision));
                nudgedValueRoundedDecimals = getDecimals(nudgedValueRounded);
                newFractionalSecond =
                    nudgedValueRounded < 1 &&
                        decimalPlaces(nudgedValueRoundedDecimals) > 0 &&
                        Math.sign(nudgedValueRoundedDecimals) === 1
                        ? formatTimePart(nudgedValueRoundedDecimals, stepPrecision)
                        : "".padStart(stepPrecision, "0");
            }
            this.setValuePart("fractionalSecond", newFractionalSecond);
        };
        this.sanitizeValue = (value) => {
            const { hour, minute, second, fractionalSecond } = parseTimeString(value);
            if (fractionalSecond) {
                const sanitizedFractionalSecond = this.sanitizeFractionalSecond(fractionalSecond);
                return `${hour}:${minute}:${second}.${sanitizedFractionalSecond}`;
            }
            return isValidTime(value) && value;
        };
        this.sanitizeFractionalSecond = (fractionalSecond) => fractionalSecond && decimalPlaces(this.step) !== fractionalSecond.length
            ? parseFloat(`0.${fractionalSecond}`).toFixed(decimalPlaces(this.step)).replace("0.", "")
            : fractionalSecond;
        this.secondKeyDownHandler = (event) => {
            const { key } = event;
            if (numberKeys.includes(key)) {
                const keyAsNumber = parseInt(key);
                let newSecond;
                if (isValidNumber(this.second) && this.second.startsWith("0")) {
                    const secondAsNumber = parseInt(this.second);
                    newSecond =
                        secondAsNumber > maxTenthForMinuteAndSecond
                            ? keyAsNumber
                            : `${secondAsNumber}${keyAsNumber}`;
                }
                else {
                    newSecond = keyAsNumber;
                }
                this.setValuePart("second", newSecond);
            }
            else {
                switch (key) {
                    case "Backspace":
                    case "Delete":
                        this.setValuePart("second", null);
                        break;
                    case "ArrowDown":
                        event.preventDefault();
                        this.decrementSecond();
                        break;
                    case "ArrowUp":
                        event.preventDefault();
                        this.incrementSecond();
                        break;
                    case " ":
                        event.preventDefault();
                        break;
                }
            }
        };
        this.secondDownClickHandler = () => {
            this.activeEl = this.secondEl;
            this.secondEl.focus();
            this.decrementSecond();
        };
        this.secondUpClickHandler = () => {
            this.activeEl = this.secondEl;
            this.secondEl.focus();
            this.incrementSecond();
        };
        this.setHourEl = (el) => (this.hourEl = el);
        this.setMeridiemEl = (el) => (this.meridiemEl = el);
        this.setMinuteEl = (el) => (this.minuteEl = el);
        this.setSecondEl = (el) => (this.secondEl = el);
        this.setFractionalSecondEl = (el) => (this.fractionalSecondEl = el);
        this.setValue = (value) => {
            if (isValidTime(value)) {
                const { hour, minute, second, fractionalSecond } = parseTimeString(value);
                const { effectiveLocale: locale, numberingSystem } = this;
                const { localizedHour, localizedHourSuffix, localizedMinute, localizedMinuteSuffix, localizedSecond, localizedDecimalSeparator, localizedFractionalSecond, localizedSecondSuffix, localizedMeridiem, } = localizeTimeStringToParts({ value, locale, numberingSystem });
                this.hour = hour;
                this.minute = minute;
                this.second = second;
                this.fractionalSecond = this.sanitizeFractionalSecond(fractionalSecond);
                this.localizedHour = localizedHour;
                this.localizedHourSuffix = localizedHourSuffix;
                this.localizedMinute = localizedMinute;
                this.localizedMinuteSuffix = localizedMinuteSuffix;
                this.localizedSecond = localizedSecond;
                this.localizedDecimalSeparator = localizedDecimalSeparator;
                this.localizedFractionalSecond = localizedFractionalSecond;
                this.localizedSecondSuffix = localizedSecondSuffix;
                if (localizedMeridiem) {
                    this.localizedMeridiem = localizedMeridiem;
                    this.meridiem = getMeridiem(this.hour);
                    const formatParts = getTimeParts({ value, locale, numberingSystem });
                    this.meridiemOrder = this.getMeridiemOrder(formatParts);
                }
            }
            else {
                this.hour = null;
                this.fractionalSecond = null;
                this.localizedHour = null;
                this.localizedHourSuffix = getLocalizedTimePartSuffix("hour", this.effectiveLocale, this.numberingSystem);
                this.localizedMeridiem = null;
                this.localizedMinute = null;
                this.localizedMinuteSuffix = getLocalizedTimePartSuffix("minute", this.effectiveLocale, this.numberingSystem);
                this.localizedSecond = null;
                this.localizedDecimalSeparator = getLocalizedDecimalSeparator(this.effectiveLocale, this.numberingSystem);
                this.localizedFractionalSecond = null;
                this.localizedSecondSuffix = getLocalizedTimePartSuffix("second", this.effectiveLocale, this.numberingSystem);
                this.meridiem = null;
                this.minute = null;
                this.second = null;
                this.value = null;
            }
        };
        this.setValuePart = (key, value) => {
            const { effectiveLocale: locale, numberingSystem } = this;
            if (key === "meridiem") {
                this.meridiem = value;
                if (isValidNumber(this.hour)) {
                    const hourAsNumber = parseInt(this.hour);
                    switch (value) {
                        case "AM":
                            if (hourAsNumber >= 12) {
                                this.hour = formatTimePart(hourAsNumber - 12);
                            }
                            break;
                        case "PM":
                            if (hourAsNumber < 12) {
                                this.hour = formatTimePart(hourAsNumber + 12);
                            }
                            break;
                    }
                    this.localizedHour = localizeTimePart({
                        value: this.hour,
                        part: "hour",
                        locale,
                        numberingSystem,
                    });
                }
            }
            else if (key === "fractionalSecond") {
                const stepPrecision = decimalPlaces(this.step);
                if (typeof value === "number") {
                    this.fractionalSecond =
                        value === 0 ? "".padStart(stepPrecision, "0") : formatTimePart(value, stepPrecision);
                }
                else {
                    this.fractionalSecond = value;
                }
                this.localizedFractionalSecond = localizeTimePart({
                    value: this.fractionalSecond,
                    part: "fractionalSecond",
                    locale,
                    numberingSystem,
                });
            }
            else {
                this[key] = typeof value === "number" ? formatTimePart(value) : value;
                this[`localized${capitalize(key)}`] = localizeTimePart({
                    value: this[key],
                    part: key,
                    locale,
                    numberingSystem,
                });
            }
            let emit = false;
            let newValue;
            if (this.hour && this.minute) {
                newValue = `${this.hour}:${this.minute}`;
                if (this.showSecond) {
                    newValue = `${newValue}:${this.second ?? "00"}`;
                    if (this.showFractionalSecond && this.fractionalSecond) {
                        newValue = `${newValue}.${this.fractionalSecond}`;
                    }
                }
            }
            else {
                newValue = null;
            }
            if (this.value !== newValue) {
                emit = true;
            }
            this.value = newValue;
            this.localizedMeridiem = this.value
                ? localizeTimeStringToParts({ value: this.value, locale, numberingSystem })
                    ?.localizedMeridiem || null
                : localizeTimePart({ value: this.meridiem, part: "meridiem", locale, numberingSystem });
            if (emit) {
                this.calciteInternalTimePickerChange.emit();
            }
        };
        this.scale = "m";
        this.step = 60;
        this.numberingSystem = undefined;
        this.value = null;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.activeEl = undefined;
        this.effectiveLocale = "";
        this.fractionalSecond = undefined;
        this.hour = undefined;
        this.hourCycle = undefined;
        this.localizedDecimalSeparator = ".";
        this.localizedHour = undefined;
        this.localizedHourSuffix = undefined;
        this.localizedMeridiem = undefined;
        this.localizedFractionalSecond = undefined;
        this.localizedMinute = undefined;
        this.localizedMinuteSuffix = undefined;
        this.localizedSecond = undefined;
        this.localizedSecondSuffix = undefined;
        this.meridiem = undefined;
        this.minute = undefined;
        this.second = undefined;
        this.showFractionalSecond = undefined;
        this.showSecond = undefined;
        this.defaultMessages = undefined;
    }
    stepChange() {
        this.toggleSecond();
    }
    valueWatcher(newValue) {
        this.setValue(newValue);
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleWatcher() {
        this.updateLocale();
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    blurHandler() {
        this.activeEl = undefined;
        this.pointerActivated = false;
        this.calciteInternalTimePickerBlur.emit();
    }
    hostFocusHandler() {
        this.calciteInternalTimePickerFocus.emit();
    }
    keyDownHandler(event) {
        this.pointerActivated = false;
        const { defaultPrevented, key } = event;
        if (defaultPrevented) {
            return;
        }
        switch (this.activeEl) {
            case this.hourEl:
                if (key === "ArrowRight") {
                    this.focusPart("minute");
                    event.preventDefault();
                }
                break;
            case this.minuteEl:
                switch (key) {
                    case "ArrowLeft":
                        this.focusPart("hour");
                        event.preventDefault();
                        break;
                    case "ArrowRight":
                        if (this.step !== 60) {
                            this.focusPart("second");
                            event.preventDefault();
                        }
                        else if (this.hourCycle === "12") {
                            this.focusPart("meridiem");
                            event.preventDefault();
                        }
                        break;
                }
                break;
            case this.secondEl:
                switch (key) {
                    case "ArrowLeft":
                        this.focusPart("minute");
                        event.preventDefault();
                        break;
                    case "ArrowRight":
                        if (this.showFractionalSecond) {
                            this.focusPart("fractionalSecond");
                        }
                        else if (this.hourCycle === "12") {
                            this.focusPart("meridiem");
                            event.preventDefault();
                        }
                        break;
                }
                break;
            case this.fractionalSecondEl:
                switch (key) {
                    case "ArrowLeft":
                        this.focusPart("second");
                        event.preventDefault();
                        break;
                    case "ArrowRight":
                        if (this.hourCycle === "12") {
                            this.focusPart("meridiem");
                            event.preventDefault();
                        }
                        break;
                }
                break;
            case this.meridiemEl:
                switch (key) {
                    case "ArrowLeft":
                        if (this.showFractionalSecond) {
                            this.focusPart("fractionalSecond");
                        }
                        else if (this.step !== 60) {
                            this.focusPart("second");
                            event.preventDefault();
                        }
                        else {
                            this.focusPart("minute");
                            event.preventDefault();
                        }
                        break;
                }
                break;
        }
    }
    pointerDownHandler() {
        this.pointerActivated = true;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Sets focus on the component's first focusable element.
     */
    async setFocus() {
        await componentFocusable(this);
        this.el?.focus();
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    async focusPart(target) {
        await componentFocusable(this);
        this[`${target || "hour"}El`]?.focus();
    }
    toggleSecond() {
        this.showSecond = this.step < 60;
        this.showFractionalSecond = decimalPlaces(this.step) > 0;
    }
    getMeridiemOrder(formatParts) {
        const locale = this.effectiveLocale;
        const isRTLKind = locale === "ar" || locale === "he";
        if (formatParts && !isRTLKind) {
            const index = formatParts.findIndex((parts) => {
                return parts.value === this.localizedMeridiem;
            });
            return index;
        }
        return 0;
    }
    updateLocale() {
        updateMessages(this);
        this.hourCycle = getLocaleHourCycle(this.effectiveLocale, this.numberingSystem);
        this.localizedDecimalSeparator = getLocalizedDecimalSeparator(this.effectiveLocale, this.numberingSystem);
        this.setValue(this.sanitizeValue(this.value));
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectLocalized(this);
        this.updateLocale();
        connectMessages(this);
        this.toggleSecond();
        this.meridiemOrder = this.getMeridiemOrder(getTimeParts({
            value: "0:00:00",
            locale: this.effectiveLocale,
            numberingSystem: this.numberingSystem,
        }));
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    disconnectedCallback() {
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const hourIsNumber = isValidNumber(this.hour);
        const iconScale = getIconScale(this.scale);
        const minuteIsNumber = isValidNumber(this.minute);
        const secondIsNumber = isValidNumber(this.second);
        const fractionalSecondIsNumber = isValidNumber(this.fractionalSecond);
        const showMeridiem = this.hourCycle === "12";
        return (hAsync("div", { class: {
                [CSS$6.timePicker]: true,
                [CSS$6.showMeridiem]: showMeridiem,
                [CSS$6.showSecond]: this.showSecond,
                [CSS$6[`scale-${this.scale}`]]: true,
            }, dir: "ltr" }, hAsync("div", { class: CSS$6.column, role: "group" }, hAsync("span", { "aria-label": this.messages.hourUp, class: {
                [CSS$6.button]: true,
                [CSS$6.buttonHourUp]: true,
                [CSS$6.buttonTopLeft]: true,
            }, onClick: this.hourUpClickHandler, role: "button" }, hAsync("calcite-icon", { icon: "chevron-up", scale: iconScale })), hAsync("span", { "aria-label": this.messages.hour, "aria-valuemax": "23", "aria-valuemin": "1", "aria-valuenow": (hourIsNumber && parseInt(this.hour)) || "0", "aria-valuetext": this.hour, class: {
                [CSS$6.input]: true,
                [CSS$6.hour]: true,
                [CSS$6.inputFocus]: this.activeEl && this.activeEl === this.hourEl,
            }, onClick: this.inputClickHandler, onFocus: this.focusHandler, onKeyDown: this.hourKeyDownHandler, role: "spinbutton", tabIndex: 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setHourEl }, this.localizedHour || "--"), hAsync("span", { "aria-label": this.messages.hourDown, class: {
                [CSS$6.button]: true,
                [CSS$6.buttonHourDown]: true,
                [CSS$6.buttonBottomLeft]: true,
            }, onClick: this.hourDownClickHandler, role: "button" }, hAsync("calcite-icon", { icon: "chevron-down", scale: iconScale }))), hAsync("span", { class: CSS$6.delimiter }, this.localizedHourSuffix), hAsync("div", { class: CSS$6.column, role: "group" }, hAsync("span", { "aria-label": this.messages.minuteUp, class: {
                [CSS$6.button]: true,
                [CSS$6.buttonMinuteUp]: true,
            }, onClick: this.minuteUpClickHandler, role: "button" }, hAsync("calcite-icon", { icon: "chevron-up", scale: iconScale })), hAsync("span", { "aria-label": this.messages.minute, "aria-valuemax": "12", "aria-valuemin": "1", "aria-valuenow": (minuteIsNumber && parseInt(this.minute)) || "0", "aria-valuetext": this.minute, class: {
                [CSS$6.input]: true,
                [CSS$6.minute]: true,
                [CSS$6.inputFocus]: this.activeEl && this.activeEl === this.minuteEl,
            }, onClick: this.inputClickHandler, onFocus: this.focusHandler, onKeyDown: this.minuteKeyDownHandler, role: "spinbutton", tabIndex: 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setMinuteEl }, this.localizedMinute || "--"), hAsync("span", { "aria-label": this.messages.minuteDown, class: {
                [CSS$6.button]: true,
                [CSS$6.buttonMinuteDown]: true,
            }, onClick: this.minuteDownClickHandler, role: "button" }, hAsync("calcite-icon", { icon: "chevron-down", scale: iconScale }))), this.showSecond && hAsync("span", { class: CSS$6.delimiter }, this.localizedMinuteSuffix), this.showSecond && (hAsync("div", { class: CSS$6.column, role: "group" }, hAsync("span", { "aria-label": this.messages.secondUp, class: {
                [CSS$6.button]: true,
                [CSS$6.buttonSecondUp]: true,
            }, onClick: this.secondUpClickHandler, role: "button" }, hAsync("calcite-icon", { icon: "chevron-up", scale: iconScale })), hAsync("span", { "aria-label": this.messages.second, "aria-valuemax": "59", "aria-valuemin": "0", "aria-valuenow": (secondIsNumber && parseInt(this.second)) || "0", "aria-valuetext": this.second, class: {
                [CSS$6.input]: true,
                [CSS$6.second]: true,
                [CSS$6.inputFocus]: this.activeEl && this.activeEl === this.secondEl,
            }, onClick: this.inputClickHandler, onFocus: this.focusHandler, onKeyDown: this.secondKeyDownHandler, role: "spinbutton", tabIndex: 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setSecondEl }, this.localizedSecond || "--"), hAsync("span", { "aria-label": this.messages.secondDown, class: {
                [CSS$6.button]: true,
                [CSS$6.buttonSecondDown]: true,
            }, onClick: this.secondDownClickHandler, role: "button" }, hAsync("calcite-icon", { icon: "chevron-down", scale: iconScale })))), this.showFractionalSecond && (hAsync("span", { class: CSS$6.delimiter }, this.localizedDecimalSeparator)), this.showFractionalSecond && (hAsync("div", { class: CSS$6.column, role: "group" }, hAsync("span", { "aria-label": this.messages.fractionalSecondUp, class: {
                [CSS$6.button]: true,
                [CSS$6.buttonFractionalSecondUp]: true,
            }, onClick: this.fractionalSecondUpClickHandler, role: "button" }, hAsync("calcite-icon", { icon: "chevron-up", scale: iconScale })), hAsync("span", { "aria-label": this.messages.fractionalSecond, "aria-valuemax": "999", "aria-valuemin": "1", "aria-valuenow": (fractionalSecondIsNumber && parseInt(this.fractionalSecond)) || "0", "aria-valuetext": this.localizedFractionalSecond, class: {
                [CSS$6.input]: true,
                [CSS$6.fractionalSecond]: true,
                [CSS$6.inputFocus]: this.activeEl && this.activeEl === this.fractionalSecondEl,
            }, onClick: this.inputClickHandler, onFocus: this.focusHandler, onKeyDown: this.fractionalSecondKeyDownHandler, role: "spinbutton", tabIndex: 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setFractionalSecondEl }, this.localizedFractionalSecond || "--"), hAsync("span", { "aria-label": this.messages.fractionalSecondDown, class: {
                [CSS$6.button]: true,
                [CSS$6.buttonFractionalSecondDown]: true,
            }, onClick: this.fractionalSecondDownClickHandler, role: "button" }, hAsync("calcite-icon", { icon: "chevron-down", scale: iconScale })))), this.localizedSecondSuffix && (hAsync("span", { class: CSS$6.delimiter }, this.localizedSecondSuffix)), showMeridiem && (hAsync("div", { class: {
                [CSS$6.column]: true,
                [CSS$6.meridiemStart]: this.meridiemOrder === 0,
            }, role: "group" }, hAsync("span", { "aria-label": this.messages.meridiemUp, class: {
                [CSS$6.button]: true,
                [CSS$6.buttonMeridiemUp]: true,
                [CSS$6.buttonTopRight]: true,
            }, onClick: this.meridiemUpClickHandler, role: "button" }, hAsync("calcite-icon", { icon: "chevron-up", scale: iconScale })), hAsync("span", { "aria-label": this.messages.meridiem, "aria-valuemax": "2", "aria-valuemin": "1", "aria-valuenow": (this.meridiem === "PM" && "2") || "1", "aria-valuetext": this.meridiem, class: {
                [CSS$6.input]: true,
                [CSS$6.meridiem]: true,
                [CSS$6.inputFocus]: this.activeEl && this.activeEl === this.meridiemEl,
            }, onClick: this.inputClickHandler, onFocus: this.focusHandler, onKeyDown: this.meridiemKeyDownHandler, role: "spinbutton", tabIndex: 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setMeridiemEl }, this.localizedMeridiem || "--"), hAsync("span", { "aria-label": this.messages.meridiemDown, class: {
                [CSS$6.button]: true,
                [CSS$6.buttonMeridiemDown]: true,
                [CSS$6.buttonBottomRight]: true,
            }, onClick: this.meridiemDownClickHandler, role: "button" }, hAsync("calcite-icon", { icon: "chevron-down", scale: iconScale }))))));
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "step": ["stepChange"],
        "value": ["valueWatcher"],
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleWatcher"]
    }; }
    static get style() { return timePickerCss; }
    static get cmpMeta() { return {
        "$flags$": 25,
        "$tagName$": "calcite-time-picker",
        "$members$": {
            "scale": [513],
            "step": [514],
            "numberingSystem": [1, "numbering-system"],
            "value": [1025],
            "messages": [1040],
            "messageOverrides": [1040],
            "activeEl": [32],
            "effectiveLocale": [32],
            "fractionalSecond": [32],
            "hour": [32],
            "hourCycle": [32],
            "localizedDecimalSeparator": [32],
            "localizedHour": [32],
            "localizedHourSuffix": [32],
            "localizedMeridiem": [32],
            "localizedFractionalSecond": [32],
            "localizedMinute": [32],
            "localizedMinuteSuffix": [32],
            "localizedSecond": [32],
            "localizedSecondSuffix": [32],
            "meridiem": [32],
            "minute": [32],
            "second": [32],
            "showFractionalSecond": [32],
            "showSecond": [32],
            "defaultMessages": [32],
            "setFocus": [64]
        },
        "$listeners$": [[0, "blur", "blurHandler"], [0, "focus", "hostFocusHandler"], [0, "keydown", "keyDownHandler"], [1, "pointerdown", "pointerDownHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["scale", "scale"], ["step", "step"]]
    }; }
}

const CSS$5 = {
    container: "container",
    header: "header",
    heading: "heading",
    close: "close",
    imageFrame: "image-frame",
    content: "content",
    info: "info",
};
const ICONS$3 = {
    close: "x",
};
const SLOTS$2 = {
    thumbnail: "thumbnail",
};

const tipCss = "/*!@:host*/.sc-calcite-tip-h{position:relative;margin:1rem;box-sizing:border-box;display:flex;flex-direction:row;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-2);background-color:var(--calcite-color-foreground-1);font-size:var(--calcite-font-size--1);line-height:1rem;color:var(--calcite-color-text-2)}/*!@:host **/.sc-calcite-tip-h *.sc-calcite-tip{box-sizing:border-box}/*!@.container*/.container.sc-calcite-tip{inline-size:100%;padding:1rem}/*!@:host([closed]),\n:host([closed]) .container*/[closed].sc-calcite-tip-h,[closed].sc-calcite-tip-h .container.sc-calcite-tip{display:none}/*!@:host([selected]) .container*/[selected].sc-calcite-tip-h .container.sc-calcite-tip{margin:0px;border-style:none;padding:0px}/*!@.header*/.header.sc-calcite-tip{margin:0px;display:flex;align-content:space-between;align-items:center;fill:var(--calcite-color-text-2);color:var(--calcite-color-text-2)}/*!@.heading*/.heading.sc-calcite-tip{margin:0px;padding:0px;font-weight:var(--calcite-font-weight-medium)}/*!@.header .heading*/.header.sc-calcite-tip .heading.sc-calcite-tip{flex:1 1 auto;padding:0.5rem}/*!@.header*/.header.sc-calcite-tip{margin-block-end:0.5rem}/*!@.header .heading*/.header.sc-calcite-tip .heading.sc-calcite-tip{padding:0px;font-size:var(--calcite-font-size-0);line-height:1.25rem;color:var(--calcite-color-text-1)}/*!@.container[hidden]*/.container[hidden].sc-calcite-tip{display:none}/*!@.content*/.content.sc-calcite-tip{display:flex}/*!@.info*/.info.sc-calcite-tip{padding-block:0px;padding-inline:1rem;inline-size:70%}/*!@.info:only-child*/.info.sc-calcite-tip:only-child{inline-size:100%;padding-inline:0px}/*!@::slotted(p)*/.sc-calcite-tip-s>p{margin-block-start:0px}/*!@::slotted(a)*/.sc-calcite-tip-s>a{outline-color:transparent;color:var(--calcite-color-brand)}/*!@::slotted(a:focus)*/.sc-calcite-tip-s>a:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.image-frame*/.image-frame.sc-calcite-tip{inline-size:25%}/*!@.image-frame img*/.image-frame.sc-calcite-tip img.sc-calcite-tip{max-inline-size:100%}/*!@::slotted(img)*/.sc-calcite-tip-s>img{max-inline-size:100%}/*!@:host([hidden])*/[hidden].sc-calcite-tip-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tip{display:none}";

/**
 * @slot - A slot for adding text and a hyperlink.
 * @slot thumbnail - A slot for adding an HTML image element.
 */
class Tip {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteTipDismiss = createEvent(this, "calciteTipDismiss", 6);
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.hideTip = () => {
            this.closed = true;
            this.calciteTipDismiss.emit();
        };
        this.closed = false;
        this.closeDisabled = false;
        this.heading = undefined;
        this.headingLevel = undefined;
        this.selected = false;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectConditionalSlotComponent(this);
        connectLocalized(this);
        connectMessages(this);
    }
    async componentWillLoad() {
        await setUpMessages(this);
    }
    disconnectedCallback() {
        disconnectConditionalSlotComponent(this);
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderHeader() {
        const { heading, headingLevel, el } = this;
        const parentLevel = el.closest("calcite-tip-manager")?.headingLevel;
        const relativeLevel = parentLevel ? constrainHeadingLevel(parentLevel + 1) : null;
        const level = headingLevel || relativeLevel;
        return heading ? (hAsync("header", { class: CSS$5.header }, hAsync(Heading, { class: CSS$5.heading, level: level }, heading))) : null;
    }
    renderDismissButton() {
        const { closeDisabled, hideTip } = this;
        return !closeDisabled ? (hAsync("calcite-action", { class: CSS$5.close, icon: ICONS$3.close, onClick: hideTip, scale: "l", text: this.messages.close })) : null;
    }
    renderImageFrame() {
        const { el } = this;
        return getSlotted(el, SLOTS$2.thumbnail) ? (hAsync("div", { class: CSS$5.imageFrame, key: "thumbnail" }, hAsync("slot", { name: SLOTS$2.thumbnail }))) : null;
    }
    renderInfoNode() {
        return (hAsync("div", { class: CSS$5.info }, hAsync("slot", null)));
    }
    renderContent() {
        return (hAsync("div", { class: CSS$5.content }, this.renderImageFrame(), this.renderInfoNode()));
    }
    render() {
        return (hAsync(Fragment, null, hAsync("article", { class: CSS$5.container }, this.renderHeader(), this.renderContent()), this.renderDismissButton()));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return tipCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tip",
        "$members$": {
            "closed": [1540],
            "closeDisabled": [516, "close-disabled"],
            "heading": [1],
            "headingLevel": [514, "heading-level"],
            "selected": [516],
            "messages": [1040],
            "messageOverrides": [1040],
            "defaultMessages": [32],
            "effectiveLocale": [32]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["closed", "closed"], ["closeDisabled", "close-disabled"], ["headingLevel", "heading-level"], ["selected", "selected"]]
    }; }
}

const tipGroupCss = "/*!@:host*/.sc-calcite-tip-group-h{box-sizing:border-box;display:block;background-color:var(--calcite-color-foreground-1);font-size:var(--calcite-font-size--1);line-height:1rem;color:var(--calcite-color-text-2)}/*!@::slotted(calcite-tip)*/.sc-calcite-tip-group-s>calcite-tip{margin:0px;border-style:none;max-inline-size:var(--calcite-tip-max-width)}/*!@:host([hidden])*/[hidden].sc-calcite-tip-group-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tip-group{display:none}";

/**
 * @slot - A slot for adding `calcite-tip`s.
 */
class TipGroup {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.groupTitle = undefined;
    }
    render() {
        return hAsync("slot", null);
    }
    static get style() { return tipGroupCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tip-group",
        "$members$": {
            "groupTitle": [1, "group-title"]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": []
    }; }
}

const CSS$4 = {
    header: "header",
    heading: "heading",
    close: "close",
    container: "container",
    tipContainer: "tip-container",
    tipContainerAdvancing: "tip-container--advancing",
    tipContainerRetreating: "tip-container--retreating",
    pagination: "pagination",
    pagePosition: "page-position",
    pageNext: "page-next",
    pagePrevious: "page-previous",
};
const ICONS$2 = {
    chevronLeft: "chevron-left",
    chevronRight: "chevron-right",
    close: "x",
};

const tipManagerCss = "/*!@:host*/.sc-calcite-tip-manager-h{box-sizing:border-box;display:block;background-color:var(--calcite-color-foreground-1);font-size:var(--calcite-font-size--1);line-height:1rem;color:var(--calcite-color-text-2);--calcite-tip-manager-height:19vh}/*!@:host **/.sc-calcite-tip-manager-h *.sc-calcite-tip-manager{box-sizing:border-box}/*!@:host([closed])*/[closed].sc-calcite-tip-manager-h{display:none}/*!@.header*/.header.sc-calcite-tip-manager{margin:0px;display:flex;align-content:space-between;align-items:center;fill:var(--calcite-color-text-2);color:var(--calcite-color-text-2)}/*!@.heading*/.heading.sc-calcite-tip-manager{margin:0px;padding:0px;font-weight:var(--calcite-font-weight-medium)}/*!@.header .heading*/.header.sc-calcite-tip-manager .heading.sc-calcite-tip-manager{flex:1 1 auto;padding:0.5rem}/*!@.header*/.header.sc-calcite-tip-manager{border-width:0px;border-block-end-width:1px;border-style:solid;border-color:var(--calcite-color-border-3);padding-block:0px;padding-inline-end:0px;padding-inline-start:1rem}/*!@.header .heading*/.header.sc-calcite-tip-manager .heading.sc-calcite-tip-manager{padding:0px;font-size:var(--calcite-font-size-1);line-height:1.5rem;font-weight:var(--calcite-font-weight-bold);color:var(--calcite-color-text-1)}/*!@.container*/.container.sc-calcite-tip-manager{position:relative;overflow:hidden;outline-color:transparent;min-block-size:150px}/*!@.container:focus*/.container.sc-calcite-tip-manager:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.tip-container*/.tip-container.sc-calcite-tip-manager{margin-block-start:1px;display:flex;align-items:flex-start;justify-content:center;overflow:auto;padding:1rem;outline-color:transparent;animation-name:none;animation-duration:var(--calcite-animation-timing);block-size:var(--calcite-tip-manager-height)}/*!@.tip-container:focus*/.tip-container.sc-calcite-tip-manager:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@::slotted(calcite-tip)*/.sc-calcite-tip-manager-s>calcite-tip{margin:0px;border-style:none;max-inline-size:var(--calcite-tip-max-width)}/*!@.tip-container--advancing*/.tip-container--advancing.sc-calcite-tip-manager{animation-name:tip-advance}/*!@.tip-container--retreating*/.tip-container--retreating.sc-calcite-tip-manager{animation-name:tip-retreat}/*!@.pagination*/.pagination.sc-calcite-tip-manager{display:flex;align-items:center;justify-content:center;padding-inline:0px;padding-block:0.75rem 0.5rem}/*!@.page-position*/.page-position.sc-calcite-tip-manager{margin-block:0px;margin-inline:0.5rem;font-size:var(--calcite-font-size--2);line-height:1rem}@keyframes tip-advance{0%{opacity:0;transform:translate3d(50px, 0, 0) scale(0.99)}100%{opacity:1;transform:translate3d(0, 0, 0) scale(1)}}@keyframes tip-retreat{0%{opacity:0;transform:translate3d(-50px, 0, 0) scale(0.99)}100%{opacity:1;transform:translate3d(0, 0, 0) scale(1)}}/*!@:host([hidden])*/[hidden].sc-calcite-tip-manager-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tip-manager{display:none}";

/**
 * @slot - A slot for adding `calcite-tip`s.
 */
class TipManager {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteTipManagerClose = createEvent(this, "calciteTipManagerClose", 6);
        this.mutationObserver = createObserver();
        this.hideTipManager = () => {
            this.closed = true;
            this.calciteTipManagerClose.emit();
        };
        this.previousClicked = () => {
            this.previousTip();
        };
        this.nextClicked = () => {
            this.nextTip();
        };
        this.tipManagerKeyDownHandler = (event) => {
            if (event.target !== this.container) {
                return;
            }
            switch (event.key) {
                case "ArrowRight":
                    event.preventDefault();
                    this.nextTip();
                    break;
                case "ArrowLeft":
                    event.preventDefault();
                    this.previousTip();
                    break;
                case "Home":
                    event.preventDefault();
                    this.selectedIndex = 0;
                    break;
                case "End":
                    event.preventDefault();
                    this.selectedIndex = this.total - 1;
                    break;
            }
        };
        this.storeContainerRef = (el) => {
            this.container = el;
        };
        this.closed = false;
        this.headingLevel = undefined;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.selectedIndex = undefined;
        this.tips = undefined;
        this.total = undefined;
        this.direction = undefined;
        this.groupTitle = undefined;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
    }
    closedChangeHandler() {
        this.direction = null;
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    selectedChangeHandler() {
        this.showSelectedTip();
        this.updateGroupTitle();
    }
    async effectiveLocaleChange() {
        await updateMessages(this);
        this.updateGroupTitle();
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectLocalized(this);
        connectMessages(this);
        this.setUpTips();
        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
    }
    async componentWillLoad() {
        await setUpMessages(this);
        this.updateGroupTitle();
    }
    disconnectedCallback() {
        this.mutationObserver?.disconnect();
        disconnectLocalized(this);
        disconnectMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /** Selects the next `calcite-tip` to display. */
    async nextTip() {
        this.direction = "advancing";
        const nextIndex = this.selectedIndex + 1;
        this.selectedIndex = (nextIndex + this.total) % this.total;
    }
    /** Selects the previous `calcite-tip` to display. */
    async previousTip() {
        this.direction = "retreating";
        const previousIndex = this.selectedIndex - 1;
        this.selectedIndex = (previousIndex + this.total) % this.total;
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    setUpTips() {
        const tips = Array.from(this.el.querySelectorAll("calcite-tip"));
        this.total = tips.length;
        if (this.total === 0) {
            return;
        }
        const selectedTip = this.el.querySelector("calcite-tip[selected]");
        this.tips = tips;
        this.selectedIndex = selectedTip ? tips.indexOf(selectedTip) : 0;
        tips.forEach((tip) => {
            tip.closeDisabled = true;
        });
        this.showSelectedTip();
    }
    showSelectedTip() {
        this.tips.forEach((tip, index) => {
            const isSelected = this.selectedIndex === index;
            tip.selected = isSelected;
            tip.hidden = !isSelected;
        });
    }
    updateGroupTitle() {
        if (this.tips) {
            const selectedTip = this.tips[this.selectedIndex];
            const tipParent = selectedTip.closest("calcite-tip-group");
            this.groupTitle = tipParent?.groupTitle || this.messages?.defaultGroupTitle;
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderPagination() {
        const dir = getElementDir(this.el);
        const { selectedIndex, tips, total, messages } = this;
        const nextLabel = messages.next;
        const previousLabel = messages.previous;
        const paginationLabel = messages.defaultPaginationLabel;
        return tips.length > 1 ? (hAsync("footer", { class: CSS$4.pagination }, hAsync("calcite-action", { class: CSS$4.pagePrevious, icon: dir === "ltr" ? ICONS$2.chevronLeft : ICONS$2.chevronRight, onClick: this.previousClicked, scale: "m", text: previousLabel }), hAsync("span", { class: CSS$4.pagePosition }, `${paginationLabel} ${selectedIndex + 1}/${total}`), hAsync("calcite-action", { class: CSS$4.pageNext, icon: dir === "ltr" ? ICONS$2.chevronRight : ICONS$2.chevronLeft, onClick: this.nextClicked, scale: "m", text: nextLabel }))) : null;
    }
    render() {
        const { closed, direction, headingLevel, groupTitle, selectedIndex, messages, total } = this;
        const closeLabel = messages.close;
        if (total === 0) {
            return null;
        }
        return (hAsync("section", { "aria-hidden": toAriaBoolean(closed), class: CSS$4.container, hidden: closed, onKeyDown: this.tipManagerKeyDownHandler, tabIndex: 0,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.storeContainerRef }, hAsync("header", { class: CSS$4.header }, hAsync(Heading, { class: CSS$4.heading, level: headingLevel }, groupTitle), hAsync("calcite-action", { class: CSS$4.close, onClick: this.hideTipManager, scale: "m", text: closeLabel }, hAsync("calcite-icon", { icon: ICONS$2.close, scale: "m" }))), hAsync("div", { class: {
                [CSS$4.tipContainer]: true,
                [CSS$4.tipContainerAdvancing]: !closed && direction === "advancing",
                [CSS$4.tipContainerRetreating]: !closed && direction === "retreating",
            }, key: selectedIndex, tabIndex: 0 }, hAsync("slot", null)), this.renderPagination()));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "closed": ["closedChangeHandler"],
        "messageOverrides": ["onMessagesChange"],
        "selectedIndex": ["selectedChangeHandler"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return tipManagerCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tip-manager",
        "$members$": {
            "closed": [1540],
            "headingLevel": [514, "heading-level"],
            "messages": [1040],
            "messageOverrides": [1040],
            "selectedIndex": [32],
            "tips": [32],
            "total": [32],
            "direction": [32],
            "groupTitle": [32],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "nextTip": [64],
            "previousTip": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["closed", "closed"], ["headingLevel", "heading-level"]]
    }; }
}

const CSS$3 = {
    container: "container",
};
const TOOLTIP_OPEN_DELAY_MS = 300;
const TOOLTIP_CLOSE_DELAY_MS = 500;
const ARIA_DESCRIBED_BY = "aria-describedby";

function getEffectiveReferenceElement(tooltip) {
    const { referenceElement } = tooltip;
    return ((typeof referenceElement === "string" ? queryElementRoots(tooltip, { id: referenceElement }) : referenceElement) ||
        null);
}

class TooltipManager {
    constructor() {
        // --------------------------------------------------------------------------
        //
        //  Private Properties
        //
        // --------------------------------------------------------------------------
        this.registeredElements = new WeakMap();
        this.registeredShadowRootCounts = new WeakMap();
        this.hoverOpenTimeout = null;
        this.hoverCloseTimeout = null;
        this.hoveredTooltip = null;
        this.clickedTooltip = null;
        this.activeTooltip = null;
        this.registeredElementCount = 0;
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.queryTooltip = (composedPath) => {
            const { registeredElements } = this;
            const registeredElement = composedPath.find((pathEl) => registeredElements.has(pathEl));
            return registeredElements.get(registeredElement);
        };
        this.keyDownHandler = (event) => {
            if (event.key === "Escape" && !event.defaultPrevented) {
                const { activeTooltip } = this;
                if (activeTooltip?.open) {
                    this.clearHoverTimeout();
                    this.closeActiveTooltip();
                    const referenceElement = getEffectiveReferenceElement(activeTooltip);
                    if (referenceElement instanceof Element && referenceElement.contains(event.target)) {
                        event.preventDefault();
                    }
                }
            }
        };
        this.pointerMoveHandler = (event) => {
            const composedPath = event.composedPath();
            const { activeTooltip } = this;
            const hoveringActiveTooltip = activeTooltip?.open && composedPath.includes(activeTooltip);
            if (hoveringActiveTooltip) {
                this.clearHoverTimeout();
                return;
            }
            const tooltip = this.queryTooltip(composedPath);
            this.hoveredTooltip = tooltip;
            if (this.isClosableClickedTooltip(tooltip)) {
                return;
            }
            this.clickedTooltip = null;
            if (tooltip) {
                this.openHoveredTooltip(tooltip);
            }
            else if (activeTooltip) {
                this.closeHoveredTooltip();
            }
        };
        this.pointerDownHandler = (event) => {
            if (!isPrimaryPointerButton(event)) {
                return;
            }
            const clickedTooltip = this.queryTooltip(event.composedPath());
            this.clickedTooltip = clickedTooltip;
            if (clickedTooltip?.closeOnClick) {
                this.toggleTooltip(clickedTooltip, false);
                this.clearHoverTimeout();
            }
        };
        this.focusInHandler = (event) => {
            this.queryFocusedTooltip(event, true);
        };
        this.focusOutHandler = (event) => {
            this.queryFocusedTooltip(event, false);
        };
        this.openHoveredTooltip = (tooltip) => {
            this.hoverOpenTimeout = window.setTimeout(() => {
                if (this.hoverOpenTimeout === null) {
                    return;
                }
                this.clearHoverCloseTimeout();
                if (this.activeTooltip === this.hoveredTooltip) {
                    return;
                }
                this.closeActiveTooltip();
                if (tooltip !== this.hoveredTooltip) {
                    return;
                }
                this.toggleTooltip(tooltip, true);
            }, this.activeTooltip ? 0 : TOOLTIP_OPEN_DELAY_MS);
        };
        this.closeHoveredTooltip = () => {
            this.hoverCloseTimeout = window.setTimeout(() => {
                if (this.hoverCloseTimeout === null) {
                    return;
                }
                this.closeActiveTooltip();
            }, TOOLTIP_CLOSE_DELAY_MS);
        };
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    registerElement(referenceEl, tooltip) {
        this.registeredElementCount++;
        this.registeredElements.set(referenceEl, tooltip);
        const shadowRoot = this.getReferenceElShadowRootNode(referenceEl);
        if (shadowRoot) {
            this.registerShadowRoot(shadowRoot);
        }
        if (this.registeredElementCount === 1) {
            this.addListeners();
        }
    }
    unregisterElement(referenceEl) {
        const shadowRoot = this.getReferenceElShadowRootNode(referenceEl);
        if (shadowRoot) {
            this.unregisterShadowRoot(shadowRoot);
        }
        if (this.registeredElements.delete(referenceEl)) {
            this.registeredElementCount--;
        }
        if (this.registeredElementCount === 0) {
            this.removeListeners();
        }
    }
    addShadowListeners(shadowRoot) {
        shadowRoot.addEventListener("focusin", this.focusInHandler, { capture: true });
        shadowRoot.addEventListener("focusout", this.focusOutHandler, { capture: true });
    }
    removeShadowListeners(shadowRoot) {
        shadowRoot.removeEventListener("focusin", this.focusInHandler, { capture: true });
        shadowRoot.removeEventListener("focusout", this.focusOutHandler, { capture: true });
    }
    addListeners() {
        window.addEventListener("keydown", this.keyDownHandler, { capture: true });
        window.addEventListener("pointermove", this.pointerMoveHandler, { capture: true });
        window.addEventListener("pointerdown", this.pointerDownHandler, { capture: true });
        window.addEventListener("focusin", this.focusInHandler, { capture: true });
        window.addEventListener("focusout", this.focusOutHandler, { capture: true });
    }
    removeListeners() {
        window.removeEventListener("keydown", this.keyDownHandler, { capture: true });
        window.removeEventListener("pointermove", this.pointerMoveHandler, { capture: true });
        window.removeEventListener("pointerdown", this.pointerDownHandler, { capture: true });
        window.removeEventListener("focusin", this.focusInHandler, { capture: true });
        window.removeEventListener("focusout", this.focusOutHandler, { capture: true });
    }
    clearHoverOpenTimeout() {
        window.clearTimeout(this.hoverOpenTimeout);
        this.hoverOpenTimeout = null;
    }
    clearHoverCloseTimeout() {
        window.clearTimeout(this.hoverCloseTimeout);
        this.hoverCloseTimeout = null;
    }
    clearHoverTimeout() {
        this.clearHoverOpenTimeout();
        this.clearHoverCloseTimeout();
    }
    closeActiveTooltip() {
        const { activeTooltip } = this;
        if (activeTooltip?.open) {
            this.toggleTooltip(activeTooltip, false);
        }
    }
    toggleFocusedTooltip(tooltip, open) {
        this.closeActiveTooltip();
        if (open) {
            this.clearHoverTimeout();
        }
        this.toggleTooltip(tooltip, open);
    }
    toggleTooltip(tooltip, open) {
        tooltip.open = open;
        this.activeTooltip = open ? tooltip : null;
    }
    queryFocusedTooltip(event, open) {
        const tooltip = this.queryTooltip(event.composedPath());
        if (!tooltip || this.isClosableClickedTooltip(tooltip)) {
            return;
        }
        this.toggleFocusedTooltip(tooltip, open);
    }
    isClosableClickedTooltip(tooltip) {
        return tooltip?.closeOnClick && tooltip === this.clickedTooltip;
    }
    registerShadowRoot(shadowRoot) {
        const { registeredShadowRootCounts } = this;
        const newCount = (registeredShadowRootCounts.get(shadowRoot) ?? 0) + 1;
        if (newCount === 1) {
            this.addShadowListeners(shadowRoot);
        }
        registeredShadowRootCounts.set(shadowRoot, newCount);
    }
    unregisterShadowRoot(shadowRoot) {
        const { registeredShadowRootCounts } = this;
        const newCount = registeredShadowRootCounts.get(shadowRoot) - 1;
        if (newCount === 0) {
            this.removeShadowListeners(shadowRoot);
        }
        registeredShadowRootCounts.set(shadowRoot, newCount);
    }
    getReferenceElShadowRootNode(referenceEl) {
        return referenceEl instanceof Element ? getShadowRootNode(referenceEl) : null;
    }
}

const tooltipCss = "/*!@:host*/.sc-calcite-tooltip-h{--calcite-floating-ui-z-index:var(--calcite-tooltip-z-index, var(--calcite-z-index-tooltip));display:block;position:absolute;z-index:var(--calcite-floating-ui-z-index)}/*!@.calcite-floating-ui-anim*/.calcite-floating-ui-anim.sc-calcite-tooltip{position:relative;transition:var(--calcite-floating-ui-transition);transition-property:transform, visibility, opacity;opacity:0;box-shadow:0 0 16px 0 rgba(0, 0, 0, 0.16);z-index:var(--calcite-z-index);border-radius:0.25rem}/*!@:host([data-placement^=bottom]) .calcite-floating-ui-anim*/[data-placement^=bottom].sc-calcite-tooltip-h .calcite-floating-ui-anim.sc-calcite-tooltip{transform:translateY(-5px)}/*!@:host([data-placement^=top]) .calcite-floating-ui-anim*/[data-placement^=top].sc-calcite-tooltip-h .calcite-floating-ui-anim.sc-calcite-tooltip{transform:translateY(5px)}/*!@:host([data-placement^=left]) .calcite-floating-ui-anim*/[data-placement^=left].sc-calcite-tooltip-h .calcite-floating-ui-anim.sc-calcite-tooltip{transform:translateX(5px)}/*!@:host([data-placement^=right]) .calcite-floating-ui-anim*/[data-placement^=right].sc-calcite-tooltip-h .calcite-floating-ui-anim.sc-calcite-tooltip{transform:translateX(-5px)}/*!@:host([data-placement]) .calcite-floating-ui-anim--active*/[data-placement].sc-calcite-tooltip-h .calcite-floating-ui-anim--active.sc-calcite-tooltip{opacity:1;transform:translate(0)}/*!@:host([calcite-hydrated-hidden])*/[calcite-hydrated-hidden].sc-calcite-tooltip-h{visibility:hidden !important;pointer-events:none}/*!@.calcite-floating-ui-arrow*/.calcite-floating-ui-arrow.sc-calcite-tooltip{pointer-events:none;position:absolute;z-index:calc(var(--calcite-z-index) * -1);fill:var(--calcite-color-foreground-1)}/*!@.calcite-floating-ui-arrow__stroke*/.calcite-floating-ui-arrow__stroke.sc-calcite-tooltip{stroke:var(--calcite-color-border-3)}/*!@.container*/.container.sc-calcite-tooltip{position:relative;overflow:hidden;border-radius:0.25rem;padding-block:0.75rem;padding-inline:1rem;font-size:var(--calcite-font-size--2);line-height:1.375;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1);max-inline-size:20rem;max-block-size:20rem;text-align:start}/*!@.calcite-floating-ui-anim*/.calcite-floating-ui-anim.sc-calcite-tooltip{border-radius:0.25rem;border-width:1px;border-style:solid;border-color:var(--calcite-color-border-3);background-color:var(--calcite-color-foreground-1)}/*!@.arrow::before*/.arrow.sc-calcite-tooltip::before{outline:1px solid var(--calcite-color-border-3)}/*!@:host([hidden])*/[hidden].sc-calcite-tooltip-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tooltip{display:none}";

const manager = new TooltipManager();
/**
 * @slot - A slot for adding text.
 */
class Tooltip {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteTooltipBeforeClose = createEvent(this, "calciteTooltipBeforeClose", 6);
        this.calciteTooltipClose = createEvent(this, "calciteTooltipClose", 6);
        this.calciteTooltipBeforeOpen = createEvent(this, "calciteTooltipBeforeOpen", 6);
        this.calciteTooltipOpen = createEvent(this, "calciteTooltipOpen", 6);
        this.guid = `calcite-tooltip-${guid()}`;
        this.hasLoaded = false;
        this.openTransitionProp = "opacity";
        this.setTransitionEl = (el) => {
            this.transitionEl = el;
        };
        this.setUpReferenceElement = (warn = true) => {
            this.removeReferences();
            this.effectiveReferenceElement = getEffectiveReferenceElement(this.el);
            connectFloatingUI(this, this.effectiveReferenceElement, this.el);
            const { el, referenceElement, effectiveReferenceElement } = this;
            if (warn && referenceElement && !effectiveReferenceElement) {
                console.warn(`${el.tagName}: reference-element id "${referenceElement}" was not found.`, {
                    el,
                });
            }
            this.addReferences();
        };
        this.getId = () => {
            return this.el.id || this.guid;
        };
        this.addReferences = () => {
            const { effectiveReferenceElement } = this;
            if (!effectiveReferenceElement) {
                return;
            }
            const id = this.getId();
            if ("setAttribute" in effectiveReferenceElement) {
                effectiveReferenceElement.setAttribute(ARIA_DESCRIBED_BY, id);
            }
            manager.registerElement(effectiveReferenceElement, this.el);
        };
        this.removeReferences = () => {
            const { effectiveReferenceElement } = this;
            if (!effectiveReferenceElement) {
                return;
            }
            if ("removeAttribute" in effectiveReferenceElement) {
                effectiveReferenceElement.removeAttribute(ARIA_DESCRIBED_BY);
            }
            manager.unregisterElement(effectiveReferenceElement);
        };
        this.closeOnClick = false;
        this.label = undefined;
        this.offsetDistance = defaultOffsetDistance;
        this.offsetSkidding = 0;
        this.open = false;
        this.overlayPositioning = "absolute";
        this.placement = "auto";
        this.referenceElement = undefined;
        this.effectiveReferenceElement = undefined;
        this.floatingLayout = "vertical";
    }
    offsetDistanceOffsetHandler() {
        this.reposition(true);
    }
    offsetSkiddingHandler() {
        this.reposition(true);
    }
    openHandler() {
        onToggleOpenCloseComponent(this);
        this.reposition(true);
    }
    overlayPositioningHandler() {
        this.reposition(true);
    }
    placementHandler() {
        this.reposition(true);
    }
    referenceElementHandler() {
        this.setUpReferenceElement();
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        this.setUpReferenceElement(this.hasLoaded);
        if (this.open) {
            onToggleOpenCloseComponent(this);
        }
        connectFloatingUI(this, this.effectiveReferenceElement, this.el);
    }
    async componentWillLoad() {
        if (this.open) {
            onToggleOpenCloseComponent(this);
        }
    }
    componentDidLoad() {
        if (this.referenceElement && !this.effectiveReferenceElement) {
            this.setUpReferenceElement();
        }
        this.reposition(true);
        this.hasLoaded = true;
    }
    disconnectedCallback() {
        this.removeReferences();
        disconnectFloatingUI(this, this.effectiveReferenceElement, this.el);
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Updates the position of the component.
     *
     * @param delayed
     */
    async reposition(delayed = false) {
        const { el, effectiveReferenceElement, placement, overlayPositioning, offsetDistance, offsetSkidding, arrowEl, } = this;
        return reposition(this, {
            floatingEl: el,
            referenceEl: effectiveReferenceElement,
            overlayPositioning,
            placement,
            offsetDistance,
            offsetSkidding,
            arrowEl,
            type: "tooltip",
        }, delayed);
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    onBeforeOpen() {
        this.calciteTooltipBeforeOpen.emit();
    }
    onOpen() {
        this.calciteTooltipOpen.emit();
    }
    onBeforeClose() {
        this.calciteTooltipBeforeClose.emit();
    }
    onClose() {
        this.calciteTooltipClose.emit();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    render() {
        const { effectiveReferenceElement, label, open, floatingLayout } = this;
        const displayed = effectiveReferenceElement && open;
        const hidden = !displayed;
        return (hAsync(Host, { "aria-hidden": toAriaBoolean(hidden), "aria-label": label, "aria-live": "polite", "calcite-hydrated-hidden": hidden, id: this.getId(), role: "tooltip" }, hAsync("div", { class: {
                [FloatingCSS.animation]: true,
                [FloatingCSS.animationActive]: displayed,
            },
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.setTransitionEl }, hAsync(FloatingArrow, { floatingLayout: floatingLayout,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (arrowEl) => (this.arrowEl = arrowEl) }), hAsync("div", { class: CSS$3.container }, hAsync("slot", null)))));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "offsetDistance": ["offsetDistanceOffsetHandler"],
        "offsetSkidding": ["offsetSkiddingHandler"],
        "open": ["openHandler"],
        "overlayPositioning": ["overlayPositioningHandler"],
        "placement": ["placementHandler"],
        "referenceElement": ["referenceElementHandler"]
    }; }
    static get style() { return tooltipCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tooltip",
        "$members$": {
            "closeOnClick": [516, "close-on-click"],
            "label": [1],
            "offsetDistance": [514, "offset-distance"],
            "offsetSkidding": [514, "offset-skidding"],
            "open": [516],
            "overlayPositioning": [513, "overlay-positioning"],
            "placement": [513],
            "referenceElement": [1, "reference-element"],
            "effectiveReferenceElement": [32],
            "floatingLayout": [32],
            "reposition": [64]
        },
        "$listeners$": undefined,
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["closeOnClick", "close-on-click"], ["offsetDistance", "offset-distance"], ["offsetSkidding", "offset-skidding"], ["open", "open"], ["overlayPositioning", "overlay-positioning"], ["placement", "placement"]]
    }; }
}

function isTreeItem(element) {
    return element?.tagName === "CALCITE-TREE-ITEM";
}
function getTraversableItems(root) {
    return Array.from(root.querySelectorAll("calcite-tree-item:not([disabled])")).filter((item) => {
        let currentItem = item;
        while (currentItem !== root && currentItem !== undefined) {
            const parent = currentItem.parentElement;
            const traversable = !isTreeItem(parent) || !parent.hasChildren || parent.expanded;
            if (!traversable) {
                return false;
            }
            currentItem = currentItem.parentElement;
        }
        return true;
    });
}

const treeCss = "/*!@:host*/.sc-calcite-tree-h{display:block}/*!@:host(:focus)*/.sc-calcite-tree-h:focus{outline:2px solid transparent;outline-offset:2px}/*!@:host([hidden])*/[hidden].sc-calcite-tree-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tree{display:none}";

/**
 * @slot - A slot for `calcite-tree-item` elements.
 */
class Tree {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteTreeSelect = createEvent(this, "calciteTreeSelect", 6);
        this.keyDownHandler = (event) => {
            if (this.child) {
                return;
            }
            const root = this.el;
            const target = event.target;
            const supportedKeys = ["ArrowRight", "ArrowDown", "ArrowLeft", "ArrowUp", "Home", "End", "Tab"];
            if (!(isTreeItem(target) && this.el.contains(target)) || !supportedKeys.includes(event.key)) {
                return;
            }
            const traversableItems = getTraversableItems(root);
            if (event.key === "Tab") {
                // root tabindex will be restored when blurred/focused
                traversableItems.forEach((item) => (item.tabIndex = -1));
                return;
            }
            if (event.key === "ArrowDown") {
                const currentItemIndex = traversableItems.indexOf(target);
                const nextItem = traversableItems[currentItemIndex + 1];
                nextItem?.focus();
                event.preventDefault();
                return;
            }
            if (event.key === "ArrowUp") {
                const currentItemIndex = traversableItems.indexOf(target);
                const previousItem = traversableItems[currentItemIndex - 1];
                previousItem?.focus();
                event.preventDefault();
                return;
            }
            if (event.key === "ArrowLeft") {
                if (target.hasChildren && target.expanded) {
                    target.expanded = false;
                    event.preventDefault();
                    return;
                }
                const rootToItemPath = traversableItems.slice(0, traversableItems.indexOf(target)).reverse();
                const parentItem = rootToItemPath.find((item) => item.depth === target.depth - 1);
                parentItem?.focus();
                event.preventDefault();
                return;
            }
            if (event.key === "ArrowRight") {
                if (!target.disabled && target.hasChildren) {
                    if (!target.expanded) {
                        target.expanded = true;
                        event.preventDefault();
                    }
                    else {
                        const currentItemIndex = traversableItems.indexOf(target);
                        const nextItem = traversableItems[currentItemIndex + 1];
                        nextItem?.focus();
                        event.preventDefault();
                    }
                }
                return;
            }
            if (event.key === "Home") {
                const firstNode = traversableItems.shift();
                if (firstNode) {
                    firstNode.focus();
                    event.preventDefault();
                }
                return;
            }
            if (event.key === "End") {
                const lastNode = traversableItems.pop();
                if (lastNode) {
                    lastNode.focus();
                    event.preventDefault();
                }
                return;
            }
        };
        this.lines = false;
        this.child = undefined;
        this.scale = "m";
        this.selectionMode = "single";
        this.selectedItems = [];
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentWillRender() {
        const parent = this.el.parentElement?.closest("calcite-tree");
        this.lines = parent ? parent.lines : this.lines;
        this.scale = parent ? parent.scale : this.scale;
        this.selectionMode = parent ? parent.selectionMode : this.selectionMode;
        this.child = !!parent;
    }
    render() {
        return (hAsync(Host, { "aria-multiselectable": this.child
                ? undefined
                : (this.selectionMode === "multiple" || this.selectionMode === "multichildren").toString(), onKeyDown: this.keyDownHandler, role: !this.child ? "tree" : undefined, tabIndex: this.getRootTabIndex() }, hAsync("slot", null)));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    onFocus() {
        if (!this.child) {
            const focusTarget = this.el.querySelector("calcite-tree-item[selected]:not([disabled])") || this.el.querySelector("calcite-tree-item:not([disabled])");
            focusElement(focusTarget);
        }
    }
    onFocusIn(event) {
        const focusedFromRootOrOutsideTree = event.relatedTarget === this.el || !this.el.contains(event.relatedTarget);
        if (focusedFromRootOrOutsideTree) {
            // gives user the ability to tab into external elements (modifying tabindex property will not work in firefox)
            this.el.removeAttribute("tabindex");
        }
    }
    onFocusOut(event) {
        const willFocusOutsideTree = !this.el.contains(event.relatedTarget);
        if (willFocusOutsideTree) {
            this.el.tabIndex = this.getRootTabIndex();
        }
    }
    onInternalTreeItemSelect(event) {
        if (this.child) {
            return;
        }
        const target = event.target;
        const childItems = nodeListToArray(target.querySelectorAll("calcite-tree-item"));
        event.preventDefault();
        event.stopPropagation();
        if (this.selectionMode === "ancestors") {
            this.updateAncestorTree(event);
            return;
        }
        const isNoneSelectionMode = this.selectionMode === "none";
        const shouldSelect = this.selectionMode !== null &&
            (!target.hasChildren ||
                (target.hasChildren &&
                    (this.selectionMode === "children" || this.selectionMode === "multichildren")));
        const shouldDeselectAllChildren = this.selectionMode === "multichildren" && target.hasChildren;
        const shouldModifyToCurrentSelection = !isNoneSelectionMode &&
            event.detail.modifyCurrentSelection &&
            (this.selectionMode === "multiple" || this.selectionMode === "multichildren");
        const shouldClearCurrentSelection = !shouldModifyToCurrentSelection &&
            (((this.selectionMode === "single" || this.selectionMode === "multiple") &&
                childItems.length <= 0) ||
                this.selectionMode === "children" ||
                this.selectionMode === "multichildren");
        const shouldUpdateExpand = ["multiple", "none", "single", "single-persist"].includes(this.selectionMode) &&
            target.hasChildren;
        const targetItems = [];
        if (shouldSelect) {
            targetItems.push(target);
        }
        if (shouldClearCurrentSelection) {
            const selectedItems = nodeListToArray(this.el.querySelectorAll("calcite-tree-item[selected]"));
            selectedItems.forEach((treeItem) => {
                if (!targetItems.includes(treeItem)) {
                    treeItem.selected = false;
                }
            });
        }
        if (shouldUpdateExpand &&
            ["multiple", "none", "single", "single-persist"].includes(this.selectionMode)) {
            target.expanded = !target.expanded;
        }
        if (shouldDeselectAllChildren) {
            childItems.forEach((item) => {
                item.selected = false;
                if (item.hasChildren) {
                    item.expanded = false;
                }
            });
        }
        if (shouldModifyToCurrentSelection) {
            window.getSelection().removeAllRanges();
        }
        if (shouldModifyToCurrentSelection && target.selected) {
            targetItems.forEach((treeItem) => {
                if (!treeItem.disabled) {
                    treeItem.selected = false;
                }
            });
        }
        else if (!isNoneSelectionMode) {
            targetItems.forEach((treeItem) => {
                if (!treeItem.disabled) {
                    treeItem.selected = true;
                }
            });
        }
        this.selectedItems = isNoneSelectionMode
            ? []
            : nodeListToArray(this.el.querySelectorAll("calcite-tree-item")).filter((i) => i.selected);
        this.calciteTreeSelect.emit();
        event.stopPropagation();
    }
    updateAncestorTree(event) {
        const item = event.target;
        const updateItem = event.detail.updateItem;
        if (item.disabled || (item.indeterminate && !updateItem)) {
            return;
        }
        const ancestors = [];
        let parent = item.parentElement.closest("calcite-tree-item");
        while (parent) {
            ancestors.push(parent);
            parent = parent.parentElement.closest("calcite-tree-item");
        }
        const childItems = Array.from(item.querySelectorAll("calcite-tree-item:not([disabled])"));
        const childItemsWithNoChildren = childItems.filter((child) => !child.hasChildren);
        const childItemsWithChildren = childItems.filter((child) => child.hasChildren);
        let futureSelected;
        if (updateItem) {
            futureSelected = item.hasChildren ? !(item.selected || item.indeterminate) : !item.selected;
        }
        else {
            futureSelected = item.selected;
        }
        childItemsWithNoChildren.forEach((el) => {
            el.selected = futureSelected;
            el.indeterminate = false;
        });
        function updateItemState(childItems, item) {
            const selected = childItems.filter((child) => child.selected);
            const unselected = childItems.filter((child) => !child.selected);
            item.selected = selected.length === childItems.length;
            item.indeterminate = selected.length > 0 && unselected.length > 0;
        }
        childItemsWithChildren.reverse().forEach((el) => {
            const directChildItems = Array.from(el.querySelectorAll(":scope > calcite-tree > calcite-tree-item"));
            updateItemState(directChildItems, el);
        });
        if (updateItem) {
            if (item.hasChildren) {
                updateItemState(childItems, item);
            }
            else {
                item.selected = futureSelected;
                item.indeterminate = false;
            }
        }
        ancestors.forEach((ancestor) => {
            const descendants = nodeListToArray(ancestor.querySelectorAll("calcite-tree-item"));
            const activeDescendants = descendants.filter((el) => el.selected);
            if (activeDescendants.length === 0) {
                ancestor.selected = false;
                ancestor.indeterminate = false;
                return;
            }
            const indeterminate = activeDescendants.length < descendants.length;
            ancestor.indeterminate = indeterminate;
            ancestor.selected = !indeterminate;
        });
        this.selectedItems = nodeListToArray(this.el.querySelectorAll("calcite-tree-item")).filter((i) => i.selected);
        if (updateItem) {
            this.calciteTreeSelect.emit();
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    getRootTabIndex() {
        return !this.child ? 0 : -1;
    }
    get el() { return getElement(this); }
    static get style() { return treeCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tree",
        "$members$": {
            "lines": [1540],
            "child": [1540],
            "scale": [1537],
            "selectionMode": [1537, "selection-mode"],
            "selectedItems": [1040]
        },
        "$listeners$": [[0, "focus", "onFocus"], [0, "focusin", "onFocusIn"], [0, "focusout", "onFocusOut"], [0, "calciteInternalTreeItemSelect", "onInternalTreeItemSelect"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["lines", "lines"], ["child", "child"], ["scale", "scale"], ["selectionMode", "selection-mode"]]
    }; }
}

const CSS$2 = {
    actionsEnd: "actions-end",
    checkboxLabel: "checkbox-label",
    checkbox: "checkbox",
    chevron: "chevron",
    nodeContainer: "node-container",
    childrenContainer: "children-container",
    bulletPointIcon: "bullet-point",
    checkmarkIcon: "checkmark",
    itemExpanded: "item--expanded",
    iconStart: "icon-start",
    nodeAndActionsContainer: "node-actions-container",
};
const SLOTS$1 = {
    actionsEnd: "actions-end",
    children: "children",
};
const ICONS$1 = {
    bulletPoint: "bullet-point",
    checkmark: "check",
    chevronRight: "chevron-right",
    blank: "blank",
};

const treeItemCss = "/*!@:host([disabled])*/[disabled].sc-calcite-tree-item-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-tree-item-h *.sc-calcite-tree-item,.sc-calcite-tree-item-h[disabled].sc-calcite-tree-item-s>*,.sc-calcite-tree-item-h[disabled] .sc-calcite-tree-item-s>*{pointer-events:none}/*!@:host*/.sc-calcite-tree-item-h{display:block;max-inline-size:100%;cursor:pointer;color:var(--calcite-color-text-3)}/*!@.node-actions-container*/.node-actions-container.sc-calcite-tree-item{display:flex}/*!@:host([calcite-hydrated-hidden])*/[calcite-hydrated-hidden].sc-calcite-tree-item-h{visibility:hidden !important;pointer-events:none}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-tree-item-h[disabled] .sc-calcite-tree-item-s>[calcite-hydrated][disabled],[disabled].sc-calcite-tree-item-h [calcite-hydrated][disabled].sc-calcite-tree-item{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-tree-item{display:contents}/*!@:host([scale=s])*/[scale=s].sc-calcite-tree-item-h{font-size:var(--calcite-font-size--2);line-height:1rem}/*!@:host([scale=s]) .node-actions-container*/[scale=s].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item{min-block-size:1.5rem}/*!@:host([scale=s]) .node-actions-container .node-container .checkbox,\n:host([scale=s]) .node-actions-container .node-container .chevron,\n:host([scale=s]) .node-actions-container .node-container .checkmark,\n:host([scale=s]) .node-actions-container .node-container .bullet-point*/[scale=s].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .checkbox.sc-calcite-tree-item,[scale=s].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .chevron.sc-calcite-tree-item,[scale=s].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .checkmark.sc-calcite-tree-item,[scale=s].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .bullet-point.sc-calcite-tree-item{margin-inline:0.25rem}/*!@:host([scale=s]) .node-actions-container .node-container .icon-start*/[scale=s].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .icon-start.sc-calcite-tree-item{margin-inline:0.75rem}/*!@:host([scale=m])*/[scale=m].sc-calcite-tree-item-h{font-size:var(--calcite-font-size--1);line-height:1rem}/*!@:host([scale=m]) .node-actions-container*/[scale=m].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item{min-block-size:2rem}/*!@:host([scale=m]) .node-actions-container .node-container .checkbox,\n:host([scale=m]) .node-actions-container .node-container .chevron,\n:host([scale=m]) .node-actions-container .node-container .checkmark,\n:host([scale=m]) .node-actions-container .node-container .bullet-point*/[scale=m].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .checkbox.sc-calcite-tree-item,[scale=m].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .chevron.sc-calcite-tree-item,[scale=m].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .checkmark.sc-calcite-tree-item,[scale=m].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .bullet-point.sc-calcite-tree-item{margin-inline:0.5rem}/*!@:host([scale=m]) .node-actions-container .node-container .icon-start*/[scale=m].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .icon-start.sc-calcite-tree-item{margin-inline:0.75rem}/*!@:host([scale=l])*/[scale=l].sc-calcite-tree-item-h{font-size:var(--calcite-font-size-0);line-height:1.25rem}/*!@:host([scale=l]) .node-actions-container*/[scale=l].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item{min-block-size:2.75rem}/*!@:host([scale=l]) .node-actions-container .node-container .checkbox,\n:host([scale=l]) .node-actions-container .node-container .chevron,\n:host([scale=l]) .node-actions-container .node-container .checkmark,\n:host([scale=l]) .node-actions-container .node-container .bullet-point*/[scale=l].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .checkbox.sc-calcite-tree-item,[scale=l].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .chevron.sc-calcite-tree-item,[scale=l].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .checkmark.sc-calcite-tree-item,[scale=l].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .bullet-point.sc-calcite-tree-item{margin-inline:0.75rem}/*!@:host([scale=l]) .node-actions-container .node-container .icon-start*/[scale=l].sc-calcite-tree-item-h .node-actions-container.sc-calcite-tree-item .node-container.sc-calcite-tree-item .icon-start.sc-calcite-tree-item{margin-inline:0.75rem}/*!@:host([lines]) .children-container:after*/[lines].sc-calcite-tree-item-h .children-container.sc-calcite-tree-item:after{position:absolute;inset-block-start:0px;z-index:var(--calcite-z-index);inline-size:1px;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;block-size:96%;content:\"\";background-color:var(--calcite-color-border-2)}/*!@:host(:not([lines])) .node-container:after*/.sc-calcite-tree-item-h:not([lines]) .node-container.sc-calcite-tree-item:after{display:none}/*!@::slotted(*)*/.sc-calcite-tree-item-s>*{min-inline-size:0px;max-inline-size:100%;overflow-wrap:break-word;color:inherit;text-decoration:none !important}/*!@::slotted(*):hover*/.sc-calcite-tree-item-s>*:hover{text-decoration:none !important}/*!@::slotted(a)*/.sc-calcite-tree-item-s>a{inline-size:100%;text-decoration-line:none}/*!@:host*/.sc-calcite-tree-item-h{outline:2px solid transparent;outline-offset:2px}/*!@:host .node-container*/.sc-calcite-tree-item-h .node-container.sc-calcite-tree-item{outline-color:transparent}/*!@:host:focus .node-container, :host:active .node-container*/.sc-calcite-tree-item-h:focus .node-container.sc-calcite-tree-item,.sc-calcite-tree-item-h:active .node-container.sc-calcite-tree-item{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@:host(:focus:not([disabled])) .node-container*/.sc-calcite-tree-item-h:focus:not([disabled]) .node-container.sc-calcite-tree-item{outline:2px solid transparent;outline-offset:2px;outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.actions-end*/.actions-end.sc-calcite-tree-item{display:flex;flex-direction:row;align-items:center;align-self:stretch}/*!@.checkbox*/.checkbox.sc-calcite-tree-item{line-height:0}/*!@.checkbox-label*/.checkbox-label.sc-calcite-tree-item{pointer-events:none;display:flex;align-items:center}/*!@.checkbox:focus*/.checkbox.sc-calcite-tree-item:focus{outline:2px solid transparent;outline-offset:2px}/*!@.children-container*/.children-container.sc-calcite-tree-item{position:relative;block-size:0px;transform-origin:top;overflow:hidden;opacity:0;margin-inline-start:1.25rem;transform:scaleY(0);transition:var(--calcite-animation-timing) cubic-bezier(0.215, 0.44, 0.42, 0.88), opacity var(--calcite-animation-timing) cubic-bezier(0.215, 0.44, 0.42, 0.88), all var(--calcite-animation-timing) ease-in-out}/*!@.item--expanded > .children-container*/.item--expanded.sc-calcite-tree-item>.children-container.sc-calcite-tree-item{overflow:visible;opacity:1;transform:none;block-size:auto}/*!@.node-container*/.node-container.sc-calcite-tree-item{position:relative;display:flex;min-inline-size:0px;flex-grow:1;align-items:center}/*!@.node-container .checkmark,\n.node-container .bullet-point*/.node-container.sc-calcite-tree-item .checkmark.sc-calcite-tree-item,.node-container.sc-calcite-tree-item .bullet-point.sc-calcite-tree-item{opacity:0;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;color:var(--calcite-color-border-1)}/*!@.node-container:hover .checkmark,\n.node-container:hover .bullet-point,\n:host([selected]) .node-container:hover .checkmark,\n:host([selected]) .node-container:hover .bullet-point,\n:host(:focus:not([disabled])) .node-container .checkmark,\n:host(:focus:not([disabled])) .node-container .bullet-point*/.node-container.sc-calcite-tree-item:hover .checkmark.sc-calcite-tree-item,.node-container.sc-calcite-tree-item:hover .bullet-point.sc-calcite-tree-item,[selected].sc-calcite-tree-item-h .node-container.sc-calcite-tree-item:hover .checkmark.sc-calcite-tree-item,[selected].sc-calcite-tree-item-h .node-container.sc-calcite-tree-item:hover .bullet-point.sc-calcite-tree-item,.sc-calcite-tree-item-h:focus:not([disabled]) .node-container.sc-calcite-tree-item .checkmark.sc-calcite-tree-item,.sc-calcite-tree-item-h:focus:not([disabled]) .node-container.sc-calcite-tree-item .bullet-point.sc-calcite-tree-item{opacity:1}/*!@:host([selected]) .node-container,\n:host([selected]) .node-container:hover*/[selected].sc-calcite-tree-item-h .node-container.sc-calcite-tree-item,[selected].sc-calcite-tree-item-h .node-container.sc-calcite-tree-item:hover{font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1)}/*!@:host([selected]) .node-container .bullet-point,\n:host([selected]) .node-container .checkmark,\n:host([selected]) .node-container:hover .bullet-point,\n:host([selected]) .node-container:hover .checkmark*/[selected].sc-calcite-tree-item-h .node-container.sc-calcite-tree-item .bullet-point.sc-calcite-tree-item,[selected].sc-calcite-tree-item-h .node-container.sc-calcite-tree-item .checkmark.sc-calcite-tree-item,[selected].sc-calcite-tree-item-h .node-container.sc-calcite-tree-item:hover .bullet-point.sc-calcite-tree-item,[selected].sc-calcite-tree-item-h .node-container.sc-calcite-tree-item:hover .checkmark.sc-calcite-tree-item{opacity:1;color:var(--calcite-color-brand)}/*!@:host([selection-mode=none]:not([has-children])):host([scale=s]) .node-container*/[selection-mode=none].sc-calcite-tree-item-h:not([has-children]).sc-calcite-tree-item-h([scale=s]) .node-container.sc-calcite-tree-item{padding-inline-start:0.5rem}/*!@:host([selection-mode=none]:not([has-children])):host([scale=m]) .node-container*/[selection-mode=none].sc-calcite-tree-item-h:not([has-children]).sc-calcite-tree-item-h([scale=m]) .node-container.sc-calcite-tree-item{padding-inline-start:1rem}/*!@:host([selection-mode=none]:not([has-children])):host([scale=l]) .node-container*/[selection-mode=none].sc-calcite-tree-item-h:not([has-children]).sc-calcite-tree-item-h([scale=l]) .node-container.sc-calcite-tree-item{padding-inline-start:1.5rem}/*!@:host(:not([has-children])):host([scale=s]) .node-container[data-selection-mode=ancestors] .checkbox*/.sc-calcite-tree-item-h:not([has-children]).sc-calcite-tree-item-h([scale=s]) .node-container[data-selection-mode=ancestors].sc-calcite-tree-item .checkbox.sc-calcite-tree-item{padding-inline-start:1.25rem}/*!@:host(:not([has-children])):host([scale=m]) .node-container[data-selection-mode=ancestors] .checkbox*/.sc-calcite-tree-item-h:not([has-children]).sc-calcite-tree-item-h([scale=m]) .node-container[data-selection-mode=ancestors].sc-calcite-tree-item .checkbox.sc-calcite-tree-item{padding-inline-start:1.5rem}/*!@:host(:not([has-children])):host([scale=l]) .node-container[data-selection-mode=ancestors] .checkbox*/.sc-calcite-tree-item-h:not([has-children]).sc-calcite-tree-item-h([scale=l]) .node-container[data-selection-mode=ancestors].sc-calcite-tree-item .checkbox.sc-calcite-tree-item{padding-inline-start:1.75rem}/*!@:host([has-children]) .node-container[data-selection-mode=ancestors] .checkbox*/[has-children].sc-calcite-tree-item-h .node-container[data-selection-mode=ancestors].sc-calcite-tree-item .checkbox.sc-calcite-tree-item{margin-inline-start:0}/*!@:host([has-children]) .node-container .bullet-point,\n:host([has-children]) .node-container .checkmark*/[has-children].sc-calcite-tree-item-h .node-container.sc-calcite-tree-item .bullet-point.sc-calcite-tree-item,[has-children].sc-calcite-tree-item-h .node-container.sc-calcite-tree-item .checkmark.sc-calcite-tree-item{display:none}/*!@.chevron*/.chevron.sc-calcite-tree-item{position:relative;align-self:center;color:var(--calcite-color-text-3);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;flex:0 0 auto;transform:rotate(0deg)}/*!@.calcite--rtl .chevron*/.calcite--rtl.sc-calcite-tree-item .chevron.sc-calcite-tree-item{transform:rotate(180deg)}/*!@.item--expanded .node-container > .chevron*/.item--expanded.sc-calcite-tree-item .node-container.sc-calcite-tree-item>.chevron.sc-calcite-tree-item{transform:rotate(90deg)}/*!@:host([selected]) .checkmark,\n:host([selected]) .bullet-point*/[selected].sc-calcite-tree-item-h .checkmark.sc-calcite-tree-item,[selected].sc-calcite-tree-item-h .bullet-point.sc-calcite-tree-item{color:var(--calcite-color-brand)}/*!@:host([hidden])*/[hidden].sc-calcite-tree-item-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-tree-item{display:none}";

/**
 * @slot - A slot for adding text.
 * @slot children - A slot for adding nested `calcite-tree` elements.
 * @slot actions-end - A slot for adding actions to the end of the component. It is recommended to use two or fewer actions.
 */
class TreeItem {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteInternalTreeItemSelect = createEvent(this, "calciteInternalTreeItemSelect", 6);
        this.iconClickHandler = (event) => {
            event.stopPropagation();
            this.expanded = !this.expanded;
        };
        this.childrenClickHandler = (event) => event.stopPropagation();
        this.userChangedValue = false;
        this.updateParentIsExpanded = (el, expanded) => {
            const items = getSlotted(el, SLOTS$1.children, {
                all: true,
                selector: "calcite-tree-item",
            });
            items.forEach((item) => (item.parentExpanded = expanded));
        };
        this.actionsEndSlotChangeHandler = (event) => {
            this.hasEndActions = slotChangeHasAssignedElement(event);
        };
        this.disabled = false;
        this.expanded = false;
        this.iconFlipRtl = undefined;
        this.iconStart = undefined;
        this.selected = false;
        this.parentExpanded = false;
        this.depth = -1;
        this.hasChildren = null;
        this.lines = undefined;
        this.scale = undefined;
        this.indeterminate = false;
        this.selectionMode = undefined;
        this.hasEndActions = false;
        this.updateAfterInitialRender = false;
    }
    expandedHandler(newValue) {
        this.updateParentIsExpanded(this.el, newValue);
    }
    handleSelectedChange(value) {
        if (this.selectionMode === "ancestors" && !this.userChangedValue) {
            if (value) {
                this.indeterminate = false;
            }
            this.calciteInternalTreeItemSelect.emit({
                modifyCurrentSelection: true,
                updateItem: false,
            });
        }
    }
    getSelectionMode() {
        this.isSelectionMultiLike =
            this.selectionMode === "multiple" || this.selectionMode === "multichildren";
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.parentTreeItem = this.el.parentElement?.closest("calcite-tree-item");
        if (this.parentTreeItem) {
            const { expanded } = this.parentTreeItem;
            this.updateParentIsExpanded(this.parentTreeItem, expanded);
        }
        connectConditionalSlotComponent(this);
        connectInteractive(this);
    }
    disconnectedCallback() {
        disconnectConditionalSlotComponent(this);
        disconnectInteractive(this);
    }
    componentWillRender() {
        this.hasChildren = !!this.el.querySelector("calcite-tree");
        this.depth = 0;
        let parentTree = this.el.closest("calcite-tree");
        if (!parentTree) {
            return;
        }
        this.selectionMode = parentTree.selectionMode;
        this.scale = parentTree.scale || "m";
        this.lines = parentTree.lines;
        let nextParentTree;
        while (parentTree) {
            nextParentTree = parentTree.parentElement?.closest("calcite-tree");
            if (nextParentTree === parentTree) {
                break;
            }
            else {
                parentTree = nextParentTree;
                this.depth = this.depth + 1;
            }
        }
    }
    componentWillLoad() {
        requestAnimationFrame(() => (this.updateAfterInitialRender = true));
    }
    componentDidLoad() {
        this.updateAncestorTree();
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    render() {
        const rtl = getElementDir(this.el) === "rtl";
        const showBulletPoint = this.selectionMode === "single" || this.selectionMode === "children";
        const showCheckmark = this.selectionMode === "multiple" || this.selectionMode === "multichildren";
        const showBlank = this.selectionMode === "none" && !this.hasChildren;
        const chevron = this.hasChildren ? (hAsync("calcite-icon", { class: {
                [CSS$2.chevron]: true,
                [CSS_UTILITY.rtl]: rtl,
            }, "data-test-id": "icon", icon: ICONS$1.chevronRight, onClick: this.iconClickHandler, scale: getIconScale(this.scale) })) : null;
        const defaultSlotNode = hAsync("slot", { key: "default-slot" });
        const checkbox = this.selectionMode === "ancestors" ? (hAsync("label", { class: CSS$2.checkboxLabel, key: "checkbox-label" }, hAsync("calcite-checkbox", { checked: this.selected, class: CSS$2.checkbox, "data-test-id": "checkbox", indeterminate: this.hasChildren && this.indeterminate, scale: this.scale, tabIndex: -1 }), defaultSlotNode)) : null;
        const selectedIcon = showBulletPoint
            ? ICONS$1.bulletPoint
            : showCheckmark
                ? ICONS$1.checkmark
                : showBlank
                    ? ICONS$1.blank
                    : null;
        const itemIndicator = selectedIcon ? (hAsync("calcite-icon", { class: {
                [CSS$2.bulletPointIcon]: selectedIcon === ICONS$1.bulletPoint,
                [CSS$2.checkmarkIcon]: selectedIcon === ICONS$1.checkmark,
                [CSS_UTILITY.rtl]: rtl,
            }, icon: selectedIcon, scale: getIconScale(this.scale) })) : null;
        const hidden = !(this.parentExpanded || this.depth === 1);
        const isExpanded = this.updateAfterInitialRender && this.expanded;
        const { hasEndActions } = this;
        const slotNode = (hAsync("slot", { key: "actionsEndSlot", name: SLOTS$1.actionsEnd, onSlotchange: this.actionsEndSlotChangeHandler }));
        const iconStartEl = (hAsync("calcite-icon", { class: CSS$2.iconStart, flipRtl: this.iconFlipRtl === "start" || this.iconFlipRtl === "both", icon: this.iconStart, scale: getIconScale(this.scale) }));
        return (hAsync(Host, { "aria-expanded": this.hasChildren ? toAriaBoolean(isExpanded) : undefined, "aria-hidden": toAriaBoolean(hidden), "aria-selected": this.selected ? "true" : showCheckmark ? "false" : undefined, "calcite-hydrated-hidden": hidden, role: "treeitem", tabIndex: this.disabled ? -1 : 0 }, hAsync(InteractiveContainer, { disabled: this.disabled }, hAsync("div", { class: { [CSS$2.itemExpanded]: isExpanded } }, hAsync("div", { class: CSS$2.nodeAndActionsContainer }, hAsync("div", { class: {
                [CSS$2.nodeContainer]: true,
                [CSS_UTILITY.rtl]: rtl,
            }, "data-selection-mode": this.selectionMode,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: (el) => (this.defaultSlotWrapper = el) }, chevron, itemIndicator, this.iconStart ? iconStartEl : null, checkbox ? checkbox : defaultSlotNode), hAsync("div", { class: CSS$2.actionsEnd, hidden: !hasEndActions, ref: (el) => (this.actionSlotWrapper = el) }, slotNode)), hAsync("div", { class: {
                [CSS$2.childrenContainer]: true,
                [CSS_UTILITY.rtl]: rtl,
            }, "data-test-id": "calcite-tree-children", onClick: this.childrenClickHandler, role: this.hasChildren ? "group" : undefined }, hAsync("slot", { name: SLOTS$1.children }))))));
    }
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    onClick(event) {
        if (this.disabled || this.isActionEndEvent(event)) {
            return;
        }
        // Solve for if the item is clicked somewhere outside the slotted anchor.
        // Anchor is triggered anywhere you click
        const [link] = filterDirectChildren(this.el, "a");
        if (link && event.composedPath()[0].tagName.toLowerCase() !== "a") {
            const target = link.target === "" ? "_self" : link.target;
            window.open(link.href, target);
        }
        this.calciteInternalTreeItemSelect.emit({
            modifyCurrentSelection: this.selectionMode === "ancestors" || this.isSelectionMultiLike,
            updateItem: true,
        });
        this.userChangedValue = true;
    }
    keyDownHandler(event) {
        if (this.isActionEndEvent(event) || event.defaultPrevented) {
            return;
        }
        switch (event.key) {
            case " ":
                this.userChangedValue = true;
                this.calciteInternalTreeItemSelect.emit({
                    modifyCurrentSelection: this.isSelectionMultiLike,
                    updateItem: true,
                });
                event.preventDefault();
                break;
            case "Enter":
                // activates a node, i.e., performs its default action. For parent nodes, one possible default action is to open or close the node. In single-select trees where selection does not follow focus (see note below), the default action is typically to select the focused node.
                const link = Array.from(this.el.children).find((el) => el.matches("a"));
                this.userChangedValue = true;
                if (link) {
                    link.click();
                    this.selected = true;
                }
                else {
                    this.calciteInternalTreeItemSelect.emit({
                        modifyCurrentSelection: this.isSelectionMultiLike,
                        updateItem: true,
                    });
                }
                event.preventDefault();
        }
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    isActionEndEvent(event) {
        const composedPath = event.composedPath();
        return composedPath.includes(this.actionSlotWrapper);
    }
    /**
     * This is meant to be called in `componentDidLoad` in order to take advantage of the hierarchical component lifecycle
     * and help check for item selection as items are initialized
     *
     * @private
     */
    updateAncestorTree() {
        const parentItem = this.parentTreeItem;
        if (this.selectionMode !== "ancestors" || !parentItem) {
            return;
        }
        if (this.selected) {
            const parentTree = this.el.parentElement;
            const siblings = Array.from(parentTree?.children);
            const selectedSiblings = siblings.filter((child) => child.selected);
            if (siblings.length === selectedSiblings.length) {
                parentItem.selected = true;
                parentItem.indeterminate = false;
            }
            else if (selectedSiblings.length > 0) {
                parentItem.indeterminate = true;
            }
            const childItems = Array.from(this.el.querySelectorAll("calcite-tree-item:not([disabled])"));
            childItems.forEach((item) => {
                item.selected = true;
                item.indeterminate = false;
            });
        }
        else if (this.indeterminate) {
            const parentItem = this.parentTreeItem;
            parentItem.indeterminate = true;
        }
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "expanded": ["expandedHandler"],
        "selected": ["handleSelectedChange"],
        "selectionMode": ["getSelectionMode"]
    }; }
    static get style() { return treeItemCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-tree-item",
        "$members$": {
            "disabled": [516],
            "expanded": [1540],
            "iconFlipRtl": [513, "icon-flip-rtl"],
            "iconStart": [513, "icon-start"],
            "selected": [1540],
            "parentExpanded": [4, "parent-expanded"],
            "depth": [1538],
            "hasChildren": [1540, "has-children"],
            "lines": [1540],
            "scale": [1537],
            "indeterminate": [516],
            "selectionMode": [1537, "selection-mode"],
            "hasEndActions": [32],
            "updateAfterInitialRender": [32]
        },
        "$listeners$": [[0, "click", "onClick"], [0, "keydown", "keyDownHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["expanded", "expanded"], ["iconFlipRtl", "icon-flip-rtl"], ["iconStart", "icon-start"], ["selected", "selected"], ["depth", "depth"], ["hasChildren", "has-children"], ["lines", "lines"], ["scale", "scale"], ["indeterminate", "indeterminate"], ["selectionMode", "selection-mode"]]
    }; }
}

const CSS$1 = {
    container: "container",
    handle: "handle",
};
var ICON_TYPES;
(function (ICON_TYPES) {
    ICON_TYPES["grip"] = "grip";
})(ICON_TYPES || (ICON_TYPES = {}));

function getScreenReaderText(item, status, valueList) {
    const { items, messages } = valueList;
    const total = items.length;
    const position = getItemIndex(valueList, item) + 1;
    const template = status === "idle"
        ? messages.dragHandleIdle
        : status === "active"
            ? messages.dragHandleActive
            : status === "change"
                ? messages.dragHandleChange
                : messages.dragHandleCommit;
    return replacePlaceholders(template, item.label, position, total);
}
function getHandleAndItemElement(event) {
    const handle = event
        .composedPath()
        .find((item) => item.dataset?.jsHandle !== undefined);
    const item = event
        .composedPath()
        .find((item) => item.tagName?.toLowerCase() === "calcite-value-list-item");
    return { handle, item };
}
function replacePlaceholders(text, label, position, total) {
    const replacePosition = text.replace("{position}", position.toString());
    const replaceLabel = replacePosition.replace("{itemLabel}", label);
    return replaceLabel.replace("{total}", total.toString());
}

const valueListCss = "/*!@:host([disabled])*/[disabled].sc-calcite-value-list-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-value-list-h *.sc-calcite-value-list,.sc-calcite-value-list-h[disabled].sc-calcite-value-list-s>*,.sc-calcite-value-list-h[disabled] .sc-calcite-value-list-s>*{pointer-events:none}/*!@:host*/.sc-calcite-value-list-h{position:relative;box-sizing:border-box;display:flex;flex-shrink:0;flex-grow:0;flex-direction:column;align-items:stretch;background-color:transparent;font-size:var(--calcite-font-size--1);color:var(--calcite-color-text-2)}/*!@:host **/.sc-calcite-value-list-h *.sc-calcite-value-list{box-sizing:border-box}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-value-list-h[disabled] .sc-calcite-value-list-s>[calcite-hydrated][disabled],[disabled].sc-calcite-value-list-h [calcite-hydrated][disabled].sc-calcite-value-list{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-value-list{display:contents}/*!@calcite-value-list-item:last-of-type*/calcite-value-list-item.sc-calcite-value-list:last-of-type{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@:host([filter-enabled]) header*/[filter-enabled].sc-calcite-value-list-h header.sc-calcite-value-list{margin-block-end:0.25rem;display:flex;align-items:center;justify-content:flex-end;background-color:var(--calcite-color-foreground-1);--tw-shadow:0 1px 0 var(--calcite-color-border-3);--tw-shadow-colored:0 1px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@:host([filter-enabled]) header.sticky-pos*/[filter-enabled].sc-calcite-value-list-h header.sticky-pos.sc-calcite-value-list{position:sticky;inset-block-start:0px;z-index:var(--calcite-z-index-sticky)}/*!@calcite-filter*/calcite-filter.sc-calcite-value-list{margin-block-end:1px}/*!@.assistive-text*/.assistive-text.sc-calcite-value-list{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}/*!@:host([hidden])*/[hidden].sc-calcite-value-list-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-value-list{display:none}";

/**
 * @deprecated Use the `list` component instead.
 * @slot - A slot for adding `calcite-value-list-item` elements. List items are displayed as a vertical list.
 * @slot menu-actions - A slot for adding a button and menu combination for performing actions, such as sorting.
 */
class ValueList {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteListChange = createEvent(this, "calciteListChange", 6);
        this.calciteListOrderChange = createEvent(this, "calciteListOrderChange", 6);
        this.calciteListFilter = createEvent(this, "calciteListFilter", 6);
        this.lastSelectedItem = null;
        this.mutationObserver = createObserver("mutation", mutationObserverCallback.bind(this));
        this.handleSelector = `.${CSS$1.handle}`;
        this.dragSelector = "calcite-value-list-item";
        this.setFilterEl = (el) => {
            this.filterEl = el;
        };
        this.setFilteredItems = (filteredItems) => {
            this.filteredItems = filteredItems;
        };
        this.deselectRemovedItems = deselectRemovedItems.bind(this);
        this.deselectSiblingItems = deselectSiblingItems.bind(this);
        this.selectSiblings = selectSiblings.bind(this);
        this.handleFilter = handleFilter.bind(this);
        this.handleFilterEvent = handleFilterEvent.bind(this);
        this.getItemData = getItemData.bind(this);
        this.keyDownHandler = (event) => {
            if (event.defaultPrevented) {
                return;
            }
            const { handle, item } = getHandleAndItemElement(event);
            if (handle && !item.handleActivated && event.key === " ") {
                this.updateScreenReaderText(getScreenReaderText(item, "commit", this));
            }
            if (!handle || !item.handleActivated) {
                keyDownHandler.call(this, event);
                return;
            }
            event.preventDefault();
            const { items } = this;
            if (event.key === " ") {
                this.updateScreenReaderText(getScreenReaderText(item, "active", this));
            }
            if ((event.key !== "ArrowUp" && event.key !== "ArrowDown") || items.length <= 1) {
                return;
            }
            const { el } = this;
            const nextIndex = moveItemIndex(this, item, event.key === "ArrowUp" ? "up" : "down");
            if (nextIndex === items.length - 1) {
                el.appendChild(item);
            }
            else {
                const itemAtNextIndex = el.children[nextIndex];
                const insertionReferenceItem = itemAtNextIndex === item.nextElementSibling
                    ? itemAtNextIndex.nextElementSibling
                    : itemAtNextIndex;
                el.insertBefore(item, insertionReferenceItem);
            }
            this.items = this.getItems();
            this.calciteListOrderChange.emit(this.items.map(({ value }) => value));
            requestAnimationFrame(() => focusElement(handle));
            item.handleActivated = true;
            this.updateHandleAriaLabel(handle, getScreenReaderText(item, "change", this));
        };
        this.storeAssistiveEl = (el) => {
            this.assistiveTextEl = el;
        };
        this.handleFocusIn = (event) => {
            const { handle, item } = getHandleAndItemElement(event);
            if (!item?.handleActivated && item && handle) {
                this.updateHandleAriaLabel(handle, getScreenReaderText(item, "idle", this));
            }
        };
        this.disabled = false;
        this.canPull = undefined;
        this.canPut = undefined;
        this.dragEnabled = false;
        this.filteredItems = [];
        this.filteredData = [];
        this.filterEnabled = false;
        this.filterPlaceholder = undefined;
        this.filterText = undefined;
        this.group = undefined;
        this.loading = false;
        this.multiple = false;
        this.selectionFollowsFocus = false;
        this.messageOverrides = undefined;
        this.messages = undefined;
        this.dataForFilter = [];
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
        this.selectedValues = new Map();
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    effectiveLocaleChange() {
        updateMessages(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        if (dragActive(this)) {
            return;
        }
        connectInteractive(this);
        connectLocalized(this);
        connectMessages(this);
        initialize.call(this);
        initializeObserver.call(this);
        this.setUpSorting();
    }
    async componentWillLoad() {
        setUpLoadableComponent(this);
        await setUpMessages(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
        handleInitialFilter.call(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    disconnectedCallback() {
        if (dragActive(this)) {
            return;
        }
        disconnectInteractive(this);
        disconnectSortableComponent(this);
        disconnectLocalized(this);
        disconnectMessages(this);
        cleanUpObserver.call(this);
    }
    calciteListFocusOutHandler(event) {
        calciteListFocusOutHandler.call(this, event);
    }
    calciteListItemRemoveHandler(event) {
        removeItem.call(this, event);
    }
    calciteListItemChangeHandler(event) {
        calciteListItemChangeHandler.call(this, event);
    }
    calciteInternalListItemPropsChangeHandler(event) {
        event.stopPropagation();
        this.setUpFilter();
    }
    calciteInternalListItemValueChangeHandler(event) {
        calciteInternalListItemValueChangeHandler.call(this, event);
        event.stopPropagation();
    }
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    onGlobalDragStart() {
        cleanUpObserver.call(this);
    }
    onGlobalDragEnd() {
        initializeObserver.call(this);
    }
    onDragEnd() { }
    onDragStart() { }
    onDragSort() {
        this.items = Array.from(this.el.querySelectorAll("calcite-value-list-item"));
        const values = this.items.map((item) => item.value);
        this.calciteListOrderChange.emit(values);
    }
    getItems() {
        return Array.from(this.el.querySelectorAll("calcite-value-list-item"));
    }
    setUpItems() {
        setUpItems.call(this, "calcite-value-list-item");
        this.setUpSorting();
    }
    setUpFilter() {
        if (this.filterEnabled) {
            this.dataForFilter = this.getItemData();
        }
    }
    setUpSorting() {
        const { dragEnabled } = this;
        if (!dragEnabled) {
            return;
        }
        connectSortableComponent(this);
    }
    handleBlur() {
        if (this.dragEnabled) {
            this.updateScreenReaderText("");
        }
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /** Returns the component's selected items. */
    async getSelectedItems() {
        return this.selectedValues;
    }
    /**
     * Sets focus on the component's first focusable element.
     *
     * @param focusId
     */
    async setFocus(focusId) {
        await componentFocusable(this);
        return setFocus.call(this, focusId);
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    getIconType() {
        let type = null;
        if (this.dragEnabled) {
            type = ICON_TYPES.grip;
        }
        return type;
    }
    updateScreenReaderText(text) {
        this.assistiveTextEl.textContent = text;
    }
    updateHandleAriaLabel(handleElement, text) {
        handleElement.ariaLabel = text;
    }
    handleValueListItemBlur(event) {
        const { item, handle } = event.detail;
        if (!item?.handleActivated && item) {
            this.updateHandleAriaLabel(handle, getScreenReaderText(item, "idle", this));
        }
        event.stopPropagation();
    }
    render() {
        return (hAsync(List, { onBlur: this.handleBlur, onFocusin: this.handleFocusIn, onKeyDown: this.keyDownHandler, props: this }));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "effectiveLocale": ["effectiveLocaleChange"]
    }; }
    static get style() { return valueListCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-value-list",
        "$members$": {
            "disabled": [516],
            "canPull": [16],
            "canPut": [16],
            "dragEnabled": [516, "drag-enabled"],
            "filteredItems": [1040],
            "filteredData": [1040],
            "filterEnabled": [516, "filter-enabled"],
            "filterPlaceholder": [513, "filter-placeholder"],
            "filterText": [1537, "filter-text"],
            "group": [513],
            "loading": [516],
            "multiple": [516],
            "selectionFollowsFocus": [516, "selection-follows-focus"],
            "messageOverrides": [1040],
            "messages": [1040],
            "dataForFilter": [32],
            "defaultMessages": [32],
            "effectiveLocale": [32],
            "selectedValues": [32],
            "getSelectedItems": [64],
            "setFocus": [64]
        },
        "$listeners$": [[0, "focusout", "calciteListFocusOutHandler"], [0, "calciteListItemRemove", "calciteListItemRemoveHandler"], [0, "calciteListItemChange", "calciteListItemChangeHandler"], [0, "calciteInternalListItemPropsChange", "calciteInternalListItemPropsChangeHandler"], [0, "calciteInternalListItemValueChange", "calciteInternalListItemValueChangeHandler"], [0, "calciteValueListItemDragHandleBlur", "handleValueListItemBlur"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["disabled", "disabled"], ["dragEnabled", "drag-enabled"], ["filterEnabled", "filter-enabled"], ["filterPlaceholder", "filter-placeholder"], ["filterText", "filter-text"], ["group", "group"], ["loading", "loading"], ["multiple", "multiple"], ["selectionFollowsFocus", "selection-follows-focus"]]
    }; }
}

const ICONS = {
    drag: "drag",
};
const SLOTS = {
    actionsEnd: "actions-end",
    actionsStart: "actions-start",
};

const valueListItemCss = "/*!@:host([disabled])*/[disabled].sc-calcite-value-list-item-h{cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}/*!@:host([disabled]) *,\n:host([disabled]) ::slotted(*)*/[disabled].sc-calcite-value-list-item-h *.sc-calcite-value-list-item,.sc-calcite-value-list-item-h[disabled].sc-calcite-value-list-item-s>*,.sc-calcite-value-list-item-h[disabled] .sc-calcite-value-list-item-s>*{pointer-events:none}/*!@:host*/.sc-calcite-value-list-item-h{margin-block-end:1px;box-sizing:border-box;display:flex;background-color:var(--calcite-color-foreground-1);font-size:var(--calcite-font-size--1);color:var(--calcite-color-text-2);--tw-shadow:0 1px 0 var(--calcite-color-border-3);--tw-shadow-colored:0 1px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);transition:background-color var(--calcite-animation-timing), box-shadow var(--calcite-animation-timing)}/*!@:host **/.sc-calcite-value-list-item-h *.sc-calcite-value-list-item{box-sizing:border-box}/*!@calcite-pick-list-item*/calcite-pick-list-item.sc-calcite-value-list-item{position:relative;margin:0px;flex-grow:1;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@:host([active]),\n:host([selected])*/[active].sc-calcite-value-list-item-h,[selected].sc-calcite-value-list-item-h{--tw-shadow:0 0 0 1px var(--calcite-color-brand);--tw-shadow-colored:0 0 0 1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}/*!@.handle*/.handle.sc-calcite-value-list-item{display:flex;cursor:move;align-items:center;justify-content:center;border-style:none;background-color:transparent;padding-block:0px;padding-inline:0.25rem;color:var(--calcite-color-border-input);outline-color:transparent}/*!@.handle:hover*/.handle.sc-calcite-value-list-item:hover{background-color:var(--calcite-color-foreground-2);color:var(--calcite-color-text-1)}/*!@.handle:focus*/.handle.sc-calcite-value-list-item:focus{outline:2px solid var(--calcite-ui-focus-color, var(--calcite-color-brand-hover, var(--calcite-color-brand)));outline-offset:calc(\n            -2px *\n            calc(\n              1 -\n              2 * clamp(\n                0,\n                var(--calcite-offset-invert-focus),\n                1\n              )\n            )\n          )}/*!@.handle--activated*/.handle--activated.sc-calcite-value-list-item{background-color:var(--calcite-color-foreground-3);color:var(--calcite-color-text-1)}/*!@.handle calcite-icon*/.handle.sc-calcite-value-list-item calcite-icon.sc-calcite-value-list-item{color:inherit}/*!@:host([disabled]) ::slotted([calcite-hydrated][disabled]),\n:host([disabled]) [calcite-hydrated][disabled]*/.sc-calcite-value-list-item-h[disabled] .sc-calcite-value-list-item-s>[calcite-hydrated][disabled],[disabled].sc-calcite-value-list-item-h [calcite-hydrated][disabled].sc-calcite-value-list-item{opacity:1}/*!@.interaction-container*/.interaction-container.sc-calcite-value-list-item{display:contents}/*!@:host([hidden])*/[hidden].sc-calcite-value-list-item-h{display:none}/*!@[hidden]*/[hidden].sc-calcite-value-list-item{display:none}";

/**
 * @deprecated Use the `list` component instead.
 * @slot actions-end - A slot for adding `calcite-action`s or content to the end side of the component.
 * @slot actions-start - A slot for adding `calcite-action`s or content to the start side of the component.
 */
class ValueListItem {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.calciteListItemChange = createEvent(this, "calciteListItemChange", 6);
        this.calciteListItemRemove = createEvent(this, "calciteListItemRemove", 7);
        this.calciteValueListItemDragHandleBlur = createEvent(this, "calciteValueListItemDragHandleBlur", 6);
        this.pickListItem = null;
        this.guid = `calcite-value-list-item-${guid()}`;
        // --------------------------------------------------------------------------
        //
        //  Private Methods
        //
        // --------------------------------------------------------------------------
        this.getPickListRef = (el) => (this.pickListItem = el);
        this.handleKeyDown = (event) => {
            if (event.key === " ") {
                this.handleActivated = !this.handleActivated;
            }
        };
        this.handleBlur = () => {
            this.handleActivated = false;
            this.calciteValueListItemDragHandleBlur.emit({ item: this.el, handle: this.handleEl });
        };
        this.handleSelectChange = (event) => {
            this.selected = event.detail.selected;
        };
        this.description = undefined;
        this.disabled = false;
        this.deselectDisabled = false;
        this.nonInteractive = false;
        this.handleActivated = false;
        this.icon = null;
        this.iconFlipRtl = false;
        this.label = undefined;
        this.metadata = undefined;
        this.removable = false;
        this.selected = false;
        this.value = undefined;
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    // --------------------------------------------------------------------------
    connectedCallback() {
        connectConditionalSlotComponent(this);
        connectInteractive(this);
    }
    disconnectedCallback() {
        disconnectConditionalSlotComponent(this);
        disconnectInteractive(this);
    }
    componentWillLoad() {
        setUpLoadableComponent(this);
    }
    componentDidLoad() {
        setComponentLoaded(this);
    }
    componentDidRender() {
        updateHostInteraction(this);
    }
    // --------------------------------------------------------------------------
    //
    //  Public Methods
    //
    // --------------------------------------------------------------------------
    /**
     * Toggle the selection state. By default this won't trigger an event.
     * The first argument allows the value to be coerced, rather than swapping values.
     *
     * @param coerce
     */
    async toggleSelected(coerce) {
        this.pickListItem.toggleSelected(coerce);
    }
    /** Set focus on the component. */
    async setFocus() {
        await componentFocusable(this);
        return this.pickListItem?.setFocus();
    }
    calciteListItemChangeHandler(event) {
        // adjust item payload from wrapped item before bubbling
        event.detail.item = this.el;
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    // --------------------------------------------------------------------------
    renderActionsEnd() {
        const { el } = this;
        const hasActionsEnd = getSlotted(el, SLOTS.actionsEnd);
        return hasActionsEnd ? (hAsync("slot", { name: SLOTS.actionsEnd, slot: SLOTS$b.actionsEnd })) : null;
    }
    renderActionsStart() {
        const { el } = this;
        const hasActionsStart = getSlotted(el, SLOTS.actionsStart);
        return hasActionsStart ? (hAsync("slot", { name: SLOTS.actionsStart, slot: SLOTS$b.actionsStart })) : null;
    }
    renderHandle() {
        const { icon, iconFlipRtl } = this;
        if (icon === ICON_TYPES$1.grip) {
            return (hAsync("span", { class: {
                    [CSS$A.handle]: true,
                    [CSS$A.handleActivated]: this.handleActivated,
                }, "data-js-handle": true, onBlur: this.handleBlur, onKeyDown: this.handleKeyDown, role: "button", tabindex: "0",
                // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
                ref: (el) => (this.handleEl = el) }, hAsync("calcite-icon", { flipRtl: iconFlipRtl, icon: ICONS.drag, scale: "s" })));
        }
    }
    render() {
        return (hAsync(Host, { id: this.el.id || this.guid }, hAsync(InteractiveContainer, { disabled: this.disabled }, this.renderHandle(), hAsync("calcite-pick-list-item", { description: this.description, deselectDisabled: this.deselectDisabled, disabled: this.disabled, label: this.label, metadata: this.metadata, nonInteractive: this.nonInteractive, onCalciteListItemChange: this.handleSelectChange, removable: this.removable, selected: this.selected, value: this.value,
            // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
            ref: this.getPickListRef }, this.renderActionsStart(), this.renderActionsEnd()))));
    }
    get el() { return getElement(this); }
    static get style() { return valueListItemCss; }
    static get cmpMeta() { return {
        "$flags$": 9,
        "$tagName$": "calcite-value-list-item",
        "$members$": {
            "description": [513],
            "disabled": [516],
            "deselectDisabled": [4, "deselect-disabled"],
            "nonInteractive": [516, "non-interactive"],
            "handleActivated": [1028, "handle-activated"],
            "icon": [513],
            "iconFlipRtl": [516, "icon-flip-rtl"],
            "label": [513],
            "metadata": [16],
            "removable": [516],
            "selected": [1540],
            "value": [8],
            "toggleSelected": [64],
            "setFocus": [64]
        },
        "$listeners$": [[0, "calciteListItemChange", "calciteListItemChangeHandler"]],
        "$lazyBundleId$": "-",
        "$attrsToReflect$": [["description", "description"], ["disabled", "disabled"], ["nonInteractive", "non-interactive"], ["icon", "icon"], ["iconFlipRtl", "icon-flip-rtl"], ["label", "label"], ["removable", "removable"], ["selected", "selected"]]
    }; }
}

registerComponents([
  Accordion,
  AccordionItem,
  Action,
  ActionBar,
  ActionGroup,
  ActionMenu,
  ActionPad,
  Alert,
  Avatar,
  Block,
  BlockSection,
  Button,
  CalciteMenu,
  CalciteMenuItem,
  CalciteNavigation,
  CalciteNavigationLogo,
  CalciteNavigationUser,
  Card,
  CardGroup,
  Checkbox,
  Chip,
  ChipGroup,
  ColorPicker,
  ColorPickerHexInput,
  ColorPickerSwatch,
  Combobox,
  ComboboxItem,
  ComboboxItemGroup,
  DatePicker,
  DatePickerDay,
  DatePickerMonth,
  DatePickerMonthHeader,
  Dropdown,
  DropdownGroup,
  DropdownItem,
  Fab,
  Filter,
  Flow,
  FlowItem,
  Graph,
  Handle,
  Icon,
  InlineEditable,
  Input,
  InputDatePicker,
  InputMessage,
  InputNumber,
  InputText,
  InputTimePicker,
  InputTimeZone,
  Label,
  Link,
  List$1,
  ListItem,
  ListItemGroup,
  Loader,
  Meter,
  Modal,
  Notice,
  Option,
  OptionGroup,
  Pagination,
  Panel,
  PickList,
  PickListGroup,
  PickListItem,
  Popover,
  Progress,
  RadioButton,
  RadioButtonGroup,
  Rating,
  Scrim,
  SegmentedControl,
  SegmentedControlItem,
  Select,
  Sheet,
  Shell,
  ShellCenterRow,
  ShellPanel,
  Slider,
  SortableList,
  SplitButton,
  Stack,
  Stepper,
  StepperItem,
  Switch,
  Tab,
  TabNav,
  TabTitle,
  Table,
  TableCell,
  TableHeader,
  TableRow,
  Tabs,
  TextArea,
  Tile,
  TileGroup,
  TileSelect,
  TileSelectGroup,
  TimePicker,
  Tip,
  TipGroup,
  TipManager,
  Tooltip,
  Tree,
  TreeItem,
  ValueList,
  ValueListItem,
]);

// Arabic [ar]
var months$5 = 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_');
var symbolMap = {
  1: '١',
  2: '٢',
  3: '٣',
  4: '٤',
  5: '٥',
  6: '٦',
  7: '٧',
  8: '٨',
  9: '٩',
  0: '٠'
};
var numberMap = {
  '١': '1',
  '٢': '2',
  '٣': '3',
  '٤': '4',
  '٥': '5',
  '٦': '6',
  '٧': '7',
  '٨': '8',
  '٩': '9',
  '٠': '0'
};
var locale$M = {
  name: 'ar',
  weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
  weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
  weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
  months: months$5,
  monthsShort: months$5,
  weekStart: 6,
  meridiem: function meridiem(hour) {
    return hour > 12 ? 'م' : 'ص';
  },
  relativeTime: {
    future: 'بعد %s',
    past: 'منذ %s',
    s: 'ثانية واحدة',
    m: 'دقيقة واحدة',
    mm: '%d دقائق',
    h: 'ساعة واحدة',
    hh: '%d ساعات',
    d: 'يوم واحد',
    dd: '%d أيام',
    M: 'شهر واحد',
    MM: '%d أشهر',
    y: 'عام واحد',
    yy: '%d أعوام'
  },
  preparse: function preparse(string) {
    return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
      return numberMap[match];
    }).replace(/،/g, ',');
  },
  postformat: function postformat(string) {
    return string.replace(/\d/g, function (match) {
      return symbolMap[match];
    }).replace(/,/g, '،');
  },
  ordinal: function ordinal(n) {
    return n;
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'D/‏M/‏YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY HH:mm',
    LLLL: 'dddd D MMMM YYYY HH:mm'
  }
};
dayjs.locale(locale$M, null, true);

var ar = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$M
});

// Bulgarian [bg]
var locale$L = {
  name: 'bg',
  weekdays: 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
  weekdaysShort: 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
  weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
  months: 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
  monthsShort: 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
  weekStart: 1,
  ordinal: function ordinal(n) {
    var last2Digits = n % 100;

    if (last2Digits > 10 && last2Digits < 20) {
      return n + "-\u0442\u0438";
    }

    var lastDigit = n % 10;

    if (lastDigit === 1) {
      return n + "-\u0432\u0438";
    } else if (lastDigit === 2) {
      return n + "-\u0440\u0438";
    } else if (lastDigit === 7 || lastDigit === 8) {
      return n + "-\u043C\u0438";
    }

    return n + "-\u0442\u0438";
  },
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'D.MM.YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY H:mm',
    LLLL: 'dddd, D MMMM YYYY H:mm'
  },
  relativeTime: {
    future: 'след %s',
    past: 'преди %s',
    s: 'няколко секунди',
    m: 'минута',
    mm: '%d минути',
    h: 'час',
    hh: '%d часа',
    d: 'ден',
    dd: '%d дена',
    M: 'месец',
    MM: '%d месеца',
    y: 'година',
    yy: '%d години'
  }
};
dayjs.locale(locale$L, null, true);

var bg = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$L
});

// Bosnian [bs]
var locale$K = {
  name: 'bs',
  weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
  months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
  weekStart: 1,
  weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
  monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
  weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
  ordinal: function ordinal(n) {
    return n;
  },
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D. MMMM YYYY',
    LLL: 'D. MMMM YYYY H:mm',
    LLLL: 'dddd, D. MMMM YYYY H:mm'
  }
};
dayjs.locale(locale$K, null, true);

var bs = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$K
});

// Catalan [ca]
var locale$J = {
  name: 'ca',
  weekdays: 'Diumenge_Dilluns_Dimarts_Dimecres_Dijous_Divendres_Dissabte'.split('_'),
  weekdaysShort: 'Dg._Dl._Dt._Dc._Dj._Dv._Ds.'.split('_'),
  weekdaysMin: 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
  months: 'Gener_Febrer_Març_Abril_Maig_Juny_Juliol_Agost_Setembre_Octubre_Novembre_Desembre'.split('_'),
  monthsShort: 'Gen._Febr._Març_Abr._Maig_Juny_Jul._Ag._Set._Oct._Nov._Des.'.split('_'),
  weekStart: 1,
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'DD/MM/YYYY',
    LL: 'D MMMM [de] YYYY',
    LLL: 'D MMMM [de] YYYY [a les] H:mm',
    LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
    ll: 'D MMM YYYY',
    lll: 'D MMM YYYY, H:mm',
    llll: 'ddd D MMM YYYY, H:mm'
  },
  relativeTime: {
    future: 'd\'aquí %s',
    past: 'fa %s',
    s: 'uns segons',
    m: 'un minut',
    mm: '%d minuts',
    h: 'una hora',
    hh: '%d hores',
    d: 'un dia',
    dd: '%d dies',
    M: 'un mes',
    MM: '%d mesos',
    y: 'un any',
    yy: '%d anys'
  },
  ordinal: function ordinal(n) {
    var ord;
    if (n === 1 || n === 3) ord = 'r';else if (n === 2) ord = 'n';else if (n === 4) ord = 't';else ord = 'è';
    return "" + n + ord;
  }
};
dayjs.locale(locale$J, null, true);

var ca = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$J
});

// Czech [cs]

function plural$4(n) {
  return n > 1 && n < 5 && ~~(n / 10) !== 1; // eslint-disable-line
}
/* eslint-disable */


function translate$3(number, withoutSuffix, key, isFuture) {
  var result = number + " ";

  switch (key) {
    case 's':
      // a few seconds / in a few seconds / a few seconds ago
      return withoutSuffix || isFuture ? 'pár sekund' : 'pár sekundami';

    case 'm':
      // a minute / in a minute / a minute ago
      return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';

    case 'mm':
      // 9 minutes / in 9 minutes / 9 minutes ago
      if (withoutSuffix || isFuture) {
        return result + (plural$4(number) ? 'minuty' : 'minut');
      }

      return result + "minutami";

    case 'h':
      // an hour / in an hour / an hour ago
      return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';

    case 'hh':
      // 9 hours / in 9 hours / 9 hours ago
      if (withoutSuffix || isFuture) {
        return result + (plural$4(number) ? 'hodiny' : 'hodin');
      }

      return result + "hodinami";

    case 'd':
      // a day / in a day / a day ago
      return withoutSuffix || isFuture ? 'den' : 'dnem';

    case 'dd':
      // 9 days / in 9 days / 9 days ago
      if (withoutSuffix || isFuture) {
        return result + (plural$4(number) ? 'dny' : 'dní');
      }

      return result + "dny";

    case 'M':
      // a month / in a month / a month ago
      return withoutSuffix || isFuture ? 'měsíc' : 'měsícem';

    case 'MM':
      // 9 months / in 9 months / 9 months ago
      if (withoutSuffix || isFuture) {
        return result + (plural$4(number) ? 'měsíce' : 'měsíců');
      }

      return result + "m\u011Bs\xEDci";

    case 'y':
      // a year / in a year / a year ago
      return withoutSuffix || isFuture ? 'rok' : 'rokem';

    case 'yy':
      // 9 years / in 9 years / 9 years ago
      if (withoutSuffix || isFuture) {
        return result + (plural$4(number) ? 'roky' : 'let');
      }

      return result + "lety";
  }
}
/* eslint-enable */


var locale$I = {
  name: 'cs',
  weekdays: 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
  weekdaysShort: 'ne_po_út_st_čt_pá_so'.split('_'),
  weekdaysMin: 'ne_po_út_st_čt_pá_so'.split('_'),
  months: 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_'),
  monthsShort: 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_'),
  weekStart: 1,
  yearStart: 4,
  ordinal: function ordinal(n) {
    return n + ".";
  },
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D. MMMM YYYY',
    LLL: 'D. MMMM YYYY H:mm',
    LLLL: 'dddd D. MMMM YYYY H:mm',
    l: 'D. M. YYYY'
  },
  relativeTime: {
    future: 'za %s',
    past: 'před %s',
    s: translate$3,
    m: translate$3,
    mm: translate$3,
    h: translate$3,
    hh: translate$3,
    d: translate$3,
    dd: translate$3,
    M: translate$3,
    MM: translate$3,
    y: translate$3,
    yy: translate$3
  }
};
dayjs.locale(locale$I, null, true);

var cs = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$I
});

// Danish [da]
var locale$H = {
  name: 'da',
  weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
  weekdaysShort: 'søn._man._tirs._ons._tors._fre._lør.'.split('_'),
  weekdaysMin: 'sø._ma._ti._on._to._fr._lø.'.split('_'),
  months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
  monthsShort: 'jan._feb._mar._apr._maj_juni_juli_aug._sept._okt._nov._dec.'.split('_'),
  weekStart: 1,
  ordinal: function ordinal(n) {
    return n + ".";
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D. MMMM YYYY',
    LLL: 'D. MMMM YYYY HH:mm',
    LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
  },
  relativeTime: {
    future: 'om %s',
    past: '%s siden',
    s: 'få sekunder',
    m: 'et minut',
    mm: '%d minutter',
    h: 'en time',
    hh: '%d timer',
    d: 'en dag',
    dd: '%d dage',
    M: 'en måned',
    MM: '%d måneder',
    y: 'et år',
    yy: '%d år'
  }
};
dayjs.locale(locale$H, null, true);

var da = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$H
});

// German [de]
var texts$3 = {
  s: 'ein paar Sekunden',
  m: ['eine Minute', 'einer Minute'],
  mm: '%d Minuten',
  h: ['eine Stunde', 'einer Stunde'],
  hh: '%d Stunden',
  d: ['ein Tag', 'einem Tag'],
  dd: ['%d Tage', '%d Tagen'],
  M: ['ein Monat', 'einem Monat'],
  MM: ['%d Monate', '%d Monaten'],
  y: ['ein Jahr', 'einem Jahr'],
  yy: ['%d Jahre', '%d Jahren']
};

function relativeTimeFormatter$4(number, withoutSuffix, key) {
  var l = texts$3[key];

  if (Array.isArray(l)) {
    l = l[withoutSuffix ? 0 : 1];
  }

  return l.replace('%d', number);
}

var locale$G = {
  name: 'de',
  weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
  weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
  weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
  months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
  monthsShort: 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sept._Okt._Nov._Dez.'.split('_'),
  ordinal: function ordinal(n) {
    return n + ".";
  },
  weekStart: 1,
  yearStart: 4,
  formats: {
    LTS: 'HH:mm:ss',
    LT: 'HH:mm',
    L: 'DD.MM.YYYY',
    LL: 'D. MMMM YYYY',
    LLL: 'D. MMMM YYYY HH:mm',
    LLLL: 'dddd, D. MMMM YYYY HH:mm'
  },
  relativeTime: {
    future: 'in %s',
    past: 'vor %s',
    s: relativeTimeFormatter$4,
    m: relativeTimeFormatter$4,
    mm: relativeTimeFormatter$4,
    h: relativeTimeFormatter$4,
    hh: relativeTimeFormatter$4,
    d: relativeTimeFormatter$4,
    dd: relativeTimeFormatter$4,
    M: relativeTimeFormatter$4,
    MM: relativeTimeFormatter$4,
    y: relativeTimeFormatter$4,
    yy: relativeTimeFormatter$4
  }
};
dayjs.locale(locale$G, null, true);

var de = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$G
});

// German (Austria) [de-at]
var texts$2 = {
  s: 'ein paar Sekunden',
  m: ['eine Minute', 'einer Minute'],
  mm: '%d Minuten',
  h: ['eine Stunde', 'einer Stunde'],
  hh: '%d Stunden',
  d: ['ein Tag', 'einem Tag'],
  dd: ['%d Tage', '%d Tagen'],
  M: ['ein Monat', 'einem Monat'],
  MM: ['%d Monate', '%d Monaten'],
  y: ['ein Jahr', 'einem Jahr'],
  yy: ['%d Jahre', '%d Jahren']
};

function relativeTimeFormatter$3(number, withoutSuffix, key) {
  var l = texts$2[key];

  if (Array.isArray(l)) {
    l = l[withoutSuffix ? 0 : 1];
  }

  return l.replace('%d', number);
}

var locale$F = {
  name: 'de-at',
  weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
  weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
  weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
  months: 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
  monthsShort: 'Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
  ordinal: function ordinal(n) {
    return n + ".";
  },
  weekStart: 1,
  formats: {
    LTS: 'HH:mm:ss',
    LT: 'HH:mm',
    L: 'DD.MM.YYYY',
    LL: 'D. MMMM YYYY',
    LLL: 'D. MMMM YYYY HH:mm',
    LLLL: 'dddd, D. MMMM YYYY HH:mm'
  },
  relativeTime: {
    future: 'in %s',
    past: 'vor %s',
    s: relativeTimeFormatter$3,
    m: relativeTimeFormatter$3,
    mm: relativeTimeFormatter$3,
    h: relativeTimeFormatter$3,
    hh: relativeTimeFormatter$3,
    d: relativeTimeFormatter$3,
    dd: relativeTimeFormatter$3,
    M: relativeTimeFormatter$3,
    MM: relativeTimeFormatter$3,
    y: relativeTimeFormatter$3,
    yy: relativeTimeFormatter$3
  }
};
dayjs.locale(locale$F, null, true);

var deAt = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$F
});

// German (Switzerland) [de-ch]
var texts$1 = {
  s: 'ein paar Sekunden',
  m: ['eine Minute', 'einer Minute'],
  mm: '%d Minuten',
  h: ['eine Stunde', 'einer Stunde'],
  hh: '%d Stunden',
  d: ['ein Tag', 'einem Tag'],
  dd: ['%d Tage', '%d Tagen'],
  M: ['ein Monat', 'einem Monat'],
  MM: ['%d Monate', '%d Monaten'],
  y: ['ein Jahr', 'einem Jahr'],
  yy: ['%d Jahre', '%d Jahren']
};

function relativeTimeFormatter$2(number, withoutSuffix, key) {
  var l = texts$1[key];

  if (Array.isArray(l)) {
    l = l[withoutSuffix ? 0 : 1];
  }

  return l.replace('%d', number);
}

var locale$E = {
  name: 'de-ch',
  weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
  weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
  weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
  months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
  monthsShort: 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
  ordinal: function ordinal(n) {
    return n + ".";
  },
  weekStart: 1,
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D. MMMM YYYY',
    LLL: 'D. MMMM YYYY HH:mm',
    LLLL: 'dddd, D. MMMM YYYY HH:mm'
  },
  relativeTime: {
    future: 'in %s',
    past: 'vor %s',
    s: relativeTimeFormatter$2,
    m: relativeTimeFormatter$2,
    mm: relativeTimeFormatter$2,
    h: relativeTimeFormatter$2,
    hh: relativeTimeFormatter$2,
    d: relativeTimeFormatter$2,
    dd: relativeTimeFormatter$2,
    M: relativeTimeFormatter$2,
    MM: relativeTimeFormatter$2,
    y: relativeTimeFormatter$2,
    yy: relativeTimeFormatter$2
  }
};
dayjs.locale(locale$E, null, true);

var deCh = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$E
});

// Greek [el]
var locale$D = {
  name: 'el',
  weekdays: 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
  weekdaysShort: 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
  weekdaysMin: 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
  months: 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
  monthsShort: 'Ιαν_Φεβ_Μαρ_Απρ_Μαι_Ιουν_Ιουλ_Αυγ_Σεπτ_Οκτ_Νοε_Δεκ'.split('_'),
  ordinal: function ordinal(n) {
    return n;
  },
  weekStart: 1,
  relativeTime: {
    future: 'σε %s',
    past: 'πριν %s',
    s: 'μερικά δευτερόλεπτα',
    m: 'ένα λεπτό',
    mm: '%d λεπτά',
    h: 'μία ώρα',
    hh: '%d ώρες',
    d: 'μία μέρα',
    dd: '%d μέρες',
    M: 'ένα μήνα',
    MM: '%d μήνες',
    y: 'ένα χρόνο',
    yy: '%d χρόνια'
  },
  formats: {
    LT: 'h:mm A',
    LTS: 'h:mm:ss A',
    L: 'DD/MM/YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY h:mm A',
    LLLL: 'dddd, D MMMM YYYY h:mm A'
  }
};
dayjs.locale(locale$D, null, true);

var el = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$D
});

// English (Australia) [en-au]
var locale$C = {
  name: 'en-au',
  weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
  months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
  weekStart: 1,
  weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
  monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
  weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
  ordinal: function ordinal(n) {
    return n;
  },
  formats: {
    LT: 'h:mm A',
    LTS: 'h:mm:ss A',
    L: 'DD/MM/YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY h:mm A',
    LLLL: 'dddd, D MMMM YYYY h:mm A'
  },
  relativeTime: {
    future: 'in %s',
    past: '%s ago',
    s: 'a few seconds',
    m: 'a minute',
    mm: '%d minutes',
    h: 'an hour',
    hh: '%d hours',
    d: 'a day',
    dd: '%d days',
    M: 'a month',
    MM: '%d months',
    y: 'a year',
    yy: '%d years'
  }
};
dayjs.locale(locale$C, null, true);

var enAu = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$C
});

// English (Canada) [en-ca]
var locale$B = {
  name: 'en-ca',
  weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
  months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
  weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
  monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
  weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
  ordinal: function ordinal(n) {
    return n;
  },
  formats: {
    LT: 'h:mm A',
    LTS: 'h:mm:ss A',
    L: 'YYYY-MM-DD',
    LL: 'MMMM D, YYYY',
    LLL: 'MMMM D, YYYY h:mm A',
    LLLL: 'dddd, MMMM D, YYYY h:mm A'
  },
  relativeTime: {
    future: 'in %s',
    past: '%s ago',
    s: 'a few seconds',
    m: 'a minute',
    mm: '%d minutes',
    h: 'an hour',
    hh: '%d hours',
    d: 'a day',
    dd: '%d days',
    M: 'a month',
    MM: '%d months',
    y: 'a year',
    yy: '%d years'
  }
};
dayjs.locale(locale$B, null, true);

var enCa = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$B
});

// English (United Kingdom) [en-gb]
var locale$A = {
  name: 'en-gb',
  weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
  weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
  weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
  months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
  monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
  weekStart: 1,
  yearStart: 4,
  relativeTime: {
    future: 'in %s',
    past: '%s ago',
    s: 'a few seconds',
    m: 'a minute',
    mm: '%d minutes',
    h: 'an hour',
    hh: '%d hours',
    d: 'a day',
    dd: '%d days',
    M: 'a month',
    MM: '%d months',
    y: 'a year',
    yy: '%d years'
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD/MM/YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY HH:mm',
    LLLL: 'dddd, D MMMM YYYY HH:mm'
  },
  ordinal: function ordinal(n) {
    var s = ['th', 'st', 'nd', 'rd'];
    var v = n % 100;
    return "[" + n + (s[(v - 20) % 10] || s[v] || s[0]) + "]";
  }
};
dayjs.locale(locale$A, null, true);

var enGb = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$A
});

// Spanish [es]
var locale$z = {
  name: 'es',
  monthsShort: 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
  weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
  weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
  weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
  months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
  weekStart: 1,
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'DD/MM/YYYY',
    LL: 'D [de] MMMM [de] YYYY',
    LLL: 'D [de] MMMM [de] YYYY H:mm',
    LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
  },
  relativeTime: {
    future: 'en %s',
    past: 'hace %s',
    s: 'unos segundos',
    m: 'un minuto',
    mm: '%d minutos',
    h: 'una hora',
    hh: '%d horas',
    d: 'un día',
    dd: '%d días',
    M: 'un mes',
    MM: '%d meses',
    y: 'un año',
    yy: '%d años'
  },
  ordinal: function ordinal(n) {
    return n + "\xBA";
  }
};
dayjs.locale(locale$z, null, true);

var es = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$z
});

// Spanish (Mexico) [es-mx]
var locale$y = {
  name: 'es-mx',
  weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
  weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
  weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
  months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
  monthsShort: 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
  relativeTime: {
    future: 'en %s',
    past: 'hace %s',
    s: 'unos segundos',
    m: 'un minuto',
    mm: '%d minutos',
    h: 'una hora',
    hh: '%d horas',
    d: 'un día',
    dd: '%d días',
    M: 'un mes',
    MM: '%d meses',
    y: 'un año',
    yy: '%d años'
  },
  ordinal: function ordinal(n) {
    return n + "\xBA";
  },
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'DD/MM/YYYY',
    LL: 'D [de] MMMM [de] YYYY',
    LLL: 'D [de] MMMM [de] YYYY H:mm',
    LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
  }
};
dayjs.locale(locale$y, null, true);

var esMx = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$y
});

// Estonian [et]

function relativeTimeWithTense(number, withoutSuffix, key, isFuture) {
  var format = {
    s: ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
    m: ['ühe minuti', 'üks minut'],
    mm: ['%d minuti', '%d minutit'],
    h: ['ühe tunni', 'tund aega', 'üks tund'],
    hh: ['%d tunni', '%d tundi'],
    d: ['ühe päeva', 'üks päev'],
    M: ['kuu aja', 'kuu aega', 'üks kuu'],
    MM: ['%d kuu', '%d kuud'],
    y: ['ühe aasta', 'aasta', 'üks aasta'],
    yy: ['%d aasta', '%d aastat']
  };

  if (withoutSuffix) {
    return (format[key][2] ? format[key][2] : format[key][1]).replace('%d', number);
  }

  return (isFuture ? format[key][0] : format[key][1]).replace('%d', number);
}

var locale$x = {
  name: 'et',
  // Estonian
  weekdays: 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
  // Note weekdays are not capitalized in Estonian
  weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
  // There is no short form of weekdays in Estonian except this 1 letter format so it is used for both 'weekdaysShort' and 'weekdaysMin'
  weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
  months: 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
  // Note month names are not capitalized in Estonian
  monthsShort: 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
  ordinal: function ordinal(n) {
    return n + ".";
  },
  weekStart: 1,
  relativeTime: {
    future: '%s pärast',
    past: '%s tagasi',
    s: relativeTimeWithTense,
    m: relativeTimeWithTense,
    mm: relativeTimeWithTense,
    h: relativeTimeWithTense,
    hh: relativeTimeWithTense,
    d: relativeTimeWithTense,
    dd: '%d päeva',
    M: relativeTimeWithTense,
    MM: relativeTimeWithTense,
    y: relativeTimeWithTense,
    yy: relativeTimeWithTense
  },
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D. MMMM YYYY',
    LLL: 'D. MMMM YYYY H:mm',
    LLLL: 'dddd, D. MMMM YYYY H:mm'
  }
};
dayjs.locale(locale$x, null, true);

var et = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$x
});

// Finnish [fi]

function relativeTimeFormatter$1(number, withoutSuffix, key, isFuture) {
  var past = {
    s: 'muutama sekunti',
    m: 'minuutti',
    mm: '%d minuuttia',
    h: 'tunti',
    hh: '%d tuntia',
    d: 'päivä',
    dd: '%d päivää',
    M: 'kuukausi',
    MM: '%d kuukautta',
    y: 'vuosi',
    yy: '%d vuotta',
    numbers: 'nolla_yksi_kaksi_kolme_neljä_viisi_kuusi_seitsemän_kahdeksan_yhdeksän'.split('_')
  };
  var future = {
    s: 'muutaman sekunnin',
    m: 'minuutin',
    mm: '%d minuutin',
    h: 'tunnin',
    hh: '%d tunnin',
    d: 'päivän',
    dd: '%d päivän',
    M: 'kuukauden',
    MM: '%d kuukauden',
    y: 'vuoden',
    yy: '%d vuoden',
    numbers: 'nollan_yhden_kahden_kolmen_neljän_viiden_kuuden_seitsemän_kahdeksan_yhdeksän'.split('_')
  };
  var words = isFuture && !withoutSuffix ? future : past;
  var result = words[key];

  if (number < 10) {
    return result.replace('%d', words.numbers[number]);
  }

  return result.replace('%d', number);
}

var locale$w = {
  name: 'fi',
  // Finnish
  weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
  // Note weekdays are not capitalized in Finnish
  weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
  // There is no short form of weekdays in Finnish except this 2 letter format so it is used for both 'weekdaysShort' and 'weekdaysMin'
  weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
  months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
  // Note month names are not capitalized in Finnish
  monthsShort: 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
  ordinal: function ordinal(n) {
    return n + ".";
  },
  weekStart: 1,
  yearStart: 4,
  relativeTime: {
    future: '%s päästä',
    past: '%s sitten',
    s: relativeTimeFormatter$1,
    m: relativeTimeFormatter$1,
    mm: relativeTimeFormatter$1,
    h: relativeTimeFormatter$1,
    hh: relativeTimeFormatter$1,
    d: relativeTimeFormatter$1,
    dd: relativeTimeFormatter$1,
    M: relativeTimeFormatter$1,
    MM: relativeTimeFormatter$1,
    y: relativeTimeFormatter$1,
    yy: relativeTimeFormatter$1
  },
  formats: {
    LT: 'HH.mm',
    LTS: 'HH.mm.ss',
    L: 'DD.MM.YYYY',
    LL: 'D. MMMM[ta] YYYY',
    LLL: 'D. MMMM[ta] YYYY, [klo] HH.mm',
    LLLL: 'dddd, D. MMMM[ta] YYYY, [klo] HH.mm',
    l: 'D.M.YYYY',
    ll: 'D. MMM YYYY',
    lll: 'D. MMM YYYY, [klo] HH.mm',
    llll: 'ddd, D. MMM YYYY, [klo] HH.mm'
  }
};
dayjs.locale(locale$w, null, true);

var fi = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$w
});

// French [fr]
var locale$v = {
  name: 'fr',
  weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
  weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
  weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
  months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
  monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
  weekStart: 1,
  yearStart: 4,
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD/MM/YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY HH:mm',
    LLLL: 'dddd D MMMM YYYY HH:mm'
  },
  relativeTime: {
    future: 'dans %s',
    past: 'il y a %s',
    s: 'quelques secondes',
    m: 'une minute',
    mm: '%d minutes',
    h: 'une heure',
    hh: '%d heures',
    d: 'un jour',
    dd: '%d jours',
    M: 'un mois',
    MM: '%d mois',
    y: 'un an',
    yy: '%d ans'
  },
  ordinal: function ordinal(n) {
    var o = n === 1 ? 'er' : '';
    return "" + n + o;
  }
};
dayjs.locale(locale$v, null, true);

var fr = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$v
});

// French (Switzerland) [fr-ch]
var locale$u = {
  name: 'fr-ch',
  weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
  months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
  weekStart: 1,
  weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
  monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
  weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
  ordinal: function ordinal(n) {
    return n;
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY HH:mm',
    LLLL: 'dddd D MMMM YYYY HH:mm'
  },
  relativeTime: {
    future: 'dans %s',
    past: 'il y a %s',
    s: 'quelques secondes',
    m: 'une minute',
    mm: '%d minutes',
    h: 'une heure',
    hh: '%d heures',
    d: 'un jour',
    dd: '%d jours',
    M: 'un mois',
    MM: '%d mois',
    y: 'un an',
    yy: '%d ans'
  }
};
dayjs.locale(locale$u, null, true);

var frCh = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$u
});

// Hebrew [he]
var texts = {
  s: 'מספר שניות',
  ss: '%d שניות',
  m: 'דקה',
  mm: '%d דקות',
  h: 'שעה',
  hh: '%d שעות',
  hh2: 'שעתיים',
  d: 'יום',
  dd: '%d ימים',
  dd2: 'יומיים',
  M: 'חודש',
  MM: '%d חודשים',
  MM2: 'חודשיים',
  y: 'שנה',
  yy: '%d שנים',
  yy2: 'שנתיים'
};

function relativeTimeFormatter(number, withoutSuffix, key) {
  var text = texts[key + (number === 2 ? '2' : '')] || texts[key];
  return text.replace('%d', number);
}

var locale$t = {
  name: 'he',
  weekdays: 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
  weekdaysShort: 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
  weekdaysMin: 'א׳_ב׳_ג׳_ד׳_ה׳_ו_ש׳'.split('_'),
  months: 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
  monthsShort: 'ינו_פבר_מרץ_אפר_מאי_יונ_יול_אוג_ספט_אוק_נוב_דצמ'.split('_'),
  relativeTime: {
    future: 'בעוד %s',
    past: 'לפני %s',
    s: relativeTimeFormatter,
    m: relativeTimeFormatter,
    mm: relativeTimeFormatter,
    h: relativeTimeFormatter,
    hh: relativeTimeFormatter,
    d: relativeTimeFormatter,
    dd: relativeTimeFormatter,
    M: relativeTimeFormatter,
    MM: relativeTimeFormatter,
    y: relativeTimeFormatter,
    yy: relativeTimeFormatter
  },
  ordinal: function ordinal(n) {
    return n;
  },
  format: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD/MM/YYYY',
    LL: 'D [ב]MMMM YYYY',
    LLL: 'D [ב]MMMM YYYY HH:mm',
    LLLL: 'dddd, D [ב]MMMM YYYY HH:mm',
    l: 'D/M/YYYY',
    ll: 'D MMM YYYY',
    lll: 'D MMM YYYY HH:mm',
    llll: 'ddd, D MMM YYYY HH:mm'
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD/MM/YYYY',
    LL: 'D [ב]MMMM YYYY',
    LLL: 'D [ב]MMMM YYYY HH:mm',
    LLLL: 'dddd, D [ב]MMMM YYYY HH:mm',
    l: 'D/M/YYYY',
    ll: 'D MMM YYYY',
    lll: 'D MMM YYYY HH:mm',
    llll: 'ddd, D MMM YYYY HH:mm'
  }
};
dayjs.locale(locale$t, null, true);

var he = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$t
});

// Hindi [hi]
var locale$s = {
  name: 'hi',
  weekdays: 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
  months: 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
  weekdaysShort: 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
  monthsShort: 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
  weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
  ordinal: function ordinal(n) {
    return n;
  },
  formats: {
    LT: 'A h:mm बजे',
    LTS: 'A h:mm:ss बजे',
    L: 'DD/MM/YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY, A h:mm बजे',
    LLLL: 'dddd, D MMMM YYYY, A h:mm बजे'
  },
  relativeTime: {
    future: '%s में',
    past: '%s पहले',
    s: 'कुछ ही क्षण',
    m: 'एक मिनट',
    mm: '%d मिनट',
    h: 'एक घंटा',
    hh: '%d घंटे',
    d: 'एक दिन',
    dd: '%d दिन',
    M: 'एक महीने',
    MM: '%d महीने',
    y: 'एक वर्ष',
    yy: '%d वर्ष'
  }
};
dayjs.locale(locale$s, null, true);

var hi = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$s
});

// Croatian [hr]
var monthFormat$4 = 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_');
var monthStandalone$4 = 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_');
var MONTHS_IN_FORMAT$4 = /D[oD]?(\[[^[\]]*\]|\s)+MMMM?/;

var months$4 = function months(dayjsInstance, format) {
  if (MONTHS_IN_FORMAT$4.test(format)) {
    return monthFormat$4[dayjsInstance.month()];
  }

  return monthStandalone$4[dayjsInstance.month()];
};

months$4.s = monthStandalone$4;
months$4.f = monthFormat$4;
var locale$r = {
  name: 'hr',
  weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
  weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
  weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
  months: months$4,
  monthsShort: 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
  weekStart: 1,
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D. MMMM YYYY',
    LLL: 'D. MMMM YYYY H:mm',
    LLLL: 'dddd, D. MMMM YYYY H:mm'
  },
  relativeTime: {
    future: 'za %s',
    past: 'prije %s',
    s: 'sekunda',
    m: 'minuta',
    mm: '%d minuta',
    h: 'sat',
    hh: '%d sati',
    d: 'dan',
    dd: '%d dana',
    M: 'mjesec',
    MM: '%d mjeseci',
    y: 'godina',
    yy: '%d godine'
  },
  ordinal: function ordinal(n) {
    return n + ".";
  }
};
dayjs.locale(locale$r, null, true);

var hr = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$r
});

// Hungarian [hu]
var locale$q = {
  name: 'hu',
  weekdays: 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
  weekdaysShort: 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
  weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
  months: 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
  monthsShort: 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
  ordinal: function ordinal(n) {
    return n + ".";
  },
  weekStart: 1,
  relativeTime: {
    future: '%s múlva',
    past: '%s',
    s: function s(_, _s, ___, isFuture) {
      return "n\xE9h\xE1ny m\xE1sodperc" + (isFuture || _s ? '' : 'e');
    },
    m: function m(_, s, ___, isFuture) {
      return "egy perc" + (isFuture || s ? '' : 'e');
    },
    mm: function mm(n, s, ___, isFuture) {
      return n + " perc" + (isFuture || s ? '' : 'e');
    },
    h: function h(_, s, ___, isFuture) {
      return "egy " + (isFuture || s ? 'óra' : 'órája');
    },
    hh: function hh(n, s, ___, isFuture) {
      return n + " " + (isFuture || s ? 'óra' : 'órája');
    },
    d: function d(_, s, ___, isFuture) {
      return "egy " + (isFuture || s ? 'nap' : 'napja');
    },
    dd: function dd(n, s, ___, isFuture) {
      return n + " " + (isFuture || s ? 'nap' : 'napja');
    },
    M: function M(_, s, ___, isFuture) {
      return "egy " + (isFuture || s ? 'hónap' : 'hónapja');
    },
    MM: function MM(n, s, ___, isFuture) {
      return n + " " + (isFuture || s ? 'hónap' : 'hónapja');
    },
    y: function y(_, s, ___, isFuture) {
      return "egy " + (isFuture || s ? 'év' : 'éve');
    },
    yy: function yy(n, s, ___, isFuture) {
      return n + " " + (isFuture || s ? 'év' : 'éve');
    }
  },
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'YYYY.MM.DD.',
    LL: 'YYYY. MMMM D.',
    LLL: 'YYYY. MMMM D. H:mm',
    LLLL: 'YYYY. MMMM D., dddd H:mm'
  }
};
dayjs.locale(locale$q, null, true);

var hu = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$q
});

// Indonesian [id]
var locale$p = {
  name: 'id',
  weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
  months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
  weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
  monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
  weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
  weekStart: 1,
  formats: {
    LT: 'HH.mm',
    LTS: 'HH.mm.ss',
    L: 'DD/MM/YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY [pukul] HH.mm',
    LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
  },
  relativeTime: {
    future: 'dalam %s',
    past: '%s yang lalu',
    s: 'beberapa detik',
    m: 'semenit',
    mm: '%d menit',
    h: 'sejam',
    hh: '%d jam',
    d: 'sehari',
    dd: '%d hari',
    M: 'sebulan',
    MM: '%d bulan',
    y: 'setahun',
    yy: '%d tahun'
  },
  ordinal: function ordinal(n) {
    return n + ".";
  }
};
dayjs.locale(locale$p, null, true);

var id = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$p
});

// Italian [it]
var locale$o = {
  name: 'it',
  weekdays: 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split('_'),
  weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
  weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
  months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
  weekStart: 1,
  monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD/MM/YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY HH:mm',
    LLLL: 'dddd D MMMM YYYY HH:mm'
  },
  relativeTime: {
    future: 'tra %s',
    past: '%s fa',
    s: 'qualche secondo',
    m: 'un minuto',
    mm: '%d minuti',
    h: 'un\' ora',
    hh: '%d ore',
    d: 'un giorno',
    dd: '%d giorni',
    M: 'un mese',
    MM: '%d mesi',
    y: 'un anno',
    yy: '%d anni'
  },
  ordinal: function ordinal(n) {
    return n + "\xBA";
  }
};
dayjs.locale(locale$o, null, true);

var it = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$o
});

// Italian (Switzerland) [it-ch]
var locale$n = {
  name: 'it-ch',
  weekdays: 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split('_'),
  months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
  weekStart: 1,
  weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
  monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
  weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
  ordinal: function ordinal(n) {
    return n;
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY HH:mm',
    LLLL: 'dddd D MMMM YYYY HH:mm'
  },
  relativeTime: {
    future: 'tra %s',
    past: '%s fa',
    s: 'alcuni secondi',
    m: 'un minuto',
    mm: '%d minuti',
    h: 'un\'ora',
    hh: '%d ore',
    d: 'un giorno',
    dd: '%d giorni',
    M: 'un mese',
    MM: '%d mesi',
    y: 'un anno',
    yy: '%d anni'
  }
};
dayjs.locale(locale$n, null, true);

var itCh = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$n
});

// Japanese [ja]
var locale$m = {
  name: 'ja',
  weekdays: '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
  weekdaysShort: '日_月_火_水_木_金_土'.split('_'),
  weekdaysMin: '日_月_火_水_木_金_土'.split('_'),
  months: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
  monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
  ordinal: function ordinal(n) {
    return n + "\u65E5";
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'YYYY/MM/DD',
    LL: 'YYYY年M月D日',
    LLL: 'YYYY年M月D日 HH:mm',
    LLLL: 'YYYY年M月D日 dddd HH:mm',
    l: 'YYYY/MM/DD',
    ll: 'YYYY年M月D日',
    lll: 'YYYY年M月D日 HH:mm',
    llll: 'YYYY年M月D日(ddd) HH:mm'
  },
  meridiem: function meridiem(hour) {
    return hour < 12 ? '午前' : '午後';
  },
  relativeTime: {
    future: '%s後',
    past: '%s前',
    s: '数秒',
    m: '1分',
    mm: '%d分',
    h: '1時間',
    hh: '%d時間',
    d: '1日',
    dd: '%d日',
    M: '1ヶ月',
    MM: '%dヶ月',
    y: '1年',
    yy: '%d年'
  }
};
dayjs.locale(locale$m, null, true);

var ja = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$m
});

// Korean [ko]
var locale$l = {
  name: 'ko',
  weekdays: '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
  weekdaysShort: '일_월_화_수_목_금_토'.split('_'),
  weekdaysMin: '일_월_화_수_목_금_토'.split('_'),
  months: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
  monthsShort: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
  ordinal: function ordinal(n) {
    return n + "\uC77C";
  },
  formats: {
    LT: 'A h:mm',
    LTS: 'A h:mm:ss',
    L: 'YYYY.MM.DD.',
    LL: 'YYYY년 MMMM D일',
    LLL: 'YYYY년 MMMM D일 A h:mm',
    LLLL: 'YYYY년 MMMM D일 dddd A h:mm',
    l: 'YYYY.MM.DD.',
    ll: 'YYYY년 MMMM D일',
    lll: 'YYYY년 MMMM D일 A h:mm',
    llll: 'YYYY년 MMMM D일 dddd A h:mm'
  },
  meridiem: function meridiem(hour) {
    return hour < 12 ? '오전' : '오후';
  },
  relativeTime: {
    future: '%s 후',
    past: '%s 전',
    s: '몇 초',
    m: '1분',
    mm: '%d분',
    h: '한 시간',
    hh: '%d시간',
    d: '하루',
    dd: '%d일',
    M: '한 달',
    MM: '%d달',
    y: '일 년',
    yy: '%d년'
  }
};
dayjs.locale(locale$l, null, true);

var ko = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$l
});

// Lithuanian [lt]
var monthFormat$3 = 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_');
var monthStandalone$3 = 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_'); // eslint-disable-next-line no-useless-escape

var MONTHS_IN_FORMAT$3 = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/;

var months$3 = function months(dayjsInstance, format) {
  if (MONTHS_IN_FORMAT$3.test(format)) {
    return monthFormat$3[dayjsInstance.month()];
  }

  return monthStandalone$3[dayjsInstance.month()];
};

months$3.s = monthStandalone$3;
months$3.f = monthFormat$3;
var locale$k = {
  name: 'lt',
  weekdays: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_'),
  weekdaysShort: 'sek_pir_ant_tre_ket_pen_šeš'.split('_'),
  weekdaysMin: 's_p_a_t_k_pn_š'.split('_'),
  months: months$3,
  monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
  ordinal: function ordinal(n) {
    return n + ".";
  },
  weekStart: 1,
  relativeTime: {
    future: 'už %s',
    past: 'prieš %s',
    s: 'kelias sekundes',
    m: 'minutę',
    mm: '%d minutes',
    h: 'valandą',
    hh: '%d valandas',
    d: 'dieną',
    dd: '%d dienas',
    M: 'mėnesį',
    MM: '%d mėnesius',
    y: 'metus',
    yy: '%d metus'
  },
  format: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'YYYY-MM-DD',
    LL: 'YYYY [m.] MMMM D [d.]',
    LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
    LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
    l: 'YYYY-MM-DD',
    ll: 'YYYY [m.] MMMM D [d.]',
    lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
    llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'YYYY-MM-DD',
    LL: 'YYYY [m.] MMMM D [d.]',
    LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
    LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
    l: 'YYYY-MM-DD',
    ll: 'YYYY [m.] MMMM D [d.]',
    lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
    llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
  }
};
dayjs.locale(locale$k, null, true);

var lt = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$k
});

// Latvian [lv]
var locale$j = {
  name: 'lv',
  weekdays: 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
  months: 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
  weekStart: 1,
  weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
  monthsShort: 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
  weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
  ordinal: function ordinal(n) {
    return n;
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD.MM.YYYY.',
    LL: 'YYYY. [gada] D. MMMM',
    LLL: 'YYYY. [gada] D. MMMM, HH:mm',
    LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm'
  },
  relativeTime: {
    future: 'pēc %s',
    past: 'pirms %s',
    s: 'dažām sekundēm',
    m: 'minūtes',
    mm: '%d minūtēm',
    h: 'stundas',
    hh: '%d stundām',
    d: 'dienas',
    dd: '%d dienām',
    M: 'mēneša',
    MM: '%d mēnešiem',
    y: 'gada',
    yy: '%d gadiem'
  }
};
dayjs.locale(locale$j, null, true);

var lv = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$j
});

// Macedonian [mk]
var locale$i = {
  name: 'mk',
  weekdays: 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
  months: 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
  weekStart: 1,
  weekdaysShort: 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
  monthsShort: 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
  weekdaysMin: 'нe_пo_вт_ср_че_пе_сa'.split('_'),
  ordinal: function ordinal(n) {
    return n;
  },
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'D.MM.YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY H:mm',
    LLLL: 'dddd, D MMMM YYYY H:mm'
  },
  relativeTime: {
    future: 'после %s',
    past: 'пред %s',
    s: 'неколку секунди',
    m: 'минута',
    mm: '%d минути',
    h: 'час',
    hh: '%d часа',
    d: 'ден',
    dd: '%d дена',
    M: 'месец',
    MM: '%d месеци',
    y: 'година',
    yy: '%d години'
  }
};
dayjs.locale(locale$i, null, true);

var mk = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$i
});

// Dutch [nl]
var locale$h = {
  name: 'nl',
  weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
  weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
  weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
  months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
  monthsShort: 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_'),
  ordinal: function ordinal(n) {
    return "[" + n + (n === 1 || n === 8 || n >= 20 ? 'ste' : 'de') + "]";
  },
  weekStart: 1,
  yearStart: 4,
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD-MM-YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY HH:mm',
    LLLL: 'dddd D MMMM YYYY HH:mm'
  },
  relativeTime: {
    future: 'over %s',
    past: '%s geleden',
    s: 'een paar seconden',
    m: 'een minuut',
    mm: '%d minuten',
    h: 'een uur',
    hh: '%d uur',
    d: 'een dag',
    dd: '%d dagen',
    M: 'een maand',
    MM: '%d maanden',
    y: 'een jaar',
    yy: '%d jaar'
  }
};
dayjs.locale(locale$h, null, true);

var nl = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$h
});

// Norwegian Bokmål [nb]
var locale$g = {
  name: 'nb',
  weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
  weekdaysShort: 'sø._ma._ti._on._to._fr._lø.'.split('_'),
  weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
  months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
  monthsShort: 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
  ordinal: function ordinal(n) {
    return n + ".";
  },
  weekStart: 1,
  yearStart: 4,
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D. MMMM YYYY',
    LLL: 'D. MMMM YYYY [kl.] HH:mm',
    LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
  },
  relativeTime: {
    future: 'om %s',
    past: '%s siden',
    s: 'noen sekunder',
    m: 'ett minutt',
    mm: '%d minutter',
    h: 'en time',
    hh: '%d timer',
    d: 'en dag',
    dd: '%d dager',
    M: 'en måned',
    MM: '%d måneder',
    y: 'ett år',
    yy: '%d år'
  }
};
dayjs.locale(locale$g, null, true);

var nb = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$g
});

// Polish [pl]

function plural$3(n) {
  return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1; // eslint-disable-line
}
/* eslint-disable */


function translate$2(number, withoutSuffix, key) {
  var result = number + " ";

  switch (key) {
    case 'm':
      return withoutSuffix ? 'minuta' : 'minutę';

    case 'mm':
      return result + (plural$3(number) ? 'minuty' : 'minut');

    case 'h':
      return withoutSuffix ? 'godzina' : 'godzinę';

    case 'hh':
      return result + (plural$3(number) ? 'godziny' : 'godzin');

    case 'MM':
      return result + (plural$3(number) ? 'miesiące' : 'miesięcy');

    case 'yy':
      return result + (plural$3(number) ? 'lata' : 'lat');
  }
}
/* eslint-enable */


var monthFormat$2 = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');
var monthStandalone$2 = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_');
var MONTHS_IN_FORMAT$2 = /D MMMM/;

var months$2 = function months(dayjsInstance, format) {
  if (MONTHS_IN_FORMAT$2.test(format)) {
    return monthFormat$2[dayjsInstance.month()];
  }

  return monthStandalone$2[dayjsInstance.month()];
};

months$2.s = monthStandalone$2;
months$2.f = monthFormat$2;
var locale$f = {
  name: 'pl',
  weekdays: 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
  weekdaysShort: 'ndz_pon_wt_śr_czw_pt_sob'.split('_'),
  weekdaysMin: 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
  months: months$2,
  monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
  ordinal: function ordinal(n) {
    return n + ".";
  },
  weekStart: 1,
  yearStart: 4,
  relativeTime: {
    future: 'za %s',
    past: '%s temu',
    s: 'kilka sekund',
    m: translate$2,
    mm: translate$2,
    h: translate$2,
    hh: translate$2,
    d: '1 dzień',
    dd: '%d dni',
    M: 'miesiąc',
    MM: translate$2,
    y: 'rok',
    yy: translate$2
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY HH:mm',
    LLLL: 'dddd, D MMMM YYYY HH:mm'
  }
};
dayjs.locale(locale$f, null, true);

var pl = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$f
});

// Portuguese [pt]
var locale$e = {
  name: 'pt',
  weekdays: 'domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado'.split('_'),
  weekdaysShort: 'dom_seg_ter_qua_qui_sex_sab'.split('_'),
  weekdaysMin: 'Do_2ª_3ª_4ª_5ª_6ª_Sa'.split('_'),
  months: 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
  monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
  ordinal: function ordinal(n) {
    return n + "\xBA";
  },
  weekStart: 1,
  yearStart: 4,
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD/MM/YYYY',
    LL: 'D [de] MMMM [de] YYYY',
    LLL: 'D [de] MMMM [de] YYYY [às] HH:mm',
    LLLL: 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
  },
  relativeTime: {
    future: 'em %s',
    past: 'há %s',
    s: 'alguns segundos',
    m: 'um minuto',
    mm: '%d minutos',
    h: 'uma hora',
    hh: '%d horas',
    d: 'um dia',
    dd: '%d dias',
    M: 'um mês',
    MM: '%d meses',
    y: 'um ano',
    yy: '%d anos'
  }
};
dayjs.locale(locale$e, null, true);

var pt = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$e
});

// Portuguese (Brazil) [pt-br]
var locale$d = {
  name: 'pt-br',
  weekdays: 'domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado'.split('_'),
  weekdaysShort: 'dom_seg_ter_qua_qui_sex_sáb'.split('_'),
  weekdaysMin: 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
  months: 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
  monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
  ordinal: function ordinal(n) {
    return n + "\xBA";
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD/MM/YYYY',
    LL: 'D [de] MMMM [de] YYYY',
    LLL: 'D [de] MMMM [de] YYYY [às] HH:mm',
    LLLL: 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
  },
  relativeTime: {
    future: 'em %s',
    past: 'há %s',
    s: 'poucos segundos',
    m: 'um minuto',
    mm: '%d minutos',
    h: 'uma hora',
    hh: '%d horas',
    d: 'um dia',
    dd: '%d dias',
    M: 'um mês',
    MM: '%d meses',
    y: 'um ano',
    yy: '%d anos'
  }
};
dayjs.locale(locale$d, null, true);

var ptBr = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$d
});

// Romanian [ro]
var locale$c = {
  name: 'ro',
  weekdays: 'Duminică_Luni_Marți_Miercuri_Joi_Vineri_Sâmbătă'.split('_'),
  weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
  weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
  months: 'Ianuarie_Februarie_Martie_Aprilie_Mai_Iunie_Iulie_August_Septembrie_Octombrie_Noiembrie_Decembrie'.split('_'),
  monthsShort: 'Ian._Febr._Mart._Apr._Mai_Iun._Iul._Aug._Sept._Oct._Nov._Dec.'.split('_'),
  weekStart: 1,
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY H:mm',
    LLLL: 'dddd, D MMMM YYYY H:mm'
  },
  relativeTime: {
    future: 'peste %s',
    past: 'acum %s',
    s: 'câteva secunde',
    m: 'un minut',
    mm: '%d minute',
    h: 'o oră',
    hh: '%d ore',
    d: 'o zi',
    dd: '%d zile',
    M: 'o lună',
    MM: '%d luni',
    y: 'un an',
    yy: '%d ani'
  },
  ordinal: function ordinal(n) {
    return n;
  }
};
dayjs.locale(locale$c, null, true);

var ro = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$c
});

// Russian [ru]
var monthFormat$1 = 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_');
var monthStandalone$1 = 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_');
var monthShortFormat = 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split('_');
var monthShortStandalone = 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split('_');
var MONTHS_IN_FORMAT$1 = /D[oD]?(\[[^[\]]*\]|\s)+MMMM?/;

function plural$2(word, num) {
  var forms = word.split('_');
  return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]; // eslint-disable-line
}

function relativeTimeWithPlural$1(number, withoutSuffix, key) {
  var format = {
    mm: withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
    hh: 'час_часа_часов',
    dd: 'день_дня_дней',
    MM: 'месяц_месяца_месяцев',
    yy: 'год_года_лет'
  };

  if (key === 'm') {
    return withoutSuffix ? 'минута' : 'минуту';
  }

  return number + " " + plural$2(format[key], +number);
}

var months$1 = function months(dayjsInstance, format) {
  if (MONTHS_IN_FORMAT$1.test(format)) {
    return monthFormat$1[dayjsInstance.month()];
  }

  return monthStandalone$1[dayjsInstance.month()];
};

months$1.s = monthStandalone$1;
months$1.f = monthFormat$1;

var monthsShort = function monthsShort(dayjsInstance, format) {
  if (MONTHS_IN_FORMAT$1.test(format)) {
    return monthShortFormat[dayjsInstance.month()];
  }

  return monthShortStandalone[dayjsInstance.month()];
};

monthsShort.s = monthShortStandalone;
monthsShort.f = monthShortFormat;
var locale$b = {
  name: 'ru',
  weekdays: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
  weekdaysShort: 'вск_пнд_втр_срд_чтв_птн_сбт'.split('_'),
  weekdaysMin: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
  months: months$1,
  monthsShort: monthsShort,
  weekStart: 1,
  yearStart: 4,
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D MMMM YYYY г.',
    LLL: 'D MMMM YYYY г., H:mm',
    LLLL: 'dddd, D MMMM YYYY г., H:mm'
  },
  relativeTime: {
    future: 'через %s',
    past: '%s назад',
    s: 'несколько секунд',
    m: relativeTimeWithPlural$1,
    mm: relativeTimeWithPlural$1,
    h: 'час',
    hh: relativeTimeWithPlural$1,
    d: 'день',
    dd: relativeTimeWithPlural$1,
    M: 'месяц',
    MM: relativeTimeWithPlural$1,
    y: 'год',
    yy: relativeTimeWithPlural$1
  },
  ordinal: function ordinal(n) {
    return n;
  },
  meridiem: function meridiem(hour) {
    if (hour < 4) {
      return 'ночи';
    } else if (hour < 12) {
      return 'утра';
    } else if (hour < 17) {
      return 'дня';
    }

    return 'вечера';
  }
};
dayjs.locale(locale$b, null, true);

var ru = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$b
});

// Slovak [sk]

function plural$1(n) {
  return n > 1 && n < 5 && ~~(n / 10) !== 1; // eslint-disable-line
}
/* eslint-disable */


function translate$1(number, withoutSuffix, key, isFuture) {
  var result = number + " ";

  switch (key) {
    case 's':
      // a few seconds / in a few seconds / a few seconds ago
      return withoutSuffix || isFuture ? 'pár sekúnd' : 'pár sekundami';

    case 'm':
      // a minute / in a minute / a minute ago
      return withoutSuffix ? 'minúta' : isFuture ? 'minútu' : 'minútou';

    case 'mm':
      // 9 minutes / in 9 minutes / 9 minutes ago
      if (withoutSuffix || isFuture) {
        return result + (plural$1(number) ? 'minúty' : 'minút');
      }

      return result + "min\xFAtami";

    case 'h':
      // an hour / in an hour / an hour ago
      return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';

    case 'hh':
      // 9 hours / in 9 hours / 9 hours ago
      if (withoutSuffix || isFuture) {
        return result + (plural$1(number) ? 'hodiny' : 'hodín');
      }

      return result + "hodinami";

    case 'd':
      // a day / in a day / a day ago
      return withoutSuffix || isFuture ? 'deň' : 'dňom';

    case 'dd':
      // 9 days / in 9 days / 9 days ago
      if (withoutSuffix || isFuture) {
        return result + (plural$1(number) ? 'dni' : 'dní');
      }

      return result + "d\u0148ami";

    case 'M':
      // a month / in a month / a month ago
      return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';

    case 'MM':
      // 9 months / in 9 months / 9 months ago
      if (withoutSuffix || isFuture) {
        return result + (plural$1(number) ? 'mesiace' : 'mesiacov');
      }

      return result + "mesiacmi";

    case 'y':
      // a year / in a year / a year ago
      return withoutSuffix || isFuture ? 'rok' : 'rokom';

    case 'yy':
      // 9 years / in 9 years / 9 years ago
      if (withoutSuffix || isFuture) {
        return result + (plural$1(number) ? 'roky' : 'rokov');
      }

      return result + "rokmi";
  }
}
/* eslint-enable */


var locale$a = {
  name: 'sk',
  weekdays: 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
  weekdaysShort: 'ne_po_ut_st_št_pi_so'.split('_'),
  weekdaysMin: 'ne_po_ut_st_št_pi_so'.split('_'),
  months: 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_'),
  monthsShort: 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_'),
  weekStart: 1,
  yearStart: 4,
  ordinal: function ordinal(n) {
    return n + ".";
  },
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D. MMMM YYYY',
    LLL: 'D. MMMM YYYY H:mm',
    LLLL: 'dddd D. MMMM YYYY H:mm',
    l: 'D. M. YYYY'
  },
  relativeTime: {
    future: 'za %s',
    // Should be `o %s` (change when moment/moment#5408 is fixed)
    past: 'pred %s',
    s: translate$1,
    m: translate$1,
    mm: translate$1,
    h: translate$1,
    hh: translate$1,
    d: translate$1,
    dd: translate$1,
    M: translate$1,
    MM: translate$1,
    y: translate$1,
    yy: translate$1
  }
};
dayjs.locale(locale$a, null, true);

var sk = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$a
});

// Slovenian [sl]

function dual(n) {
  return n % 100 == 2; // eslint-disable-line
}

function threeFour(n) {
  return n % 100 == 3 || n % 100 == 4; // eslint-disable-line
}
/* eslint-disable */


function translate(number, withoutSuffix, key, isFuture) {
  var result = number + " ";

  switch (key) {
    case 's':
      // a few seconds / in a few seconds / a few seconds ago
      return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';

    case 'm':
      // a minute / in a minute / a minute ago
      return withoutSuffix ? 'ena minuta' : 'eno minuto';

    case 'mm':
      // 9 minutes / in 9 minutes / 9 minutes ago
      if (dual(number)) {
        return result + (withoutSuffix || isFuture ? 'minuti' : 'minutama');
      }

      if (threeFour(number)) {
        return result + (withoutSuffix || isFuture ? 'minute' : 'minutami');
      }

      return result + (withoutSuffix || isFuture ? 'minut' : 'minutami');

    case 'h':
      // an hour / in an hour / an hour ago
      return withoutSuffix ? 'ena ura' : isFuture ? 'eno uro' : 'eno uro';

    case 'hh':
      // 9 hours / in 9 hours / 9 hours ago
      if (dual(number)) {
        return result + (withoutSuffix || isFuture ? 'uri' : 'urama');
      }

      if (threeFour(number)) {
        return result + (withoutSuffix || isFuture ? 'ure' : 'urami');
      }

      return result + (withoutSuffix || isFuture ? 'ur' : 'urami');

    case 'd':
      // a day / in a day / a day ago
      return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';

    case 'dd':
      // 9 days / in 9 days / 9 days ago
      if (dual(number)) {
        return result + (withoutSuffix || isFuture ? 'dneva' : 'dnevoma');
      }

      return result + (withoutSuffix || isFuture ? 'dni' : 'dnevi');

    case 'M':
      // a month / in a month / a month ago
      return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';

    case 'MM':
      // 9 months / in 9 months / 9 months ago
      if (dual(number)) {
        // 2 minutes / in 2 minutes
        return result + (withoutSuffix || isFuture ? 'meseca' : 'mesecema');
      }

      if (threeFour(number)) {
        return result + (withoutSuffix || isFuture ? 'mesece' : 'meseci');
      }

      return result + (withoutSuffix || isFuture ? 'mesecev' : 'meseci');

    case 'y':
      // a year / in a year / a year ago
      return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';

    case 'yy':
      // 9 years / in 9 years / 9 years ago
      if (dual(number)) {
        // 2 minutes / in 2 minutes
        return result + (withoutSuffix || isFuture ? 'leti' : 'letoma');
      }

      if (threeFour(number)) {
        return result + (withoutSuffix || isFuture ? 'leta' : 'leti');
      }

      return result + (withoutSuffix || isFuture ? 'let' : 'leti');
  }
}
/* eslint-enable */


var locale$9 = {
  name: 'sl',
  weekdays: 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
  months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
  weekStart: 1,
  weekdaysShort: 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
  monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
  weekdaysMin: 'ne_po_to_sr_če_pe_so'.split('_'),
  ordinal: function ordinal(n) {
    return n + ".";
  },
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D. MMMM YYYY',
    LLL: 'D. MMMM YYYY H:mm',
    LLLL: 'dddd, D. MMMM YYYY H:mm',
    l: 'D. M. YYYY'
  },
  relativeTime: {
    future: 'čez %s',
    past: 'pred %s',
    s: translate,
    m: translate,
    mm: translate,
    h: translate,
    hh: translate,
    d: translate,
    dd: translate,
    M: translate,
    MM: translate,
    y: translate,
    yy: translate
  }
};
dayjs.locale(locale$9, null, true);

var sl = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$9
});

// Serbian [sr]
var translator = {
  words: {
    m: ['jedan minut', 'jednog minuta'],
    mm: ['%d minut', '%d minuta', '%d minuta'],
    h: ['jedan sat', 'jednog sata'],
    hh: ['%d sat', '%d sata', '%d sati'],
    d: ['jedan dan', 'jednog dana'],
    dd: ['%d dan', '%d dana', '%d dana'],
    M: ['jedan mesec', 'jednog meseca'],
    MM: ['%d mesec', '%d meseca', '%d meseci'],
    y: ['jednu godinu', 'jedne godine'],
    yy: ['%d godinu', '%d godine', '%d godina']
  },
  correctGrammarCase: function correctGrammarCase(number, wordKey) {
    if (number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
      return number % 10 === 1 ? wordKey[0] : wordKey[1];
    }

    return wordKey[2];
  },
  relativeTimeFormatter: function relativeTimeFormatter(number, withoutSuffix, key, isFuture) {
    var wordKey = translator.words[key];

    if (key.length === 1) {
      // Nominativ
      if (key === 'y' && withoutSuffix) return 'jedna godina';
      return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
    }

    var word = translator.correctGrammarCase(number, wordKey); // Nominativ

    if (key === 'yy' && withoutSuffix && word === '%d godinu') return number + " godina";
    return word.replace('%d', number);
  }
};
var locale$8 = {
  name: 'sr',
  weekdays: 'Nedelja_Ponedeljak_Utorak_Sreda_Četvrtak_Petak_Subota'.split('_'),
  weekdaysShort: 'Ned._Pon._Uto._Sre._Čet._Pet._Sub.'.split('_'),
  weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
  months: 'Januar_Februar_Mart_April_Maj_Jun_Jul_Avgust_Septembar_Oktobar_Novembar_Decembar'.split('_'),
  monthsShort: 'Jan._Feb._Mar._Apr._Maj_Jun_Jul_Avg._Sep._Okt._Nov._Dec.'.split('_'),
  weekStart: 1,
  relativeTime: {
    future: 'za %s',
    past: 'pre %s',
    s: 'nekoliko sekundi',
    m: translator.relativeTimeFormatter,
    mm: translator.relativeTimeFormatter,
    h: translator.relativeTimeFormatter,
    hh: translator.relativeTimeFormatter,
    d: translator.relativeTimeFormatter,
    dd: translator.relativeTimeFormatter,
    M: translator.relativeTimeFormatter,
    MM: translator.relativeTimeFormatter,
    y: translator.relativeTimeFormatter,
    yy: translator.relativeTimeFormatter
  },
  ordinal: function ordinal(n) {
    return n + ".";
  },
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'D. M. YYYY.',
    LL: 'D. MMMM YYYY.',
    LLL: 'D. MMMM YYYY. H:mm',
    LLLL: 'dddd, D. MMMM YYYY. H:mm'
  }
};
dayjs.locale(locale$8, null, true);

var sr = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$8
});

// Swedish [sv]
var locale$7 = {
  name: 'sv',
  weekdays: 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
  weekdaysShort: 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
  weekdaysMin: 'sö_må_ti_on_to_fr_lö'.split('_'),
  months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
  monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
  weekStart: 1,
  yearStart: 4,
  ordinal: function ordinal(n) {
    var b = n % 10;
    var o = b === 1 || b === 2 ? 'a' : 'e';
    return "[" + n + o + "]";
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'YYYY-MM-DD',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY [kl.] HH:mm',
    LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
    lll: 'D MMM YYYY HH:mm',
    llll: 'ddd D MMM YYYY HH:mm'
  },
  relativeTime: {
    future: 'om %s',
    past: 'för %s sedan',
    s: 'några sekunder',
    m: 'en minut',
    mm: '%d minuter',
    h: 'en timme',
    hh: '%d timmar',
    d: 'en dag',
    dd: '%d dagar',
    M: 'en månad',
    MM: '%d månader',
    y: 'ett år',
    yy: '%d år'
  }
};
dayjs.locale(locale$7, null, true);

var sv = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$7
});

// Thai [th]
var locale$6 = {
  name: 'th',
  weekdays: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
  weekdaysShort: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'),
  weekdaysMin: 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
  months: 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
  monthsShort: 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split('_'),
  formats: {
    LT: 'H:mm',
    LTS: 'H:mm:ss',
    L: 'DD/MM/YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY เวลา H:mm',
    LLLL: 'วันddddที่ D MMMM YYYY เวลา H:mm'
  },
  relativeTime: {
    future: 'อีก %s',
    past: '%sที่แล้ว',
    s: 'ไม่กี่วินาที',
    m: '1 นาที',
    mm: '%d นาที',
    h: '1 ชั่วโมง',
    hh: '%d ชั่วโมง',
    d: '1 วัน',
    dd: '%d วัน',
    M: '1 เดือน',
    MM: '%d เดือน',
    y: '1 ปี',
    yy: '%d ปี'
  },
  ordinal: function ordinal(n) {
    return n + ".";
  }
};
dayjs.locale(locale$6, null, true);

var th = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$6
});

// Turkish [tr]
var locale$5 = {
  name: 'tr',
  weekdays: 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
  weekdaysShort: 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
  weekdaysMin: 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
  months: 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
  monthsShort: 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
  weekStart: 1,
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D MMMM YYYY',
    LLL: 'D MMMM YYYY HH:mm',
    LLLL: 'dddd, D MMMM YYYY HH:mm'
  },
  relativeTime: {
    future: '%s sonra',
    past: '%s önce',
    s: 'birkaç saniye',
    m: 'bir dakika',
    mm: '%d dakika',
    h: 'bir saat',
    hh: '%d saat',
    d: 'bir gün',
    dd: '%d gün',
    M: 'bir ay',
    MM: '%d ay',
    y: 'bir yıl',
    yy: '%d yıl'
  },
  ordinal: function ordinal(n) {
    return n + ".";
  }
};
dayjs.locale(locale$5, null, true);

var tr = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$5
});

// Ukrainian [uk]
var monthFormat = 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_');
var monthStandalone = 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_');
var MONTHS_IN_FORMAT = /D[oD]?(\[[^[\]]*\]|\s)+MMMM?/;

function plural(word, num) {
  var forms = word.split('_');
  return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]; // eslint-disable-line
}

function relativeTimeWithPlural(number, withoutSuffix, key) {
  var format = {
    ss: withoutSuffix ? 'секунда_секунди_секунд' : 'секунду_секунди_секунд',
    mm: withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
    hh: withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
    dd: 'день_дні_днів',
    MM: 'місяць_місяці_місяців',
    yy: 'рік_роки_років'
  };

  if (key === 'm') {
    return withoutSuffix ? 'хвилина' : 'хвилину';
  } else if (key === 'h') {
    return withoutSuffix ? 'година' : 'годину';
  }

  return number + " " + plural(format[key], +number);
}

var months = function months(dayjsInstance, format) {
  if (MONTHS_IN_FORMAT.test(format)) {
    return monthFormat[dayjsInstance.month()];
  }

  return monthStandalone[dayjsInstance.month()];
};

months.s = monthStandalone;
months.f = monthFormat;
var locale$4 = {
  name: 'uk',
  weekdays: 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
  weekdaysShort: 'ндл_пнд_втр_срд_чтв_птн_сбт'.split('_'),
  weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
  months: months,
  monthsShort: 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
  weekStart: 1,
  relativeTime: {
    future: 'за %s',
    past: '%s тому',
    s: 'декілька секунд',
    m: relativeTimeWithPlural,
    mm: relativeTimeWithPlural,
    h: relativeTimeWithPlural,
    hh: relativeTimeWithPlural,
    d: 'день',
    dd: relativeTimeWithPlural,
    M: 'місяць',
    MM: relativeTimeWithPlural,
    y: 'рік',
    yy: relativeTimeWithPlural
  },
  ordinal: function ordinal(n) {
    return n;
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD.MM.YYYY',
    LL: 'D MMMM YYYY р.',
    LLL: 'D MMMM YYYY р., HH:mm',
    LLLL: 'dddd, D MMMM YYYY р., HH:mm'
  }
};
dayjs.locale(locale$4, null, true);

var uk = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$4
});

// Vietnamese [vi]
var locale$3 = {
  name: 'vi',
  weekdays: 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
  months: 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
  weekStart: 1,
  weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
  monthsShort: 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
  weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
  ordinal: function ordinal(n) {
    return n;
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'DD/MM/YYYY',
    LL: 'D MMMM [năm] YYYY',
    LLL: 'D MMMM [năm] YYYY HH:mm',
    LLLL: 'dddd, D MMMM [năm] YYYY HH:mm',
    l: 'DD/M/YYYY',
    ll: 'D MMM YYYY',
    lll: 'D MMM YYYY HH:mm',
    llll: 'ddd, D MMM YYYY HH:mm'
  },
  relativeTime: {
    future: '%s tới',
    past: '%s trước',
    s: 'vài giây',
    m: 'một phút',
    mm: '%d phút',
    h: 'một giờ',
    hh: '%d giờ',
    d: 'một ngày',
    dd: '%d ngày',
    M: 'một tháng',
    MM: '%d tháng',
    y: 'một năm',
    yy: '%d năm'
  }
};
dayjs.locale(locale$3, null, true);

var vi = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$3
});

// Chinese (China) [zh-cn]
var locale$2 = {
  name: 'zh-cn',
  weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
  weekdaysShort: '周日_周一_周二_周三_周四_周五_周六'.split('_'),
  weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
  months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
  monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
  ordinal: function ordinal(number, period) {
    switch (period) {
      case 'W':
        return number + "\u5468";

      default:
        return number + "\u65E5";
    }
  },
  weekStart: 1,
  yearStart: 4,
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'YYYY/MM/DD',
    LL: 'YYYY年M月D日',
    LLL: 'YYYY年M月D日Ah点mm分',
    LLLL: 'YYYY年M月D日ddddAh点mm分',
    l: 'YYYY/M/D',
    ll: 'YYYY年M月D日',
    lll: 'YYYY年M月D日 HH:mm',
    llll: 'YYYY年M月D日dddd HH:mm'
  },
  relativeTime: {
    future: '%s内',
    past: '%s前',
    s: '几秒',
    m: '1 分钟',
    mm: '%d 分钟',
    h: '1 小时',
    hh: '%d 小时',
    d: '1 天',
    dd: '%d 天',
    M: '1 个月',
    MM: '%d 个月',
    y: '1 年',
    yy: '%d 年'
  },
  meridiem: function meridiem(hour, minute) {
    var hm = hour * 100 + minute;

    if (hm < 600) {
      return '凌晨';
    } else if (hm < 900) {
      return '早上';
    } else if (hm < 1100) {
      return '上午';
    } else if (hm < 1300) {
      return '中午';
    } else if (hm < 1800) {
      return '下午';
    }

    return '晚上';
  }
};
dayjs.locale(locale$2, null, true);

var zhCn = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$2
});

// Chinese (Hong Kong) [zh-hk]
var locale$1 = {
  name: 'zh-hk',
  months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
  monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
  weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
  weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
  weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
  ordinal: function ordinal(number, period) {
    switch (period) {
      case 'W':
        return number + "\u9031";

      default:
        return number + "\u65E5";
    }
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'YYYY/MM/DD',
    LL: 'YYYY年M月D日',
    LLL: 'YYYY年M月D日 HH:mm',
    LLLL: 'YYYY年M月D日dddd HH:mm'
  },
  relativeTime: {
    future: '%s內',
    past: '%s前',
    s: '幾秒',
    m: '一分鐘',
    mm: '%d 分鐘',
    h: '一小時',
    hh: '%d 小時',
    d: '一天',
    dd: '%d 天',
    M: '一個月',
    MM: '%d 個月',
    y: '一年',
    yy: '%d 年'
  }
};
dayjs.locale(locale$1, null, true);

var zhHk = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale$1
});

// Chinese (Taiwan) [zh-tw]
var locale = {
  name: 'zh-tw',
  weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
  weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
  weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
  months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
  monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
  ordinal: function ordinal(number, period) {
    switch (period) {
      case 'W':
        return number + "\u9031";

      default:
        return number + "\u65E5";
    }
  },
  formats: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'YYYY/MM/DD',
    LL: 'YYYY年M月D日',
    LLL: 'YYYY年M月D日 HH:mm',
    LLLL: 'YYYY年M月D日dddd HH:mm',
    l: 'YYYY/M/D',
    ll: 'YYYY年M月D日',
    lll: 'YYYY年M月D日 HH:mm',
    llll: 'YYYY年M月D日dddd HH:mm'
  },
  relativeTime: {
    future: '%s內',
    past: '%s前',
    s: '幾秒',
    m: '1 分鐘',
    mm: '%d 分鐘',
    h: '1 小時',
    hh: '%d 小時',
    d: '1 天',
    dd: '%d 天',
    M: '1 個月',
    MM: '%d 個月',
    y: '1 年',
    yy: '%d 年'
  },
  meridiem: function meridiem(hour, minute) {
    var hm = hour * 100 + minute;

    if (hm < 600) {
      return '凌晨';
    } else if (hm < 900) {
      return '早上';
    } else if (hm < 1100) {
      return '上午';
    } else if (hm < 1300) {
      return '中午';
    } else if (hm < 1800) {
      return '下午';
    }

    return '晚上';
  }
};
dayjs.locale(locale, null, true);

var zhTw = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': locale
});

const supportedTimeZones = (() => {
    const platformTimeZones = Intl.supportedValuesOf('timeZone');
    // not all browsers include these time zones, so we add them to ensure consistent groups
    const etcTimeZones = [
        "Etc/GMT+1",
        "Etc/GMT+10",
        "Etc/GMT+11",
        "Etc/GMT+12",
        "Etc/GMT+2",
        "Etc/GMT+3",
        "Etc/GMT+4",
        "Etc/GMT+5",
        "Etc/GMT+6",
        "Etc/GMT+7",
        "Etc/GMT+8",
        "Etc/GMT+9",
        "Etc/GMT-1",
        "Etc/GMT-10",
        "Etc/GMT-11",
        "Etc/GMT-12",
        "Etc/GMT-13",
        "Etc/GMT-14",
        "Etc/GMT-2",
        "Etc/GMT-3",
        "Etc/GMT-4",
        "Etc/GMT-5",
        "Etc/GMT-6",
        "Etc/GMT-7",
        "Etc/GMT-8",
        "Etc/GMT-9"
    ];
    return [...new Set([...platformTimeZones, ...etcTimeZones])];
})();

const now = new Date();
const startDate = now.toISOString();
const daysInYear = 365;
const groupDateRange = daysInYear;
const defaultGroupingOptions = {
    startDate,
    groupDateRange,
    debug: false,
};

const continentAllowList = new Set([
    'Europe',
    'Asia',
    'America',
    'America/Argentina',
    'Africa',
    'Australia',
    'Pacific',
    'Atlantic',
    'Antarctica',
    'Arctic',
    'Indian',
]);
const _getDates = (startDate, numberDays, dateEngine) => {
    const dateArray = [];
    let date = dateEngine.create(startDate);
    for (let i = 0; i <= numberDays; i++) {
        date = dateEngine.increase(date);
        dateArray.push(dateEngine.formatToIsoDateString(date));
    }
    return dateArray;
};
const _extractContinent = (label) => {
    if (label.includes('Istanbul')) {
        return 'Europe';
    }
    const lastIndex = label.lastIndexOf('/');
    return lastIndex === -1 ? label : label.slice(0, lastIndex);
};
const _isRegularContinent = (continent) => continentAllowList.has(continent);
const generateTimeZoneMetadata = (timeZoneItems, startDate, numberDays, dateEngine, debug = false) => {
    const processedDates = new Map();
    if (debug) {
        console.log(`Initializing data starting ${startDate} with ${numberDays} days in the future, comparing ${timeZoneItems.length} timezones`);
    }
    const theDates = _getDates(startDate, numberDays, dateEngine);
    return timeZoneItems.map((tzItem) => {
        const label = tzItem.label;
        const continent = _extractContinent(label);
        const dates = theDates.map((date) => {
            const key = `${date}-${label}`;
            let utc = processedDates.get(key);
            if (utc) {
                return utc;
            }
            utc = dateEngine.isoToTimeZone(date, label);
            processedDates.set(key, utc);
            return utc;
        });
        return {
            ...tzItem,
            continent,
            isRegularContinent: _isRegularContinent(continent),
            dates,
        };
    });
};
const compareDateArrs = (array1, array2, dateEngine) => array1.length === array2.length &&
    array1.every((value, index) => dateEngine.same(value, array2[index]));
const getGroupLabelTimeZoneIndices = (rawTZs, max = 5) => {
    const shrinkedTzs = rawTZs.filter(({ label }) => _isRegularContinent(_extractContinent(label)));
    if (shrinkedTzs.length === 0) {
        return [0];
    }
    const validLabels = shrinkedTzs.map((tz) => rawTZs.indexOf(tz));
    return equallyDistributedSampling(validLabels, max);
};
function equallyDistributedSampling(items, maxItems = 5) {
    const totalItems = items.length;
    if (totalItems <= maxItems) {
        return items;
    }
    const numberItemsToSelect = Math.min(totalItems - 2, maxItems - 2);
    const stepSize = (totalItems - 1) / (numberItemsToSelect + 1);
    return [
        items[0],
        ...Array.from({ length: numberItemsToSelect }, (_, i) => items[Math.round((i + 1) * stepSize)]),
        items[totalItems - 1],
    ];
}

async function groupTimeZones(options) {
    const { debug, groupDateRange, hooks, startDate, dateEngine } = {
        ...defaultGroupingOptions,
        ...options,
    };
    const grouping = [];
    if (!dateEngine) {
        throw new Error('dateEngine is required');
    }
    const timeZoneItems = supportedTimeZones.map((tz) => ({ label: tz }));
    hooks?.onBeforeTimeZoneMetadataCreate?.(timeZoneItems);
    const timeZoneMetadata = generateTimeZoneMetadata(timeZoneItems, startDate, groupDateRange, dateEngine, debug);
    hooks?.onTimeZoneMetadataCreate?.(timeZoneMetadata);
    // We traverse the mappedDB and see if we find matches by comparing each set
    // of transformed date for that specific TZ.
    for (const tzMetadatumI of timeZoneMetadata) {
        const { label, continent, dates } = tzMetadatumI;
        // ignore if we visited this element already
        if (tzMetadatumI.visited) {
            continue;
        }
        // Mark element as already visited
        tzMetadatumI.visited = true;
        // The grouped timezone that we want as a result
        const newGroup = {
            labelTzIndices: undefined,
            tzs: [{ label }],
        };
        hooks?.onGroupCreate?.(newGroup, tzMetadatumI);
        for (const tzMetadatumJ of timeZoneMetadata.filter((_) => !_.visited)) {
            const { label: labelJ, continent: continentJ, isRegularContinent: isRegularContinentJ, dates: datesJ, } = tzMetadatumJ;
            // We define a matching TZ by:
            // 1) if both continents match (avoid grouping Antarctica with anything else)
            // 2) if the transformed dates match in both TZs
            if ((continent === continentJ || !isRegularContinentJ) &&
                compareDateArrs(dates, datesJ, dateEngine)) {
                const tzItem = { label: labelJ };
                newGroup.tzs.push(tzItem);
                hooks?.onGroupTimeZoneAdd?.(newGroup, tzItem, tzMetadatumJ);
                // Mark element as already visited
                tzMetadatumJ.visited = true;
            }
        }
        grouping.push(newGroup);
        hooks?.onGroupAdd?.(newGroup);
    }
    // Now that we have a group, we want an easy way to find a fitting label for the group
    // which is defined as the list of the most-common 7 cities, shown in alphabetical order
    const finalGrouping = grouping
        .map((group) => {
        hooks?.onBeforeFinalGroupCreate?.(group);
        group.tzs = group.tzs.sort((a, b) => a.label.localeCompare(b.label));
        const finalGrouping = {
            labelTzIndices: getGroupLabelTimeZoneIndices(group.tzs, 7),
            tzs: group.tzs.map((_) => _.label),
        };
        hooks?.onFinalGroupCreate?.(finalGrouping, group);
        return finalGrouping;
    })
        .sort((a, b) => b.tzs.length - a.tzs.length);
    if (debug) {
        const missingTzs = supportedTimeZones
            .map((tz) => (finalGrouping.some((y) => y.tzs.includes(tz)) ? null : tz))
            .filter(Boolean);
        if (missingTzs.length > 0) {
            throw new Error(`There are ${missingTzs.length} missing timezones: ${missingTzs.toString()}`);
        }
    }
    return hooks?.onFinalGroupingCreate
        ? hooks.onFinalGroupingCreate(finalGrouping)
        : finalGrouping;
}

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    groupTimeZones: groupTimeZones
});

class NativeDateEngine {
    constructor() {
        this._formatterCache = new Map();
        this._commonDateTimeFormatterOptions = {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            timeZoneName: 'shortOffset',
        };
    }
    get name() {
        return 'native';
    }
    create(date) {
        return new Date(date);
    }
    increase(date) {
        const oneDayInMs = 86400000;
        return new Date(date.getTime() + oneDayInMs);
    }
    formatToIsoDateString(date) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const day = date.getDate();
        return `${year}-${month.toString().padStart(2, '0')}-${day
            .toString()
            .padStart(2, '0')}`;
    }
    isoToTimeZone(isoDate, tz) {
        const date = this._toDate(isoDate);
        const formatter = this._getFormatter(tz);
        const parts = formatter.formatToParts(date);
        const [offset] = parts
            .filter(({ type }) => type === 'timeZoneName')
            .map(({ value }) => value);
        const tzOffset = this._getTimeZoneOffsetInMins(offset);
        const tzOffsetMinutes = date.getMinutes() - (date.getTimezoneOffset() - tzOffset);
        date.setMinutes(tzOffsetMinutes);
        return date;
    }
    same(date1, date2) {
        return date1.getTime() === date2.getTime();
    }
    _toDate(isoDate) {
        return new Date(isoDate);
    }
    _getFormatter(tz) {
        let formatter = this._formatterCache.get(tz);
        if (!formatter) {
            formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: tz,
                ...this._commonDateTimeFormatterOptions,
            });
            this._formatterCache.set(tz, formatter);
        }
        return formatter;
    }
    _getTimeZoneOffsetInMins(gmtTimeZone) {
        const [sign, ...hoursMinutes] = gmtTimeZone.slice(3);
        const [hours, minutes] = hoursMinutes.join('').split(':');
        const signMultiplier = sign === '+' ? 1 : -1;
        return signMultiplier * (Number(hours) * 60 + Number(minutes || 0));
    }
}

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DateEngine: NativeDateEngine
});

exports.hydrateApp = hydrateApp;


    /*hydrateAppClosure end*/
    hydrateApp(window, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve);
  }

  hydrateAppClosure($stencilWindow);
}

function createWindowFromHtml(e, t) {
 let r = templateWindows.get(t);
 return null == r && (r = new MockWindow(e), templateWindows.set(t, r)), cloneWindow(r);
}

function inspectElement(e, t, r) {
 const s = t.children;
 for (let t = 0, n = s.length; t < n; t++) {
  const n = s[t], o = n.nodeName.toLowerCase();
  if (o.includes("-")) {
   const t = e.components.find((e => e.tag === o));
   null != t && (t.count++, r > t.depth && (t.depth = r));
  } else switch (o) {
  case "a":
   const t = collectAttributes(n);
   t.href = n.href, "string" == typeof t.href && (e.anchors.some((e => e.href === t.href)) || e.anchors.push(t));
   break;

  case "img":
   const r = collectAttributes(n);
   r.src = n.src, "string" == typeof r.src && (e.imgs.some((e => e.src === r.src)) || e.imgs.push(r));
   break;

  case "link":
   const s = collectAttributes(n);
   s.href = n.href, "string" == typeof s.rel && "stylesheet" === s.rel.toLowerCase() && "string" == typeof s.href && (e.styles.some((e => e.link === s.href)) || (delete s.rel, 
   delete s.type, e.styles.push(s)));
   break;

  case "script":
   const o = collectAttributes(n);
   if (n.hasAttribute("src")) o.src = n.src, "string" == typeof o.src && (e.scripts.some((e => e.src === o.src)) || e.scripts.push(o)); else {
    const t = n.getAttribute("data-stencil-static");
    t && e.staticData.push({
     id: t,
     type: n.getAttribute("type"),
     content: n.textContent
    });
   }
  }
  inspectElement(e, n, ++r);
 }
}

function collectAttributes(e) {
 const t = {}, r = e.attributes;
 for (let e = 0, s = r.length; e < s; e++) {
  const s = r.item(e), n = s.nodeName.toLowerCase();
  if (SKIP_ATTRS.has(n)) continue;
  const o = s.nodeValue;
  "class" === n && "" === o || (t[n] = o);
 }
 return t;
}

function patchDomImplementation(e, t) {
 let r;
 if (null != e.defaultView ? (t.destroyWindow = !0, patchWindow(e.defaultView), r = e.defaultView) : (t.destroyWindow = !0, 
 t.destroyDocument = !1, r = new MockWindow(!1)), r.document !== e && (r.document = e), 
 e.defaultView !== r && (e.defaultView = r), "function" != typeof e.documentElement.constructor.prototype.getRootNode && (e.createElement("unknown-element").constructor.prototype.getRootNode = getRootNode), 
 "function" == typeof e.createEvent) {
  const t = e.createEvent("CustomEvent").constructor;
  r.CustomEvent !== t && (r.CustomEvent = t);
 }
 try {
  r.__stencil_baseURI = e.baseURI;
 } catch (t) {
  Object.defineProperty(e, "baseURI", {
   get() {
    const t = e.querySelector("base[href]");
    return t ? new URL(t.getAttribute("href"), r.location.href).href : r.location.href;
   }
  });
 }
 return r;
}

function getRootNode(e) {
 const t = null != e && !0 === e.composed;
 let r = this;
 for (;null != r.parentNode; ) r = r.parentNode, !0 === t && null == r.parentNode && null != r.host && (r = r.host);
 return r;
}

function normalizeHydrateOptions(e) {
 const t = Object.assign({
  serializeToHtml: !1,
  destroyWindow: !1,
  destroyDocument: !1
 }, e || {});
 return "boolean" != typeof t.clientHydrateAnnotations && (t.clientHydrateAnnotations = !0), 
 "boolean" != typeof t.constrainTimeouts && (t.constrainTimeouts = !0), "number" != typeof t.maxHydrateCount && (t.maxHydrateCount = 300), 
 "boolean" != typeof t.runtimeLogging && (t.runtimeLogging = !1), "number" != typeof t.timeout && (t.timeout = 15e3), 
 Array.isArray(t.excludeComponents) ? t.excludeComponents = t.excludeComponents.filter(filterValidTags).map(mapValidTags) : t.excludeComponents = [], 
 Array.isArray(t.staticComponents) ? t.staticComponents = t.staticComponents.filter(filterValidTags).map(mapValidTags) : t.staticComponents = [], 
 t;
}

function filterValidTags(e) {
 return "string" == typeof e && e.includes("-");
}

function mapValidTags(e) {
 return e.trim().toLowerCase();
}

function generateHydrateResults(e) {
 "string" != typeof e.url && (e.url = "https://hydrate.stenciljs.com/"), "string" != typeof e.buildId && (e.buildId = createHydrateBuildId());
 const t = {
  buildId: e.buildId,
  diagnostics: [],
  url: e.url,
  host: null,
  hostname: null,
  href: null,
  pathname: null,
  port: null,
  search: null,
  hash: null,
  html: null,
  httpStatus: null,
  hydratedCount: 0,
  anchors: [],
  components: [],
  imgs: [],
  scripts: [],
  staticData: [],
  styles: [],
  title: null
 };
 try {
  const r = new URL(e.url, "https://hydrate.stenciljs.com/");
  t.url = r.href, t.host = r.host, t.hostname = r.hostname, t.href = r.href, t.port = r.port, 
  t.pathname = r.pathname, t.search = r.search, t.hash = r.hash;
 } catch (e) {
  renderCatchError(t, e);
 }
 return t;
}

function renderBuildDiagnostic(e, t, r, s) {
 const n = {
  level: t,
  type: "build",
  header: r,
  messageText: s,
  relFilePath: void 0,
  absFilePath: void 0,
  lines: []
 };
 return e.pathname ? "/" !== e.pathname && (n.header += ": " + e.pathname) : e.url && (n.header += ": " + e.url), 
 e.diagnostics.push(n), n;
}

function renderBuildError(e, t) {
 return renderBuildDiagnostic(e, "error", "Hydrate Error", t);
}

function renderCatchError(e, t) {
 const r = renderBuildError(e, null);
 return null != t && (null != t.stack ? r.messageText = t.stack.toString() : null != t.message ? r.messageText = t.message.toString() : r.messageText = t.toString()), 
 r;
}

function runtimeLog(e, t, r) {
 global.console[t].apply(global.console, [ `[ ${e}  ${t} ] `, ...r ]);
}

function renderToString(e, t) {
 const r = normalizeHydrateOptions(t);
 return r.serializeToHtml = !0, new Promise((t => {
  let s;
  const n = generateHydrateResults(r);
  if (hasError(n.diagnostics)) t(n); else if ("string" == typeof e) try {
   r.destroyWindow = !0, r.destroyDocument = !0, s = new MockWindow(e), render(s, r, n, t);
  } catch (e) {
   s && s.close && s.close(), s = null, renderCatchError(n, e), t(n);
  } else if (isValidDocument(e)) try {
   r.destroyDocument = !1, s = patchDomImplementation(e, r), render(s, r, n, t);
  } catch (e) {
   s && s.close && s.close(), s = null, renderCatchError(n, e), t(n);
  } else renderBuildError(n, 'Invalid html or document. Must be either a valid "html" string, or DOM "document".'), 
  t(n);
 }));
}

function hydrateDocument(e, t) {
 const r = normalizeHydrateOptions(t);
 return r.serializeToHtml = !1, new Promise((t => {
  let s;
  const n = generateHydrateResults(r);
  if (hasError(n.diagnostics)) t(n); else if ("string" == typeof e) try {
   r.destroyWindow = !0, r.destroyDocument = !0, s = new MockWindow(e), render(s, r, n, t);
  } catch (e) {
   s && s.close && s.close(), s = null, renderCatchError(n, e), t(n);
  } else if (isValidDocument(e)) try {
   r.destroyDocument = !1, s = patchDomImplementation(e, r), render(s, r, n, t);
  } catch (e) {
   s && s.close && s.close(), s = null, renderCatchError(n, e), t(n);
  } else renderBuildError(n, 'Invalid html or document. Must be either a valid "html" string, or DOM "document".'), 
  t(n);
 }));
}

function render(e, t, r, s) {
 if (process.__stencilErrors || (process.__stencilErrors = !0, process.on("unhandledRejection", (e => {
  console.log("unhandledRejection", e);
 }))), function n(e, t, r, s) {
  try {
   e.location.href = r.url;
  } catch (e) {
   renderCatchError(s, e);
  }
  if ("string" == typeof r.userAgent) try {
   e.navigator.userAgent = r.userAgent;
  } catch (e) {}
  if ("string" == typeof r.cookie) try {
   t.cookie = r.cookie;
  } catch (e) {}
  if ("string" == typeof r.referrer) try {
   t.referrer = r.referrer;
  } catch (e) {}
  if ("string" == typeof r.direction) try {
   t.documentElement.setAttribute("dir", r.direction);
  } catch (e) {}
  if ("string" == typeof r.language) try {
   t.documentElement.setAttribute("lang", r.language);
  } catch (e) {}
  if ("string" == typeof r.buildId) try {
   t.documentElement.setAttribute("data-stencil-build", r.buildId);
  } catch (e) {}
  try {
   e.customElements = null;
  } catch (e) {}
  return r.constrainTimeouts && constrainTimeouts(e), function n(e, t, r) {
   try {
    const s = e.location.pathname;
    e.console.error = (...e) => {
     const n = e.reduce(((e, t) => {
      if (t) {
       if (null != t.stack) return e + " " + String(t.stack);
       if (null != t.message) return e + " " + String(t.message);
      }
      return String(t);
     }), "").trim();
     "" !== n && (renderCatchError(r, n), t.runtimeLogging && runtimeLog(s, "error", [ n ]));
    }, e.console.debug = (...e) => {
     renderBuildDiagnostic(r, "debug", "Hydrate Debug", [ ...e ].join(", ")), t.runtimeLogging && runtimeLog(s, "debug", e);
    }, t.runtimeLogging && [ "log", "warn", "assert", "info", "trace" ].forEach((t => {
     e.console[t] = (...e) => {
      runtimeLog(s, t, e);
     };
    }));
   } catch (e) {
    renderCatchError(r, e);
   }
  }(e, r, s), e;
 }(e, e.document, t, r), "function" == typeof t.beforeHydrate) try {
  const n = t.beforeHydrate(e.document);
  isPromise(n) ? n.then((() => {
   hydrateFactory(e, t, r, afterHydrate, s);
  })) : hydrateFactory(e, t, r, afterHydrate, s);
 } catch (n) {
  renderCatchError(r, n), finalizeHydrate(e, e.document, t, r, s);
 } else hydrateFactory(e, t, r, afterHydrate, s);
}

function afterHydrate(e, t, r, s) {
 if ("function" == typeof t.afterHydrate) try {
  const n = t.afterHydrate(e.document);
  isPromise(n) ? n.then((() => {
   finalizeHydrate(e, e.document, t, r, s);
  })) : finalizeHydrate(e, e.document, t, r, s);
 } catch (n) {
  renderCatchError(r, n), finalizeHydrate(e, e.document, t, r, s);
 } else finalizeHydrate(e, e.document, t, r, s);
}

function finalizeHydrate(e, t, r, s, n) {
 try {
  if (inspectElement(s, t.documentElement, 0), !1 !== r.removeUnusedStyles) try {
   removeUnusedStyles(t, s.diagnostics);
  } catch (e) {
   renderCatchError(s, e);
  }
  if ("string" == typeof r.title) try {
   t.title = r.title;
  } catch (e) {
   renderCatchError(s, e);
  }
  s.title = t.title, r.removeScripts && removeScripts(t.documentElement);
  try {
   updateCanonicalLink(t, r.canonicalUrl);
  } catch (e) {
   renderCatchError(s, e);
  }
  try {
   relocateMetaCharset(t);
  } catch (e) {}
  hasError(s.diagnostics) || (s.httpStatus = 200);
  try {
   const e = t.head.querySelector('meta[http-equiv="status"]');
   if (null != e) {
    const t = e.getAttribute("content");
    t && t.length > 0 && (s.httpStatus = parseInt(t, 10));
   }
  } catch (e) {}
  r.clientHydrateAnnotations && t.documentElement.classList.add("hydrated"), r.serializeToHtml && (s.html = serializeDocumentToString(t, r));
 } catch (e) {
  renderCatchError(s, e);
 }
 if (r.destroyWindow) try {
  r.destroyDocument || (e.document = null, t.defaultView = null), e.close && e.close();
 } catch (e) {
  renderCatchError(s, e);
 }
 n(s);
}

function serializeDocumentToString(e, t) {
 return serializeNodeToHtml(e, {
  approximateLineWidth: t.approximateLineWidth,
  outerHtml: !1,
  prettyHtml: t.prettyHtml,
  removeAttributeQuotes: t.removeAttributeQuotes,
  removeBooleanAttributeQuotes: t.removeBooleanAttributeQuotes,
  removeEmptyAttributes: t.removeEmptyAttributes,
  removeHtmlComments: t.removeHtmlComments,
  serializeShadowRoot: !1
 });
}

function isValidDocument(e) {
 return null != e && 9 === e.nodeType && null != e.documentElement && 1 === e.documentElement.nodeType && null != e.body && 1 === e.body.nodeType;
}

function removeScripts(e) {
 const t = e.children;
 for (let e = t.length - 1; e >= 0; e--) {
  const r = t[e];
  removeScripts(r), ("SCRIPT" === r.nodeName || "LINK" === r.nodeName && "modulepreload" === r.getAttribute("rel")) && r.remove();
 }
}

const templateWindows = new Map, isPromise = e => !!e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then, hasError = e => null != e && 0 !== e.length && e.some((e => "error" === e.level && "runtime" !== e.type)), TASK_CANCELED_MSG = "task canceled", updateCanonicalLink = (e, t) => {
 let r = e.head.querySelector('link[rel="canonical"]');
 "string" == typeof t ? (null == r && (r = e.createElement("link"), r.setAttribute("rel", "canonical"), 
 e.head.appendChild(r)), r.setAttribute("href", t)) : null != r && (r.getAttribute("href") || r.parentNode.removeChild(r));
}, relocateMetaCharset = e => {
 const t = e.head;
 let r = t.querySelector("meta[charset]");
 null == r ? (r = e.createElement("meta"), r.setAttribute("charset", "utf-8")) : r.remove(), 
 t.insertBefore(r, t.firstChild);
}, parseCss = (e, t) => {
 let r = 1, s = 1;
 const n = [], o = e => {
  const t = e.match(/\n/g);
  t && (r += t.length);
  const n = e.lastIndexOf("\n");
  s = ~n ? e.length - n : s + e.length;
 }, i = () => {
  const e = {
   line: r,
   column: s
  };
  return t => (t.position = new A(e), m(), t);
 }, a = o => {
  const i = e.split("\n"), a = {
   level: "error",
   type: "css",
   language: "css",
   header: "CSS Parse",
   messageText: o,
   absFilePath: t,
   lines: [ {
    lineIndex: r - 1,
    lineNumber: r,
    errorCharStart: s,
    text: e[r - 1]
   } ]
  };
  if (r > 1) {
   const t = {
    lineIndex: r - 1,
    lineNumber: r - 1,
    text: e[r - 2],
    errorCharStart: -1,
    errorLength: -1
   };
   a.lines.unshift(t);
  }
  if (r + 2 < i.length) {
   const e = {
    lineIndex: r,
    lineNumber: r + 1,
    text: i[r],
    errorCharStart: -1,
    errorLength: -1
   };
   a.lines.push(e);
  }
  return n.push(a), null;
 }, l = () => u(/^{\s*/), c = () => u(/^}/), u = t => {
  const r = t.exec(e);
  if (!r) return;
  const s = r[0];
  return o(s), e = e.slice(s.length), r;
 }, d = () => {
  let t;
  const r = [];
  for (m(), h(r); e.length && "}" !== e.charAt(0) && (t = T() || w()); ) r.push(t), 
  h(r);
  return r;
 }, m = () => u(/^\s*/), h = e => {
  let t;
  for (e = e || []; t = p(); ) e.push(t);
  return e;
 }, p = () => {
  const t = i();
  if ("/" !== e.charAt(0) || "*" !== e.charAt(1)) return null;
  let r = 2;
  for (;"" !== e.charAt(r) && ("*" !== e.charAt(r) || "/" !== e.charAt(r + 1)); ) ++r;
  if (r += 2, "" === e.charAt(r - 1)) return a("End of comment missing");
  const n = e.slice(2, r - 2);
  return s += 2, o(n), e = e.slice(r), s += 2, t({
   type: 1,
   comment: n
  });
 }, f = () => {
  const e = u(/^([^{]+)/);
  return e ? trim(e[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, "").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, (function(e) {
   return e.replace(/,/g, "‌");
  })).split(/\s*(?![^(]*\)),\s*/).map((function(e) {
   return e.replace(/\u200C/g, ",");
  })) : null;
 }, g = () => {
  const e = i();
  let t = u(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
  if (!t) return null;
  if (t = trim(t[0]), !u(/^:\s*/)) return a("property missing ':'");
  const r = u(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/), s = e({
   type: 4,
   property: t.replace(commentre, ""),
   value: r ? trim(r[0]).replace(commentre, "") : ""
  });
  return u(/^[;\s]*/), s;
 }, y = () => {
  const e = [];
  if (!l()) return a("missing '{'");
  let t;
  for (h(e); t = g(); ) e.push(t), h(e);
  return c() ? e : a("missing '}'");
 }, C = () => {
  let e;
  const t = [], r = i();
  for (;e = u(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/); ) t.push(e[1]), u(/^,\s*/);
  return t.length ? r({
   type: 9,
   values: t,
   declarations: y()
  }) : null;
 }, S = (e, t) => {
  const r = new RegExp("^@" + e + "\\s*([^;]+);");
  return () => {
   const s = i(), n = u(r);
   if (!n) return null;
   const o = {
    type: t
   };
   return o[e] = n[1].trim(), s(o);
  };
 }, E = S("import", 7), b = S("charset", 0), v = S("namespace", 11), T = () => "@" !== e[0] ? null : (() => {
  const e = i();
  let t = u(/^@([-\w]+)?keyframes\s*/);
  if (!t) return null;
  const r = t[1];
  if (t = u(/^([-\w]+)\s*/), !t) return a("@keyframes missing name");
  const s = t[1];
  if (!l()) return a("@keyframes missing '{'");
  let n, o = h();
  for (;n = C(); ) o.push(n), o = o.concat(h());
  return c() ? e({
   type: 8,
   name: s,
   vendor: r,
   keyframes: o
  }) : a("@keyframes missing '}'");
 })() || (() => {
  const e = i(), t = u(/^@media *([^{]+)/);
  if (!t) return null;
  const r = trim(t[1]);
  if (!l()) return a("@media missing '{'");
  const s = h().concat(d());
  return c() ? e({
   type: 10,
   media: r,
   rules: s
  }) : a("@media missing '}'");
 })() || (() => {
  const e = i(), t = u(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
  return t ? e({
   type: 2,
   name: trim(t[1]),
   media: trim(t[2])
  }) : null;
 })() || (() => {
  const e = i(), t = u(/^@supports *([^{]+)/);
  if (!t) return null;
  const r = trim(t[1]);
  if (!l()) return a("@supports missing '{'");
  const s = h().concat(d());
  return c() ? e({
   type: 15,
   supports: r,
   rules: s
  }) : a("@supports missing '}'");
 })() || E() || b() || v() || (() => {
  const e = i(), t = u(/^@([-\w]+)?document *([^{]+)/);
  if (!t) return null;
  const r = trim(t[1]), s = trim(t[2]);
  if (!l()) return a("@document missing '{'");
  const n = h().concat(d());
  return c() ? e({
   type: 3,
   document: s,
   vendor: r,
   rules: n
  }) : a("@document missing '}'");
 })() || (() => {
  const e = i();
  if (!u(/^@page */)) return null;
  const t = f() || [];
  if (!l()) return a("@page missing '{'");
  let r, s = h();
  for (;r = g(); ) s.push(r), s = s.concat(h());
  return c() ? e({
   type: 12,
   selectors: t,
   declarations: s
  }) : a("@page missing '}'");
 })() || (() => {
  const e = i();
  if (!u(/^@host\s*/)) return null;
  if (!l()) return a("@host missing '{'");
  const t = h().concat(d());
  return c() ? e({
   type: 6,
   rules: t
  }) : a("@host missing '}'");
 })() || (() => {
  const e = i();
  if (!u(/^@font-face\s*/)) return null;
  if (!l()) return a("@font-face missing '{'");
  let t, r = h();
  for (;t = g(); ) r.push(t), r = r.concat(h());
  return c() ? e({
   type: 5,
   declarations: r
  }) : a("@font-face missing '}'");
 })(), w = () => {
  const e = i(), t = f();
  return t ? (h(), e({
   type: 13,
   selectors: t,
   declarations: y()
  })) : a("selector missing");
 };
 class A {
  constructor(e) {
   this.start = e, this.end = {
    line: r,
    column: s
   }, this.source = t;
  }
 }
 return A.prototype.content = e, {
  diagnostics: n,
  ...addParent((() => {
   const e = d();
   return {
    type: 14,
    stylesheet: {
     source: t,
     rules: e
    }
   };
  })())
 };
}, trim = e => e ? e.trim() : "", addParent = (e, t) => {
 const r = e && "string" == typeof e.type, s = r ? e : t;
 for (const t in e) {
  const r = e[t];
  Array.isArray(r) ? r.forEach((function(e) {
   addParent(e, s);
  })) : r && "object" == typeof r && addParent(r, s);
 }
 return r && Object.defineProperty(e, "parent", {
  configurable: !0,
  writable: !0,
  enumerable: !1,
  value: t || null
 }), e;
}, commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, getCssSelectors = e => {
 SELECTORS.all.length = SELECTORS.tags.length = SELECTORS.classNames.length = SELECTORS.ids.length = SELECTORS.attrs.length = 0;
 const t = (e = e.replace(/\./g, " .").replace(/\#/g, " #").replace(/\[/g, " [").replace(/\>/g, " > ").replace(/\+/g, " + ").replace(/\~/g, " ~ ").replace(/\*/g, " * ").replace(/\:not\((.*?)\)/g, " ")).split(" ");
 for (let e = 0, r = t.length; e < r; e++) t[e] = t[e].split(":")[0], 0 !== t[e].length && ("." === t[e].charAt(0) ? SELECTORS.classNames.push(t[e].slice(1)) : "#" === t[e].charAt(0) ? SELECTORS.ids.push(t[e].slice(1)) : "[" === t[e].charAt(0) ? (t[e] = t[e].slice(1).split("=")[0].split("]")[0].trim(), 
 SELECTORS.attrs.push(t[e].toLowerCase())) : /[a-z]/g.test(t[e].charAt(0)) && SELECTORS.tags.push(t[e].toLowerCase()));
 return SELECTORS.classNames = SELECTORS.classNames.sort(((e, t) => e.length < t.length ? -1 : e.length > t.length ? 1 : 0)), 
 SELECTORS;
}, SELECTORS = {
 all: [],
 tags: [],
 classNames: [],
 ids: [],
 attrs: []
}, serializeCssVisitNode = (e, t, r, s) => {
 var n;
 const o = t.type;
 return 4 === o ? serializeCssDeclaration(t, r, s) : 13 === o ? serializeCssRule(e, t) : 1 === o ? "!" === (null === (n = t.comment) || void 0 === n ? void 0 : n[0]) ? `/*${t.comment}*/` : "" : 10 === o ? serializeCssMedia(e, t) : 8 === o ? serializeCssKeyframes(e, t) : 9 === o ? serializeCssKeyframe(e, t) : 5 === o ? serializeCssFontFace(e, t) : 15 === o ? serializeCssSupports(e, t) : 7 === o ? "@import " + t.import + ";" : 0 === o ? "@charset " + t.charset + ";" : 12 === o ? serializeCssPage(e, t) : 6 === o ? "@host{" + serializeCssMapVisit(e, t.rules) + "}" : 2 === o ? "@custom-media " + t.name + " " + t.media + ";" : 3 === o ? serializeCssDocument(e, t) : 11 === o ? "@namespace " + t.namespace + ";" : "";
}, serializeCssRule = (e, t) => {
 var r, s;
 const n = t.declarations, o = e.usedSelectors, i = null !== (s = null === (r = t.selectors) || void 0 === r ? void 0 : r.slice()) && void 0 !== s ? s : [];
 if (null == n || 0 === n.length) return "";
 if (o) {
  let t, r, s = !0;
  for (t = i.length - 1; t >= 0; t--) {
   const n = getCssSelectors(i[t]);
   s = !0;
   let a = n.classNames.length;
   if (a > 0 && e.hasUsedClassNames) for (r = 0; r < a; r++) if (!o.classNames.has(n.classNames[r])) {
    s = !1;
    break;
   }
   if (s && e.hasUsedTags && (a = n.tags.length, a > 0)) for (r = 0; r < a; r++) if (!o.tags.has(n.tags[r])) {
    s = !1;
    break;
   }
   if (s && e.hasUsedAttrs && (a = n.attrs.length, a > 0)) for (r = 0; r < a; r++) if (!o.attrs.has(n.attrs[r])) {
    s = !1;
    break;
   }
   if (s && e.hasUsedIds && (a = n.ids.length, a > 0)) for (r = 0; r < a; r++) if (!o.ids.has(n.ids[r])) {
    s = !1;
    break;
   }
   s || i.splice(t, 1);
  }
 }
 if (0 === i.length) return "";
 const a = [];
 let l = "";
 if (t.selectors) for (const e of t.selectors) l = removeSelectorWhitespace(e), a.includes(l) || a.push(l);
 return `${a}{${serializeCssMapVisit(e, n)}}`;
}, serializeCssDeclaration = (e, t, r) => "" === e.value ? "" : r - 1 === t ? e.property + ":" + e.value : e.property + ":" + e.value + ";", serializeCssMedia = (e, t) => {
 const r = serializeCssMapVisit(e, t.rules);
 return "" === r ? "" : "@media " + removeMediaWhitespace(t.media) + "{" + r + "}";
}, serializeCssKeyframes = (e, t) => {
 const r = serializeCssMapVisit(e, t.keyframes);
 return "" === r ? "" : "@" + (t.vendor || "") + "keyframes " + t.name + "{" + r + "}";
}, serializeCssKeyframe = (e, t) => {
 var r, s;
 return (null !== (s = null === (r = t.values) || void 0 === r ? void 0 : r.join(",")) && void 0 !== s ? s : "") + "{" + serializeCssMapVisit(e, t.declarations) + "}";
}, serializeCssFontFace = (e, t) => {
 const r = serializeCssMapVisit(e, t.declarations);
 return "" === r ? "" : "@font-face{" + r + "}";
}, serializeCssSupports = (e, t) => {
 const r = serializeCssMapVisit(e, t.rules);
 return "" === r ? "" : "@supports " + t.supports + "{" + r + "}";
}, serializeCssPage = (e, t) => {
 var r, s;
 return "@page " + (null !== (s = null === (r = t.selectors) || void 0 === r ? void 0 : r.join(", ")) && void 0 !== s ? s : "") + "{" + serializeCssMapVisit(e, t.declarations) + "}";
}, serializeCssDocument = (e, t) => {
 const r = serializeCssMapVisit(e, t.rules), s = "@" + (t.vendor || "") + "document " + t.document;
 return "" === r ? "" : s + "{" + r + "}";
}, serializeCssMapVisit = (e, t) => {
 let r = "";
 if (t) for (let s = 0, n = t.length; s < n; s++) r += serializeCssVisitNode(e, t[s], s, n);
 return r;
}, removeSelectorWhitespace = e => {
 let t = "", r = "", s = !1;
 for (let n = 0, o = (e = e.trim()).length; n < o; n++) if (r = e[n], "[" === r && "\\" !== t[t.length - 1] ? s = !0 : "]" === r && "\\" !== t[t.length - 1] && (s = !1), 
 !s && CSS_WS_REG.test(r)) {
  if (CSS_NEXT_CHAR_REG.test(e[n + 1])) continue;
  if (CSS_PREV_CHAR_REG.test(t[t.length - 1])) continue;
  t += " ";
 } else t += r;
 return t;
}, removeMediaWhitespace = e => {
 var t;
 let r = "", s = "";
 for (let n = 0, o = (e = null !== (t = null == e ? void 0 : e.trim()) && void 0 !== t ? t : "").length; n < o; n++) if (s = e[n], 
 CSS_WS_REG.test(s)) {
  if (CSS_WS_REG.test(r[r.length - 1])) continue;
  r += " ";
 } else r += s;
 return r;
}, CSS_WS_REG = /\s/, CSS_NEXT_CHAR_REG = /[>\(\)\~\,\+\s]/, CSS_PREV_CHAR_REG = /[>\(\~\,\+]/, collectUsedSelectors = (e, t) => {
 if (null != t && 1 === t.nodeType) {
  const r = t.children, s = t.nodeName.toLowerCase();
  e.tags.add(s);
  const n = t.attributes;
  for (let r = 0, s = n.length; r < s; r++) {
   const s = n.item(r), o = s.name.toLowerCase();
   if (e.attrs.add(o), "class" === o) {
    const r = t.classList;
    for (let t = 0, s = r.length; t < s; t++) e.classNames.add(r.item(t));
   } else "id" === o && e.ids.add(s.value);
  }
  if (r) for (let t = 0, s = r.length; t < s; t++) collectUsedSelectors(e, r[t]);
 }
}, removeUnusedStyles = (e, t) => {
 try {
  const r = e.head.querySelectorAll("style[data-styles]"), s = r.length;
  if (s > 0) {
   const n = (e => {
    const t = {
     attrs: new Set,
     classNames: new Set,
     ids: new Set,
     tags: new Set
    };
    return collectUsedSelectors(t, e), t;
   })(e.documentElement);
   for (let e = 0; e < s; e++) removeUnusedStyleText(n, t, r[e]);
  }
 } catch (e) {
  ((e, t, r) => {
   const s = {
    level: "error",
    type: "build",
    header: "Build Error",
    messageText: "build error",
    lines: []
   };
   null != t && (null != t.stack ? s.messageText = t.stack.toString() : null != t.message ? s.messageText = t.message.length ? t.message : "UNKNOWN ERROR" : s.messageText = t.toString()), 
   null == e || (e => e === TASK_CANCELED_MSG)(s.messageText) || e.push(s);
  })(t, e);
 }
}, removeUnusedStyleText = (e, t, r) => {
 try {
  const s = parseCss(r.innerHTML);
  if (t.push(...s.diagnostics), hasError(t)) return;
  try {
   r.innerHTML = ((e, t) => {
    const r = t.usedSelectors || null, s = {
     usedSelectors: r || null,
     hasUsedAttrs: !!r && r.attrs.size > 0,
     hasUsedClassNames: !!r && r.classNames.size > 0,
     hasUsedIds: !!r && r.ids.size > 0,
     hasUsedTags: !!r && r.tags.size > 0
    }, n = e.rules;
    if (!n) return "";
    const o = n.length, i = [];
    for (let e = 0; e < o; e++) i.push(serializeCssVisitNode(s, n[e], e, o));
    return i.join("");
   })(s.stylesheet, {
    usedSelectors: e
   });
  } catch (e) {
   t.push({
    level: "warn",
    type: "css",
    header: "CSS Stringify",
    messageText: e,
    lines: []
   });
  }
 } catch (e) {
  t.push({
   level: "warn",
   type: "css",
   header: "CSS Parse",
   messageText: e,
   lines: []
  });
 }
}, SKIP_ATTRS = new Set([ "s-id", "c-id" ]), createHydrateBuildId = () => {
 let e = "abcdefghijklmnopqrstuvwxyz", t = "";
 for (;t.length < 8; ) t += e[Math.floor(Math.random() * e.length)], 1 === t.length && (e += "0123456789");
 return t;
};

exports.createWindowFromHtml = createWindowFromHtml;
exports.hydrateDocument = hydrateDocument;
exports.renderToString = renderToString;
exports.serializeDocumentToString = serializeDocumentToString;
