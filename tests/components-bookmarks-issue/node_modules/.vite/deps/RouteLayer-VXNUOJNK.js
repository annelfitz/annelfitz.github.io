import {
  a as a2
} from "./chunk-NA6Q3Z3J.js";
import {
  O as O2,
  c,
  d as d3,
  f as f6,
  u as u3
} from "./chunk-QWNRUCON.js";
import "./chunk-QRKFUTEF.js";
import {
  O,
  c as c2,
  c2 as c3,
  f as f7,
  g as g2,
  j as j4,
  m as m2
} from "./chunk-B3DOIFRS.js";
import {
  O as O3,
  b as b3,
  n as n4,
  o2 as o6
} from "./chunk-CEUXXR2I.js";
import {
  o as o5
} from "./chunk-TUVEYM7U.js";
import "./chunk-5S637BGW.js";
import "./chunk-BFOJPIF7.js";
import "./chunk-Y7RXGLGH.js";
import "./chunk-GKMVTGGM.js";
import "./chunk-XGTCDM4C.js";
import "./chunk-QNG4TY7L.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import "./chunk-OKRW5W44.js";
import "./chunk-Q6RZBEZ6.js";
import "./chunk-PC66NY33.js";
import "./chunk-YY2VB3AE.js";
import "./chunk-VEYMN5N3.js";
import "./chunk-H6NTWZSO.js";
import "./chunk-BMT3OVAP.js";
import "./chunk-IYKBAIQE.js";
import "./chunk-BDRVHR2K.js";
import "./chunk-DVIGFJWY.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import {
  d as d2
} from "./chunk-F3BQGS35.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-LMO6NZJA.js";
import "./chunk-A5QTLE4Y.js";
import "./chunk-SCHTG6ZQ.js";
import {
  R
} from "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import {
  f as f4
} from "./chunk-QYC3GV65.js";
import {
  P
} from "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import {
  f as f5
} from "./chunk-I2X6UR6L.js";
import {
  i
} from "./chunk-OWKPWQPA.js";
import "./chunk-CQFVWMFK.js";
import {
  j as j2
} from "./chunk-4ZLXDMI5.js";
import {
  n as n3
} from "./chunk-6PMFOUWZ.js";
import "./chunk-3KPZ3BQR.js";
import "./chunk-5JYVZQZR.js";
import {
  t
} from "./chunk-UUG4W2PI.js";
import {
  u as u2
} from "./chunk-WW22JHXA.js";
import {
  S as S2
} from "./chunk-ZAM62XN5.js";
import "./chunk-RKVEKQ5O.js";
import "./chunk-P7J4JFEH.js";
import {
  b as b2
} from "./chunk-G7FOE26O.js";
import "./chunk-USOPZ2Q6.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-JW7VBMHD.js";
import "./chunk-GLLRUDMY.js";
import {
  j2 as j3
} from "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import {
  S as S3
} from "./chunk-G5EVVNIJ.js";
import {
  y as y3
} from "./chunk-HU5IGOTI.js";
import {
  d
} from "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import {
  o as o4
} from "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-AKLOTDO2.js";
import "./chunk-6AQIVLDN.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import {
  f as f3
} from "./chunk-LBXFRGMS.js";
import {
  y as y2
} from "./chunk-VTH4DAHQ.js";
import "./chunk-HLDUDRTD.js";
import {
  S
} from "./chunk-SLQA5YBV.js";
import {
  Q
} from "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import {
  B,
  H
} from "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import {
  m2 as m,
  u
} from "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-5LSHHVQ5.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  f as f2
} from "./chunk-MBGZKT2Z.js";
import {
  g2 as g,
  j
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import {
  o as o3
} from "./chunk-YOPMY6TS.js";
import {
  r as r2
} from "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import {
  n as n2
} from "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import {
  I,
  U
} from "./chunk-SAYWXQVM.js";
import {
  f
} from "./chunk-SBL4URUW.js";
import {
  v
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  o3 as o2,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  b
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n,
  o,
  r,
  s
} from "./chunk-7RBRCL6S.js";
import {
  k
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/layers/support/RouteStopSymbols.js
var p = class extends f {
  constructor(o7) {
    super(o7), this.break = new y3({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.first = new y3({ color: [0, 255, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.unlocated = new y3({ color: [255, 0, 0], size: 12, outline: { color: [255, 255, 255], width: 3 } }), this.last = new y3({ color: [255, 0, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.middle = new y3({ color: [51, 51, 51], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.waypoint = new y3({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } });
  }
};
e([y({ types: j3 })], p.prototype, "break", void 0), e([y({ types: j3 })], p.prototype, "first", void 0), e([y({ types: j3 })], p.prototype, "unlocated", void 0), e([y({ types: j3 })], p.prototype, "last", void 0), e([y({ types: j3 })], p.prototype, "middle", void 0), e([y({ types: j3 })], p.prototype, "waypoint", void 0), p = e([a("esri.layers.support.RouteStopSymbols")], p);
var l = p;

// node_modules/@arcgis/core/layers/support/RouteSymbols.js
var n5 = class extends f {
  constructor(o7) {
    super(o7), this.directionLines = new d({ color: [0, 122, 194], width: 6 }), this.directionPoints = new y3({ color: [255, 255, 255], size: 6, outline: { color: [0, 122, 194], width: 2 } }), this.pointBarriers = new y3({ style: "x", size: 10, outline: { color: [255, 0, 0], width: 3 } }), this.polygonBarriers = new S3({ color: [255, 170, 0, 0.6], outline: { width: 7.5, color: [255, 0, 0, 0.6] } }), this.polylineBarriers = new d({ width: 7.5, color: [255, 85, 0, 0.7] }), this.routeInfo = new d({ width: 8, color: [20, 89, 127] }), this.stops = new l();
  }
};
e([y({ types: j3 })], n5.prototype, "directionLines", void 0), e([y({ types: j3 })], n5.prototype, "directionPoints", void 0), e([y({ types: j3 })], n5.prototype, "pointBarriers", void 0), e([y({ types: j3 })], n5.prototype, "polygonBarriers", void 0), e([y({ types: j3 })], n5.prototype, "polylineBarriers", void 0), e([y({ types: j3 })], n5.prototype, "routeInfo", void 0), e([y({ type: l })], n5.prototype, "stops", void 0), n5 = e([a("esri.layers.support.RouteSymbols")], n5);
var c4 = n5;

// node_modules/@arcgis/core/rest/support/NAMessage.js
var p2 = new n2({ 0: "informative", 1: "process-definition", 2: "process-start", 3: "process-stop", 50: "warning", 100: "error", 101: "empty", 200: "abort" });
var c5 = class extends a2 {
  constructor(r3) {
    super(r3), this.type = null;
  }
};
e([y({ type: String, json: { read: p2.read, write: p2.write } })], c5.prototype, "type", void 0), c5 = e([a("esri.rest.support.NAMessage")], c5);
var i2 = c5;

// node_modules/@arcgis/core/rest/support/DirectionsString.js
var c6 = class extends f {
  constructor(r3) {
    super(r3);
  }
};
e([y({ json: { read: { source: "string" } } })], c6.prototype, "text", void 0), e([o4(b3, { name: "stringType" })], c6.prototype, "type", void 0), c6 = e([a("esri.rest.support.DirectionsString")], c6);
var i3 = c6;

// node_modules/@arcgis/core/rest/support/DirectionsEvent.js
var a3 = class extends f {
  constructor(r3) {
    super(r3), this.arriveTime = null, this.arriveTimeOffset = null, this.geometry = null, this.strings = null;
  }
  readArriveTimeOffset(r3, e2) {
    return n4(e2.ETA, e2.arriveTimeUTC);
  }
  readGeometry(r3, e2) {
    return x.fromJSON(e2.point);
  }
};
e([y({ type: Date, json: { read: { source: "arriveTimeUTC" } } })], a3.prototype, "arriveTime", void 0), e([y()], a3.prototype, "arriveTimeOffset", void 0), e([o3("arriveTimeOffset", ["arriveTimeUTC", "ETA"])], a3.prototype, "readArriveTimeOffset", null), e([y({ type: x })], a3.prototype, "geometry", void 0), e([o3("geometry", ["point"])], a3.prototype, "readGeometry", null), e([y({ type: [i3] })], a3.prototype, "strings", void 0), a3 = e([a("esri.rest.support.DirectionsEvent")], a3);
var c7 = a3;

// node_modules/@arcgis/core/rest/support/DirectionsFeature.js
function c8(r3) {
  if (null == r3 || "" === r3)
    return null;
  let e2 = 0, t2 = 0, s2 = 0, o7 = 0;
  const p3 = [];
  let n7, i4, c11, a5, m7, l3, u7, f8, d4 = 0, y5 = 0, h = 0;
  if (m7 = r3.match(/((\+|\-)[^\+\-\|]+|\|)/g), m7 || (m7 = []), 0 === parseInt(m7[d4], 32)) {
    d4 = 2;
    const r4 = parseInt(m7[d4], 32);
    d4++, l3 = parseInt(m7[d4], 32), d4++, 1 & r4 && (y5 = m7.indexOf("|") + 1, u7 = parseInt(m7[y5], 32), y5++), 2 & r4 && (h = m7.indexOf("|", y5) + 1, f8 = parseInt(m7[h], 32), h++);
  } else
    l3 = parseInt(m7[d4], 32), d4++;
  for (; d4 < m7.length && "|" !== m7[d4]; ) {
    n7 = parseInt(m7[d4], 32) + e2, d4++, e2 = n7, i4 = parseInt(m7[d4], 32) + t2, d4++, t2 = i4;
    const r4 = [n7 / l3, i4 / l3];
    y5 && (a5 = parseInt(m7[y5], 32) + s2, y5++, s2 = a5, r4.push(a5 / u7)), h && (c11 = parseInt(m7[h], 32) + o7, h++, o7 = c11, r4.push(c11 / f8)), p3.push(r4);
  }
  return { paths: [p3], hasZ: y5 > 0, hasM: h > 0 };
}
var a4 = class extends f4 {
  constructor(r3) {
    super(r3), this.events = null, this.strings = null;
  }
  readGeometry(r3, e2) {
    const t2 = c8(e2.compressedGeometry);
    return null != t2 ? m.fromJSON(t2) : null;
  }
};
e([y({ type: [c7] })], a4.prototype, "events", void 0), e([o3("geometry", ["compressedGeometry"])], a4.prototype, "readGeometry", null), e([y({ type: [i3] })], a4.prototype, "strings", void 0), a4 = e([a("esri.rest.support.DirectionsFeature")], a4);
var m3 = a4;

// node_modules/@arcgis/core/rest/support/DirectionsFeatureSet.js
function m4(e2, t2) {
  if (0 === e2.length)
    return new m({ spatialReference: t2 });
  const r3 = [];
  for (const n7 of e2)
    for (const e3 of n7.paths)
      r3.push(...e3);
  const o7 = [];
  r3.forEach((e3, t3) => {
    0 !== t3 && e3[0] === r3[t3 - 1][0] && e3[1] === r3[t3 - 1][1] || o7.push(e3);
  });
  const { hasM: s2, hasZ: a5 } = e2[0];
  return new m({ hasM: s2, hasZ: a5, paths: [o7], spatialReference: t2 });
}
var u4 = class extends d2 {
  constructor(e2) {
    super(e2), this.extent = null, this.features = [], this.geometryType = "polyline", this.routeId = null, this.routeName = null, this.totalDriveTime = null, this.totalLength = null, this.totalTime = null;
  }
  readFeatures(e2, t2) {
    if (!e2)
      return [];
    const r3 = t2.summary.envelope.spatialReference ?? t2.spatialReference, o7 = r3 && f2.fromJSON(r3);
    return e2.map((e3) => {
      const t3 = m3.fromJSON(e3);
      if (null != t3.geometry && (t3.geometry.spatialReference = o7), null != t3.events)
        for (const r4 of t3.events)
          null != r4.geometry && (r4.geometry.spatialReference = o7);
      return t3;
    });
  }
  get mergedGeometry() {
    if (!this.features)
      return null;
    return m4(this.features.map(({ geometry: e2 }) => e2), this.extent.spatialReference);
  }
  get strings() {
    return this.features.flatMap(({ strings: e2 }) => e2).filter(k);
  }
};
e([y({ type: w, json: { read: { source: "summary.envelope" } } })], u4.prototype, "extent", void 0), e([y({ nonNullable: true })], u4.prototype, "features", void 0), e([o3("features")], u4.prototype, "readFeatures", null), e([y()], u4.prototype, "geometryType", void 0), e([y({ readOnly: true })], u4.prototype, "mergedGeometry", null), e([y()], u4.prototype, "routeId", void 0), e([y()], u4.prototype, "routeName", void 0), e([y({ value: null, readOnly: true })], u4.prototype, "strings", null), e([y({ json: { read: { source: "summary.totalDriveTime" } } })], u4.prototype, "totalDriveTime", void 0), e([y({ json: { read: { source: "summary.totalLength" } } })], u4.prototype, "totalLength", void 0), e([y({ json: { read: { source: "summary.totalTime" } } })], u4.prototype, "totalTime", void 0), u4 = e([a("esri.rest.support.DirectionsFeatureSet")], u4);
var c9 = u4;

// node_modules/@arcgis/core/rest/support/RouteResult.js
var n6 = class extends f {
  constructor(t2) {
    super(t2), this.directionLines = null, this.directionPoints = null, this.directions = null, this.route = null, this.routeName = null, this.stops = null, this.traversedEdges = null, this.traversedJunctions = null, this.traversedTurns = null;
  }
};
e([y({ type: d2, json: { write: true } })], n6.prototype, "directionLines", void 0), e([y({ type: d2, json: { write: true } })], n6.prototype, "directionPoints", void 0), e([y({ type: c9, json: { write: true } })], n6.prototype, "directions", void 0), e([y({ type: f4, json: { write: true } })], n6.prototype, "route", void 0), e([y({ type: String, json: { write: true } })], n6.prototype, "routeName", void 0), e([y({ type: [f4], json: { write: true } })], n6.prototype, "stops", void 0), e([y({ type: d2, json: { write: true } })], n6.prototype, "traversedEdges", void 0), e([y({ type: d2, json: { write: true } })], n6.prototype, "traversedJunctions", void 0), e([y({ type: d2, json: { write: true } })], n6.prototype, "traversedTurns", void 0), n6 = e([a("esri.rest.support.RouteResult")], n6);
var u5 = n6;

// node_modules/@arcgis/core/rest/support/RouteSolveResult.js
function u6(r3) {
  return r3 ? d2.fromJSON(r3).features.filter(k) : [];
}
var m5 = class extends f {
  constructor(r3) {
    super(r3), this.messages = null, this.pointBarriers = null, this.polylineBarriers = null, this.polygonBarriers = null, this.routeResults = null;
  }
  readPointBarriers(r3, o7) {
    return u6(o7.barriers);
  }
  readPolylineBarriers(r3) {
    return u6(r3);
  }
  readPolygonBarriers(r3) {
    return u6(r3);
  }
};
e([y({ type: [i2] })], m5.prototype, "messages", void 0), e([y({ type: [f4] })], m5.prototype, "pointBarriers", void 0), e([o3("pointBarriers", ["barriers"])], m5.prototype, "readPointBarriers", null), e([y({ type: [f4] })], m5.prototype, "polylineBarriers", void 0), e([o3("polylineBarriers")], m5.prototype, "readPolylineBarriers", null), e([y({ type: [f4] })], m5.prototype, "polygonBarriers", void 0), e([o3("polygonBarriers")], m5.prototype, "readPolygonBarriers", null), e([y({ type: [u5] })], m5.prototype, "routeResults", void 0), m5 = e([a("esri.rest.support.RouteSolveResult")], m5);
var y4 = m5;

// node_modules/@arcgis/core/rest/route.js
function c10(e2) {
  return e2 instanceof d2;
}
async function l2(f8, p3, l3) {
  const y5 = [], d4 = [], g3 = {}, h = {}, R2 = f5(f8), { path: v2 } = R2;
  c10(p3.stops) && u3(p3.stops.features, d4, "stops.features", g3), c10(p3.pointBarriers) && u3(p3.pointBarriers.features, d4, "pointBarriers.features", g3), c10(p3.polylineBarriers) && u3(p3.polylineBarriers.features, d4, "polylineBarriers.features", g3), c10(p3.polygonBarriers) && u3(p3.polygonBarriers.features, d4, "polygonBarriers.features", g3);
  const B2 = await R(d4);
  for (const e2 in g3) {
    const r3 = g3[e2];
    y5.push(e2), h[e2] = B2.slice(r3[0], r3[1]);
  }
  if (c(h, y5)) {
    let e2 = null;
    try {
      e2 = await d3(v2, p3.apiKey, l3);
    } catch {
    }
    e2 && !e2.hasZ && f6(h, y5);
  }
  for (const e2 in h)
    h[e2].forEach((t2, s2) => {
      o2(p3, e2)[s2].geometry = t2;
    });
  const E = { ...l3, query: { ...R2.query, ...o6(p3), f: "json" } }, T = v2.endsWith("/solve") ? v2 : `${v2}/solve`, { data: b4 } = await U(T, E);
  return m6(b4);
}
function m6(e2) {
  const { barriers: r3, directionLines: t2, directionPoints: s2, directions: o7, messages: a5, polygonBarriers: i4, polylineBarriers: n7, routes: u7, stops: f8, traversedEdges: c11, traversedJunctions: l3, traversedTurns: m7 } = e2, y5 = (e3) => {
    const r4 = g3.find((r5) => r5.routeName === e3);
    if (null != r4)
      return r4;
    const t3 = { routeId: g3.length + 1, routeName: e3 };
    return g3.push(t3), t3;
  }, d4 = (e3) => {
    const r4 = g3.find((r5) => r5.routeId === e3);
    if (null != r4)
      return r4;
    const t3 = { routeId: e3, routeName: null };
    return g3.push(t3), t3;
  }, g3 = [];
  u7 == null ? void 0 : u7.features.forEach((e3, r4) => {
    e3.geometry.spatialReference = u7.spatialReference ?? void 0;
    const t3 = e3.attributes.Name, s3 = r4 + 1;
    g3.push({ routeId: s3, routeName: t3, route: e3 });
  }), o7 == null ? void 0 : o7.forEach((e3) => {
    const { routeName: r4 } = e3;
    y5(r4).directions = e3;
  });
  const h = ((f8 == null ? void 0 : f8.features.every((e3) => null == e3.attributes.RouteName)) ?? false) && g3.length > 0 ? g3[0].routeName : null;
  return f8 == null ? void 0 : f8.features.forEach((e3) => {
    var _a;
    e3.geometry && ((_a = e3.geometry).spatialReference ?? (_a.spatialReference = f8.spatialReference ?? void 0));
    const r4 = h ?? e3.attributes.RouteName, t3 = y5(r4);
    t3.stops ?? (t3.stops = []), t3.stops.push(e3);
  }), t2 == null ? void 0 : t2.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, s3 = d4(r4), { geometryType: o8, spatialReference: a6 } = t2;
    s3.directionLines ?? (s3.directionLines = { features: [], geometryType: o8, spatialReference: a6 }), s3.directionLines.features.push(e3);
  }), s2 == null ? void 0 : s2.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, t3 = d4(r4), { geometryType: o8, spatialReference: a6 } = s2;
    t3.directionPoints ?? (t3.directionPoints = { features: [], geometryType: o8, spatialReference: a6 }), t3.directionPoints.features.push(e3);
  }), c11 == null ? void 0 : c11.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, t3 = d4(r4), { geometryType: s3, spatialReference: o8 } = c11;
    t3.traversedEdges ?? (t3.traversedEdges = { features: [], geometryType: s3, spatialReference: o8 }), t3.traversedEdges.features.push(e3);
  }), l3 == null ? void 0 : l3.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, t3 = d4(r4), { geometryType: s3, spatialReference: o8 } = l3;
    t3.traversedJunctions ?? (t3.traversedJunctions = { features: [], geometryType: s3, spatialReference: o8 }), t3.traversedJunctions.features.push(e3);
  }), m7 == null ? void 0 : m7.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, t3 = d4(r4);
    t3.traversedTurns ?? (t3.traversedTurns = { features: [] }), t3.traversedTurns.features.push(e3);
  }), y4.fromJSON({ routeResults: g3, barriers: r3, polygonBarriers: i4, polylineBarriers: n7, messages: a5 });
}

// node_modules/@arcgis/core/layers/RouteLayer.js
function z(e2) {
  return e2.length ? e2 : null;
}
function H2(e2) {
  switch (e2) {
    case "esriGeometryPoint":
      return { type: "esriSMS", style: "esriSMSCircle", size: 12, color: [0, 0, 0, 0], outline: H2("esriGeometryPolyline") };
    case "esriGeometryPolyline":
      return { type: "esriSLS", style: "esriSLSSolid", width: 1, color: [0, 0, 0, 0] };
    case "esriGeometryPolygon":
      return { type: "esriSFS", style: "esriSFSNull", outline: H2("esriGeometryPolyline") };
  }
}
function K(e2) {
  return "layers" in e2;
}
function Q2(e2) {
  return "esri.rest.support.FeatureSet" === e2.declaredClass;
}
function Y(e2) {
  return "esri.rest.support.NetworkFeatureSet" === e2.declaredClass;
}
function Z(e2, t2, r3) {
  var _a, _b, _c, _d, _e, _f;
  const o7 = (_a = t2.networkDataset) == null ? void 0 : _a.networkAttributes, i4 = (o7 == null ? void 0 : o7.filter(({ usageType: e3 }) => "cost" === e3)) ?? [], s2 = r3.travelMode ?? t2.defaultTravelMode;
  if (null == s2)
    return void ue().warn("route-layer:missing-travel-mode", "The routing service must have a default travel mode or one must be specified in the route parameter.");
  const { timeAttributeName: n7, distanceAttributeName: a5 } = s2, u7 = i4.find(({ name: e3 }) => e3 === n7), p3 = i4.find(({ name: e3 }) => e3 === a5), c11 = ((_b = r3.travelMode) == null ? void 0 : _b.impedanceAttributeName) ?? r3.impedanceAttribute ?? t2.impedance, m7 = u7 == null ? void 0 : u7.units, y5 = p3 == null ? void 0 : p3.units;
  if (!m7 || !y5)
    throw new s("routelayer:unknown-impedance-units", "the units of either the distance or time impedance are unknown");
  const f8 = r3.directionsLanguage ?? t2.directionsLanguage, d4 = r3.accumulateAttributes ?? t2.accumulateAttributeNames ?? [], h = new Set(i4.filter(({ name: e3 }) => e3 === n7 || e3 === a5 || e3 === c11 || null != e3 && d4.includes(e3)).map(({ name: e3 }) => e3)), w2 = (e3) => {
    for (const t3 in e3)
      h.has(t3) || delete e3[t3];
  };
  for (const l3 of e2.pointBarriers)
    null != l3.costs && (l3.addedCost = l3.costs[c11] ?? 0, w2(l3.costs));
  for (const l3 of e2.polygonBarriers)
    null != l3.costs && (l3.scaleFactor = l3.costs[c11] ?? 1, w2(l3.costs));
  for (const l3 of e2.polylineBarriers)
    null != l3.costs && (l3.scaleFactor = l3.costs[c11] ?? 1, w2(l3.costs));
  const { routeInfo: S4 } = e2, { findBestSequence: g3, preserveFirstStop: b4, preserveLastStop: v2, startTimeIsUTC: B2, timeWindowsAreUTC: P2 } = r3;
  S4.analysisSettings = new c3({ accumulateAttributes: d4, directionsLanguage: f8, findBestSequence: g3, preserveFirstStop: b4, preserveLastStop: v2, startTimeIsUTC: B2, timeWindowsAreUTC: P2, travelMode: s2 }), S4.totalDuration = X(((_c = S4.totalCosts) == null ? void 0 : _c[n7]) ?? 0, m7), S4.totalDistance = ee(((_d = S4.totalCosts) == null ? void 0 : _d[a5]) ?? 0, y5), S4.totalLateDuration = X(((_e = S4.totalViolations) == null ? void 0 : _e[n7]) ?? 0, m7), S4.totalWaitDuration = X(((_f = S4.totalWait) == null ? void 0 : _f[n7]) ?? 0, m7), null != S4.totalCosts && w2(S4.totalCosts), null != S4.totalViolations && w2(S4.totalViolations), null != S4.totalWait && w2(S4.totalWait);
  for (const l3 of e2.stops)
    null != l3.serviceCosts && (l3.serviceDuration = X(l3.serviceCosts[n7] ?? 0, m7), l3.serviceDistance = ee(l3.serviceCosts[a5] ?? 0, y5), w2(l3.serviceCosts)), null != l3.cumulativeCosts && (l3.cumulativeDuration = X(l3.cumulativeCosts[n7] ?? 0, m7), l3.cumulativeDistance = ee(l3.cumulativeCosts[a5] ?? 0, y5), w2(l3.cumulativeCosts)), null != l3.violations && (l3.lateDuration = X(l3.violations[n7] ?? 0, m7), w2(l3.violations)), null != l3.wait && (l3.waitDuration = X(l3.wait[n7] ?? 0, m7), w2(l3.wait));
}
async function $(e2) {
  const t2 = f2.WGS84;
  return await H(e2.spatialReference, t2), B(e2, t2);
}
function X(e2, t2) {
  switch (t2) {
    case "seconds":
      return e2 / 60;
    case "hours":
      return 60 * e2;
    case "days":
      return 60 * e2 * 24;
    default:
      return e2;
  }
}
function ee(e2, t2) {
  return "decimal-degrees" === t2 || "points" === t2 || "unknown" === t2 ? e2 : j(e2, t2, "meters");
}
function te(e2) {
  const { attributes: t2, geometry: r3, popupTemplate: o7, symbol: i4 } = e2.toGraphic().toJSON();
  return { attributes: t2, geometry: r3, popupInfo: o7, symbol: i4 };
}
var re = V.ofType(m2);
var oe = V.ofType(c2);
var ie = V.ofType(O);
var se = V.ofType(f7);
var ne = V.ofType(j4);
var le = V.ofType(O3);
var ae = "esri.layers.RouteLayer";
var ue = () => n.getLogger(ae);
var pe = class extends n3(t(u2(j2(S2(b2))))) {
  constructor(e2) {
    super(e2), this._cachedServiceDescription = null, this._featureCollection = null, this._type = "Feature Collection", this.defaultSymbols = new c4(), this.directionLines = null, this.directionPoints = null, this.featureCollectionType = "route", this.legendEnabled = false, this.maxScale = 0, this.minScale = 0, this.pointBarriers = new ie(), this.polygonBarriers = new se(), this.polylineBarriers = new ne(), this.routeInfo = null, this.spatialReference = f2.WGS84, this.stops = new le(), this.type = "route";
    const t2 = () => {
      this._setStopSymbol(this.stops);
    };
    this.addHandles(v(() => this.stops, "change", t2, { sync: true, onListenerAdd: t2 }));
  }
  writeFeatureCollectionWebmap(e2, t2, r3, o7) {
    const i4 = [this._writePolygonBarriers(), this._writePolylineBarriers(), this._writePointBarriers(), this._writeRouteInfo(), this._writeDirectionLines(), this._writeDirectionPoints(), this._writeStops()].filter((e3) => !!e3), s2 = i4.map((e3, t3) => t3), n7 = "web-map" === o7.origin ? "featureCollection.layers" : "layers";
    o(n7, i4, t2), t2.opacity = this.opacity, t2.visibility = this.visible, t2.visibleLayers = s2;
  }
  readDirectionLines(e2, t2) {
    return this._getNetworkFeatures(t2, "DirectionLines", (e3) => m2.fromGraphic(e3));
  }
  readDirectionPoints(e2, t2) {
    return this._getNetworkFeatures(t2, "DirectionPoints", (e3) => c2.fromGraphic(e3));
  }
  get fullExtent() {
    var _a;
    const e2 = new w({ xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: f2.WGS84 });
    if (null != ((_a = this.routeInfo) == null ? void 0 : _a.geometry))
      return this.routeInfo.geometry.extent ?? e2;
    if (null == this.stops)
      return e2;
    const t2 = this.stops.filter((e3) => null != e3.geometry);
    if (t2.length < 2)
      return e2;
    const { spatialReference: r3 } = t2.at(0).geometry;
    if (null == r3)
      return e2;
    const o7 = t2.toArray().map((e3) => {
      const t3 = e3.geometry;
      return [t3.x, t3.y];
    });
    return new u({ points: o7, spatialReference: r3 }).extent;
  }
  readMaxScale(e2, t2) {
    var _a;
    const r3 = K(t2) ? t2.layers : (_a = t2.featureCollection) == null ? void 0 : _a.layers, o7 = r3 == null ? void 0 : r3.find((e3) => null != e3.layerDefinition.maxScale);
    return (o7 == null ? void 0 : o7.layerDefinition.maxScale) ?? 0;
  }
  readMinScale(e2, t2) {
    var _a;
    const r3 = K(t2) ? t2.layers : (_a = t2.featureCollection) == null ? void 0 : _a.layers, o7 = r3 == null ? void 0 : r3.find((e3) => null != e3.layerDefinition.minScale);
    return (o7 == null ? void 0 : o7.layerDefinition.minScale) ?? 0;
  }
  readPointBarriers(e2, t2) {
    return this._getNetworkFeatures(t2, "Barriers", (e3) => O.fromGraphic(e3));
  }
  readPolygonBarriers(e2, t2) {
    return this._getNetworkFeatures(t2, "PolygonBarriers", (e3) => f7.fromGraphic(e3));
  }
  readPolylineBarriers(e2, t2) {
    return this._getNetworkFeatures(t2, "PolylineBarriers", (e3) => j4.fromGraphic(e3));
  }
  readRouteInfo(e2, t2) {
    const r3 = this._getNetworkFeatures(t2, "RouteInfo", (e3) => g2.fromGraphic(e3));
    return r3.length > 0 ? r3.at(0) : null;
  }
  readSpatialReference(e2, t2) {
    var _a, _b;
    const r3 = K(t2) ? t2.layers : (_a = t2.featureCollection) == null ? void 0 : _a.layers;
    if (!(r3 == null ? void 0 : r3.length))
      return f2.WGS84;
    const { layerDefinition: o7, featureSet: i4 } = r3[0], s2 = i4.features[0], n7 = ((_b = s2 == null ? void 0 : s2.geometry) == null ? void 0 : _b.spatialReference) ?? i4.spatialReference ?? o7.spatialReference ?? o7.extent.spatialReference ?? g;
    return f2.fromJSON(n7);
  }
  readStops(e2, t2) {
    return this._getNetworkFeatures(t2, "Stops", (e3) => O3.fromGraphic(e3), (e3) => this._setStopSymbol(e3));
  }
  get title() {
    var _a;
    return null != ((_a = this.routeInfo) == null ? void 0 : _a.name) ? this.routeInfo.name : "Route";
  }
  set title(e2) {
    this._overrideIfSome("title", e2);
  }
  get url() {
    return r.routeServiceUrl;
  }
  set url(e2) {
    null != e2 ? this._set("url", y2(e2, ue())) : this._set("url", r.routeServiceUrl);
  }
  load(e2) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Feature Collection"] }, e2)), Promise.resolve(this);
  }
  removeAll() {
    this.removeResult(), this.pointBarriers.removeAll(), this.polygonBarriers.removeAll(), this.polylineBarriers.removeAll(), this.stops.removeAll();
  }
  removeResult() {
    null != this.directionLines && (this.directionLines.removeAll(), this._set("directionLines", null)), null != this.directionPoints && (this.directionPoints.removeAll(), this._set("directionPoints", null)), null != this.routeInfo && this._set("routeInfo", null);
  }
  async save() {
    await this.load();
    const { fullExtent: e2, portalItem: t2 } = this;
    if (!t2)
      throw new s("routelayer:portal-item-not-set", "save() requires to the layer to have a portal item");
    if (!t2.id)
      throw new s("routelayer:portal-item-not-saved", "Please use saveAs() first to save the routelayer");
    if ("Feature Collection" !== t2.type)
      throw new s("routelayer:portal-item-wrong-type", 'Portal item needs to have type "Feature Collection"');
    if (null == this.routeInfo)
      throw new s("routelayer:route-unsolved", "save() requires a solved route");
    const { portal: r3 } = t2;
    await r3.signIn(), r3.user || await t2.reload();
    const { itemUrl: o7, itemControl: i4 } = t2;
    if ("admin" !== i4 && "update" !== i4)
      throw new s("routelayer:insufficient-permissions", "To save this layer, you need to be the owner or an administrator of your organization");
    const s2 = { messages: [], origin: "portal-item", portal: r3, url: o7 ? I(o7) : void 0, writtenProperties: [] }, n7 = this.write(void 0, s2);
    return t2.extent = await $(e2), t2.title = this.title, await t2.update({ data: n7 }), t2;
  }
  async saveAs(e2, t2 = {}) {
    var _a;
    if (await this.load(), null == this.routeInfo)
      throw new s("routelayer:route-unsolved", "saveAs() requires a solved route");
    const r3 = S.from(e2).clone();
    r3.extent ?? (r3.extent = await $(this.fullExtent)), r3.id = null, r3.portal ?? (r3.portal = Q.getDefault()), r3.title ?? (r3.title = this.title), r3.type = "Feature Collection", r3.typeKeywords = ["Data", "Feature Collection", f3.MULTI_LAYER, "Route Layer"];
    const { portal: o7 } = r3, i4 = { messages: [], origin: "portal-item", portal: o7, url: null, writtenProperties: [] };
    await o7.signIn();
    const s2 = t2 == null ? void 0 : t2.folder, n7 = this.write(void 0, i4);
    return await ((_a = o7.user) == null ? void 0 : _a.addItem({ item: r3, folder: s2, data: n7 })), this.portalItem = r3, i(i4), i4.portalItem = r3, r3;
  }
  async solve(e2, t2) {
    const r3 = (e2 == null ? void 0 : e2.stops) ?? this.stops, o7 = (e2 == null ? void 0 : e2.pointBarriers) ?? z(this.pointBarriers), i4 = (e2 == null ? void 0 : e2.polylineBarriers) ?? z(this.polylineBarriers), s2 = (e2 == null ? void 0 : e2.polygonBarriers) ?? z(this.polygonBarriers);
    if (null == r3)
      throw new s("routelayer:undefined-stops", "the route layer must have stops defined in the route parameters.");
    if ((Q2(r3) || Y(r3)) && r3.features.length < 2 || V.isCollection(r3) && r3.length < 2)
      throw new s("routelayer:insufficent-stops", "the route layer must have two or more stops to solve a route.");
    if (V.isCollection(r3))
      for (const n7 of r3)
        n7.routeName = null;
    const a5 = e2 == null ? void 0 : e2.apiKey, u7 = this.url, c11 = await this._getServiceDescription(u7, a5, t2), m7 = (e2 == null ? void 0 : e2.travelMode) ?? c11.defaultTravelMode, y5 = (e2 == null ? void 0 : e2.accumulateAttributes) ?? [];
    null != m7 && (y5.push(m7.distanceAttributeName), m7.timeAttributeName && y5.push(m7.timeAttributeName));
    const f8 = { accumulateAttributes: y5, directionsOutputType: "featuresets", ignoreInvalidLocations: true, pointBarriers: o7, polylineBarriers: i4, polygonBarriers: s2, preserveFirstStop: true, preserveLastStop: true, returnBarriers: !!o7, returnDirections: true, returnPolygonBarriers: !!s2, returnPolylineBarriers: !!i4, returnRoutes: true, returnStops: true, stops: r3 }, d4 = O2.from(e2 ?? {});
    let h;
    d4.set(f8);
    try {
      h = await l2(u7, d4, t2);
    } catch (S4) {
      throw b(S4) ? S4 : new s("routelayer:failed-route-request", "the routing request failed", { error: S4 });
    }
    const w2 = this._toRouteLayerSolution(h);
    return this._isOverridden("title") || (this.title = w2.routeInfo.name ?? "Route"), Z(w2, c11, d4), w2;
  }
  update(e2) {
    const { stops: t2, directionLines: r3, directionPoints: o7, pointBarriers: i4, polylineBarriers: s2, polygonBarriers: n7, routeInfo: l3 } = e2;
    this.set({ stops: t2, pointBarriers: i4, polylineBarriers: s2, polygonBarriers: n7 }), this._set("directionLines", r3), this._set("directionPoints", o7), this._set("routeInfo", l3), null != l3.geometry && (this.spatialReference = l3.geometry.spatialReference);
  }
  _getNetworkFeatures(e2, t2, s2, l3) {
    var _a;
    const a5 = K(e2) ? e2.layers : (_a = e2.featureCollection) == null ? void 0 : _a.layers, u7 = a5 == null ? void 0 : a5.find((e3) => e3.layerDefinition.name === t2);
    if (null == u7)
      return new V();
    const { layerDefinition: p3, popupInfo: c11, featureSet: m7 } = u7, y5 = p3.drawingInfo.renderer, { features: f8 } = m7, d4 = m7.spatialReference ?? p3.spatialReference ?? p3.extent.spatialReference ?? g, h = y5 && o5(y5), w2 = f2.fromJSON(d4), S4 = f8.map((e3) => {
      const i4 = f4.fromJSON(e3);
      null != i4.geometry && null != e3.geometry && null == e3.geometry.spatialReference && (i4.geometry.spatialReference = w2);
      const n7 = s2(i4);
      return n7.symbol ?? (n7.symbol = (h == null ? void 0 : h.getSymbol(i4)) ?? this._getNetworkSymbol(t2)), n7.popupTemplate ?? (n7.popupTemplate = c11 && P.fromJSON(c11)), n7;
    });
    return l3 && S4.some((e3) => !e3.symbol) && l3(S4), new V(S4);
  }
  _getNetworkSymbol(e2) {
    switch (e2) {
      case "Barriers":
        return this.defaultSymbols.pointBarriers;
      case "DirectionPoints":
        return this.defaultSymbols.directionPoints;
      case "DirectionLines":
        return this.defaultSymbols.directionLines;
      case "PolylineBarriers":
        return this.defaultSymbols.polylineBarriers;
      case "PolygonBarriers":
        return this.defaultSymbols.polygonBarriers;
      case "RouteInfo":
        return this.defaultSymbols.routeInfo;
      case "Stops":
        return null;
    }
  }
  async _getServiceDescription(e2, t2, r3) {
    if (null != this._cachedServiceDescription && this._cachedServiceDescription.url === e2)
      return this._cachedServiceDescription.serviceDescription;
    const o7 = await d3(e2, t2, r3);
    return this._cachedServiceDescription = { serviceDescription: o7, url: e2 }, o7;
  }
  _setStopSymbol(e2) {
    if (!e2 || 0 === e2.length)
      return;
    if (null == this.defaultSymbols.stops)
      return;
    if (e2.every(({ symbol: e3 }) => null != e3))
      return;
    const { first: t2, last: r3, middle: o7, unlocated: i4, waypoint: s2, break: n7 } = this.defaultSymbols.stops;
    if (null == this.routeInfo || 1 === e2.length)
      return void e2.forEach((i5, s3) => {
        switch (s3) {
          case 0:
            i5.symbol = t2;
            break;
          case e2.length - 1:
            i5.symbol = r3;
            break;
          default:
            i5.symbol = o7;
        }
      });
    const l3 = e2.map(({ sequence: e3 }) => e3).filter((e3) => null != e3), a5 = Math.min(...l3), u7 = Math.max(...l3);
    for (const p3 of e2)
      p3.sequence !== a5 ? p3.sequence !== u7 ? "ok" === p3.status || "not-located-on-closest" === p3.status ? "waypoint" !== p3.locationType ? "break" !== p3.locationType ? p3.symbol = o7 : p3.symbol = n7 : p3.symbol = s2 : p3.symbol = i4 : p3.symbol = r3 : p3.symbol = t2;
  }
  _toRouteLayerSolution(e2) {
    var _a, _b, _c, _d, _e, _f, _g;
    const t2 = (_a = e2.routeResults[0].stops) == null ? void 0 : _a.map((e3) => O3.fromJSON(e3.toJSON()));
    this._setStopSymbol(t2);
    const r3 = new le(t2), o7 = new se((_b = e2.polygonBarriers) == null ? void 0 : _b.map((e3) => {
      const t3 = f7.fromJSON(e3.toJSON());
      return t3.symbol = this.defaultSymbols.polygonBarriers, t3;
    })), i4 = new ne((_c = e2.polylineBarriers) == null ? void 0 : _c.map((e3) => {
      const t3 = j4.fromJSON(e3.toJSON());
      return t3.symbol = this.defaultSymbols.polylineBarriers, t3;
    })), s2 = new ie((_d = e2.pointBarriers) == null ? void 0 : _d.map((e3) => {
      const t3 = O.fromJSON(e3.toJSON());
      return t3.symbol = this.defaultSymbols.pointBarriers, t3;
    })), n7 = (_e = e2.routeResults[0].route) == null ? void 0 : _e.toJSON(), l3 = g2.fromJSON(n7);
    l3.symbol = this.defaultSymbols.routeInfo;
    const a5 = new oe((_f = e2.routeResults[0].directionPoints) == null ? void 0 : _f.features.map((e3) => {
      const t3 = c2.fromJSON(e3.toJSON());
      return t3.symbol = this.defaultSymbols.directionPoints, t3;
    }));
    return { directionLines: new re((_g = e2.routeResults[0].directionLines) == null ? void 0 : _g.features.map((e3) => {
      const t3 = m2.fromJSON(e3.toJSON());
      return t3.symbol = this.defaultSymbols.directionLines, t3;
    })), directionPoints: a5, pointBarriers: s2, polygonBarriers: o7, polylineBarriers: i4, routeInfo: l3, stops: r3 };
  }
  _writeDirectionLines() {
    return this._writeNetworkFeatures(this.directionLines, this.defaultSymbols.directionLines, "esriGeometryPolyline", m2.fields, m2.popupInfo, "DirectionLines", "Direction Lines");
  }
  _writeDirectionPoints() {
    return this._writeNetworkFeatures(this.directionPoints, this.defaultSymbols.directionPoints, "esriGeometryPoint", c2.fields, c2.popupInfo, "DirectionPoints", "Direction Points");
  }
  _writeNetworkFeatures(e2, t2, r3, o7, i4, s2, n7) {
    if (!(e2 == null ? void 0 : e2.length))
      return null;
    const l3 = this.spatialReference.toJSON(), { fullExtent: a5, maxScale: u7, minScale: p3 } = this;
    return { featureSet: { features: e2.toArray().map((e3) => te(e3)), geometryType: r3, spatialReference: l3 }, layerDefinition: { capabilities: "Query,Update,Editing", drawingInfo: { renderer: { type: "simple", symbol: null != t2 ? t2.toJSON() : H2(r3) } }, extent: a5.toJSON(), fields: o7, geometryType: r3, hasM: false, hasZ: false, maxScale: u7, minScale: p3, name: s2, objectIdField: "ObjectID", spatialReference: l3, title: n7, type: "Feature Layer", typeIdField: "" }, popupInfo: i4 };
  }
  _writePointBarriers() {
    return this._writeNetworkFeatures(this.pointBarriers, this.defaultSymbols.pointBarriers, "esriGeometryPoint", O.fields, O.popupInfo, "Barriers", "Point Barriers");
  }
  _writePolygonBarriers() {
    return this._writeNetworkFeatures(this.polygonBarriers, this.defaultSymbols.polygonBarriers, "esriGeometryPolygon", f7.fields, f7.popupInfo, "PolygonBarriers", "Polygon Barriers");
  }
  _writePolylineBarriers() {
    return this._writeNetworkFeatures(this.polylineBarriers, this.defaultSymbols.polylineBarriers, "esriGeometryPolyline", j4.fields, j4.popupInfo, "PolylineBarriers", "Line Barriers");
  }
  _writeRouteInfo() {
    return this._writeNetworkFeatures(null != this.routeInfo ? new V([this.routeInfo]) : null, this.defaultSymbols.routeInfo, "esriGeometryPolyline", g2.fields, g2.popupInfo, "RouteInfo", "Route Details");
  }
  _writeStops() {
    var _a, _b, _c;
    const e2 = this._writeNetworkFeatures(this.stops, null, "esriGeometryPoint", O3.fields, O3.popupInfo, "Stops", "Stops");
    if (null == e2)
      return null;
    const { stops: t2 } = this.defaultSymbols, r3 = (_a = t2 == null ? void 0 : t2.first) == null ? void 0 : _a.toJSON(), o7 = (_b = t2 == null ? void 0 : t2.middle) == null ? void 0 : _b.toJSON(), i4 = (_c = t2 == null ? void 0 : t2.last) == null ? void 0 : _c.toJSON();
    return e2.layerDefinition.drawingInfo.renderer = { type: "uniqueValue", field1: "Sequence", defaultSymbol: o7, uniqueValueInfos: [{ value: "1", symbol: r3, label: "First Stop" }, { value: `${this.stops.length}`, symbol: i4, label: "Last Stop" }] }, e2;
  }
};
e([y({ readOnly: true, json: { read: false, origins: { "portal-item": { write: { allowNull: true, ignoreOrigin: true } }, "web-map": { write: { overridePolicy() {
  return { allowNull: true, ignoreOrigin: null == this.portalItem };
} } } } } })], pe.prototype, "_featureCollection", void 0), e([r2(["web-map", "portal-item"], "_featureCollection")], pe.prototype, "writeFeatureCollectionWebmap", null), e([y({ readOnly: true, json: { read: false, origins: { "web-map": { write: { target: "type", overridePolicy() {
  return { ignoreOrigin: null != this.portalItem };
} } } } } })], pe.prototype, "_type", void 0), e([y({ nonNullable: true, type: c4 })], pe.prototype, "defaultSymbols", void 0), e([y({ readOnly: true })], pe.prototype, "directionLines", void 0), e([o3(["web-map", "portal-item"], "directionLines", ["layers", "featureCollection.layers"])], pe.prototype, "readDirectionLines", null), e([y({ readOnly: true })], pe.prototype, "directionPoints", void 0), e([o3(["web-map", "portal-item"], "directionPoints", ["layers", "featureCollection.layers"])], pe.prototype, "readDirectionPoints", null), e([y({ readOnly: true, json: { read: false, origins: { "web-map": { write: { ignoreOrigin: true } } } } })], pe.prototype, "featureCollectionType", void 0), e([y({ readOnly: true })], pe.prototype, "fullExtent", null), e([y({ json: { origins: { "web-map": { name: "featureCollection.showLegend" } }, write: true } })], pe.prototype, "legendEnabled", void 0), e([y({ type: ["show", "hide"] })], pe.prototype, "listMode", void 0), e([y({ type: Number, nonNullable: true, json: { write: false } })], pe.prototype, "maxScale", void 0), e([o3(["web-map", "portal-item"], "maxScale", ["layers", "featureCollection.layers"])], pe.prototype, "readMaxScale", null), e([y({ type: Number, nonNullable: true, json: { write: false } })], pe.prototype, "minScale", void 0), e([o3(["web-map", "portal-item"], "minScale", ["layers", "featureCollection.layers"])], pe.prototype, "readMinScale", null), e([y({ type: ["ArcGISFeatureLayer"], value: "ArcGISFeatureLayer" })], pe.prototype, "operationalLayerType", void 0), e([y({ nonNullable: true, type: V.ofType(O) })], pe.prototype, "pointBarriers", void 0), e([o3(["web-map", "portal-item"], "pointBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPointBarriers", null), e([y({ nonNullable: true, type: V.ofType(f7) })], pe.prototype, "polygonBarriers", void 0), e([o3(["web-map", "portal-item"], "polygonBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPolygonBarriers", null), e([y({ nonNullable: true, type: V.ofType(j4) })], pe.prototype, "polylineBarriers", void 0), e([o3(["web-map", "portal-item"], "polylineBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPolylineBarriers", null), e([y({ readOnly: true })], pe.prototype, "routeInfo", void 0), e([o3(["web-map", "portal-item"], "routeInfo", ["layers", "featureCollection.layers"])], pe.prototype, "readRouteInfo", null), e([y({ type: f2 })], pe.prototype, "spatialReference", void 0), e([o3(["web-map", "portal-item"], "spatialReference", ["layers", "featureCollection.layers"])], pe.prototype, "readSpatialReference", null), e([y({ nonNullable: true, type: V.ofType(O3) })], pe.prototype, "stops", void 0), e([o3(["web-map", "portal-item"], "stops", ["layers", "featureCollection.layers"])], pe.prototype, "readStops", null), e([y()], pe.prototype, "title", null), e([y({ readOnly: true, json: { read: false } })], pe.prototype, "type", void 0), e([y()], pe.prototype, "url", null), pe = e([a(ae)], pe);
var ce = pe;
export {
  ce as default
};
//# sourceMappingURL=RouteLayer-VXNUOJNK.js.map
