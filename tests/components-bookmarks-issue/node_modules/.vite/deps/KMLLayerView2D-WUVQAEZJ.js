import {
  c as c2
} from "./chunk-HB6ZUQQ2.js";
import {
  a as a2
} from "./chunk-475SVAPV.js";
import {
  b as b2,
  f as f3,
  g as g2
} from "./chunk-SQGFMYIT.js";
import {
  m as m2
} from "./chunk-UXMZQA2H.js";
import "./chunk-V2LOXBCS.js";
import {
  u as u2
} from "./chunk-NGAYW4TW.js";
import {
  o
} from "./chunk-LSOYCE62.js";
import {
  y as y2
} from "./chunk-MHIDY6OV.js";
import "./chunk-5IHJU3SQ.js";
import {
  t as t2
} from "./chunk-MASBINVZ.js";
import "./chunk-AD6XW3W5.js";
import {
  $
} from "./chunk-ES7G4AF5.js";
import "./chunk-SGCIDT4C.js";
import "./chunk-QXRPUAVL.js";
import "./chunk-M5UX4IRZ.js";
import "./chunk-2WUPZJUL.js";
import {
  h
} from "./chunk-KN52PCW4.js";
import "./chunk-SFKZ25SS.js";
import "./chunk-NCZU5DB4.js";
import "./chunk-SMDSNUU2.js";
import "./chunk-XTY645DH.js";
import "./chunk-UIOX7MPV.js";
import "./chunk-HRDKP7QO.js";
import "./chunk-4UOHLZKX.js";
import "./chunk-VJ2I4VSQ.js";
import "./chunk-MCZ4QOSQ.js";
import "./chunk-Q23RMXBO.js";
import "./chunk-2YYSD64V.js";
import "./chunk-6XTKBOD7.js";
import "./chunk-IUY6HBLC.js";
import "./chunk-BHOYA5LV.js";
import "./chunk-6RR3WN7W.js";
import {
  t
} from "./chunk-TXCVD3YI.js";
import "./chunk-SCRCLNT5.js";
import {
  c
} from "./chunk-M5DWZKDJ.js";
import "./chunk-PGADGS3I.js";
import {
  b,
  d as d2,
  g
} from "./chunk-AUJRLQGP.js";
import "./chunk-7A5N7G2Z.js";
import "./chunk-MEEG7XMI.js";
import "./chunk-LJULTBAY.js";
import "./chunk-FD4DXBZA.js";
import "./chunk-7FQYGAVT.js";
import "./chunk-QRQWG4D3.js";
import "./chunk-6ZDDHEYR.js";
import "./chunk-YQQSFFN3.js";
import "./chunk-32X2FZ3S.js";
import "./chunk-4IJED6JM.js";
import "./chunk-LGIO6OCK.js";
import "./chunk-C5EJV3NW.js";
import "./chunk-XXIDOBRO.js";
import "./chunk-JL4LXZGM.js";
import "./chunk-O556EBAK.js";
import {
  x as x2
} from "./chunk-IJD65EMQ.js";
import "./chunk-4YGBWYMD.js";
import "./chunk-ZPU7GNG4.js";
import "./chunk-TNR6E67I.js";
import "./chunk-7O3VD45U.js";
import "./chunk-QREUCRQ4.js";
import "./chunk-YK3UMVCY.js";
import "./chunk-IQFWVTUJ.js";
import "./chunk-GB4RVOXH.js";
import {
  e2 as e3,
  m
} from "./chunk-JTUYA5FE.js";
import "./chunk-UNTQATE2.js";
import "./chunk-5YY6NZNY.js";
import "./chunk-DCBZOZ54.js";
import "./chunk-5IT6RVBX.js";
import "./chunk-N4HNOQVJ.js";
import "./chunk-MTQHYT7Y.js";
import "./chunk-JCP47SOM.js";
import "./chunk-CXCB57TE.js";
import "./chunk-IWO6JXL2.js";
import "./chunk-AVR3LWTZ.js";
import "./chunk-YUWVLORR.js";
import {
  C,
  ee
} from "./chunk-QQDXHR2B.js";
import "./chunk-FFG7BDAP.js";
import "./chunk-I4SHZ6P5.js";
import "./chunk-DGRFM5OL.js";
import "./chunk-AOAT6HYL.js";
import "./chunk-JBU54P54.js";
import "./chunk-5LIYYE75.js";
import "./chunk-TLTAGTBA.js";
import "./chunk-2QPP5AGU.js";
import "./chunk-2C26DRKK.js";
import "./chunk-M4RFJU4F.js";
import {
  D,
  G,
  U as U2,
  X
} from "./chunk-WKVHVZW2.js";
import "./chunk-YT66FIGM.js";
import "./chunk-VIKID44H.js";
import "./chunk-RLZYC2LS.js";
import "./chunk-TXLJQAAN.js";
import "./chunk-3AIILHI5.js";
import "./chunk-JKLFCJPR.js";
import "./chunk-7JR6S3WL.js";
import "./chunk-P4MNTMCZ.js";
import "./chunk-BSPKLAHD.js";
import "./chunk-VS6AHHIY.js";
import "./chunk-TUVEYM7U.js";
import "./chunk-5S637BGW.js";
import "./chunk-BFOJPIF7.js";
import "./chunk-Y7RXGLGH.js";
import "./chunk-3JC3OUNW.js";
import "./chunk-RO3CTAP7.js";
import "./chunk-GKMVTGGM.js";
import "./chunk-XGTCDM4C.js";
import "./chunk-QNG4TY7L.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import "./chunk-OKRW5W44.js";
import "./chunk-Q6RZBEZ6.js";
import "./chunk-PC66NY33.js";
import "./chunk-YY2VB3AE.js";
import "./chunk-VEYMN5N3.js";
import "./chunk-H6NTWZSO.js";
import "./chunk-BMT3OVAP.js";
import "./chunk-W5ALAOW2.js";
import "./chunk-FHDHOWK5.js";
import "./chunk-Y546C2O5.js";
import "./chunk-IYKBAIQE.js";
import "./chunk-BDRVHR2K.js";
import "./chunk-DVIGFJWY.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-HZSGATFT.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-ERD6I7QP.js";
import "./chunk-F3BQGS35.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-LMO6NZJA.js";
import "./chunk-A5QTLE4Y.js";
import "./chunk-SCHTG6ZQ.js";
import "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import "./chunk-QYC3GV65.js";
import "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import {
  f as f2
} from "./chunk-I2X6UR6L.js";
import "./chunk-5JYVZQZR.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-JW7VBMHD.js";
import "./chunk-GLLRUDMY.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import {
  B,
  k
} from "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-545NO6M2.js";
import "./chunk-5LSHHVQ5.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import {
  A,
  U,
  r,
  v
} from "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  d
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import {
  e as e2,
  u
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/support/imageReprojection.js
var w2 = class _w {
  constructor(t3) {
    if (this._ownsRctx = false, t3)
      this._ownsRctx = false, this._rctx = t3;
    else {
      if (_w._instance)
        return _w._instanceRefCount++, _w._instance;
      _w._instanceRefCount = 1, _w._instance = this, this._ownsRctx = true;
      const t4 = document.createElement("canvas"), e5 = t(t4);
      e5.getExtension("OES_texture_float"), this._rctx = new y2(e5, {});
    }
    const e4 = { applyProjection: true, bilinear: false, bicubic: false }, r2 = o("raster/reproject", "raster/reproject", /* @__PURE__ */ new Map([["a_position", 0]]), e4);
    this._program = this._rctx.programCache.acquire(r2.shaders.vertexShader, r2.shaders.fragmentShader, r2.attributes), this._rctx.useProgram(this._program), this._program.setUniform1f("u_opacity", 1), this._program.setUniform1i("u_image", 0), this._program.setUniform1i("u_flipY", 0), this._program.setUniform1i("u_transformGrid", 1), this._quad = new h(this._rctx, [0, 0, 1, 0, 0, 1, 1, 1]);
  }
  reprojectTexture(t3, s, n = false) {
    const o2 = B(t3.extent, s), m3 = new x({ x: (t3.extent.xmax - t3.extent.xmin) / t3.texture.descriptor.width, y: (t3.extent.ymax - t3.extent.ymin) / t3.texture.descriptor.height, spatialReference: t3.extent.spatialReference }), { x: c3, y: g3 } = C(m3, s, t3.extent);
    let f4 = (c3 + g3) / 2;
    const w3 = Math.round((o2.xmax - o2.xmin) / f4), b3 = Math.round((o2.ymax - o2.ymin) / f4);
    f4 = (o2.width / w3 + o2.height / b3) / 2;
    const j2 = new x({ x: f4, y: f4, spatialReference: o2.spatialReference }), D2 = ee({ projectedExtent: o2, srcBufferExtent: t3.extent, pixelSize: j2, hasWrapAround: true, spacing: [16, 16] }), R = c2(this._rctx, D2), T = new e3(w3, b3);
    T.wrapMode = D.CLAMP_TO_EDGE;
    const C3 = new x2(this._rctx, T);
    this._rctx.bindFramebuffer(C3), this._rctx.setViewport(0, 0, w3, b3), this._rctx.useProgram(this._program), this._rctx.bindTexture(t3.texture, 0), this._rctx.bindTexture(R, 1), this._quad.bind();
    const { width: y3 = 0, height: E = 0 } = t3.texture.descriptor;
    if (this._program.setUniform2f("u_srcImageSize", y3, E), this._program.setUniform2fv("u_transformSpacing", D2.spacing), this._program.setUniform2fv("u_transformGridSize", D2.size), this._program.setUniform2f("u_targetImageSize", w3, b3), this._quad.draw(), this._quad.unbind(), this._rctx.useProgram(null), this._rctx.bindFramebuffer(null), R.dispose(), n) {
      const { width: t4, height: e4 } = C3, r2 = new ImageData(t4 ?? 0, e4 ?? 0);
      C3.readPixels(0, 0, t4 ?? 0, e4 ?? 0, G.RGBA, U2.UNSIGNED_BYTE, r2.data);
      const i = C3.detachColorTexture(X.COLOR_ATTACHMENT0);
      return C3.dispose(), { texture: i, extent: o2, imageData: r2 };
    }
    const U3 = C3.detachColorTexture(X.COLOR_ATTACHMENT0);
    return C3.dispose(), { texture: U3, extent: o2 };
  }
  reprojectBitmapData(t3, e4) {
    const r2 = g2(t3.bitmapData) ? f3(t3.bitmapData) : t3.bitmapData, i = new e3();
    i.wrapMode = D.CLAMP_TO_EDGE, i.width = t3.bitmapData.width, i.height = t3.bitmapData.height;
    const a3 = new m(this._rctx, i, r2), o2 = this.reprojectTexture({ texture: a3, extent: t3.extent }, e4, true);
    o2.texture.dispose();
    const m3 = document.createElement("canvas"), c3 = o2.imageData;
    m3.width = c3.width, m3.height = c3.height;
    return m3.getContext("2d").putImageData(c3, 0, 0), { bitmapData: m3, extent: o2.extent };
  }
  async loadAndReprojectBitmapData(e4, r2, i) {
    const a3 = (await U(e4, { responseType: "image" })).data, s = document.createElement("canvas");
    s.width = a3.width, s.height = a3.height;
    const n = s.getContext("2d");
    n.drawImage(a3, 0, 0);
    const o2 = n.getImageData(0, 0, s.width, s.height);
    if (r2.spatialReference.equals(i))
      return { bitmapData: o2, extent: r2 };
    const m3 = this.reprojectBitmapData({ bitmapData: o2, extent: r2 }, i);
    return { bitmapData: m3.bitmapData, extent: m3.extent };
  }
  destroy() {
    this._ownsRctx ? (_w._instanceRefCount--, 0 === _w._instanceRefCount && (this._quad.dispose(), this._program.dispose(), this._rctx.dispose(), _w._instance = null)) : (this._quad.dispose(), this._program.dispose());
  }
};
w2._instanceRefCount = 0;

// node_modules/@arcgis/core/views/2d/layers/KMLLayerView2D.js
var C2 = class {
  constructor() {
    this.allSublayers = /* @__PURE__ */ new Map(), this.allPoints = [], this.allPolylines = [], this.allPolygons = [], this.allMapImages = [];
  }
};
var j = class extends m2(u2) {
  constructor() {
    super(...arguments), this._bitmapIndex = /* @__PURE__ */ new Map(), this._mapImageContainer = new a2(), this._kmlVisualData = new C2(), this._fetchController = null, this.allVisiblePoints = new c(), this.allVisiblePolylines = new c(), this.allVisiblePolygons = new c(), this.allVisibleMapImages = new V();
  }
  async hitTest(e4, i) {
    var _a, _b, _c;
    const t3 = this.layer;
    return [(_a = this._pointsView) == null ? void 0 : _a.hitTest(e4), (_b = this._polylinesView) == null ? void 0 : _b.hitTest(e4), (_c = this._polygonsView) == null ? void 0 : _c.hitTest(e4)].flat().filter(Boolean).map((i2) => (i2.layer = t3, i2.sourceLayer = t3, { type: "graphic", graphic: i2, layer: t3, mapPoint: e4 }));
  }
  update(e4) {
    this._polygonsView && this._polygonsView.processUpdate(e4), this._polylinesView && this._polylinesView.processUpdate(e4), this._pointsView && this._pointsView.processUpdate(e4);
  }
  attach() {
    this._fetchController = new AbortController(), this.container.addChild(this._mapImageContainer), this._polygonsView = new $({ view: this.view, graphics: this.allVisiblePolygons, requestUpdateCallback: () => this.requestUpdate(), container: new t2(this.view.featuresTilingScheme) }), this.container.addChild(this._polygonsView.container), this._polylinesView = new $({ view: this.view, graphics: this.allVisiblePolylines, requestUpdateCallback: () => this.requestUpdate(), container: new t2(this.view.featuresTilingScheme) }), this.container.addChild(this._polylinesView.container), this._pointsView = new $({ view: this.view, graphics: this.allVisiblePoints, requestUpdateCallback: () => this.requestUpdate(), container: new t2(this.view.featuresTilingScheme) }), this.container.addChild(this._pointsView.container), this.addAttachHandles([this.allVisibleMapImages.on("change", (e4) => {
      e4.added.forEach((e5) => this._addMapImage(e5)), e4.removed.forEach((e5) => this._removeMapImage(e5));
    }), d(() => this.layer.visibleSublayers, (e4) => {
      for (const [i, t3] of this._kmlVisualData.allSublayers)
        t3.visibility = 0;
      for (const i of e4) {
        const e5 = this._kmlVisualData.allSublayers.get(i.id);
        e5 && (e5.visibility = 1);
      }
      this._refreshCollections();
    })]), this._updatingHandles.addPromise(this._fetchService(this._fetchController.signal)), this._imageReprojector = new w2();
  }
  detach() {
    this._fetchController = e2(this._fetchController), this._mapImageContainer.removeAllChildren(), this.container.removeAllChildren(), this._bitmapIndex.clear(), this._polygonsView = u(this._polygonsView), this._polylinesView = u(this._polylinesView), this._pointsView = u(this._pointsView), this._imageReprojector = u(this._imageReprojector);
  }
  viewChange() {
    this._polygonsView.viewChange(), this._polylinesView.viewChange(), this._pointsView.viewChange();
  }
  moveEnd() {
  }
  isUpdating() {
    return this._pointsView.updating || this._polygonsView.updating || this._polylinesView.updating;
  }
  _addMapImage(e4) {
    var _a, _b;
    (((_a = this.view.spatialReference) == null ? void 0 : _a.isWGS84) || ((_b = this.view.spatialReference) == null ? void 0 : _b.isWebMercator)) && this._imageReprojector.loadAndReprojectBitmapData(e4.href, w.fromJSON(e4.extent), this.view.spatialReference).then((i) => {
      const t3 = new b2(i.bitmapData);
      t3.x = i.extent.xmin, t3.y = i.extent.ymax, t3.resolution = i.extent.width / i.bitmapData.width, t3.rotation = e4.rotation, this._mapImageContainer.addChild(t3), this._bitmapIndex.set(e4, t3);
    });
  }
  async _getViewDependentUrl(e4, t3) {
    const { viewFormat: s, viewBoundScale: a3, httpQuery: o2 } = e4;
    if (null != s) {
      if (null == t3)
        throw new Error("Loading this network link requires a view state.");
      let n;
      if (await k(), null != a3 && 1 !== a3) {
        const e5 = new w(t3.extent);
        e5.expand(a3), n = e5;
      } else
        n = t3.extent;
      n = B(n, f.WGS84);
      const h2 = B(n, f.WebMercator), y3 = n.xmin, g3 = n.xmax, w3 = n.ymin, _ = n.ymax, b3 = t3.size[0] * t3.pixelRatio, V2 = t3.size[1] * t3.pixelRatio, f4 = Math.max(h2.width, h2.height), v2 = { "[bboxWest]": y3.toString(), "[bboxEast]": g3.toString(), "[bboxSouth]": w3.toString(), "[bboxNorth]": _.toString(), "[lookatLon]": n.center.x.toString(), "[lookatLat]": n.center.y.toString(), "[lookatRange]": f4.toString(), "[lookatTilt]": "0", "[lookatHeading]": t3.rotation.toString(), "[lookatTerrainLon]": n.center.x.toString(), "[lookatTerrainLat]": n.center.y.toString(), "[lookatTerrainAlt]": "0", "[cameraLon]": n.center.x.toString(), "[cameraLat]": n.center.y.toString(), "[cameraAlt]": f4.toString(), "[horizFov]": "60", "[vertFov]": "60", "[horizPixels]": b3.toString(), "[vertPixels]": V2.toString(), "[terrainEnabled]": "0", "[clientVersion]": r, "[kmlVersion]": "2.2", "[clientName]": "ArcGIS API for JavaScript", "[language]": "en-US" }, S = (e5) => {
        for (const i in e5) {
          let t4;
          for (t4 in v2)
            e5[i] = e5[i].replace(t4, v2[t4]);
        }
      }, I = A(s);
      S(I);
      let x3 = {};
      null != o2 && (x3 = A(o2), S(x3));
      const C3 = f2(e4.href);
      C3.query = { ...C3.query, ...I, ...x3 };
      return `${C3.path}?${v(I)}`;
    }
    return e4.href;
  }
  async _fetchService(e4) {
    const i = new C2();
    await this._loadVisualData(this.layer.url, i, e4), this._kmlVisualData = i, this._refreshCollections();
  }
  _refreshCollections() {
    this.allVisiblePoints.removeAll(), this.allVisiblePolylines.removeAll(), this.allVisiblePolygons.removeAll(), this.allVisibleMapImages.removeAll(), this.allVisiblePoints.addMany(this._kmlVisualData.allPoints.filter((e4) => this._isSublayerVisible(e4.sublayerId)).map(({ item: e4 }) => e4)), this.allVisiblePolylines.addMany(this._kmlVisualData.allPolylines.filter((e4) => this._isSublayerVisible(e4.sublayerId)).map(({ item: e4 }) => e4)), this.allVisiblePolygons.addMany(this._kmlVisualData.allPolygons.filter((e4) => this._isSublayerVisible(e4.sublayerId)).map(({ item: e4 }) => e4)), this.allVisibleMapImages.addMany(this._kmlVisualData.allMapImages.filter((e4) => this._isSublayerVisible(e4.sublayerId)).map(({ item: e4 }) => e4));
  }
  _isSublayerVisible(e4) {
    const i = this._kmlVisualData.allSublayers.get(e4);
    return !!(i == null ? void 0 : i.visibility) && (-1 === i.parentFolderId || this._isSublayerVisible(i.parentFolderId));
  }
  _loadVisualData(e4, i, t3) {
    return this._fetchParsedKML(e4, t3).then(async (e5) => {
      for (const s of e5.sublayers) {
        i.allSublayers.set(s.id, s);
        const e6 = s.points ? await b(s.points) : [], a3 = s.polylines ? await b(s.polylines) : [], o2 = s.polygons ? await b(s.polygons) : [], l = s.mapImages || [];
        if (i.allPoints.push(...e6.map((e7) => ({ item: e7, sublayerId: s.id }))), i.allPolylines.push(...a3.map((e7) => ({ item: e7, sublayerId: s.id }))), i.allPolygons.push(...o2.map((e7) => ({ item: e7, sublayerId: s.id }))), i.allMapImages.push(...l.map((e7) => ({ item: e7, sublayerId: s.id }))), s.networkLink) {
          const e7 = await this._getViewDependentUrl(s.networkLink, this.view.state);
          await this._loadVisualData(e7, i, t3);
        }
      }
    });
  }
  _fetchParsedKML(e4, i) {
    return g(e4, this.layer.spatialReference, this.layer.refreshInterval, i).then((e5) => d2(e5.data));
  }
  _removeMapImage(e4) {
    const i = this._bitmapIndex.get(e4);
    i && (this._mapImageContainer.removeChild(i), this._bitmapIndex.delete(e4));
  }
};
e([y()], j.prototype, "_pointsView", void 0), e([y()], j.prototype, "_polylinesView", void 0), e([y()], j.prototype, "_polygonsView", void 0), e([y()], j.prototype, "updating", void 0), j = e([a("esri.views.2d.layers.KMLLayerView2D")], j);
var k2 = j;
export {
  k2 as default
};
//# sourceMappingURL=KMLLayerView2D-WUVQAEZJ.js.map
