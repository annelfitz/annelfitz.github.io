{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/environment/atmosphereUtils.js", "../../@arcgis/core/chunks/ChapmanAtmosphere.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport{clamp as t}from\"../../../core/mathUtils.js\";function e(e){const o=1e5;return t((e-o)/(1e6-o),0,1)}const o=1e4,r=.085,n=1e5;export{n as atmosphereHeight,e as computeInnerAltitudeFade,o as innerAtmosphereDepth,r as rayLeighScaleHeight};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport{invertOrIdentity as e}from\"../core/libs/gl-matrix-2/math/mat4.js\";import{create as t}from\"../core/libs/gl-matrix-2/factories/mat4f64.js\";import{fromValues as a}from\"../core/libs/gl-matrix-2/factories/vec3f64.js\";import{rayLeighScaleHeight as r,atmosphereHeight as i}from\"../views/3d/environment/atmosphereUtils.js\";import{TextureCoordinateAttribute as o,TextureCoordinateAttributeType as n}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";import{ReadLinearDepth as s}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js\";import{Gamma as l}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js\";import{addMainLightDirection as c}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";import{Float2PassUniform as h}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float3PassUniform as d}from\"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";import{Float4PassUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as u}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as f}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as v}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{VertexAttribute as x}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";const y=a(parseFloat(Number(5802e-9).toFixed(6)),parseFloat(Number(13558e-9).toFixed(6)),parseFloat(Number(331e-7).toFixed(6))),b=3,D=a(b*parseFloat(Number(65e-8).toFixed(6)),b*parseFloat(Number(1881e-9).toFixed(6)),b*parseFloat(Number(85e-9).toFixed(6))),P=3996e-9,w=a(parseFloat(Number(y[0]+D[0]).toFixed(6)),parseFloat(Number(y[1]+D[1]).toFixed(6)),parseFloat(Number(y[2]+D[2]).toFixed(6)));function S(t){const a=new f;a.attributes.add(x.POSITION,\"vec2\"),a.include(o,{textureCoordinateType:n.Default}),a.varyings.add(\"worldRay\",\"vec3\"),a.varyings.add(\"eyeDir\",\"vec3\");const{vertex:b,fragment:D}=a;return b.uniforms.add(new g(\"inverseProjectionMatrix\",((e,t)=>t.camera.inverseProjectionMatrix)),new g(\"inverseViewMatrix\",((t,a)=>e(F,a.camera.viewMatrix)))),b.code.add(u`void main(void) {\nvec3 posViewNear = (inverseProjectionMatrix * vec4(position, -1, 1)).xyz;\neyeDir = posViewNear;\nworldRay = (inverseViewMatrix * vec4(posViewNear, 0)).xyz;\nforwardTextureCoordinates();\ngl_Position = vec4(position, 1, 1);\n}`),D.uniforms.add(new d(\"backgroundColor\",(e=>e.backgroundColor)),new h(\"radii\",(e=>e.radii)),new d(\"cameraPosition\",((e,t)=>t.camera.eye)),new p(\"heightParameters\",(e=>e.heightParameters)),new m(\"innerFadeDistance\",(e=>e.innerFadeDistance)),new m(\"altitudeFade\",(e=>e.altitudeFade)),new v(\"depthTexture\",(e=>e.depthTexture)),new m(\"hazeStrength\",(e=>e.hazeStrength))),D.constants.add(\"betaRayleigh\",\"vec3\",y),D.constants.add(\"betaCombined\",\"vec3\",w),D.constants.add(\"betaMie\",\"float\",P),D.constants.add(\"scaleHeight\",\"float\",r*i),c(D),a.include(l),t.haze&&(D.include(s),D.uniforms.add(new h(\"nearFar\",((e,t)=>t.camera.nearFar)))),D.code.add(u`vec2 sphereIntersect(vec3 start, vec3 dir, float radius, bool planet) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = planet ? heightParameters[1] - radius * radius : heightParameters[2];\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}`),D.code.add(u`float chapmanApproximation(float X, float h, float cosZenith) {\nfloat c = sqrt(X + h);\nfloat cExpH = c * exp(-h);\nif (cosZenith >= 0.0) {\nreturn cExpH / (c * cosZenith + 1.0);\n} else {\nfloat x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);\nfloat c0 = sqrt(x0);\nreturn 2.0 * c0 * exp(X - x0) - cExpH / (1.0 - c * cosZenith);\n}\n}`),D.code.add(u`float getOpticalDepth(vec3 position, vec3 dir, float h) {\nreturn scaleHeight * chapmanApproximation(radii[0] / scaleHeight, h, dot(normalize(position), dir));\n}`),D.code.add(u`\n    const int STEPS = 6;\n\n    vec3 getAtmosphereColour(vec3 cameraPos, vec3 rayDir, vec3 lightDir, float terrainDepth) {\n      float reducedPlanetRadius = radii[0] - 20000.0;\n      vec2 rayPlanetIntersect = sphereIntersect(cameraPos, rayDir, reducedPlanetRadius, true);\n      vec2 rayAtmosphereIntersect = sphereIntersect(cameraPos, rayDir, radii[1], false);\n      bool hitsAtmosphere = (rayAtmosphereIntersect.x <= rayAtmosphereIntersect.y) && rayAtmosphereIntersect.x > 0.0;\n      bool insideAtmosphere = heightParameters[0] < radii[1];\n\n      if (!(hitsAtmosphere || insideAtmosphere)) {\n        return vec3(0);\n      }\n\n      bool hitsPlanet = (rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.x > 0.0;\n\n      float start = insideAtmosphere ? 0.0 : rayAtmosphereIntersect.x;\n\n      if (heightParameters[0] < reducedPlanetRadius) {\n        // Long light rays from the night side of the planet lead to numerical instability\n        // Do not render the atmosphere in such cases\n        if (dot(rayDir, normalize(cameraPos)) < -0.025) {\n          return vec3(0);\n        }\n        start = rayPlanetIntersect.y;\n      }\n\n      float end = hitsPlanet ? rayPlanetIntersect.x : rayAtmosphereIntersect.y;\n      float maxEnd = end;\n\n      ${t.haze?u`if (terrainDepth != -1.0) { end = terrainDepth; }`:\"\"}\n\n      vec3 samplePoint = cameraPos + rayDir * end;\n      float multiplier = hitsPlanet ? -1.0 : 1.0;\n\n      vec3 scattering = vec3(0);\n      float scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n      float lastOpticalDepth = getOpticalDepth(samplePoint, rayDir, scaleFract);\n      float stepSize = (end - start) / float(STEPS);\n      for (int i = 0; i < STEPS; i++) {\n        samplePoint -= stepSize * rayDir;\n        scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n        float opticalDepth = multiplier * getOpticalDepth(samplePoint, rayDir * multiplier, scaleFract);\n\n        if (i > 0) {\n          scattering *= ${t.haze?\"\":u`mix(2.5, 1.0, clamp((length(cameraPos) - radii[0]) / 50e3, 0.0, 1.0)) * `} exp(-(mix(betaCombined, betaRayleigh, 0.5) + betaMie) * max(0.0, (opticalDepth - lastOpticalDepth)));\n        }\n\n        if (dot(normalize(samplePoint), lightDir) > -0.3) {\n\n          float scale = exp(-scaleFract);\n          float lightDepth = getOpticalDepth(samplePoint, lightDir, scaleFract);\n\n          scattering += scale * exp(-(betaCombined + betaMie) * lightDepth);\n          ${t.haze?\"\":u`scattering += scale * exp(-(0.25 * betaCombined ) * lightDepth);`}\n        }\n\n        lastOpticalDepth = opticalDepth;\n\n      }\n\n      float mu = dot(rayDir, lightDir);\n      float mumu = 1.0 + mu * mu;\n\n      float phaseRayleigh = 0.0596831 * mumu;\n\n      ${t.haze?u`return 3.0 * scattering * stepSize * phaseRayleigh * betaRayleigh;`:u`\n            const float g = 0.8;\n            const float gg = g * g;\n            float phaseMie = end == maxEnd ? 0.1193662 * ((1.0 - gg) * mumu) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n            phaseMie = clamp(phaseMie, 0.0, 128.0);\n            return 3.0 * scattering * stepSize * (phaseRayleigh * betaRayleigh + 0.025 * phaseMie * betaMie);`}\n    }\n\n    ${t.haze?\"\":u`\n            vec4 applyUndergroundAtmosphere(vec3 rayDir, vec3 lightDirection, vec4 fragColor) {\n              vec2 rayPlanetIntersect = sphereIntersect(cameraPosition, rayDir, radii[0], true);\n              if (!((rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.y > 0.0)) {\n                return fragColor;\n              }\n\n              float lightAngle = dot(lightDirection, normalize(cameraPosition + rayDir * max(0.0, rayPlanetIntersect.x)));\n              vec4 surfaceColor = vec4(vec3(max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)))), 1.0 - altitudeFade);\n              float relDist = (rayPlanetIntersect.y - max(0.0, rayPlanetIntersect.x)) / innerFadeDistance;\n              if (relDist > 1.0) {\n                return surfaceColor;\n              }\n\n              return mix(fragColor, surfaceColor, smoothstep(0.0, 1.0, relDist * relDist));\n            }\n\n            float getGlow(float dist, float radius, float intensity) {\n              return pow(radius / max(dist, 1e-6), intensity);\n            }\n\n            vec3 getSun(vec3 cameraPos, vec3 rayDir, vec3 lightDir){\n\n              // Get the amount of atmosphere between camera and the Sun along the view ray\n              float scaleFract = (length(cameraPos) - radii[0]) / scaleHeight;\n              float sunOpticalDepth = getOpticalDepth(cameraPos, rayDir, max(scaleFract, 0.0));\n\n              // Find the amount of light that remains after travelling through the atmosphere from the Sun along the view ray\n              // This will make the colour of the Sun reddish on the horizon and white from space\n              vec3 sunTransmittance = exp(-(mix(betaCombined, betaRayleigh, 0.5)) * max(0.0, sunOpticalDepth));\n\n              // Alignment of light direction and view ray\n              float mu = clamp(dot(rayDir, lightDir), 0.0, 1.0);\n              // Draw the Sun as a bright disc\n              float sunDisc = 256.0 * smoothstep(0.0, 128.0, clamp(getGlow(1.0 - mu, 3e-5, 3.0), 0.0, 128.0));\n\n              return normalize(sunTransmittance) * sunDisc;\n            }`}\n\n    ${t.haze&&t.reduced?u`\n        float getDepth(vec2 uv){\n          return linearDepthFromTexture(depthTexture, uv, nearFar);\n        }\n\n        float textureBilinear(vec2 uv) {\n          // Information about the high-resolution depth texture\n          vec2 depthTextureSize = vec2(textureSize(depthTexture, 0));\n          vec2 texelSize = 1.0 / depthTextureSize;\n\n          // The uv inside the upper right pixel - of the tile of 4 pixels -\n          // that the atmosphere uv maps to in the depth texture\n          vec2 depthUV = (uv * depthTextureSize) - vec2(0.5);\n\n          // Relative distance of the uv coordinates inside the depth texture pixel\n          vec2 f = fract(depthUV);\n\n          // Snap to the centre of the depth texture pixel\n          vec2 snapUV = (floor(depthUV) + vec2(0.5)) / depthTextureSize;\n\n          // Read the depth texture pixel and its three neighbours\n          float d0 = getDepth(snapUV);\n          float d1 = getDepth(snapUV + vec2(texelSize.x, 0.0));\n          float d2 = getDepth(snapUV + vec2(0.0, texelSize.y));\n          float d3 = getDepth(snapUV + texelSize);\n\n          // Return the bilinearly interpolated value of the neighbouring pixels based\n          // on the sample position in the depth texture pixel\n          return mix(mix(d0, d1, f.x), mix(d2, d3, f.x), f.y);\n        }\n        `:\"\"}\n\n    vec3 tonemapACES(vec3 x) {\n      return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n    }\n\n    void main() {\n      vec3 rayDir = normalize(worldRay);\n      float terrainDepth = -1.0;\n      ${t.haze?u`\n          vec4 depthSample = texture(depthTexture, vuv0).rgba;\n          if (depthSample != vec4(0)) {\n            vec3 cameraSpaceRay = normalize(eyeDir);\n            cameraSpaceRay /= cameraSpaceRay.z;\n\n              ${t.reduced?u`cameraSpaceRay *= -textureBilinear(vuv0);`:u`cameraSpaceRay *= -linearDepthFromTexture(depthTexture, vuv0, nearFar);`}\n\n            terrainDepth = max(0.0, length(cameraSpaceRay));\n          }else{\n            discard;\n          }\n          `:u`${t.reduced?\"\":u`\n                float depthSample = texture(depthTexture, vuv0).r;\n                if (depthSample != 1.0) {\n                  fragColor = vec4(0);\n                  return;\n                }`}`}\n\n      ${t.haze?u`\n            vec3 col = vec3(0);\n            float fadeOut = smoothstep(-10000.0, -15000.0, heightParameters[0] - radii[0]);\n            if(depthSample != vec4(0)){\n              col = (1.0 - fadeOut) * hazeStrength * getAtmosphereColour(cameraPosition, rayDir, mainLightDirection, terrainDepth);\n            }\n            // Alpha is ignored for haze blending\n            float alpha = 1.0;\n            `:u`\n            vec3 col = linearizeGamma(backgroundColor);\n            col += getAtmosphereColour(cameraPosition, rayDir, mainLightDirection, terrainDepth);\n            col += getSun(cameraPosition, rayDir, mainLightDirection);\n            float alpha = smoothstep(0.0, mix(0.15, 0.01, heightParameters[3]), length(col));`}\n\n      col = tonemapACES(col);\n      fragColor = delinearizeGamma(vec4(col, alpha));\n      ${t.haze?\"\":u`fragColor = applyUndergroundAtmosphere(rayDir, mainLightDirection, fragColor);`}\n    }\n  `),a}const F=t(),z=Object.freeze(Object.defineProperty({__proto__:null,betaRayleigh:y,build:S},Symbol.toStringTag,{value:\"Module\"}));export{z as C,S as a,y as b};\n"],
  "mappings": "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",
  "names": ["e", "o", "r", "t", "o", "e", "b", "D", "a", "r"]
}
