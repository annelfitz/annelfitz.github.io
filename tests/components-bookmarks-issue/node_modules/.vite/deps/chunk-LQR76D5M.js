import {
  p,
  t
} from "./chunk-2CWW7O7M.js";
import {
  x
} from "./chunk-FLBJ53KN.js";
import {
  C as C2
} from "./chunk-DXMBDX2I.js";
import {
  m as m3,
  o as o5
} from "./chunk-TUVEYM7U.js";
import {
  D as D2
} from "./chunk-2NPNEA6N.js";
import {
  m as m2
} from "./chunk-OKRW5W44.js";
import {
  j
} from "./chunk-Q6RZBEZ6.js";
import {
  b
} from "./chunk-PC66NY33.js";
import {
  a as a4
} from "./chunk-YY2VB3AE.js";
import {
  P
} from "./chunk-ETHGDNE6.js";
import {
  m,
  y as y2
} from "./chunk-RKVEKQ5O.js";
import {
  a as a3
} from "./chunk-P7J4JFEH.js";
import {
  D
} from "./chunk-ZIJHDTB7.js";
import {
  i
} from "./chunk-R4CJB3GP.js";
import {
  y as y3
} from "./chunk-HU5IGOTI.js";
import {
  o as o3
} from "./chunk-TGXFDJCS.js";
import {
  o as o4
} from "./chunk-BOAEEYBE.js";
import {
  o as o2
} from "./chunk-YOPMY6TS.js";
import {
  r
} from "./chunk-VIN55KNF.js";
import {
  f
} from "./chunk-SBL4URUW.js";
import {
  C,
  d
} from "./chunk-Z4Y53NDM.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a2
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  a,
  n2 as n,
  o,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/layers/support/ExpressionInfo.js
var p2 = class extends i(f) {
  constructor(r2) {
    super(r2), this.expression = null, this.title = null, this.returnType = null;
  }
};
e([y({ type: String, json: { write: true } })], p2.prototype, "expression", void 0), e([y({ type: String, json: { write: true } })], p2.prototype, "title", void 0), e([y({ type: String, json: { write: true } })], p2.prototype, "returnType", void 0), p2 = e([a2("esri.layers.support.ExpressionInfo")], p2);
var i2 = p2;

// node_modules/@arcgis/core/layers/support/AggregateField.js
var p3;
var n2 = p3 = class extends f {
  constructor(t2) {
    super(t2), this.isAutoGenerated = false, this.name = null, this.alias = null, this.onStatisticField = null, this.onStatisticExpression = null, this.statisticType = null;
  }
  clone() {
    return new p3({ name: this.name, alias: this.alias, isAutoGenerated: this.isAutoGenerated, onStatisticExpression: a(this.onStatisticExpression), onStatisticField: this.onStatisticField, statisticType: this.statisticType });
  }
};
e([y({ type: Boolean, json: { write: true } })], n2.prototype, "isAutoGenerated", void 0), e([y({ type: String, json: { write: true } })], n2.prototype, "name", void 0), e([y({ type: String, json: { write: true } })], n2.prototype, "alias", void 0), e([y({ type: String, json: { write: true } })], n2.prototype, "onStatisticField", void 0), e([y({ type: i2, json: { write: true } })], n2.prototype, "onStatisticExpression", void 0), e([y({ type: String, json: { write: true } })], n2.prototype, "statisticType", void 0), n2 = p3 = e([a2("esri.layers.support.AggregateField")], n2);
var a5 = n2;

// node_modules/@arcgis/core/layers/support/FeatureReductionBinning.js
var y4;
var g = y4 = class extends t {
  constructor(e2) {
    super(e2), this.type = "binning", this.binType = "geohash", this.fixedBinLevel = 3, this.labelingInfo = null, this.labelsVisible = true, this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.fields = [], this.renderer = null;
  }
  writeFields(e2, r2, o7) {
    const t2 = e2.filter((e3) => "avg_angle" !== e3.statisticType).map((e3) => e3.toJSON());
    o(o7, t2, r2);
  }
  readRenderer(e2, r2, t2) {
    var _a;
    const s2 = (_a = r2.drawingInfo) == null ? void 0 : _a.renderer;
    return s2 ? o5(s2, r2, t2) ?? void 0 : D2(r2, t2);
  }
  clone() {
    return new y4({ fields: a(this.fields), fixedBinLevel: this.fixedBinLevel, labelingInfo: a(this.labelingInfo), labelsVisible: this.labelsVisible, maxScale: this.maxScale, popupEnabled: this.popupEnabled, popupTemplate: a(this.popupTemplate), renderer: a(this.renderer) });
  }
};
e([o3({ binning: "binning" })], g.prototype, "type", void 0), e([o3({ geohash: "geohash" })], g.prototype, "binType", void 0), e([y({ type: Number, range: { min: 1, max: 9 }, json: { write: true } })], g.prototype, "fixedBinLevel", void 0), e([y({ type: [C2], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], g.prototype, "labelingInfo", void 0), e([y(m)], g.prototype, "labelsVisible", void 0), e([y({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], g.prototype, "maxScale", void 0), e([y(y2)], g.prototype, "popupEnabled", void 0), e([y({ type: P, json: { name: "popupInfo", write: true } })], g.prototype, "popupTemplate", void 0), e([y({ type: [a5], json: { write: true } })], g.prototype, "fields", void 0), e([r("fields")], g.prototype, "writeFields", null), e([y({ types: m3, json: { write: { target: "drawingInfo.renderer" } } })], g.prototype, "renderer", void 0), e([o2("renderer", ["drawingInfo.renderer"])], g.prototype, "readRenderer", null), g = y4 = e([a2("esri.layers.support.FeatureReductionBinning")], g);
var h = g;

// node_modules/@arcgis/core/layers/support/FeatureReductionCluster.js
var g2;
function S(e2) {
  var _a;
  return "simple" === e2.type && !((_a = e2.visualVariables) == null ? void 0 : _a.length);
}
var w = g2 = class extends f {
  constructor(e2) {
    super(e2), this.type = "cluster", this.clusterRadius = o4("80px"), this.clusterMinSize = o4("12px"), this.clusterMaxSize = o4("50px"), this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.renderer = null, this.symbol = null, this.labelingInfo = null, this.labelsVisible = true, this.fields = [];
  }
  readRenderer(e2, r2, t2) {
    var _a, _b;
    const s2 = (_a = r2.drawingInfo) == null ? void 0 : _a.renderer;
    return ((_b = s2 == null ? void 0 : s2.authoringInfo) == null ? void 0 : _b.isAutoGenerated) ? null : s2 ? S(s2) ? null : o5(s2, r2, t2) ?? void 0 : D2(r2, t2);
  }
  readSymbol(e2, r2, t2) {
    var _a, _b;
    const s2 = (_a = r2.drawingInfo) == null ? void 0 : _a.renderer;
    if ((_b = s2 == null ? void 0 : s2.authoringInfo) == null ? void 0 : _b.isAutoGenerated)
      return null;
    if (s2 && S(s2)) {
      const e3 = o5(s2, r2, t2);
      return e3 == null ? void 0 : e3.symbol;
    }
    return null;
  }
  writeSymbol(e2, r2, o7, s2) {
    var _a, _b;
    const i3 = (_b = (_a = this.renderer) == null ? void 0 : _a.authoringInfo) == null ? void 0 : _b.isAutoGenerated;
    if (!this.renderer || i3) {
      const o8 = new m2({ symbol: e2 });
      r2.drawingInfo = { renderer: o8.write({}, s2) };
    }
  }
  writeFields(e2, r2, t2) {
    const o7 = e2.filter((e3) => "avg_angle" !== e3.statisticType).map((e3) => e3.toJSON());
    o(t2, o7, r2);
  }
  readFields(e2, r2, t2) {
    return e2.filter((e3) => !e3.isAutoGenerated).map((e3) => a5.fromJSON(e3));
  }
  clone() {
    return new g2({ clusterRadius: this.clusterRadius, clusterMinSize: this.clusterMinSize, clusterMaxSize: this.clusterMaxSize, labelingInfo: a(this.labelingInfo), labelsVisible: this.labelsVisible, fields: a(this.fields), maxScale: this.maxScale, renderer: a(this.renderer), symbol: a(this.symbol), popupEnabled: this.popupEnabled, popupTemplate: a(this.popupTemplate) });
  }
};
e([y({ type: ["cluster"], readOnly: true, json: { write: true } })], w.prototype, "type", void 0), e([y({ type: Number, cast: (e2) => "auto" === e2 ? e2 : o4(e2), json: { write: true } })], w.prototype, "clusterRadius", void 0), e([y({ type: Number, cast: o4, json: { write: true } })], w.prototype, "clusterMinSize", void 0), e([y({ type: Number, cast: o4, json: { write: true } })], w.prototype, "clusterMaxSize", void 0), e([y({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], w.prototype, "maxScale", void 0), e([y(y2)], w.prototype, "popupEnabled", void 0), e([y({ type: P, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], w.prototype, "popupTemplate", void 0), e([y({ types: m3, json: { write: { target: "drawingInfo.renderer" } } })], w.prototype, "renderer", void 0), e([o2("renderer", ["drawingInfo.renderer"])], w.prototype, "readRenderer", null), e([y({ types: D })], w.prototype, "symbol", void 0), e([o2("symbol", ["drawingInfo.renderer"])], w.prototype, "readSymbol", null), e([r("symbol")], w.prototype, "writeSymbol", null), e([y({ type: [C2], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], w.prototype, "labelingInfo", void 0), e([y(m)], w.prototype, "labelsVisible", void 0), e([y({ type: [a5], json: { write: true } })], w.prototype, "fields", void 0), e([r("fields")], w.prototype, "writeFields", null), e([o2("fields")], w.prototype, "readFields", null), w = g2 = e([a2("esri.layers.support.FeatureReductionCluster")], w);
var I = w;

// node_modules/@arcgis/core/layers/support/featureReductionUtils.js
var o6 = { key: "type", base: t, typeMap: { cluster: I, binning: h } };
var p4 = { types: { key: "type", base: t, typeMap: { selection: p, cluster: I, binning: h } }, json: { name: "layerDefinition.featureReduction", write: { allowNull: true }, origins: { "web-map": { types: o6 }, "portal-item": { types: o6 }, "web-scene": { types: { key: "type", base: t, typeMap: { selection: p } }, name: "layerDefinition.featureReduction", write: { layerContainerTypes: a3 } } } } };

// node_modules/@arcgis/core/views/2d/layers/support/clusterUtils.js
var l = () => n.getLogger("esri.views.2d.layers.support.clusterUtils");
has.add("esri-cluster-arcade-enabled", true);
var u = has("esri-cluster-arcade-enabled");
var p5 = /* @__PURE__ */ new Set(["simple-line", "simple-fill", "picture-fill"]);
function d2(r2, s2) {
  let n3 = s2.clone();
  if (!c(n3))
    return n3;
  if (s2.getSymbols().some((e2) => p5.has(e2.type)) && (n3 = new m2({ symbol: new y3() })), n3.authoringInfo || (n3.authoringInfo = new j()), n3.authoringInfo.isAutoGenerated = true, "visualVariables" in n3) {
    const e2 = (n3.visualVariables || []).filter((e3) => "$view.scale" !== e3.valueExpression);
    e2.forEach((e3) => {
      "rotation" === e3.type ? e3.field ? e3.field = g3(r2, e3.field, "avg_angle", "number") : e3.valueExpression && (e3.field = b2(r2, e3.valueExpression, "avg_angle", "number"), e3.valueExpression = null) : e3.normalizationField ? (e3.field = g3(r2, e3.field, "avg_norm", "number", e3.normalizationField), e3.normalizationField = null) : e3.field ? e3.field = g3(r2, e3.field, "avg", "number") : e3.valueExpression && (e3.field = b2(r2, e3.valueExpression, "avg", "number"), e3.valueExpression = null);
    }), n3.visualVariables = e2;
  }
  switch (n3.type) {
    case "simple":
      break;
    case "pie-chart":
      for (const e2 of n3.attributes)
        e2.field ? e2.field = g3(r2, e2.field, "sum", "number") : e2.valueExpression && (e2.field = b2(r2, e2.valueExpression, "sum", "number"), e2.valueExpression = null);
      break;
    case "unique-value":
      n3.field ? n3.field = g3(r2, n3.field, "mode", "string") : n3.valueExpression && (n3.field = b2(r2, n3.valueExpression, "mode", "string"), n3.valueExpression = null);
      break;
    case "class-breaks":
      n3.normalizationField ? (n3.field = g3(r2, n3.field, "avg_norm", "number", n3.normalizationField), n3.normalizationField = null) : n3.field ? n3.field = g3(r2, n3.field, "avg", "number") : n3.valueExpression && (n3.field = b2(r2, n3.valueExpression, "avg", "number"), n3.valueExpression = null);
  }
  return n3;
}
var c = (e2) => {
  const r2 = (r3) => l().error(new s("Unsupported-renderer", r3, { renderer: e2 }));
  if (!e2)
    return false;
  switch (e2.type) {
    case "unique-value":
      if (e2.field2 || e2.field3)
        return r2("FeatureReductionCluster does not support multi-field UniqueValueRenderers"), false;
      break;
    case "class-breaks":
      if (e2.normalizationField) {
        const s2 = e2.normalizationType;
        if ("field" !== s2)
          return r2(`FeatureReductionCluster does not support a normalizationType of ${s2}`), false;
      }
      break;
    case "simple":
    case "pie-chart":
      break;
    default:
      return r2(`FeatureReductionCluster does not support renderers of type ${e2.type}`), false;
  }
  if (!u) {
    if ("valueExpression" in e2 && e2.valueExpression)
      return r2("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"), false;
    if (("visualVariables" in e2 && e2.visualVariables || []).some((e3) => !(!("valueExpression" in e3) || !e3.valueExpression)))
      return r2("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"), false;
  }
  return true;
};
function v(e2, r2, s2) {
  switch (e2) {
    case "sum":
      return `cluster_sum_${r2}`;
    case "avg":
    case "avg_angle":
      return `cluster_avg_${r2}`;
    case "mode":
      return `cluster_type_${r2}`;
    case "avg_norm": {
      const e3 = s2, i3 = "field", t2 = r2.toLowerCase() + ",norm:" + i3 + "," + e3.toLowerCase();
      return "cluster_avg_" + x(t2);
    }
  }
}
function b2(e2, r2, s2, o7) {
  const a6 = x(r2), l2 = "mode" === s2 ? `cluster_type_${a6}` : "sum" === s2 ? `cluster_sum_${a6}` : `cluster_avg_${a6}`;
  return e2.some((e3) => e3.name === l2) || e2.push(new a5({ name: l2, isAutoGenerated: true, onStatisticExpression: new i2({ expression: r2, returnType: o7 }), statisticType: s2 })), l2;
}
function g3(e2, r2, s2, n3, o7) {
  if ("cluster_count" === r2 || e2.some((e3) => e3.name === r2))
    return r2;
  const a6 = v(s2, r2, o7);
  return e2.some((e3) => e3.name === a6) || ("avg_norm" === s2 ? e2.push(new a5({ name: a6, isAutoGenerated: true, onStatisticExpression: new i2({ expression: `$feature.${r2} / $feature.${o7}`, returnType: n3 }), statisticType: "avg" })) : e2.push(new a5({ name: a6, isAutoGenerated: true, onStatisticField: r2, statisticType: s2 }))), a6;
}

// node_modules/@arcgis/core/layers/mixins/FeatureReductionLayer.js
var c2 = (c3) => {
  let p6 = class extends c3 {
    constructor(...e2) {
      super(...e2), this.addHandles(d(() => this.renderer, () => {
        if (this.featureReduction) {
          const e3 = this._normalizeFeatureReduction(this.featureReduction);
          this._set("featureReduction", e3);
        }
      }, C));
    }
    set featureReduction(e2) {
      const r2 = this._normalizeFeatureReduction(e2);
      this._set("featureReduction", r2);
    }
    set renderer(e2) {
    }
    _withClusterVariable(e2, r2, s2) {
      const t2 = e2.clone();
      if ("visualVariables" in t2) {
        t2.visualVariables || (t2.visualVariables = []);
        t2.visualVariables.some((e3) => "size" === e3.type) || t2.visualVariables.push(new b({ field: "cluster_count", stops: [new a4({ value: 1 }), new a4({ useMinValue: true, size: r2 }), new a4({ useMaxValue: true, size: s2 })] }));
      }
      return t2;
    }
    _normalizeFeatureReduction(e2) {
      var _a;
      if ("cluster" !== (e2 == null ? void 0 : e2.type))
        return e2;
      const s2 = e2.clone(), t2 = [new a5({ name: "cluster_count", isAutoGenerated: true, statisticType: "count" })], i3 = (s2.fields ?? []).filter((e3) => !e3.isAutoGenerated), n3 = e2.renderer && !((_a = e2.renderer.authoringInfo) == null ? void 0 : _a.isAutoGenerated), { clusterMinSize: a6, clusterMaxSize: u2 } = s2;
      if (n3) {
        s2.fields = [...t2, ...i3];
        const e3 = this._withClusterVariable(s2.renderer, a6, u2);
        return s2.effectiveFeatureRenderer = e3, s2.effectiveClusterRenderer = e3, s2;
      }
      if (e2.symbol) {
        if (s2.fields = [...t2, ...i3], s2.renderer = null, !this.renderer)
          return s2.effectiveFeatureRenderer = null, s2.effectiveClusterRenderer = null, s2;
        const n4 = d2(t2, this.renderer), o7 = this._withClusterVariable(n4, a6, u2), l3 = "visualVariables" in o7 && o7.visualVariables ? o7.visualVariables : [], c5 = new m2({ symbol: e2.symbol, visualVariables: l3 });
        return s2.fields = [...t2, ...i3], s2.effectiveFeatureRenderer = o7, s2.effectiveClusterRenderer = c5, s2;
      }
      if (!this.renderer)
        return e2;
      const l2 = d2(t2, this.renderer);
      s2.fields = [...t2, ...i3], s2.renderer = l2;
      const c4 = this._withClusterVariable(l2, a6, u2);
      return s2.effectiveFeatureRenderer = c4, s2.effectiveClusterRenderer = c4, s2;
    }
  };
  return e([y(p4)], p6.prototype, "featureReduction", null), p6 = e([a2("esri.layers.mixins.FeatureReductionLayer")], p6), p6;
};

export {
  c2 as c
};
//# sourceMappingURL=chunk-LQR76D5M.js.map
