import {
  $
} from "./chunk-N7746YEI.js";
import {
  i,
  o
} from "./chunk-WTKF56EK.js";
import {
  d as d2
} from "./chunk-XJICXW6N.js";
import {
  d
} from "./chunk-F3BQGS35.js";
import {
  s
} from "./chunk-YUUTEPX2.js";
import {
  f as f2
} from "./chunk-QYC3GV65.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  r2 as r
} from "./chunk-I2RC5KWA.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/rest/support/meshFeatureSet.js
var m = () => n.getLogger("esri.rest.support.meshFeatureSet");
function p(t, r2, o2) {
  const n2 = o2.features;
  o2.features = [], delete o2.geometryType;
  const s2 = d.fromJSON(o2);
  if (s2.geometryType = "mesh", !o2.assetMaps)
    return s2;
  const i2 = S(r2, o2.assetMaps), u = t.sourceSpatialReference ?? f.WGS84, f3 = o2.globalIdFieldName, { outFields: c } = t, m2 = null != c && c.length > 0 ? g(c.includes("*") ? null : new Set(c)) : () => ({});
  for (const a of n2) {
    const t2 = h(a, f3, u, r2, i2);
    null != t2 && s2.features.push(new f2({ geometry: t2, attributes: m2(a) }));
  }
  return s2;
}
function g(e) {
  return ({ attributes: t }) => {
    if (!t)
      return {};
    if (!e)
      return t;
    for (const r2 in t)
      e.has(r2) || delete t[r2];
    return t;
  };
}
function h(e, t, r2, s2, a) {
  const i2 = e.attributes[t], u = a.get(i2);
  if (null == u)
    return m().error("mesh-feature-set:asset-not-found", "Service returned a feature which was not found in the asset map", e), null;
  if (!e.geometry)
    return m().error("mesh-feature-set:no-geometry", "Service returned a feature without geometry", e), null;
  const f3 = y(e, r2, s2), c = w.fromJSON(e.geometry);
  c.spatialReference = r2;
  const l = E(e.attributes, s2), p2 = r2.isGeographic ? "local" : "georeferenced", g2 = w2(u);
  return g2 ? $.createWithExternalSource(f3, g2, { extent: c, transform: l, vertexSpace: p2 }) : $.createIncomplete(f3, { extent: c, transform: l, vertexSpace: p2 });
}
function y({ attributes: e }, t, { transformFieldRoles: r2 }) {
  const o2 = e[r2.originX], n2 = e[r2.originY], a = e[r2.originZ];
  return new x({ x: o2, y: n2, z: a, spatialReference: t });
}
function E(e, { transformFieldRoles: t }) {
  return new d2({ translation: [e[t.translationX], -e[t.translationZ], e[t.translationY]], rotationAxis: [e[t.rotationX], -e[t.rotationZ], e[t.rotationY]], rotationAngle: e[t.rotationDeg], scale: [e[t.scaleX], e[t.scaleZ], e[t.scaleY]] });
}
var d3;
function S(e, t) {
  const o2 = /* @__PURE__ */ new Map();
  for (const n2 of t) {
    const t2 = n2.parentGlobalId;
    if (null == t2)
      continue;
    const s2 = n2.assetName, a = n2.assetType, i2 = n2.assetHash, u = n2.assetURL, f3 = n2.conversionStatus, l = n2.seqNo, p2 = s(a, e.supportedFormats);
    if (!p2) {
      m().error("mesh-feature-set:unknown-format", `Service returned an asset of type ${a}, but it does not list it as a supported type`);
      continue;
    }
    const g2 = r(o2, t2, () => ({ files: /* @__PURE__ */ new Map() }));
    r(g2.files, s2, () => ({ name: s2, type: a, mimeType: p2, status: D(f3), parts: [] })).parts[l] = { hash: i2, url: u };
  }
  return o2;
}
function w2(e) {
  const t = Array.from(e.files.values()), r2 = new Array();
  for (const o2 of t) {
    if (o2.status !== d3.COMPLETED)
      return null;
    const e2 = new Array();
    for (const t2 of o2.parts) {
      if (!t2)
        return null;
      e2.push(new o(t2.url, t2.hash));
    }
    r2.push(new i(o2.name, o2.mimeType, e2));
  }
  return r2;
}
function D(e) {
  switch (e) {
    case "COMPLETED":
    case "SUBMITTED":
      return d3.COMPLETED;
    case "INPROGRESS":
      return d3.PENDING;
    default:
      return d3.FAILED;
  }
}
!function(e) {
  e[e.FAILED = 0] = "FAILED", e[e.PENDING = 1] = "PENDING", e[e.COMPLETED = 2] = "COMPLETED";
}(d3 || (d3 = {}));

export {
  p,
  h,
  S
};
//# sourceMappingURL=chunk-7KK6L4F6.js.map
