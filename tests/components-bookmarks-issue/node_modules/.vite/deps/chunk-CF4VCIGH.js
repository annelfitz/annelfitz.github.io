import {
  I,
  R,
  b as b2,
  g as g2,
  h,
  m as m2,
  p
} from "./chunk-QJHIIUXI.js";
import {
  x
} from "./chunk-3IAZNUQL.js";
import {
  s as s2
} from "./chunk-ZOUC7PLM.js";
import {
  o as o2
} from "./chunk-ZECONJNT.js";
import {
  v
} from "./chunk-WTKF56EK.js";
import {
  a as a3,
  g
} from "./chunk-QJRGTKPN.js";
import {
  i as i2
} from "./chunk-2QCWKZIQ.js";
import {
  Q
} from "./chunk-2NPNEA6N.js";
import {
  b
} from "./chunk-W5ALAOW2.js";
import {
  F
} from "./chunk-YUUTEPX2.js";
import {
  a as a4,
  c as c2,
  i,
  t as t2
} from "./chunk-OHE3HDFF.js";
import {
  c
} from "./chunk-I5RCKVDX.js";
import {
  w as w2
} from "./chunk-VTH4DAHQ.js";
import {
  m
} from "./chunk-ONK5AE7R.js";
import {
  r
} from "./chunk-TPLOIZC7.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  n as n2
} from "./chunk-RUN6MNXL.js";
import {
  U,
  V,
  t3 as t
} from "./chunk-SAYWXQVM.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a2
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  A,
  a,
  k as k2
} from "./chunk-JGDJR5EV.js";
import {
  n2 as n,
  o,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has,
  k
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/layers/graphics/sources/FeatureLayerSource.js
var D = new n2({ originalAndCurrentFeatures: "original-and-current-features", none: "none" });
var P = new n2({ Started: "published", Publishing: "publishing", Stopped: "unavailable" });
var $ = class extends m {
  constructor() {
    super(...arguments), this.type = "feature-layer", this.supportedSourceTypes = /* @__PURE__ */ new Set(["Feature Layer", "Oriented Imagery Layer", "Table", "Catalog Layer"]), this.refresh = k2(async () => {
      var _a, _b;
      await this.load();
      const e2 = (_a = this.sourceJSON.editingInfo) == null ? void 0 : _a.lastEditDate;
      if (null == e2)
        return { dataChanged: true, updates: {} };
      try {
        await this._fetchService(null);
      } catch {
        return { dataChanged: true, updates: {} };
      }
      const t3 = e2 !== ((_b = this.sourceJSON.editingInfo) == null ? void 0 : _b.lastEditDate);
      return { dataChanged: t3, updates: t3 ? { editingInfo: this.sourceJSON.editingInfo, extent: this.sourceJSON.extent } : null };
    }), this._ongoingAssetUploads = /* @__PURE__ */ new Map();
  }
  load(e2) {
    const t3 = this.layer.sourceJSON, s3 = this._fetchService(t3, { ...e2 }).then(() => this.layer.setUserPrivileges(this.sourceJSON.serviceItemId, e2)).then(() => this._ensureLatestMetadata(e2));
    return this.addResolvingPromise(s3), Promise.resolve(this);
  }
  get queryTask() {
    var _a;
    const { capabilities: e2, parsedUrl: t3, dynamicDataSource: s3, infoFor3D: r2, gdbVersion: a5, spatialReference: i3, fieldsIndex: o3 } = this.layer, n3 = has("featurelayer-pbf") && (e2 == null ? void 0 : e2.query.supportsFormatPBF) && null == r2, u = ((_a = e2 == null ? void 0 : e2.operations) == null ? void 0 : _a.supportsQueryAttachments) ?? false;
    return new x({ url: t3.path, pbfSupported: n3, fieldsIndex: o3, infoFor3D: r2, dynamicDataSource: s3, gdbVersion: a5, sourceSpatialReference: i3, queryAttachmentsSupported: u });
  }
  async addAttachment(e2, t3) {
    await this.load();
    const { layer: r2 } = this;
    await Q(r2, "editing");
    const a5 = e2.attributes[r2.objectIdField], i3 = r2.parsedUrl.path + "/" + a5 + "/addAttachment", o3 = this._getLayerRequestOptions(), n3 = this._getFormDataForAttachment(t3, o3.query);
    try {
      const e3 = await U(i3, { body: n3 });
      return R(e3.data.addAttachmentResult);
    } catch (u) {
      throw this._createAttachmentErrorResult(a5, u);
    }
  }
  async updateAttachment(e2, t3, r2) {
    await this.load();
    const { layer: a5 } = this;
    await Q(a5, "editing");
    const i3 = e2.attributes[a5.objectIdField], o3 = a5.parsedUrl.path + "/" + i3 + "/updateAttachment", n3 = this._getLayerRequestOptions({ query: { attachmentId: t3 } }), u = this._getFormDataForAttachment(r2, n3.query);
    try {
      const e3 = await U(o3, { body: u });
      return R(e3.data.updateAttachmentResult);
    } catch (l) {
      throw this._createAttachmentErrorResult(i3, l);
    }
  }
  async applyEdits(e2, r2) {
    var _a, _b, _c, _d, _e, _f;
    await this.load();
    const { layer: o3 } = this;
    await Q(o3, "editing");
    const n3 = o3.infoFor3D, u = null != n3, l = u || ((r2 == null ? void 0 : r2.globalIdUsed) ?? false), c3 = u ? await this._uploadMeshesAndGetAssetMapEditsJSON(e2) : null, d = ((_a = e2.addFeatures) == null ? void 0 : _a.map((e3) => p(this.layer, e3, n3))) ?? [], p2 = (await Promise.all(d)).filter(k), y2 = ((_b = e2.updateFeatures) == null ? void 0 : _b.map((e3) => p(this.layer, e3, n3))) ?? [], h2 = (await Promise.all(y2)).filter(k), m3 = g2(this.layer, e2.deleteFeatures, l);
    i2(p2, h2, o3.spatialReference);
    const f2 = await m2(this.layer, e2), g3 = o3.capabilities.editing.supportsAsyncApplyEdits && u, w3 = (r2 == null ? void 0 : r2.gdbVersion) || o3.gdbVersion, S = { gdbVersion: w3, rollbackOnFailure: r2 == null ? void 0 : r2.rollbackOnFailureEnabled, useGlobalIds: l, returnEditMoment: r2 == null ? void 0 : r2.returnEditMoment, usePreviousEditMoment: r2 == null ? void 0 : r2.usePreviousEditMoment, async: g3 };
    await i(this.layer.url, w3, true);
    const q = c2(this.layer.url, w3 || null);
    if (await a4(o3.url, w3, o3.historicMoment))
      throw new s("feature-layer-source:historic-version", "Editing a historic version is not allowed");
    (r2 == null ? void 0 : r2.returnServiceEditsOption) ? (S.edits = JSON.stringify([{ id: o3.layerId, adds: p2, updates: h2, deletes: m3, attachments: f2, assetMaps: c3 }]), S.returnServiceEditsOption = D.toJSON(r2 == null ? void 0 : r2.returnServiceEditsOption), S.returnServiceEditsInSourceSR = r2 == null ? void 0 : r2.returnServiceEditsInSourceSR) : (S.adds = p2.length ? JSON.stringify(p2) : null, S.updates = h2.length ? JSON.stringify(h2) : null, S.deletes = m3.length ? l ? JSON.stringify(m3) : m3.join(",") : null, S.attachments = f2 && JSON.stringify(f2), S.assetMaps = null != c3 ? JSON.stringify(c3) : void 0);
    const E = this._getLayerRequestOptions({ method: "post", query: S });
    q && (E.authMode = "immediate", E.query.returnEditMoment = true, E.query.sessionId = t2);
    const F2 = (r2 == null ? void 0 : r2.returnServiceEditsOption) ? o3.url : o3.parsedUrl.path;
    let _;
    try {
      _ = g3 ? await this._asyncApplyEdits(F2 + "/applyEdits", E) : await U(F2 + "/applyEdits", E);
    } catch (x2) {
      if (!h(x2))
        throw x2;
      E.authMode = "immediate", _ = g3 ? await this._asyncApplyEdits(F2 + "/applyEdits", E) : await U(F2 + "/applyEdits", E);
    }
    if (!((_c = o3.capabilities.operations) == null ? void 0 : _c.supportsEditing) && ((_e = (_d = o3.effectiveCapabilities) == null ? void 0 : _d.operations) == null ? void 0 : _e.supportsEditing)) {
      const e3 = (_f = t) == null ? void 0 : _f.findCredential(o3.url);
      await (e3 == null ? void 0 : e3.refreshToken());
    }
    return this._createEditsResult(_);
  }
  async deleteAttachments(e2, t3) {
    await this.load();
    const { layer: r2 } = this;
    await Q(r2, "editing");
    const a5 = e2.attributes[r2.objectIdField], i3 = r2.parsedUrl.path + "/" + a5 + "/deleteAttachments";
    try {
      return (await U(i3, this._getLayerRequestOptions({ query: { attachmentIds: t3.join(",") }, method: "post" }))).data.deleteAttachmentResults.map(R);
    } catch (o3) {
      throw this._createAttachmentErrorResult(a5, o3);
    }
  }
  fetchRecomputedExtents(e2 = {}) {
    const t3 = e2.signal;
    return this.load({ signal: t3 }).then(async () => {
      const t4 = this._getLayerRequestOptions({ ...e2, query: { returnUpdates: true } }), { layerId: a5, url: i3 } = this.layer, { data: o3 } = await U(`${i3}/${a5}`, t4), { id: n3, extent: u, fullExtent: l, timeExtent: c3 } = o3, d = u || l;
      return { id: n3, fullExtent: d && w.fromJSON(d), timeExtent: c3 && c.fromJSON({ start: c3[0], end: c3[1] }) };
    });
  }
  async queryAttachments(e2, t3 = {}) {
    await this.load();
    const s3 = this._getLayerRequestOptions(t3);
    return this.queryTask.executeAttachmentQuery(e2, s3);
  }
  async queryFeatures(e2, t3) {
    var _a;
    await this.load();
    const s3 = await this.queryTask.execute(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
    return ((_a = e2.outStatistics) == null ? void 0 : _a.length) && s3.features.length && s3.features.forEach((t4) => {
      var _a2;
      const s4 = t4.attributes;
      (_a2 = e2.outStatistics) == null ? void 0 : _a2.forEach(({ outStatisticFieldName: e3 }) => {
        if (e3) {
          const t5 = e3.toLowerCase();
          t5 && t5 in s4 && e3 !== t5 && (s4[e3] = s4[t5], delete s4[t5]);
        }
      });
    }), s3;
  }
  async queryFeaturesJSON(e2, t3) {
    return await this.load(), this.queryTask.executeJSON(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryObjectIds(e2, t3) {
    return await this.load(), this.queryTask.executeForIds(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryFeatureCount(e2, t3) {
    return await this.load(), this.queryTask.executeForCount(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryExtent(e2, t3) {
    return await this.load(), this.queryTask.executeForExtent(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryRelatedFeatures(e2, t3) {
    return await this.load(), this.queryTask.executeRelationshipQuery(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryRelatedFeaturesCount(e2, t3) {
    return await this.load(), this.queryTask.executeRelationshipQueryForCount(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopFeatures(e2, t3) {
    return await this.load(), this.queryTask.executeTopFeaturesQuery(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopObjectIds(e2, t3) {
    return await this.load(), this.queryTask.executeForTopIds(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopExtents(e2, t3) {
    return await this.load(), this.queryTask.executeForTopExtents(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopCount(e2, t3) {
    return await this.load(), this.queryTask.executeForTopCount(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async fetchPublishingStatus() {
    if (!w2(this.layer.url))
      return "unavailable";
    const e2 = V(this.layer.url, "status"), t3 = await U(e2, { query: { f: "json" } });
    return P.fromJSON(t3.data.status);
  }
  async uploadAssets(e2, t3) {
    const { uploadAssets: s3 } = await import("./uploadAssets-XCDAPP73.js");
    return s3(e2, { layer: this.layer, ongoingUploads: this._ongoingAssetUploads }, t3);
  }
  async _asyncApplyEdits(e2, t3) {
    const r2 = (await U(e2, t3)).data.statusUrl;
    for (; ; ) {
      const e3 = (await U(r2, { query: { f: "json" }, responseType: "json" })).data;
      switch (e3.status) {
        case "Completed":
          return U(e3.resultUrl, { query: { f: "json" }, responseType: "json" });
        case "CompletedWithErrors":
          throw new s("async-applyEdits-failed", "asynchronous applyEdits call failed.");
        case "Failed ImportChanges":
        case "InProgress":
        case "Pending":
        case "ExportAttachments":
        case "ExportChanges":
        case "ExportingData":
        case "ExportingSnapshot":
        case "ImportAttachments":
        case "ProvisioningReplica":
        case "UnRegisteringReplica":
          break;
        default:
          throw new s("async-applyEdits-failed", "asynchronous applyEdits call failed (undefined response status)");
      }
      await A(V2);
    }
  }
  _createRequestQueryOptions(e2) {
    const t3 = { ...this.layer.customParameters, token: this.layer.apiKey, ...e2 == null ? void 0 : e2.query };
    return this.layer.datesInUnknownTimezone && (t3.timeReferenceUnknownClient = true), t3;
  }
  async _fetchService(e2, t3) {
    if (!e2) {
      const r3 = {};
      has("featurelayer-advanced-symbols") && (r3.returnAdvancedSymbols = true), (t3 == null ? void 0 : t3.cacheBust) && (r3._ts = Date.now());
      const { data: a5 } = await U(this.layer.parsedUrl.path, this._getLayerRequestOptions({ query: r3, signal: t3 == null ? void 0 : t3.signal }));
      e2 = a5;
    }
    this.sourceJSON = await this._patchServiceJSON(e2, t3 == null ? void 0 : t3.signal);
    const r2 = e2.type;
    if (!this.supportedSourceTypes.has(r2))
      throw new s("feature-layer-source:unsupported-type", `Source type "${r2}" is not supported`);
  }
  async _patchServiceJSON(e2, t3) {
    var _a;
    if ("Table" !== e2.type && e2.geometryType && !((_a = e2 == null ? void 0 : e2.drawingInfo) == null ? void 0 : _a.renderer) && !e2.defaultSymbol) {
      const t4 = o2(e2.geometryType).renderer;
      o("drawingInfo.renderer", t4, e2);
    }
    if ("esriGeometryMultiPatch" === e2.geometryType && e2.infoFor3D && (e2.geometryType = "mesh"), null == e2.extent)
      try {
        const { data: r2 } = await U(this.layer.url, this._getLayerRequestOptions({ signal: t3 }));
        r2.spatialReference && (e2.extent = { xmin: 0, ymin: 0, xmax: 0, ymax: 0, spatialReference: r2.spatialReference });
      } catch (r2) {
        a(r2);
      }
    return e2;
  }
  async _ensureLatestMetadata(e2) {
    if (this.layer.userHasUpdateItemPrivileges && this.sourceJSON.cacheMaxAge > 0)
      return this._fetchService(null, { ...e2, cacheBust: true });
  }
  async _uploadMeshesAndGetAssetMapEditsJSON(e2) {
    const { addAssetFeatures: t3 } = e2;
    if (!(t3 == null ? void 0 : t3.length))
      return null;
    const s3 = await this._filterRedundantAssetMaps(t3);
    if (!(t3 == null ? void 0 : t3.length))
      return null;
    const r2 = new Array(), a5 = /* @__PURE__ */ new Map();
    for (const i3 of s3) {
      const { geometry: e3 } = i3, { vertexSpace: t4 } = e3;
      if (g(t4))
        r2.push(e3);
      else {
        const t5 = a3(e3);
        a5.set(t5, e3), i3.geometry = t5, r2.push(t5);
      }
    }
    await this.uploadAssets(r2);
    for (const [i3, o3] of a5)
      o3.addExternalSources(i3.metadata.externalSources.items);
    return { adds: this._getAssetMapEditsJSON(s3), updates: [], deletes: [] };
  }
  _getAssetMapEditsJSON(e2) {
    const t3 = new Array(), s3 = this.layer.globalIdField, r2 = this.layer.parsedUrl;
    for (const a5 of e2) {
      const e3 = a5.geometry, { metadata: i3 } = e3, o3 = i3.getExternalSourcesOnService(r2), n3 = a5.getAttribute(s3);
      if (0 === o3.length) {
        n.getLogger(this).error(`Skipping feature ${n3}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);
        continue;
      }
      const { source: l } = o3.find(v) ?? o3[0];
      for (const s4 of l)
        1 === s4.parts.length ? t3.push({ globalId: r(), parentGlobalId: n3, assetName: s4.assetName, assetHash: s4.parts[0].partHash, flags: [] }) : n.getLogger(this).error(`Skipping asset ${s4.assetName}. It does not have exactly one part, so we cannot map it to a feature.`);
    }
    return t3;
  }
  _createEditsResult(e2) {
    const t3 = e2.data, { layerId: s3 } = this.layer, r2 = [];
    let a5 = null;
    if (Array.isArray(t3))
      for (const o3 of t3)
        r2.push({ id: o3.id, editedFeatures: o3.editedFeatures }), o3.id === s3 && (a5 = { addResults: o3.addResults ?? [], updateResults: o3.updateResults ?? [], deleteResults: o3.deleteResults ?? [], attachments: o3.attachments, editMoment: o3.editMoment });
    else
      a5 = t3;
    const i3 = b2(a5);
    if (r2.length > 0) {
      i3.editedFeatureResults = [];
      for (const e3 of r2) {
        const { editedFeatures: t4 } = e3, s4 = (t4 == null ? void 0 : t4.spatialReference) ? new f(t4.spatialReference) : null;
        i3.editedFeatureResults.push({ layerId: e3.id, editedFeatures: I(t4, s4) });
      }
    }
    return i3;
  }
  _createAttachmentErrorResult(e2, t3) {
    var _a;
    const s3 = ((_a = t3.details.messages) == null ? void 0 : _a[0]) || t3.message, r2 = t3.details.httpStatus || t3.details.messageCode;
    return { objectId: e2, globalId: null, error: new s("feature-layer-source:attachment-failure", s3, { code: r2 }) };
  }
  _getFormDataForAttachment(e2, t3) {
    const s3 = e2 instanceof FormData ? e2 : e2 && e2.elements ? new FormData(e2) : null;
    if (s3)
      for (const r2 in t3) {
        const e3 = t3[r2];
        null != e3 && (s3.set ? s3.set(r2, e3) : s3.append(r2, e3));
      }
    return s3;
  }
  _getLayerRequestOptions(e2 = {}) {
    const { parsedUrl: t3, gdbVersion: s3, dynamicDataSource: r2 } = this.layer;
    return { ...e2, query: { gdbVersion: s3, layer: r2 ? JSON.stringify({ source: r2 }) : void 0, ...t3.query, f: "json", ...this._createRequestQueryOptions(e2) }, responseType: "json" };
  }
  async _filterRedundantAssetMaps(e2) {
    const { layer: t3 } = this, { globalIdField: s3, infoFor3D: r2, parsedUrl: i3 } = t3;
    if (null == r2 || null == s3)
      return e2;
    const o3 = F(r2);
    if (null == o3)
      return e2;
    const n3 = V(i3.path, `../${o3.id}`), u = new Array(), l = new Array();
    for (const a5 of e2)
      a5.geometry.metadata.getExternalSourcesOnService(i3).length > 0 ? l.push(a5) : u.push(a5);
    const c3 = l.map((e3) => e3.getAttribute(s3)).filter(k);
    if (0 === c3.length)
      return e2;
    const { assetMapFieldRoles: { parentGlobalId: d, assetHash: p2 } } = r2, h2 = new b({ where: `${d} IN (${c3.map((e3) => `'${e3}'`)})`, outFields: [p2, d], returnGeometry: false }), m3 = await s2(n3, h2), { features: f2 } = m3;
    return 0 === f2.length ? e2 : [...u, ...l.filter((e3) => {
      const t4 = e3.getAttribute(s3);
      if (!t4)
        return true;
      const { metadata: r3 } = e3.geometry, a5 = f2.filter((e4) => e4.getAttribute(d) === t4);
      if (0 === a5.length)
        return true;
      const o4 = a5.map((e4) => e4.getAttribute(p2));
      return r3.getExternalSourcesOnService(i3).flatMap(({ source: e4 }) => e4.flatMap((e5) => e5.parts.map((e6) => e6.partHash))).some((e4) => o4.every((t5) => e4 !== t5));
    })];
  }
};
e([y()], $.prototype, "type", void 0), e([y({ constructOnly: true })], $.prototype, "layer", void 0), e([y({ constructOnly: true })], $.prototype, "supportedSourceTypes", void 0), e([y({ readOnly: true })], $.prototype, "queryTask", null), $ = e([a2("esri.layers.graphics.sources.FeatureLayerSource")], $);
var V2 = 1e3;
var G = $;

export {
  G
};
//# sourceMappingURL=chunk-CF4VCIGH.js.map
