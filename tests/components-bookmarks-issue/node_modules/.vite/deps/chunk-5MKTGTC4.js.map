{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/FoamRendering.glsl.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ScreenSpaceReflections.glsl.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/Water.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport{glsl as t}from\"../../shaderModules/interfaces.js\";function o(o){o.fragment.code.add(t`float normals2FoamIntensity(vec3 n, float waveStrength){\nfloat normalizationFactor =  max(0.015, waveStrength);\nreturn max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);\n}`)}function n(o){o.fragment.code.add(t`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){\nreturn foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;\n}`)}export{n as FoamColor,o as FoamIntensity};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport{ReadLinearDepth as e}from\"../output/ReadDepth.glsl.js\";import{Float2PassUniform as o}from\"../../shaderModules/Float2PassUniform.js\";import{FloatPassUniform as t}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as r}from\"../../shaderModules/interfaces.js\";import{Matrix4PassUniform as a}from\"../../shaderModules/Matrix4PassUniform.js\";import{Texture2DPassUniform as i}from\"../../shaderModules/Texture2DPassUniform.js\";function d(d,n){const c=d.fragment;c.include(e),c.uniforms.add(new o(\"nearFar\",((e,o)=>o.camera.nearFar))),c.uniforms.add(new i(\"depthMap\",((e,o)=>o.linearDepth?.getTexture()))),c.uniforms.add(new a(\"proj\",((e,o)=>o.camera.projectionMatrix))),c.uniforms.add(new t(\"invResolutionHeight\",((e,o)=>1/o.camera.height))),c.uniforms.add(new a(\"reprojectionMatrix\",((e,o)=>o.ssr.reprojectionMatrix))),c.code.add(r`\n  vec2 reprojectionCoordinate(vec3 projectionCoordinate)\n  {\n    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);\n    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);\n    reprojectedCoord.xy /= reprojectedCoord.w;\n    return reprojectedCoord.xy * 0.5 + 0.5;\n  }\n\n  const int maxSteps = ${n.highStepCount?\"150\":\"75\"};\n\n  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)\n  {\n    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);\n    projectedCoord.xy /= projectedCoord.w;\n    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;\n    return projectedCoord;\n  }\n\n  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)\n  {\n    vec3 viewPos = startPosition;\n    vec3 viewPosEnd = startPosition;\n\n    // Project the start position to the screen\n    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);\n    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space\n    float k0 = 1.0/ projectedCoordStart.w;\n\n    // advance the position in the direction of the reflection\n    viewPos += dir;\n\n    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);\n\n    // Project the advanced position to the screen\n    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);\n    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space\n    float k1 = 1.0/ projectedCoordEnd.w;\n\n    // calculate the reflection direction in the screen space\n    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);\n    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);\n\n    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);\n\n    float projectedCoordDirLength = length(projectedCoordDir);\n    float maxSt = float(maxSteps);\n\n    // normalize the projection direction depending on maximum steps\n    // this determines how blocky the reflection looks\n    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);\n\n    // Normalize the homogeneous camera space coordinates\n    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);\n    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);\n\n    // initialize the variables for ray marching\n    vec2 P = projectedCoordStart.xy;\n    vec3 Q = Q0;\n    float k = k0;\n    float rayStartZ = -startPosition.z; // estimated ray start depth value\n    float rayEndZ = -startPosition.z;   // estimated ray end depth value\n    float prevEstimateZ = -startPosition.z;\n    float rayDiffZ = 0.0;\n    float dDepth;\n    float depth;\n    float rayDiffZOld = 0.0;\n\n    // early outs\n    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)\n      return vec3(P, 0.0);\n\n    for(int i = 0; i < maxSteps-1; i++)\n    {\n      depth = -linearDepthFromTexture(depthMap, P, nearFar); // get linear depth from the depth buffer\n\n      // estimate depth of the marching ray\n      rayStartZ = prevEstimateZ;\n      dDepth = -rayStartZ - depth;\n      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));\n      rayDiffZ = rayEndZ- rayStartZ;\n      prevEstimateZ = rayEndZ;\n\n      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )\n      {\n        return vec3(P, 0.);\n      }\n\n      // If we detect a hit - return the intersection point, two conditions:\n      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth\n      //  - if difference between dDepth and rayDiffZOld is not too large\n      //  - if difference between dDepth and 0.025/abs(k) is not too large\n      //  - if the sampled depth is not behind far plane or in front of near plane\n\n      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)\n      {\n        return vec3(P, depth);\n      }\n\n      // continue with ray marching\n      P = clamp(P + dP, vec2(0.0), vec2(0.999));\n      Q.z += dQ.z;\n      k += dk;\n      rayDiffZOld = rayDiffZ;\n    }\n    return vec3(P, 0.0);\n  }\n  `)}export{d as ScreenSpaceReflections};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport{FoamColor as e}from\"./FoamRendering.glsl.js\";import{Gamma as o}from\"./Gamma.glsl.js\";import{PhysicallyBasedRenderingWater as r}from\"./PhysicallyBasedRendering.glsl.js\";import{distanceFadeStart as t,distanceFadeEnd as i}from\"./ScreenSpaceConstants.js\";import{ScreenSpaceReflections as a}from\"./ScreenSpaceReflections.glsl.js\";import{CloudsParallaxShading as l}from\"../util/CloudsParallaxShading.glsl.js\";import{FloatPassUniform as n}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as d}from\"../../shaderModules/interfaces.js\";import{Matrix4PassUniform as c}from\"../../shaderModules/Matrix4PassUniform.js\";import{Texture2DPassUniform as s}from\"../../shaderModules/Texture2DPassUniform.js\";function f(f,m){f.include(r,m),f.include(o),f.include(e),m.hasCloudsReflections&&f.include(l,m),m.hasScreenSpaceReflections&&f.include(a,m);const v=f.fragment;v.constants.add(\"fresnelSky\",\"vec3\",[.02,1,15]).add(\"fresnelMaterial\",\"vec2\",[.02,.1]).add(\"roughness\",\"float\",.015).add(\"foamIntensityExternal\",\"float\",1.7).add(\"ssrIntensity\",\"float\",.65).add(\"ssrHeightFadeStart\",\"float\",t).add(\"ssrHeightFadeEnd\",\"float\",i).add(\"waterDiffusion\",\"float\",.92).add(\"waterSeaColorMod\",\"float\",.8).add(\"correctionViewingPowerFactor\",\"float\",.4).add(\"skyZenitColor\",\"vec3\",[.52,.68,.9]).add(\"skyColor\",\"vec3\",[.67,.79,.9]).add(\"cloudFresnelModifier\",\"vec2\",[1.2,.01]),v.code.add(d`PBRShadingWater shadingInfo;\nvec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {\nfloat exponent = pow((1.0 - cosTheta), fresnelSky[2]);\nreturn mix(zenit, horizon, exponent);\n}`),v.uniforms.add(new n(\"lightingSpecularStrength\",((e,o)=>o.lighting.mainLight.specularStrength)),new n(\"lightingEnvironmentStrength\",((e,o)=>o.lighting.mainLight.environmentStrength))),v.code.add(d`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 viewPosition, vec3 position) {\nfloat reflectionHit = 0.0;\nfloat reflectionHitDiffused = 0.0;\nvec3 seaWaterColor = linearizeGamma(color);\nvec3 h = normalize(l + v);\nshadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);\nshadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);\nshadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);\nshadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\nshadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\nshadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\nfloat upDotV = max(dot(localUp,v), 0.0);\nvec3 skyHorizon = linearizeGamma(skyColor);\nvec3 skyZenit = linearizeGamma(skyZenitColor);\nvec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );\nfloat upDotL = max(dot(localUp,l),0.0);\nfloat daytimeMod = 0.1 + upDotL * 0.9;\nskyColor *= daytimeMod;\nfloat shadowModifier = clamp(shadow, 0.8, 1.0);\nvec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);\nvec3 reflSky = lightingEnvironmentStrength * fresnelModifier * skyColor * shadowModifier;\nvec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;\nvec3 specular = vec3(0.0);\nif(upDotV > 0.0 && upDotL > 0.0) {\nvec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);\nvec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;\nspecular = lightingSpecularStrength * shadingInfo.NdotL * incidentLight * specularSun;\n}\nvec3 foam = vec3(0.0);\nif(upDotV > 0.0) {\nfoam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);\n}\nfloat correctionViewingFactor = pow(max(dot(v, localUp), 0.0), correctionViewingPowerFactor);\nvec3 normalCorrectedClouds = mix(localUp, n, correctionViewingFactor);\nvec3 reflectedWorld = normalize(reflect(-v, normalCorrectedClouds));`),m.hasCloudsReflections&&v.code.add(d`vec4 cloudsColor = renderClouds(reflectedWorld, position);\ncloudsColor.a = 1.0 - cloudsColor.a;\ncloudsColor = pow(cloudsColor, vec4(GAMMA));\ncloudsColor *= clamp(fresnelModifier.y * cloudFresnelModifier[0] - cloudFresnelModifier[1], 0.0, 1.0) * clamp((1.0 - totalFadeInOut), 0.0, 1.0);`),m.hasScreenSpaceReflections?(v.uniforms.add(new c(\"view\",((e,o)=>o.camera.viewMatrix)),new s(\"lastFrameColorTexture\",((e,o)=>o.ssr.lastFrameColor?.getTexture())),new n(\"fadeFactorSSR\",((e,o)=>o.ssr.fadeFactor))),v.code.add(d`vec3 viewDir = normalize(viewPosition);\nvec4 viewNormalVectorCoordinate = view *vec4(n, 0.0);\nvec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);\nvec4 viewUp = view * vec4(localUp, 0.0);\nvec3 viewNormalCorrectedSSR = mix(viewUp.xyz, viewNormal, correctionViewingFactor);\nvec3 reflected = normalize(reflect(viewDir, viewNormalCorrectedSSR));\nvec3 hitCoordinate = screenSpaceIntersection(reflected, viewPosition, viewDir, viewUp.xyz);\nvec3 reflectedColor = vec3(0.0);\nif (hitCoordinate.z > 0.0)\n{\nvec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);\nvec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));\nfloat heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -viewPosition.z);\nreflectionHit = clamp(1.0 - (1.3 * dCoords.y), 0.0, 1.0) * heightMod * fadeFactorSSR;\nreflectionHitDiffused = waterDiffusion * reflectionHit;\nreflectedColor = linearizeGamma(texture(lastFrameColorTexture, reprojectedCoordinate).xyz) *\nreflectionHitDiffused * fresnelModifier.y * ssrIntensity;\n}\nfloat seaColorMod =  mix(waterSeaColorMod, waterSeaColorMod * 0.5, reflectionHitDiffused);\nvec3 waterRenderedColor = tonemapACES((1.0 - reflectionHitDiffused) * reflSky + reflectedColor +\nreflSea * seaColorMod + specular + foam);`)):v.code.add(d`vec3 waterRenderedColor = tonemapACES(reflSky + reflSea * waterSeaColorMod + specular + foam);`),m.hasCloudsReflections?m.hasScreenSpaceReflections?v.code.add(d`return waterRenderedColor * (1.0 - (1.0 - reflectionHit) * cloudsColor.a) + (1.0 - reflectionHit) * cloudsColor.xyz;\n}`):v.code.add(d`return waterRenderedColor * (1.0 - cloudsColor.a) + cloudsColor.xyz;\n}`):v.code.add(d`return waterRenderedColor;\n}`)}export{f as Water};\n"],
  "mappings": "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",
  "names": ["o", "d", "n", "e", "o", "f", "e", "v", "o"]
}
