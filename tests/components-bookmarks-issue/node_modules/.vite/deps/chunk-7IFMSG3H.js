import {
  A,
  b,
  j as j2,
  z
} from "./chunk-3FTSPLRV.js";
import {
  m,
  o as o2
} from "./chunk-PMQ5HDZI.js";
import {
  a,
  n as n4
} from "./chunk-YKIGDW5O.js";
import {
  L
} from "./chunk-3AIILHI5.js";
import {
  n as n2
} from "./chunk-D56W4LPT.js";
import {
  _,
  n as n3
} from "./chunk-ZLQTPFTL.js";
import {
  G as G2,
  o,
  r
} from "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";
import {
  G,
  j
} from "./chunk-UWQ3OYA5.js";

// node_modules/@arcgis/core/views/support/angularMeasurementUtils.js
var j3;
function R(e, r2) {
  if (null == e || null == r2)
    return;
  const i = b2(e, r2);
  return null != i ? o2(i, "radians", "geographic") : void 0;
}
!function(e) {
  e.Absolute = "absolute", e.Relative = "relative", e.RelativeBilateral = "relative-bilateral";
}(j3 || (j3 = {}));
var b2 = (() => {
  const e = n(), r2 = n();
  return (t, i) => (o(e, t.x, t.y, t.z ?? 0), o(r2, i.x, i.y, i.z ?? 0), y(e, r2, t.spatialReference, i.spatialReference));
})();
var y = (() => {
  const e = n3(), r2 = n(), t = n();
  return (i, a2, c, u) => {
    if (G2(i, a2))
      return;
    const m2 = A(c), v = A(u);
    if (m2 && v && G(m2, v) && n2(i, c, r2, m2) && n2(a2, u, t, v)) {
      const { azimuth: e2 } = j2(M, r2, t, m2);
      return null != e2 ? j(e2, "degrees", "radians") : void 0;
    }
    e[0] = a2[0] - i[0], e[1] = a2[1] - i[1];
    let d = L(_, e);
    return e[0] < 0 && (d = U - d), d;
  };
})();
function x(e, r2, t, i = j3.Absolute) {
  if (r2 && t)
    switch (i) {
      case j3.Absolute:
        return R(r2, t);
      case j3.Relative:
        return w(z2(e, r2, t), j3.Relative);
      case j3.RelativeBilateral:
        return w(z2(e, r2, t), j3.RelativeBilateral);
    }
}
function z2(e, r2, i) {
  if (!e || !r2 || !i)
    return;
  const o3 = b2(e, r2), n5 = b2(r2, i);
  return null != o3 && null != n5 ? o2(n5 - o3, "radians", "geographic") : void 0;
}
function w(e, r2) {
  if (null == e)
    return;
  const i = B(e);
  switch (r2) {
    case j3.Absolute: {
      const e2 = T.normalize(i, 0, true);
      return o2(e2, "degrees", "geographic");
    }
    case j3.Relative: {
      let e2 = V.normalize(i, 0, true);
      return -180 === e2 && (e2 = 180), o2(e2, "degrees", "geographic");
    }
    case j3.RelativeBilateral: {
      const e2 = Math.abs(V.normalize(i, 0, true));
      return o2(e2, "degrees", "geographic");
    }
  }
}
var A2 = (() => {
  const e = n();
  return (r2, t, n5, s, a2, l = "geodesic") => {
    r(e, t);
    const m2 = B(a2);
    if ("geodesic" === l) {
      const i = A(n5);
      if (i && n2(e, n5, e, i))
        return b(r2, e, m2, s, i), r2[2] = t[2], !!n2(r2, i, r2, n5);
    }
    const p = m(m2, "geographic", "arithmetic"), d = j(p, "degrees", "radians"), h = t[0] + s * Math.cos(d), j4 = t[1] + s * Math.sin(d), R2 = t[2];
    return o(r2, h, j4, R2), true;
  };
})();
function B(e) {
  return null != e ? m(j(e.value, e.unit, "degrees"), e.rotationType, "geographic") : void 0;
}
var M = new z();
var U = 2 * Math.PI;
var T = a;
var V = new n4(-180, 180);

export {
  j3 as j,
  R,
  y,
  x,
  w,
  A2 as A,
  B
};
//# sourceMappingURL=chunk-7IFMSG3H.js.map
