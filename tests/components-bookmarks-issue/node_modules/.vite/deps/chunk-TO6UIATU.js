import {
  a as a2,
  f,
  i as i2,
  l as l2,
  p as p4,
  s as s2
} from "./chunk-WCBCYPOZ.js";
import {
  b as b4,
  j as j4,
  z as z2
} from "./chunk-3FTSPLRV.js";
import {
  c
} from "./chunk-OMRW2J7M.js";
import {
  d as d3,
  j as j5
} from "./chunk-UXQH3C5A.js";
import {
  _ as _3
} from "./chunk-K3DEHPDR.js";
import {
  B,
  E as E3,
  T as T2,
  _ as _2,
  b as b3,
  d as d2,
  e as e5,
  j as j3,
  o as o3,
  p as p3,
  q as q2
} from "./chunk-3AIILHI5.js";
import {
  e as e4
} from "./chunk-BKOYOJBG.js";
import {
  D,
  E,
  T,
  W,
  Z as Z2
} from "./chunk-XMYPMIYH.js";
import {
  b
} from "./chunk-W5ALAOW2.js";
import {
  D as D2,
  E as E2,
  F as F2,
  J,
  R,
  V,
  b as b2,
  j as j2,
  w
} from "./chunk-Z2F5OKVA.js";
import {
  p as p2
} from "./chunk-UQA6M3KF.js";
import {
  a,
  n as n4,
  r as r3
} from "./chunk-ZLQTPFTL.js";
import {
  n as n3
} from "./chunk-AKEHDP75.js";
import {
  j,
  s
} from "./chunk-5MMGIT64.js";
import {
  n
} from "./chunk-VEODBKUJ.js";
import {
  e as e3
} from "./chunk-6AQIVLDN.js";
import {
  g
} from "./chunk-6CWL7BCV.js";
import {
  i
} from "./chunk-WNNYD62G.js";
import {
  F,
  l
} from "./chunk-OCF7OAES.js";
import {
  G,
  H,
  K,
  P,
  Z,
  _,
  e as e2,
  o as o2,
  p,
  q,
  r as r2,
  v,
  x,
  z
} from "./chunk-JZBR4X6W.js";
import {
  n as n2,
  r,
  t,
  y
} from "./chunk-OIJCMME5.js";
import {
  e
} from "./chunk-4KLYOMH2.js";
import {
  A,
  d
} from "./chunk-Z4Y53NDM.js";
import {
  o4 as o
} from "./chunk-NDIXNREV.js";
import {
  h,
  k
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/interactive/snapping/snappingUtils.js
function d4(e6, t2) {
  const n5 = e6.x - t2.x, r4 = e6.y - t2.y;
  return n5 * n5 + r4 * r4;
}
function g2(e6, t2) {
  return Math.sqrt(d4(e6, t2));
}
function f2(e6, t2) {
  t2.sort((t3, n5) => p(t3.targetPoint, e6) - p(n5.targetPoint, e6));
}
var E4;
function y2({ point: e6, distance: t2, returnEdge: n5, vertexMode: i3, coordinateHelper: { spatialReference: l3 }, filter: c2 }, p5, u) {
  return u = null != u ? u.clone() : new b({ where: "1=1" }), c2 && (u.geometry = c2.geometry, u.distance = c2.distance, u.spatialRelationship = c2.spatialRelationship, u.where = n(u.where, c2.where), u.timeExtent = g(u.timeExtent, c2.timeExtent), u.objectIds = h2(u.objectIds, c2.objectIds)), { point: e4(e6[0], e6[1], e6[2], l3.toJSON()), mode: p5, distance: t2, returnEdge: n5, vertexMode: i3, query: u.toJSON() };
}
function h2(e6, t2) {
  return e6 || t2 ? t2 ? e6 ? Array.from(o(new Set(e6), new Set(t2))) : t2 : e6 : null;
}
function w2(e6, t2, n5) {
  return { left: p4(e6.leftVertex.pos, t2, n5), right: p4(e6.rightVertex.pos, t2, n5) };
}
function j6(e6) {
  return e6.createQuery();
}
!function(e6) {
  e6[e6.TARGET = 0] = "TARGET", e6[e6.REFERENCE = 1] = "REFERENCE", e6[e6.REFERENCE_EXTENSION = 2] = "REFERENCE_EXTENSION";
}(E4 || (E4 = {}));
var R2 = Symbol("snapping-toggle");
function N(n5, r4 = () => {
}) {
  const o4 = d(() => ({ view: n5.view, snappingOptions: n5.snappingOptions }), ({ view: e6, snappingOptions: t2 }) => {
    if (n5.removeHandles(R2), !e6 || !t2)
      return;
    const o5 = _3.TOOL, i3 = [e6.on("key-down", (e7) => {
      e7.key !== c.toggle || e7.repeat || (t2.enabledToggled = true, r4());
    }, o5), e6.on("key-up", (e7) => {
      e7.key === c.toggle && (t2.enabledToggled = false, r4());
    }, o5), e6.on("pointer-move", (e7) => {
      const n6 = e7.native.ctrlKey;
      t2.enabledToggled !== n6 && (t2.enabledToggled = n6, r4());
    }, o5)];
    n5.addHandles(i3, R2);
  }, A);
  n5.addHandles(o4);
}
function v2(e6) {
  var _a;
  return e3(e6) && "utilityNetworks" in e6 && !!((_a = e6.utilityNetworks) == null ? void 0 : _a.length);
}

// node_modules/@arcgis/core/views/support/geometry3dUtils.js
function k2({ start: t2, end: o4, type: c2 }, i3, u) {
  const a3 = [], f3 = e5(et, o4, t2), m2 = e5(ot, t2, i3), L = p3(f3), h3 = 2 * j3(f3, m2), A2 = h3 * h3 - 4 * L * (p3(m2) - u * u);
  if (0 === A2) {
    const n5 = -h3 / (2 * L);
    (c2 === rt.PLANE || n5 >= 0) && a3.push(d2(n4(), t2, f3, n5));
  } else if (A2 > 0) {
    const n5 = Math.sqrt(A2), r4 = (-h3 + n5) / (2 * L);
    (c2 === rt.PLANE || r4 >= 0) && a3.push(d2(n4(), t2, f3, r4));
    const s3 = (-h3 - n5) / (2 * L);
    (c2 === rt.PLANE || s3 >= 0) && a3.push(d2(n4(), t2, f3, s3));
  }
  return a3;
}
function U(t2, r4) {
  const e6 = t2.start, c2 = t2.end, i3 = e5(et, c2, e6), u = o2(it, -i3[1], i3[0], 0), a3 = r4.start, f3 = r4.end, p5 = K(ut, f3, a3), m2 = P(p5, u), L = o2(at, e6[0], e6[1], 0), E5 = K(ft, L, a3), N2 = P(E5, u), y3 = e();
  if (Math.abs(m2) < y3)
    return Math.abs(N2), [];
  const P2 = q(pt, a3, p5, N2 / m2);
  if (r4.type === j5.RAY) {
    const t3 = K(mt, P2, a3);
    if (P(t3, p5) < -y3)
      return [];
  }
  if (t2.type === rt.HALF_PLANE) {
    const t3 = B(ot, P2, e6);
    if (j3(t3, i3) < -y3)
      return [];
  }
  return [t(P2)];
}
function w3(t2, n5) {
  return T3(X(ht, n5[2], t2), n5);
}
function z3(t2, n5) {
  const r4 = 0;
  return S(X(ht, r4, t2), X(At, r4, n5)).map(([t3, n6]) => r3(t3, n6));
}
function C(t2, n5) {
  return J2(t2, X(ht, t2[2], n5));
}
function D3(t2, r4, s3) {
  const o4 = e5(et, t2, r4), i3 = q2(o4), u = 0 === i3 ? 1 : s3 / i3, a3 = n2();
  return d2(a3, r4, o4, u), a3[2] = t2[2], a3;
}
function J2(t2, { start: n5, end: r4, type: s3 }, e6 = n2()) {
  const o4 = K(ct, t2, n5), c2 = K(it, r4, n5), i3 = P(o4, c2) / P(c2, c2);
  return q(e6, n5, c2, s3 === j5.RAY ? Math.max(i3, 0) : i3);
}
var O = (() => {
  const t2 = n2(), n5 = n2(), r4 = n2();
  return ({ start: s3, end: e6 }, { center: o4, radius: c2, normal: i3, slicePlane: u }) => {
    const a3 = j2(o4, i3, Lt);
    if ($(R(a3, s3), 0) && $(R(a3, e6), 0)) {
      p2(i3, t2, n5);
      const a4 = (s4, e7) => (e2(r4, e7, o4), o3(s4, P(r4, t2), P(r4, n5)), s4), p6 = d3({ start: a4(et, s3), end: a4(ot, e6), type: j5.LINE }, a, c2), m2 = [];
      for (const [r5, s4] of p6) {
        const e7 = r2(n2(), o4);
        q(e7, e7, t2, r5), q(e7, e7, n5, s4), u && !nt(u, e7) || m2.push(e7);
      }
      return m2;
    }
    const p5 = n2();
    return w(a3, s3, e6, p5) ? !$(x(p5, o4), c2) || u && !nt(u, p5) ? [] : [p5] : [];
  };
})();
function Q({ start: t2, end: e6, type: o4 }, c2, i3) {
  const u = [], a3 = e2(ct, e6, t2), f3 = e5(ot, t2, c2), p5 = p3(a3), m2 = 2 * j3(a3, f3), L = m2 * m2 - 4 * p5 * (p3(f3) - i3 * i3);
  if (0 === L) {
    const n5 = -m2 / (2 * p5);
    (o4 === j5.LINE || n5 >= 0) && u.push(q(n2(), t2, a3, n5));
  } else if (L > 0) {
    const n5 = Math.sqrt(L), r4 = (-m2 + n5) / (2 * p5);
    (o4 === j5.LINE || r4 >= 0) && u.push(q(n2(), t2, a3, r4));
    const s3 = (-m2 - n5) / (2 * p5);
    (o4 === j5.LINE || s3 >= 0) && u.push(q(n2(), t2, a3, s3));
  }
  return u;
}
function S(t2, n5) {
  const r4 = t2.start, s3 = t2.end, e6 = n5.start, o4 = n5.end, c2 = K(ct, s3, r4), i3 = K(it, o4, e6), u = K(ut, e6, r4), a3 = _(at, c2, i3);
  if (!$(P(u, a3), 0))
    return [];
  const f3 = Z(a3);
  if ($(f3, 0))
    return [];
  const p5 = _(ft, u, i3), m2 = P(p5, a3) / f3, L = q(pt, r4, c2, m2);
  if (t2.type === j5.RAY) {
    const t3 = K(mt, L, r4);
    if (P(c2, t3) < -e())
      return [];
  }
  if (n5.type === j5.RAY) {
    const t3 = K(mt, L, e6);
    if (P(i3, t3) < -e())
      return [];
  }
  return [t(L)];
}
function T3({ start: t2, end: n5, type: r4 }, s3) {
  const e6 = K(ct, s3, t2), o4 = K(it, n5, t2), c2 = _(ut, o4, e6), i3 = Z(c2) / Z(o4), u = e();
  if (i3 < u)
    switch (r4) {
      case j5.LINE:
        return [t(s3)];
      case j5.RAY:
        return P(o4, e6) < -u ? [] : [t(s3)];
    }
  return [];
}
function W2(t2, n5, r4, s3) {
  const [e6, o4] = t2, [c2, i3] = r4, u = c2 - e6, f3 = i3 - o4, p5 = u * u + f3 * f3, L = Math.sqrt(p5);
  if (L > n5 + s3)
    return [];
  if (L < Math.abs(n5 - s3))
    return [];
  if ($(L, 0) && $(n5, s3))
    return [];
  const h3 = (n5 * n5 - s3 * s3 + p5) / (2 * L), A2 = Math.sqrt(n5 * n5 - h3 * h3), d5 = A2 * f3 / L, l3 = A2 * u / L, [E5, N2] = _2(et, t2, r4, h3 / L);
  return $(d5, l3) ? [r3(E5, N2)] : [r3(E5 + d5, N2 - l3), r3(E5 - d5, N2 + l3)];
}
function X(t2, n5, { start: r4, end: s3, type: e6 }) {
  return o2(t2.start, r4[0], r4[1], n5), o2(t2.end, s3[0], s3[1], n5), t2.type = st[e6], t2;
}
function Z3(t2, n5) {
  return $(t2[2], n5[2]);
}
function $(n5, r4) {
  return F(Math.abs(n5 - r4), 0, e());
}
function tt(t2, n5) {
  return n5.filter((n6) => nt(t2, n6));
}
function nt(t2, n5) {
  return D2(t2, n5);
}
var rt;
!function(t2) {
  t2[t2.PLANE = 0] = "PLANE", t2[t2.HALF_PLANE = 1] = "HALF_PLANE";
}(rt || (rt = {}));
var st = { [rt.PLANE]: j5.LINE, [rt.HALF_PLANE]: j5.RAY };
var et = n4();
var ot = n4();
var ct = n2();
var it = n2();
var ut = n2();
var at = n2();
var ft = n2();
var pt = n2();
var mt = n2();
var Lt = E2();
var ht = { start: n2(), end: n2(), type: j5.LINE };
var At = { start: n2(), end: n2(), type: j5.LINE };

// node_modules/@arcgis/core/views/interactive/sketch/constraints.js
var mt2 = class {
  intersect(t2) {
    return Ht(this, t2);
  }
  closestPoints(t2) {
    return [this.closestTo(t2)];
  }
};
var gt = class extends mt2 {
  constructor(t2) {
    super(), this.point = t2;
  }
  equals(t2) {
    return this === t2 || Le(t2) && G(this.point, t2.point);
  }
  closestTo() {
    return a2(this.point);
  }
};
var _t = class extends mt2 {
  constructor(t2, e6, s3) {
    super(), this.start = t2, this.end = e6, this.lineLike = { start: t2, end: e6, type: s3 };
  }
  equals(t2) {
    return this === t2 || ke(t2) && this.lineLike.type === t2.lineLike.type && G(this.start, t2.start) && G(this.end, t2.end);
  }
  closestTo(t2) {
    const e6 = J2(t2, this.lineLike);
    return l2(e6);
  }
};
var Lt2 = class extends _t {
  constructor(t2, e6) {
    super(t2, e6, j5.LINE);
  }
};
var kt = class extends _t {
  constructor(t2, e6) {
    super(t2, e6, j5.RAY);
  }
};
var Mt = class extends mt2 {
  constructor(t2) {
    super(), this.constraints = t2;
  }
  equals(t2) {
    return this === t2 || _e(t2) && h(this.constraints, t2.constraints, (t3, e6) => t3.equals(e6));
  }
  closestTo(t2) {
    let e6, s3 = 1 / 0;
    for (const r4 of this.constraints) {
      const n5 = r4.closestTo(t2), i3 = p(t2, n5);
      i3 < s3 && (s3 = i3, e6 = n5);
    }
    return e6 ? a2(e6) : t2;
  }
  closestPoints(t2) {
    return this.constraints.flatMap((e6) => e6 === this ? [] : e6.closestPoints(t2));
  }
};
var xt = class extends mt2 {
  constructor(t2, e6) {
    super(), this.center = t2, this.radius = e6;
  }
  equals(t2) {
    return this === t2 || ye(t2) && this.center[0] === t2.center[0] && this.center[1] === t2.center[1] && this.radius === t2.radius;
  }
  closestTo(t2) {
    const e6 = D3(t2, this.center, this.radius);
    return l2(e6);
  }
};
var yt = class extends mt2 {
  constructor(t2, e6) {
    super(), this.center = t2, this.radius = e6;
  }
  equals(t2) {
    return this === t2 || Pe(t2) && G(this.center, t2.center) && this.radius === t2.radius;
  }
  closestTo(t2) {
    const e6 = D3(t2, this.center, this.radius);
    return e6[2] = this.center[2], l2(e6);
  }
  asCircle() {
    return new Pt(a2(this.center), this.radius, s2(0, 0, 1));
  }
};
var Pt = class extends mt2 {
  constructor(t2, e6, s3, r4 = void 0) {
    super(), this.center = t2, this.radius = e6, this.normal = s3, this.slicePlane = r4;
  }
  equals(t2) {
    return this === t2 || ze(t2) && G(this.center, t2.center) && G(this.normal, t2.normal) && this.radius === t2.radius;
  }
  closestTo(t2) {
    const { center: e6, radius: s3 } = this;
    J(this.getPlane(vt), t2, zt);
    const r4 = K(zt, zt, e6), n5 = v(r4);
    if ($(n5, 0))
      return a2(t2);
    const i3 = s3 / Math.sqrt(n5), o4 = q(n2(), e6, r4, i3), { slicePlane: c2 } = this;
    if (c2 && !nt(c2, o4)) {
      const e7 = Jt(c2, this);
      return (e7 == null ? void 0 : e7.closestTo(t2)) ?? a2(t2);
    }
    return l2(o4);
  }
  getPlane(t2 = E2()) {
    return j2(this.center, this.normal, t2);
  }
};
var zt = n2();
var vt = E2();
var Tt = class extends mt2 {
  constructor(t2) {
    super(), this.z = t2;
  }
  equals(t2) {
    return this === t2 || Me(t2) && this.z === t2.z;
  }
  closestTo(t2) {
    return l2(r(t2[0], t2[1], this.z));
  }
  getPlane(t2 = E2()) {
    return o2(qt, 0, 0, this.z), j2(qt, y, t2);
  }
};
var qt = n2();
var wt = class extends mt2 {
  constructor(t2, e6, s3) {
    super(), this.start = t2, this.end = e6, this.planeLike = { start: f(t2), end: f(e6), type: s3 };
  }
  equals(t2) {
    return this === t2 || xe(t2) && this.planeLike.type === t2.planeLike.type && G(this.start, t2.start) && G(this.end, t2.end);
  }
  closestTo(t2) {
    return l2(C(t2, this.planeLike));
  }
  closestEndTo(t2) {
    const { start: e6, end: s3 } = this.planeLike;
    return Math.sign(j3(e5(jt, s3, e6), e5(At2, f(t2), e6))) > 0 ? this.end : this.start;
  }
  getPlane(t2 = E2()) {
    const e6 = r2(Dt, this.end);
    return e6[2] += 1, b2(this.start, this.end, e6, t2);
  }
  getSlicePlane(t2 = E2()) {
    const { start: e6, end: s3, type: r4 } = this.planeLike;
    if (r4 === rt.PLANE)
      return;
    const n5 = o2(Dt, e6[0], e6[1], 0), i3 = o2(bt, s3[0], s3[1], 0), o4 = e2(bt, i3, n5);
    return j2(n5, o4, t2), t2;
  }
};
var jt = n4();
var At2 = n4();
var Dt = n2();
var bt = n2();
var Et = class extends wt {
  constructor(t2, e6) {
    super(t2, e6, rt.HALF_PLANE);
  }
};
var Rt = class extends wt {
  constructor(t2, e6) {
    super(t2, e6, rt.PLANE);
  }
};
var Nt = class extends mt2 {
  constructor(t2, e6) {
    super(), this.sphere = T(t2, e6);
  }
  equals(t2) {
    return this === t2 || ve(t2) && E(this.sphere, t2.sphere);
  }
  closestTo(t2) {
    const e6 = W(this.sphere, t2, n2());
    return l2(e6);
  }
  get center() {
    return Z2(this.sphere);
  }
  get radius() {
    return this.sphere[3];
  }
};
var Ut = class extends mt2 {
  constructor(t2, e6, s3) {
    super(), this.start = t2, this.end = e6, this.getZ = s3, this.planeLike = { start: f(t2), end: f(e6), type: rt.PLANE };
  }
  equals(t2) {
    return this === t2 || Te(t2) && G(this.start, t2.start) && G(this.end, t2.end) && this.getZ === t2.getZ;
  }
  closestTo(t2) {
    return Ft(this, t2);
  }
  addIfOnTheGround(t2, e6) {
    for (const s3 of e6) {
      const e7 = this.getZ(s3[0], s3[1]) ?? 0;
      $(s3[2], e7) && (s3[2] = e7, t2.push(s3));
    }
  }
};
var Zt = class extends mt2 {
  constructor(t2, e6, s3) {
    super(), this._x = t2, this._y = e6, this._z = s3;
  }
  equals(t2) {
    return this === t2 || we(t2) && this._x === t2._x && this._y === t2._y && this._z === t2._z;
  }
  closestTo([t2, e6, s3]) {
    return i2(this._x ?? t2, this._y ?? e6, this._z ?? s3);
  }
};
var It = class extends mt2 {
  constructor(t2, e6, s3, r4, n5) {
    super(), this._origin = t2, this._spatialReference = e6, this._distanceMeters = s3, this._elevationMeters = r4, this._directionDegrees = n5;
  }
  equals(t2) {
    return this === t2 || qe(t2) && E3(this._origin, t2._origin) && this._spatialReference === t2._spatialReference && this._distanceMeters === t2._distanceMeters && this._elevationMeters === t2._elevationMeters && this._directionDegrees === t2._directionDegrees;
  }
  closestTo([t2, e6, s3]) {
    return o3(Gt, t2, e6), T2(Gt, this._origin) || this._applyDirectionAndDistance(Gt), i2(Gt[0], Gt[1], this._elevationMeters ?? s3);
  }
  _applyDirectionAndDistance(t2) {
    if (null != this._directionDegrees && null != this._distanceMeters)
      b4(t2, this._origin, this._directionDegrees, this._distanceMeters, this._spatialReference);
    else if (null != this._directionDegrees)
      Ct(t2, this._origin, this._directionDegrees, t2, this._spatialReference);
    else if (null != this._distanceMeters) {
      const { azimuth: e6 } = j4(St, this._origin, t2, this._spatialReference);
      b4(t2, this._origin, e6 ?? 0, this._distanceMeters, this._spatialReference);
    }
  }
};
var Gt = [0, 0];
var St = new z2();
function Ct(t2, e6, s3, r4, n5) {
  let { azimuth: i3, distance: o4 } = j4(Ot, e6, r4, n5);
  i3 ?? (i3 = 0);
  let c2 = o4 * Math.cos((i3 - s3) * i);
  c2 = Math.max(0, c2), b4(t2, e6, s3, c2, n5);
}
var Ot = new z2();
function Ft(t2, e6) {
  const s3 = C(e6, t2.planeLike);
  return s3[2] = t2.getZ(s3[0], s3[1]) ?? je, l2(s3);
}
function Ht(t2, e6) {
  if (_e(t2)) {
    const s3 = [];
    for (const r4 of t2.constraints) {
      const t3 = r4.intersect(e6);
      t3 && s3.push(t3);
    }
    return ge(s3);
  }
  if (_e(e6))
    return Ht(e6, t2);
  if (Te(t2))
    return fe(t2, e6);
  if (Te(e6))
    return fe(e6, t2);
  if (Le(t2)) {
    const { point: s3 } = t2;
    if (Le(e6))
      return G(s3, e6.point) ? t2 : void 0;
    const r4 = e6.closestTo(s3);
    return H(r4, s3) ? t2 : void 0;
  }
  if (ke(t2)) {
    if (Le(e6))
      return Ht(e6, t2);
    if (ke(e6))
      return pe(S(t2.lineLike, e6.lineLike));
    if (Me(e6))
      return Vt(t2, e6);
    if (xe(e6))
      return pe(U(e6.planeLike, t2.lineLike));
    if (ye(e6))
      return pe(Q(t2.lineLike, e6.center, e6.radius));
    if (ze(e6))
      return pe(O(t2.lineLike, e6));
    if (Pe(e6))
      return Yt(t2, e6);
    if (ve(e6))
      return Bt(t2, e6);
  } else if (Me(t2)) {
    if (Le(e6) || ke(e6))
      return Ht(e6, t2);
    if (Me(e6))
      return Kt(t2, e6);
    if (xe(e6))
      return Qt(t2, e6);
    if (ye(e6))
      return Wt(t2, e6);
    if (ze(e6))
      return $t(t2, e6);
    if (Pe(e6))
      return Xt(t2, e6);
    if (ve(e6))
      return te(t2, e6);
  } else if (xe(t2)) {
    if (Le(e6) || ke(e6) || Me(e6))
      return Ht(e6, t2);
    if (xe(e6))
      return de(z3(t2.planeLike, e6.planeLike));
    if (ye(e6))
      return de(k2(t2.planeLike, e6.center, e6.radius));
    if (ze(e6))
      return se(t2, e6);
    if (Pe(e6))
      return ee(t2, e6);
    if (ve(e6))
      return re(t2, e6);
  } else if (ye(t2)) {
    if (Le(e6) || ke(e6) || Me(e6) || xe(e6))
      return Ht(e6, t2);
    if (ye(e6))
      return de(W2(f(t2.center), t2.radius, f(e6.center), e6.radius));
    if (ze(e6))
      return ne();
    if (Pe(e6))
      return ie(t2, e6);
    if (ve(e6))
      return oe();
  } else if (ze(t2)) {
    if (Le(e6) || ke(e6) || Me(e6) || xe(e6) || ye(e6))
      return Ht(e6, t2);
    if (ze(e6))
      return ce();
    if (Pe(e6))
      return ce(e6.asCircle());
    if (ve(e6))
      return ue();
  } else if (Pe(t2)) {
    if (Le(e6) || ke(e6) || Me(e6) || xe(e6) || ye(e6) || ze(e6))
      return Ht(e6, t2);
    if (Pe(e6))
      return ae(e6, t2);
    if (ve(e6))
      return he();
  } else if (ve(t2)) {
    if (Le(e6) || ke(e6) || Me(e6) || xe(e6) || ye(e6) || Pe(e6))
      return Ht(e6, t2);
    if (ve(e6))
      return le();
  }
}
var Vt = (() => {
  const t2 = E2();
  return (e6, s3) => {
    const { start: r4, end: n5 } = e6;
    if (Z3(r4, n5) && $(r4[2], s3.z))
      return e6;
    const i3 = n2();
    return w(s3.getPlane(t2), r4, n5, i3) ? new gt(l2(i3)) : void 0;
  };
})();
function Yt({ lineLike: t2 }, { center: e6, radius: s3 }) {
  const r4 = e6[2];
  return pe(Q(t2, e6, s3).filter((t3) => $(t3[2], r4)));
}
function Bt({ lineLike: t2 }, { sphere: e6 }) {
  return pe(D(e6, t2.start, t2.end));
}
var Jt = (() => {
  const t2 = n3(), e6 = n2(), r4 = n2();
  return (n5, i3, o4) => {
    const { normal: c2, center: u, radius: a3 } = i3;
    p2(c2, e6, r4);
    const l3 = F2(n5), f3 = a3 * P(l3, e6), d5 = a3 * P(l3, r4);
    s(t2, u[0], u[1], u[2], 1);
    const p5 = j(n5, t2), m2 = Math.hypot(f3, d5), g3 = $(m2, 0);
    if ($(R(n5, u), 0)) {
      if (g3)
        return i3;
      if ($(a3, 0))
        return !o4 || nt(o4, u) ? new gt(a2(u)) : void 0;
      _(e6, l3, c2), z(e6, e6);
      const t3 = new Array(), s3 = t(u);
      q(s3, s3, e6, a3), o4 && !nt(o4, s3) || t3.push(s3);
      const r5 = t(u);
      return q(r5, r5, e6, -a3), o4 && !nt(o4, r5) || t3.push(r5), pe(t3);
    }
    if (g3)
      return;
    const _4 = -p5 / m2;
    if (Math.abs(_4) > 1 || $(_4, 1))
      return;
    const L = Math.atan(f3 / d5), z4 = l(_4) - L, v3 = Math.PI - z4, w4 = new Array(), j7 = n2();
    q(j7, u, e6, a3 * Math.cos(z4)), q(j7, j7, r4, a3 * Math.sin(z4)), w4.push(j7);
    const A2 = n2();
    return q(A2, u, e6, a3 * Math.cos(v3)), q(A2, A2, r4, a3 * Math.sin(v3)), w4.push(A2), pe(o4 ? tt(o4, w4) : w4);
  };
})();
function Kt(t2, e6) {
  return $(t2.z, e6.z) ? t2 : void 0;
}
function Qt({ z: t2 }, { planeLike: e6 }) {
  const [s3, r4] = e6.start, [n5, i3] = e6.end, o4 = s2(s3, r4, t2), c2 = s2(n5, i3, t2);
  return e6.type === rt.PLANE ? new Lt2(o4, c2) : new kt(o4, c2);
}
function Wt(t2, e6) {
  const [s3, r4] = e6.center;
  return new yt(s2(s3, r4, t2.z), e6.radius);
}
function Xt(t2, e6) {
  return $(e6.center[2], t2.z) ? e6 : void 0;
}
var $t = (() => {
  const t2 = E2();
  return (e6, s3) => Jt(e6.getPlane(t2), s3, s3.slicePlane);
})();
function te(t2, { center: e6, radius: s3 }) {
  const r4 = Math.abs(e6[2] - t2.z);
  if (r4 > s3 && !$(r4, s3))
    return;
  const n5 = s2(e6[0], e6[1], t2.z), i3 = Math.sqrt(s3 ** 2 - r4 ** 2);
  return $(i3, 0) ? void 0 : new yt(n5, i3);
}
var ee = (() => {
  const t2 = E2();
  return (e6, { center: s3, radius: r4 }) => {
    const n5 = k2(e6.planeLike, s3, r4), i3 = s3[2];
    e6.getSlicePlane(t2);
    const o4 = new Array();
    for (const [c2, u] of n5) {
      const e7 = [c2, u, i3];
      nt(t2, e7) && o4.push(e7);
    }
    return pe(o4);
  };
})();
var se = (() => {
  const t2 = E2(), e6 = E2();
  return (s3, r4) => Jt(s3.getPlane(t2), r4, s3.getSlicePlane(e6));
})();
var re = (() => {
  const t2 = E2();
  return (e6, { center: s3, radius: r4 }) => {
    const n5 = e6.getPlane(t2), i3 = V(n5, s3), o4 = Math.abs(i3);
    if (o4 > r4 && !$(o4, r4))
      return;
    const c2 = t(F2(n5)), u = q(n2(), s3, c2, i3), a3 = Math.sqrt(r4 ** 2 - i3 ** 2);
    return $(a3, 0) ? new gt(l2(J(n5, s3, n2()))) : new Pt(l2(u), a3, c2, e6.getSlicePlane());
  };
})();
function ne(t2, e6) {
}
function ie(t2, e6) {
  const s3 = b3(f(t2.center), f(e6.center));
  if ($(s3, 0) && $(t2.radius, e6.radius))
    return e6;
  return me(W2(f(t2.center), t2.radius, f(e6.center), e6.radius), e6.center[2]);
}
function oe(t2, e6) {
}
function ce(t2, e6) {
}
function ue(t2, e6) {
}
function ae(t2, e6) {
  if (!Z3(t2.center, e6.center))
    return;
  const s3 = b3(f(t2.center), f(e6.center));
  if ($(s3, 0) && $(t2.radius, e6.radius))
    return t2;
  return me(W2(f(t2.center), t2.radius, f(e6.center), e6.radius), t2.center[2]);
}
function he(t2, e6) {
}
function le(t2, e6) {
}
function fe(t2, e6) {
  const { planeLike: s3, getZ: r4 } = t2, n5 = new Array();
  if (Le(e6))
    t2.addIfOnTheGround(n5, w3(s3, e6.point));
  else if (ke(e6))
    t2.addIfOnTheGround(n5, U(s3, e6.lineLike));
  else if (ye(e6))
    for (const [i3, o4] of k2(s3, e6.center, e6.radius)) {
      const t3 = r4(i3, o4);
      null != t3 && n5.push(r(i3, o4, t3));
    }
  else if (xe(e6) || Te(e6))
    for (const [i3, o4] of z3(s3, e6.planeLike)) {
      const t3 = r4(i3, o4) ?? je;
      n5.push(r(i3, o4, t3));
    }
  return pe(n5);
}
function de(t2) {
  return ge(t2.map(([t3, e6]) => {
    const s3 = s2(t3, e6, 0), r4 = s2(t3, e6, 1);
    return new Lt2(s3, r4);
  }));
}
function pe(t2) {
  return ge(t2.map((t3) => t3 ? new gt(l2(t3)) : void 0));
}
function me(t2, e6) {
  return pe(t2.map(([t3, s3]) => [t3, s3, e6]));
}
function ge(e6) {
  if (0 !== e6.length)
    return 1 === e6.length ? e6[0] ?? void 0 : new Mt(e6.filter(k));
}
function _e(t2) {
  return t2 instanceof Mt;
}
function Le(t2) {
  return t2 instanceof gt;
}
function ke(t2) {
  return t2 instanceof _t;
}
function Me(t2) {
  return t2 instanceof Tt;
}
function xe(t2) {
  return t2 instanceof wt;
}
function ye(t2) {
  return t2 instanceof xt;
}
function Pe(t2) {
  return t2 instanceof yt;
}
function ze(t2) {
  return t2 instanceof Pt;
}
function ve(t2) {
  return t2 instanceof Nt;
}
function Te(t2) {
  return t2 instanceof Ut;
}
function qe(t2) {
  return t2 instanceof It;
}
function we(t2) {
  return t2 instanceof Zt;
}
var je = 0;

export {
  d4 as d,
  g2 as g,
  f2 as f,
  E4 as E,
  y2 as y,
  w2 as w,
  j6 as j,
  N,
  v2 as v,
  J2 as J,
  gt,
  Lt2 as Lt,
  xt,
  Tt,
  Et,
  Rt,
  Ut,
  Zt,
  It,
  ge,
  Le
};
//# sourceMappingURL=chunk-TO6UIATU.js.map
