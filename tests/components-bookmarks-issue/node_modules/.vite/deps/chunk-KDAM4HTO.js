import {
  N,
  Z
} from "./chunk-RK2U53CD.js";
import {
  Ge,
  be,
  je
} from "./chunk-X7VSXJWW.js";
import {
  i
} from "./chunk-AG6JXA4M.js";
import {
  O
} from "./chunk-HLDUDRTD.js";
import {
  o,
  u
} from "./chunk-C62RZQQX.js";
import {
  E,
  g,
  j
} from "./chunk-QLL2YG25.js";
import {
  n2 as n,
  r2 as r
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/widgets/Feature/support/featureUtils.js
var m = "esri.widgets.Feature.support.featureUtils";
var y = () => n.getLogger(m);
var g2 = /href=(""|'')/gi;
var I = /(\{([^\{\r\n]+)\})/g;
var h = /\'/g;
var b = /^\s*expression\//i;
var T = /(\n)/gi;
var w = /[\u00A0-\u9999<>\&]/gim;
var F = /href\s*=\s*(?:\"([^\"]+)\"|\'([^\']+)\')/gi;
var N2 = /^(?:mailto:|tel:)/;
var j2 = "relationships/";
var Z2 = E("short-date-short-time");
function E2(e) {
  if (null != e)
    return (e.sourceLayer || e.layer) ?? void 0;
}
async function v({ type: e, value: t, event: n2 }) {
  try {
    return "function" == typeof t ? t(n2) : t;
  } catch (r2) {
    return void y().error("error", `An error occurred when calling the "${e}" function`, { error: r2, graphic: n2.graphic, value: t });
  }
}
function x(e = "") {
  if (e)
    return !N2.test(e.trim().toLowerCase());
}
function A(e) {
  return !!e && b.test(e);
}
function C(e, t) {
  if (!A(t) || !e)
    return;
  const n2 = t.replace(b, "").toLowerCase();
  return e.find(({ name: e2 }) => e2.toLowerCase() === n2);
}
function M(e, t) {
  const n2 = C(t, e == null ? void 0 : e.fieldName);
  return n2 ? n2.title || null : e ? e.label || e.fieldName : null;
}
function U(e, t) {
  const n2 = t.get(e.toLowerCase());
  return `{${(n2 == null ? void 0 : n2.fieldName) || e}}`;
}
function q(e) {
  return e.replaceAll(g2, "");
}
function L(e, t) {
  const n2 = $(t, e);
  return n2 ? n2.name : e;
}
function R(e, t) {
  return e && e.map((e2) => L(e2, t));
}
function $(e, t) {
  return e && "function" == typeof e.getField && t ? e.getField(t) ?? null : null;
}
function k(e) {
  return `${e}`.trim();
}
function D({ attributes: e, globalAttributes: t, layer: n2, text: r2, expressionAttributes: i2, fieldInfoMap: o2 }) {
  return r2 ? z({ formattedAttributes: t, template: Q(r2, { ...t, ...i2, ...e }, n2), fieldInfoMap: o2 }) : "";
}
function z({ formattedAttributes: e, template: n2, fieldInfoMap: r2 }) {
  return k(q(r(r(n2, (e2) => U(e2, r2)), e)));
}
function O2(e, t, n2 = false) {
  const r2 = t[e];
  if ("string" == typeof r2) {
    const i2 = "%27", o2 = (n2 ? encodeURIComponent(r2) : r2).replaceAll(h, i2);
    t[e] = o2;
  }
}
function G(e, t = false) {
  const n2 = { ...e };
  return Object.keys(n2).forEach((e2) => O2(e2, n2, t)), n2;
}
function S(e, n2, r2) {
  const i2 = (n2 = k(n2)) && "{" !== n2[0];
  return r(e, G(r2, i2 || false));
}
function P(e, t) {
  return e.replaceAll(I, (e2, n2, r2) => {
    const i2 = $(t, r2);
    return i2 ? `{${i2.name}}` : n2;
  });
}
function Q(e, t, n2) {
  const r2 = P(e, n2);
  return r2 ? r2.replaceAll(F, (e2, n3, r3) => S(e2, n3 || r3, t)) : r2;
}
function _(e, t) {
  if ("string" == typeof e && t && null == t.dateFormat && (null != t.places || null != t.digitSeparator)) {
    const t2 = Number(e);
    if (!isNaN(t2))
      return t2;
  }
  return e;
}
function H(e) {
  return null != e && "object" == typeof e && "fieldsIndex" in e && "geometryType" in e && "getField" in e && "load" in e && "loaded" in e && "objectIdField" in e && "spatialReference" in e && "type" in e && ("feature" === e.type || "scene" === e.type) && "when" in e;
}
function B(e) {
  return null != e && "object" == typeof e && "createQuery" in e && "queryFeatureCount" in e && "queryObjectIds" in e && "queryRelatedFeatures" in e && "queryRelatedFeaturesCount" in e && "relationships" in e;
}
function J(e) {
  return H(e) && B(e);
}
function K(e) {
  return !!e && "object" == typeof e && "sourceLayer" in e && J(e.sourceLayer);
}
function V(e, t) {
  var _a;
  const { fieldInfos: n2, fieldName: r2, preventPlacesFormatting: l, layer: u2, timeZone: s } = t, c = Y(n2, r2), d = $(u2, r2);
  if (c && !Ge(r2)) {
    const t2 = d == null ? void 0 : d.type, n3 = (_a = c.format) == null ? void 0 : _a.dateFormat;
    if ("date" === t2 || "date-only" === t2 || "time-only" === t2 || "timestamp-offset" === t2 || n3)
      return N(e, { format: n3, fieldType: t2, timeZoneOptions: { layerTimeZone: u2 && "preferredTimeZone" in u2 ? u2.preferredTimeZone : null, viewTimeZone: s, datesInUnknownTimezone: !(!u2 || !("datesInUnknownTimezone" in u2)) && !!u2.datesInUnknownTimezone } });
  }
  const p = c == null ? void 0 : c.format;
  return "string" == typeof e && Ge(r2) && p ? W(e, p) : "string" == typeof (e = _(e, p)) || null == e || null == p ? ae(e) : u(e, l ? { ...o(p), minimumFractionDigits: 0, maximumFractionDigits: 20 } : o(p));
}
function W(e, t) {
  return e = e.trim(), /\d{2}-\d{2}/.test(e) ? e : e.includes(",") ? X(e, ",", ", ", t) : e.includes(";") ? X(e, ";", "; ", t) : e.includes(" ") ? X(e, " ", " ", t) : u(Number(e), o(t));
}
function X(e, t, n2, r2) {
  return e.trim().split(t).map((e2) => u(Number(e2), o(r2))).join(n2);
}
function Y(e, t) {
  if ((e == null ? void 0 : e.length) && t)
    return e.find((e2) => {
      var _a;
      return ((_a = e2.fieldName) == null ? void 0 : _a.toLowerCase()) === t.toLowerCase();
    });
}
function ee({ fieldName: e, graphic: t, layer: n2 }) {
  if (de(e))
    return null;
  if (!n2 || "function" != typeof n2.getFeatureType)
    return null;
  const { typeIdField: r2 } = n2;
  if (!r2 || e !== r2)
    return null;
  const i2 = n2.getFeatureType(t);
  return i2 ? i2.name : null;
}
function te({ fieldName: e, value: t, graphic: n2, layer: r2 }) {
  if (de(e))
    return null;
  if (!r2 || "function" != typeof r2.getFieldDomain)
    return null;
  const i2 = n2 && r2.getFieldDomain(e, { feature: n2 });
  return i2 && "coded-value" === i2.type ? i2.getName(t) : null;
}
function ne(e, t, r2, i2) {
  const { creatorField: o2, creationDateField: a, editorField: l, editDateField: u2 } = e;
  if (!t)
    return;
  const s = g(i2 && "preferredTimeZone" in i2 ? i2.preferredTimeZone : null, !(!i2 || !("datesInUnknownTimezone" in i2)) && !!i2.datesInUnknownTimezone, r2, Z2, "date"), f = { ...Z2, ...s }, c = t[u2];
  if ("number" == typeof c) {
    const e2 = t[l];
    return { type: "edit", date: j(c, f), user: e2 };
  }
  const d = t[a];
  if ("number" == typeof d) {
    const e2 = t[o2];
    return { type: "create", date: j(d, f), user: e2 };
  }
  return null;
}
function re(e, t) {
  const n2 = /* @__PURE__ */ new Map();
  return e ? (e.forEach((e2) => {
    const r2 = L(e2.fieldName, t);
    e2.fieldName = r2, n2.set(r2.toLowerCase(), e2);
  }), n2) : n2;
}
function ie(e) {
  const t = [];
  if (!e)
    return t;
  const { fieldInfos: n2, content: r2 } = e;
  return n2 && t.push(...n2), r2 && Array.isArray(r2) ? (r2.forEach((e2) => {
    if ("fields" === e2.type) {
      const n3 = e2 == null ? void 0 : e2.fieldInfos;
      n3 && t.push(...n3);
    }
  }), t) : t;
}
function oe(e) {
  return e.replaceAll(w, (e2) => `&#${e2.charCodeAt(0)};`);
}
function ae(e) {
  return "string" == typeof e ? e.replaceAll(T, '<br class="esri-text-new-line" />') : e;
}
function le(e) {
  var _a;
  const { value: t, fieldName: n2, fieldInfos: r2, fieldInfoMap: i2, layer: o2, graphic: a, timeZone: l } = e;
  if (null == t)
    return "";
  const s = te({ fieldName: n2, value: t, graphic: a, layer: o2 });
  if (s)
    return s;
  const d = ee({ fieldName: n2, graphic: a, layer: o2 });
  if (d)
    return d;
  if (i2.get(n2.toLowerCase()))
    return V(t, { fieldInfos: r2 || Array.from(i2.values()), fieldName: n2, layer: o2, timeZone: l });
  const p = (_a = o2 == null ? void 0 : o2.fieldsIndex) == null ? void 0 : _a.get(n2);
  return p && (Z(p) || be(p)) ? N(t, { fieldType: p.type, timeZoneOptions: { layerTimeZone: o2 && "preferredTimeZone" in o2 ? o2.preferredTimeZone : null, viewTimeZone: l, datesInUnknownTimezone: !(!o2 || !("datesInUnknownTimezone" in o2)) && !!o2.datesInUnknownTimezone } }) : ae(t);
}
function ue({ fieldInfos: e, attributes: t, layer: n2, graphic: r2, fieldInfoMap: i2, relatedInfos: o2, timeZone: a }) {
  const l = {};
  return o2 == null ? void 0 : o2.forEach((t2) => ye({ attributes: l, relatedInfo: t2, fieldInfoMap: i2, fieldInfos: e, layer: n2, timeZone: a })), t && Object.keys(t).forEach((o3) => {
    const u2 = t[o3];
    l[o3] = le({ fieldName: o3, fieldInfos: e, fieldInfoMap: i2, layer: n2, value: u2, graphic: r2, timeZone: a });
  }), l;
}
async function se(e, t) {
  var _a, _b;
  const { layer: n2, graphic: r2, outFields: i2, objectIds: o2, returnGeometry: a, spatialReference: l } = e, u2 = o2[0];
  if ("number" != typeof u2 && "string" != typeof u2) {
    const e2 = "Could not query required fields for the specified feature. The feature's ID is invalid.", t2 = { layer: n2, graphic: r2, objectId: u2, requiredFields: i2 };
    return y().warn(e2, t2), null;
  }
  if (!((_b = (_a = O(n2)) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsQuery)) {
    const e2 = "The specified layer cannot be queried. The following fields will not be available.", t2 = { layer: n2, graphic: r2, requiredFields: i2, returnGeometry: a };
    return y().warn(e2, t2), null;
  }
  const f = n2.createQuery();
  f.objectIds = o2, f.outFields = (i2 == null ? void 0 : i2.length) ? i2 : [n2.objectIdField], f.returnGeometry = !!a, f.returnZ = !!a, f.returnM = !!a, f.outSpatialReference = l;
  return (await n2.queryFeatures(f, t)).features[0];
}
async function fe(e) {
  var _a;
  if (!((_a = e.expressionInfos) == null ? void 0 : _a.length))
    return false;
  const t = await i(), { arcadeUtils: { hasGeometryFunctions: n2 } } = t;
  return n2(e);
}
async function ce({ graphic: e, popupTemplate: t, layer: n2, spatialReference: r2 }, i2) {
  if (!n2 || !t)
    return;
  if ("function" == typeof n2.load && await n2.load(i2), !e.attributes)
    return;
  const o2 = e.attributes[n2.objectIdField];
  if (null == o2)
    return;
  const a = [o2], u2 = await t.getRequiredFields(n2.fieldsIndex), s = je(u2, e), f = s ? [] : u2, c = t.returnGeometry || await fe(t);
  if (s && !c)
    return;
  const d = await se({ layer: n2, graphic: e, outFields: f, objectIds: a, returnGeometry: c, spatialReference: r2 }, i2);
  d && (d.geometry && (e.geometry = d.geometry), d.attributes && (e.attributes = { ...e.attributes, ...d.attributes }));
}
function de(e = "") {
  return !!e && e.includes(j2);
}
function pe(e) {
  return e ? `${j2}${e.layerId}/${e.fieldName}` : "";
}
function me({ attributes: e, graphic: t, relatedInfo: n2, fieldInfos: r2, fieldInfoMap: i2, layer: o2, timeZone: a }) {
  e && t && n2 && Object.keys(t.attributes).forEach((l) => {
    const u2 = pe({ layerId: n2.relation.id.toString(), fieldName: l }), s = t.attributes[l];
    e[u2] = le({ fieldName: u2, fieldInfos: r2, fieldInfoMap: i2, layer: o2, value: s, graphic: t, timeZone: a });
  });
}
function ye({ attributes: e, relatedInfo: t, fieldInfoMap: n2, fieldInfos: r2, layer: i2, timeZone: o2 }) {
  var _a, _b;
  e && t && ((_a = t.relatedFeatures) == null ? void 0 : _a.forEach((a) => me({ attributes: e, graphic: a, relatedInfo: t, fieldInfoMap: n2, fieldInfos: r2, layer: i2, timeZone: o2 })), (_b = t.relatedStatsFeatures) == null ? void 0 : _b.forEach((a) => me({ attributes: e, graphic: a, relatedInfo: t, fieldInfoMap: n2, fieldInfos: r2, layer: i2, timeZone: o2 })));
}
var ge = (e) => {
  if (!e)
    return false;
  const t = e.toUpperCase();
  return t.includes("CURRENT_TIMESTAMP") || t.includes("CURRENT_DATE") || t.includes("CURRENT_TIME");
};
var Ie = ({ layer: e, method: t, query: n2, definitionExpression: r2 }) => {
  var _a, _b;
  if (!((_b = (_a = e.capabilities) == null ? void 0 : _a.query) == null ? void 0 : _b.supportsCacheHint) || "attachments" === t)
    return;
  const i2 = null != n2.where ? n2.where : null, o2 = null != n2.geometry ? n2.geometry : null;
  ge(r2) || ge(i2) || "extent" === (o2 == null ? void 0 : o2.type) || "tile" === n2.resultType || (n2.cacheHint = true);
};
var he = ({ query: e, layer: t, method: n2 }) => {
  Ie({ layer: t, method: n2, query: e, definitionExpression: `${t.definitionExpression} ${t.serviceDefinitionExpression}` });
};
var be2 = ({ queryPayload: e, layer: t, method: n2 }) => {
  Ie({ layer: t, method: n2, query: e, definitionExpression: `${t.definitionExpression} ${t.serviceDefinitionExpression}` });
};
function Te(e, t, n2) {
  return e && t && n2 ? we(e.allLayers, t, n2) || we(e.allTables, t, n2) : null;
}
function we(e, t, { relatedTableId: n2 }) {
  const r2 = "scene" === t.type && t.associatedLayer ? t.associatedLayer.url : t.url;
  return e.filter(J).find((e2) => e2 !== t && e2.url === r2 && e2.layerId === n2);
}
function Fe(e) {
  const t = e.getObjectId();
  return null != t ? `oid:${t}` : `uid:${e.uid}`;
}

export {
  E2 as E,
  v,
  x,
  A,
  M,
  L,
  R,
  D,
  z,
  P,
  J,
  K,
  Y,
  ne,
  re,
  ie,
  oe,
  ae,
  ue,
  se,
  ce,
  de,
  he,
  be2 as be,
  Te,
  Fe
};
//# sourceMappingURL=chunk-KDAM4HTO.js.map
