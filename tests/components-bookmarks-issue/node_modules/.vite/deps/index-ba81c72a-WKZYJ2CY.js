import "./chunk-Z4ZPL3B3.js";

// node_modules/@esri/calcite-components/dist/esm/index-ba81c72a.js
var supportedTimeZones = (() => {
  const platformTimeZones = Intl.supportedValuesOf("timeZone");
  const etcTimeZones = [
    "Etc/GMT+1",
    "Etc/GMT+10",
    "Etc/GMT+11",
    "Etc/GMT+12",
    "Etc/GMT+2",
    "Etc/GMT+3",
    "Etc/GMT+4",
    "Etc/GMT+5",
    "Etc/GMT+6",
    "Etc/GMT+7",
    "Etc/GMT+8",
    "Etc/GMT+9",
    "Etc/GMT-1",
    "Etc/GMT-10",
    "Etc/GMT-11",
    "Etc/GMT-12",
    "Etc/GMT-13",
    "Etc/GMT-14",
    "Etc/GMT-2",
    "Etc/GMT-3",
    "Etc/GMT-4",
    "Etc/GMT-5",
    "Etc/GMT-6",
    "Etc/GMT-7",
    "Etc/GMT-8",
    "Etc/GMT-9"
  ];
  return [.../* @__PURE__ */ new Set([...platformTimeZones, ...etcTimeZones])];
})();
var now = /* @__PURE__ */ new Date();
var startDate = now.toISOString();
var daysInYear = 365;
var groupDateRange = daysInYear;
var defaultGroupingOptions = {
  startDate,
  groupDateRange,
  debug: false
};
var continentAllowList = /* @__PURE__ */ new Set([
  "Europe",
  "Asia",
  "America",
  "America/Argentina",
  "Africa",
  "Australia",
  "Pacific",
  "Atlantic",
  "Antarctica",
  "Arctic",
  "Indian"
]);
var _getDates = (startDate2, numberDays, dateEngine) => {
  const dateArray = [];
  let date = dateEngine.create(startDate2);
  for (let i = 0; i <= numberDays; i++) {
    date = dateEngine.increase(date);
    dateArray.push(dateEngine.formatToIsoDateString(date));
  }
  return dateArray;
};
var _extractContinent = (label) => {
  if (label.includes("Istanbul")) {
    return "Europe";
  }
  const lastIndex = label.lastIndexOf("/");
  return lastIndex === -1 ? label : label.slice(0, lastIndex);
};
var _isRegularContinent = (continent) => continentAllowList.has(continent);
var generateTimeZoneMetadata = (timeZoneItems, startDate2, numberDays, dateEngine, debug = false) => {
  const processedDates = /* @__PURE__ */ new Map();
  if (debug) {
    console.log(`Initializing data starting ${startDate2} with ${numberDays} days in the future, comparing ${timeZoneItems.length} timezones`);
  }
  const theDates = _getDates(startDate2, numberDays, dateEngine);
  return timeZoneItems.map((tzItem) => {
    const label = tzItem.label;
    const continent = _extractContinent(label);
    const dates = theDates.map((date) => {
      const key = `${date}-${label}`;
      let utc = processedDates.get(key);
      if (utc) {
        return utc;
      }
      utc = dateEngine.isoToTimeZone(date, label);
      processedDates.set(key, utc);
      return utc;
    });
    return {
      ...tzItem,
      continent,
      isRegularContinent: _isRegularContinent(continent),
      dates
    };
  });
};
var compareDateArrs = (array1, array2, dateEngine) => array1.length === array2.length && array1.every((value, index) => dateEngine.same(value, array2[index]));
var getGroupLabelTimeZoneIndices = (rawTZs, max = 5) => {
  const shrinkedTzs = rawTZs.filter(({ label }) => _isRegularContinent(_extractContinent(label)));
  if (shrinkedTzs.length === 0) {
    return [0];
  }
  const validLabels = shrinkedTzs.map((tz) => rawTZs.indexOf(tz));
  return equallyDistributedSampling(validLabels, max);
};
function equallyDistributedSampling(items, maxItems = 5) {
  const totalItems = items.length;
  if (totalItems <= maxItems) {
    return items;
  }
  const numberItemsToSelect = Math.min(totalItems - 2, maxItems - 2);
  const stepSize = (totalItems - 1) / (numberItemsToSelect + 1);
  return [
    items[0],
    ...Array.from({ length: numberItemsToSelect }, (_, i) => items[Math.round((i + 1) * stepSize)]),
    items[totalItems - 1]
  ];
}
async function groupTimeZones(options) {
  var _a, _b, _c, _d, _e;
  const { debug, groupDateRange: groupDateRange2, hooks, startDate: startDate2, dateEngine } = {
    ...defaultGroupingOptions,
    ...options
  };
  const grouping = [];
  if (!dateEngine) {
    throw new Error("dateEngine is required");
  }
  const timeZoneItems = supportedTimeZones.map((tz) => ({ label: tz }));
  (_a = hooks == null ? void 0 : hooks.onBeforeTimeZoneMetadataCreate) == null ? void 0 : _a.call(hooks, timeZoneItems);
  const timeZoneMetadata = generateTimeZoneMetadata(timeZoneItems, startDate2, groupDateRange2, dateEngine, debug);
  (_b = hooks == null ? void 0 : hooks.onTimeZoneMetadataCreate) == null ? void 0 : _b.call(hooks, timeZoneMetadata);
  for (const tzMetadatumI of timeZoneMetadata) {
    const { label, continent, dates } = tzMetadatumI;
    if (tzMetadatumI.visited) {
      continue;
    }
    tzMetadatumI.visited = true;
    const newGroup = {
      labelTzIndices: void 0,
      tzs: [{ label }]
    };
    (_c = hooks == null ? void 0 : hooks.onGroupCreate) == null ? void 0 : _c.call(hooks, newGroup, tzMetadatumI);
    for (const tzMetadatumJ of timeZoneMetadata.filter((_) => !_.visited)) {
      const { label: labelJ, continent: continentJ, isRegularContinent: isRegularContinentJ, dates: datesJ } = tzMetadatumJ;
      if ((continent === continentJ || !isRegularContinentJ) && compareDateArrs(dates, datesJ, dateEngine)) {
        const tzItem = { label: labelJ };
        newGroup.tzs.push(tzItem);
        (_d = hooks == null ? void 0 : hooks.onGroupTimeZoneAdd) == null ? void 0 : _d.call(hooks, newGroup, tzItem, tzMetadatumJ);
        tzMetadatumJ.visited = true;
      }
    }
    grouping.push(newGroup);
    (_e = hooks == null ? void 0 : hooks.onGroupAdd) == null ? void 0 : _e.call(hooks, newGroup);
  }
  const finalGrouping = grouping.map((group) => {
    var _a2, _b2;
    (_a2 = hooks == null ? void 0 : hooks.onBeforeFinalGroupCreate) == null ? void 0 : _a2.call(hooks, group);
    group.tzs = group.tzs.sort((a, b) => a.label.localeCompare(b.label));
    const finalGrouping2 = {
      labelTzIndices: getGroupLabelTimeZoneIndices(group.tzs, 7),
      tzs: group.tzs.map((_) => _.label)
    };
    (_b2 = hooks == null ? void 0 : hooks.onFinalGroupCreate) == null ? void 0 : _b2.call(hooks, finalGrouping2, group);
    return finalGrouping2;
  }).sort((a, b) => b.tzs.length - a.tzs.length);
  if (debug) {
    const missingTzs = supportedTimeZones.map((tz) => finalGrouping.some((y) => y.tzs.includes(tz)) ? null : tz).filter(Boolean);
    if (missingTzs.length > 0) {
      throw new Error(`There are ${missingTzs.length} missing timezones: ${missingTzs.toString()}`);
    }
  }
  return (hooks == null ? void 0 : hooks.onFinalGroupingCreate) ? hooks.onFinalGroupingCreate(finalGrouping) : finalGrouping;
}
export {
  groupTimeZones
};
/*! Bundled license information:

@esri/calcite-components/dist/esm/index-ba81c72a.js:
  (*!
   * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
   * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
   * v2.6.0
   *)
*/
//# sourceMappingURL=index-ba81c72a-WKZYJ2CY.js.map
