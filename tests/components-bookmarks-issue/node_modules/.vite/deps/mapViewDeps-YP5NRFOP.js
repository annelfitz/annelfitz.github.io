import {
  s as s7,
  s2 as s8
} from "./chunk-47WR7A25.js";
import {
  p as p3
} from "./chunk-6ZLA7UW2.js";
import {
  e as e11
} from "./chunk-3PAQL7YW.js";
import {
  w as w3
} from "./chunk-6GHUHFYG.js";
import {
  f as f6
} from "./chunk-HSRJRAFC.js";
import {
  e as e10,
  i as i8
} from "./chunk-CTO5W2RR.js";
import {
  o as o10
} from "./chunk-LSOYCE62.js";
import {
  y as y2
} from "./chunk-MHIDY6OV.js";
import {
  a as a4,
  a2 as a5,
  e as e9,
  f as f7,
  n as n5,
  r as r6,
  r2 as r7,
  t as t8,
  t2 as t10
} from "./chunk-I3GWXP7X.js";
import "./chunk-QYYSPD2Q.js";
import "./chunk-K3DEHPDR.js";
import "./chunk-I6RS7YIS.js";
import "./chunk-FZI7RNDL.js";
import "./chunk-BSYULFZQ.js";
import {
  e as e5
} from "./chunk-YGP7UFWC.js";
import "./chunk-5IHJU3SQ.js";
import {
  a as a3,
  c as c3,
  l as l4,
  m as m3
} from "./chunk-VQKDRN55.js";
import {
  t as t9
} from "./chunk-MASBINVZ.js";
import "./chunk-AD6XW3W5.js";
import {
  $ as $2
} from "./chunk-ES7G4AF5.js";
import "./chunk-SGCIDT4C.js";
import {
  F as F3,
  T as T4
} from "./chunk-QXRPUAVL.js";
import "./chunk-M5UX4IRZ.js";
import "./chunk-2WUPZJUL.js";
import {
  h as h7,
  h2 as h8,
  i as i7,
  n as n4
} from "./chunk-KN52PCW4.js";
import {
  m as m4,
  t as t7
} from "./chunk-SFKZ25SS.js";
import {
  e as e8
} from "./chunk-NCZU5DB4.js";
import "./chunk-SMDSNUU2.js";
import "./chunk-XTY645DH.js";
import "./chunk-UIOX7MPV.js";
import {
  A as A3,
  E as E3,
  h2 as h6,
  i as i6,
  o as o9,
  t as t6
} from "./chunk-HRDKP7QO.js";
import "./chunk-4UOHLZKX.js";
import {
  s as s6
} from "./chunk-VJ2I4VSQ.js";
import {
  e as e7
} from "./chunk-MCZ4QOSQ.js";
import "./chunk-Q23RMXBO.js";
import "./chunk-2YYSD64V.js";
import {
  e as e6
} from "./chunk-6XTKBOD7.js";
import "./chunk-IUY6HBLC.js";
import {
  o as o8
} from "./chunk-BHOYA5LV.js";
import {
  i as i5
} from "./chunk-XEXYFKCA.js";
import "./chunk-6RR3WN7W.js";
import {
  t as t5
} from "./chunk-TXCVD3YI.js";
import "./chunk-PGADGS3I.js";
import "./chunk-MVSN2HAN.js";
import "./chunk-7A5N7G2Z.js";
import "./chunk-MEEG7XMI.js";
import "./chunk-LJULTBAY.js";
import "./chunk-FD4DXBZA.js";
import "./chunk-YKIGDW5O.js";
import "./chunk-7FQYGAVT.js";
import "./chunk-QO4PGON2.js";
import "./chunk-QRQWG4D3.js";
import "./chunk-QWREIIJ5.js";
import "./chunk-6ZDDHEYR.js";
import "./chunk-YQQSFFN3.js";
import "./chunk-32X2FZ3S.js";
import {
  l as l3
} from "./chunk-4IJED6JM.js";
import "./chunk-LGIO6OCK.js";
import {
  M as M3,
  j as j2,
  y
} from "./chunk-C5EJV3NW.js";
import "./chunk-XXIDOBRO.js";
import "./chunk-JL4LXZGM.js";
import "./chunk-O556EBAK.js";
import {
  i as i4,
  s as s5,
  x as x2
} from "./chunk-IJD65EMQ.js";
import {
  h as h5
} from "./chunk-4YGBWYMD.js";
import {
  K2 as K,
  i as i2,
  t as t3
} from "./chunk-ZPU7GNG4.js";
import "./chunk-TNR6E67I.js";
import {
  f as f5,
  u as u6
} from "./chunk-7O3VD45U.js";
import "./chunk-QREUCRQ4.js";
import {
  a as a2,
  c as c2,
  i as i3,
  s as s4
} from "./chunk-YK3UMVCY.js";
import "./chunk-IQFWVTUJ.js";
import "./chunk-GB4RVOXH.js";
import {
  e2 as e4,
  m as m2
} from "./chunk-JTUYA5FE.js";
import "./chunk-UNTQATE2.js";
import "./chunk-5YY6NZNY.js";
import {
  _
} from "./chunk-DCBZOZ54.js";
import "./chunk-5IT6RVBX.js";
import "./chunk-N4HNOQVJ.js";
import "./chunk-MTQHYT7Y.js";
import {
  t as t4
} from "./chunk-JCP47SOM.js";
import "./chunk-CXCB57TE.js";
import {
  i
} from "./chunk-IWO6JXL2.js";
import {
  $,
  At,
  Dt,
  I as I3,
  J,
  M as M2,
  T as T3,
  Ut,
  b as b3,
  it,
  j,
  lt,
  vt
} from "./chunk-AVR3LWTZ.js";
import "./chunk-YUWVLORR.js";
import {
  t as t2
} from "./chunk-FFG7BDAP.js";
import {
  h as h4
} from "./chunk-I4SHZ6P5.js";
import "./chunk-DGRFM5OL.js";
import "./chunk-AOAT6HYL.js";
import {
  r as r5
} from "./chunk-JBU54P54.js";
import "./chunk-5LIYYE75.js";
import {
  n as n3
} from "./chunk-252ISA6Z.js";
import "./chunk-TLTAGTBA.js";
import "./chunk-2QPP5AGU.js";
import "./chunk-2C26DRKK.js";
import "./chunk-M4RFJU4F.js";
import "./chunk-VBLASJK5.js";
import {
  B as B2,
  C,
  D as D2,
  E as E2,
  F as F2,
  G,
  I as I2,
  L as L3,
  N,
  O,
  P as P3,
  R,
  T as T2,
  U as U2
} from "./chunk-WKVHVZW2.js";
import "./chunk-YT66FIGM.js";
import "./chunk-VIKID44H.js";
import "./chunk-RLZYC2LS.js";
import {
  s as s3
} from "./chunk-L52HB3KV.js";
import "./chunk-TXLJQAAN.js";
import "./chunk-3AIILHI5.js";
import "./chunk-JKLFCJPR.js";
import {
  o as o7
} from "./chunk-7JR6S3WL.js";
import "./chunk-P4MNTMCZ.js";
import "./chunk-BSPKLAHD.js";
import "./chunk-VS6AHHIY.js";
import {
  f as f3
} from "./chunk-BFOJPIF7.js";
import "./chunk-3JC3OUNW.js";
import "./chunk-RO3CTAP7.js";
import {
  A as A2,
  B,
  D,
  E,
  F,
  I,
  L as L2,
  P as P2,
  T,
  b as b2,
  f as f2,
  h as h2,
  o as o6,
  p as p2,
  t,
  u as u5,
  w as w2,
  x,
  z
} from "./chunk-GKMVTGGM.js";
import {
  o as o5
} from "./chunk-XGTCDM4C.js";
import "./chunk-QNG4TY7L.js";
import "./chunk-VEYMN5N3.js";
import "./chunk-W5ALAOW2.js";
import "./chunk-FHDHOWK5.js";
import "./chunk-Y546C2O5.js";
import "./chunk-BDRVHR2K.js";
import {
  r as r4
} from "./chunk-ZLQTPFTL.js";
import {
  M,
  f as f4,
  h as h3,
  l as l2
} from "./chunk-HZSGATFT.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-ERD6I7QP.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import "./chunk-I2X6UR6L.js";
import "./chunk-5JYVZQZR.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import {
  e as e3,
  u as u4
} from "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import {
  e as e2,
  h
} from "./chunk-OCF7OAES.js";
import {
  o as o4
} from "./chunk-JZBR4X6W.js";
import {
  n as n2
} from "./chunk-OIJCMME5.js";
import {
  u as u3
} from "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-545NO6M2.js";
import "./chunk-5LSHHVQ5.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import {
  Pt,
  U
} from "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  P,
  d as d2
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import {
  o as o3
} from "./chunk-TXBMNSNF.js";
import {
  d
} from "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  A,
  r2 as r
} from "./chunk-NDIXNREV.js";
import "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  L,
  b,
  f2 as f,
  m,
  o,
  o3 as o2,
  s as s2,
  u2,
  w
} from "./chunk-JGDJR5EV.js";
import {
  e,
  l,
  r as r3,
  u
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  a,
  c2 as c,
  n2 as n,
  r as r2,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has,
  p
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/symbols/cim/cimAnalyzer.js
var V = () => n.getLogger("esri.symbols.cim.cimAnalyzer");
function N2(e13) {
  const r14 = e13.markerPlacement;
  return r14 && r14.angleToLine ? i.MAP : i.SCREEN;
}
var w4 = class {
  constructor(e13) {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [], e13 && (this._resourceManager = e13);
  }
  analyzeSymbolReference(r14, t15, i12) {
    if (this._cimLayers = i12 ?? [], !r14)
      return this._cimLayers;
    if (this._reset(), r14.primitiveOverrides) {
      this._primitiveOverrides = r14.primitiveOverrides;
      for (const r15 of this._primitiveOverrides) {
        const t16 = r15.valueExpressionInfo;
        if (t16)
          this._setPoMap(r15.primitiveName, r15.propertyName, t16);
        else if (null != r15.value) {
          let t17 = r15.value;
          r15.propertyName.includes("Color") && (o5(t17) && (t17 = o6(t17)), t17 = f2(t17)), this._setPoMap(r15.primitiveName, r15.propertyName, t17);
        }
      }
    }
    return this._analyzeSymbol(r14.symbol, t15), this._cimLayers;
  }
  _reset() {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [];
  }
  _analyzeSymbol(e13, r14) {
    switch (e13 == null ? void 0 : e13.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        this._analyzeMultiLayerSymbol(e13, r14);
    }
  }
  _analyzeMultiLayerSymbol(e13, r14) {
    const t15 = e13 == null ? void 0 : e13.symbolLayers;
    if (!t15)
      return;
    const i12 = e13.effects;
    let o14 = i.SCREEN;
    const a9 = B(e13) ?? 0;
    "CIMPointSymbol" === e13.type && "Map" === e13.angleAlignment && (o14 = i.MAP);
    const s12 = "CIMPolygonSymbol" === e13.type;
    let l11 = t15.length;
    for (; l11--; ) {
      const n12 = t15[l11];
      if (!n12 || false === n12.enable)
        continue;
      let c10;
      (i12 == null ? void 0 : i12.length) && (c10 = [...i12]);
      const m7 = n12.effects;
      (m7 == null ? void 0 : m7.length) && (i12 ? c10.push(...m7) : c10 = [...m7]);
      let y3 = null;
      if (c10) {
        y3 = [];
        for (const e14 of c10) {
          const r15 = f3.findEffectOverrides(e14, this._primitiveOverrides);
          r15 && y3.push(r15);
        }
      }
      const f10 = [];
      switch (f3.findApplicableOverrides(n12, this._primitiveOverrides, f10), n12.type) {
        case "CIMSolidFill":
          this._analyzeSolidFill(n12, y3);
          break;
        case "CIMPictureFill":
          this._analyzePictureFill(n12, y3);
          break;
        case "CIMHatchFill":
          this._analyzeHatchFill(n12, y3);
          break;
        case "CIMGradientFill":
          this._analyzeGradientFill(n12, y3);
          break;
        case "CIMSolidStroke":
          this._analyzeSolidStroke(n12, y3, s12, a9);
          break;
        case "CIMPictureStroke":
          this._analyzePictureStroke(n12, y3, s12, a9);
          break;
        case "CIMGradientStroke":
          this._analyzeGradientStroke(n12, y3, s12, a9);
          break;
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
        case "CIMVectorMarker": {
          "CIMLineSymbol" !== e13.type && "CIMPolygonSymbol" !== e13.type || (o14 = N2(n12));
          const t16 = [], i13 = n12.primitiveName;
          i13 && t16.push(i13);
          const l12 = s12 && b2(n12.markerPlacement);
          this._analyzeMarker(n12, y3, null, t16, o14, a9, r14, [], false, l12);
          break;
        }
        default:
          V().error("Cannot analyze CIM layer", n12.type);
      }
    }
  }
  _analyzeSolidFill(e13, r14) {
    const { primitiveName: t15, type: i12 } = e13, o14 = f2(e13.color);
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: null, colorLocked: !!e13.colorLocked, color: this._getValueOrOverrideExpression(i12, t15, "Color", o14), height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, effects: r14, applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: false });
  }
  _analyzePictureFill(e13, r14) {
    const { primitiveName: t15, type: i12 } = e13, o14 = p2(e13), a9 = I(e13.height, t.CIMPictureFill.height);
    let s12 = I(e13.scaleX, 1);
    if ("width" in e13 && "number" == typeof e13.width) {
      const r15 = e13.width;
      let t16 = 1;
      const i13 = this._resourceManager.getResource(e13.url);
      null != i13 && (t16 = i13.width / i13.height), s12 /= t16 * (a9 / r15);
    }
    const l11 = { type: "sprite-rasterization-param", resource: e13, overrides: this._getPrimitiveMaterialOverrides(t15, i12) };
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: l11, colorLocked: !!e13.colorLocked, effects: r14, color: this._getValueOrOverrideExpression(i12, t15, "TintColor", o14), height: this._getValueOrOverrideExpression(i12, t15, "Height", a9), scaleX: this._getValueOrOverrideExpression(i12, t15, "ScaleX", s12), angle: this._getValueOrOverrideExpression(i12, t15, "Rotation", I(e13.rotation)), offsetX: this._getValueOrOverrideExpression(i12, t15, "OffsetX", I(e13.offsetX)), offsetY: this._getValueOrOverrideExpression(i12, t15, "OffsetY", I(e13.offsetY)), applyRandomOffset: false, sampleAlphaOnly: false, hasUnresolvedReplacementColor: false });
  }
  _analyzeHatchFill(e13, r14) {
    var _a, _b, _c;
    const { primitiveName: t15, type: i12 } = e13, o14 = A4(this._analyzeMaterialOverrides(t15, ["Rotation", "OffsetX", "OffsetY"]));
    let a9 = [255, 255, 255, 1], s12 = false;
    if ((_a = e13.lineSymbol) == null ? void 0 : _a.symbolLayers)
      for (const n12 of e13.lineSymbol.symbolLayers) {
        if ("CIMSolidStroke" !== n12.type)
          continue;
        const e14 = n12.primitiveName ?? t15;
        s12 || !e14 || n12.colorLocked || null == ((_b = this._poMap[e14]) == null ? void 0 : _b.Color) && null == ((_c = this._poMap[e14]) == null ? void 0 : _c.StrokeColor) || (a9 = f2(n12.color), a9 = this._maybeGetValueOrOverrideExpression(e14, "StrokeColor") ?? this._getValueOrOverrideExpression(i12, e14, "Color", a9), s12 = true);
        const r15 = this._maybeGetValueOrOverrideExpression(e14, "StrokeWidth");
        if (r15) {
          let t16 = null, a10 = null;
          "number" == typeof r15 ? t16 = r15 : a10 = r15.valueExpressionInfo;
          let s13 = o14.find((e15) => "strokeWidth" === e15.propertyName);
          s13 ? s13.propertyName = "width" : (s13 = { type: "CIMPrimitiveOverride", primitiveName: e14, propertyName: "width", valueExpressionInfo: a10, value: t16, defaultValue: D(i12, "width") }, o14.push(s13));
        }
      }
    const l11 = { type: "sprite-rasterization-param", resource: e13, overrides: o14 };
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: l11, colorLocked: !!e13.colorLocked, effects: r14, color: a9, height: this._getValueOrOverrideExpression(i12, t15, "Separation", I(e13.separation, t.CIMHatchFill.separation)), scaleX: 1, angle: this._getValueOrOverrideExpression(i12, t15, "Rotation", I(e13.rotation)), offsetX: this._getValueOrOverrideExpression(i12, t15, "OffsetX", I(e13.offsetX)), offsetY: this._getValueOrOverrideExpression(i12, t15, "OffsetY", I(e13.offsetY)), applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: !s12 });
  }
  _analyzeGradientFill(e13, r14) {
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: null, colorLocked: !!e13.colorLocked, effects: r14, color: [128, 128, 128, 1], height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, applyRandomOffset: false, sampleAlphaOnly: false, hasUnresolvedReplacementColor: false });
  }
  _analyzeSolidStroke(e13, r14, t15, i12) {
    const { primitiveName: o14, type: a9 } = e13, s12 = f2(e13.color), l11 = I(e13.width, t.CIMSolidStroke.width), c10 = h2(e13.capStyle, t.CIMSolidStroke.capstyle), p6 = h2(e13.joinStyle, t.CIMSolidStroke.joinstyle), m7 = e13.miterLimit;
    let y3, f10, d4 = [];
    if (this._analyzePrimitiveOverrides(o14, r14, null, null) && (d4 = this._getPrimitiveMaterialOverrides(o14, a9)), r14 && Array.isArray(r14) && r14.length > 0) {
      const e14 = r14[r14.length - 1].effect;
      e14 && "CIMGeometricEffectDashes" === e14.type && "NoConstraint" === e14.lineDashEnding && null === e14.offsetAlongLine && (y3 = e14.dashTemplate, f10 = e14.scaleDash, (r14 = [...r14]).pop());
    }
    const u11 = void 0 !== y3 ? { type: "sprite-rasterization-param", resource: { type: "dash", dashTemplate: y3, capStyle: c10 }, overrides: d4 } : null;
    this._cimLayers.push({ type: "line", spriteRasterizationParam: u11, isOutline: t15, colorLocked: !!e13.colorLocked, effects: r14, color: this._getValueOrOverrideExpression(a9, o14, "Color", s12), width: this._getValueOrOverrideExpression(a9, o14, "Width", l11), cap: this._getValueOrOverrideExpression(a9, o14, "CapStyle", c10), join: this._getValueOrOverrideExpression(a9, o14, "JoinStyle", p6), miterLimit: m7 && this._getValueOrOverrideExpression(a9, o14, "MiterLimit", m7), referenceWidth: i12, zOrder: G2(e13.name), dashTemplate: y3, scaleDash: f10, sampleAlphaOnly: true });
  }
  _analyzePictureStroke(e13, r14, t15, i12) {
    const { primitiveName: o14, type: a9 } = e13, s12 = p2(e13), l11 = I(e13.width, t.CIMPictureStroke.width), c10 = h2(e13.capStyle, t.CIMPictureStroke.capstyle), p6 = h2(e13.joinStyle, t.CIMPictureStroke.joinstyle), m7 = e13.miterLimit, y3 = { type: "sprite-rasterization-param", resource: e13, overrides: this._getPrimitiveMaterialOverrides(o14, a9) };
    this._cimLayers.push({ type: "line", spriteRasterizationParam: y3, isOutline: t15, colorLocked: !!e13.colorLocked, effects: r14, color: this._getValueOrOverrideExpression(a9, o14, "TintColor", s12), width: this._getValueOrOverrideExpression(a9, o14, "Width", l11), cap: this._getValueOrOverrideExpression(a9, o14, "CapStyle", c10), join: this._getValueOrOverrideExpression(a9, o14, "JoinStyle", p6), miterLimit: m7 && this._getValueOrOverrideExpression(a9, o14, "MiterLimit", m7), referenceWidth: i12, zOrder: G2(e13.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false });
  }
  _analyzeGradientStroke(e13, r14, t15, i12) {
    const { primitiveName: o14, type: a9 } = e13, s12 = I(e13.width, t.CIMSolidStroke.width), l11 = h2(e13.capStyle, t.CIMGradientStroke.capstyle), c10 = h2(e13.joinStyle, t.CIMGradientStroke.joinstyle), p6 = e13.miterLimit;
    this._cimLayers.push({ type: "line", spriteRasterizationParam: null, isOutline: t15, colorLocked: !!e13.colorLocked, effects: r14, color: [128, 128, 128, 1], width: this._getValueOrOverrideExpression(a9, o14, "Width", s12), cap: this._getValueOrOverrideExpression(a9, o14, "CapStyle", l11), join: this._getValueOrOverrideExpression(a9, o14, "JoinStyle", c10), miterLimit: p6 && this._getValueOrOverrideExpression(a9, o14, "MiterLimit", p6), referenceWidth: i12, zOrder: G2(e13.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false });
  }
  _analyzeMarker(e13, r14, t15, i12, o14, a9, s12, l11, c10 = false, p6 = false) {
    if (c10 || (c10 = !!e13.colorLocked), this._analyzeMarkerInsidePolygon(e13, r14, c10))
      return;
    const m7 = I(e13.size, t.CIMVectorMarker.size), y3 = I(e13.rotation), f10 = I(e13.offsetX), h13 = I(e13.offsetY), { primitiveName: d4, type: u11 } = e13, v3 = this._getValueOrOverrideExpression(u11, d4, "Size", m7), _5 = this._getValueOrOverrideExpression(u11, d4, "Rotation", y3), g3 = this._getValueOrOverrideExpression(u11, d4, "OffsetX", f10), S = this._getValueOrOverrideExpression(u11, d4, "OffsetY", h13);
    switch (e13.type) {
      case "CIMPictureMarker":
        this._analyzePictureMarker(e13, r14, t15, i12, o14, a9, v3, _5, g3, S, l11, c10, p6);
        break;
      case "CIMVectorMarker":
        this._analyzeVectorMarker(e13, r14, t15, i12, o14, a9, v3, _5, g3, S, l11, s12, c10, p6);
    }
  }
  _analyzeMarkerInsidePolygon(e13, r14, t15) {
    const { markerPlacement: i12, type: o14 } = e13;
    if (!i12 || "CIMMarkerPlacementInsidePolygon" !== i12.type)
      return false;
    if ("CIMVectorMarker" === o14 || "CIMPictureMarker" === o14) {
      const t16 = e13.primitiveName;
      if (t16 && this._analyzePrimitiveOverrides([t16], r14, null, null))
        return false;
      const a9 = i12.primitiveName;
      if (a9 && this._analyzePrimitiveOverrides([a9], r14, null, null))
        return false;
      if ("CIMVectorMarker" === o14) {
        const { markerGraphics: r15 } = e13;
        if (r15)
          for (const e14 of r15) {
            const { symbol: r16 } = e14;
            if ("CIMPolygonSymbol" === (r16 == null ? void 0 : r16.type) && r16.symbolLayers) {
              const { symbolLayers: e15 } = r16;
              for (const r17 of e15)
                if ("CIMSolidStroke" === r17.type)
                  return false;
            }
          }
      } else {
        const { animatedSymbolProperties: r15 } = e13;
        if (r15)
          return false;
      }
    }
    const s12 = Math.abs(i12.stepX), l11 = Math.abs(i12.stepY);
    if (0 === s12 || 0 === l11)
      return true;
    let n12, c10;
    if ("Random" === i12.gridType) {
      const e14 = e3(lt), r15 = Math.max(Math.floor(e14 / s12), 1);
      n12 = l11 * Math.max(Math.floor(e14 / l11), 1);
      c10 = r15 * s12 / n12;
    } else
      i12.shiftOddRows ? (n12 = 2 * l11, c10 = s12 / l11 * 0.5) : (n12 = l11, c10 = s12 / l11);
    const p6 = p2(e13), m7 = "CIMCharacterMarker" === e13.type ? null : { type: "sprite-rasterization-param", resource: e13, overrides: [] };
    return this._cimLayers.push({ type: "fill", spriteRasterizationParam: m7, colorLocked: t15, effects: r14, color: p6, height: n12, scaleX: c10, angle: i12.gridAngle, offsetX: I(i12.offsetX), offsetY: I(i12.offsetY), applyRandomOffset: "Random" === i12.gridType, sampleAlphaOnly: "CIMPictureMarker" !== e13.type, hasUnresolvedReplacementColor: true }), true;
  }
  _analyzePictureMarker(e13, r14, i12, o14, a9, l11, n12, c10, p6, m7, y3, f10, h13) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { primitiveName: d4, type: u11 } = e13;
    let _5 = I(e13.scaleX, 1);
    const g3 = p2(e13);
    i12 || (i12 = this._createMarkerPlacementOverrideExpression(e13.markerPlacement));
    const S = this._createAnimatedSymbolPropertiesOverrideExpression(e13.animatedSymbolProperties), k2 = e13.anchorPoint ?? { x: 0, y: 0 };
    if ("width" in e13 && "number" == typeof e13.width) {
      const r15 = e13.width;
      let t15 = 1;
      const i13 = this._resourceManager.getResource(e13.url);
      null != i13 && (t15 = i13.width / i13.height);
      _5 /= t15 * (I(e13.size) / r15);
    }
    const M4 = [...o14];
    let b5;
    e13.primitiveName && M4.push(e13.primitiveName), e13.animatedSymbolProperties || S ? b5 = { type: "animated", url: e13.url, urlHash: "H" + c(e13.url), playAnimation: (_a = e13.animatedSymbolProperties) == null ? void 0 : _a.playAnimation, reverseAnimation: (_b = e13.animatedSymbolProperties) == null ? void 0 : _b.reverseAnimation, randomizeStartTime: (_c = e13.animatedSymbolProperties) == null ? void 0 : _c.randomizeStartTime, randomizeStartSeed: (_d = e13.animatedSymbolProperties) == null ? void 0 : _d.randomizeStartSeed, startTimeOffset: (_e = e13.animatedSymbolProperties) == null ? void 0 : _e.startTimeOffset, duration: (_f = e13.animatedSymbolProperties) == null ? void 0 : _f.duration, repeatType: (_g = e13.animatedSymbolProperties) == null ? void 0 : _g.repeatType, repeatDelay: (_h = e13.animatedSymbolProperties) == null ? void 0 : _h.repeatDelay } : (b5 = a(e13), b5.markerPlacement = null);
    const C2 = { type: "sprite-rasterization-param", resource: b5, overrides: this._getMaterialOverrides(M4, u11) };
    S && C2.overrides.push(...S.overrides), this._cimLayers.push({ type: "marker", spriteRasterizationParam: C2, colorLocked: f10, effects: r14, scaleSymbolsProportionally: false, alignment: a9, size: n12, scaleX: this._getValueOrOverrideExpression(u11, d4, "ScaleX", _5), rotation: c10, offsetX: p6, offsetY: m7, transform: { type: "cim-marker-transform-param", params: y3 }, color: this._getValueOrOverrideExpression(u11, d4, "TintColor", g3), anchorPoint: { x: k2.x, y: k2.y }, isAbsoluteAnchorPoint: "Relative" !== e13.anchorPointUnits, outlineColor: [0, 0, 0, 0], outlineWidth: 0, frameHeight: 0, widthRatio: 1, rotateClockwise: !!e13.rotateClockwise, referenceSize: l11, sizeRatio: 1, isOutline: h13, markerPlacement: i12, animatedSymbolProperties: S });
  }
  _analyzeVectorMarker(e13, r14, t15, i12, o14, a9, s12, l11, n12, c10, p6, m7, y3, f10) {
    const h13 = e13.markerGraphics;
    if (!h13)
      return;
    const d4 = e13.frame;
    let u11 = 0;
    if (u11 = d4 ? d4.ymax - d4.ymin : a9, u11) {
      const r15 = { offsetX: n12, offsetY: c10, rotation: l11, size: s12, frameHeight: u11, rotateClockWise: !!e13.rotateClockwise };
      p6 = [...p6, r15];
    }
    t15 || (t15 = this._createMarkerPlacementOverrideExpression(e13.markerPlacement));
    for (const v3 of h13)
      if (v3) {
        const s13 = v3.symbol;
        if (!s13)
          continue;
        const l12 = v3.primitiveName;
        let n13;
        if (l12 && i12.push(l12), ("CIMPointSymbol" === s13.type || "CIMTextSymbol" === s13.type) && d4) {
          let r15 = 0, t16 = 0;
          const i13 = v3.geometry;
          "x" in i13 && "y" in i13 && (r15 += i13.x - 0.5 * (d4.xmin + d4.xmax), t16 += i13.y - 0.5 * (d4.ymin + d4.ymax));
          const o15 = e13.anchorPoint;
          o15 && ("Absolute" === e13.anchorPointUnits ? (r15 -= o15.x, t16 -= o15.y) : d4 && (r15 -= (d4.xmax - d4.xmin) * o15.x, t16 -= (d4.ymax - d4.ymin) * o15.y));
          const a10 = { offsetX: r15, offsetY: t16, rotation: 0, size: 0, frameHeight: 0, rotateClockWise: false };
          n13 = [...p6, a10];
        }
        switch (s13.type) {
          case "CIMPointSymbol":
          case "CIMLineSymbol":
          case "CIMPolygonSymbol":
            m7 || T5(s13) ? this._analyzeMultiLayerGraphicNonSDF(e13, r14, t15, null, v3, i12, o14, a9, n13 ?? p6, u11, y3, f10) : this._analyzeMultiLayerGraphic(e13, r14, t15, null, v3, i12, o14, a9, n13 ?? p6, u11, y3, f10);
            break;
          case "CIMTextSymbol":
            this._analyzeTextGraphic(r14, t15, v3, i12, o14, a9, n13 ?? p6, y3);
        }
        l12 && i12.pop();
      }
  }
  _analyzeMultiLayerGraphic(e13, r14, t15, i12, o14, a9, s12, l11, n12, c10, p6, f10) {
    const d4 = o14.symbol, u11 = d4.symbolLayers;
    if (!u11)
      return;
    let v3 = u11.length;
    if (F4(u11))
      return void this._analyzeCompositeMarkerGraphic(e13, r14, t15, i12, o14, u11, s12, l11, n12, c10, p6, f10);
    const O3 = this._resourceManager.geometryEngine, _5 = l3.applyEffects(d4.effects, o14.geometry, O3);
    if (_5)
      for (; v3--; ) {
        const d5 = u11[v3];
        if (!d5 || false === d5.enable)
          continue;
        const g3 = d5.primitiveName;
        switch (g3 && a9.push(g3), d5.type) {
          case "CIMSolidFill":
          case "CIMSolidStroke": {
            const a10 = l3.applyEffects(d5.effects, _5, O3), u12 = m3(a10);
            if (!u12)
              continue;
            const v4 = "Relative" !== e13.anchorPointUnits, [b5, C2, P5, x4] = a3(u12, e13.frame, e13.size, e13.anchorPoint, v4), z2 = "CIMSolidFill" === d5.type, L5 = { type: "sdf", geom: a10, asFill: z2 }, { path: I4 } = d5, V2 = z2 ? f2(L2(d5)) : null == I4 ? f2(T(d5)) : [0, 0, 0, 0], N4 = z2 ? [0, 0, 0, 0] : f2(T(d5)), w5 = x(d5) ?? 0;
            if (!z2 && !w5)
              break;
            const R3 = o14.primitiveName;
            let A7 = null;
            z2 && !d5.colorLocked && (A7 = this._maybeGetValueOrOverrideExpression(R3, "FillColor"));
            let G4 = null;
            z2 || d5.colorLocked || (G4 = this._maybeGetValueOrOverrideExpression(R3, "StrokeColor"));
            const X = A7 ?? this._getValueOrOverrideExpression(d5.type, g3, "Color", V2), F6 = G4 ?? this._getValueOrOverrideExpression(d5.type, g3, "Color", N4), T6 = this._maybeGetValueOrOverrideExpression(R3, "StrokeWidth") ?? this._getValueOrOverrideExpression(d5.type, g3, "Width", w5), Y2 = I4 ? { type: "sprite-rasterization-param", resource: { type: "path", path: I4, asFill: z2 }, overrides: [] } : { type: "sprite-rasterization-param", resource: L5, overrides: [] };
            this._cimLayers.push({ type: "marker", spriteRasterizationParam: Y2, colorLocked: !!d5.colorLocked || !!p6, effects: r14, scaleSymbolsProportionally: !!e13.scaleSymbolsProportionally, alignment: s12, anchorPoint: { x: C2, y: P5 }, isAbsoluteAnchorPoint: v4, size: c10, rotation: 0, offsetX: 0, offsetY: 0, scaleX: 1, transform: { type: "cim-marker-transform-param", params: n12 }, frameHeight: c10, widthRatio: x4, rotateClockwise: false, referenceSize: l11, sizeRatio: b5, color: X, outlineColor: F6, outlineWidth: T6, isOutline: f10, markerPlacement: t15, animatedSymbolProperties: i12 });
            break;
          }
          case "CIMPictureMarker":
          case "CIMVectorMarker":
            d5.markerPlacement ? this._analyzeMultiLayerGraphicNonSDF(e13, r14, t15, i12, o14, a9, s12, l11, n12, c10, !!d5.colorLocked || !!p6, f10) : this._analyzeMarker(d5, r14, t15, a9, s12, l11, false, n12, p6, f10);
            break;
          default:
            this._analyzeMultiLayerGraphicNonSDF(e13, r14, t15, i12, o14, a9, s12, l11, n12, c10, !!d5.colorLocked || !!p6, f10);
        }
        g3 && a9.pop();
      }
  }
  _analyzeTextGraphic(e13, t15, i12, o14, a9, s12, l11, c10) {
    var _a;
    const m7 = [];
    f3.findApplicableOverrides(i12, this._primitiveOverrides, m7);
    const y3 = i12.geometry;
    if (!("x" in y3) || !("y" in y3))
      return;
    const f10 = i12.symbol, d4 = w2(f10), u11 = P2(f10.fontStyleName), v3 = u6(f10.fontFamilyName);
    f10.font = { family: v3, decoration: d4, ...u11 };
    const _5 = I(f10.height, t.CIMTextSymbol.height), g3 = I(f10.angle), z2 = I(f10.offsetX), L5 = I(f10.offsetY), E4 = f2(L2(f10));
    let I4 = f2(T(f10)), V2 = x(f10) ?? 0;
    V2 || (I4 = f2(L2(f10.haloSymbol)), V2 = I(f10.haloSize));
    let N4 = false;
    if ((_a = f10.symbol) == null ? void 0 : _a.symbolLayers)
      for (const r14 of f10.symbol.symbolLayers) {
        null != f2(L2(r14)) && (N4 = !!r14.colorLocked);
      }
    const w5 = i12.primitiveName;
    let R3 = null;
    N4 || (R3 = this._maybeGetValueOrOverrideExpression(w5, "FillColor"));
    const A7 = this._maybeGetValueOrOverrideExpression(w5, "TextSize"), G4 = this._maybeGetValueOrOverrideExpression(w5, "TextAngle"), X = this._maybeGetValueOrOverrideExpression(w5, "TextOffsetX"), F6 = this._maybeGetValueOrOverrideExpression(w5, "TextOffsetY");
    let T6 = null, Y2 = null, j4 = 0;
    if (f10.callout && "CIMBackgroundCallout" === f10.callout.type) {
      const e14 = f10.callout;
      if (e14.backgroundSymbol) {
        const r14 = e14.backgroundSymbol.symbolLayers;
        if (r14)
          for (const e15 of r14)
            "CIMSolidFill" === e15.type ? T6 = f2(e15.color) : "CIMSolidStroke" === e15.type && (Y2 = f2(e15.color), j4 = I(e15.width, t.CIMSolidStroke.width));
      }
    }
    const W = this._getValueOrOverrideExpression(f10.type, i12.primitiveName, "TextString", i12.textString ?? "");
    if (null == W)
      return;
    const { fontStyleName: D4 } = f10, H = v3 + (D4 ? "-" + D4.toLowerCase() : "-regular"), U3 = this._getMaterialOverrides(o14, f10.type);
    U3.push(...this._getPrimitiveMaterialOverrides(i12.primitiveName, f10.type));
    const J2 = { type: "text-rasterization-param", resource: { type: "text", textString: i12.textString ?? "", font: f10.font, symbol: f10, primitiveName: i12.primitiveName }, overrides: U3 };
    this._cimLayers.push({ type: "text", lineWidth: null, textRasterizationParam: J2, colorLocked: !!c10 || !!N4, effects: e13, alignment: a9, anchorPoint: { x: 0, y: 0 }, isAbsoluteAnchorPoint: false, fontName: H, decoration: d4, weight: u11.weight, style: u11.style, size: A7 ?? _5, angle: G4 ?? g3, offsetX: X ?? z2, offsetY: F6 ?? L5, transform: { type: "cim-marker-transform-param", params: l11 }, horizontalAlignment: A2(f10.horizontalAlignment), verticalAlignment: F(f10.verticalAlignment), text: W, color: R3 ?? this._getValueOrOverrideExpression(f10.type, i12.primitiveName, "Color", E4), outlineColor: I4, outlineSize: V2, backgroundColor: T6, borderLineColor: Y2, borderLineWidth: j4, referenceSize: s12, sizeRatio: 1, markerPlacement: t15 });
  }
  _analyzeMultiLayerGraphicNonSDF(e13, r14, t15, i12, a9, s12, n12, c10, p6, m7, y3, f10) {
    const h13 = R2(e13, a9), d4 = e13.primitiveName, u11 = A4(this._analyzeMaterialOverrides(d4, ["Rotation", "OffsetX", "OffsetY"])), [v3, O3, _5] = K.getTextureAnchor(h13, this._resourceManager), g3 = this._getMaterialOverrides(s12, e13.type);
    g3.push(...u11);
    const S = { type: "sprite-rasterization-param", resource: { ...h13, avoidSDFRasterization: true }, overrides: g3 };
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: S, colorLocked: y3, effects: r14, scaleSymbolsProportionally: !!e13.scaleSymbolsProportionally, alignment: n12, anchorPoint: { x: v3, y: O3 }, isAbsoluteAnchorPoint: false, size: m7, rotation: 0, offsetX: 0, offsetY: 0, transform: { type: "cim-marker-transform-param", params: p6 }, color: [255, 255, 255, 1], outlineColor: [0, 0, 0, 0], outlineWidth: 0, scaleX: 1, frameHeight: m7, widthRatio: 1, rotateClockwise: !!e13.rotateClockwise, referenceSize: c10, sizeRatio: _5 / u4(e13.size), isOutline: f10, markerPlacement: t15, animatedSymbolProperties: i12 });
  }
  _createMarkerPlacementOverrideExpression(e13) {
    if (!e13)
      return null;
    const r14 = [];
    return f3.findApplicableOverrides(e13, this._primitiveOverrides, r14), { type: "cim-marker-placement-info", placement: e13, overrides: Y(r14) };
  }
  _createAnimatedSymbolPropertiesOverrideExpression(e13) {
    if (!e13)
      return null;
    const r14 = [];
    return f3.findApplicableOverrides(e13, this._primitiveOverrides, r14), { type: "cim-animation-info", animation: e13, overrides: Y(r14) };
  }
  _analyzeCompositeMarkerGraphic(e13, r14, t15, i12, o14, a9, s12, l11, c10, p6, f10, d4) {
    const u11 = o14.geometry, v3 = a9[0], _5 = a9[1], g3 = m3(u11);
    if (!g3)
      return;
    const S = "Relative" !== e13.anchorPointUnits, [k2, M4, b5, C2] = a3(g3, e13.frame, e13.size, e13.anchorPoint, S), { path: P5 } = _5, x4 = _5.primitiveName, z2 = v3.primitiveName, L5 = o14.primitiveName;
    let E4 = null;
    _5.colorLocked || f10 || (E4 = this._maybeGetValueOrOverrideExpression(L5, "FillColor"));
    const I4 = E4 ?? this._getValueOrOverrideExpression(_5.type, x4, "Color", f2(_5.color));
    let V2 = null;
    v3.colorLocked || f10 || (V2 = this._maybeGetValueOrOverrideExpression(L5, "StrokeColor"));
    const N4 = V2 ?? this._getValueOrOverrideExpression(v3.type, z2, "Color", f2(v3.color)), w5 = this._maybeGetValueOrOverrideExpression(L5, "StrokeWidth") ?? this._getValueOrOverrideExpression(v3.type, z2, "Width", I(v3.width, t.CIMSolidStroke.width)), R3 = { type: "sprite-rasterization-param", resource: P5 ? { type: "path", path: P5, asFill: true } : { type: "sdf", geom: u11, asFill: true }, overrides: [] };
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: R3, colorLocked: f10, effects: r14, scaleSymbolsProportionally: !!e13.scaleSymbolsProportionally, alignment: s12, anchorPoint: { x: M4, y: b5 }, isAbsoluteAnchorPoint: S, size: p6, rotation: 0, offsetX: 0, offsetY: 0, scaleX: 1, transform: { type: "cim-marker-transform-param", params: c10 }, frameHeight: p6, widthRatio: C2, rotateClockwise: false, referenceSize: l11, sizeRatio: k2, color: I4, outlineColor: N4, outlineWidth: w5, isOutline: d4, markerPlacement: t15, animatedSymbolProperties: i12 });
  }
  _setPoMap(e13, r14, t15) {
    let i12;
    this._poMap[e13] ? i12 = this._poMap[e13] : (i12 = {}, this._poMap[e13] = i12), i12[r14] = t15;
  }
  _maybeGetValueOrOverrideExpression(e13, r14, t15) {
    return this._getValueOrOverrideExpression("", e13, r14, t15, false);
  }
  _getValueOrOverrideExpression(e13, r14, t15, i12, o14 = true) {
    if (o14 && !E(i12) && (i12 = D(e13, t15.toLowerCase())), null == r14)
      return i12;
    const a9 = this._poMap[r14];
    if (null == a9)
      return i12;
    const s12 = a9[t15];
    return "string" == typeof s12 || "number" == typeof s12 || Array.isArray(s12) ? s12 : s12 ? { valueExpressionInfo: s12, defaultValue: i12 } : i12;
  }
  _analyzePrimitiveOverrides(e13, r14, t15, i12) {
    if (null == e13)
      return false;
    "string" == typeof e13 && (e13 = [e13]);
    for (const o14 of this._primitiveOverrides)
      if (e13.includes(o14.primitiveName) && o14.valueExpressionInfo)
        return true;
    if (null != r14) {
      for (const o14 of r14)
        if ((o14 == null ? void 0 : o14.overrides.length) > 0)
          return true;
    }
    if (null != t15) {
      for (const o14 of t15)
        if ((o14 == null ? void 0 : o14.overrides.length) > 0)
          return true;
    }
    if (null != i12) {
      for (const o14 of i12)
        if ((o14 == null ? void 0 : o14.overrides.length) > 0)
          return true;
    }
    return false;
  }
  _getMaterialOverrides(e13, r14) {
    if (!e13)
      return [];
    const t15 = [];
    for (const i12 of e13)
      t15.push(...this._getPrimitiveMaterialOverrides(i12, r14));
    return t15;
  }
  _getPrimitiveMaterialOverrides(e13, r14) {
    if (!e13)
      return [];
    const t15 = A4(this._primitiveOverrides.filter((r15) => r15.primitiveName === e13));
    return t15.forEach((e14) => e14.defaultValue = D(r14, e14.propertyName.toLowerCase())), t15;
  }
  _analyzeMaterialOverrides(e13, r14) {
    return this._primitiveOverrides.filter((t15) => t15.primitiveName !== e13 || !r14.includes(t15.propertyName));
  }
};
function R2(e13, r14) {
  return { type: e13.type, enable: true, name: e13.name, colorLocked: e13.colorLocked, primitiveName: e13.primitiveName, anchorPoint: e13.anchorPoint, anchorPointUnits: e13.anchorPointUnits, offsetX: 0, offsetY: 0, rotateClockwise: e13.rotateClockwise, rotation: 0, size: e13.size, billboardMode3D: e13.billboardMode3D, depth3D: e13.depth3D, frame: e13.frame, markerGraphics: [r14], scaleSymbolsProportionally: e13.scaleSymbolsProportionally, respectFrame: e13.respectFrame, clippingPath: e13.clippingPath };
}
function A4(e13) {
  return e13.map((e14) => ({ ...e14, propertyName: z(e14.propertyName) }));
}
function G2(e13) {
  if (e13 && 0 === e13.indexOf("Level_")) {
    const r14 = parseInt(e13.substr(6), 10);
    if (!isNaN(r14))
      return r14;
  }
  return 0;
}
var F4 = (e13) => e13 && 2 === e13.length && e13[0].enable && e13[1].enable && "CIMSolidStroke" === e13[0].type && "CIMSolidFill" === e13[1].type && null == e13[0].path && null == e13[1].path && !e13[0].effects && !e13[1].effects;
function T5(e13) {
  const r14 = e13.symbolLayers;
  if (!r14 || 2 !== r14.length)
    return false;
  const t15 = r14.find((e14) => {
    var _a;
    return (_a = e14.effects) == null ? void 0 : _a.find((e15) => "CIMGeometricEffectDashes" === e15.type && null != e15.dashTemplate);
  }), i12 = r14.find((e14) => {
    var _a;
    return (_a = e14.effects) == null ? void 0 : _a.find((e15) => "CIMGeometricEffectAddControlPoints" === e15.type);
  });
  return !!t15 || !!i12;
}
function Y(e13) {
  return a(e13).map((e14) => ({ ...e14, propertyName: z(e14.propertyName) }));
}

// node_modules/@arcgis/core/views/2d/engine/ManagedCanvas.js
var l5 = class {
  constructor(s12) {
    this.events = new o3(), this._hasMajorPerformanceCaveat = false, this._lastRenderFrameCounter = 0, this._canvas = document.createElement("canvas"), this._canvas.setAttribute("style", "width: 100%; height:100%; display:block; willChange:transform");
    const r14 = { failIfMajorPerformanceCaveat: true, alpha: true, antialias: false, depth: true, stencil: true };
    s12.appendChild(this._canvas);
    let i12 = t5(this._canvas, r14);
    i12 || (i12 = t5(this._canvas, { ...r14, failIfMajorPerformanceCaveat: false }), this._hasMajorPerformanceCaveat = true), this._gl = i12, this._handles = o([o2(this._canvas, "webglcontextlost", (e13) => this.events.emit("webgl-context-lost", e13))]);
  }
  destroy() {
    var _a;
    (_a = this._canvas.parentNode) == null ? void 0 : _a.removeChild(this._canvas), this._canvas = null, this._handles.remove(), this._gl = null;
  }
  get gl() {
    return this._gl;
  }
  render(e13, t15) {
    if (this._hasMajorPerformanceCaveat || has("esri-force-performance-mode")) {
      if (++this._lastRenderFrameCounter >= has("esri-performance-mode-frames-between-render") && (t15(), this._lastRenderViewState = e13.state.clone(), this._lastRenderFrameCounter = 0), this._lastRenderViewState) {
        const [t16, a9, s12, r14, i12, o14] = this._computeViewTransform(this._lastRenderViewState, e13.state);
        this._canvas.style.transform = `matrix(${t16}, ${a9}, ${s12}, ${r14}, ${i12}, ${o14})`;
      }
    } else
      t15();
  }
  resize(e13) {
    const t15 = this._canvas, a9 = t15.style, { state: { size: s12 }, pixelRatio: r14 } = e13, i12 = s12[0], o14 = s12[1], n12 = Math.round(i12 * r14), h13 = Math.round(o14 * r14);
    t15.width === n12 && t15.height === h13 || (t15.width = n12, t15.height = h13), a9.width = i12 + "px", a9.height = o14 + "px";
  }
  _computeViewTransform(e13, t15) {
    const [a9, c10] = e13.center, [l11, m7] = t15.center, [d4, f10] = e13.toScreen([0, 0], l11, m7), [_5, v3] = e13.toScreen([0, 0], a9, c10), p6 = _5 - d4, g3 = v3 - f10, w5 = e13.scale / t15.scale, u11 = t15.rotation - e13.rotation, j4 = e5();
    return a2(j4), c2(j4, j4, [w5, w5]), s4(j4, j4, h(u11)), i3(j4, j4, [p6, g3]), j4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/BitBlitRenderer.js
var _2 = class {
  constructor() {
    this._initialized = false;
  }
  dispose() {
    this._program = r3(this._program), this._vertexArrayObject = r3(this._vertexArrayObject);
  }
  render(r14, t15, e13, i12) {
    r14 && (this._initialized || this._initialize(r14), r14.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), r14.bindVAO(this._vertexArrayObject), r14.useProgram(this._program), t15.setSamplingMode(e13), r14.bindTexture(t15, 0), this._program.setUniform1i("u_tex", 0), this._program.setUniform1f("u_opacity", i12), r14.drawArrays(E2.TRIANGLE_STRIP, 0, 4), r14.bindTexture(null, 0), r14.bindVAO());
  }
  _initialize(r14) {
    if (this._initialized)
      return true;
    const s12 = e6(r14, e9);
    if (!s12)
      return false;
    const o14 = new Int8Array(16);
    o14[0] = -1, o14[1] = -1, o14[2] = 0, o14[3] = 0, o14[4] = 1, o14[5] = -1, o14[6] = 1, o14[7] = 0, o14[8] = -1, o14[9] = 1, o14[10] = 0, o14[11] = 1, o14[12] = 1, o14[13] = 1, o14[14] = 1, o14[15] = 1;
    const _5 = e9.attributes, p6 = new o8(r14, _5, t7, { geometry: h5.createVertex(r14, F2.STATIC_DRAW, o14) });
    return this._program = s12, this._vertexArrayObject = p6, this._initialized = true, true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MaterialManager.js
var e12 = class {
  constructor(r14) {
    this._rctx = r14, this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((r14) => r14.dispose()), this._programByKey.clear();
  }
  getProgram(e13, t15 = []) {
    const a9 = e13.vsPath + "." + e13.fsPath + JSON.stringify(t15);
    if (this._programByKey.has(a9))
      return this._programByKey.get(a9);
    const s12 = { ...t15.map((r14) => "string" == typeof r14 ? { name: r14, value: true } : r14).reduce((r14, e14) => ({ ...r14, [e14.name]: e14.value }), {}) }, { vsPath: o14, fsPath: h13, attributes: i12 } = e13, g3 = o10(o14, h13, i12, s12), m7 = this._rctx.programCache.acquire(g3.shaders.vertexShader, g3.shaders.fragmentShader, g3.attributes);
    if (!m7)
      throw new Error("Unable to get program for key: ${key}");
    return this._programByKey.set(a9, m7), m7;
  }
};

// node_modules/@arcgis/core/symbols/cim/Rasterizer.js
var o11 = 512;
var c4 = class {
  constructor(e13) {
    this._resourceManager = e13, this._cachedRasterizationCanvas = null;
  }
  dispose() {
    this._cachedRasterizationCanvas = null;
  }
  get _canvas() {
    return this._cachedRasterizationCanvas || (this._cachedRasterizationCanvas = document.createElement("canvas")), this._cachedRasterizationCanvas;
  }
  rasterizeJSONResource(e13, a9) {
    switch (e13.type) {
      case "dash": {
        const r14 = e13.dashTemplate, a10 = e13.capStyle, [s12, n12, i12] = i8(r14, a10);
        return { size: [n12, i12], image: new Uint32Array(s12.buffer), sdf: true, simplePattern: true, anchorX: 0, anchorY: 0 };
      }
      case "fill-style": {
        const [t15, s12, n12, i12] = e10(this._canvas, e13, a9);
        return { size: [s12, n12], image: new Uint32Array(t15.buffer), sdf: false, simplePattern: true, anchorX: 0, anchorY: 0, rasterizationScale: i12 };
      }
      case "sdf":
        return l6(e13);
      case "CIMHatchFill":
      case "CIMVectorMarker":
      case "CIMPictureMarker":
        return this._rasterizeCIMJSONResource(e13, a9);
    }
  }
  _rasterizeCIMJSONResource(r14, t15) {
    var _a;
    switch (r14.type) {
      case "CIMHatchFill": {
        const a9 = K.fromCIMHatchFill(r14, t15);
        return this._rasterizeCIMVectorMarker(a9);
      }
      case "CIMPictureMarker": {
        const t16 = K.fromCIMInsidePolygon(r14);
        return this._rasterizeCIMVectorMarker(t16);
      }
      case "CIMVectorMarker": {
        if ("CIMMarkerPlacementInsidePolygon" === ((_a = r14.markerPlacement) == null ? void 0 : _a.type)) {
          const t17 = K.fromCIMInsidePolygon(r14);
          return this._rasterizeCIMVectorMarker(t17);
        }
        const t16 = l4(r14);
        return t16 && !r14.avoidSDFRasterization ? l6(t16) : this._rasterizeCIMVectorMarker(r14, false);
      }
    }
  }
  _rasterizeCIMVectorMarker(r14, t15 = true) {
    const s12 = t15 ? t3.fromExtent(r14.frame) : null, [n12, i12, o14, c10, l11] = K.rasterize(this._canvas, r14, s12, this._resourceManager);
    return n12 ? { size: [i12, o14], image: new Uint32Array(n12.buffer), sdf: false, simplePattern: false, anchorX: c10, anchorY: l11 } : null;
  }
  rasterizeImageResource(e13, r14, t15, a9) {
    this._canvas.width = e13, this._canvas.height = r14;
    const s12 = this._canvas.getContext("2d", { willReadFrequently: true });
    t15 instanceof ImageData ? s12.putImageData(t15, 0, 0) : (t15.setAttribute("width", `${e13}px`), t15.setAttribute("height", `${r14}px`), s12.drawImage(t15, 0, 0, e13, r14));
    const n12 = s12.getImageData(0, 0, e13, r14), c10 = new Uint8Array(n12.data);
    if (a9) {
      for (const i12 of a9)
        if (i12 && i12.oldColor && 4 === i12.oldColor.length && i12.newColor && 4 === i12.newColor.length) {
          const [e14, r15, t16, a10] = i12.oldColor, [s13, n13, o14, l12] = i12.newColor;
          if (e14 === s13 && r15 === n13 && t16 === o14 && a10 === l12)
            continue;
          for (let i13 = 0; i13 < c10.length; i13 += 4)
            e14 === c10[i13] && r15 === c10[i13 + 1] && t16 === c10[i13 + 2] && a10 === c10[i13 + 3] && (c10[i13] = s13, c10[i13 + 1] = n13, c10[i13 + 2] = o14, c10[i13 + 3] = l12);
        }
    }
    let l11;
    for (let i12 = 0; i12 < c10.length; i12 += 4)
      l11 = c10[i12 + 3] / 255, c10[i12] = c10[i12] * l11, c10[i12 + 1] = c10[i12 + 1] * l11, c10[i12 + 2] = c10[i12 + 2] * l11;
    let h13 = c10, u11 = e13, f10 = r14;
    const m7 = o11;
    if (u11 >= m7 || f10 >= m7) {
      const t16 = u11 / f10;
      t16 > 1 ? (u11 = m7, f10 = Math.round(m7 / t16)) : (f10 = m7, u11 = Math.round(m7 * t16)), h13 = new Uint8Array(4 * u11 * f10);
      const a10 = new Uint8ClampedArray(h13.buffer);
      u5(c10, e13, r14, a10, u11, f10, false);
    }
    return { size: [u11, f10], image: new Uint32Array(h13.buffer), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0 };
  }
};
function l6(e13) {
  if (!e13)
    return null;
  const [r14, t15, a9] = c3(e13);
  return r14 ? { size: [t15, a9], image: new Uint32Array(r14.buffer), sdf: true, simplePattern: true, anchorX: 0, anchorY: 0 } : null;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/RectangleBinPack.js
var t11 = class {
  constructor(t15, e13) {
    this._width = 0, this._height = 0, this._free = [], this._width = t15, this._height = e13, this._free.push(new t4(0, 0, t15, e13));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(t15, e13) {
    if (t15 > this._width || e13 > this._height)
      return new t4();
    let i12 = null, s12 = -1;
    for (let h13 = 0; h13 < this._free.length; ++h13) {
      const r14 = this._free[h13];
      t15 <= r14.width && e13 <= r14.height && (null === i12 || r14.y <= i12.y && r14.x <= i12.x) && (i12 = r14, s12 = h13);
    }
    return null === i12 ? new t4() : (this._free.splice(s12, 1), i12.width < i12.height ? (i12.width > t15 && this._free.push(new t4(i12.x + t15, i12.y, i12.width - t15, e13)), i12.height > e13 && this._free.push(new t4(i12.x, i12.y + e13, i12.width, i12.height - e13))) : (i12.width > t15 && this._free.push(new t4(i12.x + t15, i12.y, i12.width - t15, i12.height)), i12.height > e13 && this._free.push(new t4(i12.x, i12.y + e13, t15, i12.height - e13))), new t4(i12.x, i12.y, t15, e13));
  }
  release(h13) {
    for (let t15 = 0; t15 < this._free.length; ++t15) {
      const e13 = this._free[t15];
      if (e13.y === h13.y && e13.height === h13.height && e13.x + e13.width === h13.x)
        e13.width += h13.width;
      else if (e13.x === h13.x && e13.width === h13.width && e13.y + e13.height === h13.y)
        e13.height += h13.height;
      else if (h13.y === e13.y && h13.height === e13.height && h13.x + h13.width === e13.x)
        e13.x = h13.x, e13.width += h13.width;
      else {
        if (h13.x !== e13.x || h13.width !== e13.width || h13.y + h13.height !== e13.y)
          continue;
        e13.y = h13.y, e13.height += h13.height;
      }
      this._free.splice(t15, 1), this.release(h13);
    }
    this._free.push(h13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphMosaic.js
var n6 = 256;
var o12 = (t15) => Math.floor(t15 / 256);
function c5(t15) {
  const e13 = /* @__PURE__ */ new Set();
  for (const i12 of t15)
    e13.add(o12(i12));
  return e13;
}
function l7(e13, i12, h13) {
  return e13.has(i12) || e13.set(i12, h13().then(() => {
    e13.delete(i12);
  }).catch((h14) => {
    e13.delete(i12), f(h14);
  })), e13.get(i12);
}
var g = (t15) => ({ rect: new t4(0, 0, 0, 0), page: 0, metrics: { left: 0, width: 0, height: 0, advance: 0, top: 0 }, code: t15, sdf: true });
var p4 = class {
  constructor(t15, e13, h13) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphCache = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this._preloadCache = {}, this.width = t15, this.height = e13, this._glyphSource = h13, this._binPack = new t11(t15 - 4, e13 - 4), this._glyphData.push(new Uint8Array(t15 * e13)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs();
  }
  dispose() {
    this._binPack = null;
    for (const t15 of this._textures)
      t15 && t15.dispose();
    this._textures.length = 0, this._glyphData.length = 0;
  }
  _initDecorationGlyphs() {
    const t15 = [117, 149, 181, 207, 207, 181, 149, 117], e13 = [], i12 = [];
    for (let r14 = 0; r14 < t15.length; r14++) {
      const h14 = t15[r14];
      for (let t16 = 0; t16 < 11; t16++) {
        const s13 = r14 >= 3 && r14 < 5 && t16 >= 3 && t16 < 8 ? 255 : 0;
        e13.push(h14), i12.push(s13);
      }
    }
    const h13 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(e13) }, s12 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(i12) };
    this._recordGlyph(h13), this._recordGlyph(s12);
  }
  getTexture(t15, e13) {
    if (!this._textures[e13]) {
      const i12 = new e4();
      i12.pixelFormat = G.ALPHA, i12.wrapMode = D2.CLAMP_TO_EDGE, i12.width = this.width, i12.height = this.height, this._textures[e13] = new m2(t15, i12, new Uint8Array(this.width * this.height));
    }
    return this._dirties[e13] && (this._textures[e13].setData(this._glyphData[e13]), this._dirties[e13] = false), this._textures[e13];
  }
  async getGlyphItems(t15, e13, i12) {
    const h13 = this._getGlyphCache(t15);
    return await this._fetchRanges(t15, e13, i12), e13.map((e14) => this._getMosaicItem(h13, t15, e14));
  }
  bind(t15, e13, i12, h13) {
    const s12 = this.getTexture(t15, i12);
    s12.setSamplingMode(e13), t15.bindTexture(s12, h13);
  }
  preloadASCIIGlyphCache(t15) {
    const e13 = this._preloadCache[t15];
    if (null != e13)
      return e13;
    const i12 = this._glyphSource.preloadASCIIRange(t15).then(() => {
      const e14 = this._getGlyphCache(t15);
      for (let i13 = 0; i13 < 256; i13++)
        this._getMosaicItem(e14, t15, i13);
    });
    return this._preloadCache[t15] = i12, i12;
  }
  _getGlyphCache(t15) {
    return this._glyphCache[t15] || (this._glyphCache[t15] = {}), this._glyphCache[t15];
  }
  _invalidate() {
    this._dirties[this._currentPage] = true;
  }
  async _fetchRanges(t15, e13, i12) {
    const h13 = c5(e13), s12 = [];
    h13.forEach((e14) => {
      s12.push(this._fetchRange(t15, e14, i12));
    }), await Promise.all(s12);
  }
  async _fetchRange(t15, e13, i12) {
    if (e13 > n6)
      return;
    const h13 = t15 + e13;
    return l7(this._rangePromises, h13, () => this._glyphSource.getRange(t15, e13, i12));
  }
  _getMosaicItem(t15, e13, i12) {
    if (!t15[i12]) {
      const h13 = this._glyphSource.getGlyph(e13, i12);
      if (!(h13 == null ? void 0 : h13.metrics))
        return g(i12);
      const s12 = this._recordGlyph(h13), r14 = this._currentPage, a9 = h13.metrics;
      t15[i12] = { rect: s12, page: r14, metrics: a9, code: i12, sdf: true }, this._invalidate();
    }
    return t15[i12];
  }
  _recordGlyph(t15) {
    const h13 = t15.metrics;
    let s12;
    if (0 === h13.width)
      s12 = new t4(0, 0, 0, 0);
    else {
      const e13 = 3, r14 = h13.width + 2 * e13, a9 = h13.height + 2 * e13;
      s12 = this._binPack.allocate(r14, a9), s12.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs(), this._binPack = new t11(this.width - 4, this.height - 4), s12 = this._binPack.allocate(r14, a9));
      const n12 = this._glyphData[this._currentPage], o14 = t15.bitmap;
      let c10, l11;
      if (o14)
        for (let t16 = 0; t16 < a9; t16++) {
          c10 = r14 * t16, l11 = this.width * (s12.y + t16) + s12.x;
          for (let t17 = 0; t17 < r14; t17++)
            n12[l11 + t17] = o14[c10 + t17];
        }
      has("esri-glyph-debug") && this._showDebugPage(n12);
    }
    return s12;
  }
  _showDebugPage(t15) {
    const e13 = document.createElement("canvas"), i12 = e13.getContext("2d"), h13 = new ImageData(this.width, this.height), s12 = h13.data;
    e13.width = this.width, e13.height = this.height, e13.style.border = "1px solid black";
    for (let r14 = 0; r14 < t15.length; ++r14)
      s12[4 * r14] = t15[r14], s12[4 * r14 + 1] = 0, s12[4 * r14 + 2] = 0, s12[4 * r14 + 3] = 255;
    i12.putImageData(h13, 0, 0), document.body.appendChild(e13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphSource.js
var a6 = class {
  constructor(e13) {
    for (this._metrics = [], this._bitmaps = []; e13.next(); )
      switch (e13.tag()) {
        case 1: {
          const t15 = e13.getMessage();
          for (; t15.next(); )
            switch (t15.tag()) {
              case 3: {
                const e14 = t15.getMessage();
                let a9, s12, r14, n12, i12, c10, g3;
                for (; e14.next(); )
                  switch (e14.tag()) {
                    case 1:
                      a9 = e14.getUInt32();
                      break;
                    case 2:
                      s12 = e14.getBytes();
                      break;
                    case 3:
                      r14 = e14.getUInt32();
                      break;
                    case 4:
                      n12 = e14.getUInt32();
                      break;
                    case 5:
                      i12 = e14.getSInt32();
                      break;
                    case 6:
                      c10 = e14.getSInt32();
                      break;
                    case 7:
                      g3 = e14.getUInt32();
                      break;
                    default:
                      e14.skip();
                  }
                e14.release(), a9 && (this._metrics[a9] = { width: r14, height: n12, left: i12, top: c10, advance: g3 }, this._bitmaps[a9] = s12);
                break;
              }
              default:
                t15.skip();
            }
          t15.release();
          break;
        }
        default:
          e13.skip();
      }
  }
  getMetrics(e13) {
    return this._metrics[e13];
  }
  getBitmap(e13) {
    return this._bitmaps[e13];
  }
};
var s9 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e13) {
    return this._ranges[e13];
  }
  addRange(e13, t15) {
    this._ranges[e13] = t15;
  }
};
var r8 = class {
  constructor(e13) {
    this._glyphInfo = {}, this._baseURL = e13;
  }
  getRange(s12, r14, n12) {
    const i12 = this._getFontStack(s12);
    if (i12.getRange(r14))
      return Promise.resolve();
    const c10 = 256 * r14, g3 = c10 + 255, o14 = this._baseURL.replace("{fontstack}", s12).replace("{range}", c10 + "-" + g3);
    return U(o14, { responseType: "array-buffer", ...n12 }).then((e13) => {
      i12.addRange(r14, new a6(new n3(new Uint8Array(e13.data), new DataView(e13.data))));
    });
  }
  async preloadASCIIRange(s12) {
    const r14 = this._getFontStack(s12), n12 = 0, i12 = 255, c10 = this._baseURL.replace("{fontstack}", s12).replace("{range}", n12 + "-" + i12), g3 = await U(c10, { responseType: "array-buffer" }), o14 = new a6(new n3(new Uint8Array(g3.data), new DataView(g3.data)));
    for (let e13 = n12; e13 <= i12; e13++)
      r14.getRange(e13) || r14.addRange(e13, o14);
  }
  getGlyph(e13, t15) {
    const a9 = this._getFontStack(e13);
    if (!a9)
      return;
    const s12 = Math.floor(t15 / 256), r14 = a9.getRange(s12);
    return r14 ? { metrics: r14.getMetrics(t15), bitmap: r14.getBitmap(t15) } : void 0;
  }
  _getFontStack(e13) {
    let t15 = this._glyphInfo[e13];
    return t15 || (t15 = this._glyphInfo[e13] = new s9()), t15;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SDFConverter.js
var s10 = 1e20;
var r9 = class {
  constructor(t15, e13 = 2) {
    this._textureSize = t15, this._rasterizationScale = e13, this._canvasSize = this._textureSize * this._rasterizationScale, this._svg = null;
    const { _canvasSize: i12 } = this, s12 = document.createElement("canvas");
    s12.width = s12.height = i12, this._context = s12.getContext("2d", { willReadFrequently: false }), this._gridOuter = new Float64Array(i12 * i12), this._gridInner = new Float64Array(i12 * i12), this._f = new Float64Array(i12), this._d = new Float64Array(i12), this._z = new Float64Array(i12 + 1), this._v = new Int16Array(i12);
  }
  dispose() {
    this._context = this._gridOuter = this._gridInner = this._f = this._d = this._z = this._v = null, this._svg && (document.body.removeChild(this._svg), this._svg = null);
  }
  draw(r14, n12, o14) {
    const { _canvasSize: h13, _textureSize: a9, _rasterizationScale: l11 } = this, d4 = a9 / 4;
    this._initSVG();
    const _5 = this.createSVGString(r14, n12);
    return new Promise((r15, n13) => {
      const c10 = new Image();
      c10.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(_5), c10.onload = () => {
        c10.onload = null, this._context.clearRect(0, 0, h13, h13), this._context.drawImage(c10, 0, 0, h13, h13);
        const e13 = this._context.getImageData(0, 0, h13, h13), i12 = new Uint8Array(a9 * a9 * 4);
        for (let t15 = 0; t15 < h13 * h13; t15++) {
          const i13 = e13.data[4 * t15 + 3] / 255;
          this._gridOuter[t15] = 1 === i13 ? 0 : 0 === i13 ? s10 : Math.max(0, 0.5 - i13) ** 2, this._gridInner[t15] = 1 === i13 ? s10 : 0 === i13 ? 0 : Math.max(0, i13 - 0.5) ** 2;
        }
        this._edt(this._gridOuter, h13, h13), this._edt(this._gridInner, h13, h13);
        for (let s12 = 0; s12 < a9 * a9; s12++) {
          let e14 = 0;
          for (let t15 = 0; t15 < l11; t15++) {
            const i13 = Math.floor(s12 / a9) * l11 + t15;
            for (let t16 = 0; t16 < l11; t16++) {
              const r16 = i13 * h13 + (s12 % a9 * l11 + t16);
              e14 += this._gridOuter[r16] - this._gridInner[r16];
            }
          }
          e14 /= l11 * l11, e14 /= l11;
          o7(0.5 - e14 / (2 * d4), i12, 4 * s12);
        }
        r15(i12);
      };
      const g3 = o14 == null ? void 0 : o14.signal;
      g3 && m(g3, () => n13(u2()));
    });
  }
  _initSVG() {
    if (!this._svg) {
      const t15 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t15.setAttribute("style", "position: absolute;"), t15.setAttribute("width", "0"), t15.setAttribute("height", "0"), t15.setAttribute("aria-hidden", "true"), t15.setAttribute("role", "presentation"), document.body.appendChild(t15), this._svg = t15;
    }
    return this._svg;
  }
  createSVGString(t15, e13) {
    const i12 = this._initSVG(), s12 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    s12.setAttribute("d", t15), i12.appendChild(s12);
    const r14 = s12.getBBox(), n12 = r14.width / r14.height, o14 = this._canvasSize / 2;
    let h13, a9, l11;
    if (n12 > 1) {
      h13 = o14 / r14.width;
      const t16 = o14 * (1 / n12);
      a9 = this._canvasSize / 4, l11 = o14 - t16 / 2;
    } else {
      h13 = o14 / r14.height;
      a9 = o14 - o14 * n12 / 2, l11 = this._canvasSize / 4;
    }
    const d4 = -r14.x * h13 + a9, _5 = -r14.y * h13 + l11;
    s12.setAttribute("style", `transform: matrix(${h13}, 0, 0, ${h13}, ${d4}, ${_5})`), s12.setAttribute("stroke-width", "" + 0.5 / h13);
    const c10 = `<svg style="fill:${e13 ? "red" : "none"}; stroke:${e13 ? "none" : "red"}" height="${this._canvasSize}" width="${this._canvasSize}" xmlns="http://www.w3.org/2000/svg">${i12.innerHTML}</svg>`;
    return i12.removeChild(s12), c10;
  }
  _edt(t15, e13, i12) {
    const s12 = this._f, r14 = this._d, n12 = this._v, o14 = this._z;
    for (let h13 = 0; h13 < e13; h13++) {
      for (let r15 = 0; r15 < i12; r15++)
        s12[r15] = t15[r15 * e13 + h13];
      this._edt1d(s12, r14, n12, o14, i12);
      for (let s13 = 0; s13 < i12; s13++)
        t15[s13 * e13 + h13] = r14[s13];
    }
    for (let h13 = 0; h13 < i12; h13++) {
      for (let i13 = 0; i13 < e13; i13++)
        s12[i13] = t15[h13 * e13 + i13];
      this._edt1d(s12, r14, n12, o14, e13);
      for (let i13 = 0; i13 < e13; i13++)
        t15[h13 * e13 + i13] = Math.sqrt(r14[i13]);
    }
  }
  _edt1d(t15, e13, i12, r14, n12) {
    i12[0] = 0, r14[0] = -s10, r14[1] = +s10;
    for (let o14 = 1, h13 = 0; o14 < n12; o14++) {
      let e14 = (t15[o14] + o14 * o14 - (t15[i12[h13]] + i12[h13] * i12[h13])) / (2 * o14 - 2 * i12[h13]);
      for (; e14 <= r14[h13]; )
        h13--, e14 = (t15[o14] + o14 * o14 - (t15[i12[h13]] + i12[h13] * i12[h13])) / (2 * o14 - 2 * i12[h13]);
      h13++, i12[h13] = o14, r14[h13] = e14, r14[h13 + 1] = +s10;
    }
    for (let s12 = 0, o14 = 0; s12 < n12; s12++) {
      for (; r14[o14 + 1] < s12; )
        o14++;
      e13[s12] = (s12 - i12[o14]) * (s12 - i12[o14]) + t15[i12[o14]];
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SpriteMosaic.js
function c6(t15) {
  return t15 && "static" === t15.type;
}
var n7 = class _n {
  constructor(t15, e13, i12 = 0) {
    this._mosaicPages = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = /* @__PURE__ */ new Map(), this._spriteCopyQueue = [], this.pixelRatio = 1, (t15 <= 0 || e13 <= 0) && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t15, this._pageHeight = e13, i12 > 0 && (this._maxItemSize = i12), this.pixelRatio = window.devicePixelRatio || 1, this._binPack = new t11(this._pageWidth, this._pageHeight);
    const s12 = Math.floor(this._pageWidth), r14 = Math.floor(this._pageHeight);
    this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(s12 * r14) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 });
  }
  getWidth(t15) {
    return t15 >= this._mosaicPages.length ? -1 : this._mosaicPages[t15].size[0];
  }
  getHeight(t15) {
    return t15 >= this._mosaicPages.length ? -1 : this._mosaicPages[t15].size[1];
  }
  getPageTexture(t15) {
    return t15 < this._mosaicPages.length ? this._mosaicPages[t15].texture : null;
  }
  has(t15) {
    return this._mosaicRects.has(t15);
  }
  get itemCount() {
    return this._mosaicRects.size;
  }
  getSpriteItem(t15) {
    return this._mosaicRects.get(t15);
  }
  addSpriteItem(t15, i12, a9, r14, o14, h13, n12 = 1) {
    if (this._mosaicRects.has(t15))
      return this._mosaicRects.get(t15);
    let g3, p6, m7;
    if (c6(a9))
      [g3, p6, m7] = this._allocateImage(i12[0], i12[1]);
    else {
      g3 = new t4(0, 0, i12[0], i12[1]), p6 = this._mosaicPages.length;
      const t16 = void 0;
      this._mosaicPages.push({ mosaicsData: a9, size: [i12[0] + 2 * $, i12[1] + 2 * $], dirty: true, texture: t16 });
    }
    if (g3.width <= 0 || g3.height <= 0)
      return null;
    const d4 = { type: "sprite", rect: g3, width: i12[0], height: i12[1], sdf: o14, simplePattern: h13, rasterizationScale: n12, page: p6 };
    return this._mosaicRects.set(t15, d4), c6(a9) && (has("esri-mosaic-debug") && this._showDebugSprite(i12, a9.data), this._copy({ rect: g3, spriteSize: i12, spriteData: a9.data, page: p6, pageSize: m7, repeat: r14, sdf: o14 })), d4;
  }
  hasItemsToProcess() {
    return 0 !== this._spriteCopyQueue.length;
  }
  processNextItem() {
    const t15 = this._spriteCopyQueue.pop();
    t15 && this._copy(t15);
  }
  getMosaicItemPosition(t15) {
    const i12 = this.getSpriteItem(t15), s12 = i12 == null ? void 0 : i12.rect;
    if (!s12)
      return null;
    s12.width = i12.width, s12.height = i12.height;
    const a9 = i12.width, r14 = i12.height, o14 = $, h13 = this._mosaicPages[i12.page].size;
    return { size: [i12.width, i12.height], tl: [(s12.x + o14) / h13[0], (s12.y + o14) / h13[1]], br: [(s12.x + o14 + a9) / h13[0], (s12.y + o14 + r14) / h13[1]], page: i12.page };
  }
  bind(t15, e13, i12 = 0, s12 = 0) {
    const a9 = this._mosaicPages[i12], r14 = a9.mosaicsData;
    let o14 = a9.texture;
    if (o14 || (o14 = p5(t15, a9.size), a9.texture = o14), o14.setSamplingMode(e13), c6(r14))
      t15.bindTexture(o14, s12), a9.dirty && (o14.setData(new Uint8Array(r14.data.buffer)), o14.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(i12));
    else {
      r14.data.loadFrame(o14), t15.bindTexture(o14, s12), o14.generateMipmap();
    }
    a9.dirty = false;
  }
  getTexture(t15, e13 = 0) {
    const i12 = this._mosaicPages[e13], s12 = i12.mosaicsData;
    let a9 = i12.texture;
    if (a9 || (a9 = p5(t15, i12.size), i12.texture = a9), c6(s12))
      i12.dirty && (a9.setData(new Uint8Array(s12.data.buffer)), a9.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(e13));
    else {
      s12.data.loadFrame(a9), a9.generateMipmap();
    }
    return i12.dirty = false, a9;
  }
  dispose() {
    this._binPack = null;
    for (const t15 of this._mosaicPages) {
      const e13 = t15.texture;
      e13 && e13.dispose();
      const i12 = t15.mosaicsData;
      if (!c6(i12)) {
        i12.data.destroy();
      }
    }
    this._mosaicPages = null, this._mosaicRects.clear();
  }
  static _copyBits(t15, e13, i12, s12, a9, r14, o14, h13, c10, n12, g3) {
    let p6 = s12 * e13 + i12, m7 = h13 * r14 + o14;
    if (g3) {
      m7 -= r14;
      for (let o15 = -1; o15 <= n12; o15++, p6 = ((o15 + n12) % n12 + s12) * e13 + i12, m7 += r14)
        for (let e14 = -1; e14 <= c10; e14++)
          a9[m7 + e14] = t15[p6 + (e14 + c10) % c10];
    } else
      for (let d4 = 0; d4 < n12; d4++) {
        for (let e14 = 0; e14 < c10; e14++)
          a9[m7 + e14] = t15[p6 + e14];
        p6 += e13, m7 += r14;
      }
  }
  _copy(i12) {
    if (i12.page >= this._mosaicPages.length)
      return;
    const s12 = this._mosaicPages[i12.page], a9 = s12.mosaicsData;
    if (!c6(s12.mosaicsData))
      throw new s("mapview-invalid-resource", "unsuitable data type!");
    const r14 = i12.spriteData, o14 = a9.data;
    o14 && r14 || console.error("Source or target images are uninitialized!"), _n._copyBits(r14, i12.spriteSize[0], 0, 0, o14, i12.pageSize[0], i12.rect.x + $, i12.rect.y + $, i12.spriteSize[0], i12.spriteSize[1], i12.repeat), s12.dirty = true;
  }
  _allocateImage(t15, r14) {
    t15 += 2 * $, r14 += 2 * $;
    const o14 = Math.max(t15, r14);
    if (this._maxItemSize && this._maxItemSize < o14) {
      const e13 = 2 ** Math.ceil(e8(t15)), a9 = 2 ** Math.ceil(e8(r14)), o15 = new t4(0, 0, t15, r14);
      return this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(e13 * a9) }, size: [e13, a9], dirty: true, texture: void 0 }), [o15, this._mosaicPages.length - 1, [e13, a9]];
    }
    const h13 = this._binPack.allocate(t15, r14);
    if (h13.width <= 0) {
      const e13 = this._mosaicPages[this._currentPage];
      return !e13.dirty && c6(e13.mosaicsData) && (e13.mosaicsData.data = null), this._currentPage = this._mosaicPages.length, this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(this._pageWidth * this._pageHeight) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 }), this._binPack = new t11(this._pageWidth, this._pageHeight), this._allocateImage(t15, r14);
    }
    return [h13, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _showDebugSprite([t15, e13], i12) {
    const s12 = document.createElement("canvas");
    s12.width = t15, s12.height = e13, s12.setAttribute("style", `position: absolute; top: ${4 + 204 * g2++}px; right: 208px; width: 200px; height: 200px; border: 1px solid black;`);
    const a9 = s12.getContext("2d"), r14 = new ImageData(t15, e13);
    r14.data.set(new Uint8Array(i12.buffer)), a9.putImageData(r14, 0, 0), document.body.appendChild(s12);
  }
  _showDebugPage(t15) {
    const e13 = this._mosaicPages[t15], { size: [i12, s12], mosaicsData: a9 } = e13;
    if (!c6(a9))
      return void console.error("Could not show sprite mosaic debug for non-static resource");
    const r14 = `mosaicDebugPage${t15}`, o14 = document.getElementById(r14) ?? document.createElement("canvas");
    o14.id = r14, o14.width = i12, o14.height = s12, o14.setAttribute("style", `position: absolute; top: ${4 + 204 * t15}px; right: 4px; width: 200px; height: 200px; border: 1px solid black;`);
    const h13 = o14.getContext("2d"), n12 = new ImageData(i12, s12);
    n12.data.set(new Uint8Array(a9.data.buffer)), h13.putImageData(n12, 0, 0), document.body.appendChild(o14);
  }
};
var g2 = 0;
function p5(t15, e13) {
  const i12 = new e4();
  return i12.width = e13[0], i12.height = e13[1], i12.wrapMode = D2.CLAMP_TO_EDGE, new m2(t15, i12, null);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/AnimatableTextureResource.js
var a7 = class {
  constructor(t15, a9, h13, e13) {
    this._animation = t15, this._frameData = null;
    const n12 = (t16) => {
      this._frameData = t16, a9.requestRender();
    };
    this.frameCount = this._animation.frameDurations.length, this.width = this._animation.width, this.height = this._animation.height, this._playHandle = f6(this._animation, h13, e13, n12);
  }
  destroy() {
    this._playHandle.remove();
  }
  loadFrame(i12) {
    const a9 = this._frameData;
    if (null == a9)
      return;
    const h13 = "width" in a9 ? a9.width : a9.codedWidth, e13 = "height" in a9 ? a9.height : a9.codedHeight;
    i12.updateData(0, $, $, h13, e13, a9), this._frameData = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureManager.js
var P4 = "arial-unicode-ms-regular";
var b4 = () => n.getLogger("esri.views.2d.engine.webgl.TextureManager");
var v = (e13, t15, i12) => b4().error(new s(e13, t15, i12));
function j3(e13) {
  switch (e13.type) {
    case "fill-style":
    case "CIMHatchFill":
      return it;
  }
  return 1;
}
var $3 = class _$ {
  static fromMosaic(e13, t15) {
    return new _$(e13, t15.page, t15.sdf);
  }
  constructor(e13, t15, i12) {
    this.mosaicType = e13, this.page = t15, this.sdf = i12;
  }
};
var k = class {
  constructor(i12) {
    this._requestRender = i12, this._resourceManager = new i5(), this._invalidFontsMap = /* @__PURE__ */ new Map(), this._sdfConverter = new r9(Dt), this._bindingInfos = new Array(), this._hashToBindingIndex = /* @__PURE__ */ new Map(), this._ongoingRasterizations = /* @__PURE__ */ new Map(), this._imageRequestQueue = new _({ concurrency: 10, process: async (e13, i13) => {
      s2(i13);
      try {
        return await U(e13, { responseType: "image", signal: i13 });
      } catch (r14) {
        if (!b(r14))
          throw new s("mapview-invalid-resource", `Could not fetch requested resource at ${e13}`, r14);
        throw r14;
      }
    } }), this._spriteMosaic = new n7(2048, 2048, 500), this._glyphSource = new r8(`${r2.fontsUrl}/{fontstack}/{range}.pbf`), this._glyphMosaic = new p4(1024, 1024, this._glyphSource), this._rasterizer = new c4(this.resourceManager);
  }
  dispose() {
    this._spriteMosaic.dispose(), this._glyphMosaic.dispose(), this._rasterizer.dispose(), this._sdfConverter.dispose(), this._spriteMosaic = null, this._glyphMosaic = null, this._sdfConverter = null, this._hashToBindingIndex.clear(), this._hashToBindingIndex = null, this._bindingInfos = null, this._ongoingRasterizations.clear(), this._ongoingRasterizations = null, this._imageRequestQueue.clear(), this._imageRequestQueue = null, this._resourceManager.destroy();
  }
  get sprites() {
    return this._spriteMosaic;
  }
  get glyphs() {
    return this._glyphMosaic;
  }
  get resourceManager() {
    return this._resourceManager;
  }
  async rasterizeItem(e13, t15) {
    if (null == e13)
      return v("mapview-null-resource", "Unable to rasterize null resource"), null;
    if ("cim-rasterization-info" !== e13.type)
      return v("mapview-unexpected-resource", "Unable to rasterize resource"), null;
    const { resource: i12 } = e13;
    if ("text" === i12.type) {
      const e14 = await this._rasterizeText(i12, t15);
      for (const t16 of e14.glyphs)
        this._setTextureBinding(A3.GLYPH, t16);
      return e14;
    }
    const s12 = await this._rasterizeSprite(i12, t15);
    return s12 && this._setTextureBinding(A3.SPRITE, s12), s12;
  }
  getMosaicInfo(e13, t15, i12 = false) {
    const s12 = this._getTextureBindingInfo(e13, t15, i12);
    return s12 ? { size: s12.size, texture: { texture: s12.texture, unit: "sprite" === s12.type ? b3 : j } } : (v("mapview-invalid-resource", `Unable to find resource for ${t15}`), { size: [0, 0], texture: { texture: null, unit: 0 } });
  }
  _getTextureBindingInfo(e13, t15, i12) {
    const s12 = this._bindingInfos[t15 - 1], r14 = s12.page, a9 = i12 ? L3.LINEAR_MIPMAP_LINEAR : L3.LINEAR;
    switch (s12.mosaicType) {
      case A3.SPRITE: {
        const t16 = [this.sprites.getWidth(r14), this.sprites.getHeight(r14)], i13 = this._spriteMosaic.getTexture(e13, r14);
        return i13.setSamplingMode(a9), { type: "sprite", texture: i13, size: t16 };
      }
      case A3.GLYPH: {
        const t16 = [this.glyphs.width, this.glyphs.height], i13 = this._glyphMosaic.getTexture(e13, r14);
        return this._glyphMosaic.bind(e13, a9, r14, j), i13.setSamplingMode(a9), { type: "glyph", texture: i13, size: t16 };
      }
      default:
        return v("mapview-texture-manager", `Cannot handle unknown type ${s12.mosaicType}`), null;
    }
  }
  _hashMosaic(e13, t15) {
    return 1 | e13 << 1 | (t15.sdf ? 1 : 0) << 2 | t15.page << 3;
  }
  _setTextureBinding(e13, t15) {
    const i12 = this._hashMosaic(e13, t15);
    if (!this._hashToBindingIndex.has(i12)) {
      const s12 = $3.fromMosaic(e13, t15), r14 = this._bindingInfos.length + 1;
      this._hashToBindingIndex.set(i12, r14), this._bindingInfos.push(s12);
    }
    t15.textureBinding = this._hashToBindingIndex.get(i12);
  }
  async _rasterizeText(e13, t15) {
    const { font: s12, textString: a9 } = e13, n12 = f5(s12), o14 = this._invalidFontsMap.has(n12), [c10, h13] = i2(a9), u11 = j2(c10);
    try {
      const e14 = o14 ? P4 : n12;
      has("esri-2d-stabilize-glyphs") && await this._glyphMosaic.preloadASCIIGlyphCache(e14);
      return { type: "glyphs", glyphs: await this._glyphMosaic.getGlyphItems(e14, u11, t15), isRightToLeft: h13 };
    } catch (l11) {
      v("mapview-invalid-resource", `Couldn't find font ${n12}. Falling back to Arial Unicode MS Regular`), this._invalidFontsMap.set(n12, true);
      return { type: "glyphs", glyphs: await this._glyphMosaic.getGlyphItems(P4, u11, t15), isRightToLeft: h13 };
    }
  }
  _hashSpriteResource(e13) {
    switch (e13.type) {
      case "path":
        return `path:${e13.path}.${e13.asFill ? 1 : 0}`;
      case "CIMPictureMarker":
        return `${e13.type}:${e13.url}:${e13.size}`;
      case "CIMPictureFill":
        return `${e13.type}:${e13.url}:${e13.height}`;
      case "CIMPictureStroke":
        return `${e13.type}:${e13.url}:${e13.width}`;
      case "dash":
        return `dash:${e13.capStyle}.${e13.dashTemplate.join("")}`;
      case "sdf":
        return `sdf:${JSON.stringify(e13.geom)}.${e13.asFill ? 1 : 0}`;
      case "fill-style":
        return `fill_style:${e13.style}`;
      case "animated":
        return JSON.stringify(M3(e13));
      case "CIMHatchFill":
      case "CIMVectorMarker":
        return JSON.stringify(e13);
    }
  }
  async _rasterizeSprite(e13, t15) {
    var _a;
    if (!e13)
      return null;
    const i12 = c(this._hashSpriteResource(e13));
    if (this._spriteMosaic.has(i12))
      return this._spriteMosaic.getSpriteItem(i12);
    if ("url" in e13 && e13.url || "CIMPictureFill" === e13.type || "CIMPictureStroke" === e13.type || "CIMPictureMarker" === e13.type || "CIMVectorMarker" === e13.type) {
      const t16 = [];
      K.fetchResources({ type: "CIMPointSymbol", symbolLayers: [e13] }, this._resourceManager, t16), t16.length > 0 && await Promise.all(t16);
    }
    switch (e13.type) {
      case "CIMPictureMarker":
        return "CIMMarkerPlacementInsidePolygon" === ((_a = e13.markerPlacement) == null ? void 0 : _a.type) ? this._rasterizeJSONResource(i12, e13) : this._handleAsyncResource(i12, e13, t15);
      case "animated":
      case "CIMPictureFill":
      case "CIMPictureStroke":
      case "path":
        return this._handleAsyncResource(i12, e13, t15);
      case "sdf":
      case "dash":
      case "fill-style":
      case "CIMVectorMarker":
      case "CIMHatchFill":
        return this._rasterizeJSONResource(i12, e13);
    }
  }
  _rasterizeJSONResource(e13, t15) {
    const i12 = this._rasterizer.rasterizeJSONResource(t15, j3(t15));
    if (i12) {
      const { size: s12, image: r14, sdf: a9, simplePattern: n12, rasterizationScale: o14 } = i12;
      return this._addItemToMosaic(e13, s12, { type: "static", data: r14 }, A5(t15), a9, n12, o14);
    }
    return null;
  }
  async _handleAsyncResource(e13, t15, i12) {
    if (this._ongoingRasterizations.has(e13))
      return this._ongoingRasterizations.get(e13);
    let s12;
    return s12 = "path" === t15.type ? this._handleSVG(t15, e13, i12) : this._handleImage(t15, e13, i12), this._ongoingRasterizations.set(e13, s12), s12.finally(() => this._ongoingRasterizations.delete(e13)), s12;
  }
  async _handleSVG(e13, t15, i12) {
    const s12 = [Dt, Dt], { asFill: r14 } = e13, a9 = await this._sdfConverter.draw(e13.path, r14, i12);
    return this._addItemToMosaic(t15, s12, { type: "static", data: new Uint32Array(a9.buffer) }, false, true, true);
  }
  async _handleGIFOrPNG(e13, t15, i12) {
    const s12 = e13.url, r14 = this.resourceManager.getResource(s12);
    if (null == r14)
      return null;
    const { width: a9, height: n12 } = r14;
    if (r14 instanceof HTMLImageElement) {
      if ("animated" === e13.type)
        return v("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
      const i13 = "colorSubstitutions" in e13 ? e13.colorSubstitutions : void 0, { size: s13, sdf: o15, image: c11 } = this._rasterizer.rasterizeImageResource(a9, n12, r14, i13);
      return this._addItemToMosaic(t15, s13, { type: "static", data: c11 }, A5(e13), o15, false);
    }
    let o14, c10, h13;
    "animated" === e13.type ? (o14 = false, c10 = { playAnimation: e13.playAnimation, reverseAnimation: e13.reverseAnimation, randomizeStartTime: e13.randomizeStartTime, randomizeStartSeed: e13.randomizeStartSeed, startTimeOffset: e13.startTimeOffset, duration: e13.duration, repeatType: e13.repeatType, repeatDelay: e13.repeatDelay }, h13 = e13.startGroup || 0) : (o14 = A5(e13), c10 = {}, h13 = 0);
    const u11 = new a7(r14, this._requestRender, c10, h13);
    return this._addItemToMosaic(t15, [u11.width, u11.height], { type: "animated", data: u11 }, o14, false, false);
  }
  async _handleImage(e13, t15, i12) {
    const r14 = e13.url;
    if (G3(r14) || L4(r14))
      return this._handleGIFOrPNG(e13, t15, i12);
    if ("animated" === e13.type)
      return v("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
    try {
      let s12;
      const a9 = this.resourceManager.getResource(r14);
      if (null != a9 && a9 instanceof HTMLImageElement)
        s12 = a9;
      else {
        const { data: e14 } = await this._imageRequestQueue.push(r14, { ...i12 });
        s12 = e14;
      }
      if (y(r14)) {
        if ("width" in e13 && "height" in e13)
          s12.width = u4(e13.width), s12.height = u4(e13.height);
        else if ("cim" in e13) {
          const t16 = e13;
          s12.width = u4(t16.width ?? t16.scaleX * t16.size), s12.height = u4(t16.size);
        }
      }
      if (!s12.width || !s12.height)
        return null;
      const n12 = s12.width, o14 = s12.height, h13 = "colorSubstitutions" in e13 ? e13.colorSubstitutions : void 0, { size: u11, sdf: l11, image: p6 } = this._rasterizer.rasterizeImageResource(n12, o14, s12, h13);
      return this._addItemToMosaic(t15, u11, { type: "static", data: p6 }, A5(e13), l11, false);
    } catch (v3) {
      if (!b(v3))
        throw new s("mapview-invalid-resource", `Could not fetch requested resource at ${r14}. ${v3.message}`);
      throw v3;
    }
  }
  _addItemToMosaic(e13, t15, i12, s12, r14, a9, n12) {
    return this._spriteMosaic.addSpriteItem(e13, t15, i12, s12, r14, a9, n12);
  }
};
function A5(e13) {
  switch (e13.type) {
    case "CIMVectorMarker":
    case "CIMPictureMarker":
      return N3(e13);
    default:
      return true;
  }
}
var F5 = (e13) => null != e13 && e13.startsWith("data:image/gif");
var G3 = (e13) => e13 && (e13.includes(".gif") || F5(e13));
var B3 = (e13) => null != e13 && e13.startsWith("data:image/png");
var L4 = (e13) => e13 && (e13.includes(".png") || B3(e13));
var N3 = (e13) => e13 && "markerPlacement" in e13 && e13.markerPlacement && "CIMMarkerPlacementInsidePolygon" === e13.markerPlacement.type;

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureUploadManager.js
var r10 = class {
  constructor(e13) {
    this._queue = [], this._refreshable = e13;
  }
  destroy() {
    this._queue = [];
  }
  enqueueTextureUpdate(o14, r14) {
    const n12 = L(), h13 = o14, i12 = vt, a9 = Math.ceil(h13.height / i12);
    s2(r14);
    for (let e13 = 0; e13 < a9; e13++) {
      const t15 = e13 * i12, s12 = e13 === a9 - 1, u11 = s12 ? h13.height - i12 * e13 : i12;
      this._queue.push({ type: "chunk", request: o14, resolver: n12, chunk: e13, chunkOffset: t15, destHeight: u11, chunkIsLast: s12, options: r14 });
    }
    return w(r14, (e13) => n12.reject(e13)), n12.promise;
  }
  upload() {
    let e13 = 0;
    for (; this._queue.length; ) {
      const t15 = performance.now(), s12 = this._queue.shift();
      if (s12) {
        if (null != s12.options.signal && s12.options.signal.aborted)
          continue;
        switch (s12.type) {
          case "chunk":
            this._uploadChunk(s12);
            break;
          case "no-chunk":
            this._uploadNoChunk(s12);
        }
        const u11 = performance.now() - t15;
        if (e13 += u11, e13 + u11 >= At)
          break;
      }
    }
    this._queue.length && this._refreshable.requestRender();
  }
  _uploadChunk(e13) {
    const { request: t15, resolver: s12, chunkOffset: o14, chunkIsLast: u11, destHeight: r14 } = e13, { data: n12, texture: h13, width: i12 } = t15;
    null != n12 && (h13.updateData(0, 0, o14, i12, r14, n12, o14), u11 && s12.resolve());
  }
  _uploadNoChunk(e13) {
    const { request: t15, resolver: s12 } = e13, { data: o14, texture: u11 } = t15;
    u11.setData(o14), s12.resolve();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WorldExtentClipRenderer.js
var f8 = r4(-0.5, -0.5);
var u7 = class {
  constructor() {
    this._centerNdc = n2(), this._pxToNdc = n2(), this._worldDimensionsPx = n2(), this._mat3 = e7(), this._initialized = false;
  }
  dispose() {
    this._program = r3(this._program), this._quad = r3(this._quad);
  }
  render(t15, i12, e13) {
    const { context: r14 } = t15, s12 = this._updateGeometry(t15, e13);
    if (null != i12) {
      const { r: t16, g: e14, b: s13, a: o14 } = i12;
      r14.setClearColor(o14 * t16 / 255, o14 * e14 / 255, o14 * s13 / 255, o14);
    } else
      r14.setClearColor(0, 0, 0, 0);
    if (r14.setStencilFunction(O.ALWAYS, 0, 255), r14.setStencilWriteMask(255), !s12)
      return r14.setClearStencil(1), void r14.clear(r14.gl.STENCIL_BUFFER_BIT | r14.gl.COLOR_BUFFER_BIT);
    r14.setClearStencil(0), r14.clear(r14.gl.STENCIL_BUFFER_BIT | r14.gl.COLOR_BUFFER_BIT), this._initialized || this._initialize(r14), r14.setDepthWriteEnabled(false), r14.setDepthTestEnabled(false), r14.setColorMask(false, false, false, false), r14.setBlendingEnabled(false), r14.setStencilOp(I2.KEEP, I2.KEEP, I2.REPLACE), r14.setStencilFunction(O.ALWAYS, 1, 255), r14.setStencilTestEnabled(true), r14.useProgram(this._program), this._program.setUniformMatrix3fv("u_worldExtent", this._mat3), this._quad.draw(), this._quad.unbind();
  }
  _initialize(t15) {
    if (this._initialized)
      return;
    const i12 = e6(t15, r6);
    i12 && (this._program = i12, this._quad = new h7(t15, [0, 0, 1, 0, 0, 1, 1, 1]), this._initialized = true);
  }
  _updateGeometry(t15, a9) {
    const { state: n12, pixelRatio: m7 } = t15, { size: c10, rotation: h13 } = n12, _5 = Math.round(c10[0] * m7), d4 = Math.round(c10[1] * m7);
    if (!n12.spatialReference.isWrappable)
      return false;
    const p6 = u3(h13), u11 = Math.abs(Math.cos(p6)), g3 = Math.abs(Math.sin(p6)), b5 = Math.round(_5 * u11 + d4 * g3), x4 = Math.round(n12.worldScreenWidth);
    if (b5 <= x4)
      return false;
    const E4 = _5 * g3 + d4 * u11, S = x4 * m7, C2 = (a9.left - a9.right) * m7 / _5, T6 = (a9.bottom - a9.top) * m7 / d4;
    o4(this._worldDimensionsPx, S, E4, 1), o4(this._pxToNdc, 2 / _5, -2 / d4, 1), o4(this._centerNdc, C2, T6, 1);
    const j4 = this._mat3;
    return l2(j4, this._centerNdc), f4(j4, j4, this._pxToNdc), 0 !== h13 && h3(j4, j4, p6), f4(j4, j4, this._worldDimensionsPx), M(j4, j4, f8), true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/Effect.js
var t12 = class {
  constructor() {
    this.name = this.constructor.name;
  }
  createOptions(t15, r14) {
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/AnimationEffect.js
var i9 = class extends t12 {
  constructor() {
    super(...arguments), this.defines = [], this._desc = { vsPath: "fx/integrate", fsPath: "fx/integrate", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) };
  }
  dispose() {
    this._quad && this._quad.dispose();
  }
  bind() {
  }
  unbind() {
  }
  draw(r14, i12) {
    if (!(i12 == null ? void 0 : i12.size))
      return;
    const { context: n12, renderingOptions: o14 } = r14;
    this._quad || (this._quad = new h7(n12, [0, 0, 1, 0, 0, 1, 1, 1]));
    const a9 = n12.getBoundFramebufferObject(), { x: s12, y: u11, width: m7, height: d4 } = n12.getViewport(), f10 = i12.getBlock(M2.Animation);
    if (null == f10)
      return;
    const l11 = i12.getUniforms(n12);
    n12.setViewport(0, 0, i12.size, i12.size);
    const c10 = l11.filterFlags, x4 = l11.animation, p6 = has("featurelayer-animation-enabled") ? o14.labelsAnimationTime : 1, _5 = f10.getFBO(n12, 1);
    n12.unbindTexture(_5.colorTexture), this._computeDelta(r14, _5, x4, c10, p6);
    const g3 = f10.getFBO(n12);
    n12.unbindTexture(g3.colorTexture), this._updateAnimationState(r14, _5, g3), n12.bindFramebuffer(a9), n12.setViewport(s12, u11, m7, d4);
  }
  _computeDelta(e13, t15, r14, i12, n12) {
    const { context: o14, painter: a9, displayLevel: s12 } = e13, u11 = a9.materialManager.getProgram(this._desc, ["delta"]);
    if (o14.bindFramebuffer(t15), o14.setColorMask(true, true, true, true), o14.setClearColor(0, 0, 0, 0), o14.clear(o14.gl.COLOR_BUFFER_BIT), o14.useProgram(u11), !("type" in i12.texture) || !("type" in r14.texture))
      throw new Error("InternalError: Expected to find texture");
    o14.bindTexture(i12.texture, i12.unit), o14.bindTexture(r14.texture, r14.unit), u11.setUniform1i("u_maskTexture", i12.unit), u11.setUniform1i("u_sourceTexture", r14.unit), u11.setUniform1f("u_timeDelta", e13.deltaTime), u11.setUniform1f("u_animationTime", n12), u11.setUniform1f("u_zoomLevel", Math.round(10 * s12)), this._quad.draw();
  }
  _updateAnimationState(e13, t15, r14) {
    const { context: i12, painter: n12 } = e13, o14 = n12.materialManager.getProgram(this._desc, ["update"]);
    i12.bindTexture(t15.colorTexture, 1), i12.useProgram(o14), o14.setUniform1i("u_sourceTexture", 1), i12.bindFramebuffer(r14), i12.setColorMask(true, true, true, true), i12.setClearColor(0, 0, 0, 0), i12.clear(i12.gl.COLOR_BUFFER_BIT), this._quad.draw();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BlendPrograms.js
var r11 = (e13) => e13.replace("-", "_").toUpperCase();
var t13 = (e13) => `#define ${r11(e13)}
`;
function n8(r14) {
  return { attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]), shaders: { vertexShader: t13(r14) + n4("blend/blend.vert"), fragmentShader: t13(r14) + n4("blend/blend.frag") } };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/BlendEffect.js
var c7 = () => n.getLogger("esri.views.2d.engine.webgl.effects.blendEffects.BlendEffect");
var m5 = class {
  constructor() {
    this._size = [0, 0];
  }
  dispose(e13) {
    this._backBufferTexture = r3(this._backBufferTexture), this._quad = r3(this._quad);
  }
  draw(r14, t15, i12, a9, d4) {
    const { context: u11, drawPhase: f10 } = r14;
    if (this._setupShader(u11), a9 && "normal" !== a9 && f10 !== E3.LABEL)
      return void this._drawBlended(r14, t15, i12, a9, d4);
    const m7 = n8("normal"), h13 = u11.programCache.acquire(m7.shaders.vertexShader, m7.shaders.fragmentShader, m7.attributes);
    if (!h13)
      return void c7().error(new s("mapview-BlendEffect", 'Error creating shader program for blend mode "normal"'));
    u11.useProgram(h13), t15.setSamplingMode(i12), u11.bindTexture(t15, 0), h13.setUniform1i("u_layerTexture", 0), h13.setUniform1f("u_opacity", d4), u11.setBlendingEnabled(true), u11.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA);
    const l11 = this._quad;
    l11.draw(), l11.unbind(), h13.dispose();
  }
  _drawBlended(r14, t15, s12, i12, a9) {
    const { context: d4, state: u11, pixelRatio: f10, inFadeTransition: m7 } = r14, { size: h13 } = u11, l11 = d4.getBoundFramebufferObject();
    let _5, p6;
    null != l11 ? (_5 = l11.width, p6 = l11.height) : (_5 = Math.round(f10 * h13[0]), p6 = Math.round(f10 * h13[1])), this._createOrResizeTexture(r14, _5, p6);
    const b5 = this._backBufferTexture;
    l11.copyToTexture(0, 0, _5, p6, 0, 0, b5), d4.setStencilTestEnabled(false), d4.setStencilWriteMask(0), d4.setBlendingEnabled(true), d4.setDepthTestEnabled(false), d4.setDepthWriteEnabled(false);
    const g3 = n8(i12), x4 = d4.programCache.acquire(g3.shaders.vertexShader, g3.shaders.fragmentShader, g3.attributes);
    if (!x4)
      return void c7().error(new s("mapview-BlendEffect", `Error creating shader program for blend mode ${i12}`));
    d4.useProgram(x4), b5.setSamplingMode(s12), d4.bindTexture(b5, 0), x4.setUniform1i("u_backbufferTexture", 0), t15.setSamplingMode(s12), d4.bindTexture(t15, 1), x4.setUniform1i("u_layerTexture", 1), x4.setUniform1f("u_opacity", a9), x4.setUniform1f("u_inFadeOpacity", m7 ? 1 : 0), d4.setBlendFunction(R.ONE, R.ZERO);
    const T6 = this._quad;
    T6.draw(), T6.unbind(), x4.dispose(), d4.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA);
  }
  _setupShader(e13) {
    this._quad || (this._quad = new h7(e13, [-1, -1, 1, -1, -1, 1, 1, 1]));
  }
  _createOrResizeTexture(e13, r14, t15) {
    const { context: s12 } = e13;
    if (null === this._backBufferTexture || r14 !== this._size[0] || t15 !== this._size[1]) {
      if (this._backBufferTexture)
        this._backBufferTexture.resize(r14, t15);
      else {
        const e14 = new e4();
        e14.internalFormat = G.RGBA, e14.wrapMode = D2.CLAMP_TO_EDGE, e14.width = r14, e14.height = t15, this._backBufferTexture = new m2(s12, e14);
      }
      this._size[0] = r14, this._size[1] = t15;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/FeatureEffect.js
var s11 = class extends t12 {
  constructor(e13) {
    super(), this.name = this.constructor.name, this.defines = [e13];
  }
  dispose() {
  }
  bind({ context: e13, painter: t15 }) {
    this._prev = e13.getBoundFramebufferObject();
    const s12 = t15.getFbos().effect0;
    e13.bindFramebuffer(s12), e13.setColorMask(true, true, true, true), e13.setClearColor(0, 0, 0, 0), e13.clear(e13.gl.COLOR_BUFFER_BIT);
  }
  unbind() {
  }
  draw(e13, s12) {
    const { context: r14, painter: o14 } = e13, n12 = o14.getPostProcessingEffects(s12), c10 = r14.getBoundFramebufferObject();
    for (const { postProcessingEffect: t15, effect: f10 } of n12)
      t15.draw(e13, c10, f10);
    r14.bindFramebuffer(this._prev), r14.setStencilTestEnabled(false), o14.blitTexture(r14, c10.colorTexture, L3.NEAREST), r14.setStencilTestEnabled(true);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightRenderer.js
var c8 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.quadGeometry.dispose(), this._resources.quadVAO.dispose(), this._resources.highlightProgram.dispose(), this._resources.blurProgram.dispose(), this._resources = null);
  }
  preBlur(e13, i12) {
    e13.bindTexture(i12, I3), e13.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [1, 0, 1 / this._width, 0]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", t6), e13.bindVAO(this._resources.quadVAO), e13.drawArrays(E2.TRIANGLE_STRIP, 0, 4), e13.bindVAO();
  }
  finalBlur(e13, s12) {
    e13.bindTexture(s12, I3), e13.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [0, 1, 0, 1 / this._height]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", i6), e13.bindVAO(this._resources.quadVAO), e13.drawArrays(E2.TRIANGLE_STRIP, 0, 4), e13.bindVAO();
  }
  renderHighlight(e13, s12, i12) {
    e13.bindTexture(s12, I3), e13.useProgram(this._resources.highlightProgram), i12.applyHighlightOptions(e13, this._resources.highlightProgram), e13.bindVAO(this._resources.quadVAO), e13.setBlendingEnabled(true), e13.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), e13.drawArrays(E2.TRIANGLE_STRIP, 0, 4), e13.bindVAO();
  }
  _initialize(s12, i12, a9) {
    this._width = i12, this._height = a9;
    const m7 = h5.createVertex(s12, F2.STATIC_DRAW, new Int8Array([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]).buffer), c10 = new o8(s12, /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]), { geometry: [new t2("a_position", 2, C.BYTE, 0, 4), new t2("a_texcoord", 2, C.UNSIGNED_BYTE, 2, 4)] }, { geometry: m7 }), f10 = e6(s12, t8), b5 = e6(s12, r7);
    s12.useProgram(f10), f10.setUniform1i("u_texture", I3), f10.setUniform1i("u_shade", J), f10.setUniform1f("u_sigma", o9), s12.useProgram(b5), b5.setUniform1i("u_texture", I3), b5.setUniform1f("u_sigma", o9), this._resources = { quadGeometry: m7, quadVAO: c10, highlightProgram: f10, blurProgram: b5 };
  }
  setup(r14, e13, s12) {
    this._resources ? (this._width = e13, this._height = s12) : this._initialize(r14, e13, s12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightSurfaces.js
function i10(i12, h13, u11) {
  const l11 = new e4(h13, u11);
  return l11.wrapMode = D2.CLAMP_TO_EDGE, new x2(i12, l11, new i4(B2.STENCIL_INDEX8, h13, u11));
}
var h9 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.sharedBlur1Fbo.dispose(), this._resources.sharedBlur2Fbo.dispose(), this._resources = null);
  }
  _initialize(r14, e13, s12) {
    this._width = e13, this._height = s12;
    const t15 = i10(r14, e13, s12), o14 = i10(r14, e13, s12);
    this._resources = { sharedBlur1Fbo: t15, sharedBlur2Fbo: o14 };
  }
  setup(r14, e13, s12) {
    !this._resources || this._width === e13 && this._height === s12 || this.dispose(), this._resources || this._initialize(r14, e13, s12);
  }
  get sharedBlur1Tex() {
    return this._resources.sharedBlur1Fbo.colorTexture;
  }
  get sharedBlur1Fbo() {
    return this._resources.sharedBlur1Fbo;
  }
  get sharedBlur2Tex() {
    return this._resources.sharedBlur2Fbo.colorTexture;
  }
  get sharedBlur2Fbo() {
    return this._resources.sharedBlur2Fbo;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HighlightEffect.js
var h10 = 4;
var d3 = 4 / h10;
var l8 = class extends t12 {
  constructor() {
    super(...arguments), this.defines = ["highlight"], this._hlRenderer = new c8(), this._width = void 0, this._height = void 0, this._boundFBO = null, this._hlSurfaces = new h9(), this._adjustedWidth = void 0, this._adjustedHeight = void 0, this._blitRenderer = new _2();
  }
  dispose() {
    var _a, _b;
    (_a = this._hlSurfaces) == null ? void 0 : _a.dispose(), (_b = this._hlRenderer) == null ? void 0 : _b.dispose(), this._boundFBO = null;
  }
  bind(e13) {
    const { context: t15, painter: s12 } = e13, { width: r14, height: i12 } = t15.getViewport(), h13 = s12.getFbos().effect0;
    this.setup(e13, r14, i12), t15.bindFramebuffer(h13), t15.setColorMask(true, true, true, true), t15.setClearColor(0, 0, 0, 0), t15.clear(t15.gl.COLOR_BUFFER_BIT);
  }
  unbind() {
  }
  setup({ context: e13 }, t15, s12) {
    this._width = t15, this._height = s12;
    const r14 = t15 % h10, i12 = s12 % h10;
    t15 += r14 < h10 / 2 ? -r14 : h10 - r14, s12 += i12 < h10 / 2 ? -i12 : h10 - i12, this._adjustedWidth = t15, this._adjustedHeight = s12, this._boundFBO = e13.getBoundFramebufferObject();
    const l11 = Math.round(t15 * d3), o14 = Math.round(s12 * d3);
    this._hlRenderer.setup(e13, l11, o14), this._hlSurfaces.setup(e13, l11, o14);
  }
  draw(e13) {
    const { context: t15, passOptions: s12 } = e13, r14 = s12.activeGradient, h13 = t15.getBoundFramebufferObject();
    t15.setViewport(0, 0, this._adjustedWidth * d3, this._adjustedHeight * d3), t15.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t15.setStencilTestEnabled(false), t15.setClearColor(0, 0, 0, 0), t15.clear(t15.gl.COLOR_BUFFER_BIT), this._blitRenderer.render(t15, h13.colorTexture, L3.NEAREST, 1), t15.setStencilTestEnabled(false), t15.setBlendingEnabled(false), t15.setColorMask(false, false, false, true), t15.bindFramebuffer(this._hlSurfaces.sharedBlur2Fbo), t15.setClearColor(0, 0, 0, 0), t15.clear(t15.gl.COLOR_BUFFER_BIT), this._hlRenderer.preBlur(t15, this._hlSurfaces.sharedBlur1Tex), t15.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t15.setClearColor(0, 0, 0, 0), t15.clear(t15.gl.COLOR_BUFFER_BIT), this._hlRenderer.finalBlur(t15, this._hlSurfaces.sharedBlur2Tex), t15.bindFramebuffer(this._boundFBO), t15.setBlendingEnabled(true), t15.setColorMask(true, true, true, true), t15.setViewport(0, 0, this._width, this._height), this._hlRenderer.renderHighlight(t15, this._hlSurfaces.sharedBlur1Tex, r14), this._boundFBO = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HittestEffect.js
var n9 = class extends t12 {
  constructor() {
    super(...arguments), this.name = this.constructor.name, this.defines = ["hittest"];
  }
  dispose() {
    null != this._fbo && this._fbo.dispose();
  }
  createOptions({ pixelRatio: e13 }, s12, i12 = T3) {
    if (!s12.length)
      return null;
    const o14 = s12.shift(), n12 = o14.x, r14 = o14.y;
    return this._outstanding = o14, { type: "hittest", distance: i12 * e13, smallSymbolDistance: 0, smallSymbolSizeThreshold: 3, position: [n12, r14] };
  }
  bind(t15) {
    const { context: s12, attributeView: i12 } = t15;
    if (!i12.size)
      return;
    const o14 = i12.getBlock(M2.GPGPU);
    if (null == o14)
      return;
    const n12 = o14.getFBO(s12);
    s12.setViewport(0, 0, i12.size, i12.size), s12.bindFramebuffer(n12), s12.setColorMask(true, true, true, true), s12.setClearColor(0, 0, 0, 0), s12.clear(s12.gl.COLOR_BUFFER_BIT | s12.gl.DEPTH_BUFFER_BIT);
  }
  unbind() {
  }
  draw(t15) {
    if (null == this._outstanding)
      return;
    const e13 = this._outstanding;
    this._outstanding = null, this._resolve(t15, e13.resolvers);
  }
  async _resolve(t15, s12) {
    const { context: n12, attributeView: r14 } = t15, l11 = r14.getBlock(M2.GPGPU);
    if (null == l11)
      return void s12.forEach((t16) => t16.resolve([]));
    const c10 = l11.getFBO(n12), a9 = new Uint8Array(c10.width * c10.height * 4);
    try {
      await c10.readPixelsAsync(0, 0, c10.width, c10.height, G.RGBA, U2.UNSIGNED_BYTE, a9);
    } catch (u11) {
      return void s12.forEach((t16) => t16.resolve([]));
    }
    const h13 = [];
    for (let e13 = 0; e13 < a9.length; e13 += 4) {
      const t16 = e13 / 4;
      a9[e13] && h13.push(t16);
    }
    s12.forEach((t16) => t16.resolve(h13));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HittestEffectVTL.js
var r12 = class extends t12 {
  constructor() {
    super(...arguments), this.name = this.constructor.name, this.defines = ["id"], this._lastSize = 0, this._boundFBO = null;
  }
  dispose() {
    null != this._fbo && this._fbo.dispose();
  }
  bind({ context: t15, painter: e13 }) {
    this._boundFBO = t15.getBoundFramebufferObject();
    const s12 = e13.getFbos().effect0;
    t15.bindFramebuffer(s12), t15.setColorMask(true, true, true, true), t15.setClearColor(0, 0, 0, 0), t15.clear(t15.gl.COLOR_BUFFER_BIT);
  }
  unbind({ context: t15 }) {
    t15.bindFramebuffer(this._boundFBO), this._boundFBO = null;
  }
  draw(e13, s12, o14 = 2 * T3) {
    this._resolve(e13, s12, o14);
  }
  async _resolve({ context: t15, state: e13, pixelRatio: r14 }, i12, n12) {
    const f10 = t15.getBoundFramebufferObject(), a9 = e13.size[1] * r14, u11 = Math.round(n12 * r14), h13 = u11 / 2, l11 = u11 / 2;
    this._ensureBuffer(u11), i12.forEach(async (t16, e14) => {
      const n13 = /* @__PURE__ */ new Map(), b5 = Math.floor(e14.x * r14 - u11 / 2), c10 = Math.floor(a9 - e14.y * r14 - u11 / 2);
      await f10.readPixelsAsync(b5, c10, u11, u11, G.RGBA, U2.UNSIGNED_BYTE, this._buf);
      for (let s12 = 0; s12 < this._buf32.length; s12++) {
        const t17 = this._buf32[s12];
        if (4294967295 !== t17 && 0 !== t17) {
          const e15 = s12 % u11, o14 = u11 - Math.floor(s12 / u11), r15 = (h13 - e15) * (h13 - e15) + (l11 - o14) * (l11 - o14), i13 = n13.has(t17) ? n13.get(t17) : 4294967295;
          n13.set(t17, Math.min(r15, i13));
        }
      }
      const _5 = Array.from(n13).sort((t17, e15) => t17[1] - e15[1]).map((t17) => t17[0]);
      t16.resolve(_5), i12.delete(e14);
    });
  }
  _ensureBuffer(t15) {
    this._lastSize !== t15 && (this._lastSize = t15, this._buf = new Uint8Array(4 * t15 * t15), this._buf32 = new Uint32Array(this._buf.buffer));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Bloom.js
var a8 = 5;
var u8 = [1, 0];
var l9 = [0, 1];
var m6 = [1, 0.8, 0.6, 0.4, 0.2];
var _3 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var h11 = class {
  constructor() {
    this._intensityFBO = null, this._compositeFBO = null, this._mipsFBOs = new Array(a8), this._nMips = a8, this._kernelSizeArray = [3, 5, 7, 9, 11], this._size = [0, 0], this._programDesc = { luminosityHighPass: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/luminosityHighPass", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, gaussianBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, composite: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/composite", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    if (this._quad = r3(this._quad), this._intensityFBO = r3(this._intensityFBO), this._compositeFBO = r3(this._compositeFBO), this._mipsFBOs) {
      for (let t15 = 0; t15 < this._nMips; t15++)
        this._mipsFBOs[t15] && (this._mipsFBOs[t15].horizontal.dispose(), this._mipsFBOs[t15].vertical.dispose());
      this._mipsFBOs = null;
    }
  }
  draw(t15, i12, r14) {
    const { width: o14, height: n12 } = i12, { context: h13, painter: p6 } = t15, { materialManager: c10 } = p6, d4 = h13.gl, f10 = this._programDesc, { strength: b5, radius: F6, threshold: O3 } = r14;
    this._quad || (this._quad = new h7(h13, [-1, -1, 1, -1, -1, 1, 1, 1])), this._createOrResizeResources(t15, o14, n12), h13.setStencilTestEnabled(false), h13.setBlendingEnabled(true), h13.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), h13.setStencilWriteMask(0);
    const B4 = this._quad;
    B4.bind(), h13.bindFramebuffer(this._intensityFBO);
    const g3 = c10.getProgram(f10.luminosityHighPass);
    h13.useProgram(g3), h13.bindTexture(i12.colorTexture, 0), g3.setUniform1i("u_texture", 0), g3.setUniform3fv("u_defaultColor", [0, 0, 0]), g3.setUniform1f("u_defaultOpacity", 0), g3.setUniform1f("u_luminosityThreshold", O3), g3.setUniform1f("u_smoothWidth", 0.01);
    const T6 = [Math.round(o14 / 2), Math.round(n12 / 2)];
    h13.setViewport(0, 0, T6[0], T6[1]), h13.setClearColor(0, 0, 0, 0), h13.clear(d4.COLOR_BUFFER_BIT), B4.draw(), h13.setBlendingEnabled(false);
    let x4 = this._intensityFBO.colorTexture;
    for (let e13 = 0; e13 < this._nMips; e13++) {
      const t16 = c10.getProgram(f10.gaussianBlur, [{ name: "radius", value: this._kernelSizeArray[e13] }]);
      h13.useProgram(t16), h13.bindTexture(x4, e13 + 1), t16.setUniform1i("u_colorTexture", e13 + 1), t16.setUniform2fv("u_texSize", T6), t16.setUniform2fv("u_direction", u8), h13.setViewport(0, 0, T6[0], T6[1]);
      const s12 = this._mipsFBOs[e13];
      h13.bindFramebuffer(s12.horizontal), B4.draw(), x4 = s12.horizontal.colorTexture, h13.bindFramebuffer(s12.vertical), h13.bindTexture(x4, e13 + 1), t16.setUniform2fv("u_direction", l9), B4.draw(), x4 = s12.vertical.colorTexture, T6[0] = Math.round(T6[0] / 2), T6[1] = Math.round(T6[1] / 2);
    }
    h13.setViewport(0, 0, o14, n12);
    const w5 = c10.getProgram(f10.composite, [{ name: "nummips", value: a8 }]);
    h13.bindFramebuffer(this._compositeFBO), h13.useProgram(w5), w5.setUniform1f("u_bloomStrength", b5), w5.setUniform1f("u_bloomRadius", F6), w5.setUniform1fv("u_bloomFactors", m6), w5.setUniform3fv("u_bloomTintColors", _3), h13.bindTexture(this._mipsFBOs[0].vertical.colorTexture, 1), w5.setUniform1i("u_blurTexture1", 1), h13.bindTexture(this._mipsFBOs[1].vertical.colorTexture, 2), w5.setUniform1i("u_blurTexture2", 2), h13.bindTexture(this._mipsFBOs[2].vertical.colorTexture, 3), w5.setUniform1i("u_blurTexture3", 3), h13.bindTexture(this._mipsFBOs[3].vertical.colorTexture, 4), w5.setUniform1i("u_blurTexture4", 4), h13.bindTexture(this._mipsFBOs[4].vertical.colorTexture, 5), w5.setUniform1i("u_blurTexture5", 5), B4.draw(), h13.bindFramebuffer(i12), h13.setBlendingEnabled(true);
    const M4 = c10.getProgram(f10.blit);
    h13.useProgram(M4), h13.bindTexture(this._compositeFBO.colorTexture, 6), M4.setUniform1i("u_texture", 6), h13.setBlendFunction(R.ONE, R.ONE), B4.draw(), B4.unbind(), h13.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), h13.setStencilTestEnabled(true);
  }
  _createOrResizeResources(t15, e13, s12) {
    const { context: a9 } = t15;
    if (this._compositeFBO && this._size[0] === e13 && this._size[1] === s12)
      return;
    this._size[0] = e13, this._size[1] = s12;
    const u11 = [Math.round(e13 / 2), Math.round(s12 / 2)];
    if (this._compositeFBO)
      this._compositeFBO.resize(e13, s12);
    else {
      const t16 = new e4(e13, s12);
      t16.internalFormat = G.RGBA, t16.wrapMode = D2.CLAMP_TO_EDGE, this._compositeFBO = new x2(a9, t16);
    }
    if (this._intensityFBO)
      this._intensityFBO.resize(u11[0], u11[1]);
    else {
      const t16 = new e4(u11[0], u11[1]);
      t16.internalFormat = G.RGBA, t16.wrapMode = D2.CLAMP_TO_EDGE, this._intensityFBO = new x2(a9, t16);
    }
    for (let l11 = 0; l11 < this._nMips; l11++) {
      if (this._mipsFBOs[l11])
        this._mipsFBOs[l11].horizontal.resize(u11[0], u11[1]), this._mipsFBOs[l11].vertical.resize(u11[0], u11[1]);
      else {
        const t16 = new e4(u11[0], u11[1]);
        t16.internalFormat = G.RGBA, t16.wrapMode = D2.CLAMP_TO_EDGE, this._mipsFBOs[l11] = { horizontal: new x2(a9, t16), vertical: new x2(a9, t16) };
      }
      u11[0] = Math.round(u11[0] / 2), u11[1] = Math.round(u11[1] / 2);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Blur.js
var n10 = [1, 0];
var o13 = [0, 1];
var u9 = class {
  constructor() {
    this._blurFBO = null, this._size = [0, 0], this._programDesc = { gaussianBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, radialBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/radial-blur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    this._blurFBO && (this._blurFBO.dispose(), this._blurFBO = null);
  }
  draw(t15, s12, r14) {
    const { context: i12 } = t15, { type: a9, radius: n12 } = r14;
    if (0 === n12)
      return;
    this._createOrResizeResources(t15), this._quad || (this._quad = new h7(i12, [-1, -1, 1, -1, -1, 1, 1, 1]));
    const o14 = this._quad;
    o14.bind(), "blur" === a9 ? this._gaussianBlur(t15, s12, n12) : this._radialBlur(t15, s12), o14.unbind();
  }
  _gaussianBlur(e13, s12, r14) {
    const { context: i12, state: a9, painter: u11, pixelRatio: l11 } = e13, { size: d4 } = a9, { materialManager: b5 } = u11, c10 = this._programDesc, _5 = this._quad, p6 = [Math.round(l11 * d4[0]), Math.round(l11 * d4[1])], h13 = this._blurFBO, m7 = b5.getProgram(c10.gaussianBlur, [{ name: "radius", value: Math.ceil(r14) }]);
    i12.useProgram(m7), i12.setBlendingEnabled(false), i12.bindFramebuffer(h13), i12.bindTexture(s12.colorTexture, 4), m7.setUniform1i("u_colorTexture", 4), m7.setUniform2fv("u_texSize", p6), m7.setUniform2fv("u_direction", n10), m7.setUniform1f("u_sigma", r14), _5.draw(), i12.bindFramebuffer(s12), i12.setStencilWriteMask(0), i12.setStencilTestEnabled(false), i12.setDepthWriteEnabled(false), i12.setDepthTestEnabled(false), i12.bindTexture(h13 == null ? void 0 : h13.colorTexture, 5), m7.setUniform1i("u_colorTexture", 5), m7.setUniform2fv("u_direction", o13), _5.draw(), i12.setBlendingEnabled(true), i12.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), i12.setStencilTestEnabled(true);
  }
  _radialBlur(e13, s12) {
    const { context: r14, painter: i12 } = e13, { materialManager: a9 } = i12, n12 = this._programDesc, o14 = this._quad, u11 = this._blurFBO;
    r14.bindFramebuffer(u11);
    const l11 = a9.getProgram(n12.radialBlur);
    r14.useProgram(l11), r14.setBlendingEnabled(false), r14.bindTexture(s12.colorTexture, 4), l11.setUniform1i("u_colorTexture", 4), o14.draw(), r14.bindFramebuffer(s12), r14.setStencilWriteMask(0), r14.setStencilTestEnabled(false), r14.setDepthWriteEnabled(false), r14.setDepthTestEnabled(false), r14.setBlendingEnabled(true);
    const d4 = a9.getProgram(n12.blit);
    r14.useProgram(d4), r14.bindTexture(u11 == null ? void 0 : u11.colorTexture, 5), d4.setUniform1i("u_texture", 5), r14.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), o14.draw();
  }
  _createOrResizeResources(e13) {
    const { context: t15, state: n12, pixelRatio: o14 } = e13, { size: u11 } = n12, l11 = Math.round(o14 * u11[0]), d4 = Math.round(o14 * u11[1]);
    if (!this._blurFBO || this._size[0] !== l11 || this._size[1] !== d4)
      if (this._size[0] = l11, this._size[1] = d4, this._blurFBO)
        this._blurFBO.resize(l11, d4);
      else {
        const e14 = new e4(l11, d4);
        e14.internalFormat = G.RGBA, e14.wrapMode = D2.CLAMP_TO_EDGE, this._blurFBO = new x2(t15, e14);
      }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Colorize.js
var n11 = class {
  constructor() {
    this._layerFBOTexture = null, this._size = [0, 0], this._programDesc = { vsPath: "post-processing/pp", fsPath: "post-processing/filterEffect", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) };
  }
  dispose() {
    this._layerFBOTexture = r3(this._layerFBOTexture);
  }
  draw(e13, t15, s12) {
    const { width: i12, height: o14 } = t15;
    this._createOrResizeResources(e13, i12, o14);
    const { context: a9, painter: n12 } = e13, { materialManager: c10 } = n12, l11 = this._programDesc, u11 = this._quad, _5 = s12.colorMatrix;
    u11.bind();
    const h13 = this._layerFBOTexture;
    a9.bindFramebuffer(t15), t15.copyToTexture(0, 0, i12, o14, 0, 0, h13), a9.setBlendingEnabled(false), a9.setStencilTestEnabled(false);
    const m7 = c10.getProgram(l11);
    a9.useProgram(m7), a9.bindTexture(h13, 2), m7.setUniformMatrix4fv("u_coefficients", _5), m7.setUniform1i("u_colorTexture", 2), u11.draw(), a9.setBlendingEnabled(true), a9.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), a9.setStencilTestEnabled(true), u11.unbind();
  }
  _createOrResizeResources(e13, r14, n12) {
    const { context: c10 } = e13;
    if (!this._layerFBOTexture || this._size[0] !== r14 || this._size[1] !== n12) {
      if (this._size[0] = r14, this._size[1] = n12, this._layerFBOTexture)
        this._layerFBOTexture.resize(r14, n12);
      else {
        const e14 = new e4();
        e14.internalFormat = G.RGBA, e14.wrapMode = D2.CLAMP_TO_EDGE, e14.width = r14, e14.height = n12, this._layerFBOTexture = new m2(c10, e14);
      }
      this._quad || (this._quad = new h7(c10, [-1, -1, 1, -1, -1, 1, 1, 1]));
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/DropShadow.js
var u10 = [1, 0];
var h12 = [0, 1];
var _4 = class {
  constructor() {
    this._layerFBOTexture = null, this._horizontalBlurFBO = null, this._verticalBlurFBO = null, this._size = [0, 0], this._quad = null, this._programDesc = { blur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, composite: { vsPath: "post-processing/pp", fsPath: "post-processing/drop-shadow/composite", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    this._layerFBOTexture = r3(this._layerFBOTexture), this._horizontalBlurFBO = r3(this._horizontalBlurFBO), this._verticalBlurFBO = r3(this._verticalBlurFBO);
  }
  draw(e13, i12, o14) {
    const { context: a9, state: n12, painter: l11 } = e13, { materialManager: _5 } = l11, c10 = this._programDesc, p6 = i12.width, m7 = i12.height, f10 = [Math.round(p6), Math.round(m7)], { blurRadius: B4, offsetX: d4, offsetY: b5, color: O3 } = o14, F6 = [u4(d4), u4(b5)];
    this._createOrResizeResources(e13, p6, m7, f10);
    const w5 = this._horizontalBlurFBO, T6 = this._verticalBlurFBO;
    a9.setStencilWriteMask(0), a9.setStencilTestEnabled(false), a9.setDepthWriteEnabled(false), a9.setDepthTestEnabled(false);
    const x4 = this._layerFBOTexture;
    i12.copyToTexture(0, 0, p6, m7, 0, 0, x4), this._quad || (this._quad = new h7(a9, [-1, -1, 1, -1, -1, 1, 1, 1])), a9.setViewport(0, 0, f10[0], f10[1]);
    const g3 = this._quad;
    g3.bind(), a9.setBlendingEnabled(false);
    const z2 = _5.getProgram(c10.blur, [{ name: "radius", value: Math.ceil(B4) }]);
    a9.useProgram(z2), a9.bindFramebuffer(w5), a9.bindTexture(i12.colorTexture, 4), z2.setUniform1i("u_colorTexture", 4), z2.setUniform2fv("u_texSize", f10), z2.setUniform2fv("u_direction", u10), z2.setUniform1f("u_sigma", B4), g3.draw(), a9.bindFramebuffer(T6), a9.bindTexture(w5 == null ? void 0 : w5.colorTexture, 5), z2.setUniform1i("u_colorTexture", 5), z2.setUniform2fv("u_direction", h12), g3.draw(), a9.bindFramebuffer(i12), a9.setViewport(0, 0, p6, m7);
    const M4 = _5.getProgram(c10.composite);
    a9.useProgram(M4), a9.bindTexture(T6 == null ? void 0 : T6.colorTexture, 2), M4.setUniform1i("u_blurTexture", 2), a9.bindTexture(x4, 3), M4.setUniform1i("u_layerFBOTexture", 3), M4.setUniform4fv("u_shadowColor", [O3[3] * (O3[0] / 255), O3[3] * (O3[1] / 255), O3[3] * (O3[2] / 255), O3[3]]), M4.setUniformMatrix3fv("u_displayViewMat3", n12.displayMat3), M4.setUniform2fv("u_shadowOffset", F6), g3.draw(), a9.setBlendingEnabled(true), a9.setStencilTestEnabled(true), a9.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), g3.unbind();
  }
  _createOrResizeResources(e13, t15, r14, s12) {
    const { context: u11 } = e13;
    if (!this._horizontalBlurFBO || this._size[0] !== t15 || this._size[1] !== r14) {
      if (this._size[0] = t15, this._size[1] = r14, this._horizontalBlurFBO)
        this._horizontalBlurFBO.resize(s12[0], s12[1]);
      else {
        const e14 = new e4(s12[0], s12[1]);
        e14.internalFormat = G.RGBA, e14.wrapMode = D2.CLAMP_TO_EDGE, this._horizontalBlurFBO = new x2(u11, e14);
      }
      if (this._verticalBlurFBO)
        this._verticalBlurFBO.resize(s12[0], s12[1]);
      else {
        const e14 = new e4(s12[0], s12[1]);
        e14.internalFormat = G.RGBA, e14.wrapMode = D2.CLAMP_TO_EDGE, this._verticalBlurFBO = new x2(u11, e14);
      }
      if (this._layerFBOTexture)
        this._layerFBOTexture.resize(t15, r14);
      else {
        const e14 = new e4();
        e14.internalFormat = G.RGBA, e14.wrapMode = D2.CLAMP_TO_EDGE, e14.width = t15, e14.height = r14, this._layerFBOTexture = new m2(u11, e14);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Opacity.js
var l10 = class {
  constructor() {
    this._size = [0, 0], this._layerFBOTexture = null;
  }
  dispose() {
    this._layerFBOTexture = r3(this._layerFBOTexture);
  }
  draw(e13, r14, s12) {
    const { width: i12, height: o14 } = r14;
    this._createOrResizeResources(e13, i12, o14);
    const { context: l11, painter: a9 } = e13, { amount: n12 } = s12, h13 = l11.gl, u11 = this._layerFBOTexture;
    l11.bindFramebuffer(r14), r14.copyToTexture(0, 0, i12, o14, 0, 0, u11), l11.setBlendingEnabled(true), l11.setStencilTestEnabled(false), l11.setDepthTestEnabled(false), l11.setClearColor(0, 0, 0, 0), l11.clear(h13.COLOR_BUFFER_BIT), a9.blitTexture(l11, u11, L3.NEAREST, n12);
  }
  _createOrResizeResources(e13, l11, a9) {
    const { context: n12 } = e13;
    if (!this._layerFBOTexture || this._size[0] !== l11 || this._size[1] !== a9)
      if (this._size[0] = l11, this._size[1] = a9, this._layerFBOTexture)
        this._layerFBOTexture.resize(l11, a9);
      else {
        const e14 = new e4();
        e14.internalFormat = G.RGBA, e14.wrapMode = D2.CLAMP_TO_EDGE, e14.samplingMode = L3.NEAREST, e14.width = l11, e14.height = a9, this._layerFBOTexture = new m2(n12, e14);
      }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/EffectManager.js
function c9(o14) {
  switch (o14) {
    case "bloom":
    case "blur":
    case "opacity":
    case "drop-shadow":
      return o14;
    default:
      return "colorize";
  }
}
var f9 = { colorize: () => new n11(), blur: () => new u9(), bloom: () => new h11(), opacity: () => new l10(), "drop-shadow": () => new _4() };
var i11 = class {
  constructor() {
    this._effectMap = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._effectMap.forEach((o14) => o14.dispose()), this._effectMap.clear();
  }
  getPostProcessingEffects(o14) {
    if (!o14 || 0 === o14.length)
      return [];
    const e13 = [];
    for (const t15 of o14) {
      const o15 = c9(t15.type);
      let s12 = this._effectMap.get(o15);
      s12 || (s12 = f9[o15](), this._effectMap.set(o15, s12)), e13.push({ postProcessingEffect: s12, effect: t15 });
    }
    return e13;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/painter/RenderPass.js
var t14 = class {
  constructor(e13, t15) {
    this.brushes = e13, this.name = t15.name, this.drawPhase = t15.drawPhase || E3.MAP, this._targetFn = t15.target, this.effects = t15.effects || [], this.enableDefaultDraw = t15.enableDefaultDraw ?? (() => true), this.forceDrawByDisplayOrder = !!t15.forceDrawByDisplayOrder;
  }
  render(e13) {
    var _a;
    const { context: r14, profiler: t15 } = e13, s12 = this._targetFn(), a9 = this.drawPhase & e13.drawPhase;
    if (t15.recordPassStart(this.name), a9) {
      this.enableDefaultDraw() && this._doRender(e13, s12), t15.recordPassEnd();
      for (const t16 of this.effects) {
        if (!t16.enable())
          continue;
        const a10 = t16.apply, n12 = (_a = t16.args) == null ? void 0 : _a.call(t16), i12 = r14.getViewport(), o14 = r14.getBoundFramebufferObject(), d4 = e13.passOptions;
        this._bindEffect(e13, a10, n12), this._doRender(e13, s12, a10.defines), this._drawAndUnbindEffect(e13, a10, i12, o14, d4, n12);
      }
    }
  }
  _doRender(e13, r14, t15) {
    if (null == r14)
      return;
    const { profiler: s12, context: a9 } = e13;
    for (const n12 of this.brushes) {
      if (s12.recordBrushStart(n12.name), null != n12.brushEffect) {
        const s13 = a9.getViewport(), i12 = a9.getBoundFramebufferObject(), o14 = e13.passOptions;
        this._bindEffect(e13, n12.brushEffect), this._drawWithBrush(n12, e13, r14, t15), this._drawAndUnbindEffect(e13, n12.brushEffect, s13, i12, o14);
      } else
        this._drawWithBrush(n12, e13, r14, t15);
      s12.recordBrushEnd();
    }
  }
  _drawWithBrush(r14, t15, s12, a9) {
    p(s12) ? (r14.prepareState(t15, a9), r14.drawMany(t15, s12, a9)) : s12.visible && (r14.prepareState(t15, a9), r14.draw(t15, s12, a9));
  }
  _bindEffect(e13, r14, t15) {
    const { profiler: s12 } = e13;
    s12.recordPassStart(this.name + "." + r14.name), r14.bind(e13, t15);
    const a9 = r14.createOptions(e13, t15);
    e13.passOptions = a9;
  }
  _drawAndUnbindEffect(e13, r14, t15, s12, a9, n12) {
    const { profiler: i12, context: o14 } = e13;
    e13.passOptions = a9, i12.recordBrushStart(r14.name), r14.draw(e13, n12), r14.unbind(e13, n12), o14.bindFramebuffer(s12);
    const { x: d4, y: f10, width: h13, height: c10 } = t15;
    o14.setViewport(d4, f10, h13, c10), i12.recordBrushEnd(), i12.recordPassEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/TechniqueProgramCache.js
var r13 = class {
  constructor() {
    this._programCache = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const r14 of this._programCache.values())
      r14.destroy();
    this._programCache.clear();
  }
  getProgram(r14, e13, t15, a9, o14) {
    const s12 = r14.getShaderKey(e13, t15, a9, o14);
    let c10 = this._programCache.get(s12);
    return c10 || (c10 = r14.getProgram(e13, t15, a9, o14), this._programCache.set(s12, c10)), c10;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/Painter.js
var D3 = class {
  constructor(e13, t15) {
    this.context = e13, this._currentPipelineStateNeedsUpdate = false, this._blitRenderer = new _2(), this._worldExtentRenderer = new u7(), this._brushCache = /* @__PURE__ */ new Map(), this._lastWidth = null, this._lastHeight = null, this._vtlMaterialManager = new p3(), this._blendEffect = new m5(), this._stencilBuf = null, this._prevBeforeLayerFBOStack = [], this._fboPool = [], this.effects = { highlight: new l8(), hittest: new n9(), hittestVTL: new r12(), integrate: new i9(), insideEffect: new s11("inside"), outsideEffect: new s11("outside") }, this._programCache = new r13(), this._shaderState = { shader: null, uniforms: null, defines: null, optionalAttributes: null, useComputeBuffer: false }, this.materialManager = new e12(e13), this.textureManager = new k(t15), this.textureUploadManager = new r10(t15), this._effectsManager = new i11(), this._quadMesh = new h7(e13, [0, 0, 1, 0, 0, 1, 1, 1]);
  }
  dispose() {
    if (this._programCache.destroy(), this.materialManager.dispose(), this.textureManager.dispose(), this.textureUploadManager.destroy(), this._blitRenderer = r3(this._blitRenderer), this._worldExtentRenderer = r3(this._worldExtentRenderer), this._quadMesh.dispose(), this._brushCache && (this._brushCache.forEach((e13) => e13.dispose()), this._brushCache.clear(), this._brushCache = null), this._fbos) {
      let e13;
      for (e13 in this._fbos)
        this._fbos[e13] && this._fbos[e13].dispose();
    }
    for (const e13 of this._fboPool)
      e13.dispose();
    if (this._fboPool.length = 0, this.effects) {
      let e13;
      for (e13 in this.effects)
        this.effects[e13] && this.effects[e13].dispose();
    }
    this._effectsManager.dispose(), this._blendEffect.dispose(this.context), this._vtlMaterialManager = r3(this._vtlMaterialManager);
  }
  clearShaderCache() {
    this._programCache.destroy(), this._programCache = new r13();
  }
  get blitRenderer() {
    return this._blitRenderer;
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  getFbos() {
    if (!this._fbos)
      throw new Error("InternalError: Painter FBOs not initialized");
    return this._fbos;
  }
  acquireFbo(e13, t15) {
    let s12;
    if (this._fboPool.length > 0)
      s12 = this._fboPool.pop();
    else {
      const r14 = new e4(e13, t15);
      r14.samplingMode = L3.NEAREST, r14.wrapMode = D2.CLAMP_TO_EDGE, s12 = new x2(this.context, r14, this._stencilBuf);
    }
    return s12.width === e13 && s12.height === t15 || s12.resize(e13, t15), s12;
  }
  releaseFbo(e13) {
    this._fboPool.push(e13);
  }
  getSharedStencilBuffer() {
    return this._stencilBuf;
  }
  beforeRenderPhases(e13, t15, s12) {
    const { context: r14 } = e13;
    this._worldExtentRenderer.render(e13, t15, s12);
    const { width: i12, height: n12 } = r14.getViewport();
    if (this.updateFBOs(i12, n12), this._prevFBO = r14.getBoundFramebufferObject(), r14.bindFramebuffer(this.getFbos().output), r14.setColorMask(true, true, true, true), null != t15) {
      const { r: e14, g: s13, b: i13, a: n13 } = t15;
      r14.setClearColor(n13 * e14 / 255, n13 * s13 / 255, n13 * i13 / 255, n13);
    } else
      r14.setClearColor(0, 0, 0, 0);
    r14.setDepthWriteEnabled(true), r14.setClearDepth(1), r14.clear(r14.gl.COLOR_BUFFER_BIT | r14.gl.DEPTH_BUFFER_BIT), r14.setDepthWriteEnabled(false);
  }
  afterRenderPhases(e13) {
    const { context: t15 } = e13;
    t15.bindFramebuffer(this._prevFBO), t15.setStencilFunction(O.EQUAL, 1, 255), t15.setStencilTestEnabled(true), t15.setDepthTestEnabled(false), this.blitTexture(t15, this.getFbos().output.colorTexture, L3.NEAREST);
  }
  beforeRenderLayer(e13, t15, s12) {
    const { context: r14, blendMode: i12, effects: n12, drawPhase: a9, requireFBO: o14 } = e13;
    if (o14 || x3(a9, i12, n12, s12)) {
      const e14 = r14.getBoundFramebufferObject();
      this._prevBeforeLayerFBOStack.push(e14);
      const { width: t16, height: s13 } = r14.getViewport(), i13 = this.acquireFbo(t16, s13);
      r14.bindFramebuffer(i13), r14.setColorMask(true, true, true, true), r14.setClearColor(0, 0, 0, 0), r14.setDepthWriteEnabled(true), r14.setClearDepth(1), r14.clear(r14.gl.COLOR_BUFFER_BIT | r14.gl.DEPTH_BUFFER_BIT), r14.setDepthWriteEnabled(false);
    }
    r14.setDepthWriteEnabled(false), r14.setDepthTestEnabled(false), r14.setStencilTestEnabled(true), r14.setClearStencil(t15), r14.setStencilWriteMask(255), r14.clear(r14.gl.STENCIL_BUFFER_BIT);
  }
  afterRenderLayer(e13, t15) {
    const { context: s12, blendMode: r14, effects: n12, requireFBO: a9, drawPhase: o14 } = e13;
    if (a9 || x3(o14, r14, n12, t15)) {
      const a10 = s12.getBoundFramebufferObject();
      null != n12 && n12.length > 0 && o14 === E3.MAP && (s12.setColorMask(true, true, true, true), this._applyEffects(e13, n12, a10)), s12.bindFramebuffer(this._prevBeforeLayerFBOStack.pop()), s12.setStencilTestEnabled(false), s12.setStencilWriteMask(0), s12.setBlendingEnabled(true), s12.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), s12.setColorMask(true, true, true, true);
      const l11 = null == r14 || o14 === E3.HIGHLIGHT ? "normal" : r14;
      this._blendEffect.draw(e13, a10.colorTexture, L3.NEAREST, l11, t15), this.releaseFbo(a10);
    }
  }
  renderObject(e13, s12, r14, i12) {
    const n12 = h8[r14];
    if (!n12)
      return;
    let a9 = this._brushCache.get(n12);
    void 0 === a9 && (a9 = new n12(), this._brushCache.set(n12, a9)), a9.prepareState(e13), a9.draw(e13, s12, i12);
  }
  renderObjects(e13, s12, r14, i12) {
    const n12 = h8[r14];
    if (!n12)
      return;
    let a9 = this._brushCache.get(n12);
    void 0 === a9 && (a9 = new n12(), this._brushCache.set(n12, a9)), a9.drawMany(e13, s12, i12);
  }
  registerRenderPass(e13) {
    const t15 = e13.brushes.map((e14) => (this._brushCache.has(e14) || this._brushCache.set(e14, new e14()), this._brushCache.get(e14)));
    return new t14(t15, e13);
  }
  blitTexture(e13, t15, s12, r14 = 1) {
    e13.setBlendingEnabled(true), e13.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e13.setColorMask(true, true, true, true), this._blitRenderer.render(e13, t15, s12, r14), this._currentPipelineStateNeedsUpdate = true;
  }
  getPostProcessingEffects(e13) {
    return this._effectsManager.getPostProcessingEffects(e13);
  }
  updateFBOs(e13, t15) {
    if (e13 !== this._lastWidth || t15 !== this._lastHeight) {
      if (this._lastWidth = e13, this._lastHeight = t15, this._fbos) {
        let s13;
        for (s13 in this._fbos)
          this._fbos[s13].resize(e13, t15);
        return;
      }
      const s12 = new e4(e13, t15);
      s12.samplingMode = L3.NEAREST, s12.wrapMode = D2.CLAMP_TO_EDGE;
      const r14 = new i4(B2.DEPTH_STENCIL, e13, t15);
      this._stencilBuf = new s5(this.context, r14), this._fbos = { output: new x2(this.context, s12, this._stencilBuf), effect0: new x2(this.context, s12, this._stencilBuf) };
    }
  }
  _applyEffects(e13, t15, s12) {
    const { context: r14 } = e13, i12 = this._effectsManager.getPostProcessingEffects(t15);
    for (const { postProcessingEffect: n12, effect: a9 } of i12)
      r14.bindFramebuffer(s12), n12.draw(e13, s12, a9);
    this._currentPipelineStateNeedsUpdate = true;
  }
  setShader(e13) {
    this._shaderState.shader = e13.shader, this._shaderState.uniforms = e13.uniforms, this._shaderState.defines = e13.defines, this._shaderState.optionalAttributes = e13.optionalAttributes, this._shaderState.useComputeBuffer = e13.useComputeBuffer ?? false;
  }
  setPipelineState(e13) {
    e13 !== this._currentPipelineState && (this._currentPipelineState = e13, this._currentPipelineStateNeedsUpdate = true);
  }
  submitDraw(e13, t15) {
    const { instance: s12 } = t15, r14 = s12.instanceId, { shader: i12, uniforms: n12, defines: a9, optionalAttributes: o14, useComputeBuffer: l11 } = this._shaderState, h13 = t15.target.getMesh(r14), f10 = { useComputeBuffer: l11, locationInfo: i12.locationInfo, computeAttributeMap: i12.computeAttributes }, c10 = h13.getLayout(f10);
    if (null == c10)
      return null;
    const { primitive: d4, count: u11, offset: p6 } = h13.getDrawArgs(E2.TRIANGLES, t15.count, t15.start * Uint32Array.BYTES_PER_ELEMENT, l11), _5 = this._programCache.getProgram(i12, c10, n12, a9 ?? {}, o14 ?? {});
    _5.setUniforms(n12), _5.bind(e13), this.updatePipelineState(e13), this._updateStencilRef(e13, t15.target);
    const b5 = h13.getVAO(e13, i12.locationInfo, f10);
    return e13.bindVAO(b5), e13.drawElements(d4, u11, C.UNSIGNED_INT, p6), e13.bindVAO(null), _5.cleanupTemporaryTextures(), { vertexShader: _5.vertexShader, fragmentShader: _5.fragmentShader };
  }
  submitDrawQuad(e13) {
    const { shader: t15, uniforms: s12, defines: r14, optionalAttributes: i12 } = this._shaderState, n12 = this._programCache.getProgram(t15, this._quadMesh.layout, s12, r14 ?? {}, i12 ?? {});
    n12.setUniforms(s12), n12.bind(e13), this.updatePipelineState(e13), this._updateStencilRef(e13, null), this._quadMesh.draw(), e13.bindVAO(null), n12.cleanupTemporaryTextures();
  }
  submitDrawMesh(e13, t15, s12) {
    const { shader: r14, uniforms: i12, defines: n12, optionalAttributes: a9 } = this._shaderState, o14 = this._programCache.getProgram(r14, t15.layout, i12, n12 ?? {}, a9 ?? {});
    if (o14.setUniforms(i12), o14.bind(e13), this.updatePipelineState(e13), this._updateStencilRef(e13, null), s12)
      for (const l11 of s12)
        t15.bind(e13, l11), t15.draw(e13);
    else
      for (let l11 = 0; l11 < t15.parts.length; l11++)
        t15.bind(e13, l11), t15.draw(e13);
    t15.unbind(e13), o14.cleanupTemporaryTextures();
  }
  updatePipelineState(e13) {
    this._currentPipelineStateNeedsUpdate && (this._currentPipelineStateNeedsUpdate = false, this._updatePipelineState(e13));
  }
  _updatePipelineState(e13) {
    if (null == this._currentPipelineState)
      throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const { color: t15, depth: s12, stencil: r14 } = this._currentPipelineState;
    if (t15) {
      const { blendMode: s13, write: r15 } = t15;
      switch (e13.setColorMask(...r15), e13.setBlendingEnabled(true), e13.setBlendEquation(T2.ADD), s13) {
        case "composite":
          e13.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA);
          break;
        case "additive":
          e13.setBlendFunctionSeparate(R.ONE, R.ONE, R.ONE, R.ONE);
          break;
        case "custom": {
          const { blendParameters: s14 } = t15, { dstAlpha: r16, dstRGB: i12, srcAlpha: n12, srcRGB: a9 } = s14;
          e13.setBlendFunctionSeparate(a9, i12, n12, r16);
          break;
        }
        case "delete":
          e13.setBlendEquation(T2.REVERSE_SUBTRACT), e13.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA);
      }
    }
    if (s12) {
      const { test: t16, write: r15 } = s12;
      r15 ? (e13.setDepthWriteEnabled(true), e13.setDepthRange(r15.zNear, r15.zFar)) : e13.setDepthWriteEnabled(false), t16 ? (e13.setDepthTestEnabled(true), e13.setDepthFunction(t16)) : e13.setDepthTestEnabled(false);
    } else
      e13.setDepthTestEnabled(false), e13.setDepthWriteEnabled(false);
    if (r14) {
      const { test: t16, write: s13 } = r14;
      if (t16) {
        const { compare: s14, mask: r15, op: i12, ref: n12 } = t16;
        e13.setStencilTestEnabled(true), "function" != typeof n12 && e13.setStencilFunctionSeparate(N.FRONT_AND_BACK, s14, n12, r15), e13.setStencilOpSeparate(N.FRONT_AND_BACK, i12.fail, i12.zFail, i12.zPass);
      } else
        e13.setStencilTestEnabled(false);
      if (s13) {
        const { mask: t17 } = s13;
        e13.setStencilWriteMask(t17);
      } else
        e13.setStencilWriteMask(0);
    } else
      e13.setStencilTestEnabled(false), e13.setStencilWriteMask(0);
  }
  _updateStencilRef(e13, t15) {
    if (null == this._currentPipelineState)
      throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const { stencil: s12 } = this._currentPipelineState;
    if (s12) {
      const { test: r14 } = s12;
      if (r14) {
        const { compare: s13, mask: i12, ref: n12 } = r14;
        "function" == typeof n12 && e13.setStencilFunctionSeparate(N.FRONT_AND_BACK, s13, n12(t15), i12);
      }
    }
  }
};
function x3(e13, t15, s12, r14) {
  return e13 !== E3.LABEL_ALPHA && e13 !== E3.LABEL && e13 !== E3.HIGHLIGHT && (1 !== r14 || null != t15 && "normal" !== t15 || null != s12 && s12.length > 0);
}

// node_modules/@arcgis/core/views/2d/engine/Stage.js
var O2 = 2e3;
var v2 = class extends h6 {
  constructor(t15, i12) {
    super(), this._trash = /* @__PURE__ */ new Set(), this._renderRemainingTime = 0, this._lastFrameRenderTime = 0, this._renderRequested = r5(false), this.stage = this, this._stationary = true, this._reshuffleManager = new s7(), this._canvas = new l5(t15), this.context = new y2(this._canvas.gl, i12.contextOptions ?? {}), this.painter = new D3(this.context, this), this._cimAnalyzer = new w4(this.painter.textureManager.resourceManager), has("esri-2d-profiler") && (this._debugOutput = document.createElement("div"), this._debugOutput.setAttribute("style", "margin: 24px 64px; position: absolute; color: red;"), t15.appendChild(this._debugOutput));
    const a9 = () => this._highlightGradient;
    this._renderParameters = { drawPhase: 0, state: this.state, pixelRatio: window.devicePixelRatio, stationary: false, globalOpacity: 1, blendMode: null, deltaTime: -1, time: 0, inFadeTransition: false, effects: null, context: this.context, painter: this.painter, timeline: i12.timeline || new e11(), renderingOptions: i12.renderingOptions, requestRender: () => this.requestRender(), allowDelayedRender: false, requireFBO: false, profiler: new n5(this.context, this._debugOutput), dataUploadCounter: 0, get highlightGradient() {
      return a9();
    }, reshuffleManager: this._reshuffleManager, backgroundColor: i12.backgroundColor }, this._taskHandle = A({ render: (e13) => this.renderFrame(e13) }), this._taskHandle.pause(), this._lostWebGLContextHandle = this._canvas.events.on("webgl-context-lost", (t16) => this.emit("webgl-error", { error: new s("webgl-context-lost", t16.statusMessage) })), this._bufferPool = new i7(), F3();
  }
  destroy() {
    var _a, _b;
    T4(this.context), this.removeAllChildren(), this._emptyTrash(), this._taskHandle = l(this._taskHandle), this._lostWebGLContextHandle = l(this._lostWebGLContextHandle), this._canvas.destroy(), (_b = (_a = this._debugOutput) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.removeChild(this._debugOutput), this._bufferPool.destroy(), this.painter.dispose(), this.context.dispose(), this._canvas = null;
  }
  get textureManager() {
    return this.painter.textureManager;
  }
  get backgroundColor() {
    return this._renderParameters.backgroundColor;
  }
  set backgroundColor(e13) {
    this._renderParameters.backgroundColor = e13, this.requestRender();
  }
  get bufferPool() {
    return this._bufferPool;
  }
  get cimAnalyzer() {
    return this._cimAnalyzer;
  }
  get renderingOptions() {
    return this._renderingOptions;
  }
  set renderingOptions(e13) {
    this._renderingOptions = e13, this.requestRender();
  }
  get renderRequested() {
    return this._renderRequested.value;
  }
  get state() {
    return this._state;
  }
  set state(e13) {
    this._state = e13, this.requestRender();
  }
  get stationary() {
    return this._stationary;
  }
  set stationary(e13) {
    this._stationary !== e13 && (this._stationary = e13, this.requestRender());
  }
  trashDisplayObject(e13) {
    this._trash.add(e13), this.requestRender();
  }
  untrashDisplayObject(e13) {
    return this._trash.delete(e13);
  }
  requestRender() {
    this._renderRemainingTime = O2, this.renderRequested || (this._renderRequested.value = true, this._taskHandle.resume());
  }
  renderFrame(e13) {
    const t15 = this._lastFrameRenderTime ? e13.time - this._lastFrameRenderTime : 0;
    this._renderRemainingTime -= t15, this._renderRemainingTime <= 0 && this._taskHandle.pause(), this._lastFrameRenderTime = e13.time, this._renderRequested.value = false, this._renderParameters.state = this._state, this._renderParameters.stationary = this.stationary, this._renderParameters.pixelRatio = window.devicePixelRatio, this._renderParameters.globalOpacity = 1, this._renderParameters.time = e13.time, this._renderParameters.deltaTime = e13.deltaTime, this._renderParameters.effects = null, this.processRender(this._renderParameters), this._emptyTrash();
  }
  _createTransforms() {
    return { displayViewScreenMat3: e7() };
  }
  renderChildren(e13) {
    for (const t15 of this.children)
      t15.beforeRender(e13);
    this._reshuffleManager.reshuffle(Ut), this._canvas.render(e13, () => this._renderChildren(this.children, e13));
    for (const t15 of this.children)
      t15.afterRender(e13);
  }
  _renderChildren(e13, t15) {
    const r14 = this.context;
    this.painter.textureUploadManager.upload(), r14.resetInfo(), t15.profiler.recordStart("drawLayers"), t15.dataUploadCounter = 0, this.painter.beforeRenderPhases(t15, t15.backgroundColor, this.state.padding), t15.drawPhase = E3.MAP;
    for (const s12 of e13)
      s12.processRender(t15);
    if (this.children.some((e14) => e14.hasHighlight)) {
      t15.drawPhase = E3.HIGHLIGHT;
      for (const r15 of e13)
        r15.processRender(t15);
    }
    if (this.children.some((e14) => e14.hasLabels)) {
      t15.drawPhase = E3.LABEL;
      for (const r15 of e13)
        r15.processRender(t15);
    }
    if (has("esri-tiles-debug")) {
      t15.drawPhase = E3.DEBUG;
      for (const r15 of e13)
        r15.processRender(t15);
    }
    this.painter.afterRenderPhases(t15), t15.profiler.recordEnd("drawLayers"), r14.logInfo();
  }
  doRender(e13) {
    const t15 = this.context, { state: r14, pixelRatio: s12 } = e13;
    this._canvas.resize(e13), t15.setViewport(0, 0, s12 * r14.size[0], s12 * r14.size[1]), t15.setDepthWriteEnabled(true), t15.setStencilWriteMask(255), this.renderChildren(e13);
  }
  async takeScreenshot(e13, t15, r14, s12) {
    const i12 = Math.round(this.state.size[0] * e13.resolutionScale), n12 = Math.round(this.state.size[1] * e13.resolutionScale), a9 = e13.resolutionScale, o14 = this.context, h13 = this._state.clone();
    if (null != s12) {
      const e14 = h13.viewpoint;
      h13.viewpoint.rotation = s12, h13.viewpoint = e14;
    }
    const d4 = { ...this._renderParameters, drawPhase: null, globalOpacity: 1, stationary: true, state: h13, pixelRatio: a9, time: performance.now(), deltaTime: 0, blendMode: null, effects: null, inFadeTransition: false, backgroundColor: r14 }, l11 = new e4(i12, n12);
    l11.wrapMode = D2.CLAMP_TO_EDGE, l11.internalFormat = P3.RGBA8, l11.isImmutable = true;
    const m7 = new x2(o14, l11, new i4(B2.DEPTH_STENCIL, i12, n12)), c10 = o14.getBoundFramebufferObject(), u11 = o14.getViewport();
    o14.bindFramebuffer(m7), o14.setViewport(0, 0, i12, n12), this._renderChildren(t15 ?? this.children, d4);
    const p6 = this._readbackScreenshot(m7, { ...e13.cropArea, y: n12 - (e13.cropArea.y + e13.cropArea.height) });
    o14.bindFramebuffer(c10), o14.setViewport(u11.x, u11.y, u11.width, u11.height), this.requestRender();
    const f10 = await p6;
    let g3;
    return 1 === e13.outputScale ? g3 = f10 : (g3 = new ImageData(Math.round(f10.width * e13.outputScale), Math.round(f10.height * e13.outputScale)), w3(f10, g3, true)), m7.dispose(), g3;
  }
  async _readbackScreenshot(e13, t15) {
    const r14 = s3(t15.width, t15.height, document.createElement("canvas"));
    return await e13.readPixelsAsync(t15.x, t15.y, t15.width, t15.height, G.RGBA, U2.UNSIGNED_BYTE, new Uint8Array(r14.data.buffer)), r14;
  }
  _emptyTrash() {
    for (; this._trash.size > 0; ) {
      const e13 = Array.from(this._trash);
      this._trash.clear();
      for (const t15 of e13)
        t15.processDetach();
    }
  }
};

// node_modules/@arcgis/core/views/2d/magnifier/MagnifierView2D.js
var A6 = class extends s6 {
  constructor() {
    super(), this._handles = new r(), this._resourcePixelRatio = 1, this.updatingHandles = new h4(), this.visible = false;
  }
  destroy() {
    this._handles = u(this._handles), this._disposeRenderResources(), this._resourcesTask = e(this._resourcesTask);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(e13) {
    this._backgroundColor = e13, this.requestRender();
  }
  get magnifier() {
    return this._magnifier;
  }
  set magnifier(e13) {
    this._magnifier = e13, this._handles.removeAll(), this._handles.add([d2(() => e13.version, () => {
      this.visible = e13.visible && null != e13.position && e13.size > 0, this.requestRender();
    }, P), d2(() => [e13.maskUrl, e13.overlayUrl], () => this._reloadResources()), d2(() => e13.size, () => {
      this._disposeRenderResources(), this.requestRender();
    })]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e7() };
  }
  doRender(e13) {
    const r14 = e13.context;
    if (!this._resourcesTask)
      return void this._reloadResources();
    if (e13.drawPhase !== E3.MAP || !this._canRender())
      return;
    this._updateResources(e13);
    const s12 = this._magnifier;
    if (null == s12.position)
      return;
    const i12 = e13.pixelRatio, o14 = s12.size * i12, a9 = 1 / s12.factor, n12 = Math.ceil(a9 * o14);
    this._readbackTexture.resize(n12, n12);
    const { size: l11 } = e13.state, h13 = i12 * l11[0], m7 = i12 * l11[1], u11 = 0.5 * n12, c10 = 0.5 * n12, d4 = e2(i12 * s12.position.x, u11, h13 - u11 - 1), p6 = e2(m7 - i12 * s12.position.y, c10, m7 - c10 - 1);
    r14.setBlendingEnabled(true);
    const f10 = d4 - u11, g3 = p6 - c10, x4 = this._readbackTexture;
    r14.bindTexture(x4, 0), r14.gl.copyTexImage2D(x4.descriptor.target, 0, x4.descriptor.pixelFormat, f10, g3, n12, n12, 0);
    const T6 = this.backgroundColor, y3 = T6 ? [T6.a * T6.r / 255, T6.a * T6.g / 255, T6.a * T6.b / 255, T6.a] : [1, 1, 1, 1], k2 = (d4 + s12.offset.x * i12) / h13 * 2 - 1, R3 = (p6 - s12.offset.y * i12) / m7 * 2 - 1, v3 = o14 / h13 * 2, j4 = o14 / m7 * 2, w5 = this._program;
    r14.bindVAO(this._vertexArrayObject), r14.bindTexture(this._overlayTexture, 6), r14.bindTexture(this._maskTexture, 7), r14.useProgram(w5), w5.setUniform4fv("u_background", y3), w5.setUniform1i("u_readbackTexture", 0), w5.setUniform1i("u_overlayTexture", 6), w5.setUniform1i("u_maskTexture", 7), w5.setUniform4f("u_drawPos", k2, R3, v3, j4), w5.setUniform1i("u_maskEnabled", s12.maskEnabled ? 1 : 0), w5.setUniform1i("u_overlayEnabled", s12.overlayEnabled ? 1 : 0), r14.setStencilTestEnabled(false), r14.setColorMask(true, true, true, true), r14.drawArrays(E2.TRIANGLE_STRIP, 0, 4), r14.bindVAO();
  }
  _canRender() {
    return this._mask && this._overlay && null != this._magnifier;
  }
  _reloadResources() {
    this._resourcesTask && this._resourcesTask.abort();
    const s12 = null != this._magnifier ? this._magnifier.maskUrl : null, t15 = null != this._magnifier ? this._magnifier.overlayUrl : null;
    this._resourcesTask = d(async (r14) => {
      const i12 = null == s12 || null == t15 ? s8(r14) : null, o14 = null != s12 ? U(s12, { responseType: "image", signal: r14 }).then((e13) => e13.data) : i12.then((e13) => e13.mask), a9 = null != t15 ? U(t15, { responseType: "image", signal: r14 }).then((e13) => e13.data) : i12.then((e13) => e13.overlay), [n12, l11] = await Promise.all([o14, a9]);
      this._mask = n12, this._overlay = l11, this._disposeRenderResources(), this.requestRender();
    }), this.updatingHandles.addPromise(this._resourcesTask.promise);
  }
  _disposeRenderResources() {
    this._readbackTexture = r3(this._readbackTexture), this._overlayTexture = r3(this._overlayTexture), this._maskTexture = r3(this._maskTexture), this._vertexArrayObject = r3(this._vertexArrayObject), this._program = r3(this._program);
  }
  _updateResources(e13) {
    if (e13.pixelRatio !== this._resourcePixelRatio && this._disposeRenderResources(), this._readbackTexture)
      return;
    const r14 = e13.context;
    this._resourcePixelRatio = e13.pixelRatio;
    const s12 = Math.ceil(this._magnifier.size * e13.pixelRatio);
    this._program = t10(r14);
    const t15 = new Uint16Array([0, 1, 0, 0, 1, 1, 1, 0]), i12 = a5.attributes;
    this._vertexArrayObject = new o8(r14, i12, m4, { geometry: h5.createVertex(r14, F2.STATIC_DRAW, t15) }), this._overlay.width = s12, this._overlay.height = s12;
    const o14 = new e4();
    o14.internalFormat = G.RGBA, o14.wrapMode = D2.CLAMP_TO_EDGE, o14.samplingMode = L3.NEAREST, o14.flipped = true, o14.preMultiplyAlpha = !Pt(this._overlay.src) || !e13.context.driverTest.svgPremultipliesAlpha.result, this._overlayTexture = new m2(r14, o14, this._overlay), this._mask.width = s12, this._mask.height = s12, o14.pixelFormat = o14.internalFormat = G.ALPHA, this._maskTexture = new m2(r14, o14, this._mask);
    const a9 = 1 / this._magnifier.factor;
    o14.pixelFormat = o14.internalFormat = G.RGBA, o14.width = o14.height = Math.ceil(a9 * s12), o14.samplingMode = L3.LINEAR, o14.flipped = false, this._readbackTexture = new m2(r14, o14);
  }
};
export {
  t9 as GraphicContainer,
  $2 as GraphicsView2D,
  a4 as LabelManager,
  A6 as MagnifierView2D,
  f7 as MapViewNavigation,
  v2 as Stage
};
//# sourceMappingURL=mapViewDeps-YP5NRFOP.js.map
