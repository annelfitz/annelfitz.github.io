import {
  a as a3
} from "./chunk-SBL4URUW.js";
import {
  b,
  c2 as c,
  m,
  u2 as u
} from "./chunk-JGDJR5EV.js";
import {
  a,
  a2,
  n2 as n,
  r,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has,
  k
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/portal/support/urlUtils.js
var e = /^https:\/\/([a-z\d-]+)(\.maps([^.]*))?\.arcgis\.com/i;
var s2 = { devext: { customBaseUrl: "mapsdevext.arcgis.com", portalHostname: "devext.arcgis.com" }, qaext: { customBaseUrl: "mapsqa.arcgis.com", portalHostname: "qaext.arcgis.com" }, www: { customBaseUrl: "maps.arcgis.com", portalHostname: "www.arcgis.com" } };
function a4(a7) {
  const t5 = a7 == null ? void 0 : a7.match(e);
  if (!t5)
    return null;
  const [, r3, o, l3] = t5;
  if (!r3)
    return null;
  let c6 = null, m5 = null, n4 = null;
  const { devext: u3, qaext: i3, www: p2 } = s2;
  if (o)
    if (c6 = r3, l3)
      switch (l3.toLowerCase()) {
        case "devext":
          ({ customBaseUrl: m5, portalHostname: n4 } = u3);
          break;
        case "qa":
          ({ customBaseUrl: m5, portalHostname: n4 } = i3);
          break;
        default:
          return null;
      }
    else
      ({ customBaseUrl: m5, portalHostname: n4 } = p2);
  else
    switch (r3.toLowerCase()) {
      case "devext":
        ({ customBaseUrl: m5, portalHostname: n4 } = u3);
        break;
      case "qaext":
        ({ customBaseUrl: m5, portalHostname: n4 } = i3);
        break;
      case "www":
        ({ customBaseUrl: m5, portalHostname: n4 } = p2);
        break;
      default:
        return null;
    }
  return { customBaseUrl: m5, isPortal: false, portalHostname: n4, urlKey: c6 };
}
function t(e2) {
  return /\/(sharing|usrsvcs)\/(appservices|servers)\//i.test(e2);
}

// node_modules/@arcgis/core/support/base64Utils.js
function t2(t5) {
  const n4 = atob(t5), r3 = new Uint8Array(n4.length);
  for (let e2 = 0; e2 < n4.length; e2++)
    r3[e2] = n4.charCodeAt(e2);
  return r3.buffer;
}
function n2(t5) {
  const n4 = new Uint8Array(t5);
  let r3 = "";
  for (let e2 = 0; e2 < n4.length; e2++)
    r3 += String.fromCharCode(n4[e2]);
  return btoa(r3);
}

// node_modules/@arcgis/core/core/urlUtils.js
var l = () => n.getLogger("esri.core.urlUtils");
var c2 = r.request;
var f = "esri/config: esriConfig.request.proxyUrl is not set.";
var a5 = /^\s*[a-z][a-z0-9-+.]*:(?![0-9])/i;
var p = /^\s*http:/i;
var h = /^\s*https:/i;
var d = /^\s*file:/i;
var m2 = /:\d+$/;
var g = /^https?:\/\/[^/]+\.arcgis.com\/sharing(\/|$)/i;
var y = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$");
var $ = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$");
var x = class {
  constructor(t5 = "") {
    this.uri = t5, this.scheme = null, this.authority = null, this.path = null, this.query = null, this.fragment = null, this.user = null, this.password = null, this.host = null, this.port = null;
    let n4 = this.uri.match(y);
    this.scheme = n4[2] || (n4[1] ? "" : null), this.authority = n4[4] || (n4[3] ? "" : null), this.path = n4[5], this.query = n4[7] || (n4[6] ? "" : null), this.fragment = n4[9] || (n4[8] ? "" : null), null != this.authority && (n4 = this.authority.match($), this.user = n4[3] || null, this.password = n4[4] || null, this.host = n4[6] || n4[7], this.port = n4[9] || null);
  }
  toString() {
    return this.uri;
  }
};
var w = {};
var O = new x(r.applicationUrl);
var U = O;
var R = j();
var b2 = R;
var C = () => U;
var q = () => b2;
function j() {
  const t5 = U.path, n4 = t5.substring(0, t5.lastIndexOf(t5.split("/")[t5.split("/").length - 1]));
  return `${`${U.scheme}://${U.host}${null != U.port ? `:${U.port}` : ""}`}${n4}`;
}
function I(t5) {
  if (!t5)
    return null;
  const n4 = { path: null, query: null }, e2 = new x(t5), r3 = t5.indexOf("?");
  return null === e2.query ? n4.path = t5 : (n4.path = t5.substring(0, r3), n4.query = A(e2.query)), e2.fragment && (n4.hash = e2.fragment, null === e2.query && (n4.path = n4.path.substring(0, n4.path.length - (e2.fragment.length + 1)))), n4;
}
function A(t5) {
  const n4 = t5.split("&"), e2 = {};
  for (const r3 of n4) {
    if (!r3)
      continue;
    const t6 = r3.indexOf("=");
    let n5, o;
    t6 < 0 ? (n5 = decodeURIComponent(r3), o = "") : (n5 = decodeURIComponent(r3.slice(0, t6)), o = decodeURIComponent(r3.slice(t6 + 1)));
    let s3 = e2[n5];
    "string" == typeof s3 && (s3 = e2[n5] = [s3]), Array.isArray(s3) ? s3.push(o) : e2[n5] = o;
  }
  return e2;
}
function v(t5, n4) {
  return t5 ? n4 && "function" == typeof n4 ? Object.keys(t5).map((e2) => encodeURIComponent(e2) + "=" + encodeURIComponent(n4(e2, t5[e2]))).join("&") : Object.keys(t5).map((e2) => {
    const o = t5[e2];
    if (null == o)
      return "";
    const s3 = encodeURIComponent(e2) + "=", i3 = n4 == null ? void 0 : n4[e2];
    return i3 ? s3 + encodeURIComponent(i3(o)) : Array.isArray(o) ? o.map((t6) => a3(t6) ? s3 + encodeURIComponent(JSON.stringify(t6)) : s3 + encodeURIComponent(t6)).join("&") : a3(o) ? s3 + encodeURIComponent(JSON.stringify(o)) : s3 + encodeURIComponent(o);
  }).filter((t6) => t6).join("&") : "";
}
function P(t5 = false) {
  let n4, r3 = c2.proxyUrl;
  if ("string" == typeof t5) {
    n4 = dt(t5);
    const e2 = T(t5);
    e2 && (r3 = e2.proxyUrl);
  } else
    n4 = !!t5;
  if (!r3)
    throw l().warn(f), new s("urlUtils:proxy-not-set", f);
  n4 && wt() && (r3 = $t(r3));
  return I(r3);
}
function S(t5) {
  const n4 = T(t5);
  let e2, r3;
  if (n4) {
    const t6 = E(n4.proxyUrl);
    e2 = t6.path, r3 = t6.query ? A(t6.query) : null;
  }
  if (e2) {
    const n5 = I(t5);
    t5 = e2 + "?" + n5.path;
    const o = v({ ...r3, ...n5.query });
    o && (t5 = `${t5}?${o}`);
  }
  return t5;
}
var k2 = { path: "", query: "" };
function E(t5) {
  const n4 = t5.indexOf("?");
  return -1 !== n4 ? (k2.path = t5.slice(0, n4), k2.query = t5.slice(n4 + 1)) : (k2.path = t5, k2.query = null), k2;
}
function B(t5) {
  return t5 = (t5 = Ot(t5 = Ct(t5 = E(t5).path), true)).toLowerCase();
}
function H(t5) {
  const n4 = { proxyUrl: t5.proxyUrl, urlPrefix: B(t5.urlPrefix) }, e2 = c2.proxyRules, r3 = n4.urlPrefix;
  let o = e2.length;
  for (let s3 = 0; s3 < e2.length; s3++) {
    const t6 = e2[s3].urlPrefix;
    if (0 === r3.indexOf(t6)) {
      if (r3.length === t6.length)
        return -1;
      o = s3;
      break;
    }
    0 === t6.indexOf(r3) && (o = s3 + 1);
  }
  return e2.splice(o, 0, n4), o;
}
function T(t5) {
  const n4 = c2.proxyRules, e2 = B(t5);
  for (let r3 = 0; r3 < n4.length; r3++)
    if (0 === e2.indexOf(n4[r3].urlPrefix))
      return n4[r3];
}
function W(t5, n4) {
  if (!t5 || !n4)
    return false;
  t5 = z(t5), n4 = z(n4);
  const e2 = a4(t5), r3 = a4(n4);
  return null != e2 && null != r3 ? e2.portalHostname === r3.portalHostname : null == e2 && null == r3 && F(t5, n4, true);
}
function N(t5, n4) {
  return t5 = z(t5), n4 = z(n4), Ot(t5) === Ot(n4);
}
function z(t5) {
  const n4 = (t5 = K(t5)).indexOf("/sharing");
  return n4 > 0 ? t5.substring(0, n4) : t5.replace(/\/+$/, "");
}
function D(t5) {
  const n4 = (n5) => null == n5 || n5 instanceof RegExp && n5.test(t5) || "string" == typeof n5 && t5.startsWith(n5), e2 = c2.interceptors;
  if (e2) {
    for (const r3 of e2)
      if (Array.isArray(r3.urls)) {
        if (r3.urls.some(n4))
          return r3;
      } else if (n4(r3.urls))
        return r3;
  }
  return null;
}
function F(t5, n4, e2 = false) {
  if (!t5 || !n4)
    return false;
  const r3 = vt(t5), o = vt(n4);
  return !(!e2 && r3.scheme !== o.scheme) && (null != r3.host && null != o.host && (r3.host.toLowerCase() === o.host.toLowerCase() && r3.port === o.port));
}
function M(t5) {
  if ("string" == typeof t5) {
    if (!Y(t5))
      return true;
    t5 = vt(t5);
  }
  if (F(t5, U))
    return true;
  const n4 = c2.trustedServers || [];
  for (let e2 = 0; e2 < n4.length; e2++) {
    const r3 = Q(n4[e2]);
    for (let n5 = 0; n5 < r3.length; n5++)
      if (F(t5, r3[n5]))
        return true;
  }
  return false;
}
function Q(t5) {
  return w[t5] || (ht(t5) || pt(t5) ? w[t5] = [new x(_(t5))] : w[t5] = [new x(`http://${t5}`), new x(`https://${t5}`)]), w[t5];
}
function _(t5, n4 = b2, e2) {
  return pt(t5) ? e2 && e2.preserveProtocolRelative ? t5 : "http" === U.scheme && U.authority === X(t5).slice(2) ? `http:${t5}` : `https:${t5}` : ht(t5) ? t5 : V("/" === t5[0] ? Ut(n4) : n4, t5);
}
function G(t5, n4 = b2, e2) {
  if (null == t5 || !Y(t5))
    return t5;
  const r3 = K(t5), o = r3.toLowerCase(), s3 = K(n4).toLowerCase().replace(/\/+$/, ""), i3 = e2 ? K(e2).toLowerCase().replace(/\/+$/, "") : null;
  if (i3 && 0 !== s3.indexOf(i3))
    return t5;
  const u3 = (t6, n5, e3) => -1 === (e3 = t6.indexOf(n5, e3)) ? t6.length : e3;
  let l3 = u3(o, "/", o.indexOf("//") + 2), c6 = -1;
  for (; o.slice(0, l3 + 1) === s3.slice(0, l3) + "/" && (c6 = l3 + 1, l3 !== o.length); )
    l3 = u3(o, "/", l3 + 1);
  if (-1 === c6)
    return t5;
  if (i3 && c6 < i3.length)
    return t5;
  t5 = r3.slice(c6);
  const f3 = s3.slice(c6 - 1).replaceAll(/[^/]+/g, "").length;
  if (f3 > 0)
    for (let a7 = 0; a7 < f3; a7++)
      t5 = `../${t5}`;
  else
    t5 = `./${t5}`;
  return t5;
}
function K(t5) {
  return t5 = It(t5 = Lt(t5 = jt(t5 = _(t5 = t5.trim()))));
}
function V(...t5) {
  const e2 = t5.filter(k);
  if (!(e2 == null ? void 0 : e2.length))
    return;
  const r3 = [];
  if (Y(e2[0])) {
    const t6 = e2[0], n4 = t6.indexOf("//");
    -1 !== n4 && (r3.push(t6.slice(0, n4 + 1)), gt(e2[0]) && (r3[0] += "/"), e2[0] = t6.slice(n4 + 2));
  } else
    "/" === e2[0][0] && r3.push("");
  const o = e2.reduce((t6, n4) => n4 ? t6.concat(n4.split("/")) : t6, []);
  for (let n4 = 0; n4 < o.length; n4++) {
    const t6 = o[n4];
    ".." === t6 && r3.length > 0 && ".." !== r3[r3.length - 1] ? r3.pop() : (!t6 && n4 === o.length - 1 || t6 && ("." !== t6 || 0 === r3.length)) && r3.push(t6);
  }
  return r3.join("/");
}
function X(t5, n4 = false) {
  if (null == t5 || Z(t5) || tt(t5))
    return null;
  let e2 = t5.indexOf("://");
  if (-1 === e2 && pt(t5))
    e2 = 2;
  else {
    if (-1 === e2)
      return null;
    e2 += 3;
  }
  const r3 = t5.indexOf("/", e2);
  return -1 !== r3 && (t5 = t5.slice(0, r3)), n4 && (t5 = Ot(t5, true)), t5;
}
function Y(t5) {
  return pt(t5) || ht(t5);
}
function Z(t5) {
  return null != t5 && "blob:" === t5.slice(0, 5);
}
function tt(t5) {
  return null != t5 && "data:" === t5.slice(0, 5);
}
function nt(t5) {
  const n4 = ot(t5);
  return n4 && n4.isBase64 ? t2(n4.data) : null;
}
function et(t5) {
  return n2(t5).replaceAll("+", "-").replaceAll("/", "_").replace(/=+$/, "");
}
var rt = /^data:(.*?)(;base64)?,(.*)$/;
function ot(t5) {
  const n4 = t5.match(rt);
  if (!n4)
    return null;
  const [, e2, r3, o] = n4;
  return { mediaType: e2, isBase64: !!r3, data: o };
}
function st(t5) {
  return t5.isBase64 ? `data:${t5.mediaType};base64,${t5.data}` : `data:${t5.mediaType},${t5.data}`;
}
async function it(t5) {
  return (await fetch(t5)).blob();
}
function ut(t5) {
  const n4 = nt(t5);
  if (!n4)
    return null;
  const e2 = ot(t5);
  return new Blob([n4], { type: e2.mediaType });
}
function ct(t5, n4) {
  at(t5, n4);
}
function at(t5, n4) {
  if (!t5)
    return false;
  const e2 = document.createElement("a");
  if (!("download" in e2))
    return false;
  const r3 = URL.createObjectURL(t5);
  return e2.download = n4, e2.href = r3, e2.style.display = "none", document.body.appendChild(e2), e2.click(), document.body.removeChild(e2), URL.revokeObjectURL(r3), true;
}
function pt(t5) {
  return null != t5 && "/" === t5[0] && "/" === t5[1];
}
function ht(t5) {
  return null != t5 && a5.test(t5);
}
function dt(t5) {
  return null != t5 && h.test(t5) || "https" === U.scheme && pt(t5);
}
function mt(t5) {
  return null != t5 && p.test(t5) || "http" === U.scheme && pt(t5);
}
function gt(t5) {
  return null != t5 && d.test(t5);
}
function $t(t5) {
  return pt(t5) ? `https:${t5}` : t5.replace(p, "https:");
}
function xt() {
  return "http" === U.scheme;
}
function wt() {
  return "https" === U.scheme;
}
function Ot(t5, n4 = false) {
  return pt(t5) ? t5.slice(2) : (t5 = t5.replace(a5, ""), n4 && t5.length > 1 && "/" === t5[0] && "/" === t5[1] && (t5 = t5.slice(2)), t5);
}
function Ut(t5) {
  const n4 = t5.indexOf("//"), e2 = t5.indexOf("/", n4 + 2);
  return -1 === e2 ? t5 : t5.slice(0, e2);
}
function Rt(t5) {
  let n4 = 0;
  if (Y(t5)) {
    const e3 = t5.indexOf("//");
    -1 !== e3 && (n4 = e3 + 2);
  }
  const e2 = t5.lastIndexOf("/");
  return e2 < n4 ? t5 : t5.slice(0, e2 + 1);
}
function bt(t5, n4) {
  if (!t5)
    return "";
  const e2 = I(t5).path.replace(/\/+$/, ""), r3 = e2.substring(e2.lastIndexOf("/") + 1);
  if (!(n4 == null ? void 0 : n4.length))
    return r3;
  const o = new RegExp(`.(${n4.join("|")})$`, "ig");
  return r3.replace(o, "");
}
function Ct(t5) {
  return t5.endsWith("/") ? t5 : `${t5}/`;
}
function qt(t5) {
  return t5.replace(/\/+$/, "");
}
function jt(t5) {
  if (/^https?:\/\//i.test(t5)) {
    const n4 = E(t5);
    t5 = (t5 = n4.path.replaceAll(/\/{2,}/g, "/")).replace("/", "//"), n4.query && (t5 += `?${n4.query}`);
  }
  return t5;
}
function Lt(t5) {
  return t5.replace(/^(https?:\/\/)(arcgis\.com)/i, "$1www.$2");
}
function It(t5) {
  const n4 = c2.httpsDomains;
  if (!mt(t5))
    return t5;
  const e2 = t5.indexOf("/", 7);
  let r3;
  if (r3 = -1 === e2 ? t5 : t5.slice(0, e2), r3 = r3.toLowerCase().slice(7), m2.test(r3)) {
    if (!r3.endsWith(":80"))
      return t5;
    r3 = r3.slice(0, -3), t5 = t5.replace(":80", "");
  }
  return xt() && r3 === U.authority && !g.test(t5) || (wt() && r3 === U.authority || n4 && n4.some((t6) => r3 === t6 || r3.endsWith(`.${t6}`)) || wt() && !T(t5)) && (t5 = $t(t5)), t5;
}
function At(t5, n4, e2) {
  if (!(n4 && e2 && t5 && Y(t5)))
    return t5;
  const r3 = t5.indexOf("//"), o = t5.indexOf("/", r3 + 2), s3 = t5.indexOf(":", r3 + 2), i3 = Math.min(o < 0 ? t5.length : o, s3 < 0 ? t5.length : s3);
  if (t5.slice(r3 + 2, i3).toLowerCase() !== n4.toLowerCase())
    return t5;
  return `${t5.slice(0, r3 + 2)}${e2}${t5.slice(i3)}`;
}
function vt(t5) {
  return "string" == typeof t5 ? new x(_(t5)) : (t5.scheme || (t5.scheme = U.scheme), t5);
}
function Pt(t5) {
  return Nt.test(t5);
}
function St(t5, n4) {
  const e2 = I(t5), r3 = Object.keys(e2.query || {});
  return r3.length > 0 && n4 && n4.warn("removeQueryParameters()", `Url query parameters are not supported, the following parameters have been removed: ${r3.join(", ")}.`), e2.path;
}
function kt(t5, n4, e2) {
  const r3 = I(t5), o = r3.query || {};
  return o[n4] = String(e2), `${r3.path}?${v(o)}`;
}
function Et(t5, n4) {
  if (!n4)
    return t5;
  const e2 = I(t5), r3 = e2.query || {};
  for (const [s3, i3] of Object.entries(n4))
    null != i3 && (r3[s3] = i3);
  const o = v(r3);
  return o ? `${e2.path}?${o}` : e2.path;
}
function Ht(t5) {
  if (null == t5)
    return null;
  const n4 = t5.match(Jt);
  return n4 ? n4[2] : null;
}
function Tt(t5) {
  if (null == t5)
    return null;
  const n4 = t5.match(Jt);
  return n4 ? { path: n4[1], extension: n4[2] } : { path: t5, extension: null };
}
async function Wt(t5) {
  if ("string" == typeof t5) {
    return ot(t5) ?? { data: t5 };
  }
  return new Promise((n4, e2) => {
    const r3 = new FileReader();
    r3.readAsDataURL(t5), r3.onload = () => n4(ot(r3.result)), r3.onerror = (t6) => e2(t6);
  });
}
var Jt = /([^.]*)\.([^\/]*)$/;
var Nt = /(^data:image\/svg|\.svg$)/i;

// node_modules/@arcgis/core/kernel.js
Symbol.dispose ?? (Symbol.dispose = Symbol("Symbol.dispose")), Symbol.asyncDispose ?? (Symbol.asyncDispose = Symbol("Symbol.asyncDispose"));
var r2 = "4.30";
var t3;
var n3 = r2;
n3 = `${"4.30.0"}-next.${a2}`;
function i(o) {
  t3 = o;
}
function m3(s3) {
  const e2 = t3 == null ? void 0 : t3.findCredential(s3);
  return (e2 == null ? void 0 : e2.token) ? kt(s3, "token", e2.token) : s3;
}
has("host-webworker");

// node_modules/@arcgis/core/support/apiKeyUtils.js
var t4 = /* @__PURE__ */ new Set(["elevation3d.arcgis.com", "js.arcgis.com", "jsdev.arcgis.com", "jsqa.arcgis.com", "static.arcgis.com"]);
function c4(r3) {
  const c6 = X(r3, true);
  return !!c6 && (c6.endsWith(".arcgis.com") && !t4.has(c6) && !r3.endsWith("/sharing/rest/generateToken"));
}

// node_modules/@arcgis/core/support/requestUtils.js
function i2(e2, o, t5 = false, n4) {
  return new Promise((s3, i3) => {
    if (c(n4))
      return void i3(c5());
    let a7 = () => {
      l3(), i3(new Error(`Unable to load ${o}`));
    }, u3 = () => {
      const r3 = e2;
      l3(), s3(r3);
    }, m5 = () => {
      if (!e2)
        return;
      const r3 = e2;
      l3(), r3.src = "", i3(c5());
    };
    const l3 = () => {
      has("esri-image-decode") || (e2.removeEventListener("error", a7), e2.removeEventListener("load", u3)), a7 = null, u3 = null, e2 = null, null != n4 && n4.removeEventListener("abort", m5), m5 = null, t5 && URL.revokeObjectURL(o);
    };
    null != n4 && n4.addEventListener("abort", m5), has("esri-image-decode") ? e2.decode().then(u3, a7) : (e2.addEventListener("error", a7), e2.addEventListener("load", u3));
  });
}
function c5() {
  try {
    return new DOMException("Aborted", "AbortError");
  } catch {
    const e2 = new Error();
    return e2.name = "AbortError", e2;
  }
}
var a6 = "Timeout exceeded";
function u2() {
  return new Error(a6);
}
function m4(e2) {
  return "object" == typeof e2 && !!e2 && "message" in e2 && e2.message === a6;
}
function l2(r3) {
  r.request.crossOriginNoCorsDomains || (r.request.crossOriginNoCorsDomains = {});
  const t5 = r.request.crossOriginNoCorsDomains;
  for (let e2 of r3)
    e2 = e2.toLowerCase(), /^https?:\/\//.test(e2) ? t5[X(e2) ?? ""] = 0 : (t5[X("http://" + e2) ?? ""] = 0, t5[X("https://" + e2) ?? ""] = 0);
}
function d2(r3) {
  const s3 = r.request.crossOriginNoCorsDomains;
  if (s3) {
    let e2 = X(r3);
    if (e2)
      return e2 = e2.toLowerCase(), !F(e2, C()) && s3[e2] < Date.now() - 36e5;
  }
  return false;
}
async function f2(r3) {
  var _a;
  const t5 = r.request.crossOriginNoCorsDomains, n4 = X(r3);
  t5 && n4 && (t5[n4.toLowerCase()] = Date.now());
  const i3 = I(r3);
  r3 = i3.path, "json" === ((_a = i3.query) == null ? void 0 : _a.f) && (r3 += "?f=json");
  try {
    await fetch(r3, { mode: "no-cors", credentials: "include" });
  } catch {
  }
}

// node_modules/@arcgis/core/request.js
async function U2(e2, t5) {
  var _a;
  e2 instanceof URL && (e2 = e2.toString()), (t5 == null ? void 0 : t5.query) instanceof URLSearchParams && (t5.query = A(t5.query.toString().replaceAll("+", " ")));
  const r3 = tt(e2), s3 = Z(e2);
  s3 || r3 || (e2 = K(e2));
  const a7 = { url: e2, requestOptions: { ...t5 } };
  let n4 = D(e2);
  if (n4) {
    const e3 = await G2(n4, a7);
    if (null != e3)
      return { data: e3, getAllHeaders: H2, getHeader: H2, httpStatus: 200, requestOptions: a7.requestOptions, url: a7.url };
    n4.after || n4.error || (n4 = null);
  }
  if (e2 = a7.url, "image" === (t5 = a7.requestOptions).responseType && (has("host-webworker") || has("host-node")))
    throw N2("request:invalid-parameters", new Error("responseType 'image' is not supported in Web Workers or Node environment"), a7);
  if ("head" === t5.method) {
    if (t5.body)
      throw N2("request:invalid-parameters", new Error("body parameter cannot be set when method is 'head'"), a7);
    if (r3 || s3)
      throw N2("request:invalid-parameters", new Error("data and blob URLs are not supported for method 'head'"), a7);
  }
  if (await B2(), j2)
    return j2.execute(e2, t5);
  const i3 = new AbortController();
  m(t5, () => i3.abort());
  const h2 = { controller: i3, credential: void 0, credentialToken: void 0, fetchOptions: void 0, hasToken: false, interceptor: n4, params: a7, redoRequest: false, useIdentity: A2.useIdentity, useProxy: false, useSSL: false, withCredentials: false }, m5 = await Q2(h2);
  return (_a = n4 == null ? void 0 : n4.after) == null ? void 0 : _a.call(n4, m5), m5;
}
var j2;
var A2 = r.request;
var P2 = "FormData" in globalThis;
var _2 = /* @__PURE__ */ new Set([499, 498, 403, 401]);
var D2 = /* @__PURE__ */ new Set(["COM_0056", "COM_0057", "SB_0008"]);
var F2 = [/\/arcgis\/tokens/i, /\/sharing(\/rest)?\/generatetoken/i, /\/rest\/info/i];
var H2 = () => null;
var I2 = Symbol();
function R2(e2) {
  const t5 = X(e2);
  t5 && !U2._corsServers.includes(t5) && U2._corsServers.push(t5);
}
function M2(e2) {
  const t5 = X(e2);
  return !t5 || t5.endsWith(".arcgis.com") || U2._corsServers.includes(t5) || M(t5);
}
function N2(e2, t5, o, i3) {
  let l3 = "Error";
  const u3 = { url: o.url, requestOptions: o.requestOptions, getAllHeaders: H2, getHeader: H2, ssl: false };
  if (t5 instanceof s)
    return t5.details ? (t5.details = a(t5.details), t5.details.url = o.url, t5.details.requestOptions = o.requestOptions) : t5.details = u3, t5;
  if (t5) {
    const e3 = i3 && (() => Array.from(i3.headers)), r3 = i3 && ((e4) => i3.headers.get(e4)), s3 = i3 == null ? void 0 : i3.status, o2 = t5.message;
    o2 && (l3 = o2), e3 && r3 && (u3.getAllHeaders = e3, u3.getHeader = r3), u3.httpStatus = (null != t5.httpCode ? t5.httpCode : t5.code) || s3 || 0, u3.subCode = t5.subcode, u3.messageCode = t5.messageCode, "string" == typeof t5.details ? u3.messages = [t5.details] : u3.messages = t5.details, u3.raw = I2 in t5 ? t5[I2] : t5;
  }
  return b(t5) ? u() : new s(e2, l3, u3);
}
async function B2() {
  has("host-webworker") && !j2 && (j2 = await import("./request-6PRYT5ZH.js"));
}
async function $2() {
  t3 || await import("./IdentityManager-NGZBG6JT.js");
}
async function z2(r3) {
  var _a;
  const s3 = r3.params.url, o = r3.params.requestOptions, a7 = r3.controller.signal, n4 = o.body;
  let l3 = null, u3 = null;
  if (P2 && "HTMLFormElement" in globalThis && (n4 instanceof FormData ? l3 = n4 : n4 instanceof HTMLFormElement && (l3 = new FormData(n4))), "string" == typeof n4 && (u3 = n4), r3.fetchOptions = { cache: o.cacheBust ? "no-cache" : "default", credentials: "same-origin", headers: o.headers || {}, method: "head" === o.method ? "HEAD" : "GET", mode: "cors", priority: A2.priority, redirect: "follow", signal: a7 }, (l3 || u3) && (r3.fetchOptions.body = l3 || u3), "anonymous" === o.authMode && (r3.useIdentity = false), r3.hasToken = !!(/token=/i.test(s3) || ((_a = o.query) == null ? void 0 : _a.token) || (l3 == null ? void 0 : l3.get("token"))), !r3.hasToken && r.apiKey && c4(s3) && (o.query || (o.query = {}), o.query.token = r.apiKey, r3.hasToken = true), r3.useIdentity && !r3.hasToken && !r3.credentialToken && !K2(s3) && !c(a7)) {
    let e2;
    "immediate" === o.authMode ? (await $2(), e2 = await t3.getCredential(s3, { signal: a7 }), r3.credential = e2) : "no-prompt" === o.authMode ? (await $2(), e2 = await t3.getCredential(s3, { prompt: false, signal: a7 }).catch(() => {
    }), r3.credential = e2) : t3 && (e2 = t3.findCredential(s3)), e2 && (r3.credentialToken = e2.token, r3.useSSL = !!e2.ssl);
  }
}
function K2(e2) {
  return F2.some((t5) => t5.test(e2));
}
async function W2(e2) {
  let r3 = e2.params.url;
  const s3 = e2.params.requestOptions, o = e2.fetchOptions ?? {}, a7 = Z(r3) || tt(r3), i3 = s3.responseType || "json", l3 = a7 ? 0 : null != s3.timeout ? s3.timeout : A2.timeout;
  let d3 = false;
  if (!a7) {
    e2.useSSL && (r3 = $t(r3));
    let a8 = { ...s3.query };
    e2.credentialToken && (a8.token = e2.credentialToken);
    let n4 = v(a8);
    has("esri-url-encodes-apostrophe") && (n4 = n4.replaceAll("'", "%27"));
    const i4 = r3.length + 1 + n4.length;
    let l4;
    d3 = "delete" === s3.method || "post" === s3.method || "put" === s3.method || !!s3.body || i4 > A2.maxUrlLength;
    const u3 = s3.useProxy || !!T(r3);
    if (u3) {
      const e3 = P(r3);
      l4 = e3.path, !d3 && l4.length + 1 + i4 > A2.maxUrlLength && (d3 = true), e3.query && (a8 = { ...e3.query, ...a8 });
    }
    if ("HEAD" === o.method && (d3 || u3)) {
      if (d3) {
        if (i4 > A2.maxUrlLength)
          throw N2("request:invalid-parameters", new Error("URL exceeds maximum length"), e2.params);
        throw N2("request:invalid-parameters", new Error("cannot use POST request when method is 'head'"), e2.params);
      }
      if (u3)
        throw N2("request:invalid-parameters", new Error("cannot use proxy when method is 'head'"), e2.params);
    }
    if (d3 ? (o.method = "delete" === s3.method ? "DELETE" : "put" === s3.method ? "PUT" : "POST", s3.body ? r3 = Et(r3, a8) : (o.body = v(a8), o.headers || (o.headers = {}), o.headers["Content-Type"] = "application/x-www-form-urlencoded")) : r3 = Et(r3, a8), u3 && (e2.useProxy = true, r3 = `${l4}?${r3}`), a8.token && P2 && o.body instanceof FormData && !t(r3) && o.body.set("token", a8.token), s3.hasOwnProperty("withCredentials"))
      e2.withCredentials = s3.withCredentials;
    else if (!F(r3, C())) {
      if (M(r3))
        e2.withCredentials = true;
      else if (t3) {
        const s4 = t3.findServerInfo(r3);
        (s4 == null ? void 0 : s4.webTierAuth) && (e2.withCredentials = true);
      }
    }
    e2.withCredentials && (o.credentials = "include", d2(r3) && await f2(d3 ? Et(r3, a8) : r3));
  }
  let p2, O2, v2 = 0, E2 = false;
  l3 > 0 && (v2 = setTimeout(() => {
    E2 = true, e2.controller.abort();
  }, l3));
  try {
    if ("native-request-init" === s3.responseType)
      O2 = o, O2.url = r3;
    else if ("image" !== s3.responseType || "default" !== o.cache || "GET" !== o.method || d3 || J(s3.headers) || !a7 && !e2.useProxy && A2.proxyUrl && !M2(r3)) {
      if (U2._beforeFetch && await U2._beforeFetch(r3, o), p2 = await fetch(r3, o), U2._afterFetch && await U2._afterFetch(p2), e2.useProxy || R2(r3), "native" === s3.responseType)
        O2 = p2;
      else if ("HEAD" !== o.method)
        if (p2.ok) {
          switch (i3) {
            case "array-buffer":
              O2 = await p2.arrayBuffer();
              break;
            case "blob":
            case "image":
              O2 = await p2.blob();
              break;
            default:
              O2 = await p2.text();
          }
          if (v2 && (clearTimeout(v2), v2 = 0), "json" === i3 || "xml" === i3 || "document" === i3)
            if (O2)
              switch (i3) {
                case "json":
                  O2 = JSON.parse(O2);
                  break;
                case "xml":
                  O2 = X2(O2, "application/xml");
                  break;
                case "document":
                  O2 = X2(O2, "text/html");
              }
            else
              O2 = null;
          if (O2) {
            if ("array-buffer" === i3 || "blob" === i3) {
              const e3 = p2.headers.get("Content-Type");
              if (e3 && /application\/json|text\/plain/i.test(e3) && O2["blob" === i3 ? "size" : "byteLength"] <= 750)
                try {
                  const e4 = await new Response(O2).json();
                  e4.error && (O2 = e4);
                } catch {
                }
            }
            "image" === i3 && O2 instanceof Blob && (O2 = await Y2(URL.createObjectURL(O2), e2, true));
          }
        } else {
          O2 = await p2.text();
          try {
            O2 = JSON.parse(O2);
          } catch {
          }
        }
    } else
      O2 = await Y2(r3, e2);
  } catch (j3) {
    if ("AbortError" === j3.name) {
      if (E2)
        throw u2();
      throw u("Request canceled");
    }
    if (!(!p2 && j3 instanceof TypeError && A2.proxyUrl) || s3.body || "delete" === s3.method || "head" === s3.method || "post" === s3.method || "put" === s3.method || e2.useProxy || M2(r3))
      throw j3;
    e2.redoRequest = true, H({ proxyUrl: A2.proxyUrl, urlPrefix: X(r3) ?? "" });
  } finally {
    v2 && clearTimeout(v2);
  }
  return [p2, O2];
}
async function G2(e2, t5) {
  if (null != e2.responseData)
    return e2.responseData;
  if (e2.headers && (t5.requestOptions.headers = { ...t5.requestOptions.headers, ...e2.headers }), e2.query && (t5.requestOptions.query = { ...t5.requestOptions.query, ...e2.query }), e2.before) {
    let o, a7;
    try {
      a7 = await e2.before(t5);
    } catch (s3) {
      o = N2("request:interceptor", s3, t5);
    }
    if ((a7 instanceof Error || a7 instanceof s) && (o = N2("request:interceptor", a7, t5)), o)
      throw e2.error && e2.error(o), o;
    return a7;
  }
}
function J(e2) {
  if (e2) {
    for (const t5 of Object.getOwnPropertyNames(e2))
      if (e2[t5])
        return true;
  }
  return false;
}
function X2(e2, t5) {
  let r3;
  try {
    r3 = new DOMParser().parseFromString(e2, t5);
  } catch {
  }
  if (!r3 || r3.getElementsByTagName("parsererror").length)
    throw new SyntaxError("XML Parse error");
  return r3;
}
async function Q2(e2) {
  var _a, _b;
  let r3, s3;
  await z2(e2);
  try {
    do {
      [r3, s3] = await W2(e2);
    } while (!await V2(e2, r3, s3));
  } catch (n4) {
    const t5 = N2("request:server", n4, e2.params, r3);
    throw t5.details.ssl = e2.useSSL, ((_a = e2.interceptor) == null ? void 0 : _a.error) && e2.interceptor.error(t5), t5;
  }
  const o = e2.params.url;
  if (s3 && /\/sharing\/rest\/(accounts|portals)\/self/i.test(o)) {
    if (!e2.hasToken && !e2.credentialToken && ((_b = s3.user) == null ? void 0 : _b.username) && !M(o)) {
      const e3 = X(o, true);
      e3 && A2.trustedServers.push(e3);
    }
    Array.isArray(s3.authorizedCrossOriginNoCorsDomains) && l2(s3.authorizedCrossOriginNoCorsDomains);
  }
  const a7 = e2.credential;
  if (a7 && t3) {
    const e3 = t3.findServerInfo(a7.server);
    let r4 = e3 == null ? void 0 : e3.owningSystemUrl;
    if (r4) {
      r4 = r4.replace(/\/?$/, "/sharing");
      const e4 = t3.findCredential(r4, a7.userId);
      e4 && -1 === t3._getIdenticalSvcIdx(r4, e4) && e4.resources.unshift(r4);
    }
  }
  return { data: s3, getAllHeaders: r3 ? () => Array.from(r3.headers) : H2, getHeader: r3 ? (e3) => r3.headers.get(e3) : H2, httpStatus: (r3 == null ? void 0 : r3.status) ?? 200, requestOptions: e2.params.requestOptions, ssl: e2.useSSL, url: e2.params.url };
}
async function V2(e2, r3, s3) {
  var _a;
  if (e2.redoRequest)
    return e2.redoRequest = false, false;
  const o = e2.params.requestOptions;
  if (!r3 || "native" === o.responseType || "native-request-init" === o.responseType)
    return true;
  let a7, n4;
  if (s3 && (s3.error && "object" == typeof s3.error ? a7 = s3.error : "error" === s3.status && Array.isArray(s3.messages) && (a7 = { ...s3 }, a7[I2] = s3, a7.details = s3.messages)), !a7 && !r3.ok)
    throw a7 = new Error(`Unable to load ${r3.url} status: ${r3.status}`), a7[I2] = s3, a7;
  let i3, l3 = null;
  a7 && (n4 = Number(a7.code), l3 = a7.hasOwnProperty("subcode") ? Number(a7.subcode) : null, i3 = a7.messageCode, i3 = i3 == null ? void 0 : i3.toUpperCase());
  const u3 = o.authMode;
  if (403 === n4 && (4 === l3 || ((_a = a7.message) == null ? void 0 : _a.toLowerCase().includes("ssl")) && !a7.message.toLowerCase().includes("permission"))) {
    if (!e2.useSSL)
      return e2.useSSL = true, false;
  } else if (!e2.hasToken && e2.useIdentity && ("no-prompt" !== u3 || 498 === n4) && void 0 !== n4 && _2.has(n4) && !K2(e2.params.url) && (403 !== n4 || (!i3 || !D2.has(i3)) && (null == l3 || 2 === l3 && e2.credentialToken))) {
    await $2();
    try {
      const r4 = await t3.getCredential(e2.params.url, { error: N2("request:server", a7, e2.params), prompt: "no-prompt" !== u3, signal: e2.controller.signal, token: e2.credentialToken });
      return e2.credential = r4, e2.credentialToken = r4.token, e2.useSSL = e2.useSSL || r4.ssl, false;
    } catch (c6) {
      if ("no-prompt" === u3)
        return e2.credential = void 0, e2.credentialToken = void 0, false;
      a7 = c6;
    }
  }
  if (a7)
    throw a7;
  return true;
}
function Y2(e2, t5, r3 = false) {
  const s3 = t5.controller.signal, o = new Image();
  return t5.withCredentials ? o.crossOrigin = "use-credentials" : o.crossOrigin = "anonymous", o.alt = "", o.fetchPriority = A2.priority, o.src = e2, i2(o, e2, r3, s3);
}
U2._corsServers = ["https://server.arcgisonline.com", "https://services.arcgisonline.com"], U2._beforeFetch = void 0, U2._afterFetch = void 0;

export {
  a4 as a,
  t,
  t2,
  x,
  C,
  q,
  I,
  A,
  v,
  S,
  T,
  W,
  N,
  D,
  F,
  _,
  G,
  K,
  V,
  Y,
  Z,
  tt,
  nt,
  et,
  ot,
  st,
  it,
  ut,
  ct,
  pt,
  dt,
  $t,
  Rt,
  bt,
  Ct,
  qt,
  At,
  Pt,
  St,
  kt,
  Et,
  Ht,
  Tt,
  Wt,
  r2 as r,
  t3,
  n3 as n,
  i,
  m3 as m,
  c4 as c,
  i2,
  m4 as m2,
  U2 as U
};
//# sourceMappingURL=chunk-SAYWXQVM.js.map
