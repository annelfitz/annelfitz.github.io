import {
  e,
  i,
  l,
  n as n2
} from "./chunk-A5QTLE4Y.js";
import {
  n as n3
} from "./chunk-SCHTG6ZQ.js";
import {
  f
} from "./chunk-QYC3GV65.js";
import {
  m
} from "./chunk-NCRCDVOW.js";
import {
  u
} from "./chunk-WDPG5BMO.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/renderers/visualVariables/support/visualVariableUtils.js
var c = () => n.getLogger("esri.renderers.visualVariables.support.visualVariableUtils");
var u2 = new f();
var f2 = Math.PI;
var d = /^\s*(return\s+)?\$view\.scale\s*(;)?\s*$/i;
function p(a, i2, n4) {
  const r = "visualVariables" in a && a.visualVariables ? a.visualVariables.find((e2) => "color" === e2.type) : a;
  if (!r)
    return;
  if ("esri.renderers.visualVariables.ColorVariable" !== r.declaredClass)
    return void c().warn("The visualVariable should be an instance of esri.renderers.visualVariables.ColorVariable");
  const t = "number" == typeof i2, s = t ? null : i2, l2 = s == null ? void 0 : s.attributes;
  let o = t ? i2 : null;
  const u3 = r.field, { ipData: f3, hasExpression: d2 } = r.cache;
  let p2 = r.cache.compiledFunc;
  if (!u3 && !d2) {
    const e2 = r.stops;
    return e2 && e2[0] && e2[0].color;
  }
  if ("number" != typeof o)
    if (d2) {
      if (null == (n4 == null ? void 0 : n4.arcade))
        return void c().error("Use of arcade expressions requires an arcade context");
      const e2 = { viewingMode: n4.viewingMode, scale: n4.scale, spatialReference: n4.spatialReference }, a2 = n4.arcade.arcadeUtils, i3 = a2.getViewInfo(e2), t2 = a2.createExecContext(s, i3, n4.timeZone);
      if (!p2) {
        const e3 = a2.createSyntaxTree(r.valueExpression);
        p2 = a2.createFunction(e3), r.cache.compiledFunc = p2;
      }
      o = a2.executeFunction(p2, t2);
    } else
      l2 && (o = l2[u3]);
  const v2 = r.normalizationField, b2 = null != l2 && null != v2 ? parseFloat(l2[v2]) : void 0;
  if (null != o && (!v2 || t || !isNaN(b2) && 0 !== b2)) {
    isNaN(b2) || t || (o /= b2);
    const a2 = k(o, f3);
    if (a2) {
      const i3 = a2[0], t2 = a2[1], s2 = i3 === t2 ? r.stops[i3].color : u.blendColors(r.stops[i3].color, r.stops[t2].color, a2[2], null != n4 ? n4.color : void 0);
      return new u(s2);
    }
  }
}
function v(e2, a, i2) {
  const n4 = "visualVariables" in e2 && e2.visualVariables ? e2.visualVariables.find((e3) => "opacity" === e3.type) : e2;
  if (!n4)
    return;
  if ("esri.renderers.visualVariables.OpacityVariable" !== n4.declaredClass)
    return void c().warn("The visualVariable should be an instance of esri.renderers.visualVariables.OpacityVariable");
  const r = "number" == typeof a, t = r ? null : a, s = t == null ? void 0 : t.attributes;
  let l2 = r ? a : null;
  const o = n4.field, { ipData: u3, hasExpression: f3 } = n4.cache;
  let d2 = n4.cache.compiledFunc;
  if (!o && !f3) {
    const e3 = n4.stops;
    return e3 && e3[0] && e3[0].opacity;
  }
  if ("number" != typeof l2)
    if (f3) {
      if (null == (i2 == null ? void 0 : i2.arcade))
        return void c().error("Use of arcade expressions requires an arcade context");
      const e3 = { viewingMode: i2.viewingMode, scale: i2.scale, spatialReference: i2.spatialReference }, a2 = i2.arcade.arcadeUtils, r2 = a2.getViewInfo(e3), s2 = a2.createExecContext(t, r2, i2.timeZone);
      if (!d2) {
        const e4 = a2.createSyntaxTree(n4.valueExpression);
        d2 = a2.createFunction(e4), n4.cache.compiledFunc = d2;
      }
      l2 = a2.executeFunction(d2, s2);
    } else
      s && (l2 = s[o]);
  const p2 = n4.normalizationField, v2 = null != s && null != p2 ? parseFloat(s[p2]) : void 0;
  if (null != l2 && (!p2 || r || !isNaN(v2) && 0 !== v2)) {
    isNaN(v2) || r || (l2 /= v2);
    const e3 = k(l2, u3);
    if (e3) {
      const a2 = e3[0], i3 = e3[1];
      if (a2 === i3)
        return n4.stops[a2].opacity;
      {
        const r2 = n4.stops[a2].opacity;
        return r2 + (n4.stops[i3].opacity - r2) * e3[2];
      }
    }
  }
}
function b(e2, a, i2) {
  const n4 = "visualVariables" in e2 && e2.visualVariables ? e2.visualVariables.find((e3) => "rotation" === e3.type) : e2;
  if (!n4)
    return;
  if ("esri.renderers.visualVariables.RotationVariable" !== n4.declaredClass)
    return void c().warn("The visualVariable should be an instance of esri.renderers.visualVariables.RotationVariable");
  const r = n4.axis || "heading", t = "heading" === r && "arithmetic" === n4.rotationType ? 90 : 0, s = "heading" === r && "arithmetic" === n4.rotationType ? -1 : 1, l2 = "number" == typeof a ? null : a, o = l2 == null ? void 0 : l2.attributes, u3 = n4.field, { hasExpression: f3 } = n4.cache;
  let d2 = n4.cache.compiledFunc, p2 = 0;
  if (!u3 && !f3)
    return p2;
  if (f3) {
    if (null == (i2 == null ? void 0 : i2.arcade))
      return void c().error("Use of arcade expressions requires an arcade context");
    const e3 = { viewingMode: i2.viewingMode, scale: i2.scale, spatialReference: i2.spatialReference }, a2 = i2.arcade.arcadeUtils, r2 = a2.getViewInfo(e3), t2 = a2.createExecContext(l2, r2, i2.timeZone);
    if (!d2) {
      const e4 = a2.createSyntaxTree(n4.valueExpression);
      d2 = a2.createFunction(e4), n4.cache.compiledFunc = d2;
    }
    p2 = a2.executeFunction(d2, t2);
  } else
    o && (p2 = o[u3] || 0);
  return p2 = "number" != typeof p2 || isNaN(p2) ? null : t + s * p2, p2;
}
function m2(e2, a, i2) {
  const n4 = "number" == typeof a, r = n4 ? null : a, t = r == null ? void 0 : r.attributes;
  let l2 = n4 ? a : null;
  const { isScaleDriven: u3 } = e2.cache;
  let f3 = e2.cache.compiledFunc;
  if (u3) {
    const a2 = null != i2 ? i2.scale : void 0, n5 = null != i2 ? i2.view : void 0;
    l2 = null == a2 || "3d" === n5 ? h(e2) : a2;
  } else if (!n4)
    switch (e2.inputValueType) {
      case n2.Expression: {
        if (null == (i2 == null ? void 0 : i2.arcade))
          return void c().error("Use of arcade expressions requires an arcade context");
        const a2 = { viewingMode: i2.viewingMode, scale: i2.scale, spatialReference: i2.spatialReference }, n5 = i2.arcade.arcadeUtils, t2 = n5.getViewInfo(a2), s = n5.createExecContext(r, t2, i2.timeZone);
        if (!f3) {
          const a3 = n5.createSyntaxTree(e2.valueExpression);
          f3 = n5.createFunction(a3), e2.cache.compiledFunc = f3;
        }
        l2 = n5.executeFunction(f3, s);
        break;
      }
      case n2.Field:
        t && (l2 = t[e2.field]);
        break;
      case n2.Unknown:
        l2 = null;
    }
  if (!l(l2))
    return null;
  if (n4 || !e2.normalizationField)
    return l2;
  const d2 = t ? parseFloat(t[e2.normalizationField]) : null;
  return l(d2) && 0 !== d2 ? l2 / d2 : null;
}
function h(e2) {
  let a = null, i2 = null;
  const n4 = e2.stops;
  return n4 ? (a = n4[0].value, i2 = n4[n4.length - 1].value) : (a = e2.minDataValue || 0, i2 = e2.maxDataValue || 0), (a + i2) / 2;
}
function V(e2, a, i2) {
  const n4 = "visualVariables" in e2 && e2.visualVariables ? e2.visualVariables.find((e3) => "size" === e3.type) : e2;
  if (!n4)
    return;
  if ("esri.renderers.visualVariables.SizeVariable" !== n4.declaredClass)
    return void c().warn("The visualVariable should be an instance of esri.renderers.visualVariables.SizeVariable");
  const r = C(m2(n4, a, i2), n4, a, i2, n4.cache.ipData);
  return null == r || isNaN(r) ? 0 : r;
}
function x(e2, a, i2) {
  return null == e2 ? null : e(e2) ? V(e2, a, i2) : l(e2) ? e2 : null;
}
function y(e2, a, i2) {
  return l(i2) && e2 > i2 ? i2 : l(a) && e2 < a ? a : e2;
}
function w(e2, a, i2, n4) {
  return e2 + ((x(a.minSize, i2, n4) || a.minDataValue) ?? 0);
}
function g(e2, a, i2) {
  const n4 = e2.stops;
  let r = (n4 == null ? void 0 : n4.length) && n4[0].size;
  return null == r && (r = e2.minSize), x(r, a, i2);
}
function z(e2, a, i2, n4) {
  const r = (e2 - a.minDataValue) / (a.maxDataValue - a.minDataValue), t = x(a.minSize, i2, n4), s = x(a.maxSize, i2, n4), l2 = null != n4 ? n4.shape : void 0;
  if (e2 <= a.minDataValue)
    return t;
  if (e2 >= a.maxDataValue)
    return s;
  if (null == t || null == s)
    return null;
  if ("area" === a.scaleBy && l2) {
    const e3 = "circle" === l2, a2 = e3 ? f2 * (t / 2) ** 2 : t * t, i3 = a2 + r * ((e3 ? f2 * (s / 2) ** 2 : s * s) - a2);
    return e3 ? 2 * Math.sqrt(i3 / f2) : Math.sqrt(i3);
  }
  return t + r * (s - t);
}
function F(e2, a, i2, n4) {
  const r = null != n4 ? n4.shape : void 0, t = e2 / a.minDataValue, s = x(a.minSize, i2, n4), l2 = x(a.maxSize, i2, n4);
  let o = null;
  return o = "circle" === r ? 2 * Math.sqrt(t * (s / 2) ** 2) : "square" === r || "diamond" === r || "image" === r ? Math.sqrt(t * s ** 2) : t * s, y(o, s, l2);
}
function S(e2, a, i2, n4, r) {
  var _a, _b, _c;
  const [t, s, l2] = k(e2, r);
  if (t === s)
    return x((_a = a.stops) == null ? void 0 : _a[t].size, i2, n4);
  {
    const e3 = x((_b = a.stops) == null ? void 0 : _b[t].size, i2, n4);
    return e3 + (x((_c = a.stops) == null ? void 0 : _c[s].size, i2, n4) - e3) * l2;
  }
}
function E(e2, a, i2, n4) {
  const t = ((n4 == null ? void 0 : n4.resolution) ?? 1) * m[a.valueUnit], s = x(a.minSize, i2, n4), l2 = x(a.maxSize, i2, n4), { valueRepresentation: o } = a;
  let c2 = null;
  return c2 = "area" === o ? 2 * Math.sqrt(e2 / f2) / t : "radius" === o || "distance" === o ? 2 * e2 / t : e2 / t, y(c2, s, l2);
}
function U(e2) {
  return e2;
}
function C(e2, a, i2, n4, r) {
  switch (a.transformationType) {
    case i.Additive:
      return w(e2, a, i2, n4);
    case i.Constant:
      return g(a, i2, n4);
    case i.ClampedLinear:
      return z(e2, a, i2, n4);
    case i.Proportional:
      return F(e2, a, i2, n4);
    case i.Stops:
      return S(e2, a, i2, n4, r);
    case i.RealWorldSize:
      return E(e2, a, i2, n4);
    case i.Identity:
      return U(e2);
    case i.Unknown:
      return null;
  }
}
function D(e2, a, i2) {
  const { isScaleDriven: n4 } = e2.cache;
  if (!(n4 && "3d" === i2 || a))
    return null;
  const r = { scale: a, view: i2 };
  let t = x(e2.minSize, u2, r), s = x(e2.maxSize, u2, r);
  if (null != t || null != s) {
    if (t > s) {
      const e3 = s;
      s = t, t = e3;
    }
    return { minSize: t, maxSize: s };
  }
}
function M(e2, a, i2) {
  if (!e2.visualVariables)
    return;
  const n4 = [], r = [], t = [], s = [], l2 = [];
  for (const o of e2.visualVariables)
    switch (o.type) {
      case "color":
        r.push(o);
        break;
      case "opacity":
        t.push(o);
        break;
      case "rotation":
        l2.push(o);
        break;
      case "size":
        s.push(o);
    }
  return r.forEach((e3) => {
    const r2 = p(e3, a, i2);
    n4.push({ variable: e3, value: r2 });
  }), t.forEach((e3) => {
    const r2 = v(e3, a, i2);
    n4.push({ variable: e3, value: r2 });
  }), l2.forEach((e3) => {
    const r2 = b(e3, a, i2);
    n4.push({ variable: e3, value: r2 });
  }), s.forEach((e3) => {
    const r2 = V(e3, a, i2);
    n4.push({ variable: e3, value: r2 });
  }), n4.filter((e3) => null != e3.value);
}
function k(e2, a) {
  if (!a)
    return;
  let i2 = 0, n4 = a.length - 1;
  return a.some((a2, r) => e2 < a2 ? (n4 = r, true) : (i2 = r, false)), [i2, n4, (e2 - a[i2]) / (a[n4] - a[i2])];
}
function N(e2, a, n4) {
  const r = ["proportional", "proportional", "proportional"];
  for (const t of e2) {
    const e3 = t.useSymbolValue ? "symbol-value" : V(t, a, n4);
    switch (t.axis) {
      case "width":
        r[0] = e3;
        break;
      case "depth":
        r[1] = e3;
        break;
      case "height":
        r[2] = e3;
        break;
      case "width-and-depth":
        r[0] = e3, r[1] = e3;
        break;
      case "all":
      case void 0:
      case null:
        r[0] = e3, r[1] = e3, r[2] = e3;
        break;
      default:
        n3(t.axis);
    }
  }
  return r;
}

export {
  d,
  p,
  v,
  b,
  V,
  x,
  C,
  D,
  M,
  N
};
//# sourceMappingURL=chunk-LMO6NZJA.js.map
