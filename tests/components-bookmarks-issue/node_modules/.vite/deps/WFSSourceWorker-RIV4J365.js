import {
  K,
  ee,
  oe
} from "./chunk-3AS2B6OH.js";
import "./chunk-44EKWUJ3.js";
import {
  E,
  N
} from "./chunk-NGNPSQZK.js";
import {
  p
} from "./chunk-C6M5UQQR.js";
import "./chunk-E5PVY3UF.js";
import {
  m
} from "./chunk-PGOAFABD.js";
import "./chunk-63NZBHDP.js";
import {
  $
} from "./chunk-BNDDKY53.js";
import "./chunk-BECEVYQR.js";
import "./chunk-S243OWEZ.js";
import "./chunk-QYDOVVH7.js";
import "./chunk-YSXT2SWC.js";
import {
  j,
  x
} from "./chunk-DGRFM5OL.js";
import "./chunk-AOAT6HYL.js";
import "./chunk-YH3SFFF7.js";
import "./chunk-JBU54P54.js";
import "./chunk-UQEUYEWU.js";
import "./chunk-5LIYYE75.js";
import "./chunk-UWZ4CRJK.js";
import {
  ot,
  rt
} from "./chunk-TLTAGTBA.js";
import "./chunk-2QPP5AGU.js";
import "./chunk-2C26DRKK.js";
import "./chunk-M4RFJU4F.js";
import "./chunk-WVKWBQ7C.js";
import "./chunk-RK2U53CD.js";
import "./chunk-YPY24RRU.js";
import "./chunk-O7RKI2QW.js";
import "./chunk-BMB27ANS.js";
import "./chunk-3FOBZIUS.js";
import "./chunk-JKLFCJPR.js";
import {
  Z
} from "./chunk-QNG4TY7L.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import "./chunk-IYKBAIQE.js";
import "./chunk-BDRVHR2K.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import "./chunk-I2X6UR6L.js";
import "./chunk-HV2SFSJW.js";
import "./chunk-SBARCIDP.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-326OSIM5.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-VTH4DAHQ.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import {
  i
} from "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-PWPXYWXV.js";
import "./chunk-545NO6M2.js";
import "./chunk-5LSHHVQ5.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import {
  G
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import {
  d
} from "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import "./chunk-NDIXNREV.js";
import {
  s3
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  b,
  s as s2
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/layers/graphics/sources/WFSSourceWorker.js
var w = "esri.layers.WFSLayer";
var R = class {
  constructor() {
    this._customParameters = null, this._queryEngine = null, this._supportsPagination = true;
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = null;
  }
  async load(e, r = {}) {
    const { getFeatureUrl: s4, getFeatureOutputFormat: o, fields: n2, geometryType: i2, featureType: u, maxRecordCount: c, maxTotalRecordCount: p2, maxPageCount: d2, objectIdField: g, customParameters: y } = e, { spatialReference: _, getFeatureSpatialReference: w2 } = oe(s4, u, e.spatialReference);
    try {
      await x(w2, _);
    } catch {
      throw new s("unsupported-projection", "Projection not supported", { inSpatialReference: w2, outSpatialReference: _ });
    }
    s2(r), this._customParameters = y, this._featureType = u, this._fieldsIndex = Z.fromLayerJSON({ fields: n2, dateFieldsTimeReference: n2.some((e2) => "esriFieldTypeDate" === e2.type) ? { timeZoneIANA: i } : null }), this._geometryType = i2, this._getFeatureUrl = s4, this._getFeatureOutputFormat = o, this._getFeatureSpatialReference = w2, this._maxRecordCount = c, this._maxTotalRecordCount = p2, this._maxPageCount = d2, this._objectIdField = g, this._spatialReference = _;
    let R2 = await this._snapshotFeatures(r);
    if (R2.errors.length > 0 && (this._supportsPagination = false, R2 = await this._snapshotFeatures(r), R2.errors.length > 0))
      throw R2.errors[0];
    return this._queryEngine = new $({ fieldsIndex: this._fieldsIndex, geometryType: i2, hasM: false, hasZ: false, objectIdField: g, spatialReference: _, timeInfo: null, featureStore: new m({ geometryType: i2, hasM: false, hasZ: false }) }), this._queryEngine.featureStore.addMany(R2.features), { warnings: T(R2), extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async applyEdits() {
    throw new s("wfs-source:editing-not-supported", "applyEdits() is not supported on WFSLayer");
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
  }
  async refresh(t) {
    var _a;
    return this._customParameters = t.customParameters, this._maxRecordCount = t.maxRecordCount, this._maxTotalRecordCount = t.maxTotalRecordCount, this._maxPageCount = t.maxPageCount, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d((e) => this._snapshotFeatures({ signal: e })), this._snapshotTask.promise.then((e) => {
      var _a2;
      this._queryEngine.featureStore.clear(), this._queryEngine.featureStore.addMany(e.features);
      for (const t2 of T(e))
        n.getLogger(w).warn(new s3("wfs-layer:refresh-warning", t2.message, t2.details));
      ((_a2 = e.errors) == null ? void 0 : _a2.length) && n.getLogger(w).warn(new s3("wfs-layer:refresh-error", "Refresh completed with errors", { errors: e.errors }));
    }, () => {
      this._queryEngine.featureStore.clear();
    }), await this._waitSnapshotComplete(), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _snapshotFeatures(e) {
    const t = e == null ? void 0 : e.signal, r = this._maxTotalRecordCount, o = this._maxPageCount, n2 = this._supportsPagination ? await ee(this._getFeatureUrl, this._featureType.typeName, { customParameters: this._customParameters, signal: t }) : void 0;
    let i2 = [];
    const u = [];
    if (null == n2)
      try {
        i2 = await this._singleQuery(t);
      } catch (l) {
        b(l) || u.push(l);
      }
    else {
      const e2 = Math.min(n2, r), a = F(this, Math.max(1, Math.min(Math.ceil(e2 / this._maxRecordCount), o)), t);
      await Promise.allSettled(Array.from({ length: 10 }).map(() => S(a, i2, u)));
    }
    return s2(t), { features: i2, totalRecordCount: n2, maxTotalRecordCount: r, maxPageCount: o, errors: u };
  }
  async _singleQuery(e) {
    const t = await K(this._getFeatureUrl, this._featureType.typeName, this._getFeatureSpatialReference, this._getFeatureOutputFormat, { customParameters: this._customParameters, signal: e });
    return this._processGeoJSON(t, { signal: e });
  }
  async _pageQuery(e, t) {
    const r = e * this._maxRecordCount, a = await K(this._getFeatureUrl, this._featureType.typeName, this._getFeatureSpatialReference, this._getFeatureOutputFormat, { customParameters: this._customParameters, startIndex: r, count: this._maxRecordCount, signal: t });
    return this._processGeoJSON(a, { startIndex: r, signal: t });
  }
  _processGeoJSON(e, t) {
    E(e, this._getFeatureSpatialReference.wkid);
    const { startIndex: r, signal: s4 } = t;
    s2(s4);
    const o = N(e, { geometryType: this._geometryType, hasZ: false, objectIdField: this._objectIdField });
    if (!G(this._spatialReference, this._getFeatureSpatialReference))
      for (const a of o)
        null != a.geometry && (a.geometry = ot(j(rt(a.geometry, this._geometryType, false, false), this._getFeatureSpatialReference, this._spatialReference)));
    let l = r ?? 1;
    for (const a of o) {
      const e2 = {};
      p(this._fieldsIndex, e2, a.attributes, true), a.attributes = e2, null == e2[this._objectIdField] && (a.objectId = e2[this._objectIdField] = l++);
    }
    return o;
  }
};
function* F(e, t, r) {
  for (let a = 0; a < t; a++)
    yield e._pageQuery(a, r);
}
async function S(e, t, r) {
  let a = e.next();
  for (; !a.done; ) {
    try {
      const e2 = await a.value;
      t.push(...e2);
    } catch (o) {
      b(o) || r.push(o);
    }
    a = e.next();
  }
}
function T(e) {
  const t = [];
  return null != e.totalRecordCount && (e.features.length < e.totalRecordCount && t.push({ name: "wfs-layer:maxRecordCount-too-low", message: `Could only fetch ${e.features.length} of ${e.totalRecordCount} in ${e.maxPageCount} queries. Try increasing the value of WFSLayer.maxRecordCount.`, details: { recordCount: e.features.length, totalRecordCount: e.totalRecordCount } }), e.totalRecordCount > e.maxTotalRecordCount && t.push({ name: "wfs-layer:large-dataset", message: `The number of ${e.totalRecordCount} features exceeds the maximum allowed of ${e.maxTotalRecordCount}.`, details: { recordCount: e.features.length, totalRecordCount: e.totalRecordCount, maxTotalRecordCount: e.maxTotalRecordCount } })), t;
}
export {
  R as default
};
//# sourceMappingURL=WFSSourceWorker-RIV4J365.js.map
