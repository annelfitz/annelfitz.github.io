import {
  T
} from "./chunk-KVZT4PEH.js";
import {
  l
} from "./chunk-REXEABYB.js";
import {
  E as E3,
  m as m2
} from "./chunk-QCUK7T7Y.js";
import {
  e as e6
} from "./chunk-2NDIVJST.js";
import {
  ct
} from "./chunk-SPYHZ6ZW.js";
import {
  C
} from "./chunk-PMFQ2A2V.js";
import {
  E as E2
} from "./chunk-TACIE3AK.js";
import {
  n as n2
} from "./chunk-SPU25K6A.js";
import {
  i
} from "./chunk-SWNHB34O.js";
import {
  u as u4
} from "./chunk-NGAYW4TW.js";
import {
  u as u3
} from "./chunk-BEXFYHUM.js";
import {
  N
} from "./chunk-XVQGALI7.js";
import {
  t as t4
} from "./chunk-4BCSYJOQ.js";
import {
  t as t3
} from "./chunk-UNTPHF5R.js";
import {
  D
} from "./chunk-WKVHVZW2.js";
import {
  I as I2
} from "./chunk-KSZESDGM.js";
import {
  t as t2
} from "./chunk-R4SGP2EA.js";
import {
  t
} from "./chunk-42DUJ2CX.js";
import {
  e as e5
} from "./chunk-GLF3KRAL.js";
import {
  E,
  I,
  M,
  U,
  e as e4,
  s as s2,
  u as u2
} from "./chunk-C7NPPGFR.js";
import {
  w as w2
} from "./chunk-IZKCZQUY.js";
import {
  w
} from "./chunk-Z4Y53NDM.js";
import {
  _,
  a as a2
} from "./chunk-BVQWKK2V.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  b,
  c2 as c,
  e as e3,
  k,
  m,
  s,
  u2 as u
} from "./chunk-JGDJR5EV.js";
import {
  e as e2
} from "./chunk-QHK5ZYFW.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/views/3d/layers/support/overlayImageUtils.js
function u5(r, o, n3) {
  const i2 = M(r) / s2(r), m3 = { width: n3, height: n3 };
  return i2 > 1.0001 ? m3.height = n3 / i2 : i2 < 0.9999 && (m3.width = n3 * i2), m3.width = Math.round(m3.width / (M(r) / M(o))), m3.height = Math.round(m3.height / (s2(r) / s2(o))), m3;
}
function l2(t5, e7) {
  return ct(t5, [[e7[0], e7[1], -1], [e7[2], e7[1], -1], [e7[2], e7[3], -1], [e7[0], e7[3], -1]]);
}
function s3(t5, e7, h) {
  if (!E(e7, h))
    return l2(t5, h);
  const u6 = [e7[1] - h[1], Math.min(e7[3], h[3]) - Math.max(e7[1], h[1]), h[3] - e7[3], 123456], s4 = [e7[0] - h[0], Math.min(e7[2], h[2]) - Math.max(e7[0], h[0]), h[2] - e7[2], 123456], f = h[2] - h[0], p = h[3] - h[1], w3 = s4[0] > 0 && s4[2] > 0 ? 3 : 2, b2 = u6[0] > 0 && u6[2] > 0 ? 3 : 2, c2 = (b2 + 1) * (w3 + 1), y2 = t2(3 * c2), d = t3(2 * c2), j = new Array(6 * (b2 * w3 - 1));
  let A = 0, M2 = 0, x = 0, O = 0, G = 0;
  for (let r = 0; r < 4; r++) {
    const t6 = u6[r];
    if (t6 <= 0)
      continue;
    let e8 = 0;
    for (let o = 0; o < 4; o++) {
      const t7 = s4[o];
      t7 <= 0 || (y2[M2++] = h[0] + e8, y2[M2++] = h[1] + A, y2[M2++] = -1, d[x++] = e8 / f, d[x++] = A / p, o < 3 && r < 3 && (1 !== o || 1 !== r) && (j[G++] = O, j[G++] = O + 1, j[G++] = O + w3 + 1, j[G++] = O + 1, j[G++] = O + w3 + 2, j[G++] = O + w3 + 1), O++, e8 += t7);
    }
    A += t6;
  }
  const I3 = new Array(j.length);
  return new I2(t5, [[e5.POSITION, new t(y2, j, 3, true)], [e5.NORMAL, new t(a3, I3, 3, true)], [e5.UV0, new t(d, j, 2, true)]]);
}
var a3 = [0, 0, 1];

// node_modules/@arcgis/core/views/3d/layers/DynamicLayerView3D.js
var V = class extends i(n2(u4)) {
  constructor() {
    super(...arguments), this.drapeSourceType = e6.RasterImage, this.updatePolicy = C.SYNC, this.fullExtentInLocalViewSpatialReference = null, this.maximumDataResolution = null, this._images = new Array(), this._extents = new Array(), this._overlays = new Array(), this.updateWhenStationary = true, this._drapeSourceRenderer = null, this.refreshDebounced = k(async (e7) => {
      this.destroyed || await this._doRefresh(e7).catch((e8) => {
        b(e8) || n.getLogger(this).error(e8);
      });
    }, 2e3);
  }
  initialize() {
    this._drapeSourceRenderer = this.view.basemapTerrain.overlayManager.registerGeometryDrapeSource(this), this.addHandles(e3(() => this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this))), this.addResolvingPromise(l(this).then((e7) => this._set("fullExtentInLocalViewSpatialReference", e7))), this._updatingHandles.add(() => this.suspended, () => this._suspendedChangeHandler()), this.addHandles(this.view.resourceController.scheduler.registerIdleStateCallbacks(() => {
      this._isScaleRangeActive() && this.notifyChange("suspended");
    }, () => {
    })), this._isScaleRangeLayer() && this._updatingHandles.add(() => this.layer.effectiveScaleRange, () => this.notifyChange("suspended"));
  }
  destroy() {
    this.clear();
  }
  setDrapingExtent(e7, t5) {
    this._spatialReference = t5, e7.forEach((e8, t6) => {
      this._overlays[t6] = e8, this._updateImageExtent(e8, t6);
    });
  }
  _updateImageExtent(e7, t5) {
    const r = this._clippedExtent(e7.extent, z);
    if (null == r)
      return;
    const i2 = u5(e7.extent, r, e7.resolution);
    let s4 = e7.pixelRatio * this.view.state.pixelRatio;
    const { layer: n3 } = this;
    if ("imageMaxWidth" in n3 && null != n3.imageMaxWidth || "imageMaxHeight" in n3 && null != n3.imageMaxHeight) {
      const e8 = n3.imageMaxWidth, t6 = n3.imageMaxHeight;
      if (i2.width > e8) {
        const t7 = e8 / i2.width;
        i2.height = Math.floor(i2.height * t7), i2.width = e8, s4 *= t7;
      }
      if (i2.height > t6) {
        const e9 = t6 / i2.height;
        i2.width = Math.floor(i2.width * e9), i2.height = t6, s4 *= e9;
      }
    }
    const l3 = this._extents[t5];
    l3 && I(l3.extent, r) && this._imageSizeEquals(r, l3.imageSize, i2) || (this._extents[t5] = { extent: u2(r), imageSize: i2, pixelRatio: s4 }, this.suspended || this._fetch(t5).catch((e8) => {
      b(e8) || n.getLogger(this).error(e8);
    }));
  }
  clear() {
    for (let e7 = 0; e7 < this._images.length; e7++)
      this._clearImage(e7);
  }
  async doRefresh() {
    return this._doRefresh();
  }
  async _doRefresh(e7) {
    if (this.suspended)
      return;
    const t5 = [];
    for (let r = 0; r < this._extents.length; r++)
      this._extents[r] && t5.push(this._fetch(r, e7));
    await Promise.allSettled(t5);
  }
  canResume() {
    if (!super.canResume())
      return false;
    const e7 = this.layer;
    if (this._isScaleRangeActive()) {
      const { minScale: t5, maxScale: r } = e7.effectiveScaleRange, i2 = this.view.scale;
      if (i2 < r || t5 > 0 && i2 > t5)
        return false;
    }
    return true;
  }
  async processResult(e7, t5, r) {
    (t5 instanceof HTMLImageElement || t5 instanceof HTMLCanvasElement) && (e7.image = t5);
  }
  findExtentInfoAt(e7) {
    for (const t5 of this._extents) {
      const r = t5.extent;
      if (new w2(r[0], r[1], r[2], r[3], this._spatialReference).contains(e7))
        return t5;
    }
    return null;
  }
  getFetchOptions() {
  }
  async redraw(e7, r) {
    await a2(this._images, async (t5, i2) => {
      t5 && (await e7(t5, r), await this._createStageObjects(i2, t5.image, r));
    });
  }
  _imageSizeEquals(e7, t5, r) {
    if (!this.maximumDataResolution)
      return false;
    const i2 = M(e7) / this.maximumDataResolution.x, a4 = s2(e7) / this.maximumDataResolution.y, s4 = i2 / t5.width, n3 = a4 / t5.height, o = i2 / r.width, l3 = a4 / r.height, h = Math.abs(s4 - o), m3 = Math.abs(n3 - l3), d = t4.TESTS_DISABLE_OPTIMIZATIONS ? 0 : 1.5;
    return h <= d && m3 <= d;
  }
  async _fetch(e7, t5) {
    if (this.suspended)
      return;
    const r = this._extents[e7], i2 = r.extent;
    this._images[e7] || (this._images[e7] = { texture: null, material: null, renderGeometry: null, loadingPromise: null, loadingAbortController: null, image: null, pixelData: null, renderExtent: u2(i2) });
    const n3 = this._images[e7];
    n3.loadingAbortController = e2(n3.loadingAbortController);
    const c2 = new w2(i2[0], i2[1], i2[2], i2[3], this._spatialReference);
    if (0 === c2.width || 0 === c2.height)
      return void this._clearImage(e7);
    const g = new AbortController();
    n3.loadingAbortController = g, m(t5, () => g.abort());
    const u6 = g.signal, f = this._waitFetchReady(u6).then(async () => {
      const t6 = { requestAsImageElement: true, pixelRatio: this._overlays[e7].pixelRatio, ...this.getFetchOptions(), signal: u6 }, { height: i3, width: a4 } = r.imageSize;
      return this.layer.fetchImage(c2, a4, i3, t6);
    }).then((e8) => {
      if (c(u6))
        throw n.getLogger(this).warnOnce("A call to fetchImage resolved even though the request was aborted. fetchImage should not resolve if options.signal.aborted is true."), u();
      return this.processResult(n3, e8);
    }).then(() => {
      e4(n3.renderExtent, i2);
    });
    n3.loadingPromise = f, await this._updatingHandles.addPromise(f.then(async () => {
      s(u6), await this._createStageObjects(e7, n3.image, u6);
    }).catch((e8) => {
      throw e8 && !b(e8) && n.getLogger(this).error(e8), e8;
    }).finally(() => {
      f === n3.loadingPromise && (n3.loadingPromise = null, n3.loadingAbortController = null);
    }));
  }
  _clearImage(e7) {
    const t5 = this._images[e7];
    if (t5) {
      null != t5.renderGeometry && (this._drapeSourceRenderer.removeGeometries([t5.renderGeometry], E3.UPDATE), t5.renderGeometry = null);
      const e8 = this.view._stage, r = t5.texture;
      r == null ? void 0 : r.unload(), e8.remove(r), t5.texture = null, e8.remove(t5.material), t5.material = null, t5.loadingAbortController = e2(t5.loadingAbortController), t5.loadingPromise = null, t5.image = null, t5.pixelData = null;
    }
  }
  async _createStageObjects(e7, t5, i2) {
    const a4 = this.view._stage, s4 = this._images[e7], n3 = () => {
      var _a;
      (_a = s4.texture) == null ? void 0 : _a.unload(), a4.remove(s4.texture), s4.texture = null, s4.renderGeometry && (this._drapeSourceRenderer.removeGeometries([s4.renderGeometry], E3.UPDATE), s4.renderGeometry = null);
    };
    if (t5) {
      const o = new N(t5, { width: t5.width, height: t5.height, preMultiplyAlpha: true, wrap: { s: D.CLAMP_TO_EDGE, t: D.CLAMP_TO_EDGE } });
      let l3;
      if (await _(this._images[e7 === E2.INNER ? E2.OUTER : E2.INNER].loadingPromise), s(i2), n3(), await a4.schedule(() => o.load(a4.renderView.renderingContext), i2), a4.add(o), s4.texture = o, null == s4.material ? (s4.material = new T({ transparent: true, textureId: o.id }), a4.add(s4.material)) : s4.material.setParameters({ textureId: o.id }), e7 === E2.INNER)
        l3 = l2(s4.material, s4.renderExtent);
      else {
        const e8 = this._images[0].renderExtent;
        if (!e8)
          return void n3();
        l3 = s3(s4.material, e8, s4.renderExtent);
      }
      s4.renderGeometry = new m2(l3), s4.renderGeometry.localOrigin = this._overlays[e7].renderLocalOrigin, this._drapeSourceRenderer.addGeometries([s4.renderGeometry], E3.UPDATE);
    } else
      n3(), a4.remove(s4.material), s4.material = null;
  }
  _isScaleRangeLayer() {
    return "effectiveScaleRange" in this.layer;
  }
  _isScaleRangeActive() {
    const e7 = this.layer;
    if (!this._isScaleRangeLayer())
      return false;
    const { minScale: t5, maxScale: r } = e7.effectiveScaleRange;
    return u3(t5, r);
  }
  _clippedExtent(e7, t5) {
    if ("local" !== this.view.viewingMode)
      return e4(t5, e7);
    const r = this.view.basemapTerrain;
    return r.ready ? U(e7, r.extent, t5) : e4(t5, e7);
  }
  _suspendedChangeHandler() {
    this.suspended ? this.clear() : this.refreshDebounced();
  }
  async _waitFetchReady(e7) {
    await w(() => this.view.stationary, e7), s(e7);
  }
};
e([y()], V.prototype, "layer", void 0), e([y()], V.prototype, "suspended", void 0), e([y({ readOnly: true })], V.prototype, "fullExtentInLocalViewSpatialReference", void 0), e([y()], V.prototype, "updating", void 0), V = e([a("esri.views.3d.layers.DynamicLayerView3D")], V);
var N2 = V;
var z = u2();

export {
  N2 as N
};
//# sourceMappingURL=chunk-HDXOQPN6.js.map
