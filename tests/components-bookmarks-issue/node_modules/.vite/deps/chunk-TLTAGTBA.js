import {
  e
} from "./chunk-2QPP5AGU.js";
import {
  t
} from "./chunk-2C26DRKK.js";
import {
  e as e2
} from "./chunk-M4RFJU4F.js";
import {
  d,
  q
} from "./chunk-326OSIM5.js";
import {
  f,
  l,
  s as s2,
  u
} from "./chunk-J7AMTUNG.js";
import {
  a
} from "./chunk-C7NPPGFR.js";
import {
  n as n2
} from "./chunk-QHK5ZYFW.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/layers/graphics/featureConversionUtils.js
function d2(t2, e3) {
  return t2 ? e3 ? 4 : 3 : e3 ? 3 : 2;
}
var m = () => n.getLogger("esri.layers.graphics.featureConversionUtils");
var g = { esriGeometryPoint: 0, esriGeometryPolyline: 2, esriGeometryPolygon: 3, esriGeometryMultipoint: 0, esriGeometryEnvelope: 0 };
var y = (t2, e3, n3, o, r, s3) => {
  t2[n3] = r, t2[n3 + 1] = s3;
};
var p = (t2, e3, n3, o, r, s3) => {
  t2[n3] = r, t2[n3 + 1] = s3, t2[n3 + 2] = e3[o + 2];
};
var I = (t2, e3, n3, o, r, s3) => {
  t2[n3] = r, t2[n3 + 1] = s3, t2[n3 + 2] = e3[o + 3];
};
var b = (t2, e3, n3, o, r, s3) => {
  t2[n3] = r, t2[n3 + 1] = s3, t2[n3 + 2] = e3[o + 2], t2[n3 + 3] = e3[o + 3];
};
function M(t2, e3, n3, o) {
  if (t2) {
    if (n3)
      return e3 && o ? b : p;
    if (e3 && o)
      return I;
  } else if (e3 && o)
    return p;
  return y;
}
function N({ scale: t2, translate: e3 }, n3) {
  return Math.round((n3 - e3[0]) / t2[0]);
}
function w({ scale: t2, translate: e3 }, n3) {
  return Math.round((e3[1] - n3) / t2[1]);
}
function F({ scale: t2, translate: e3 }, n3, o) {
  return n3 * t2[o] + e3[o];
}
function x(t2, e3, n3) {
  return t2 ? e3 ? n3 ? k(t2) : Z(t2) : n3 ? v(t2) : P(t2) : null;
}
function P(t2) {
  const e3 = t2.coords;
  return { x: e3[0], y: e3[1] };
}
function j(t2, e3) {
  return t2.coords[0] = e3.x, t2.coords[1] = e3.y, t2;
}
function Z(t2) {
  const e3 = t2.coords;
  return { x: e3[0], y: e3[1], z: e3[2] };
}
function E(t2, e3) {
  return t2.coords[0] = e3.x, t2.coords[1] = e3.y, t2.coords[2] = e3.z, t2;
}
function v(t2) {
  const e3 = t2.coords;
  return { x: e3[0], y: e3[1], m: e3[2] };
}
function z(t2, e3) {
  return t2.coords[0] = e3.x, t2.coords[1] = e3.y, t2.coords[2] = e3.m, t2;
}
function k(t2) {
  const e3 = t2.coords;
  return { x: e3[0], y: e3[1], z: e3[2], m: e3[3] };
}
function V(t2, e3) {
  return t2.coords[0] = e3.x, t2.coords[1] = e3.y, t2.coords[2] = e3.z, t2.coords[3] = e3.m, t2;
}
function Y(t2, e3, n3, o) {
  let r = P;
  n3 && o ? r = k : n3 ? r = Z : o && (r = v);
  for (const s3 of e3) {
    const { geometry: e4, attributes: n4 } = s3, o2 = null != e4 ? r(e4) : null;
    t2.push({ attributes: n4, geometry: o2 });
  }
  return t2;
}
function _(t2, e3) {
  return t2 && e3 ? V : t2 ? E : e3 ? z : j;
}
function L(t2, e3, n3, o, r) {
  const s3 = _(n3, o);
  for (const { geometry: u2, attributes: l2 } of e3) {
    const e4 = null != u2 ? s3(new e2(), u2) : null;
    t2.push(new t(e4, l2, null, r ? l2[r] : void 0));
  }
  return t2;
}
function O(t2, e3, n3 = _(null != e3.z, null != e3.m)) {
  return n3(t2, e3);
}
function S(t2, e3, n3, o) {
  for (const { geometry: r, attributes: s3 } of e3)
    t2.push({ attributes: s3, geometry: null != r ? U(r, n3, o) : null });
  return t2;
}
function U(t2, e3, n3) {
  if (null == t2)
    return null;
  const o = d2(e3, n3), r = [];
  for (let s3 = 0; s3 < t2.coords.length; s3 += o) {
    const e4 = [];
    for (let n4 = 0; n4 < o; n4++)
      e4.push(t2.coords[s3 + n4]);
    r.push(e4);
  }
  return e3 ? n3 ? { points: r, hasZ: e3, hasM: n3 } : { points: r, hasZ: e3 } : n3 ? { points: r, hasM: n3 } : { points: r };
}
function q2(t2, e3, n3, o, r) {
  const s3 = d2(n3, o);
  for (const { geometry: u2, attributes: l2 } of e3) {
    const e4 = null != u2 ? R(new e2(), u2, s3) : null;
    t2.push(new t(e4, l2, null, r ? l2[r] : void 0));
  }
  return t2;
}
function R(t2, e3, n3 = d2(e3.hasZ, e3.hasM)) {
  t2.lengths[0] = e3.points.length;
  const o = t2.coords;
  let r = 0;
  for (const s3 of e3.points)
    for (let t3 = 0; t3 < n3; t3++)
      o[r++] = s3[t3];
  return t2;
}
function A(t2, e3, n3, o) {
  for (const { geometry: r, attributes: s3 } of e3)
    t2.push({ attributes: s3, geometry: null != r ? $(r, n3, o) : null });
  return t2;
}
function $(t2, e3, n3) {
  if (!t2)
    return null;
  const o = d2(e3, n3), { coords: r, lengths: s3 } = t2, u2 = [];
  let l2 = 0;
  for (const c of s3) {
    const t3 = [];
    for (let e4 = 0; e4 < c; e4++) {
      const e5 = [];
      for (let t4 = 0; t4 < o; t4++)
        e5.push(r[l2++]);
      t3.push(e5);
    }
    u2.push(t3);
  }
  return e3 ? n3 ? { paths: u2, hasZ: e3, hasM: n3 } : { paths: u2, hasZ: e3 } : n3 ? { paths: u2, hasM: n3 } : { paths: u2 };
}
function B(t2, e3, n3, o, r) {
  const s3 = d2(n3, o);
  for (const { geometry: u2, attributes: l2, centroid: c } of e3) {
    const e4 = null != u2 ? C(new e2(), u2, s3) : null, n4 = null != c ? O(new e2(), c) : null;
    t2.push(new t(e4, l2, n4, r ? l2[r] : void 0));
  }
  return t2;
}
function C(t2, e3, n3 = d2(e3.hasZ, e3.hasM)) {
  const { lengths: o, coords: r } = t2;
  let s3 = 0;
  for (const u2 of e3.paths) {
    for (const t3 of u2)
      for (let e4 = 0; e4 < n3; e4++)
        r[s3++] = t3[e4];
    o.push(u2.length);
  }
  return t2;
}
function D(t2, e3, n3, o) {
  for (const { geometry: r, attributes: s3, centroid: u2 } of e3) {
    const e4 = null != r ? H(r, n3, o) : null;
    if (null != u2) {
      const n4 = P(u2);
      t2.push({ attributes: s3, centroid: n4, geometry: e4 });
    } else
      t2.push({ attributes: s3, geometry: e4 });
  }
  return t2;
}
function H(t2, e3, n3) {
  if (!t2)
    return null;
  const o = d2(e3, n3), { coords: r, lengths: s3 } = t2, u2 = [];
  let l2 = 0;
  for (const c of s3) {
    const t3 = [];
    for (let e4 = 0; e4 < c; e4++) {
      const e5 = [];
      for (let t4 = 0; t4 < o; t4++)
        e5.push(r[l2++]);
      t3.push(e5);
    }
    u2.push(t3);
  }
  return e3 ? n3 ? { rings: u2, hasZ: e3, hasM: n3 } : { rings: u2, hasZ: e3 } : n3 ? { rings: u2, hasM: n3 } : { rings: u2 };
}
function J(t2, e3, n3, o, r) {
  for (const { geometry: s3, centroid: u2, attributes: l2 } of e3) {
    const e4 = null != s3 ? K(new e2(), s3, n3, o) : null, c = r ? l2[r] : void 0;
    null != u2 ? t2.push(new t(e4, l2, j(new e2(), u2), c)) : t2.push(new t(e4, l2, null, c));
  }
  return t2;
}
function K(t2, e3, n3 = e3.hasZ, o = e3.hasM) {
  return Q(t2, e3.rings, n3, o);
}
function Q(t2, e3, n3, o) {
  const r = d2(n3, o), { lengths: s3, coords: u2 } = t2;
  let l2 = 0;
  wt(t2);
  for (const c of e3) {
    for (const t3 of c)
      for (let e4 = 0; e4 < r; e4++)
        u2[l2++] = t3[e4];
    s3.push(c.length);
  }
  return t2;
}
var W = [];
var X = [];
function tt(t2, e3, n3, o, r) {
  W[0] = t2;
  const [s3] = et(X, W, e3, n3, o, r);
  return Tt(W), Tt(X), s3;
}
function et(e3, n3, o, r, s3, u2) {
  if (Tt(e3), !o) {
    for (const t2 of n3) {
      const n4 = u2 ? t2.attributes[u2] : void 0;
      e3.push(new t(null, t2.attributes, null, n4));
    }
    return e3;
  }
  switch (o) {
    case "esriGeometryPoint":
      return L(e3, n3, r, s3, u2);
    case "esriGeometryMultipoint":
      return q2(e3, n3, r, s3, u2);
    case "esriGeometryPolyline":
      return B(e3, n3, r, s3, u2);
    case "esriGeometryPolygon":
      return J(e3, n3, r, s3, u2);
    default:
      m().error("convertToFeatureSet:unknown-geometry", new s(`Unable to parse unknown geometry type '${o}'`)), Tt(e3);
  }
  return e3;
}
function nt(t2, e3, n3, o) {
  X[0] = t2, ut(W, X, e3, n3, o);
  const r = W[0];
  return Tt(W), Tt(X), r;
}
function ot(e3, n3, o) {
  if (null == e3)
    return null;
  const r = new e2();
  if ("hasZ" in e3 && null == n3 && (n3 = e3.hasZ), "hasM" in e3 && null == o && (o = e3.hasM), u(e3)) {
    return _(null != n3 ? n3 : null != e3.z, null != o ? o : null != e3.m)(r, e3);
  }
  return f(e3) ? K(r, e3, n3, o) : s2(e3) ? C(r, e3, d2(n3, o)) : l(e3) ? R(r, e3, d2(n3, o)) : void m().error("convertFromGeometry:unknown-geometry", new s(`Unable to parse unknown geometry type '${e3}'`));
}
function rt(e3, n3, o, r) {
  const s3 = e3 && ("coords" in e3 ? e3 : e3.geometry);
  if (null == s3)
    return null;
  switch (n3) {
    case "esriGeometryPoint": {
      let t2 = P;
      return o && r ? t2 = k : o ? t2 = Z : r && (t2 = v), t2(s3);
    }
    case "esriGeometryMultipoint":
      return U(s3, o, r);
    case "esriGeometryPolyline":
      return $(s3, o, r);
    case "esriGeometryPolygon":
      return H(s3, o, r);
    default:
      return m().error("convertToGeometry:unknown-geometry", new s(`Unable to parse unknown geometry type '${n3}'`)), null;
  }
}
function st(t2, e3) {
  for (const n3 of e3)
    t2.push({ attributes: n3.attributes });
  return t2;
}
function ut(e3, n3, o, r, s3) {
  if (Tt(e3), null == o)
    return st(e3, n3);
  switch (o) {
    case "esriGeometryPoint":
      return Y(e3, n3, r, s3);
    case "esriGeometryMultipoint":
      return S(e3, n3, r, s3);
    case "esriGeometryPolyline":
      return A(e3, n3, r, s3);
    case "esriGeometryPolygon":
      return D(e3, n3, r, s3);
    default:
      m().error("convertToFeatureSet:unknown-geometry", new s(`Unable to parse unknown geometry type '${o}'`));
  }
  return e3;
}
function lt(t2) {
  const { objectIdFieldName: e3, spatialReference: n3, transform: o, fields: r, hasM: s3, hasZ: u2, features: l2, geometryType: c, exceededTransferLimit: i, uniqueIdField: f2, queryGeometry: a2, queryGeometryType: h } = t2, d3 = { features: ut([], l2, c, u2, s3), fields: r, geometryType: c, objectIdFieldName: e3, spatialReference: n3, uniqueIdField: f2, queryGeometry: rt(a2, h, false, false) };
  return o && (d3.transform = o), i && (d3.exceededTransferLimit = i), s3 && (d3.hasM = s3), u2 && (d3.hasZ = u2), d3;
}
function ct(e3, n3) {
  const o = new e(), { hasM: r, hasZ: s3, features: u2, objectIdFieldName: l2, spatialReference: c, geometryType: i, exceededTransferLimit: f2, transform: h, fields: d3 } = e3;
  return d3 && (o.fields = d3), o.geometryType = i ?? null, o.objectIdFieldName = l2 ?? n3 ?? null, o.spatialReference = c ?? null, o.objectIdFieldName ? (u2 && et(o.features, u2, i, s3, r, o.objectIdFieldName), f2 && (o.exceededTransferLimit = f2), r && (o.hasM = r), s3 && (o.hasZ = s3), h && (o.transform = h), o) : (m().error(new s("optimized-features:invalid-objectIdFieldName", "objectIdFieldName is missing")), o);
}
function it(t2) {
  const { transform: e3, features: n3, hasM: o, hasZ: r } = t2;
  if (!e3)
    return t2;
  for (const s3 of n3)
    null != s3.geometry && pt(s3.geometry, s3.geometry, o, r, e3), null != s3.centroid && pt(s3.centroid, s3.centroid, o, r, e3);
  return t2.transform = null, t2;
}
function ft(t2, e3) {
  const { geometryType: n3, features: o, hasM: r, hasZ: s3 } = e3;
  if (!t2)
    return e3;
  for (let u2 = 0; u2 < o.length; u2++) {
    const e4 = o[u2], l2 = e4.weakClone();
    l2.geometry = new e2(), at(l2.geometry, e4.geometry, r, s3, n3, t2), e4.centroid && (l2.centroid = new e2(), at(l2.centroid, e4.centroid, r, s3, "esriGeometryPoint", t2)), o[u2] = l2;
  }
  return e3.transform = t2, e3;
}
function at(t2, e3, n3, o, r, s3, u2 = n3, l2 = o) {
  if (wt(t2), !(e3 == null ? void 0 : e3.coords.length))
    return null;
  const c = g[r], { coords: i, lengths: f2 } = e3, a2 = d2(n3, o), h = d2(n3 && u2, o && l2), m2 = M(n3, o, u2, l2);
  if (!f2.length)
    return m2(t2.coords, i, 0, 0, N(s3, i[0]), w(s3, i[1])), wt(t2, a2, 0), t2;
  let y2, p2, I2, b2, T = 0, G = 0, F2 = G;
  for (const d3 of f2) {
    if (d3 < c)
      continue;
    let e4 = 0;
    G = F2, I2 = y2 = N(s3, i[T]), b2 = p2 = w(s3, i[T + 1]), m2(t2.coords, i, G, T, I2, b2), e4++, T += a2, G += h;
    for (let n4 = 1; n4 < d3; n4++, T += a2)
      I2 = N(s3, i[T]), b2 = w(s3, i[T + 1]), I2 === y2 && b2 === p2 || (m2(t2.coords, i, G, T, I2 - y2, b2 - p2), G += h, e4++, y2 = I2, p2 = b2);
    e4 >= c && (t2.lengths.push(e4), F2 = G);
  }
  return Tt(t2.coords, F2), t2.coords.length ? t2 : null;
}
function ht(t2, e3, n3, o, r, s3, u2 = n3, l2 = o) {
  if (wt(t2), !(e3 == null ? void 0 : e3.coords.length))
    return null;
  const c = g[r], { coords: i, lengths: f2 } = e3, a2 = d2(n3, o), h = d2(n3 && u2, o && l2), m2 = M(n3, o, u2, l2);
  if (!f2.length)
    return m2(t2.coords, i, 0, 0, i[0], i[1]), wt(t2, a2, 0), t2;
  let y2 = 0;
  const p2 = s3 * s3;
  for (const d3 of f2) {
    if (d3 < c) {
      y2 += d3 * a2;
      continue;
    }
    const e4 = t2.coords.length / h, n4 = y2, o2 = y2 + (d3 - 1) * a2;
    m2(t2.coords, i, t2.coords.length, n4, i[n4], i[n4 + 1]), mt(t2.coords, i, a2, p2, m2, n4, o2), m2(t2.coords, i, t2.coords.length, o2, i[o2], i[o2 + 1]);
    const r2 = t2.coords.length / h - e4;
    r2 >= c ? t2.lengths.push(r2) : Tt(t2.coords, e4 * h), y2 += d3 * a2;
  }
  return t2.coords.length ? t2 : null;
}
function dt(t2, e3, n3, o) {
  const r = t2[e3], s3 = t2[e3 + 1], u2 = t2[n3], l2 = t2[n3 + 1], c = t2[o], i = t2[o + 1];
  let f2 = u2, a2 = l2, h = c - f2, d3 = i - a2;
  if (0 !== h || 0 !== d3) {
    const t3 = ((r - f2) * h + (s3 - a2) * d3) / (h * h + d3 * d3);
    t3 > 1 ? (f2 = c, a2 = i) : t3 > 0 && (f2 += h * t3, a2 += d3 * t3);
  }
  return h = r - f2, d3 = s3 - a2, h * h + d3 * d3;
}
function mt(t2, e3, n3, o, r, s3, u2) {
  let l2, c = o, i = 0;
  for (let f2 = s3 + n3; f2 < u2; f2 += n3)
    l2 = dt(e3, f2, s3, u2), l2 > c && (i = f2, c = l2);
  c > o && (i - s3 > n3 && mt(t2, e3, n3, o, r, s3, i), r(t2, e3, t2.length, i, e3[i], e3[i + 1]), u2 - i > n3 && mt(t2, e3, n3, o, r, i, u2));
}
function gt(t2, e3, n3, u2) {
  var _a;
  if (!((_a = e3 == null ? void 0 : e3.coords) == null ? void 0 : _a.length))
    return null;
  const l2 = d2(n3, u2);
  let c = Number.POSITIVE_INFINITY, i = Number.POSITIVE_INFINITY, f2 = Number.NEGATIVE_INFINITY, a2 = Number.NEGATIVE_INFINITY;
  if (e3 && e3.coords) {
    const t3 = e3.coords;
    for (let e4 = 0; e4 < t3.length; e4 += l2) {
      const n4 = t3[e4], o = t3[e4 + 1];
      c = Math.min(c, n4), f2 = Math.max(f2, n4), i = Math.min(i, o), a2 = Math.max(a2, o);
    }
  }
  return q(t2) ? d(t2, c, i, f2, a2) : a(c, i, f2, a2, t2), t2;
}
function pt(t2, e3, o, r, s3) {
  const { coords: u2, lengths: l2 } = e3, c = d2(o, r);
  if (!u2.length)
    return t2 !== e3 && wt(t2), t2;
  n2(s3);
  const { originPosition: i, scale: f2, translate: a2 } = s3, h = Gt;
  h.originPosition = i;
  const m2 = h.scale;
  m2[0] = f2[0] ?? 1, m2[1] = -(f2[1] ?? 1), m2[2] = f2[2] ?? 1, m2[3] = f2[3] ?? 1;
  const g2 = h.translate;
  if (g2[0] = a2[0] ?? 0, g2[1] = a2[1] ?? 0, g2[2] = a2[2] ?? 0, g2[3] = a2[3] ?? 0, !l2.length) {
    for (let e4 = 0; e4 < c; ++e4)
      t2.coords[e4] = F(h, u2[e4], e4);
    return t2 !== e3 && wt(t2, c, 0), t2;
  }
  let y2 = 0;
  for (let n3 = 0; n3 < l2.length; n3++) {
    const e4 = l2[n3];
    t2.lengths[n3] = e4;
    for (let n4 = 0; n4 < c; ++n4)
      t2.coords[y2 + n4] = F(h, u2[y2 + n4], n4);
    let o2 = t2.coords[y2], r2 = t2.coords[y2 + 1];
    y2 += c;
    for (let n4 = 1; n4 < e4; n4++, y2 += c) {
      o2 += u2[y2] * m2[0], r2 += u2[y2 + 1] * m2[1], t2.coords[y2] = o2, t2.coords[y2 + 1] = r2;
      for (let e5 = 2; e5 < c; ++e5)
        t2.coords[y2 + e5] = F(h, u2[y2 + e5], e5);
    }
  }
  return t2 !== e3 && wt(t2, u2.length, l2.length), t2;
}
function It(t2, e3, n3, o, r, s3) {
  if (wt(t2), t2.lengths.push(...e3.lengths), n3 === r && o === s3)
    for (let u2 = 0; u2 < e3.coords.length; u2++)
      t2.coords.push(e3.coords[u2]);
  else {
    const u2 = d2(n3, o), l2 = M(n3, o, r, s3), c = e3.coords;
    for (let e4 = 0; e4 < c.length; e4 += u2)
      l2(t2.coords, c, t2.coords.length, e4, c[e4], c[e4 + 1]);
  }
  return t2;
}
function Mt(t2, e3, n3, o) {
  let r = 0, s3 = t2[o * e3], u2 = t2[o * (e3 + 1)];
  for (let l2 = 1; l2 < n3; l2++) {
    const n4 = s3 + t2[o * (e3 + l2)], c = u2 + t2[o * (e3 + l2) + 1], i = (n4 - s3) * (c + u2);
    s3 = n4, u2 = c, r += i;
  }
  return 0.5 * r;
}
function Nt(t2, e3) {
  const { coords: n3, lengths: o } = t2;
  let r = 0, s3 = 0;
  for (let u2 = 0; u2 < o.length; u2++) {
    const t3 = o[u2];
    s3 += Mt(n3, r, t3, e3), r += t3;
  }
  return Math.abs(s3);
}
function wt(t2, e3 = 0, n3 = 0) {
  Tt(t2.lengths, n3), Tt(t2.coords, e3);
}
function Tt(t2, e3 = 0) {
  t2.length !== e3 && (t2.length = e3);
}
var Gt = { originPosition: "lowerLeft", scale: [1, 1, 1, 1], translate: [0, 0, 0, 0] };

export {
  N,
  w,
  x,
  O,
  U,
  $,
  H,
  K,
  Q,
  tt,
  et,
  nt,
  ot,
  rt,
  lt,
  ct,
  it,
  ft,
  at,
  ht,
  gt,
  pt,
  It,
  Nt
};
//# sourceMappingURL=chunk-TLTAGTBA.js.map
