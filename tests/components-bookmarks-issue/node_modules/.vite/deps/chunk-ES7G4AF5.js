import {
  S as S2,
  a2 as a5,
  h3 as h,
  p as p3,
  s as s7,
  t2 as t,
  u as u3,
  x as x2,
  y2 as y3,
  z
} from "./chunk-QXRPUAVL.js";
import {
  b as b2
} from "./chunk-KN52PCW4.js";
import {
  a as a4
} from "./chunk-PGADGS3I.js";
import {
  M,
  b,
  n as n2,
  n2 as n4,
  p as p2,
  s as s5,
  s2 as s6
} from "./chunk-6ZDDHEYR.js";
import {
  i
} from "./chunk-32X2FZ3S.js";
import {
  d2 as d3,
  n as n3
} from "./chunk-4IJED6JM.js";
import {
  J,
  K2 as K,
  U,
  W
} from "./chunk-ZPU7GNG4.js";
import {
  O as O2,
  a as a3
} from "./chunk-AVR3LWTZ.js";
import {
  j as j2,
  x
} from "./chunk-DGRFM5OL.js";
import {
  at,
  ht,
  ot
} from "./chunk-TLTAGTBA.js";
import {
  e as e2
} from "./chunk-M4RFJU4F.js";
import {
  f as f2
} from "./chunk-BFOJPIF7.js";
import {
  N,
  O,
  y as y2
} from "./chunk-RO3CTAP7.js";
import {
  Z
} from "./chunk-QNG4TY7L.js";
import {
  L
} from "./chunk-G7YFDDME.js";
import {
  s as s4
} from "./chunk-QX66UTIR.js";
import {
  f,
  m as m2,
  p,
  s as s3
} from "./chunk-J7AMTUNG.js";
import {
  u as u2
} from "./chunk-BOAEEYBE.js";
import {
  a as a2,
  j,
  l,
  o
} from "./chunk-HV6S3GY2.js";
import {
  m
} from "./chunk-IGR2BTWR.js";
import {
  E,
  u
} from "./chunk-C7NPPGFR.js";
import {
  s2
} from "./chunk-UWQ3OYA5.js";
import {
  d as d2
} from "./chunk-Z4Y53NDM.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  d,
  s
} from "./chunk-JGDJR5EV.js";
import {
  n
} from "./chunk-QHK5ZYFW.js";
import {
  has,
  k
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/createGraphicSymbolMeshSchemas.js
async function l2(l3, o2, p6) {
  const m3 = [], u6 = { scaleInfo: s7(l3), scaleExpression: null };
  for (const e3 of o2)
    switch (e3.type) {
      case "marker":
        m3.push(...u3(p6.instances.marker, e3, x2, u6));
        break;
      case "fill":
        null == e3.spriteRasterizationParam ? m3.push(...p3(p6.instances.fill, e3, u6)) : m3.push(...S2(p6.instances.complexFill, e3, false, u6));
        break;
      case "line":
        e3.spriteRasterizationParam ? m3.push(...z(p6.instances.texturedLine, e3, false, u6)) : m3.push(...h(p6.instances.line, e3, false, u6));
        break;
      case "text":
        m3.push(...y3(p6.instances.text, e3, x2, u6));
    }
  return m3;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/GraphicsReader.js
var c = class _c extends M {
  static from(t3, e3, r) {
    return new _c(t3, e3, r);
  }
  constructor(t3, e3, r) {
    super(r), this._items = t3, this._tile = e3, this._index = -1, this._cachedGeometry = null;
    const s8 = e3.lod;
    s8.wrap && (this._wrappingInfo = { worldSizeX: s8.worldSize[0] });
  }
  get _current() {
    return this._items[this._index];
  }
  getItem() {
    return this._current;
  }
  getZOrder() {
    return this._current.zOrder;
  }
  getMeshWriters() {
    var _a;
    return ((_a = this._current.symbolResource) == null ? void 0 : _a.symbolInfo.meshWriters) ?? [];
  }
  hasField(t3) {
    return null != this._current.attributes[t3];
  }
  field(t3) {
    return this.readAttribute(t3);
  }
  get geometryType() {
    const t3 = p(this._current.geometry);
    return "esriGeometryPoint" === t3 ? "esriGeometryMultipoint" : t3;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const t3 = new _c(this._items, this._tile, this.metadata);
    return this.copyInto(t3), t3;
  }
  copyInto(t3) {
    super.copyInto(t3), t3._cachedGeometry = this._cachedGeometry, t3._index = this._index;
  }
  get fields() {
    throw new Error("Fields reading not supported to graphics.");
  }
  get hasFeatures() {
    return !!this._items.length;
  }
  get hasNext() {
    return this._index + 1 < this._items.length;
  }
  get exceededTransferLimit() {
    throw new Error("InternalError: exceededTransferLimit not implemented for graphics.");
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  getInTransform() {
    return this._tile.transform;
  }
  getSize() {
    return this._items.length;
  }
  getAttributeHash() {
    let t3 = "";
    for (const e3 in this._current.attributes)
      t3 += this._current.attributes[e3];
    return t3;
  }
  getObjectId() {
    return this._items[this._index].objectId;
  }
  getDisplayId() {
    return this._current.displayId;
  }
  setDisplayId(t3) {
    throw new Error("InternalError: Setting displayId not supported for graphics.");
  }
  setIndex(t3) {
    this._index = t3;
  }
  getIndex() {
    return this._index;
  }
  next() {
    for (this._cachedGeometry = null; ++this._index < this._items.length && !this._getExists(); )
      ;
    return this._index < this._items.length;
  }
  readGeometryArea() {
    throw new Error("InternalError: readGeometryArea not supported for graphics.");
  }
  _readGeometry() {
    if (!this._cachedGeometry) {
      let t3 = ot(this._current.projectedGeometry, this.hasZ, this.hasM);
      if ("esriGeometryPolyline" === this.geometryType && (t3 = ht(new e2(), t3, this.hasZ, this.hasM, this.geometryType, this._tile.transform.scale[0])), this._cachedGeometry = at(new e2(), t3, this.hasZ, this.hasM, this.geometryType, this._tile.transform), !this._cachedGeometry)
        return null;
      this._wrapGeometry(this._cachedGeometry);
    }
    return this._cachedGeometry;
  }
  _wrapGeometry(t3) {
    if (!this._wrappingInfo)
      return;
    const { worldSizeX: e3 } = this._wrappingInfo;
    if (t3.isPoint)
      return 1 === e3 ? (t3.coords.push(a3, 0), t3.coords.push(2 * -a3, 0), void t3.lengths.push(3)) : 2 === e3 ? (t3.coords.push(2 * a3, 0), t3.coords.push(4 * -a3, 0), void t3.lengths.push(3)) : void this._wrapVertex(t3.coords, 0, 2, e3);
    if ("esriGeometryMultipoint" !== this.geometryType)
      ;
    else {
      if (1 === e3) {
        const e4 = t3.coords.slice();
        e4[0] -= 512;
        const r = t3.coords.slice();
        r[0] += 512, t3.coords.push(...e4, ...r);
        const s8 = t3.lengths[0];
        return void t3.lengths.push(s8, s8);
      }
      this._wrapVertex(t3.coords, 0, 2, e3);
    }
  }
  _wrapVertex(t3, e3, r, s8) {
    const i2 = e3 * r, o2 = t3[i2];
    o2 < -a3 * (s8 - 2) ? t3[i2] = o2 + a3 * s8 : o2 > a3 * (s8 - 1) && (t3[i2] = o2 - a3 * s8);
  }
  _readX() {
    const t3 = this._readGeometry();
    return null != t3 ? t3.coords[0] : 0;
  }
  _readY() {
    const t3 = this._readGeometry();
    return null != t3 ? t3.coords[1] : 0;
  }
  _readServerCentroid() {
    switch (this.geometryType) {
      case "esriGeometryPolygon": {
        const t3 = l(this._current.projectedGeometry), r = new e2([], t3);
        return at(new e2(), r, this.hasZ, this.hasM, this.geometryType, this._tile.transform);
      }
      case "esriGeometryPolyline": {
        const e3 = this._current.projectedGeometry, r = o(e3.paths, this.hasZ), s8 = new e2([], r);
        return at(new e2(), s8, this.hasZ, this.hasM, this.geometryType, this._tile.transform);
      }
    }
    return null;
  }
  _readAttribute(t3, e3) {
    const r = this._current.attributes[t3];
    if (void 0 !== r)
      return r;
    const s8 = t3.toLowerCase();
    for (const i2 in this._current.attributes)
      if (i2.toLowerCase() === s8)
        return this._current.attributes[i2];
  }
  _readAttributes() {
    return this._current.attributes;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/graphicsUtils.js
var a6 = 50;
function u4(e3) {
  if (!e3)
    return null;
  const { xmin: t3, ymin: i2, xmax: r, ymax: o2, spatialReference: s8 } = e3;
  return new j({ rings: [[[t3, i2], [t3, o2], [r, o2], [r, i2], [t3, i2]]], spatialReference: s8 });
}

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStoreItem.js
var p4 = class _p {
  static fromGraphic(t3, e3, s8, r) {
    return new _p(t3.geometry, e3, t3.attributes, t3.visible, t3.uid, s8, r);
  }
  constructor(e3, s8, r, i2, o2, m3, p6) {
    this.geometry = e3, this.symbol = s8, this.attributes = r, this.visible = i2, this.objectId = o2, this.zOrder = m3, this.displayId = p6, this.bounds = u(), this.prevBounds = u(), this.size = [0, 0, 0, 0];
  }
  get linearCIM() {
    var _a;
    return (_a = this.symbolResource) == null ? void 0 : _a.symbolInfo.linearCIM;
  }
  update(e3, s8, r) {
    return (this.geometry !== e3.geometry || this.attributes !== e3.attributes || this.symbol !== s8 || this.zOrder !== r || this.visible !== e3.visible) && (this.prevBounds = this.bounds, this.bounds = u(), this.zOrder = r, this.geometry = e3.geometry, this.attributes = e3.attributes, this.symbol = s8, this.visible = e3.visible, this.symbolResource = null, this.projectedGeometry = null, true);
  }
  async projectAndNormalize(t3) {
    let p6 = this.geometry;
    if (!p6 || !p6.spatialReference || "mesh" === p6.type)
      return;
    "extent" === p6.type && (p6 = u4(p6)), await x(p6.spatialReference, t3);
    const h2 = a4(p6);
    if (!h2)
      return;
    const a7 = j2(h2, p6.spatialReference, t3);
    a7 && m(a7), this.projectedGeometry = m2(a7) ? u4(a7) : a7;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicUpdateMessage.js
var t2 = class {
  constructor(t3, e3, d5) {
    this.added = t3, this.updated = e3, this.removed = d5;
  }
  hasAnyUpdate() {
    return !!(this.added.length || this.updated.length || this.removed.length);
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStore.js
var u5 = 1e-5;
function d4(e3, t3) {
  return t3.zOrder - e3.zOrder;
}
var p5 = class {
  constructor(e3, t3, s8, o2, i2) {
    this._items = /* @__PURE__ */ new Map(), this._boundsDirty = false, this._outSpatialReference = e3, this._cimResourceManager = t3, this._hittestDrawHelper = new W(t3), this._tileInfoView = s8, this._store = i2;
    const r = s8.getClosestInfoForScale(o2);
    this._resolution = this._tileInfoView.getTileResolution(r.level);
  }
  items() {
    return this._items.values();
  }
  getItem(e3) {
    return this._items.get(e3);
  }
  async update(e3, t3, s8) {
    const o2 = [], i2 = [], r = [], n5 = /* @__PURE__ */ new Set(), m3 = [];
    let l3 = 0;
    for (const c2 of e3.items) {
      l3++;
      const e4 = c2.uid, r2 = this._items.get(e4), h2 = t3(c2);
      if (n5.add(e4), r2) {
        r2.update(c2, h2, l3) && (i2.push(r2), m3.push(this._updateItem(r2, s8)));
        continue;
      }
      const u6 = this._store.createDisplayIdForObjectId(e4), d5 = p4.fromGraphic(c2, h2, l3, u6);
      m3.push(this._updateItem(d5, s8)), this._items.set(d5.objectId, d5), o2.push(d5);
    }
    for (const [a7, c2] of this._items.entries())
      n5.has(a7) || (this._store.releaseDisplayIdForObjectId(a7), this._items.delete(a7), r.push(c2));
    return await Promise.all(m3), this._index = null, new t2(o2, i2, r);
  }
  updateLevel(e3) {
    this._resolution !== e3 && (this._index = null, this._boundsDirty = true, this._resolution = e3);
  }
  hitTest(e3, t3, i2, n5, m3) {
    const l3 = has("esri-mobile"), a7 = has(l3 ? "hittest-2d-mobile-tolerance" : "hittest-2d-desktop-tolerance"), h2 = a7 + (l3 ? 0 : has("hittest-2d-small-symbol-tolerance"));
    e3 = L(e3, this._tileInfoView.spatialReference);
    const u6 = n5 * window.devicePixelRatio * h2, p6 = u();
    p6[0] = e3 - u6, p6[1] = t3 - u6, p6[2] = e3 + u6, p6[3] = t3 + u6;
    const _ = n5 * window.devicePixelRatio * a7, f3 = u();
    f3[0] = e3 - _, f3[1] = t3 - _, f3[2] = e3 + _, f3[3] = t3 + _;
    const b3 = 0.5 * n5 * (h2 + a6), y4 = this._searchIndex(e3 - b3, t3 - b3, e3 + b3, t3 + b3);
    if (!y4 || 0 === y4.length)
      return [];
    const I = [], g2 = u(), j3 = u();
    for (const s8 of y4) {
      if (!s8.visible)
        continue;
      const { projectedGeometry: e4, symbolResource: t4 } = s8;
      this._getSymbolBounds(g2, t4, e4, j3, m3), j3[3] = j3[2] = j3[1] = j3[0] = 0, E(g2, p6) && I.push(s8);
    }
    if (0 === I.length)
      return [];
    const x3 = this._hittestDrawHelper, w = [];
    for (const s8 of I) {
      const { projectedGeometry: e4, symbolResource: t4 } = s8;
      if (!t4)
        continue;
      const { textInfo: o2, symbolInfo: i3 } = t4, r = i3.cimSymbol;
      x3.hitTest(f3, r.symbol, e4, o2, m3, n5) && w.push(s8);
    }
    return w.sort(d4), w.map((e4) => e4.objectId);
  }
  queryItems(e3) {
    return 0 === this._items.size ? [] : this._searchForItems(e3);
  }
  clear() {
    this._items.clear(), this._index = null;
  }
  async _updateItem(e3, t3) {
    await e3.projectAndNormalize(this._outSpatialReference), await t3(e3);
    const { size: s8 } = e3;
    s8[0] = s8[1] = s8[2] = s8[3] = 0, this._getSymbolBounds(e3.bounds, e3.symbolResource, e3.projectedGeometry, e3.size, 0);
  }
  _searchIndex(e3, s8, o2, i2) {
    return this._boundsDirty && (this._items.forEach((e4) => this._getSymbolBounds(e4.bounds, e4.symbolResource, e4.projectedGeometry, e4.size, 0)), this._boundsDirty = false), this._index || (this._index = i(9, (e4) => ({ minX: e4.bounds[0], minY: e4.bounds[1], maxX: e4.bounds[2], maxY: e4.bounds[3] })), this._index.load(Array.from(this._items.values()))), this._index.search({ minX: e3, minY: s8, maxX: o2, maxY: i2 });
  }
  _searchForItems(e3) {
    const t3 = this._tileInfoView.spatialReference, o2 = e3.bounds, i2 = s2(t3);
    if (i2 && t3.isWrappable) {
      const [t4, r] = i2.valid, n5 = Math.abs(o2[2] - r) < u5, m3 = Math.abs(o2[0] - t4) < u5;
      if ((!n5 || !m3) && (n5 || m3)) {
        const i3 = e3.resolution;
        let m4;
        m4 = u(n5 ? [t4, o2[1], t4 + i3 * a6, o2[3]] : [r - i3 * a6, o2[1], r, o2[3]]);
        const l3 = this._searchIndex(o2[0], o2[1], o2[2], o2[3]), a7 = this._searchIndex(m4[0], m4[1], m4[2], m4[3]);
        return [.../* @__PURE__ */ new Set([...l3, ...a7])];
      }
    }
    return this._searchIndex(o2[0], o2[1], o2[2], o2[3]);
  }
  _getSymbolBounds(t3, o2, r, n5, m3) {
    if (!o2 || !o2.symbolInfo.linearCIM || !r)
      return null;
    if (t3 || (t3 = u()), a2(t3, r), !n5 || 0 === n5[0] && 0 === n5[1] && 0 === n5[2] && 0 === n5[3]) {
      const { textInfo: t4, symbolInfo: s8 } = o2, i2 = s8.cimSymbol;
      n5 || (n5 = [0, 0, 0, 0]);
      const r2 = J.getSymbolInflateSize(n5, i2.symbol, this._cimResourceManager, m3, t4);
      n5[0] = u2(r2[0]), n5[1] = u2(r2[1]), n5[2] = u2(r2[2]), n5[3] = u2(r2[3]);
    }
    const a7 = this._resolution, c2 = J.safeSize(n5);
    return t3[0] -= c2 * a7, t3[1] -= c2 * a7, t3[2] += c2 * a7, t3[3] += c2 * a7, t3;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicsView2D.js
var F = class _F {
  static getOrCreate(e3, t3, r) {
    let s8 = t3.get(e3.id);
    return s8 || (s8 = new _F(e3, r), t3.set(e3.id, s8)), s8;
  }
  static fromItems(e3, t3, r) {
    const s8 = new _F(e3, r);
    return s8.addedOrModified.push(...t3), s8;
  }
  constructor(e3, t3) {
    this.tile = e3, this.metadata = t3, this.addedOrModified = [], this.removed = [];
  }
  get reader() {
    return this._reader || (this._reader = c.from(this.addedOrModified, this.tile, this.metadata)), this._reader;
  }
};
var V = class extends s4(S) {
  constructor(e3) {
    super(e3), this._attached = false, this._tiles = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._hashToSymbolInfo = /* @__PURE__ */ new Map(), this._lastCleanup = performance.now(), this._cleanupRequired = true, this.lastUpdateId = -1, this.renderer = null, this._updateTracking = new d3({ debugName: "GraphicsView2D" }), this.updateRequested = false, this.defaultPointSymbolEnabled = true, this._commandQueue = new a5({ process: (e4) => {
      switch (e4.type) {
        case "processed-edit":
          throw new Error("InternalError: Unsupported command");
        case "update":
          return this._update();
      }
    } }), this.graphicUpdateHandler = this.graphicUpdateHandler.bind(this);
  }
  destroy() {
    this.container.destroy(), this.view = null, this.renderer = null, this._set("graphics", null), this._controller.abort(), this._graphicStore.clear(), this._attributeStore = null, this._hashToSymbolInfo.clear(), this._updateTracking.destroy(), this._commandQueue.destroy();
  }
  _initAttributeStore() {
    this._storage = new p2({ spatialReference: this.view.spatialReference, fields: new Z() }), this._attributeStore = new b({ isLocal: true, update: (e4) => {
      has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView2D.AttributeStoreView.updateStart`, { message: e4 }), this.container.attributeView.requestUpdate(e4), this.container.requestRender(), has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView2D.AttributeStoreView.updateEnd`, { message: e4 });
    } });
    const e3 = t(null, []);
    this._attributeStore.update(e3, this._storage, null), this.container.checkHighlight = () => this._attributeStore.hasHighlight;
  }
  initialize() {
    this._initAttributeStore(), this._metadata = s6.create(this.view.spatialReference), this._resourceProxy = new s5({ fetch: (e4) => Promise.all(e4.map((e5) => this.view.stage.textureManager.rasterizeItem(e5))), fetchDictionary: (e4) => {
      throw new Error("InternalError: Graphics do not support Dictionary requests");
    } }), this.addHandles([d2(() => this._effectiveRenderer, () => this._pushUpdate()), this.view.graphicsTileStore.on("update", this._onTileUpdate.bind(this)), this.container.on("attach", () => {
      this.addHandles([this.graphics.on("change", () => this._pushUpdate())]), this._graphicStore = new p5(this.view.spatialReference, this._cimResourceManager, this.view.featuresTilingScheme, this.view.state.scale, this._attributeStore), this._attached = true, this.requestUpdate(), this._pushUpdate();
    })]), this._updateTracking.addUpdateTracking("CommandQueue", this._commandQueue.updateTracking);
    const e3 = this.view.graphicsTileStore.tiles;
    this._onTileUpdate({ added: e3, removed: [] });
  }
  get _effectiveRenderer() {
    return "function" == typeof this.renderer ? this.renderer() : this.renderer;
  }
  get _cimResourceManager() {
    return this.view.stage.textureManager.resourceManager;
  }
  get updating() {
    const e3 = !this._attached || this._updateTracking.updating;
    return has("esri-2d-log-updating") && console.log(`Updating GraphicsView2D: ${e3}
  -> attaching ${!this._attached}
  -> updateTracking ${this._updateTracking.updating}`), e3;
  }
  hitTest(e3) {
    if (!this.view || this.view.suspended)
      return [];
    const { resolution: t3, rotation: s8 } = this.view.state, i2 = this._graphicStore.hitTest(e3.x, e3.y, 2, t3, s8), o2 = new Set(i2), a7 = this.graphics.items.reduce((e4, t4) => (o2.has(t4.uid) && e4.set(t4.uid, t4), e4), /* @__PURE__ */ new Map());
    return i2.map((e4) => a7.get(e4)).filter(k);
  }
  requestUpdate() {
    this.updateRequested || (this.updateRequested = true, this.requestUpdateCallback()), this.notifyChange("updating");
  }
  processUpdate(e3) {
    this.updateRequested && (this.updateRequested = false, this.update(e3));
  }
  viewChange() {
    this.requestUpdate();
  }
  setHighlight(e3) {
    var _a;
    const t3 = [];
    for (const { objectId: r, highlightFlags: s8 } of e3) {
      const e4 = (_a = this._graphicStore.getItem(r)) == null ? void 0 : _a.displayId;
      t3.push({ objectId: r, highlightFlags: s8, displayId: e4 });
    }
    this._attributeStore.setHighlight(t3, e3), this._pushUpdate();
  }
  graphicUpdateHandler(e3) {
    this._pushUpdate();
  }
  update(e3) {
    this.updateRequested = false, this._attached && this._graphicStore.updateLevel(e3.state.resolution);
  }
  _pushUpdate() {
    d(this._commandQueue.push({ type: "update" }));
  }
  async _update() {
    try {
      has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView._update start`);
      const e3 = await this._graphicStore.update(this.graphics, (e4) => this._getSymbolForGraphic(e4), (e4) => this._ensureSymbolResource(e4));
      if (!e3.hasAnyUpdate())
        return void this._attributeStore.sendUpdates();
      e3.removed.length && (this._cleanupRequired = true), has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView updateMessage`, e3);
      const t3 = this._createTileMessages(e3);
      await this._fetchResources(t3), this._write(t3);
      for (const r of e3.added)
        this._setFilterState(r);
      for (const r of e3.updated)
        this._setFilterState(r);
      has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView sendUpdate`, e3), this._attributeStore.sendUpdates(), has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView sendUpdate.await`, e3);
    } catch (e3) {
    }
    this._cleanupSharedResources();
  }
  _createTileMessages(e3) {
    const t3 = /* @__PURE__ */ new Map();
    for (const r of e3.added) {
      const e4 = this.view.graphicsTileStore.getIntersectingTiles(r.bounds);
      for (const s8 of e4) {
        F.getOrCreate(s8, t3, this._metadata).addedOrModified.push(r);
      }
    }
    for (const r of e3.updated) {
      const e4 = this.view.graphicsTileStore.getIntersectingTiles(r.prevBounds), s8 = this.view.graphicsTileStore.getIntersectingTiles(r.bounds);
      for (const i2 of e4) {
        F.getOrCreate(i2, t3, this._metadata).removed.push(r.displayId);
      }
      for (const i2 of s8) {
        F.getOrCreate(i2, t3, this._metadata).addedOrModified.push(r);
      }
    }
    for (const r of e3.removed) {
      const e4 = this.view.graphicsTileStore.getIntersectingTiles(r.bounds);
      for (const s8 of e4) {
        F.getOrCreate(s8, t3, this._metadata).removed.push(r.displayId);
      }
    }
    return Array.from(t3.values());
  }
  async _fetchResources(e3) {
    for (const { tile: t3, reader: r } of e3) {
      has("esri-2d-update-debug") && console.debug(`Id[${this.layerId}] Tile[${t3.id}] GraphicsView fetchResources`, e3);
      const s8 = r.getCursor();
      for (; s8.next(); )
        for (const e4 of s8.getMeshWriters())
          e4.enqueueRequest(this._resourceProxy, s8, t3.createArcadeEvaluationOptions(this.view.timeZone));
    }
    await this._resourceProxy.fetchEnqueuedResources();
  }
  _write(e3) {
    for (const t3 of e3) {
      has("esri-2d-update-debug") && console.debug(`Id[${this.layerId}] Tile[${t3.tile.id}] GraphicsView write`, t3);
      const e4 = this._writeMeshes(t3);
      let r = this._tiles.get(t3.tile.key);
      r || (r = this._createFeatureTile(t3.tile.key)), has("esri-2d-update-debug") && console.debug(`Id[${this.layerId}] Tile[${t3.tile.id}] GraphicsView onTileData`, t3), this.container.onTileData(r, { type: "update", modify: e4, remove: t3.removed, end: false, attributeEpoch: this._attributeStore.epoch }), this.container.requestRender();
    }
  }
  _writeMeshes(e3) {
    const t3 = new n2(e3.tile.id), r = e3.reader.getCursor();
    for (; r.next(); ) {
      t3.entityStart(r.getDisplayId(), r.getZOrder());
      for (const s8 of r.getMeshWriters())
        s8.write(t3, this._resourceProxy, r, e3.tile.createArcadeEvaluationOptions(this.view.timeZone), e3.tile.level);
      t3.entityEnd();
    }
    return { ...t3.serialize().message, tileId: e3.tile.id };
  }
  _setFilterState(e3) {
    const t3 = e3.displayId, r = this._attributeStore.getHighlightFlags(e3.objectId);
    this._attributeStore.setData(t3, 0, 0, r | (e3.visible ? O2 : 0));
  }
  _getSymbolForGraphic(e3) {
    return null != e3.symbol ? e3.symbol : null != this._effectiveRenderer ? this._effectiveRenderer.getSymbol(e3) : this._getNullSymbol(e3);
  }
  async _ensureSymbolResource(e3) {
    if (!e3.symbol)
      return;
    const t3 = await this._getSymbolInfo(e3.symbol);
    if (!t3)
      return;
    const r = t3.linearCIM.filter((e4) => "text" === e4.type);
    if (r.length > 0) {
      const s8 = await this._getTextResources(e3, r);
      e3.symbolResource = { symbolInfo: t3, textInfo: s8 };
    } else
      e3.symbolResource = { symbolInfo: t3 };
  }
  _getSymbolInfo(e3) {
    const t3 = e3.hash();
    return this._hashToSymbolInfo.has(t3) || this._hashToSymbolInfo.set(t3, this._createSymbolInfo(t3, e3).catch((e4) => null)), this._hashToSymbolInfo.get(t3);
  }
  async _createSymbolInfo(e3, t3) {
    const r = await this._convertToCIMSymbol(t3), s8 = await this._createLinearCIM(r);
    if ("text" === t3.type)
      for (const i2 of s8)
        "text" === i2.type && (i2.lineWidth = t3.lineWidth);
    return { hash: e3, cimSymbol: r, linearCIM: s8, meshWriters: await this._createMeshWriters(r, s8) };
  }
  async _convertToCIMSymbol(e3) {
    const t3 = U(e3);
    if ("web-style" === t3.type) {
      return (await t3.fetchCIMSymbol()).data;
    }
    return t3;
  }
  async _createLinearCIM(e3) {
    return await Promise.all(K.fetchResources(e3.symbol, this._cimResourceManager, [])), this.view.stage.cimAnalyzer.analyzeSymbolReference(e3, false);
  }
  async _createMeshWriters(e3, t3) {
    s(this._controller.signal);
    const r = this.container.instanceStore, s8 = await l2(e3, t3, r);
    return Promise.all(s8.map((e4) => n4(this._storage, this._resourceProxy, e4.meshWriterName, n3(e4.id), e4.options, { tileInfo: this.view.featuresTilingScheme.tileInfo }, e4.optionalAttributes)));
  }
  _onTileUpdate(e3) {
    if (e3.added && e3.added.length > 0)
      for (const t3 of e3.added)
        this._updateTracking.addPromise(this._addTile(t3));
    if (e3.removed && e3.removed.length > 0)
      for (const t3 of e3.removed)
        this._removeTile(t3.key);
  }
  _createFeatureTile(e3) {
    const t3 = this.view.featuresTilingScheme.getTileBounds(u(), e3), r = this.view.featuresTilingScheme.getTileResolution(e3.level), s8 = new b2(e3, r, t3[0], t3[3]);
    return this._tiles.set(e3, s8), this.container.addChild(s8), s8;
  }
  async _addTile(e3) {
    if (!this._attached)
      return;
    const t3 = this._graphicStore.queryItems(e3);
    if (!t3.length)
      return;
    const r = this._createFeatureTile(e3.key), s8 = F.fromItems(e3, t3, this._metadata);
    await this._fetchResources([s8]);
    const i2 = this._writeMeshes(s8);
    r.onMessage({ type: "append", append: i2, clear: false, end: true, attributeEpoch: this._attributeStore.epoch });
  }
  _removeTile(e3) {
    if (!this._tiles.has(e3))
      return;
    const t3 = this._tiles.get(e3);
    this.container.removeChild(t3), t3.destroy(), this._tiles.delete(e3);
  }
  _getNullSymbol(e3) {
    const t3 = e3.geometry;
    return s3(t3) ? O : f(t3) || m2(t3) ? y2 : this.defaultPointSymbolEnabled ? N : null;
  }
  async _getTextResources(e3, t3) {
    const r = new Array(), s8 = new Array();
    for (let i2 = 0; i2 < t3.length; i2++) {
      const o3 = t3[i2], { resource: a8, overrides: n6 } = o3.textRasterizationParam;
      if ((n6 == null ? void 0 : n6.length) > 0) {
        const t4 = f2.resolveSymbolOverrides({ type: "CIMSymbolReference", primitiveOverrides: n6, symbol: { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, size: a8.symbol.height, anchorPointUnits: "Relative", frame: { xmin: -5, ymin: -5, xmax: 5, ymax: 5 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { x: 0, y: 0 }, symbol: a8.symbol, textString: a8.textString }], scaleSymbolsProportionally: true, respectFrame: true }] } }, e3, this.view.spatialReference, null, p(e3.projectedGeometry), null, null);
        t4.then((e4) => {
          const t5 = e4.symbolLayers[0], { textString: r2 } = t5.markerGraphics[0];
          s8.push({ type: "cim-rasterization-info", resource: { type: "text", textString: r2 || "", font: a8.font } }), o3.text = a8.textString = r2 || "";
        }), r.push(t4);
      } else
        s8.push({ type: "cim-rasterization-info", resource: a8 });
    }
    r.length > 0 && await Promise.all(r);
    const o2 = s8.map((e4) => this.view.stage.textureManager.rasterizeItem(e4)), a7 = await Promise.all(o2);
    n(a7);
    const n5 = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < t3.length; i2++) {
      const e4 = t3[i2];
      n5.set(e4.textRasterizationParam.resource.symbol, { text: e4.text, glyphMosaicItems: a7[i2] });
    }
    return n5;
  }
  _cleanupSharedResources() {
    var _a;
    if (!this._cleanupRequired)
      return;
    const e3 = performance.now();
    if (e3 - this._lastCleanup < 5e3)
      return;
    this._cleanupRequired = false, this._lastCleanup = e3;
    const t3 = /* @__PURE__ */ new Set();
    for (const s8 of this._graphicStore.items()) {
      const e4 = (_a = s8.symbolResource) == null ? void 0 : _a.symbolInfo.hash;
      t3.add(e4);
    }
    const r = new Set(this._hashToSymbolInfo.keys());
    for (const s8 of r.values())
      t3.has(s8) || this._hashToSymbolInfo.delete(s8);
  }
};
e([y()], V.prototype, "_effectiveRenderer", null), e([y({ constructOnly: true })], V.prototype, "layerId", void 0), e([y({ constructOnly: true })], V.prototype, "requestUpdateCallback", void 0), e([y()], V.prototype, "container", void 0), e([y({ constructOnly: true })], V.prototype, "graphics", void 0), e([y()], V.prototype, "renderer", void 0), e([y()], V.prototype, "_updateTracking", void 0), e([y()], V.prototype, "updating", null), e([y()], V.prototype, "view", void 0), e([y()], V.prototype, "updateRequested", void 0), e([y()], V.prototype, "defaultPointSymbolEnabled", void 0), V = e([a("esri.views.2d.layers.graphics.GraphicsView2D")], V);
var $ = V;

export {
  $
};
//# sourceMappingURL=chunk-ES7G4AF5.js.map
