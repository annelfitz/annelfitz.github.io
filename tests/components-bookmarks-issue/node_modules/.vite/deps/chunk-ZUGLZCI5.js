import {
  o as o3
} from "./chunk-7VV4JAZJ.js";
import {
  x as x2
} from "./chunk-3IAZNUQL.js";
import {
  n as n4
} from "./chunk-BUEJAM23.js";
import {
  a as a3
} from "./chunk-HFYOMP47.js";
import {
  p as p3
} from "./chunk-JNGJWHJD.js";
import {
  c as c3
} from "./chunk-4IKPTZ53.js";
import {
  C as C2
} from "./chunk-DXMBDX2I.js";
import {
  m as m2,
  u
} from "./chunk-TUVEYM7U.js";
import {
  p as p2
} from "./chunk-OHYLFFUW.js";
import {
  Z
} from "./chunk-QNG4TY7L.js";
import {
  c as c4
} from "./chunk-RGAA5Z76.js";
import {
  b
} from "./chunk-W5ALAOW2.js";
import {
  r as r3
} from "./chunk-DVIGFJWY.js";
import {
  K,
  c as c2
} from "./chunk-ERD6I7QP.js";
import {
  y as y2
} from "./chunk-Z3NX5DTX.js";
import {
  P
} from "./chunk-ETHGDNE6.js";
import {
  f as f2
} from "./chunk-I2X6UR6L.js";
import {
  l
} from "./chunk-CYVKDANA.js";
import {
  S
} from "./chunk-ZAM62XN5.js";
import {
  I,
  y as y3
} from "./chunk-RKVEKQ5O.js";
import {
  s as s5
} from "./chunk-QX66UTIR.js";
import {
  x
} from "./chunk-ZIJHDTB7.js";
import {
  n as n3
} from "./chunk-VEODBKUJ.js";
import {
  o as o2
} from "./chunk-PJNK3TLV.js";
import {
  c
} from "./chunk-LBXFRGMS.js";
import {
  p
} from "./chunk-VTH4DAHQ.js";
import {
  m
} from "./chunk-ONK5AE7R.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  o
} from "./chunk-YOPMY6TS.js";
import {
  r as r2
} from "./chunk-VIN55KNF.js";
import {
  s as s4
} from "./chunk-IOB3DJMR.js";
import {
  U,
  V as V2,
  v as v2
} from "./chunk-SAYWXQVM.js";
import {
  C,
  d as d2
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  e as e2,
  n2,
  t2,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  T,
  a3 as a2,
  d,
  r2 as r,
  s2 as s3,
  t,
  v
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  s as s2
} from "./chunk-JGDJR5EV.js";
import {
  a,
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/layers/mixins/ArcGISMapService.js
var f3 = (f5) => {
  let b2 = class extends f5 {
    constructor() {
      super(...arguments), this.capabilities = void 0, this.copyright = null, this.fullExtent = null, this.legendEnabled = true, this.spatialReference = null, this.version = void 0, this._allLayersAndTablesMap = null;
    }
    readCapabilities(e3, r4) {
      const t3 = r4.capabilities && r4.capabilities.split(",").map((e4) => e4.toLowerCase().trim());
      if (!t3)
        return { operations: { supportsExportMap: false, supportsExportTiles: false, supportsIdentify: false, supportsQuery: false, supportsTileMap: false }, exportMap: null, exportTiles: null };
      const s6 = this.type, o4 = "tile" !== s6 && !!r4.supportsDynamicLayers, a4 = t3.includes("query"), p4 = t3.includes("map"), l2 = !!r4.exportTilesAllowed, n5 = t3.includes("tilemap"), c5 = t3.includes("data"), u2 = "tile" !== s6 && (!r4.tileInfo || o4), y4 = "tile" !== s6 && (!r4.tileInfo || o4), m4 = "tile" !== s6, d3 = r4.cimVersion && r3.parse(r4.cimVersion), h2 = (d3 == null ? void 0 : d3.since(1, 4)) ?? false, f6 = (d3 == null ? void 0 : d3.since(2, 0)) ?? false;
      return { operations: { supportsExportMap: p4, supportsExportTiles: l2, supportsIdentify: a4, supportsQuery: c5, supportsTileMap: n5 }, exportMap: p4 ? { supportsArcadeExpressionForLabeling: h2, supportsSublayersChanges: m4, supportsDynamicLayers: o4, supportsSublayerVisibility: u2, supportsSublayerDefinitionExpression: y4, supportsCIMSymbols: f6 } : null, exportTiles: l2 ? { maxExportTilesCount: +r4.maxExportTilesCount } : null };
    }
    readVersion(e3, r4) {
      let t3 = r4.currentVersion;
      return t3 || (t3 = r4.hasOwnProperty("capabilities") || r4.hasOwnProperty("tables") ? 10 : r4.hasOwnProperty("supportedImageFormatTypes") ? 9.31 : 9.3), t3;
    }
    async fetchRelatedService(e3) {
      const r4 = this.portalItem;
      if (!r4 || !c(r4))
        return null;
      this._relatedFeatureServicePromise || (this._relatedFeatureServicePromise = r4.fetchRelatedItems({ relationshipType: "Service2Service", direction: "reverse" }, e3).then((e4) => e4.find((e5) => "Feature Service" === e5.type) ?? null, () => null));
      const t3 = await this._relatedFeatureServicePromise;
      return s2(e3), t3 ? { itemId: t3.id, url: t3.url } : null;
    }
    async fetchSublayerInfo(e3, t3) {
      var _a;
      const { source: s6 } = e3;
      if ((this == null ? void 0 : this.portalItem) && "tile" === this.type && "map-layer" === (s6 == null ? void 0 : s6.type) && c(this.portalItem) && e3.originIdOf("url") < e2.SERVICE) {
        const r4 = await this.fetchRelatedService(t3);
        r4 && (e3.url = V2(r4.url, s6.mapLayerId.toString()), e3.layerItemId = r4.itemId);
      }
      const { url: i } = e3;
      let a4;
      if ("data-layer" === s6.type) {
        a4 = (await U(i, { responseType: "json", query: { f: "json", ...this.customParameters, token: this.apiKey }, ...t3 })).data;
      } else if (i && e3.originIdOf("url") > e2.SERVICE)
        try {
          const e4 = await this._fetchAllLayersAndTablesFromService(i), r4 = ((_a = p(i)) == null ? void 0 : _a.sublayer) ?? s6.mapLayerId;
          a4 = e4.get(r4);
        } catch {
        }
      else {
        let r4 = e3.id;
        "map-layer" === (s6 == null ? void 0 : s6.type) && (r4 = s6.mapLayerId);
        try {
          a4 = (await this.fetchAllLayersAndTables(t3)).get(r4);
        } catch {
        }
      }
      return a4;
    }
    async fetchAllLayersAndTables(e3) {
      var _a;
      return this._fetchAllLayersAndTablesFromService((_a = this.parsedUrl) == null ? void 0 : _a.path, e3);
    }
    async _fetchAllLayersAndTablesFromService(e3, i) {
      await this.load(i), this._allLayersAndTablesMap || (this._allLayersAndTablesMap = /* @__PURE__ */ new Map());
      const a4 = p(e3), p4 = r(this._allLayersAndTablesMap, a4 == null ? void 0 : a4.url.path, () => U(V2(a4 == null ? void 0 : a4.url.path, "/layers"), { responseType: "json", query: { f: "json", ...this.customParameters, token: this.apiKey } }).then((e4) => {
        const r4 = /* @__PURE__ */ new Map();
        for (const t3 of e4.data.layers)
          r4.set(t3.id, t3);
        return { result: r4 };
      }, (e4) => ({ error: e4 }))), l2 = await p4;
      if (s2(i), "result" in l2)
        return l2.result;
      throw l2.error;
    }
  };
  return e([y({ readOnly: true })], b2.prototype, "capabilities", void 0), e([o("service", "capabilities", ["capabilities", "exportTilesAllowed", "maxExportTilesCount", "supportsDynamicLayers", "tileInfo"])], b2.prototype, "readCapabilities", null), e([y({ json: { read: { source: "copyrightText" } } })], b2.prototype, "copyright", void 0), e([y({ type: w })], b2.prototype, "fullExtent", void 0), e([y(I)], b2.prototype, "id", void 0), e([y({ type: Boolean, json: { origins: { service: { read: { enabled: false } } }, read: { source: "showLegend" }, write: { target: "showLegend" } } })], b2.prototype, "legendEnabled", void 0), e([y(y3)], b2.prototype, "popupEnabled", void 0), e([y({ type: f })], b2.prototype, "spatialReference", void 0), e([y({ readOnly: true })], b2.prototype, "version", void 0), e([o("version", ["currentVersion", "capabilities", "tables", "supportedImageFormatTypes"])], b2.prototype, "readVersion", null), b2 = e([a2("esri.layers.mixins.ArcGISMapService")], b2), b2;
};

// node_modules/@arcgis/core/layers/support/Sublayer.js
var B;
function J(e3) {
  return null != e3 && "esriSMS" === e3.type;
}
function $(e3, r4, t3) {
  var _a;
  const i = this.originIdOf(r4) >= n2(t3.origin);
  return { ignoreOrigin: true, allowNull: i, enabled: !!t3 && ("map-image" === ((_a = t3.layer) == null ? void 0 : _a.type) && (t3.writeSublayerStructure || i)) };
}
function G(e3, r4, t3) {
  var _a;
  return { enabled: !!t3 && ("tile" === ((_a = t3.layer) == null ? void 0 : _a.type) && (t3.origin && this.originIdOf(r4) >= n2(t3.origin) || this._isOverridden(r4))) };
}
function H(e3, r4, t3) {
  return { ignoreOrigin: true, enabled: t3 && t3.writeSublayerStructure || false };
}
function z(e3, r4, t3) {
  return { ignoreOrigin: true, enabled: !!t3 && (t3.writeSublayerStructure || this.originIdOf(r4) >= n2(t3.origin)) };
}
var K2 = 0;
var W = /* @__PURE__ */ new Set();
W.add("layer"), W.add("parent"), W.add("loaded"), W.add("loadStatus"), W.add("loadError"), W.add("loadWarnings");
var X = B = class extends S(s5(m)) {
  constructor(e3) {
    super(e3), this.capabilities = void 0, this.maxScaleRange = { minScale: 0, maxScale: 0 }, this.fields = null, this.fullExtent = null, this.geometryType = null, this.globalIdField = null, this.legendEnabled = true, this.objectIdField = null, this.parent = null, this.popupEnabled = true, this.popupTemplate = null, this.sourceJSON = null, this.title = null, this.typeIdField = null, this.type = "sublayer", this.types = null, this._lastParsedUrl = null;
  }
  async load(e3) {
    return this.addResolvingPromise((async () => {
      const { layer: r4, url: t3 } = this;
      if (!r4 && !t3)
        throw new s("sublayer:missing-layer", "Sublayer can't be loaded without being part of a layer", { sublayer: this });
      const i = r4 ? await r4.fetchSublayerInfo(this, e3) : (await U(t3, { responseType: "json", query: { f: "json" }, ...e3 })).data;
      i && (this.sourceJSON = i, this.read({ layerDefinition: i }, { origin: "service", layer: r4, url: f2(t3) }));
    })()), this;
  }
  readCapabilities(e3, r4) {
    r4 = r4.layerDefinition || r4;
    const { operations: { supportsQuery: t3, supportsQueryAttachments: i }, query: { supportsFormatPBF: o4 }, data: { supportsAttachment: a4 }, queryRelated: s6 } = a3(r4, this.url);
    return { exportMap: { supportsModification: !!r4.canModifyLayer }, operations: { supportsQuery: t3, supportsQueryAttachments: i }, data: { supportsAttachment: a4 }, query: { supportsFormatPBF: o4 }, queryRelated: s6 };
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  set definitionExpression(e3) {
    this._setAndNotifyLayer("definitionExpression", e3);
  }
  get effectiveScaleRange() {
    const { minScale: e3, maxScale: r4 } = this;
    return { minScale: e3, maxScale: r4 };
  }
  readMaxScaleRange(e3, r4) {
    return { minScale: (r4 = r4.layerDefinition || r4).minScale ?? 0, maxScale: r4.maxScale ?? 0 };
  }
  get fieldsIndex() {
    return new Z(this.fields || []);
  }
  set floorInfo(e3) {
    this._setAndNotifyLayer("floorInfo", e3);
  }
  readGlobalIdFieldFromService(e3, r4) {
    if ((r4 = r4.layerDefinition || r4).globalIdField)
      return r4.globalIdField;
    if (r4.fields) {
      for (const t3 of r4.fields)
        if ("esriFieldTypeGlobalID" === t3.type)
          return t3.name;
    }
  }
  get id() {
    const e3 = this._get("id");
    return e3 ?? K2++;
  }
  set id(e3) {
    var _a, _b, _c;
    this._get("id") !== e3 && (false !== ((_c = (_b = (_a = this.layer) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.exportMap) == null ? void 0 : _c.supportsDynamicLayers) ? this._set("id", e3) : this._logLockedError("id", "capability not available 'layer.capabilities.exportMap.supportsDynamicLayers'"));
  }
  set labelingInfo(e3) {
    this._setAndNotifyLayer("labelingInfo", e3);
  }
  writeLabelingInfo(e3, r4, t3, i) {
    e3 && e3.length && (r4.layerDefinition = { drawingInfo: { labelingInfo: e3.map((e4) => e4.write({}, i)) } });
  }
  set labelsVisible(e3) {
    this._setAndNotifyLayer("labelsVisible", e3);
  }
  set layer(e3) {
    this._set("layer", e3), this.sublayers && this.sublayers.forEach((r4) => r4.layer = e3);
  }
  set listMode(e3) {
    this._set("listMode", e3);
  }
  set minScale(e3) {
    this._setAndNotifyLayer("minScale", e3);
  }
  readMinScale(e3, r4) {
    var _a;
    return r4.minScale || ((_a = r4.layerDefinition) == null ? void 0 : _a.minScale) || 0;
  }
  set maxScale(e3) {
    this._setAndNotifyLayer("maxScale", e3);
  }
  readMaxScale(e3, r4) {
    var _a;
    return r4.maxScale || ((_a = r4.layerDefinition) == null ? void 0 : _a.maxScale) || 0;
  }
  readObjectIdFieldFromService(e3, r4) {
    if ((r4 = r4.layerDefinition || r4).objectIdField)
      return r4.objectIdField;
    if (r4.fields) {
      for (const t3 of r4.fields)
        if ("esriFieldTypeOID" === t3.type)
          return t3.name;
    }
  }
  set opacity(e3) {
    this._setAndNotifyLayer("opacity", e3);
  }
  readOpacity(e3, r4) {
    var _a;
    const t3 = r4.layerDefinition;
    return 1 - 0.01 * ((null != (t3 == null ? void 0 : t3.transparency) ? t3.transparency : (_a = t3 == null ? void 0 : t3.drawingInfo) == null ? void 0 : _a.transparency) ?? 0);
  }
  writeOpacity(e3, r4, t3, i) {
    r4.layerDefinition = { drawingInfo: { transparency: 100 - 100 * e3 } };
  }
  writeParent(e3, r4) {
    this.parent && this.parent !== this.layer ? r4.parentLayerId = s3(this.parent.id) : r4.parentLayerId = -1;
  }
  get queryTask() {
    var _a;
    if (!this.layer)
      return null;
    const { spatialReference: e3 } = this.layer, r4 = "gdbVersion" in this.layer ? this.layer.gdbVersion : void 0, { capabilities: t3, fieldsIndex: i } = this, o4 = has("featurelayer-pbf") && (t3 == null ? void 0 : t3.query.supportsFormatPBF), a4 = ((_a = t3 == null ? void 0 : t3.operations) == null ? void 0 : _a.supportsQueryAttachments) ?? false;
    return new x2({ url: this.url, pbfSupported: o4, fieldsIndex: i, gdbVersion: r4, sourceSpatialReference: e3, queryAttachmentsSupported: a4 });
  }
  set renderer(e3) {
    if (e3) {
      for (const r4 of e3.getSymbols())
        if (x(r4)) {
          n.getLogger(this).warn("Sublayer renderer should use 2D symbols");
          break;
        }
    }
    this._setAndNotifyLayer("renderer", e3);
  }
  get source() {
    return this._get("source") || new c2({ mapLayerId: this.id });
  }
  set source(e3) {
    this._setAndNotifyLayer("source", e3);
  }
  set sublayers(e3) {
    this._handleSublayersChange(e3, this._get("sublayers")), this._set("sublayers", e3);
  }
  castSublayers(e3) {
    return d(V.ofType(B), e3);
  }
  writeSublayers(e3, r4, t3) {
    var _a;
    ((_a = this.sublayers) == null ? void 0 : _a.length) && (r4[t3] = this.sublayers.map((e4) => e4.id).toArray().reverse());
  }
  readTitle(e3, r4) {
    var _a;
    return ((_a = r4.layerDefinition) == null ? void 0 : _a.name) ?? r4.name;
  }
  readTypeIdField(e3, r4) {
    let t3 = (r4 = r4.layerDefinition || r4).typeIdField;
    if (t3 && r4.fields) {
      t3 = t3.toLowerCase();
      const e4 = r4.fields.find((e5) => e5.name.toLowerCase() === t3);
      e4 && (t3 = e4.name);
    }
    return t3;
  }
  get url() {
    var _a;
    const e3 = ((_a = this.layer) == null ? void 0 : _a.parsedUrl) ?? this._lastParsedUrl, r4 = this.source;
    if (!e3)
      return null;
    if (this._lastParsedUrl = e3, "map-layer" === (r4 == null ? void 0 : r4.type))
      return `${e3.path}/${r4.mapLayerId}`;
    const t3 = { layer: JSON.stringify({ source: this.source }) };
    return `${e3.path}/dynamicLayer?${v2(t3)}`;
  }
  set url(e3) {
    this._overrideIfSome("url", e3);
  }
  set visible(e3) {
    this._setAndNotifyLayer("visible", e3);
  }
  writeVisible(e3, r4, t3, i) {
    r4[t3] = this.getAtOrigin("defaultVisibility", "service") || e3;
  }
  clone() {
    const { store: e3 } = t(this), r4 = new B();
    return t(r4).store = e3.clone(W), this.commitProperty("url"), r4._lastParsedUrl = this._lastParsedUrl, r4;
  }
  createPopupTemplate(e3) {
    return p2(this, e3);
  }
  createQuery() {
    return new b({ returnGeometry: true, where: this.definitionExpression || "1=1" });
  }
  async createFeatureLayer() {
    var _a;
    if (this.hasOwnProperty("sublayers"))
      return null;
    const e3 = (await import("./FeatureLayer-I6BSIWIF.js")).default, { layer: r4, url: t3 } = this;
    let i;
    if (t3 && this.originIdOf("url") > e2.SERVICE)
      i = new e3({ url: t3 });
    else {
      if (!(r4 == null ? void 0 : r4.parsedUrl))
        throw new s("createFeatureLayer:missing-information", "Cannot create a FeatureLayer without a url or a parent layer");
      {
        const t4 = r4.parsedUrl;
        i = new e3({ url: t4.path }), t4 && this.source && ("map-layer" === this.source.type ? i.layerId = this.source.mapLayerId : i.dynamicDataSource = this.source);
      }
    }
    return null != (r4 == null ? void 0 : r4.refreshInterval) && (i.refreshInterval = r4.refreshInterval), this.definitionExpression && (i.definitionExpression = this.definitionExpression), this.floorInfo && (i.floorInfo = a(this.floorInfo)), this.originIdOf("labelingInfo") > e2.SERVICE && (i.labelingInfo = a(this.labelingInfo)), this.originIdOf("labelsVisible") > e2.DEFAULTS && (i.labelsVisible = this.labelsVisible), this.originIdOf("legendEnabled") > e2.DEFAULTS && (i.legendEnabled = this.legendEnabled), this.originIdOf("visible") > e2.DEFAULTS && (i.visible = this.visible), this.originIdOf("minScale") > e2.DEFAULTS && (i.minScale = this.minScale), this.originIdOf("maxScale") > e2.DEFAULTS && (i.maxScale = this.maxScale), this.originIdOf("opacity") > e2.DEFAULTS && (i.opacity = this.opacity), this.originIdOf("popupTemplate") > e2.DEFAULTS && (i.popupTemplate = a(this.popupTemplate)), this.originIdOf("renderer") > e2.SERVICE && (i.renderer = a(this.renderer)), "data-layer" === ((_a = this.source) == null ? void 0 : _a.type) && (i.dynamicDataSource = this.source.clone()), this.originIdOf("title") > e2.DEFAULTS && (i.title = this.title), "map-image" === (r4 == null ? void 0 : r4.type) && r4.originIdOf("customParameters") > e2.DEFAULTS && (i.customParameters = r4.customParameters), "tile" === (r4 == null ? void 0 : r4.type) && r4.originIdOf("customParameters") > e2.DEFAULTS && (i.customParameters = r4.customParameters), i;
  }
  getField(e3) {
    return this.fieldsIndex.get(e3);
  }
  getFeatureType(e3) {
    const { typeIdField: r4, types: t3 } = this;
    if (!r4 || !e3)
      return null;
    const i = e3.attributes ? e3.attributes[r4] : void 0;
    if (null == i)
      return null;
    let o4 = null;
    return t3 == null ? void 0 : t3.some((e4) => {
      const { id: r5 } = e4;
      return null != r5 && (r5.toString() === i.toString() && (o4 = e4), !!o4);
    }), o4;
  }
  getFieldDomain(e3, r4) {
    const t3 = r4 == null ? void 0 : r4.feature, i = this.getFeatureType(t3);
    if (i) {
      const r5 = i.domains && i.domains[e3];
      if (r5 && "inherited" !== r5.type)
        return r5;
    }
    return this._getLayerDomain(e3);
  }
  async queryAttachments(e3, r4) {
    var _a, _b;
    await this.load(), e3 = c4.from(e3);
    const t3 = this.capabilities;
    if (!((_a = t3 == null ? void 0 : t3.data) == null ? void 0 : _a.supportsAttachment))
      throw new s("queryAttachments:not-supported", "this layer doesn't support attachments");
    const { attachmentTypes: i, objectIds: o4, globalIds: a4, num: s6, size: n5, start: p4, where: y4 } = e3;
    if (!((_b = t3 == null ? void 0 : t3.operations) == null ? void 0 : _b.supportsQueryAttachments)) {
      if ((i == null ? void 0 : i.length) > 0 || (a4 == null ? void 0 : a4.length) > 0 || (n5 == null ? void 0 : n5.length) > 0 || s6 || p4 || y4)
        throw new s("queryAttachments:option-not-supported", "when 'capabilities.operations.supportsQueryAttachments' is false, only objectIds is supported", e3);
    }
    if (!((o4 == null ? void 0 : o4.length) || (a4 == null ? void 0 : a4.length) || y4))
      throw new s("queryAttachments:invalid-query", "'objectIds', 'globalIds', or 'where' are required to perform attachment query", e3);
    return this.queryTask.executeAttachmentQuery(e3, r4);
  }
  async queryFeatures(e3 = this.createQuery(), r4) {
    var _a, _b;
    if (await this.load(), !this.capabilities.operations.supportsQuery)
      throw new s("queryFeatures:not-supported", "this layer doesn't support queries.");
    if (!this.url)
      throw new s("queryFeatures:not-supported", "this layer has no url.");
    const t3 = await this.queryTask.execute(e3, { ...r4, query: { ...(_a = this.layer) == null ? void 0 : _a.customParameters, token: (_b = this.layer) == null ? void 0 : _b.apiKey } });
    if (t3 == null ? void 0 : t3.features)
      for (const i of t3.features)
        i.sourceLayer = this;
    return t3;
  }
  toExportImageJSON(e3) {
    var _a, _b;
    const r4 = { id: this.id, source: ((_a = this.source) == null ? void 0 : _a.toJSON()) || { mapLayerId: this.id, type: "mapLayer" } }, t3 = n3(e3, this.definitionExpression);
    null != t3 && (r4.definitionExpression = t3);
    const i = ["renderer", "labelingInfo", "opacity", "labelsVisible"].reduce((e4, r5) => (e4[r5] = this.originIdOf(r5), e4), {}), o4 = Object.keys(i).some((e4) => i[e4] > e2.SERVICE);
    if (o4) {
      const e4 = r4.drawingInfo = {};
      if (i.renderer > e2.SERVICE && (e4.renderer = this.renderer ? this.renderer.toJSON() : null), i.labelsVisible > e2.SERVICE && (e4.showLabels = this.labelsVisible), this.labelsVisible && i.labelingInfo > e2.SERVICE)
        if (this.labelingInfo) {
          !this.loaded && ((_b = this.labelingInfo) == null ? void 0 : _b.some((e5) => !e5.labelPlacement)) && n.getLogger(this).warnOnce(`A Sublayer (title: ${this.title}, id: ${this.id}) has an undefined 'labelPlacement' and so labels cannot be displayed. Either define a valid 'labelPlacement' or call Sublayer.load() to use a default value based on geometry type.`, { sublayer: this });
          let r5 = this.labelingInfo;
          null != this.geometryType && (r5 = c3(this.labelingInfo, o2.toJSON(this.geometryType))), e4.showLabels = true, e4.labelingInfo = r5.filter((e5) => e5.labelPlacement).map((e5) => e5.toJSON({ origin: "service", layer: this.layer }));
        } else
          e4.showLabels = false;
      i.opacity > e2.SERVICE && (e4.transparency = 100 - 100 * this.opacity), this._assignDefaultSymbolColors(e4.renderer);
    }
    return r4;
  }
  _assignDefaultSymbolColors(e3) {
    this._forEachSimpleMarkerSymbols(e3, (e4) => {
      var _a;
      e4.color || "esriSMSX" !== e4.style && "esriSMSCross" !== e4.style || (((_a = e4.outline) == null ? void 0 : _a.color) ? e4.color = e4.outline.color : e4.color = [0, 0, 0, 0]);
    });
  }
  _forEachSimpleMarkerSymbols(e3, r4) {
    if (e3) {
      const t3 = ("uniqueValueInfos" in e3 ? e3.uniqueValueInfos : "classBreakInfos" in e3 ? e3.classBreakInfos : null) ?? [];
      for (const e4 of t3)
        J(e4.symbol) && r4(e4.symbol);
      "symbol" in e3 && J(e3.symbol) && r4(e3.symbol), "defaultSymbol" in e3 && J(e3.defaultSymbol) && r4(e3.defaultSymbol);
    }
  }
  _setAndNotifyLayer(e3, r4) {
    var _a, _b, _c, _d;
    const t3 = this.layer, i = this._get(e3);
    let o4, a4;
    switch (e3) {
      case "definitionExpression":
      case "floorInfo":
        o4 = "supportsSublayerDefinitionExpression";
        break;
      case "minScale":
      case "maxScale":
      case "visible":
        o4 = "supportsSublayerVisibility";
        break;
      case "labelingInfo":
      case "labelsVisible":
      case "opacity":
      case "renderer":
      case "source":
        o4 = "supportsDynamicLayers", a4 = "supportsModification";
    }
    const s6 = t(this).getDefaultOrigin();
    if ("service" !== s6) {
      if (o4 && false === ((_c = (_b = (_a = this.layer) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.exportMap) == null ? void 0 : _c[o4]))
        return void this._logLockedError(e3, `capability not available 'layer.capabilities.exportMap.${o4}'`);
      if (a4 && false === ((_d = this.capabilities) == null ? void 0 : _d.exportMap[a4]))
        return void this._logLockedError(e3, `capability not available 'capabilities.exportMap.${a4}'`);
    }
    "source" !== e3 || "not-loaded" === this.loadStatus ? (this._set(e3, r4), "service" !== s6 && i !== r4 && t3 && t3.emit && t3.emit("sublayer-update", { propertyName: e3, target: this })) : this._logLockedError(e3, "'source' can't be changed after calling sublayer.load()");
  }
  _handleSublayersChange(e3, r4) {
    r4 && (r4.forEach((e4) => {
      e4.parent = null, e4.layer = null;
    }), this.removeAllHandles()), e3 && (e3.forEach((e4) => {
      e4.parent = this, e4.layer = this.layer;
    }), this.addHandles([e3.on("after-add", ({ item: e4 }) => {
      e4.parent = this, e4.layer = this.layer;
    }), e3.on("after-remove", ({ item: e4 }) => {
      e4.parent = null, e4.layer = null;
    }), e3.on("before-changes", (e4) => {
      var _a, _b, _c;
      const r5 = (_c = (_b = (_a = this.layer) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.exportMap) == null ? void 0 : _c.supportsSublayersChanges;
      null == r5 || r5 || (n.getLogger(this).error(new s("sublayer:sublayers-non-modifiable", "Sublayer can't be added, moved, or removed from the layer's sublayers", { sublayer: this, layer: this.layer })), e4.preventDefault());
    })]));
  }
  _logLockedError(e3, r4) {
    const { layer: t3, declaredClass: i } = this;
    n.getLogger(i).error(new s("sublayer:locked", `Property '${String(e3)}' can't be changed on Sublayer from the layer '${t3 == null ? void 0 : t3.id}'`, { reason: r4, sublayer: this, layer: t3 }));
  }
  _getLayerDomain(e3) {
    const r4 = this.fieldsIndex.get(e3);
    return r4 ? r4.domain : null;
  }
};
X.test = { isMapImageLayerOverridePolicy: (e3) => e3 === H || e3 === $, isTileImageLayerOverridePolicy: (e3) => e3 === G }, e([y({ readOnly: true })], X.prototype, "capabilities", void 0), e([o("service", "capabilities", ["layerDefinition.canModifyLayer", "layerDefinition.capabilities"])], X.prototype, "readCapabilities", null), e([y()], X.prototype, "defaultPopupTemplate", null), e([y({ type: String, value: null, json: { name: "layerDefinition.definitionExpression", write: { allowNull: true, overridePolicy: $ } } })], X.prototype, "definitionExpression", null), e([y({ readOnly: true })], X.prototype, "effectiveScaleRange", null), e([o("service", "maxScaleRange", ["minScale", "maxScale"])], X.prototype, "readMaxScaleRange", null), e([y({ type: [y2], json: { origins: { service: { read: { source: "layerDefinition.fields" } } } } })], X.prototype, "fields", void 0), e([y({ readOnly: true })], X.prototype, "fieldsIndex", null), e([y({ type: p3, value: null, json: { name: "layerDefinition.floorInfo", read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo", overridePolicy: $ }, origins: { "web-scene": { read: false, write: false } } } })], X.prototype, "floorInfo", null), e([y({ type: w, json: { read: { source: "layerDefinition.extent" } } })], X.prototype, "fullExtent", void 0), e([y({ type: o2.apiValues, json: { origins: { service: { name: "layerDefinition.geometryType", read: { reader: o2.read } } } } })], X.prototype, "geometryType", void 0), e([y({ type: String })], X.prototype, "globalIdField", void 0), e([o("service", "globalIdField", ["layerDefinition.globalIdField", "layerDefinition.fields"])], X.prototype, "readGlobalIdFieldFromService", null), e([y({ type: T, json: { write: { ignoreOrigin: true } } })], X.prototype, "id", null), e([y({ value: null, type: [C2], json: { read: { source: "layerDefinition.drawingInfo.labelingInfo" }, write: { target: "layerDefinition.drawingInfo.labelingInfo", overridePolicy: H } } })], X.prototype, "labelingInfo", null), e([r2("labelingInfo")], X.prototype, "writeLabelingInfo", null), e([y({ type: Boolean, value: true, json: { read: { source: "layerDefinition.drawingInfo.showLabels" }, write: { target: "layerDefinition.drawingInfo.showLabels", overridePolicy: H } } })], X.prototype, "labelsVisible", null), e([y({ value: null })], X.prototype, "layer", null), e([y({ type: String, json: { write: { overridePolicy: G } } })], X.prototype, "layerItemId", void 0), e([y({ type: Boolean, value: true, json: { origins: { service: { read: { enabled: false } } }, read: { source: "showLegend" }, write: { target: "showLegend", overridePolicy: z } } })], X.prototype, "legendEnabled", void 0), e([y({ type: ["show", "hide", "hide-children"], value: "show", json: { read: false, write: false, origins: { "web-scene": { read: true, write: true } } } })], X.prototype, "listMode", null), e([y({ type: Number, value: 0, json: { write: { overridePolicy: H } } })], X.prototype, "minScale", null), e([o("minScale", ["minScale", "layerDefinition.minScale"])], X.prototype, "readMinScale", null), e([y({ type: Number, value: 0, json: { write: { overridePolicy: H } } })], X.prototype, "maxScale", null), e([o("maxScale", ["maxScale", "layerDefinition.maxScale"])], X.prototype, "readMaxScale", null), e([y({ type: String })], X.prototype, "objectIdField", void 0), e([o("service", "objectIdField", ["layerDefinition.objectIdField", "layerDefinition.fields"])], X.prototype, "readObjectIdFieldFromService", null), e([y({ type: Number, value: 1, json: { write: { target: "layerDefinition.drawingInfo.transparency", overridePolicy: H } } })], X.prototype, "opacity", null), e([o("opacity", ["layerDefinition.drawingInfo.transparency", "layerDefinition.transparency"])], X.prototype, "readOpacity", null), e([r2("opacity")], X.prototype, "writeOpacity", null), e([y({ json: { type: T, write: { target: "parentLayerId", writerEnsuresNonNull: true, overridePolicy: H } } })], X.prototype, "parent", void 0), e([r2("parent")], X.prototype, "writeParent", null), e([y({ type: Boolean, value: true, json: { read: { source: "disablePopup", reader: (e3, r4) => !r4.disablePopup }, write: { target: "disablePopup", overridePolicy: z, writer(e3, r4, t3) {
  r4[t3] = !e3;
} } } })], X.prototype, "popupEnabled", void 0), e([y({ type: P, json: { read: { source: "popupInfo" }, write: { target: "popupInfo", overridePolicy: z } } })], X.prototype, "popupTemplate", void 0), e([y({ readOnly: true })], X.prototype, "queryTask", null), e([y({ types: m2, value: null, json: { name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: H }, origins: { "web-scene": { types: u, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: H } } } } })], X.prototype, "renderer", null), e([y({ types: { key: "type", base: null, typeMap: { "data-layer": K, "map-layer": c2 } }, cast(e3) {
  if (e3) {
    if ("mapLayerId" in e3)
      return v(c2, e3);
    if ("dataSource" in e3)
      return v(K, e3);
  }
  return e3;
}, json: { name: "layerDefinition.source", write: { overridePolicy: H } } })], X.prototype, "source", null), e([y()], X.prototype, "sourceJSON", void 0), e([y({ value: null, json: { type: [T], write: { target: "subLayerIds", allowNull: true, overridePolicy: H } } })], X.prototype, "sublayers", null), e([s4("sublayers")], X.prototype, "castSublayers", null), e([r2("sublayers")], X.prototype, "writeSublayers", null), e([y({ type: String, json: { name: "name", write: { overridePolicy: z } } })], X.prototype, "title", void 0), e([o("service", "title", ["name", "layerDefinition.name"])], X.prototype, "readTitle", null), e([y({ type: String })], X.prototype, "typeIdField", void 0), e([y({ json: { read: false }, readOnly: true, value: "sublayer" })], X.prototype, "type", void 0), e([o("typeIdField", ["layerDefinition.typeIdField"])], X.prototype, "readTypeIdField", null), e([y({ type: [n4], json: { origins: { service: { read: { source: "layerDefinition.types" } } } } })], X.prototype, "types", void 0), e([y({ type: String, json: { name: "layerUrl", write: { overridePolicy: G } } })], X.prototype, "url", null), e([y({ type: Boolean, value: true, json: { read: { source: "defaultVisibility" }, write: { target: "defaultVisibility", overridePolicy: H } } })], X.prototype, "visible", null), e([r2("visible")], X.prototype, "writeVisible", null), X = B = e([a2("esri.layers.support.Sublayer")], X);
var Y = X;

// node_modules/@arcgis/core/layers/mixins/SublayersOwner.js
function f4(e3, r4) {
  const s6 = [], t3 = {};
  return e3 ? (e3.forEach((e4) => {
    const o4 = new Y();
    if (o4.read(e4, r4), t3[o4.id] = o4, null != e4.parentLayerId && -1 !== e4.parentLayerId) {
      const r5 = t3[e4.parentLayerId];
      r5.sublayers || (r5.sublayers = []), r5.sublayers.unshift(o4);
    } else
      s6.unshift(o4);
  }), s6) : s6;
}
var S2 = V.ofType(Y);
function h(e3, r4) {
  e3 && e3.forEach((e4) => {
    r4(e4), e4.sublayers && e4.sublayers.length && h(e4.sublayers, r4);
  });
}
var m3 = (m4) => {
  let E = class extends m4 {
    constructor(...e3) {
      super(...e3), this.allSublayers = new l({ getCollections: () => [this.sublayers], getChildrenFunction: (e4) => e4.sublayers }), this.sublayersSourceJSON = { [e2.SERVICE]: {}, [e2.PORTAL_ITEM]: {}, [e2.WEB_SCENE]: {}, [e2.WEB_MAP]: {} }, this.addHandles(d2(() => this.sublayers, (e4, r4) => this._handleSublayersChange(e4, r4), C));
    }
    destroy() {
      this.allSublayers.destroy();
    }
    readSublayers(e3, r4) {
      if (!r4 || !e3)
        return;
      const { sublayersSourceJSON: s6 } = this, t3 = n2(r4.origin);
      if (t3 < e2.SERVICE)
        return;
      if (s6[t3] = { context: r4, visibleLayers: e3.visibleLayers || s6[t3].visibleLayers, layers: e3.layers || s6[t3].layers }, t3 > e2.SERVICE)
        return;
      this._set("serviceSublayers", this.createSublayersForOrigin("service").sublayers);
      const { sublayers: o4, origin: a4 } = this.createSublayersForOrigin("web-document"), l2 = t(this);
      l2.setDefaultOrigin(a4), this._set("sublayers", new S2(o4)), l2.setDefaultOrigin("user");
    }
    findSublayerById(e3) {
      return this.allSublayers.find((r4) => r4.id === e3);
    }
    createServiceSublayers() {
      return this.createSublayersForOrigin("service").sublayers;
    }
    createSublayersForOrigin(e3) {
      const r4 = n2("web-document" === e3 ? "web-map" : e3);
      let s6 = e2.SERVICE, t3 = this.sublayersSourceJSON[e2.SERVICE].layers, o4 = this.sublayersSourceJSON[e2.SERVICE].context, a4 = null;
      const l2 = [e2.PORTAL_ITEM, e2.WEB_SCENE, e2.WEB_MAP].filter((e4) => e4 <= r4);
      for (const u2 of l2) {
        const e4 = this.sublayersSourceJSON[u2];
        o3(e4.layers) && (s6 = u2, t3 = e4.layers, o4 = e4.context, e4.visibleLayers && (a4 = { visibleLayers: e4.visibleLayers, context: e4.context }));
      }
      const i = [e2.PORTAL_ITEM, e2.WEB_SCENE, e2.WEB_MAP].filter((e4) => e4 > s6 && e4 <= r4);
      let n5 = null;
      for (const u2 of i) {
        const { layers: e4, visibleLayers: r5, context: s7 } = this.sublayersSourceJSON[u2];
        e4 && (n5 = { layers: e4, context: s7 }), r5 && (a4 = { visibleLayers: r5, context: s7 });
      }
      const y4 = f4(t3, o4), d3 = /* @__PURE__ */ new Map(), m5 = /* @__PURE__ */ new Set();
      if (n5)
        for (const u2 of n5.layers)
          d3.set(u2.id, u2);
      if (a4 == null ? void 0 : a4.visibleLayers)
        for (const u2 of a4.visibleLayers)
          m5.add(u2);
      return h(y4, (e4) => {
        n5 && e4.read(d3.get(e4.id), n5.context), a4 && e4.read({ defaultVisibility: m5.has(e4.id) }, a4.context);
      }), { origin: t2(s6), sublayers: new S2({ items: y4 }) };
    }
    read(e3, r4) {
      super.read(e3, r4), this.readSublayers(e3, r4);
    }
    _handleSublayersChange(e3, r4) {
      r4 && (r4.forEach((e4) => {
        e4.parent = null, e4.layer = null;
      }), this.removeHandles("sublayers-owner")), e3 && (e3.forEach((e4) => {
        e4.parent = this, e4.layer = this;
      }), this.addHandles([e3.on("after-add", ({ item: e4 }) => {
        e4.parent = this, e4.layer = this;
      }), e3.on("after-remove", ({ item: e4 }) => {
        e4.parent = null, e4.layer = null;
      })], "sublayers-owner"), "tile" === this.type && this.addHandles(e3.on("before-changes", (e4) => {
        n.getLogger("esri.layers.TileLayer").error(new s("tilelayer:sublayers-non-modifiable", "ISublayer can't be added, moved, or removed from the layer's sublayers", { layer: this })), e4.preventDefault();
      }), "sublayers-owner"));
    }
  };
  return e([y({ readOnly: true })], E.prototype, "allSublayers", void 0), e([y({ readOnly: true, type: V.ofType(Y) })], E.prototype, "serviceSublayers", void 0), e([y({ value: null, type: S2, json: { read: false, write: { allowNull: true, ignoreOrigin: true } } })], E.prototype, "sublayers", void 0), e([y({ readOnly: true })], E.prototype, "sublayersSourceJSON", void 0), E = e([a2("esri.layers.mixins.SublayersOwner")], E), E;
};

export {
  f3 as f,
  Y,
  m3 as m
};
//# sourceMappingURL=chunk-ZUGLZCI5.js.map
