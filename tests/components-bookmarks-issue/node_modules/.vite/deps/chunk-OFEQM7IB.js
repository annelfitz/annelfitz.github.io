import {
  r as r2
} from "./chunk-NMKWX7AG.js";
import {
  e as e3
} from "./chunk-FIHLU3LF.js";
import {
  h,
  p as p2,
  t as t2,
  u
} from "./chunk-MDXZIVBP.js";
import {
  x
} from "./chunk-ZQTY6DQZ.js";
import {
  a as a2
} from "./chunk-A47N2JLN.js";
import {
  o as o6
} from "./chunk-ZEMG7GKC.js";
import {
  a
} from "./chunk-XIWETS2Q.js";
import {
  l
} from "./chunk-LOPMLCHC.js";
import {
  d,
  i,
  o as o5
} from "./chunk-DRCNNCTI.js";
import {
  e as e5,
  e2 as e6,
  t
} from "./chunk-JKOHBDRD.js";
import {
  o as o7
} from "./chunk-MDSRD3WV.js";
import {
  o as o9
} from "./chunk-HBRJJENW.js";
import {
  e as e7
} from "./chunk-VHY5K2VE.js";
import {
  P
} from "./chunk-FV43HSGW.js";
import {
  d as d2,
  f,
  p
} from "./chunk-ZR7OV2EH.js";
import {
  o as o4
} from "./chunk-LJULTBAY.js";
import {
  e as e4
} from "./chunk-QR7J3YDY.js";
import {
  o as o8
} from "./chunk-UYMREM3D.js";
import {
  o as o2
} from "./chunk-CDBOQCLE.js";
import {
  e as e2
} from "./chunk-VYSGSKHB.js";
import {
  o as o3
} from "./chunk-IDPLBNJX.js";
import {
  o
} from "./chunk-P4MNTMCZ.js";
import {
  e
} from "./chunk-GLF3KRAL.js";
import {
  r
} from "./chunk-ZLQTPFTL.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl.js
var p3 = 8;
function f2(e8, c) {
  const f3 = e.FEATUREVALUE;
  e8.attributes.add(f3, "vec4");
  const n2 = e8.vertex;
  n2.code.add(o`
  bool isCapVertex() {
    return ${f3}.w == 1.0;
  }
  `), n2.uniforms.add(new e4("size", (e9) => e9.size)), c.vvSize ? (n2.uniforms.add(new e2("vvSizeMinSize", (e9) => e9.vvSize.minSize), new e2("vvSizeMaxSize", (e9) => e9.vvSize.maxSize), new e2("vvSizeOffset", (e9) => e9.vvSize.offset), new e2("vvSizeFactor", (e9) => e9.vvSize.factor)), n2.code.add(o`
    vec2 getSize() {
      return size * clamp(vvSizeOffset + ${f3}.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xz;
    }
    `)) : n2.code.add(o`vec2 getSize(){
return size;
}`), c.vvOpacity ? (n2.constants.add("vvOpacityNumber", "int", p3), n2.uniforms.add(new o7("vvOpacityValues", (e9) => e9.vvOpacity.values, p3), new o7("vvOpacityOpacities", (e9) => e9.vvOpacity.opacityValues, p3)), n2.code.add(o`
    vec4 applyOpacity(vec4 color) {
      float value = ${f3}.z;
      if (value <= vvOpacityValues[0]) {
        return vec4( color.xyz, vvOpacityOpacities[0]);
      }

      for (int i = 1; i < vvOpacityNumber; ++i) {
        if (vvOpacityValues[i] >= value) {
          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
          return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));
        }
      }

      return vec4( color.xyz, vvOpacityOpacities[vvOpacityNumber - 1]);
    }
    `)) : n2.code.add(o`vec4 applyOpacity(vec4 color){
return color;
}`), c.vvColor ? (n2.constants.add("vvColorNumber", "int", e6), n2.uniforms.add(new o7("vvColorValues", (e9) => e9.vvColor.values, e6), new e5("vvColorColors", (e9) => e9.vvColor.colors, e6)), n2.code.add(o`
    vec4 getColor() {
      float value = ${f3}.y;
      if (value <= vvColorValues[0]) {
        return applyOpacity(vvColorColors[0]);
      }

      for (int i = 1; i < vvColorNumber; ++i) {
        if (vvColorValues[i] >= value) {
          float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
          return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));
        }
      }

      return applyOpacity(vvColorColors[vvColorNumber - 1]);
    }
    `)) : n2.code.add(o`vec4 getColor(){
return applyOpacity(vec4(1, 1, 1, 1));
}`), e8.include(o5), e8.attributes.add(e.PROFILERIGHT, "vec4"), e8.attributes.add(e.PROFILEUP, "vec4"), e8.attributes.add(e.PROFILEVERTEXANDNORMAL, "vec4"), n2.code.add(o`vec3 calculateVPos() {
vec2 size = getSize();
vec3 origin = position;
vec3 right = profileRight.xyz;
vec3 up = profileUp.xyz;
vec3 forward = cross(up, right);
vec2 profileVertex = profileVertexAndNormal.xy * size;
vec2 profileNormal = profileVertexAndNormal.zw;
float positionOffsetAlongProfilePlaneNormal = 0.0;
float normalOffsetAlongProfilePlaneNormal = 0.0;`), n2.code.add(o`if(!isCapVertex()) {
vec2 rotationRight = vec2(profileRight.w, profileUp.w);
float maxDistance = length(rotationRight);`), n2.code.add(o`rotationRight = maxDistance > 0.0 ? normalize(rotationRight) : vec2(0, 0);
float rx = dot(profileVertex, rotationRight);
if (abs(rx) > maxDistance) {
vec2 rotationUp = vec2(-rotationRight.y, rotationRight.x);
float ry = dot(profileVertex, rotationUp);
profileVertex = rotationRight * maxDistance * sign(rx) + rotationUp * ry;
}
}else{
positionOffsetAlongProfilePlaneNormal = profileRight.w * size[0];
normalOffsetAlongProfilePlaneNormal = profileUp.w;
}
vec3 offset = right * profileVertex.x + up * profileVertex.y + forward * positionOffsetAlongProfilePlaneNormal;
return origin + offset;
}`), n2.code.add(o`vec3 localNormal() {
vec3 right = profileRight.xyz;
vec3 up = profileUp.xyz;
vec3 forward = cross(up, right);
vec2 profileNormal = profileVertexAndNormal.zw;
vec3 normal = right * profileNormal.x + up * profileNormal.y;
if(isCapVertex()) {
normal += forward * profileUp.w;
}
return normal;
}`);
}
var n = class extends t {
  constructor() {
    super(...arguments), this.size = r(1, 1);
  }
};

// node_modules/@arcgis/core/chunks/Path.glsl.js
function O(O2) {
  const D2 = new o8(), { vertex: A, fragment: F } = D2;
  switch (d2(A, O2), D2.varyings.add("vpos", "vec3"), D2.include(f2, O2), O2.output !== o2.Color && O2.output !== o2.Alpha || (D2.include(o6, O2), D2.include(x, O2), D2.include(d, O2), D2.varyings.add("vnormal", "vec3"), D2.varyings.add("vcolor", "vec4"), O2.multipassEnabled && D2.varyings.add("depth", "float"), A.code.add(o`
      void main() {
        vpos = calculateVPos();
        vnormal = normalize(localNormal());

        ${O2.multipassEnabled ? "depth = (view * vec4(vpos, 1.0)).z;" : ""}
        gl_Position = transformPosition(proj, view, vpos);

        ${O2.output === o2.Color ? "forwardLinearDepth();" : ""}

        vcolor = getColor();
      }
    `)), D2.include(o9, O2), O2.output) {
    case o2.Alpha:
      D2.include(P, O2), F.uniforms.add(new o3("opacity", (e8) => e8.opacity)), F.code.add(o`
      void main() {
        discardBySlice(vpos);
        ${O2.multipassEnabled ? "terrainDepthTest(depth);" : ""}
        float combinedOpacity = vcolor.a * opacity;
        fragColor = vec4(combinedOpacity);
      }
    `);
      break;
    case o2.Color:
      D2.include(P, O2), D2.include(p2, O2), D2.include(t2, O2), D2.include(x, O2), D2.include(e3, O2), f(F, O2), u(F), h(F), F.uniforms.add(A.uniforms.get("localOrigin"), new e2("ambient", (e8) => e8.ambient), new e2("diffuse", (e8) => e8.diffuse), new e2("specular", (e8) => e8.specular), new o3("opacity", (e8) => e8.opacity)), F.include(e7), a2(F), F.code.add(o`
        void main() {
          discardBySlice(vpos);
          ${O2.multipassEnabled ? "terrainDepthTest(depth);" : ""}

          shadingParams.viewDirection = normalize(vpos - cameraPosition);
          shadingParams.normalView = vnormal;
          vec3 normal = shadingNormal(shadingParams);
          float ssao = evaluateAmbientOcclusionInverse();

          float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
          vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
          ${O2.receiveShadows ? "float shadow = readShadowMap(vpos, linearDepth);" : O2.spherical ? "float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);" : "float shadow = 0.0;"}
          vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one
          float combinedOpacity = vcolor.a * opacity;
          albedo += 0.25 * specular; // don't completely ignore specular for now

          vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);
          fragColor = vec4(shadedColor, combinedOpacity);
          fragColor = highlightSlice(fragColor, vpos);
          ${O2.transparencyPassType === o4.Color ? "fragColor = premultiplyAlpha(fragColor);" : ""}
        }
      `);
      break;
    case o2.LinearDepth:
    case o2.Shadow:
    case o2.ShadowHighlight:
    case o2.ShadowExcludeHighlight:
      D2.include(o6, O2), i(D2), D2.varyings.add("depth", "float"), A.code.add(o`void main() {
vpos = calculateVPos();
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
}`), D2.include(P, O2), D2.include(l, O2), F.code.add(o`void main() {
discardBySlice(vpos);
outputDepth(depth);
}`);
      break;
    case o2.Normal:
      D2.include(o6, O2), D2.include(r2, O2), p(A), D2.varyings.add("vnormal", "vec3"), A.code.add(o`void main(void) {
vpos = calculateVPos();
vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);
}`), D2.include(P, O2), F.code.add(o`void main() {
discardBySlice(vpos);
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) normal = -normal;
fragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);
}`);
      break;
    case o2.Highlight:
      D2.include(o6, O2), D2.include(r2, O2), D2.varyings.add("vnormal", "vec3"), A.code.add(o`void main(void) {
vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);
}`), D2.include(P, O2), D2.include(a, O2), F.code.add(o`void main() {
discardBySlice(vpos);
outputHighlight();
}`);
  }
  return D2;
}
var D = Object.freeze(Object.defineProperty({ __proto__: null, build: O }, Symbol.toStringTag, { value: "Module" }));

export {
  n,
  O,
  D
};
//# sourceMappingURL=chunk-OFEQM7IB.js.map
