import {
  _ as _4,
  t as t8
} from "./chunk-RQW2N53A.js";
import {
  X
} from "./chunk-LHVWC4RW.js";
import {
  f,
  o as o5
} from "./chunk-GN2OLKIL.js";
import {
  it,
  n as n8,
  s as s6
} from "./chunk-5WKN6K5Z.js";
import {
  i as i5
} from "./chunk-3YZBQBZ5.js";
import {
  r as r6
} from "./chunk-RFBA77K3.js";
import {
  G,
  e as e5,
  i as i4
} from "./chunk-46T3D2EU.js";
import {
  A as A3
} from "./chunk-7UDCRD5C.js";
import {
  E as E2,
  I as I2
} from "./chunk-QCUK7T7Y.js";
import {
  a as a3,
  e as e6,
  t as t7
} from "./chunk-2NDIVJST.js";
import {
  C as C3
} from "./chunk-PMFQ2A2V.js";
import {
  a as a4,
  d as d3
} from "./chunk-5INQRMFY.js";
import {
  d as d4,
  m as m2
} from "./chunk-XP3ABGGF.js";
import {
  E
} from "./chunk-TACIE3AK.js";
import {
  c as c3,
  s as s5
} from "./chunk-KYKKN5I4.js";
import {
  v as v2
} from "./chunk-J54I3TB7.js";
import {
  _ as _3,
  i as i3
} from "./chunk-OE52KVBM.js";
import {
  R as R2
} from "./chunk-L577YNYZ.js";
import {
  c as c2,
  d as d2
} from "./chunk-GL5TSVQL.js";
import {
  r as r3,
  r2 as r4,
  t as t4
} from "./chunk-ZPC74XHC.js";
import {
  A as A2
} from "./chunk-IVGJRGD2.js";
import {
  r as r5,
  t as t5
} from "./chunk-JBF6CULO.js";
import {
  h as h3
} from "./chunk-3DFMDDMO.js";
import {
  t as t6
} from "./chunk-4BCSYJOQ.js";
import {
  O
} from "./chunk-GMUCR2DJ.js";
import {
  n as n7
} from "./chunk-HBRJJENW.js";
import {
  S as S2,
  _ as _2,
  l as l4,
  s as s4
} from "./chunk-MEEG7XMI.js";
import {
  o as o4
} from "./chunk-LJULTBAY.js";
import {
  t as t3
} from "./chunk-FD4DXBZA.js";
import {
  h as h2
} from "./chunk-4YGBWYMD.js";
import {
  e2 as e4,
  m
} from "./chunk-JTUYA5FE.js";
import {
  t as t2
} from "./chunk-QIEXJLRX.js";
import {
  C as C2,
  I
} from "./chunk-QYDOVVH7.js";
import {
  F,
  L,
  R,
  _
} from "./chunk-WKVHVZW2.js";
import {
  l as l3,
  s as s3
} from "./chunk-RLZYC2LS.js";
import {
  a as a2,
  i as i2
} from "./chunk-TXLJQAAN.js";
import {
  o as o3
} from "./chunk-CDBOQCLE.js";
import {
  l as l2
} from "./chunk-WZJNHZ6H.js";
import {
  Z
} from "./chunk-XMYPMIYH.js";
import {
  i,
  s as s2
} from "./chunk-LGMX4E7L.js";
import {
  n as n6
} from "./chunk-ZLQTPFTL.js";
import {
  e as e3
} from "./chunk-N5GQOIDP.js";
import {
  Q,
  c,
  h,
  q,
  s
} from "./chunk-HWHMO3CO.js";
import {
  e as e2,
  u as u3,
  z as z2
} from "./chunk-C7NPPGFR.js";
import {
  u as u2
} from "./chunk-OCF7OAES.js";
import {
  o as o2
} from "./chunk-JZBR4X6W.js";
import {
  n as n5,
  r as r2
} from "./chunk-OIJCMME5.js";
import {
  A,
  d,
  v
} from "./chunk-Z4Y53NDM.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import {
  S,
  n3,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a,
  n as n4
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  l
} from "./chunk-C26KUZ46.js";
import {
  r,
  t,
  u
} from "./chunk-QHK5ZYFW.js";
import {
  n as n2
} from "./chunk-L65HKN25.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";
import {
  C,
  has,
  z
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/3d/terrain/Overlay.js
var n9 = class {
  constructor() {
    this._extent = u3(), this.resolution = 0, this.renderLocalOrigin = t8(0, 0, 0, "O"), this.pixelRatio = 1, this.mapUnitsPerPixel = 1, this.canvasGeometries = new r7();
  }
  get extent() {
    return this._extent;
  }
  setupGeometryViewsCyclical(e7) {
    this.setupGeometryViewsDirect();
    const s14 = 1e-3 * e7.range;
    if (this._extent[0] - s14 <= e7.min) {
      const s15 = this.canvasGeometries.extents[this.canvasGeometries.numViews++];
      z2(this._extent, e7.range, 0, s15);
    }
    if (this._extent[2] + s14 >= e7.max) {
      const s15 = this.canvasGeometries.extents[this.canvasGeometries.numViews++];
      z2(this._extent, -e7.range, 0, s15);
    }
  }
  setupGeometryViewsDirect() {
    this.canvasGeometries.numViews = 1, e2(this.canvasGeometries.extents[0], this._extent);
  }
  hasSomeSizedView() {
    for (let e7 = 0; e7 < this.canvasGeometries.numViews; e7++) {
      const t13 = this.canvasGeometries.extents[e7];
      if (t13[0] !== t13[2] && t13[1] !== t13[3])
        return true;
    }
    return false;
  }
};
var r7 = class {
  constructor() {
    this.extents = [u3(), u3(), u3()], this.numViews = 0;
  }
};

// node_modules/@arcgis/core/views/3d/terrain/OverlayFramebufferObject.js
var t9 = class {
  constructor(e7, t13, h5) {
    this._fbos = e7, this._format = t13, this._name = h5;
  }
  get valid() {
    var _a;
    return null != ((_a = this._handle) == null ? void 0 : _a.getTexture());
  }
  dispose() {
    this._handle = t(this._handle);
  }
  get texture() {
    var _a;
    return (_a = this._handle) == null ? void 0 : _a.getTexture();
  }
  bind(e7, t13, h5) {
    var _a, _b, _c;
    this._handle && this._handle.fbo.width === t13 && this._handle.fbo.height === h5 || ((_a = this._handle) == null ? void 0 : _a.release(), this._handle = this._fbos.acquire(t13, h5, this._name, this._format)), e7.unbindTexture((_b = this._handle) == null ? void 0 : _b.fbo.colorTexture), e7.bindFramebuffer((_c = this._handle) == null ? void 0 : _c.fbo);
  }
  generateMipMap() {
    var _a, _b, _c, _d, _e;
    ((_c = (_b = (_a = this._handle) == null ? void 0 : _a.getTexture()) == null ? void 0 : _b.descriptor) == null ? void 0 : _c.hasMipmap) && ((_e = (_d = this._handle) == null ? void 0 : _d.getTexture()) == null ? void 0 : _e.generateMipmap());
  }
};

// node_modules/@arcgis/core/views/3d/terrain/OverlayRenderTargets.js
var a5 = class {
  constructor(r11, t13, a8, s14, l6 = R2.RGBA_MIPMAP) {
    this.output = a8, this.content = s14, this.fbo = new t9(r11, l6, t13);
  }
  get valid() {
    return this.fbo.valid;
  }
};
var s7 = class {
  constructor(e7) {
    this.targets = [new a5(e7, "overlay color", o3.Color, o5.Color), new a5(e7, "overlay IM color", o3.Color, o5.ColorNoRasterImage), new a5(e7, "overlay highlight", o3.Highlight, o5.Highlight, R2.RGBA4), new a5(e7, "overlay water", o3.Normal, o5.WaterNormal), new a5(e7, "overlay occluded", o3.Color, o5.Occluded)], has("enable-feature:objectAndLayerId-rendering") && this.targets.push(new a5(e7, "overlay oid", o3.ObjectAndLayerIdColor, o5.ObjectAndLayerIdColor));
  }
  getTexture(r11) {
    var _a;
    return (_a = this.targets[r11]) == null ? void 0 : _a.fbo.texture;
  }
  dispose() {
    for (const r11 of this.targets)
      r11.fbo.dispose();
  }
  computeValidity() {
    return this.targets.reduce((r11, e7, o10) => e7.valid ? r11 |= 1 << o10 : r11, 0);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechniqueRepository.js
var r8 = class {
  constructor(t13) {
    this._context = t13, this._perConstructorInstances = new t3(), this._frameCounter = 0, this._keepAliveFrameCount = n10;
  }
  get viewingMode() {
    return this._context.viewingMode;
  }
  get constructionContext() {
    return this._context;
  }
  destroy() {
    this._perConstructorInstances.forEach((e7) => e7.forEach((e8) => e8.technique.destroy())), this._perConstructorInstances.clear();
  }
  acquire(e7, t13 = o6) {
    const r11 = t13.key;
    let n14 = this._perConstructorInstances.get(e7, r11);
    if (null == n14) {
      const o10 = new e7(this._context, t13, () => this.release(o10));
      n14 = new s8(o10), this._perConstructorInstances.set(e7, r11, n14);
    }
    return ++n14.refCount, n14.technique;
  }
  releaseAndAcquire(e7, t13, r11) {
    if (null != r11) {
      if (t13.key === r11.key)
        return r11;
      this.release(r11);
    }
    return this.acquire(e7, t13);
  }
  release(e7) {
    if (null == e7 || this._perConstructorInstances.empty)
      return;
    const t13 = this._perConstructorInstances.get(e7.constructor, e7.key);
    null != t13 && (--t13.refCount, 0 === t13.refCount && (t13.refZeroFrame = this._frameCounter));
  }
  frameUpdate() {
    this._frameCounter++, this._keepAliveFrameCount !== n10 && this._perConstructorInstances.forEach((e7, t13) => {
      e7.forEach((e8, r11) => {
        0 === e8.refCount && e8.refZeroFrame + this._keepAliveFrameCount < this._frameCounter && (e8.technique.destroy(), this._perConstructorInstances.delete(t13, r11));
      });
    });
  }
  async reloadAll() {
    const e7 = new Array();
    this._perConstructorInstances.forEach((t13, r11) => {
      const s14 = async (e8, t14) => {
        const r12 = t14.shader;
        r12 && (await r12.reload(), e8.forEach((e9) => e9.technique.reload(this._context)));
      };
      e7.push(s14(t13, r11));
    }), await Promise.all(e7);
  }
};
var s8 = class {
  constructor(e7) {
    this.technique = e7, this.refCount = 0, this.refZeroFrame = 0;
  }
};
var n10 = -1;
var o6 = new t5();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLMaterialRepository.js
var s9 = class {
  constructor(e7, t13, i6, s14) {
    this._textureRepository = e7, this._techniqueRepository = t13, this.materialChanged = i6, this.requestRender = s14, this._id2glMaterialRef = new t3();
  }
  dispose() {
    this._textureRepository.destroy();
  }
  acquire(e7, t13, r11) {
    this._ownMaterial(e7);
    const i6 = e7.produces.get(t13);
    if (!i6 || !i6(r11))
      return null;
    let s14 = this._id2glMaterialRef.get(r11, e7.id);
    if (null == s14) {
      const t14 = e7.createGLMaterial({ material: e7, techniqueRep: this._techniqueRepository, textureRepository: this._textureRepository, output: r11 });
      s14 = new o7(t14), this._id2glMaterialRef.set(r11, e7.id, s14);
    }
    return s14.ref(), s14.glMaterial;
  }
  release(e7, r11) {
    const i6 = this._id2glMaterialRef.get(r11, e7.id);
    null != i6 && (i6.unref(), i6.referenced || (r(i6.glMaterial), this._id2glMaterialRef.delete(r11, e7.id)));
  }
  _ownMaterial(t13) {
    t13.repository && t13.repository !== this && n.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository").error("Material is already owned by a different material repository"), t13.repository = this;
  }
};
var o7 = class {
  constructor(e7) {
    this.glMaterial = e7, this._refCnt = 0;
  }
  ref() {
    ++this._refCnt;
  }
  unref() {
    --this._refCnt, s3(this._refCnt >= 0);
  }
  get referenced() {
    return this._refCnt > 0;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/BindParameters.js
var m3 = class {
  constructor(i6, m5) {
    this.shadowMap = i6, this.slicePlane = m5, this.slot = A2.OPAQUE_MATERIAL, this.hasOccludees = false, this.enableFillLights = true, this.transparencyPassType = o4.NONE, this.alignPixelEnabled = false, this.decorations = i2.ON, this.overlayStretch = 1, this._camera = new it(), this._inverseViewport = n6(), this.oldLighting = new _3(), this.newLighting = new _3(), this._fadedLighting = new _3(), this._lighting = this.newLighting, this.ssr = new c4(), this.multipassEnabled = false, this.multipassTerrain = new n7(), this.multipassGeometry = new s5(), this.hudRenderStyle = c3.Occluded, this.cloudsFade = new A3();
  }
  get camera() {
    return this._camera;
  }
  set camera(i6) {
    this._camera = i6, this._inverseViewport[0] = 1 / i6.fullViewport[2], this._inverseViewport[1] = 1 / i6.fullViewport[3];
  }
  get inverseViewport() {
    return this._inverseViewport;
  }
  get lighting() {
    return this._lighting;
  }
  get weatherFading() {
    return this._lighting === this._fadedLighting;
  }
  fadeLighting(i6) {
    const { oldLighting: t13, newLighting: e7 } = this;
    i6 >= 1 ? this._lighting = e7 : (this._fadedLighting.lerpLighting(t13, e7, i6), this._lighting = this._fadedLighting);
  }
};
var c4 = class {
  constructor() {
    this.fadeFactor = 1, this.reprojectionMatrix = e3();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/RenderContext.js
var a6 = class {
  constructor(e7, i6, a8 = null) {
    this.rctx = e7, this.sliceHelper = a8, this.lastFrameCamera = new it(), this.output = o3.Color, this.renderOccludedMask = l5, this.bindParameters = new m3(i6, null != a8 ? a8.plane : null), this.bindParameters.alignPixelEnabled = true;
  }
};
var n11 = class extends a6 {
  constructor(r11, t13, s14, i6) {
    super(r11, s14, i6), this.offscreenRenderingHelper = t13, this.sliceHelper = i6, this.time = n2(0);
  }
};
var l5 = h3.Occlude | h3.OccludeAndTransparent | h3.OccludeAndTransparentStencil;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLMaterials.js
var t10 = class {
  constructor(s14, t13) {
    this._material = s14, this._repository = t13, this._map = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._map.forEach((s14, t13) => {
      null != s14 && this._repository.release(this._material, t13);
    });
  }
  load(t13, e7, r11) {
    const i6 = this._material.produces.get(e7);
    if (!i6 || !i6(r11))
      return null;
    this._map.has(r11) || this._map.set(r11, this._repository.acquire(this._material, e7, r11));
    const a8 = this._map.get(r11);
    if (null != a8) {
      if (a8.ensureResources(t13) === a2.LOADED)
        return a8;
      this._repository.requestRender();
    }
    return null;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DrawParameters.js
var s10 = class extends v2 {
  constructor(i6 = n5()) {
    super(), this.origin = i6, this.slicePlaneLocalOrigin = this.origin;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/BufferRange.js
var t11 = class {
  constructor(t13 = 0, o10 = 0) {
    this.from = t13, this.to = o10;
  }
  get numElements() {
    return this.to - this.from;
  }
};
function o8(t13) {
  const o10 = /* @__PURE__ */ new Map();
  t13.forAll((t14) => o10.set(t14.from, t14));
  let e7 = true;
  for (; e7; ) {
    e7 = false;
    for (let r11 = 0; r11 < t13.length; ++r11) {
      const n14 = t13.data[r11], s14 = o10.get(n14.to);
      if (!s14)
        return;
      n14.to = s14.to, o10.delete(s14.from), t13.removeUnordered(s14), e7 = true;
    }
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/Instance.js
var s11 = class extends t11 {
  constructor(e7, s14, t13) {
    super(s14, t13), this.geometry = e7;
  }
  get isVisible() {
    return this.geometry.visible;
  }
  get hasHighlights() {
    return null != this.geometry.highlights && this.isVisible;
  }
  get hasOccludees() {
    return null != this.geometry.occludees;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/DrawCommand.js
var t12 = class {
  constructor() {
    this.first = 0, this.count = 0;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/PerBufferData.js
var n12 = class {
  constructor() {
    this._numElements = 0, this._instances = /* @__PURE__ */ new Map(), this.holes = new l({ allocator: (s14) => s14 || new t11(), deallocator: null }), this.hasHiddenInstances = false, this.hasHighlights = false, this.hasOccludees = false, this.drawCommandsDirty = true, this.drawCommandsDefault = o9(), this.drawCommandsHighlight = o9(), this.drawCommandsOccludees = o9(), this.drawCommandsShadowHighlightRest = o9();
  }
  get numElements() {
    return this._numElements;
  }
  get instances() {
    return this._instances;
  }
  addInstance(s14, t13) {
    this.deleteInstance(s14), this._instances.set(s14, t13), this._numElements += t13.numElements;
  }
  deleteInstance(s14) {
    const t13 = this._instances.get(s14);
    t13 && (this._numElements -= t13.numElements, this._instances.delete(s14));
  }
  updateInstance(s14, t13, e7) {
    const n14 = this._instances.get(s14);
    n14 && (this._numElements -= n14.numElements, n14.from = t13, n14.to = e7, this._numElements += n14.numElements);
  }
  updateDrawState(s14) {
    s14.isVisible ? (s14.hasHighlights && (this.hasHighlights = true), s14.hasOccludees && (this.hasOccludees = true)) : this.hasHiddenInstances = true;
  }
  updateDrawCommands(s14) {
    if (this.drawCommandsDefault.clear(), this.drawCommandsHighlight.clear(), this.drawCommandsOccludees.clear(), this.drawCommandsShadowHighlightRest.clear(), this.drawCommandsDirty = false, 0 === this._instances.size)
      return;
    if (!this.needsMultipleCommands()) {
      const t14 = this.drawCommandsDefault.pushNew(), e7 = this.holes.front();
      return null != this.vao && 1 === this.holes.length && e7.to === Math.floor(this.vao.byteSize / s14) ? (t14.first = 0, void (t14.count = e7.from)) : (t14.first = 1 / 0, t14.count = 0, this._instances.forEach((s15) => {
        t14.first = Math.min(t14.first, s15.from), t14.count = Math.max(t14.count, s15.to);
      }), void (t14.count -= t14.first));
    }
    const t13 = Array.from(this._instances.values()).sort((s15, t14) => s15.from === t14.from ? s15.to - t14.to : s15.from - t14.from);
    for (const e7 of t13)
      e7.isVisible && (h4(e7.hasOccludees ? this.drawCommandsOccludees : this.drawCommandsDefault, e7), h4(e7.hasHighlights ? this.drawCommandsHighlight : this.drawCommandsShadowHighlightRest, e7));
  }
  needsMultipleCommands() {
    return this.hasOccludees || this.hasHighlights || this.hasHiddenInstances;
  }
};
function a7(s14) {
  return null != s14.vao;
}
function o9() {
  return new l({ allocator: (s14) => s14 || new t12(), deallocator: (s14) => s14 });
}
function h4(s14, t13) {
  const e7 = s14.back();
  if (null == e7) {
    const e8 = s14.pushNew();
    return e8.first = t13.from, void (e8.count = t13.numElements);
  }
  if (r9(e7, t13)) {
    const s15 = t13.from - e7.first + t13.numElements;
    e7.count = s15;
  } else {
    const e8 = s14.pushNew();
    e8.first = t13.from, e8.count = t13.numElements;
  }
}
function r9(s14, t13) {
  return s14.first + s14.count >= t13.from;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/PerOriginData.js
var s12 = class {
  constructor(s14) {
    this.origin = s14, this.buffers = new Array();
  }
  dispose() {
    this.buffers.forEach((s14) => s14.vao.dispose()), this.buffers.length = 0;
  }
  findBuffer(s14) {
    return this.buffers.find((r11) => r11.instances.has(s14));
  }
};

// node_modules/@arcgis/core/core/MemCachePool.js
var c5 = class {
  constructor(t13, c6) {
    this._cache = t13(c6, (t14, c7, s14) => {
      switch (c7) {
        case i.ALL:
          return t14.forEach((e7) => e7.dispose()), 0;
        case i.SOME: {
          const e7 = t14.shift();
          return e7 && (s14 -= Math.round(e7.usedMemory), e7.dispose()), s14;
        }
      }
    });
  }
  hitrate() {
    return this._cache.hitRate;
  }
  destroy() {
    this._cache.destroy();
  }
  clear() {
    this._cache.clear();
  }
  getSize(e7) {
    return this._cache.getSize(e7);
  }
  pop(e7) {
    const t13 = this._cache.peek(e7);
    if (!t13)
      return;
    const c6 = t13.pop();
    if (t13.length > 0) {
      if (c6) {
        const s14 = this._cache.getSize(e7) - Math.round(c6.usedMemory);
        this._cache.updateSize(e7, t13, s14);
      }
    } else
      this._cache.pop(e7);
    return c6;
  }
  put(e7, c6, s14 = s2) {
    const h5 = this._cache.peek(e7);
    if (!h5)
      return void this._cache.put(e7, [c6], c6.usedMemory, s14);
    h5.push(c6);
    const r11 = this._cache.getSize(e7) + Math.round(c6.usedMemory);
    this._cache.updateSize(e7, h5, r11);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/VaoCache.js
var s13 = class {
  constructor(e7, r11, o10) {
    this._rctx = e7, this._locations = r11, this._layout = o10, this._cache = new c5(e7.newCache, "VAOCache");
  }
  dispose() {
    this._cache.destroy();
  }
  newVao(t13) {
    const s14 = t13.toString();
    let c6 = this._cache.pop(s14);
    return c6 || (c6 = new r6(this._rctx, this._locations, { geometry: this._layout }, { geometry: h2.createVertex(this._rctx, F.STATIC_DRAW) }), c6.vertexBuffers.geometry.setSize(t13), c6);
  }
  deleteVao(t13) {
    if (null == t13)
      return;
    const e7 = t13.byteSize.toString();
    this._cache.put(e7, t13);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/MergedRenderer.js
var M = class extends d2 {
  constructor(e7) {
    super(e7), this._vaoCache = null, this._glMaterials = null, this._bufferWriter = null, this._dataByOrigin = /* @__PURE__ */ new Map(), this._hasHighlights = false, this._hasOccludees = false, this._produces = /* @__PURE__ */ new Map(), this.drapedPriority = 0;
  }
  destroy() {
    this._glMaterials = r(this._glMaterials), this._dataByOrigin.forEach((e7) => e7.dispose()), this._dataByOrigin.clear(), this._vaoCache = r(this._vaoCache);
  }
  initialize() {
    this.material.produces.forEach((e7, t13) => {
      this._produces.set(t13, (t14) => !(0 === this._dataByOrigin.size || !(t14 !== o3.Highlight && t14 !== o3.ShadowHighlight || this._hasHighlights)) && e7(t14));
    });
  }
  get produces() {
    return this._produces;
  }
  initializeRenderContext(e7, t13) {
    const { rctx: r11 } = e7.renderContext;
    this._glMaterials = new t10(this.material, t13 ?? e7.materialRepository), this._bufferWriter = this.material.createBufferWriter(), this._vaoCache = new s13(r11, this.material.vertexAttributeLocations, t2(this._bufferWriter.vertexBufferLayout));
  }
  uninitializeRenderContext() {
  }
  get hasOccludees() {
    return this._hasOccludees;
  }
  get isDecoration() {
    return this.material.parameters.isDecoration;
  }
  queryRenderOccludedState(e7) {
    return this.material.queryRenderOccludedState(e7);
  }
  get materialReference() {
    return this.material;
  }
  get numGeometries() {
    let e7 = 0;
    return this._dataByOrigin.forEach((t13) => e7 += t13.buffers.reduce((e8, t14) => e8 + t14.instances.size, 0)), e7;
  }
  get usedMemory() {
    let e7 = 0;
    return this._dataByOrigin.forEach((t13) => e7 += t13.buffers.reduce((e8, t14) => e8 + t14.vao.usedMemory, 0)), e7;
  }
  forEachGeometry(e7) {
    this._dataByOrigin.forEach((t13) => t13.buffers.forEach((t14) => t14.instances.forEach((t15) => e7(t15.geometry))));
  }
  modify(e7) {
    this._updateGeometries(e7.updates), this._addAndRemoveGeometries(e7.adds, e7.removes), this._updateDrawCommands();
  }
  _updateGeometries(e7) {
    const t13 = this._bufferWriter;
    if (null === t13)
      return;
    const r11 = t13.vertexBufferLayout.stride / 4;
    for (const i6 of e7) {
      const e8 = i6.renderGeometry, s14 = this._dataByOrigin.get(e8.localOrigin.id), a8 = s14 == null ? void 0 : s14.findBuffer(e8.id);
      if (null == a8)
        return;
      const o10 = a8.instances.get(e8.id);
      if (i6.updateType & (I2.GEOMETRY | I2.TRANSFORMATION)) {
        const i7 = U(t13.elementCount(o10.geometry.geometry) * r11), s15 = t13.vertexBufferLayout.createView(i7.buffer);
        this._writeGeometry(e8, s15, 0), a8.vao.vertexBuffers.geometry.setSubData(i7, o10.from * r11, 0, o10.numElements * r11);
      }
      i6.updateType & (I2.HIGHLIGHT | I2.OCCLUDEE | I2.VISIBILITY) && (a8.drawCommandsDirty = true);
    }
  }
  _computeDeltas(e7, t13) {
    const r11 = new t3();
    for (const i6 of e7) {
      const e8 = i6.localOrigin;
      if (null == e8)
        continue;
      let t14 = r11.get(e8.id, null);
      null == t14 && (t14 = new S3(e8.vec3), r11.set(e8.id, null, t14)), t14.changes.push(i6);
    }
    for (const i6 of t13) {
      const e8 = i6.localOrigin;
      if (null == e8)
        continue;
      const t14 = this._dataByOrigin.get(e8.id), s14 = t14 == null ? void 0 : t14.findBuffer(i6.id);
      if (null == s14)
        continue;
      let a8 = r11.get(e8.id, s14);
      null == a8 && (a8 = new S3(e8.vec3), r11.set(e8.id, s14, a8)), a8.changes.push(i6);
    }
    return r11;
  }
  _addAndRemoveGeometries(e7, r11) {
    if (null === this._bufferWriter || null === this._vaoCache)
      return;
    const { _bufferWriter: i6, _dataByOrigin: s14 } = this, a8 = i6.vertexBufferLayout.stride / 4, o10 = this._computeDeltas(e7, r11);
    o10.forEach((e8, r12) => {
      const n14 = e8.get(null), l6 = null != n14 ? n14.changes : [];
      o10.delete(r12, null);
      let u4 = s14.get(r12);
      if (e8.forEach((e9, n15) => {
        if (o10.delete(r12, n15), null == n15)
          return void s3(false, "No VAO for removed geometries");
        if (n15.instances.size === e9.changes.length)
          return this._vaoCache.deleteVao(n15.vao), z(u4.buffers, n15), void (0 === u4.buffers.length && 0 === l6.length && s14.delete(r12));
        const h5 = n15.numElements, c6 = n15.vao.byteSize / 4, f2 = l6.reduce((e10, t13) => e10 + i6.elementCount(t13.geometry), 0), d5 = e9.changes.reduce((e10, t13) => e10 + i6.elementCount(t13.geometry), 0), m5 = Math.min((h5 + f2 - d5) * a8, z3), g = m5 > c6;
        m5 > G2 && m5 < c6 / 2 ? (e9.changes.forEach(({ id: e10 }) => n15.deleteInstance(e10)), n15.instances.forEach(({ geometry: e10 }) => l6.push(e10)), this._vaoCache.deleteVao(n15.vao), z(u4.buffers, n15)) : g ? this._applyAndRebuild(n15, l6, e9) : this._applyRemoves(n15, e9);
      }), l6.length > 0)
        for (null == u4 && (u4 = new s12(n14.origin), s14.set(r12, u4)), u4.buffers.forEach((e9) => this._applyAdds(e9, l6)); l6.length > 0; )
          u4.buffers.push(this._applyAndRebuild(new n12(), l6, null));
    });
  }
  _updateDrawCommands() {
    this._hasHighlights = false, this._hasOccludees = false, this._dataByOrigin.forEach((e7) => {
      e7.buffers.forEach((e8) => {
        e8.drawCommandsDirty && (e8.hasHiddenInstances = false, e8.hasHighlights = false, e8.hasOccludees = false, n4(e8.instances, (t13) => (e8.updateDrawState(t13), e8.hasHiddenInstances && e8.hasHighlights && e8.hasOccludees)), e8.updateDrawCommands(this._bufferWriter.vertexBufferLayout.stride)), this._hasHighlights = this._hasHighlights || e8.hasHighlights, this._hasOccludees = this._hasOccludees || e8.hasOccludees;
      });
    });
  }
  _applyAndRebuild(e7, t13, r11) {
    if (null != r11)
      for (const d5 of r11.changes)
        e7.deleteInstance(d5.id);
    const i6 = this._bufferWriter, s14 = i6.vertexBufferLayout.stride, a8 = s14 / 4, o10 = Math.floor(z3 / a8);
    let n14 = e7.numElements;
    for (; t13.length > 0; ) {
      const r12 = t13.pop(), s15 = i6.elementCount(r12.geometry);
      if (n14 + s15 > o10 && n14 > 0) {
        t13.push(r12);
        break;
      }
      n14 += s15;
      const a9 = new s11(r12, 0, 0);
      s3(null == e7.instances.get(r12.id)), e7.addInstance(r12.id, a9);
    }
    const l6 = n14 * a8, u4 = U(l6), h5 = i6.vertexBufferLayout.createView(u4.buffer);
    let c6 = 0;
    e7.hasHiddenInstances = false, e7.hasHighlights = false, e7.hasOccludees = false, e7.instances.forEach((t14, r12) => {
      this._writeGeometry(t14.geometry, h5, c6);
      const s15 = c6;
      c6 += i6.elementCount(t14.geometry.geometry), e7.updateInstance(r12, s15, c6), e7.updateDrawState(t14);
    }), this._vaoCache.deleteVao(e7.vao), e7.vao = this._vaoCache.newVao(q2(l6)), e7.vao.vertexBuffers.geometry.setSubData(u4, 0, 0, c6 * a8), e7.holes.clear();
    const f2 = e7.holes.pushNew();
    return f2.from = c6, f2.to = Math.floor(e7.vao.byteSize / s14), e7.updateDrawCommands(s14), e7;
  }
  _applyRemoves(e7, t13) {
    if (0 === t13.changes.length || null === this._bufferWriter)
      return;
    for (const o10 of t13.changes) {
      const t14 = o10.id, r12 = e7.instances.get(t14);
      if (!r12)
        continue;
      e7.deleteInstance(t14);
      const i7 = T.back();
      if (i7) {
        if (i7.to === r12.from) {
          i7.to = r12.to;
          continue;
        }
        if (i7.from === r12.to) {
          i7.from = r12.from;
          continue;
        }
      }
      const s15 = T.pushNew();
      s15.from = r12.from, s15.to = r12.to;
    }
    o8(T);
    const r11 = this._bufferWriter.vertexBufferLayout.stride / 4, i6 = T.reduce((e8, t14) => Math.max(e8, t14.numElements), 0) * r11, s14 = U(i6);
    s14.fill(0, 0, i6);
    const a8 = e7.vao.vertexBuffers.geometry;
    T.forAll((e8) => a8.setSubData(s14, e8.from * r11, 0, e8.numElements * r11)), e7.holes.pushArray(T.data, T.length), T.forAll((e8, t14) => T.data[t14] = null), T.clear(), e7.drawCommandsDirty = true;
  }
  _applyAdds(e7, t13) {
    if (0 === t13.length || null === this._bufferWriter)
      return;
    if (!a7(e7))
      return void this._applyAndRebuild(e7, t13, null);
    const i6 = this._bufferWriter, s14 = i6.vertexBufferLayout.stride / 4, a8 = e7.numElements, o10 = t13.reduce((e8, t14) => e8 + i6.elementCount(t14.geometry), 0), n14 = Math.min((a8 + o10) * s14, z3), l6 = 4 * n14;
    if (e7.vao.byteSize < q2(z3 - G2) && l6 > e7.vao.byteSize)
      return void this._applyAndRebuild(e7, t13, null);
    o8(e7.holes);
    const u4 = new Array();
    for (const r11 of t13) {
      const t14 = i6.elementCount(r11.geometry), s15 = x(e7.holes, t14);
      u4.push(s15);
    }
    const h5 = e7.vao.vertexBuffers.geometry;
    let c6 = 0, f2 = 0, d5 = 0;
    const m5 = U(n14), g = i6.vertexBufferLayout.createView(m5.buffer);
    t13.forEach((t14, r11) => {
      const a9 = u4[r11];
      if (null == a9)
        return;
      if (!(d5 === a9)) {
        const e8 = d5 - f2;
        e8 > 0 && h5.setSubData(m5, f2 * s14, 0, e8 * s14), f2 = a9, c6 = 0;
      }
      const o11 = i6.elementCount(t14.geometry);
      this._writeGeometry(t14, g, c6), c6 += o11, d5 = a9 + o11;
      const n15 = new s11(t14, a9, a9 + o11);
      s3(null == e7.instances.get(t14.id)), e7.addInstance(t14.id, n15), e7.drawCommandsDirty = true;
    });
    const p = d5 - f2;
    p > 0 && h5.setSubData(m5, f2 * s14, 0, p * s14), C(t13, (e8, t14) => null == u4[t14]);
  }
  _writeGeometry(e7, t13, r11) {
    if (null === this._bufferWriter)
      return;
    const i6 = e7.localOrigin.vec3;
    l3(j, -i6[0], -i6[1], -i6[2]);
    const s14 = c(L2, j, e7.transformation);
    h(I3, s14), s(I3, I3), this._bufferWriter.write(s14, I3, e7.geometry, t13, r11);
  }
  updateAnimation(e7) {
    return this.material.update(e7);
  }
  prepareTechnique(e7) {
    if (!this.material.shouldRender(e7))
      return null;
    const { output: t13, bindParameters: r11 } = e7, i6 = this.material.produces.get(r11.slot);
    if (!i6 || !i6(t13))
      return null;
    const s14 = t13 === o3.Highlight || t13 === o3.ShadowHighlight;
    if (s14 && !this._hasHighlights)
      return null;
    const a8 = t13 === o3.ShadowExcludeHighlight, o10 = !(s14 || a8);
    for (const n14 of this._dataByOrigin.values())
      for (const i7 of n14.buffers) {
        if (s14 && !i7.hasHighlights)
          continue;
        const n15 = (s14 ? i7.drawCommandsHighlight : a8 && i7.needsMultipleCommands() ? i7.drawCommandsShadowHighlightRest : i7.drawCommandsDefault) || null, l6 = o10 && i7.drawCommandsOccludees || null;
        if ((n15 == null ? void 0 : n15.length) || (l6 == null ? void 0 : l6.length)) {
          const i8 = this._glMaterials.load(e7.rctx, r11.slot, t13), s15 = null != i8 ? i8.beginSlot(r11) : null;
          if (null != s15)
            return s15;
        }
      }
    return null;
  }
  renderNode(e7, t13) {
    const { output: r11, bindParameters: i6 } = e7, s14 = r11 === o3.Highlight || r11 === o3.ShadowHighlight, a8 = r11 === o3.ShadowExcludeHighlight, o10 = !(s14 || a8), n14 = e7.rctx, l6 = e7.bindParameters.slot === A2.OCCLUDER_MATERIAL, u4 = e7.bindParameters.slot === A2.TRANSPARENT_OCCLUDER_MATERIAL;
    n14.runAppleAmdDriverHelper(), n14.bindTechnique(t13, i6, this.material.parameters);
    for (const h5 of this._dataByOrigin.values())
      for (const e8 of h5.buffers) {
        if (s14 && !e8.hasHighlights)
          continue;
        const r12 = (s14 ? e8.drawCommandsHighlight : a8 && e8.needsMultipleCommands() ? e8.drawCommandsShadowHighlightRest : e8.drawCommandsDefault) || null, c6 = o10 && e8.drawCommandsOccludees || null;
        if ((r12 == null ? void 0 : r12.length) || (c6 == null ? void 0 : c6.length)) {
          t13.program.bindDraw(new s10(h5.origin), i6, this.material.parameters), t13.ensureAttributeLocations(e8.vao), n14.bindVAO(e8.vao), (r12 == null ? void 0 : r12.length) && (n14.setPipelineState(t13.getPipeline(false, l6, u4)), r12.forAll((e9) => n14.drawArrays(t13.primitiveType, e9.first, e9.count))), (c6 == null ? void 0 : c6.length) && (n14.setPipelineState(t13.getPipeline(true, l6, u4)), c6.forAll((e9) => n14.drawArrays(t13.primitiveType, e9.first, e9.count)));
        }
      }
  }
  get test() {
    return { material: this.material, glMaterials: this._glMaterials, dataByOrigin: this._dataByOrigin };
  }
};
e([y({ constructOnly: true })], M.prototype, "material", void 0), M = e([a("esri.views.3d.webgl-engine.materials.renderers.MergedRenderer")], M);
var S3 = class {
  constructor(e7) {
    this.origin = e7, this.changes = new Array();
  }
};
function x(e7, t13) {
  let r11;
  if (!e7.some((e8) => !(e8.numElements < t13) && (r11 = e8, true)))
    return null;
  const i6 = r11.from;
  return r11.from += t13, r11.from >= r11.to && e7.removeUnordered(r11), i6;
}
var j = e3();
var L2 = e3();
var I3 = e3();
var T = new l({ allocator: (e7) => e7 || new t11(), deallocator: null });
var G2 = 65536;
var P = 4 * G2;
var W = 1024;
var V = 16777216;
var z3 = V / 4;
var N = new Float32Array(G2);
function U(e7) {
  return N.length < e7 && (N = new Float32Array(e7)), N;
}
function q2(e7) {
  const t13 = 4 * e7;
  return t13 <= W ? W : t13 < P ? u2(t13) : Math.max(Math.min(Math.ceil(1.5 * t13 / P) * P, V), t13);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/SortedRenderGeometryRenderer.js
var R3 = class extends S {
  constructor(e7) {
    super(e7), this._pending = new G3(), this._changes = new s6(), this._materialRenderers = new l(), this._sortedMaterialRenderers = new l(), this._geometries = /* @__PURE__ */ new Map(), this._hasHighlights = false, this._hasWater = false;
  }
  destroy() {
    this._changes.prune(), this._materialRenderers.forAll((e7) => e7.destroy()), this._materialRenderers.clear(), this._sortedMaterialRenderers.clear(), this._geometries.clear(), this._pending.clear();
  }
  get updating() {
    return !this._pending.empty || this._changes.updates.length > 0;
  }
  get rctx() {
    return this.rendererContext.rctx;
  }
  get _materialRepository() {
    return this.rendererContext.materialRepository;
  }
  get _localOriginFactory() {
    return this.rendererContext.localOriginFactory;
  }
  get hasHighlights() {
    return this._hasHighlights;
  }
  get hasWater() {
    return this._hasWater;
  }
  get rendersOccludedDraped() {
    return this._materialRenderers.some((e7) => 0 !== e7.numGeometries && !e7.queryRenderOccludedState(h3.Occlude));
  }
  get isEmpty() {
    return !this.updating && 0 === this._materialRenderers.length && 0 === this._geometries.size;
  }
  getMemoryForMaterial(e7) {
    if (null == e7)
      return 0;
    const r11 = this._materialRenderers.find((r12) => r12.materialReference === e7);
    return (r11 == null ? void 0 : r11.usedMemory) ?? 0;
  }
  commitChanges() {
    if (!this.updating)
      return false;
    this._processAddsRemoves();
    const e7 = n8(this._changes);
    let r11 = false;
    return e7.forEach((e8, t13) => {
      let s14 = this._materialRenderers.find((e9) => e9.materialReference === t13);
      if (!s14 && e8.adds.length > 0) {
        const e9 = new M({ material: t13 });
        e9.initializeRenderContext(this.rendererContext.pluginContext, this._materialRepository), s14 = e9, this._materialRenderers.push(s14), r11 = true;
      }
      s14 && (s14.modify(e8), 0 === s14.numGeometries && (this._materialRenderers.removeUnordered(s14), s14.destroy(), r11 = true));
    }), this._changes.clear(), r11 && this._updateSortedMaterialRenderers(), this._hasHighlights = this._materialRenderers.some((e8) => {
      const r12 = e8.produces.get(A2.DRAPED_MATERIAL);
      return !!r12 && r12(o3.Highlight);
    }), this._hasWater = this._materialRenderers.some((e8) => {
      const r12 = e8.produces.get(A2.DRAPED_WATER);
      return !!r12 && r12(o3.Normal);
    }), this.notifyChange("updating"), true;
  }
  addGeometries(e7, r11) {
    if (0 === e7.length)
      return;
    const t13 = this._validateRenderGeometries(e7);
    for (const i6 of t13)
      this._geometries.set(i6.id, i6);
    const s14 = this._pending.empty;
    for (const i6 of t13)
      this._pending.adds.add(i6);
    s14 && this.notifyChange("updating"), r11 === E2.UPDATE && this._notifyGraphicGeometryChanged(e7);
  }
  removeGeometries(e7, r11) {
    const t13 = this._pending.empty, s14 = this._pending.adds;
    for (const i6 of e7)
      s14.has(i6) ? (this._pending.removed.add(i6), s14.delete(i6)) : this._pending.removed.has(i6) || this._pending.removes.add(i6), this._geometries.delete(i6.id);
    t13 && !this._pending.empty && this.notifyChange("updating"), r11 === E2.UPDATE && this._notifyGraphicGeometryChanged(e7);
  }
  modifyGeometries(e7, r11) {
    const t13 = 0 === this._changes.updates.length;
    for (const s14 of e7) {
      const e8 = this._changes.updates.pushNew();
      e8.renderGeometry = this._validateRenderGeometry(s14), e8.updateType = r11;
    }
    switch (t13 && this._changes.updates.length > 0 && this.notifyChange("updating"), r11) {
      case I2.TRANSFORMATION:
      case I2.GEOMETRY:
        return this._notifyGraphicGeometryChanged(e7);
      case I2.VISIBILITY:
        return this._notifyGraphicVisibilityChanged(e7);
    }
  }
  updateAnimation(e7) {
    let r11 = false;
    return this._sortedMaterialRenderers.forAll((t13) => r11 = !!t13.updateAnimation && t13.updateAnimation(e7) || r11), r11;
  }
  shouldRender(e7) {
    return this._sortedMaterialRenderers.some((r11) => r11.prepareTechnique(e7));
  }
  render(e7) {
    this._sortedMaterialRenderers.forAll((r11) => {
      const t13 = r11.prepareTechnique(e7);
      null != t13 && r11.renderNode(e7, t13);
    });
  }
  intersect(e7, r11, t13, s14, i6) {
    return this._geometries.forEach((n14) => {
      if (s14 && !s14(n14))
        return;
      this._intersectRenderGeometry(n14, t13, r11, 0, e7, i6);
      const o10 = this.rendererContext.longitudeCyclical;
      o10 && (n14.boundingSphere[0] - n14.boundingSphere[3] < o10.min && this._intersectRenderGeometry(n14, t13, r11, o10.range, e7, i6), n14.boundingSphere[0] + n14.boundingSphere[3] > o10.max && this._intersectRenderGeometry(n14, t13, r11, -o10.range, e7, i6)), i6++;
    }), i6;
  }
  _updateSortedMaterialRenderers() {
    this._sortedMaterialRenderers.clear(), this._materialRenderers.forAll((e7, r11) => {
      e7.drapedPriority = r11, this._sortedMaterialRenderers.push(e7);
    }), this._sortedMaterialRenderers.sort((e7, r11) => {
      var _a, _b, _c, _d;
      return ((_a = r11.materialReference) == null ? void 0 : _a.renderPriority) === ((_b = e7.materialReference) == null ? void 0 : _b.renderPriority) ? e7.drapedPriority - r11.drapedPriority : (((_c = r11.materialReference) == null ? void 0 : _c.renderPriority) || 0) - (((_d = e7.materialReference) == null ? void 0 : _d.renderPriority) || 0);
    });
  }
  _processAddsRemoves() {
    this._changes.adds.clear(), this._changes.removes.clear(), this._changes.adds.pushArray(Array.from(this._pending.adds)), this._changes.removes.pushArray(Array.from(this._pending.removes));
    for (let e7 = 0; e7 < this._changes.updates.length; ) {
      const r11 = this._changes.updates.data[e7];
      this._pending.has(r11.renderGeometry) ? this._changes.updates.removeUnorderedIndex(e7) : e7++;
    }
    this._pending.clear();
  }
  _intersectRenderGeometry(e7, r11, t13, s14, i6, n14) {
    if (!e7.visible)
      return;
    let o10 = 0;
    s14 += e7.transformation[12], o10 = e7.transformation[13], C4[0] = t13[0] - s14, C4[1] = t13[1] - o10, e7.screenToWorldRatio = this.rendererContext.screenToWorldRatio, e7.material.intersectDraped(e7, null, i6, C4, (t14, s15, o11) => {
      v3(r11, o11, n14, e7.material.renderPriority, i6, e7.layerUid, e7.graphicUid);
    }, r11);
  }
  _notifyGraphicGeometryChanged(e7) {
    if (null == this.drapeSource.notifyGraphicGeometryChanged)
      return;
    let r11;
    for (const t13 of e7) {
      const e8 = t13.graphicUid;
      null != e8 && e8 !== r11 && (this.drapeSource.notifyGraphicGeometryChanged(e8), r11 = e8);
    }
  }
  _notifyGraphicVisibilityChanged(e7) {
    if (null == this.drapeSource.notifyGraphicVisibilityChanged)
      return;
    let r11;
    for (const t13 of e7) {
      const e8 = t13.graphicUid;
      null != e8 && e8 !== r11 && (this.drapeSource.notifyGraphicVisibilityChanged(e8), r11 = e8);
    }
  }
  _validateRenderGeometries(e7) {
    for (const r11 of e7)
      this._validateRenderGeometry(r11);
    return e7;
  }
  _validateRenderGeometry(e7) {
    return null == e7.localOrigin && (e7.localOrigin = this._localOriginFactory.getOrigin(Z(e7.boundingSphere))), e7;
  }
  get test() {
    return { sortedMaterialRenderers: this._sortedMaterialRenderers };
  }
};
e([y()], R3.prototype, "drapeSource", void 0), e([y()], R3.prototype, "updating", null), e([y()], R3.prototype, "rctx", null), e([y({ constructOnly: true })], R3.prototype, "rendererContext", void 0), e([y()], R3.prototype, "_materialRepository", null), e([y()], R3.prototype, "_localOriginFactory", null), e([y({ readOnly: true })], R3.prototype, "isEmpty", null), e([y()], R3.prototype, "_materialRenderers", void 0), e([y()], R3.prototype, "_geometries", void 0), R3 = e([a("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")], R3);
var G3 = class {
  constructor() {
    this.adds = /* @__PURE__ */ new Set(), this.removes = /* @__PURE__ */ new Set(), this.removed = /* @__PURE__ */ new Set();
  }
  get empty() {
    return 0 === this.adds.size && 0 === this.removes.size && 0 === this.removed.size;
  }
  has(e7) {
    return this.adds.has(e7) || this.removes.has(e7) || this.removed.has(e7);
  }
  clear() {
    this.adds.clear(), this.removes.clear(), this.removed.clear();
  }
};
function v3(e7, r11, t13, s14, i6, n14, o10) {
  const d5 = new i5(n14, o10, r11), h5 = (r12) => {
    r12.set(i4.OVERLAY, d5, e7.dist, e7.normal, e7.transformation, t13, s14);
  };
  if ((null == i6.results.min.drapedLayerOrder || t13 >= i6.results.min.drapedLayerOrder) && (null == i6.results.min.dist || i6.results.ground.dist <= i6.results.min.dist) && h5(i6.results.min), i6.options.store !== e5.MIN && (null == i6.results.max.drapedLayerOrder || t13 < i6.results.max.drapedLayerOrder) && (null == i6.results.max.dist || i6.results.ground.dist > i6.results.max.dist) && h5(i6.results.max), i6.options.store === e5.ALL) {
    const e8 = G(i6.ray);
    h5(e8), i6.results.all.push(e8);
  }
}
var C4 = n6();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextureTechnique.js
var m4 = class _m extends r3 {
  initializeProgram(e7) {
    return new r4(e7.rctx, _m.shader.get().build(), O);
  }
  initializePipeline() {
    return this.configuration.hasAlpha ? S2({ blending: l4(R.SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE_MINUS_SRC_ALPHA), colorWrite: _2 }) : S2({ colorWrite: _2 });
  }
};
m4.shader = new t4(d3, () => import("./TextureOnly.glsl-I2DAZM4P.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextureTechniqueConfiguration.js
var r10 = class extends t5 {
  constructor() {
    super(...arguments), this.hasAlpha = false;
  }
};
e([r5()], r10.prototype, "hasAlpha", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/OverlayCompositingTechnique.js
var n13 = class _n extends r3 {
  initializeProgram(e7) {
    return new r4(e7.rctx, _n.shader.get().build(), O);
  }
  initializePipeline() {
    return S2({ blending: s4(R.ONE, R.ONE_MINUS_SRC_ALPHA), colorWrite: _2 });
  }
};
n13.shader = new t4(m2, () => import("./OverlayCompositing.glsl-EZKHNFEE.js"));

// node_modules/@arcgis/core/views/3d/terrain/OverlayRenderer.js
var $ = class extends c2 {
  constructor(e7) {
    super(e7), this._overlays = null, this._renderTargets = null, this._overlayParameters = new d4(), this.hasHighlights = false, this._hasWater = false, this._renderers = /* @__PURE__ */ new Map(), this._sortedDrapeSourceRenderersDirty = false, this._sortedRenderers = new l(), this._passParameters = new a4(), this._materialRepository = null, this._screenToWorldRatio = 1, this._localOriginFactory = null, this.unloadedMemory = 0, this.ignoresMemoryFactor = false, this._camera = new it(), this.worldToPCSRatio = 1, this.events = new o(), this.longitudeCyclical = null, this.produces = /* @__PURE__ */ new Map([[A2.DRAPED_MATERIAL, (e8) => e8 !== o3.Highlight || this.hasHighlights], [A2.DRAPED_WATER, () => this._hasWater]]), this._hasTargetWithoutRasterImage = false, this._hasDrapedFeatureSource = false, this._hasDrapedRasterSource = false;
  }
  initialize() {
    const e7 = this.view._stage.renderer.fboCache, r11 = this.view._stage.renderView, { waterTextures: t13, stippleTextures: s14, markerTextures: i6 } = r11;
    this._shaderTechniques = new r8({ rctx: this._rctx, viewingMode: l2.Local, stippleTextureRepository: s14, markerTextureRepository: i6, waterTextureRepository: t13 }), this._renderContext = new a6(this._rctx, new X(e7, this.view.state.viewingMode), null), this.addHandles([d(() => t13.updating, () => this.events.emit("content-changed"), A), d(() => this.spatialReference, (e8) => this._localOriginFactory = new _4(e8), A), v(() => this.view.allLayerViews, "after-changes", () => this._sortedDrapeSourceRenderersDirty = true)]), this._materialRepository = new s9(r11.textureRepository, this._shaderTechniques, () => {
      this.notifyChange("rendersOccludedDraped"), this.events.emit("content-changed"), this.notifyChange("updating"), this.notifyChange("isEmpty");
    }, () => this.events.emit("content-changed")), this._bindParameters.slot = A2.DRAPED_MATERIAL, this._bindParameters.mainDepth = null, this._camera.near = 1, this._camera.far = 1e4, this._camera.relativeElevation = null, this._bindParameters.camera = this._camera, this._bindParameters.transparencyPassType = o4.NONE, this._bindParameters.newLighting.noonFactor = 0, this._bindParameters.newLighting.globalFactor = 0, this._bindParameters.newLighting.set([new i3(r2(1, 1, 1))]), this.addHandles(this.view.resourceController.scheduler.registerTask(I.STAGE, this));
  }
  destroy() {
    this._renderers.forEach((e7) => e7.destroy()), this._renderers.clear(), this._debugTextureTechnique = t(this._debugTextureTechnique), this._passParameters.texture = r(this._passParameters.texture), this._shaderTechniques = u(this._shaderTechniques), this.disposeOverlays();
  }
  get _bindParameters() {
    return this._renderContext.bindParameters;
  }
  get _rctx() {
    return this.view._stage.renderView.renderingContext;
  }
  get rctx() {
    return this._rctx;
  }
  get materialRepository() {
    return this._materialRepository;
  }
  get screenToWorldRatio() {
    return this._screenToWorldRatio;
  }
  get localOriginFactory() {
    return this._localOriginFactory;
  }
  initializeRenderContext(e7) {
    this.pluginContext = e7;
  }
  uninitializeRenderContext() {
  }
  renderNode() {
  }
  get updating() {
    return this._sortedDrapeSourceRenderersDirty || n4(this._renderers, (e7) => e7.updating);
  }
  get hasOverlays() {
    return null != this._overlays && null != this._renderTargets;
  }
  getMemoryForMaterial(e7) {
    return Array.from(this._renderers.values()).reduce((r11, t13) => r11 + t13.getMemoryForMaterial(e7), 0);
  }
  get layers() {
    return this._sortedDrapeSourceRenderersDirty && this._updateSortedDrapeSourceRenderers(), this._sortedRenderers.map((e7) => e7.drapeSource.layer).filter((e7) => !!e7);
  }
  createGeometryDrapeSourceRenderer(e7) {
    return this.createDrapeSourceRenderer(e7, R3);
  }
  createDrapeSourceRenderer(e7, r11, t13) {
    const s14 = this._renderers.get(e7);
    null != s14 && s14.destroy();
    const i6 = new r11({ ...t13, rendererContext: this, drapeSource: e7 });
    return this._renderers.set(e7, i6), this._sortedDrapeSourceRenderersDirty = true, "fullOpacity" in e7 && this.addHandles(d(() => e7.fullOpacity, () => this.events.emit("content-changed")), e7), i6;
  }
  removeDrapeSourceRenderer(e7) {
    if (null == e7)
      return;
    const r11 = this._renderers.get(e7);
    null != r11 && (this._sortedDrapeSourceRenderersDirty = true, this._renderers.delete(e7), this.removeHandles(e7), r11.destroy());
  }
  computeValidity() {
    var _a;
    return ((_a = this._renderTargets) == null ? void 0 : _a.computeValidity()) ?? 0;
  }
  releaseRenderTargets() {
    var _a;
    (_a = this._renderTargets) == null ? void 0 : _a.dispose();
  }
  get overlays() {
    return this._overlays ?? [];
  }
  ensureDrapeTargets(e7) {
    this._hasTargetWithoutRasterImage = !!this._overlays && n3(e7, (e8) => e8.drapeTargetType === t7.WithoutRasterImage);
  }
  ensureDrapeSources(e7) {
    this._overlays ? (this._hasDrapedFeatureSource = n3(e7, (e8) => e8.drapeSourceType === e6.Features), this._hasDrapedRasterSource = n3(e7, (e8) => e8.drapeSourceType === e6.RasterImage)) : this._hasDrapedFeatureSource = this._hasDrapedRasterSource = false;
  }
  get _needsColorWithoutRasterImage() {
    return this._hasDrapedRasterSource && this._hasDrapedFeatureSource && this._hasTargetWithoutRasterImage;
  }
  ensureOverlays(e7, r11, t13 = this._bindParameters.overlayStretch) {
    null == this._overlays && (this._renderTargets = new s7(this.view._stage.renderer.fboCache), this._overlays = [new n9(), new n9()]), this.ensureDrapeTargets(e7), this.ensureDrapeSources(r11), this._bindParameters.overlayStretch = t13;
  }
  disposeOverlays() {
    this._overlays = null, this._renderTargets = r(this._renderTargets), this.events.emit("textures-disposed");
  }
  getTexture(e7) {
    var _a, _b;
    if (null != e7)
      return e7 === o5.ColorNoRasterImage && !this._needsColorWithoutRasterImage && this._hasDrapedFeatureSource ? (_a = this._renderTargets) == null ? void 0 : _a.getTexture(o5.Color) : (_b = this._renderTargets) == null ? void 0 : _b.getTexture(e7);
  }
  get running() {
    return this.updating;
  }
  runTask(e7) {
    this._processDrapeSources(e7, () => true);
  }
  _processDrapeSources(e7, r11) {
    let s14 = false;
    for (const [t13, i6] of this._renderers) {
      if (e7.done)
        break;
      (t13.destroyed || r11(t13)) && (i6.commitChanges() && (s14 = true, e7.madeProgress()));
    }
    this._sortedDrapeSourceRenderersDirty && (this._sortedDrapeSourceRenderersDirty = false, s14 = true, this._updateSortedDrapeSourceRenderers()), s14 && (null != this._overlays && 0 === this._renderers.size && this.disposeOverlays(), this.notifyChange("updating"), this.notifyChange("isEmpty"), this.events.emit("content-changed"), this.hasHighlights = n4(this._renderers, (e8) => e8.hasHighlights), this.notifyChange("rendersOccludedDraped"), this._updateHasWater());
  }
  processSyncDrapeSources() {
    this._processDrapeSources(C2, (e7) => e7.updatePolicy === C3.SYNC);
  }
  get isEmpty() {
    return !t6.OVERLAY_DRAW_DEBUG_TEXTURE && !n4(this._renderers, (e7) => !e7.isEmpty);
  }
  get hasWater() {
    return this._hasWater;
  }
  get rendersOccludedDraped() {
    const e7 = this._renderContext.renderOccludedMask;
    this._renderContext.renderOccludedMask = se;
    const r11 = this._sortedRenderers.some(({ renderer: e8 }) => e8.shouldRender(this._renderContext));
    return this._renderContext.renderOccludedMask = e7, r11;
  }
  renders(e7) {
    return t6.OVERLAY_DRAW_DEBUG_TEXTURE && e7 !== o5.Occluded || this._sortedRenderers.some(({ renderer: e8 }) => e8.shouldRender(this._renderContext));
  }
  get mode() {
    var _a, _b;
    return this.isEmpty ? f.Disabled : ((_a = this._renderTargets) == null ? void 0 : _a.getTexture(o5.WaterNormal)) ? f.EnabledWithWater : ((_b = this._renderTargets) == null ? void 0 : _b.getTexture(o5.Color)) ? f.Enabled : f.Disabled;
  }
  updateAnimation(e7) {
    let r11 = false;
    return this._renderers.forEach((t13) => r11 = t13.updateAnimation(e7) || r11), r11;
  }
  updateDrapeSourceOrder() {
    this._sortedDrapeSourceRenderersDirty = true;
  }
  drawOverlays(e7) {
    if (this._overlays && this._renderTargets) {
      for (const e8 of this._overlays)
        this.longitudeCyclical ? e8.setupGeometryViewsCyclical(this.longitudeCyclical) : e8.setupGeometryViewsDirect();
      for (const r11 of this._renderTargets.targets) {
        if (r11.content === o5.ColorNoRasterImage && !this._needsColorWithoutRasterImage)
          continue;
        const t13 = this._drawTarget(E.INNER, r11, e7), s14 = this._drawTarget(E.OUTER, r11, e7);
        (t13 || s14) && r11.fbo.generateMipMap();
      }
    }
  }
  _drawTarget(e7, r11, t13) {
    const s14 = this._overlays[e7], i6 = s14.canvasGeometries;
    if (0 === i6.numViews)
      return false;
    const { alignPixelEnabled: a8, contentPixelRatio: o10 } = t13;
    this._screenToWorldRatio = o10 * s14.mapUnitsPerPixel / this._bindParameters.overlayStretch;
    const n14 = r11.output;
    if (this.isEmpty || n14 === o3.Highlight && !this.hasHighlights || n14 === o3.Normal && !this.hasWater || !s14.hasSomeSizedView())
      return false;
    const h5 = this._rctx;
    if (this._camera.pixelRatio = s14.pixelRatio * o10, this._renderContext.output = n14, this._bindParameters.alignPixelEnabled = a8, this._bindParameters.screenToWorldRatio = this._screenToWorldRatio, this._bindParameters.screenToPCSRatio = this._screenToWorldRatio * this.worldToPCSRatio, this._bindParameters.slot = n14 === o3.Normal ? A2.DRAPED_WATER : A2.DRAPED_MATERIAL, r11.content === o5.Occluded && (this._renderContext.renderOccludedMask = se), !this.renders(r11.content))
      return this._renderContext.renderOccludedMask = l5, false;
    const d5 = s14.resolution;
    this._rctx.setViewport(e7 === E.INNER ? 0 : d5, 0, d5, d5);
    const l6 = 2 * s14.resolution, c6 = s14.resolution, u4 = r11.fbo;
    u4.bind(h5, l6, c6), e7 === E.INNER && (h5.setClearColor(0, 0, 0, 0), h5.clear(_.COLOR_BUFFER_BIT));
    if (t6.OVERLAY_DRAW_DEBUG_TEXTURE && r11.content !== o5.Occluded)
      for (let p = 0; p < i6.numViews; p++)
        this._setViewParameters(i6.extents[p], s14), this._ensureDebugPatternResources(s14.resolution, re[e7]), this._rctx.bindTechnique(this._debugTextureTechnique, this._renderContext.bindParameters, this._passParameters), this._rctx.screen.draw();
    return this._sortedRenderers.forAll(({ drapeSource: t14, renderer: a9 }) => {
      if (r11.content === o5.ColorNoRasterImage && t14.drapeSourceType === e6.RasterImage)
        return;
      const { fullOpacity: o11 } = t14, d6 = null != o11 && o11 < 1 && n14 === o3.Color ? this.bindTemporaryFramebuffer(l6, c6) : null;
      for (let e8 = 0; e8 < i6.numViews; e8++)
        this._setViewParameters(i6.extents[e8], s14), a9.render(this._renderContext);
      if (d6) {
        u4.bind(h5, l6, c6), this._overlayParameters.texture = d6.getTexture(), this._overlayParameters.opacity = o11, this._overlayParameters.overlayIndex = e7;
        const r12 = this.pluginContext.techniqueRepository.acquire(n13);
        this._rctx.bindTechnique(r12, this._renderContext.bindParameters, this._overlayParameters), this._rctx.screen.draw(), r12.release(), d6.release();
      }
    }), h5.bindFramebuffer(null), this._renderContext.renderOccludedMask = l5, true;
  }
  bindTemporaryFramebuffer(e7, r11) {
    const t13 = this.view._stage.renderer.fboCache, s14 = t13.acquire(e7, r11, "overlay tmp");
    return t13.rctx.unbindTexture(s14.fbo.colorTexture), t13.rctx.bindFramebuffer(s14.fbo), t13.rctx.clear(_.COLOR_BUFFER_BIT), s14;
  }
  async reloadShaders() {
    await this._shaderTechniques.reloadAll();
  }
  notifyContentChanged() {
    this.events.emit("content-changed");
  }
  intersect(e7, r11, t13, s14) {
    var _a;
    this._sortedDrapeSourceRenderersDirty && this._updateSortedDrapeSourceRenderers();
    let i6 = 0;
    for (const { renderer: a8 } of this._sortedRenderers)
      i6 = ((_a = a8.intersect) == null ? void 0 : _a.call(a8, e7, r11, t13, s14, i6)) ?? i6;
  }
  _updateSortedDrapeSourceRenderers() {
    if (this._sortedRenderers.clear(), 0 === this._renderers.size)
      return;
    const e7 = this.view.map.allLayers, r11 = e7.length;
    this._renderers.forEach((t13, s14) => {
      const i6 = e7.indexOf(s14.layer), a8 = i6 >= 0, o10 = s14.renderGroup ?? (a8 ? a3.MapLayer : a3.ViewLayer), n14 = r11 * o10 + (a8 ? i6 : 0);
      this._sortedRenderers.push(new ee(s14, t13, n14));
    }), this._sortedRenderers.sort((e8, r12) => e8.index - r12.index);
  }
  _setViewParameters(e7, r11) {
    const t13 = this._camera;
    t13.viewport = [0, 0, r11.resolution, r11.resolution], Q(t13.projectionMatrix, 0, e7[2] - e7[0], 0, e7[3] - e7[1], t13.near, t13.far), q(t13.viewMatrix, [-e7[0], -e7[1], 0]);
  }
  _updateHasWater() {
    const e7 = n4(this._renderers, (e8) => e8.hasWater);
    e7 !== this._hasWater && (this._hasWater = e7, this.events.emit("has-water", e7));
  }
  _ensureDebugPatternResources(e7, r11) {
    if (o2(this._passParameters.color, r11[0], r11[1], r11[2]), this._passParameters.texture)
      return;
    const t13 = new Uint8Array(e7 * e7 * 4);
    let s14 = 0;
    for (let o10 = 0; o10 < e7; o10++)
      for (let r12 = 0; r12 < e7; r12++) {
        const i7 = Math.floor(r12 / 10), a9 = Math.floor(o10 / 10);
        i7 < 2 || a9 < 2 || 10 * i7 > e7 - 20 || 10 * a9 > e7 - 20 ? (t13[s14++] = 255, t13[s14++] = 255, t13[s14++] = 255, t13[s14++] = 255) : (t13[s14++] = 255, t13[s14++] = 255, t13[s14++] = 255, t13[s14++] = 1 & i7 && 1 & a9 ? 1 & r12 ^ 1 & o10 ? 0 : 255 : 1 & i7 ^ 1 & a9 ? 0 : 128);
      }
    const i6 = new e4(e7);
    i6.samplingMode = L.NEAREST, this._passParameters.texture = new m(this._rctx, i6, t13);
    const a8 = new r10();
    a8.hasAlpha = true, this._debugTextureTechnique = this._shaderTechniques.acquire(m4, a8);
  }
  get test() {
    return { drapedRenderers: Array.from(this._renderers.values()), sortedDrapeSources: Array.from(this._sortedRenderers).map(({ drapeSource: e7 }) => e7), getDrapeSourceRenderer: (e7) => this._renderers.get(e7) };
  }
};
e([y()], $.prototype, "hasHighlights", void 0), e([y()], $.prototype, "_sortedDrapeSourceRenderersDirty", void 0), e([y()], $.prototype, "_shaderTechniques", void 0), e([y({ constructOnly: true })], $.prototype, "view", void 0), e([y()], $.prototype, "worldToPCSRatio", void 0), e([y()], $.prototype, "spatialReference", void 0), e([y({ type: Boolean, readOnly: true })], $.prototype, "updating", null), e([y()], $.prototype, "isEmpty", null), e([y({ readOnly: true })], $.prototype, "rendersOccludedDraped", null), $ = e([a("esri.views.3d.terrain.OverlayRenderer")], $);
var ee = class {
  constructor(e7, r11, t13) {
    this.drapeSource = e7, this.renderer = r11, this.index = t13;
  }
};
var re = [[1, 0.5, 0.5], [0.5, 0.5, 1]];
var te = -2;
var se = h3.OccludeAndTransparent;

export {
  r8 as r,
  s9 as s,
  m3 as m,
  n11 as n,
  l5 as l,
  t10 as t,
  s10 as s2,
  c5 as c,
  M,
  R3 as R,
  m4 as m2,
  r10 as r2,
  $,
  te,
  se
};
//# sourceMappingURL=chunk-YYI7TRI3.js.map
