import {
  E,
  K,
  N,
  V,
  a as a5,
  c as c3,
  c2 as c4,
  d as d6,
  f as f7,
  h,
  i as i3,
  j as j5,
  k as k2,
  l as l3,
  m as m3,
  n as n8,
  p as p4,
  t as t3
} from "./chunk-AYKBCBY7.js";
import {
  d as d7,
  g as g3,
  m as m2,
  p as p3
} from "./chunk-IOKSWIVD.js";
import "./chunk-54XXLVAD.js";
import "./chunk-KO7QNSNZ.js";
import {
  A as A2,
  B2 as B,
  G,
  P,
  U2,
  d as d5,
  j as j4,
  m,
  n2 as n6,
  n4 as n7
} from "./chunk-TBCOV2E5.js";
import {
  g as g2,
  l3 as l2,
  s2 as s7
} from "./chunk-HUFLW46E.js";
import {
  s as s6
} from "./chunk-XKG6TWCH.js";
import {
  n as n5,
  s as s4
} from "./chunk-AC67ONZX.js";
import {
  s as s5
} from "./chunk-ZOUC7PLM.js";
import "./chunk-F2EHRKUX.js";
import "./chunk-2636VFVY.js";
import "./chunk-252ISA6Z.js";
import "./chunk-2QPP5AGU.js";
import "./chunk-2C26DRKK.js";
import "./chunk-M4RFJU4F.js";
import "./chunk-3FOBZIUS.js";
import "./chunk-MGFAIE2L.js";
import "./chunk-ONKWNPIN.js";
import "./chunk-YH2IYJYF.js";
import "./chunk-GGHKH3LP.js";
import "./chunk-VS6AHHIY.js";
import {
  e as e3
} from "./chunk-OF4YIONV.js";
import {
  l
} from "./chunk-AHEDDTVZ.js";
import {
  f as f6
} from "./chunk-7UUNSIMA.js";
import "./chunk-GMRQGGML.js";
import "./chunk-BYK4ZOU2.js";
import {
  p as p2
} from "./chunk-OHYLFFUW.js";
import {
  e as e2
} from "./chunk-XW3FDKYP.js";
import "./chunk-Y7RXGLGH.js";
import "./chunk-GKMVTGGM.js";
import "./chunk-XGTCDM4C.js";
import {
  Z
} from "./chunk-QNG4TY7L.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import "./chunk-RGAA5Z76.js";
import "./chunk-Q6RZBEZ6.js";
import {
  b as b2
} from "./chunk-PC66NY33.js";
import "./chunk-YY2VB3AE.js";
import "./chunk-VEYMN5N3.js";
import "./chunk-H6NTWZSO.js";
import "./chunk-BMT3OVAP.js";
import {
  b as b3,
  s as s2
} from "./chunk-W5ALAOW2.js";
import "./chunk-FHDHOWK5.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-AKQ765JR.js";
import "./chunk-ERD6I7QP.js";
import "./chunk-QIT4M76C.js";
import "./chunk-EZL4LTMD.js";
import {
  d as d4
} from "./chunk-F3BQGS35.js";
import {
  y as y3
} from "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-LMO6NZJA.js";
import "./chunk-A5QTLE4Y.js";
import "./chunk-SCHTG6ZQ.js";
import {
  R
} from "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import {
  f as f4
} from "./chunk-QYC3GV65.js";
import {
  P as P2
} from "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import {
  f as f5,
  i as i2,
  s as s3
} from "./chunk-I2X6UR6L.js";
import {
  A
} from "./chunk-7EQJLP2H.js";
import {
  j as j3
} from "./chunk-4ZLXDMI5.js";
import {
  t as t2
} from "./chunk-QG73ZMDG.js";
import {
  f as f3
} from "./chunk-EMYOYGGK.js";
import {
  n as n4
} from "./chunk-6PMFOUWZ.js";
import "./chunk-3KPZ3BQR.js";
import "./chunk-5JYVZQZR.js";
import {
  t
} from "./chunk-UUG4W2PI.js";
import {
  u as u2
} from "./chunk-WW22JHXA.js";
import {
  S
} from "./chunk-ZAM62XN5.js";
import {
  c as c2,
  d as d3,
  g,
  y as y4
} from "./chunk-RKVEKQ5O.js";
import "./chunk-P7J4JFEH.js";
import {
  b
} from "./chunk-G7FOE26O.js";
import "./chunk-USOPZ2Q6.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-JW7VBMHD.js";
import "./chunk-GLLRUDMY.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import {
  i
} from "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import {
  n as n3
} from "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import {
  p,
  y as y2
} from "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import {
  o as o3
} from "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-AKLOTDO2.js";
import "./chunk-6AQIVLDN.js";
import {
  c
} from "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-LBXFRGMS.js";
import "./chunk-VTH4DAHQ.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import {
  j as j2,
  u
} from "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-5LSHHVQ5.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  f as f2
} from "./chunk-MBGZKT2Z.js";
import {
  d2,
  fe,
  me,
  oe
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import {
  o as o2
} from "./chunk-YOPMY6TS.js";
import {
  r
} from "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import {
  n as n2
} from "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import {
  I,
  U
} from "./chunk-SAYWXQVM.js";
import {
  f
} from "./chunk-SBL4URUW.js";
import {
  d
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  j2 as j,
  o,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  T,
  a as a3,
  a3 as a4,
  v
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  a as a2,
  k
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  a,
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionSchema.js
var e4 = { StretchFunction: { arguments: { ComputeGamma: { isDataset: false, isPublic: false, name: "ComputeGamma", type: "RasterFunctionVariable", value: false }, DRA: { isDataset: false, isPublic: false, name: "DRA", type: "RasterFunctionVariable", value: false }, EstimateStatsHistogram: { isDataset: false, isPublic: false, name: "EstimateStatsHistogram", type: "RasterFunctionVariable", value: false }, Gamma: { displayName: "Gamma", isDataset: false, isPublic: false, name: "Gamma", type: "RasterFunctionVariable" }, Histograms: { isDataset: false, isPublic: false, name: "Histograms", type: "RasterFunctionVariable" }, Max: { isDataset: false, isPublic: false, name: "Max", type: "RasterFunctionVariable", value: 255 }, MaxPercent: { isDataset: false, isPublic: false, name: "MaxPercent", type: "RasterFunctionVariable", value: 0.5 }, Min: { isDataset: false, isPublic: false, name: "Min", type: "RasterFunctionVariable", value: 0 }, MinPercent: { isDataset: false, isPublic: false, name: "MinPercent", type: "RasterFunctionVariable", value: 0.25 }, NumberOfStandardDeviations: { isDataset: false, isPublic: false, name: "NumberOfStandardDeviation", type: "RasterFunctionVariable", value: 2 }, Raster: { isDataset: true, isPublic: false, name: "Raster", type: "RasterFunctionVariable" }, SigmoidStrengthLevel: { isDataset: false, isPublic: false, name: "SigmoidStrengthLevel", type: "RasterFunctionVariable", value: 2 }, Statistics: { isDataset: false, isPublic: false, name: "Statistics", type: "RasterFunctionVariable" }, StretchType: { isDataset: false, isPublic: false, name: "StretchType", type: "RasterFunctionVariable", value: 0 }, type: "StretchFunctionArguments", UseGamma: { isDataset: false, isPublic: false, name: "UseGamma", type: "RasterFunctionVariable", value: false } }, description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", function: { description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", name: "Stretch", pixelType: "UNKNOWN", type: "StretchFunction" }, functionType: 0, name: "Stretch", thumbnail: "" }, RemapFunction: { name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table.", function: { type: "RemapFunction", pixelType: "UNKNOWN", name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, UseTable: { name: "UseTable", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, InputRanges: { name: "InputRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Input Ranges" }, OutputValues: { name: "OutputValues", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Output Values" }, NoDataRanges: { name: "NoDataRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "NoData Ranges" }, Table: { name: "Table", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputField: { name: "InputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, OutputField: { name: "OutputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputMaxField: { name: "InputMaxField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, RemapTableType: { name: "RemapTableType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, AllowUnmatched: { name: "AllowUnmatched", isPublic: false, isDataset: false, value: true, type: "RasterFunctionVariable" }, type: "RemapFunctionArguments" }, functionType: 0, thumbnail: "" }, ColormapFunction: { name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.", function: { type: "ColormapFunction", pixelType: "UNKNOWN", name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, ColormapName: { name: "ColormapName", isPublic: false, isDataset: false, value: "Gray", type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, type: "ColormapFunctionArguments" }, functionType: 0, thumbnail: "" }, ShadedReliefFunction: { name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.", function: { type: "ShadedReliefFunction", pixelType: "UNKNOWN", name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "ShadedReliefFunctionArguments" }, functionType: 0, thumbnail: "" }, HillshadeFunction: { name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image", function: { type: "HillshadeFunction", pixelType: "UNKNOWN", name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image" }, arguments: { DEM: { name: "DEM", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "HillshadeFunctionArguments" }, functionType: 0, thumbnail: "" }, ResampleFunction: { name: "Resample", description: "Changes the cell size of a raster.", function: { type: "ResampleFunction", pixelType: "UNKNOWN", name: "Resample", description: "Changes the cell size of a raster." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ResamplingType: { name: "ResamplingType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, InputCellSize: { name: "InputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, OutputCellSize: { name: "OutputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, type: "ResampleFunctionArguments" }, functionType: 0, thumbnail: "" } };

// node_modules/@arcgis/core/layers/support/imageryRendererUtils.js
var c5 = /* @__PURE__ */ new Set(["u1", "u2", "u4", "u8", "s8", "u16", "s16"]);
var m4 = { simple_scalar: "Simple Scalar", wind_barb: "Wind Barb", single_arrow: "Single Arrow", beaufort_kn: "Beaufort Wind (Knots)", beaufort_m: "Beaufort Wind (MetersPerSecond)", ocean_current_m: "Ocean Current (MetersPerSecond)", ocean_current_kn: "Ocean Current (Knots)" };
var f8 = /* @__PURE__ */ new Set(["raster-stretch", "unique-value", "class-breaks", "raster-shaded-relief", "vector-field", "raster-colormap"]);
function p5(e6) {
  return f8.has(e6.type);
}
function g4(n16, t5) {
  var _a;
  if (!n16 || !t5)
    return a(n16 || t5);
  const r2 = a(n16);
  if (r2.functionDefinition && t5.rasterFunctionDefinition) {
    const e6 = t5.rasterFunctionDefinition;
    (e6.thumbnail || e6.thumbnailEx) && (e6.thumbnail = e6.thumbnailEx = void 0), d8(r2.functionDefinition.arguments, t5), r2.rasterFunctionDefinition = r2.functionDefinition.toJSON();
  } else if ("none" !== ((_a = t5.functionName) == null ? void 0 : _a.toLowerCase())) {
    b4(r2.functionArguments).Raster = t5;
  }
  return r2;
}
function d8(e6, n16) {
  for (const t5 in e6)
    "raster" === t5.toLowerCase() && ("RasterFunctionVariable" === e6[t5].type ? (e6[t5] = n16.rasterFunctionDefinition, e6[t5].type = "RasterFunctionTemplate") : "RasterFunctionTemplate" === e6[t5].type && d8(e6[t5].arguments, n16));
}
function h2(n16) {
  const t5 = a(e4[n16.functionName + "Function"]), o4 = n16.functionArguments;
  for (const e6 in o4)
    "raster" === e6.toLowerCase() ? (t5.arguments[e6] = h2(o4[e6]), t5.arguments[e6].type = "RasterFunctionTemplate") : "colormap" === e6.toLowerCase() ? (t5.arguments[e6].value = V2(o4[e6]), t5.arguments.ColorSchemeType.value = 0) : t5.arguments[e6].value = o4[e6];
  return t5;
}
function y5(e6, n16) {
  switch (n16 = n16 || {}, e6.type) {
    case "raster-stretch":
      return w2(e6, n16);
    case "class-breaks":
      return S2(e6, n16);
    case "unique-value":
      return F(e6, n16);
    case "raster-colormap":
      return A3(e6, n16);
    case "vector-field":
      return T2(e6, n16);
    case "raster-shaded-relief":
      return v2(e6, n16);
    case "flow":
      throw new Error("Unsupported rendering rule.");
  }
}
function b4(e6) {
  const n16 = (e6 == null ? void 0 : e6.Raster) ?? (e6 == null ? void 0 : e6.raster);
  return n16 && "esri.layers.support.RasterFunction" === n16.declaredClass ? b4(n16.functionArguments) : e6;
}
var R2 = { none: 0, standardDeviation: 3, histogramEqualization: 4, minMax: 5, percentClip: 6, sigmoid: 9 };
function T2(e6, t5) {
  const r2 = new N();
  r2.functionName = "VectorFieldRenderer";
  const { dataType: o4, bandNames: a14 } = t5, i10 = "vector-uv" === o4;
  let s9, u7;
  if (a14 && 2 === a14.length) {
    const e7 = a14.map((e8) => e8.toLowerCase());
    s9 = e7.indexOf("magnitude"), u7 = e7.indexOf("direction");
  }
  -1 !== s9 && null !== s9 || (s9 = 0, u7 = 1);
  const c22 = "arithmetic" === e6.rotationType ? 1 : 2, f9 = "flow-from" === e6.flowRepresentation ? 0 : 1, p20 = e6.visualVariables ? e6.visualVariables.find((e7) => "Magnitude" === e7.field) : new b2(), g6 = { magnitudeBandID: s9, directionBandID: u7, isUVComponents: i10, referenceSystem: c22, massFlowAngleRepresentation: f9, symbolTileSize: 50, symbolTileSizeUnits: 100, calculationMethod: "Vector Average", symbologyName: m4[e6.style.toLowerCase().replace("-", "_")], minimumMagnitude: p20.minDataValue, maximumMagnitude: p20.maxDataValue, minimumSymbolSize: p20.minSize, maximumSymbolSize: p20.maxSize };
  r2.functionArguments = g6;
  const d12 = h2(r2);
  return t5.convertToRFT ? N.fromJSON({ rasterFunctionDefinition: d12 }) : r2;
}
function v2(e6, t5) {
  const r2 = t5.convertToRFT;
  if ("elevation" !== t5.dataType && ("generic" !== t5.dataType || 1 !== t5.bandCount || "s16" !== t5.pixelType && "s32" !== t5.pixelType && "f32" !== t5.pixelType && "f64" !== t5.pixelType))
    return new N();
  const i10 = new N();
  i10.functionName = "Hillshade";
  const s9 = "traditional" === e6.hillshadeType ? 0 : 1, u7 = "none" === e6.scalingType ? 1 : 3, l11 = { HillshadeType: s9, SlopeType: u7, ZFactor: e6.zFactor };
  return 0 === s9 && (l11.Azimuth = e6.azimuth, l11.Altitude = e6.altitude), 3 === u7 && (l11.PSPower = e6.pixelSizePower, l11.PSZFactor = e6.pixelSizeFactor), i10.functionArguments = l11, i10.variableName = "Raster", e6.colorRamp && (i10.functionName = "ShadedRelief", r2 ? l11.ColorRamp = G(e6.colorRamp) : l11.Colormap = B(e6.colorRamp)), r2 ? new N({ rasterFunctionDefinition: h2(i10) }) : i10;
}
function w2(e6, t5) {
  var _a;
  const r2 = t5.convertToRFT, s9 = new N();
  s9.functionName = "Stretch";
  const l11 = R2[n7.toJSON(e6.stretchType)], c22 = "u8", m13 = { StretchType: l11, Statistics: N2(e6.statistics ?? []), DRA: e6.dynamicRangeAdjustment, UseGamma: e6.useGamma, Gamma: e6.gamma, ComputeGamma: e6.computeGamma };
  if (null != e6.outputMin && (m13.Min = e6.outputMin), null != e6.outputMax && (m13.Max = e6.outputMax), l11 === R2.standardDeviation ? (m13.NumberOfStandardDeviations = e6.numberOfStandardDeviations, s9.outputPixelType = c22) : l11 === R2.percentClip ? (m13.MinPercent = e6.minPercent, m13.MaxPercent = e6.maxPercent, s9.outputPixelType = c22) : l11 === R2.minMax ? s9.outputPixelType = c22 : l11 === R2.sigmoid && (m13.SigmoidStrengthLevel = e6.sigmoidStrengthLevel), s9.functionArguments = m13, s9.variableName = "Raster", e6.colorRamp) {
    const u7 = e6.colorRamp, l12 = new N();
    if (r2)
      l12.functionArguments = { ColorRamp: G(u7) };
    else {
      const n16 = d5(u7, true);
      if (n16)
        l12.functionArguments = { colorRampName: n16 };
      else if (!t5.convertColorRampToColormap || "algorithmic" !== u7.type && "multipart" !== u7.type) {
        const n17 = e6.colorRamp.toJSON();
        "algorithmic" === n17.type ? n17.algorithm = n17.algorithm || "esriCIELabAlgorithm" : "multipart" === n17.type && ((_a = n17.colorRamps) == null ? void 0 : _a.length) && n17.colorRamps.forEach((e7) => e7.algorithm = e7.algorithm || "esriCIELabAlgorithm"), l12.functionArguments = { colorRamp: n17 };
      } else
        l12.functionArguments = { Colormap: B(u7) };
    }
    return l12.variableName = "Raster", l12.functionName = "Colormap", l12.functionArguments.Raster = s9, r2 ? new N({ rasterFunctionDefinition: h2(l12) }) : l12;
  }
  return r2 ? new N({ rasterFunctionDefinition: h2(s9) }) : s9;
}
function S2(e6, t5) {
  const r2 = [], o4 = [], a14 = [], i10 = [], s9 = 1e-4, { pixelType: u7, rasterAttributeTable: l11 } = t5, c22 = null == l11 ? null : l11.features, m13 = C(l11);
  if (m13 && c22 && Array.isArray(c22) && e6.classBreakInfos) {
    e6.classBreakInfos.forEach((n16, t6) => {
      var _a;
      const r4 = (_a = n16.symbol) == null ? void 0 : _a.color;
      let o6;
      (r4 == null ? void 0 : r4.a) && null != n16.minValue && null != n16.maxValue && c22.forEach((a15) => {
        null != n16.minValue && null != n16.maxValue && (o6 = a15.attributes[e6.field], (o6 >= n16.minValue && o6 < n16.maxValue || t6 === e6.classBreakInfos.length - 1 && o6 >= n16.minValue) && i10.push([a15.attributes[m13], r4.r, r4.g, r4.b]));
      });
    });
    const r3 = u7 ? x2(i10, u7) : i10, o5 = new N();
    return o5.functionName = "Colormap", o5.functionArguments = {}, o5.functionArguments.Colormap = r3, o5.variableName = "Raster", t5.convertToRFT ? new N({ rasterFunctionDefinition: h2(o5) }) : o5;
  }
  e6.classBreakInfos.forEach((e7, n16) => {
    if (null == e7.minValue || null == e7.maxValue)
      return;
    const t6 = e7.symbol && e7.symbol.color;
    (t6 == null ? void 0 : t6.a) ? (0 === n16 ? r2.push(e7.minValue, e7.maxValue + s9) : r2.push(e7.minValue + s9, e7.maxValue + s9), o4.push(n16), i10.push([n16, t6.r, t6.g, t6.b])) : a14.push(e7.minValue, e7.maxValue);
  });
  const f9 = u7 ? x2(i10, u7) : i10, p20 = new N();
  p20.functionName = "Remap", p20.functionArguments = { InputRanges: r2, OutputValues: o4, NoDataRanges: a14 }, p20.variableName = "Raster";
  const g6 = new N();
  return g6.functionName = "Colormap", g6.functionArguments = { Colormap: f9, Raster: p20 }, t5.convertToRFT ? new N({ rasterFunctionDefinition: h2(g6) }) : g6;
}
function x2(e6, n16) {
  const r2 = c5.has(n16) ? s6(n16) : null;
  return r2 && e6.push([Math.floor(r2[0] - 1), 0, 0, 0], [Math.ceil(r2[1] + 1), 0, 0, 0]), e6;
}
function C(e6) {
  if (null == e6)
    return;
  const { fields: n16 } = e6, t5 = n16 == null ? void 0 : n16.find((e7) => (e7 == null ? void 0 : e7.name) && "value" === e7.name.toLowerCase());
  return t5 == null ? void 0 : t5.name;
}
function F(e6, t5) {
  var _a, _b, _c;
  const r2 = [], { pixelType: o4, rasterAttributeTable: a14 } = t5, i10 = null == a14 ? null : a14.features, s9 = C(a14), u7 = (_b = (_a = e6.defaultSymbol) == null ? void 0 : _a.color) == null ? void 0 : _b.toRgb(), l11 = e6.uniqueValueInfos;
  if (l11)
    if (i10) {
      if (s9) {
        const n16 = /* @__PURE__ */ new Map();
        l11.forEach((e7) => {
          var _a2;
          const t7 = e7.value, r3 = (_a2 = e7.symbol) == null ? void 0 : _a2.color;
          null != t7 && (r3 == null ? void 0 : r3.a) && n16.set(String(t7), r3.toRgb());
        });
        const t6 = e6.field;
        i10.forEach(({ attributes: e7 }) => {
          const o5 = String(e7[t6]), a15 = e7[s9], i11 = n16.get(o5);
          i11 ? r2.push([a15, ...i11]) : u7 && r2.push([a15, ...u7]);
        });
      }
    } else
      for (let n16 = 0; n16 < l11.length; n16++) {
        const e7 = l11[n16], t6 = (_c = e7.symbol) == null ? void 0 : _c.color, o5 = +e7.value;
        if (t6 == null ? void 0 : t6.a) {
          if (isNaN(o5))
            return null;
          r2.push([o5, t6.r, t6.g, t6.b]);
        }
      }
  const c22 = o4 ? x2(r2, o4) : r2, m13 = new N();
  return m13.functionName = "Colormap", m13.functionArguments = {}, m13.functionArguments.Colormap = c22, m13.variableName = "Raster", t5.convertToRFT ? new N({ rasterFunctionDefinition: h2(m13) }) : m13;
}
function A3(e6, t5) {
  const r2 = e6.extractColormap();
  if (!r2 || 0 === r2.length)
    return null;
  const { pixelType: o4 } = t5, a14 = o4 ? x2(r2, o4) : r2, i10 = new N();
  return i10.functionName = "Colormap", i10.functionArguments = {}, i10.functionArguments.Colormap = a14, t5.convertToRFT ? new N({ rasterFunctionDefinition: h2(i10) }) : i10;
}
function N2(e6) {
  const n16 = [];
  return e6 == null ? void 0 : e6.forEach((e7) => {
    const t5 = e7;
    if (Array.isArray(t5))
      n16.push(t5);
    else {
      if (null == t5.min || null == t5.max)
        return;
      const e8 = [t5.min, t5.max, t5.avg || 0, t5.stddev || 0];
      n16.push(e8);
    }
  }), n16;
}
function V2(e6) {
  const n16 = [], t5 = [];
  return e6.forEach((e7) => {
    n16.push(e7[0]), t5.push(A2([...e7.slice(1), 255]));
  }), { type: "RasterColormap", values: n16, colors: t5 };
}

// node_modules/@arcgis/core/layers/support/ExportImageServiceParameters.js
var y6 = class extends f {
  constructor() {
    super(...arguments), this.layer = null, this.compression = void 0, this.pixelType = void 0, this.lercVersion = 2;
  }
  get adjustAspectRatio() {
    return this.layer.adjustAspectRatio;
  }
  writeAdjustAspectRatio(e6, t5, r2) {
    this.layer.version < 10.3 || (t5[r2] = e6);
  }
  get bandIds() {
    return this.layer.bandIds;
  }
  get compressionQuality() {
    return this.layer.compressionQuality;
  }
  writeCompressionQuality(e6, t5, r2) {
    this.format && this.format.toLowerCase().includes("jpg") && null != e6 && (t5[r2] = e6);
  }
  get compressionTolerance() {
    return this.layer.compressionTolerance;
  }
  writeCompressionTolerance(e6, t5, r2) {
    "lerc" === this.format && null != e6 && (t5[r2] = e6);
  }
  get format() {
    var _a;
    return "vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type) ? "lerc" : this.layer.format;
  }
  get interpolation() {
    return this.layer.interpolation;
  }
  get noData() {
    return this.layer.noData;
  }
  get noDataInterpretation() {
    return this.layer.noDataInterpretation;
  }
  writeLercVersion(e6, t5, r2) {
    "lerc" === this.format && this.layer.version >= 10.5 && (t5[r2] = e6);
  }
  get version() {
    const e6 = this.layer;
    return e6.commitProperty("bandIds"), e6.commitProperty("format"), e6.commitProperty("compressionQuality"), e6.commitProperty("compressionTolerance"), e6.commitProperty("interpolation"), e6.commitProperty("noData"), e6.commitProperty("noDataInterpretation"), e6.commitProperty("mosaicRule"), e6.commitProperty("rasterFunction"), e6.commitProperty("adjustAspectRatio"), e6.commitProperty("pixelFilter"), e6.commitProperty("definitionExpression"), e6.commitProperty("multidimensionalSubset"), (this._get("version") || 0) + 1;
  }
  set version(e6) {
    this._set("version", e6);
  }
  get mosaicRule() {
    const e6 = this.layer;
    let t5 = e6.mosaicRule;
    const r2 = e6.definitionExpression;
    return t5 ? r2 && r2 !== t5.where && (t5 = t5.clone(), t5.where = r2) : r2 && (t5 = new j5({ where: r2 })), t5;
  }
  get rasterFunction() {
    var _a, _b;
    const e6 = this.layer;
    let { rasterFunction: t5 } = e6;
    const r2 = e6.pixelFilter, o4 = !e6.format || e6.format.includes("jpg") || e6.format.includes("png");
    t5 = this._addResampleRasterFunction(t5);
    const i10 = (_a = e6.multidimensionalSubset) == null ? void 0 : _a.areaOfInterest;
    return i10 && (t5 = d9(t5, i10)), o4 && !r2 && "vector-field" !== ((_b = e6.renderer) == null ? void 0 : _b.type) && (t5 = this.combineRendererWithRenderingRule(t5)), t5;
  }
  combineRendererWithRenderingRule(e6) {
    const t5 = this.layer, { rasterInfo: r2, renderer: o4 } = t5;
    if (e6 = e6 || t5.rasterFunction, !o4 || !p5(o4))
      return e6;
    return g4(y5(o4, { rasterAttributeTable: r2.attributeTable, pixelType: r2.pixelType, dataType: r2.dataType, bandNames: r2.bandInfos.map(({ name: e7 }) => e7), convertColorRampToColormap: t5.version < 10.6, convertToRFT: !!(e6 == null ? void 0 : e6.rasterFunctionDefinition), bandCount: r2.bandCount }), e6);
  }
  _addResampleRasterFunction(e6) {
    var _a;
    if (!("vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type)) || "Resample" === (e6 == null ? void 0 : e6.functionName))
      return e6;
    const t5 = "esriImageServiceDataTypeVector-UV" === this.layer.serviceDataType ? 7 : 10, r2 = this.layer.serviceRasterInfo.pixelSize;
    let o4 = new N({ functionName: "Resample", functionArguments: { ResamplingType: t5, InputCellSize: r2 } });
    return o4 = (e6 == null ? void 0 : e6.rasterFunctionDefinition) ? new N({ rasterFunctionDefinition: h2(o4) }) : o4, g4(o4, e6);
  }
};
function d9(e6, t5) {
  const r2 = new N({ functionName: "Clip", functionArguments: { ClippingGeometry: t5.toJSON(), ClippingType: 1 } });
  return g4(r2, e6);
}
e([y()], y6.prototype, "layer", void 0), e([y({ json: { write: true } })], y6.prototype, "adjustAspectRatio", null), e([r("adjustAspectRatio")], y6.prototype, "writeAdjustAspectRatio", null), e([y({ json: { write: true } })], y6.prototype, "bandIds", null), e([y({ json: { write: true } })], y6.prototype, "compression", void 0), e([y({ json: { write: true } })], y6.prototype, "compressionQuality", null), e([r("compressionQuality")], y6.prototype, "writeCompressionQuality", null), e([y({ json: { write: true } })], y6.prototype, "compressionTolerance", null), e([r("compressionTolerance")], y6.prototype, "writeCompressionTolerance", null), e([y({ json: { write: true } })], y6.prototype, "format", null), e([y({ type: String, json: { read: { reader: a5.read }, write: { writer: a5.write } } })], y6.prototype, "interpolation", null), e([y({ json: { write: true } })], y6.prototype, "noData", null), e([y({ type: String, json: { read: { reader: i3.read }, write: { writer: i3.write } } })], y6.prototype, "noDataInterpretation", null), e([y({ json: { write: true } })], y6.prototype, "pixelType", void 0), e([y({ json: { write: true } })], y6.prototype, "lercVersion", void 0), e([r("lercVersion")], y6.prototype, "writeLercVersion", null), e([y({ type: Number })], y6.prototype, "version", null), e([y({ json: { write: true } })], y6.prototype, "mosaicRule", null), e([y({ json: { write: true, name: "renderingRule" } })], y6.prototype, "rasterFunction", null), y6 = e([a4("esri.layers.support.ExportImageServiceParameters")], y6);

// node_modules/@arcgis/core/rest/support/CameraInfoMixin.js
var s8 = (s9) => {
  let e6 = class extends s9 {
    constructor() {
      super(...arguments), this.make = null, this.model = null, this.focalLength = null, this.pixelSize = null, this.rows = null, this.cols = null;
    }
  };
  return e([y({ json: { write: true } })], e6.prototype, "make", void 0), e([y({ json: { write: true } })], e6.prototype, "model", void 0), e([y({ json: { write: true } })], e6.prototype, "focalLength", void 0), e([y({ json: { write: true } })], e6.prototype, "pixelSize", void 0), e([y({ json: { write: true } })], e6.prototype, "rows", void 0), e([y({ json: { write: true } })], e6.prototype, "cols", void 0), e6 = e([a4("esri.rest.support.CameraInfoMixin")], e6), e6;
};

// node_modules/@arcgis/core/rest/support/ImageInspectionInfo.js
var n9 = class extends s8(f) {
  constructor() {
    super(...arguments), this.id = null, this.referenceUri = null, this.acquisitionDate = null, this.cameraID = null, this.center = null, this.perspectiveCenter = null, this.orientation = null;
  }
  writeAcquisitionDate(t5, o4) {
    o4.acquisitionDate = t5 == null ? void 0 : t5.getTime();
  }
};
e([y({ json: { write: true } })], n9.prototype, "id", void 0), e([y({ json: { name: "uri", write: true } })], n9.prototype, "referenceUri", void 0), e([y({ type: Date, json: { write: true } })], n9.prototype, "acquisitionDate", void 0), e([r("acquisitionDate")], n9.prototype, "writeAcquisitionDate", null), e([y({ json: { write: true } })], n9.prototype, "cameraID", void 0), e([y({ type: x, json: { write: true } })], n9.prototype, "center", void 0), e([y({ type: x, json: { write: true } })], n9.prototype, "perspectiveCenter", void 0), e([y({ json: { write: true } })], n9.prototype, "orientation", void 0), n9 = e([a4("esri.rest.support.ImageInspectionInfo")], n9);
var c6 = n9;

// node_modules/@arcgis/core/rest/support/FindImagesResult.js
var p6 = class extends f {
  constructor() {
    super(...arguments), this.images = null;
  }
};
e([y({ type: [c6], json: { write: true } })], p6.prototype, "images", void 0), p6 = e([a4("esri.rest.support.FindImagesResult")], p6);
var c7 = p6;

// node_modules/@arcgis/core/rest/support/ImageAngleResult.js
var p7 = class extends f {
  constructor(r2) {
    super(r2), this.north = null, this.up = null, this.spatialReference = null;
  }
};
e([y({ type: Number, json: { write: true } })], p7.prototype, "north", void 0), e([y({ type: Number, json: { write: true } })], p7.prototype, "up", void 0), e([y({ type: f2, json: { write: true } })], p7.prototype, "spatialReference", void 0), p7 = e([a4("esri.rest.support.ImageAngleResult")], p7);
var i4 = p7;

// node_modules/@arcgis/core/rest/support/BaseImageMeasureResult.js
var i5 = class extends f {
  constructor() {
    super(...arguments), this.value = null, this.displayValue = null, this.uncertainty = null;
  }
};
e([y({ type: Number, json: { read: true, write: true } })], i5.prototype, "value", void 0), e([y({ type: String, json: { read: true, write: true } })], i5.prototype, "displayValue", void 0), e([y({ type: Number, json: { read: true, write: true } })], i5.prototype, "uncertainty", void 0), i5 = e([a4("esri.rest.support.BaseImageMeasureResult.BaseImageMeasureResultValue")], i5);
var p8 = class extends i5 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
e([y({ type: String, json: { read: me.read, write: me.write } })], p8.prototype, "unit", void 0), p8 = e([a4("esri.rest.support.BaseImageMeasureResult.ImageMeasureResultLengthValue")], p8);
var n10 = class extends i5 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
e([y({ type: String, json: { read: oe.read, write: oe.write } })], n10.prototype, "unit", void 0), n10 = e([a4("esri.rest.support.BaseImageMeasureResult.ImageMeasureResultAreaValue")], n10);
var l4 = class extends i5 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
e([y({ type: String, json: { read: fe.read, write: fe.write } })], l4.prototype, "unit", void 0), l4 = e([a4("esri.rest.support.BaseImageMeasureResult.ImageMeasureResultAngleValue")], l4);
var c8 = class extends f {
  constructor() {
    super(...arguments), this.name = null, this.sensorName = null;
  }
};
e([y({ type: String, json: { read: true, write: true } })], c8.prototype, "name", void 0), e([y({ type: String, json: { read: true, write: true } })], c8.prototype, "sensorName", void 0), c8 = e([a4("esri.rest.support.BaseImageMeasureResult")], c8);

// node_modules/@arcgis/core/rest/support/ImageAreaResult.js
var a6 = class extends c8 {
  constructor() {
    super(...arguments), this.area = null, this.perimeter = null;
  }
};
e([y({ type: n10, json: { read: true, write: true } })], a6.prototype, "area", void 0), e([y({ type: p8, json: { read: true, write: true } })], a6.prototype, "perimeter", void 0), a6 = e([a4("esri.rest.support.ImageAreaResult")], a6);
var c9 = a6;

// node_modules/@arcgis/core/rest/support/ImageBoundaryResult.js
var a7 = class extends f {
  constructor() {
    super(...arguments), this.area = null, this.geometry = null;
  }
  readGeometry(r2, o4) {
    return null == r2 ? null : r2.rings ? j2.fromJSON(r2) : w.fromJSON(r2);
  }
};
e([y({ type: Number, json: { write: true } })], a7.prototype, "area", void 0), e([y({ json: { name: "shape", write: true } })], a7.prototype, "geometry", void 0), e([o2("geometry")], a7.prototype, "readGeometry", null), a7 = e([a4("esri.rest.support.ImageBoundaryResult")], a7);
var c10 = a7;

// node_modules/@arcgis/core/rest/support/ImageDistanceResult.js
var a8 = class extends c8 {
  constructor() {
    super(...arguments), this.distance = null, this.azimuthAngle = null, this.elevationAngle = null;
  }
};
e([y({ type: p8, json: { read: true, write: true } })], a8.prototype, "distance", void 0), e([y({ type: l4, json: { read: true, write: true } })], a8.prototype, "azimuthAngle", void 0), e([y({ type: l4, json: { read: true, write: true } })], a8.prototype, "elevationAngle", void 0), a8 = e([a4("esri.rest.support.ImageDistanceResult")], a8);
var i6 = a8;

// node_modules/@arcgis/core/rest/support/CameraInfo.js
var p9 = class extends s8(f) {
  constructor() {
    super(...arguments), this.id = null;
  }
};
e([y({ json: { write: true } })], p9.prototype, "id", void 0), p9 = e([a4("esri.rest.support.CameraInfo")], p9);
var c11 = p9;

// node_modules/@arcgis/core/rest/support/ImageGPSInfo.js
var p10 = class extends f {
  constructor() {
    super(...arguments), this.id = null, this.name = null, this.acquisitionDate = null, this.cameraID = null, this.center = null, this.gps = null, this.orientation = null;
  }
  writeAcquisitionDate(o4, t5) {
    t5.acquisitionDate = o4 == null ? void 0 : o4.getTime();
  }
};
e([y({ json: { write: true } })], p10.prototype, "id", void 0), e([y({ json: { write: true } })], p10.prototype, "name", void 0), e([y({ type: Date, json: { write: true } })], p10.prototype, "acquisitionDate", void 0), e([r("acquisitionDate")], p10.prototype, "writeAcquisitionDate", null), e([y({ json: { write: true } })], p10.prototype, "cameraID", void 0), e([y({ type: x, json: { write: true } })], p10.prototype, "center", void 0), e([y({ json: { write: true } })], p10.prototype, "gps", void 0), e([y({ json: { write: true } })], p10.prototype, "orientation", void 0), p10 = e([a4("esri.rest.support.ImageGPSInfo")], p10);
var n11 = p10;

// node_modules/@arcgis/core/rest/support/ImageGPSInfoResult.js
var m5 = class extends f {
  constructor() {
    super(...arguments), this.images = null, this.cameras = null;
  }
};
e([y({ type: [n11], json: { write: true } })], m5.prototype, "images", void 0), e([y({ type: [c11], json: { write: true } })], m5.prototype, "cameras", void 0), m5 = e([a4("esri.rest.support.ImageGPSInfoResult")], m5);
var a9 = m5;

// node_modules/@arcgis/core/rest/support/ImageHeightResult.js
var p11 = class extends c8 {
  constructor() {
    super(...arguments), this.height = null;
  }
};
e([y({ type: p8, json: { read: true, write: true } })], p11.prototype, "height", void 0), p11 = e([a4("esri.rest.support.ImageHeightResult")], p11);
var c12 = p11;

// node_modules/@arcgis/core/rest/support/ImageIdentifyResult.js
var p12 = class extends f {
  constructor() {
    super(...arguments), this.catalogItemVisibilities = null, this.catalogItems = null, this.location = null, this.name = null, this.objectId = null, this.processedValues = null, this.properties = null, this.value = null;
  }
};
e([y({ json: { write: true } })], p12.prototype, "catalogItemVisibilities", void 0), e([y({ type: d4, json: { write: true } })], p12.prototype, "catalogItems", void 0), e([y({ type: x, json: { write: true } })], p12.prototype, "location", void 0), e([y({ json: { write: true } })], p12.prototype, "name", void 0), e([y({ json: { write: true } })], p12.prototype, "objectId", void 0), e([y({ json: { write: true } })], p12.prototype, "processedValues", void 0), e([y({ json: { write: true } })], p12.prototype, "properties", void 0), e([y({ json: { write: true } })], p12.prototype, "value", void 0), p12 = e([a4("esri.rest.support.ImageIdentifyResult")], p12);
var l5 = p12;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationResult.js
var t4 = class extends f {
  constructor() {
    super(...arguments), this.geometries = null;
  }
};
e([y({ json: { write: true } })], t4.prototype, "geometries", void 0), t4 = e([a4("esri.rest.support.ImagePixelLocationResult")], t4);
var p13 = t4;

// node_modules/@arcgis/core/rest/support/ImagePointResult.js
var p14 = class extends c8 {
  constructor() {
    super(...arguments), this.point = null;
  }
};
e([y({ type: x, json: { name: "point.value", read: true, write: true } })], p14.prototype, "point", void 0), p14 = e([a4("esri.rest.support.ImagePointResult")], p14);
var m6 = p14;

// node_modules/@arcgis/core/rest/support/ImageSample.js
var i7 = class extends f {
  constructor() {
    super(...arguments), this.attributes = null, this.location = null, this.locationId = null, this.rasterId = null, this.resolution = null, this.pixelValue = null;
  }
};
e([y({ json: { write: true } })], i7.prototype, "attributes", void 0), e([y({ type: x, json: { write: true } })], i7.prototype, "location", void 0), e([y({ json: { write: true } })], i7.prototype, "locationId", void 0), e([y({ json: { write: true } })], i7.prototype, "rasterId", void 0), e([y({ json: { write: true } })], i7.prototype, "resolution", void 0), e([y({ json: { write: true } })], i7.prototype, "pixelValue", void 0), i7 = e([a4("esri.rest.support.ImageSample")], i7);
var p15 = i7;

// node_modules/@arcgis/core/rest/support/ImageSampleResult.js
var p16 = class extends f {
  constructor() {
    super(...arguments), this.samples = null;
  }
};
e([y({ type: [p15], json: { write: true } })], p16.prototype, "samples", void 0), p16 = e([a4("esri.rest.support.ImageSampleResult")], p16);
var m7 = p16;

// node_modules/@arcgis/core/rest/support/ImageUrlResult.js
var e5 = class extends f {
  constructor() {
    super(...arguments), this.url = null;
  }
};
e([y({ json: { name: "imageURL", write: true } })], e5.prototype, "url", void 0), e5 = e([a4("esri.rest.support.ImageUrlResult")], e5);
var p17 = e5;

// node_modules/@arcgis/core/rest/support/MeasureAreaFromImageResult.js
var m8 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.length = null, this.area = null, this.center = null;
  }
  readCenter(e6, r2) {
    return e6.spatialReference || (e6 = { ...e6, spatialReference: r2.Shape.spatialReference }), x.fromJSON(e6);
  }
};
e([y({ types: n3, json: { name: "Shape", read: y2, write: true } })], m8.prototype, "geometry", void 0), e([y({ json: { name: "Length", write: true } })], m8.prototype, "length", void 0), e([y({ json: { name: "Area", write: true } })], m8.prototype, "area", void 0), e([y({ json: { name: "Center", write: true } })], m8.prototype, "center", void 0), e([o2("center")], m8.prototype, "readCenter", null), m8 = e([a4("esri.rest.support.MeasureAreaFromImageResult")], m8);
var i8 = m8;

// node_modules/@arcgis/core/rest/support/MeasureLengthFromImageResult.js
var m9 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.length = null;
  }
};
e([y({ types: n3, json: { name: "Shape", read: y2, write: true } })], m9.prototype, "geometry", void 0), e([y({ json: { name: "Length", write: true } })], m9.prototype, "length", void 0), m9 = e([a4("esri.rest.support.MeasureLengthFromImageResult")], m9);
var c13 = m9;

// node_modules/@arcgis/core/rest/imageService.js
function O(t5) {
  const e6 = t5 == null ? void 0 : t5.time;
  if (e6 && (null != e6.start || null != e6.end)) {
    const o4 = [];
    null != e6.start && o4.push(e6.start), null == e6.end || o4.includes(e6.end) || o4.push(e6.end), t5.time = o4.join(",");
  }
}
async function w3(t5, o4, s9) {
  const i10 = f5(t5), m13 = o4.geometry ? [o4.geometry] : [], u7 = await R(m13), c22 = o4.toJSON();
  O(c22);
  const l11 = u7 == null ? void 0 : u7[0];
  null != l11 && (c22.geometry = A4(l11));
  const f9 = s3({ ...i10.query, f: "json", ...c22 });
  return i2(f9, s9);
}
async function J(e6, o4, s9) {
  var _a, _b, _c;
  const m13 = o4.toJSON();
  null != m13.angleName && (m13.angleName = m13.angleName.join(",")), ((_b = (_a = o4 == null ? void 0 : o4.point) == null ? void 0 : _a.spatialReference) == null ? void 0 : _b.imageCoordinateSystem) && (m13.point.spatialReference = H(o4.point.spatialReference)), ((_c = o4 == null ? void 0 : o4.spatialReference) == null ? void 0 : _c.imageCoordinateSystem) && (m13.spatialReference = T3(o4.spatialReference));
  const u7 = f5(e6), c22 = s3({ ...u7.query, f: "json", ...m13 }), l11 = i2(c22, s9), { data: f9 } = await U(`${u7.path}/computeAngles`, l11);
  return f9.spatialReference = f9.spatialReference ? null != f9.spatialReference.geodataXform ? new f2({ wkid: 0, imageCoordinateSystem: f9.spatialReference }) : f2.fromJSON(f9.spatialReference) : null, "NaN" === f9.north && (f9.north = null), "NaN" === f9.up && (f9.up = null), new i4(f9);
}
async function I2(e6, o4, s9) {
  var _a;
  const i10 = o4.toJSON(), { geometries: m13 } = o4;
  if (m13)
    for (let t5 = 0; t5 < m13.length; t5++)
      ((_a = m13[t5].spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (i10.geometries.geometries[t5].spatialReference = H(m13[t5].spatialReference));
  const u7 = f5(e6), c22 = s3({ ...u7.query, f: "json", ...i10 }), l11 = i2(c22, s9), { data: f9 } = await U(`${u7.path}/computePixelLocation`, l11);
  return p13.fromJSON(f9);
}
async function q(e6, o4, a14) {
  const r2 = await w3(e6, o4, a14), s9 = f5(e6), { data: i10 } = await U(`${s9.path}/computeStatisticsHistograms`, r2), { statistics: m13 } = i10;
  return (m13 == null ? void 0 : m13.length) && m13.forEach((t5) => {
    t5.avg = t5.mean, t5.stddev = t5.standardDeviation;
  }), { statistics: m13, histograms: i10.histograms };
}
async function G2(e6, o4, a14) {
  const r2 = await w3(e6, o4, a14), s9 = f5(e6), { data: i10 } = await U(`${s9.path}/computeHistograms`, r2);
  return { histograms: i10.histograms };
}
async function $(o4, s9, i10) {
  var _a, _b;
  const m13 = s9.toJSON();
  O(m13), ((_a = m13.outFields) == null ? void 0 : _a.length) && (m13.outFields = m13.outFields.join(","));
  const u7 = await R(s9.geometry), c22 = u7 == null ? void 0 : u7[0];
  null != c22 && (m13.geometry = A4(c22));
  const l11 = f5(o4), f9 = s3({ ...l11.query, f: "json", ...m13 }), p20 = i2(f9, i10), { data: y14 } = await U(`${l11.path}/getSamples`, p20), g6 = (_b = y14 == null ? void 0 : y14.samples) == null ? void 0 : _b.map((t5) => {
    const e6 = "NaN" === t5.value || "" === t5.value ? null : t5.value.split(" ").map((t6) => Number(t6));
    return { ...t5, pixelValue: e6 };
  });
  return m7.fromJSON({ samples: g6 });
}
async function C2(o4, s9, i10) {
  const m13 = f5(o4), u7 = s9.geometry ? [s9.geometry] : [];
  return R(u7).then((e6) => {
    const o5 = s9.toJSON(), n16 = e6 == null ? void 0 : e6[0];
    null != n16 && (o5.geometry = JSON.stringify(A4(n16)));
    const u8 = s3({ ...m13.query, f: "json", ...o5 }), c22 = i2(u8, i10);
    return U(m13.path + "/identify", c22);
  }).then((t5) => l5.fromJSON(t5.data));
}
async function b5(t5, e6, o4) {
  const n16 = await M(t5, e6, [e6.fromGeometry, e6.toGeometry], o4);
  return c12.fromJSON(n16);
}
async function v3(t5, e6, o4) {
  const n16 = await M(t5, e6, [e6.geometry], o4);
  return c9.fromJSON(n16);
}
async function F2(t5, e6, o4) {
  const n16 = await M(t5, e6, [e6.geometry], o4);
  return m6.fromJSON(n16);
}
async function L(t5, e6, o4) {
  const n16 = await M(t5, e6, [e6.fromGeometry, e6.toGeometry], o4);
  return i6.fromJSON(n16);
}
async function M(o4, s9, i10, m13) {
  const u7 = f5(o4), c22 = await R(i10), l11 = s9.toJSON();
  null != c22[0] && (l11.fromGeometry = JSON.stringify(A4(c22[0]))), null != c22[1] && (l11.toGeometry = JSON.stringify(A4(c22[1])));
  const f9 = s3({ ...u7.query, f: "json", ...l11 }), p20 = i2(f9, m13), { data: y14 } = await U(u7.path + "/measure", p20);
  return y14;
}
async function P3(t5, e6, o4) {
  const n16 = await x3(t5, e6, o4);
  return c13.fromJSON(n16);
}
async function U3(t5, e6, o4) {
  const n16 = await x3(t5, e6, o4);
  return i8.fromJSON(n16);
}
async function x3(e6, o4, s9) {
  const i10 = f5(e6), m13 = o4.toJSON(), u7 = s3({ ...i10.query, f: "json", ...m13 }), c22 = i2(u7, s9), { data: l11 } = await U(i10.path + "/measureFromImage", c22);
  return l11;
}
function A4(t5) {
  var _a;
  const e6 = t5.toJSON();
  return ((_a = t5.spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (e6.spatialReference = H(t5.spatialReference)), e6;
}
function H(t5) {
  const { imageCoordinateSystem: e6 } = t5;
  if (e6) {
    const { id: t6, referenceServiceName: o4 } = e6;
    return null != t6 ? o4 ? { icsid: t6, icsns: o4 } : { icsid: t6 } : { ics: e6 };
  }
  return t5.toJSON();
}
function T3(t5, e6) {
  if (!t5.imageCoordinateSystem)
    return d2(t5);
  const n16 = H(t5), { icsid: a14, icsns: r2 } = n16;
  return null == a14 || null != r2 && !(e6 == null ? void 0 : e6.toLowerCase().includes("/" + r2.toLowerCase() + "/")) ? JSON.stringify(n16) : `0:${a14}`;
}
async function B2(e6, o4, s9) {
  const i10 = f5(e6), m13 = o4.toJSON();
  o4.outSpatialReference && (m13.outSR = T3(o4.outSpatialReference));
  const c22 = s3({ ...i10.query, f: "json", ...m13 }), l11 = i2(c22, s9), { data: f9 } = await U(i10.path + "/queryBoundary", l11);
  return c10.fromJSON(f9);
}
async function D(o4, s9, i10) {
  var _a, _b;
  const m13 = s9.toJSON();
  O(m13), ((_a = m13.objectIds) == null ? void 0 : _a.length) && (m13.objectIds = m13.objectIds.join(",")), m13.geometry || m13.objectIds || m13.time || m13.where || (m13.where = "1=1");
  const u7 = await R(s9.geometry), c22 = u7 == null ? void 0 : u7[0];
  null != c22 && (m13.geometry = A4(c22));
  const f9 = (c22 == null ? void 0 : c22.spatialReference) ?? ((_b = s9.geometry) == null ? void 0 : _b.spatialReference);
  f9 && (m13.inSR = T3(f9));
  const p20 = f5(o4), y14 = s3({ ...p20.query, f: "json", ...m13 }), g6 = i2(y14, i10), { data: d12 } = await U(`${p20.path}/queryGPSInfo`, g6);
  return a9.fromJSON(d12);
}
async function k3(e6, o4, s9) {
  const i10 = o4.toJSON();
  o4.geometry.spatialReference.imageCoordinateSystem && (i10.geometry = A4(o4.geometry)), o4.depthOffset && o4.adjust || delete i10.options;
  const m13 = f5(e6), u7 = s3({ ...m13.query, f: "json", ...i10 }), c22 = i2(u7, s9), { data: l11 } = await U(`${m13.path}/imageToMap`, c22);
  return y2(l11);
}
async function z(e6, o4, s9) {
  var _a;
  const i10 = o4.toJSON();
  ((_a = o4.rasterIds) == null ? void 0 : _a.length) && (i10.rasterIds = o4.rasterIds.join(","));
  const m13 = f5(e6), u7 = s3({ ...m13.query, f: "json", ...i10 }), c22 = i2(u7, s9), { data: l11 } = await U(`${m13.path}/imageToMapMultiray`, c22);
  return y2(l11);
}
async function E2(o4, s9, i10) {
  var _a;
  const m13 = s9.toJSON(), u7 = await R(s9.geometry), c22 = u7 == null ? void 0 : u7[0];
  null != c22 && (m13.geometry = A4(c22)), s9.visibleOnly || delete m13.options;
  const l11 = (c22 == null ? void 0 : c22.spatialReference) ?? ((_a = s9.geometry) == null ? void 0 : _a.spatialReference);
  l11 && (m13.inSR = T3(l11));
  const f9 = f5(o4), p20 = s3({ ...f9.query, f: "json", ...m13 }), y14 = i2(p20, i10), { data: g6 } = await U(`${f9.path}/mapToImage`, y14);
  return y2(g6);
}
async function V3(e6, o4, s9) {
  const i10 = o4.toJSON(), m13 = f5(e6), u7 = s3({ ...m13.query, f: "json", ...i10 }), c22 = i2(u7, s9), { data: l11 } = await U(`${m13.path}/getImageUrl`, c22);
  return p17.fromJSON(l11);
}
async function X(o4, i10, m13) {
  var _a;
  const u7 = i10.toJSON(), c22 = await R([i10.fromGeometry, i10.toGeometry]);
  null != c22[0] && (u7.fromGeometry = A4(c22[0]), c22[0].spatialReference && (u7.inSR = T3(c22[0].spatialReference))), null != c22[1] && (u7.toGeometry = A4(c22[1])), ((_a = i10.objectIds) == null ? void 0 : _a.length) && (u7.objectIds = u7.objectIds.join(","));
  const l11 = f5(o4), f9 = s3({ ...l11.query, f: "json", ...u7 }), p20 = i2(f9, m13), { data: y14 } = await U(`${l11.path}/find`, p20);
  return c7.fromJSON(y14);
}

// node_modules/@arcgis/core/rest/imageService/getCatalogItemRasterInfo.js
async function n12(n16, m13, p20) {
  var _a, _b;
  const f9 = f5(n16), u7 = s3({ ...f9 == null ? void 0 : f9.query, f: "json" }), h4 = i2(u7, p20), d12 = `${f9 == null ? void 0 : f9.path}/${m13}/info`, c22 = U(`${d12}`, h4), g6 = U(`${d12}/keyProperties`, h4), x5 = await Promise.allSettled([c22, g6]), y14 = "fulfilled" === x5[0].status ? x5[0].value.data : null, v4 = "fulfilled" === x5[1].status ? x5[1].value.data : null;
  let P4 = null;
  ((_a = y14.statistics) == null ? void 0 : _a.length) && (P4 = y14.statistics.map((e6) => ({ min: e6[0], max: e6[1], avg: e6[2], stddev: e6[3] })));
  const S3 = w.fromJSON(y14.extent), j8 = Math.ceil(S3.width / y14.pixelSizeX - 0.1), w4 = Math.ceil(S3.height / y14.pixelSizeY - 0.1), b6 = S3.spatialReference, k4 = new x({ x: y14.pixelSizeX, y: y14.pixelSizeY, spatialReference: b6 }), z2 = ((_b = y14.histograms) == null ? void 0 : _b.length) ? y14.histograms : null, L2 = new n6({ origin: y14.origin, blockWidth: y14.blockWidth, blockHeight: y14.blockHeight, firstPyramidLevel: y14.firstPyramidLevel, maximumPyramidLevel: y14.maxPyramidLevel });
  return new m({ width: j8, height: w4, bandCount: y14.bandCount, extent: S3, spatialReference: b6, pixelSize: k4, pixelType: y14.pixelType.toLowerCase(), statistics: P4, histograms: z2, keyProperties: v4, storageInfo: L2 });
}

// node_modules/@arcgis/core/rest/support/FindImagesParameters.js
var i9 = class extends i(f) {
  constructor() {
    super(...arguments), this.fromGeometry = null, this.toGeometry = null, this.objectIds = null, this.where = null, this.maxCount = null;
  }
};
e([y({ type: x, json: { read: true } })], i9.prototype, "fromGeometry", void 0), e([y({ type: x, json: { read: true, write: true } })], i9.prototype, "toGeometry", void 0), e([y({ json: { write: true } })], i9.prototype, "objectIds", void 0), e([y({ type: String, json: { write: true } })], i9.prototype, "where", void 0), e([y({ type: Number, json: { write: true } })], i9.prototype, "maxCount", void 0), i9 = e([a4("esri.rest.support.FindImagesParameters")], i9);
var m10 = i9;

// node_modules/@arcgis/core/rest/support/ImageAngleParameters.js
var n13;
var m11 = n13 = class extends f {
  constructor(e6) {
    super(e6), this.angleNames = null, this.point = null, this.spatialReference = null, this.rasterId = null;
  }
  clone() {
    return new n13(a({ angleNames: this.angleNames, point: this.point, spatialReference: this.spatialReference, rasterId: this.rasterId }));
  }
};
e([y({ type: [String], json: { name: "angleName", write: true } })], m11.prototype, "angleNames", void 0), e([y({ type: x, json: { write: true } })], m11.prototype, "point", void 0), e([y({ type: f2, json: { write: true } })], m11.prototype, "spatialReference", void 0), e([y({ type: T, json: { write: true } })], m11.prototype, "rasterId", void 0), m11 = n13 = e([a4("esri.rest.support.ImageAngleParameters")], m11);
var l6 = m11;

// node_modules/@arcgis/core/rest/support/BaseImageMeasureParameters.js
var a10 = new n2({ esriMensurationPoint: "point", esriMensurationCentroid: "centroid", esriMensurationDistanceAndAngle: "distance-and-angle", esriMensurationAreaAndPerimeter: "area-and-perimeter", esriMensurationHeightFromBaseAndTop: "base-and-top", esriMensurationHeightFromBaseAndTopShadow: "base-and-top-shadow", esriMensurationHeightFromTopAndTopShadow: "top-and-top-shadow", esriMensurationPoint3D: "point-3D", esriMensurationCentroid3D: "centroid-3D", esriMensurationDistanceAndAngle3D: "distance-and-angle-3D", esriMensurationAreaAndPerimeter3D: "area-and-perimeter-3D" });
var p18 = class extends f {
  constructor() {
    super(...arguments), this.type = null, this.measureOperation = null, this.mosaicRule = null, this.pixelSize = null, this.raster = void 0;
  }
};
e([y()], p18.prototype, "type", void 0), e([y({ type: a10.apiValues, json: { read: a10.read, write: a10.write } })], p18.prototype, "measureOperation", void 0), e([y({ type: j5, json: { write: true } })], p18.prototype, "mosaicRule", void 0), e([y({ type: x, json: { write: true } })], p18.prototype, "pixelSize", void 0), e([y({ json: { write: true } })], p18.prototype, "raster", void 0), p18 = e([a4("esri.rest.support.BaseImageMeasureParameters")], p18);

// node_modules/@arcgis/core/rest/support/ImageAreaParameters.js
var c14;
var u3 = c14 = class extends p18 {
  constructor() {
    super(...arguments), this.type = "area-perimeter", this.geometry = null, this.is3D = false, this.linearUnit = "meters", this.areaUnit = "square-meters";
  }
  writeGeometry(e6, r2, t5) {
    null != e6 && (r2.geometryType = p(e6), r2[t5] = e6.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "area-and-perimeter-3D" : "area-and-perimeter";
  }
  clone() {
    return new c14(a({ geometry: this.geometry, is3D: this.is3D, linearUnit: this.linearUnit, areaUnit: this.areaUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
e([y({ types: n3, json: { name: "fromGeometry", read: true, write: true } })], u3.prototype, "geometry", void 0), e([r("geometry")], u3.prototype, "writeGeometry", null), e([y({ type: a10.apiValues, json: { write: a10.write } })], u3.prototype, "measureOperation", null), e([y({ json: { read: true } })], u3.prototype, "is3D", void 0), e([y({ type: String, json: { read: me.read, write: me.write } })], u3.prototype, "linearUnit", void 0), e([y({ type: String, json: { read: oe.read, write: oe.write } })], u3.prototype, "areaUnit", void 0), u3 = c14 = e([a4("esri.rest.support.ImageAreaParameters")], u3);
var y7 = u3;

// node_modules/@arcgis/core/rest/support/ImageBoundaryParameters.js
var a11 = class extends i(f) {
  constructor() {
    super(...arguments), this.outSpatialReference = null;
  }
};
e([y({ type: f2, json: { name: "outSR", write: true } })], a11.prototype, "outSpatialReference", void 0), a11 = e([a4("esri.rest.support.ImageBoundaryParameters")], a11);
var c15 = a11;

// node_modules/@arcgis/core/rest/support/ImageDistanceParameters.js
var y8;
var c16 = y8 = class extends p18 {
  constructor() {
    super(...arguments), this.type = "distance-angle", this.fromGeometry = null, this.toGeometry = null, this.is3D = false, this.linearUnit = "meters", this.angularUnit = "degrees";
  }
  writeFromGeometry(e6, r2, t5) {
    null != e6 && (r2.geometryType = p(e6), r2[t5] = e6.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "distance-and-angle-3D" : "distance-and-angle";
  }
  clone() {
    return new y8(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, is3D: this.is3D, linearUnit: this.linearUnit, angularUnit: this.angularUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
e([y({ type: x, json: { read: true, write: true } })], c16.prototype, "fromGeometry", void 0), e([r("fromGeometry")], c16.prototype, "writeFromGeometry", null), e([y({ type: x, json: { read: true, write: true } })], c16.prototype, "toGeometry", void 0), e([y({ type: a10.apiValues, json: { write: a10.write } })], c16.prototype, "measureOperation", null), e([y({ json: { read: true } })], c16.prototype, "is3D", void 0), e([y({ type: String, json: { read: me.read, write: me.write } })], c16.prototype, "linearUnit", void 0), e([y({ type: String, json: { read: fe.read, write: fe.write } })], c16.prototype, "angularUnit", void 0), c16 = y8 = e([a4("esri.rest.support.ImageDistanceParameters")], c16);
var u4 = c16;

// node_modules/@arcgis/core/rest/support/ImageGPSInfoParameters.js
var j6 = class extends i(f) {
  constructor() {
    super(...arguments), this.geometry = null, this.objectIds = null, this.spatialRelationship = "intersects", this.timeExtent = null, this.where = null;
  }
  writeGeometry(o4, t5, r2) {
    null != o4 && (t5.geometryType = p(o4), t5[r2] = JSON.stringify(o4.toJSON()));
  }
};
e([y({ types: n3, json: { read: y2, write: true } })], j6.prototype, "geometry", void 0), e([r("geometry")], j6.prototype, "writeGeometry", null), e([y({ json: { write: true } })], j6.prototype, "objectIds", void 0), e([o3(s2, { ignoreUnknown: false, name: "spatialRel" })], j6.prototype, "spatialRelationship", void 0), e([y({ type: c, json: { name: "time", write: true } })], j6.prototype, "timeExtent", void 0), e([y({ type: String, json: { write: true } })], j6.prototype, "where", void 0), j6 = e([a4("esri.rest.support.ImageGPSInfoParameters")], j6);
var y9 = j6;

// node_modules/@arcgis/core/rest/support/ImageHeightParameters.js
var y10;
var l7 = y10 = class extends p18 {
  constructor() {
    super(...arguments), this.type = "height", this.fromGeometry = null, this.toGeometry = null, this.operationType = "base-and-top", this.linearUnit = "meters";
  }
  writeFromGeometry(e6, r2, t5) {
    null != e6 && (r2.geometryType = p(e6), r2[t5] = e6.toJSON());
  }
  get measureOperation() {
    return this.operationType;
  }
  clone() {
    return new y10(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, operationType: this.operationType, linearUnit: this.linearUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
e([y({ type: x, json: { read: true } })], l7.prototype, "fromGeometry", void 0), e([r("fromGeometry")], l7.prototype, "writeFromGeometry", null), e([y({ type: x, json: { read: true, write: true } })], l7.prototype, "toGeometry", void 0), e([y({ type: a10.apiValues, json: { write: a10.write } })], l7.prototype, "measureOperation", null), e([y({ json: { read: true } })], l7.prototype, "operationType", void 0), e([y({ type: String, json: { read: me.read, write: me.write } })], l7.prototype, "linearUnit", void 0), l7 = y10 = e([a4("esri.rest.support.ImageHeightParameters")], l7);
var c17 = l7;

// node_modules/@arcgis/core/rest/support/ImageIdentifyParameters.js
var y11;
var g5 = y11 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterFunctions = null, this.pixelSize = null, this.returnGeometry = true, this.returnCatalogItems = true, this.returnPixelValues = true, this.maxItemCount = null, this.timeExtent = null, this.raster = void 0, this.viewId = void 0, this.processAsMultidimensional = false;
  }
  writeGeometry(t5, e6, r2) {
    null != t5 && (e6.geometryType = p(t5), e6[r2] = JSON.stringify(t5.toJSON()));
  }
  set mosaicRule(t5) {
    let e6 = t5;
    (e6 == null ? void 0 : e6.mosaicMethod) && (e6 = j5.fromJSON({ ...e6.toJSON(), mosaicMethod: e6.mosaicMethod, mosaicOperation: e6.mosaicOperation })), this._set("mosaicRule", e6);
  }
  writeMosaicRule(t5, e6, r2) {
    null != t5 && (e6[r2] = JSON.stringify(t5.toJSON()));
  }
  get renderingRule() {
    return o(n.getLogger(this), "renderingRule", { replacement: "rasterFunction", version: "4.27", warnOnce: true }), this._get("rasterFunction");
  }
  set renderingRule(t5) {
    o(n.getLogger(this), "renderingRule", { replacement: "rasterFunction", version: "4.27", warnOnce: true }), this._set("rasterFunction", t5);
  }
  get renderingRules() {
    return o(n.getLogger(this), "renderingRules", { replacement: "rasterFunctions", version: "4.27", warnOnce: true }), this._get("rasterFunctions");
  }
  set renderingRules(t5) {
    o(n.getLogger(this), "renderingRules", { replacement: "rasterFunctions", version: "4.27", warnOnce: true }), this._set("rasterFunctions", t5);
  }
  set rasterFunction(t5) {
    let e6 = t5;
    (e6 == null ? void 0 : e6.rasterFunction) && (e6 = N.fromJSON({ ...e6.toJSON(), rasterFunction: e6.rasterFunction, rasterFunctionArguments: e6.rasterFunctionArguments })), this._set("rasterFunction", e6);
  }
  writeRasterFunction(t5, e6, r2) {
    null != t5 && (e6[r2] = JSON.stringify(t5.toJSON())), t5.rasterFunctionDefinition && (e6[r2] = JSON.stringify(t5.rasterFunctionDefinition));
  }
  writeRasterFunctions(t5, e6, r2) {
    null != t5 && (e6[r2] = JSON.stringify(t5.map((t6) => t6.rasterFunctionDefinition || t6.toJSON())));
  }
  writePixelSize(t5, e6, r2) {
    null != t5 && (e6[r2] = JSON.stringify(t5));
  }
  writeTimeExtent(t5, e6, r2) {
    if (null != t5) {
      const o4 = null != t5.start ? t5.start.getTime() : null, i10 = null != t5.end ? t5.end.getTime() : null;
      e6[r2] = null != o4 ? null != i10 ? `${o4},${i10}` : `${o4}` : null;
    }
  }
  clone() {
    return new y11(a({ geometry: this.geometry, mosaicRule: this.mosaicRule, rasterFunction: this.rasterFunction, rasterFunctions: this.rasterFunctions, pixelSize: this.pixelSize, returnGeometry: this.returnGeometry, returnCatalogItems: this.returnCatalogItems, returnPixelValues: this.returnPixelValues, maxItemCount: this.maxItemCount, processAsMultidimensional: this.processAsMultidimensional, raster: this.raster, viewId: this.viewId, timeExtent: this.timeExtent }));
  }
};
e([y({ json: { write: true } })], g5.prototype, "geometry", void 0), e([r("geometry")], g5.prototype, "writeGeometry", null), e([y({ type: j5, json: { write: true } })], g5.prototype, "mosaicRule", null), e([r("mosaicRule")], g5.prototype, "writeMosaicRule", null), e([y({ type: N })], g5.prototype, "renderingRule", null), e([y({ type: [N] })], g5.prototype, "renderingRules", null), e([y({ type: N, json: { write: true, name: "renderingRule" } })], g5.prototype, "rasterFunction", null), e([r("rasterFunction")], g5.prototype, "writeRasterFunction", null), e([y({ type: [N], json: { write: true, name: "renderingRules" } })], g5.prototype, "rasterFunctions", void 0), e([r("rasterFunctions")], g5.prototype, "writeRasterFunctions", null), e([y({ type: x, json: { write: true } })], g5.prototype, "pixelSize", void 0), e([r("pixelSize")], g5.prototype, "writePixelSize", null), e([y({ type: Boolean, json: { write: true } })], g5.prototype, "returnGeometry", void 0), e([y({ type: Boolean, json: { write: true } })], g5.prototype, "returnCatalogItems", void 0), e([y({ type: Boolean, json: { write: true } })], g5.prototype, "returnPixelValues", void 0), e([y({ type: Number, json: { write: true } })], g5.prototype, "maxItemCount", void 0), e([y({ type: c, json: { write: { target: "time" } } })], g5.prototype, "timeExtent", void 0), e([r("timeExtent")], g5.prototype, "writeTimeExtent", null), e([y({ json: { write: true } })], g5.prototype, "raster", void 0), e([y({ json: { write: true } })], g5.prototype, "viewId", void 0), e([y({ type: Boolean, json: { write: true } })], g5.prototype, "processAsMultidimensional", void 0), g5 = y11 = e([a4("esri.rest.support.ImageIdentifyParameters")], g5);
var d10 = g5;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationParameters.js
var m12;
var c18 = m12 = class extends f {
  constructor() {
    super(...arguments), this.geometries = null, this.rasterId = null;
  }
  writeGeometry(r2, e6, o4) {
    e6.geometries = { geometryType: "esriGeometryPoint", geometries: r2.map((r3) => r3.toJSON()) };
  }
  clone() {
    var _a;
    return new m12({ geometries: ((_a = this.geometries) == null ? void 0 : _a.map((r2) => r2.clone())) ?? [], rasterId: this.rasterId });
  }
};
e([y({ type: [x], json: { write: true } })], c18.prototype, "geometries", void 0), e([r("geometries")], c18.prototype, "writeGeometry", null), e([y({ type: T, json: { write: true } })], c18.prototype, "rasterId", void 0), c18 = m12 = e([a4("esri.rest.support.ImagePixelLocationParameters")], c18);
var a12 = c18;

// node_modules/@arcgis/core/rest/support/ImagePointParameters.js
var c19;
var u5 = c19 = class extends p18 {
  constructor() {
    super(...arguments), this.type = "point", this.geometry = null, this.is3D = false;
  }
  writeGeometry(e6, r2, o4) {
    null != e6 && (r2.geometryType = p(e6), r2[o4] = e6.toJSON());
  }
  get measureOperation() {
    const { is3D: e6, geometry: r2 } = this;
    return "point" === r2.type ? e6 ? "point-3D" : "point" : e6 ? "centroid-3D" : "centroid";
  }
  clone() {
    return new c19(a({ geometry: this.geometry, is3D: this.is3D, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
e([y({ types: n3, json: { name: "fromGeometry", read: y2 } })], u5.prototype, "geometry", void 0), e([r("geometry")], u5.prototype, "writeGeometry", null), e([y({ type: a10.apiValues, json: { read: a10.read, write: a10.write } })], u5.prototype, "measureOperation", null), e([y({ json: { read: true } })], u5.prototype, "is3D", void 0), u5 = c19 = e([a4("esri.rest.support.ImagePointParameters")], u5);
var y12 = u5;

// node_modules/@arcgis/core/rest/support/ImageSampleParameters.js
var d11;
var j7 = d11 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.interpolation = "nearest", this.mosaicRule = null, this.outFields = null, this.pixelSize = null, this.returnFirstValueOnly = true, this.sampleDistance = null, this.sampleCount = null, this.sliceId = null, this.timeExtent = null;
  }
  writeGeometry(t5, e6, o4) {
    null != t5 && (e6.geometryType = p(t5), e6[o4] = t5.toJSON());
  }
  set locations(t5) {
    if (t5 == null ? void 0 : t5.length) {
      const e6 = new u({ spatialReference: t5[0].spatialReference, points: t5.map(({ x: t6, y: e7 }) => [t6, e7]) });
      this._set("locations", t5), this.geometry = e6;
    }
  }
  clone() {
    return new d11(a({ geometry: this.geometry, locations: this.locations, interpolation: this.interpolation, mosaicRule: this.mosaicRule, outFields: this.outFields, raster: this.raster, returnFirstValueOnly: this.returnFirstValueOnly, sampleDistance: this.sampleDistance, sampleCount: this.sampleCount, sliceId: this.sliceId, pixelSize: this.pixelSize, timeExtent: this.timeExtent }));
  }
};
e([y({ types: n3, json: { read: y2 } })], j7.prototype, "geometry", void 0), e([r("geometry")], j7.prototype, "writeGeometry", null), e([y()], j7.prototype, "locations", null), e([y({ type: String, json: { type: a5.jsonValues, read: a5.read, write: a5.write } })], j7.prototype, "interpolation", void 0), e([y({ type: j5, json: { write: true } })], j7.prototype, "mosaicRule", void 0), e([y({ type: [String], json: { write: true } })], j7.prototype, "outFields", void 0), e([y({ type: x, json: { write: true } })], j7.prototype, "pixelSize", void 0), e([y({ type: String, json: { write: true } })], j7.prototype, "raster", void 0), e([y({ type: Boolean, json: { write: true } })], j7.prototype, "returnFirstValueOnly", void 0), e([y({ type: Number, json: { write: true } })], j7.prototype, "sampleDistance", void 0), e([y({ type: Number, json: { write: true } })], j7.prototype, "sampleCount", void 0), e([y({ type: Number, json: { write: true } })], j7.prototype, "sliceId", void 0), e([y({ type: c, json: { read: { source: "time" }, write: { target: "time" } } })], j7.prototype, "timeExtent", void 0), j7 = d11 = e([a4("esri.rest.support.ImageSampleParameters")], j7);
var h3 = j7;

// node_modules/@arcgis/core/rest/support/ImageToMapMultirayParameters.js
var l8 = class extends i(f) {
  constructor() {
    super(...arguments), this.geometries = [], this.rasterIds = null, this.outSpatialReference = null;
  }
  writeGeometries(e6, r2, o4) {
    r2.geometries = (e6 == null ? void 0 : e6.length) ? { geometryType: p(e6[0]), geometries: e6.map((e7) => ({ ...e7.toJSON(), spatialReference: void 0 })) } : null;
  }
};
e([y({ types: [n3] })], l8.prototype, "geometries", void 0), e([r("geometries")], l8.prototype, "writeGeometries", null), e([y({ type: [T], json: { write: true } })], l8.prototype, "rasterIds", void 0), e([y({ type: f2, json: { name: "outSR", write: true } })], l8.prototype, "outSpatialReference", void 0), l8 = e([a4("esri.rest.support.ImageToMapMultirayParameters")], l8);
var u6 = l8;

// node_modules/@arcgis/core/rest/support/ImageToMapParameters.js
var n14 = class extends i(f) {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = null, this.outSpatialReference = null, this.depthOffset = 0, this.adjust = false;
  }
  writeGeometry(o4, e6, r2) {
    null != o4 && (e6.geometryType = p(o4), e6[r2] = { ...o4.toJSON(), spatialReference: void 0 });
  }
};
e([y({ types: n3, json: { read: y2, write: true } })], n14.prototype, "geometry", void 0), e([r("geometry")], n14.prototype, "writeGeometry", null), e([y({ json: { write: true } })], n14.prototype, "rasterId", void 0), e([y({ type: f2, json: { name: "outSR", write: true } })], n14.prototype, "outSpatialReference", void 0), e([y({ json: { name: "options.DOff", write: true } })], n14.prototype, "depthOffset", void 0), e([y({ json: { name: "options.Adjust", write: true } })], n14.prototype, "adjust", void 0), n14 = e([a4("esri.rest.support.ImageToMapParameters")], n14);
var l9 = n14;

// node_modules/@arcgis/core/rest/support/ImageUrlParameters.js
var p19 = class extends i(f) {
  constructor() {
    super(...arguments), this.referenceUri = null;
  }
};
e([y({ type: String, json: { name: "uri", write: true } })], p19.prototype, "referenceUri", void 0), p19 = e([a4("esri.rest.support.ImageUrlParameters")], p19);
var c20 = p19;

// node_modules/@arcgis/core/rest/support/MapToImageParameters.js
var a13 = class extends i(f) {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = null, this.visibleOnly = false;
  }
  writeGeometry(r2, o4, e6) {
    null != r2 && (o4.geometryType = p(r2), o4[e6] = JSON.stringify(r2));
  }
};
e([y({ types: n3, json: { read: y2, write: true } })], a13.prototype, "geometry", void 0), e([r("geometry")], a13.prototype, "writeGeometry", null), e([y({ json: { write: true } })], a13.prototype, "rasterId", void 0), e([y({ json: { name: "options.VisibleOnly", write: true } })], a13.prototype, "visibleOnly", void 0), a13 = e([a4("esri.rest.support.MapToImageParameters")], a13);
var l10 = a13;

// node_modules/@arcgis/core/rest/support/MeasureFromImageParameters.js
var c21;
var n15 = c21 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = void 0;
  }
  writeGeometry(r2, o4, e6) {
    null != r2 && (o4.geometryType = p(r2), o4[e6] = { ...r2.toJSON(), spatialReference: void 0 });
  }
  clone() {
    const r2 = a({ geometry: this.geometry, rasterId: this.rasterId });
    return new c21(r2);
  }
};
e([y({ types: n3, json: { name: "fromGeometry", read: y2, write: true } })], n15.prototype, "geometry", void 0), e([r("geometry")], n15.prototype, "writeGeometry", null), e([y({ json: { write: true } })], n15.prototype, "rasterId", void 0), n15 = c21 = e([a4("esri.rest.support.MeasureFromImageParameters")], n15);
var y13 = n15;

// node_modules/@arcgis/core/layers/mixins/ArcGISImageService.js
var ze = /* @__PURE__ */ new Set(["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"]);
var Ge = j(a3, { min: 0, max: 255 });
function ke(e6) {
  if (!e6)
    return null;
  const t5 = JSON.stringify(e6).match(/"rasterFunction":"(.*?")/gi), r2 = t5 == null ? void 0 : t5.map((e7) => e7.replace('"rasterFunction":"', "").replace('"', ""));
  return r2 ? r2.join("/") : null;
}
var We = (d12) => {
  let f9 = class extends d12 {
    constructor() {
      super(...arguments), this._functionRasterInfos = {}, this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this._cachedRendererJson = null, this._serviceSupportsMosaicRule = null, this._rasterAttributeTableFieldPrefix = "Raster.", this.adjustAspectRatio = null, this.bandIds = void 0, this.capabilities = null, this.compressionQuality = void 0, this.compressionTolerance = 0.01, this.copyright = null, this.defaultMosaicRule = null, this.definitionExpression = null, this.exportImageServiceParameters = null, this.rasterInfo = null, this.fields = null, this.fullExtent = null, this.hasMultidimensions = false, this.imageMaxHeight = 4100, this.imageMaxWidth = 4100, this.interpolation = void 0, this.minScale = 0, this.maxScale = 0, this.multidimensionalInfo = null, this.multidimensionalSubset = null, this.noData = null, this.noDataInterpretation = void 0, this.objectIdField = null, this.geometryType = "polygon", this.typeIdField = null, this.types = [], this.pixelFilter = null, this.raster = void 0, this.sourceType = null, this.viewId = void 0, this.symbolizer = null, this.rasterFunctionInfos = null, this.serviceDataType = null, this.spatialReference = null, this.pixelType = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.url = null, this.version = void 0;
    }
    initialize() {
      this._set("exportImageServiceParameters", new y6({ layer: this }));
    }
    readServiceSupportsMosaicRule(e6, t5) {
      return this._isMosaicRuleSupported(t5);
    }
    get _rasterFunctionNamesIndex() {
      const e6 = /* @__PURE__ */ new Map();
      return !this.rasterFunctionInfos || null != this.rasterFunctionInfos && this.rasterFunctionInfos.length < 1 || null != this.rasterFunctionInfos && this.rasterFunctionInfos.forEach((t5) => {
        e6.set(t5.name.toLowerCase().replaceAll(/ /gi, "_"), t5.name);
      }), e6;
    }
    readBandIds(e6, t5) {
      if (Array.isArray(e6) && e6.length > 0 && e6.every((e7) => "number" == typeof e7))
        return e6;
    }
    readCapabilities(e6, t5) {
      return this._readCapabilities(t5);
    }
    writeCompressionQuality(e6, t5, r2) {
      null != e6 && "lerc" !== this.format && (t5[r2] = e6);
    }
    writeCompressionTolerance(e6, t5, r2) {
      "lerc" === this.format && null != e6 && (t5[r2] = e6);
    }
    readDefaultMosaicRule(e6, t5) {
      return this._serviceSupportsMosaicRule ? j5.fromJSON(t5) : null;
    }
    get fieldsIndex() {
      return this.fields ? new Z(this.fields) : null;
    }
    set format(e6) {
      e6 && ze.has(e6.toLowerCase()) && this._set("format", e6.toLowerCase());
    }
    readFormat(e6, t5) {
      return "esriImageServiceDataTypeVector-UV" === t5.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === t5.serviceDataType || null != this.pixelFilter ? "lerc" : "jpgpng";
    }
    readMinScale(e6, t5) {
      return null != t5.minLOD && null != t5.maxLOD ? e6 : 0;
    }
    readMaxScale(e6, t5) {
      return null != t5.minLOD && null != t5.maxLOD ? e6 : 0;
    }
    set mosaicRule(e6) {
      let t5 = e6;
      (t5 == null ? void 0 : t5.mosaicMethod) && (t5 = j5.fromJSON({ ...t5.toJSON(), mosaicMethod: t5.mosaicMethod, mosaicOperation: t5.mosaicOperation })), this._set("mosaicRule", t5);
    }
    readMosaicRule(e6, t5) {
      const r2 = e6 || t5.mosaicRule;
      return r2 ? j5.fromJSON(r2) : this._isMosaicRuleSupported(t5) ? j5.fromJSON(t5) : null;
    }
    writeMosaicRule(e6, t5, r2) {
      let i10 = this.mosaicRule;
      const s9 = this.definitionExpression;
      i10 ? s9 && s9 !== i10.where && (i10 = i10.clone(), i10.where = s9) : s9 && (i10 = new j5({ where: s9 })), this._isValidCustomizedMosaicRule(i10) && (t5[r2] = i10.toJSON());
    }
    writeNoData(e6, t5, r2) {
      null != e6 && "number" == typeof e6 && (t5[r2] = Ge(e6));
    }
    readObjectIdField(e6, t5) {
      if (!e6) {
        const r2 = t5.fields.find((e7) => "esriFieldTypeOID" === e7.type || "oid" === e7.type);
        e6 = r2 == null ? void 0 : r2.name;
      }
      return e6;
    }
    get parsedUrl() {
      return I(this.url);
    }
    readSourceType(e6, t5) {
      return this._isMosaicDataset(t5) ? "mosaic-dataset" : "raster-dataset";
    }
    set renderer(e6) {
      this.loaded && (e6 = this._configRenderer(e6)), this._set("renderer", e6);
    }
    readRenderer(e6, t5, r2) {
      var _a, _b;
      const i10 = (_b = (_a = t5 == null ? void 0 : t5.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.renderer, n16 = c3(i10, r2);
      return null == n16 ? null : ("vector-field" === n16.type && t5.symbolTileSize && !i10.symbolTileSize && (n16.symbolTileSize = t5.symbolTileSize), p5(n16) || n.getLogger(this).warn("ArcGISImageService", "Imagery layer doesn't support given renderer type."), n16);
    }
    writeRenderer(e6, t5, r2) {
      t5.layerDefinition = t5.layerDefinition || {}, t5.layerDefinition.drawingInfo = t5.layerDefinition.drawingInfo || {}, t5.layerDefinition.drawingInfo.renderer = e6.toJSON(), "vector-field" === e6.type && (t5.symbolTileSize = e6.symbolTileSize);
    }
    get rasterFields() {
      var _a;
      const e6 = this._rasterAttributeTableFieldPrefix, t5 = new y3({ name: "Raster.ItemPixelValue", alias: "Item Pixel Value", domain: null, editable: false, length: 50, type: "string" }), r2 = new y3({ name: "Raster.ServicePixelValue", alias: "Service Pixel Value", domain: null, editable: false, length: 50, type: "string" }), i10 = new y3({ name: "Raster.ServicePixelValue.Raw", alias: "Raw Service Pixel Value", domain: null, editable: false, length: 50, type: "string" });
      let s9 = this.fields ? a(this.fields) : [];
      s9.push(r2), ((_a = this.capabilities) == null ? void 0 : _a.operations.supportsQuery) && this.fields && this.fields.length > 0 && s9.push(t5), this.version >= 10.4 && null != this.rasterFunctionInfos && this.rasterFunctionInfos.some((e7) => "none" === e7.name.toLowerCase()) && s9.push(i10), null != this.rasterFunctionInfos && this.rasterFunctionInfos.filter((e7) => "none" !== e7.name.toLowerCase()).forEach((e7) => {
        s9.push(new y3({ name: "Raster.ServicePixelValue." + e7.name, alias: e7.name, domain: null, editable: false, length: 50, type: "string" }));
      }), this._isVectorDataSet() && (s9.push(new y3({ name: "Raster.Magnitude", alias: "Magnitude", domain: null, editable: false, type: "double" })), s9.push(new y3({ name: "Raster.Direction", alias: "Direction", domain: null, editable: false, type: "double" })));
      const { attributeTable: n16 } = this.rasterInfo ?? {};
      if (null != n16) {
        const t6 = n16.fields.filter((e7) => "esriFieldTypeOID" !== e7.type && "value" !== e7.name.toLowerCase()).map((t7) => {
          const r3 = a(t7);
          return r3.name = e6 + t7.name, r3;
        });
        s9 = s9.concat(t6);
      }
      return s9;
    }
    get renderingRule() {
      return o(n.getLogger(this), "renderingRule", { replacement: "rasterFunction", version: "4.27", warnOnce: true }), this.rasterFunction;
    }
    set renderingRule(e6) {
      o(n.getLogger(this), "renderingRule", { replacement: "rasterFunction", version: "4.27", warnOnce: true }), this._set("rasterFunction", e6);
    }
    set rasterFunction(e6) {
      let t5 = e6;
      (t5 == null ? void 0 : t5.rasterFunction) && (t5 = N.fromJSON({ ...t5.toJSON(), rasterFunction: t5.rasterFunction, rasterFunctionArguments: t5.rasterFunctionArguments })), this._set("rasterFunction", t5);
    }
    readRasterFunction(e6, t5) {
      const r2 = t5.rasterFunctionInfos;
      return t5.renderingRule || (r2 == null ? void 0 : r2.length) && "None" !== r2[0].name ? this._isRFTJson(t5.renderingRule) ? N.fromJSON({ rasterFunctionDefinition: t5.renderingRule }) : N.fromJSON(t5.renderingRule || { rasterFunctionInfos: t5.rasterFunctionInfos }) : null;
    }
    readSpatialReference(e6, t5) {
      const r2 = e6 || t5.extent.spatialReference;
      return r2 ? f2.fromJSON(r2) : null;
    }
    readPixelType(e6) {
      return n8.fromJSON(e6) || e6;
    }
    writePixelType(e6, t5, r2) {
      null != this.serviceRasterInfo && this.pixelType === this.serviceRasterInfo.pixelType || (t5[r2] = n8.toJSON(e6));
    }
    readVersion(e6, t5) {
      let r2 = t5.currentVersion;
      return r2 || (r2 = t5.hasOwnProperty("fields") || t5.hasOwnProperty("timeInfo") ? 10 : 9.3), r2;
    }
    applyFilter(e6) {
      let t5 = e6;
      return this.pixelFilter && (t5 = this._clonePixelData(e6), this.pixelFilter(t5)), t5;
    }
    async applyRenderer(e6, t5) {
      let r2 = e6;
      const { renderer: i10, symbolizer: s9, pixelFilter: n16, bandIds: a14 } = this;
      if (!this._isPicture() && i10 && s9 && !n16) {
        const n17 = JSON.stringify(this._cachedRendererJson) !== JSON.stringify(i10.toJSON()), o4 = this._rasterJobHandler.instance;
        if (o4) {
          n17 && (s9.bind(), await o4.updateSymbolizer(s9, t5), this._cachedRendererJson = i10.toJSON());
          const l11 = await o4.symbolize({ bandIds: a14, ...e6 }, t5);
          r2 = { extent: e6.extent, pixelBlock: l11 };
        } else
          r2 = { extent: e6.extent, pixelBlock: s9.symbolize({ bandIds: a14, ...e6 }) };
      }
      return r2;
    }
    destroy() {
      this._shutdownJobHandler();
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    async computeAngles(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsComputeAngles)
        throw new s("imagery-layer:compute-angles", "this operation is not supported on the input image service");
      return e6 = v(l6, e6).clone(), J(this.url, e6, this._getRequestOptions(t5));
    }
    async computePixelSpaceLocations(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsComputePixelLocation)
        throw new s("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
      return e6 = v(a12, e6).clone(), I2(this.url, e6, this._getRequestOptions(t5));
    }
    async computeHistograms(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsComputeHistograms)
        throw new s("imagery-layer:compute-histograms", "this operation is not supported on the input image service");
      return e6 = v(h, e6).clone(), this._applyMosaicAndRenderingRules(e6), G2(this.url, e6, this._getRequestOptions(t5));
    }
    async computeStatisticsHistograms(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsComputeStatisticsHistograms)
        throw new s("imagery-layer:compute-statistics-histograms", "this operation is not supported on the input image service");
      return e6 = v(h, e6).clone(), this._applyMosaicAndRenderingRules(e6), q(this.url, e6, this._getRequestOptions(t5));
    }
    async measureHeight(e6, t5) {
      const r2 = await this._fetchCapabilities(t5 == null ? void 0 : t5.signal);
      if (!("base-and-top" === e6.operationType ? r2.mensuration.supportsHeightFromBaseAndTop : "base-and-top-shadow" === e6.operationType ? r2.mensuration.supportsHeightFromBaseAndTopShadow : r2.mensuration.supportsHeightFromTopAndTopShadow))
        throw new s("imagery-layer:measure-height", "this operation is not supported on the input image service");
      return e6 = v(c17, e6).clone(), this._applyMosaicAndRenderingRules(e6), b5(this.url, e6, this._getRequestOptions(t5));
    }
    async measureAreaAndPerimeter(e6, t5) {
      const r2 = await this._fetchCapabilities(t5 == null ? void 0 : t5.signal);
      if (!(r2.mensuration.supportsAreaAndPerimeter && (!e6.is3D || r2.mensuration.supports3D)))
        throw new s("imagery-layer:measure-area-and-perimeter", "this operation is not supported on the input image service");
      return e6 = v(y7, e6).clone(), this._applyMosaicAndRenderingRules(e6), v3(this.url, e6, this._getRequestOptions(t5));
    }
    async measureDistanceAndAngle(e6, t5) {
      const r2 = await this._fetchCapabilities(t5 == null ? void 0 : t5.signal);
      if (!(r2.mensuration.supportsDistanceAndAngle && (!e6.is3D || r2.mensuration.supports3D)))
        throw new s("imagery-layer:measure-distance-and-angle", "this operation is not supported on the input image service");
      return e6 = v(u4, e6).clone(), this._applyMosaicAndRenderingRules(e6), L(this.url, e6, this._getRequestOptions(t5));
    }
    async measurePointOrCentroid(e6, t5) {
      const r2 = await this._fetchCapabilities(t5 == null ? void 0 : t5.signal);
      if (!(r2.mensuration.supportsPointOrCentroid && (!e6.is3D || r2.mensuration.supports3D)))
        throw new s("imagery-layer:measure-point-or-centroid", "this operation is not supported on the input image service");
      return e6 = v(y12, e6).clone(), this._applyMosaicAndRenderingRules(e6), F2(this.url, e6, this._getRequestOptions(t5));
    }
    async measureLengthFromImage(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsMeasureFromImage)
        throw new s("imagery-layer:measure-length-from-image", "this operation is not supported on the input image service");
      if ("polyline" !== e6.geometry.type)
        throw new s("imagery-layer:measure-length-from-image", "this input geometry must be a polyline");
      return e6 = v(y13, e6).clone(), P3(this.url, e6, this._getRequestOptions(t5));
    }
    async measureAreaFromImage(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsMeasureFromImage)
        throw new s("imagery-layer:measure-area-from-image", "this operation is not supported on the input image service");
      if ("polygon" !== e6.geometry.type)
        throw new s("imagery-layer:measure-area-from-image", "this input geometry must be a polygon");
      return e6 = v(y13, e6).clone(), U3(this.url, e6, this._getRequestOptions(t5));
    }
    getField(e6) {
      const { fieldsIndex: t5 } = this;
      return null != t5 ? t5.get(e6) : void 0;
    }
    getFieldDomain(e6, t5) {
      const r2 = this.getField(e6);
      return r2 ? r2.domain : null;
    }
    async fetchImage(e6, t5, r2, i10 = {}) {
      if (null == e6 || null == t5 || null == r2)
        throw new s("imagery-layer:fetch-image", "Insufficient parameters for requesting an image. A valid extent, width and height values are required.");
      if (this.renderer || this.symbolizer) {
        const e7 = await this._generateRasterInfo(this.rasterFunction, { signal: i10.signal });
        e7 && (this.rasterInfo = e7);
      }
      const s9 = this.getExportImageServiceParameters(e6, t5, r2, i10.timeExtent);
      if (null == s9) {
        if (i10.requestAsImageElement && this._canRequestImageElement(this.format)) {
          const e7 = document.createElement("canvas");
          if (e7.width = t5, e7.height = r2, i10.returnImageBitmap) {
            return { imageBitmap: await t2(e7, `${We2(this.parsedUrl)}/exportImage`, i10.signal) };
          }
          return { imageOrCanvasElement: e7 };
        }
        const { bandIds: s10, rasterInfo: n17 } = this, a15 = ((s10 == null ? void 0 : s10.length) || n17.bandCount) ?? 0, o4 = t5 * r2, l12 = n17.pixelType, u7 = [];
        for (let e7 = 0; e7 < a15; e7++)
          u7.push(g2.createEmptyBand(l12, o4));
        return { pixelData: { pixelBlock: new g2({ width: t5, height: r2, pixels: u7, mask: new Uint8Array(o4), pixelType: l12 }), extent: e6 } };
      }
      const n16 = !!i10.requestAsImageElement && !this.pixelFilter, a14 = n16 && !!i10.returnImageBitmap, l11 = { imageServiceParameters: s9, imageProps: { extent: e6, width: t5, height: r2, format: this.format }, requestAsImageElement: n16, returnImageBitmap: a14, signal: i10.signal };
      return this._requestArrayBuffer(l11);
    }
    fetchKeyProperties(e6) {
      return U(We2(this.parsedUrl) + "/keyProperties", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e6 == null ? void 0 : e6.rasterFunction : null }) }).then((e7) => e7.data);
    }
    fetchRasterAttributeTable(e6) {
      return this.version < 10.1 ? Promise.reject(new s("#fetchRasterAttributeTable()", "Failed to get rasterAttributeTable")) : U(We2(this.parsedUrl) + "/rasterAttributeTable", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e6 == null ? void 0 : e6.rasterFunction : null }) }).then((e7) => d4.fromJSON(e7.data));
    }
    getCatalogItemRasterInfo(e6, t5) {
      const r2 = { ...t5, query: this._getQueryParams() };
      return n12(We2(this.parsedUrl), e6, r2);
    }
    async getCatalogItemICSInfo(e6, t5) {
      var _a, _b, _c, _d, _e;
      const { data: r2 } = await U(We2(this.parsedUrl) + "/" + e6 + "/info/ics", { query: this._getQueryParams(), ...t5 }), i10 = r2 == null ? void 0 : r2.ics;
      if (!i10)
        return;
      let s9 = null;
      try {
        s9 = (await U(We2(this.parsedUrl) + "/" + e6 + "/info", { query: this._getQueryParams(), ...t5 })).data.extent;
      } catch {
      }
      if (!s9 || !s9.spatialReference)
        return { ics: i10, icsToPixelTransform: null, icsExtent: null, northDirection: null };
      const a14 = this.version >= 10.7 ? U(We2(this.parsedUrl) + "/" + e6 + "/info/icstopixel", { query: this._getQueryParams(), ...t5 }).then((e7) => e7.data).catch(() => ({})) : {}, o4 = s9.spatialReference, l11 = { geometries: JSON.stringify({ geometryType: "esriGeometryEnvelope", geometries: [s9] }), inSR: d2(o4), outSR: "0:" + e6 }, u7 = U(We2(this.parsedUrl) + "/project", { query: this._getQueryParams(l11), ...t5 }).then((e7) => e7.data).catch(() => ({})), p20 = 5, m13 = (s9.xmin + s9.xmax) / 2, c22 = (s9.ymax - s9.ymin) / (p20 + 1), d13 = s9.ymin + c22, h4 = [];
      for (let n16 = 0; n16 < p20; n16++)
        h4.push({ x: m13, y: d13 + c22 * n16 });
      const g6 = { geometries: JSON.stringify({ geometryType: "esriGeometryPoint", geometries: h4 }), inSR: d2(o4), outSR: "0:" + e6 }, f10 = U(We2(this.parsedUrl) + "/project", { query: this._getQueryParams(g6), ...t5 }).then((e7) => e7.data).catch(() => ({})), y14 = await Promise.all([a14, u7, f10]);
      let R3 = y14[0].ipxf;
      if (null == R3) {
        const e7 = (_a = i10.geodataXform) == null ? void 0 : _a.xf_0;
        "topup" === ((_b = e7 == null ? void 0 : e7.name) == null ? void 0 : _b.toLowerCase()) && 6 === ((_c = e7 == null ? void 0 : e7.coefficients) == null ? void 0 : _c.length) && (R3 = { affine: { name: "ics [sensor: Frame] to pixel (column, row) transformation", coefficients: e7.coefficients, cellsizeRatio: 0, type: "GeometricXform" } });
      }
      const b6 = w.fromJSON((_e = (_d = y14[1]) == null ? void 0 : _d.geometries) == null ? void 0 : _e[0]);
      b6 && (b6.spatialReference = new f2({ wkid: 0, imageCoordinateSystem: i10 }));
      const w4 = y14[2].geometries ? y14[2].geometries.filter((e7) => null != (e7 == null ? void 0 : e7.x) && null != e7.y && "NaN" !== e7.x && "NaN" !== e7.y) : [], v4 = w4.length;
      if (v4 < 3)
        return { ics: i10, icsToPixelTransform: R3, icsExtent: b6, northDirection: null };
      let S3 = 0, x5 = 0, _ = 0, F3 = 0;
      for (let n16 = 0; n16 < v4; n16++)
        S3 += w4[n16].x, x5 += w4[n16].y, _ += w4[n16].x * w4[n16].x, F3 += w4[n16].x * w4[n16].y;
      const D2 = (v4 * F3 - S3 * x5) / (v4 * _ - S3 * S3);
      let T5 = 0;
      const P4 = w4[p20 - 1].x > w4[0].x, j8 = w4[p20 - 1].y > w4[0].y;
      return D2 === 1 / 0 ? T5 = j8 ? 90 : 270 : 0 === D2 ? T5 = P4 ? 0 : 180 : D2 > 0 ? T5 = P4 ? 180 * Math.atan(D2) / Math.PI : 180 * Math.atan(D2) / Math.PI + 180 : D2 < 0 && (T5 = j8 ? 180 + 180 * Math.atan(D2) / Math.PI : 360 + 180 * Math.atan(D2) / Math.PI), { ics: i10, icsToPixelTransform: R3, icsExtent: b6, northDirection: T5 };
    }
    async generateRasterInfo(e6, t5) {
      var _a;
      if (e6 = v(N, e6), this.serviceRasterInfo && (!e6 || "none" === ((_a = e6.functionName) == null ? void 0 : _a.toLowerCase()) || this._isVectorFieldResampleFunction(e6)))
        return this.serviceRasterInfo;
      const r2 = ke(e6);
      if (!r2)
        throw new s("imagery-layer:generate-raster-info", "the rendering rule is not supported");
      if (this._functionRasterInfos[r2])
        return this._functionRasterInfos[r2];
      const i10 = { ...t5, query: this._getQueryParams() }, s9 = f7(We2(this.parsedUrl), e6, i10);
      this._functionRasterInfos[r2] = s9;
      try {
        return await s9;
      } catch (n16) {
        throw this._functionRasterInfos[r2] = null, n16;
      }
    }
    getExportImageServiceParameters(e6, t5, r2, i10) {
      var _a;
      e6 = e6.clone().shiftCentralMeridian();
      const s9 = T3(e6.spatialReference, We2(this.parsedUrl));
      this.pixelType !== this.serviceRasterInfo.pixelType && (this.exportImageServiceParameters.pixelType = this.pixelType);
      const n16 = this.exportImageServiceParameters.toJSON(), { bandIds: a14, noData: o4 } = n16;
      let { renderingRule: l11 } = n16;
      const u7 = (_a = this.rasterFunction) == null ? void 0 : _a.rasterFunctionDefinition, p20 = !this.renderer || "raster-stretch" === this.renderer.type;
      if ((a14 == null ? void 0 : a14.length) && this._hasRasterFunction(this.rasterFunction) && !u7 && p20) {
        const e7 = { rasterFunction: "ExtractBand", rasterFunctionArguments: { BandIds: a14 } };
        if ("Stretch" === l11.rasterFunction)
          e7.rasterFunctionArguments.Raster = l11.rasterFunctionArguments.Raster, l11.rasterFunctionArguments.Raster = e7;
        else if ("Colormap" === l11.rasterFunction) {
          const t6 = l11.rasterFunctionArguments.Raster;
          "Stretch" === (t6 == null ? void 0 : t6.rasterFunction) ? (e7.rasterFunctionArguments.Raster = t6.rasterFunctionArguments.Raster, t6.rasterFunctionArguments.Raster = e7) : (e7.rasterFunctionArguments.Raster = t6, l11.rasterFunctionArguments.Raster = e7);
        } else
          e7.rasterFunctionArguments.Raster = l11, l11 = e7;
        n16.bandIds = void 0;
      } else
        n16.bandIds = a14 == null ? void 0 : a14.join(",");
      Array.isArray(o4) && o4.length > 0 && (n16.noData = o4.join(","));
      const m13 = this._processMultidimensionalIntersection(null, i10, this.exportImageServiceParameters.mosaicRule);
      if (m13.isOutSide)
        return null;
      n16.mosaicRule = null != m13.mosaicRule ? JSON.stringify(m13.mosaicRule) : null, i10 = m13.timeExtent, n16.renderingRule = this._getRenderingRuleString(N.fromJSON(l11));
      const c22 = {};
      if (null != i10) {
        const { start: e7, end: t6 } = i10.toJSON();
        e7 && t6 && e7 === t6 ? c22.time = "" + e7 : null == e7 && null == t6 || (c22.time = `${e7 ?? "null"},${t6 ?? "null"}`);
      }
      return { bbox: e6.xmin + "," + e6.ymin + "," + e6.xmax + "," + e6.ymax, bboxSR: s9, imageSR: s9, size: t5 + "," + r2, ...n16, ...c22 };
    }
    async getSamples(e6, t5) {
      const r2 = await this._fetchCapabilities(t5 == null ? void 0 : t5.signal);
      if (!(r2 == null ? void 0 : r2.operations.supportsGetSamples))
        throw new s("imagery-layer:get-samples", "getSamples operation is not supported on the input image service");
      e6 = v(h3, e6).clone();
      const { raster: i10 } = this;
      return i10 && null == e6.raster && (e6.raster = i10), $(this.url, e6, this._getRequestOptions(t5));
    }
    async identify(e6, t5) {
      var _a;
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsIdentify)
        throw new s("imagery-layer:identify", "identify operation is not supported on the input image service");
      e6 = v(d10, e6).clone(), this.version < 10.91 && "extent" === ((_a = e6.geometry) == null ? void 0 : _a.type) && (e6.geometry = j2.fromExtent(e6.geometry));
      const r2 = this._processMultidimensionalIntersection(e6.geometry, e6.timeExtent, e6.mosaicRule || this.mosaicRule);
      if (r2.isOutSide)
        throw new s("imagery-layer:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
      e6.timeExtent = r2.timeExtent, e6.mosaicRule = r2.mosaicRule;
      const { raster: i10, rasterFunction: s9 } = this;
      return s9 && null == e6.rasterFunction && (e6.rasterFunction = s9), i10 && null == e6.raster && (e6.raster = i10), C2(this.url, e6, this._getRequestOptions(t5));
    }
    async imageToMap(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsImageToMap)
        throw new s("imagery-layer:image-to-map", "imageToMap operation is not supported on the input image service");
      return e6 = v(l9, e6), k3(We2(this.parsedUrl), e6, this._getRequestOptions(t5));
    }
    async imageToMapMultiray(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsImageToMapMultiray)
        throw new s("imagery-layer:image-to-map-multiray", "imageToMapMultiray operation is not supported on the input image service");
      return e6 = v(u6, e6), z(We2(this.parsedUrl), e6, this._getRequestOptions(t5));
    }
    async mapToImage(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsMapToImage)
        throw new s("imagery-layer:map-to-image", "mapToImage operation is not supported on the input image service");
      return e6 = v(l10, e6), E2(We2(this.parsedUrl), e6, this._getRequestOptions(t5));
    }
    async findImages(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsFindImages)
        throw new s("imagery-layer:find-images", "findImages operation is not supported on the input image service");
      return e6 = v(m10, e6), X(We2(this.parsedUrl), e6, this._getRequestOptions(t5));
    }
    async getImageUrl(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsGetImageUrl)
        throw new s("imagery-layer:get-image-url", "getImageUrl operation is not supported on the input image service");
      return e6 = v(c20, e6), V3(We2(this.parsedUrl), e6, this._getRequestOptions(t5));
    }
    createQuery() {
      return new b3({ outFields: ["*"], returnGeometry: true, where: this.definitionExpression || "1=1" });
    }
    async queryBoundary(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsQueryBoundary)
        throw new s("imagery-layer:query-boundary", "queryBoundary operation is not supported on the input image service");
      return e6 = v(c15, e6 ?? { outSpatialReference: this.spatialReference }).clone(), B2(We2(this.parsedUrl), e6, this._getRequestOptions(t5));
    }
    async queryRasters(e6, t5) {
      return { query: e6, requestOptions: t5 } = await this._prepareForQuery(e6, t5), s5(this.url, e6, t5);
    }
    async queryObjectIds(e6, t5) {
      return { query: e6, requestOptions: t5 } = await this._prepareForQuery(e6, t5), s4(this.url, e6, t5);
    }
    async queryGPSInfo(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsQueryGPSInfo)
        throw new s("imagery-layer:query-gps-info", "queryGPSInfo operation is not supported on the input image service");
      return e6 = v(y9, e6 ?? { outSpatialReference: this.spatialReference }).clone(), D(We2(this.parsedUrl), e6, this._getRequestOptions(t5));
    }
    async queryRasterCount(e6, t5) {
      return { query: e6, requestOptions: t5 } = await this._prepareForQuery(e6, t5), n5(this.url, e6, t5);
    }
    async queryVisibleRasters(e6, t5) {
      var _a, _b, _c, _d;
      if (!e6)
        throw new s("imagery-layer: query-visible-rasters", "missing query parameter");
      await this.load();
      const { pixelSize: r2, returnDomainValues: i10, returnTopmostRaster: s9, showNoDataRecords: n16 } = t5 || { pixelSize: null, returnDomainValues: false, returnTopmostRaster: false, showNoDataRecords: false };
      let a14 = false, l11 = null, u7 = null;
      const p20 = "raster.servicepixelvalue", m13 = this._rasterFunctionNamesIndex;
      if (null != e6.outFields && (a14 = e6.outFields.some((e7) => !e7.toLowerCase().includes(p20)), this.version >= 10.4)) {
        const t6 = e6.outFields.filter((e7) => e7.toLowerCase().includes(p20) && e7.length > p20.length).map((e7) => {
          const t7 = e7.slice(p20.length + 1);
          return [this._updateRenderingRulesFunctionName(t7, m13), t7];
        });
        l11 = t6.map((e7) => new N({ functionName: e7[0] })), u7 = t6.map((e7) => e7[1]);
        const { rasterFunction: r3 } = this;
        0 === l11.length ? (r3 == null ? void 0 : r3.functionName) ? (l11.push(r3), u7.push(r3.functionName)) : l11 = null : (r3 == null ? void 0 : r3.functionName) && !l11.some((e7) => e7.functionName === r3.functionName) && (l11.push(r3), u7.push(r3.functionName));
      }
      const c22 = null == e6.outSpatialReference || e6.outSpatialReference.equals(this.spatialReference), { multidimensionalSubset: d13 } = this;
      let h4 = e6.timeExtent || this.timeExtent;
      if (d13) {
        const { isOutside: t6, intersection: r3 } = m2(d13, { geometry: e6.geometry, timeExtent: e6.timeExtent, multidimensionalDefinition: (_a = this.exportImageServiceParameters.mosaicRule) == null ? void 0 : _a.multidimensionalDefinition });
        if (t6)
          throw new s("imagery-layer:query-visible-rasters", "the request cannot be fulfilled when falling outside of the multidimensional subset");
        null != (r3 == null ? void 0 : r3.timeExtent) && (h4 = r3.timeExtent);
      }
      const g6 = this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule, h4);
      let f10 = e6.geometry;
      this.version < 10.91 && "extent" === (f10 == null ? void 0 : f10.type) && (f10 = j2.fromExtent(f10));
      const y14 = this._getQueryParams({ geometry: f10, timeExtent: h4, mosaicRule: g6, rasterFunction: this.version < 10.4 ? this.rasterFunction : null, rasterFunctions: l11, pixelSize: r2, returnCatalogItems: a14, returnGeometry: c22, raster: this.raster, maxItemCount: s9 ? 1 : null });
      delete y14.f;
      const R3 = new d10(y14);
      try {
        await this._generateRasterInfo(this.rasterFunction);
        const r3 = await C2(this.url, R3, { signal: t5 == null ? void 0 : t5.signal, query: { ...this.customParameters } }), s10 = e6.outFields, o4 = null != r3.value && r3.value.toLowerCase().includes("nodata");
        if (!(a14 && !c22 && ((_b = r3 == null ? void 0 : r3.catalogItems) == null ? void 0 : _b.features.length) && (n16 || !o4)))
          return this._processVisibleRastersResponse(r3, { returnDomainValues: i10, templateRRFunctionNames: u7, showNoDataRecords: n16, templateFields: s10 });
        const l12 = this.objectIdField || "ObjectId", p21 = ((_c = r3.catalogItems) == null ? void 0 : _c.features) ?? [], m14 = p21.map((e7) => {
          var _a2;
          return (_a2 = e7.attributes) == null ? void 0 : _a2[l12];
        }), d14 = new b3({ objectIds: m14, returnGeometry: true, outSpatialReference: e6.outSpatialReference, outFields: [l12] }), h5 = await this.queryRasters(d14);
        return ((_d = h5 == null ? void 0 : h5.features) == null ? void 0 : _d.length) && h5.features.forEach((t6) => {
          p21.forEach((r4) => {
            r4.attributes[l12] === t6.attributes[l12] && (r4.geometry = new j2(t6.geometry), null != e6.outSpatialReference && (r4.geometry.spatialReference = e6.outSpatialReference));
          });
        }), this._processVisibleRastersResponse(r3, { returnDomainValues: i10, templateRRFunctionNames: u7, showNoDataRecords: n16, templateFields: s10 });
      } catch {
        throw new s("imagery-layer:query-visible-rasters", "encountered error when querying visible rasters");
      }
    }
    async fetchVariableStatisticsHistograms(e6, t5) {
      const r2 = U(We2(this.parsedUrl) + "/statistics", { query: this._getQueryParams({ variable: e6 }), signal: t5 }).then((e7) => {
        var _a;
        return (_a = e7.data) == null ? void 0 : _a.statistics;
      }), i10 = U(We2(this.parsedUrl) + "/histograms", { query: this._getQueryParams({ variable: e6 }), signal: t5 }).then((e7) => {
        var _a;
        return (_a = e7.data) == null ? void 0 : _a.histograms;
      }), s9 = await Promise.all([r2, i10]);
      return s9[0] && s9[0].forEach((e7) => {
        e7.avg = e7.mean, e7.stddev = e7.standardDeviation;
      }), { statistics: s9[0] || null, histograms: s9[1] || null };
    }
    async createFlowMesh(e6, t5) {
      const r2 = this._rasterJobHandler.instance;
      return r2 ? r2.createFlowMesh(e6, t5) : s7(e6.meshType, e6.simulationSettings, e6.flowData, null != t5.signal ? t5.signal : new AbortController().signal);
    }
    getMultidimensionalSubsetVariables(e6) {
      const t5 = e6 ?? this.serviceRasterInfo.multidimensionalInfo;
      return g3(this.multidimensionalSubset, t5);
    }
    async _fetchService(e6) {
      await this._fetchServiceInfo(e6), this.rasterInfo || (this.rasterInfo = this.serviceRasterInfo);
      const t5 = this.sourceJSON, r2 = null != this.serviceRasterInfo ? Promise.resolve(this.serviceRasterInfo) : m3(We2(this.parsedUrl), t5, { signal: e6, query: this._getQueryParams() }).then((e7) => (this._set("serviceRasterInfo", e7), this._set("multidimensionalInfo", e7.multidimensionalInfo), p4(e7, t5), e7)), i10 = this._hasRasterFunction(this.rasterFunction) ? this._generateRasterInfo(this.rasterFunction, { signal: e6 }) : null, s9 = this._getRasterFunctionInfos();
      return Promise.all([r2, i10, s9]).then((e7) => {
        e7[1] ? this._set("rasterInfo", e7[1]) : this._set("rasterInfo", e7[0]), e7[2] && this._set("rasterFunctionInfos", e7[2]), this.renderer && !this._isSupportedRenderer(this.renderer) && (this._set("renderer", null), n.getLogger(this).warn("ArcGISImageService", "Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")), this._set("renderer", this._configRenderer(this.renderer)), this.addHandles([d(() => this.rasterFunction, (e8) => {
          (this.renderer || this.symbolizer || this.popupEnabled && this.popupTemplate) && this._generateRasterInfo(e8).then((e9) => {
            e9 && (this.rasterInfo = e9);
          });
        })]);
        const { serviceRasterInfo: t6 } = this;
        null != t6.multidimensionalInfo && this._updateMultidimensionalDefinition(t6);
      });
    }
    _combineMosaicRuleWithTimeExtent(e6, t5) {
      var _a;
      const r2 = this.timeInfo, { multidimensionalInfo: i10 } = this.serviceRasterInfo;
      if (null == e6 || null == i10 || null == t5 || null == (r2 == null ? void 0 : r2.startField))
        return e6;
      const { startField: s9 } = r2, n16 = i10.variables.some((e7) => e7.dimensions.some((e8) => e8.name === s9)) ? s9 : "StdTime";
      if (e6 = e6.clone(), "mosaic-dataset" === this.sourceType)
        return e6.multidimensionalDefinition = (_a = e6.multidimensionalDefinition) == null ? void 0 : _a.filter((e7) => e7.dimensionName !== n16), this._cleanupMultidimensionalDefinition(e6);
      e6.multidimensionalDefinition = e6.multidimensionalDefinition || [];
      const a14 = e6.multidimensionalDefinition.filter((e7) => e7.dimensionName === n16), o4 = null != t5.start ? t5.start.getTime() : null, l11 = null != t5.end ? t5.end.getTime() : null, u7 = null == o4 || null == l11 || o4 === l11, p20 = u7 ? [o4 || l11] : [[o4, l11]], m13 = this.version >= 10.8;
      if (a14.length)
        a14.forEach((e7) => {
          e7.dimensionName === n16 && (m13 ? (e7.dimensionName = null, e7.isSlice = false, e7.values = []) : (e7.isSlice = u7, e7.values = p20));
        });
      else if (!m13) {
        const t6 = e6.multidimensionalDefinition.filter((e7) => null != e7.variableName && null == e7.dimensionName);
        t6.length ? t6.forEach((e7) => {
          e7.dimensionName = n16, e7.isSlice = u7, e7.values = p20;
        }) : e6.multidimensionalDefinition.push(new p3({ variableName: "", dimensionName: n16, isSlice: u7, values: p20 }));
      }
      return this._cleanupMultidimensionalDefinition(e6);
    }
    _cleanupMultidimensionalDefinition(e6) {
      return null == e6 ? null : (e6.multidimensionalDefinition && (e6.multidimensionalDefinition = e6.multidimensionalDefinition.filter((e7) => !(!e7.variableName && !e7.dimensionName)), 0 === e6.multidimensionalDefinition.length && (e6.multidimensionalDefinition = null)), "mosaic-dataset" !== this.sourceType && null == e6.multidimensionalDefinition ? null : e6);
    }
    async _prepareForQuery(e6, t5) {
      if (!(await this._fetchCapabilities(t5 == null ? void 0 : t5.signal)).operations.supportsQuery)
        throw new s("imagery-layer:query-rasters", "query operation is not supported on the input image service");
      return e6 = null != e6 ? v(b3, e6) : this.createQuery(), t5 = this._getRequestOptions(t5), this.raster && (t5.query = { ...t5.query, raster: this.raster }), { query: e6, requestOptions: t5 };
    }
    async _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise)
        return this._rasterJobHandler.connectionPromise;
      const e6 = new t3();
      this._rasterJobHandler.connectionPromise = e6.initialize().then(() => {
        this._rasterJobHandler.instance = e6;
      }, () => {
      }), await this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null;
    }
    _isSupportedRenderer(e6) {
      const { rasterInfo: t5, rasterFunction: r2 } = this;
      return "unique-value" === e6.type && this._hasRasterFunction(r2) && 1 === (t5 == null ? void 0 : t5.bandCount) && ["u8", "s8"].includes(t5.pixelType) || null != t5 && null != e6 && k2(t5).includes(e6.type);
    }
    async _fetchCapabilities(e6) {
      return this.capabilities || await this._fetchServiceInfo(e6), this.capabilities;
    }
    async _fetchServiceInfo(e6) {
      var _a;
      let t5 = this.sourceJSON;
      if (!t5) {
        const { data: r2, ssl: i10 } = await U(We2(this.parsedUrl), { query: this._getQueryParams(), signal: e6 });
        t5 = r2, this.sourceJSON = t5, i10 && (this.url = this.url.replace(/^http:/i, "https:"));
      }
      if (((_a = t5.capabilities) == null ? void 0 : _a.toLowerCase().split(",").map((e7) => e7.trim()).indexOf("tilesonly")) > -1)
        throw new s("imagery-layer:fetch-service-info", "use ImageryTileLayer to open tiles-only image services");
      this.read(t5, { origin: "service", url: this.parsedUrl });
    }
    _isMosaicDataset(e6) {
      var _a;
      return e6.serviceSourceType ? "esriImageServiceSourceTypeMosaicDataset" === e6.serviceSourceType : ((_a = e6.fields) == null ? void 0 : _a.length) > 0;
    }
    _isMosaicRuleSupported(e6) {
      var _a;
      if (!e6)
        return false;
      const t5 = this._isMosaicDataset(e6), r2 = e6.currentVersion >= 10.71 && e6.hasMultidimensions && !(((_a = e6.fields) == null ? void 0 : _a.length) > 1);
      return t5 || r2;
    }
    _isVectorFieldResampleFunction(e6) {
      if (null == e6)
        return false;
      const { functionName: t5, functionArguments: r2 } = e6, i10 = "resample" === (t5 == null ? void 0 : t5.toLowerCase()), s9 = (r2 == null ? void 0 : r2.ResampleType) || (r2 == null ? void 0 : r2.resampleType);
      return i10 && (7 === s9 || 10 === s9);
    }
    _isPicture() {
      return !this.format || this.format.includes("jpg") || this.format.includes("png");
    }
    _configRenderer(e6) {
      var _a, _b;
      const t5 = this._isPicture(), { rasterInfo: r2 } = this;
      if (!t5 && !this.pixelFilter || this._isVectorDataSet()) {
        if (!this.bandIds && r2.bandCount >= 3) {
          const e7 = E(r2);
          !e7 || 3 === r2.bandCount && 0 === e7[0] && 1 === e7[1] && 2 === e7[2] || (this.bandIds = e7);
        }
        e6 || (e6 = V(r2, { bandIds: this.bandIds, variableName: this.rasterFunction ? null : (_b = (_a = this.mosaicRule) == null ? void 0 : _a.multidimensionalDefinition) == null ? void 0 : _b[0].variableName }));
        const t6 = K(e6.toJSON());
        this.symbolizer ? (this.symbolizer.rendererJSON = t6, this.symbolizer.rasterInfo = r2) : this.symbolizer = new U2({ rendererJSON: t6, rasterInfo: r2 }), this.symbolizer.bind().success || (this.symbolizer = null);
      }
      return e6;
    }
    _clonePixelData(e6) {
      return null == e6 ? e6 : { extent: e6.extent && e6.extent.clone(), pixelBlock: null != e6.pixelBlock ? e6.pixelBlock.clone() : null };
    }
    _getQueryParams(e6) {
      null != (e6 == null ? void 0 : e6.renderingRule) && "string" != typeof e6.renderingRule && (e6.renderingRule = this._getRenderingRuleString(e6.renderingRule));
      const { raster: t5, viewId: r2 } = this;
      return { raster: t5, viewId: r2, f: "json", ...e6, ...this.customParameters };
    }
    _getRequestOptions(e6) {
      return { ...e6, query: { ...e6 == null ? void 0 : e6.query, ...this.customParameters } };
    }
    _decodePixelBlock(e6, t5, r2) {
      return this._rasterJobHandler.instance ? this._rasterJobHandler.instance.decode({ data: e6, options: t5 }) : j4(e6, t5, r2);
    }
    async _getRasterFunctionInfos(e6) {
      var _a;
      const t5 = this.sourceJSON.rasterFunctionInfos;
      if (this.loaded)
        return t5;
      if (t5 && this.version >= 10.3) {
        if (1 === t5.length && "none" === t5[0].name.toLowerCase())
          return t5;
        const r2 = await U(We2(this.parsedUrl) + "/rasterFunctionInfos", { query: this._getQueryParams(), signal: e6 });
        return (_a = r2.data) == null ? void 0 : _a.rasterFunctionInfos;
      }
      return null;
    }
    _canRequestImageElement(e6) {
      return !this.pixelFilter && (!e6 || e6.includes("png"));
    }
    async _requestArrayBuffer(e6) {
      const { imageProps: t5, requestAsImageElement: r2, returnImageBitmap: i10, signal: s9 } = e6;
      if (r2 && this._canRequestImageElement(t5.format)) {
        const r3 = `${We2(this.parsedUrl)}/exportImage`, { data: a15 } = await U(r3, { responseType: i10 ? "blob" : "image", query: this._getQueryParams({ f: "image", ...this.refreshParameters, ...e6.imageServiceParameters }), signal: s9 });
        if (a15 instanceof Blob) {
          return { imageBitmap: await t2(a15, r3, s9), params: t5 };
        }
        return { imageOrCanvasElement: a15, params: t5 };
      }
      const a14 = this._initJobHandler(), l11 = U(We2(this.parsedUrl) + "/exportImage", { responseType: "array-buffer", query: this._getQueryParams({ f: "image", ...e6.imageServiceParameters }), signal: s9 }), u7 = (await Promise.all([l11, a14]))[0].data, p20 = t5.format || "jpgpng";
      let m13 = p20;
      if ("bsq" !== m13 && "bip" !== m13 && (m13 = P(u7)), !m13)
        throw new s("imagery-layer:fetch-image", "unsupported format signature " + String.fromCharCode.apply(null, new Uint8Array(u7)));
      const c22 = { signal: s9 }, d13 = "gif" === p20 || "bmp" === p20 || p20.includes("png") && ("png" === m13 || "jpg" === m13) ? j4(u7, { useCanvas: true, ...t5 }, c22) : this._decodePixelBlock(u7, { width: t5.width, height: t5.height, planes: null, pixelType: null, noDataValue: null, format: p20 }, c22);
      return { pixelData: { pixelBlock: await d13, extent: t5.extent }, params: t5 };
    }
    _generateRasterInfo(e6, t5) {
      return this.generateRasterInfo(e6, t5).catch(() => null);
    }
    _isValidCustomizedMosaicRule(e6) {
      var _a;
      return e6 && JSON.stringify(e6.toJSON()) !== JSON.stringify((_a = this.defaultMosaicRule) == null ? void 0 : _a.toJSON());
    }
    _updateMultidimensionalDefinition(e6) {
      var _a;
      if (this._isValidCustomizedMosaicRule(this.mosaicRule))
        return;
      let t5 = d7(e6, { multidimensionalSubset: this.multidimensionalSubset });
      if (null != t5 && t5.length > 0) {
        this.mosaicRule = this.mosaicRule || new j5();
        const e7 = this.mosaicRule.multidimensionalDefinition;
        !this.sourceJSON.defaultVariableName && this.rasterFunction && "none" !== ((_a = this.rasterFunction.functionName) == null ? void 0 : _a.toLowerCase()) && t5.forEach((e8) => e8.variableName = ""), t5 = t5.filter(({ variableName: e8, dimensionName: t6 }) => e8 && "*" !== e8 || t6), !(e7 == null ? void 0 : e7.length) && t5.length && (this.mosaicRule.multidimensionalDefinition = t5);
      }
    }
    _processVisibleRastersResponse(e6, r2) {
      var _a, _b, _c;
      r2 = r2 || {};
      const i10 = e6.value, { templateRRFunctionNames: s9, showNoDataRecords: n16, returnDomainValues: a14, templateFields: o4 } = r2, l11 = e6.processedValues;
      let u7 = (_a = e6.catalogItems) == null ? void 0 : _a.features, p20 = ((_c = (_b = e6.properties) == null ? void 0 : _b.Values) == null ? void 0 : _c.map((e7) => e7.replaceAll(/ /gi, ", "))) || [];
      const m13 = this.objectIdField || "ObjectId", c22 = "string" == typeof i10 && i10.toLowerCase().includes("nodata"), d13 = [];
      if (i10 && !u7 && !c22) {
        const e7 = {};
        e7[m13] = 0;
        p20 = [i10], u7 = [new f4(this.fullExtent, null, e7)];
      }
      if (!u7)
        return [];
      let h4, g6, f10;
      this._updateResponseFieldNames(u7, o4), c22 && !n16 && (u7 = []);
      for (let t5 = 0; t5 < u7.length; t5++) {
        if (h4 = u7[t5], null != i10) {
          if (g6 = p20[t5], f10 = this.rasterFunction && l11 && l11.length > 0 && s9 && s9.length > 0 && s9.includes(this.rasterFunction.functionName) ? l11[s9.indexOf(this.rasterFunction.functionName)] : i10, "nodata" === g6.toLowerCase() && !n16)
            continue;
          const e7 = "Raster.ItemPixelValue", r3 = "Raster.ServicePixelValue";
          h4.attributes[e7] = g6, h4.attributes[r3] = f10, this._updateFeatureWithMagDirValues(h4, g6);
          const a15 = this.fields && this.fields.length > 0;
          let o5 = this.rasterFunction && null != this.serviceRasterInfo.attributeTable ? a15 ? g6 : i10 : f10;
          this.rasterFunction || (o5 = a15 ? g6 : i10), this._updateFeatureWithRasterAttributeTableValues(h4, o5);
        }
        if (h4.sourceLayer = h4.layer = this, a14 && this._updateFeatureWithDomainValues(h4), s9 && l11 && s9.length === l11.length)
          for (let e7 = 0; e7 < s9.length; e7++) {
            const t6 = "Raster.ServicePixelValue." + s9[e7];
            h4.attributes[t6] = l11[e7];
          }
        d13.push(u7[t5]);
      }
      return d13;
    }
    _processMultidimensionalIntersection(e6, t5, r2) {
      const { multidimensionalSubset: i10 } = this;
      if (!i10)
        return { isOutSide: false, timeExtent: t5, mosaicRule: r2 = this._combineMosaicRuleWithTimeExtent(r2, t5) };
      if (i10) {
        const { isOutside: r3, intersection: s9 } = m2(i10, { geometry: e6, timeExtent: t5 });
        if (r3)
          return { isOutSide: true, timeExtent: null, mosaicRule: null };
        null != (s9 == null ? void 0 : s9.timeExtent) && (t5 = s9.timeExtent);
      }
      if (r2 = this._combineMosaicRuleWithTimeExtent(r2, t5), r2 == null ? void 0 : r2.multidimensionalDefinition) {
        const { isOutside: e7 } = m2(i10, { multidimensionalDefinition: r2.multidimensionalDefinition });
        if (e7)
          return { isOutSide: true, timeExtent: null, mosaicRule: null };
      }
      return { isOutSide: false, timeExtent: t5, mosaicRule: r2 };
    }
    _updateFeatureWithRasterAttributeTableValues(e6, t5) {
      const r2 = this.rasterInfo.attributeTable || this.serviceRasterInfo.attributeTable;
      if (null == r2)
        return;
      const { features: i10, fields: s9 } = r2, n16 = s9.map((e7) => e7.name).find((e7) => "value" === e7.toLowerCase());
      if (!n16)
        return;
      const a14 = i10.filter((e7) => e7.attributes[n16] === (null != t5 ? parseInt(t5, 10) : null));
      a14 && a14[0] && s9.forEach((t6) => {
        const r3 = this._rasterAttributeTableFieldPrefix + t6.name;
        e6.attributes[r3] = a14[0].attributes[t6.name];
      });
    }
    _updateFeatureWithMagDirValues(e6, t5) {
      if (!this._isVectorDataSet())
        return;
      const r2 = t5.split(/,\s*/).map((e7) => parseFloat(e7)), i10 = r2.map((e7) => [e7]), s9 = r2.map((e7) => ({ minValue: e7, maxValue: e7, noDataValue: null })), n16 = new g2({ height: 1, width: 1, pixelType: "f32", pixels: i10, statistics: s9 });
      null != this.pixelFilter && this.pixelFilter({ pixelBlock: n16, extent: new w(0, 0, 0, 0, this.spatialReference) });
      const a14 = "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType ? [n16.pixels[0][0], n16.pixels[1][0]] : l2([n16.pixels[0][0], n16.pixels[1][0]]);
      e6.attributes["Raster.Magnitude"] = a14[0], e6.attributes["Raster.Direction"] = a14[1];
    }
    _updateFeatureWithDomainValues(e6) {
      const t5 = this.fields && this.fields.filter((e7) => e7.domain && "coded-value" === e7.domain.type);
      null != t5 && t5.forEach((t6) => {
        const r2 = e6.attributes[t6.name];
        if (null != r2) {
          const i10 = t6.domain.codedValues.find((e7) => e7.code === r2);
          i10 && (e6.attributes[t6.name] = i10.name);
        }
      });
    }
    _updateResponseFieldNames(e6, t5) {
      if (!t5 || t5.length < 1)
        return;
      const r2 = this.fieldsIndex;
      null != r2 && e6.forEach((e7) => {
        var _a;
        if (e7 == null ? void 0 : e7.attributes)
          for (const i10 of t5) {
            const t6 = (_a = r2.get(i10)) == null ? void 0 : _a.name;
            t6 && t6 !== i10 && (e7.attributes[i10] = e7.attributes[t6], delete e7.attributes[t6]);
          }
      });
    }
    _getRenderingRuleString(e6) {
      if (e6) {
        let t5 = e6.toJSON();
        return t5 = t5.rasterFunctionDefinition ?? t5, (t5.thumbnail || t5.thumbnailEx) && (t5.thumbnail = t5.thumbnailEx = null), JSON.stringify(t5);
      }
      return null;
    }
    _hasRasterFunction(e6) {
      return null != (e6 == null ? void 0 : e6.functionName) && "none" !== e6.functionName.toLowerCase();
    }
    _updateRenderingRulesFunctionName(e6, t5) {
      if (!e6 || e6.length < 1)
        return;
      if ("Raw" === e6)
        return e6.replace("Raw", "None");
      const r2 = e6.toLowerCase().replaceAll(/ /gi, "_");
      return t5.has(r2) ? t5.get(r2) : e6;
    }
    _isRFTJson(e6) {
      return (e6 == null ? void 0 : e6.name) && e6.arguments && e6.function && e6.hasOwnProperty("functionType");
    }
    _isVectorDataSet() {
      return "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType;
    }
    _applyMosaicAndRenderingRules(e6) {
      const { raster: t5, mosaicRule: r2, rasterFunction: i10 } = this;
      i10 && e6 instanceof h && null == e6.rasterFunction && (e6.rasterFunction = i10), r2 && null == e6.mosaicRule && (e6.mosaicRule = r2), t5 && null == e6.raster && (e6.raster = t5);
    }
    _readCapabilities(e6) {
      var _a;
      const t5 = e6.capabilities ? e6.capabilities.toLowerCase().split(",").map((e7) => e7.trim()) : ["image", "catalog"], { currentVersion: r2, advancedQueryCapabilities: i10, maxRecordCount: s9 } = e6, n16 = t5.includes("image"), a14 = "esriImageServiceDataTypeElevation" === e6.serviceDataType, o4 = !(!e6.spatialReference && !((_a = e6.extent) == null ? void 0 : _a.spatialReference)), l11 = t5.includes("edit"), u7 = t5.includes("mensuration") && o4, p20 = null == e6.mensurationCapabilities ? [] : e6.mensurationCapabilities.toLowerCase().split(",").map((e7) => e7.trim()), m13 = u7 && p20.includes("basic"), c22 = this._isMosaicDataset(e6) && t5.includes("catalog"), d13 = t5.includes("download");
      return { data: { supportsAttachment: false }, operations: { supportsComputeHistograms: n16, supportsExportImage: n16, supportsIdentify: n16, supportsImageToMap: r2 >= 11.2 && c22, supportsImageToMapMultiray: r2 >= 11.2 && c22, supportsMapToImage: r2 >= 11.2 && c22, supportsFindImages: r2 >= 11.2 && c22, supportsGetImageUrl: r2 >= 11.2 && d13, supportsMeasure: u7, supportsMeasureFromImage: r2 >= 11.2, supportsDownload: d13, supportsQuery: c22 && e6.fields && e6.fields.length > 0, supportsGetSamples: r2 >= 10.2 && n16, supportsProject: r2 >= 10.3 && n16, supportsComputeStatisticsHistograms: r2 >= 10.4 && n16, supportsQueryBoundary: r2 >= 10.6 && n16, supportsCalculateVolume: r2 >= 10.7 && a14, supportsComputePixelLocation: r2 >= 10.7 && c22, supportsComputeAngles: r2 >= 10.91, supportsQueryGPSInfo: r2 >= 11.2 && c22, supportsAdd: l11, supportsDelete: l11, supportsEditing: l11, supportsUpdate: l11, supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsChangeTracking: false, supportsQueryAttachments: false, supportsResizeAttachments: false, supportsSync: false, supportsExceedsLimitStatistics: false, supportsQueryAnalytics: false, supportsQueryTopFeatures: false, supportsAsyncConvert3D: false }, query: { maxRecordCount: s9, maxRecordCountFactor: void 0, supportsStatistics: !!(i10 == null ? void 0 : i10.supportsStatistics), supportsOrderBy: !!(i10 == null ? void 0 : i10.supportsOrderBy), supportsDistinct: !!(i10 == null ? void 0 : i10.supportsDistinct), supportsPagination: !!(i10 == null ? void 0 : i10.supportsPagination), supportsStandardizedQueriesOnly: !!(i10 == null ? void 0 : i10.useStandardizedQueries), supportsPercentileStatistics: !!(i10 == null ? void 0 : i10.supportsPercentileStatistics), supportsCentroid: !!(i10 == null ? void 0 : i10.supportsReturningGeometryCentroid), supportsDistance: !!(i10 == null ? void 0 : i10.supportsQueryWithDistance), supportsExtent: !!(i10 == null ? void 0 : i10.supportsReturningQueryExtent), supportsGeometryProperties: !!(i10 == null ? void 0 : i10.supportsReturningGeometryProperties), supportsHavingClause: !!(i10 == null ? void 0 : i10.supportsHavingClause), supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryGeometry: false, supportsResultType: false, supportsMaxRecordCountFactor: false, supportsSqlExpression: false, supportsTopFeaturesQuery: false, supportsQueryByAnonymous: false, supportsQueryByOthers: false, supportsHistoricMoment: false, supportsFormatPBF: false, supportsDisjointSpatialRelationship: false, supportsCacheHint: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsDefaultSpatialReference: !!(i10 == null ? void 0 : i10.supportsDefaultSR), supportsFullTextSearch: false, supportsCompactGeometry: false, standardMaxRecordCount: void 0, tileMaxRecordCount: void 0 }, mensuration: { supportsDistanceAndAngle: m13, supportsAreaAndPerimeter: m13, supportsPointOrCentroid: m13, supportsHeightFromBaseAndTop: u7 && p20.includes("base-top height"), supportsHeightFromBaseAndTopShadow: u7 && p20.includes("base-top shadow height"), supportsHeightFromTopAndTopShadow: u7 && p20.includes("top-top shadow height"), supports3D: u7 && p20.includes("3d") } };
    }
  };
  function We2(e6) {
    return (e6 == null ? void 0 : e6.path) ?? "";
  }
  return e([y({ clonable: false })], f9.prototype, "_functionRasterInfos", void 0), e([y({ clonable: false })], f9.prototype, "_rasterJobHandler", void 0), e([y({ clonable: false })], f9.prototype, "_cachedRendererJson", void 0), e([y({ readOnly: true })], f9.prototype, "_serviceSupportsMosaicRule", void 0), e([o2("_serviceSupportsMosaicRule", ["currentVersion", "fields"])], f9.prototype, "readServiceSupportsMosaicRule", null), e([y({ readOnly: true })], f9.prototype, "_rasterAttributeTableFieldPrefix", void 0), e([y({ readOnly: true })], f9.prototype, "_rasterFunctionNamesIndex", null), e([y()], f9.prototype, "adjustAspectRatio", void 0), e([y({ type: [T], json: { write: true } })], f9.prototype, "bandIds", void 0), e([o2("bandIds")], f9.prototype, "readBandIds", null), e([y({ readOnly: true, json: { read: false } })], f9.prototype, "capabilities", void 0), e([o2("service", "capabilities", ["capabilities", "currentVersion", "serviceDataType"])], f9.prototype, "readCapabilities", null), e([y({ type: Number })], f9.prototype, "compressionQuality", void 0), e([r("compressionQuality")], f9.prototype, "writeCompressionQuality", null), e([y({ type: Number })], f9.prototype, "compressionTolerance", void 0), e([r("compressionTolerance")], f9.prototype, "writeCompressionTolerance", null), e([y({ json: { read: { source: "copyrightText" } } })], f9.prototype, "copyright", void 0), e([y({ readOnly: true, dependsOn: ["_serviceSupportsMosaicRule"] })], f9.prototype, "defaultMosaicRule", void 0), e([o2("defaultMosaicRule", ["defaultMosaicMethod"])], f9.prototype, "readDefaultMosaicRule", null), e([y({ type: String, json: { name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], f9.prototype, "definitionExpression", void 0), e([y({ readOnly: true, constructOnly: true })], f9.prototype, "exportImageServiceParameters", void 0), e([y()], f9.prototype, "rasterInfo", void 0), e([y({ readOnly: true, type: [y3] })], f9.prototype, "fields", void 0), e([y({ readOnly: true })], f9.prototype, "fieldsIndex", null), e([y({ type: ["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"], json: { write: true } })], f9.prototype, "format", null), e([o2("service", "format", ["serviceDataType"])], f9.prototype, "readFormat", null), e([y({ type: w })], f9.prototype, "fullExtent", void 0), e([y({ readOnly: true })], f9.prototype, "hasMultidimensions", void 0), e([y({ json: { read: { source: "maxImageHeight" } } })], f9.prototype, "imageMaxHeight", void 0), e([y({ json: { read: { source: "maxImageWidth" } } })], f9.prototype, "imageMaxWidth", void 0), e([y({ type: String, json: { type: a5.jsonValues, read: a5.read, write: a5.write } })], f9.prototype, "interpolation", void 0), e([y()], f9.prototype, "minScale", void 0), e([o2("service", "minScale")], f9.prototype, "readMinScale", null), e([y()], f9.prototype, "maxScale", void 0), e([o2("service", "maxScale")], f9.prototype, "readMaxScale", null), e([y({ type: j5 })], f9.prototype, "mosaicRule", null), e([o2("mosaicRule", ["mosaicRule", "defaultMosaicMethod"])], f9.prototype, "readMosaicRule", null), e([r("mosaicRule")], f9.prototype, "writeMosaicRule", null), e([y()], f9.prototype, "multidimensionalInfo", void 0), e([y({ type: c4, json: { write: true } })], f9.prototype, "multidimensionalSubset", void 0), e([y({ json: { type: T } })], f9.prototype, "noData", void 0), e([r("noData")], f9.prototype, "writeNoData", null), e([y({ type: String, json: { type: i3.jsonValues, read: i3.read, write: i3.write } })], f9.prototype, "noDataInterpretation", void 0), e([y({ type: String, readOnly: true, json: { read: { source: ["fields"] } } })], f9.prototype, "objectIdField", void 0), e([o2("objectIdField")], f9.prototype, "readObjectIdField", null), e([y({ readOnly: true })], f9.prototype, "geometryType", void 0), e([y({})], f9.prototype, "typeIdField", void 0), e([y({})], f9.prototype, "types", void 0), e([y({ readOnly: true })], f9.prototype, "parsedUrl", null), e([y({ type: Function })], f9.prototype, "pixelFilter", void 0), e([y()], f9.prototype, "raster", void 0), e([y({ readOnly: true })], f9.prototype, "sourceType", void 0), e([o2("sourceType", ["serviceSourceType", "fields"])], f9.prototype, "readSourceType", null), e([y()], f9.prototype, "viewId", void 0), e([y({ types: l3, json: { name: "layerDefinition.drawingInfo.renderer", origins: { "web-scene": { types: d6, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e6) => ({ enabled: e6 && "vector-field" !== e6.type && "flow" !== e6.type }) } } } } })], f9.prototype, "renderer", null), e([o2("renderer")], f9.prototype, "readRenderer", null), e([r("renderer")], f9.prototype, "writeRenderer", null), e([y({ clonable: false })], f9.prototype, "symbolizer", void 0), e([y(g)], f9.prototype, "opacity", void 0), e([y({ readOnly: true })], f9.prototype, "rasterFields", null), e([y({ constructOnly: true })], f9.prototype, "rasterFunctionInfos", void 0), e([y({ type: N })], f9.prototype, "renderingRule", null), e([y({ type: N, json: { name: "renderingRule" } })], f9.prototype, "rasterFunction", null), e([o2("rasterFunction", ["renderingRule", "rasterFunctionInfos"])], f9.prototype, "readRasterFunction", null), e([y({ readOnly: true })], f9.prototype, "serviceDataType", void 0), e([y({ readOnly: true, type: f2 })], f9.prototype, "spatialReference", void 0), e([o2("spatialReference", ["spatialReference", "extent"])], f9.prototype, "readSpatialReference", null), e([y({ json: { type: n8.jsonValues } })], f9.prototype, "pixelType", void 0), e([o2("pixelType")], f9.prototype, "readPixelType", null), e([r("pixelType")], f9.prototype, "writePixelType", null), e([y({ constructOnly: true, type: m })], f9.prototype, "serviceRasterInfo", void 0), e([y()], f9.prototype, "sourceJSON", void 0), e([y(d3)], f9.prototype, "url", void 0), e([y({ readOnly: true })], f9.prototype, "version", void 0), e([o2("version", ["currentVersion", "fields", "timeInfo"])], f9.prototype, "readVersion", null), f9 = e([a4("esri.layers.mixins.ArcGISImageService")], f9), f9;
};

// node_modules/@arcgis/core/layers/ImageryLayer.js
var T4 = class extends n4(f6(t(u2(j3(We(f3(e2(l(S(i(b))))))))))) {
  constructor(...e6) {
    super(...e6), this.isReference = null, this.operationalLayerType = "ArcGISImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.type = "imagery", this._debouncedSaveOperations = k(async (e7, r2, t5) => {
      const { save: s9, saveAs: i10 } = await import("./imageryUtils-2KIKRXHV.js");
      switch (e7) {
        case A.SAVE:
          return s9(this, r2);
        case A.SAVE_AS:
          return i10(this, t5, r2);
      }
    });
  }
  normalizeCtorArgs(e6, r2) {
    return "string" == typeof e6 ? { url: e6, ...r2 } : e6;
  }
  load(e6) {
    const r2 = null != e6 ? e6.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e6).catch(a2).then(() => this._fetchService(r2))), Promise.resolve(this);
  }
  get legendEnabled() {
    return !this._isPreviewLayer && (this._get("legendEnabled") ?? true);
  }
  set legendEnabled(e6) {
    this._set("legendEnabled", e6);
  }
  get listMode() {
    return this._isPreviewLayer ? "hide" : this._get("listMode");
  }
  set listMode(e6) {
    this._set("listMode", e6);
  }
  writeOperationalLayerType(e6, r2, t5) {
    var _a;
    const s9 = "vector-field" === ((_a = this.renderer) == null ? void 0 : _a.type);
    r2[t5] = s9 ? "ArcGISImageServiceVectorLayer" : "ArcGISImageServiceLayer";
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get _isPreviewLayer() {
    var _a;
    return !(!this.raster || !((_a = this.url) == null ? void 0 : _a.toLowerCase().includes("/rasterrendering/imageserver")));
  }
  createPopupTemplate(e6) {
    var _a;
    const r2 = this.rasterFields, t5 = this.title, s9 = /* @__PURE__ */ new Set();
    let i10 = false, o4 = false;
    this.capabilities && (i10 = this.capabilities.operations.supportsQuery && this.fields && this.fields.length > 0, o4 = "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType);
    const a14 = /* @__PURE__ */ new Set();
    i10 && a14.add("raster.itempixelvalue");
    for (const n16 of r2) {
      const e7 = n16.name.toLowerCase();
      a14.has(e7) || e7.includes("raster.servicepixelvalue.") || s9.add(n16.name);
    }
    o4 && s9.add("raster.magnitude").add("raster.direction");
    const p20 = p2({ fields: r2, title: t5 }, { ...e6, visibleFieldNames: s9 });
    return (p20 == null ? void 0 : p20.fieldInfos) && ((_a = this.rasterInfo) == null ? void 0 : _a.pixelType.startsWith("f")) && p20.fieldInfos.forEach(({ format: e7, fieldName: r3 }) => {
      e7 && /^raster\.(item|service)pixelvalue/i.test(r3) && (e7.places = 2);
    }), p20;
  }
  queryFeatures(e6, r2) {
    return this.queryRasters(e6, r2).then((e7) => {
      if (e7 == null ? void 0 : e7.features)
        for (const r3 of e7.features)
          r3.layer = r3.sourceLayer = this;
      return e7;
    });
  }
  queryFeatureCount(e6, r2) {
    return this.queryRasterCount(e6, r2);
  }
  redraw() {
    this.emit("redraw");
  }
  async save(e6) {
    return this._debouncedSaveOperations(A.SAVE, e6);
  }
  async saveAs(e6, r2) {
    return this._debouncedSaveOperations(A.SAVE_AS, r2, e6);
  }
  serviceSupportsSpatialReference(e6) {
    return e3(this, e6);
  }
  write(e6, r2) {
    if (!this._isPreviewLayer)
      return super.write(e6, r2);
    if (r2 == null ? void 0 : r2.messages) {
      const e7 = `${r2.origin}/${r2.layerContainerType || "operational-layers"}`;
      r2.messages.push(new s("layer:unsupported", `Imagery preview layer (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e7}'`, { layer: this }));
    }
    return null;
  }
};
e([y(c2)], T4.prototype, "legendEnabled", null), e([y({ type: ["show", "hide"] })], T4.prototype, "listMode", null), e([y({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], T4.prototype, "isReference", void 0), e([y({ type: ["ArcGISImageServiceLayer"], json: { origins: { "web-map": { type: ["ArcGISImageServiceLayer", "ArcGISImageServiceVectorLayer"], read: false, write: { target: "layerType", ignoreOrigin: true } } } } })], T4.prototype, "operationalLayerType", void 0), e([r("web-map", "operationalLayerType")], T4.prototype, "writeOperationalLayerType", null), e([y(y4)], T4.prototype, "popupEnabled", void 0), e([y({ type: P2, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], T4.prototype, "popupTemplate", void 0), e([y({ readOnly: true })], T4.prototype, "defaultPopupTemplate", null), e([y({ readOnly: true, json: { read: false } })], T4.prototype, "type", void 0), e([y({ readOnly: true })], T4.prototype, "_isPreviewLayer", null), T4 = e([a4("esri.layers.ImageryLayer")], T4);
var x4 = T4;
export {
  x4 as default
};
//# sourceMappingURL=ImageryLayer-GZ46GC6Y.js.map
