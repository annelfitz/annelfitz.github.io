import {
  E as E2,
  v as v3,
  x as x2
} from "./chunk-4Z5TDPGV.js";
import "./chunk-RIBUBPHP.js";
import {
  e as e6
} from "./chunk-EPOP3OQ6.js";
import "./chunk-HWBFFWYY.js";
import "./chunk-OI7VGKTO.js";
import "./chunk-BEXFYHUM.js";
import {
  t as t2
} from "./chunk-IKON42NH.js";
import "./chunk-D5LHX57G.js";
import {
  e as e5,
  n as n3
} from "./chunk-HLKM6YBE.js";
import {
  t
} from "./chunk-CDYT7KXF.js";
import {
  i
} from "./chunk-WK2KEW7P.js";
import {
  g
} from "./chunk-G4YIJOSP.js";
import {
  a as a3,
  s as s3
} from "./chunk-PMQ5HDZI.js";
import {
  e as e4
} from "./chunk-EAAEPSBY.js";
import "./chunk-5T2QNVDA.js";
import {
  O,
  d as d2
} from "./chunk-QWNRUCON.js";
import "./chunk-QRKFUTEF.js";
import {
  O as O2,
  j as j2
} from "./chunk-CEUXXR2I.js";
import "./chunk-SCRCLNT5.js";
import "./chunk-YKIGDW5O.js";
import "./chunk-ECTYMEUP.js";
import "./chunk-FHDHOWK5.js";
import "./chunk-F3BQGS35.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-QYC3GV65.js";
import "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import "./chunk-I2X6UR6L.js";
import "./chunk-QX66UTIR.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import {
  S,
  j,
  v as v2
} from "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import {
  y as y2
} from "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import {
  Q
} from "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import {
  D,
  e2 as e3,
  r
} from "./chunk-RGCWZ2KZ.js";
import {
  n as n2
} from "./chunk-5VMSFOCB.js";
import "./chunk-LGQXPGTM.js";
import "./chunk-2SDMYJDE.js";
import "./chunk-TPLOIZC7.js";
import {
  u
} from "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import {
  E,
  F,
  a as a2,
  o as o4,
  x
} from "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import {
  DateTime,
  FixedOffsetZone,
  IANAZone
} from "./chunk-NIDZ6R4E.js";
import {
  s as s2
} from "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import {
  c
} from "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  A,
  P,
  d,
  p,
  v
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  o as o3
} from "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  b,
  e as e2,
  f,
  o3 as o2
} from "./chunk-JGDJR5EV.js";
import {
  n
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  o2 as o,
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-MDRC3XUT.js";
import "./chunk-NCF6OYL5.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/widgets/Directions/css.js
var e7 = "esri-directions";
var t3 = { base: e7, addStopButton: `${e7}__add-stop-button`, arrivalTime: `${e7}__arrival-time`, arrivalTimeContainer: `${e7}__arrival-time-container`, clearRouteButton: `${e7}__clear-route-button`, collapsibleSection: `${e7}__maneuver-section--collapsible`, contentTitle: `${e7}__content-title`, costsDetails: `${e7}__costs-details`, departureDateTimePickers: `${e7}__departure-date-time-pickers`, departureTime: `${e7}__departure-time`, departureTimeControls: `${e7}__departure-time-controls`, departureTimeSelect: `${e7}__departure-time-select`, directionCosts: `${e7}__costs`, directionsSection: `${e7}__directions-section`, horizontalSplitter: `${e7}__horizontal-splitter`, interactiveStopIcon: `${e7}__stop-icon--interactive`, intermediateCost: `${e7}__cost--intermediate`, lastStopIconContainer: `${e7}__stop-icon-container--last`, layerDetailsLink: `${e7}__layer-details-link`, loader: `${e7}__loader`, maneuver: `${e7}__maneuver`, maneuverActive: `${e7}__maneuver--active`, maneuverCosts: `${e7}__maneuver-costs`, maneuverCostsContainer: `${e7}__maneuver-costs-container`, maneuverIcon: `${e7}__maneuver-icon`, maneuverList: `${e7}__maneuver-list`, maneuverPlaceName: `${e7}__maneuver-place-name`, maneuverSection: `${e7}__maneuver-section`, maneuverSectionHeader: `${e7}__maneuver-section-header`, maneuverSectionHeaderButton: `${e7}__maneuver-section-header-toggle-button`, maneuverSectionTitle: `${e7}__maneuver-section-title`, maneuverSectionToggle: `${e7}__maneuver-section-toggle`, maneuvers: `${e7}__maneuvers`, message: `${e7}__message`, messageHeading: `${e7}__message_heading`, panelContent: `${e7}__panel-content`, panelContentError: `${e7}__panel-content--error`, panelContentLoading: `${e7}__panel-content--loading`, panelContentSignIn: `${e7}__panel-content--sign-in`, primaryCosts: `${e7}__costs-value`, printButton: `${e7}__print-button`, removeStop: `${e7}__remove-stop-icon`, removeStopButton: `${e7}__remove-stop`, reverseStops: `${e7}__reverse-stops`, routeActions: `${e7}__route-actions`, saveAsButton: `${e7}__save-as-button`, saveAsButtonPopover: `${e7}__save-as-button-with-popover`, saveButton: `${e7}__save-button`, saveButtons: `${e7}__save-buttons`, savePopover: `${e7}__save-popover`, saveSection: `${e7}__save-section`, scroller: `${e7}__scroller`, secondaryCosts: `${e7}__other-costs-total`, section: `${e7}__section`, sectionSplitter: `${e7}__section-splitter`, signInButton: `${e7}__sign-in-button`, signInContent: `${e7}__sign-in-content`, stopHandle: `${e7}__stop-handle`, stopHandleIcon: `${e7}__stop-handle-icon`, stopIcon: `${e7}__stop-icon`, stopIconContainer: `${e7}__stop-icon-container`, stopInput: `${e7}__stop-input`, stopOptions: `${e7}__stop-options`, stopRow: `${e7}__stop-row`, stopRowGhost: `${e7}__stop-row-ghost`, stops: `${e7}__stops`, summary: `${e7}__summary`, toolbarButtons: `${e7}__toolbar-buttons`, toolbarSection: `${e7}__toolbar-section`, travelMode: `${e7}__travel-modes`, travelModeSelect: `${e7}__travel-modes-select`, validStopRow: `${e7}__stop-row--valid`, verticalSplitter: `${e7}__vertical-splitter`, warningCard: `${e7}__warning-card`, warningHeader: `${e7}__warning-header`, warningHeading: `${e7}__warning-heading`, warningMessage: `${e7}__warning-message` };

// node_modules/@arcgis/core/widgets/Directions/support/directionsUtils.js
var n4 = /* @__PURE__ */ new Map([["arrive", "route-to"], ["bear-left", "bear-left"], ["bear-right", "bear-right"], ["boundary-crossing", "blank"], ["central-fork", "fork-middle"], ["clockwise-roundabout", "round-about-right"], ["counter-clockwise-roundabout", "round-about"], ["depart", "route-from"], ["door", "walk-through-door"], ["down-elevator", "elevator-down"], ["down-escalator", "escalator-down"], ["down-stairs", "stairs-down"], ["elevator", "elevator"], ["escalator", "escalator"], ["general-event", "information"], ["header", "blank"], ["landmark", "map-pin"], ["lane", "blank"], ["left-fork", "fork-left"], ["left-handed-u-turn", "u-turn"], ["left-ramp", "ramp-left"], ["left-turn", "left"], ["left-turn-and-immediate-left-turn", "left-left"], ["left-turn-and-immediate-right-turn", "left-right"], ["off-ferry", "disembark"], ["on-ferry", "embark"], ["pedestrian-ramp", "take-pedestrian-ramp"], ["restriction-violation", "exclamation-mark-triangle"], ["right-fork", "fork-right"], ["right-handed-u-turn", "u-turn-right"], ["right-ramp", "ramp-right"], ["right-turn", "right"], ["right-turn-and-immediate-left-turn", "right-left"], ["right-turn-and-immediate-right-turn", "right-right"], ["roundabout", "round-about"], ["scaled-cost-barrier-event", "blank"], ["sharp-left", "sharp-left"], ["sharp-right", "sharp-right"], ["stairs", "stairs"], ["straight", "straight"], ["time-zone-change", "clock"], ["traffic-event", "exclamation-mark-triangle"], ["u-turn", "u-turn"], ["up-elevator", "elevator-up"], ["up-escalator", "escalator-up"], ["up-stairs", "stairs-up"]]);
var i2;
function u2(t4, r2) {
  return u(t4, { style: "unit", unit: r2, unitDisplay: "short" });
}
function o5(a4, n5, i3) {
  if (0 === n5)
    return "";
  let u3, o6, l2 = 0;
  const s5 = a3(n5, "meters");
  switch (i3) {
    case "metric":
      s5.value < 0.01 ? { value: u3, unit: o6 } = s3(s5, "millimeters") : s5.value < 1 ? { value: u3, unit: o6 } = s3(s5, "centimeters") : s5.value < 1e3 ? { value: u3, unit: o6 } = s3(s5, "meters") : s5.value < 1e5 ? ({ value: u3, unit: o6 } = s3(s5, "kilometers"), l2 = 1) : { value: u3, unit: o6 } = s3(s5, "kilometers");
      break;
    case "imperial":
      s5.value < 0.254 ? { value: u3, unit: o6 } = s3(s5, "inches") : s5.value < 160.9344 ? { value: u3, unit: o6 } = s3(s5, "feet") : s5.value < 160934.4 ? ({ value: u3, unit: o6 } = s3(s5, "miles"), l2 = 1) : { value: u3, unit: o6 } = s3(s5, "miles");
      break;
    default:
      ({ value: u3, unit: o6 } = s3(s5, i3)), l2 = 2;
  }
  return g(a4, u3, o6, l2);
}
function l(t4) {
  if (0 === t4)
    return "";
  if (t4 < 1) {
    return u2(Math.floor(60 * t4), "second");
  }
  if (t4 < 60) {
    return u2(Math.floor(t4), "minute");
  }
  const r2 = Math.floor(t4 / 60);
  if (t4 < 1440) {
    const e8 = Math.floor(t4 % 60);
    return 0 === e8 ? `${u2(r2, "hour")}` : `${u2(r2, "hour")} ${u2(e8, "minute")}`;
  }
  return u2(r2, "hour");
}
function s4(t4) {
  return null != t4 && n4.has(t4) ? n4.get(t4) : "blank";
}
!function(t4) {
  t4.NOW = "now", t4.DEPART_AT = "depart-at", t4.UNSPECIFIED = "unspecified";
}(i2 || (i2 = {}));

// node_modules/@arcgis/core/widgets/Directions/DirectionsViewModel.js
function j3(e8) {
  return "esri.Graphic" === (e8 == null ? void 0 : e8.declaredClass);
}
function P2(e8) {
  return "esri.rest.support.Stop" === (e8 == null ? void 0 : e8.declaredClass);
}
var L;
!function(e8) {
  e8[e8.Active = 0] = "Active", e8[e8.Complete = 1] = "Complete", e8[e8.Failed = 2] = "Failed", e8[e8.Idle = 3] = "Idle", e8[e8.Suspended = 4] = "Suspended";
}(L || (L = {}));
var E3 = class extends t2(o3.EventedAccessor) {
  constructor(e8) {
    super(e8), this._highlight = null, this._loadPromise = null, this._loadController = null, this._routeController = null, this._serviceDescriptionStatus = L.Idle, this.apiKey = void 0, this.defaultTravelMode = null, this.departureIsoDate = null, this.departureIsoTime = null, this.departureOption = i2.NOW, this.departureTime = "now", this.lastError = null, this.lastRoute = null, this.layer = null, this.maxStops = 50, this.routeParameters = new O({ directionsLengthUnits: "kilometers", findBestSequence: false, returnZ: true, startTime: null, startTimeIsUTC: true, useTimeWindows: false }), this.serviceDescription = null, this.view = null;
  }
  initialize() {
    var _a;
    this.addHandles([v(() => {
      var _a2;
      return (_a2 = this.layer) == null ? void 0 : _a2.stops;
    }, "change", () => {
      this.clearResults();
    }), d(() => this.layer, (e9) => {
      if (null != e9) {
        for (; e9.stops.length < 2; )
          e9.stops.add(new O2());
        this._set("defaultTravelMode", null), this.addHandles(p(() => {
          var _a2, _b;
          return null != this.serviceDescription ? (_b = (_a2 = e9.routeInfo) == null ? void 0 : _a2.analysisSettings) == null ? void 0 : _b.travelMode : null;
        }, (e10) => {
          this.defaultTravelMode = this._resolveDefaultTravelMode(e10);
        }, { once: true }));
      }
    }, A)]);
    const e8 = F(((_a = this.view) == null ? void 0 : _a.timeZone) ?? o4), t4 = DateTime.fromMillis(Date.now());
    this.departureIsoDate = t4.toFormat(v2, j(e8)), this.departureIsoTime = t4.toFormat(S, j(e8));
  }
  get _directionsLanguage() {
    if (null == this.serviceDescription)
      return;
    const e8 = this.serviceDescription.directionsSupportedLanguages;
    if (!e8)
      return;
    const t4 = (this.routeParameters.directionsLanguage ?? c()).slice(0, 2);
    return e8.find((e9) => e9.toLowerCase().slice(0, 2) === t4);
  }
  get formattedEta() {
    var _a, _b, _c, _d, _e, _f;
    const e8 = (_b = (_a = this.layer) == null ? void 0 : _a.routeInfo) == null ? void 0 : _b.endTime, t4 = (_d = (_c = this.layer) == null ? void 0 : _c.routeInfo) == null ? void 0 : _d.endTimeOffset;
    if (this.departureOption === i2.UNSPECIFIED || !e8 || !t4)
      return null;
    const r2 = DateTime.fromJSDate(e8, { zone: FixedOffsetZone.instance(t4) }), i3 = DateTime.fromJSDate(e8, { zone: IANAZone.create(F(((_e = this.view) == null ? void 0 : _e.timeZone) ?? o4)) }), s5 = DateTime.fromJSDate(/* @__PURE__ */ new Date(), { zone: IANAZone.create(F(((_f = this.view) == null ? void 0 : _f.timeZone) ?? o4)) }), o6 = s5.year === i3.year && s5.month === i3.month && s5.day === i3.day, l2 = i3.offset === t4 ? void 0 : a2, a4 = o6 ? void 0 : E("short-date"), n5 = E("short-time");
    return x(r2.toISO(), { ...a4, ...n5, timeZoneName: l2 });
  }
  get impedanceAttribute() {
    var _a, _b;
    const e8 = ((_a = this.routeParameters.travelMode) == null ? void 0 : _a.impedanceAttributeName) ?? this.routeParameters.impedanceAttribute ?? ((_b = this.serviceDescription) == null ? void 0 : _b.impedance) ?? null;
    return this.getCostAttribute(e8);
  }
  get selectedTravelMode() {
    var _a;
    return null == this.serviceDescription ? null : this.defaultTravelMode ?? this.serviceDescription.defaultTravelMode ?? ((_a = this.serviceDescription.supportedTravelModes) == null ? void 0 : _a[0]) ?? null;
  }
  set selectedTravelMode(e8) {
    this._override("selectedTravelMode", e8);
  }
  get state() {
    if (null != this._routeController)
      return "routing";
    if (null != this.lastError)
      return "error";
    switch (this._serviceDescriptionStatus) {
      case L.Suspended:
        return "unauthenticated";
      case L.Idle:
        return "disabled";
      case L.Active:
        return "initializing";
      case L.Failed:
        return "error";
      default:
        return "ready";
    }
  }
  get timeAttribute() {
    var _a, _b;
    const e8 = ((_a = this.routeParameters.travelMode) == null ? void 0 : _a.timeAttributeName) ?? this.routeParameters.directionsTimeAttribute ?? ((_b = this.serviceDescription) == null ? void 0 : _b.directionsTimeAttribute) ?? null;
    return this.getCostAttribute(e8);
  }
  get travelModes() {
    var _a, _b;
    const e8 = ((_b = (_a = this.serviceDescription) == null ? void 0 : _a.supportedTravelModes) == null ? void 0 : _b.slice()) ?? [];
    return null == this.defaultTravelMode || e8.includes(this.defaultTravelMode) || e8.unshift(this.defaultTravelMode), e8;
  }
  async load() {
    if (null != this._loadPromise)
      return this._loadPromise;
    this._loadPromise = this._load(), await this._loadPromise, this._loadPromise = null;
  }
  async highlight(e8) {
    if (this.clearHighlights(), !this.view || !this.layer)
      return;
    const t4 = await this.view.whenLayerView(this.layer);
    this._highlight = t4.highlight(e8);
  }
  clearHighlights() {
    null != this._highlight && (this._highlight.remove(), this._highlight = null);
  }
  centerAt(e8) {
    if (null == this.view)
      return;
    const t4 = P2(e8) || j3(e8) ? e8.geometry : e8;
    null != t4 && this.callGoTo({ target: t4 });
  }
  clearResults() {
    var _a;
    this._set("lastRoute", null), (_a = this.layer) == null ? void 0 : _a.removeResult();
  }
  async getDirections() {
    var _a;
    const { apiKey: e8, layer: t4, state: i3 } = this;
    if (null == t4)
      throw new s("directions-view-model:missing-route-layer", "A route layer must be associated with the view model.");
    if ("unauthenticated" === i3 || "initializing" === i3 || "disabled" === i3 || this._serviceDescriptionStatus === L.Failed)
      throw new s("directions-view-model:not-loaded", "Cannot get directions until view model loads.");
    this._set("lastError", null), null != this._routeController && (this._routeController.abort(), this._routeController = null);
    const { startTime: o6, startTimeIsUTC: l2 } = this._getStartTimeParameters(), a4 = ((_a = this.view) == null ? void 0 : _a.spatialReference) ?? null, n5 = this.routeParameters.clone();
    n5.set({ startTime: o6, startTimeIsUTC: l2, directionsLanguage: this._directionsLanguage, apiKey: e8, outSpatialReference: a4 }), null != this.selectedTravelMode && (n5.travelMode = this.selectedTravelMode);
    if (t4.stops.filter(({ geometry: e9 }) => null != e9).length < 2) {
      const e9 = new s("directions-view-model:not-enough-stops", "Not enough stops for routing");
      throw this._set("lastError", e9), e9;
    }
    this._routeController = new AbortController();
    const { signal: u3 } = this._routeController;
    let d3 = null;
    try {
      d3 = await t4.solve(n5, { signal: u3 });
    } catch (c3) {
      if (!b(c3)) {
        const e9 = new s("directions-view-model:unable-to-route", "Unable to route to these addresses", { error: c3 });
        throw this._set("lastError", e9), this._set("lastRoute", null), e9;
      }
    } finally {
      this._routeController = null;
    }
    for (const r2 of d3.stops)
      null == r2.geometry && (r2.name = null);
    return t4.update(d3), this._set("lastRoute", d3), this.zoomToRoute(), d3;
  }
  getCostAttribute(e8) {
    var _a, _b;
    return (((_b = (_a = this.serviceDescription) == null ? void 0 : _a.networkDataset) == null ? void 0 : _b.networkAttributes) ?? []).find(({ name: t4, usageType: r2 }) => t4 === e8 && "cost" === r2) ?? null;
  }
  reset() {
    this.clearHighlights(), this.clearResults(), null != this.layer && (this.layer.removeAll(), this.layer.stops = new V([new O2(), new O2()]));
  }
  save() {
    if (!this.layer)
      throw new s("directions-view-model:missing-layer", "save() requires a layer");
    return this.layer.save();
  }
  saveAs(e8, t4 = {}) {
    if (!this.layer)
      throw new s("directions-view-model:missing-layer", "saveAs() requires a layer");
    return this.layer.saveAs(e8, t4);
  }
  updateDepartureTime() {
    if (this.departureIsoDate && this.departureIsoTime)
      switch (this.departureOption) {
        case i2.NOW:
          this.departureTime = "now";
          break;
        case i2.DEPART_AT: {
          const e8 = DateTime.fromISO(`${this.departureIsoDate}T${this.departureIsoTime}`, { zone: FixedOffsetZone.instance(0) });
          this.departureTime = e8.toJSDate();
          break;
        }
        case i2.UNSPECIFIED:
          this.departureTime = null;
      }
  }
  zoomToRoute() {
    const { view: e8, layer: t4 } = this;
    if (null == e8 || null == (t4 == null ? void 0 : t4.routeInfo))
      return;
    const { geometry: r2 } = t4.routeInfo;
    if (null == r2)
      return;
    const i3 = r2.extent;
    if (!i3)
      return;
    const s5 = i3.width > i3.height, o6 = i3.clone().expand(s5 ? 2 : 1);
    this.callGoTo({ target: o6 });
  }
  _getStartTimeParameters() {
    var _a;
    if ("now" === this.departureTime) {
      return { startTime: ((_a = this.serviceDescription) == null ? void 0 : _a.capabilities.supportsNow) ?? false ? "now" : /* @__PURE__ */ new Date(), startTimeIsUTC: true };
    }
    return null == this.departureTime ? { startTime: void 0, startTimeIsUTC: void 0 } : { startTime: this.departureTime, startTimeIsUTC: false };
  }
  async _load() {
    if (null != this.serviceDescription || null == this.layer)
      return;
    null != this._loadController && (this._loadController.abort(), this._loadController = null), this._loadController = new AbortController();
    const { signal: e8 } = this._loadController;
    try {
      this._serviceDescriptionStatus = L.Active;
      const t4 = await d2(this.layer.url, this.apiKey, { signal: e8 });
      this._set("serviceDescription", t4), this._serviceDescriptionStatus = L.Complete;
    } catch (t4) {
      if (b(t4))
        return void (this._serviceDescriptionStatus = L.Idle);
      if ("identity-manager:user-aborted" === t4.name)
        return void (this._serviceDescriptionStatus = L.Suspended);
      const e9 = new s("directions-view-model:service-metadata-unavailable", "Cannot load route service metadata", { error: t4 });
      throw this._serviceDescriptionStatus = L.Failed, this._set("lastError", e9), e9;
    } finally {
      this._loadController = null;
    }
  }
  _resolveDefaultTravelMode(e8) {
    var _a, _b;
    if (null == this.serviceDescription)
      return null;
    const { defaultTravelMode: t4, supportedTravelModes: r2 } = this.serviceDescription, i3 = (_b = (_a = /^<(?<name>.*)>$/i.exec(e8.name)) == null ? void 0 : _a.groups) == null ? void 0 : _b.name;
    if (i3) {
      const s6 = r2 == null ? void 0 : r2.find(({ name: e9 }) => e9.toLocaleLowerCase() === i3.trim().toLocaleLowerCase()), o6 = s6 ?? t4;
      return j2.fromJSON({ ...o6 == null ? void 0 : o6.toJSON(), ...e8.toJSON() });
    }
    const s5 = r2 == null ? void 0 : r2.find(({ name: t5 }) => t5.toLocaleLowerCase() === e8.name.toLocaleLowerCase());
    return s5 ?? t4;
  }
};
e([y()], E3.prototype, "_directionsLanguage", null), e([y()], E3.prototype, "_routeController", void 0), e([y()], E3.prototype, "_serviceDescriptionStatus", void 0), e([y()], E3.prototype, "apiKey", void 0), e([y()], E3.prototype, "defaultTravelMode", void 0), e([y()], E3.prototype, "departureTime", void 0), e([y()], E3.prototype, "formattedEta", null), e([y({ readOnly: true })], E3.prototype, "impedanceAttribute", null), e([y()], E3.prototype, "lastError", void 0), e([y({ readOnly: true })], E3.prototype, "lastRoute", void 0), e([y()], E3.prototype, "layer", void 0), e([y({ type: Number, range: { min: 2, max: 50 }, nonNullable: true })], E3.prototype, "maxStops", void 0), e([y({ type: O, nonNullable: true })], E3.prototype, "routeParameters", void 0), e([y()], E3.prototype, "selectedTravelMode", null), e([y({ readOnly: true })], E3.prototype, "serviceDescription", void 0), e([y({ readOnly: true })], E3.prototype, "state", null), e([y({ readOnly: true })], E3.prototype, "timeAttribute", null), e([y()], E3.prototype, "travelModes", null), e([y()], E3.prototype, "view", void 0), e([y()], E3.prototype, "getDirections", null), e([y()], E3.prototype, "zoomToRoute", null), E3 = e([a("esri.widgets.Directions.DirectionsViewModel")], E3);
var R = E3;

// node_modules/@arcgis/core/widgets/Directions/components/SaveLayer.js
var c2 = "esri-save-layer";
var m = { panel: `${c2}`, error: `${c2}__error`, errorIcon: `${c2}__error-icon`, errorLabel: `${c2}__error-label`, layerNameLabel: `${c2}__layer-name-label`, portalFolderLabel: `${c2}__portal-folder-label`, processLabel: `${c2}__process-label`, processLoader: `${c2}__process-loader` };
var p2 = class extends D {
  constructor(e8, s5) {
    super(e8, s5), this._folders = null, this._layer = null, this._layerNameInput = null, this._portalFolderCombobox = null, this._userName = null, this.messages = null, this.messagesCommon = null, this.messagesIdentity = null, this.opened = false, this.state = "initialized", this.close = () => {
      this.opened = false, this.state = "initialized";
    };
  }
  loadDependencies() {
    return r({ button: () => import("./calcite-button-V4T5NPWY.js"), combobox: () => import("./calcite-combobox-2DABLAR5.js"), "combobox-item": () => import("./calcite-combobox-item-CJU6ESRT.js"), icon: () => import("./calcite-icon-25XWA6H7.js"), input: () => import("./calcite-input-CHG5BNQ7.js"), label: () => import("./calcite-label-W4VTHQAF.js"), loader: () => import("./calcite-loader-64JUXTQT.js"), panel: () => import("./calcite-panel-MK7QTGYZ.js") });
  }
  get label() {
    var _a;
    return ((_a = this.messages) == null ? void 0 : _a.widgetLabel) ?? "";
  }
  set label(e8) {
    this._overrideIfSome("label", e8);
  }
  async open(e8) {
    this.state = "initialized", this.opened = true, this._layer = e8, this.state = "connect-to-portal";
    const t4 = Q.getDefault();
    try {
      await t4.signIn();
    } catch (a4) {
      return void (b(a4) || "identity-manager:user-aborted" === a4.name ? this.close() : this.state = "connect-to-portal-error");
    }
    this.state = "fetch-portal-information";
    const { user: r2 } = t4;
    this._userName = r2 == null ? void 0 : r2.username;
    try {
      this._folders = await (r2 == null ? void 0 : r2.fetchFolders());
    } catch {
      return void (this.state = "fetch-portal-information-error");
    }
    this.state = "save-layer";
  }
  render() {
    switch (this.state) {
      case "initialized":
        return this._renderInitialized();
      case "connect-to-portal":
        return this._renderProcess(this.messagesIdentity.lblSigning);
      case "connect-to-portal-error":
        return this._renderError(this.messages.errors.authenticating);
      case "fetch-portal-information":
        return this._renderProcess(this.messages.processing.fetching);
      case "fetch-portal-information-error":
        return this._renderError(this.messages.errors.fetching);
      case "save-layer":
        return this._renderSaveLayer();
      case "saving":
        return this._renderProcess(this.messages.processing.saving);
      case "saving-error":
        return this._renderError(this.messages.errors.saving);
    }
  }
  _renderError(e8) {
    return n2("calcite-panel", { class: m.panel, heading: this.messages.widgetLabel, key: `${c2}-error-panel` }, n2("div", { class: m.error }, n2("calcite-icon", { class: m.errorIcon, icon: "exclamation-mark-triangle", scale: "l", textLabel: this.messagesCommon.errorMessage }), n2("calcite-label", { class: m.errorLabel }, e8)), n2("calcite-button", { appearance: "outline", onclick: this.close, slot: "footer-actions", width: "half" }, this.messagesCommon.close));
  }
  _renderInitialized() {
    return n2("calcite-panel", { class: m.panel, heading: this.messages.widgetLabel, key: `${c2}-initialize-panel` });
  }
  _renderProcess(e8) {
    return n2("calcite-panel", { class: m.panel, heading: this.messages.widgetLabel, key: `${c2}-process-panel` }, n2("calcite-loader", { class: m.processLoader, label: e8 }), n2("calcite-label", { alignment: "center", class: m.processLabel }, e8));
  }
  _renderSaveLayer() {
    if (null == this._layer || null == this._folders || null == this._userName)
      return this._renderInitialized();
    const { stops: e8 } = this._layer, s5 = `${e8.at(0).name} - ${e8.at(-1).name}`, t4 = this._folders.map((e9) => n2("calcite-combobox-item", { key: `${c2}-folder-${e9.id}`, textLabel: e9.title ?? "", value: e9.id }));
    return t4.unshift(n2("calcite-combobox-item", { key: `${c2}-folder-home`, selected: true, textLabel: `${this._userName} (${this.messagesCommon.home})`, value: null })), n2("calcite-panel", { class: m.panel, heading: this.messages.widgetLabel, key: `${c2}-save-panel` }, n2("calcite-label", { class: m.layerNameLabel }, this.messages.laverName, n2("calcite-input", { afterCreate: (e9) => {
      this._layerNameInput = e9;
    }, label: this.messages.laverName, value: s5 })), n2("calcite-label", { class: m.portalFolderLabel }, this.messages.saveInFolder, n2("calcite-combobox", { afterCreate: (e9) => {
      this._portalFolderCombobox = e9;
    }, label: this.messages.saveInFolder, overlayPositioning: "fixed", selectionMode: "single" }, t4)), n2("calcite-button", { onclick: () => this._saveButtonClick(), slot: "footer-actions", width: "half" }, this.messagesCommon.save), n2("calcite-button", { appearance: "outline", onclick: () => {
      this.close();
    }, slot: "footer-actions", width: "half" }, this.messagesCommon.cancel));
  }
  _saveButtonClick() {
    this.state = "saving", this._saveLayer().then(() => {
      this.close();
    }).catch(() => {
      this.state = "saving-error";
    });
  }
  async _saveLayer() {
    var _a, _b;
    if (null == this._layer || null == this._folders)
      return;
    const e8 = (_a = this._layerNameInput) == null ? void 0 : _a.value, s5 = (_b = this._portalFolderCombobox) == null ? void 0 : _b.value, t4 = this._folders.find((e9) => e9.id === s5);
    await this._layer.saveAs({ title: e8 }, { folder: t4 });
  }
};
e([y()], p2.prototype, "label", null), e([y(), e3("esri/widgets/support/t9n/SaveLayer")], p2.prototype, "messages", void 0), e([y(), e3("esri/t9n/common")], p2.prototype, "messagesCommon", void 0), e([y(), e3("esri/identity/t9n/identity")], p2.prototype, "messagesIdentity", void 0), e([y()], p2.prototype, "opened", void 0), e([y()], p2.prototype, "state", void 0), p2 = e([a("esri.widgets.Directions.components.SaveLayer")], p2);

// node_modules/sortablejs/modular/sortable.esm.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i3;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
      key = sourceSymbolKeys[i3];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.2";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i3 = 0, n5 = list.length;
    if (iterator) {
      for (; i3 < n5; i3++) {
        iterator(list[i3], i3);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i3 = 0, children = el.children;
  while (i3 < children.length) {
    if (children[i3].style.display !== "none" && children[i3] !== Sortable.ghost && (includeDragEl || children[i3] !== Sortable.dragged) && closest(children[i3], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i3];
      }
      currentChild++;
    }
    i3++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i3 in arr) {
    if (!arr.hasOwnProperty(i3))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i3][key])
        return Number(i3);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x4, y3) {
  el.scrollLeft += x4;
  el.scrollTop += y3;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($2) {
    return $2(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function getChildContainingRectFromElement(container, options, ghostEl2) {
  var rect = {};
  Array.from(container.children).forEach(function(child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2)
      return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p3) {
      if (p3.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault)
        return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl;
var parentEl;
var ghostEl;
var rootEl;
var nextEl;
var lastDownEl;
var cloneEl;
var cloneHidden;
var oldIndex;
var newIndex;
var oldDraggableIndex;
var newDraggableIndex;
var activeGroup;
var putSortable;
var awaitingDragStarted = false;
var ignoreNextClick = false;
var sortables = [];
var tapEvt;
var touchEvt;
var lastDx;
var lastDy;
var tapDistanceLeft;
var tapDistanceTop;
var moved;
var lastTarget;
var lastDirection;
var pastFirstInvertThresh = false;
var isCircumstantialInvert = false;
var targetMoveDistance;
var ghostRelativeParent;
var ghostRelativeParentInitialScroll = [];
var _silent = false;
var savedInputChecked = [];
var documentExists = typeof document !== "undefined";
var PositionGhostAbsolutely = IOS;
var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
var supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}();
var _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
};
var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
};
var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x4, y3) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x4 >= rect.left - threshold && x4 <= rect.right + threshold, insideVertically = y3 >= rect.top - threshold && y3 <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
};
var _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
};
var _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
};
var _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i3 in evt) {
        if (evt.hasOwnProperty(i3)) {
          event[i3] = evt[i3];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn in this) {
    if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
      this[fn] = this[fn].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el, "pointerdown", this._onTapStart);
  } else {
    on(el, "mousedown", this._onTapStart);
    on(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, "dragover", this);
    on(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mouseup", _this._onDrop);
      on(ownerDocument, "touchend", _this._onDrop);
      on(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on(ownerDocument, "touchend", _this._disableDelayedDrag);
        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e8) {
    var touch = e8.touches ? e8.touches[0] : e8;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [], el, children = this.el.children, i3 = 0, n5 = children.length, options = this.options;
    for (; i3 < n5; i3++) {
      el = children[i3];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i3) {
      var el = rootEl2.children[i3];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i3 = str.length, sum = 0;
  while (i3--) {
    sum += str.charCodeAt(i3);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [];
var scrollEl;
var scrollRootEl;
var scrolling = false;
var lastAutoScrollX;
var lastAutoScrollY;
var touchEvt$1;
var pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x4 = (evt.touches ? evt.touches[0] : evt).clientX, y3 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x4, y3);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x4 !== lastAutoScrollX || y3 !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x4, y3), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x4;
          lastAutoScrollY = y3;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x4 = (evt.touches ? evt.touches[0] : evt).clientX, y3 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x4) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x4) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y3) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y3) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i3 = 0; i3 <= layersOut; i3++) {
        if (!autoScrolls[i3]) {
          autoScrolls[i3] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval((function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }).bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
var sortable_esm_default = Sortable;

// node_modules/@arcgis/core/widgets/Directions.js
var x3 = { departureTime: true, layerDetails: true, printButton: false, saveAsButton: true, saveButton: true, stops: true, traveMode: true };
function U(e8) {
  const { branchName: t4, displayText: s5, exitName: o6, intersectingName: i3, name: r2, objectId: n5, towardName: a4 } = e8;
  if (null == s5)
    return null;
  const l2 = [t4, o6, i3, r2, a4].filter(Boolean).sort((e9, t5) => t5.length - e9.length).map((e9) => o(e9));
  if (!l2.length)
    return s5;
  const d3 = new RegExp(l2.join("|"), "g"), u3 = s5.matchAll(d3);
  let h = 0;
  const p3 = [];
  for (const { 0: c3, index: v4 } of u3)
    p3.push(s5.slice(h, v4), n2("span", { class: t3.maneuverPlaceName }, c3)), h = v4 + c3.length;
  return p3.push(s5.slice(h)), n2("span", { id: `${t3.maneuver}-${n5}` }, p3);
}
function z(e8) {
  var _a;
  return !!((_a = e8.composedPath) == null ? void 0 : _a.call(e8).find((e9) => {
    var _a2;
    return (_a2 = e9.classList) == null ? void 0 : _a2.contains("esri-search__suggestions-list");
  }));
}
function $(e8) {
  const t4 = new Date(e8);
  return new Date(t4.getUTCFullYear(), t4.getUTCMonth(), t4.getUTCDate());
}
var O3 = "search-term";
var F2 = 100;
var N = 500;
var V2 = class extends D {
  constructor(e8, t4) {
    super(e8, t4), this._activeStop = null, this._activeManeuver = null, this._autoStopRemovalDelay = F2, this._autoStopRemovalTimeoutId = void 0, this._focusedManeuver = null, this._newPlaceholderStop = null, this._pointerDownUpHandle = null, this._pointerPressedSearchSuggestionStop = null, this._renderSavePopoverFunction = null, this._saveAsButtonNode = null, this._saveLayer = new p2(), this._sections = null, this._sortable = null, this._stopsToSearches = /* @__PURE__ */ new Map(), this._viewClickHandle = null, this.headingLevel = 2, this.messages = null, this.messagesCommon = null, this.messagesUnits = null, this.searchProperties = null, this.viewModel = new R(), this.visibleElements = { ...x3 }, this._setUpDragAndDropStops = (e9) => {
      this._sortable = sortable_esm_default.create(e9, { draggable: `.${t3.validStopRow}`, ghostClass: t3.stopRowGhost, handle: `.${t3.stopHandle}`, onEnd: this._handleStopInputDragEnd });
    }, this._handleDragHandlePointerDown = () => {
      var _a;
      return (_a = this.viewModel.layer) == null ? void 0 : _a.stops.forEach((e9) => this.acquireSearch(e9).activeMenu = "none");
    }, this._handleStopInputDragEnd = ({ oldIndex: e9, newIndex: t5, target: s5 }) => {
      if (e9 === t5 || null == t5 || null == e9)
        return;
      const { children: o6 } = s5, i3 = o6[t5], r2 = o6[e9], n5 = t5 - e9 < 0;
      s5.insertBefore(i3, n5 ? r2.nextElementSibling : r2);
      const { stops: a4 } = this.viewModel.layer;
      a4.reorder(a4.at(e9), t5);
      for (const l2 of a4)
        l2.sequence = null;
      this._solveRoute();
    };
  }
  initialize() {
    this.addHandles([d(() => {
      var _a;
      return (_a = this.viewModel.layer) == null ? void 0 : _a.routeInfo;
    }, () => {
      this._activeManeuver = null, this._focusedManeuver = null, this._sections = this._getSections(), this.scheduleRender();
    }, P), p(() => this.view, (e8, s5) => {
      if (s5 && (this._viewClickHandle = null, null != s5 && this.removeHandles(s5)), e8) {
        const s6 = this._prepPointerDownUpClick(), o6 = this._prepViewClick();
        s6.pause(), o6.pause();
        const i3 = e8.surface;
        this.addHandles([o2(i3, "mousedown", () => this._autoStopRemovalDelay = N), o2(i3, "mouseup", () => this._autoStopRemovalDelay = F2), s6, o6], e8), this._pointerDownUpHandle = s6, this._viewClickHandle = o6;
      }
    }, P), p(() => null == this.viewModel.serviceDescription, () => {
      try {
        this.viewModel.load();
      } catch {
      }
    }, P), d(() => this._saveLayer.state, () => {
      this.scheduleRender();
    })]), this.when(() => {
      this.destroyed || this.visibleElements.saveAsButton && (this._renderSavePopoverFunction = this._renderSavePopover.bind(this), this._projector.append(document.body, this._renderSavePopoverFunction));
    });
  }
  loadDependencies() {
    return r({ button: () => import("./calcite-button-V4T5NPWY.js"), icon: () => import("./calcite-icon-25XWA6H7.js"), "input-date-picker": () => import("./calcite-input-date-picker-QVEGEMR6.js"), "input-time-picker": () => import("./calcite-input-time-picker-EVB2HQGH.js"), link: () => import("./calcite-link-QPSDTQFB.js"), popover: () => import("./calcite-popover-4LQ4GPZW.js") });
  }
  destroy() {
    var _a;
    for (const e8 of this._stopsToSearches.values())
      e8.destroy();
    (_a = this._sortable) == null ? void 0 : _a.destroy(), null != this._renderSavePopoverFunction && this._projector.detach(this._renderSavePopoverFunction);
  }
  get apiKey() {
    return this.viewModel.apiKey;
  }
  set apiKey(e8) {
    this.viewModel.apiKey = e8;
  }
  get goToOverride() {
    return this.viewModel.goToOverride;
  }
  set goToOverride(e8) {
    this.viewModel.goToOverride = e8;
  }
  get icon() {
    return "right";
  }
  set icon(e8) {
    this._overrideIfSome("icon", e8);
  }
  get label() {
    var _a;
    return ((_a = this.messages) == null ? void 0 : _a.widgetLabel) ?? "";
  }
  set label(e8) {
    this._overrideIfSome("label", e8);
  }
  get lastRoute() {
    return this.viewModel.lastRoute;
  }
  get layer() {
    return this.viewModel.layer;
  }
  set layer(e8) {
    this.viewModel.layer = e8;
  }
  get maxStops() {
    return this.viewModel.maxStops;
  }
  set maxStops(e8) {
    this.viewModel.maxStops = e8;
  }
  get unit() {
    return this.defaultUnit;
  }
  set unit(e8) {
    this._overrideIfSome("unit", e8);
  }
  get view() {
    return this.viewModel.view;
  }
  set view(e8) {
    this.viewModel.view = e8;
  }
  castVisibleElements(e8) {
    return { ...x3, ...e8 };
  }
  acquireSearch(e8) {
    const { view: t4 } = this.viewModel;
    if (this._stopsToSearches.has(e8)) {
      const s6 = this._stopsToSearches.get(e8);
      return s6.view = t4, this._overrideDefaultSources(s6), s6;
    }
    const s5 = new E2({ view: t4, resultGraphicEnabled: false, popupEnabled: false, ...this.searchProperties });
    return this._normalizeSearchSources(s5), this.addHandles([v(() => s5.allSources, "change", () => this._normalizeSearchSources(s5)), s5.on("select-result", () => {
      var _a, _b;
      e8.geometry = (_a = s5.selectedResult) == null ? void 0 : _a.feature.geometry, e8.name = (_b = s5.selectedResult) == null ? void 0 : _b.name, this._solveRoute();
    }), s5.on("search-focus", () => this._handleStopInputFocus(s5, e8)), s5.on("search-blur", () => this._handleStopInputBlur(s5, e8)), s5.on("search-clear", () => {
      var _a;
      e8.geometry = null, e8.name = null, this._activeStop = e8, (_a = this.viewModel.layer) == null ? void 0 : _a.removeResult();
    }), d(() => s5.searchTerm, (t5) => {
      e8.name = t5;
    })], s5), this._stopsToSearches.set(e8, s5), s5;
  }
  getDirections() {
    return this.viewModel.getDirections();
  }
  render() {
    return n2("div", { class: this.classes(t3.base, e4.widget, e4.panel, t3.scroller) }, this._renderPanelContent());
  }
  save() {
    return this.viewModel.save();
  }
  saveAs(e8, t4 = {}) {
    return this.viewModel.saveAs(e8, t4);
  }
  zoomToRoute() {
    return this.viewModel.zoomToRoute();
  }
  _renderPanelContent() {
    const { layer: e8, serviceDescription: t4, state: s5 } = this.viewModel, o6 = "initializing" === s5, i3 = "error" === s5 && !t4, r2 = "unauthenticated" === s5, n5 = { [t3.panelContentLoading]: o6, [t3.panelContentError]: i3 || !e8, [t3.panelContentSignIn]: r2 }, a4 = o6 ? "presentation" : "group", l2 = e8 ? r2 ? this._renderSignIn() : i3 ? this._renderMessage(this._getErrorMessage()) : o6 ? this._renderLoader() : this._renderReadyContent() : this._renderMessage(this.messages.missingLayer);
    return n2("div", { class: this.classes(t3.panelContent, n5), role: a4 }, l2);
  }
  _renderReadyContent() {
    return [this._renderStopsContainer(), this._renderTravelModeOptions(), this._renderDepartureTimeControls(), this._renderSaveContainer(), this._renderSectionSplitter(), this._renderDirectionsContainer()];
  }
  _renderSignIn() {
    return n2("div", { class: t3.signInContent, key: "sign-in" }, n2(e5, { class: t3.contentTitle, level: this.headingLevel }, this.messages.widgetLabel), this._renderPlaceholder(), n2(e5, { level: n3(this.headingLevel) }, this.messages.signInRequired), n2("button", { bind: this, class: this.classes(e4.button, e4.buttonSecondary, t3.signInButton), onclick: this._handleSignInClick, tabIndex: 0, type: "button" }, this.messagesCommon.auth.signIn));
  }
  _handleSignInClick() {
    this.viewModel.load().catch(() => {
    });
  }
  _renderTravelModeOptions() {
    if (!this.visibleElements.traveMode)
      return null;
    const { selectedTravelMode: e8, travelModes: t4 } = this.viewModel;
    if (0 === t4.length)
      return null;
    const s5 = null != e8 ? e8.name : this.messages.travelMode;
    return n2("div", { "aria-disabled": this._saveLayer.opened.toString(), class: this.classes(t3.travelMode, this._saveLayer.opened && e4.buttonDisabled), key: "esri-directions__travel-mode-controls", role: "group" }, n2("select", { "aria-label": s5, bind: this, class: this.classes(t3.travelModeSelect, e4.select), key: "esri-directions__travel-mode-options", onchange: this._handleTravelModeChange, title: s5 }, t4.map((t5, s6) => n2("option", { "data-mode": t5, key: `esri-directions__travel-mode-${s6}`, selected: e8 === t5, value: `${s6}` }, t5.name))));
  }
  _handleTravelModeChange(e8) {
    const t4 = e8.currentTarget;
    this.viewModel.selectedTravelMode = q(t4.item(t4.selectedIndex)), this._solveRoute();
  }
  _renderStopsContainer() {
    return this.visibleElements.stops ? n2("div", { "aria-disabled": this._saveLayer.opened.toString(), class: this.classes(t3.section, this._saveLayer.opened && e4.buttonDisabled), key: "esri-directions__stops-container", role: "group" }, this._renderStops()) : null;
  }
  _renderDepartureTimeControls() {
    if (!this.visibleElements.departureTime)
      return null;
    const { messages: { departAt: e8, departureTime: t4, leaveNow: s5, timeUnspecified: o6 }, viewModel: { departureOption: i3 } } = this;
    return n2("div", { "aria-disabled": this._saveLayer.opened.toString(), class: this.classes(t3.departureTime, this._saveLayer.opened && e4.buttonDisabled), key: "esri-directions__departure-time-controls", role: "group" }, n2("select", { "aria-label": t4, bind: this, class: this.classes(t3.departureTimeSelect, e4.select), onchange: this._handleDepartureOptionChange, title: t4 }, n2("option", { selected: i3 === i2.NOW, value: i2.NOW }, s5), n2("option", { selected: i3 === i2.DEPART_AT, value: i2.DEPART_AT }, e8), n2("option", { selected: i3 === i2.UNSPECIFIED, value: i2.UNSPECIFIED }, o6)), i3 === i2.DEPART_AT ? this._renderTimeControls() : null);
  }
  _renderStops() {
    const { stops: e8 } = this.viewModel.layer;
    let t4 = 0;
    for (const i3 of this._stopsToSearches.keys())
      e8.includes(i3) || this._disposeSearch(i3);
    for (const i3 of e8) {
      const e9 = this.acquireSearch(i3);
      "none" !== e9.activeMenu && (t4 += 1), null != i3.name && (e9.searchTerm = i3.name);
    }
    const s5 = e8.toArray().map((s6, o7) => {
      const i3 = e8.length, r2 = o7 > 1 && null == s6.geometry, n5 = { [i.radioUnchecked]: o7 >= 0 && o7 < i3 - 1, [i.radioChecked]: o7 === i3 - 1 }, a4 = { [t3.lastStopIconContainer]: o7 === i3 - 1 }, l2 = { [t3.validStopRow]: !r2 }, c3 = e8.at(o7 + 1), d3 = o7 === i3 - 1, u3 = o7 === i3 - 2, h = 2 === i3 && 0 === o7 || i3 > 2 && !d3 && !u3 || i3 > 2 && u3 && null != (c3 == null ? void 0 : c3.geometry) || i3 > 2 && d3 && null == s6.geometry, p3 = i3 < 3, v4 = this.acquireSearch(s6), { messages: m2 } = this, { removeStop: _, reverseStops: g2, unlocated: y3 } = m2, w = null != s6.geometry && null != s6.name ? s6.name : y3, f2 = u(o7 + 1), M = `${m2.stopLabel} ${f2} (${w})`, b2 = `${this.id}__stop--${o7}`, C = !!v4.searchTerm && !!v4.selectedResult && null != s6.geometry && v4.selectedResult.name === s6.name, T = { zIndex: "none" !== v4.activeMenu ? "" + t4-- : "" };
      return n2("li", { afterCreate: this._handleStopFieldCreation, "aria-label": M, bind: this, class: this.classes(t3.stopRow, l2), "data-stop-index": o7, id: b2, key: o7, styles: T }, n2("div", { class: t3.stopHandle }, n2("span", { "aria-hidden": "true", class: this.classes(t3.stopIcon, i.handleVertical, t3.stopHandleIcon, t3.interactiveStopIcon), onpointerdown: this._handleDragHandlePointerDown }), n2("div", { "aria-labelledby": b2, bind: this, class: this.classes(t3.stopIconContainer, a4), "data-stop-index": o7, onclick: this._handleStopIconClick, onkeydown: this._handleStopIconClick, role: "button" }, n2("span", { class: this.classes(t3.stopIcon, n5), tabIndex: C ? 0 : void 0 }))), n2("div", { class: t3.stopInput }, v4.render()), n2("div", { class: t3.stopOptions, role: "group" }, n2("div", { "aria-label": _, bind: this, class: t3.removeStopButton, "data-stop-index": o7, hidden: p3, onclick: this._handleRemoveStop, onkeydown: this._handleRemoveStop, role: "button", tabIndex: 0, title: _ }, n2("span", { "aria-hidden": "true", class: this.classes(t3.stopIcon, t3.removeStop, i.trash, t3.interactiveStopIcon) }), n2("span", { class: i.fontFallbackText }, "removeStopTitle")), n2("div", { "aria-label": g2, bind: this, class: t3.reverseStops, hidden: h, onclick: this._handleReverseStops, onkeydown: this._handleReverseStops, role: "button", tabIndex: 0, title: g2 }, n2("span", { "aria-hidden": "true", class: this.classes(t3.stopIcon, i.upDownArrows, t3.interactiveStopIcon) }), n2("span", { class: i.fontFallbackText }, "removeStopTitle"))));
    }), o6 = this._renderAddStop();
    return n2("div", null, n2("ol", { afterCreate: this._setUpDragAndDropStops, class: t3.stops, role: "group" }, s5), o6);
  }
  _renderAddStop() {
    var _a;
    const e8 = (_a = this.viewModel.layer) == null ? void 0 : _a.stops;
    if (!e8)
      return null;
    const t4 = e8.filter(({ geometry: e9 }) => null != e9), s5 = e8.at(-1);
    return t4.length > 1 && t4.length < this.maxStops && null != (s5 == null ? void 0 : s5.geometry) ? n2("div", { class: t3.toolbarSection }, n2("div", { class: t3.toolbarButtons }, n2("calcite-button", { appearance: "outline", class: t3.addStopButton, iconStart: "plus", key: t3.addStopButton, kind: "neutral", label: this.messages.addStop, onclick: () => {
      this._addNewPlaceholder();
    }, round: true, scale: "s", width: "full" }, this.messages.addStop))) : null;
  }
  _handleStopIconClick(e8) {
    var _a;
    const t4 = W(e8.currentTarget), s5 = null != t4 ? (_a = this.viewModel.layer) == null ? void 0 : _a.stops.at(t4) : void 0;
    (s5 == null ? void 0 : s5.geometry) && this._centerAtStop(s5);
  }
  _handleClearRouteClick() {
    this.viewModel.reset();
  }
  _centerAtStop(e8) {
    this.viewModel.centerAt(e8);
  }
  _handleStopFieldCreation(e8) {
    var _a;
    const t4 = this._newPlaceholderStop;
    if (!t4)
      return;
    const s5 = W(e8), o6 = null != s5 ? (_a = this.viewModel.layer) == null ? void 0 : _a.stops.at(s5) : void 0;
    if (t4 === o6) {
      const e9 = this.acquireSearch(o6);
      e9.when(() => {
        this.renderNow(), e9.focus();
      });
    }
    this._newPlaceholderStop = null;
  }
  _handleStopInputBlur(e8, t4) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this._saveLayer.opened)
      return;
    this.removeHandles(O3);
    if (!!e8.selectedResult && null != t4.geometry && null != ((_a = e8.selectedResult) == null ? void 0 : _a.feature.geometry) && t4.geometry === ((_b = e8.selectedResult) == null ? void 0 : _b.feature.geometry))
      return void ((_c = this._pointerDownUpHandle) == null ? void 0 : _c.pause());
    const s5 = null == t4.geometry && null == ((_d = e8.selectedResult) == null ? void 0 : _d.feature.geometry), o6 = null != t4.geometry && null != ((_e = e8.selectedResult) == null ? void 0 : _e.feature.geometry) && t4.geometry !== ((_f = e8.selectedResult) == null ? void 0 : _f.feature.geometry);
    if ((s5 || o6) && "none" === e8.activeMenu && e8.searchTerm)
      return e8.search(), void ((_g = this._pointerDownUpHandle) == null ? void 0 : _g.pause());
    e8.searchTerm || ((_h = this._viewClickHandle) == null ? void 0 : _h.resume(), clearTimeout(this._autoStopRemovalTimeoutId), this._autoStopRemovalTimeoutId = setTimeout(() => {
      var _a2, _b2;
      this.destroyed || ((_a2 = this._viewClickHandle) == null ? void 0 : _a2.pause(), "searching" !== e8.viewModel.state ? this._pointerPressedSearchSuggestionStop || (null != t4.geometry && (t4.geometry = null, this._solveRoute()), this.scheduleRender()) : (_b2 = this._pointerDownUpHandle) == null ? void 0 : _b2.pause());
    }, this._autoStopRemovalDelay));
  }
  _handleStopInputFocus(e8, t4) {
    var _a;
    (_a = this._pointerDownUpHandle) == null ? void 0 : _a.resume();
    const { view: s5 } = this;
    if (this.hasHandles(O3) || !s5)
      return;
    const i3 = s5.cursor;
    this.addHandles([e2(() => {
      s5.cursor = i3;
    }), d(() => e8.searchTerm, (t5) => {
      e8.destroyed || (s5.cursor = t5.length ? i3 : "copy");
    }, P)], O3), this._activeStop = t4;
  }
  _prepViewClick() {
    const { view: e8 } = this.viewModel;
    n(e8), n(e8.surface);
    const t4 = f(e8, "click", this._handleViewClick.bind(this)), o6 = f(e8.surface, "click", () => {
      clearTimeout(this._autoStopRemovalTimeoutId), o6.pause();
    });
    return { remove() {
      o6.remove(), t4.remove();
    }, pause() {
      o6.pause(), t4.pause();
    }, resume() {
      o6.resume(), t4.resume();
    } };
  }
  _prepPointerDownUpClick() {
    const e8 = f(document, "pointerdown", (e9) => {
      this._pointerPressedSearchSuggestionStop = z(e9) ? this._activeStop : null;
    }), t4 = f(document, "pointerup", (e9) => {
      var _a;
      (_a = this._pointerDownUpHandle) == null ? void 0 : _a.pause();
      const t5 = z(e9), s5 = this._activeStop;
      t5 || s5 !== this._pointerPressedSearchSuggestionStop || this._removeStop(s5), this.scheduleRender(), this._pointerPressedSearchSuggestionStop = t5 ? s5 : null;
    });
    return { remove() {
      t4.remove(), e8.remove();
    }, pause() {
      t4.pause(), e8.pause();
    }, resume() {
      e8.resume();
    } };
  }
  _handleViewClick(e8) {
    var _a;
    e8.stopPropagation();
    const t4 = this._activeStop, s5 = t4 ? this._stopsToSearches.get(t4) : null;
    t4 && s5 && !s5.searchTerm && (s5.search(e8.mapPoint).then((e9) => {
      const o6 = e9 == null ? void 0 : e9.results[0].results;
      if (!o6)
        return;
      const { feature: i3, name: r2 } = o6[0];
      t4.geometry = i3.geometry, t4.name = r2, s5.searchTerm = r2;
    }), this.scheduleRender()), (_a = this._viewClickHandle) == null ? void 0 : _a.pause(), clearTimeout(this._autoStopRemovalTimeoutId);
  }
  _addNewPlaceholder() {
    var _a, _b;
    if ((_a = this._pointerDownUpHandle) == null ? void 0 : _a.pause(), this._newPlaceholderStop)
      return;
    const e8 = new O2({ symbol: new y2() });
    (_b = this.viewModel.layer) == null ? void 0 : _b.stops.add(e8), this._newPlaceholderStop = e8;
  }
  _handleReverseStops() {
    this._reverseStops();
  }
  _reverseStops() {
    var _a;
    const e8 = ((_a = this.viewModel.layer) == null ? void 0 : _a.stops) ?? [];
    e8.reverse();
    for (const t4 of e8)
      t4.sequence = null;
    this._solveRoute();
  }
  _handleRemoveStop(e8) {
    const { layer: t4 } = this.viewModel;
    if (!t4)
      return;
    const s5 = W(e8.currentTarget);
    if (null == s5)
      return;
    const { stops: o6, routeInfo: i3 } = t4, r2 = o6.at(s5);
    this._removeStop(r2), null == r2.geometry && null != i3 || this._solveRoute();
  }
  _removeStop(e8) {
    const { stops: t4 } = this.viewModel.layer;
    !e8 || t4.length <= 2 || (this._disposeSearch(e8), t4.remove(e8));
  }
  _handleDepartureOptionChange(e8) {
    const t4 = e8.currentTarget, s5 = t4.item(t4.selectedIndex);
    this.viewModel.departureOption = s5.value, this._solveRoute();
  }
  _renderTimeControls() {
    return this.viewModel.departureIsoDate && this.viewModel.departureIsoTime ? n2("div", { class: t3.departureTimeControls, key: t3.departureTimeControls, role: "group" }, n2("div", { class: t3.departureDateTimePickers }, n2("calcite-input-date-picker", { valueAsDate: $(this.viewModel.departureIsoDate), onCalciteInputDatePickerChange: ({ target: e8 }) => {
      this.viewModel.departureIsoDate = e8.value, this._solveRoute();
    } }), n2("calcite-input-time-picker", { value: this.viewModel.departureIsoTime, onCalciteInputTimePickerChange: ({ target: e8 }) => {
      this.viewModel.departureIsoTime = e8.value, this._solveRoute();
    } }))) : null;
  }
  _renderSectionSplitter() {
    return n2("div", { class: t3.sectionSplitter });
  }
  _renderSaveContainer() {
    const { saveButton: e8, saveAsButton: t4, printButton: s5, layerDetails: o6 } = this.visibleElements;
    return e8 || t4 || s5 || o6 ? n2("div", { class: t3.saveSection, key: t3.saveSection }, this._renderSaveButtons(), this._renderRouteLayerDetailsLink()) : null;
  }
  _renderSaveButtons() {
    const { saveButton: e8, saveAsButton: t4, printButton: s5 } = this.visibleElements;
    return e8 || t4 || s5 ? n2("div", { class: t3.saveButtons, key: t3.saveButtons }, this._renderSaveButton(), this._renderSaveAsButton(), this._renderPrintButton()) : null;
  }
  _renderSaveButton() {
    if (!this.visibleElements.saveButton)
      return null;
    const { portalItem: e8, routeInfo: t4 } = this.viewModel.layer, s5 = e8 == null ? void 0 : e8.itemControl, o6 = null != t4 && ("admin" === s5 || "update" === s5);
    return n2("calcite-button", { appearance: "outline", class: t3.saveButton, disabled: !o6, iconStart: "save", key: t3.saveButton, label: this.messagesCommon.save, onclick: () => {
      this._handleSaveButtonClick();
    }, width: "full" }, this.messagesCommon.save);
  }
  _renderSaveAsButton() {
    if (!this.visibleElements.saveAsButton)
      return null;
    const e8 = null == this.viewModel.layer.routeInfo;
    return n2("div", { class: t3.saveAsButtonPopover, key: t3.saveAsButtonPopover }, n2("calcite-button", { afterCreate: (e9) => {
      this._saveAsButtonNode = e9;
    }, appearance: "outline", class: t3.saveAsButton, disabled: e8, iconStart: "duplicate", key: t3.saveAsButton, label: this.messagesCommon.saveAs, onclick: () => this._handleSaveAsButtonClick(), width: "full" }, this.messagesCommon.saveAs));
  }
  _renderSavePopover() {
    return n2("calcite-popover", { class: t3.savePopover, label: this._saveLayer.label, open: this._saveLayer.opened, overlayPositioning: "fixed", referenceElement: this._saveAsButtonNode, triggerDisabled: true }, this._saveLayer.render());
  }
  _handleSaveAsButtonClick() {
    this._saveLayer.opened ? this._saveLayer.close() : this._saveLayer.open(this.viewModel.layer);
  }
  _renderPrintButton() {
    return this.visibleElements.printButton ? n2("calcite-button", { appearance: "outline", class: t3.printButton, iconStart: "print", key: t3.printButton, label: this.messagesCommon.print }) : null;
  }
  _renderRouteLayerDetailsLink() {
    if (!this.visibleElements.layerDetails)
      return null;
    const { portalItem: e8 } = this.viewModel.layer;
    if (!e8)
      return null;
    const { id: t4, portal: { url: s5 } } = e8, o6 = `${s5}/home/item.html?id=${t4}`;
    return n2("calcite-link", { class: t3.layerDetailsLink, href: o6, key: t3.layerDetailsLink, target: "_blank" }, this.messages.viewLayerDetails);
  }
  _handleSaveButtonClick() {
    this.viewModel.layer.save();
  }
  _renderDirectionsContainer() {
    return n2("div", { class: this.classes(t3.directionsSection, t3.section), key: "esri-directions__container" }, this._renderDirectionsContainerContent());
  }
  _renderLoader() {
    return n2("div", { class: t3.loader, key: "loader" });
  }
  _renderWarningCard() {
    return n2("div", { class: t3.warningCard, role: "alert" }, n2("div", { class: t3.warningHeader }, n2("span", { "aria-hidden": "true", class: i.noticeTriangle }), n2(e5, { class: t3.warningHeading, level: this.headingLevel }, this.messagesCommon.warning)), n2("div", { class: t3.warningMessage }, this._getErrorMessage()));
  }
  _renderDirectionsContainerContent() {
    const { layer: e8, state: t4 } = this.viewModel, s5 = "routing" === t4;
    return "error" === t4 ? this._renderWarningCard() : s5 ? this._renderLoader() : null != e8.directionLines ? n2("div", { "aria-disabled": this._saveLayer.opened.toString(), class: this.classes(t3.summary, this._saveLayer.opened && e4.buttonDisabled), key: t3.summary, role: "group" }, this._renderCosts(), this._renderRouteActions(), this._renderManeuverSections()) : n2("div", { class: e4.empty, key: "esri-directions__placeholder" }, this._renderPlaceholder(), n2(e5, { class: t3.message, level: this.headingLevel }, this.messages.directionsPlaceholder));
  }
  _renderPlaceholder() {
    return n2("svg", { class: e4.emptyIllustration, viewBox: "0 0 256 256", xmlns: "http://www.w3.org/2000/svg" }, n2("path", { d: "M192 36c-15.477 0-24 6.034-24 16.99v45.822l24 24 24-24v-45.82C216 42.033 207.477 36 192 36zm20 61.155l-20 20-20-20V52.99c0-8.62 6.73-12.99 20-12.99s20 4.37 20 12.99zM192 52a12 12 0 1 0 12 12 12.013 12.013 0 0 0-12-12zm0 20a8 8 0 1 1 8-8 8.008 8.008 0 0 1-8 8zM92 140.99C92 130.035 83.477 124 68 124s-24 6.034-24 16.99v45.822l24 24 24-24zm-4 44.165l-20 20-20-20V140.99c0-8.62 6.73-12.99 20-12.99s20 4.37 20 12.99zM68 140a12 12 0 1 0 12 12 12.013 12.013 0 0 0-12-12zm0 20a8 8 0 1 1 8-8 8.008 8.008 0 0 1-8 8zm84-44h16v4h-16zm-24 80h4v12h-12v-4h8zm0-28h4v16h-4zm0-52h12v4h-8v8h-4zm0 24h4v16h-4zm-36 64h16v4H92z", fill: "currentcolor" }));
  }
  _renderMessage(e8) {
    return n2(e5, { class: t3.messageHeading, level: this.headingLevel }, e8);
  }
  _renderRouteActions() {
    return n2("div", { class: t3.routeActions }, n2("button", { "aria-label": this.messages.clearRoute, bind: this, class: this.classes(t3.clearRouteButton, e4.button, e4.buttonTertiary), onclick: this._handleClearRouteClick, tabIndex: 0, type: "button" }, this.messages.clearRoute));
  }
  _getSections() {
    const { layer: e8 } = this.viewModel;
    if (!e8)
      return null;
    const { directionPoints: t4, directionLines: s5, stops: o6 } = e8;
    if (null == t4 || null == s5)
      return null;
    const i3 = [];
    let r2 = null;
    for (const n5 of t4) {
      const { objectId: e9, stopId: t5 } = n5;
      if (null != t5) {
        const e10 = o6.find(({ objectId: e11 }) => e11 === t5), s6 = 0 === i3.length;
        null != r2 && r2.stop === e10 || (r2 = { stop: e10, directions: [], open: s6 }, i3.push(r2));
        continue;
      }
      if (null == r2)
        continue;
      const a4 = s5.find(({ directionPointId: t6 }) => t6 === e9);
      null != a4 && r2.directions.push({ directionPoint: n5, directionLine: a4 });
    }
    return i3;
  }
  _renderManeuverSections() {
    return null == this._sections ? null : n2("div", { class: t3.maneuvers, role: "group" }, this._sections.map((e8, t4) => {
      const { open: s5 } = e8;
      let o6;
      e8.directions.length > 0 && s5 && (o6 = n2("ol", { class: t3.maneuverList }, e8.directions.map((e9) => this._renderManeuver(e9))));
      const i3 = this._sections.length > 2, r2 = t4 === this._sections.length - 1, n5 = { [t3.collapsibleSection]: i3 }, a4 = { [i.down]: !s5, [i.up]: s5 };
      let l2;
      if (i3 && !r2) {
        const t5 = s5 ? this.messagesCommon.close : this.messagesCommon.open;
        l2 = n2("header", { class: this.classes(t3.maneuverSectionHeader, t3.maneuverSectionToggle), key: t3.maneuverSectionHeader }, n2("div", { "aria-expanded": s5.toString(), "aria-label": t5, bind: this, class: t3.maneuverSectionHeaderButton, "data-maneuver-section": e8, onclick: this._handleSectionToggle, onkeydown: this._handleSectionToggle, role: "button", tabIndex: 0, title: t5 }, n2(e5, { class: t3.maneuverSectionTitle, level: this.headingLevel }, e8.stop.name), n2("span", { "aria-hidden": "true", class: this.classes(a4) })));
      } else
        l2 = n2("header", { class: t3.maneuverSectionHeader, key: t3.maneuverSectionHeader }, n2(e5, { class: t3.maneuverSectionTitle, level: this.headingLevel }, e8.stop.name));
      return n2("section", { class: this.classes(t3.maneuverSection, n5), key: t4 }, l2, o6);
    }));
  }
  _handleSectionToggle(e8) {
    const t4 = G(e8.currentTarget);
    t4 && (t4.open = !t4.open);
  }
  _renderCosts() {
    const e8 = this._getCostSummary(), { directionPoints: t4 } = this.viewModel.layer;
    if (null == t4 || null == e8)
      return null;
    const { distance: s5, duration: o6 } = e8, { primaryCosts: i3, secondaryCosts: r2, zoomToRoute: n5 } = this.messages, a4 = this._renderEta();
    return n2("div", { "aria-label": n5, bind: this, class: t3.directionCosts, onclick: this._handleSummaryInteraction, onkeydown: this._handleSummaryInteraction, role: "button", tabIndex: 0, title: n5 }, n2("div", { class: t3.costsDetails, role: "group" }, n2("div", { class: t3.primaryCosts, title: i3 }, o6), n2("div", { class: t3.verticalSplitter }), n2("div", { class: t3.secondaryCosts, title: r2 }, s5)), a4);
  }
  _renderEta() {
    return this.viewModel.departureOption === i2.UNSPECIFIED ? null : n2("div", { class: t3.arrivalTimeContainer, title: this.messages.eta }, n2("span", { class: t3.arrivalTime }, this.viewModel.formattedEta));
  }
  _handleSummaryInteraction() {
    this._activeManeuver = null, this._focusedManeuver = null, this.viewModel.clearHighlights(), this.zoomToRoute();
  }
  _getErrorMessage() {
    var _a;
    switch ((_a = this.viewModel.lastError) == null ? void 0 : _a.name) {
      case "directions-view-model:unable-to-route":
        return this.messages.errors.unableToRoute;
      case "directions-view-model:service-metadata-unavailable":
        return this.messages.errors.unableToLoadServiceMetadata;
      default:
        return this.messages.errors.unknownError;
    }
  }
  _normalizeSearchSources(e8) {
    this._overrideDefaultSources(e8), this._applyLocatorSourceOverrides(e8);
  }
  _overrideDefaultSources(e8) {
    e8.viewModel.defaultSources.forEach((e9) => {
      e9.autoNavigate = false;
    });
  }
  _applyLocatorSourceOverrides({ allSources: e8 }) {
    for (const t4 of e8)
      "url" in t4 && t4.url && (t4.locationType ?? (t4.locationType = "street"), x2(t4.url) && this.apiKey && null == t4.apiKey && (t4.apiKey = this.apiKey, t4.url = v3));
  }
  _disposeSearch(e8) {
    if (!e8 || !this._stopsToSearches.has(e8))
      return;
    const t4 = this._stopsToSearches.get(e8);
    this.removeHandles(t4), t4.destroy(), this._stopsToSearches.delete(e8);
  }
  _renderManeuver(e8) {
    const { directionPoint: t4, directionLine: s5 } = e8, { distance: o6, duration: i3 } = s5, { messages: r2, messagesUnits: n5, unit: a4 } = this, l2 = o5(n5, o6 ?? 0, a4), c3 = l(i3 ?? 0), d3 = l2 && c3 ? `${l2}&nbsp;&middot;&nbsp;${c3}` : `${l2}${c3}`, u3 = U(t4), { objectId: h, directionPointType: p3 } = t4, v4 = s4(p3), m2 = `${t3.maneuver}-${h}`, _ = `${t3.intermediateCost}-${h}`, g2 = { [t3.maneuverActive]: this._activeManeuver === s5 };
    return n2("li", { "aria-labelledby": `${m2} ${_}`, bind: this, class: this.classes(t3.maneuver, g2), "data-maneuver": s5, key: s5, onblur: this._handleManeuverBlur, onclick: this._handleManeuverClick, onfocus: this._handleManeuverFocus, onkeydown: this._handleManeuverClick, onmouseout: this._handleManeuverMouseOut, onmouseover: this._handleManeuverMouseOver, tabIndex: 0 }, n2("calcite-icon", { alt: "", class: t3.maneuverIcon, icon: v4 }), n2("div", { class: t3.maneuverCostsContainer }, u3, n2("div", { class: t3.maneuverCosts }, n2("div", { class: t3.horizontalSplitter }), n2("div", { "aria-hidden": "true", class: t3.intermediateCost, id: _, innerHTML: d3, title: r2.intermediateCosts }))));
  }
  _handleManeuverClick(e8) {
    const t4 = Y(e8.currentTarget);
    if (!t4)
      return;
    if (this._activeManeuver === t4)
      return this._activeManeuver = null, void this.zoomToRoute();
    this._activeManeuver = t4;
    const { geometry: s5 } = t4;
    this.viewModel.centerAt(s5), this.viewModel.highlight(t4);
  }
  _handleManeuverMouseOver(e8) {
    if (this._activeManeuver || this._focusedManeuver)
      return;
    const t4 = Y(e8.currentTarget);
    t4 && this.viewModel.highlight(t4);
  }
  _handleManeuverMouseOut() {
    this._activeManeuver || this._focusedManeuver || this.viewModel.clearHighlights();
  }
  _handleManeuverBlur() {
    this._activeManeuver || (this._focusedManeuver = null, this.viewModel.clearHighlights());
  }
  _handleManeuverFocus(e8) {
    if (this._activeManeuver)
      return;
    const t4 = Y(e8.currentTarget);
    t4 && (this._focusedManeuver = t4, this.viewModel.highlight(t4));
  }
  _getCostSummary() {
    const { messagesUnits: e8, unit: t4, viewModel: s5 } = this, { routeInfo: o6 } = s5.layer;
    if (null == o6)
      return null;
    const i3 = o6.totalDistance ?? 0, r2 = o6.totalDuration ?? 0;
    return { distance: o5(e8, i3, t4), duration: l(r2) };
  }
  async _solveRoute() {
    var _a;
    this.viewModel.updateDepartureTime();
    const e8 = (_a = this.viewModel.layer) == null ? void 0 : _a.stops.filter(({ geometry: e9 }) => null != e9);
    if (e8 && !(e8.length < 2))
      try {
        await this.viewModel.getDirections();
      } catch {
      }
  }
};
e([y()], V2.prototype, "apiKey", null), e([y(e6)], V2.prototype, "defaultUnit", void 0), e([y()], V2.prototype, "goToOverride", null), e([y()], V2.prototype, "headingLevel", void 0), e([y()], V2.prototype, "icon", null), e([y()], V2.prototype, "label", null), e([y({ readOnly: true })], V2.prototype, "lastRoute", null), e([y()], V2.prototype, "layer", null), e([y()], V2.prototype, "maxStops", null), e([y(), e3("esri/widgets/Directions/t9n/Directions")], V2.prototype, "messages", void 0), e([y(), e3("esri/t9n/common")], V2.prototype, "messagesCommon", void 0), e([y(), e3("esri/core/t9n/Units")], V2.prototype, "messagesUnits", void 0), e([y()], V2.prototype, "searchProperties", void 0), e([y()], V2.prototype, "unit", null), e([y()], V2.prototype, "view", null), e([y({ type: R })], V2.prototype, "viewModel", void 0), e([y()], V2.prototype, "visibleElements", void 0), e([s2("visibleElements")], V2.prototype, "castVisibleElements", null), e([t()], V2.prototype, "_handleStopIconClick", null), e([t()], V2.prototype, "_handleClearRouteClick", null), e([t()], V2.prototype, "_handleReverseStops", null), e([t()], V2.prototype, "_handleRemoveStop", null), e([t()], V2.prototype, "_handleSectionToggle", null), e([t()], V2.prototype, "_handleSummaryInteraction", null), e([t()], V2.prototype, "_handleManeuverClick", null), V2 = e([a("esri.widgets.Directions")], V2);
var K = V2;
function q(e8) {
  return e8 == null ? void 0 : e8["data-mode"];
}
function W(e8) {
  return e8 == null ? void 0 : e8["data-stop-index"];
}
function G(e8) {
  return e8 == null ? void 0 : e8["data-maneuver-section"];
}
function Y(e8) {
  return e8 == null ? void 0 : e8["data-maneuver"];
}
export {
  K as default
};
/*! Bundled license information:

sortablejs/modular/sortable.esm.js:
  (**!
   * Sortable 1.15.2
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)
*/
//# sourceMappingURL=Directions-QV36HQ2B.js.map
