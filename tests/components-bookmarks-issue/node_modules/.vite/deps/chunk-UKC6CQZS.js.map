{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/environment/NoiseTextureAtlasConfiguration.js", "../../@arcgis/core/chunks/NoiseTextureAtlas.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport{_ as e}from\"../../../chunks/tslib.es6.js\";import{parameter as o,ShaderTechniqueConfiguration as r}from\"../webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration.js\";var t;!function(e){e[e.Full=0]=\"Full\",e[e.WeatherMap=1]=\"WeatherMap\",e[e.COUNT=2]=\"COUNT\"}(t||(t={}));class s extends r{constructor(){super(...arguments),this.mode=t.Full}}e([o({count:t.COUNT})],s.prototype,\"mode\",void 0);export{s as NoiseTextureAtlasTechniqueConfiguration,t as NoiseTextureRenderMode};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport{fromValues as e}from\"../core/libs/gl-matrix-2/factories/vec2f64.js\";import{NoiseTextureRenderMode as o}from\"../views/3d/environment/NoiseTextureAtlasConfiguration.js\";import{tileRows as t,weatherTileSize as r,weatherMapSize as a,tileSize as l,atlasSize as i}from\"../views/3d/environment/NoiseTextureAtlasDimensions.js\";import{ScreenSpacePass as d}from\"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js\";import{Float2PassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{NoParameters as n,glsl as p}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as c}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";class s extends n{constructor(){super(...arguments),this.weatherTile=e(0,0)}}function u(e){const n=new c;if(n.include(d,!1),n.fragment.code.add(p`float remap(float x, float low1, float high1, float low2, float high2) {\nreturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}`),e.mode===o.Full){const e=2,o=8;n.fragment.code.add(p`\n    float saturate(float x) {\n      return clamp(x, 0.0, 1.0);\n    }\n\n    // Safer modulo for positive and negative values\n    vec3 modulo(vec3 m, float n){\n      return mod(mod(m, n) + n, n);\n    }\n\n    vec3 hash(vec3 p3, float frequency){\n      p3 = modulo(p3, frequency);\n      p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n      p3 += dot(p3, p3.yxz + 33.33);\n      return -1.0 + 2.0 * fract((p3.xxy + p3.yxx) * p3.zyx);\n    }\n\n    // 5th order polynomial interpolation\n    vec3 fade(vec3 t){\n      return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n    }\n\n    float gradientNoise(vec3 p, float frequency){\n      // Cell point is in\n      vec3 i = floor(p);\n\n      // Position in the cell in [0, 1]\n      vec3 f = fract(p);\n\n      // Interpolation value for gradient mixing\n      vec3 u = fade(f);\n\n      // Trilinear interpolation of gradients at cube vertices around point\n      return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0), frequency), f - vec3(0.0,0.0,0.0) ),\n                            dot( hash( i + vec3(1.0,0.0,0.0), frequency), f - vec3(1.0,0.0,0.0) ), u.x),\n                       mix( dot( hash( i + vec3(0.0,1.0,0.0), frequency), f - vec3(0.0,1.0,0.0) ),\n                            dot( hash( i + vec3(1.0,1.0,0.0), frequency), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                  mix( mix( dot( hash( i + vec3(0.0,0.0,1.0), frequency), f - vec3(0.0,0.0,1.0) ),\n                            dot( hash( i + vec3(1.0,0.0,1.0), frequency), f - vec3(1.0,0.0,1.0) ), u.x),\n                       mix( dot( hash( i + vec3(0.0,1.0,1.0), frequency), f - vec3(0.0,1.0,1.0) ),\n                            dot( hash( i + vec3(1.0,1.0,1.0), frequency), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    }\n\n    float getPerlinNoise(vec3 pos, float frequency) {\n      float octaveFrequencyFactor = 2.0;\n      float sum = 0.0;\n      float weightSum = 0.0;\n      float weight = 1.0;\n\n      for (int oct = 0; oct < 3; oct++) {\n        vec3 p = pos * frequency;\n        float val = 0.5 + 0.5 * gradientNoise(p, frequency);\n        sum += val * weight;\n        weightSum += weight;\n        weight *= 0.5;\n        frequency *= octaveFrequencyFactor;\n      }\n\n      float noise = (sum / weightSum);\n      noise = saturate(noise);\n      return noise;\n    }\n\n    float worley(vec3 pos, float numCells) {\n      vec3 p = pos * numCells;\n      float d = 1.0e10;\n\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          for (int z = -1; z <= 1; z++) {\n            vec3 tp = floor(p) + vec3(x, y, z);\n            tp = p - tp - (hash(tp, numCells) * 0.5 + 0.5);\n            d = min(d, dot(tp, tp));\n          }\n        }\n      }\n\n      return 1.0 - clamp(d, 0.0, 1.0);\n    }\n\n    vec3 get3Dfrom2D(vec2 uv) {\n      vec2 tile = floor(uv);\n      float z = floor(${p.float(t)} * tile.y + tile.x);\n      return vec3(fract(uv), z);\n    }\n\n    float getTextureForPointPerlinWorley(vec3 p) {\n      float perlinNoise = getPerlinNoise(p, ${p.float(o)});\n\n      float worley0 = worley(p, ${p.float(e)} * 2.0);\n      float worley1 = worley(p, ${p.float(e)} * 8.0);\n      float worley2 = worley(p, ${p.float(e)} * 14.0);\n\n      float worleyFBM = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n      return remap(perlinNoise, 0.0, 1.0, worleyFBM, 1.0);\n    }\n\n    float getTextureForPointWorley(vec3 p) {\n      float worley0 = worley(p, ${p.float(e)});\n      float worley1 = worley(p, ${p.float(e)} * 2.0);\n      float worley2 = worley(p, ${p.float(e)} * 4.0);\n      float worley3 = worley(p, ${p.float(e)} * 8.0);\n\n      float FBM0 = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n      float FBM1 = worley1 * 0.625 + worley2 * 0.25 + worley3 * 0.125;\n      float FBM2 = worley2 * 0.75 + worley3 * 0.25;\n\n      return FBM0 * 0.625 + FBM1 * 0.25 + FBM2 * 0.125;\n    }\n  `)}return n.fragment.uniforms.add(new f(\"weatherTile\",(e=>e.weatherTile))),n.fragment.code.add(p`\n    vec2 modulo(vec2 m, float n){\n      return mod(mod(m, n) + n, n);\n    }\n\n    vec2 hash(vec2 p){\n      // Get position of p in weather tile\n      p = modulo(p, ${p.float(r)});\n\n      // Get global coordinates of p\n      p += weatherTile * ${p.float(r)};\n\n      // Limit position to avoid numerical instability\n      p = modulo(p, ${p.float(a)});\n\n      vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n      p3 += dot(p3, p3.yzx + 33.33);\n      return 2.0 * fract((p3.xx + p3.yz) * p3.zy) - 1.0;\n    }\n\n    vec2 fade(vec2 t){\n      return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n    }\n\n    float gradientNoise(vec2 p){\n      vec2 i = floor( p );\n      vec2 f = fract( p );\n\n      vec2 u = fade(f);\n\n      // Bilinear interpolation of gradients at cell vertices around point\n      return  mix(\n                mix(dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                    dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix(dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                    dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x),\n                u.y);\n    }\n\n    float worley(vec2 p){\n      float d = 1.0e10;\n      for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n                vec2 tp = floor(p) + vec2(x, y);\n                tp = p - tp - (0.5 + 0.5 * hash(tp));\n                d = min(d, dot(tp, tp));\n            }\n        }\n      return 1.0 - clamp(d, 0.0, 1.0);\n    }\n  `),n.fragment.code.add(p`void main() {`),e.mode===o.Full&&n.fragment.code.add(p`\n        float padWidth = 1.0;\n        float paddedSize = ${p.float(l)} + 2.0 * padWidth;\n        float tileCount = ${p.float(t)} * ${p.float(t)};\n        vec2 tile = floor((gl_FragCoord.xy - 0.5) / paddedSize);\n\n        bool padCell = false;\n        if (mod(gl_FragCoord.x, paddedSize) == 0.5 || mod(gl_FragCoord.x, paddedSize) == paddedSize - 0.5) {\n          padCell = true;\n        }\n\n        if (mod(gl_FragCoord.y, paddedSize) == 0.5 || mod(gl_FragCoord.y, paddedSize) == paddedSize - 0.5) {\n          padCell = true;\n        }\n\n        bool startPadX = false;\n        bool startPadY = false;\n        bool endPadX = false;\n        bool endPadY = false;\n\n        if (gl_FragCoord.x == tile.x * paddedSize + 0.5) {\n          startPadX = true;\n        }\n\n        if (gl_FragCoord.y == tile.y * paddedSize + 0.5) {\n          startPadY = true;\n        }\n\n        if (gl_FragCoord.x == (tile.x + 1.0) * paddedSize - 0.5) {\n          endPadX = true;\n        }\n\n        if (gl_FragCoord.y == (tile.y + 1.0) * paddedSize - 0.5) {\n          endPadY = true;\n        }\n\n        vec2 padding = vec2(2.0 * padWidth) * tile;\n        vec2 uv;\n\n        if (padCell) {\n          vec2 pixel = gl_FragCoord.xy - padWidth - padding;\n\n          if (startPadX) {\n            pixel.x += ${p.float(l)};\n          }\n\n          if (startPadY) {\n            pixel.y += ${p.float(l)};\n          }\n\n          if (endPadX) {\n            pixel.x -= ${p.float(l)};\n          }\n\n          if (endPadY) {\n            pixel.y -= ${p.float(l)};\n          }\n\n          uv = vec2(pixel.xy / ${p.float(l)});\n        } else {\n          vec2 pixel = gl_FragCoord.xy - padWidth - padding;\n          uv = vec2(pixel.xy / ${p.float(l)});\n        }\n\n        vec3 p_ = get3Dfrom2D(uv);\n        vec3 p = p_;\n        p.z /= (${p.float(t)} * ${p.float(t)});\n\n        float worleyPerlinNoise = getTextureForPointPerlinWorley(p);\n        float worleyNoise = getTextureForPointWorley(p);\n\n        fragColor.r = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n        p_ = mod(p_ + 1.0, ${p.float(t)} * ${p.float(t)});\n        p = p_;\n        p.z /= (${p.float(t)} * ${p.float(t)});\n\n        worleyPerlinNoise = getTextureForPointPerlinWorley(p);\n        worleyNoise = getTextureForPointWorley(p);\n\n        fragColor.g = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n      `),n.fragment.code.add(p`\n      vec2 mapUV = ${p.float(r)} * (gl_FragCoord.xy / ${p.float(i)});\n      float map = abs(gradientNoise(mapUV));\n      map = remap(map, 0.25 * (1.0 - worley(8.0 * mapUV)), 1.0, 0.0, 1.0);\n\n      ${e.mode===o.Full?p`fragColor.ba = vec2(0.0, map);`:p`fragColor = vec4(map);`};\n    }\n  `),n}const v=Object.freeze(Object.defineProperty({__proto__:null,NoiseTextureAtlasPassParameters:s,build:u},Symbol.toStringTag,{value:\"Module\"}));export{s as N,v as a,u as b};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIoL,IAAIA;AAAE,CAAC,SAASC,IAAE;AAAC,EAAAA,GAAEA,GAAE,OAAK,CAAC,IAAE,QAAOA,GAAEA,GAAE,aAAW,CAAC,IAAE,cAAaA,GAAEA,GAAE,QAAM,CAAC,IAAE;AAAO,EAAED,OAAIA,KAAE,CAAC,EAAE;AAAE,IAAME,KAAN,cAAgB,EAAC;AAAA,EAAC,cAAa;AAAC,UAAM,GAAG,SAAS,GAAE,KAAK,OAAKF,GAAE;AAAA,EAAI;AAAC;AAAC,EAAE,CAACG,GAAE,EAAC,OAAMH,GAAE,MAAK,CAAC,CAAC,GAAEE,GAAE,WAAU,QAAO,MAAM;;;ACAiU,IAAME,KAAN,cAAgB,EAAC;AAAA,EAAC,cAAa;AAAC,UAAM,GAAG,SAAS,GAAE,KAAK,cAAY,EAAE,GAAE,CAAC;AAAA,EAAC;AAAC;AAAC,SAAS,EAAEC,IAAE;AAAC,QAAMC,KAAE,IAAIC;AAAE,MAAGD,GAAE,QAAQC,IAAE,KAAE,GAAED,GAAE,SAAS,KAAK,IAAI;AAAA;AAAA,EAE/1B,GAAED,GAAE,SAAOG,GAAE,MAAK;AAAC,UAAMH,KAAE,GAAEE,KAAE;AAAE,IAAAD,GAAE,SAAS,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAkF/B,EAAE,MAAMG,EAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,8CAKY,EAAE,MAAMF,EAAC,CAAC;AAAA;AAAA,kCAEtB,EAAE,MAAMF,EAAC,CAAC;AAAA,kCACV,EAAE,MAAMA,EAAC,CAAC;AAAA,kCACV,EAAE,MAAMA,EAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kCAOV,EAAE,MAAMA,EAAC,CAAC;AAAA,kCACV,EAAE,MAAMA,EAAC,CAAC;AAAA,kCACV,EAAE,MAAMA,EAAC,CAAC;AAAA,kCACV,EAAE,MAAMA,EAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAQzC;AAAA,EAAC;AAAC,SAAOC,GAAE,SAAS,SAAS,IAAI,IAAID,GAAE,eAAe,CAAAA,OAAGA,GAAE,WAAY,CAAC,GAAEC,GAAE,SAAS,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAO3E,EAAE,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA,2BAGL,EAAE,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA,sBAGf,EAAE,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAqC7B,GAAEA,GAAE,SAAS,KAAK,IAAI,gBAAgB,GAAED,GAAE,SAAOG,GAAE,QAAMF,GAAE,SAAS,KAAK,IAAI;AAAA;AAAA,6BAEnD,EAAE,MAAMD,EAAC,CAAC;AAAA,4BACX,EAAE,MAAMI,EAAC,CAAC,MAAM,EAAE,MAAMA,EAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAwC7B,EAAE,MAAMJ,EAAC,CAAC;AAAA;AAAA;AAAA;AAAA,yBAIV,EAAE,MAAMA,EAAC,CAAC;AAAA;AAAA;AAAA;AAAA,yBAIV,EAAE,MAAMA,EAAC,CAAC;AAAA;AAAA;AAAA;AAAA,yBAIV,EAAE,MAAMA,EAAC,CAAC;AAAA;AAAA;AAAA,iCAGF,EAAE,MAAMA,EAAC,CAAC;AAAA;AAAA;AAAA,iCAGV,EAAE,MAAMA,EAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,kBAKzB,EAAE,MAAMI,EAAC,CAAC,MAAM,EAAE,MAAMA,EAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BAOf,EAAE,MAAMA,EAAC,CAAC,MAAM,EAAE,MAAMA,EAAC,CAAC;AAAA;AAAA,kBAErC,EAAE,MAAMA,EAAC,CAAC,MAAM,EAAE,MAAMA,EAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAMrC,GAAEH,GAAE,SAAS,KAAK,IAAI;AAAA,qBACR,EAAE,MAAM,CAAC,CAAC,yBAAyB,EAAE,MAAME,EAAC,CAAC;AAAA;AAAA;AAAA;AAAA,QAI1DH,GAAE,SAAOG,GAAE,OAAK,oCAAkC,yBAAyB;AAAA;AAAA,GAEhF,GAAEF;AAAC;AAAC,IAAM,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,iCAAgCF,IAAE,OAAM,EAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["t", "e", "s", "r", "s", "e", "n", "o", "t", "r"]
}
