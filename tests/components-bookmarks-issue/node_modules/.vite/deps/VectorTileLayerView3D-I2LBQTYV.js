import {
  c as c2
} from "./chunk-BIO7MOBF.js";
import {
  M,
  V
} from "./chunk-B5IJN7OM.js";
import "./chunk-F7X3QPMY.js";
import "./chunk-BMTOVJNA.js";
import "./chunk-CMLG62TA.js";
import {
  n as n3
} from "./chunk-SPU25K6A.js";
import "./chunk-P257AUOX.js";
import {
  e as e5,
  h,
  l as l2,
  n as n2,
  t as t2
} from "./chunk-HQRXH4OY.js";
import {
  d as d3,
  r as r2,
  s as s4
} from "./chunk-T7GGEMBH.js";
import {
  u as u4
} from "./chunk-NGAYW4TW.js";
import {
  p
} from "./chunk-6ZLA7UW2.js";
import "./chunk-CTO5W2RR.js";
import {
  d as d2,
  f,
  n,
  s as s3,
  u as u3
} from "./chunk-NCZU5DB4.js";
import "./chunk-SMDSNUU2.js";
import "./chunk-XTY645DH.js";
import "./chunk-VJ2I4VSQ.js";
import {
  t
} from "./chunk-MCZ4QOSQ.js";
import "./chunk-2YYSD64V.js";
import "./chunk-IUY6HBLC.js";
import "./chunk-BHOYA5LV.js";
import "./chunk-7FQYGAVT.js";
import {
  l
} from "./chunk-2IACRN4O.js";
import "./chunk-T3YOCYDS.js";
import "./chunk-QO4PGON2.js";
import {
  a as a2,
  i
} from "./chunk-QRQWG4D3.js";
import "./chunk-5JXZHN2A.js";
import "./chunk-KTQIY334.js";
import "./chunk-LGIO6OCK.js";
import "./chunk-4YGBWYMD.js";
import {
  e as e4
} from "./chunk-IQFWVTUJ.js";
import "./chunk-GB4RVOXH.js";
import "./chunk-JTUYA5FE.js";
import "./chunk-UNTQATE2.js";
import "./chunk-5YY6NZNY.js";
import "./chunk-DCBZOZ54.js";
import "./chunk-5IT6RVBX.js";
import "./chunk-JCP47SOM.js";
import "./chunk-CXCB57TE.js";
import "./chunk-IWO6JXL2.js";
import "./chunk-AVR3LWTZ.js";
import "./chunk-FFG7BDAP.js";
import "./chunk-I4SHZ6P5.js";
import "./chunk-QYDOVVH7.js";
import "./chunk-YSXT2SWC.js";
import "./chunk-YH3SFFF7.js";
import "./chunk-JBU54P54.js";
import "./chunk-252ISA6Z.js";
import {
  O,
  R
} from "./chunk-WKVHVZW2.js";
import "./chunk-RLZYC2LS.js";
import "./chunk-3AIILHI5.js";
import "./chunk-7JR6S3WL.js";
import "./chunk-YH2IYJYF.js";
import "./chunk-GGHKH3LP.js";
import "./chunk-VS6AHHIY.js";
import "./chunk-WZJNHZ6H.js";
import "./chunk-YBPOKK6D.js";
import "./chunk-XGTCDM4C.js";
import {
  e as e3
} from "./chunk-LGMX4E7L.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-HZSGATFT.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-2SYXH2R7.js";
import "./chunk-7JNXJYRU.js";
import "./chunk-QX66UTIR.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-VTH4DAHQ.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-CZSTCON2.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import {
  u as u2
} from "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  A,
  d,
  w
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  c2 as c,
  s as s2
} from "./chunk-JGDJR5EV.js";
import {
  e as e2,
  r,
  u
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  s
} from "./chunk-7RBRCL6S.js";
import {
  has
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SchemaHelper.js
var t3 = class {
  constructor(t4, e6, s5) {
    this._scale = t4, this._shift = e6, this._levelShift = s5;
  }
  getLevelRowColumn(t4) {
    const e6 = this.getLevelShift(t4[0]), s5 = this._shift + e6;
    return s5 ? [t4[0] - e6, t4[1] >> s5, t4[2] >> s5] : t4;
  }
  getLevelShift(t4) {
    return Math.min(t4, this._levelShift);
  }
  getOffset(t4, e6) {
    let s5 = 0, i2 = 0;
    const h2 = this._shift + this.getLevelShift(t4[0]);
    if (h2) {
      const l4 = (1 << h2) - 1, f2 = e6 / (this._scale * (1 << h2 - 1));
      s5 = (t4[2] & l4) * f2, i2 = (t4[1] & l4) * f2;
    }
    return [s5, i2];
  }
  getScale(t4) {
    return this._scale * (1 << this._shift + this.getLevelShift(t4));
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobsUtil.js
function p2(p3) {
  const y2 = [], a3 = new n2(4096, y2, () => {
    const e6 = new s4();
    return e6.show = false, e6.parts.push({ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }), e6.parts.push({ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }), e6;
  }), m = new e5(y2, a3, (t4, r3, o2) => new l2(t4, r3, o2, p3.styleRepository, p3.key.level, 0), (t4, e6) => {
    r2(t4, e6, false);
  }, () => 0, (t4) => {
    const e6 = p3.styleRepository.getStyleLayerByUID(t4).getLayoutProperty("visibility");
    return !e6 || e6.getValue() !== i.NONE;
  });
  y2.push(p3), a3.add(p3), m.setScreenSize(512, 512), m.continue(1 / 0);
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler3D.js
var g = class extends h {
  constructor(e6, t4, o2, i2) {
    super(e6, t4, o2, e6.tileInfo.lods.length - 1), this._memCache = i2, this._ongoingTileRequests = /* @__PURE__ */ new Map(), this._ongoingRequestToController = /* @__PURE__ */ new Map(), this._tileInfoView = new t2(e6.tileInfo, e6.fullExtent);
  }
  destroy() {
    super.destroy(), this._ongoingRequestToController.forEach((e6) => e6.abort()), this._ongoingRequestToController.clear(), this._ongoingTileRequests.clear();
  }
  async getVectorTile(s5, l4, g2, h2) {
    const u5 = new e4(s5, l4, g2, 0);
    let m = this._memCache.get(u5.id);
    if (null != m)
      return m.retain(), m;
    const c3 = await this._getVectorTileData(u5);
    if (s2(h2), !this._layer)
      return null;
    if (m = this._memCache.get(u5.id), null != m)
      return m.retain(), m;
    const T = this._layer.tileInfo.getTileBounds(u2(), u5), _ = this._tileInfoView.getTileResolution(s5);
    return m = new d3(u5, _, T[0], T[3], 512, 512, this._styleRepository, this._memCache), c3 ? (m.setData(c3), m.retain(), this._memCache.put(u5.id, m, m.usedMemory, e3)) : m.setData(null), m.neededForCoverage = true, m.transforms.tileUnitsToPixels = t(1 / 8, 0, 0, 0, 1 / 8, 0, 0, 0, 1), p2(m), m;
  }
  _getVectorTileData(e6) {
    const t4 = e6.id;
    if (this._ongoingTileRequests.has(t4))
      return this._ongoingTileRequests.get(t4);
    const o2 = new AbortController(), i2 = { signal: o2.signal }, s5 = this._getParsedVectorTileData(e6, i2).then((e7) => (this._ongoingTileRequests.delete(t4), this._ongoingRequestToController.delete(t4), e7)).catch(() => (this._ongoingTileRequests.delete(t4), this._ongoingRequestToController.delete(t4), null));
    return this._ongoingTileRequests.set(t4, s5), this._ongoingRequestToController.set(t4, o2), s5;
  }
  _getParsedVectorTileData(e6, t4) {
    return this.fetchTileData(e6, t4).then((o2) => this.parseTileData({ key: e6, data: o2 }, t4));
  }
};

// node_modules/@arcgis/core/views/2d/engine/vtlBrushes.js
var b = { vtlBackground: u3, vtlFill: f, vtlLine: s3, vtlCircle: n, vtlSymbol: d2 };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VTLPainter3D.js
var o = 1e-6;
var l3 = class {
  constructor(e6, t4) {
    this.spriteMosaic = e6, this.glyphMosaic = t4, this._brushCache = /* @__PURE__ */ new Map(), this._vtlMaterialManager = new p();
  }
  dispose() {
    this._brushCache && (this._brushCache.forEach((e6) => e6.dispose()), this._brushCache = null), this._vtlMaterialManager = r(this._vtlMaterialManager), this.spriteMosaic.dispose(), this.glyphMosaic.dispose();
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  drawSymbols(e6, t4, s5) {
    const n4 = s5.layers;
    e6.renderPass = "translucent";
    for (let i2 = 0; i2 < n4.length; i2++) {
      const s6 = n4[i2];
      if (s6.type !== a2.SYMBOL)
        continue;
      const l4 = s6.getLayoutProperty("visibility");
      if (l4 && l4.getValue() === i.NONE)
        continue;
      const c3 = e6.displayLevel;
      void 0 !== s6.minzoom && s6.minzoom > c3 + o || void 0 !== s6.maxzoom && s6.maxzoom <= c3 - o || (e6.styleLayerUID = s6.uid, e6.styleLayer = s6, this._drawWithBrush(e6, t4, "vtlSymbol"));
    }
  }
  drawBackground(e6, t4, s5) {
    if (0 === s5.backgroundBucketIds.length)
      return;
    const { context: n4, displayLevel: i2, requiredLevel: l4 } = e6;
    t4.key.level = l4, n4.setBlendingEnabled(true), n4.setDepthTestEnabled(false), n4.setStencilTestEnabled(false), e6.renderPass = "background", s5.backgroundBucketIds.forEach((n5) => {
      const l5 = s5.getLayerById(n5);
      if (l5.type !== a2.BACKGROUND)
        return;
      const c3 = l5.getLayoutProperty("visibility");
      c3 && c3.getValue() === i.NONE || void 0 !== l5.minzoom && l5.minzoom > i2 + o || void 0 !== l5.maxzoom && l5.maxzoom <= i2 - o || (e6.styleLayerUID = l5.uid, e6.styleLayer = l5, this._drawWithBrush(e6, t4, "vtlBackground"));
    });
  }
  drawTile(e6, t4, s5, r3) {
    const { context: a3 } = e6, o2 = s5.layers;
    a3.setBlendingEnabled(false), a3.setDepthTestEnabled(true), a3.setDepthWriteEnabled(true), a3.setDepthFunction(O.LEQUAL), e6.renderPass = "opaque";
    for (let n4 = o2.length - 1; n4 >= 0; n4--) {
      const s6 = o2[n4];
      null != r3 && r3 !== s6.type || this._renderStyleLayer(s6, e6, t4, false);
    }
    a3.setDepthWriteEnabled(false), a3.setBlendingEnabled(true), a3.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e6.renderPass = "translucent";
    for (let n4 = 0; n4 < o2.length; n4++) {
      const s6 = o2[n4];
      null != r3 && r3 !== s6.type || this._renderStyleLayer(s6, e6, t4, false);
    }
    a3.setDepthTestEnabled(false), a3.bindVAO();
  }
  _renderStyleLayer(e6, t4, s5, n4) {
    if (!(n4 || e6 && s5.layerData.has(e6.uid)))
      return;
    const i2 = e6.getLayoutProperty("visibility");
    if (i2 && i2.getValue() === i.NONE)
      return;
    const { renderPass: l4 } = t4;
    let c3;
    switch (e6.type) {
      case a2.BACKGROUND:
        if ("background" !== l4)
          return;
        c3 = "vtlBackground";
        break;
      case a2.FILL:
        if ("opaque" !== l4 && "translucent" !== t4.renderPass)
          return;
        c3 = "vtlFill";
        break;
      case a2.LINE:
        if ("translucent" !== l4)
          return;
        c3 = "vtlLine";
        break;
      case a2.CIRCLE:
        if ("translucent" !== l4)
          return;
        c3 = "vtlCircle";
        break;
      case a2.SYMBOL:
        if ("translucent" !== l4)
          return;
        c3 = "vtlSymbol";
    }
    const d4 = t4.displayLevel;
    if (void 0 !== e6.minzoom && e6.minzoom > d4 + o || void 0 !== e6.maxzoom && e6.maxzoom <= d4 - o)
      return;
    const { context: h2 } = t4;
    h2.setStencilTestEnabled(false), h2.setStencilWriteMask(0), t4.styleLayerUID = e6.uid, t4.styleLayer = e6, this._drawWithBrush(t4, s5, c3);
  }
  _drawWithBrush(e6, s5, r3) {
    if (!this._brushCache.has(r3)) {
      const e7 = b[r3];
      this._brushCache.set(r3, new e7());
    }
    this._brushCache.get(r3).drawMany(e6, [s5]);
  }
};

// node_modules/@arcgis/core/views/3d/layers/VectorTileLayerView3D.js
var S = class extends c2(n3(u4)) {
  constructor() {
    super(...arguments), this._tileHandlerController = null, this.type = "vector-tile-3d", this.levelShift = has("disable-feature:vtl-level-shift") ? 0 : 1;
  }
  initialize() {
    if (null == this.layer.fullExtent)
      return void this.addResolvingPromise(Promise.reject(new s("vectortilelayerview:full-extent-undefined", "This layer view's layer does not define a fullExtent.")));
    const { basemapTerrain: e6, spatialReference: i2, state: l4, viewingMode: r3 } = this.view, h2 = "local" === r3 && !M(i2) || V.force512VTL ? this.layer.tileInfo : this.layer.tileInfo.getCompatibleForVTL(256), c3 = this._getTileInfoSupportError(h2, this.layer.fullExtent);
    if (null != c3)
      return this.addResolvingPromise(Promise.reject(c3));
    const f2 = w(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.basemapTerrain) == null ? void 0 : _b.tilingSchemeLocked;
    }).then(() => {
      var _a, _b;
      const t4 = e6.tilingScheme, i3 = t4.pixelSize, l5 = 256 === i3 ? 1 : 2, r4 = ((_a = e6.spatialReference) == null ? void 0 : _a.isGeographic) && 256 === i3 ? 1 : 0, s5 = ((_b = e6.spatialReference) == null ? void 0 : _b.isGeographic) || 256 !== i3 ? 0 : 1;
      let o2;
      this.schemaHelper = new t3(l5, r4, this.levelShift + s5), o2 = 256 === i3 || 512 === i3 ? this.layer.tileInfo.getCompatibleForVTL(i3) : this.layer.tileInfo;
      const a3 = this._getTileInfoCompatibilityError(o2, t4);
      if (a3)
        throw a3;
      this.tileInfo = o2;
    });
    this._tileHandlerController = new AbortController();
    const g2 = this.view.resourceController;
    this._memCache = g2.memoryController.newCache(`vtl-${this.layer.uid}`, (e7) => {
      e7.release();
    }), this.addHandles(d(() => this.view.qualitySettings.memoryLimit, (e7) => this._memCache.maxSize = Math.ceil(e7 / 10 * 1048576), A));
    const _ = new l(this.layer.currentStyleInfo.style);
    this._tileHandler = new g(this.layer, _, l4.contentPixelRatio, this._memCache);
    const S2 = this._tileHandlerController.signal, C2 = H(g2), w2 = this._tileHandler.start({ signal: S2, schedule: C2 }), R2 = this._tileHandler.spriteMosaic;
    R2.then((e7) => {
      !c(S2) && this._tileHandler && (this.painter = new l3(e7, this._tileHandler.glyphMosaic));
    }), w2.then(() => this._tileHandlerController = null), this._updatingHandles.add(() => {
      var _a;
      return { style: this.layer.currentStyleInfo.style, pixelRatio: (_a = this.view.state) == null ? void 0 : _a.contentPixelRatio };
    }, ({ style: e7, pixelRatio: t4 }) => {
      this._tileHandlerController && this._tileHandlerController.abort(), this._tileHandlerController = new AbortController(), this._memCache.clear();
      const i3 = new l(e7), l5 = new g(this.layer, i3, t4, this._memCache), r4 = l5.start({ signal: this._tileHandlerController.signal, schedule: C2 }), s5 = l5.spriteMosaic;
      r4.then(() => this._tileHandlerController = null), this._updatingHandles.addPromise(Promise.all([r4, s5]).then(([, e8]) => {
        const t5 = this._tileHandler, i4 = this.painter;
        this.painter = new l3(e8, l5.glyphMosaic), this._tileHandler = l5, this.emit("data-changed"), t5.destroy(), i4 && i4.dispose();
      }));
    });
    const L = Promise.all([f2, w2, R2]);
    this.addResolvingPromise(L);
  }
  destroy() {
    this.painter = r(this.painter), this._tileHandlerController = e2(this._tileHandlerController), this._tileHandler = u(this._tileHandler), this._memCache = u(this._memCache);
  }
  get contentZoom() {
    return has("disable-feature:vtl-level-shift") ? 1 : this.view.qualitySettings.tiledSurface.vtlContentZoom;
  }
  get displayLevelRange() {
    const e6 = this.tileInfo.lods, t4 = this.layer.minScale || e6[0].scale, i2 = this.layer.maxScale || e6[e6.length - 1].scale, l4 = this.levelRangeFromScaleRange(t4, i2);
    return this.layer.maxScale ? l4.maxLevel++ : l4.maxLevel += this.levelShift, l4;
  }
  get dataScaleRange() {
    const e6 = this.tileInfo.lods;
    return { minScale: e6[0].scale, maxScale: e6[e6.length - 1].scale };
  }
  get dataLevelRange() {
    const { minScale: e6, maxScale: t4 } = this.dataScaleRange, i2 = this.levelRangeFromScaleRange(e6, t4);
    return 1 === i2.minLevel && 256 === this.tileInfo.size[0] && (i2.minLevel = 0), i2.maxLevel += this.levelShift, i2;
  }
  async fetchTile(e6, t4, i2, l4) {
    return this._tileHandler.getVectorTile(e6, t4, i2, l4);
  }
};
e([y()], S.prototype, "layer", void 0), e([y()], S.prototype, "levelShift", void 0), e([y()], S.prototype, "contentZoom", null), e([y()], S.prototype, "displayLevelRange", null), e([y()], S.prototype, "tileInfo", void 0), e([y()], S.prototype, "dataScaleRange", null), e([y()], S.prototype, "dataLevelRange", null), e([y()], S.prototype, "updatingProgressValue", void 0), S = e([a("esri.views.3d.layers.VectorTileLayerView3D")], S);
var C = S;
function H(e6) {
  return (t4) => e6.immediate.schedule(t4);
}
export {
  C as default
};
//# sourceMappingURL=VectorTileLayerView3D-I2LBQTYV.js.map
