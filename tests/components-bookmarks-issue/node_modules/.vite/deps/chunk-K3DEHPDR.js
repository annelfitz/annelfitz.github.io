import {
  o
} from "./chunk-I6RS7YIS.js";
import {
  r
} from "./chunk-JBU54P54.js";
import {
  s
} from "./chunk-VS6AHHIY.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";
import {
  has
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/input/keys.js
var t = has("mac") ? "Meta" : "Control";
var o2 = /* @__PURE__ */ new Set(["Alt", "Control", "Meta", "Shift", "Ctrl", "Primary"]);
var r2 = (t2) => o2.has(t2);

// node_modules/@arcgis/core/views/input/EventMatch.js
var e2 = class {
  constructor(e3, t2 = []) {
    this.eventType = e3, this.keyModifiers = t2;
  }
  matches(e3) {
    if (e3.type !== this.eventType)
      return false;
    if (0 === this.keyModifiers.length)
      return true;
    const t2 = e3.modifiers;
    for (const i3 of this.keyModifiers)
      if (!t2.has(i3))
        return false;
    return true;
  }
};

// node_modules/@arcgis/core/views/input/InputHandler.js
var n2 = () => n.getLogger("esri.views.input.InputHandler");
var i = class {
  constructor(e3) {
    this._manager = null, this._incoming = {}, this._outgoing = {}, this._incomingEventMatches = null, this._incomingEventTypes = null, this._outgoingEventTypes = null, this._hasSideEffects = e3;
  }
  get incomingEventMatches() {
    if (!this._incomingEventMatches) {
      this._incomingEventMatches = [];
      for (const e3 in this._incoming) {
        const t2 = this._incoming[e3];
        for (const e4 of t2)
          this._incomingEventMatches.push(e4.match);
      }
    }
    return this._incomingEventMatches;
  }
  get incomingEventTypes() {
    return this._incomingEventTypes || (this._incomingEventTypes = this.incomingEventMatches.map((e3) => e3.eventType)), this._incomingEventTypes;
  }
  get outgoingEventTypes() {
    return this._outgoingEventTypes || (this._outgoingEventTypes = Object.keys(this._outgoing)), this._outgoingEventTypes;
  }
  get hasSideEffects() {
    return this._hasSideEffects;
  }
  get hasPendingInputs() {
    return false;
  }
  onInstall(e3) {
    this._manager ? n2().error("This InputHandler has already been registered with an InputManager") : (e3.setEventCallback((e4) => this._handleEvent(e4)), e3.setUninstallCallback(() => this._onUninstall()), this._manager = e3);
  }
  onUninstall() {
  }
  registerIncoming(e3, n3, i3) {
    let a3;
    "function" == typeof n3 ? (i3 = n3, a3 = []) : a3 = n3 || [];
    const o3 = "string" == typeof e3 ? new e2(e3, a3) : e3, h = () => {
      this._incomingEventTypes = null, this._incomingEventMatches = null;
    }, r3 = (e4) => {
      const t2 = this._incoming[e4.match.eventType];
      if (t2) {
        const n4 = t2.indexOf(e4);
        t2.splice(n4, 1), h(), this._manager && this._manager.updateDependencies();
      }
    }, g2 = new s2(o3, i3, { onPause: r3, onRemove: r3, onResume: (e4) => {
      const t2 = this._incoming[e4.match.eventType];
      t2 && !t2.includes(e4) && (t2.push(e4), h(), this._manager && this._manager.updateDependencies());
    } });
    let c2 = this._incoming[o3.eventType];
    return c2 || (c2 = [], this._incoming[o3.eventType] = c2), c2.push(g2), h(), this._manager && this._manager.updateDependencies(), g2;
  }
  registerOutgoing(e3) {
    if (this._outgoing[e3])
      throw new Error("There is already a callback registered for this outgoing InputEvent: " + e3);
    const t2 = new a2(e3, { onEmit: (e4, t3, n3, i3) => {
      var _a;
      (_a = this._manager) == null ? void 0 : _a.emit(e4.eventType, t3, n3, i3);
    }, onRemove: (e4) => {
      var _a;
      delete this._outgoing[e4.eventType], (_a = this._manager) == null ? void 0 : _a.updateDependencies();
    } });
    return this._outgoing[e3] = t2, this._outgoingEventTypes = null, this._manager && this._manager.updateDependencies(), t2;
  }
  startCapturingPointer(e3) {
    var _a;
    (_a = this._manager) == null ? void 0 : _a.setPointerCapture(e3, true);
  }
  stopCapturingPointer(e3) {
    var _a;
    (_a = this._manager) == null ? void 0 : _a.setPointerCapture(e3, false);
  }
  refreshHasPendingInputs() {
    var _a;
    (_a = this._manager) == null ? void 0 : _a.refreshHasPendingInputs();
  }
  _onUninstall() {
    this._manager ? (this.onUninstall(), this._manager = null) : n2().error("This InputHandler is not registered with an InputManager");
  }
  _handleEvent(e3) {
    var _a;
    const t2 = this._incoming[e3.type];
    if (t2) {
      for (const n3 of t2)
        if (n3.match.matches(e3) && ((_a = n3.callback) == null ? void 0 : _a.call(n3, e3), e3.shouldStopPropagation()))
          break;
    }
  }
};
var s2 = class {
  constructor(e3, t2, n3) {
    this.match = e3, this._callback = t2, this._handler = n3;
  }
  pause() {
    this._handler.onPause(this);
  }
  resume() {
    this._handler.onResume(this);
  }
  remove() {
    this._handler.onRemove(this);
  }
  get callback() {
    return this._callback;
  }
};
var a2 = class {
  constructor(e3, t2) {
    this.eventType = e3, this._removed = false, this._handler = t2;
  }
  emit(e3, t2, n3) {
    this._removed || this._handler.onEmit(this, e3, t2, n3);
  }
  remove() {
    this._removed = true, this._handler.onRemove(this);
  }
};

// node_modules/@arcgis/core/views/input/handlers/LatestPointer.js
var s3 = class extends i {
  constructor(t2) {
    super(true), this._onChange = t2, this._value = "mouse", this._x = null, this._y = null, this.registerIncoming("pointer-move", (t3) => {
      this._update(t3.data);
    });
  }
  _update(t2) {
    const s4 = "touch" === t2.native.pointerType ? "touch" : "mouse", { x: e3, y: i3 } = t2;
    s4 === this._value && this._x === e3 && this._y === i3 || (this._value = s4, this._x = e3, this._y = i3, this._onChange(s4, e3, i3));
  }
};

// node_modules/@arcgis/core/views/input/handlers/MultiTouch.js
var i2 = class extends i {
  get multiTouchActive() {
    return this._multiTouchActive.value;
  }
  constructor() {
    super(true), this._activeTouchPointerIds = /* @__PURE__ */ new Set(), this._multiTouchActive = r(false), this._onPointerAdd = ({ data: t2 }) => {
      "touch" === t2.pointerType && (this._activeTouchPointerIds.add(t2.native.pointerId), this._update());
    }, this._onPointerRemove = ({ data: t2 }) => {
      "touch" === t2.pointerType && (this._activeTouchPointerIds.delete(t2.native.pointerId), this._update());
    }, this.registerIncoming("pointer-down", this._onPointerAdd), this.registerIncoming("pointer-up", this._onPointerRemove), this.registerIncoming("pointer-capture-lost", this._onPointerRemove), this.registerIncoming("pointer-cancel", this._onPointerRemove);
  }
  _update() {
    this._multiTouchActive.value = this._activeTouchPointerIds.size > 1;
  }
};

// node_modules/@arcgis/core/views/input/InputManager.js
var d = class extends S {
  constructor(e3) {
    super(e3), this._pointerCaptures = /* @__PURE__ */ new Map(), this._nameToGroup = {}, this._handlers = [], this._handlersPriority = [], this._currentPropagation = null, this._updateDependenciesAfterPropagation = false, this._sourceEvents = /* @__PURE__ */ new Set(), this._keyModifiers = /* @__PURE__ */ new Set(), this._activeKeyModifiers = /* @__PURE__ */ new Set(), this._stoppedPropagationEventIds = /* @__PURE__ */ new Set(), this.primaryKey = t, this._latestPointerType = "mouse", this._propertiesPool = new o({ latestPointerLocation: v }, this), this.latestPointerLocation = null, this._paused = false, this.test = { timestamp: void 0, hasCurrentPropagation: () => !!this._currentPropagation };
  }
  initialize() {
    this.eventSource.onEventReceived = this._onEventReceived.bind(this), this._installRecognizers();
  }
  destroy() {
    const e3 = Object.keys(this._nameToGroup);
    for (const t2 of e3)
      this.uninstallHandlers(t2);
    this.eventSource.destroy(), this._currentPropagation = null, this._propertiesPool.destroy();
  }
  get hasPendingInputs() {
    return this._handlers.some((e3) => e3.handler.hasPendingInputs);
  }
  get latestPointerType() {
    return this._latestPointerType;
  }
  get multiTouchActive() {
    return this._multiTouchHandler.multiTouchActive;
  }
  get updating() {
    return this.hasPendingInputs || this._paused;
  }
  installHandlers(e3, t2, i3 = _.INTERNAL) {
    if (this._nameToGroup[e3])
      return void n.getLogger(this).error("There is already an InputHandler group registered under the name `" + e3 + "`");
    if (0 === t2.length)
      return void n.getLogger(this).error("Can't register a group of zero handlers");
    const n3 = { name: e3, handlers: t2.map((e4) => ({ handler: e4, active: true, removed: false, priorityIndex: 0, groupPriority: i3, eventCallback: null, uninstallCallback: null })) };
    this._nameToGroup[e3] = n3;
    for (let r3 = n3.handlers.length - 1; r3 >= 0; r3--) {
      const e4 = n3.handlers[r3];
      this._handlers.push(e4), e4.handler.onInstall({ updateDependencies: () => {
        this.updateDependencies();
      }, emit: (t3, r4, i4, n4, s4) => {
        this._emitInputEvent(e4.priorityIndex + 1, t3, r4, i4, s4, n4);
      }, setPointerCapture: (t3, r4) => {
        this._setPointerCapture(n3, e4, t3, r4);
      }, setEventCallback: (t3) => {
        e4.eventCallback = t3;
      }, setUninstallCallback: (t3) => {
        e4.uninstallCallback = t3;
      }, refreshHasPendingInputs: () => {
        this.notifyChange("hasPendingInputs");
      } });
    }
    this.updateDependencies();
  }
  uninstallHandlers(e3) {
    const t2 = this._nameToGroup[e3];
    t2 ? (t2.handlers.forEach((e4) => {
      var _a;
      e4.removed = true, (_a = e4.uninstallCallback) == null ? void 0 : _a.call(e4);
    }), delete this._nameToGroup[e3], this._currentPropagation ? this._currentPropagation.needsHandlerGarbageCollect = true : this._garbageCollectRemovedHandlers()) : n.getLogger(this).error("There is no InputHandler group registered under the name `" + e3 + "`");
  }
  hasHandlers(e3) {
    return void 0 !== this._nameToGroup[e3];
  }
  isModifierKeyDown(e3) {
    return this._activeKeyModifiers && this._activeKeyModifiers.has(e3);
  }
  updateDependencies() {
    if (this._currentPropagation)
      return void (this._updateDependenciesAfterPropagation = true);
    this._updateDependenciesAfterPropagation = false;
    const e3 = /* @__PURE__ */ new Set(), t2 = /* @__PURE__ */ new Set();
    this._handlersPriority = [];
    for (let r3 = this._handlers.length - 1; r3 >= 0; r3--) {
      const e4 = this._handlers[r3];
      e4.priorityIndex = r3, this._handlersPriority.push(e4);
    }
    this._handlersPriority = this._sortHandlersPriority(this._handlersPriority);
    for (let r3 = this._handlersPriority.length - 1; r3 >= 0; r3--) {
      const i3 = this._handlersPriority[r3];
      i3.priorityIndex = r3;
      let n3 = i3.handler.hasSideEffects;
      if (!n3) {
        for (const t3 of i3.handler.outgoingEventTypes)
          if (e3.has(t3)) {
            n3 = true;
            break;
          }
      }
      if (n3)
        for (const r4 of i3.handler.incomingEventMatches) {
          e3.add(r4.eventType);
          for (const e4 of r4.keyModifiers)
            r2(e4) || t2.add(e4);
        }
      i3.active = n3;
    }
    this._sourceEvents = e3, this._keyModifiers = t2, this._pointerCaptures.size > 0 && this._sourceEvents.add("pointer-capture-lost"), this._keyModifiers.size > 0 && (this._sourceEvents.add("key-down"), this._sourceEvents.add("key-up")), this.eventSource && (this.eventSource.activeEvents = this._sourceEvents);
  }
  _setLatestPointer(e3, t2, r3) {
    this._latestPointerType = e3;
    const i3 = this._get("latestPointerLocation");
    if (null == i3 || i3.x !== t2 || i3.y !== r3) {
      const e4 = this._propertiesPool.get("latestPointerLocation");
      e4.x = t2, e4.y = r3, this._set("latestPointerLocation", e4);
    }
  }
  _onEventReceived(e3, t2) {
    if ("pointer-capture-lost" === e3) {
      const e4 = t2;
      this._pointerCaptures.delete(e4.native.pointerId);
    }
    this._updateKeyModifiers(e3, t2);
    const r3 = null != this.test.timestamp ? this.test.timestamp : t2.native ? t2.native.timestamp : void 0, i3 = t2.native ? t2.native.cancelable : void 0;
    this._emitInputEventFromSource(e3, t2, r3, i3);
  }
  _updateKeyModifiers(e3, t2) {
    if (!t2)
      return;
    let r3 = false;
    const i3 = () => {
      if (!r3) {
        const e4 = /* @__PURE__ */ new Set();
        this._activeKeyModifiers.forEach((t3) => {
          e4.add(t3);
        }), this._activeKeyModifiers = e4, r3 = true;
      }
    }, n3 = (e4, t3) => {
      t3 && !this._activeKeyModifiers.has(e4) ? (i3(), this._activeKeyModifiers.add(e4)) : !t3 && this._activeKeyModifiers.has(e4) && (i3(), this._activeKeyModifiers.delete(e4));
    };
    if ("key-down" === e3 || "key-up" === e3) {
      const r4 = t2.key;
      this._keyModifiers.has(r4) && n3(r4, "key-down" === e3);
    }
    const s4 = t2.native;
    n3("Alt", !(!s4 || !s4.altKey)), n3("Control", !(!s4 || !s4.ctrlKey)), n3("Ctrl", !(!s4 || !s4.ctrlKey)), n3("Shift", !(!s4 || !s4.shiftKey)), n3("Meta", !(!s4 || !s4.metaKey)), n3("Primary", this._activeKeyModifiers.has(this.primaryKey));
  }
  _installRecognizers() {
    this._latestPointerHandler = new s3((e3, t2, r3) => this._setLatestPointer(e3, t2, r3)), this._multiTouchHandler = new i2(), this.installHandlers("input-manager-logic", [this._latestPointerHandler, this._multiTouchHandler], _.ALWAYS), this.recognizers.length > 0 && this.installHandlers("default", this.recognizers, _.INTERNAL);
  }
  _setPointerCapture(e3, t2, r3, i3) {
    const n3 = e3.name + "-" + t2.priorityIndex, s4 = this._pointerCaptures.get(r3.pointerId) || /* @__PURE__ */ new Set();
    this._pointerCaptures.set(r3.pointerId, s4), i3 ? (s4.add(n3), 1 === s4.size && this.eventSource && this.eventSource.setPointerCapture(r3, true)) : s4.has(n3) && (s4.delete(n3), 0 === s4.size && (this._pointerCaptures.delete(r3.pointerId), this.eventSource && this.eventSource.setPointerCapture(r3, false)));
  }
  _garbageCollectRemovedHandlers() {
    this._handlers = this._handlers.filter((e3) => !e3.removed), this.updateDependencies();
  }
  _emitInputEventFromSource(e3, t2, r3, i3) {
    this._emitInputEvent(0, e3, t2, r3, i3);
  }
  _emitInputEvent(e3, t2, r3, i3, n3, s4) {
    const o3 = void 0 !== i3 ? i3 : this._currentPropagation ? this._currentPropagation.timestamp : performance.now(), a3 = void 0 !== n3 && n3, h = { event: new u(t2, r3, o3, s4 || this._activeKeyModifiers, a3), priorityIndex: e3 };
    this._currentPropagation ? this._currentPropagation.events.push(h) : this._doNewPropagation(h);
  }
  _doNewPropagation(e3) {
    this._currentPropagation = { events: new s(), currentHandler: null, needsHandlerGarbageCollect: false, timestamp: e3.event.timestamp }, this._currentPropagation.events.push(e3), this._continuePropagation();
  }
  _continuePropagation() {
    var _a, _b, _c;
    this._paused = false;
    const e3 = this._currentPropagation;
    if (e3) {
      for (; e3.events.length > 0; ) {
        const { event: t2, priorityIndex: r3 } = e3.events.pop(), i3 = (_a = t2.data) == null ? void 0 : _a.eventId;
        if (!(null != i3 && this._stoppedPropagationEventIds.has(i3)))
          for (e3.currentHandler = this._handlersPriority[r3]; e3.currentHandler; ) {
            if (e3.currentHandler.removed)
              e3.needsHandlerGarbageCollect = true;
            else {
              if (e3.currentHandler.active && !t2.shouldStopPropagation() && ((_c = (_b = e3.currentHandler).eventCallback) == null ? void 0 : _c.call(_b, t2)), t2.shouldStopPropagation()) {
                null != i3 && this._stoppedPropagationEventIds.add(i3);
                break;
              }
              if (t2.shouldPausePropagation(() => this._continuePropagation()))
                return void this._pausePropagation({ event: t2, priorityIndex: e3.currentHandler.priorityIndex + 1 });
            }
            e3.currentHandler = this._handlersPriority[e3.currentHandler.priorityIndex + 1];
          }
      }
      e3.needsHandlerGarbageCollect && this._garbageCollectRemovedHandlers(), this.hasPendingInputs || this._stoppedPropagationEventIds.clear(), this._currentPropagation = null, this._updateDependenciesAfterPropagation && this.updateDependencies();
    }
  }
  _pausePropagation(e3) {
    const t2 = new s();
    t2.push(e3);
    const r3 = this._currentPropagation;
    if (r3) {
      for (; r3.events.length; )
        t2.push(r3.events.pop());
      r3.events = t2, r3.currentHandler = null, this._paused = true;
    }
  }
  _compareHandlerPriority(e3, t2) {
    if (e3.handler.hasSideEffects !== t2.handler.hasSideEffects)
      return e3.handler.hasSideEffects ? 1 : -1;
    if (e3.groupPriority !== t2.groupPriority)
      return e3.groupPriority > t2.groupPriority ? -1 : 1;
    for (const r3 of e3.handler.incomingEventMatches)
      for (const e4 of t2.handler.incomingEventMatches) {
        if (r3.eventType !== e4.eventType)
          continue;
        const t3 = r3.keyModifiers.filter((t4) => e4.keyModifiers.includes(t4));
        if (t3.length === r3.keyModifiers.length !== (t3.length === e4.keyModifiers.length))
          return r3.keyModifiers.length > e4.keyModifiers.length ? -1 : 1;
      }
    return e3.priorityIndex > t2.priorityIndex ? -1 : 1;
  }
  _sortHandlersPriority(e3) {
    const t2 = [];
    for (const r3 of e3) {
      let e4 = 0;
      for (; e4 < t2.length && this._compareHandlerPriority(r3, t2[e4]) >= 0; )
        e4++;
      t2.splice(e4, 0, r3);
    }
    return t2;
  }
  get debug() {
    const e3 = (e4) => {
      const t2 = this._setPointerCapture;
      this._setPointerCapture = () => {
      }, e4(), this._setPointerCapture = t2;
    };
    return { injectEvent: (t2, r3) => {
      e3(() => {
        this._onEventReceived(t2, r3);
      });
    }, disablePointerCapture: e3 };
  }
};
e([y({ readOnly: true })], d.prototype, "hasPendingInputs", null), e([y({ constructOnly: true })], d.prototype, "eventSource", void 0), e([y({ constructOnly: true })], d.prototype, "recognizers", void 0), e([y()], d.prototype, "_latestPointerType", void 0), e([y()], d.prototype, "latestPointerType", null), e([y()], d.prototype, "multiTouchActive", null), e([y({ readOnly: true })], d.prototype, "latestPointerLocation", void 0), e([y()], d.prototype, "_paused", void 0), e([y({ readOnly: true })], d.prototype, "updating", null), d = e([a("esri.views.input.InputManager")], d);
var u = class {
  constructor(e3, t2, r3, i3, n3) {
    this.type = e3, this.data = t2, this.timestamp = r3, this.modifiers = i3, this.cancelable = n3, this._propagationState = c.NONE, this._resumeCallback = null;
  }
  stopPropagation() {
    this._propagationState |= c.STOPPED;
  }
  shouldStopPropagation() {
    return !!(this._propagationState & c.STOPPED);
  }
  async(e3) {
    this._propagationState |= c.PAUSED;
    const t2 = (e4, t3) => {
      this._propagationState &= ~c.PAUSED;
      const r3 = this._resumeCallback;
      if (this._resumeCallback = null, r3 && r3(), t3)
        throw e4;
      return e4;
    };
    return ("function" == typeof e3 ? e3() : e3).then((e4) => t2(e4, false), (e4) => t2(e4, true));
  }
  shouldPausePropagation(e3) {
    return !!(this._propagationState & c.PAUSED) && (this._resumeCallback = e3, true);
  }
  preventDefault() {
    this.data.native.preventDefault();
  }
};
var c;
!function(e3) {
  e3[e3.NONE = 0] = "NONE", e3[e3.STOPPED = 1] = "STOPPED", e3[e3.PAUSED = 2] = "PAUSED";
}(c || (c = {}));
var _ = { ALWAYS: 1, DEFAULT: 0, TOOL: -1, WIDGET: -2, INTERNAL: -3 };
var g = class {
};
var v = g;

export {
  t,
  i,
  d,
  _
};
//# sourceMappingURL=chunk-K3DEHPDR.js.map
