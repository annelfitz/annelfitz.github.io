import {
  h as h4
} from "./chunk-LX4MCBVU.js";
import {
  U as U2
} from "./chunk-WGW5NIFJ.js";
import {
  h as h3
} from "./chunk-DSYR24NA.js";
import {
  e as e5
} from "./chunk-5HWGOVOV.js";
import {
  i
} from "./chunk-PGQVBXGK.js";
import {
  f as f2
} from "./chunk-IEGGIGRQ.js";
import "./chunk-CGJEHQM2.js";
import {
  u as u3
} from "./chunk-RUJWNMKZ.js";
import {
  n as n2,
  r
} from "./chunk-PHGMJ5KG.js";
import {
  u as u2
} from "./chunk-EIFRMATR.js";
import "./chunk-AVQM6UNY.js";
import {
  l as l2
} from "./chunk-ZIKY3AX6.js";
import "./chunk-VGQTAP4F.js";
import "./chunk-OEXKWOWE.js";
import "./chunk-QKSE6KAV.js";
import {
  c as c3,
  m as m3
} from "./chunk-BOU46AXG.js";
import "./chunk-FQUIQQYI.js";
import {
  e as e4
} from "./chunk-CTY3WTET.js";
import "./chunk-EZMIPVQL.js";
import "./chunk-7IFMSG3H.js";
import "./chunk-NIRB3OB6.js";
import "./chunk-JASPUPTW.js";
import "./chunk-HWBFFWYY.js";
import "./chunk-B473F3N3.js";
import {
  E2 as E
} from "./chunk-LEFES6LS.js";
import "./chunk-UANQJYHL.js";
import "./chunk-IB7OUIEK.js";
import "./chunk-WCBCYPOZ.js";
import "./chunk-3FTSPLRV.js";
import {
  p as p2
} from "./chunk-OMRW2J7M.js";
import "./chunk-UXQH3C5A.js";
import "./chunk-PTIWH4S7.js";
import "./chunk-67GTVIII.js";
import "./chunk-BEXFYHUM.js";
import {
  _
} from "./chunk-K3DEHPDR.js";
import "./chunk-I6RS7YIS.js";
import "./chunk-7KPPNEIJ.js";
import "./chunk-KDAM4HTO.js";
import "./chunk-G4YIJOSP.js";
import {
  h as h2
} from "./chunk-PMQ5HDZI.js";
import {
  h
} from "./chunk-NAWP2ZCR.js";
import "./chunk-M5DWZKDJ.js";
import "./chunk-LO5UMUY4.js";
import "./chunk-YKIGDW5O.js";
import "./chunk-IWO6JXL2.js";
import "./chunk-QD3CP3I4.js";
import "./chunk-ECTYMEUP.js";
import "./chunk-JBU54P54.js";
import "./chunk-RK2U53CD.js";
import "./chunk-YPY24RRU.js";
import "./chunk-O7RKI2QW.js";
import "./chunk-CHJMCUAV.js";
import "./chunk-VIKID44H.js";
import "./chunk-3IDXRFXE.js";
import "./chunk-3AIILHI5.js";
import "./chunk-SA77Z3WI.js";
import "./chunk-D56W4LPT.js";
import "./chunk-BKOYOJBG.js";
import "./chunk-VS6AHHIY.js";
import {
  l
} from "./chunk-WZJNHZ6H.js";
import "./chunk-RO3CTAP7.js";
import "./chunk-Y546C2O5.js";
import "./chunk-LQBHIBXV.js";
import "./chunk-B35SNV2V.js";
import "./chunk-Z2F5OKVA.js";
import "./chunk-UQA6M3KF.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-O76UVYOO.js";
import "./chunk-KNMQQRV7.js";
import "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-SCHTG6ZQ.js";
import {
  f
} from "./chunk-QYC3GV65.js";
import "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import "./chunk-HV2SFSJW.js";
import "./chunk-SBARCIDP.js";
import "./chunk-6PMFOUWZ.js";
import "./chunk-3KPZ3BQR.js";
import "./chunk-5JYVZQZR.js";
import "./chunk-UUG4W2PI.js";
import "./chunk-G7FOE26O.js";
import "./chunk-USOPZ2Q6.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import {
  y as y2
} from "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import {
  c as c2
} from "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-WMUEII2O.js";
import "./chunk-6QNF7OHN.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import {
  m2
} from "./chunk-HV6S3GY2.js";
import {
  c,
  e as e3,
  m
} from "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-CXNX736Z.js";
import "./chunk-RGCWZ2KZ.js";
import "./chunk-5VMSFOCB.js";
import "./chunk-LGQXPGTM.js";
import "./chunk-2SDMYJDE.js";
import "./chunk-TPLOIZC7.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  A,
  P,
  U,
  d as d2,
  p
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import {
  d
} from "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import {
  e as e2,
  u
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-MDRC3XUT.js";
import "./chunk-NCF6OYL5.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/draw/support/Reshape.js
var q = class {
  constructor(e6, t, i2) {
    this.graphic = e6, this.mover = t, this.selected = i2, this.type = "reshape-start";
  }
};
var K = class {
  constructor(e6, t, i2) {
    this.graphic = e6, this.mover = t, this.selected = i2, this.type = "reshape";
  }
};
var N = class {
  constructor(e6, t, i2) {
    this.graphic = e6, this.mover = t, this.selected = i2, this.type = "reshape-stop";
  }
};
var B = class {
  constructor(e6, t, i2) {
    this.mover = e6, this.dx = t, this.dy = i2, this.type = "move-start";
  }
};
var J = class {
  constructor(e6, t, i2) {
    this.mover = e6, this.dx = t, this.dy = i2, this.type = "move";
  }
};
var Q = class {
  constructor(e6, t, i2) {
    this.mover = e6, this.dx = t, this.dy = i2, this.type = "move-stop";
  }
};
var W = class {
  constructor(e6) {
    this.added = e6, this.type = "vertex-select";
  }
};
var X = class {
  constructor(e6) {
    this.removed = e6, this.type = "vertex-deselect";
  }
};
var Y = class {
  constructor(e6, t, i2, s2) {
    this.added = e6, this.graphic = t, this.oldGraphic = i2, this.vertices = s2, this.type = "vertex-add";
  }
};
var Z = class {
  constructor(e6, t, i2, s2) {
    this.removed = e6, this.graphic = t, this.oldGraphic = i2, this.vertices = s2, this.type = "vertex-remove";
  }
};
var $ = h4.reshapeGraphics;
var ee = { vertices: { default: new y2({ style: "circle", size: $.vertex.size, color: $.vertex.color, outline: { color: $.vertex.outlineColor, width: 1 } }), hover: new y2({ style: "circle", size: $.vertex.hoverSize, color: $.vertex.hoverColor, outline: { color: $.vertex.hoverOutlineColor, width: 1 } }), selected: new y2({ style: "circle", size: $.selected.size, color: $.selected.color, outline: { color: $.selected.outlineColor, width: 1 } }) }, midpoints: { default: new y2({ style: "circle", size: $.midpoint.size, color: $.midpoint.color, outline: { color: $.midpoint.outlineColor, width: 1 } }), hover: new y2({ style: "circle", size: $.midpoint.size, color: $.midpoint.color, outline: { color: $.midpoint.outlineColor, width: 1 } }) } };
var te = class extends o.EventedAccessor {
  constructor(e6) {
    super(e6), this._activeOperationInfo = null, this._editGeometryOperations = null, this._graphicAttributes = { esriSketchTool: "box" }, this._mover = null, this._snappingContext = null, this._hoverGraphic = null, this._snappingTask = null, this._stagedVertex = null, this.tooltip = null, this._translateGraphicTooltipInfo = null, this._translateVertexTooltipInfo = null, this.callbacks = { onReshapeStart() {
    }, onReshape() {
    }, onReshapeStop() {
    }, onMoveStart() {
    }, onMove() {
    }, onMoveStop() {
    }, onGraphicClick() {
    } }, this.enableMidpoints = true, this.enableMovement = true, this.enableVertices = true, this.graphic = null, this.layer = null, this.midpointGraphics = new V(), this.midpointSymbol = new y2({ style: "circle", size: 6, color: [200, 200, 200], outline: { color: [100, 100, 100], width: 1 } }), this.selectedVertices = [], this.snappingManager = null, this.symbols = ee, this.sketchOptions = new l2(), this.type = "reshape", this.vertexGraphics = new V(), this.view = null;
  }
  initialize() {
    const e6 = this.view;
    this._highlightHelper = new h3({ view: e6 }), this._setup(), this.addHandles([p(() => e6 == null ? void 0 : e6.ready, () => {
      const { layer: e7, view: t } = this;
      e5(t, e7), this.addHandles(t.on("key-down", (e8) => this._keyDownHandler(e8), _.TOOL));
    }, { once: true, initial: true }), U(() => this.graphic, () => this.refresh()), U(() => this.layer, (e7, t) => {
      t && (this._clearSelection(), this._resetGraphics(t)), this.refresh();
    }), U(() => this.enableMidpoints, () => this.refresh()), d2(() => this.sketchOptions.tooltips.effectiveEnabled, (e7) => {
      this.tooltip = e7 ? new u2({ view: this.view }) : u(this.tooltip);
    }, A), d2(() => this.view.effectiveTheme.accentColor, () => this._updateSymbolsForTheme(), P)]);
  }
  destroy() {
    var _a;
    this._reset(), (_a = this._mover) == null ? void 0 : _a.destroy(), this._mover = null, this.tooltip = u(this.tooltip);
  }
  set highlightsEnabled(e6) {
    var _a;
    (_a = this._highlightHelper) == null ? void 0 : _a.removeAll(), this._set("highlightsEnabled", e6), this._setUpHighlights();
  }
  get state() {
    const e6 = this.view.ready, t = !(!this.graphic || !this.layer);
    return e6 && t ? "active" : e6 ? "ready" : "disabled";
  }
  isUIGraphic(e6) {
    const t = [];
    return this.graphic && t.push(this.graphic), t.concat(this.vertexGraphics.items, this.midpointGraphics.items), t.length > 0 && t.includes(e6);
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphic = null;
  }
  clearSelection() {
    this._clearSelection();
  }
  removeSelectedVertices() {
    this.selectedVertices.length && this._removeVertices(this.selectedVertices);
  }
  _setup() {
    const { graphic: e6, layer: t } = this;
    if (!t || null == (e6 == null ? void 0 : e6.geometry))
      return;
    const i2 = e6.geometry;
    "mesh" !== i2.type && "extent" !== i2.type ? ("polygon" === i2.type && m(i2), this._setUpHighlights(), this._setupGraphics(), this._setupMover()) : this._logGeometryTypeError();
  }
  _setUpHighlights() {
    var _a;
    this.highlightsEnabled && this.graphic && ((_a = this._highlightHelper) == null ? void 0 : _a.add(this.graphic));
  }
  _setUpGeometryHelper() {
    const e6 = this.graphic.geometry;
    if (null == e6 || "mesh" === e6.type || "extent" === e6.type)
      return void this._logGeometryTypeError();
    const t = "multipoint" === e6.type ? new m2({ paths: e6.points, spatialReference: e6.spatialReference }) : e6;
    this._editGeometryOperations = E.fromGeometry(t, l.Local);
  }
  _saveSnappingContextForHandle(e6, t) {
    var _a;
    this._snappingGraphicsLayer = new h({ listMode: "hide", internal: true, title: "Reshape snapping layer" }), this.view.map.layers.add(this._snappingGraphicsLayer), this._snappingContext = new e4({ editGeometryOperations: this._editGeometryOperations, elevationInfo: { mode: "on-the-ground", offset: 0 }, pointer: ((_a = t.viewEvent) == null ? void 0 : _a.pointerType) || "mouse", excludeFeature: this.graphic, feature: this.graphic, visualizer: new f2(this._snappingGraphicsLayer), vertexHandle: this._getVertexFromEditGeometry(e6) });
  }
  _reset() {
    var _a;
    this._clearSelection(), (_a = this._highlightHelper) == null ? void 0 : _a.removeAll(), this._updateTooltip(), this._resetGraphics(), this._resetSnappingStateVars(), this._activeOperationInfo = null, this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetSnappingStateVars() {
    var _a;
    null != this.snappingManager && this.snappingManager.doneSnapping(), null != this._snappingGraphicsLayer && (((_a = this.view) == null ? void 0 : _a.map) && this.view.map.layers.remove(this._snappingGraphicsLayer), this._snappingGraphicsLayer.destroy()), this._editGeometryOperations = u(this._editGeometryOperations), this._snappingTask = e2(this._snappingTask), this._snappingTask = null, this._snappingContext = null, this._stagedVertex = null;
  }
  _resetGraphics(e6) {
    this._removeMidpointGraphics(e6), this._removeVertexGraphics(e6), this._set("selectedVertices", []);
  }
  _removeMidpointGraphics(e6) {
    const t = e6 || this.layer;
    t && t.removeMany(this.midpointGraphics.items), this.midpointGraphics.items.forEach((e7) => e7.destroy()), this.midpointGraphics.removeAll();
  }
  _removeVertexGraphics(e6) {
    const t = e6 || this.layer;
    t && t.removeMany(this.vertexGraphics.items), this.vertexGraphics.items.forEach((e7) => e7.destroy()), this.vertexGraphics.removeAll();
  }
  _setupGraphics() {
    const e6 = this.graphic.geometry;
    if (null != e6 && ("polyline" === e6.type || "polygon" === e6.type)) {
      const t = ie(e6);
      this.enableMidpoints && this._setUpMidpointGraphics(t), this.enableVertices && this._setUpVertexGraphics(t);
    }
  }
  _setUpMidpointGraphics(e6) {
    this._removeMidpointGraphics();
    const t = this._createMidpointGraphics(e6);
    this.midpointGraphics.addMany(t), this.layer.addMany(t);
  }
  _setUpVertexGraphics(e6) {
    this._removeVertexGraphics();
    const t = this._createVertexGraphics(e6);
    this.vertexGraphics.addMany(t), this._storeRelatedVertexIndices(), this.layer.addMany(t);
  }
  _createVertexGraphics(e6) {
    const { _graphicAttributes: i2, symbols: s2, view: { spatialReference: o2 } } = this, r2 = [];
    return e6 == null ? void 0 : e6.forEach((e7, n3) => {
      e7.forEach((e8, h5) => {
        var _a;
        const [a2, p3, c4] = e8;
        r2.push(new f({ geometry: new x({ x: a2, y: p3, z: c4, spatialReference: o2 }), symbol: (_a = s2 == null ? void 0 : s2.vertices) == null ? void 0 : _a.default, attributes: { ...i2, pathIndex: n3, pointIndex: h5 } }));
      });
    }), r2;
  }
  _createMidpointGraphics(e6) {
    const { _graphicAttributes: i2, symbols: s2, view: { spatialReference: o2 } } = this, r2 = [];
    return e6 == null ? void 0 : e6.forEach((e7, n3) => {
      e7.forEach((h5, a2) => {
        var _a;
        const [p3, c4, l3] = h5, d3 = e7[a2 + 1] ? a2 + 1 : 0;
        if ("polygon" === ((_a = this.graphic.geometry) == null ? void 0 : _a.type) || 0 !== d3) {
          const [h6, m4, v] = e7[d3], [y3, _2, g] = c([p3, c4, l3], [h6, m4, v]);
          r2.push(new f({ geometry: new x({ x: y3, y: _2, z: g, spatialReference: o2 }), symbol: s2.midpoints.default, attributes: { ...i2, pathIndex: n3, pointIndexStart: a2, pointIndexEnd: d3 } }));
        }
      });
    }), r2;
  }
  _updateSymbolsForTheme() {
    var _a;
    const e6 = this.view.effectiveTheme.accentColor;
    this.symbols = { vertices: { ...this.symbols.vertices, default: this.symbols.vertices.default.clone().set("color", e6), hover: (_a = this.symbols.vertices.hover) == null ? void 0 : _a.clone().set("color", e6) }, midpoints: { ...this.symbols.midpoints } };
    for (const t of this.vertexGraphics)
      this._isSelected(t) ? t.symbol = this.symbols.vertices.selected : this._hoverGraphic === t ? t.symbol = this.symbols.vertices.hover : t.symbol = this.symbols.vertices.default;
  }
  _storeRelatedVertexIndices() {
    const e6 = this.vertexGraphics.items;
    if (!e6)
      return;
    const t = e6.map(({ geometry: e7 }) => ({ x: e7.x, y: e7.y }));
    for (let i2 = 0; i2 < t.length; i2++) {
      const s2 = [];
      for (let e7 = 0; e7 < t.length; e7++) {
        if (i2 === e7)
          continue;
        const o2 = t[i2], r2 = t[e7];
        o2.x === r2.x && o2.y === r2.y && s2.push(e7);
      }
      e6[i2].attributes.relatedGraphicIndices = s2;
    }
  }
  _setupMover() {
    const { enableMovement: e6, graphic: t, midpointGraphics: i2, vertexGraphics: s2, view: o2 } = this, r2 = s2.concat(i2).items;
    e6 && r2.push(t), this._mover = new U2({ enableMoveAllGraphics: false, highlightsEnabled: false, indicatorsEnabled: false, graphics: r2, view: o2, callbacks: { onGraphicClick: (e7) => this._onGraphicClickCallback(e7), onGraphicMoveStart: (e7) => this._onGraphicMoveStartCallback(e7), onGraphicMove: (e7) => this._onGraphicMoveCallback(e7), onGraphicMoveStop: (e7) => this._onGraphicMoveStopCallback(e7), onGraphicPointerOver: (e7) => this._onGraphicPointerOverCallback(e7), onGraphicPointerOut: (e7) => this._onGraphicPointerOutCallback(e7) } });
  }
  _onGraphicClickCallback(e6) {
    e6.viewEvent.stopPropagation();
    const t = e6.graphic;
    if (t === this.graphic)
      this.clearSelection(), this.emit("graphic-click", e6), this.callbacks.onGraphicClick && this.callbacks.onGraphicClick(e6);
    else if (this._isMidpoint(t)) {
      if (2 === e6.viewEvent.button)
        return;
      const i2 = this.graphic.clone(), s2 = this._createVertexFromMidpoint(t);
      this.refresh(), this._emitVertexAddEvent([t], i2, s2);
    } else if (this._isVertex(t))
      if (e6.viewEvent.stopPropagation(), 2 === e6.viewEvent.button)
        this._removeVertices(t);
      else {
        e6.viewEvent.native.shiftKey || this._clearSelection(), this.selectedVertices.includes(t) ? this._removeFromSelection(t, true) : this._addToSelection(t);
      }
  }
  _setUpOperation(e6) {
    const { graphic: t, dx: i2, dy: s2 } = e6, o2 = t === this.graphic;
    this._resetSnappingStateVars(), this._setUpGeometryHelper(), this._saveSnappingContextForHandle(t, e6), this._activeOperationInfo = { target: this.graphic, mover: t, operationType: o2 ? "move" : "reshape", totalDx: i2, totalDy: s2 };
  }
  _onGraphicMoveStartCallback(e6) {
    const { dx: t, dy: i2, graphic: s2 } = e6;
    if (s2 === this.graphic) {
      const { geometry: o2 } = s2;
      return this._setUpOperation(e6), this._emitMoveStartEvent(t, i2), void (null != o2 && "point" === o2.type && this._onHandleMove(s2, t, i2, e6, () => {
        this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(t, i2);
      }));
    }
    if (!this.selectedVertices.includes(s2)) {
      if (this._clearSelection(), this._isMidpoint(s2)) {
        const e7 = this.graphic.clone(), t2 = this._createVertexFromMidpoint(s2);
        this._emitVertexAddEvent([s2], e7, t2);
      }
      this._addToSelection(s2);
    }
    this._setUpOperation(e6), this._emitReshapeStartEvent(s2), this._onHandleMove(s2, t, i2, e6, () => {
      this._updateTooltip(s2, e6.viewEvent), this._emitReshapeEvent(s2);
    });
  }
  _onGraphicMoveCallback(e6) {
    const t = this._activeOperationInfo;
    if (!t)
      return;
    const { dx: i2, dy: s2, graphic: o2 } = e6;
    t.totalDx += i2, t.totalDy += s2;
    const { operationType: r2 } = t, { geometry: n3 } = o2;
    if (null != n3) {
      if ("move" !== r2)
        this._onHandleMove(o2, i2, s2, e6, () => {
          this._updateTooltip(o2, e6.viewEvent), this._emitReshapeEvent(o2);
        });
      else if ("point" === n3.type)
        this._onHandleMove(o2, i2, s2, e6, () => {
          this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(i2, s2);
        });
      else if ("polyline" === n3.type || "polygon" === n3.type) {
        const t2 = ie(n3);
        this._updateVertexGraphicLocations(t2), this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(i2, s2);
      }
    }
  }
  _onGraphicMoveStopCallback(e6) {
    const t = this._activeOperationInfo;
    if (!t)
      return;
    const { dx: i2, dy: s2, graphic: o2 } = e6, { operationType: r2 } = t;
    t.totalDx += i2, t.totalDy += s2, this._onHandleMove(o2, i2, s2, e6, () => "move" === r2 ? this._emitMoveStopEvent() : this._emitReshapeStopEvent(o2)), this._isMidpoint(o2) ? this.refresh() : (this._updateTooltip(this._isVertex(o2) ? o2 : null), this._resetSnappingStateVars(), this._activeOperationInfo = null);
  }
  _updateVertexGraphicLocations(e6) {
    const t = this.view.spatialReference;
    for (const i2 of this.vertexGraphics) {
      const { pathIndex: s2, pointIndex: o2 } = i2.attributes, [r2, n3, h5] = e6[s2][o2];
      i2.geometry = new x({ x: r2, y: n3, z: h5, spatialReference: t });
    }
    this._updateMidpointGraphicLocations(e6);
  }
  _updateMidpointGraphicLocations(e6) {
    for (const t of this.midpointGraphics) {
      const { pathIndex: i2, pointIndexStart: s2, pointIndexEnd: o2 } = t.attributes, [r2, n3, h5] = e6[i2][s2], [a2, p3, c4] = e6[i2][o2], [l3, d3, m4] = c([r2, n3, h5], [a2, p3, c4]);
      t.geometry = new x({ x: l3, y: d3, z: m4, spatialReference: this.view.spatialReference });
    }
  }
  _getVertexFromEditGeometry(e6) {
    const [t, i2] = se(e6);
    return this._editGeometryOperations.data.components[t].vertices[i2];
  }
  _onHandleMove(e6, t, s2, o2, r2) {
    e2(this._snappingTask);
    const n3 = this._snappingContext;
    if (!n3)
      return;
    const h5 = e6.geometry, p3 = "graphic-move-stop" === o2.type;
    if (null != this.snappingManager && this.selectedVertices.length < 2 && !p3) {
      const o3 = this.snappingManager;
      this._stagedVertex = o3.update({ point: h5, context: n3 }), this._syncGeometryAfterVertexMove(e6, new x(this._stagedVertex), t, s2, p3), r2(), this._snappingTask = d(async (i2) => {
        const a2 = await o3.snap({ point: h5, context: n3, signal: i2 });
        a2.valid && (this._stagedVertex = a2.apply(), this._syncGeometryAfterVertexMove(e6, new x(this._stagedVertex), t, s2, p3), r2());
      });
    } else {
      const i2 = null != this._stagedVertex ? new x(this._stagedVertex) : h5;
      this._syncGeometryAfterVertexMove(e6, i2, t, s2, p3), r2();
    }
  }
  async _syncGeometryAfterVertexMove(e6, t, i2, s2, o2 = false) {
    const r2 = this._editGeometryOperations.data.geometry;
    if ("point" === r2.type)
      e6.geometry = t;
    else if ("mesh" === r2.type)
      e6.geometry = r2.centerAt(t);
    else {
      const { x: n3, y: h5, z: a2 } = t, [p3, c4] = se(e6);
      let l3 = e3(r2);
      const d3 = l3[p3].length - 1, m4 = null != a2 ? [n3, h5, a2] : [n3, h5];
      l3[p3][c4] = m4, "polygon" === r2.type && (0 === c4 ? l3[p3][d3] = m4 : c4 === d3 && (l3[p3][0] = m4)), this._isVertex(e6) && (l3 = this._moveRelatedCoordinates(l3, e6, m4), l3 = this._moveSelectedHandleCoordinates(l3, e6, i2, s2, "polygon" === r2.type), this._updateMidpointGraphicLocations(l3)), this.graphic.geometry = r2.clone();
      const v = this._getVertexFromEditGeometry(e6), y3 = n3 - v.pos[0], _2 = h5 - v.pos[1];
      this._editGeometryOperations.moveVertices([v], y3, _2, 0), o2 && (this._mover ? this._mover.updateGeometry(this._mover.graphics.indexOf(e6), t) : e6.geometry = t);
    }
  }
  _moveRelatedCoordinates(e6, t, i2) {
    const { relatedGraphicIndices: s2 } = t.attributes;
    for (const o2 of s2) {
      const s3 = this.vertexGraphics.at(o2), { pathIndex: r2, pointIndex: n3 } = s3.attributes;
      e6[r2][n3] = i2, s3.geometry = t.geometry;
    }
    return e6;
  }
  _moveSelectedHandleCoordinates(e6, t, i2, s2, o2) {
    for (const r2 of this.selectedVertices)
      if (r2 !== t) {
        const { pathIndex: t2, pointIndex: n3, relatedGraphicIndices: h5 } = r2.attributes, a2 = i(r2.geometry, i2, s2, this.view), p3 = e6[t2].length - 1;
        e6[t2][n3] = [a2.x, a2.y], r2.geometry = a2, o2 && (0 === n3 ? e6[t2][p3] = [a2.x, a2.y] : n3 === p3 && (e6[t2][0] = [a2.x, a2.y]));
        for (const i3 of h5) {
          const t3 = this.vertexGraphics.at(i3), { pathIndex: s3, pointIndex: o3 } = t3.attributes;
          e6[s3][o3] = [a2.x, a2.y], t3.geometry = a2;
        }
      }
    return e6;
  }
  _onGraphicPointerOverCallback(e6) {
    const t = e6.graphic;
    this._hoverGraphic = t;
    const i2 = this._isVertex(t);
    i2 && !this._isSelected(t) && (t.symbol = this.symbols.vertices.hover), this._updateTooltip(i2 ? t : null), this._updateHoverCursor(t);
  }
  _onGraphicPointerOutCallback(e6) {
    const t = e6.graphic;
    this._hoverGraphic = null, this._isVertex(t) && !this._isSelected(t) && (t.symbol = this.symbols.vertices.default), this.view.cursor = "default", this._updateTooltip();
  }
  _createVertexFromMidpoint(e6) {
    const { _graphicAttributes: t, graphic: i2 } = this, s2 = i2.geometry;
    if (null == s2 || "polygon" !== s2.type && "polyline" !== s2.type)
      return [];
    const o2 = s2.clone(), r2 = [], { pathIndex: n3, pointIndexStart: h5, pointIndexEnd: a2 } = e6.attributes, { x: p3, y: c4, z: l3 } = e6.geometry, d3 = 0 === a2 ? h5 + 1 : a2, m4 = e3(o2);
    return m4[n3].splice(d3, 0, null != l3 ? [p3, c4, l3] : [p3, c4]), e6.attributes = { ...t, pathIndex: n3, pointIndex: d3, relatedGraphicIndices: [] }, r2.push({ coordinates: m4[n3][d3], componentIndex: n3, vertexIndex: d3 }), this.graphic.geometry = o2, r2;
  }
  _addToSelection(e6) {
    e6 instanceof f && (e6 = [e6]);
    for (const t of e6)
      t.symbol = this.symbols.vertices.selected;
    this._set("selectedVertices", this.selectedVertices.concat(e6)), this._emitSelectEvent(e6);
  }
  _removeFromSelection(e6, i2) {
    const { vertices: s2 } = this.symbols, o2 = i2 ? s2.hover : s2.default;
    e6 instanceof f && (e6 = [e6]);
    for (const t of e6)
      this.selectedVertices.splice(this.selectedVertices.indexOf(t), 1), this._set("selectedVertices", this.selectedVertices), t.set("symbol", o2);
    this._emitDeselectEvent(e6);
  }
  _clearSelection() {
    if (this.selectedVertices.length) {
      const e6 = this.selectedVertices;
      for (const t of this.selectedVertices)
        t.set("symbol", this.symbols.vertices.default);
      this._set("selectedVertices", []), this._emitDeselectEvent(e6);
    }
  }
  _keyDownHandler(e6) {
    p2.delete.includes(e6.key) && !e6.repeat && this.selectedVertices.length && this._removeVertices(this.selectedVertices);
  }
  _removeVertices(e6) {
    const i2 = this.graphic.geometry;
    if (null == i2 || "polygon" !== i2.type && "polyline" !== i2.type)
      return;
    if ("polygon" === i2.type && this.vertexGraphics.length < 4 || this.vertexGraphics.length < 3)
      return;
    e6 instanceof f && (e6 = [e6]);
    const s2 = this.graphic.clone(), o2 = i2.clone();
    let r2 = e3(o2);
    const n3 = [];
    e6 instanceof f && (e6 = [e6]);
    for (const t of e6) {
      const { x: e7, y: i3 } = t.geometry;
      for (let t2 = 0; t2 < r2.length; t2++) {
        const s3 = r2[t2];
        for (let o3 = 0; o3 < s3.length; o3++) {
          const [h5, a2] = s3[o3];
          e7 === h5 && i3 === a2 && (n3.push({ coordinates: r2[t2][o3], componentIndex: t2, vertexIndex: o3 }), r2[t2].splice(Number(o3), 1));
        }
      }
    }
    if ("polygon" === o2.type)
      r2 = r2.filter((e7) => {
        if (e7.length < 2)
          return false;
        const [t, i3] = e7[0], [s3, o3] = e7[e7.length - 1];
        return (2 !== e7.length || t !== s3 || i3 !== o3) && (t === s3 && i3 === o3 || e7.push(e7[0]), true);
      }), o2.rings = r2;
    else {
      for (const e7 of r2)
        1 === e7.length && r2.splice(r2.indexOf(e7), 1);
      o2.paths = r2;
    }
    this.graphic.geometry = o2, this.refresh(), this._emitVertexRemoveEvent(e6, s2, n3);
  }
  _isVertex(e6) {
    return this.vertexGraphics.includes(e6);
  }
  _isSelected(e6) {
    return this._isVertex(e6) && this.selectedVertices.includes(e6);
  }
  _isMidpoint(e6) {
    return this.midpointGraphics.includes(e6);
  }
  _updateHoverCursor(e6) {
    this.view.cursor = this._isMidpoint(e6) ? "copy" : "move";
  }
  _updateTooltip(e6, t) {
    null != this.tooltip && (e6 ? e6 === this.graphic ? this._updateMoveGraphicTooltip(t) : this._updateMoveVertexTooltip(t) : this.tooltip.clear());
  }
  _updateMoveGraphicTooltip(e6) {
    const { tooltip: t, sketchOptions: i2, view: s2 } = this;
    if (null == t)
      return;
    const o2 = this._translateGraphicTooltipInfo ?? (this._translateGraphicTooltipInfo = new r({ sketchOptions: i2 }));
    if (o2.clear(), o2.sketchOptions = i2, e6) {
      const { x: t2, y: i3 } = e6.origin, r2 = s2.toMap(e6), n3 = s2.toMap(c2(t2, i3)), h5 = m3(n3, r2);
      o2.distance = null != h5 ? h5 : h2;
    }
    t.info = o2;
  }
  _updateMoveVertexTooltip(e6) {
    const { tooltip: t, graphic: { geometry: i2 }, sketchOptions: s2, view: o2 } = this;
    if (null == t)
      return;
    const r2 = this._translateVertexTooltipInfo ?? (this._translateVertexTooltipInfo = new n2({ sketchOptions: s2 }));
    if (r2.clear(), r2.sketchOptions = s2, "polygon" === (i2 == null ? void 0 : i2.type) ? r2.area = u3(i2) : "polyline" === (i2 == null ? void 0 : i2.type) && (r2.totalLength = c3(i2)), e6) {
      const { x: t2, y: i3 } = e6.origin, s3 = o2.toMap(e6), n3 = o2.toMap(c2(t2, i3)), h5 = m3(n3, s3);
      r2.distance = null != h5 ? h5 : h2;
    }
    t.info = r2;
  }
  _emitMoveStartEvent(e6, t) {
    const i2 = new B(this.graphic, e6, t);
    this.emit("move-start", i2), this.callbacks.onMoveStart && this.callbacks.onMoveStart(i2);
  }
  _emitMoveEvent(e6, t) {
    const i2 = new J(this.graphic, e6, t);
    this.emit("move", i2), this.callbacks.onMove && this.callbacks.onMove(i2);
  }
  _emitMoveStopEvent() {
    const e6 = this._activeOperationInfo;
    if (!e6)
      return;
    const { totalDx: t, totalDy: i2 } = e6, s2 = new Q(this.graphic, t, i2);
    this.emit("move-stop", s2), this.callbacks.onMoveStop && this.callbacks.onMoveStop(s2);
  }
  _emitReshapeStartEvent(e6) {
    const t = new q(this.graphic, e6, this.selectedVertices);
    this.emit("reshape-start", t), this.callbacks.onReshapeStart && this.callbacks.onReshapeStart(t);
  }
  _emitReshapeEvent(e6) {
    const t = new K(this.graphic, e6, this.selectedVertices);
    this.emit("reshape", t), this.callbacks.onReshape && this.callbacks.onReshape(t);
  }
  _emitReshapeStopEvent(e6) {
    const t = new N(this.graphic, e6, this.selectedVertices);
    this.emit("reshape-stop", t), this.callbacks.onReshapeStop && this.callbacks.onReshapeStop(t);
  }
  _emitSelectEvent(e6) {
    const t = new W(e6);
    this.emit("select", t), this.callbacks.onVertexSelect && this.callbacks.onVertexSelect(t);
  }
  _emitDeselectEvent(e6) {
    const t = new X(e6);
    this.emit("deselect", t), this.callbacks.onVertexDeselect && this.callbacks.onVertexDeselect(t);
  }
  _emitVertexAddEvent(e6, t, i2) {
    const s2 = new Y(e6, this.graphic, t, i2);
    this.emit("vertex-add", s2), this.callbacks.onVertexAdd && this.callbacks.onVertexAdd(s2);
  }
  _emitVertexRemoveEvent(e6, t, i2) {
    const s2 = new Z(e6, this.graphic, t, i2);
    this.emit("vertex-remove", s2), this.callbacks.onVertexRemove && this.callbacks.onVertexRemove(s2);
  }
  _logGeometryTypeError() {
    n.getLogger(this).error(new s("reshape:invalid-geometry", "Reshape operation not supported for the provided graphic. The geometry type is not supported."));
  }
};
function ie(e6) {
  const t = e3(e6.clone());
  if ("polygon" === e6.type)
    for (const i2 of t) {
      const e7 = i2[i2.length - 1];
      i2[0][0] === e7[0] && i2[0][1] === e7[1] && i2.length > 2 && i2.pop();
    }
  return t;
}
function se({ attributes: e6 }) {
  return [(e6 == null ? void 0 : e6.pathIndex) || 0, (e6 == null ? void 0 : e6.pointIndex) || 0];
}
e([y()], te.prototype, "tooltip", void 0), e([y()], te.prototype, "_translateGraphicTooltipInfo", void 0), e([y()], te.prototype, "_translateVertexTooltipInfo", void 0), e([y()], te.prototype, "callbacks", void 0), e([y()], te.prototype, "enableMidpoints", void 0), e([y()], te.prototype, "enableMovement", void 0), e([y()], te.prototype, "enableVertices", void 0), e([y()], te.prototype, "graphic", void 0), e([y({ value: true })], te.prototype, "highlightsEnabled", null), e([y()], te.prototype, "layer", void 0), e([y({ readOnly: true })], te.prototype, "midpointGraphics", void 0), e([y()], te.prototype, "midpointSymbol", void 0), e([y({ readOnly: true })], te.prototype, "selectedVertices", void 0), e([y()], te.prototype, "snappingManager", void 0), e([y({ readOnly: true })], te.prototype, "state", null), e([y()], te.prototype, "symbols", void 0), e([y({ type: l2 })], te.prototype, "sketchOptions", void 0), e([y({ readOnly: true })], te.prototype, "type", void 0), e([y({ readOnly: true })], te.prototype, "vertexGraphics", void 0), e([y()], te.prototype, "view", void 0), te = e([a("esri.views.draw.support.Reshape")], te);
var oe = te;
export {
  oe as default
};
//# sourceMappingURL=Reshape-JKVJ7HT7.js.map
