import {
  e as e2
} from "./chunk-33LWZO2E.js";
import {
  s
} from "./chunk-RLZYC2LS.js";
import {
  c,
  i as i2,
  q,
  u,
  x,
  y
} from "./chunk-IRL6OOVK.js";
import {
  e
} from "./chunk-GLF3KRAL.js";
import {
  G as G2,
  H
} from "./chunk-HWHMO3CO.js";
import {
  A,
  G,
  i
} from "./chunk-326OSIM5.js";
import {
  K,
  _,
  o,
  r,
  z
} from "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/bufferWriterUtils.js
function d(e3, t, f, o2 = 1) {
  const { data: r2, indices: i3 } = e3, s2 = t.typedBuffer, n2 = t.typedBufferStride, c2 = i3.length;
  if (f *= n2, 1 === o2)
    for (let l = 0; l < c2; ++l)
      s2[f] = r2[i3[l]], f += n2;
  else
    for (let l = 0; l < c2; ++l) {
      const e4 = r2[i3[l]];
      for (let t2 = 0; t2 < o2; t2++)
        s2[f] = e4, f += n2;
    }
}
function u2(e3, t, f) {
  const { data: o2, indices: r2 } = e3, i3 = t.typedBuffer, s2 = t.typedBufferStride, n2 = r2.length;
  f *= s2;
  for (let c2 = 0; c2 < n2; ++c2) {
    const e4 = 2 * r2[c2];
    i3[f] = o2[e4], i3[f + 1] = o2[e4 + 1], f += s2;
  }
}
function a(e3, t, f, o2) {
  const { data: r2, indices: i3 } = e3, s2 = t.typedBuffer, n2 = t.typedBufferStride, c2 = i3.length;
  if (f *= n2, null == o2 || 1 === o2)
    for (let l = 0; l < c2; ++l) {
      const e4 = 3 * i3[l];
      s2[f] = r2[e4], s2[f + 1] = r2[e4 + 1], s2[f + 2] = r2[e4 + 2], f += n2;
    }
  else
    for (let l = 0; l < c2; ++l) {
      const e4 = 3 * i3[l];
      for (let t2 = 0; t2 < o2; ++t2)
        s2[f] = r2[e4], s2[f + 1] = r2[e4 + 1], s2[f + 2] = r2[e4 + 2], f += n2;
    }
}
function p(e3, t, f, o2 = 1) {
  const { data: r2, indices: i3 } = e3, s2 = t.typedBuffer, n2 = t.typedBufferStride, c2 = i3.length;
  if (f *= n2, 1 === o2)
    for (let l = 0; l < c2; ++l) {
      const e4 = 4 * i3[l];
      s2[f] = r2[e4], s2[f + 1] = r2[e4 + 1], s2[f + 2] = r2[e4 + 2], s2[f + 3] = r2[e4 + 3], f += n2;
    }
  else
    for (let l = 0; l < c2; ++l) {
      const e4 = 4 * i3[l];
      for (let t2 = 0; t2 < o2; ++t2)
        s2[f] = r2[e4], s2[f + 1] = r2[e4 + 1], s2[f + 2] = r2[e4 + 2], s2[f + 3] = r2[e4 + 3], f += n2;
    }
}
function y2(e3, t, f) {
  const o2 = e3.typedBuffer, r2 = e3.typedBufferStride;
  t *= r2;
  for (let i3 = 0; i3 < f; ++i3)
    o2[t] = 0, o2[t + 1] = 0, o2[t + 2] = 0, o2[t + 3] = 0, t += r2;
}
function b(t, f, o2, r2, i3 = 1) {
  if (!f)
    return void a(t, o2, r2, i3);
  const { data: s2, indices: n2 } = t, c2 = o2.typedBuffer, l = o2.typedBufferStride, d3 = n2.length, u3 = f[0], p3 = f[1], y4 = f[2], B2 = f[4], g2 = f[5], b3 = f[6], O3 = f[8], h3 = f[9], S3 = f[10], N3 = f[12], R3 = f[13], E2 = f[14];
  r2 *= l;
  let A4 = 0, L = 0, F = 0;
  const z3 = H(f) ? (e3) => {
    A4 = s2[e3] + N3, L = s2[e3 + 1] + R3, F = s2[e3 + 2] + E2;
  } : (e3) => {
    const t2 = s2[e3], f2 = s2[e3 + 1], o3 = s2[e3 + 2];
    A4 = u3 * t2 + B2 * f2 + O3 * o3 + N3, L = p3 * t2 + g2 * f2 + h3 * o3 + R3, F = y4 * t2 + b3 * f2 + S3 * o3 + E2;
  };
  if (1 === i3)
    for (let e3 = 0; e3 < d3; ++e3)
      z3(3 * n2[e3]), c2[r2] = A4, c2[r2 + 1] = L, c2[r2 + 2] = F, r2 += l;
  else
    for (let e3 = 0; e3 < d3; ++e3) {
      z3(3 * n2[e3]);
      for (let e4 = 0; e4 < i3; ++e4)
        c2[r2] = A4, c2[r2 + 1] = L, c2[r2 + 2] = F, r2 += l;
    }
}
function O(f, o2, r2, i3, s2 = 1) {
  if (!o2)
    return void a(f, r2, i3, s2);
  const { data: n2, indices: c2 } = f, l = o2, d3 = r2.typedBuffer, u3 = r2.typedBufferStride, p3 = c2.length, y4 = l[0], B2 = l[1], g2 = l[2], b3 = l[4], O3 = l[5], h3 = l[6], S3 = l[8], N3 = l[9], R3 = l[10], E2 = !G2(l), A4 = 1e-6, L = 1 - A4;
  i3 *= u3;
  let F = 0, z3 = 0, m2 = 0;
  const I2 = H(l) ? (e3) => {
    F = n2[e3], z3 = n2[e3 + 1], m2 = n2[e3 + 2];
  } : (e3) => {
    const t = n2[e3], f2 = n2[e3 + 1], o3 = n2[e3 + 2];
    F = y4 * t + b3 * f2 + S3 * o3, z3 = B2 * t + O3 * f2 + N3 * o3, m2 = g2 * t + h3 * f2 + R3 * o3;
  };
  if (1 === s2)
    if (E2)
      for (let e3 = 0; e3 < p3; ++e3) {
        I2(3 * c2[e3]);
        const t = F * F + z3 * z3 + m2 * m2;
        if (t < L && t > A4) {
          const e4 = 1 / Math.sqrt(t);
          d3[i3] = F * e4, d3[i3 + 1] = z3 * e4, d3[i3 + 2] = m2 * e4;
        } else
          d3[i3] = F, d3[i3 + 1] = z3, d3[i3 + 2] = m2;
        i3 += u3;
      }
    else
      for (let e3 = 0; e3 < p3; ++e3)
        I2(3 * c2[e3]), d3[i3] = F, d3[i3 + 1] = z3, d3[i3 + 2] = m2, i3 += u3;
  else
    for (let e3 = 0; e3 < p3; ++e3) {
      if (I2(3 * c2[e3]), E2) {
        const e4 = F * F + z3 * z3 + m2 * m2;
        if (e4 < L && e4 > A4) {
          const t = 1 / Math.sqrt(e4);
          F *= t, z3 *= t, m2 *= t;
        }
      }
      for (let e4 = 0; e4 < s2; ++e4)
        d3[i3] = F, d3[i3 + 1] = z3, d3[i3 + 2] = m2, i3 += u3;
    }
}
function h(e3, f, o2, r2, i3 = 1) {
  if (!f)
    return void p(e3, o2, r2, i3);
  const { data: s2, indices: n2 } = e3, c2 = f, l = o2.typedBuffer, d3 = o2.typedBufferStride, u3 = n2.length, a2 = c2[0], y4 = c2[1], B2 = c2[2], g2 = c2[4], b3 = c2[5], O3 = c2[6], h3 = c2[8], S3 = c2[9], N3 = c2[10], R3 = !G2(c2), E2 = 1e-6, A4 = 1 - E2;
  if (r2 *= d3, 1 === i3)
    for (let t = 0; t < u3; ++t) {
      const e4 = 4 * n2[t], f2 = s2[e4], o3 = s2[e4 + 1], i4 = s2[e4 + 2], c3 = s2[e4 + 3];
      let u4 = a2 * f2 + g2 * o3 + h3 * i4, p3 = y4 * f2 + b3 * o3 + S3 * i4, L = B2 * f2 + O3 * o3 + N3 * i4;
      if (R3) {
        const e5 = u4 * u4 + p3 * p3 + L * L;
        if (e5 < A4 && e5 > E2) {
          const t2 = 1 / Math.sqrt(e5);
          u4 *= t2, p3 *= t2, L *= t2;
        }
      }
      l[r2] = u4, l[r2 + 1] = p3, l[r2 + 2] = L, l[r2 + 3] = c3, r2 += d3;
    }
  else
    for (let t = 0; t < u3; ++t) {
      const e4 = 4 * n2[t], f2 = s2[e4], o3 = s2[e4 + 1], c3 = s2[e4 + 2], u4 = s2[e4 + 3];
      let p3 = a2 * f2 + g2 * o3 + h3 * c3, L = y4 * f2 + b3 * o3 + S3 * c3, F = B2 * f2 + O3 * o3 + N3 * c3;
      if (R3) {
        const e5 = p3 * p3 + L * L + F * F;
        if (e5 < A4 && e5 > E2) {
          const t2 = 1 / Math.sqrt(e5);
          p3 *= t2, L *= t2, F *= t2;
        }
      }
      for (let t2 = 0; t2 < i3; ++t2)
        l[r2] = p3, l[r2 + 1] = L, l[r2 + 2] = F, l[r2 + 3] = u4, r2 += d3;
    }
}
function S(e3, t, f, o2, r2 = 1) {
  const { data: i3, indices: s2 } = e3, n2 = f.typedBuffer, c2 = f.typedBufferStride, l = s2.length;
  if (o2 *= c2, t !== i3.length || 4 !== t)
    if (1 !== r2)
      if (4 !== t)
        for (let d3 = 0; d3 < l; ++d3) {
          const e4 = 3 * s2[d3];
          for (let t2 = 0; t2 < r2; ++t2)
            n2[o2] = i3[e4], n2[o2 + 1] = i3[e4 + 1], n2[o2 + 2] = i3[e4 + 2], n2[o2 + 3] = 255, o2 += c2;
        }
      else
        for (let d3 = 0; d3 < l; ++d3) {
          const e4 = 4 * s2[d3];
          for (let t2 = 0; t2 < r2; ++t2)
            n2[o2] = i3[e4], n2[o2 + 1] = i3[e4 + 1], n2[o2 + 2] = i3[e4 + 2], n2[o2 + 3] = i3[e4 + 3], o2 += c2;
        }
    else {
      if (4 === t) {
        for (let e4 = 0; e4 < l; ++e4) {
          const t2 = 4 * s2[e4];
          n2[o2] = i3[t2], n2[o2 + 1] = i3[t2 + 1], n2[o2 + 2] = i3[t2 + 2], n2[o2 + 3] = i3[t2 + 3], o2 += c2;
        }
        return;
      }
      for (let e4 = 0; e4 < l; ++e4) {
        const t2 = 3 * s2[e4];
        n2[o2] = i3[t2], n2[o2 + 1] = i3[t2 + 1], n2[o2 + 2] = i3[t2 + 2], n2[o2 + 3] = 255, o2 += c2;
      }
    }
  else {
    n2[o2] = i3[0], n2[o2 + 1] = i3[1], n2[o2 + 2] = i3[2], n2[o2 + 3] = i3[3];
    const e4 = new Uint32Array(f.typedBuffer.buffer, f.start), t2 = c2 / 4, s3 = e4[o2 /= 4];
    o2 += t2;
    const d3 = l * r2;
    for (let f2 = 1; f2 < d3; ++f2)
      e4[o2] = s3, o2 += t2;
  }
}
function N(e3, t, f) {
  const { data: o2, indices: r2 } = e3, i3 = t.typedBuffer, s2 = t.typedBufferStride, n2 = r2.length, c2 = o2[0];
  f *= s2;
  for (let l = 0; l < n2; ++l)
    i3[f] = c2, f += s2;
}
function R(e3, t, f, o2, r2 = 1) {
  const i3 = t.typedBuffer, s2 = t.typedBufferStride;
  if (o2 *= s2, 1 === r2)
    for (let n2 = 0; n2 < f; ++n2)
      i3[o2] = e3[0], i3[o2 + 1] = e3[1], i3[o2 + 2] = e3[2], i3[o2 + 3] = e3[3], o2 += s2;
  else
    for (let n2 = 0; n2 < f; ++n2)
      for (let t2 = 0; t2 < r2; ++t2)
        i3[o2] = e3[0], i3[o2 + 1] = e3[1], i3[o2 + 2] = e3[2], i3[o2 + 3] = e3[3], o2 += s2;
}
function E(e3, t, o2, r2, i3, s2) {
  var _a;
  for (const n2 of t.fields.keys()) {
    const t2 = e3.attributes.get(n2), c2 = t2 == null ? void 0 : t2.indices;
    if (t2 && c2)
      A2(n2, t2, o2, r2, i3, s2);
    else if (n2 === e.OBJECTANDLAYERIDCOLOR && null != e3.objectAndLayerIdColor) {
      const t3 = (_a = e3.attributes.get(e.POSITION)) == null ? void 0 : _a.indices;
      if (t3) {
        const o3 = t3.length, r3 = i3.getField(n2, x);
        R(e3.objectAndLayerIdColor, r3, o3, s2);
      }
    }
  }
}
function A2(e3, t, d3, a2, y4, B2) {
  switch (e3) {
    case e.POSITION: {
      s(3 === t.size);
      const f = y4.getField(e3, i2);
      s(!!f, `No buffer view for ${e3}`), f && b(t, d3, f, B2);
      break;
    }
    case e.NORMAL: {
      s(3 === t.size);
      const f = y4.getField(e3, i2);
      s(!!f, `No buffer view for ${e3}`), f && O(t, a2, f, B2);
      break;
    }
    case e.NORMALCOMPRESSED: {
      s(2 === t.size);
      const f = y4.getField(e3, q);
      s(!!f, `No buffer view for ${e3}`), f && u2(t, f, B2);
      break;
    }
    case e.UV0: {
      s(2 === t.size);
      const f = y4.getField(e3, u);
      s(!!f, `No buffer view for ${e3}`), f && u2(t, f, B2);
      break;
    }
    case e.COLOR:
    case e.SYMBOLCOLOR: {
      const o2 = y4.getField(e3, x);
      s(!!o2, `No buffer view for ${e3}`), s(3 === t.size || 4 === t.size), !o2 || 3 !== t.size && 4 !== t.size || S(t, t.size, o2, B2);
      break;
    }
    case e.COLORFEATUREATTRIBUTE: {
      const f = y4.getField(e3, y);
      s(!!f, `No buffer view for ${e3}`), s(1 === t.size), f && 1 === t.size && N(t, f, B2);
      break;
    }
    case e.TANGENT: {
      s(4 === t.size);
      const f = y4.getField(e3, c);
      s(!!f, `No buffer view for ${e3}`), f && h(t, a2, f, B2);
      break;
    }
    case e.PROFILERIGHT:
    case e.PROFILEUP:
    case e.PROFILEVERTEXANDNORMAL:
    case e.FEATUREVALUE: {
      s(4 === t.size);
      const f = y4.getField(e3, c);
      s(!!f, `No buffer view for ${e3}`), f && p(t, f, B2);
    }
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/RayIntersections.js
var p2 = class {
  constructor(t = false, n2 = true) {
    this.isVerticalRay = t, this.normalRequired = n2;
  }
};
var m = i();
function h2(n2, o2, e3, i3, s2, c2) {
  if (!n2.visible)
    return;
  const r2 = K(P, i3, e3), a2 = (t, n3, o3) => {
    c2(t, o3, n3, false);
  }, m2 = new p2(false, o2.options.normalRequired);
  if (n2.boundingInfo) {
    s(n2.type === e2.Mesh);
    const t = o2.tolerance;
    b2(n2.boundingInfo, e3, r2, t, s2, m2, a2);
  } else {
    const t = n2.attributes.get(e.POSITION), o3 = t.indices;
    V(e3, r2, 0, o3.length / 3, o3, t.data, t.stride, s2, m2, a2);
  }
}
var d2 = n();
function b2(t, n2, o2, e3, i3, s2, c2) {
  if (null == t)
    return;
  const f = C(o2, d2);
  if (A(m, t.bbMin), G(m, t.bbMax), null != i3 && i3.applyToAabb(m), k(m, n2, f, e3)) {
    const { primitiveIndices: r2, position: a2 } = t, f2 = r2 ? r2.length : a2.indices.length / 3;
    if (f2 > z2) {
      const r3 = t.getChildren();
      if (void 0 !== r3) {
        for (const t2 of r3)
          b2(t2, n2, o2, e3, i3, s2, c2);
        return;
      }
    }
    g(n2, o2, 0, f2, a2.indices, a2.data, a2.stride, r2, i3, s2, c2);
  }
}
var M = n();
function x2(n2, o2, e3, i3, s2, c2, r2, a2, f) {
  const { data: u3, stride: l } = c2;
  V(n2, K(P, o2, n2), e3, i3, s2, u3, l, r2, a2, f);
}
function y3(t, n2, o2, e3, i3, s2, c2, r2, a2, f, u3) {
  const l = t[0], p3 = t[1], m2 = t[2], h3 = n2[0], d3 = n2[1], b3 = n2[2], { normalRequired: x3 } = r2;
  for (let y4 = o2; y4 < e3; ++y4) {
    const t2 = f[y4] + u3, n3 = 3 * t2, o3 = c2 * i3[n3], e4 = s2[o3], r3 = s2[o3 + 1], T = s2[o3 + 2], g2 = c2 * i3[n3 + 1], V2 = s2[g2], j2 = s2[g2 + 1], R3 = s2[g2 + 2], q3 = c2 * i3[n3 + 2], I2 = V2 - e4, O3 = j2 - r3, A4 = R3 - T, B2 = s2[q3] - e4, C2 = s2[q3 + 1] - r3, k2 = s2[q3 + 2] - T, w2 = d3 * k2 - C2 * b3, z3 = b3 * B2 - k2 * h3, P2 = h3 * C2 - B2 * d3, S3 = I2 * w2 + O3 * z3 + A4 * P2;
    if (Math.abs(S3) <= N2)
      continue;
    const U = l - e4, D = p3 - r3, E2 = m2 - T, F = U * w2 + D * z3 + E2 * P2;
    if (S3 > 0) {
      if (F < 0 || F > S3)
        continue;
    } else if (F > 0 || F < S3)
      continue;
    const G3 = D * A4 - O3 * E2, H2 = E2 * I2 - A4 * U, J = U * O3 - I2 * D, K2 = h3 * G3 + d3 * H2 + b3 * J;
    if (S3 > 0) {
      if (K2 < 0 || F + K2 > S3)
        continue;
    } else if (K2 > 0 || F + K2 < S3)
      continue;
    const L = (B2 * G3 + C2 * H2 + k2 * J) / S3;
    if (L >= 0) {
      a2(L, t2, x3 ? v(I2, O3, A4, B2, C2, k2, M) : null);
    }
  }
}
function g(t, n2, o2, e3, i3, s2, c2, r2, a2, f, u3) {
  const l = t[0], p3 = t[1], m2 = t[2], h3 = n2[0], d3 = n2[1], b3 = n2[2], { normalRequired: x3 } = f;
  for (let y4 = o2; y4 < e3; ++y4) {
    const t2 = r2[y4], n3 = 3 * t2, o3 = c2 * i3[n3];
    let e4 = s2[o3], f2 = s2[o3 + 1], T = s2[o3 + 2];
    const g2 = c2 * i3[n3 + 1];
    let V2 = s2[g2], j2 = s2[g2 + 1], R3 = s2[g2 + 2];
    const q3 = c2 * i3[n3 + 2];
    let I2 = s2[q3], O3 = s2[q3 + 1], A4 = s2[q3 + 2];
    null != a2 && ([e4, f2, T] = a2.applyToVertex(e4, f2, T, y4), [V2, j2, R3] = a2.applyToVertex(V2, j2, R3, y4), [I2, O3, A4] = a2.applyToVertex(I2, O3, A4, y4));
    const B2 = V2 - e4, C2 = j2 - f2, k2 = R3 - T, w2 = I2 - e4, z3 = O3 - f2, P2 = A4 - T, S3 = d3 * P2 - z3 * b3, U = b3 * w2 - P2 * h3, D = h3 * z3 - w2 * d3, E2 = B2 * S3 + C2 * U + k2 * D;
    if (Math.abs(E2) <= N2)
      continue;
    const F = l - e4, G3 = p3 - f2, H2 = m2 - T, J = F * S3 + G3 * U + H2 * D;
    if (E2 > 0) {
      if (J < 0 || J > E2)
        continue;
    } else if (J > 0 || J < E2)
      continue;
    const K2 = G3 * k2 - C2 * H2, L = H2 * B2 - k2 * F, Q = F * C2 - B2 * G3, W = h3 * K2 + d3 * L + b3 * Q;
    if (E2 > 0) {
      if (W < 0 || J + W > E2)
        continue;
    } else if (W > 0 || J + W < E2)
      continue;
    const X = (w2 * K2 + z3 * L + P2 * Q) / E2;
    if (X >= 0) {
      u3(X, t2, x3 ? v(B2, C2, k2, w2, z3, P2, M) : null);
    }
  }
}
function V(e3, i3, s2, c2, r2, a2, f, u3, l, p3) {
  const m2 = i3, h3 = S2, d3 = Math.abs(m2[0]), b3 = Math.abs(m2[1]), M2 = Math.abs(m2[2]), x3 = d3 >= b3 ? d3 >= M2 ? 0 : 2 : b3 >= M2 ? 1 : 2, y4 = x3, T = m2[y4] < 0 ? 2 : 1, g2 = (x3 + T) % 3, V2 = (x3 + (3 - T)) % 3, v2 = m2[g2] / m2[y4], O3 = m2[V2] / m2[y4], A4 = 1 / m2[y4], B2 = j, C2 = R2, k2 = q2, { normalRequired: w2 } = l;
  for (let j2 = s2; j2 < c2; ++j2) {
    const i4 = 3 * j2, s3 = f * r2[i4];
    o(h3[0], a2[s3 + 0], a2[s3 + 1], a2[s3 + 2]);
    const c3 = f * r2[i4 + 1];
    o(h3[1], a2[c3 + 0], a2[c3 + 1], a2[c3 + 2]);
    const l2 = f * r2[i4 + 2];
    o(h3[2], a2[l2 + 0], a2[l2 + 1], a2[l2 + 2]), u3 && (r(h3[0], u3.applyToVertex(h3[0][0], h3[0][1], h3[0][2], j2)), r(h3[1], u3.applyToVertex(h3[1][0], h3[1][1], h3[1][2], j2)), r(h3[2], u3.applyToVertex(h3[2][0], h3[2][1], h3[2][2], j2))), K(B2, h3[0], e3), K(C2, h3[1], e3), K(k2, h3[2], e3);
    const m3 = B2[g2] - v2 * B2[y4], d4 = B2[V2] - O3 * B2[y4], b4 = C2[g2] - v2 * C2[y4], M3 = C2[V2] - O3 * C2[y4], x4 = k2[g2] - v2 * k2[y4], T2 = k2[V2] - O3 * k2[y4], R3 = x4 * M3 - T2 * b4, q3 = m3 * T2 - d4 * x4, z3 = b4 * d4 - M3 * m3;
    if ((R3 < 0 || q3 < 0 || z3 < 0) && (R3 > 0 || q3 > 0 || z3 > 0))
      continue;
    const N3 = R3 + q3 + z3;
    if (0 === N3)
      continue;
    const P2 = R3 * (A4 * B2[y4]) + q3 * (A4 * C2[y4]) + z3 * (A4 * k2[y4]);
    if (P2 * Math.sign(N3) < 0)
      continue;
    const S3 = P2 / N3;
    if (S3 >= 0) {
      p3(S3, j2, w2 ? I(h3) : null);
    }
  }
}
var j = n();
var R2 = n();
var q2 = n();
function v(t, o2, s2, c2, r2, a2, f) {
  return o(O2, t, o2, s2), o(A3, c2, r2, a2), _(f, O2, A3), z(f, f), f;
}
function I(n2) {
  return K(O2, n2[1], n2[0]), K(A3, n2[2], n2[0]), _(M, O2, A3), z(M, M), M;
}
var O2 = n();
var A3 = n();
function B(t, o2, e3) {
  return o(e3, 1 / (o2[0] - t[0]), 1 / (o2[1] - t[1]), 1 / (o2[2] - t[2]));
}
function C(t, o2) {
  return o(o2, 1 / t[0], 1 / t[1], 1 / t[2]);
}
function k(t, n2, o2, e3) {
  return w(t, n2, o2, e3, 1 / 0);
}
function w(t, n2, o2, e3, i3) {
  const s2 = (t[0] - e3 - n2[0]) * o2[0], c2 = (t[3] + e3 - n2[0]) * o2[0];
  let r2 = Math.min(s2, c2), a2 = Math.max(s2, c2);
  const f = (t[1] - e3 - n2[1]) * o2[1], u3 = (t[4] + e3 - n2[1]) * o2[1];
  if (a2 = Math.min(a2, Math.max(f, u3)), a2 < 0)
    return false;
  if (r2 = Math.max(r2, Math.min(f, u3)), r2 > a2)
    return false;
  const l = (t[2] - e3 - n2[2]) * o2[2], p3 = (t[5] + e3 - n2[2]) * o2[2];
  return a2 = Math.min(a2, Math.max(l, p3)), !(a2 < 0) && (r2 = Math.max(r2, Math.min(l, p3)), !(r2 > a2) && r2 < i3);
}
var z2 = 1e3;
var N2 = 1e-7;
var P = n();
var S2 = [n(), n(), n()];

export {
  p2 as p,
  h2 as h,
  x2 as x,
  y3 as y,
  B,
  k,
  w,
  d,
  p as p2,
  y2,
  b,
  O,
  S,
  R,
  E,
  A2 as A
};
//# sourceMappingURL=chunk-M6P775BS.js.map
