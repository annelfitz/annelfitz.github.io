import {
  d as d4
} from "./chunk-O7GHSWFW.js";
import {
  A,
  I as I5
} from "./chunk-XPABJ7YF.js";
import {
  a as a8,
  s as s9
} from "./chunk-52QXS2S5.js";
import {
  a as a9
} from "./chunk-BZ24WJCW.js";
import {
  c as c3
} from "./chunk-BY6CCMKY.js";
import {
  u as u9
} from "./chunk-YWPIIZFL.js";
import {
  i as i3
} from "./chunk-QFYJUFUK.js";
import {
  d2 as d3,
  f,
  o as o4,
  u2 as u8
} from "./chunk-4VVENLLF.js";
import {
  s as s8
} from "./chunk-2LPPSWTR.js";
import {
  c as c2,
  t as t4
} from "./chunk-BEXFYHUM.js";
import {
  n as n9,
  r as r8,
  t as t3,
  u as u7
} from "./chunk-BQGPMKNK.js";
import {
  N
} from "./chunk-XVQGALI7.js";
import {
  r as r7
} from "./chunk-XFQIXBHG.js";
import {
  o as o3
} from "./chunk-6ENXMQPD.js";
import {
  a as a7,
  c,
  d as d2,
  h as h3,
  l as l3,
  o as o2,
  r as r6,
  s as s7
} from "./chunk-BYRUCUF7.js";
import {
  e as e10
} from "./chunk-CXP4BHPO.js";
import {
  H as H2,
  I as I4,
  L as L3,
  s as s6
} from "./chunk-ESK2YRQM.js";
import {
  C as C2,
  I as I3,
  i as i2
} from "./chunk-QYDOVVH7.js";
import {
  t
} from "./chunk-HXYRQKMI.js";
import {
  D
} from "./chunk-WKVHVZW2.js";
import {
  S as S2,
  h as h2
} from "./chunk-7KK6L4F6.js";
import {
  e as e9,
  s as s5,
  u as u6
} from "./chunk-TXLJQAAN.js";
import {
  g as g3
} from "./chunk-QJRGTKPN.js";
import {
  F as F2,
  H,
  O as O3,
  Z as Z2,
  de,
  ge,
  k as k2,
  ye
} from "./chunk-676ANOCK.js";
import {
  e as e7
} from "./chunk-BKOYOJBG.js";
import {
  I,
  p as p2
} from "./chunk-5DH2QVPW.js";
import {
  I as I2,
  L as L2
} from "./chunk-GPWQGIYV.js";
import {
  l as l2,
  o
} from "./chunk-WZJNHZ6H.js";
import {
  O as O2,
  T,
  Z,
  it,
  k,
  w as w2
} from "./chunk-XMYPMIYH.js";
import {
  e as e6
} from "./chunk-LGMX4E7L.js";
import {
  r as r5,
  t as t2
} from "./chunk-U34ZXOJT.js";
import {
  F,
  V as V2
} from "./chunk-Z2F5OKVA.js";
import {
  a as a6
} from "./chunk-O76UVYOO.js";
import {
  j
} from "./chunk-HZSGATFT.js";
import {
  e as e8
} from "./chunk-NFB6O77E.js";
import {
  n as n8
} from "./chunk-AKEHDP75.js";
import {
  a as a5,
  r as r4
} from "./chunk-5MMGIT64.js";
import {
  a as a4,
  n as n7,
  r as r3
} from "./chunk-JW7VBMHD.js";
import {
  u as u5
} from "./chunk-WDPG5BMO.js";
import {
  G as G3
} from "./chunk-GBF2OQAY.js";
import {
  g as g2,
  u as u4
} from "./chunk-C7NPPGFR.js";
import {
  e as e5
} from "./chunk-OCF7OAES.js";
import {
  G as G2,
  K,
  P as P2,
  U as U2,
  X,
  Y,
  e as e4,
  g,
  p,
  q,
  r as r2,
  s as s4,
  u as u3,
  v,
  x,
  z as z2
} from "./chunk-JZBR4X6W.js";
import {
  _ as _3,
  n as n6
} from "./chunk-OIJCMME5.js";
import {
  n as n5
} from "./chunk-TPLOIZC7.js";
import {
  u as u2
} from "./chunk-C62RZQQX.js";
import {
  n as n4
} from "./chunk-Z2PDA67N.js";
import {
  G,
  O,
  s3
} from "./chunk-UWQ3OYA5.js";
import {
  U,
  _,
  i2 as i,
  m2
} from "./chunk-SAYWXQVM.js";
import {
  C,
  P,
  d
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  _ as _2,
  b as b2,
  y as y2
} from "./chunk-BVQWKK2V.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  l
} from "./chunk-C26KUZ46.js";
import {
  $,
  L,
  a as a2,
  b,
  e as e3,
  h,
  s as s2,
  w
} from "./chunk-JGDJR5EV.js";
import {
  e as e2,
  n as n3,
  u
} from "./chunk-QHK5ZYFW.js";
import {
  a,
  n2,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has,
  m,
  n,
  r2 as r,
  z
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/enums.js
var e11;
var s10;
!function(e12) {
  e12[e12.KTX2 = 1] = "KTX2", e12[e12.Basis = 2] = "Basis", e12[e12.DDS_S3TC = 4] = "DDS_S3TC", e12[e12.PNG = 8] = "PNG", e12[e12.JPG = 16] = "JPG", e12[e12.KTX_ETC2 = 32] = "KTX_ETC2";
}(e11 || (e11 = {})), function(e12) {
  e12[e12.None = 0] = "None", e12[e12.Color = 1] = "Color", e12[e12.MetallicRoughness = 2] = "MetallicRoughness", e12[e12.Normal = 4] = "Normal", e12[e12.Occlusion = 8] = "Occlusion", e12[e12.Emissive = 16] = "Emissive", e12[e12.AlphaMask = 32] = "AlphaMask", e12[e12.ColorTextures = 19] = "ColorTextures", e12[e12.GeometryTextures = 36] = "GeometryTextures", e12[e12.GeometryTexturesPBR = 44] = "GeometryTexturesPBR", e12[e12.AllTextures = 37] = "AllTextures", e12[e12.AllTexturesPBR = 63] = "AllTexturesPBR";
}(s10 || (s10 = {}));

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SClientMaterialUtil.js
async function c4(o6) {
  const t5 = [], r10 = [];
  if (null == o6) {
    return { material: { alphaMode: "opaque", alphaCutoff: 0.1, doubleSided: true, cullFace: 0, normalTextureId: -1, emissiveTextureId: -1, occlusionTextureId: -1, emissiveFactor: [0, 0, 0], metallicRoughness: { baseColorFactor: [1, 1, 1, 1], baseColorTextureId: -1, metallicRoughnessTextureId: -1, metallicFactor: 0, roughnessFactor: 0.6000000238418579 }, wrapTextures: false, hasParametersFromSource: true }, requiredTextures: t5, textureData: r10 };
  }
  const a12 = d5(o6);
  "auto" === o6.alphaMode && console.warn('alphaMode "auto" not supported by I3S PBRMaterial - defaulting to "blend".');
  const n10 = u7({ normalTexture: o6.normalTexture, emissiveTexture: a12 ? o6.emissiveTexture : null, emissiveFactor: a12 ? u5.toUnitRGB(o6.emissiveColor) : null, occlusionTexture: a12 ? o6.occlusionTexture : null, metallicRoughnessTexture: a12 ? o6.metallicRoughnessTexture : null, metallicFactor: a12 ? o6.metallic : null, roughnessFactor: a12 ? o6.roughness : null }), c7 = n10 ? t3[0] : a12 ? o6.metallic : 0, g6 = n10 ? t3[1] : a12 ? o6.roughness : 0;
  return { material: { alphaMode: "auto" === o6.alphaMode ? "blend" : o6.alphaMode, alphaCutoff: o6.alphaCutoff, doubleSided: o6.doubleSided, cullFace: o6.doubleSided ? e9.None : e9.Back, normalTextureId: await m3(o6.normalTexture, t5, r10, s10.Normal), emissiveTextureId: a12 ? await m3(o6.emissiveTexture, t5, r10, s10.Emissive) : -1, occlusionTextureId: a12 ? await m3(o6.occlusionTexture, t5, r10, s10.Occlusion) : -1, emissiveFactor: a12 && null != o6.emissiveColor ? u5.toUnitRGB(o6.emissiveColor) : [0, 0, 0], metallicRoughness: { baseColorFactor: null != o6.color ? u5.toUnitRGBA(o6.color) : [1, 1, 1, 1], baseColorTextureId: await m3(o6.colorTexture, t5, r10, s10.Color), metallicRoughnessTextureId: a12 ? await m3(o6.metallicRoughnessTexture, t5, r10, s10.MetallicRoughness) : -1, metallicFactor: c7, roughnessFactor: g6 }, wrapTextures: true, hasParametersFromSource: n10 }, requiredTextures: t5, textureData: r10 };
}
async function m3(e12, s12, l5, i4) {
  if (null == e12)
    return -1;
  const u10 = l5.length, c7 = e12.data, m5 = e12.url;
  if (null != c7) {
    if (c7 instanceof HTMLImageElement || c7 instanceof HTMLCanvasElement) {
      const e13 = r7(c7);
      return l5.push({ id: u10, usage: i4, data: e13, encoding: e11.PNG, downsampled: false }), s12.push({ id: u10, usage: i4, encodings: [{ name: void 0, encoding: e11.PNG }] }), u10;
    }
    if (c7 instanceof HTMLVideoElement)
      return -1;
    if (c7 instanceof ImageData)
      throw new s("ImageData textures not supported yet for client side I3S nodes");
    if (c7 instanceof t)
      throw new s("EncodedMeshTexture textures not supported yet for client side I3S nodes");
  } else if (null != m5) {
    const e13 = new Image();
    e13.src = m5;
    const o6 = await i(e13, e13.src, false, void 0), r10 = r7(o6);
    return l5.push({ id: u10, usage: i4, data: r10, encoding: e11.PNG, downsampled: false }), s12.push({ id: u10, usage: i4, encodings: [{ name: void 0, encoding: e11.PNG }] }), u10;
  }
  return -1;
}
function d5(e12) {
  return e12.hasOwnProperty("metallicRoughnessTexture");
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SClientNodeLoader.js
var h4 = class {
  constructor(e12, t5, o6, r10) {
    this._uid = e12, this._worker = r10, this._id2Meta = /* @__PURE__ */ new Map(), this._oid2Meta = /* @__PURE__ */ new Map(), this._indexSR = t5.indexSR, this._vertexSR = t5.vertexSR, this._renderSR = t5.renderSR, this._localMode = t5.localMode, this._memCache = o6.newCache(`sl-client-mesh-data-${this._uid}`);
  }
  get uid() {
    return this._uid;
  }
  get worker() {
    return this._worker;
  }
  get indexSR() {
    return this._indexSR;
  }
  get renderSR() {
    return this._renderSR;
  }
  createMeshNodeInfo(e12, t5) {
    const o6 = `mesh${t5}`, r10 = e12.extent, n10 = r10.spatialReference, s12 = this._indexSR, a12 = p3(r10, e12.origin);
    a8(a12, n10, a12, s12);
    return { type: "mesh", id: o6, version: M(e12), oid: t5, mbs: a12, componentNodeIds: [], unloadedMesh: e12, nodeIndex: null, loadMeshPromise: null };
  }
  addMeshNode(t5, o6) {
    if (null != this.getMeshNodeIndex(o6.oid))
      throw new s(`I3SClientNodeLoader: client side mesh for feature oid=${o6.oid} already exists`);
    o6.nodeIndex = t5, this._id2Meta.set(o6.id, o6), this._oid2Meta.set(o6.oid, o6);
  }
  getMeshNodeIndex(e12) {
    const t5 = this._oid2Meta.get(e12);
    return null == t5 || "mesh" !== t5.type ? null : t5.nodeIndex;
  }
  getMeshNodeInfo(e12) {
    const t5 = this._oid2Meta.values();
    for (const o6 of t5)
      if ("mesh" === o6.type && o6.id === e12)
        return o6;
    return null;
  }
  removeNode(e12) {
    const t5 = this._id2Meta.get(e12);
    null != t5 && (this._id2Meta.delete(e12), "mesh" === t5.type && this._oid2Meta.delete(t5.oid));
  }
  async loadNodeJSON(t5) {
    const o6 = this._id2Meta.get(t5);
    if (null == o6)
      throw new s(`I3SClientNodeLoader::loadNodeJSON unable to find node ${t5}`);
    switch (o6.type) {
      case "mesh":
        return this._loadMeshNodeJSON(o6);
      case "mesh-component":
        return f2(o6);
      default:
        throw new s(`I3SClientNodeLoader::loadNodeJSON unable to handle node ${t5}`);
    }
  }
  async _loadMeshNodeJSON(e12) {
    const t5 = e12.id, o6 = (await this._getMeshData(e12)).loadedMesh;
    if (null == o6.components || 0 === o6.components.length)
      return { id: t5, version: null, mbs: e12.mbs, obb: null, sharedResource: null, geometryData: null, attributeData: null, featureData: null, children: null };
    const r10 = [], n10 = o6.components;
    for (let s12 = 0; s12 < n10.length; ++s12) {
      const o7 = `${t5}-component${s12}`, n11 = { type: "mesh-component", id: o7, mbs: e12.mbs, componentIndex: s12, meshNodeInfo: e12, textureData: /* @__PURE__ */ new Map() };
      this._id2Meta.set(n11.id, n11), e12.componentNodeIds.push(o7), r10.push({ id: n11.id, href: null, mbs: n11.mbs, obb: null });
    }
    return { id: t5, version: null, mbs: e12.mbs, obb: null, sharedResource: null, geometryData: null, attributeData: null, featureData: null, children: r10 };
  }
  updateNodeIndex(e12, t5, o6) {
    const r10 = this._id2Meta.get(e12);
    r10 && "mesh" === r10.type && (r10.nodeIndex = o6);
  }
  async loadNodeData(o6, n10) {
    const s12 = this._id2Meta.get(o6);
    if (null == s12 || "mesh-component" !== s12.type)
      throw new s(`Failed to load client node data for node ${o6} (unexpected node info)`);
    const a12 = s12.meshNodeInfo, i4 = await this._getMeshData(a12), l5 = i4.loadedMesh, d8 = a12.oid;
    if (null == l5.components)
      throw new s(`Failed to load client node data for node ${o6} (unexpected null reference)`);
    const u10 = l5.components[s12.componentIndex], { material: c7, requiredTextures: h8, textureData: f4 } = await c4(u10.material);
    if (null != f4)
      for (const e12 of f4)
        null != e12 && s12.textureData.set(e12.id, e12);
    const p5 = { params: { material: c7 }, type: "ArrayBufferView" }, { vertexSpace: g6, origin: M5, transform: _6 } = l5, w6 = [M5.x, M5.y, M5.z ?? 0], S6 = { featureDataPosition: w6, featureIds: [], geometries: [p5] }, b6 = { attributeData: {}, loadedAttributes: [] };
    i4.projectionPromise || (n3(this._worker, "SceneLayerWorker is needed to project mesh"), i4.projectionPromise = this._worker.project({ positions: l5.vertexAttributes.position, localMatrix: _6 == null ? void 0 : _6.localMatrix, vertexSpace: g6.toJSON(), origin: w6, inSpatialReference: l5.spatialReference.toJSON(), outSpatialReference: this._vertexSR.toJSON(), localMode: this._localMode }, n10));
    const { projected: N3, original: v2 } = await i4.projectionPromise;
    l5.vertexAttributes.position = v2;
    const { transformed: D5, original: I7 } = await x2(u10, i4, this._worker, n10);
    l5.vertexAttributes.normal = I7, s2(n10);
    const { geometryBuffer: j3, geometryDescriptor: R4 } = y3(N3, u10.faces, D5, l5.vertexAttributes.uv, l5.vertexAttributes.color, d8);
    return { geometryData: S6, attributeDataInfo: b6, geometryBuffer: j3, geometryDescriptor: R4, requiredTextures: h8, textureData: f4, normalReferenceFrame: this._vertexSR.isGeographic ? "east-north-up" : "vertex-reference-frame" };
  }
  async loadAttributes(e12, t5, o6) {
    const r10 = e12.numFeatures, n10 = {};
    for (const { field: { name: s12 } } of t5)
      n10[s12] = new Array(r10);
    return n10;
  }
  async loadTextures(e12, t5, o6) {
    const r10 = e12.id, n10 = this._id2Meta.get(r10);
    if (null == n10 || "mesh-component" !== n10.type)
      throw new Error(`Failed to load textures for node ${e12.id} (unexpected node info)`);
    const s12 = [];
    for (const a12 of t5)
      s12.push(n10.textureData.get(a12.id) || null);
    return s12;
  }
  async _getMeshData(e12) {
    const t5 = e12.version, r10 = this._memCache.get(t5);
    if (null == r10) {
      if (null != e12.loadMeshPromise)
        return e12.loadMeshPromise;
      const r11 = async (r12, n10) => {
        const s12 = e12.unloadedMesh.clone();
        try {
          await s12.load();
        } catch (l5) {
          n10(l5);
        }
        const a12 = s12.memoryUsage, i4 = { loadedMesh: s12, projectionPromise: null, normalsTransformPromise: null, usedMemoryInBytes: a12 };
        this._memCache.put(t5, i4, a12, e6), e12.loadMeshPromise = null, r12(i4);
      };
      return e12.loadMeshPromise = new Promise((e13, t6) => r11(e13, t6)), e12.loadMeshPromise;
    }
    return r10;
  }
};
async function f2(e12) {
  return { id: e12.id, version: e12.meshNodeInfo.version, mbs: e12.mbs, obb: null, sharedResource: null, geometryData: null, attributeData: null, featureData: null, children: null, isEmpty: false };
}
function p3(e12, t5) {
  const { spatialReference: o6 } = e12, r10 = [1, -1], n10 = [0.5 * e12.width, 0.5 * e12.height, e12.hasZ ? 0.5 * (e12.zmax - e12.zmin) : 0], s12 = o6.isGeographic ? o6.metersPerUnit : 1, a12 = e12.center;
  let i4 = 0;
  if (e12.hasZ)
    for (let l5 = 0; l5 < 2; ++l5)
      for (let e13 = 0; e13 < 2; ++e13)
        for (let o7 = 0; o7 < 2; ++o7) {
          const d8 = (a12.x + r10[l5] * n10[0] - t5.x) * s12, u10 = (a12.y + r10[e13] * n10[1] - t5.y) * s12, c7 = a12.z + r10[o7] * n10[2] - t5.z;
          i4 = Math.max(d8 * d8 + u10 * u10 + c7 * c7, i4);
        }
  else
    for (let l5 = 0; l5 < 2; ++l5)
      for (let e13 = 0; e13 < 2; ++e13) {
        const o7 = (a12.x + r10[l5] * n10[0] - t5.x) * s12, d8 = (a12.y + r10[e13] * n10[1] - t5.y) * s12;
        i4 = Math.max(o7 * o7 + d8 * d8, i4);
      }
  return T([t5.x, t5.y, t5.z], Math.sqrt(i4));
}
async function x2(e12, o6, r10, n10) {
  const { transform: d8, vertexAttributes: u10 } = o6.loadedMesh, c7 = "source" === e12.shading ? u10.normal : null;
  if (!(null != c7 && null != d8 && (0 !== d8.rotationAngle || !G2(d8.scale, _3))))
    return { transformed: c7, original: u10.normal };
  if (!o6.normalsTransformPromise) {
    n3(r10, "SceneLayerWorker is needed to transform mesh normals");
    const e13 = e8();
    j(e13, d8.localMatrix), o6.normalsTransformPromise = r10.transformNormals({ normalMatrix: e13, normals: c7 }, n10);
  }
  return o6.normalsTransformPromise;
}
function y3(e12, t5, o6, r10, n10, s12) {
  const a12 = 1, i4 = t5.length / 3, l5 = 3 * i4;
  let d8 = 0, u10 = 0, c7 = false, m5 = 0, h8 = false, f4 = 0, p5 = false, x5 = 0, y5 = 0, M5 = 0;
  d8 += _4, d8 += _4, u10 = d8, d8 += 3 * l5 * w3, null != o6 && (c7 = true, m5 = d8, d8 += 3 * l5 * w3), null != r10 && (h8 = true, f4 = d8, d8 += 2 * l5 * w3), null != n10 && (p5 = true, x5 = d8, d8 += 4 * l5 * S3), y5 = d8, d8 += a12 * b3, M5 = d8, d8 += 2 * a12 * _4;
  const N3 = new ArrayBuffer(d8), v2 = new Uint8Array(N3);
  g4(v2, 0, l5), g4(v2, _4, a12);
  const D5 = new Float32Array(N3, u10), I7 = null != o6 ? new Float32Array(N3, m5) : null, j3 = null != r10 ? new Float32Array(N3, f4) : null, R4 = null != n10 ? new Uint8Array(N3, x5) : null;
  for (let g6 = 0; g6 < i4; ++g6) {
    const s13 = 3 * g6;
    for (let a13 = 0; a13 < 3; ++a13) {
      const i5 = t5[s13 + a13], l6 = 3 * i5, d9 = 9 * g6 + 3 * a13;
      if (D5[d9] = e12[l6], D5[d9 + 1] = e12[l6 + 1], D5[d9 + 2] = e12[l6 + 2], null != I7 && (I7[d9] = o6[l6], I7[d9 + 1] = o6[l6 + 1], I7[d9 + 2] = o6[l6 + 2]), null != j3) {
        const e13 = 2 * i5, t6 = 6 * g6 + 2 * a13;
        j3[t6] = r10[e13], j3[t6 + 1] = r10[e13 + 1];
      }
      if (null != R4) {
        const e13 = 4 * i5, t6 = 12 * g6 + 4 * a13;
        R4[t6] = n10[e13], R4[t6 + 1] = n10[e13 + 1], R4[t6 + 2] = n10[e13 + 2], R4[t6 + 3] = n10[e13 + 3];
      }
    }
  }
  g4(v2, y5, s12), g4(v2, y5 + _4, s12 / 2 ** 32), g4(v2, M5, 0), g4(v2, M5 + _4, i4 - 1);
  return { geometryBuffer: N3, geometryDescriptor: { isDraco: false, isLegacy: true, color: p5, normal: c7, uv0: h8, uvRegion: false, featureIndex: true } };
}
function g4(e12, t5, o6) {
  e12[t5] = 255 & o6, e12[t5 + 1] = 255 & o6 >> 8, e12[t5 + 2] = 255 & o6 >> 16, e12[t5 + 3] = 255 & o6 >> 24;
}
function M(e12) {
  var _a;
  const t5 = (_a = e12.metadata.displaySource) == null ? void 0 : _a.source;
  if (null == t5 || !Array.isArray(t5) || !t5.length || t5[0] instanceof File)
    return n5();
  const o6 = t5;
  let r10 = "";
  for (const n10 of o6)
    r10 += n10.makeHash();
  return r10 + JSON.stringify(null != e12.transform ? e12.transform.toJSON() : "") + (g3(e12.vertexSpace) ? JSON.stringify(e12.vertexSpace.origin) : "");
}
var _4 = 4;
var w3 = 4;
var S3 = 1;
var b3 = 8;

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SFrameTask.js
var a10 = class extends S {
  constructor() {
    super(), this.referenceCount = 0, this.callbacks = new Array(), this.runIndex = 0;
  }
  get running() {
    return this.callbacks.some((r10) => r10.running);
  }
  runTask(r10) {
    this._sort();
    const s12 = this.callbacks, t5 = { numIndexLoading: 0, numNodesLoading: 0 };
    for (let e12 = 0; e12 < s12.length && !r10.done; ++e12)
      s12[e12].priority = s12[e12].runTask(r10, t5), this.runIndex = e12;
  }
  _sort() {
    const r10 = this.callbacks;
    let s12 = r10.length;
    for (let t5 = this.runIndex; t5 > 0; t5--) {
      const e12 = r10[t5 - 1];
      let o6 = t5;
      for (; o6 < r10.length && e12.priority <= r10[o6].priority && (o6 !== s12 || e12.priority < r10[o6].priority); )
        r10[o6 - 1] = r10[o6], o6++;
      r10[o6 - 1] = e12, s12 = o6 - 1;
    }
    this.runIndex = 0;
  }
  add(r10) {
    this._sort(), r10.priority = 1 / 0, this.callbacks.unshift(r10), this.notifyChange("running");
  }
  remove(r10) {
    z(this.callbacks, r10), this.runIndex = this.callbacks.length, this._sort(), this.notifyChange("running");
  }
};
e([y({ readOnly: true })], a10.prototype, "running", null), a10 = e([a3("esri.views.3d.layers.i3s.I3SFrameTask")], a10);
var l4 = class {
  constructor(r10, s12) {
    this.task = r10, this.handle = s12;
  }
};
var c5 = /* @__PURE__ */ new Map();
function h5(r10, s12) {
  let t5 = c5.get(r10);
  if (null == t5) {
    const s13 = new a10(), e12 = r10.registerTask(I3.I3S_CONTROLLER, s13);
    t5 = new l4(s13, e12), c5.set(r10, t5);
  }
  return t5.task.add(s12), e3(() => {
    if (null == t5)
      return;
    t5.task.remove(s12);
    t5.task.callbacks.length > 0 || (c5.delete(r10), t5.handle.remove(), t5.task.destroy()), t5 = null;
  });
}

// node_modules/@arcgis/core/views/3d/layers/i3s/ValidatedNode.js
var s11 = class {
  constructor(s12, t5, i4, e12, h8, o6, r10, c7) {
    this.id = s12, this.mbs = t5, this.obb = i4, this.version = e12, this.resources = h8, this.children = o6, this.lodSelection = r10, this.numFeatures = c7;
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SIndex.js
var p4 = class {
  constructor(e12, t5, i4, n10, s12) {
    this.childOffset = e12, this.childCount = t5, this.visibilityCache = i4, this.ref = n10, this.node = s12, this.useAsHole = 0, this.filterImpact = o2.NotChecked, this.traversalState = null, this.parent = -1;
  }
  invalidateBounds() {
    var _a, _b;
    (_a = this.node) == null ? void 0 : _a.invalidateServiceBVsInRenderSR(), (_b = this.ref) == null ? void 0 : _b.invalidateServiceBVsInRenderSR();
  }
};
var b4 = class {
  constructor(e12 = new Array(), t5 = new Array()) {
    this.nodes = e12, this.children = t5, this.lastTraversed = 0, this.numNodesWithLoadedChildren = 0;
  }
};
var I6 = class {
  get _useNodePages() {
    return this._pageSize > 0;
  }
  constructor(t5, i4, n10, s12, o6, r10, l5, h8, u10, c7, g6, _6, f4, m5, v2, N3) {
    var _a, _b;
    this.viewingMode = t5, this._layer = i4, this._streamDataController = s12, this._clientNodeLoader = o6, this._viewportQueries = r10, this._logger = l5, this.holeFilling = h8, this._isLoaded = u10, this._isReloading = c7, this._isSelected = g6, this._enable = _6, this._needsUpdate = f4, this._canRequest = m5, this._computeVisibilityObb = v2, this._computeNodeFiltering = N3, this._dirty = true, this._nodePages = /* @__PURE__ */ new Map(), this._clientNodePage = null, this._pageSize = 0, this._rootIndex = 0, this._lodMetric = d2.None, this._lodConversion = (e12) => e12, this._isEditable = false, this._urlPrefix = "", this._loadingNodes = /* @__PURE__ */ new Set(), this._loadingPages = /* @__PURE__ */ new Set(), this._failedNodes = /* @__PURE__ */ new Set(), this._failedPages = /* @__PURE__ */ new Set(), this._indexMissing = 1, this._maxUnloadedPrio = Number.NEGATIVE_INFINITY, this._maxProcessingPrio = Number.POSITIVE_INFINITY, this._version = S4(0), this._visibilityCacheVersion = S4(0), this._maxLevel = 1, this._featureEstimate = { estimate: 0, leavesReached: false }, this._unloadedMemoryEstimate = 0, this._missingPagesAndNodes = new l({ deallocator: null }), this._prefetchNodes = new l({ deallocator: null }), this._updates = new y4(this._missingPagesAndNodes), this._imModificationUncategorized = new l({ deallocator: null }), this.ignoreServiceObb = false, this.progressiveLoadPenalty = 0, this._pageQueue = new Array(), this._newPages = new Array(), this.needNodeElevationRange = false, this.layerHasModifications = false, this._layerHasFilter = false, this._frameNumber = 0, this._traverseDescendantsQueue = [0], this._traverseDescendantsNestingLevel = 0, this._isEditable = r3() && null != ((_a = i4.associatedLayer) == null ? void 0 : _a.infoFor3D), ((_b = i4.serviceUpdateTimeStamp) == null ? void 0 : _b.lastUpdate) && (this._lastUpdate = `${i4.serviceUpdateTimeStamp.lastUpdate}`), this._maxLodLevel = this._viewportQueries ? this._viewportQueries.maxLodLevel : 1, this._init(n10);
  }
  _init(e12) {
    if ("page" === e12.type) {
      const t5 = e12.rootPage;
      switch (this._urlPrefix = e12.urlPrefix, this._pageSize = e12.pageSize, e12.lodMetric) {
        case "maxScreenThreshold":
          this._lodMetric = d2.MaxScreenThreshold;
          break;
        case "maxScreenThresholdSQ":
          this._lodMetric = d2.MaxScreenThreshold, this._lodConversion = k3;
      }
      if (this._isEditable) {
        this._rootIndex = -1;
        const i4 = M2(e12.rootIndex, e12.pageSize), n10 = t5.nodes[i4], s12 = { nodes: [{ index: this._rootIndex, children: [e12.rootIndex], mesh: void 0, obb: n10.obb, lodThreshold: n10.lodThreshold }] };
        this._addPage(E(this._rootIndex, this._pageSize), s12), this.getNode(-1).serviceObbInIndexSR = void 0;
      } else
        this._rootIndex = e12.rootIndex;
      this._addPage(E(e12.rootIndex, this._pageSize), t5), this._updateParentsAndLevel();
    } else if ("node" === e12.type) {
      this._urlPrefix = e12.urlPrefix;
      const t5 = new b4();
      if (this._nodePages.set(0, t5), this._isEditable) {
        this._clientNodePage = new b4();
        const t6 = { id: "-1", version: null, mbs: e12.rootNode.mbs, obb: e12.rootNode.obb, sharedResource: null, geometryData: null, attributeData: null, featureData: null, children: [{ id: "root", href: "../root", mbs: e12.rootNode.mbs, obb: e12.rootNode.obb }] };
        this._rootIndex = this._makeClientRefNode(new s7(t6.id, null), -1);
        const i5 = this._validateNode(t6.id, t6);
        i5 && this._addNode(i5, this._rootIndex);
      } else
        this._rootIndex = this._makeRefNode(new s7(e12.rootNode.id, null), -1);
      const i4 = this._validateNode(e12.rootNode.id, e12.rootNode);
      i4 && this._addNode(i4, 0);
    }
  }
  addClientNodeToIndex(e12, t5) {
    const i4 = -1, n10 = new s7(e12, t5), s12 = this._makeClientRefNode(n10, i4);
    return this._linkChildToParentNode(i4, s12), this.requestUpdate(), s12;
  }
  removeClientNodeFromIndex(e12, t5, i4) {
    this._destroyClientRefNode(e12, t5, i4), this.requestUpdate();
  }
  _loadPage(e12) {
    this._loadingPages.add(e12);
    const i4 = this._urlPrefix + e12;
    this._streamDataController.request(i4, "json").then((t5) => {
      this._pageQueue.push({ pageIndex: e12, page: t5 });
    }).catch((i5) => {
      this._loadingPages.delete(e12), b(i5) || (this._failedPages.add(e12), this._logger.error("#loadPage()", this._layer, `Error when loading page ${e12}`, i5));
    });
  }
  _addQueuedPages(e12) {
    for (; this._pageQueue.length > 0 && !e12.done; ) {
      const { pageIndex: t5, page: i4 } = this._pageQueue.shift();
      this._addPage(t5, i4), this._loadingPages.delete(t5), e12.madeProgress(), this.needNodeElevationRange && this._newPages.push(t5);
    }
    this._updateParentsAndLevel();
  }
  _invalidateElevationRangeForNewPages(e12) {
    if (this.needNodeElevationRange)
      for (; this._newPages.length > 0 && !e12.done; ) {
        const e13 = this._nodePages.get(this._newPages.shift());
        e13 == null ? void 0 : e13.nodes.forEach((e14) => {
          let t5 = e14.parent;
          for (; null != t5 && t5 !== this._rootIndex; ) {
            const e15 = this.getNode(t5);
            e15 && !Number.isNaN(e15 == null ? void 0 : e15.elevationRangeMin) && (e15.invalidateElevationRange(), this.invalidateBoundingVolumeCache(t5)), t5 = this.getParentIndex(t5);
          }
        });
      }
  }
  _addPage(e12, t5) {
    const i4 = [], s12 = [], o6 = t5.nodes.map((t6, o7) => {
      var _a, _b, _c;
      const r11 = i4.length, a12 = t6.children ? t6.children.length : 0;
      s12.push(this._rootIndex);
      for (let e13 = 0; e13 < a12; e13++)
        i4.push(t6.children[e13]);
      const d8 = `${t6.index}`, l5 = I2.fromJSON(t6.obb), u10 = T(l5.center, l5.radius), c7 = (_a = t6.mesh) == null ? void 0 : _a.attribute, g6 = (_b = t6.mesh) == null ? void 0 : _b.geometry, _6 = (_c = t6.mesh) == null ? void 0 : _c.material, f4 = { hasSharedResource: false, isEmpty: null == g6, attributes: null != (c7 == null ? void 0 : c7.resource) ? `${c7.resource}` : void 0, geometry: null != (g6 == null ? void 0 : g6.resource) ? `${g6.resource}` : void 0, texture: null != (_6 == null ? void 0 : _6.resource) ? `${_6.resource}` : void 0, geometryDefinition: g6 ? g6.definition : -1, materialDefinition: _6 ? _6.definition : -1 }, m5 = new h3(d8, O4(o7, e12, this._pageSize), u10, a12, 0, f4, this._lastUpdate, this._lodMetric, this._lodConversion(t6.lodThreshold), g6 ? g6.featureCount : null);
      return m5.serviceObbInIndexSR = l5, m5.visibilityObbInRenderSR = this._computeVisibilityObb(m5), m5.vertexCount = g6 ? g6.vertexCount : 0, new p4(r11, a12, x3(this._visibilityCacheVersion), null, m5);
    }), r10 = new b4(o6, i4);
    -1 === e12 ? this._clientNodePage = r10 : this._nodePages.set(e12, r10);
  }
  _updateParentsAndLevel() {
    const e12 = new Array(), t5 = (t6, i4, n10) => {
      const s12 = this._getPage(t6);
      if (null != s12) {
        const o6 = M2(t6, this._pageSize), r10 = s12.nodes[o6];
        r10.parent = null != i4 ? i4 : -1;
        const a12 = r10.node;
        null != a12 && (a12.level = n10, e12.push(t6));
      }
    };
    for (t5(this._rootIndex, null, 0); e12.length; ) {
      const i4 = e12.pop(), n10 = this.getNode(i4);
      if (null != n10)
        for (let e13 = 0; e13 < n10.childCount; e13++) {
          t5(this.getChildIndex(n10.index, e13), i4, n10.level + 1), this._maxLevel = Math.max(this._maxLevel, n10.level + 1);
        }
    }
  }
  _getPage(e12) {
    const t5 = E(e12, this._pageSize);
    return this._getPageFromPageIndex(t5);
  }
  _getPageFromPageIndex(e12) {
    return e12 < 0 ? this._clientNodePage : this._nodePages.get(e12);
  }
  _getNodeInternal(e12) {
    const t5 = this._getPage(e12);
    return null == t5 ? null : (t5.lastTraversed = this._frameNumber, t5.nodes[M2(e12, this._pageSize)]);
  }
  _addNode(e12, t5) {
    e12.children && this.populateChildren(t5, e12.children);
    const i4 = this.getParent(t5), n10 = null != i4 ? i4.level + 1 : 0;
    this._maxLevel = Math.max(this._maxLevel, e12.children ? n10 + 1 : n10);
    const { lodMetric: s12, maxError: o6 } = A2(e12.lodSelection), r10 = this._getNodeInternal(t5), a12 = new h3(e12.id, t5, e12.mbs, r10.childCount, n10, e12.resources, e12.version, s12, o6, e12.numFeatures);
    r10.node = a12, e12.obb && (a12.serviceObbInIndexSR = I2.fromJSON(e12.obb)), a12.visibilityObbInRenderSR = this._computeVisibilityObb(a12);
    const d8 = r10.ref;
    return null != d8 && (null == d8.serviceMbsInIndexSR && (d8.serviceMbsInIndexSR = e12.mbs), a12.shareServiceBVsInRenderSRWith(d8), d8.visibilityObbInRenderSR = a12.visibilityObbInRenderSR), a12;
  }
  _makeRefNode(e12, t5) {
    const i4 = this._nodePages.get(0);
    if (t5 < -1)
      return this._makeClientRefNode(e12, t5);
    if (null == i4)
      return -1;
    const n10 = i4.nodes.length, s12 = new p4(0, 0, x3(this._visibilityCacheVersion), e12, null);
    return i4.nodes.push(s12), s12.parent = t5, e12.invalidateServiceBVsInRenderSR(), n10;
  }
  _makeClientRefNode(e12, t5) {
    const i4 = this._clientNodePage;
    if (null == i4)
      return -1;
    if (t5 >= 0)
      throw new Error("I3SIndex::client side nodes can not be made children of service side nodes.");
    const n10 = -(i4.nodes.length + 1), s12 = new p4(0, 0, x3(this._visibilityCacheVersion), e12, null);
    return i4.nodes.push(s12), s12.parent = t5, e12.invalidateServiceBVsInRenderSR(), n10;
  }
  _linkChildToParentNode(e12, t5) {
    const i4 = this._clientNodePage;
    if (null == i4 || e12 >= 0)
      return;
    const n10 = M2(e12, this._pageSize), s12 = M2(t5, this._pageSize), o6 = i4.nodes[n10], r10 = o6.childOffset;
    i4.children.splice(o6.childOffset + o6.childCount, 0, t5);
    const a12 = 1;
    o6.childCount += a12, null != o6.node && (o6.node.childCount += a12);
    for (const d8 of i4.nodes)
      d8.childOffset > r10 && (d8.childOffset += a12);
    i4.nodes[s12].parent = e12, this._updateParentBoundingInformation(e12);
  }
  _destroyClientRefNode(e12, t5, i4) {
    var _a, _b;
    const n10 = this._clientNodePage;
    if (null == n10)
      return;
    const s12 = this.getParentIndex(e12);
    if (null == s12)
      return;
    const o6 = /* @__PURE__ */ new Set(), r10 = /* @__PURE__ */ new Map(), a12 = (e13) => {
      var _a2, _b2;
      const i5 = M2(e13, this._pageSize), s13 = n10.nodes[i5];
      if (s13.childCount > 0)
        for (let t6 = s13.childOffset; t6 < s13.childOffset + s13.childCount; ++t6)
          a12(n10.children[t6]);
      const r11 = ((_a2 = s13.node) == null ? void 0 : _a2.id) ?? ((_b2 = s13.ref) == null ? void 0 : _b2.id);
      if (null == r11)
        throw new Error("Node has no id");
      t5(r11, e13), o6.add(s13);
    };
    a12(e12);
    const d8 = n10.nodes, l5 = n10.children, h8 = n10.nodes.map(() => -1), u10 = [], c7 = [];
    for (let g6 = 0; g6 < d8.length; ++g6) {
      const e13 = d8[g6];
      if (o6.has(e13))
        continue;
      const t6 = u10.length, n11 = O4(g6, -1, this._pageSize), s13 = O4(t6, -1, this._pageSize);
      if (e13.node && (e13.node.index = s13), h8[g6] = s13, u10.push(e13), n11 !== s13) {
        const t7 = ((_a = e13.node) == null ? void 0 : _a.id) ?? ((_b = e13.ref) == null ? void 0 : _b.id);
        if (null == t7)
          throw new Error("Node has no id");
        i4(t7, n11, s13), r10.set(n11, s13);
      }
    }
    for (let g6 = 0; g6 < u10.length; ++g6) {
      const e13 = O4(g6, -1, this._pageSize), t6 = u10[g6], i5 = c7.length;
      for (let n11 = t6.childOffset; n11 < t6.childOffset + t6.childCount; ++n11) {
        const t7 = l5[n11];
        if (t7 >= 0)
          c7.push(t7);
        else {
          const i6 = M2(t7, this._pageSize), n12 = d8[i6];
          if (o6.has(n12))
            continue;
          const s13 = h8[i6];
          c7.push(s13), n12.parent = e13;
        }
      }
      t6.childOffset = i5, t6.childCount = c7.length - i5, t6.node && (t6.node.childCount = t6.childCount);
    }
    n10.nodes = u10, n10.children = c7, this._updateParentBoundingInformation(h8[M2(s12, this._pageSize)]);
  }
  _updateParentBoundingInformation(e12) {
    let t5 = e12;
    do {
      let e13 = null;
      const n10 = this._clientNodeLoader.indexSR, a12 = this._clientNodeLoader.renderSR, d8 = this._getNodeInternal(t5);
      if (null == d8)
        return;
      for (let r10 = 0; r10 < d8.childCount; r10++) {
        const d9 = this.getChildIndex(t5, r10), l6 = this._getNodeInternal(d9), h8 = null != l6 ? l6.ref || l6.node : null;
        if (null != h8 && h8.serviceMbsInIndexSR[3] > 0)
          if (null == e13)
            e13 = O2(h8.serviceMbsInIndexSR, D2);
          else {
            const t6 = F3, s12 = z3, r11 = T2;
            a8(h8.serviceMbsInIndexSR, n10, t6, a12), a8(e13, n10, s12, a12), it(t6, s12, r11), a8(r11, a12, e13, n10);
          }
      }
      const l5 = d8.ref || d8.node;
      null != l5 && (null != e13 ? (l5.serviceMbsInIndexSR ?? (l5.serviceMbsInIndexSR = w2()), O2(e13, l5.serviceMbsInIndexSR)) : ge(l5.serviceMbsInIndexSR), l5.invalidateServiceBVsInRenderSR(), l5.geometryObbInRenderSR = null), this.invalidateNodeVisibilityCacheInternal(d8), t5 = this.getParentIndex(t5);
    } while (null != t5);
  }
  populateChildren(e12, t5) {
    const i4 = this._getNodeInternal(e12), n10 = this._getPage(e12);
    i4.childOffset = n10.children.length, i4.childCount = t5.length;
    for (let s12 = 0; s12 < t5.length; s12++) {
      const i5 = this._makeRefNode(t5[s12], e12);
      n10.children.push(i5);
    }
  }
  getNode(e12) {
    const t5 = this._getNodeInternal(e12);
    return null != t5 ? t5.node : null;
  }
  getIndexById(e12) {
    let t5;
    return this._forAllNodes((i4, n10) => {
      (null != i4.node && i4.node.id === e12 || null != i4.ref && i4.ref.id === e12) && (t5 = n10);
    }), t5;
  }
  getNodeById(e12) {
    const t5 = this.getIndexById(e12);
    return null != t5 && t5 >= 0 ? this.getNode(t5) : null;
  }
  getChildIndex(e12, t5) {
    const i4 = this._getPage(e12);
    if (null == i4)
      return -1;
    const n10 = i4.nodes[M2(e12, this._pageSize)];
    return i4.children[n10.childOffset + t5];
  }
  getParentIndex(e12) {
    const t5 = this._getPage(e12);
    return null != t5 && e12 !== this._rootIndex ? t5.nodes[M2(e12, this._pageSize)].parent : null;
  }
  getParent(e12) {
    const t5 = this.getParentIndex(e12);
    return null != t5 ? this.getNode(t5) : null;
  }
  isLeaf(e12) {
    const t5 = this._getNodeInternal(e12);
    return null != t5 && 0 === t5.childCount;
  }
  get rootNode() {
    return this.getNode(this._rootIndex);
  }
  get isEditable() {
    return this._isEditable;
  }
  removeAllGeometryObbs() {
    this._forAllNodes((e12) => {
      null != e12.node && (e12.node.geometryObbInRenderSR = null);
    });
  }
  invalidateVisibilityCache() {
    this._visibilityCacheVersion = S4(this._visibilityCacheVersion);
  }
  invalidateNodeVisibilityCache(e12) {
    const t5 = this._getNodeInternal(e12);
    null != t5 && this.invalidateNodeVisibilityCacheInternal(t5);
  }
  invalidateNodeVisibilityCacheInternal(e12) {
    e12.visibilityCache = x3(this._visibilityCacheVersion);
  }
  invalidateBoundingVolumeCache(e12) {
    const t5 = this._getNodeInternal(e12);
    null != t5 && (t5 == null ? void 0 : t5.invalidateBounds(), this.invalidateNodeVisibilityCacheInternal(t5));
  }
  updateElevationChanged(e12) {
    const t5 = this._getNodeInternal(e12);
    if (null == t5)
      return;
    if (!this.needNodeElevationRange)
      return void this.invalidateBoundingVolumeCache(e12);
    const i4 = null != t5.node ? t5.node : t5.ref;
    null != i4 && i4.invalidateElevationRange();
  }
  invalidateGeometryVisibility(e12) {
    const t5 = this._getNodeInternal(e12), i4 = t5 == null ? void 0 : t5.node;
    i4 && (i4.geometryObbInRenderSR = null, i4.invalidateServiceBVsInRenderSR());
  }
  invalidateVisibilityObbs() {
    null != this.rootNode && this.traverse(this.rootNode, (e12) => (e12.visibilityObbInRenderSR = this._computeVisibilityObb(e12), e12.geometryObbInRenderSR = null, true));
  }
  _isElevationRangeUpToDate(e12) {
    if (!this.needNodeElevationRange)
      return true;
    const t5 = (e12 == null ? void 0 : e12.node) ?? (e12 == null ? void 0 : e12.ref);
    return !t5 || t5.elevationRangeValid;
  }
  updateElevationRange(e12) {
    this._updateElevationRangeInternal(e12, null);
  }
  _updateElevationRangeInternal(e12, t5) {
    var _a, _b, _c;
    const i4 = this._getNodeInternal(e12);
    if (!i4)
      return false;
    const n10 = (i4 == null ? void 0 : i4.node) ?? (i4 == null ? void 0 : i4.ref);
    if (!n10)
      return false;
    if (n10.elevationRangeValid)
      return t5 == null ? void 0 : t5.expandElevationRange(n10), true;
    const s12 = new e10();
    let o6 = false;
    for (let d8 = 0; d8 < i4.childCount; d8++) {
      const t6 = this.getChildIndex(e12, d8), i5 = this._updateElevationRangeInternal(t6, s12);
      o6 = o6 || !i5;
    }
    if (0 === i4.childCount || o6) {
      const e13 = !((_a = i4.node) == null ? void 0 : _a.resources.isEmpty);
      this._viewportQueries.expandElevationRange(n10, e13, s12);
    }
    const r10 = n10.elevationRangeMin, a12 = n10.elevationRangeMax;
    return r10 === s12.elevationRangeMin && a12 === s12.elevationRangeMax ? (t5 == null ? void 0 : t5.expandElevationRange(n10), true) : ((_b = i4.node) == null ? void 0 : _b.setElevationRange(s12), (_c = i4.ref) == null ? void 0 : _c.setElevationRange(s12), this.invalidateBoundingVolumeCache(e12), t5 == null ? void 0 : t5.expandElevationRange(n10), true);
  }
  isNodeVisible(e12) {
    const t5 = this._getNodeInternal(e12);
    if (null == t5)
      return true;
    const i4 = t5.ref;
    if (null != i4 && !i4.serviceMbsInIndexSR)
      return true;
    if (this._isElevationRangeUpToDate(t5) && C3(t5.visibilityCache, this._visibilityCacheVersion))
      return w4(t5.visibilityCache);
    const n10 = t5.node, s12 = this._viewportQueries;
    if (n10) {
      const e13 = s12.ensureElevationAgnosticBoundingVolume(n10), i5 = s12.isElevationAgnosticBoundingVolumeVisible(e13);
      let o7 = i5;
      if (this.needNodeElevationRange && i5) {
        const t6 = s12.getNodeObbInRenderSRIndependentOfElevationOffset(n10);
        null != t6 && (o7 = s12.isObbVisibleIndependentOfElevation(e13, t6));
      }
      if (!o7)
        return t5.visibilityCache = R(false, this._visibilityCacheVersion), false;
    }
    if (this._layerHasFilter && this._computeNodeFiltering && (null != n10 || null != i4) && t5.filterImpact === o2.NotChecked) {
      const e13 = null != n10 ? n10.serviceMbsInIndexSR : null != i4 ? i4.serviceMbsInIndexSR : null;
      t5.filterImpact = null != e13 ? this._computeNodeFiltering(e13) : o2.Unmodified;
    }
    const o6 = null != n10 && t5.filterImpact === o2.Culled;
    let r10 = !(null != n10 && n10.imModificationImpact === r6.Culled) && !o6;
    if (r10) {
      const t6 = !n10 || i4 && !n10.visibilityObbInRenderSR ? i4 ?? null : n10;
      if (null != t6) {
        this.needNodeElevationRange && this.updateElevationRange(e12);
        r10 = s12.isNodeVisible(t6);
      }
    }
    return t5.visibilityCache = R(r10, this._visibilityCacheVersion), r10;
  }
  isGeometryVisible(e12) {
    var _a;
    if (!this.isNodeVisible(e12))
      return false;
    const t5 = this._getNodeInternal(e12);
    return !!(null == ((_a = t5 == null ? void 0 : t5.node) == null ? void 0 : _a.geometryObbInRenderSR) || this.layerHasModifications && t5.node.imModificationImpact === r6.NotChecked) || this._viewportQueries.isGeometryVisible(t5.node);
  }
  _traverseCoverage(e12, t5, i4, n10, s12) {
    const o6 = this._getPage(e12);
    if (null == o6 || 0 === t5.childCount)
      return;
    const r10 = t5.childOffset + t5.childCount, a12 = new Array();
    for (let d8 = t5.childOffset; d8 < r10; ++d8) {
      const e13 = o6.children[d8], t6 = this._getNodeInternal(e13);
      null != (t6 == null ? void 0 : t6.node) && this.isGeometryVisible(e13) && a12.push(t6);
    }
    n10 /= a12.length;
    for (const d8 of a12) {
      const e13 = d8.node.index;
      this._isLoaded(e13) || this._isReloading(e13) ? (s12.delta = Math.max(s12.delta, i4), s12.coverage += n10) : this._traverseCoverage(e13, d8, i4 + 1, n10, s12);
    }
  }
  useNodeAsHole(e12) {
    if ("off" === this.holeFilling)
      return false;
    const t5 = this._getNodeInternal(e12);
    if (null == t5)
      return false;
    if ("always" === this.holeFilling)
      return true;
    if (C3(t5.useAsHole, this._version))
      return w4(t5.useAsHole);
    const i4 = { delta: 0, coverage: 0 };
    this._traverseCoverage(e12, t5, 0, 1, i4);
    const n10 = i4.delta * i4.coverage <= 0.5;
    return t5.useAsHole = R(n10, this._version), n10;
  }
  get maxLevel() {
    return this._maxLevel;
  }
  get dirty() {
    return this._dirty;
  }
  destroy() {
    this._updates.add.prune(), this._updates.update.prune();
  }
  requestUpdate() {
    this._dirty = true, this._indexMissing = 1, this._version = S4(this._version);
  }
  imModificationsChanged(e12) {
    this.layerHasModifications = e12, this._forAllNodes(({ node: e13 }) => {
      null != e13 && (e13.imModificationImpact = r6.NotChecked, e13.visibilityObbInRenderSR = this._computeVisibilityObb(e13), e13.hasModifications && this.invalidateGeometryVisibility(e13.index));
    }), this.invalidateVisibilityCache();
  }
  layerFilterChanged(e12) {
    this._layerHasFilter = e12, this._forAllNodes((e13) => {
      if (null != e13) {
        e13.filterImpact = o2.NotChecked;
        const t5 = e13.node;
        null != t5 && this.invalidateNodeVisibilityCache(t5.index);
      }
    }), this.invalidateVisibilityCache();
  }
  update(e12, t5, i4) {
    if (!this._dirty)
      return;
    this._pageQueue.length > 0 && this._addQueuedPages(t5), this._invalidateElevationRangeForNewPages(t5), this._maxUnloadedPrio = Number.NEGATIVE_INFINITY, this._maxProcessingPrio = Number.NEGATIVE_INFINITY, this._missingPagesAndNodes.clear(), this._prefetchNodes.clear(), this._updates.reset(e12), P3.clear();
    let n10 = true;
    const s12 = new L4(), o6 = new L4(), r10 = this._imModificationUncategorized;
    r10.clear();
    const a12 = /* @__PURE__ */ new Set();
    let d8 = 0;
    const l5 = (a13, l6, h9) => {
      const u10 = E(a13, this._pageSize);
      if (null == l6) {
        let e13 = this._entryPriority(a13);
        return e13 === 1 / 0 && (e13 = this._entryPriority(h9)), P3.set(u10, Math.max(e13, P3.get(u10) || 0)), this._loadingPages.has(u10) || this._failedPages.has(u10) || (this._missingPagesAndNodes.push(u10), ++d8), void (this._maxProcessingPrio = Math.max(this._maxProcessingPrio, e13));
      }
      const g6 = l6.node;
      if (this._updateNodeFeatureEstimate(g6, o6), null == g6) {
        const e13 = this._entryPriority(a13);
        return this._loadingNodes.has(a13) || this._failedNodes.has(a13) || (this._missingPagesAndNodes.push(a13), P3.set(a13, e13)), void (this._maxProcessingPrio = Math.max(this._maxProcessingPrio, e13));
      }
      const _6 = this._getPage(a13);
      if (0 === this._missingPagesAndNodes.length && !this._useNodePages)
        for (let e13 = 0; e13 < l6.childCount; e13++) {
          const t6 = _6.children[l6.childOffset + e13], i5 = this._getNodeInternal(t6);
          null == i5 || i5.node || this._loadingNodes.has(t6) || this._failedNodes.has(t6) || (P3.set(t6, this._entryPriority(t6)), this._prefetchNodes.push(t6));
        }
      if (g6.failed || g6.resources.isEmpty)
        return void (n10 && l6.childCount > 0 && this._isSelected(g6) && (n10 = false));
      if (this._isLoaded(a13)) {
        if (s12.known += g6.memory, ++s12.knownNodes, this._isSelected(g6) ? l6.childCount > 0 && (n10 = false) : (s12.unremoved += g6.memory, n10 = false), this._needsUpdate(g6)) {
          const e13 = this._entryPriority(a13);
          P3.set(a13, e13), this._maxProcessingPrio = Math.max(this._maxProcessingPrio, e13), this._updates.update.push(a13);
        }
        return;
      }
      if (g6.memory && (s12.known += g6.memory, ++s12.knownNodes), !this._isSelected(g6))
        return void (this._isReloading(a13) && this._updates.remove.push(a13));
      if (l6.childCount > 0 && (n10 = false), g6.memory ? (s12.missing += g6.memory, s12.known += g6.memory, ++s12.knownNodes) : ++s12.missingNodes, e12.includes(g6.index))
        return this._maxProcessingPrio = Math.max(this._maxProcessingPrio, this._entryPriority(a13)), void (this._updates.cancel = this._updates.cancel.filter((e13) => e13 !== g6.index));
      if (!t5.done && this._enable(g6))
        return void t5.madeProgress();
      const f4 = this._entryPriority(a13);
      P3.set(a13, f4), this._maxProcessingPrio = Math.max(this._maxProcessingPrio, f4), this._updates.add.push(a13), this.layerHasModifications && i4 && null != g6 && g6.imModificationImpact === r6.NotChecked && r10.push(a13);
    };
    this.traverseVisible(l5, a12), this._frameNumber++, this._missingPagesAndNodes.sort((e13, t6) => e13 - t6), this._missingPagesAndNodes.filterInPlace((e13, t6) => t6 < 1 || this._missingPagesAndNodes.data[t6 - 1] !== e13), this._missingPagesAndNodes.sort((e13, t6) => P3.get(e13) - P3.get(t6)), this._missingPagesAndNodes.length > 0 && (this._maxUnloadedPrio = P3.get(this._missingPagesAndNodes.back()), this._prefetchNodes.clear()), this._removeUnusedNodePages(a12, d8);
    const h8 = this._updates.add;
    h8.length > 0 && this.layerHasModifications && (r10.length > 0 && (i4 == null ? void 0 : i4(r10)), h8.filterInPlace((e13) => {
      const t6 = this._getNodeInternal(e13), i5 = null == (t6 == null ? void 0 : t6.node) || t6.node.imModificationImpact !== r6.Culled;
      return i5 || this.invalidateNodeVisibilityCache(e13), i5;
    })), this._unloadedMemoryEstimate = s12.missing - s12.unremoved, s12.knownNodes > 3 && s12.missingNodes > 0 && (this._unloadedMemoryEstimate += s12.known / s12.knownNodes * s12.missingNodes), this._unloadedMemoryEstimate = 0.8 * Math.max(0, this._unloadedMemoryEstimate), this._featureEstimate.estimate = this._computeFeatureEstimate(o6), this._featureEstimate.leavesReached = n10, this._updates.add.filterInPlace((e13) => P3.get(e13) >= this._maxUnloadedPrio).sort((e13, t6) => P3.get(e13) - P3.get(t6)), this._updates.update.sort((e13, t6) => P3.get(e13) - P3.get(t6)), this._indexMissing = this._loadingPages.size + this._loadingNodes.size + this._missingPagesAndNodes.length, this._dirty = this._indexMissing > 0, P3.clear();
  }
  checkFeatureTarget(e12, t5) {
    const i4 = this._viewportQueries.updateScreenSpaceErrorBias(t5);
    let n10 = t5, s12 = t5, o6 = i4, r10 = 10;
    for (; r10--; ) {
      const i5 = new L4();
      this._updateFeatureEstimate(n10, i5);
      if (this._computeFeatureEstimate(i5) <= e12) {
        if (n10 >= t5 || i5.missingNodes > 0 || 0 === r10)
          break;
        o6 = n10, n10 = 0.5 * (n10 + s12);
      } else
        s12 = n10, n10 = 0.5 * (n10 + o6);
    }
    return this._version = S4(this._version), this._viewportQueries.updateScreenSpaceErrorBias(i4), Math.min(t5, n10);
  }
  _removeUnusedNodePages(e12, t5) {
    if (!this._useNodePages)
      return;
    const i4 = e12.size, n10 = this._nodePages, s12 = n10.size + this._loadingPages.size + t5;
    if (s12 > B && s12 > i4) {
      const t6 = new Array();
      for (const [i5, s13] of n10)
        0 !== s13.numNodesWithLoadedChildren || e12.has(i5) || t6.push([s13.lastTraversed, i5]);
      t6.sort((e13, t7) => e13[0] - t7[0]).some((e13) => {
        const t7 = e13[1];
        return this._deleteNodePage(t7), n10.size <= B;
      });
    }
  }
  _updateFeatureEstimate(e12, t5) {
    this._version = S4(this._version), this._viewportQueries.updateScreenSpaceErrorBias(e12), this.traverseVisible((e13, i4) => this._updateNodeFeatureEstimate(null != i4 ? i4.node : void 0, t5));
  }
  _updateNodeFeatureEstimate(e12, t5) {
    null == e12 || e12.failed || null == e12.numFeatures || this._isSelected(e12) && (null != e12.numFeatures ? (t5.missing += e12.numFeatures, t5.known += e12.numFeatures, ++t5.knownNodes) : ++t5.missingNodes);
  }
  _computeFeatureEstimate(e12) {
    let t5 = e12.known - e12.unremoved;
    return e12.knownNodes > 3 && e12.missingNodes > 0 && (t5 += e12.known / e12.knownNodes * e12.missingNodes), Math.max(0, t5);
  }
  load() {
    return this._load(this._missingPagesAndNodes);
  }
  prefetch() {
    return this._prefetchNodes.sort((e12, t5) => P3.get(e12) - P3.get(t5)), this._load(this._prefetchNodes);
  }
  _load(e12) {
    if (0 === e12.length || !this._canRequest())
      return false;
    for (; e12.length > 0 && this._canRequest(); ) {
      const t5 = e12.pop();
      this._useNodePages && t5 >= 0 ? this._loadPage(t5) : this._loadNode(t5);
    }
    return true;
  }
  get isLoading() {
    return this._indexMissing > 0;
  }
  get isPrefetching() {
    return this._prefetchNodes.length > 0;
  }
  get indexLoading() {
    return this._loadingPages.size + this._loadingNodes.size;
  }
  get indexMissing() {
    return this._indexMissing;
  }
  get unloadedMemoryEstimate() {
    return this._unloadedMemoryEstimate;
  }
  get updates() {
    return this._updates;
  }
  get featureEstimate() {
    return this._featureEstimate;
  }
  get maxPriority() {
    return Math.max(this._maxProcessingPrio, this._maxUnloadedPrio);
  }
  nodeTraversalState(e12) {
    if (null == e12)
      return null;
    const t5 = e12.index, i4 = this._getNodeInternal(t5);
    if (!i4)
      return null;
    let n10 = i4 == null ? void 0 : i4.traversalState;
    if (n10 && C3(n10.version, this._version))
      return n10;
    const s12 = this._viewportQueries.getLodLevel(e12), o6 = this._viewportQueries.hasLOD(e12);
    let r10 = true;
    if (o6) {
      const e13 = this.getParentIndex(t5);
      if (null != e13) {
        const t6 = this._getNodeInternal(e13), i5 = t6 == null ? void 0 : t6.traversalState;
        r10 = !!i5 && s12 > i5.lodLevel;
      } else
        r10 = s12 > 0;
    } else
      r10 = 0 === e12.childCount;
    return n10 ? (n10.lodLevel = s12, n10.isChosen = r10, n10.version = R(true, this._version), n10) : (n10 = new l3(o6, r10, s12, R(true, this._version)), i4.traversalState = n10, n10);
  }
  async _loadNode(e12) {
    this._loadingNodes.add(e12);
    const i4 = this._getNodeInternal(e12).ref;
    if (null == i4)
      return void this._failedNodes.add(e12);
    const n10 = i4.id, s12 = this._urlPrefix + n10, o6 = () => {
      this._loadingNodes.delete(e12), 0 === this._missingPagesAndNodes.length && 0 === this._loadingNodes.size && this.requestUpdate();
    };
    let r10 = null;
    try {
      r10 = e12 >= 0 ? await this._streamDataController.request(s12, "json") : await this._clientNodeLoader.loadNodeJSON(n10);
    } catch (l5) {
      return o6(), void (b(l5) || (this._logger.error("#loadNode()", this._layer, "Error loading node: " + s12), this._failedNodes.add(e12)));
    }
    o6();
    const a12 = this._validateNode(n10, r10);
    if (null == a12)
      return;
    a12.obb && this.invalidateNodeVisibilityCache(e12);
    const d8 = this._addNode(a12, e12);
    this.nodeTraversalState(d8);
  }
  _validateNode(e12, t5) {
    var _a;
    if (null == t5 || "object" != typeof t5 || t5.id !== e12)
      return this._logger.error("#validateNode()", this._layer, `Invalid node. Wrong type or wrong id "${e12}"`), null;
    if (!Array.isArray(t5.mbs))
      return this._logger.error("#validateNode()", this._layer, `Invalid bounding volume on node ${e12}.`), null;
    t5.sharedResource && "./shared" !== t5.sharedResource.href && "./shared/" !== t5.sharedResource.href && this._logger.warn("#validateNode()", this._layer, `Invalid shared resource href on node "${e12}"`);
    const i4 = t5.geometryData;
    null == i4 || Array.isArray(i4) && 0 === i4.length || Array.isArray(i4) && 1 === i4.length && "./geometries/0" === i4[0].href || this._logger.warn("#validateNode()", this._layer, `Invalid geometry data on node "${e12}"`);
    const n10 = t5.attributeData, s12 = this._layer.attributeStorageInfo;
    null == n10 || Array.isArray(n10) && !n10.some((e13, t6) => {
      var _a2;
      return e13.href !== `./attributes/${((_a2 = s12 == null ? void 0 : s12[t6]) == null ? void 0 : _a2.key) ?? `f_${t6}`}/0`;
    }) || this._logger.warn("#validateNode()", this._layer, `Invalid attribute data on node "${e12}"`), t5.featureData && t5.featureData.length > 1 && this._logger.warn("#validateNode()", this._layer, `Node ${e12} has ${t5.featureData.length} bundles. Only the first bundle will be loaded.`);
    const o6 = t5.hasOwnProperty("obb") && !this.ignoreServiceObb ? t5.obb : void 0, r10 = t5.featureData && 1 === t5.featureData.length && t5.featureData[0].featureRange ? t5.featureData[0].featureRange[1] - t5.featureData[0].featureRange[0] + 1 : void 0, a12 = (t6) => {
      if (null == t6)
        return null;
      const i5 = (t7) => this._logger.error("#validateNode()", this._layer, `Invalid node reference on node ${e12}: ${t7}`);
      if ("number" == typeof t6.id)
        i5(`id ${t6.id} is a number instead of a string.`);
      else if ("string" != typeof t6.id || !Array.isArray(t6.mbs))
        return i5("Missing or invalid id."), null;
      if (!Array.isArray(t6.mbs))
        return i5(`Invalid bounding volume on reference ${t6.id}.`), null;
      t6.href && t6.href !== "../" + t6.id && this._logger.error("#validateNode()", this._layer, `Invalid node href on node "${e12}"`);
      const n11 = new s7(`${t6.id}`, t6.mbs);
      return n11.serviceObbInIndexSR = !this.ignoreServiceObb && t6.hasOwnProperty("obb") && t6.obb ? I2.fromJSON(t6.obb) : null, n11.visibilityObbInRenderSR = this._computeVisibilityObb(n11), n11;
    }, d8 = Array.isArray(t5.children) ? t5.children.map(a12).filter((e13) => null != e13) : null, h8 = ((_a = t5.featureData) == null ? void 0 : _a.length) ?? false, u10 = true === t5.isEmpty;
    return new s11(e12, t5.mbs, o6, "string" == typeof t5.version ? t5.version : null, { isEmpty: !h8 && u10, hasSharedResource: null != t5.sharedResource, attributes: t5.attributeData ? e12 : void 0, texture: t5.textureData && t5.textureData.length > 0 ? e12 : void 0, geometry: null != t5.geometryData ? e12 : void 0 }, d8, Array.isArray(t5.lodSelection) ? t5.lodSelection : null, r10);
  }
  resetFailedNodes() {
    this._failedNodes.clear(), this._failedPages.clear(), this._forAllNodes((e12) => {
      null != e12.node && (e12.node.failed = false);
    });
  }
  _entryPriority(e12) {
    const t5 = this._getNodeInternal(e12), i4 = this.getParentIndex(e12);
    if (null == t5 || null == i4 && null == t5.node)
      return null == i4 ? 1 / 0 : this._entryPriority(i4);
    let n10 = 0;
    if (t5.node && null != i4) {
      const e13 = this._getNodeInternal(i4).traversalState;
      null != e13 && (n10 = e13.lodLevel);
    }
    let s12 = this.progressiveLoadPenalty;
    for (let r10 = e12; null != r10; r10 = this.getParentIndex(r10))
      if (this._isLoaded(r10)) {
        s12 = 0;
        break;
      }
    const o6 = null != t5.ref ? this._viewportQueries.distToPOI(t5.ref) : null != t5.node ? this._viewportQueries.distToPOI(t5.node) : 0;
    return -o6 - n10 * (o6 + this.progressiveLoadPenalty) + s12;
  }
  traverseVisible(e12, t5) {
    const i4 = this._getNodeInternal(this._rootIndex);
    null != i4 ? this._traverseVisible(this._rootIndex, null, i4, e12, t5) : e12(this._rootIndex, null, null);
  }
  _traverseVisible(e12, t5, i4, n10, s12) {
    const o6 = E(e12, this._pageSize);
    if (s12 && s12.add(o6), i4.node && 0 === i4.childCount)
      return void (this.isGeometryVisible(e12) && n10(e12, i4, t5));
    if (!this.isNodeVisible(e12))
      return;
    if (n10(e12, i4, t5), null == i4.node)
      return;
    const r10 = this.nodeTraversalState(i4.node);
    if ((r10 == null ? void 0 : r10.nodeHasLOD) && r10.lodLevel === this._maxLodLevel)
      return;
    const a12 = this._getPageFromPageIndex(o6);
    for (let d8 = 0; d8 < i4.childCount; d8++) {
      const t6 = a12.children[i4.childOffset + d8], o7 = this._getNodeInternal(t6);
      if (o7)
        this._traverseVisible(t6, e12, o7, n10, s12);
      else {
        if (s12) {
          const e13 = E(t6, this._pageSize);
          s12.add(e13);
        }
        n10(t6, null, e12);
      }
    }
  }
  traverse(e12, t5) {
    t5(e12) && this.traverseDescendants(e12, t5);
  }
  traverseDescendants(e12, t5) {
    ++this._traverseDescendantsNestingLevel;
    const i4 = e12.index, n10 = this._pageSize, s12 = E(i4, n10), o6 = this._getPageFromPageIndex(s12);
    if (null == o6)
      return;
    const r10 = this._frameNumber, a12 = this._nodePages;
    o6.lastTraversed = r10;
    const d8 = M2(i4, n10), l5 = o6.nodes[d8], { childCount: h8 } = l5;
    if (0 === h8)
      return;
    const u10 = 1 === this._traverseDescendantsNestingLevel ? this._traverseDescendantsQueue : [0];
    let c7 = 0;
    const g6 = [];
    {
      const { childOffset: e13, childCount: t6 } = l5, { children: i5 } = o6;
      u10.length = 2 ** Math.ceil(Math.log2(c7 + t6));
      for (let n11 = e13; n11 < e13 + t6; ++n11) {
        const e14 = i5[n11];
        e14 >= 0 ? (u10[c7] = e14, ++c7) : g6.push(e14);
      }
    }
    if (g6.length > 0) {
      const e13 = this._clientNodePage;
      if (e13) {
        const i5 = e13.children;
        let n11 = 0;
        for (; n11 < g6.length; ) {
          const s13 = g6[n11];
          ++n11;
          const o7 = -s13 - 1, r11 = e13.nodes[o7], a13 = r11.node;
          if (!a13)
            continue;
          if (!t5(a13))
            continue;
          const { childCount: d9 } = r11;
          if (0 === d9)
            continue;
          const { childOffset: l6 } = r11, h9 = l6 + d9;
          for (let e14 = l6; e14 < h9; ++e14)
            g6.push(i5[e14]);
        }
      }
    }
    if (c7 > 0) {
      let e13 = 0;
      if (n10 > 0) {
        let i5 = s12 * n10, d9 = o6, l6 = d9.nodes;
        for (; e13 < c7; ) {
          const s13 = u10[e13];
          let o7;
          if (++e13, i5 <= s13 && s13 < i5 + n10)
            o7 = d9;
          else {
            const e14 = s13 / n10 | 0, t6 = a12.get(e14);
            if (void 0 === t6)
              continue;
            o7 = t6, o7.lastTraversed = r10, d9 = o7, l6 = d9.nodes, i5 = n10 * e14;
          }
          const h9 = l6[s13 - i5], g7 = h9.node;
          if (null == g7)
            continue;
          if (false === t5(g7))
            continue;
          const { childCount: _6 } = h9;
          if (0 === _6)
            continue;
          const f4 = c7 + _6;
          for (u10.length < f4 && (u10.length = 2 ** Math.ceil(Math.log2(c7 + _6))); u10.length < c7 + _6; )
            u10.length += u10.length;
          const m5 = o7.children, { childOffset: v2 } = h9, N3 = v2 + _6;
          for (let e14 = v2; e14 < N3; ++e14)
            u10[c7] = m5[e14], ++c7;
        }
      } else {
        const i5 = a12.get(0);
        if (i5)
          for (; e13 < c7; ) {
            const n11 = u10[e13];
            ++e13;
            const s13 = i5.nodes[n11], o7 = s13.node;
            if (!o7)
              continue;
            if (!t5(o7))
              continue;
            const { childCount: r11 } = s13;
            if (0 === r11)
              continue;
            u10.length = Math.max(u10.length, 2 ** Math.ceil(Math.log2(c7 + r11)));
            const a13 = i5.children, { childOffset: d9 } = s13, l6 = d9 + r11;
            for (let e14 = d9; e14 < l6; ++e14)
              u10[c7] = a13[e14], ++c7;
          }
      }
    }
    --this._traverseDescendantsNestingLevel;
  }
  updateChildrenLoaded(e12, t5) {
    let i4 = this.getNode(e12);
    for (; null != i4; ) {
      const e13 = i4.childrenLoaded, n10 = e13 + t5;
      i4.childrenLoaded = n10;
      const s12 = 0 === e13 ? 1 : 0 === n10 ? -1 : 0, o6 = i4.index;
      if (0 !== s12) {
        this._getPage(o6).numNodesWithLoadedChildren += s12;
      }
      i4 = this.getParent(o6);
    }
  }
  checkChildrenLoadedInvariant() {
    if (null == this.rootNode)
      return true;
    const e12 = [], t5 = (i4) => {
      let n10 = this._isLoaded(i4.index) || this._isReloading(i4.index) ? 1 : 0;
      return this.traverseDescendants(i4, (e13) => (n10 += t5(e13), false)), i4.childrenLoaded !== n10 && e12.push(i4.index), n10;
    };
    return t5(this.rootNode), e12.length && this._logger.error("childrenLoaded invariant broken at following nodes: " + e12.join(",")), e12.length > 0;
  }
  updateElevationInfo(e12, t5) {
    this.needNodeElevationRange = t5 && !!e12 && ("relative-to-ground" === e12.mode || "on-the-ground" === e12.mode), this._viewportQueries.updateElevationInfo(e12), this.invalidateAllElevationRanges();
  }
  invalidateAllElevationRanges() {
    this._forAllNodes((e12) => {
      var _a, _b;
      e12 == null ? void 0 : e12.invalidateBounds(), (_a = e12.node) == null ? void 0 : _a.invalidateElevationRange(), (_b = e12.ref) == null ? void 0 : _b.invalidateElevationRange();
    });
  }
  _forAllNodes(e12) {
    if (null != this._clientNodePage) {
      const t5 = this._clientNodePage;
      for (let i4 = 0; i4 < t5.nodes.length; i4++)
        e12(t5.nodes[i4], -(i4 + 1));
    }
    for (const [t5, i4] of this._nodePages) {
      const n10 = t5 * this._pageSize;
      for (let t6 = 0; t6 < i4.nodes.length; t6++)
        e12(i4.nodes[t6], n10 + t6);
    }
  }
  clearCaches() {
    if (this._useNodePages) {
      const e12 = this._nodePages, t5 = /* @__PURE__ */ new Set();
      this.traverseVisible((e13) => t5.add(E(e13, this._pageSize)));
      for (const [i4, n10] of e12)
        if (0 !== n10.numNodesWithLoadedChildren || t5.has(i4))
          for (const e13 of n10.nodes)
            e13.traversalState = null;
        else
          this._deleteNodePage(i4);
    }
  }
  _deleteNodePage(e12) {
    this._nodePages.delete(e12);
  }
  get test() {
    return { addNode: (e12, t5) => this._addNode(this._validateNode(e12.id, e12), t5), getNodeInternal: (e12) => this._getNodeInternal(e12), getPageIndex: (e12) => E(e12, this._pageSize), getIndexWithinPage: (e12) => M2(e12, this._pageSize), getNodePage: (e12) => e12 < 0 ? this._clientNodePage : this._nodePages.get(e12), getChildIndices: (e12) => {
      const t5 = this._getNodeInternal(e12), i4 = this._getPage(e12);
      if (null == t5 || null == i4)
        return [];
      const n10 = [];
      for (let s12 = t5.childOffset; s12 < t5.childOffset + t5.childCount; ++s12)
        n10.push(i4.children[s12]);
      return n10;
    }, rootIndex: this._rootIndex, clientNodePage: this._clientNodePage, nodePages: this._nodePages };
  }
};
var P3 = /* @__PURE__ */ new Map();
var y4 = class {
  constructor(t5) {
    this.missing = t5, this.update = new l({ deallocator: null }), this.add = new l({ deallocator: null }), this.remove = new l({ deallocator: null }), this.cancel = [];
  }
  reset(e12) {
    this.add.clear(), this.update.clear(), this.cancel = e12;
  }
};
function x3(e12) {
  return de(e12, -2);
}
function S4(e12) {
  return de(e12, 2);
}
function R(e12, t5) {
  return t5 + (e12 ? 1 : 0);
}
function C3(e12, t5) {
  return (-2 & e12) === t5;
}
function w4(e12) {
  return !(1 & ~e12);
}
function E(e12, t5) {
  return e12 < 0 ? -1 : t5 > 0 ? e12 / t5 | 0 : 0;
}
function M2(e12, t5) {
  return e12 < 0 ? -e12 - 1 : 0 === t5 ? e12 : e12 % t5;
}
function O4(e12, t5, i4) {
  return -1 === t5 ? -(e12 + 1) : 0 === i4 ? e12 : t5 * i4 + e12;
}
var V3 = [["maxScreenThreshold", d2.MaxScreenThreshold], ["screenSpaceRelative", d2.ScreenSpaceRelative], ["removedFeatureDiameter", d2.RemovedFeatureDiameter], ["distanceRangeFromDefaultCamera", d2.DistanceRangeFromDefaultCamera]];
function A2(e12) {
  if (e12) {
    for (let t5 = 0; t5 < e12.length; t5++)
      for (const i4 of V3)
        if (i4[0] === e12[t5].metricType)
          return { lodMetric: i4[1], maxError: e12[t5].maxError };
  }
  return { lodMetric: d2.None, maxError: 0 };
}
var L4 = class {
  constructor() {
    this.known = 0, this.knownNodes = 0, this.missing = 0, this.missingNodes = 0, this.unremoved = 0;
  }
};
function k3(e12) {
  return Math.sqrt(e12 * (4 / Math.PI));
}
var D2 = w2();
var F3 = w2();
var z3 = w2();
var T2 = w2();
var B = has("esri-mobile") ? 100 : 300;

// node_modules/@arcgis/core/views/3d/layers/support/I3SLayerView.js
var a11;
!function(a12) {
  a12[a12.FadeIn = 0] = "FadeIn", a12[a12.FadeOut = 1] = "FadeOut";
}(a11 || (a11 = {}));

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SLodHandling.js
var o5 = class {
  constructor(e12) {
    this._layerView = e12, this._lodGlobalDirty = false;
  }
  startNodeLoading(e12, i4, s12, o6) {
    this._maxLodLevel = o6.maxLodLevel, this._index = s12, this._isNodeInScaleBounds = e12, this._removeNodes = i4;
  }
  shouldLoadNode(e12) {
    if (null == e12)
      return false;
    const i4 = this._index.nodeTraversalState(e12);
    return !!this._isChosenMaxLOD(i4) || !!i4.isChosen && this._childrenRequireLoading(e12);
  }
  setLodGlobalDirty() {
    this._lodGlobalDirty = true;
  }
  get requiresLODGlobalHandling() {
    return null != this._index && true === this._lodGlobalDirty;
  }
  lodGlobalHandling(e12) {
    if (!this.requiresLODGlobalHandling)
      return false;
    this._lodGlobalDirty = false;
    const i4 = this._layerView.view.resourceController.memoryController.usedMemory, s12 = Math.max(0, Math.floor(10 * (i4 - 1)));
    d6.clear(), this._lodGlobalHandling(this._index.rootNode, s12, false, !!this._layerView.nodeCrossfadingEnabled);
    const o6 = d6.length;
    this._removeNodes(d6, e12);
    const t5 = d6.length < o6;
    return 0 !== d6.length && (this._lodGlobalDirty = true), d6.clear(), t5;
  }
  _lodGlobalHandling(e12, o6, t5, n10) {
    if (null == e12)
      return false;
    const l5 = e12.index, r10 = this._index, a12 = this._layerView, h8 = r10.nodeTraversalState(e12), u10 = this._isChosenMaxLOD(h8), _6 = e12.resources.isEmpty;
    if (u10 && _6)
      return e12.childrenLoaded > 0 && this._removeChildrenRecursive(e12), true;
    const c7 = a12.isNodeLoaded(l5);
    if (n10 && c7 && u10) {
      const i4 = !t5 && this.hasNoVisibleChildren(e12);
      a12.fadeNode(l5, a11.FadeIn, !i4);
    }
    const x5 = c7 && (!a12.isNodeFullyFadedIn || a12.isNodeFullyFadedIn(l5));
    if (c7 && (a12.updateNodeState(l5, u10 ? c.Leaf : c.Hole), u10))
      return x5 && this._removeChildrenRecursive(e12), x5;
    const L5 = e12.childCount > 0;
    let y5 = L5;
    if (L5)
      for (let i4 = 0; i4 < e12.childCount; i4++) {
        const e13 = r10.getChildIndex(l5, i4), s12 = r10.getNode(e13);
        if (null != s12) {
          !(!r10.isGeometryVisible(e13) || this._lodGlobalHandling(s12, o6, t5 || x5, n10)) && this._isNodeInScaleBounds(s12) && (y5 = false);
        } else
          r10.isNodeVisible(e13) && (y5 = false);
      }
    const N3 = c7 && !u10 && (y5 || d6.length < o6);
    N3 && d6.push(l5), !n10 || N3 || !c7 || t5 || y5 || a12.fadeNode(l5, a11.FadeIn, false);
    const m5 = e12.resources.isEmpty;
    return y5 || x5 && !N3 || m5;
  }
  _removeChildrenRecursive(e12) {
    this._index.traverseDescendants(e12, (e13) => ((this._layerView.isNodeLoaded(e13.index) || this._layerView.isNodeReloading(e13.index)) && d6.push(e13.index), e13.childrenLoaded > 0));
  }
  hasNoVisibleChildren(e12) {
    let i4 = true;
    return this._index.traverseDescendants(e12, (e13) => !(!i4 || !this._index.isNodeVisible(e13.index)) && (this._layerView.isNodeLoaded(e13.index) ? (i4 = false, false) : e13.childrenLoaded > 0)), i4;
  }
  _childrenRequireLoading(e12) {
    let i4 = false, s12 = true;
    return this._index.traverseDescendants(e12, (e13) => {
      if (!s12 || !this._index.isNodeVisible(e13.index))
        return false;
      const o6 = this._index.nodeTraversalState(e13);
      return this._isChosenMaxLOD(o6) && this._index.isGeometryVisible(e13.index) && (i4 = true), this._layerView.isNodeLoaded(e13.index) ? (s12 = false, false) : e13.childrenLoaded > 0;
    }), s12 && i4;
  }
  _isChosenMaxLOD(e12) {
    return e12.isChosen && (!e12.nodeHasLOD || e12.lodLevel === this._maxLodLevel);
  }
};
var d6 = new l({ deallocator: null });

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SMaterialUtil.js
function h6(e12, o6, a12) {
  const s12 = /* @__PURE__ */ new Map(), t5 = (e13, o7) => {
    if (null == e13)
      return -1;
    const r10 = s12.get(e13.id);
    if (r10)
      return r10.usage |= o7, r10.id;
    const a13 = s12.size;
    return s12.set(e13.id, { id: a13, usage: o7 }), a13;
  }, l5 = o6.pbrMetallicRoughness, i4 = l5 == null ? void 0 : l5.baseColorFactor, u10 = o6.emissiveFactor, p5 = has("disable-feature:diffuse-rendering-i3s") || a12 ? n9({ normalTexture: o6.normalTexture, emissiveTexture: o6.emissiveTexture, emissiveFactor: o6.emissiveFactor, occlusionTexture: o6.occlusionTexture, metallicRoughnessTexture: l5 == null ? void 0 : l5.metallicRoughnessTexture, metallicFactor: l5 == null ? void 0 : l5.metallicFactor, roughnessFactor: l5 == null ? void 0 : l5.roughnessFactor }) : u7({ normalTexture: o6.normalTexture, emissiveTexture: o6.emissiveTexture, emissiveFactor: o6.emissiveFactor, occlusionTexture: o6.occlusionTexture, metallicRoughnessTexture: l5 == null ? void 0 : l5.metallicRoughnessTexture, metallicFactor: l5 == null ? void 0 : l5.metallicFactor, roughnessFactor: l5 == null ? void 0 : l5.roughnessFactor }), h8 = p5 ? t3[0] : (l5 == null ? void 0 : l5.metallicFactor) ?? r8[0], x5 = p5 ? t3[1] : (l5 == null ? void 0 : l5.roughnessFactor) ?? r8[1], F5 = "mask" === o6.alphaMode ? s10.Color | s10.AlphaMask : s10.Color, b6 = { baseColorFactor: i4 ? [i4[0], i4[1], i4[2], i4[3]] : [1, 1, 1, 1], baseColorTextureId: t5(l5 == null ? void 0 : l5.baseColorTexture, F5), metallicRoughnessTextureId: t5(l5 == null ? void 0 : l5.metallicRoughnessTexture, s10.MetallicRoughness), metallicFactor: h8, roughnessFactor: x5 }, C5 = { alphaMode: o6.alphaMode, alphaCutoff: o6.alphaCutoff, doubleSided: o6.doubleSided, cullFace: "none" === o6.cullFace ? e9.None : "back" === o6.cullFace ? e9.Back : "front" === o6.cullFace ? e9.Front : e9.None, normalTextureId: t5(o6.normalTexture, s10.Normal), emissiveTextureId: t5(o6.emissiveTexture, s10.Emissive), occlusionTextureId: t5(o6.occlusionTexture, s10.Occlusion), emissiveFactor: u10 ? [u10[0], u10[1], u10[2]] : [0, 0, 0], metallicRoughness: b6, wrapTextures: false, hasParametersFromSource: p5 }, P5 = [];
  return s12.forEach(({ usage: o7 }, r10) => {
    const a13 = null != e12 && e12[r10] && e12[r10].formats, s13 = a13 ? T3(a13.map(({ name: e13, format: o8 }) => ({ name: e13, encoding: f3[o8] }))) : [];
    P5.push({ id: r10, usage: o7, encodings: s13 });
  }), { material: C5, textures: P5 };
}
function T3(e12) {
  return e12.sort((e13, o6) => e13.encoding - o6.encoding);
}
var f3 = { ktx2: e11.KTX2, basis: e11.Basis, dds: e11.DDS_S3TC, png: e11.PNG, jpg: e11.JPG, "ktx-etc2": e11.KTX_ETC2 };
var x4 = { [u6.KTX2_ENCODING]: e11.Basis, [u6.BASIS_ENCODING]: e11.Basis, [u6.DDS_ENCODING]: e11.DDS_S3TC, "image/png": e11.PNG, "image/jpg": e11.JPG, "image/jpeg": e11.JPG, "image/ktx": e11.KTX_ETC2 };
function F4(o6) {
  var _a, _b;
  const a12 = (o6 == null ? void 0 : o6.materialDefinitions) ? Object.keys(o6.materialDefinitions)[0] : null, s12 = (o6 == null ? void 0 : o6.textureDefinitions) ? Object.keys(o6.textureDefinitions)[0] : null, t5 = a12 ? (_a = o6.materialDefinitions) == null ? void 0 : _a[a12] : null, l5 = s12 ? (_b = o6.textureDefinitions) == null ? void 0 : _b[s12] : null, i4 = b5();
  if (null != t5) {
    const o7 = t5.params;
    o7.diffuse && (i4.metallicRoughness.baseColorFactor = [o7.diffuse[0], o7.diffuse[1], o7.diffuse[2], 1]), null != o7.doubleSided && (i4.doubleSided = o7.doubleSided, i4.cullFace = o7.doubleSided ? e9.None : e9.Back), "none" !== o7.cullFace && "front" !== o7.cullFace && "back" !== o7.cullFace || (i4.cullFace = "none" === o7.cullFace ? e9.None : "back" === o7.cullFace ? e9.Back : e9.Front), o7.transparency && (i4.metallicRoughness.baseColorFactor[3] = e5(1 - o7.transparency, 0, 1)), (o7.useVertexColorAlpha || i4.metallicRoughness.baseColorFactor[3] < 1) && (i4.alphaMode = "blend");
  }
  const u10 = [];
  if (null != l5) {
    const e12 = 0;
    !l5.wrap || "repeat" !== l5.wrap[0] && "repeat" !== l5.wrap[1] || (i4.wrapTextures = true);
    let o7 = s10.Color;
    "rgba" === l5.channels && (i4.alphaMode = "blend", o7 |= s10.AlphaMask);
    const a13 = l5.images.length - 1, s13 = l5.images[a13], t6 = (e13) => e13 == null ? void 0 : e13.split("/").pop(), n10 = Array.isArray(l5.encoding) ? T3(l5.encoding.map((e13, o8) => ({ name: t6(s13.href[o8]), encoding: x4[e13] || 0 }))) : [{ name: t6(s13.href), encoding: x4[l5.encoding] || 0 }];
    u10.push({ id: e12, usage: o7, encodings: n10 }), i4.metallicRoughness.baseColorTextureId = e12;
  }
  return { material: i4, textures: u10 };
}
var b5 = () => ({ alphaMode: "opaque", alphaCutoff: o3, doubleSided: true, cullFace: e9.None, normalTextureId: -1, emissiveTextureId: -1, occlusionTextureId: -1, emissiveFactor: [0, 0, 0], metallicRoughness: { baseColorFactor: [0.8, 0.8, 0.8, 1], baseColorTextureId: -1, metallicRoughnessTextureId: -1, metallicFactor: 0, roughnessFactor: 0.6 }, wrapTextures: false, hasParametersFromSource: true });
function C4(e12, o6, a12, s12) {
  if (null == (e12 == null ? void 0 : e12.data))
    return null;
  const t5 = e12.data, l5 = s12.renderingContext.parameters.maxMaxAnisotropy, n10 = l5 > 1, i4 = a12 || !o6.wrapTextures ? P4 : S5, c7 = N2(e12.encoding), m5 = e12.usage & s10.Color ? "opaque" === o6.alphaMode ? 3 : 4 : 3;
  return new N(t5, { mipmap: n10, maxAnisotropy: l5, encoding: c7, wrap: i4, components: m5, noUnpackFlip: true });
}
var P4 = { s: D.CLAMP_TO_EDGE, t: D.CLAMP_TO_EDGE };
var S5 = { s: D.REPEAT, t: D.REPEAT };
function M3(o6, l5, n10, u10, c7, m5) {
  const p5 = m5.rendererTextureUsage, h8 = (e12) => w5(u10, n10, e12 & p5), T6 = l5.metallicRoughness.baseColorFactor, f4 = e5(l5.metallicRoughness.baseColorFactor[3], 0, 1);
  o6.baseColor = [T6[0], T6[1], T6[2], f4], o6.hasParametersFromSource = !!l5.hasParametersFromSource, o6.usePBR = m5.usePBR, o6.mrrFactors = [l5.metallicRoughness.metallicFactor, l5.metallicRoughness.roughnessFactor, l5.hasParametersFromSource ? t3[2] : r8[2]], o6.emissiveFactor = l5.emissiveFactor, o6.isIntegratedMesh = m5.isIntegratedMesh, o6.textureAlphaCutoff = "mask" === l5.alphaMode ? l5.alphaCutoff : o3, o6.alphaDiscardMode = "opaque" === l5.alphaMode ? s5.Opaque : "mask" === l5.alphaMode ? s5.Mask : s5.MaskBlend;
  const x5 = [], F5 = h8(s10.Color | s10.AlphaMask);
  null != F5 && (o6.baseColorTexture = new s9(c7, F5), x5.push(o6.baseColorTexture.loadPromise));
  const b6 = h8(s10.MetallicRoughness);
  null != b6 && (o6.metallicRoughnessTexture = new s9(c7, b6), x5.push(o6.metallicRoughnessTexture.loadPromise));
  const C5 = h8(s10.Emissive);
  null != C5 && (o6.emissionTexture = new s9(c7, C5), x5.push(o6.emissionTexture.loadPromise));
  const P5 = h8(s10.Occlusion);
  null != P5 && (o6.occlusionTexture = new s9(c7, P5), x5.push(o6.occlusionTexture.loadPromise));
  const S6 = h8(s10.Normal);
  return null != S6 && (o6.normalTexture = new s9(c7, S6), x5.push(o6.normalTexture.loadPromise)), o6.commonMaterialParameters.hasSlicePlane = m5.slicePlaneEnabled, o6.commonMaterialParameters.doubleSided = l5.doubleSided, o6.commonMaterialParameters.cullFace = l5.cullFace, o6.ellipsoidMode = a9(m5.viewSpatialReference), Promise.all(x5);
}
function R2(e12) {
  const r10 = !!e12.compressedTextureS3TC, a12 = !!e12.compressedTextureETC, s12 = has("disable-feature:i3s-basis") ? 0 : e11.Basis | e11.KTX2, t5 = e11.JPG | e11.PNG, l5 = s12 | e11.DDS_S3TC;
  return t5 | (r10 ? l5 : 0) | (a12 ? s12 : 0);
}
function D3(e12, o6) {
  if (null != o6)
    return e12.find((e13) => !!(e13.encoding & o6));
}
function w5(e12, o6, a12) {
  if (null == e12 || a12 === s10.None)
    return null;
  for (let r10 = 0; r10 < e12.length; r10++) {
    const s12 = e12[r10];
    if (null != s12 && s12.usage & a12) {
      const e13 = o6[r10];
      return null != e13 ? e13.id : null;
    }
  }
  return null;
}
function N2(e12) {
  switch (e12) {
    case e11.KTX2:
      return u6.KTX2_ENCODING;
    case e11.Basis:
      return u6.BASIS_ENCODING;
    case e11.DDS_S3TC:
      return u6.DDS_ENCODING;
    case e11.PNG:
      return "image/png";
    case e11.JPG:
      return "image/jpeg";
    case e11.KTX_ETC2:
      return "image/ktx";
    default:
      return "";
  }
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SNodeLoader.js
var d7 = class _d {
  constructor(e12, t5, r10, i4, o6, n10) {
    if (this._streamDataController = t5, this._logger = r10, this._defaultGeometrySchema = i4, this._requiredAttributes = o6, this._options = n10, this._logLayer = e12, this._layerUrl = e12.parsedUrl.path, this._geometryDefinitions = e12.geometryDefinitions, e12.materialDefinitions) {
      const t6 = e12.textureSetDefinitions;
      this._materialAndTextures = e12.materialDefinitions.map((r11) => h6(t6, r11, "integrated-mesh" === e12.type));
    }
  }
  _load(e12, t5, r10) {
    return this._streamDataController.request(e12, t5, r10);
  }
  _loadAttribute(e12, t5, r10) {
    const i4 = `${this._layerUrl}/nodes/${e12.resources.attributes}/attributes/${t5.key}/0`;
    return this._load(i4, "binary", r10).then((e13) => I(t5, e13));
  }
  async loadAttributes(e12, t5, r10) {
    const o6 = await Promise.allSettled(t5.map((t6) => this._loadAttribute(e12, t6.attributeStorageInfo, r10))), n10 = {};
    for (let s12 = 0; s12 < t5.length; ++s12) {
      const r11 = o6[s12], a12 = t5[s12];
      if ("fulfilled" === r11.status) {
        const e13 = r11.value;
        n10[a12.name] = e13;
      } else {
        const t6 = r11.reason;
        a2(t6), this._logger.error("#loadAttributes", this._logLayer, `Failed to load attributeData for '${a12.name}' on node '${e12.id}'`, t6);
      }
    }
    return n10;
  }
  async loadNodeData(r10, i4) {
    const o6 = null != this._requiredAttributes && r10.resources.attributes ? _2(this.loadAttributes(r10, this._requiredAttributes, i4)) : null, { bufferDefinition: n10, bufferIndex: s12 } = _5(this._geometryDefinitions, r10), u10 = !!r10.resources.geometry, f4 = u10 ? _2(this._loadGeometry(r10.resources.geometry, s12, i4)) : null, d8 = r10.resources.hasSharedResource ? await this._loadShared(r10, i4) : null, y5 = r10.resources.materialDefinition, b6 = this._materialAndTextures && null != y5 && y5 >= 0 ? this._materialAndTextures[y5] : null != d8 ? F4(d8) : null, D5 = b6 == null ? void 0 : b6.material, p5 = (b6 == null ? void 0 : b6.textures) ?? [], x5 = `${r10.id}`, A3 = !u10 && this._options.loadFeatureData, w6 = A3 ? await this._loadFeatureData(x5, i4) : null, T6 = A3 ? m4(w6) : c6(D5), $5 = null == T6 ? h7(w6) : null, j3 = p5.length > 0 ? _2(this.loadTextures(r10, p5, i4)) : null;
    let I7 = null, S6 = null;
    if (f4) {
      I7 = y2(await f4);
      const e12 = g5(this._defaultGeometrySchema, d8);
      S6 = p2(n10, e12);
    }
    const U3 = j3 ? y2(await j3) : null, q2 = o6 ? y2(await o6) : {}, B3 = q2 ? { attributeData: q2, loadedAttributes: this._requiredAttributes } : null;
    if (null != T6)
      return { geometryData: T6, attributeDataInfo: B3, geometryBuffer: I7, geometryDescriptor: S6, requiredTextures: p5, textureData: U3 };
    if (null != $5)
      return { pointData: $5, attributeDataInfo: B3, geometryBuffer: I7, geometryDescriptor: S6, requiredTextures: p5, textureData: U3 };
    throw new Error();
  }
  static _addAbsoluteHrefTexture(e12, t5) {
    const r10 = e12.textureDefinitions;
    if (null != r10)
      for (const i4 of Object.keys(r10))
        for (const e13 of r10[i4].images)
          Array.isArray(e13.href) ? e13.hrefConcat = e13.href.map((e14) => _(e14, t5)) : e13.hrefConcat = _(e13.href, t5);
  }
  static _fixTextureEncodings(e12) {
    const t5 = e12.textureDefinitions;
    if (null != t5)
      for (const r10 in t5) {
        const e13 = t5[r10];
        if (Array.isArray(e13.encoding))
          for (let t6 = 0; t6 < e13.encoding.length; t6++) {
            const r11 = e13.encoding[t6];
            "data:" === r11.substring(0, 5) && (e13.encoding[t6] = r11.substring(5));
          }
        else {
          const t6 = e13.encoding;
          "data:" === t6.substring(0, 5) && (e13.encoding = t6.substring(5));
        }
      }
  }
  async _loadShared(e12, t5) {
    if (null == e12.resources.geometry)
      return {};
    const r10 = `${this._layerUrl}/nodes/${e12.resources.geometry}/shared`, i4 = await this._load(r10, "json", t5);
    return _d._fixTextureEncodings(i4), _d._addAbsoluteHrefTexture(i4, r10), i4;
  }
  _loadTexture(e12, t5, r10, i4, o6, s12) {
    let a12 = false;
    return o6 === e11.DDS_S3TC || o6 === e11.KTX2 || o6 === e11.Basis ? this._load(e12, "binary", s12).then((e13) => ({ id: t5, usage: r10, data: e13, encoding: o6, downsampled: a12 })) : this._load(e12, "image", s12).then((e13) => {
      let n10 = e13;
      const s13 = 4096, u10 = 2;
      if (i4 && e13.width * e13.height >= s13) {
        const t6 = Math.ceil(e13.width / u10), r11 = Math.ceil(e13.height / u10), i5 = document.createElement("canvas");
        i5.width = t6, i5.height = r11;
        i5.getContext("2d").drawImage(e13, 0, 0, t6, r11), n10 = i5, a12 = true;
      }
      return { id: t5, usage: r10, data: n10, encoding: o6, downsampled: a12 };
    });
  }
  loadTextures(e12, t5, r10) {
    const i4 = !!this._options.uncompressedTextureDownsamplingEnabled, o6 = this._options.textureUsageMask;
    return Promise.all(t5.map((t6) => {
      if (!(t6.usage & o6))
        return null;
      const n10 = D3(t6.encodings, this._options.textureEncodings);
      if (null == n10)
        return this._logger.error("#loadTextures", this._logLayer, `No known encoding for texture found on node ${e12.id}`), Promise.reject();
      const s12 = e12.resources.texture || e12.id, a12 = `${this._layerUrl}/nodes/${s12}/textures/${n10.name}`;
      return this._loadTexture(a12, t6.id, t6.usage, i4, n10.encoding, r10);
    }));
  }
  _loadFeatureData(e12, t5) {
    const r10 = `${this._layerUrl}/nodes/${e12}/features/0`;
    return this._load(r10, "json", t5);
  }
  _loadGeometry(e12, t5, r10) {
    const i4 = `${this._layerUrl}/nodes/${e12}/geometries/${t5}`;
    return this._load(i4, "binary", r10);
  }
};
function c6(e12) {
  return { featureIds: [], geometries: [{ type: "ArrayBufferView", params: { material: e12 } }], featureDataPosition: [0, 0, 0] };
}
function m4(e12) {
  if (!e12)
    return null;
  for (const t5 of e12.featureData) {
    const e13 = t5.geometries;
    if (null != e13)
      for (const r10 of e13)
        return { featureIds: [t5.id], featureDataPosition: t5.position, geometries: [r10] };
  }
  return null;
}
function h7(e12) {
  if (!e12)
    return null;
  const t5 = new Array();
  for (const r10 of e12.featureData)
    null != r10.position && t5.push({ featureIds: [r10.id], featureDataPosition: r10.position, geometries: [] });
  return t5;
}
function g5(e12, t5) {
  if (!e12 || !(t5 == null ? void 0 : t5.materialDefinitions))
    return e12;
  const i4 = Object.keys(t5.materialDefinitions)[0];
  return !t5.materialDefinitions[i4].params.vertexRegions && e12.vertexAttributes.region && delete (e12 = a(e12)).vertexAttributes.region, e12;
}
function _5(e12, t5) {
  const r10 = { bufferDefinition: null, bufferIndex: 0 }, i4 = t5.resources.geometryDefinition;
  if (null == e12 || null == i4 || i4 < 0)
    return r10;
  const o6 = i4 >= 0 ? e12[i4].geometryBuffers : null;
  if (null == o6)
    return r10;
  for (let n10 = 0; n10 < o6.length; n10++) {
    const e13 = o6[n10];
    if (null == e13.compressedAttributes)
      r10.bufferIndex = n10, r10.bufferDefinition = o6[n10];
    else if ("draco" === e13.compressedAttributes.encoding && !has("disable-feature:i3s-draco"))
      return r10.bufferIndex = n10, r10.bufferDefinition = e13, r10;
  }
  return r10;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SStreamDataController.js
var r9 = class {
  constructor(e12, t5, r10) {
    this._requester = e12, this._customParameters = t5, this._apiKey = r10, this._activeRequests = /* @__PURE__ */ new Set();
  }
  get busy() {
    return this._requester.busy;
  }
  request(r10, s12, o6) {
    const a12 = new AbortController(), l5 = w(o6, () => a12.abort()), i4 = { signal: a12.signal, query: { ...this._customParameters, token: this._apiKey } }, n10 = this._requester.request(r10, s12, i4), u10 = { response: n10, abortController: a12, abortHandle: l5 };
    return this._activeRequests.add(u10), $(n10, () => {
      var _a;
      u10.abortController = null, (_a = u10.abortHandle) == null ? void 0 : _a.remove(), u10.abortHandle = null, this._activeRequests.delete(u10);
    }), n10;
  }
  cancelAll() {
    this._activeRequests.forEach((e12) => {
      var _a, _b;
      (_a = e12.abortController) == null ? void 0 : _a.abort(), e12.abortController = null, (_b = e12.abortHandle) == null ? void 0 : _b.remove();
    }), this._activeRequests.clear();
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SViewportQueries.js
var T4 = 1e5;
var H3 = class {
  get _frustumMbsCenter() {
    return this._frustumMbs;
  }
  get _frustumMbsRadius() {
    return this._frustumMbs[3];
  }
  get _frustumPlanes() {
    return this._frustum;
  }
  constructor(e12, t5, i4, s12, n10, r10, o6, a12, c7 = {}) {
    this._indexSR = e12, this._renderCoordsHelper = t5, this._clippingArea = n10, this._elevationProvider = r10, this._viewingMode = o6, this._options = c7, this._frustum = H2(), this._frustumMbs = n8(), this._useFrustumCulling = false, this._poi = n6(), this._elevationContext = null, this.minDistance = 1 / 0, this.maxDistance = 0, this.maxLodLevel = 2, this._tmpObb = new I2(), this._tmp1 = n6(), this._tmp2 = n6(), this._tmp3 = n6(), this._tmp0 = n6(), this._screenspaceErrorBias = c7.screenspaceErrorBias || 1, this._progressiveLoadFactor = c7.progressiveLoadFactor || 1, this.updateCamera(i4, s12);
    const u10 = this._renderCoordsHelper.spatialReference;
    this._renderSR = u10, this._renderSRSphericalPCPF = a6(u10), this._isGlobalMode = u10 === this._renderSRSphericalPCPF, this.updateElevationInfo(a12), this._tmpPoint = e7(0, 0, 0, e12), this._isECEFOBBInLocalMode = this._indexSR.isWGS84 && (u10.isWebMercator || O(u10)), this._indexSREllipsoidRadius = s3(this._indexSR).radius, this._indexSRSphericalPCPF = a6(e12), this._projectorIndexSRToIndexSRSphericalPCPF = G3(this._indexSR, this._indexSRSphericalPCPF);
  }
  updateElevationInfo(e12) {
    null != e12 ? (this._elevationContext = o4.fromElevationInfo(e12), this._elevationContext.updateFeatureExpressionInfoContext(u8(d3(e12, false)))) : this._elevationContext = null;
  }
  updateCamera(n10, r10) {
    if (this._useFrustumCulling = r10, r10) {
      L3(n10.viewMatrix, n10.projectionMatrix, this._frustum, X2);
      {
        const r11 = n10.eye, o6 = Z3;
        z2(o6, n10.viewForward);
        const a12 = Y2;
        K(a12, X2[4], r11);
        const c7 = 0.5 * P2(a12, a12) / P2(o6, a12), u10 = this._frustumMbs;
        q(u10, r11, o6, c7);
        const h8 = 1 + c7;
        u10[3] = h8;
      }
    }
    this._screenSizeFactor = 1 / (n10.perScreenPixelRatio / 2), this._camPos = n10.eye, this.minDistance = 1 / 0, this.maxDistance = 0;
  }
  setPointOfInterest(e12) {
    this._poi = e12;
  }
  updateScreenSpaceErrorBias(e12) {
    const t5 = this._screenspaceErrorBias;
    return this._screenspaceErrorBias = e12, t5;
  }
  updateClippingArea(e12) {
    this._clippingArea = e12;
  }
  expandElevationRange(e12, t5, i4) {
    var _a, _b;
    if (null == this._elevationContext)
      return;
    const s12 = e12.serviceMbsInIndexSR;
    if (!s12)
      return;
    const n10 = "relative-to-scene" === this._elevationContext.mode ? "scene" : "ground";
    if (this._elevationProvider.getSphereElevationBounds) {
      const e13 = this._elevationProvider.getSphereElevationBounds(s12, this._indexSR, n10);
      return void (e13 && i4.expandElevationRange(e13));
    }
    const r10 = s12[0], o6 = s12[1], a12 = s12[2], c7 = this._elevationProvider.getElevation(r10, o6, a12, this._indexSR, n10);
    c7 && i4.expandElevationRangeValues(c7, c7);
    const u10 = t5 ? null : (_b = (_a = this._elevationProvider).getRootElevationBounds) == null ? void 0 : _b.call(_a);
    u10 && i4.expandElevationRange(u10);
  }
  getServiceMbsInRenderSR(e12) {
    const t5 = e12.serviceMbsInRenderSR;
    if (ye(t5))
      return t5;
    e12.serviceMbsInIndexSR && a5(t5, e12.serviceMbsInIndexSR);
    const i4 = e12.elevationRangeMin;
    if (this._elevationContext && Number.isFinite(i4)) {
      let s12 = 0, n10 = 0;
      const r10 = e12.elevationRangeMax;
      switch (this._elevationContext.mode) {
        case "relative-to-ground":
          s12 = this._elevationContext.geometryZWithOffset(t5[2], this._renderCoordsHelper) + i4 - t5[2], n10 = r10 - i4;
          break;
        case "on-the-ground":
          s12 = i4 - t5[2], n10 = r10 - i4;
      }
      t5[2] += s12 + 0.5 * n10, t5[3] += 0.5 * n10;
    } else
      this._elevationContext && t5[3] < T4 && (this._tmpPoint.x = t5[0], this._tmpPoint.y = t5[1], this._tmpPoint.z = t5[2], t5[2] = f(this._tmpPoint, this._elevationProvider, this._elevationContext, this._renderCoordsHelper));
    return a8(t5, this._indexSR, t5, this._renderSR), t5;
  }
  getAndUpdateVisibilityObbInRenderSR(e12) {
    {
      const t6 = e12.visibilityObbInRenderSR;
      if (t6)
        return t6;
    }
    const t5 = 0.01 * this._indexSREllipsoidRadius, { serviceMbsInIndexSR: i4, serviceObbInIndexSR: s12 } = e12;
    if (null == s12 || !i4 || !s12.isValid || this._isECEFOBBInLocalMode && (s12.halfSizeX > t5 || s12.halfSizeY > t5 || s12.halfSizeZ > t5))
      return null;
    {
      let t6 = e12.serviceObbInRenderSR;
      if (null == t6)
        t6 = new I2(), e12.serviceObbInRenderSR = t6;
      else if (t6.isValid)
        return t6;
      const n10 = i4[3];
      let r10 = 0, o6 = 0;
      const a12 = s12.centerZ, c7 = this._renderCoordsHelper, u10 = this._elevationContext;
      if (u10 && e12.elevationRangeValid) {
        const t7 = e12.elevationRangeMin, i5 = e12.elevationRangeMax;
        switch (u10.mode) {
          case "relative-to-ground":
            r10 = u10.geometryZWithOffset(a12, c7) + t7 - a12, o6 = i5 - t7;
            break;
          case "on-the-ground":
            r10 = t7 - a12, o6 = i5 - t7;
        }
      } else if (u10 && n10 < T4) {
        const e13 = this._tmpPoint;
        e13.x = s12.centerX, e13.y = s12.centerY, e13.z = a12, r10 = f(e13, this._elevationProvider, u10, c7) - a12;
      }
      const h8 = o6 > 0, l5 = h8 ? this._tmpObb : t6;
      return s12.transform(l5, this._indexSR, this._renderSR, r10, this._renderSRSphericalPCPF, this._indexSRSphericalPCPF, this._projectorIndexSRToIndexSRSphericalPCPF), h8 && L2(l5, 0, o6, this._viewingMode, t6), t6;
    }
  }
  getNodeObbInRenderSRIndependentOfElevationOffset(e12) {
    {
      const t6 = e12.visibilityObbInRenderSR ?? e12.serviceObbInRenderSR ?? null;
      if (t6 == null ? void 0 : t6.isValid)
        return t6;
    }
    const t5 = e12.serviceObbInIndexSR;
    return t5 ? (t5.transform(ee, this._indexSR, this._renderSR, void 0, this._renderSRSphericalPCPF, this._indexSRSphericalPCPF, this._projectorIndexSRToIndexSRSphericalPCPF), ee) : null;
  }
  ensureElevationAgnosticBoundingVolume(e12) {
    return -1 === e12.elevationAgnosticBoundingVolume[3] && e12.level > 0 && (this._viewingMode === l2.Global ? this._updateElevationAgnosticBoundingVolumeGlobal(e12) : this._updateElevationAgnosticBoundingVolumeLocal(e12)), e12.elevationAgnosticBoundingVolume;
  }
  _updateElevationAgnosticBoundingVolumeGlobal(t5) {
    const s12 = this.getNodeObbInRenderSRIndependentOfElevationOffset(t5), o6 = t5.elevationAgnosticBoundingVolume;
    let a12, c7 = -1;
    if (s12) {
      const t6 = te;
      s12.getCenter(t6), z2(t6, t6), a12 = t6, s12.getCorners(ie);
      for (const s13 of ie) {
        z2(s13, s13);
        const n10 = P2(s13, t6);
        if (n10 <= 0)
          return void (o6[3] = -1);
        const r10 = Math.sqrt(1 - n10 * n10);
        c7 = Math.max(c7, r10);
      }
    } else {
      const i4 = t5.serviceMbsInRenderSR;
      if (!ye(i4))
        return void (o6[3] = -1);
      {
        const t6 = r2(te, Z(i4)), s13 = i4[3], o7 = Y(t6);
        c7 = 0 === s13 ? 0 : o7 < s13 ? -1 : s13 / o7, z2(t6, t6), a12 = t6;
      }
    }
    r4(o6, a12);
    const u10 = 1e-3;
    o6[3] = c7 + u10;
  }
  _updateElevationAgnosticBoundingVolumeLocal(e12) {
    const t5 = e12.elevationAgnosticBoundingVolume, i4 = this.getNodeObbInRenderSRIndependentOfElevationOffset(e12);
    if (i4) {
      const e13 = i4.getCenter(te);
      e13[2] = 0, r4(t5, e13);
      let s12 = 0;
      const n10 = se;
      i4.getCorners(ie);
      for (const t6 of ie) {
        t6[2] = 0;
        const e14 = X(n10, t6);
        s12 = Math.max(s12, e14);
      }
      t5[3] = Math.sqrt(s12);
    } else {
      const i5 = e12.serviceMbsInRenderSR;
      if (ye(i5)) {
        const e13 = r2(te, Z(i5));
        e13[2] = 0, r4(t5, e13), t5[3] = i5[3];
      }
    }
  }
  isNodeVisible(e12) {
    const t5 = this.getServiceMbsInRenderSR(e12);
    if (!this._isMBSinClippingArea(t5))
      return false;
    if (!this._useFrustumCulling)
      return true;
    const i4 = this.getAndUpdateVisibilityObbInRenderSR(e12);
    return i4 ? i4.doesIntersectFrustumConservativeApproximation(this._frustum) : s6(this._frustum, k(t5));
  }
  isElevationAgnosticBoundingVolumeVisible(e12) {
    return !this._useFrustumCulling || (-1 === e12[3] || (this._viewingMode === l2.Global ? this._isConeVisibleInFrustum(e12) : this._isCylinderVisibleInFrustum(e12)));
  }
  _isConeVisibleInFrustum(n10) {
    if (!this._isConeVisibleInFrustumMbs(n10))
      return false;
    const r10 = n10[3];
    if (-1 === r10 || r10 > 0.9)
      return true;
    const o6 = this._frustumPlanes, c7 = this._frustumMbsCenter, u10 = n10, h8 = P2(u10, c7), l5 = this._frustumMbsRadius, d8 = h8 - l5, m5 = h8 + l5;
    if (d8 <= 0)
      return true;
    const _6 = g(K2, u10, d8), p5 = g(Q, u10, m5), f4 = r10 / Math.sqrt(1 - r10 * r10);
    for (const v2 of o6) {
      const n11 = F(v2), r11 = z2($2, n11), o7 = P2(r11, u10);
      if (Math.abs(1 - o7) < 0.01)
        continue;
      const c8 = ne;
      g(c8, u10, o7), K(c8, c8, r11), z2(c8, c8);
      const h9 = re;
      q(h9, _6, c8, d8 * f4);
      if (V2(v2, h9) <= 0)
        continue;
      q(h9, p5, c8, m5 * f4);
      if (V2(v2, h9) <= 0)
        continue;
      return false;
    }
    return true;
  }
  _isConeVisibleInFrustumMbs(e12) {
    const t5 = e12[3];
    if (t5 > 0.9)
      return true;
    const s12 = this._frustumMbsRadius, n10 = this._frustumMbsCenter, o6 = Y(n10);
    if (o6 <= s12)
      return true;
    const u10 = e12, h8 = P2(u10, n10);
    {
      const e13 = g(J, u10, h8);
      if (U2(e13, n10) < s12)
        return true;
    }
    const l5 = h8 / o6;
    if (h8 <= 0) {
      return -l5 < s12;
    }
    const d8 = Math.sqrt(1 - l5 * l5);
    if (d8 < t5)
      return true;
    const m5 = s12 / o6;
    return d8 * Math.sqrt(1 - m5 * m5) - m5 * l5 < t5;
  }
  isObbVisibleIndependentOfElevation(e12, t5) {
    if (!this._useFrustumCulling)
      return true;
    if (-1 === e12[3])
      return true;
    const s12 = this._frustumMbsRadius, n10 = this._frustumMbsCenter, r10 = this._frustumPlanes, o6 = ie;
    if (t5.getCorners(o6), this._viewingMode === l2.Global) {
      const t6 = e12, c7 = P2(t6, n10), u10 = c7 - s12, h8 = c7 + s12;
      if (u10 <= 0)
        return true;
      for (const e13 of r10) {
        let s13 = true;
        for (const n11 of o6) {
          const r11 = P2(n11, t6), o7 = oe;
          if (g(o7, n11, u10 / r11), V2(e13, o7) <= 0) {
            s13 = false;
            break;
          }
          const c8 = oe;
          if (g(c8, n11, h8 / r11), V2(e13, c8) <= 0) {
            s13 = false;
            break;
          }
        }
        if (s13)
          return false;
      }
    } else {
      const e13 = n10[2] - s12, t6 = n10[2] + s12;
      for (const i4 of r10) {
        let s13 = true;
        const n11 = F(i4), r11 = n11[0], a12 = n11[1], c7 = n11[2], u10 = i4[3];
        for (const i5 of o6) {
          const n12 = r11 * i5[0] + a12 * i5[1] + u10;
          if (n12 + c7 * e13 <= 0 || n12 + c7 * t6 <= 0) {
            s13 = false;
            break;
          }
        }
        if (s13)
          return false;
      }
    }
    return true;
  }
  _isCylinderVisibleInFrustum(e12) {
    const t5 = this._frustumMbsCenter, i4 = this._frustumMbsRadius, s12 = r2(J, t5);
    s12[2] = 0;
    const r10 = e12[3];
    return U2(s12, e12) <= r10 + i4;
  }
  isGeometryVisible(e12) {
    if (!this._useFrustumCulling)
      return true;
    const t5 = e12.geometryObbInRenderSR;
    return (t5 == null ? void 0 : t5.doesIntersectFrustumConservativeApproximation(this._frustum)) ?? this.isNodeVisible(e12);
  }
  _isMBSinClippingArea(e12) {
    return null == this._clippingArea || O3(this._clippingArea, e12) !== F2.OUTSIDE;
  }
  _screenSpaceDiameterMbs(e12, t5) {
    const i4 = this.getServiceMbsInRenderSR(e12), s12 = Math.sqrt(p(Z(i4), this._camPos)), n10 = s12 - i4[3];
    return this._updateMinMaxDistance(s12), n10 < 0 ? 0.5 * Number.MAX_VALUE : t5 / n10 * this._screenSizeFactor;
  }
  calcCameraDistance(e12) {
    return this.calcCameraDistanceToCenter(e12) - this.getServiceMbsInRenderSR(e12)[3];
  }
  calcCameraDistanceToCenter(e12) {
    const t5 = this.getServiceMbsInRenderSR(e12), i4 = x(Z(t5), this._camPos);
    return this._updateMinMaxDistance(i4), i4;
  }
  calcAngleDependentLoD(e12) {
    const t5 = this.getServiceMbsInRenderSR(e12), i4 = t5[3], s12 = (Math.abs(t5[0] * (t5[0] - this._camPos[0]) + t5[1] * (t5[1] - this._camPos[1]) + t5[2] * (t5[2] - this._camPos[2])) / s4(Z(t5)) + i4) / x(Z(t5), this._camPos);
    return Math.min(1, s12);
  }
  hasLOD(e12) {
    return e12.lodMetric !== d2.None;
  }
  _getDistanceGlobeMode(e12, t5) {
    const s12 = s4(Z(t5)), n10 = s4(e12) - s12;
    g(this._tmp0, e12, P2(e12, Z(t5)) / v(e12));
    const r10 = p(Z(t5), this._tmp0), o6 = t5[3];
    if (r10 <= o6 * o6)
      return Math.abs(n10);
    {
      const r11 = g(this._tmp0, Z(t5), 1 / s12), c7 = s12, u10 = o6 * o6 / 2 / c7, d8 = g(this._tmp1, r11, c7 - u10), p5 = e12, f4 = e4(this._tmp2, p5, d8), v2 = e4(this._tmp2, f4, g(this._tmp3, r11, P2(r11, f4))), g6 = u3(this._tmp2, d8, g(this._tmp2, v2, o6 / s4(v2)));
      let b6 = x(p5, g6);
      if (n10 >= 2e5) {
        const e13 = e4(this._tmp1, p5, g6);
        let t6 = P2(e13, r11) / s4(e13);
        t6 < 0.08 && (t6 = 1e-4), b6 /= t6;
      }
      return b6;
    }
  }
  _getDistance(e12, t5) {
    return this._isGlobalMode ? this._getDistanceGlobeMode(e12, t5) : W(e12, t5);
  }
  _updateMinMaxDistance(e12) {
    e12 > 0 ? (this.minDistance = Math.min(this.minDistance, e12), this.maxDistance = Math.max(this.maxDistance, e12)) : (this.minDistance = 0, this.maxDistance = Math.max(this.maxDistance, -e12));
  }
  getLodLevel(e12) {
    if (e12.lodMetric === d2.None)
      return 0;
    if (0 === e12.childCount)
      return this.maxLodLevel;
    if (this._useFrustumCulling && this._progressiveLoadFactor < 1) {
      const t5 = this._progressiveLoadFactor * this._screenspaceErrorBias, i4 = this._screenspaceErrorBias;
      return this.evaluateLODmetric(e12, t5) ? this.evaluateLODmetric(e12, i4) ? 2 : 1 : 0;
    }
    return this.evaluateLODmetric(e12, this._screenspaceErrorBias) ? this.maxLodLevel : 0;
  }
  evaluateLODmetric(e12, t5) {
    switch (e12.lodMetric) {
      case d2.ScreenSpaceRelative: {
        const i4 = this.getServiceMbsInRenderSR(e12), s12 = this._getDistance(this._camPos, i4), n10 = 2 * s12 / this._screenSizeFactor, r10 = s12 + i4[3];
        return this._updateMinMaxDistance(r10), e12.maxError * t5 <= n10;
      }
      case d2.MaxScreenThreshold: {
        let i4 = this._screenSpaceDiameterMbs(e12, e12.serviceMbsInIndexSR[3] * t5);
        return this._options.angleDependentLoD && (i4 *= this.calcAngleDependentLoD(e12)), i4 < e12.maxError;
      }
      case d2.RemovedFeatureDiameter:
        return this._screenSpaceDiameterMbs(e12, e12.maxError) * t5 < 10;
      case d2.DistanceRangeFromDefaultCamera:
        return this.calcCameraDistance(e12) > e12.maxError * t5;
    }
    return false;
  }
  distToPOI(e12) {
    const t5 = this.getServiceMbsInRenderSR(e12);
    return x(Z(t5), this._poi) - t5[3];
  }
  distCameraToPOI() {
    return x(this._camPos, this._poi);
  }
};
function W(e12, t5) {
  const i4 = e12[0] - t5[0], s12 = e12[1] - t5[1], n10 = e12[2] - t5[2], r10 = i4 * i4 + s12 * s12, o6 = t5[3];
  if (r10 <= o6 * o6)
    return Math.abs(n10);
  const a12 = Math.sqrt(r10) - o6;
  return Math.sqrt(n10 * n10 + a12 * a12);
}
var Z3 = n6();
var X2 = I4();
var Y2 = n6();
var J = n6();
var K2 = n6();
var Q = n6();
var $2 = n6();
var ee = new I2();
var te = n6();
var ie = [n6(), n6(), n6(), n6(), n6(), n6(), n6(), n6()];
var se = n6();
var ne = n6();
var re = n6();
var oe = n6();

// node_modules/@arcgis/core/layers/graphics/controllers/I3SOnDemandController.js
var G4 = 100;
var R3 = 2;
var j2 = 1e4;
var Q2 = 1e-4;
var T5 = 1.2;
var E2 = 500;
var H4 = 1.5;
var k4 = class extends n4(S) {
  get isMeshPyramid() {
    var _a;
    return "mesh-pyramids" === this.layer.profile || "MeshPyramid" === ((_a = this.layer.store) == null ? void 0 : _a.lodType);
  }
  get isGraphics3D() {
    return "points" === this.layer.profile;
  }
  get useMaximumNumberOfFeatures() {
    return !this.isMeshPyramid && (null == this.layer.priority || "High" === this.layer.priority);
  }
  get indexStreamController() {
    const e12 = this.layerView.view.resourceController.createStreamDataRequester(A.I3S_INDEX);
    return new r9(e12, this.layer.customParameters, this.layer.apiKey);
  }
  get dataStreamController() {
    const e12 = this.layerView.view.resourceController.createStreamDataRequester(A.I3S_DATA);
    return new r9(e12, this.layer.customParameters, this.layer.apiKey);
  }
  get crsVertex() {
    return H(this.layer);
  }
  get crsIndex() {
    return Z2(this.layer);
  }
  get layer() {
    return this.layerView.i3slayer;
  }
  get running() {
    return this.updating;
  }
  get rootNodeVisible() {
    if (this._index) {
      const e12 = this._index.rootNode;
      if (e12)
        return this._updateViewData(), this._index.isNodeVisible(e12.index);
    }
    return true;
  }
  get index() {
    return this._index;
  }
  get requiredAttributes() {
    return this._requiredAttributes;
  }
  constructor(e12) {
    super(e12), this.screenSizeFactor = 0, this.featureTarget = 5e4, this.fixedFeatureTarget = false, this.updating = true, this.updatingProgress = 1, this.leavesReached = false, this.scaleVisibilityEnabled = true, this.worker = null, this._featureLOD = 1, this._stableFeatureLOD = false, this._isIdle = false, this._cameraDirty = true, this._invisibleDirty = false, this._idleStateCallbacks = null, this._newLoadingNodes = new l({ deallocator: null }), this._loadedNodeScales = /* @__PURE__ */ new Map(), this._modificationsNodeFilteringArray = new l(), this._downloadingCount = 0, this._loadingNodes = /* @__PURE__ */ new Map(), this._updatingNodes = /* @__PURE__ */ new Map(), this._progressMaxNumNodes = 1, this._requiredAttributes = new Array(), this._requiredAttributesDirty = true, this._updatesDisabled = false, this.disableIDBCache = false, this._disableMemCache = false, this._restartNodeLoading = false, this._fields = null, this._attributeStorageInfo = null, this._idleQueue = new i2(), this._elevationUpdateNodes = new l({ deallocator: null }), this._errorCount = 0;
  }
  initialize() {
    const { layerView: e12, layer: t5 } = this;
    this._disableMemCache = !e12.loadCachedGPUData || !e12.addCachedGPUData, this._lodHandling = new o5(e12), this._defaultGeometrySchema = t5.store.defaultGeometrySchema, this.disableIDBCache = has("disable-feature:idb-cache"), "fields" in t5 && (this._fields = t5.fields, this._attributeStorageInfo = t5.attributeStorageInfo), this.addResolvingPromise(Promise.all([t5.indexInfo, t5.when(), e12.when()]).then(([s12]) => {
      if (this.destroyed || !e12 || e12.destroyed || !s12)
        return;
      const { view: r10, clientGeometry: a12 } = e12, { resourceController: l5 } = r10;
      if (this._setClippingArea(r10.clippingArea), this.addHandles([d(() => {
        var _a, _b;
        return (_b = (_a = r10 == null ? void 0 : r10.pointsOfInterest) == null ? void 0 : _a.focus) == null ? void 0 : _b.renderLocation;
      }, (e13) => this._pointOfInterestChanged(e13), P), d(() => r10.quality, () => this._setCameraDirty(), C), d(() => e12.contentVisible, (e13) => {
        const t6 = e13 ? () => this._updateIdleState(true) : () => this._updateViewData(), i4 = e13 ? () => this._updateIdleState(false) : () => {
        };
        e13 && null != this._index && this._index.invalidateAllElevationRanges(), this._idleStateCallbacks ? (e13 || this.cancelNodeLoading(), this.restartNodeLoading(), this._idleStateCallbacks.idleBegin = t6, this._idleStateCallbacks.idleEnd = i4) : this._idleStateCallbacks = l5.scheduler.registerIdleStateCallbacks(t6, i4);
      }, P), h5(e12.view.resourceController.scheduler, this), d(() => e12.uncompressedTextureDownsamplingEnabled, () => this.restartNodeLoading()), d(() => [this.featureTarget, this.fixedFeatureTarget], () => {
        this._setCameraDirty(), this._stableFeatureLOD = false;
      }), d(() => {
        var _a;
        return (_a = r10.state) == null ? void 0 : _a.contentCamera;
      }, () => this._setCameraDirty()), d(() => t5.elevationInfo, (e13) => this._elevationInfoChanged(e13)), d(() => t5.effectiveScaleRange, () => this._scaleBoundsChanged()), d(() => e12.lodFactor, () => this._setCameraDirty()), d(() => e12.availableFields, () => this._requiredFieldsChange()), d(() => e12.holeFilling, (e13) => null != this._index && (this._index.holeFilling = e13))]), this._updateScaleHandles(), this._viewportQueries = new H3(this.crsIndex, r10.renderCoordsHelper, r10.state.contentCamera, !r10.state.fixedContentCamera || this.isGraphics3D, this._clippingArea, this.isMeshPyramid ? r10.basemapTerrain : r10.elevationProvider, o(r10.viewingMode), this.layer.elevationInfo, { progressiveLoadFactor: this._getProgressiveLoadFactor(), screenspaceErrorBias: this._lod, angleDependentLoD: this._lod < 0.5 }), this._clientNodeLoader = new h4(this.layer.uid, { indexSR: this.crsIndex, vertexSR: this.crsVertex, renderSR: r10.renderCoordsHelper.spatialReference, localMode: "local" === r10.viewingMode }, r10.resourceController.memoryController, this.worker), this._index = new I6(o(r10.viewingMode), t5, s12, this.indexStreamController, this._clientNodeLoader, this._viewportQueries, n2.getLogger(this), e12.holeFilling, (t6) => e12.isNodeLoaded(t6), (t6) => e12.isNodeReloading(t6), (e13) => this._shouldLoadNode(e13), (e13) => this._enableFromGPUCache(e13, c.Leaf), (e13) => this._needsUpdate(e13), () => !this.indexStreamController.busy, (t6) => {
        var _a;
        return ((_a = e12.computeVisibilityObb) == null ? void 0 : _a.call(e12, t6)) ?? null;
      }, (e12 == null ? void 0 : e12.computeNodeFiltering) ? (t6) => e12.computeNodeFiltering(t6) : void 0), this._index.updateElevationInfo(this.layer.elevationInfo, this.isMeshPyramid || this.isGraphics3D), this._index.imModificationsChanged(!!e12.hasModifications), this._index.layerFilterChanged(!!e12.hasGeometryFilter), null != a12) {
        for (const e13 of a12)
          this._addMesh(e13.mesh, e13.oid);
        this.addHandles(a12.on("change", (e13) => {
          for (const t6 of e13.removed)
            this._removeMesh(t6.oid);
          for (const t6 of e13.added)
            this._addMesh(t6.mesh, t6.oid);
        }));
      }
      this._startNodeLoading();
    })), this._tmpPoint = e7(0, 0, 0, this.crsIndex);
  }
  updateNodeModificationStatus(e12) {
    const t5 = this._index, i4 = this.layerView;
    null != t5 && (i4 == null ? void 0 : i4.updateNodeModificationStatus) && (this._modificationsNodeFilteringArray.clear(), e12.forAll((e13) => {
      const i5 = t5.getNode(e13);
      null != i5 && this._modificationsNodeFilteringArray.push(i5);
    }), i4.updateNodeModificationStatus(this._modificationsNodeFilteringArray), this._invisibleDirty = true);
  }
  destroy() {
    this.cancelNodeLoading(), this._idleStateCallbacks && (this._isIdle = false, this._idleStateCallbacks.remove(), this._idleStateCallbacks = null), this._nodeLoader = null, B2.prune(), null != z4 && (z4.hide(), z4 = null);
  }
  get viewportQueries() {
    return this._viewportQueries;
  }
  _getRequiredAttributes() {
    if (null == this._attributeStorageInfo || !this._fields || !this.layerView.availableFields)
      return [];
    const e12 = this._attributeStorageInfo, t5 = this._fields, i4 = this.layer.objectIdField;
    return this.layerView.availableFields.map((i5) => {
      const s12 = K3(e12, i5), r10 = K3(t5, i5);
      return s12 >= 0 && r10 >= 0 ? { index: s12, name: t5[r10].name, field: t5[r10], attributeStorageInfo: e12[s12] } : null;
    }).filter((e13) => null != e13 && e13.name !== i4);
  }
  _requiredFieldsChange() {
    const e12 = this._getRequiredAttributes();
    $3(this._requiredAttributes, e12) || (this._requiredAttributes = e12, this._requiredAttributesDirty = false, this.restartNodeLoading());
  }
  requestUpdate() {
    this._requiredAttributesDirty = true, this.restartNodeLoading();
  }
  _setClippingArea(e12) {
    const t5 = u4();
    u9(e12, t5, this.layerView.view.renderSpatialReference) ? this._clippingArea = t5 : this._clippingArea = null;
  }
  _pointOfInterestChanged(e12) {
    null != this._viewportQueries && (this._viewportQueries.setPointOfInterest(e12), null != this._index && (this._index.progressiveLoadPenalty = W2.distancePenalty * this._viewportQueries.distCameraToPOI(), this._index.requestUpdate()));
  }
  updateClippingArea(e12) {
    this._setClippingArea(e12), null != this._viewportQueries && null != this._index && (this._viewportQueries.updateClippingArea(this._clippingArea), this._index.invalidateVisibilityCache()), this._setCameraDirty();
  }
  _setCameraDirty() {
    this._cameraDirty = true, this._lodHandling.setLodGlobalDirty(), this._evaluateUpdating();
  }
  _addMesh(e12, t5) {
    if (null == this._index)
      return;
    const i4 = this._clientNodeLoader.createMeshNodeInfo(e12, t5), s12 = this._index.addClientNodeToIndex(i4.id, i4.mbs);
    this._clientNodeLoader.addMeshNode(s12, i4), this._evaluateUpdating(), this.notifyChange("rootNodeVisible");
  }
  _removeMesh(e12) {
    const t5 = this._clientNodeLoader.getMeshNodeIndex(e12);
    if (null != t5) {
      if (null == this._index)
        throw new Error("delayed removal of client side i3s node geometry not supported yet.");
      {
        const e13 = (e14, t6) => {
          var _a, _b, _c, _d;
          this.layerView.removeNode(t6), this._loadedNodeScales.delete(t6), this._clientNodeLoader.removeNode(e14), this.layerView.deleteCachedNodeData && null != e14 && this.layerView.deleteCachedNodeData(e14), (_d = (_c = this.layerView).deleteCachedGPUData) == null ? void 0 : _d.call(_c, (_b = (_a = this.layerView).loadCachedGPUData) == null ? void 0 : _b.call(_a, t6));
        }, i4 = (e14, t6, i5) => {
          this._clientNodeLoader.updateNodeIndex(e14, t6, i5), this.layerView.updateNodeIndex && this.layerView.updateNodeIndex(t6, i5);
        };
        this._index.removeClientNodeFromIndex(t5, e13, i4), this.notifyChange("rootNodeVisible");
      }
    }
  }
  updateElevationChanged(e12, t5) {
    const i4 = this._index;
    if (null == (i4 == null ? void 0 : i4.rootNode) || null == t5)
      return null;
    this.crsIndex.equals(t5) || (i3(e12, t5, X3, this.crsIndex), e12 = X3);
    const s12 = this._elevationUpdateNodes;
    return s12.clear(), k2(e12, i4.rootNode, i4, (e13) => s12.push(e13.index)), s12.length && (s12.forAll((e13) => i4.updateElevationChanged(e13)), this._setCameraDirty()), s12;
  }
  removeAllGeometryObbs() {
    null != this._index && this._index.removeAllGeometryObbs();
  }
  getRenderMbs(e12) {
    return null != this._viewportQueries ? this._viewportQueries.getServiceMbsInRenderSR(e12) : null;
  }
  _elevationInfoChanged(e12) {
    null != this._index && (this._index.updateElevationInfo(e12, this.isMeshPyramid || this.isGraphics3D), this._setCameraDirty());
  }
  _updateScaleHandles() {
    const e12 = "scale-bounds";
    this.removeHandles(e12), this._areScaleBoundsActive && this.addHandles(this.layerView.view.basemapTerrain.on("scale-change", (e13) => this._scaleUpdateHandler(e13)), e12);
  }
  _scaleBoundsChanged() {
    this._areScaleBoundsActive || this._loadedNodeScales.clear(), this._updateScaleHandles(), this._setCameraDirty();
  }
  _scaleUpdateHandler(e12) {
    this._updateScaleInBoundingRect(e12.extent, e12.spatialReference), this._setCameraDirty();
  }
  _updateScaleInBoundingRect(e12, t5) {
    const i4 = this._index;
    if (null == i4)
      return;
    null != i4.rootNode && i3(e12, t5, X3, this.crsIndex) && this._loadedNodeScales.forEach((e13, t6) => {
      const s12 = i4.getNode(t6);
      null != s12 && g2(X3, s12.serviceMbsInIndexSR) && this._loadedNodeScales.set(t6, this._computeScale(s12));
    });
  }
  restartNodeLoading() {
    this._restartNodeLoading = true, this.cancelNodeLoading(), this._evaluateUpdating();
  }
  schedule(e12, t5) {
    return this._idleQueue.push(e12, t5);
  }
  reschedule(e12, t5) {
    return this._idleQueue.unshift(e12, t5);
  }
  get _isIntegratedMesh() {
    return "integrated-mesh" === this.layer.type;
  }
  get _areScaleBoundsActive() {
    const { minScale: e12, maxScale: t5 } = c2(this.layer);
    return this.scaleVisibilityEnabled && (e12 > 0 || t5 > 0);
  }
  get unloadedMemoryEstimate() {
    return null != this._index && this.layerView.contentVisible ? this._index.unloadedMemoryEstimate * this._lodDropFactor : 0;
  }
  async _loadNodeData(e12, t5) {
    return e12.index < 0 ? this._clientNodeLoader.loadNodeData(e12.id, t5) : this._nodeLoader.loadNodeData(e12, t5);
  }
  async _loadAttributes(e12, t5, i4) {
    return (e12.index < 0 ? this._clientNodeLoader : this._nodeLoader).loadAttributes(e12, t5, i4);
  }
  get indexDepth() {
    return null != this._index ? this._index.maxLevel : 0;
  }
  set disableMemCache(e12) {
    this.layerView.loadCachedGPUData && this.layerView.addCachedGPUData ? this._disableMemCache = e12 : this._disableMemCache = true;
  }
  runTask(e12, t5) {
    return this.layerView.contentVisible ? this.layerView.visible && null != this._index ? (this._processWithErrorLogging(e12, t5), this._index.maxPriority) : -1 / 0 : (this._updateViewData(), this._evaluateUpdating(), -1 / 0);
  }
  _processWithErrorLogging(e12, t5) {
    try {
      this._process(e12, t5);
    } catch (s12) {
      this._errorCount < 50 ? n2.getLogger(this).error(`Error during processing: ${s12} at ${s12.stack}`) : 50 === this._errorCount && n2.getLogger(this).error("Too many errors for this layer. Further errors will not be displayed."), this._errorCount++;
    }
  }
  _process(e12, t5) {
    this._restartNodeLoading && this._startNodeLoading(), null != this._nodeLoader && null != this._index && (this._updateViewData(), this._invisibleDirty && this._removeInvisibleNodes(e12) && (this._invisibleDirty = false), this._isIntegratedMesh && (e12.enabled = false), e12.run(() => this._processIndex(e12)), this._updateFeatureLOD(), e12.run(() => this._processCache(e12)), this._isIntegratedMesh && (e12.enabled = true), e12.run(() => this._processNodes(e12, t5)), this._idleQueue.runTask(e12), e12.run(() => this._prefetchIndex()), t5.numIndexLoading += this._index.indexLoading, t5.numNodesLoading += this._downloadingCount, e12.run(() => this._lodHandling.lodGlobalHandling(e12)), this._evaluateUpdating());
  }
  _processIndex(e12) {
    if (null == this._index)
      return false;
    if (this._index.dirty) {
      this._newLoadingNodes.clear(), this._index.update(Array.from(this._loadingNodes.keys()), e12, (e13) => this.updateNodeModificationStatus(e13)), this._disableMemCache || (this._newLoadingNodes.pushArray(this._index.updates.add.data, this._index.updates.add.length), this._newLoadingNodes.pushArray(this._index.updates.missing.data, this._index.updates.missing.length));
      const t5 = this._index.featureEstimate.leavesReached;
      this._index.isLoading || t5 === this._get("leavesReached") || this._set("leavesReached", t5);
    }
    return this._index.load();
  }
  _prefetchIndex() {
    return !(null == this._index || this._loadingNodes.size > 0 || this._index.updates.add.length > 0) && this._index.prefetch();
  }
  _updateFeatureLOD() {
    if (!this.useMaximumNumberOfFeatures || null == this._index || null == this._viewportQueries)
      return;
    const e12 = !this._index.isLoading, t5 = this.featureTarget * this._baseLOD, i4 = this._index.featureEstimate;
    if (i4.estimate = i4.estimate || t5 / 2, this._index.indexMissing > E2) {
      if (this._featureLOD <= Q2)
        return;
      this._featureLOD /= H4, this._stableFeatureLOD = false;
    } else if (e12 && i4.estimate < t5) {
      if (i4.leavesReached || this._featureLOD >= j2 || this._stableFeatureLOD)
        return;
      const e13 = Math.min(10, Math.max(t5 / i4.estimate, 1.001));
      this._featureLOD *= e13;
      const s12 = this._lod, r10 = this._index.checkFeatureTarget(t5, s12);
      r10 !== s12 && (this._featureLOD = r10 / this._baseLOD, this._stableFeatureLOD = true);
    } else {
      if (!(i4.estimate > t5 * T5 || e12 && i4.estimate > t5))
        return;
      if (this._featureLOD <= Q2)
        return;
      this._featureLOD /= 1 + 0.25 * (i4.estimate / t5 - 1), this._stableFeatureLOD = false;
    }
    this._featureLOD = Math.min(j2, Math.max(Q2, this._featureLOD)), this._viewportQueries.updateScreenSpaceErrorBias(this._lod), this._index.requestUpdate();
  }
  _processCache(e12) {
    const t5 = this._index;
    if (null == t5)
      return false;
    for (; this._newLoadingNodes.length > 0 && !e12.done; ) {
      const i4 = this._newLoadingNodes.pop();
      for (let s12 = t5.getParent(i4); null != s12 && (!this.layerView.isNodeLoaded(s12.index) && this._isNodeInScaleBounds(s12)); s12 = t5.getParent(s12.index))
        if (this._enableFromGPUCache(s12, c.Hole)) {
          e12.madeProgress();
          break;
        }
    }
    return e12.hasProgressed;
  }
  _processNodes(e12, t5) {
    if (null == this._index)
      return false;
    let i4 = (this._isIdle ? G4 : R3) - this._loadingNodes.size;
    const s12 = this._index.updates;
    for (s12.cancel.forEach(this._cancelNode, this), s12.cancel = []; s12.remove.length > 0 && !e12.done; )
      this.layerView.removeNode(s12.remove.pop()), e12.madeProgress();
    for (; s12.update.length > 0 && !e12.done; ) {
      const t6 = this._index.getNode(s12.update.pop());
      null != t6 && (this._updateLoadedNode(t6), e12.madeProgress());
    }
    for (; s12.add.length > 0 && !e12.done && i4 > 0; ) {
      --i4;
      const r10 = this._index.getNode(s12.add.back());
      if (null == r10 || r10.cacheState !== a7.Cached && !this._hasNodeLoadToken(t5))
        break;
      s12.add.pop(), this._loadNode(r10), e12.madeProgress();
    }
    return e12.hasProgressed;
  }
  _cancelAllNodes() {
    this._loadingNodes.forEach((e12) => e12.abort()), this._loadingNodes.clear(), this._updatingNodes.forEach((e12) => e12.abort()), this._updatingNodes.clear();
  }
  _cancelNode(e12) {
    const t5 = this._loadingNodes.get(e12);
    t5 && (t5.abort(), this._loadingNodes.delete(e12));
  }
  _hasNodeLoadToken(e12) {
    return !(!this._isIdle && e12.numNodesLoading + this._loadingNodes.size >= R3) && (this._downloadingCount < I5 && !this.dataStreamController.busy);
  }
  _evaluateUpdating() {
    let e12 = false, t5 = 0;
    if (this.layerView) {
      if (this.layerView.contentVisible) {
        const i4 = (null != this._index ? this._index.indexMissing : 0) + 3 * (null != this._index ? this._index.updates.add.length : 0) + 2 * this._loadingNodes.size;
        e12 = !!(i4 > 0 || this._updatingNodes.size > 0 || this._restartNodeLoading || this._cameraDirty || this._idleQueue.running || this._lodHandling && this._lodHandling.requiresLODGlobalHandling || null != this._index && this._index.isPrefetching), 0 === i4 && (this._progressMaxNumNodes = 1), this._progressMaxNumNodes = Math.max(i4, this._progressMaxNumNodes), t5 = 1 - i4 / this._progressMaxNumNodes;
      } else
        e12 = this._cameraDirty, t5 = e12 ? 0 : 1;
      this.updating = e12, this.updatingProgress = t5;
    }
  }
  _updateViewData() {
    if (!this._cameraDirty || null == this._index || null == this._viewportQueries)
      return;
    const e12 = this.layerView.view, { contentCamera: t5, fixedContentCamera: i4 } = e12.state;
    this.screenSizeFactor = 1 / (t5.perScreenPixelRatio / 2), this._viewportQueries.updateCamera(t5, !i4 || this.isGraphics3D), this._viewportQueries.setPointOfInterest(e12.pointsOfInterest.focus.renderLocation), this._viewportQueries.updateScreenSpaceErrorBias(this._lod), this._index.invalidateVisibilityCache(), this._index.progressiveLoadPenalty = W2.distancePenalty * this._viewportQueries.distCameraToPOI(), this._index.requestUpdate(), this._stableFeatureLOD = false, this._invisibleDirty = true, this._cameraDirty = false, this.notifyChange("rootNodeVisible");
  }
  _getProgressiveLoadFactor() {
    return this.layerView.view.quality < 1 ? 1 : this.layerView.progressiveLoadFactor;
  }
  get _lod() {
    return this._featureLOD * this._baseLOD;
  }
  get _baseLOD() {
    const e12 = this.layerView.lodFactor;
    return this.fixedFeatureTarget ? 1 : (e12 > 0 ? e12 : 1) * this.layerView.view.quality;
  }
  get _lodDropFactor() {
    if (this.fixedFeatureTarget)
      return 1;
    return (Math.min(this.layerView.view.quality, 0.5) - d4) / (0.5 - d4);
  }
  isGeometryVisible(e12) {
    var _a;
    return !!((_a = this._index) == null ? void 0 : _a.isGeometryVisible(e12.index));
  }
  updateVisibility(e12) {
    var _a;
    (_a = this._index) == null ? void 0 : _a.invalidateNodeVisibilityCache(e12);
  }
  invalidateGeometryVisibility(e12) {
    var _a;
    (_a = this._index) == null ? void 0 : _a.invalidateGeometryVisibility(e12);
  }
  invalidateVisibilityObbs() {
    var _a;
    (_a = this._index) == null ? void 0 : _a.invalidateVisibilityObbs();
  }
  modificationsChanged() {
    var _a;
    (_a = this._index) == null ? void 0 : _a.imModificationsChanged(!!this.layerView.hasModifications), this._invisibleDirty = true;
  }
  _shouldLoadNode(e12) {
    return !(!this._lodHandling.shouldLoadNode(e12) || this._shouldDropNode(e12)) && (!(null == this._index || !this._index.isGeometryVisible(e12.index)) && this._isNodeInScaleBounds(e12));
  }
  _shouldDropNode(e12) {
    if (null == this._viewportQueries)
      return false;
    const t5 = this._lodDropFactor;
    if (t5 >= 1 || !this._lodHandling.hasNoVisibleChildren(e12))
      return false;
    return Math.abs(this._viewportQueries.calcCameraDistanceToCenter(e12)) - this._viewportQueries.minDistance > (this._viewportQueries.maxDistance - this._viewportQueries.minDistance) * t5;
  }
  _startNodeLoading() {
    this._restartNodeLoading = false;
    const e12 = this._index;
    if (this._updatesDisabled || null == e12 || null == this._viewportQueries)
      return;
    this._updateViewData(), this._requiredAttributesDirty && (this._requiredAttributes = this._getRequiredAttributes(), this._requiredAttributesDirty = false);
    const t5 = { textureEncodings: this.layerView.supportedTextureEncodings, uncompressedTextureDownsamplingEnabled: this.layerView.uncompressedTextureDownsamplingEnabled, textureUsageMask: this.layerView.rendererTextureUsage, loadFeatureData: this.useMaximumNumberOfFeatures };
    this._nodeLoader = new d7(this.layer, this.dataStreamController, n2.getLogger(this), this._defaultGeometrySchema, this._requiredAttributes, t5), e12.requestUpdate(), this._lodHandling.startNodeLoading((e13) => this._isNodeInScaleBounds(e13), (e13, t6) => this._removeNodes(e13, t6, J2.fadeout), e12, { maxLodLevel: this._viewportQueries.maxLodLevel }), this._evaluateUpdating();
  }
  isNodeLoading() {
    return null != this._nodeLoader && null != this._index;
  }
  cancelNodeLoading() {
    this.isNodeLoading() && (this.indexStreamController.cancelAll(), this.dataStreamController.cancelAll(), this._idleQueue.cancelAll(), this._cancelAllNodes(), this._nodeLoader = null, this._evaluateUpdating());
  }
  _removeInvisibleNodes(e12) {
    const t5 = this._index;
    if (null == t5 || null == this._viewportQueries)
      return false;
    B2.clear(), this.layerView.getLoadedNodeIndices(B2);
    const i4 = 0 === this._viewportQueries.maxDistance, s12 = i4 ? () => false : (e13) => this._shouldDropNode(e13);
    return B2.filterInPlace((e13) => {
      const i5 = t5.getNode(e13);
      return null == i5 || !t5.isGeometryVisible(e13) || s12(i5) || !this._isNodeInScaleBounds(i5);
    }), B2.length > 0 && this._lodHandling.setLodGlobalDirty(), this._removeNodes(B2, e12, J2.pop), !(i4 && this._lodDropFactor < 1) && (0 === B2.length || (B2.clear(), false));
  }
  markNodeToRemove(e12) {
    B2.push(e12);
  }
  removeMarkedNodes() {
    this._removeNodes(B2, C2, J2.pop);
  }
  _removeNodes(e12, t5, i4) {
    const s12 = e12.length;
    if (0 !== s12 && !t5.done) {
      for (null != this._index && this._index.requestUpdate(); e12.length > 0 && !t5.done; ) {
        const s13 = e12.pop(), r10 = this._index;
        i4 === J2.fadeout && this.layerView.nodeFadeoutEnabled && null != r10 && r10.isGeometryVisible(s13) ? this.layerView.fadeNode(s13, a11.FadeOut, true) : this.layerView.removeNode(s13), t5.madeProgress();
      }
      if (this._loadedNodeScales.size > 0)
        for (let t6 = e12.length; t6 < s12; t6++) {
          const i5 = e12.data[t6];
          this._loadedNodeScales.delete(i5);
        }
    }
  }
  _needsUpdate(e12) {
    if (e12.resources.isEmpty || this._updatingNodes.has(e12.index))
      return false;
    const t5 = this.layerView.getLoadedAttributes(e12.index);
    return null != t5 && t5 !== this._requiredAttributes;
  }
  async _updateLoadedNode(e12) {
    const t5 = new AbortController();
    this._updatingNodes.set(e12.index, t5), this._evaluateUpdating();
    try {
      const i4 = $3(this.layerView.getLoadedAttributes(e12.index), this._requiredAttributes);
      let s12 = null;
      s12 = i4 ? this.layerView.getAttributeData(e12.index) : await this._loadAttributes(e12, this._requiredAttributes, t5.signal), await this.schedule(() => this.layerView.updateAttributes(e12.index, { loadedAttributes: this._requiredAttributes, attributeData: s12 }, t5.signal), t5.signal);
    } catch (i4) {
      if (!b(i4))
        return this.layerView.updateAttributes(e12.index, { loadedAttributes: this._requiredAttributes, attributeData: {} }, t5.signal);
    }
    this._updatingNodes.delete(e12.index), this._evaluateUpdating();
  }
  _loadNode(e12) {
    if (this._loadingNodes.has(e12.index))
      return void n2.getLogger(this).error("already loading node " + e12.index);
    const t5 = new AbortController();
    this._loadingNodes.set(e12.index, t5), this._evaluateUpdating(), this._loadAndAddNode(e12, t5.signal).then((i4) => {
      i4 && null != this._index && this._loadingNodes.get(e12.index) === t5 && (this._loadingNodes.delete(e12.index), this._index.requestUpdate());
    }).catch((e13) => {
      if (!b(e13))
        throw e13;
    }).finally(() => {
      this._loadingNodes.get(e12.index) === t5 && this._loadingNodes.delete(e12.index), this._evaluateUpdating();
    });
  }
  _loadAndAddNode(e12, t5) {
    return e12.cacheState === a7.Uncached ? this._loadUncached(e12, t5).then(() => false) : this._loadCached(e12, t5).then((t6) => !t6 && (e12.cacheState = a7.Uncached, true)).catch((t6) => !b(t6) && (e12.cacheState = a7.Uncached, true));
  }
  _enableFromGPUCache(e12, t5) {
    if (this._disableMemCache || null == this._index)
      return false;
    if (t5 === c.Hole && !this._index.useNodeAsHole(e12.index))
      return true;
    const i4 = this._loadCachedGPUData(e12);
    return !!i4 && (this.layerView.addCachedGPUData(e12, i4, t5), this._nodeAdded(), true);
  }
  _loadCachedGPUData(e12) {
    const t5 = this.layerView.loadCachedGPUData(e12.index);
    return null != (t5 == null ? void 0 : t5.attributeInfo) && $3(t5.attributeInfo.loadedAttributes, this._requiredAttributes) ? t5 : (this.layerView.deleteCachedGPUData(t5), null);
  }
  _nodeAdded() {
    null != this._index && this._index.requestUpdate(), this._lodHandling.setLodGlobalDirty(), this._evaluateUpdating();
  }
  updateLoadStatus(e12, t5) {
    const i4 = this._index;
    null != i4 && i4.updateChildrenLoaded(e12, t5 ? 1 : -1);
  }
  async _loadCached(e12, t5) {
    if (this._enableFromGPUCache(e12, c.Leaf))
      return true;
    const i4 = this.layerView;
    if (this.disableIDBCache || !i4.loadCachedNodeData || !i4.addCachedNodeData)
      return false;
    const s12 = (t6, i5) => this._nodeLoader.loadTextures(e12, t6, i5), r10 = (t6, i5) => this._clientNodeLoader.loadTextures(e12, t6, i5), a12 = e12.index >= 0 ? s12 : r10, d8 = await this.schedule(() => i4.loadCachedNodeData(e12, t5, a12), t5);
    if (null == d8)
      return false;
    const o6 = this._requiredAttributes, n10 = await this.reschedule(() => this._loadAttributes(e12, o6, t5), t5);
    return await this.reschedule(() => i4.addCachedNodeData(e12, d8, { loadedAttributes: o6, attributeData: n10 }, t5), t5), this._nodeAdded(), true;
  }
  _loadUncached(e12, t5) {
    return this._downloadingCount++, this._loadNodeData(e12, t5).catch((e13) => {
      throw this._downloadingCount--, e13;
    }).then((i4) => (this._downloadingCount--, this.schedule(() => this.layerView.addNode(e12, i4, t5), t5))).then(() => {
      this._nodeAdded(), e12.cacheState = a7.Cached;
    }).catch((t6) => {
      if (!b(t6))
        throw n2.getLogger(this).error("#loadNodeData()", this.layer, `Failed to load node '${e12.id}'`, t6), e12.failed = true, null != this._index && this._index.requestUpdate(), t6;
    });
  }
  _updateIdleState(e12) {
    e12 !== this._isIdle && (this._isIdle = e12, this._evaluateUpdating(), e12 && this._index && null != this._index && this._index.resetFailedNodes());
  }
  _getScale(e12) {
    if (this._loadedNodeScales.has(e12.index))
      return this._loadedNodeScales.get(e12.index);
    const t5 = this._computeScale(e12);
    return this.layerView.isNodeLoaded(e12.index) && this._loadedNodeScales.set(e12.index, t5), t5;
  }
  _computeScale(e12) {
    this._tmpPoint.x = e12.serviceMbsInIndexSR[0], this._tmpPoint.y = e12.serviceMbsInIndexSR[1], this._tmpPoint.z = e12.serviceMbsInIndexSR[2];
    const t5 = e12.serviceMbsInIndexSR[3];
    return this.layerView.view.basemapTerrain.getSphereScale(this._tmpPoint, t5);
  }
  _isNodeInScaleBounds(e12) {
    if (!this._areScaleBoundsActive)
      return true;
    const t5 = this._getScale(e12), { minScale: i4, maxScale: s12 } = c2(this.layer);
    return t4(t5, i4, s12);
  }
  get test() {
    const e12 = this;
    return { index: this._index, set disableUpdates(t5) {
      e12._updatesDisabled = t5, t5 ? e12.cancelNodeLoading() : e12.requestUpdate();
    }, set disableIDBCache(t5) {
      e12.disableIDBCache = t5;
    }, set ignoreServiceObb(t5) {
      null != e12._index && (e12._index.ignoreServiceObb = t5);
    }, shouldLoadNode: (t5) => e12._shouldLoadNode(t5), clientNodeLoader: this._clientNodeLoader };
  }
  notifyLODUpdate() {
    this._lodHandling.setLodGlobalDirty(), this._evaluateUpdating(), null != this._index && this._index.requestUpdate();
  }
  geometryFilterChanged(e12) {
    const t5 = this._index;
    null != t5 && t5.layerFilterChanged(e12), this._setCameraDirty();
  }
};
e([y({ readOnly: true })], k4.prototype, "isMeshPyramid", null), e([y({ readOnly: true })], k4.prototype, "isGraphics3D", null), e([y({ readOnly: true })], k4.prototype, "useMaximumNumberOfFeatures", null), e([y({ readOnly: true })], k4.prototype, "indexStreamController", null), e([y({ readOnly: true })], k4.prototype, "dataStreamController", null), e([y({ readOnly: true })], k4.prototype, "crsVertex", null), e([y({ readOnly: true })], k4.prototype, "crsIndex", null), e([y()], k4.prototype, "screenSizeFactor", void 0), e([y()], k4.prototype, "featureTarget", void 0), e([y()], k4.prototype, "fixedFeatureTarget", void 0), e([y()], k4.prototype, "layerView", void 0), e([y()], k4.prototype, "layer", null), e([y()], k4.prototype, "updating", void 0), e([y({ readOnly: true })], k4.prototype, "running", null), e([y()], k4.prototype, "updatingProgress", void 0), e([y({ readOnly: true })], k4.prototype, "leavesReached", void 0), e([y({ constructOnly: true })], k4.prototype, "scaleVisibilityEnabled", void 0), e([y({ constructOnly: true })], k4.prototype, "worker", void 0), e([y({ readOnly: true, dependsOn: [] })], k4.prototype, "rootNodeVisible", null), k4 = e([a3("esri.layers.graphics.controllers.I3SOnDemandController")], k4);
var B2 = new l({ deallocator: null });
var z4;
function $3(e12, t5) {
  return null != e12 && e12.length === t5.length && e12.every((e13) => K3(t5, e13.name) >= 0);
}
function K3(e12, t5) {
  const i4 = t5.toLowerCase();
  for (let s12 = 0; s12 < e12.length; s12++)
    if (e12[s12].name.toLowerCase() === i4)
      return s12;
  return -1;
}
var W2 = { factorIM: 0.2, factor3dObject: 0.05, distancePenalty: 10 };
var X3 = u4();
var J2;
!function(e12) {
  e12[e12.pop = 0] = "pop", e12[e12.fadeout = 1] = "fadeout";
}(J2 || (J2 = {}));
var Y3 = k4;

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SOverrides.js
var G5 = class extends S {
  constructor(e12) {
    super(e12), this._warnMaximumChangedObjectsExceeded = false, this._maximumNumberOfEditOVerrides = V4, this._original3DOFLDefinitionExpression = null, this._interactiveEditingSessions = new V(), this.geometryOverrides = new V(), this._clientGeometryCache = /* @__PURE__ */ new Map(), this._associatedLayerView = null, this._attributeChangedObjectIds = new s8(), this._geometryChangedObjectIds = new s8(), this._pendingFetchChangedObjectIds = null, this._pendingFetchAbortController = new AbortController(), this._featureIdLocks = /* @__PURE__ */ new Map();
  }
  initialize() {
    var _a;
    this._memCache = this.memoryController.newCache(`i3s-attribute-overrides-${this.layer.uid}`), this._pendingFetchChangedObjectIds = this._fetchChangedObjectIds((_a = this._pendingFetchAbortController) == null ? void 0 : _a.signal), this._pendingFetchChangedObjectIds.finally(() => {
      this._pendingFetchAbortController = null, this._pendingFetchChangedObjectIds = null;
    }), this.is3DOFL && null != this._associatedLayer && (a4() ? this._associatedLayer.load().then((e12) => {
      this.destroyed || (this._original3DOFLDefinitionExpression = e12.definitionExpression, this.addHandles(d(() => this._definitionExpression, (t5) => e12.definitionExpression = t5, P)), this._associatedLayerView = new c3({ layer: this._associatedLayer, view: this.view }));
    }) : r3());
  }
  destroy() {
    this.is3DOFL && null != this._associatedLayer && (a4() ? null != this._associatedLayerView && (this._associatedLayer.definitionExpression = this._original3DOFLDefinitionExpression) : r3()), this._set("layer", null), this._memCache = u(this._memCache), this._pendingFetchAbortController = e2(this._pendingFetchAbortController), this._pendingFetchChangedObjectIds = null, this._featureIdLocks.clear();
  }
  get is3DOFL() {
    var _a;
    return n7() && null != ((_a = this._associatedLayer) == null ? void 0 : _a.infoFor3D);
  }
  get sortedGeometryChangedObjectIds() {
    return this.is3DOFL ? [...this._geometryChangedObjectIds].sort((e12, t5) => e12 - t5) : [];
  }
  get _associatedLayer() {
    return null == this.layer ? null : this.layer.associatedLayer;
  }
  get hasGeometryChanges() {
    return this._geometryChangedObjectIds.size > 0;
  }
  get _definitionExpression() {
    const e12 = this.sortedGeometryChangedObjectIds;
    return 0 === e12.length ? "1 = 0" : `OBJECTID IN (${e12.join(",")})`;
  }
  get updating() {
    if (!this.is3DOFL)
      return false;
    if (this._pendingFetchChangedObjectIds)
      return true;
    if (a4()) {
      return !(null != this._associatedLayerView) || null != this._associatedLayerView && this._associatedLayerView.updating;
    }
    return false;
  }
  get isEmpty() {
    return null == this._pendingFetchChangedObjectIds && 0 === this._attributeChangedObjectIds.size && 0 === this._geometryChangedObjectIds.size;
  }
  featureHasGeometryChanges(e12) {
    return this._geometryChangedObjectIds.has(e12);
  }
  featureHasAttributeChanges(e12) {
    return this._attributeChangedObjectIds.has(e12);
  }
  createInteractiveEditSession(e12) {
    this._attributeChangedObjectIds.add(e12);
    const t5 = this._interactiveEditingSessions, i4 = new D4(e12, () => {
      t5.remove(i4);
    });
    return t5.unshift(i4), i4;
  }
  async applyAttributeOverrides(e12, t5, i4, r10 = []) {
    if (this._pendingFetchChangedObjectIds && await h(this._pendingFetchChangedObjectIds, i4), null == t5)
      return;
    const { attributeData: s12, loadedAttributes: o6 } = t5;
    if (null == o6 || null == s12 || 0 === this._attributeChangedObjectIds.size)
      return;
    const n10 = /* @__PURE__ */ new Set();
    for (const d8 of o6)
      n10.add(d8.index);
    for (const d8 of r10)
      n10.has(d8.index) || (o6.push(d8), s12[d8.name] = new Array(e12.length));
    const a12 = await this._lockFeatureIds(e12);
    try {
      const t6 = { attributeData: s12, loadedAttributes: o6 }, r11 = this._getOverridesFromCache(e12, t6, this._attributeChangedObjectIds), { objectIds: n11, fieldNames: a13 } = r11;
      if (0 === n11.length || 0 === a13.length)
        return;
      const d8 = await this._queryAttributeOverridesFromAssociatedLayer(n11, a13, i4);
      if (null == d8)
        return;
      this._processOverridesFromAssociatedLayer(e12, d8, a13, t6);
    } finally {
      a12.remove();
    }
  }
  updateGeometry(e12, t5) {
    this._geometryChangedObjectIds.add(e12);
    const i4 = this._clientGeometryCache.get(e12);
    if (null != i4 && (this.geometryOverrides.remove(i4), this._clientGeometryCache.delete(e12)), null != t5) {
      const i5 = { oid: e12, mesh: t5 };
      this.geometryOverrides.add(i5), this._clientGeometryCache.set(e12, i5);
    }
  }
  updateAttributeValue(e12, t5, i4) {
    this._attributeChangedObjectIds.add(e12), this._cacheAttributeValue(e12, t5, i4);
  }
  featureAdded(e12) {
    this.is3DOFL && r3() && this._geometryChangedObjectIds.add(e12), this._attributeChangedObjectIds.add(e12);
  }
  _cacheAttributeValue(e12, t5, i4) {
    this._memCache.put(this._getAttributeCacheKey(e12, t5), i4, this._memCacheAttributeValueSize(i4));
  }
  _getOverridesFromCache(e12, { loadedAttributes: t5, attributeData: i4 }, r10) {
    const s12 = /* @__PURE__ */ new Set(), o6 = new Array();
    for (const a12 of t5)
      o6[a12.index] = i4[a12.name];
    const n10 = /* @__PURE__ */ new Set();
    for (let a12 = 0; a12 < e12.length; a12++) {
      const i5 = e12[a12];
      if (r10.has(i5))
        for (const e13 of t5) {
          const t6 = this._attributeFromCache(i5, e13.index);
          void 0 === t6 ? (s12.add(i5), n10.add(e13.name)) : o6[e13.index][a12] = t6;
        }
    }
    return { objectIds: Array.from(s12), fieldNames: Array.from(n10) };
  }
  _attributeFromCache(e12, t5) {
    const i4 = this._fromInteractiveEditingSession(e12, t5);
    if (void 0 !== i4)
      return i4;
    const r10 = this._getAttributeCacheKey(e12, t5);
    return this._memCache.get(r10);
  }
  _fromInteractiveEditingSession(e12, t5) {
    if (null != this._interactiveEditingSessions)
      for (const i4 of this._interactiveEditingSessions) {
        if (i4.objectId !== e12)
          continue;
        const r10 = i4.getAttribute(t5);
        if (void 0 !== r10)
          return r10;
      }
  }
  _getAttributeCacheKey(e12, t5) {
    return `${e12}-${t5}`;
  }
  async _queryAttributeOverridesFromAssociatedLayer(e12, t5, i4) {
    if (0 === e12.length)
      return null;
    this._logWarningIfMaximumObjectsExceeded();
    const { associatedLayer: r10 } = this.layer;
    if (null == r10)
      return null;
    const s12 = r10.createQuery(), { objectIdField: o6 } = r10, n10 = [o6, ...t5];
    s12.where = "1=1", s12.returnGeometry = false, s12.outFields = n10, s12.cacheHint = true;
    const a12 = await this._executeBatchQuery(r10, e12, s12, i4), d8 = [];
    for (const c7 of a12)
      if (c7.ok)
        for (const e13 of c7.value.features)
          d8.push(e13);
    return d8;
  }
  async _queryGeometryOverridesFromAssociatedLayer(e12, t5) {
    if (0 === e12.length || !this.is3DOFL || !r3())
      return null;
    const i4 = this.layer.associatedLayer, r10 = i4.infoFor3D, { spatialReference: s12 } = i4, { state: { viewingMode: o6 }, spatialReference: n10 } = this.view, a12 = o6 === l2.Global, d8 = s12.isGeographic;
    if (a12 && !d8)
      return n2.getLogger(this).warn("unsupported-pcs-edits-in-global-view", this.layer.title, k5(s12, n10, this.view.viewingMode, $4.Mode)), null;
    if (!a12 && d8)
      return n2.getLogger(this).warn("unsupported-gcs-edits-in-local-view", this.layer.title, k5(s12, n10, this.view.viewingMode, $4.Mode)), null;
    if (!(G(s12, n10) || a12 && n10.isWebMercator && s12.isWGS84))
      return n2.getLogger(this).warn("unsupported-mismatched-spatial-reference-edits", this.layer.title, k5(s12, n10, this.view.viewingMode, $4.SpatialReference)), null;
    this._logWarningIfMaximumObjectsExceeded();
    const { objectIdField: c7, globalIdField: l5 } = i4, u10 = [c7, ...null != l5 ? [l5] : []], m5 = i4.createQuery();
    m5.where = "1=1", m5.returnGeometry = true, m5.outFields = u10, m5.cacheHint = true, m5.returnZ = i4.hasZ, m5.returnM = i4.hasM;
    const g6 = await this._executeBatchQuery(i4, e12, m5, t5), p5 = [];
    for (const h8 of g6) {
      if (!h8.ok)
        continue;
      const e13 = h8.value, { assetMaps: t6, features: i5, globalIdFieldName: o7 } = e13;
      if (null == t6)
        continue;
      const n11 = S2(r10, t6);
      for (const a13 of i5) {
        const e14 = h2(a13, o7, s12, r10, n11), t7 = a13;
        null != e14 ? (t7.geometry = e14, p5.push(t7)) : t7.geometry = null;
      }
    }
    return p5;
  }
  _logWarningIfMaximumObjectsExceeded() {
    if (!this._warnMaximumChangedObjectsExceeded)
      return;
    this._warnMaximumChangedObjectsExceeded = false;
    let e12 = `The number of edited objects that are not yet cached in the scene service exceeds the maximum limit. Attribute changes will only be available for the first ${u2(this._maximumNumberOfEditOVerrides)} objects. Please consider re-caching the scene service`;
    const t5 = this.layer.portalItem;
    t5 && t5.loaded ? e12 += ` (${t5.portal.url}/home/item.html?id=${t5.id}#settings)` : e12 += ` (${this.layer.parsedUrl.path})`, n2.getLogger(this).warn("#queryOverrides()", this.layer.title, `${e12}.`);
  }
  async _executeBatchQuery(e12, t5, i4, o6) {
    if (0 === t5.length)
      return [];
    const n10 = t2(e12);
    t5 = [...t5].sort((e13, t6) => e13 - t6);
    const a12 = m(t5, n10).map((t6) => {
      const r10 = i4.clone();
      return r10.objectIds = t6, b2(r5(e12, r10, { signal: o6 }));
    });
    return Promise.all(a12);
  }
  _processOverridesFromAssociatedLayer(e12, t5, i4, { loadedAttributes: r10, attributeData: s12 }) {
    const o6 = this._associatedLayer;
    if (null == o6)
      return;
    const n10 = o6.objectIdField, a12 = i4.map((t6) => (t6 in s12 || (s12[t6] = new Array(e12.length)), s12[t6])), d8 = new Map(r10.map((e13) => [e13.name, e13.index])), c7 = i4.map((e13) => d8.get(e13)), h8 = new Map(Array.from(e12, (e13, t6) => [e13, t6]));
    for (const l5 of t5) {
      const e13 = l5.attributes[n10];
      for (let t6 = 0; t6 < i4.length; t6++) {
        const r11 = c7[t6], s13 = h8.get(e13), o7 = l5.attributes[i4[t6]];
        a12[t6][s13] = o7, this._cacheAttributeValue(e13, r11, o7);
      }
    }
  }
  _memCacheAttributeValueSize(e12) {
    return "string" == typeof e12 ? r(e12) : n();
  }
  async _fetchChangedObjectIds(e12) {
    var _a, _b, _c, _d;
    const i4 = this.layer;
    await i4.load({ signal: e12 }), this._geometryChangedObjectIds.clear(), this._attributeChangedObjectIds.clear();
    const { associatedLayer: r10 } = i4;
    if (null == r10 || !((_b = (_a = r10.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsChangeTracking))
      return;
    const s12 = this._getFetchChangedObjectIdsServerGen();
    if (null == s12)
      return;
    const n10 = r10.layerId, a12 = this.is3DOFL, d8 = { f: "json", returnIdsOnly: true, layers: `[${n10}]`, returnUpdates: true, returnDeletes: a12, returnInserts: a12, layerServerGens: JSON.stringify([{ id: n10, serverGen: s12 }]) };
    if (a12) {
      const e13 = r10.infoFor3D;
      d8.fieldsToCompare = JSON.stringify({ fields: [...Object.values(e13.transformFieldRoles), e13.sourceHashField] });
    }
    const c7 = await _2(U(`${r10.url}/extractChanges`, { method: "post", query: d8, timeout: M4, signal: e12 }));
    if (!c7.ok && m2(c7.error)) {
      const e13 = this.layer.title;
      n2.getLogger(this).warn("extractChanges:timeout", e13, `${e13} could not obtain edited features that are not cached in the scene service. Display of features may not be up to date with the latest edits. Consider re-caching the scene service.`);
    }
    if (c7.ok && 1 === ((_d = (_c = c7.value.data) == null ? void 0 : _c.edits) == null ? void 0 : _d.length)) {
      const t5 = c7.value.data.edits[0], i5 = t5 == null ? void 0 : t5.objectIds, s13 = t5 == null ? void 0 : t5.fieldUpdates, o6 = (i5 == null ? void 0 : i5.adds) ?? [], n11 = (i5 == null ? void 0 : i5.updates) ?? [], d9 = (i5 == null ? void 0 : i5.deletes) ?? [], h8 = [...o6, ...n11, ...d9], l5 = a12 ? [...o6, ...s13 ?? n11, ...d9] : [], u10 = Math.min(this._maximumNumberOfEditOVerrides, h8.length);
      u10 < h8.length && (this._warnMaximumChangedObjectsExceeded = true);
      const m5 = h8.sort((e13, t6) => e13 - t6);
      for (let e13 = 0; e13 < u10; ++e13) {
        const t6 = m5[e13];
        this._attributeChangedObjectIds.add(t6);
      }
      for (const e13 of l5)
        this._geometryChangedObjectIds.add(e13);
      if (this.is3DOFL && r3() && this._geometryChangedObjectIds.size > 0) {
        const t6 = await this._queryGeometryOverridesFromAssociatedLayer(Array.from(this._geometryChangedObjectIds), e12);
        if (null != t6)
          for (const e13 of t6)
            null != e13.geometry && this.updateGeometry(e13.attributes[r10.objectIdField], e13.geometry);
      }
    }
  }
  _getFetchChangedObjectIdsServerGen() {
    var _a, _b;
    const e12 = this.layer;
    if (null != ((_a = e12.serviceUpdateTimeStamp) == null ? void 0 : _a.lastUpdate))
      return e12.serviceUpdateTimeStamp.lastUpdate;
    const t5 = e12.associatedLayer;
    return null != ((_b = t5 == null ? void 0 : t5.serverGens) == null ? void 0 : _b.minServerGen) ? t5.serverGens.minServerGen : null;
  }
  async _lockFeatureIds(e12) {
    const t5 = this._featureIdLocks;
    let i4 = true;
    for (; i4; ) {
      const r11 = new Array();
      for (const i5 of e12) {
        const e13 = t5.get(i5);
        e13 && r11.push(e13);
      }
      0 === r11.length ? i4 = false : await Promise.all(r11);
    }
    const r10 = L(), s12 = r10.promise;
    for (const o6 of e12)
      t5.set(o6, s12);
    return e3(() => {
      for (const i5 of e12)
        t5.delete(i5);
      r10.resolve();
    });
  }
  get test() {
    const e12 = Array.from(this._attributeChangedObjectIds), t5 = this._pendingFetchChangedObjectIds, i4 = this;
    return { changedObjectIds: e12, pendingFetchChangedObjectIds: t5, get maximumNumberOfEditOVerrides() {
      return i4._maximumNumberOfEditOVerrides;
    }, set maximumNumberOfEditOVerrides(e13) {
      i4._maximumNumberOfEditOVerrides = e13;
    } };
  }
};
e([y({ constructOnly: true })], G5.prototype, "view", void 0), e([y({ constructOnly: true })], G5.prototype, "layer", void 0), e([y({ readOnly: true })], G5.prototype, "is3DOFL", null), e([y()], G5.prototype, "_interactiveEditingSessions", void 0), e([y({ readOnly: true })], G5.prototype, "sortedGeometryChangedObjectIds", null), e([y({ readOnly: true })], G5.prototype, "geometryOverrides", void 0), e([y()], G5.prototype, "_clientGeometryCache", void 0), e([y()], G5.prototype, "_associatedLayer", null), e([y()], G5.prototype, "_associatedLayerView", void 0), e([y({ constructOnly: true })], G5.prototype, "memoryController", void 0), e([y()], G5.prototype, "_attributeChangedObjectIds", void 0), e([y()], G5.prototype, "_geometryChangedObjectIds", void 0), e([y()], G5.prototype, "hasGeometryChanges", null), e([y()], G5.prototype, "_pendingFetchChangedObjectIds", void 0), e([y()], G5.prototype, "_pendingFetchAbortController", void 0), e([y()], G5.prototype, "_definitionExpression", null), e([y()], G5.prototype, "updating", null), e([y()], G5.prototype, "isEmpty", null), G5 = e([a3("esri.views.3d.layers.i3s.I3SOverrides")], G5);
var D4 = class {
  constructor(e12, t5) {
    this.objectId = e12, this._remove = t5, this._updates = /* @__PURE__ */ new Map(), this._isActive = true;
  }
  getAttribute(e12) {
    return this._updates.get(e12);
  }
  setAttribute(e12, t5) {
    this.isActive && this._updates.set(e12, t5);
  }
  remove() {
    this.isActive && (this._isActive = false, this._remove());
  }
  get isActive() {
    return this._isActive;
  }
};
var M4 = 1e4;
var V4 = 5e4;
var $4;
function k5(e12, t5, i4, r10) {
  return `Displaying the edits of a SceneLayer with a${r10 === $4.Mode ? e12.isGeographic ? " geographic " : " projected " : " "}spatial reference (wkid:${e12.wkid}) in ${i4} viewing mode${r10 === $4.SpatialReference ? ` with spatial reference (wkid:${t5.wkid}) ` : " "}is not supported. No geometry edits will be displayed for this layer.
Please consider re-caching the scene service or changing the ${r10 === $4.Mode ? "viewing mode" : "view spatial reference"} to display edits.`;
}
!function(e12) {
  e12[e12.Mode = 0] = "Mode", e12[e12.SpatialReference = 1] = "SpatialReference";
}($4 || ($4 = {}));

export {
  e11 as e,
  s10 as s,
  a11 as a,
  b5 as b,
  C4 as C,
  M3 as M,
  R2 as R,
  D3 as D,
  Y3 as Y,
  G5 as G
};
//# sourceMappingURL=chunk-J3NVEAU3.js.map
