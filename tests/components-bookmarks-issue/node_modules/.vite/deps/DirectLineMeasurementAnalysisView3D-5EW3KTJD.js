import {
  e as e7,
  o as o5
} from "./chunk-RYFDUIZK.js";
import {
  e as e6
} from "./chunk-TIIBPE7N.js";
import {
  e as e5
} from "./chunk-EPOP3OQ6.js";
import {
  s as s4
} from "./chunk-W7EBFJRP.js";
import {
  _ as _3,
  f as f4,
  m,
  v
} from "./chunk-3UHI6U3P.js";
import {
  D
} from "./chunk-5SOMZZNP.js";
import "./chunk-7G5NQR7Q.js";
import "./chunk-UEYTNVS4.js";
import {
  L,
  R as R2,
  d as d2,
  h as h6,
  y as y2
} from "./chunk-NIRB3OB6.js";
import {
  p
} from "./chunk-CA3XJ2RX.js";
import {
  f as f2,
  i
} from "./chunk-JASPUPTW.js";
import "./chunk-HWBFFWYY.js";
import {
  h as h5
} from "./chunk-B473F3N3.js";
import {
  s as s3
} from "./chunk-45P2R3BJ.js";
import {
  f as f3,
  r as r6,
  t as t4
} from "./chunk-FXZUN4XG.js";
import {
  a as a3
} from "./chunk-3W2U3CD4.js";
import "./chunk-3ENNELTC.js";
import "./chunk-3FTSPLRV.js";
import {
  h as h4
} from "./chunk-HBBLDSW6.js";
import "./chunk-YYI7TRI3.js";
import "./chunk-RQW2N53A.js";
import "./chunk-LHVWC4RW.js";
import "./chunk-GN2OLKIL.js";
import "./chunk-PAH4PVZY.js";
import "./chunk-5T7MASZO.js";
import "./chunk-5WKN6K5Z.js";
import "./chunk-WCBHO6BH.js";
import "./chunk-V7NVRGBC.js";
import "./chunk-KCZGCTYM.js";
import "./chunk-3YZBQBZ5.js";
import "./chunk-RFBA77K3.js";
import "./chunk-46T3D2EU.js";
import "./chunk-RYF27IO3.js";
import "./chunk-2GT6KC2O.js";
import "./chunk-5MKTGTC4.js";
import "./chunk-7UDCRD5C.js";
import "./chunk-B3GKRGWX.js";
import "./chunk-FN7LLNVA.js";
import "./chunk-BR3PF5YD.js";
import "./chunk-QCUK7T7Y.js";
import "./chunk-2NDIVJST.js";
import {
  gt
} from "./chunk-SPYHZ6ZW.js";
import "./chunk-637XZX4A.js";
import "./chunk-PMFQ2A2V.js";
import "./chunk-HHAESKQ6.js";
import "./chunk-5INQRMFY.js";
import "./chunk-XP3ABGGF.js";
import "./chunk-TACIE3AK.js";
import "./chunk-KYKKN5I4.js";
import "./chunk-4MJOJUFR.js";
import "./chunk-BHOYA5LV.js";
import "./chunk-G4YIJOSP.js";
import {
  s as s2
} from "./chunk-PMQ5HDZI.js";
import "./chunk-KWLN46JY.js";
import "./chunk-7KNPDPFB.js";
import "./chunk-M6P775BS.js";
import "./chunk-J5F4VILS.js";
import {
  t as t3
} from "./chunk-KSBIR2KG.js";
import "./chunk-XVQGALI7.js";
import "./chunk-XFQIXBHG.js";
import "./chunk-MVSN2HAN.js";
import {
  A as A2,
  c as c4
} from "./chunk-7A5N7G2Z.js";
import "./chunk-J54I3TB7.js";
import "./chunk-OE52KVBM.js";
import "./chunk-L577YNYZ.js";
import "./chunk-GL5TSVQL.js";
import "./chunk-FD7NY4JS.js";
import "./chunk-TYYN3C37.js";
import "./chunk-OBABKQ6S.js";
import "./chunk-4GGEQMYI.js";
import "./chunk-A47N2JLN.js";
import {
  r as r3,
  r2 as r4,
  t as t2
} from "./chunk-ZPC74XHC.js";
import {
  A as A3
} from "./chunk-IVGJRGD2.js";
import "./chunk-JA2AO4PC.js";
import {
  t
} from "./chunk-MTLWPXQD.js";
import "./chunk-ZEMG7GKC.js";
import "./chunk-ECIXBYOQ.js";
import "./chunk-5MQ4HAUX.js";
import "./chunk-XIWETS2Q.js";
import "./chunk-2DATALUO.js";
import "./chunk-QFKFOAJ6.js";
import "./chunk-LOPMLCHC.js";
import "./chunk-JIR2YP6A.js";
import "./chunk-LANUNBDP.js";
import {
  r as r5
} from "./chunk-JBF6CULO.js";
import "./chunk-DRCNNCTI.js";
import "./chunk-MKOOEINB.js";
import "./chunk-JKOHBDRD.js";
import "./chunk-MDSRD3WV.js";
import {
  c2 as c3,
  h as h3,
  u2 as u3
} from "./chunk-3DFMDDMO.js";
import "./chunk-4BCSYJOQ.js";
import "./chunk-GMUCR2DJ.js";
import "./chunk-HBRJJENW.js";
import "./chunk-VHY5K2VE.js";
import "./chunk-6ENXMQPD.js";
import "./chunk-FV43HSGW.js";
import "./chunk-ZR7OV2EH.js";
import "./chunk-U76EZJUZ.js";
import {
  S as S2,
  _ as _2,
  o as o4
} from "./chunk-MEEG7XMI.js";
import {
  o as o3
} from "./chunk-LJULTBAY.js";
import "./chunk-FD4DXBZA.js";
import "./chunk-LO5UMUY4.js";
import "./chunk-YKIGDW5O.js";
import "./chunk-6MGK5WBT.js";
import "./chunk-HSOVRETF.js";
import "./chunk-CPZW2LMK.js";
import "./chunk-QR7J3YDY.js";
import "./chunk-GO2OGJDG.js";
import "./chunk-UYMREM3D.js";
import "./chunk-4YGBWYMD.js";
import "./chunk-JTUYA5FE.js";
import "./chunk-UNTQATE2.js";
import "./chunk-5YY6NZNY.js";
import "./chunk-YUWVLORR.js";
import "./chunk-7MYYCSEB.js";
import "./chunk-ESK2YRQM.js";
import "./chunk-QIEXJLRX.js";
import "./chunk-UNTPHF5R.js";
import {
  H
} from "./chunk-YJFPDMSR.js";
import "./chunk-FFG7BDAP.js";
import "./chunk-ECTYMEUP.js";
import "./chunk-QYDOVVH7.js";
import "./chunk-YSXT2SWC.js";
import "./chunk-YH3SFFF7.js";
import "./chunk-JBU54P54.js";
import "./chunk-H7T5AB2S.js";
import {
  E as E2,
  O as O2
} from "./chunk-WKVHVZW2.js";
import "./chunk-KSZESDGM.js";
import "./chunk-CHJMCUAV.js";
import "./chunk-5P74D2TG.js";
import "./chunk-33LWZO2E.js";
import "./chunk-YT66FIGM.js";
import "./chunk-3IDXRFXE.js";
import "./chunk-RLZYC2LS.js";
import "./chunk-WEER6QME.js";
import "./chunk-TXLJQAAN.js";
import "./chunk-YF5E2R37.js";
import "./chunk-R4SGP2EA.js";
import "./chunk-IRL6OOVK.js";
import {
  j as j2
} from "./chunk-3AIILHI5.js";
import "./chunk-SA77Z3WI.js";
import "./chunk-6MBDB46F.js";
import "./chunk-D56W4LPT.js";
import "./chunk-BKOYOJBG.js";
import "./chunk-7JR6S3WL.js";
import "./chunk-CJNDQ2LH.js";
import "./chunk-B4E4X2TN.js";
import "./chunk-HS6YI5DU.js";
import {
  o as o2
} from "./chunk-CDBOQCLE.js";
import "./chunk-RSRUEM5U.js";
import "./chunk-HFJMEXIX.js";
import "./chunk-VYSGSKHB.js";
import "./chunk-DGJJJ2DD.js";
import "./chunk-UAFQMHYI.js";
import "./chunk-IDPLBNJX.js";
import "./chunk-ZHAZR5C3.js";
import "./chunk-P4MNTMCZ.js";
import "./chunk-BSPKLAHD.js";
import "./chunk-GPWQGIYV.js";
import "./chunk-WZJNHZ6H.js";
import "./chunk-XMYPMIYH.js";
import "./chunk-FQLGRQKL.js";
import {
  E,
  F,
  G,
  P as P2,
  R,
  q
} from "./chunk-XGTCDM4C.js";
import "./chunk-LGMX4E7L.js";
import "./chunk-LQBHIBXV.js";
import "./chunk-42DUJ2CX.js";
import "./chunk-B35SNV2V.js";
import {
  c as c2
} from "./chunk-Z2F5OKVA.js";
import "./chunk-UQA6M3KF.js";
import {
  e as e4
} from "./chunk-GLF3KRAL.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-WIVZ7SMV.js";
import "./chunk-O76UVYOO.js";
import "./chunk-QCMUK3QA.js";
import "./chunk-HZSGATFT.js";
import "./chunk-KNMQQRV7.js";
import {
  e as e3
} from "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import {
  n as n3,
  r as r2
} from "./chunk-AKEHDP75.js";
import {
  a as a2
} from "./chunk-5MMGIT64.js";
import "./chunk-SCHTG6ZQ.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-326OSIM5.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import {
  s,
  x as x2
} from "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-WMUEII2O.js";
import "./chunk-6QNF7OHN.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import {
  c,
  h as h2
} from "./chunk-OCF7OAES.js";
import {
  O,
  _,
  e as e2,
  g,
  o,
  u as u2,
  x,
  z
} from "./chunk-JZBR4X6W.js";
import {
  n as n2
} from "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-LGQXPGTM.js";
import "./chunk-2SDMYJDE.js";
import "./chunk-C62RZQQX.js";
import {
  h
} from "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import {
  J,
  j
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import {
  f
} from "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  A,
  P,
  d
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  S,
  r2 as r,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import {
  u
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurement/DirectLineMeasurementController.js
var m2 = class extends S {
  constructor(e8) {
    super(e8);
  }
  initialize() {
    this.addHandles([d(() => ({ viewData: this.viewData, startPoint: this.analysis.startPoint }), ({ viewData: e8, startPoint: t5 }) => {
      e8.elevationAlignedStartPoint = this._applyProjectionAndElevationAlignment(t5);
    }, A), d(() => ({ viewData: this.viewData, endPoint: this.analysis.endPoint }), ({ viewData: e8, endPoint: t5 }) => {
      e8.elevationAlignedEndPoint = this._applyProjectionAndElevationAlignment(t5);
    }, A), d(() => ({ result: this._computedResult, viewData: this.viewData }), ({ result: e8, viewData: t5 }) => {
      t5.result = e8;
    }, A)]);
  }
  _applyProjectionAndElevationAlignment(e8) {
    if (null == e8)
      return e8;
    const { spatialReference: t5, elevationProvider: o6 } = this.view, r7 = r6(e8, t5, o6);
    return r7 ?? (t4(this.analysis, e8.spatialReference, n.getLogger(this)), null);
  }
  get _computedResult() {
    const { elevationAlignedStartPoint: e8, elevationAlignedEndPoint: t5, measurementMode: i2 } = this.viewData;
    if (null == e8 || null == t5)
      return null;
    const o6 = h5(e8, t5), r7 = f2(e8, t5);
    if (null == o6)
      return null;
    let s5, n4;
    switch (i2) {
      case e6.Auto:
        n4 = null != r7 ? "geodesic" : "euclidean", s5 = r7 ?? o6.horizontal;
        break;
      case e6.Geodesic:
        if (null == r7)
          return null;
        n4 = "geodesic", s5 = r7;
        break;
      case e6.Euclidean:
        n4 = "euclidean", s5 = o6.horizontal;
    }
    return { mode: n4, directDistance: o6.direct, horizontalDistance: s5, verticalDistance: o6.vertical, distance: i2 === e6.Euclidean || o6.horizontal.value <= i ? o6.direct : r7 ?? o6.horizontal };
  }
};
e([y()], m2.prototype, "view", void 0), e([y()], m2.prototype, "analysis", void 0), e([y()], m2.prototype, "viewData", void 0), e([y()], m2.prototype, "_computedResult", null), m2 = e([a("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementController")], m2);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/MeasurementArrowTechnique.js
var g2 = class _g extends r3 {
  constructor(e8, r7, t5) {
    super(e8, r7, t5);
  }
  initializeProgram(e8) {
    return new r4(e8.rctx, _g.shader.get().build(this.configuration), y3);
  }
  _setPipelineState(e8) {
    const r7 = e8 === o3.NONE, t5 = this.configuration;
    return S2({ blending: t5.transparent ? r7 ? c4 : A2(e8) : null, polygonOffset: this.configuration.polygonOffsetEnabled ? { factor: 0, units: -4 } : null, depthTest: { func: O2.LESS }, depthWrite: o4, colorWrite: _2 });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
  get primitiveType() {
    return E2.TRIANGLE_STRIP;
  }
};
g2.shader = new t2(s4, () => import("./MeasurementArrow.glsl-UL37QRIE.js"));
var T = class extends t3 {
  constructor() {
    super(...arguments), this.polygonOffsetEnabled = false, this.transparent = false, this.transparencyPassType = o3.NONE;
  }
};
e([r5()], T.prototype, "polygonOffsetEnabled", void 0), e([r5()], T.prototype, "transparent", void 0), e([r5({ count: o3.COUNT })], T.prototype, "transparencyPassType", void 0);
var y3 = /* @__PURE__ */ new Map([[e4.POSITION, 0], [e4.NORMAL, 1], [e4.UV0, 2], [e4.LENGTH, 3]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/MeasurementArrowMaterial.js
var A4 = class extends c3 {
  constructor(t5) {
    super(t5, new _4()), this._vertexAttributeLocations = y3, this.produces = /* @__PURE__ */ new Map([[A3.OPAQUE_MATERIAL, (t6) => !this._transparent && (t6 === o2.Color || t6 === o2.Alpha)], [A3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL, (t6) => this._transparent && (t6 === o2.Color || t6 === o2.Alpha)]]), this._configuration = new T();
  }
  getConfiguration(t5, e8) {
    return this._configuration.polygonOffsetEnabled = this.parameters.polygonOffset, this._configuration.transparent = this._transparent, this._configuration.transparencyPassType = e8.transparencyPassType, this._configuration;
  }
  intersect() {
  }
  createGLMaterial(t5) {
    return new O3(t5);
  }
  createBufferWriter() {
    return new j3();
  }
  get _transparent() {
    const { parameters: t5 } = this;
    return t5.outlineColor[3] < 1 || t5.stripeEvenColor[3] < 1 || t5.stripeOddColor[3] < 1;
  }
};
var O3 = class extends t {
  beginSlot(t5) {
    return this.ensureTechnique(g2, t5);
  }
};
var _4 = class extends u3 {
  constructor() {
    super(...arguments), this.width = 32, this.outlineSize = 0.2, this.outlineColor = r2(1, 0.5, 0, 1), this.stripeEvenColor = r2(1, 1, 1, 1), this.stripeOddColor = r2(1, 0.5, 0, 1), this.stripeLength = 1, this.polygonOffset = false;
  }
};
var T2 = H().vec3f(e4.POSITION).vec3f(e4.NORMAL).vec2f(e4.UV0).f32(e4.LENGTH);
var L2 = n2();
var v2 = n2();
var E3 = n2();
var I = n2();
var M = n2();
var j3 = class {
  constructor() {
    this.vertexBufferLayout = T2;
  }
  elementCount(t5) {
    return 2 * (t5.attributes.get(e4.POSITION).indices.length / 2 + 1);
  }
  write(n4, a4, c5, l, u4) {
    const { data: p4, indices: f5 } = c5.attributes.get(e4.POSITION), h7 = c5.attributes.get(e4.NORMAL).data, g3 = p4.length / 3;
    f5 && f5.length !== 2 * (g3 - 1) && console.warn("MeasurementArrowMaterial does not support indices");
    const d3 = L2, b = v2, A5 = E3, O4 = I, _5 = M, T3 = l.position, j4 = l.normal, w = l.uv0;
    let y5 = 0;
    for (let m3 = 0; m3 < g3; ++m3) {
      const c6 = 3 * m3;
      if (o(d3, p4[c6], p4[c6 + 1], p4[c6 + 2]), m3 < g3 - 1) {
        const o6 = 3 * (m3 + 1);
        o(b, p4[o6], p4[o6 + 1], p4[o6 + 2]), o(_5, h7[o6], h7[o6 + 1], h7[o6 + 2]), z(_5, _5), e2(A5, b, d3), z(A5, A5), _(O4, _5, A5), z(O4, O4);
      }
      const l2 = x(d3, b);
      n4 && a4 && (O(d3, d3, n4), O(b, b, n4), O(O4, O4, a4));
      const f6 = u4 + 2 * m3, L3 = f6 + 1;
      T3.setVec(f6, d3), T3.setVec(L3, d3), j4.setVec(f6, O4), j4.setVec(L3, O4), w.set(f6, 0, y5), w.set(f6, 1, -1), w.set(L3, 0, y5), w.set(L3, 1, 1), m3 < g3 - 1 && (y5 += l2);
    }
    const C = l.length;
    for (let t5 = 0; t5 < 2 * g3; ++t5)
      C.set(u4 + t5, y5);
  }
};

// node_modules/@arcgis/core/views/3d/interactive/visualElements/MeasurementArrowVisualElement.js
var p2 = class extends a3 {
  constructor(e8) {
    super(e8), this._arrowWidth = 16, this._arrowSubdivisions = 128, this._origin = n2(), this._originTransform = e3(), this._arrowCenter = n2(), this._renderOccluded = h3.OccludeAndTransparent, this._geometry = null, this._stripeLength = 1, this._stripesEnabled = true, this._color = n3(), this._contrastColor = n3(), this.applyProperties(e8);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e8) {
    e8 !== this._renderOccluded && (this._renderOccluded = e8, this._arrowMaterial && this._arrowMaterial.setParameters({ renderOccluded: e8 }));
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e8) {
    this._geometry = e8, this._geometryChanged();
  }
  get stripeLength() {
    return this._stripeLength;
  }
  set stripeLength(e8) {
    this._stripeLength = e8, this.attached && this._arrowMaterial.setParameters({ stripeLength: this._stripeLength });
  }
  get stripesEnabled() {
    return this._stripesEnabled;
  }
  set stripesEnabled(e8) {
    if (this._stripesEnabled = e8, this.attached) {
      const e9 = this._stripesEnabled ? this._contrastColor : this._color;
      this._arrowMaterial.setParameters({ stripeEvenColor: e9 });
    }
  }
  get color() {
    return this._color;
  }
  set color(t5) {
    P2(t5, this._color) || (a2(this._color, t5), this._updateArrowColor());
  }
  get contrastColor() {
    return this._contrastColor;
  }
  set contrastColor(t5) {
    P2(t5, this._color) || (a2(this._contrastColor, t5), this._updateArrowColor());
  }
  createExternalResources() {
    const e8 = this._color, r7 = this._contrastColor, o6 = this._stripesEnabled ? r7 : e8;
    this._arrowMaterial = new A4({ outlineColor: e8, stripeEvenColor: o6, stripeOddColor: e8, renderOccluded: this.renderOccluded, polygonOffset: true, isDecoration: this.isDecoration }), this._handles = new r(), this._handles.add(d(() => this.view.state.camera, () => {
      this._viewChanged();
    }));
  }
  destroyExternalResources() {
    this._arrowMaterial = null, this._handles = u(this._handles);
  }
  forEachExternalMaterial(e8) {
    e8(this._arrowMaterial);
  }
  createGeometries(e8) {
    var _a;
    if (null == ((_a = this._geometry) == null ? void 0 : _a.startRenderSpace) || null == this._geometry.endRenderSpace)
      return;
    const t5 = this._createArrowGeometry(this._geometry.startRenderSpace, this._geometry.endRenderSpace, this._origin, this._geometry);
    t5.transformation = this._originTransform, e8.addGeometry(t5), this._viewChanged();
  }
  _createArrowGeometry(e8, t5, r7, s5) {
    const o6 = this.view.renderCoordsHelper, a4 = [], n4 = [], h7 = (e9, t6) => {
      const s6 = c2.get();
      e2(s6, e9, r7), a4.push(s6), n4.push(t6);
    };
    if ("euclidean" === s5.type) {
      s5.eval(0.5, this._arrowCenter);
      const r8 = c2.get();
      o6.worldUpAtPosition(this._arrowCenter, r8), h7(e8, r8), h7(t5, r8);
    } else {
      s5.eval(0.5, this._arrowCenter);
      const e9 = this._arrowSubdivisions + 1 & -2;
      for (let t6 = 0; t6 < e9; ++t6) {
        const r8 = t6 / (e9 - 1), i2 = c2.get(), a5 = c2.get();
        s5.eval(r8, i2), o6.worldUpAtPosition(i2, a5), h7(i2, a5);
      }
    }
    return gt(this._arrowMaterial, a4, n4);
  }
  _geometryChanged() {
    this.recreateGeometry();
  }
  _viewChanged() {
    if (this.view.ready && this.attached && null != this._geometry) {
      const e8 = this.view.state.camera.computeScreenPixelSizeAt(this._arrowCenter);
      this._arrowMaterial.setParameters({ width: this._arrowWidth * e8 });
    }
  }
  _updateArrowColor() {
    if (!this.attached)
      return;
    const e8 = this._color, t5 = this._contrastColor, r7 = this._stripesEnabled ? t5 : e8, s5 = e8, o6 = e8;
    this._arrowMaterial.setParameters({ stripeEvenColor: r7, outlineColor: s5, stripeOddColor: o6 });
  }
};

// node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurement/DirectLineMeasurementVisualization.js
var W = class extends S {
  get _parameters() {
    const e8 = this.view.effectiveTheme, { accentColor: t5, textColor: l } = e8, a4 = E(t5), c5 = F(t5, 0.75), h7 = E(G(t5)), d3 = G(l, q.Low);
    return { accentColor: a4, contrastColor: h7, translucentAccentColor: c5, triangleLineWidth: 3, geodesicProjectionLineWidth: 2, guideLineWidth: 2, guideStippleLengthPixels: 3, directLabelFontSize: 16, horizontalLabelFontSize: 12, verticalLabelFontSize: 12, textColor: l, textBackgroundColor: R(d3, 0.6), textCalloutColor: R(d3, 0.5) };
  }
  get visible() {
    return this.analysisView.visible;
  }
  get viewMode() {
    const { elevationAlignedStartPoint: e8, elevationAlignedEndPoint: t5 } = this.analysisView;
    if (null == e8 || null == t5 || e8.equals(t5))
      return e7.None;
    const i2 = this.analysisView.result;
    if (null == i2)
      return e7.Direct;
    if ("geodesic" === this.actualVisualizedMeasurement)
      return this._requiresGeodesicGuideAt(this._startPosition) || this._requiresGeodesicGuideAt(this._endPosition) ? e7.ProjectedGeodesic : e7.Direct;
    const { verticalDistance: s5, horizontalDistance: n4 } = i2, o6 = s5.value, r7 = n4.value;
    return Math.min(o6 / r7, r7 / o6) < this.triangleCollapseRatioThreshold ? e7.Direct : e7.Triangle;
  }
  get actualVisualizedMeasurement() {
    const { measurementMode: e8, result: t5 } = this.analysisView;
    switch (e8) {
      case e6.Auto:
        return null != t5 && t5.horizontalDistance.value > i ? "geodesic" : "euclidean";
      case e6.Euclidean:
        return "euclidean";
      case e6.Geodesic:
        return "geodesic";
    }
  }
  get allowVisualElementsOrientationChange() {
    return null == this._triangleOrientationOverride;
  }
  set allowVisualElementsOrientationChange(e8) {
    null == this._triangleOrientationOverride !== e8 && (null == this._triangleOrientationOverride ? this._triangleOrientationOverride = this._actualVisualElementsOrientation : this._triangleOrientationOverride = null);
  }
  get labels() {
    return "geodesic" === this.actualVisualizedMeasurement ? { direct: null, horizontal: this._segmentLabel, vertical: this._verticalLabel } : { direct: this._segmentLabel, horizontal: this._horizontalLabel, vertical: this._verticalLabel };
  }
  constructor(e8) {
    super(e8), this._segmentVisualElement = null, this._triangleVisualElement = null, this._rightAngleQuad = null, this._projectedGeodesicLine = null, this._geodesicStartHint = null, this._geodesicEndHint = null, this._segmentLabel = null, this._verticalLabel = null, this._horizontalLabel = null, this._startPosition = n2(), this._endPosition = n2(), this._cornerPosition = n2(), this._startPositionAtSeaLevel = n2(), this._endPositionAtSeaLevel = n2(), this._triangleOrientationOverride = null, this.messages = null, this.loadingMessages = true, this.visualElementOrientation = o5.Auto, this.triangleCollapseRatioThreshold = 0.03;
  }
  initialize() {
    const e8 = this._parameters, t5 = { attached: true, view: this.view, isDecoration: true }, { guideLineWidth: i2, guideStippleLengthPixels: s5, triangleLineWidth: n4, geodesicProjectionLineWidth: o6, directLabelFontSize: r7, verticalLabelFontSize: l, horizontalLabelFontSize: a4 } = e8;
    this._segmentVisualElement = new p2({ ...t5, geometry: null, renderOccluded: h3.OccludeAndTransparent }), this._triangleVisualElement = new f3({ ...t5, width: n4, renderOccluded: h3.OccludeAndTransparent }), this._rightAngleQuad = new D({ ...t5, renderOccluded: h3.OccludeAndTransparent });
    const c5 = { ...t5, polygonOffset: true, renderOccluded: h3.OccludeAndTransparent };
    this._projectedGeodesicLine = new f3({ ...c5, width: o6, stipplePattern: h4(s5) }), this._geodesicStartHint = new f3({ ...c5, width: i2, stipplePattern: h4(s5) }), this._geodesicEndHint = new f3({ ...c5, width: i2, stipplePattern: h4(s5) }), this._segmentLabel = new f4({ ...t5, fontSize: r7 }), this._verticalLabel = new f4({ ...t5, fontSize: l }), this._horizontalLabel = new f4({ ...t5, fontSize: a4 }), this.addHandles([d(() => {
      const { elevationAlignedStartPoint: e9, elevationAlignedEndPoint: t6 } = this.analysisView, i3 = this.view;
      return { view: i3, camera: i3.state.camera, viewMode: this.viewMode, elevationAlignedStartPoint: e9, elevationAlignedEndPoint: t6, orientation: this._actualVisualElementsOrientation, visualizedMeasurement: this.actualVisualizedMeasurement, stripeLength: this._measurementArrowStripeLength };
    }, (e9) => this._updateGeometryAndViewMode(e9), A), d(() => ({ visible: this.visible, viewMode: this.viewMode }), (e9) => this._updateVisualElementVisibility(e9), A), d(() => ({ text: this._labelsText, visualizedMeasurement: this.actualVisualizedMeasurement }), (e9) => this._updateLabelText(e9), A), d(() => ({ visible: this.visible, viewMode: this.viewMode }), (e9) => this._updateLabelVisibility(e9), A), d(() => this._measurementArrowStripeLength, (e9) => this._updateSegmentStripeLength(e9), A), f(async () => this._updateMessageBundle()), d(() => this._parameters, ({ textBackgroundColor: e9, textCalloutColor: t6, textColor: i3, translucentAccentColor: s6, accentColor: n5, contrastColor: o7 }) => {
      const { _segmentLabel: r8, _verticalLabel: l2, _horizontalLabel: a5, _triangleVisualElement: c6, _rightAngleQuad: h7, _projectedGeodesicLine: d3, _geodesicStartHint: u4, _geodesicEndHint: m3, _segmentVisualElement: g3 } = this;
      r8.backgroundColor = e9, r8.calloutColor = t6, r8.textColor = i3, l2.backgroundColor = e9, l2.calloutColor = t6, l2.textColor = i3, a5.backgroundColor = e9, a5.calloutColor = t6, a5.textColor = i3, c6.color = s6, h7.color = s6, d3.color = s6, u4.color = s6, m3.color = s6, g3.color = n5, g3.contrastColor = o7;
    }, P)]), this._updateMessageBundle();
  }
  destroy() {
    this._segmentVisualElement = u(this._segmentVisualElement), this._triangleVisualElement = u(this._triangleVisualElement), this._rightAngleQuad = u(this._rightAngleQuad), this._projectedGeodesicLine = u(this._projectedGeodesicLine), this._geodesicStartHint = u(this._geodesicStartHint), this._geodesicEndHint = u(this._geodesicEndHint), this._segmentLabel = u(this._segmentLabel), this._verticalLabel = u(this._verticalLabel), this._horizontalLabel = u(this._horizontalLabel), this.set("view", null);
  }
  _updateVisualElementVisibility({ visible: e8, viewMode: t5 }) {
    if (this._segmentVisualElement.visible = false, this._triangleVisualElement.visible = false, this._rightAngleQuad.visible = false, this._projectedGeodesicLine.visible = false, this._geodesicStartHint.visible = false, this._geodesicEndHint.visible = false, e8)
      switch (t5) {
        case e7.None:
          break;
        case e7.Direct:
          this._segmentVisualElement.visible = true;
          break;
        case e7.Triangle:
          this._segmentVisualElement.visible = true, this._triangleVisualElement.visible = true, this._rightAngleQuad.visible = true;
          break;
        case e7.ProjectedGeodesic:
          this._segmentVisualElement.visible = true, this._projectedGeodesicLine.visible = true, this._geodesicStartHint.visible = true, this._geodesicEndHint.visible = true;
      }
  }
  _updateGeometryAndViewMode({ view: e8, camera: t5, viewMode: i2, elevationAlignedStartPoint: s5, elevationAlignedEndPoint: n4, orientation: o6, visualizedMeasurement: r7, stripeLength: l }) {
    const a4 = e8.renderCoordsHelper;
    if (null == a4 || null == s5 || null == n4 || s5.equals(n4))
      return;
    let c5 = this._startPosition, h7 = this._endPosition;
    a4.toRenderCoords(s5, c5), a4.toRenderCoords(n4, h7);
    const d3 = o6 === o5.AboveSegment ? 1 : -1, u4 = d3 * (a4.getAltitude(h7) - a4.getAltitude(c5));
    u4 < 0 && (c5 = this._endPosition, h7 = this._startPosition);
    const m3 = "geodesic" === r7 ? new _3(this._startPosition, this._endPosition, a4.spatialReference) : new m(this._startPosition, this._endPosition);
    switch (this._segmentVisualElement.geometry = m3, this._updateSegmentStripeLength(l), i2) {
      case e7.Direct:
        this._updateSegment(m3, o6);
        break;
      case e7.Triangle:
        this._updateSegmentAndTriangle({ view: e8, camera: t5, segment: m3, orientation: o6, startPosition: c5, endPosition: h7, deltaSign: d3, altitudeDelta: u4 });
        break;
      case e7.ProjectedGeodesic:
        this._updateSegmentAndProjection({ view: e8, orientation: o6, startPosition: c5, endPosition: h7 });
    }
  }
  _updateSegment(e8, t5) {
    this._segmentLabel.anchor = t5 === o5.AboveSegment ? "top" : "bottom", this._segmentLabel.geometry = { type: "segment", segment: e8, sampleLocation: "center" };
  }
  _updateSegmentAndTriangle({ view: { renderCoordsHelper: e8 }, camera: t5, segment: i2, orientation: s5, startPosition: n4, endPosition: o6, deltaSign: r7, altitudeDelta: l }) {
    const a4 = this._cornerPosition;
    e8.worldUpAtPosition(n4, a4), g(a4, a4, r7 * Math.abs(l)), u2(a4, a4, n4), this._triangleVisualElement.geometry = [[[n4[0], n4[1], n4[2]], [a4[0], a4[1], a4[2]], [o6[0], o6[1], o6[2]]]], this._rightAngleQuad.geometry = { previous: n4, center: a4, next: o6 };
    const c5 = new m(n4, a4), h7 = new m(a4, o6), d3 = N(n4, o6, a4, s5, t5);
    this._segmentLabel.anchor = d3.segment, this._segmentLabel.geometry = { type: "segment", segment: i2, sampleLocation: "center" }, this._verticalLabel.geometry = { type: "segment", segment: c5, sampleLocation: "center" }, this._verticalLabel.anchor = d3.vertical, this._horizontalLabel.geometry = { type: "segment", segment: h7, sampleLocation: "center" }, this._horizontalLabel.anchor = d3.horizontal;
  }
  _updateSegmentAndProjection({ view: { renderCoordsHelper: e8 }, orientation: t5, startPosition: i2, endPosition: s5 }) {
    e8.setAltitude(this._startPositionAtSeaLevel, 0, i2), e8.setAltitude(this._endPositionAtSeaLevel, 0, s5);
    const n4 = new _3(this._startPositionAtSeaLevel, this._endPositionAtSeaLevel, e8.spatialReference);
    this._projectedGeodesicLine.setGeometryFromSegment(n4), this._geodesicStartHint.setGeometryFromSegment(new m(this._startPositionAtSeaLevel, i2)), this._geodesicEndHint.setGeometryFromSegment(new m(this._endPositionAtSeaLevel, s5)), this._segmentLabel.geometry = { type: "segment", segment: n4, sampleLocation: "center" }, this._segmentLabel.anchor = t5 === o5.AboveSegment ? "top" : "bottom";
  }
  _updateLabelText({ text: e8, visualizedMeasurement: t5 }) {
    null != e8 ? (this._segmentLabel.text = "euclidean" === t5 ? e8.directDistance : e8.horizontalDistance, this._horizontalLabel.text = e8.horizontalDistance, this._verticalLabel.text = e8.verticalDistance) : (this._segmentLabel.text = null, this._horizontalLabel.text = null, this._verticalLabel.text = null), this.notifyChange("labels");
  }
  _updateLabelVisibility({ visible: e8, viewMode: t5 }) {
    const i2 = this._segmentLabel, s5 = this._horizontalLabel, n4 = this._verticalLabel;
    if (i2.visible = false, s5.visible = false, n4.visible = false, e8)
      switch (t5) {
        case e7.Direct:
          i2.visible = true;
          break;
        case e7.Triangle:
          i2.visible = true, s5.visible = true, n4.visible = true;
          break;
        case e7.ProjectedGeodesic:
          i2.visible = true;
        case e7.None:
      }
  }
  get _labelsText() {
    if (this.destroyed)
      return null;
    const e8 = this.messages, t5 = this.analysisView.result;
    if (null == t5 || null == e8)
      return null;
    const { directDistance: i2, horizontalDistance: s5, verticalDistance: n4 } = t5, o6 = this.analysisView.unit, r7 = (e9) => ({ directDistance: "", horizontalDistance: "", verticalDistance: "", ...e9 });
    switch (o6) {
      case "metric":
        return r7({ directDistance: i2 && L(e8, i2), horizontalDistance: s5 && L(e8, s5), verticalDistance: n4 && d2(e8, n4) });
      case "imperial":
        return r7({ directDistance: i2 && R2(e8, i2), horizontalDistance: s5 && R2(e8, s5), verticalDistance: n4 && y2(e8, n4) });
      default:
        return r7({ directDistance: i2 && h6(e8, i2, o6), horizontalDistance: s5 && h6(e8, s5, o6), verticalDistance: n4 && h6(e8, n4, o6) });
    }
  }
  _updateSegmentStripeLength(e8) {
    const t5 = this._segmentVisualElement;
    null != e8 ? (t5.stripeLength = e8, t5.stripesEnabled = true) : t5.stripesEnabled = false;
  }
  get _actualVisualElementsOrientation() {
    if (null != this._triangleOrientationOverride)
      return this._triangleOrientationOverride;
    const e8 = this.visualElementOrientation;
    return e8 === o5.Auto ? this.view.state.camera.aboveGround ? o5.AboveSegment : o5.BelowSegment : e8;
  }
  _requiresGeodesicGuideAt(e8) {
    const t5 = this.view;
    if (!(t5 == null ? void 0 : t5.state))
      return false;
    const i2 = t5.state.camera, s5 = t5.renderCoordsHelper;
    if (!s5)
      return false;
    const n4 = i2.computeScreenPixelSizeAt(e8);
    return s5.getAltitude(e8) / n4 >= 10;
  }
  get _measurementArrowStripeLength() {
    const { result: e8, unit: t5 } = this.analysisView;
    if (null == e8)
      return null;
    let i2 = null;
    const s5 = e8.directDistance;
    switch (t5) {
      case "metric":
        i2 = s5 && s2(s5, "meters");
        break;
      case "imperial":
        i2 = s5 && s2(s5, J(s5.value, s5.unit));
        break;
      default:
        i2 = s5 && s2(s5, t5);
    }
    if (null == i2)
      return null;
    return c(i2.value / 30) * j(1, i2.unit, "meters");
  }
  _updateMessageBundle() {
    this.loadingMessages = true, h("esri/core/t9n/Units").then((e8) => {
      this.messages = e8;
    }).finally(() => {
      this.loadingMessages = false;
    });
  }
  get testData() {
    var _a;
    return { labels: this.labels, stripeLength: (_a = this._segmentVisualElement) == null ? void 0 : _a.stripeLength };
  }
};
function N(e8, t5, i2, s5, n4) {
  const o6 = J2, r7 = K;
  n4.projectToRenderScreen(i2, o6), n4.projectToRenderScreen(t5, r7);
  const l = { segment: "bottom", horizontal: "top", vertical: o6[0] < r7[0] ? "left" : "right" };
  {
    const s6 = X, o7 = Y;
    if (p(e8, i2, n4, s6), p(e8, t5, n4, o7), j2(s6, o7) >= I2) {
      const e9 = Math.sign(s6[1]) === Math.sign(o7[1]);
      l.segment = e9 ? v(l.vertical) : l.vertical;
    } else {
      const e9 = Z;
      p(i2, t5, n4, e9), j2(e9, o7) >= I2 && (l.segment = Math.sign(e9[0]) === Math.sign(o7[0]) ? v(l.horizontal) : l.horizontal);
    }
  }
  if (s5 === o5.BelowSegment) {
    const e9 = (e10) => "top" === e10 ? "bottom" : "top";
    l.segment = e9(l.segment), l.horizontal = e9(l.horizontal), l.vertical = e9(l.vertical);
  }
  return l;
}
e([y()], W.prototype, "_parameters", null), e([y()], W.prototype, "_triangleOrientationOverride", void 0), e([y()], W.prototype, "messages", void 0), e([y()], W.prototype, "view", void 0), e([y()], W.prototype, "analysis", void 0), e([y()], W.prototype, "analysisView", void 0), e([y()], W.prototype, "loadingMessages", void 0), e([y()], W.prototype, "visible", null), e([y()], W.prototype, "viewMode", null), e([y()], W.prototype, "actualVisualizedMeasurement", null), e([y()], W.prototype, "visualElementOrientation", void 0), e([y()], W.prototype, "triangleCollapseRatioThreshold", void 0), e([y()], W.prototype, "allowVisualElementsOrientationChange", null), e([y()], W.prototype, "labels", null), e([y()], W.prototype, "_labelsText", null), e([y()], W.prototype, "_actualVisualElementsOrientation", null), e([y()], W.prototype, "_measurementArrowStripeLength", null), W = e([a("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementVisualization")], W);
var I2 = Math.cos(h2(12));
var J2 = x2();
var K = x2();
var X = s();
var Y = s();
var Z = s();

// node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurementAnalysisView3D.js
var p3 = class extends s3(S) {
  constructor(t5) {
    super(t5), this.type = "direct-line-measurement-view-3d", this.analysis = null, this.result = null, this.measurementMode = e6.Auto, this.elevationAlignedStartPoint = null, this.elevationAlignedEndPoint = null;
  }
  initialize() {
    const t5 = this.view, i2 = this.analysis;
    this._analysisVisualization = new W({ view: t5, analysis: i2, analysisView: this }), this._analysisController = new m2({ view: t5, analysis: i2, viewData: this });
  }
  destroy() {
    this._analysisController = u(this._analysisController), this._analysisVisualization = u(this._analysisVisualization);
  }
  get updating() {
    var _a;
    return !!((_a = this._analysisVisualization) == null ? void 0 : _a.loadingMessages);
  }
  get viewMode() {
    return this._analysisVisualization.viewMode;
  }
  get actualVisualizedMeasurement() {
    return this._analysisVisualization.actualVisualizedMeasurement;
  }
  get visualElementOrientation() {
    return this._analysisVisualization.visualElementOrientation;
  }
  set visualElementOrientation(t5) {
    this._analysisVisualization.visualElementOrientation = t5;
  }
  get allowVisualElementsOrientationChange() {
    return this._analysisVisualization.allowVisualElementsOrientationChange;
  }
  set allowVisualElementsOrientationChange(t5) {
    this._analysisVisualization.allowVisualElementsOrientationChange = t5;
  }
  get triangleCollapseRatioThreshold() {
    return this._analysisVisualization.triangleCollapseRatioThreshold;
  }
  set triangleCollapseRatioThreshold(t5) {
    this._analysisVisualization.triangleCollapseRatioThreshold = t5;
  }
  get directLabelText() {
    var _a;
    return ((_a = this._analysisVisualization.labels.direct) == null ? void 0 : _a.text) ?? "";
  }
  get horizontalLabelText() {
    var _a;
    return ((_a = this._analysisVisualization.labels.horizontal) == null ? void 0 : _a.text) ?? "";
  }
  get verticalLabelText() {
    var _a;
    return ((_a = this._analysisVisualization.labels.vertical) == null ? void 0 : _a.text) ?? "";
  }
  get unit() {
    return this.analysis.unit ?? this._defaultUnit;
  }
  get testData() {
    var _a;
    return this.destroyed ? { labels: null, stripeLength: null, visualization: null, controller: null } : { ...(_a = this._analysisVisualization) == null ? void 0 : _a.testData, visualization: this._analysisVisualization, controller: this._analysisController };
  }
};
e([y()], p3.prototype, "updating", null), e([y({ readOnly: true })], p3.prototype, "type", void 0), e([y({ constructOnly: true, nonNullable: true })], p3.prototype, "analysis", void 0), e([y()], p3.prototype, "result", void 0), e([y()], p3.prototype, "measurementMode", void 0), e([y()], p3.prototype, "elevationAlignedStartPoint", void 0), e([y()], p3.prototype, "elevationAlignedEndPoint", void 0), e([y({ readOnly: true })], p3.prototype, "viewMode", null), e([y({ readOnly: true })], p3.prototype, "actualVisualizedMeasurement", null), e([y()], p3.prototype, "visualElementOrientation", null), e([y()], p3.prototype, "allowVisualElementsOrientationChange", null), e([y()], p3.prototype, "triangleCollapseRatioThreshold", null), e([y({ readOnly: true })], p3.prototype, "directLabelText", null), e([y({ readOnly: true })], p3.prototype, "horizontalLabelText", null), e([y({ readOnly: true })], p3.prototype, "verticalLabelText", null), e([y()], p3.prototype, "_analysisVisualization", void 0), e([y()], p3.prototype, "_analysisController", void 0), e([y()], p3.prototype, "unit", null), e([y(e5)], p3.prototype, "_defaultUnit", void 0), p3 = e([a("esri.views.3d.analysis.DirectLineMeasurementAnalysisView3D")], p3);
var y4 = p3;
export {
  y4 as default
};
//# sourceMappingURL=DirectLineMeasurementAnalysisView3D-5EW3KTJD.js.map
