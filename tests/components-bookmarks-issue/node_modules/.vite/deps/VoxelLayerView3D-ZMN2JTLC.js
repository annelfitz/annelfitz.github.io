import {
  i as i2,
  l,
  o as o2
} from "./chunk-ANVRI6HX.js";
import {
  i
} from "./chunk-2G4FVFG2.js";
import {
  t as t2
} from "./chunk-CMLG62TA.js";
import {
  n as n4
} from "./chunk-SPU25K6A.js";
import "./chunk-P257AUOX.js";
import {
  u
} from "./chunk-NGAYW4TW.js";
import {
  t
} from "./chunk-BEXFYHUM.js";
import "./chunk-I4SHZ6P5.js";
import "./chunk-J6T3FJLS.js";
import {
  n as n3
} from "./chunk-D56W4LPT.js";
import "./chunk-BKOYOJBG.js";
import "./chunk-YBPOKK6D.js";
import "./chunk-LQBHIBXV.js";
import "./chunk-QX66UTIR.js";
import {
  P as P2,
  h
} from "./chunk-326OSIM5.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-VTH4DAHQ.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import {
  _,
  o,
  z
} from "./chunk-JZBR4X6W.js";
import {
  n as n2
} from "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  G
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  P,
  d
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/3d/layers/VoxelLayerView3D.js
var W;
!function(e2) {
  e2[e2.API = 1] = "API", e2[e2.VerboseAPI = 2] = "VerboseAPI", e2[e2.Error = 3] = "Error";
}(W || (W = {}));
var T = n2();
var x = n2();
var E = class extends i(n4(u)) {
  constructor() {
    super(...arguments), this._suspendedHandle = null, this._usedMemory = 0, this._futureMemory = 0, this.type = "voxel-3d", this.slicePlaneEnabled = false, this._wasmLayerId = -1, this.ignoresMemoryFactor = true, this._dbgFlags = /* @__PURE__ */ new Set();
  }
  get baseUrl() {
    var _a;
    return ((_a = this.layer.parsedUrl) == null ? void 0 : _a.path) ?? "";
  }
  get wasmLayerId() {
    return this._wasmLayerId;
  }
  initialize() {
    var _a;
    if (this._dbgFlags.add(W.Error), "local" !== this.view.viewingMode)
      throw new s("voxel:unsupported-viewingMode", "Voxel layers support local viewingMode only.", {});
    if (!!!((_a = this.view._stage.renderView.renderingContext.capabilities.colorBufferFloat) == null ? void 0 : _a.textureFloat))
      throw new s("voxel:missing-color-buffer-float", "Voxel layers require the WebGL2 extension EXT_color_buffer_float", {});
    const e2 = this.layer.spatialReference;
    if (!G(e2, this.view.spatialReference))
      throw new s("layerview:spatial-reference-incompatible", "The spatial reference of this scene layer is incompatible with the spatial reference of the view", {});
    const t3 = this.layer.currentVariableId, r = this.layer.getVolume(t3), o3 = this.layer.getVariable(t3);
    if (null != r && null != o3) {
      const e3 = r.dimensions[0], s2 = r.dimensions[1], t4 = r.zDimension;
      if (t4 > 1) {
        const i3 = r.dimensions[t4], a2 = e3.size * s2.size * i3.size;
        let l3 = 1;
        switch (o3.renderingFormat.type) {
          case "Int16":
          case "UInt16":
            l3 = 2;
            break;
          case "Int32":
          case "UInt32":
          case "Float32":
            l3 = 4;
        }
        this._futureMemory = l3 * a2;
      }
    }
    const l2 = l(this).then((e3) => {
      this._wasmLayerId = e3, this._suspendedHandle = d(() => this.suspended, (e4) => {
        const s2 = o2(this.view);
        s2 && s2.setEnabled(this, !e4);
      }, P), this.addHandles([d(() => this.layer.renderMode, (e4) => this._pushRenderModeToWasm(e4)), d(() => this.layer.currentVariableId, (e4) => this._pushCurrentVariableIdToWasm(e4)), d(() => this.layer.getSections(), (e4) => this._pushSectionsToWasm(e4)), d(() => this.layer.getVariableStyles(), (e4) => this._pushVariableStylesToWasm(e4)), d(() => this.layer.getVolumeStyles(), (e4) => this._pushVolumeStylesToWasm(e4)), d(() => this.layer.enableDynamicSections, (e4) => this._pushEnableDynamicSectionsToWasm(e4)), d(() => this.layer.enableIsosurfaces, (e4) => this._pushEnableIsosurfacesToWasm(e4)), d(() => this.layer.enableSections, (e4) => this._pushEnableSectionsToWasm(e4)), d(() => this.layer.enableSlices, (e4) => this._pushEnableSlicesToWasm(e4)), d(() => this.slicePlaneEnabled, (e4) => this._pushAnalysisSliceToWasm(e4, this.view.slicePlane)), d(() => this.view.slicePlane, (e4) => this._pushAnalysisSliceToWasm(this.slicePlaneEnabled, e4)), d(() => this.layer.minScale, (e4) => this._onScaleUpdated(this.view.scale, e4, this.layer.maxScale), P), d(() => this.layer.maxScale, (e4) => this._onScaleUpdated(this.view.scale, this.layer.minScale, e4), P), d(() => this.view.scale, (e4) => this._onScaleUpdated(e4, this.layer.minScale, this.layer.maxScale), P)]);
    }).catch((e3) => {
      if (i2(this), this._wasmLayerId = -1, -1 === e3)
        throw new s("voxel:addLayer-failure", "The voxel layer description was invalid.", {});
      if (-2 === e3)
        throw new s("voxel:addLayer-failure", "The voxel layer web assembly module failed to download.", {});
    });
    this.addResolvingPromise(l2);
  }
  destroy() {
    i2(this), this._suspendedHandle && (this._suspendedHandle.remove(), this._suspendedHandle = null);
  }
  isUpdating() {
    const e2 = o2(this.view);
    return !(this._wasmLayerId < 0 || null == e2) && e2.isUpdating(this._wasmLayerId);
  }
  updatingFlagChanged() {
    this.notifyChange("updating");
  }
  get usedMemory() {
    return this._usedMemory;
  }
  get unloadedMemory() {
    return this._futureMemory;
  }
  get performanceInfo() {
    return new t2(this.usedMemory);
  }
  whenGraphicBounds(e2, s2) {
    const t3 = e2.attributes["Voxel.WorldPosition"];
    if (t3) {
      const e3 = P2(), s3 = JSON.parse(t3);
      if (n3(s3, this.view.renderSpatialReference, x, this.view.spatialReference || f.WGS84))
        return h(e3, x), Promise.resolve({ boundingBox: e3, screenSpaceObjects: [] });
    }
    return Promise.reject();
  }
  setUsedMemory(e2) {
    this._usedMemory = e2, this._futureMemory = 0;
  }
  captureFrustum() {
    const e2 = o2(this.view);
    e2 == null ? void 0 : e2.captureFrustum();
  }
  toggleFullVolumeExtentDraw() {
    const e2 = o2(this.view);
    e2 == null ? void 0 : e2.toggleFullVolumeExtentDraw(this);
  }
  getLayerTimes() {
    const e2 = o2(this.view);
    return (e2 == null ? void 0 : e2.getLayerTimes(this)) ?? [];
  }
  getCurrentLayerTimeIndex() {
    const e2 = o2(this.view);
    return (e2 == null ? void 0 : e2.getCurrentLayerTimeIndex(this)) ?? 0;
  }
  _pushRenderModeToWasm(e2) {
    const s2 = o2(this.view);
    this._dbg(W.VerboseAPI, "VoxelLayerView3D._pushRenderModeToWasm() called, " + (s2 ? "have WASM" : "don't have WASM!!!")), (s2 == null ? void 0 : s2.setRenderMode(this, e2)) || this._dbg(W.Error, "VoxelLayerView3D._pushRenderModeToWasm() failed!");
  }
  _pushSectionsToWasm(e2) {
    const s2 = o2(this.view);
    this._dbg(W.VerboseAPI, "VoxelLayerView3D._pushSectionsToWasm() called, " + (s2 ? "have WASM" : "don't have WASM!!!")), (s2 == null ? void 0 : s2.setStaticSections(this, e2)) || this._dbg(W.Error, "VoxelLayerView3D._pushSectionsToWasm() failed!");
  }
  _pushCurrentVariableIdToWasm(e2) {
    const s2 = o2(this.view);
    this._dbg(W.VerboseAPI, "VoxelLayerView3D._pushCurrentVariableIdToWasm() called!, " + (s2 ? "have WASM" : "don't have WASM!!!")), (s2 == null ? void 0 : s2.setCurrentVariable(this, e2)) || this._dbg(W.Error, "VoxelLayerView3D._pushCurrentVariableIdToWasm() failed!");
  }
  _pushVariableStylesToWasm(e2) {
    const s2 = o2(this.view);
    this._dbg(W.VerboseAPI, "VoxelLayerView3D._pushVariableStylesToWasm() called, " + (s2 ? "have WASM" : "don't have WASM!!!")), (s2 == null ? void 0 : s2.setVariableStyles(this, e2)) || this._dbg(W.Error, "VoxelLayerView3D._pushVariableStylesToWasm() failed!");
  }
  _accountForEnableSlices(e2, s2) {
    const t3 = null != s2 ? s2 : this.layer.enableSlices;
    for (let i3 = 0; i3 < e2.length; ++i3) {
      const s3 = e2[i3];
      for (const e3 of s3.slices)
        e3.enabled = e3.enabled && t3;
    }
  }
  _pushVolumeStylesToWasm(e2) {
    const s2 = o2(this.view);
    this._dbg(W.VerboseAPI, "VoxelLayerView3D._pushVolumeStylesToWasm() called, " + (s2 ? "have WASM" : "don't have WASM!!!")), s2 && (this._accountForEnableSlices(e2, null), s2.setVolumeStyles(this, e2) || this._dbg(W.Error, "VoxelLayerView3D._pushVolumeStylesToWasm() failed!"));
  }
  _pushAnalysisSliceToWasm(e2, s2) {
    const t3 = o2(this.view);
    this._dbg(W.VerboseAPI, "VoxelLayerView3D._pushAnalysisSliceToWasm() called, " + (t3 ? "have WASM" : "don't have WASM!!!"));
    let i3 = false;
    if (t3) {
      if (s2) {
        const a2 = s2.origin;
        _(T, s2.basis1, s2.basis2), z(T, T), i3 = t3.setAnalysisSlice(this, e2, a2, T);
      } else
        o(T, 0, 0, 1), i3 = t3.setAnalysisSlice(this, false, T, T);
      i3 || this._dbg(W.Error, "VoxelLayerView3D._pushAnalysisSliceToWasm() failed!");
    }
  }
  _pushEnableDynamicSectionsToWasm(e2) {
    const s2 = o2(this.view);
    this._dbg(W.VerboseAPI, "VoxelLayerView3D._pushEnableDynamicSectionsToWasm() called, " + (s2 ? "have WASM" : "don't have WASM!!!")), (s2 == null ? void 0 : s2.setEnableDynamicSections(this, e2)) || this._dbg(W.Error, "VoxelLayerView3D._pushEnableDynamicSectionsToWasm() failed!");
  }
  _pushEnableSlicesToWasm(e2) {
    const s2 = o2(this.view);
    if (this._dbg(W.VerboseAPI, "VoxelLayerView3D._pushEnableSlicesToWasm() called, " + (s2 ? "have WASM" : "don't have WASM!!!")), s2) {
      const t3 = this.layer.getVolumeStyles();
      this._accountForEnableSlices(t3, e2), s2.setVolumeStyles(this, t3) || this._dbg(W.Error, "VoxelLayerView3D._pushEnableSlicesToWasm() failed!");
    }
  }
  _pushEnableIsosurfacesToWasm(e2) {
    const s2 = o2(this.view);
    this._dbg(W.VerboseAPI, "VoxelLayerView3D._pushEnableIsosurfacesToWasm() called, " + (s2 ? "have WASM" : "don't have WASM!!!")), (s2 == null ? void 0 : s2.setEnableIsosurfaces(this, e2)) || this._dbg(W.Error, "VoxelLayerView3D._pushEnableIsosurfacesToWasm() failed!");
  }
  _pushEnableSectionsToWasm(e2) {
    const s2 = o2(this.view);
    this._dbg(W.VerboseAPI, "VoxelLayerView3D._pushEnableSectionsToWasm() called, " + (s2 ? "have WASM" : "don't have WASM!!!")), (s2 == null ? void 0 : s2.setEnableSections(this, e2)) || this._dbg(W.Error, "VoxelLayerView3D._pushEnableSectionsToWasm() failed!");
  }
  _onScaleUpdated(e2, s2, t3) {
    const i3 = t(e2, s2, t3), a2 = o2(this.view);
    a2 && a2.setIsInScaleRange(this, i3);
  }
  async whenGraphicAttributes(e2, s2) {
    return e2;
  }
  _dbg(e2, s2) {
    this._dbgFlags.has(e2) && (e2 === W.Error ? n.getLogger(this).error(s2) : n.getLogger(this).warn(s2));
  }
};
e([y()], E.prototype, "layer", void 0), e([y()], E.prototype, "baseUrl", null), e([y({ type: Boolean })], E.prototype, "slicePlaneEnabled", void 0), E = e([a("esri.views.3d.layers.VoxelLayerView3D")], E);
var I = E;
export {
  I as default
};
//# sourceMappingURL=VoxelLayerView3D-ZMN2JTLC.js.map
