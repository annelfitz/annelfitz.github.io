import {
  o as o2
} from "./chunk-SCHTG6ZQ.js";
import {
  t
} from "./chunk-SBARCIDP.js";
import {
  n as n2
} from "./chunk-HTKSTTSR.js";
import {
  n as n3,
  r as r2
} from "./chunk-6IED7TER.js";
import {
  u as u3
} from "./chunk-WDPG5BMO.js";
import {
  o
} from "./chunk-TGXFDJCS.js";
import {
  m
} from "./chunk-ONK5AE7R.js";
import {
  r
} from "./chunk-VIN55KNF.js";
import {
  f,
  u2
} from "./chunk-SBL4URUW.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  T,
  a3 as a2
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  b,
  s as s2
} from "./chunk-JGDJR5EV.js";
import {
  u
} from "./chunk-QHK5ZYFW.js";
import {
  a,
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/ground/NavigationConstraint.js
var s3;
var p = s3 = class extends f {
  constructor(o3) {
    super(o3), this.type = "none";
  }
  clone() {
    return new s3({ type: this.type });
  }
};
e([o({ none: "none", stayAbove: "stay-above" })], p.prototype, "type", void 0), p = s3 = e([a2("esri.ground.NavigationConstraint")], p);

// node_modules/@arcgis/core/Ground.js
var S;
var C = S = class extends u2(m) {
  constructor(r3) {
    super(r3), this.opacity = 1, this.surfaceColor = null, this.navigationConstraint = null, this.layers = new V();
    const e2 = (r4) => {
      r4.parent && r4.parent !== this && "remove" in r4.parent && r4.parent.remove(r4), r4.parent = this, "elevation" !== r4.type && "base-elevation" !== r4.type && n.getLogger(this).error(`Layer '${r4.title}, id:${r4.id}' of type '${r4.type}' is not supported as a ground layer and will therefore be ignored. Only layers of type 'elevation' are supported.`);
    }, t2 = (r4) => {
      r4.parent = null;
    };
    this.addHandles([this.layers.on("after-add", (r4) => e2(r4.item)), this.layers.on("after-remove", (r4) => t2(r4.item))]);
  }
  initialize() {
    this.when().catch((r3) => {
      b(r3) || n.getLogger(this).error("#load()", "Failed to load ground", r3);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    const r3 = this.layers.removeAll();
    for (const e2 of r3)
      u(e2);
    this.layers.destroy();
  }
  normalizeCtorArgs(r3) {
    return r3 && "resourceInfo" in r3 && (this._set("resourceInfo", r3.resourceInfo), delete (r3 = { ...r3 }).resourceInfo), r3;
  }
  set layers(r3) {
    this._set("layers", n2(r3, this._get("layers")));
  }
  writeLayers(r3, e2, o3, t2) {
    const i = [];
    r3 ? (t2 = { ...t2, layerContainerType: "ground" }, r3.forEach((r4) => {
      if ("write" in r4) {
        const e3 = {};
        o2(r4)().write(e3, t2) && i.push(e3);
      } else
        (t2 == null ? void 0 : t2.messages) && t2.messages.push(new s("layer:unsupported", `Layers (${r4.title}, ${r4.id}) of type '${r4.declaredClass}' cannot be persisted in the ground`, { layer: r4 }));
    }), e2.layers = i) : e2.layers = i;
  }
  load(r3) {
    return this.addResolvingPromise(this._loadFromSource(r3)), Promise.resolve(this);
  }
  loadAll() {
    return t(this, (r3) => {
      r3(this.layers);
    });
  }
  async queryElevation(r3, e2) {
    await this.load({ signal: e2 == null ? void 0 : e2.signal });
    const { ElevationQuery: o3 } = await import("./ElevationQuery-AMBQNGOP.js");
    s2(e2);
    const t2 = new o3(), s4 = this.layers.filter(L).toArray();
    return t2.queryAll(s4, r3, e2);
  }
  async createElevationSampler(r3, e2) {
    await this.load({ signal: e2 == null ? void 0 : e2.signal });
    const { ElevationQuery: o3 } = await import("./ElevationQuery-AMBQNGOP.js");
    s2(e2);
    const t2 = new o3(), s4 = this.layers.filter(L).toArray();
    return t2.createSamplerAll(s4, r3, e2);
  }
  clone() {
    const r3 = { opacity: this.opacity, surfaceColor: a(this.surfaceColor), navigationConstraint: a(this.navigationConstraint), layers: this.layers.slice() };
    return this.loaded && (r3.loadStatus = "loaded"), new S({ resourceInfo: this.resourceInfo }).set(r3);
  }
  read(r3, e2) {
    this.resourceInfo || this._set("resourceInfo", { data: r3, context: e2 }), super.read(r3, e2);
  }
  _loadFromSource(r3) {
    const e2 = this.resourceInfo;
    return e2 ? this._loadLayersFromJSON(e2.data, e2.context, r3) : Promise.resolve();
  }
  async _loadLayersFromJSON(r3, e2, o3) {
    const t2 = (e2 == null ? void 0 : e2.origin) || "web-scene", s4 = (e2 == null ? void 0 : e2.portal) || null, a3 = (e2 == null ? void 0 : e2.url) || null, { populateOperationalLayers: i } = await import("./layersCreator-SR6BJJA3.js");
    s2(o3);
    const n4 = [];
    if (r3.layers && Array.isArray(r3.layers)) {
      const e3 = { context: { origin: t2, url: a3, portal: s4, layerContainerType: "ground" }, defaultLayerType: "ArcGISTiledElevationServiceLayer" };
      n4.push(i(this.layers, r3.layers, e3));
    }
    await Promise.allSettled(n4);
  }
};
function I(r3) {
  return r3 && "createElevationSampler" in r3;
}
function L(r3) {
  return "elevation" === r3.type || I(r3);
}
e([y({ json: { read: false } })], C.prototype, "layers", null), e([r("layers")], C.prototype, "writeLayers", null), e([y({ readOnly: true })], C.prototype, "resourceInfo", void 0), e([y({ type: Number, nonNullable: true, range: { min: 0, max: 1 }, json: { type: T, read: { reader: r2, source: "transparency" }, write: { writer: (r3, e2) => {
  e2.transparency = n3(r3);
}, target: "transparency" } } })], C.prototype, "opacity", void 0), e([y({ type: u3, json: { type: [T], write: (r3, e2) => {
  e2.surfaceColor = r3.toJSON().slice(0, 3);
} } })], C.prototype, "surfaceColor", void 0), e([y({ type: p, json: { write: true } })], C.prototype, "navigationConstraint", void 0), C = S = e([a2("esri.Ground")], C);
var b2 = C;

export {
  b2 as b
};
//# sourceMappingURL=chunk-7PVGO24P.js.map
