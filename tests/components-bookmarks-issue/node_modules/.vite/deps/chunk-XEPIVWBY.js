import {
  t as t2,
  u as u3
} from "./chunk-42NBQMXF.js";
import {
  t
} from "./chunk-7JNXJYRU.js";
import {
  B,
  H
} from "./chunk-2ICUS4HL.js";
import {
  m2 as m,
  u
} from "./chunk-HV6S3GY2.js";
import {
  R,
  o,
  u as u2
} from "./chunk-C7NPPGFR.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  W2 as W
} from "./chunk-UWQ3OYA5.js";
import {
  _
} from "./chunk-BVQWKK2V.js";
import {
  a,
  h
} from "./chunk-JGDJR5EV.js";
import {
  n
} from "./chunk-QHK5ZYFW.js";
import {
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/layers/support/ElevationTile.js
var t3 = class {
  constructor(t4, l2 = null) {
    if (this.tile = t4, null != l2 && null != t4) {
      const e = t4.extent;
      this._samplerData = new t2(l2, e);
    }
  }
  get zmin() {
    return null != this._samplerData ? this._samplerData.data.minValue : 0;
  }
  get zmax() {
    return null != this._samplerData ? this._samplerData.data.maxValue : 0;
  }
  get hasNoDataValues() {
    var _a;
    return !!((_a = this._samplerData) == null ? void 0 : _a.data.hasNoDataValues);
  }
  sample(a2, t4) {
    if (null == this._samplerData)
      return;
    const { safeWidth: e, data: s2, dx: r, dy: n2, y1: i, x0: u4 } = this._samplerData, { width: o2, values: m2, noDataValue: h2 } = s2, p = l(n2 * (i - t4), 0, e), D2 = l(r * (a2 - u4), 0, e), d = Math.floor(p), f = Math.floor(D2), _3 = d * o2 + f, c = _3 + o2, x3 = m2[_3], V = m2[c], g2 = m2[_3 + 1], v2 = m2[c + 1];
    if (x3 !== h2 && V !== h2 && g2 !== h2 && v2 !== h2) {
      const a3 = D2 - f, t5 = x3 + (g2 - x3) * a3;
      return t5 + (V + (v2 - V) * a3 - t5) * (p - d);
    }
  }
};
function l(a2, t4, l2) {
  return a2 < t4 ? t4 : a2 > l2 ? l2 : a2;
}

// node_modules/@arcgis/core/layers/support/ElevationQuery.js
var T = class {
  async queryAll(e, i, n2) {
    if (!(e = n2 && n2.ignoreInvisibleLayers ? e.filter((e2) => e2.visible) : e.slice()).length)
      throw new s("elevation-query:invalid-layer", "Elevation queries require at least one elevation layer to fetch tiles from");
    const o2 = w.fromGeometry(i);
    let l2 = false;
    n2 && n2.returnSampleInfo || (l2 = true);
    const s2 = { ...R2, ...n2, returnSampleInfo: true }, a2 = await this.query(e[e.length - 1], o2, s2), r = await this._queryAllContinue(e, a2, s2);
    return r.geometry = r.geometry.export(), l2 && delete r.sampleInfo, r;
  }
  async query(e, i, n2) {
    if (!e)
      throw new s("elevation-query:invalid-layer", "Elevation queries require an elevation layer to fetch tiles from");
    if (!i || !(i instanceof w) && "point" !== i.type && "multipoint" !== i.type && "polyline" !== i.type)
      throw new s("elevation-query:invalid-geometry", "Only point, polyline and multipoint geometries can be used to query elevation");
    const o2 = { ...R2, ...n2 }, l2 = new x2(e, i.spatialReference, o2), s2 = o2.signal;
    return await e.load({ signal: s2 }), await q(l2, i, s2), await this._selectTiles(l2, s2), await F(l2, s2), j(l2), b(l2, s2);
  }
  async createSampler(e, i, n2) {
    if (!e)
      throw new s("elevation-query:invalid-layer", "Elevation queries require an elevation layer to fetch tiles from");
    if (!i || "extent" !== i.type)
      throw new s("elevation-query:invalid-extent", "Invalid or undefined extent");
    const o2 = { ...R2, ...n2 };
    return this._createSampler(e, i, o2);
  }
  async createSamplerAll(e, i, n2) {
    if (!(e = n2 && n2.ignoreInvisibleLayers ? e.filter((e2) => e2.visible) : e.slice()).length)
      throw new s("elevation-query:invalid-layer", "Elevation queries require at least one elevation layer to fetch tiles from");
    if (!i || "extent" !== i.type)
      throw new s("elevation-query:invalid-extent", "Invalid or undefined extent");
    const o2 = { ...R2, ...n2, returnSampleInfo: true }, l2 = await this._createSampler(e[e.length - 1], i, o2);
    return this._createSamplerAllContinue(e, i, l2, o2);
  }
  async _createSampler(e, t4, i, n2) {
    const o2 = i.signal;
    await e.load({ signal: o2 });
    const l2 = t4.spatialReference, s2 = e.tileInfo.spatialReference;
    l2.equals(s2) || (await H([{ source: l2, dest: s2 }], { signal: o2 }), t4 = B(t4, s2));
    const a2 = new _2(e, t4, i, n2);
    return await this._selectTiles(a2, o2), await F(a2, o2), new u3(a2.elevationTiles, a2.layer.tileInfo, a2.options.noDataValue);
  }
  async _createSamplerAllContinue(e, t4, i, n2) {
    if (e.pop(), !e.length)
      return i;
    const o2 = i.samplers.filter((e2) => !e2.tile.hasNoDataValues).map((e2) => o(e2.extent)), l2 = await this._createSampler(e[e.length - 1], t4, n2, o2);
    if (0 === l2.samplers.length)
      return i;
    const s2 = i.samplers.concat(l2.samplers), a2 = new u3(s2, n2.noDataValue);
    return this._createSamplerAllContinue(e, t4, a2, n2);
  }
  async _queryAllContinue(e, t4, n2) {
    const o2 = e.pop(), l2 = t4.geometry.coordinates, s2 = t4.sampleInfo;
    n(s2);
    const a2 = [], r = [];
    for (let i = 0; i < l2.length; i++) {
      const t5 = s2[i];
      t5.demResolution >= 0 ? t5.source || (t5.source = o2) : e.length && (a2.push(l2[i]), r.push(i));
    }
    if (!e.length || 0 === a2.length)
      return t4;
    const c = t4.geometry.clone(a2), u4 = await this.query(e[e.length - 1], c, n2), h2 = u4.sampleInfo;
    if (!h2)
      throw new Error("no sampleInfo");
    return r.forEach((e2, t5) => {
      l2[e2].z = u4.geometry.coordinates[t5].z, s2[e2].demResolution = h2[t5].demResolution;
    }), this._queryAllContinue(e, t4, n2);
  }
  async _selectTiles(e, i) {
    "geometry" === e.type && I(e);
    const n2 = e.options.demResolution;
    if ("number" == typeof n2)
      C(e, n2);
    else if ("finest-contiguous" === n2)
      await this._selectTilesFinestContiguous(e, i);
    else {
      if ("auto" !== n2)
        throw new s("elevation-query:invalid-dem-resolution", `Invalid dem resolution value '${n2}', expected a number, "finest-contiguous" or "auto"`);
      await this._selectTilesAuto(e, i);
    }
  }
  async _selectTilesFinestContiguous(e, t4) {
    const { tileInfo: i, tilemapCache: n2 } = e.layer, o2 = E(i, n2, e.options.minDemResolution);
    await this._selectTilesFinestContiguousAt(e, o2, t4);
  }
  async _selectTilesFinestContiguousAt(e, i, l2) {
    const s2 = e.layer;
    if (e.selectTilesAtLOD(i), i < 0)
      return;
    const a2 = s2.tilemapCache, r = e.getTilesToFetch();
    try {
      if (a2 && !L(a2))
        await h(Promise.all(r.map((e2) => a2.fetchAvailability(e2.level, e2.row, e2.col, { signal: l2 }))), l2);
      else if (await F(e, l2), !e.allElevationTilesFetched())
        throw e.clearElevationTiles(), new s("elevation-query:has-unavailable-tiles");
    } catch (c) {
      a(c), await this._selectTilesFinestContiguousAt(e, i - 1, l2);
    }
  }
  async _selectTilesAuto(t4, i) {
    M(t4), S(t4);
    const l2 = t4.layer.tilemapCache;
    if (!l2 || L(l2))
      return this._selectTilesAutoPrefetchUpsample(t4, i);
    const s2 = t4.getTilesToFetch(), a2 = {}, r = s2.map(async (t5) => {
      const n2 = new t(null, 0, 0, 0, u2()), s3 = await _(l2.fetchAvailabilityUpsample(t5.level, t5.row, t5.col, n2, { signal: i }));
      false !== s3.ok ? null != t5.id && (a2[t5.id] = n2) : a(s3.error);
    });
    await h(Promise.all(r), i), t4.remapTiles(a2);
  }
  async _selectTilesAutoPrefetchUpsample(e, t4) {
    const i = e.layer.tileInfo;
    await F(e, t4);
    let n2 = false;
    e.forEachTileToFetch((e2, t5) => {
      i.upsampleTile(e2) ? n2 = true : t5();
    }), n2 && await this._selectTilesAutoPrefetchUpsample(e, t4);
  }
};
var w = class _w {
  export() {
    return this._exporter(this.coordinates, this.spatialReference);
  }
  clone(e) {
    const t4 = new _w();
    return t4.geometry = this.geometry, t4.spatialReference = this.spatialReference, t4.coordinates = e || this.coordinates.map((e2) => e2.clone()), t4._exporter = this._exporter, t4;
  }
  async project(e, t4) {
    if (this.spatialReference.equals(e))
      return this.clone();
    await H([{ source: this.spatialReference, dest: e }], { signal: t4 });
    const i = new u({ spatialReference: this.spatialReference, points: this.coordinates.map((e2) => [e2.x, e2.y]) }), n2 = B(i, e);
    if (!n2)
      return null;
    const o2 = this.coordinates.map((e2, t5) => {
      const i2 = e2.clone(), o3 = n2.points[t5];
      return i2.x = o3[0], i2.y = o3[1], i2;
    }), l2 = this.clone(o2);
    return l2.spatialReference = e, l2;
  }
  static fromGeometry(e) {
    const t4 = new _w();
    if (t4.geometry = e, t4.spatialReference = e.spatialReference, e instanceof _w)
      t4.coordinates = e.coordinates.map((e2) => e2.clone()), t4._exporter = (t5, i) => {
        const n2 = e.clone(t5);
        return n2.spatialReference = i, n2;
      };
    else
      switch (e.type) {
        case "point": {
          const i = e, { hasZ: n2, hasM: o2 } = i;
          t4.coordinates = n2 && o2 ? [new v(i.x, i.y, i.z, i.m)] : n2 ? [new v(i.x, i.y, i.z)] : o2 ? [new v(i.x, i.y, null, i.m)] : [new v(i.x, i.y)], t4._exporter = (t5, i2) => e.hasM ? new x(t5[0].x, t5[0].y, t5[0].z, t5[0].m, i2) : new x(t5[0].x, t5[0].y, t5[0].z, i2);
          break;
        }
        case "multipoint": {
          const i = e, { hasZ: n2, hasM: o2 } = i;
          t4.coordinates = n2 && o2 ? i.points.map((e2) => new v(e2[0], e2[1], e2[2], e2[3])) : n2 ? i.points.map((e2) => new v(e2[0], e2[1], e2[2])) : o2 ? i.points.map((e2) => new v(e2[0], e2[1], null, e2[2])) : i.points.map((e2) => new v(e2[0], e2[1])), t4._exporter = (t5, i2) => e.hasM ? new u({ points: t5.map((e2) => [e2.x, e2.y, e2.z, e2.m]), hasZ: true, hasM: true, spatialReference: i2 }) : new u(t5.map((e2) => [e2.x, e2.y, e2.z]), i2);
          break;
        }
        case "polyline": {
          const i = e, n2 = [], o2 = [], { hasZ: l2, hasM: s2 } = e;
          let a2 = 0;
          for (const e2 of i.paths)
            if (o2.push([a2, a2 + e2.length]), a2 += e2.length, l2 && s2)
              for (const t5 of e2)
                n2.push(new v(t5[0], t5[1], t5[2], t5[3]));
            else if (l2)
              for (const t5 of e2)
                n2.push(new v(t5[0], t5[1], t5[2]));
            else if (s2)
              for (const t5 of e2)
                n2.push(new v(t5[0], t5[1], null, t5[2]));
            else
              for (const t5 of e2)
                n2.push(new v(t5[0], t5[1]));
          t4.coordinates = n2, t4._exporter = (t5, i2) => {
            const n3 = e.hasM ? t5.map((e2) => [e2.x, e2.y, e2.z, e2.m]) : t5.map((e2) => [e2.x, e2.y, e2.z]), l3 = o2.map((e2) => n3.slice(e2[0], e2[1]));
            return new m({ paths: l3, hasM: e.hasM, hasZ: true, spatialReference: i2 });
          };
          break;
        }
      }
    return t4;
  }
};
var v = class _v {
  constructor(e, t4, i = null, n2 = null, o2 = null, l2 = null) {
    this.x = e, this.y = t4, this.z = i, this.m = n2, this.tile = o2, this.elevationTile = l2;
  }
  clone() {
    return new _v(this.x, this.y, this.z, this.m);
  }
};
var g = class {
  constructor(e, t4) {
    this.layer = e, this.options = t4;
  }
};
var x2 = class extends g {
  constructor(e, t4, i) {
    super(e, i), this.outSpatialReference = t4, this.type = "geometry";
  }
  selectTilesAtLOD(e) {
    if (e < 0)
      this.geometry.coordinates.forEach((e2) => e2.tile = null);
    else {
      const { tileInfo: t4, tilemapCache: i } = this.layer, n2 = D(t4, i)[e].level;
      this.geometry.coordinates.forEach((e2) => e2.tile = t4.tileAt(n2, e2.x, e2.y));
    }
  }
  allElevationTilesFetched() {
    return !this.geometry.coordinates.some((e) => !e.elevationTile);
  }
  clearElevationTiles() {
    for (const e of this.geometry.coordinates)
      e.elevationTile !== this.outsideExtentTile && (e.elevationTile = null);
  }
  populateElevationTiles(e) {
    var _a;
    for (const t4 of this.geometry.coordinates)
      !t4.elevationTile && ((_a = t4.tile) == null ? void 0 : _a.id) && (t4.elevationTile = e[t4.tile.id]);
  }
  remapTiles(e) {
    var _a;
    for (const t4 of this.geometry.coordinates) {
      const i = (_a = t4.tile) == null ? void 0 : _a.id;
      t4.tile = i ? e[i] : null;
    }
  }
  getTilesToFetch() {
    var _a;
    const e = {}, t4 = [];
    for (const i of this.geometry.coordinates) {
      const n2 = i.tile;
      if (!n2)
        continue;
      const o2 = (_a = i.tile) == null ? void 0 : _a.id;
      i.elevationTile || !o2 || e[o2] || (e[o2] = n2, t4.push(n2));
    }
    return t4;
  }
  forEachTileToFetch(e) {
    for (const t4 of this.geometry.coordinates)
      t4.tile && !t4.elevationTile && e(t4.tile, () => {
        t4.tile = null;
      });
  }
};
var _2 = class extends g {
  constructor(e, t4, i, n2) {
    super(e, i), this.type = "extent", this.elevationTiles = [], this._candidateTiles = [], this._fetchedCandidates = /* @__PURE__ */ new Set(), this.extent = t4.clone().intersection(e.fullExtent), this.maskExtents = n2;
  }
  selectTilesAtLOD(e, t4) {
    const i = this._maximumLodForRequests(t4), n2 = Math.min(i, e);
    n2 < 0 ? this._candidateTiles.length = 0 : this._selectCandidateTilesCoveringExtentAt(n2);
  }
  _maximumLodForRequests(e) {
    const { tileInfo: t4, tilemapCache: i } = this.layer, n2 = D(t4, i);
    if (!e)
      return n2.length - 1;
    const o2 = this.extent;
    if (null == o2)
      return -1;
    for (let l2 = n2.length - 1; l2 >= 0; l2--) {
      const i2 = n2[l2], s2 = i2.resolution * t4.size[0], a2 = i2.resolution * t4.size[1];
      if (Math.ceil(o2.width / s2) * Math.ceil(o2.height / a2) <= e)
        return l2;
    }
    return -1;
  }
  allElevationTilesFetched() {
    return this._candidateTiles.length === this.elevationTiles.length;
  }
  clearElevationTiles() {
    this.elevationTiles.length = 0, this._fetchedCandidates.clear();
  }
  populateElevationTiles(e) {
    for (const t4 of this._candidateTiles) {
      const i = t4.id && e[t4.id];
      i && (this._fetchedCandidates.add(t4), this.elevationTiles.push(i));
    }
  }
  remapTiles(e) {
    this._candidateTiles = z(this._candidateTiles.map((t4) => e[t4.id]));
  }
  getTilesToFetch() {
    return this._candidateTiles;
  }
  forEachTileToFetch(e, t4) {
    const i = this._candidateTiles;
    this._candidateTiles = [], i.forEach((i2) => {
      if (this._fetchedCandidates.has(i2))
        return void (t4 && t4(i2));
      let n2 = false;
      e(i2, () => n2 = true), n2 ? t4 && t4(i2) : this._candidateTiles.push(i2);
    }), this._candidateTiles = z(this._candidateTiles, t4);
  }
  _selectCandidateTilesCoveringExtentAt(e) {
    this._candidateTiles.length = 0;
    const t4 = this.extent;
    if (null == t4)
      return;
    const { tileInfo: i, tilemapCache: n2 } = this.layer, o2 = D(i, n2)[e], l2 = i.tileAt(o2.level, t4.xmin, t4.ymin), s2 = l2.extent;
    if (null == s2)
      return;
    const a2 = o2.resolution * i.size[0], r = o2.resolution * i.size[1], c = Math.ceil((t4.xmax - s2[0]) / a2), u4 = Math.ceil((t4.ymax - s2[1]) / r);
    for (let h2 = 0; h2 < u4; h2++)
      for (let e2 = 0; e2 < c; e2++) {
        const t5 = new t(null, l2.level, l2.row - h2, l2.col + e2);
        i.updateTileInfo(t5), this._tileIsMasked(t5) || this._candidateTiles.push(t5);
      }
  }
  _tileIsMasked(e) {
    return !!this.maskExtents && this.maskExtents.some((t4) => e.extent && R(t4, e.extent));
  }
};
function E(e, t4, i = 0) {
  const n2 = D(e, t4);
  let o2 = n2.length - 1;
  if (i > 0) {
    const t5 = i / W(e.spatialReference), s2 = n2.findIndex((e2) => e2.resolution < t5);
    0 === s2 ? o2 = 0 : s2 > 0 && (o2 = s2 - 1);
  }
  return o2;
}
var R2 = { maximumAutoTileRequests: 20, noDataValue: 0, returnSampleInfo: false, demResolution: "auto", minDemResolution: 0 };
async function q(e, i, n2) {
  let o2;
  const l2 = e.layer.tileInfo.spatialReference;
  if (i instanceof w ? o2 = await i.project(l2, n2) : (await H([{ source: i.spatialReference, dest: l2 }], { signal: n2 }), o2 = B(i, l2)), !o2)
    throw new s("elevation-query:spatial-reference-mismatch", `Cannot query elevation in '${i.spatialReference.wkid}' on an elevation service in '${l2.wkid}'`);
  e.geometry = w.fromGeometry(o2);
}
function I(e) {
  if (null == e.layer.fullExtent)
    return;
  const t4 = new t3(null);
  t4.sample = () => e.options.noDataValue, e.outsideExtentTile = t4;
  const i = e.layer.fullExtent;
  e.geometry.coordinates.forEach((e2) => {
    const n2 = e2.x, o2 = e2.y;
    (n2 < i.xmin || n2 > i.xmax || o2 < i.ymin || o2 > i.ymax) && (e2.elevationTile = t4);
  });
}
function A(e, t4) {
  const { tileInfo: i, tilemapCache: n2 } = e.layer, o2 = t4 / W(i.spatialReference), s2 = D(i, n2);
  let a2 = s2[0], r = 0;
  for (let l2 = 1; l2 < s2.length; l2++) {
    const e2 = s2[l2];
    Math.abs(e2.resolution - o2) < Math.abs(a2.resolution - o2) && (a2 = e2, r = l2);
  }
  return r;
}
function C(e, t4) {
  const i = A(e, t4);
  e.selectTilesAtLOD(i);
}
function M(e) {
  const { tileInfo: t4, tilemapCache: i } = e.layer, n2 = E(t4, i, e.options.minDemResolution);
  e.selectTilesAtLOD(n2, e.options.maximumAutoTileRequests);
}
function D(e, t4) {
  const i = e.lods;
  if (L(t4)) {
    const { effectiveMinLOD: e2, effectiveMaxLOD: n2 } = t4;
    return i.filter((t5) => t5.level >= e2 && t5.level <= n2);
  }
  return i;
}
async function F(e, t4) {
  const i = e.getTilesToFetch(), o2 = {}, l2 = e.options.cache, s2 = e.options.noDataValue, a2 = i.map(async (i2) => {
    if (null == i2.id)
      return;
    const n2 = `${e.layer.uid}:${i2.id}:${s2}`, a3 = null != l2 ? l2.get(n2) : null, r = null != a3 ? a3 : await e.layer.fetchTile(i2.level, i2.row, i2.col, { noDataValue: s2, signal: t4 });
    null != l2 && l2.put(n2, r), o2[i2.id] = new t3(i2, r);
  });
  await h(Promise.allSettled(a2), t4), e.populateElevationTiles(o2);
}
function S(e) {
  const t4 = e.layer.tileInfo;
  let i = 0;
  const n2 = {}, o2 = (e2) => {
    null != e2.id && (e2.id in n2 ? n2[e2.id]++ : (n2[e2.id] = 1, i++));
  }, l2 = (e2) => {
    if (null == e2.id)
      return;
    const t5 = n2[e2.id];
    1 === t5 ? (delete n2[e2.id], i--) : n2[e2.id] = t5 - 1;
  };
  e.forEachTileToFetch(o2, l2);
  let s2 = true;
  for (; s2 && (s2 = false, e.forEachTileToFetch((n3) => {
    i <= e.options.maximumAutoTileRequests || (l2(n3), t4.upsampleTile(n3) && (s2 = true), o2(n3));
  }, l2), s2); )
    ;
}
function j(e) {
  e.geometry.coordinates.forEach((t4) => {
    const i = t4.elevationTile;
    let n2 = e.options.noDataValue;
    if (i) {
      const e2 = i.sample(t4.x, t4.y);
      null != e2 ? n2 = e2 : t4.elevationTile = null;
    }
    t4.z = n2;
  });
}
function z(e, t4) {
  const i = {}, n2 = [];
  for (const l2 of e) {
    const e2 = l2.id;
    e2 && !i[e2] ? (i[e2] = l2, n2.push(l2)) : t4 && t4(l2);
  }
  const o2 = n2.sort((e2, t5) => e2.level - t5.level);
  return o2.filter((e2, i2) => {
    for (let n3 = 0; n3 < i2; n3++) {
      const i3 = o2[n3].extent;
      if (i3 && e2.extent && R(i3, e2.extent))
        return t4 && t4(e2), false;
    }
    return true;
  });
}
async function b(e, t4) {
  const n2 = await e.geometry.project(e.outSpatialReference, t4);
  n(n2);
  const o2 = { geometry: n2.export(), noDataValue: e.options.noDataValue };
  return e.options.returnSampleInfo && (o2.sampleInfo = k(e)), e.geometry.coordinates.forEach((e2) => {
    e2.tile = null, e2.elevationTile = null;
  }), o2;
}
function k(e) {
  const t4 = e.layer.tileInfo, i = W(t4.spatialReference);
  return e.geometry.coordinates.map((n2) => {
    let o2 = -1;
    if (n2.elevationTile && n2.elevationTile !== e.outsideExtentTile) {
      o2 = t4.lodAt(n2.elevationTile.tile.level).resolution * i;
    }
    return { demResolution: o2 };
  });
}
function L(e) {
  return null != (e == null ? void 0 : e.tileInfo);
}

export {
  T,
  w,
  E
};
//# sourceMappingURL=chunk-XEPIVWBY.js.map
