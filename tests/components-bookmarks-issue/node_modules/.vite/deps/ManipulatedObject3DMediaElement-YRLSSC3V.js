import {
  E2 as E
} from "./chunk-LEFES6LS.js";
import "./chunk-UXQH3C5A.js";
import {
  a as a2,
  b
} from "./chunk-3KF6TCFQ.js";
import "./chunk-ALYZBARC.js";
import "./chunk-VE57JPH4.js";
import {
  h
} from "./chunk-I4SHZ6P5.js";
import "./chunk-L52HB3KV.js";
import "./chunk-3AIILHI5.js";
import "./chunk-WZJNHZ6H.js";
import {
  c
} from "./chunk-LQBHIBXV.js";
import "./chunk-Z2F5OKVA.js";
import "./chunk-UQA6M3KF.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-HZSGATFT.js";
import "./chunk-KNMQQRV7.js";
import "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-SCHTG6ZQ.js";
import "./chunk-ZAM62XN5.js";
import "./chunk-QX66UTIR.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import {
  B,
  D,
  H
} from "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import {
  j
} from "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import {
  x as x2
} from "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-TPLOIZC7.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  A,
  C,
  P,
  d,
  v
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  l
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import "./chunk-7RBRCL6S.js";
import {
  k
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/3d/interactive/editingTools/media/MediaElementControllerControlPoints.js
var h2 = class extends S {
  get operations() {
    return this._operations;
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  constructor(e2) {
    super(e2), this._updatingHandles = new h();
  }
  initialize() {
    this.addHandles([l(this._updatingHandles), this._updatingHandles.add(() => {
      const e2 = this.element.georeference;
      return "control-points" === (e2 == null ? void 0 : e2.type) ? e2.controlPoints : null;
    }, (e2) => this._elementControlPointsChanged(e2), P)]);
  }
  _elementControlPointsChanged(e2) {
    if (this._updatedElementControlPoints === e2)
      return;
    const t2 = e2 == null ? void 0 : e2.map(({ mapPoint: e3 }) => e3).filter(k), r2 = this.view.spatialReference;
    this._updatingHandles.addPromise(this._whenProjected(t2, r2, (e3) => {
      if (!e3)
        return void this._replaceOperations(null);
      const { _operations: t3 } = this, o2 = new j({ rings: [e3.map(({ x: e4, y: t4 }) => [e4, t4])], spatialReference: r2 });
      (t3 == null ? void 0 : t3.trySetGeometry(o2)) ? this.onModifiedExternally() : this._replaceOperations(E.fromGeometry(o2, this.view.state.viewingMode));
    }));
  }
  _operationsGeometryChanged() {
    var _a;
    const { element: { georeference: e2 }, _operations: t2 } = this;
    if (!t2 || !e2 || "control-points" !== e2.type || !e2.controlPoints)
      return;
    const r2 = t2.data.geometry, n2 = e2.controlPoints.map(({ mapPoint: e3 }) => e3).filter(k);
    if (((_a = r2.rings[0]) == null ? void 0 : _a.length) !== n2.length)
      return void this._updateElementControlPoints(null);
    const i = r2.rings[0].map(([e3, t3]) => new x({ x: e3, y: t3, spatialReference: r2.spatialReference })), s = n2.map(({ spatialReference: e3 }) => e3);
    this._updatingHandles.addPromise(this._whenProjected(i, s, (e3) => this._updateElementControlPoints(e3)));
  }
  _updateElementControlPoints(e2) {
    var _a;
    const { georeference: t2 } = this.element;
    if (!t2 || !e2 || "control-points" !== t2.type || ((_a = t2.controlPoints) == null ? void 0 : _a.length) !== (e2 == null ? void 0 : e2.length))
      return;
    e2 || (t2.controlPoints = null);
    const o2 = t2.controlPoints;
    if ((o2 == null ? void 0 : o2.length) === e2.length)
      for (let r2 = 0; r2 < o2.length; r2++)
        o2[r2].mapPoint = e2[r2];
  }
  async _whenProjected(e2, t2, o2) {
    if (!e2)
      return void o2(e2);
    const { _operations: r2, element: { georeference: n2 } } = this, i = e2.map(({ spatialReference: e3 }) => e3), s = Array.isArray(t2) ? t2 : new Array(i.length).fill(t2);
    await H(Array.from(i).map((e3, t3) => ({ source: e3, dest: s[t3] })));
    const a3 = e2.map((e3, t3) => B(e3, s[t3]));
    r2 === this._operations && n2 === this.element.georeference && o2(a3);
  }
  _replaceOperations(e2) {
    this._operations && (this.removeHandles(this._operations), this._operations.destroy()), this._operations = e2, e2 && this.addHandles(e2.data.on("change", () => this._operationsGeometryChanged()), e2);
  }
};
e([y({ constructOnly: true })], h2.prototype, "view", void 0), e([y({ constructOnly: true })], h2.prototype, "layer", void 0), e([y({ constructOnly: true })], h2.prototype, "element", void 0), e([y({ constructOnly: true })], h2.prototype, "onModifiedExternally", void 0), e([y()], h2.prototype, "_operations", void 0), e([y()], h2.prototype, "operations", null), e([y()], h2.prototype, "updating", null), h2 = e([a("esri.views.3d.interactive.editingTools.media.MediaElementControllerControlPoints")], h2);

// node_modules/@arcgis/core/views/3d/interactive/editingTools/media/MediaElementControllerShape.js
var p = class extends S {
  get operations() {
    return this._operations;
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  constructor(e2) {
    super(e2), this._updatingHandles = new h();
  }
  initialize() {
    this.addHandles([l(this._updatingHandles), this._updatingHandles.add(() => {
      var _a;
      return (_a = this.element.georeference) == null ? void 0 : _a.coords;
    }, (e2) => this._elementCoordinatesChanged(e2), P)]);
  }
  _elementCoordinatesChanged(e2) {
    this._updatedElementCoordinates !== e2 && this._updatingHandles.addPromise(this._whenProjected(e2, this.view.spatialReference, (e3) => {
      if (!e3)
        return void this._replaceOperations(null);
      const { _operations: t2 } = this;
      (t2 == null ? void 0 : t2.trySetGeometry(e3)) ? this.onModifiedExternally() : this._replaceOperations(E.fromGeometry(e3, this.view.state.viewingMode));
    }));
  }
  _operationsGeometryChanged() {
    const { element: { georeference: e2 }, _operations: t2 } = this;
    if (!t2 || !e2)
      return;
    const o2 = t2.data.geometry;
    if (!e2.coords)
      return void this._updateElementCoordinates(o2);
    const r2 = e2.coords.spatialReference;
    this._updatingHandles.addPromise(this._whenProjected(o2, r2, (e3) => this._updateElementCoordinates(e3)));
  }
  _updateElementCoordinates(e2) {
    const { georeference: t2 } = this.element;
    t2 && (t2.coords = e2, this._updatedElementCoordinates = t2.coords);
  }
  async _whenProjected(e2, t2, o2) {
    if (!e2)
      return void o2(e2);
    const { _operations: r2, element: { georeference: i } } = this, s = await D(e2, t2);
    r2 === this._operations && i === this.element.georeference && o2(s);
  }
  _replaceOperations(e2) {
    this._operations && (this.removeHandles(this._operations), this._operations.destroy()), this._operations = e2, e2 && this.addHandles(e2.data.on("change", () => this._operationsGeometryChanged()), e2), this.onModifiedExternally();
  }
};
e([y({ constructOnly: true })], p.prototype, "view", void 0), e([y({ constructOnly: true })], p.prototype, "layer", void 0), e([y({ constructOnly: true })], p.prototype, "element", void 0), e([y({ constructOnly: true })], p.prototype, "onModifiedExternally", void 0), e([y()], p.prototype, "_operations", void 0), e([y()], p.prototype, "operations", null), e([y()], p.prototype, "updating", null), p = e([a("esri.views.3d.interactive.editingTools.media.MediaElementControllerShape")], p);

// node_modules/@arcgis/core/views/3d/interactive/editingTools/media/mediaElementUtils.js
function r(e2, n2, r2) {
  return t(e2.allLayerViews.find((e3) => e3.layer === n2), r2);
}
function t(r2, t2) {
  if (!r2 || "media-3d" !== r2.type || r2.suspended)
    return false;
  const s = r2.layer.source;
  return !!s && (s instanceof b || s instanceof a2 ? s === t2 : "hasElement" in s && s.hasElement(t2));
}

// node_modules/@arcgis/core/views/3d/interactive/editingTools/media/MediaElementManipulator3D.js
var m = class extends S {
  grabbableForEvent() {
    return true;
  }
  constructor(e2) {
    super(e2), this.interactive = true, this.selectable = false, this.grabbable = true, this.grabbing = false, this.dragging = false, this.hovering = true, this.selected = false, this.cursor = null, this.consumesClicks = true, this.events = new o.EventEmitter(), this.addHandles(d(() => this.selected, (e3) => this.events.emit("select-changed", { action: e3 ? "select" : "deselect" }), C));
  }
  destroy() {
    this._set("view", null);
  }
  intersectionDistance(e2) {
    const { view: t2, layer: o2, element: r2 } = this;
    if (!r(t2, o2, r2))
      return null;
    const s = t2.toMap(e2, { include: { layer: o2, element: r2 } });
    return s && c(s, d2, t2.renderSpatialReference) ? x2(d2, t2.state.camera.eye) : null;
  }
  onElevationChange() {
  }
  onViewChange() {
  }
};
e([y({ constructOnly: true, nonNullable: true })], m.prototype, "element", void 0), e([y({ constructOnly: true, nonNullable: true })], m.prototype, "layer", void 0), e([y({ constructOnly: true, nonNullable: true })], m.prototype, "view", void 0), e([y()], m.prototype, "interactive", void 0), e([y()], m.prototype, "selectable", void 0), e([y()], m.prototype, "grabbable", void 0), e([y()], m.prototype, "grabbing", void 0), e([y()], m.prototype, "dragging", void 0), e([y()], m.prototype, "hovering", void 0), e([y()], m.prototype, "selected", void 0), e([y()], m.prototype, "cursor", void 0), m = e([a("esri.views.3d.interactive.editingTools.media.MediaElementManipulator3D")], m);
var d2 = n();

// node_modules/@arcgis/core/views/3d/interactive/editingTools/ManipulatedObject3DMediaElement.js
var d3 = Symbol();
var u = class extends o.EventedAccessor {
  get operations() {
    var _a;
    return (_a = this._controller) == null ? void 0 : _a.operations;
  }
  get elevationInfo() {
    return { mode: "on-the-ground", offset: 0 };
  }
  get _layerView() {
    const e2 = this.view.allLayerViews.find((e3) => e3.layer === this.layer);
    return "media-3d" === (e2 == null ? void 0 : e2.type) ? e2 : null;
  }
  get visible() {
    return t(this._layerView, this.element);
  }
  get isDraped() {
    return true;
  }
  get origin() {
    return null;
  }
  get updating() {
    var _a;
    return !!((_a = this._controller) == null ? void 0 : _a.updating);
  }
  get _controllerClass() {
    var _a;
    return "transform" === this.tool || "control-points" !== ((_a = this.element.georeference) == null ? void 0 : _a.type) ? p : h2;
  }
  constructor(e2) {
    super(e2), this.tool = "transform";
  }
  initialize() {
    this.addHandles([d(() => this._controllerClass, (e2) => this._updateController(e2), A), v(() => this._layerView, "element-render-changed", ({ element: e2 }) => {
      this.element === e2 && this.emit("committed");
    })]);
  }
  toMap(e2) {
    const { layer: t2, element: o2 } = this;
    return this.view.toMap(e2, { include: { layer: t2, element: o2 } });
  }
  createManipulator(e2) {
    const { view: t2, layer: o2, element: r2 } = this;
    return new m({ view: t2, layer: o2, element: r2, ...e2 });
  }
  _updateController(e2) {
    if (this._controller && this._controller instanceof e2)
      return;
    this.removeHandles(d3);
    const { view: t2, layer: r2, element: i } = this, l2 = () => {
      this.emit("modified-externally");
    };
    this._controller = new e2({ view: t2, layer: r2, element: i, onModifiedExternally: l2 }), l2(), this.addHandles(l(this._controller), d3);
  }
};
e([y({ constructOnly: true })], u.prototype, "view", void 0), e([y({ constructOnly: true })], u.prototype, "layer", void 0), e([y({ constructOnly: true })], u.prototype, "element", void 0), e([y()], u.prototype, "tool", void 0), e([y()], u.prototype, "_controller", void 0), e([y()], u.prototype, "elevationInfo", null), e([y()], u.prototype, "_layerView", null), e([y()], u.prototype, "visible", null), e([y()], u.prototype, "updating", null), e([y()], u.prototype, "_controllerClass", null), u = e([a("esri.views.3d.interactive.editingTools.ManipulatedObject3DMediaElement")], u);
export {
  u as ManipulatedObject3DMediaElement
};
//# sourceMappingURL=ManipulatedObject3DMediaElement-YRLSSC3V.js.map
