import {
  n as n2,
  p
} from "./chunk-5T2QNVDA.js";
import {
  Q
} from "./chunk-UMXV3EBO.js";
import {
  d,
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  n2 as n,
  r,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/widgets/support/geolocationUtils.js
var u = () => n.getLogger("esri.widgets.support.geolocationUtils");
var a = { maximumAge: 0, timeout: 15e3, enableHighAccuracy: true };
function m() {
  const e = has("esri-geolocation");
  return e || u().warn("geolocation-unsupported", "Geolocation unsupported."), e;
}
function l() {
  const e = window.isSecureContext;
  return e || u().warn("insecure-context", "Geolocation requires a secure origin."), e;
}
function g() {
  return m() && l();
}
function p2(e) {
  const o = 15e3;
  return e || (e = a), new Promise((r2, i) => {
    setTimeout(() => i(new s("geolocation:timeout", "getting the current geolocation position timed out")), o), navigator.geolocation.getCurrentPosition(r2, i, e ?? void 0);
  });
}
var d2;
function f(e, o) {
  if (d2)
    return d2(e, o);
  const { position: r2, view: i } = e, n3 = v(r2), c = n3 == null ? void 0 : n3.coords;
  if (!c)
    throw new s("geometry-service:no-coords", "Geolocation has no coordinates");
  return h(y(c), i, o);
}
function v(e) {
  const t = e && e.coords || {}, o = { accuracy: t.accuracy, altitude: t.altitude, altitudeAccuracy: t.altitudeAccuracy, heading: t.heading, latitude: t.latitude, longitude: t.longitude, speed: t.speed };
  return e ? { coords: o, timestamp: e.timestamp } : e;
}
function y({ longitude: e, latitude: t, altitude: o }) {
  return new x({ longitude: e, latitude: t, z: o || void 0, spatialReference: { wkid: 4326 } });
}
function h(e, o, r2) {
  if (!o)
    return Promise.resolve(e);
  const n3 = o.spatialReference;
  return n3.isWGS84 ? Promise.resolve(e) : n3.isWebMercator ? Promise.resolve(d(e)) : j(r2).then((o2) => {
    if (!o2)
      throw new s("geometry-service:missing-url", "Geometry service URL is missing");
    const i = new p({ geometries: [e], outSpatialReference: n3 });
    return n2(o2, i, r2).then((e2) => e2[0]);
  });
}
function j(t) {
  if (r.geometryServiceUrl)
    return Promise.resolve(r.geometryServiceUrl);
  const o = Q.getDefault();
  return o.load(t).catch(() => {
  }).then(() => {
    var _a, _b;
    return (_b = (_a = o.helperServices) == null ? void 0 : _a.geometry) == null ? void 0 : _b.url;
  });
}

export {
  g,
  p2 as p,
  f
};
//# sourceMappingURL=chunk-RIBUBPHP.js.map
