import {
  c as c3
} from "./chunk-HGJYELD4.js";
import {
  v,
  z
} from "./chunk-MP3BMLR3.js";
import {
  c as c2
} from "./chunk-ARNGZTAW.js";
import "./chunk-OOISODT4.js";
import "./chunk-KCZGCTYM.js";
import {
  G,
  e as e2,
  i
} from "./chunk-46T3D2EU.js";
import "./chunk-RYF27IO3.js";
import "./chunk-KWLN46JY.js";
import {
  o
} from "./chunk-7W5MWPC6.js";
import {
  c
} from "./chunk-GL5TSVQL.js";
import {
  A
} from "./chunk-IVGJRGD2.js";
import "./chunk-FD4DXBZA.js";
import {
  g2 as g,
  j
} from "./chunk-ESK2YRQM.js";
import "./chunk-YH3SFFF7.js";
import {
  I,
  N,
  O
} from "./chunk-WKVHVZW2.js";
import "./chunk-3IDXRFXE.js";
import "./chunk-D56W4LPT.js";
import "./chunk-BKOYOJBG.js";
import "./chunk-CDBOQCLE.js";
import "./chunk-GPWQGIYV.js";
import {
  l
} from "./chunk-WZJNHZ6H.js";
import "./chunk-XMYPMIYH.js";
import "./chunk-FQLGRQKL.js";
import "./chunk-LQBHIBXV.js";
import "./chunk-42DUJ2CX.js";
import "./chunk-B35SNV2V.js";
import "./chunk-Z2F5OKVA.js";
import "./chunk-UQA6M3KF.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-WIVZ7SMV.js";
import "./chunk-O76UVYOO.js";
import "./chunk-QCMUK3QA.js";
import "./chunk-HZSGATFT.js";
import "./chunk-KNMQQRV7.js";
import "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import {
  f
} from "./chunk-QYC3GV65.js";
import "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-QX66UTIR.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import {
  x
} from "./chunk-JZBR4X6W.js";
import {
  n as n3
} from "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import {
  n as n2
} from "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import {
  U
} from "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  P,
  d
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  b
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";
import {
  has
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/libs/vxl/enums.js
var e3;
var i2;
var t;
var n4;
var a2;
var o2;
!function(e5) {
  e5[e5.Binary = 0] = "Binary", e5[e5.JSON = 1] = "JSON";
}(e3 || (e3 = {})), function(e5) {
  e5[e5.TreeIndex = 0] = "TreeIndex", e5[e5.TreeStats = 1] = "TreeStats", e5[e5.TreeData = 2] = "TreeData", e5[e5.BrickBundles = 3] = "BrickBundles", e5[e5.Section = 4] = "Section", e5[e5.VariableStats = 5] = "VariableStats";
}(i2 || (i2 = {})), function(e5) {
  e5[e5.None = 1] = "None", e5[e5.Front = 2] = "Front", e5[e5.Back = 3] = "Back";
}(t || (t = {})), function(e5) {
  e5[e5.Low = 0] = "Low", e5[e5.Medium = 1] = "Medium", e5[e5.High = 2] = "High";
}(n4 || (n4 = {})), function(e5) {
  e5[e5.None = 0] = "None", e5[e5.StaticSections = 1] = "StaticSections", e5[e5.Slices = 2] = "Slices", e5[e5.DynamicSections = 4] = "DynamicSections", e5[e5.GhostShell = 8] = "GhostShell", e5[e5.Isosurface = 16] = "Isosurface", e5[e5.Quality = 32] = "Quality", e5[e5.SunLocation = 64] = "SunLocation", e5[e5.StaticSectionSelection = 128] = "StaticSectionSelection", e5[e5.ExaggerationAndOffset = 256] = "ExaggerationAndOffset", e5[e5.CurrentTime = 512] = "CurrentTime", e5[e5.CurrentVariable = 1024] = "CurrentVariable", e5[e5.DeleteIsosurface = 2048] = "DeleteIsosurface", e5[e5.ContainerVisibility = 4096] = "ContainerVisibility", e5[e5.RenderMode = 8192] = "RenderMode", e5[e5.Optimization = 16384] = "Optimization", e5[e5.VariableStyles = 32768] = "VariableStyles", e5[e5.VolumeStyles = 65536] = "VolumeStyles", e5[e5.AnalysisSlice = 131072] = "AnalysisSlice";
}(a2 || (a2 = {})), function(e5) {
  e5[e5.Isosurfaces = 0] = "Isosurfaces", e5[e5.DynamicSections = 1] = "DynamicSections", e5[e5.StaticSections = 2] = "StaticSections";
}(o2 || (o2 = {}));

// node_modules/@arcgis/core/libs/vxl/VxlModule.js
function e4(t2) {
  return new Promise((e5) => import("./vxlLayer-XXXCWS2Z.js").then((t3) => t3.v).then(({ default: n5 }) => {
    const r = n5({ locateFile: i3, preinitializedWebGLContext: t2, onRuntimeInitialized: () => e5(r) });
  })).catch((t3) => {
    throw t3;
  });
}
function i3(e5) {
  return n2(`esri/libs/vxl/${e5}`);
}

// node_modules/@arcgis/core/layers/VoxelWasmPerSceneView.js
var I2;
!function(e5) {
  e5[e5.Lifetime = 1] = "Lifetime", e5[e5.RequestResponse = 2] = "RequestResponse", e5[e5.Rendering = 3] = "Rendering", e5[e5.Error = 4] = "Error";
}(I2 || (I2 = {}));
var U2 = class extends c {
  constructor(e5) {
    super(e5), this._halfIntTexturesAvailable = false, this._textureFloatLinearAvailable = false, this._havePreparedWithAllLayers = false, this._renderPluginContext = null, this._vxlPromise = null, this._vxl = null, this._pluginIsActive = false, this._moreToLoad = false, this._viewportWidth = -1, this._viewportHeight = -1, this._newLayers = [], this._layers = /* @__PURE__ */ new Map(), this._rctx = null, this._renderTargetToRestore = null, this._lastFrameWasStationary = false, this._wasmMemBlockSizes = [512, 1024, 2048, 4096, 8192, 16384, 32768, 65536], this._wasmMemBlocks = /* @__PURE__ */ new Map(), this._dbgFlags = /* @__PURE__ */ new Set(), this._captureFrustum = false, this._frustum = null, this._frustumRenderableId = -1, this._renderCoordsHelper = null, this.produces = /* @__PURE__ */ new Map([[A.VOXEL, () => !!this._vxl && "local" === this.view.viewingMode]]), this.type = i.VOXEL, this.slicePlaneEnabled = true, this.isGround = false, this.layerUid = [];
  }
  _dbg(e5, t2) {
    this._dbgFlags.has(e5) && (e5 === I2.Error ? n.getLogger(this).error(t2) : n.getLogger(this).warn(t2));
  }
  _removeRenderPlugin() {
    this._pluginIsActive && this.view._stage && (this._dbg(I2.Lifetime, "--removeRenderPlugin--"), this.view._stage.removeRenderPlugin(this)), this._pluginIsActive = false;
  }
  initialize() {
    this._dbg(I2.Lifetime, "--initialize--");
    for (const e5 of this._wasmMemBlockSizes)
      this._wasmMemBlocks.set(e5, 0);
    this.addHandles([d(() => this.view.ready, (e5) => {
      e5 && "local" === this.view.viewingMode ? (this._dbg(I2.Lifetime, "view ready status changed to ready on a local view, calling addRenderPlugin"), this.view._stage.addRenderPlugin(this), this._pluginIsActive = true) : (this._dbg(I2.Lifetime, "view ready status changed, not ready or not a local view!"), this._removeRenderPlugin());
    }, P), d(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.qualityProfile;
    }, (e5) => {
      this._dbg(I2.Rendering, "qualityProfile changed to " + e5), this._vxl && this._vxl.set_quality(this._toWasmQuality(e5));
    }, P), d(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.timeExtent;
    }, () => {
      var _a;
      if (this._vxl) {
        const e5 = this._getTimeArgs((_a = this.view) == null ? void 0 : _a.timeExtent);
        this._dbg(I2.Rendering, "sceneView timeExtent changed to useTime=" + e5.useTime + " st=" + e5.startTime + " et=" + e5.endTime), this._vxl.set_scene_time_extent(e5.startTime, e5.endTime, e5.useTime), this._renderPluginContext.requestRender();
      }
    }, P), d(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.stationary;
    }, (e5) => {
      this._vxl && e5 && !this._lastFrameWasStationary && this._renderPluginContext.requestRender();
    })]);
  }
  initializeRenderContext(e5) {
    this._dbg(I2.Lifetime, "--initializeRenderContext--");
    const t2 = e5.renderContext.rctx;
    this._renderPluginContext = e5, this._rctx = e5.renderContext.rctx, this._halfIntTexturesAvailable = !!this._rctx.capabilities.textureNorm16, this._textureFloatLinearAvailable = this._rctx.capabilities.textureFloatLinear, this._initializeWasm(t2.gl);
  }
  uninitializeRenderContext() {
    this._renderPluginContext = null, this._rctx = null, this._dbg(I2.Lifetime, "--uninitializeRenderContext--");
  }
  _restoreFramebuffer() {
    if (!this._renderTargetToRestore)
      return;
    const e5 = this._renderTargetToRestore.fbo;
    if (!!!this._rctx)
      return void this._dbg(I2.Error, "no context in restoreFramebuffer!");
    this._rctx.bindFramebuffer(e5, true);
    const t2 = this._renderTargetToRestore.viewport;
    this._rctx.setViewport(t2.x, t2.y, t2.width, t2.height);
  }
  _bindPreviousDepthToSlot(e5, t2) {
    const s = !!this._rctx, r = !!this._renderTargetToRestore;
    if (!s || !r)
      return 0;
    const i4 = this._renderTargetToRestore.fbo.depthStencilTexture;
    return i4 ? (0 === t2 ? this._rctx.bindTexture(null, e5, true) : this._rctx.bindTexture(i4, e5, true), 1) : (this._dbg(I2.Error, "no depth/stencil texture exists!"), 0);
  }
  _modifyResourceCount(e5, t2, s) {
    if (!this._rctx)
      return void this._dbg(I2.Error, "modifyAllocation callback has no rendering context!");
    const r = e5;
    1 === s ? this._rctx.instanceCounter.increment(r, t2) : this._rctx.instanceCounter.decrement(r, t2);
  }
  _setBlendState(e5, t2, s, r) {
    this._rctx ? (this._rctx.setBlendingEnabled(1 === e5), this._rctx.setBlendFunction(t2, s), this._rctx.setBlendEquation(r)) : this._dbg(I2.Error, "setBlendState callback has no rendering context!");
  }
  _setFrontFace(e5) {
    this._rctx ? this._rctx.setFrontFace(e5) : this._dbg(I2.Error, "setFrontFace callback has no rendering context!");
  }
  _setDepthStencilStateFunction(e5, t2, s) {
    this._rctx ? (this._rctx.setDepthFunction(s), this._rctx.setDepthTestEnabled(1 === e5), this._rctx.setDepthWriteEnabled(1 === t2), this._rctx.setStencilTestEnabled(false), this._rctx.setStencilFunction(O.ALWAYS, 0, 255), this._rctx.setStencilOpSeparate(N.FRONT, I.KEEP, I.INCR, I.KEEP), this._rctx.setStencilOpSeparate(N.BACK, I.KEEP, I.DECR, I.KEEP)) : this._dbg(I2.Error, "setDepthStencilStateFunction callback has no rendering context!");
  }
  _setRasterizerState(e5) {
    if (this._rctx)
      switch (e5) {
        case t.None:
          this._rctx.setFaceCullingEnabled(false);
          break;
        case t.Back:
          this._rctx.setCullFace(N.BACK), this._rctx.setFaceCullingEnabled(true);
          break;
        case t.Front:
          this._rctx.setCullFace(N.FRONT), this._rctx.setFaceCullingEnabled(true);
      }
    else
      this._dbg(I2.Error, "setRasterizerState callback has no rendering context!");
  }
  _setViewport(e5, t2, s, r) {
    this._rctx ? this._rctx.setViewport(e5, t2, s, r) : this._dbg(I2.Error, "setViewport callback has no rendering context!");
  }
  _updateMemoryUsage() {
    this._layers.forEach((e5, t2) => {
      if (e5.needMemoryUsageUpdate) {
        const s = this._vxl.estimate_memory_usage(t2);
        s >= 0 && (e5.needMemoryUsageUpdate = false, e5.layerView.setUsedMemory(s));
      }
    });
  }
  _syncRequestsResponses() {
    this._layers.forEach((e5, t2) => {
      const r = [];
      e5.responses.forEach((s, i4) => {
        r.push(i4), this._dbg(I2.RequestResponse, "responding for requestID:" + i4 + " size:" + s.size), this._vxl.respond(t2, i4, s), s.requestType !== i2.TreeIndex && s.requestType !== i2.Section || (e5.needMemoryUsageUpdate = true);
      });
      const a3 = e5.responses;
      for (const s of r)
        a3.delete(s);
      const n5 = this._vxl.get_new_requests(t2), o3 = e5.abortController.signal;
      for (const l2 in n5) {
        e5.outstandingRequestCount += 1, 1 === e5.outstandingRequestCount && e5.layerView.updatingFlagChanged();
        const t3 = n5[l2], r2 = { responseType: "array-buffer", signal: o3, query: { ...e5.layerView.layer.customParameters, token: e5.layerView.layer.apiKey } };
        this._dbg(I2.RequestResponse, "making requestID:" + l2 + " url:" + t3.url), U(t3.url, r2).then((s) => {
          e5.outstandingRequestCount -= 1, 0 === e5.outstandingRequestCount && e5.layerView.updatingFlagChanged(), this._dbg(I2.RequestResponse, "have response for requestID:" + l2);
          let r3 = 0;
          if (s.data.byteLength > 0) {
            r3 = this._vxl._malloc(s.data.byteLength);
            const e6 = new Uint8Array(this._vxl.HEAPU8.buffer, r3, s.data.byteLength), t4 = new Uint8Array(s.data);
            for (let r4 = 0; r4 < s.data.byteLength; ++r4)
              e6[r4] = t4[r4];
          }
          a3.set(+l2, { responseType: t3.responseType, ptr: r3, size: s.data.byteLength, success: true, requestType: t3.requestType });
        }).catch((s) => {
          e5.outstandingRequestCount -= 1, 0 === e5.outstandingRequestCount && e5.layerView.updatingFlagChanged(), b(s) || (this._dbg(I2.Error, `requestID:${l2} failed, error=${s.toString()}`), a3.set(+l2, { responseType: t3.responseType, ptr: 0, size: 0, success: false, requestType: t3.requestType }));
        });
      }
    });
  }
  updateWasmCamera(e5) {
    this._vxl.set_projection_matrix.apply(this._vxl, e5.projectionMatrix), this._vxl.set_view_matrix.apply(this._vxl, e5.viewMatrix), this._vxl.set_near_far(e5.near, e5.far);
  }
  isUpdating(e5) {
    if (!this._vxl && this._vxlPromise)
      return true;
    const t2 = this._layers.get(e5);
    return !!t2 && t2.outstandingRequestCount > 0;
  }
  getLayerTimes(e5) {
    const t2 = [];
    return this._layers.forEach((s, r) => {
      if (s.layerView.wasmLayerId === e5.wasmLayerId) {
        const s2 = this._vxl.get_layer_epoch_times(r, e5.layer.currentVariableId);
        for (let e6 = 0; e6 < s2.length; ++e6)
          t2.push(s2[e6]);
      }
    }), t2;
  }
  getCurrentLayerTimeIndex(e5) {
    let t2 = 0;
    return this._layers.forEach((s, r) => {
      s.layerView.wasmLayerId === e5.wasmLayerId && (t2 = this._vxl.get_layer_current_time_id(r));
    }), t2;
  }
  setEnabled(e5, t2) {
    this._layers.forEach((s, r) => {
      s.layerView.wasmLayerId === e5.wasmLayerId && (this._vxl.set_enabled(r, t2), s.needMemoryUsageUpdate = true, this._renderPluginContext.requestRender());
    });
  }
  setIsInScaleRange(e5, t2) {
    const s = this._layers.get(e5.wasmLayerId);
    s && t2 !== s.isInScaleRange && (s.isInScaleRange = t2, this._vxl.set_is_in_scale_range(e5.wasmLayerId, t2), s.needMemoryUsageUpdate = !t2, this._renderPluginContext.requestRender());
  }
  setStaticSections(e5, t2) {
    const s = { mask: a2.StaticSections, staticSections: t2 };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setCurrentVariable(e5, t2) {
    const s = { mask: a2.CurrentVariable, currentVariable: t2 };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setRenderMode(e5, t2) {
    const s = { mask: a2.RenderMode, renderMode: t2 };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setVerticalExaggerationAndOffset(e5, t2, s, r) {
    const i4 = { mask: a2.ExaggerationAndOffset, volStyleDesc: { volumeId: t2, verticalExaggeration: s, verticalOffset: r } };
    return this._doMaskedUIUpdate(e5, i4, true);
  }
  setVariableStyles(e5, t2) {
    const s = { mask: a2.VariableStyles, variableStyles: t2 };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setVolumeStyles(e5, t2) {
    const s = { mask: a2.VolumeStyles, volumeStyles: t2 };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setEnableDynamicSections(e5, t2) {
    const s = { mask: a2.ContainerVisibility, containerIsVisible: t2, container: o2.DynamicSections };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setEnableIsosurfaces(e5, t2) {
    const s = { mask: a2.ContainerVisibility, containerIsVisible: t2, container: o2.Isosurfaces };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setEnableSections(e5, t2) {
    const s = { mask: a2.ContainerVisibility, containerIsVisible: t2, container: o2.StaticSections };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setAnalysisSlice(e5, t2, s, r) {
    const i4 = { mask: a2.AnalysisSlice, analysisSlice: { point: s, normal: r, enabled: t2 } };
    return this._doMaskedUIUpdate(e5, i4, true);
  }
  _doMaskedUIUpdate(e5, t2, s) {
    if (!this._vxl)
      return false;
    let r = false;
    return this._layers.forEach((s2, i4) => {
      if (s2.layerView.wasmLayerId === e5.wasmLayerId) {
        const e6 = { str: JSON.stringify(t2), byteCount: 0, ptr: 0, isReusable: false };
        this._allocateBlock(e6) && (r = 1 === this._vxl.handle_masked_ui_update(i4, e6.ptr, e6.byteCount), e6.isReusable || this._vxl._free(e6.ptr));
      }
    }), r && s && this._renderPluginContext.requestRender(), r;
  }
  _addTriangleToWasmBuffer(e5, t2, s, r, i4) {
    return e5[3 * t2] = s[0], e5[3 * t2 + 1] = s[1], e5[3 * t2 + 2] = s[2], e5[3 * (t2 += 1)] = r[0], e5[3 * t2 + 1] = r[1], e5[3 * t2 + 2] = r[2], e5[3 * (t2 += 1)] = i4[0], e5[3 * t2 + 1] = i4[1], e5[3 * t2 + 2] = i4[2], t2 += 1;
  }
  _addNormalToWasmBuffer(e5, t2, s) {
    return e5[3 * t2] = s[0], e5[3 * t2 + 1] = s[1], e5[3 * t2 + 2] = s[2], t2 += 1;
  }
  _doCaptureFrustum() {
    if (!this._vxl)
      return;
    const e5 = 36, t2 = e5 / 3, s = this._vxl._malloc(3 * e5 * Float32Array.BYTES_PER_ELEMENT), r = new Float32Array(this._vxl.HEAPF32.buffer, s, 3 * e5), i4 = this._vxl._malloc(3 * t2 * Float32Array.BYTES_PER_ELEMENT), a3 = new Float32Array(this._vxl.HEAPF32.buffer, i4, e5), n5 = this._frustum.points[g.NEAR_BOTTOM_LEFT], o3 = this._frustum.points[g.NEAR_BOTTOM_RIGHT], l2 = this._frustum.points[g.NEAR_TOP_RIGHT], h = this._frustum.points[g.NEAR_TOP_LEFT], d2 = this._frustum.points[g.FAR_BOTTOM_LEFT], u = this._frustum.points[g.FAR_BOTTOM_RIGHT], m = this._frustum.points[g.FAR_TOP_RIGHT], g2 = this._frustum.points[g.FAR_TOP_LEFT];
    let p = 0, f2 = 0;
    const x2 = this._frustum.planes[j.NEAR];
    p = this._addTriangleToWasmBuffer(r, p, l2, o3, n5), f2 = this._addNormalToWasmBuffer(a3, f2, x2), p = this._addTriangleToWasmBuffer(r, p, n5, h, l2), f2 = this._addNormalToWasmBuffer(a3, f2, x2);
    const y2 = this._frustum.planes[j.FAR];
    p = this._addTriangleToWasmBuffer(r, p, d2, u, m), f2 = this._addNormalToWasmBuffer(a3, f2, y2), p = this._addTriangleToWasmBuffer(r, p, m, g2, d2), f2 = this._addNormalToWasmBuffer(a3, f2, y2);
    const v2 = this._frustum.planes[j.TOP];
    p = this._addTriangleToWasmBuffer(r, p, m, l2, h), f2 = this._addNormalToWasmBuffer(a3, f2, v2), p = this._addTriangleToWasmBuffer(r, p, h, g2, m), f2 = this._addNormalToWasmBuffer(a3, f2, v2);
    const b2 = this._frustum.planes[j.BOTTOM];
    p = this._addTriangleToWasmBuffer(r, p, n5, o3, u), f2 = this._addNormalToWasmBuffer(a3, f2, b2), p = this._addTriangleToWasmBuffer(r, p, u, d2, n5), f2 = this._addNormalToWasmBuffer(a3, f2, b2);
    const w = this._frustum.planes[j.LEFT];
    p = this._addTriangleToWasmBuffer(r, p, h, n5, d2), f2 = this._addNormalToWasmBuffer(a3, f2, w), p = this._addTriangleToWasmBuffer(r, p, d2, g2, h), f2 = this._addNormalToWasmBuffer(a3, f2, w);
    const T = this._frustum.planes[j.RIGHT];
    p = this._addTriangleToWasmBuffer(r, p, l2, m, u), f2 = this._addNormalToWasmBuffer(a3, f2, T), p = this._addTriangleToWasmBuffer(r, p, u, o3, l2), f2 = this._addNormalToWasmBuffer(a3, f2, T), -1 !== this._frustumRenderableId && this._vxl.remove_generic_mesh(this._frustumRenderableId), this._frustumRenderableId = this._vxl.add_generic_mesh(s, 3 * e5, i4, e5, 255, 0, 0, 64), this._vxl._free(s), this._vxl._free(i4), this._captureFrustum = false, this._renderPluginContext.requestRender();
  }
  captureFrustum() {
    null === this._renderCoordsHelper && (this._renderCoordsHelper = v.create(l.Local, z(false, this.view.spatialReference))), null === this._frustum && (this._frustum = new c3(this._renderCoordsHelper)), this._captureFrustum = true, null !== this._renderPluginContext && this._renderPluginContext.requestRender();
  }
  toggleFullVolumeExtentDraw(e5) {
    this._vxl && this._layers.forEach((t2, s) => {
      t2.layerView.wasmLayerId === e5.wasmLayerId && (this._vxl.toggle_full_volume_extent_draw(s), this._renderPluginContext.requestRender());
    });
  }
  addVoxelLayer(e5) {
    if (!this._vxl) {
      const t3 = { layerView: e5, resolveCallback: null, rejectCallback: null }, s = new Promise((e6, s2) => {
        t3.resolveCallback = e6, t3.rejectCallback = s2;
      });
      return this._newLayers.push(t3), s;
    }
    const t2 = this._addVoxelLayer(e5);
    return t2 < 0 ? Promise.reject(-1) : Promise.resolve(t2);
  }
  removeVoxelLayer(e5) {
    if (!this._vxl) {
      const t3 = this._newLayers.findIndex((t4) => e5.uid === t4.layerView.uid);
      t3 >= 0 && (this._newLayers[t3].resolveCallback(-1), this._newLayers.splice(t3, 1));
      const s2 = this._newLayers.length;
      return 0 === s2 && (this._dbg(I2.Lifetime, " no voxel layers left after removing a layer, removing RenderPlugin and destroying"), this.destroy()), s2;
    }
    let t2 = -1;
    this._layers.forEach((s2, r) => {
      if (s2.layerView.wasmLayerId === e5.wasmLayerId) {
        t2 = r, s2.abortController.abort(), this._vxl.remove_layer(t2);
        const i4 = this.layerUid.indexOf(e5.layer.uid);
        -1 !== i4 && this.layerUid.splice(i4, 1);
      }
    }), t2 >= 0 && this._layers.delete(t2);
    const s = this._layers.size;
    return 0 === s && (this._dbg(I2.Lifetime, " no voxel layers left after removing a layer, removing RenderPlugin and destroying"), this.destroy()), s;
  }
  _getBlockSize(e5) {
    for (const t2 of this._wasmMemBlockSizes)
      if (e5 < t2)
        return t2;
    return -1;
  }
  _allocateBlock(e5) {
    e5.byteCount = this._vxl.lengthBytesUTF8(e5.str) + 1;
    const t2 = this._getBlockSize(e5.byteCount);
    return t2 < 0 ? (e5.isReusable = false, e5.ptr = this._vxl._malloc(e5.byteCount)) : (e5.isReusable = true, e5.ptr = this._wasmMemBlocks.get(t2), 0 === e5.ptr && (e5.ptr = this._vxl._malloc(t2), this._wasmMemBlocks.set(t2, e5.ptr))), 0 !== e5.ptr && (this._vxl.stringToUTF8(e5.str, e5.ptr, e5.byteCount), true);
  }
  _getTimeArgs(e5) {
    let t2 = -Number.MAX_VALUE, s = Number.MAX_VALUE, r = false;
    return null != e5 && (e5.isAllTime ? r = true : (null != e5.start && (r = true, t2 = e5.start.getTime() / 1e3), null != e5.end && (r = true, s = e5.end.getTime() / 1e3))), { startTime: t2, endTime: s, useTime: r };
  }
  _addVoxelLayer(e5) {
    var _a, _b;
    const t2 = e5.layer;
    let s = -1;
    const i4 = t2.getConfiguration();
    if (i4.length < 1)
      return -1;
    const a3 = { str: i4, byteCount: 0, ptr: 0, isReusable: false };
    if (!this._allocateBlock(a3))
      return -1;
    const n5 = this._getTimeArgs((_a = this.view) == null ? void 0 : _a.timeExtent), o3 = this.view.spatialReference.isWGS84 && t2.spatialReference.isWGS84 ? 111319.49079327357 : 1;
    if (s = this._vxl.add_layer(t2.serviceRoot, a3.ptr, a3.byteCount, o3, o3, n5.startTime, n5.endTime, n5.useTime, this._toWasmQuality(this.view.qualityProfile)), a3.isReusable || this._vxl._free(a3.ptr), s >= 0) {
      ((_b = t2.test) == null ? void 0 : _b.constantUpscaling) && (this._setUpscalingLimits(0, 0.25, 0.25), this._setUpscalingLimits(1, 0.5, 0.5), this._setUpscalingLimits(2, 0.75, 0.75));
      const i5 = new AbortController();
      if (this._layers.set(s, { layerView: e5, responses: /* @__PURE__ */ new Map(), outstandingRequestCount: 0, abortController: i5, needMemoryUsageUpdate: false, isInScaleRange: true }), this.layerUid.push(e5.layer.uid), !this._halfIntTexturesAvailable || has("mac")) {
        const t3 = [];
        let s2 = "";
        for (const r of e5.layer.variables)
          "Int16" !== r.renderingFormat.type && "UInt16" !== r.renderingFormat.type || (t3.push(r.name), r.id === e5.layer.currentVariableId && (s2 = r.name));
        "" !== s2 && n.getLogger(this).error("#addVoxelLayer_error()", e5.layer, `The voxel layer '${e5.layer.title}' cannot render the current variable '${s2}' in this browser`), t3.length > 0 && n.getLogger(this).warn("#addVoxelLayer_warning()", e5.layer, `The voxel layer '${e5.layer.title}' cannot render the variables '${t3.toString()}' in this browser`);
      }
      if (!this._textureFloatLinearAvailable) {
        const t3 = [];
        let s2 = "";
        for (const r of e5.layer.variables)
          "Float32" === r.renderingFormat.type && (t3.push(r.name), r.id === e5.layer.currentVariableId && (s2 = r.name));
        "" !== s2 && n.getLogger(this).error("#addVoxelLayer_error()", e5.layer, `The voxel layer '${e5.layer.title}' cannot render the current variable '${s2}' in this browser`), t3.length > 0 && n.getLogger(this).warn("#addVoxelLayer_warning()", e5.layer, `The voxel layer '${e5.layer.title}' cannot render the variables '${t3.toString()}' in this browser`);
      }
      return has("esri-mobile") && n.getLogger(this).warnOnce("Mobile support differs across devices. Voxel layer might not display as expected."), s;
    }
    return -1;
  }
  prepareRender(e5) {
    if (!this._vxl)
      return;
    const t2 = e5.bindParameters.camera.viewForward, s = e5.bindParameters.camera.eye;
    this._vxl.update_camera_pos_and_direction(s[0], s[1], s[2], t2[0], t2[1], t2[2]);
    const r = this._vxl.cull();
    this._dbg(I2.RequestResponse, "missingResourceCount=" + r), this._moreToLoad = r > 0, this._havePreparedWithAllLayers = 0 === this._newLayers.length, this._updateMemoryUsage();
  }
  renderNode(e5) {
    if (!this._vxl)
      return;
    for (const s of this._newLayers) {
      const e6 = this._addVoxelLayer(s.layerView);
      -1 === e6 ? s.rejectCallback(-1) : s.resolveCallback(e6);
    }
    if (this._newLayers = [], 0 === this._layers.size)
      return void this._dbg(I2.Error, "No voxel layers but RenderPlugin instance is being asked to render!");
    this._lastFrameWasStationary = this.view.stationary, this._syncRequestsResponses(), this._beforeDraw(), this._vxl.begin_color_frame(!this.view._stage.renderer.isFeatureEnabled(o.HighResolutionVoxel), e5.bindParameters.lighting.mainLight.direction[0], e5.bindParameters.lighting.mainLight.direction[1], e5.bindParameters.lighting.mainLight.direction[2]);
    const t2 = this._renderTargetToRestore.viewport;
    t2.width === this._viewportWidth && t2.height === this._viewportHeight || (this._viewportWidth = t2.width, this._viewportHeight = t2.height, this._vxl.set_viewport(t2.width, t2.height), this._layers.forEach((e6) => {
      e6.needMemoryUsageUpdate = true;
    })), 0 === t2.x && 0 === t2.y || this._dbg(I2.Error, "Unsupported viewport parameters detected!"), this.updateWasmCamera(e5.bindParameters.camera), this._captureFrustum && (this._frustum.update(e5.bindParameters.camera), this._doCaptureFrustum()), this._vxl.draw(), this._afterDraw(), (this._moreToLoad || !this._havePreparedWithAllLayers && this._layers.size > 0) && this._renderPluginContext.requestRender();
  }
  destroy() {
    this._dbg(I2.Lifetime, "--destroy--"), this._removeRenderPlugin(), this._vxl && (this._layers.forEach((e5) => {
      e5.abortController.abort();
    }), this._wasmMemBlocks.forEach((e5) => {
      0 !== e5 && this._vxl._free(e5);
    }), this._vxl.uninitialize_voxel_wasm(), this._vxl = null);
  }
  _initializeWasm(e5) {
    return this._vxl ? Promise.resolve() : (this._vxlPromise || (this._vxlPromise = e4(e5).then((e6) => {
      var _a;
      if (this._vxl = e6, this._vxlPromise = null, this._newLayers.length <= 0)
        return this._dbg(I2.Lifetime, " no voxel layers left after WASM downloaded, removing RenderPlugin and destroying"), void this.destroy();
      const t2 = this._getTimeArgs((_a = this.view) == null ? void 0 : _a.timeExtent), s = this._vxl.addFunction(this._restoreFramebuffer.bind(this), "v"), r = this._vxl.addFunction(this._setBlendState.bind(this), "viiii"), i4 = this._vxl.addFunction(this._setFrontFace.bind(this), "vi"), a3 = this._vxl.addFunction(this._setRasterizerState.bind(this), "vi"), n5 = this._vxl.addFunction(this._setDepthStencilStateFunction.bind(this), "viii"), o3 = this._vxl.addFunction(this._setViewport.bind(this), "viiii"), l2 = this._vxl.addFunction(this._bindPreviousDepthToSlot.bind(this), "iii"), h = this._vxl.addFunction(this._modifyResourceCount.bind(this), "viii"), d2 = this._halfIntTexturesAvailable && !has("mac"), u = this._textureFloatLinearAvailable;
      this._vxl.initialize_voxel_wasm(s, r, i4, a3, n5, o3, l2, h, t2.startTime, t2.endTime, t2.useTime, d2, u), this._renderPluginContext && this._renderPluginContext.requestRender();
    }).catch(() => {
      for (const e6 of this._newLayers)
        e6.rejectCallback(-2);
      this._dbg(I2.Error, " WASM failed to download, removing RenderPlugin and destroying"), this.destroy();
    })), this._vxlPromise);
  }
  pickDepth(e5, t2, s) {
    if (!this._vxl || !this._rctx || 0 === this._layers.size)
      return null;
    const r = s.viewport[3] - t2;
    if (e5 < 0 || e5 > s.viewport[2] || t2 < 0 || t2 > s.viewport[3])
      return this._dbg(I2.Error, `[js] pickDepth: outOfRange, screenXY=[${e5.toFixed(0)}, ${r.toFixed(0)}]]`), null;
    this._beforeDraw();
    const i4 = s.viewForward, a3 = s.eye;
    this._vxl.update_camera_pos_and_direction(a3[0], a3[1], a3[2], i4[0], i4[1], i4[2]), this.updateWasmCamera(s), this._vxl.begin_frame();
    const n5 = this._vxl.pick_depth(e5, r);
    if (this._afterDraw(), n5.success) {
      return n5.distanceToCamera;
    }
    return null;
  }
  pickObject(e5, t2, s, r) {
    if (!this._vxl || !this._rctx || 0 === this._layers.size)
      return null;
    const i4 = Math.round(e5), a3 = Math.round(t2);
    if (i4 < 0 || i4 > s.viewport[2] || a3 < 0 || a3 > s.viewport[3])
      return this._dbg(I2.Error, `[js] pickObject: outOfRange, screenXY=[${i4}, ${a3}], vp=[${s.viewport.toString()}]`), null;
    this._beforeDraw();
    const n5 = s.viewForward, o3 = s.eye;
    this._vxl.update_camera_pos_and_direction(o3[0], o3[1], o3[2], n5[0], n5[1], n5[2]), this.updateWasmCamera(s), this._vxl.begin_frame();
    let l2 = null;
    if (0 === r.length)
      l2 = this._vxl.pick_object(i4, a3, 0, 0);
    else {
      const e6 = { str: JSON.stringify({ layerIds: r }), byteCount: 0, ptr: 0, isReusable: false };
      this._allocateBlock(e6) && (l2 = this._vxl.pick_object(i4, a3, e6.ptr, e6.byteCount), e6.isReusable || this._vxl._free(e6.ptr));
    }
    return this._afterDraw(), l2;
  }
  _beforeDraw() {
    this._renderTargetToRestore = { fbo: this._rctx.getBoundFramebufferObject(), viewport: this._rctx.getViewport() }, this._rctx.setPolygonOffsetFillEnabled(false), this._rctx.setScissorTestEnabled(false), this._rctx.setColorMask(true, true, true, true);
  }
  _afterDraw() {
    this._renderTargetToRestore.fbo = null, this._rctx.externalTextureUnitUpdate(this._vxl.get_texture_units_bound_in_frame(), this._vxl.get_active_texture_unit()), this._rctx.externalVertexArrayObjectUpdate(), this._rctx.externalVertexBufferUpdate(), this._rctx.externalProgramUpdate();
  }
  intersect(e5, t2, s, r, i4) {
    if (!this._vxl || !this._rctx || 0 === this._layers.size || !e5.options.selectionMode || e5.options.isFiltered)
      return;
    if (null == i4 || i4[0] < 0 || i4[0] > e5.camera.viewport[2] || i4[1] < 0 || i4[1] > e5.camera.viewport[3])
      return this._dbg(I2.Error, `[js] VoxelWasmPerScene.intersect: outOfRange, screenXY=[${i4[0].toFixed(0)}, ${i4[1].toFixed(0)}]`), null;
    const a3 = [];
    this._layers.forEach((t3) => {
      e5.options.filteredLayerUids.includes(t3.layerView.layer.uid) && a3.push(t3.layerView.wasmLayerId);
    });
    const n5 = this.pickObject(i4[0], i4[1], e5.camera, a3);
    if (null == n5 || -1 === n5.layerId)
      return;
    const o3 = this._layers.get(n5.layerId);
    if (o3) {
      const t3 = o3.layerView.layer.uid, i5 = n5.distanceToCamera / x(s, r), a4 = n3();
      a4[0] = n5.worldX, a4[1] = n5.worldY, a4[2] = n5.worldZ;
      const l2 = {};
      if (null != n5.continuousValue && null != n5.continuousValueUnits ? l2["Voxel.ServiceValue"] = `${n5.continuousValue.toLocaleString()} ${n5.continuousValueUnits}` : null != n5.uniqueValueLabel && null != n5.uniqueValue ? l2["Voxel.ServiceValue"] = `${n5.uniqueValueLabel} (${n5.uniqueValue})` : null != n5.uniqueValue && (l2["Voxel.ServiceValue"] = `${n5.uniqueValue}`), l2["Voxel.ServiceVariableLabel"] = n5.variableLabel, l2["Voxel.Position"] = n5.voxelSpacePosition, null != n5.epochTime && null != n5.nativeTime && null != n5.nativeTimeUnits) {
        const e6 = new Date(n5.epochTime);
        l2["Voxel.ServiceLocalTime"] = e6.toString(), l2["Voxel.ServiceNativeTime"] = `${n5.nativeTime.toLocaleString()} ${n5.nativeTimeUnits}`;
      }
      null != n5.depth && null != n5.depthUnits && (l2["Voxel.ServiceDepth"] = `${n5.depth.toLocaleString()} ${n5.depthUnits}`);
      const u = n5.faceNormal;
      l2["Voxel.WorldPosition"] = `[${a4[0]}, ${a4[1]}, ${a4[2]}]`;
      const _ = (e6) => {
        const s2 = new c2(a4, t3, () => this._createVoxelGraphic(o3.layerView.layer, l2));
        e6.set(this.type, s2, i5, u);
      }, c4 = e5.results, m = e5.options.store === e2.ALL;
      if ((null == c4.min.dist || i5 < c4.min.dist) && _(c4.min), (null == c4.max.dist || i5 > c4.max.dist) && _(c4.max), m) {
        const t4 = G(e5.ray);
        _(t4), e5.results.all.push(t4);
      }
    }
  }
  _createVoxelGraphic(e5, s) {
    return new f({ layer: e5, sourceLayer: e5, attributes: s });
  }
  _toWasmQuality(e5) {
    switch (e5) {
      case "low":
        return 0;
      case "medium":
        return 1;
      case "high":
        return 2;
    }
  }
  _setUpscalingLimits(e5, t2, s) {
    this._vxl && this._vxl.set_upscaling_limits(e5, t2, s);
  }
};
e([y({ constructOnly: true })], U2.prototype, "view", void 0), U2 = e([a("esri.layers.VoxelWasmPerSceneView")], U2);
var k = U2;
export {
  k as default
};
//# sourceMappingURL=VoxelWasmPerSceneView-N7EFY4J3.js.map
