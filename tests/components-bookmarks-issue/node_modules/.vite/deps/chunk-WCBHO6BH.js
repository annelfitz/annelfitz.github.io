import {
  C
} from "./chunk-PMFQ2A2V.js";
import {
  R,
  j as j2,
  r as r11,
  s as s6
} from "./chunk-HHAESKQ6.js";
import {
  s as s5
} from "./chunk-4MJOJUFR.js";
import {
  P as P2,
  e as e6,
  f,
  i,
  l as l3,
  m as m3,
  o as o7,
  s as s4
} from "./chunk-J5F4VILS.js";
import {
  A as A2,
  E as E4,
  _ as _2,
  c as c4,
  l as l2
} from "./chunk-7A5N7G2Z.js";
import {
  r as r9,
  r2 as r10,
  t as t3
} from "./chunk-ZPC74XHC.js";
import {
  A as A3
} from "./chunk-IVGJRGD2.js";
import {
  t as t2
} from "./chunk-MTLWPXQD.js";
import {
  t as t4
} from "./chunk-JKOHBDRD.js";
import {
  c2 as c3,
  h as h2
} from "./chunk-3DFMDDMO.js";
import {
  S,
  _,
  o as o6
} from "./chunk-MEEG7XMI.js";
import {
  o as o5
} from "./chunk-LJULTBAY.js";
import {
  Y
} from "./chunk-7MYYCSEB.js";
import {
  j
} from "./chunk-ESK2YRQM.js";
import {
  H as H2
} from "./chunk-YJFPDMSR.js";
import {
  E as E3
} from "./chunk-WKVHVZW2.js";
import {
  n as n4,
  r as r7
} from "./chunk-KSZESDGM.js";
import {
  r as r6
} from "./chunk-5P74D2TG.js";
import {
  e as e5,
  r as r5
} from "./chunk-33LWZO2E.js";
import {
  M,
  b as b2,
  d,
  v
} from "./chunk-3IDXRFXE.js";
import {
  m as m2,
  s as s3
} from "./chunk-RLZYC2LS.js";
import {
  t
} from "./chunk-TXLJQAAN.js";
import {
  r as r8
} from "./chunk-3AIILHI5.js";
import {
  c as c2,
  h,
  o as o4,
  r as r4
} from "./chunk-CDBOQCLE.js";
import {
  Z,
  w
} from "./chunk-XMYPMIYH.js";
import {
  E as E2,
  F,
  V,
  b
} from "./chunk-Z2F5OKVA.js";
import {
  m
} from "./chunk-UQA6M3KF.js";
import {
  E,
  e as e4
} from "./chunk-GLF3KRAL.js";
import {
  e as e3,
  o as o3
} from "./chunk-N5GQOIDP.js";
import {
  s as s2
} from "./chunk-AKEHDP75.js";
import {
  H,
  c,
  n as n3
} from "./chunk-HWHMO3CO.js";
import {
  x as x2
} from "./chunk-BOAEEYBE.js";
import {
  e as e2
} from "./chunk-OCF7OAES.js";
import {
  A,
  G,
  O,
  P,
  e,
  g,
  o as o2,
  r as r3,
  s,
  u as u2,
  x
} from "./chunk-JZBR4X6W.js";
import {
  n as n2,
  r as r2
} from "./chunk-OIJCMME5.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import {
  r2 as r
} from "./chunk-NDIXNREV.js";
import {
  l
} from "./chunk-C26KUZ46.js";
import {
  u
} from "./chunk-QHK5ZYFW.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";
import {
  has
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Object3D.js
var O2 = class extends r5 {
  get geometries() {
    return this._geometries;
  }
  get transformation() {
    return this._transformation ?? o3;
  }
  set transformation(e8) {
    this._transformation = n3(this._transformation ?? e3(), e8), this._invalidateBoundingVolume(), this._emit("transformationChanged", this);
  }
  get shaderTransformation() {
    return this._shaderTransformation;
  }
  set shaderTransformation(e8) {
    this._shaderTransformation = e8 ? n3(this._shaderTransformation ?? e3(), e8) : null, this._invalidateBoundingVolume(), this._emit("shaderTransformationChanged", this);
  }
  get effectiveTransformation() {
    return this.shaderTransformation ?? this.transformation;
  }
  constructor(t5 = {}) {
    super(), this.type = e5.Object, this._shaderTransformation = null, this._parentLayer = null, this._visible = true, this.castShadow = t5.castShadow ?? true, this.usesVerticalDistanceToGround = t5.usesVerticalDistanceToGround ?? false, this.graphicUid = t5.graphicUid, this.layerUid = t5.layerUid, t5.isElevationSource && (this.lastValidElevationBB = new A4()), this._geometries = t5.geometries ? Array.from(t5.geometries) : new Array();
  }
  dispose() {
    this._geometries.length = 0;
  }
  get parentLayer() {
    return this._parentLayer;
  }
  set parentLayer(t5) {
    s3(null == this._parentLayer || null == t5, "Object3D can only be added to a single Layer"), this._parentLayer = t5;
  }
  addGeometry(t5) {
    t5.visible = this._visible, this._geometries.push(t5), this._emit("geometryAdded", { object: this, geometry: t5 }), this._invalidateBoundingVolume();
  }
  removeGeometry(t5) {
    const e8 = this._geometries.splice(t5, 1)[0];
    e8 && (this._emit("geometryRemoved", { object: this, geometry: e8 }), this._invalidateBoundingVolume());
  }
  removeAllGeometries() {
    for (; this._geometries.length > 0; )
      this.removeGeometry(0);
  }
  geometryVertexAttributeUpdated(t5, e8, i2 = false) {
    this._emit("attributesChanged", { object: this, geometry: t5, attribute: e8, sync: i2 }), E(e8) && this._invalidateBoundingVolume();
  }
  get visible() {
    return this._visible;
  }
  set visible(t5) {
    if (this._visible !== t5) {
      this._visible = t5;
      for (const t6 of this._geometries)
        t6.visible = this._visible;
      this._emit("visibilityChanged", this);
    }
  }
  maskOccludee() {
    const t5 = new r6(t.MaskOccludee);
    for (const e8 of this._geometries)
      e8.occludees = n4(e8.occludees, t5);
    return this._emit("occlusionChanged", this), t5;
  }
  removeOcclude(t5) {
    for (const e8 of this._geometries)
      e8.occludees = r7(e8.occludees, t5);
    this._emit("occlusionChanged", this);
  }
  highlight() {
    const t5 = new r6(t.Highlight);
    for (const e8 of this._geometries)
      e8.highlights = n4(e8.highlights, t5);
    return this._emit("highlightChanged", this), t5;
  }
  removeHighlight(t5) {
    for (const e8 of this._geometries)
      e8.highlights = r7(e8.highlights, t5);
    this._emit("highlightChanged", this);
  }
  getCombinedStaticTransformation(t5, i2) {
    return c(i2, this.transformation, t5.transformation);
  }
  getCombinedShaderTransformation(t5, i2 = e3()) {
    return c(i2, this.effectiveTransformation, t5.transformation);
  }
  get boundingVolumeWorldSpace() {
    return this._bvWorldSpace || (this._bvWorldSpace = this._bvWorldSpace || new M2(), this._validateBoundingVolume(this._bvWorldSpace, W.WorldSpace)), this._bvWorldSpace;
  }
  get boundingVolumeObjectSpace() {
    return this._bvObjectSpace || (this._bvObjectSpace = this._bvObjectSpace || new M2(), this._validateBoundingVolume(this._bvObjectSpace, W.ObjectSpace)), this._bvObjectSpace;
  }
  _validateBoundingVolume(t5, e8) {
    const i2 = e8 === W.ObjectSpace;
    for (const s7 of this._geometries) {
      const e9 = s7.boundingInfo;
      e9 && L(e9, t5, i2 ? s7.transformation : this.getCombinedShaderTransformation(s7));
    }
    A(Z(t5.bounds), t5.min, t5.max, 0.5);
    for (const s7 of this._geometries) {
      const e9 = s7.boundingInfo;
      if (null == e9)
        continue;
      const r12 = i2 ? s7.transformation : this.getCombinedShaderTransformation(s7), o8 = m(r12);
      O(U, e9.center, r12);
      const m4 = x(U, Z(t5.bounds)), h3 = e9.radius * o8;
      t5.bounds[3] = Math.max(t5.bounds[3], m4 + h3);
    }
  }
  _invalidateBoundingVolume() {
    var _a;
    const t5 = (_a = this._bvWorldSpace) == null ? void 0 : _a.bounds;
    this._bvObjectSpace = this._bvWorldSpace = void 0, this._parentLayer && t5 && this._parentLayer.notifyObjectBBChanged(this, t5);
  }
  _emit(t5, e8) {
    this._parentLayer && this._parentLayer.events.emit(t5, e8);
  }
  get test() {
    const t5 = this;
    return { hasGeometry: (e8) => t5._geometries.includes(e8), getGeometryIndex: (e8) => t5._geometries.indexOf(e8) };
  }
};
var A4 = class {
  constructor() {
    this.min = r2(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this.max = r2(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  }
  isEmpty() {
    return this.max[0] < this.min[0] && this.max[1] < this.min[1] && this.max[2] < this.min[2];
  }
};
var M2 = class extends A4 {
  constructor() {
    super(...arguments), this.bounds = w();
  }
};
function L(t5, e8, s7) {
  const r12 = t5.bbMin, o8 = t5.bbMax;
  if (H(s7)) {
    const t6 = o2(T, s7[12], s7[13], s7[14]);
    u2(C2, r12, t6), u2(B, o8, t6);
    for (let i2 = 0; i2 < 3; ++i2)
      e8.min[i2] = Math.min(e8.min[i2], C2[i2]), e8.max[i2] = Math.max(e8.max[i2], B[i2]);
  } else if (O(C2, r12, s7), G(r12, o8))
    for (let i2 = 0; i2 < 3; ++i2)
      e8.min[i2] = Math.min(e8.min[i2], C2[i2]), e8.max[i2] = Math.max(e8.max[i2], C2[i2]);
  else {
    O(B, o8, s7);
    for (let t6 = 0; t6 < 3; ++t6)
      e8.min[t6] = Math.min(e8.min[t6], C2[t6], B[t6]), e8.max[t6] = Math.max(e8.max[t6], C2[t6], B[t6]);
    for (let t6 = 0; t6 < 3; ++t6) {
      r3(C2, r12), r3(B, o8), C2[t6] = o8[t6], B[t6] = r12[t6], O(C2, C2, s7), O(B, B, s7);
      for (let t7 = 0; t7 < 3; ++t7)
        e8.min[t7] = Math.min(e8.min[t7], C2[t7], B[t7]), e8.max[t7] = Math.max(e8.max[t7], C2[t7], B[t7]);
    }
  }
}
var T = n2();
var C2 = n2();
var B = n2();
var U = n2();
var W;
!function(t5) {
  t5[t5.WorldSpace = 0] = "WorldSpace", t5[t5.ObjectSpace = 1] = "ObjectSpace";
}(W || (W = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DirtyEvents.js
var e7 = ["layerObjectAdded", "layerObjectRemoved", "layerObjectsAdded", "layerObjectsRemoved", "transformationChanged", "shaderTransformationChanged", "visibilityChanged", "occlusionChanged", "highlightChanged", "geometryAdded", "geometryRemoved", "attributesChanged"];

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/WebGLLayer.js
var a = class extends r5 {
  get objects() {
    return this._objects;
  }
  constructor(s7, r12, h3 = "") {
    super(), this.stage = s7, this.apiLayerUid = h3, this.type = e5.Layer, this.events = new o(), this.visible = true, this.pickable = true, this.sliceable = false, this._objects = new l(), this._objectsAdded = new l(), this._handles = new r(), this.apiLayerUid = h3, this.visible = (r12 == null ? void 0 : r12.visible) ?? true, this.pickable = (r12 == null ? void 0 : r12.pickable) ?? true, this.updatePolicy = (r12 == null ? void 0 : r12.updatePolicy) ?? C.ASYNC, this._disableOctree = (r12 == null ? void 0 : r12.disableOctree) ?? false, s7.add(this);
    for (const e8 of e7)
      this._handles.add(this.events.on(e8, (t5) => s7.handleEvent(e8, t5)));
  }
  destroy() {
    this._handles.size && (this._handles.destroy(), this.stage.remove(this), this.invalidateSpatialQueryAccelerator());
  }
  add(e8) {
    this._objects.push(e8), e8.parentLayer = this, this.events.emit("layerObjectAdded", { layer: this, object: e8 }), null != this._octree && this._objectsAdded.push(e8);
  }
  remove(e8) {
    this._objects.removeUnordered(e8) && (e8.parentLayer = null, this.events.emit("layerObjectRemoved", { layer: this, object: e8 }), null != this._octree && (this._objectsAdded.removeUnordered(e8) || this._octree.remove([e8])));
  }
  addMany(e8) {
    this._objects.pushArray(e8);
    for (const t5 of e8)
      t5.parentLayer = this;
    this.events.emit("layerObjectsAdded", { layer: this, objects: e8 }), null != this._octree && this._objectsAdded.pushArray(e8);
  }
  removeMany(e8) {
    const t5 = new Array();
    if (this._objects.removeUnorderedMany(e8, e8.length, t5), 0 !== t5.length) {
      for (const e9 of t5)
        e9.parentLayer = null;
      if (this.events.emit("layerObjectsRemoved", { layer: this, objects: t5 }), null != this._octree) {
        for (let e9 = 0; e9 < t5.length; )
          this._objectsAdded.removeUnordered(t5[e9]) ? (t5[e9] = t5[t5.length - 1], t5.length -= 1) : ++e9;
        this._octree.remove(t5);
      }
    }
  }
  sync() {
    this.updatePolicy !== C.SYNC && this.stage.syncLayer(this.id);
  }
  notifyObjectBBChanged(e8, t5) {
    null == this._octree || this._objectsAdded.includes(e8) || this._octree.update(e8, t5);
  }
  getSpatialQueryAccelerator() {
    return null == this._octree && this._objects.length > 50 && !this._disableOctree ? (this._octree = new Y((e8) => e8.boundingVolumeWorldSpace.bounds), this._octree.add(this._objects.data, this._objects.length)) : null != this._octree && this._objectsAdded.length > 0 && (this._octree.add(this._objectsAdded.data, this._objectsAdded.length), this._objectsAdded.clear()), this._octree;
  }
  invalidateSpatialQueryAccelerator() {
    this._octree = u(this._octree), this._objectsAdded.clear();
  }
};
function n5(e8) {
  return null != e8 && e8.type === e5.Layer;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/RibbonLineTechnique.js
var y = /* @__PURE__ */ new Map([[e4.POSITION, 0], [e4.PREVPOSITION, 1], [e4.NEXTPOSITION, 2], [e4.SUBDIVISIONFACTOR, 3], [e4.UV0, 4], [e4.COLOR, 5], [e4.COLORFEATUREATTRIBUTE, 5], [e4.SIZE, 6], [e4.SIZEFEATUREATTRIBUTE, 6], [e4.OPACITYFEATUREATTRIBUTE, 7], [e4.OBJECTANDLAYERIDCOLOR, 8]]);
var W2 = class _W extends r9 {
  initializeProgram(e8) {
    return new r10(e8.rctx, _W.shader.get().build(this.configuration), y);
  }
  _makePipelineState(i2, r12) {
    const a2 = this.configuration, d2 = i2 === o5.NONE, T2 = i2 === o5.FrontFace, f2 = r4(a2.output);
    return S({ blending: a2.output === o4.Color || a2.output === o4.Alpha ? d2 ? c4 : A2(i2) : null, depthTest: { func: l2(i2) }, depthWrite: d2 ? a2.writeDepth || f2 ? o6 : null : E4(i2), colorWrite: _, stencilWrite: a2.hasOccludees ? e6 : null, stencilTest: a2.hasOccludees ? r12 ? o7 : f : null, polygonOffset: d2 || T2 ? a2.hasPolygonOffset ? A5 : null : _2 });
  }
  initializePipeline() {
    const e8 = this.configuration;
    if (e8.occluder) {
      const t5 = e8.hasPolygonOffset ? A5 : null;
      this._occluderPipelineTransparent = S({ blending: c4, polygonOffset: t5, depthTest: s4, depthWrite: null, colorWrite: _, stencilWrite: null, stencilTest: m3 }), this._occluderPipelineOpaque = S({ blending: c4, polygonOffset: t5, depthTest: s4, depthWrite: null, colorWrite: _, stencilWrite: l3, stencilTest: P2 }), this._occluderPipelineMaskWrite = S({ blending: null, polygonOffset: t5, depthTest: i, depthWrite: null, colorWrite: null, stencilWrite: e6, stencilTest: o7 });
    }
    return this._occludeePipelineState = this._makePipelineState(this.configuration.transparencyPassType, true), this._makePipelineState(this.configuration.transparencyPassType, false);
  }
  get primitiveType() {
    return this.configuration.wireframe ? E3.LINES : E3.TRIANGLE_STRIP;
  }
  getPipeline(e8, t5, i2) {
    return e8 ? this._occludeePipelineState : this.configuration.occluder ? i2 ? this._occluderPipelineTransparent : t5 ? this._occluderPipelineOpaque : this._occluderPipelineMaskWrite : super.getPipeline();
  }
};
W2.shader = new t3(R, () => import("./RibbonLine.glsl-GN3UUEN7.js"));
var A5 = { factor: 0, units: -4 };

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/RibbonLineMaterial.js
var G2;
!function(e8) {
  e8[e8.LEFT_JOIN_START = -2] = "LEFT_JOIN_START", e8[e8.LEFT_JOIN_END = -1] = "LEFT_JOIN_END", e8[e8.LEFT_CAP_START = -4] = "LEFT_CAP_START", e8[e8.LEFT_CAP_END = -5] = "LEFT_CAP_END", e8[e8.RIGHT_JOIN_START = 2] = "RIGHT_JOIN_START", e8[e8.RIGHT_JOIN_END = 1] = "RIGHT_JOIN_END", e8[e8.RIGHT_CAP_START = 4] = "RIGHT_CAP_START", e8[e8.RIGHT_CAP_END = 5] = "RIGHT_CAP_END";
}(G2 || (G2 = {}));
var H3 = class extends c3 {
  constructor(e8) {
    super(e8, new k()), this._configuration = new s6(), this.produces = /* @__PURE__ */ new Map([[A3.OPAQUE_MATERIAL, (e9) => e9 === o4.Highlight || e9 === o4.ObjectAndLayerIdColor || (e9 === o4.Color || e9 === o4.Alpha) && this.parameters.renderOccluded === h2.OccludeAndTransparentStencil], [A3.OPAQUE_NO_SSAO_DEPTH, (e9) => e9 === o4.LinearDepth], [A3.OCCLUDER_MATERIAL, (e9) => c2(e9) && this.parameters.renderOccluded === h2.OccludeAndTransparentStencil], [A3.TRANSPARENT_OCCLUDER_MATERIAL, (e9) => c2(e9) && this.parameters.renderOccluded === h2.OccludeAndTransparentStencil], [A3.TRANSPARENT_MATERIAL, (e9) => (e9 === o4.Color || e9 === o4.Alpha) && this.parameters.writeDepth && this.parameters.renderOccluded !== h2.OccludeAndTransparentStencil], [A3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL, (e9) => (e9 === o4.Color || e9 === o4.Alpha) && !this.parameters.writeDepth && this.parameters.renderOccluded !== h2.OccludeAndTransparentStencil], [A3.DRAPED_MATERIAL, (e9) => h(e9)]]), this._vertexAttributeLocations = y;
  }
  getConfiguration(e8, t5) {
    this._configuration.output = e8, this._configuration.draped = t5.slot === A3.DRAPED_MATERIAL;
    const r12 = null != this.parameters.stipplePattern && e8 !== o4.Highlight;
    return this._configuration.stippleEnabled = r12, this._configuration.stippleOffColorEnabled = r12 && null != this.parameters.stippleOffColor, this._configuration.stipplePreferContinuous = r12 && this.parameters.stipplePreferContinuous, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasOccludees = this.parameters.hasOccludees, this._configuration.roundJoins = "round" === this.parameters.join, this._configuration.capType = this.parameters.cap, this._configuration.applyMarkerOffset = null != this.parameters.markerParameters && Y2(this.parameters.markerParameters), this._configuration.hasPolygonOffset = this.parameters.hasPolygonOffset, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.vvSize = !!this.parameters.vvSize, this._configuration.vvColor = !!this.parameters.vvColor, this._configuration.vvOpacity = !!this.parameters.vvOpacity, this._configuration.innerColorEnabled = this.parameters.innerWidth > 0 && null != this.parameters.innerColor, this._configuration.falloffEnabled = this.parameters.falloff > 0, this._configuration.occluder = this.parameters.renderOccluded === h2.OccludeAndTransparentStencil, this._configuration.transparencyPassType = t5.transparencyPassType, this._configuration.multipassEnabled = t5.multipassEnabled, this._configuration.cullAboveGround = t5.multipassTerrain.cullAboveGround, this._configuration.wireframe = this.parameters.wireframe, this._configuration;
  }
  intersectDraped(e8, r12, s7, i2, a2, n6) {
    if (!s7.options.selectionMode)
      return;
    const o8 = e8.attributes.get(e4.POSITION).data, l4 = e8.attributes.get(e4.SIZE);
    let c5 = this.parameters.width;
    if (this.parameters.vvSize) {
      const r13 = e8.attributes.get(e4.SIZEFEATUREATTRIBUTE).data[0];
      c5 *= e2(this.parameters.vvSize.offset[0] + r13 * this.parameters.vvSize.factor[0], this.parameters.vvSize.minSize[0], this.parameters.vvSize.maxSize[0]);
    } else
      l4 && (c5 *= l4.data[0]);
    const u3 = i2[0], h3 = i2[1], p = (c5 / 2 + 4) * e8.screenToWorldRatio;
    let m4 = Number.MAX_VALUE, f2 = 0;
    for (let d2 = 0; d2 < o8.length - 5; d2 += 3) {
      const e9 = o8[d2], r13 = o8[d2 + 1], s8 = u3 - e9, i3 = h3 - r13, a3 = o8[d2 + 3] - e9, n7 = o8[d2 + 4] - r13, l5 = e2((a3 * s8 + n7 * i3) / (a3 * a3 + n7 * n7), 0, 1), c6 = a3 * l5 - s8, p2 = n7 * l5 - i3, T2 = c6 * c6 + p2 * p2;
      T2 < m4 && (m4 = T2, f2 = d2 / 3);
    }
    m4 < p * p && a2(n6.dist, n6.normal, f2, false);
  }
  intersect(r12, p, m4, f2, T2, R2) {
    if (!m4.options.selectionMode || !r12.visible)
      return;
    if (!m2(p))
      return void n.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");
    const g2 = r12.attributes, b3 = g2.get(e4.POSITION).data;
    let v2 = this.parameters.width;
    if (this.parameters.vvSize) {
      const e8 = g2.get(e4.SIZEFEATUREATTRIBUTE).data[0];
      v2 *= e2(this.parameters.vvSize.offset[0] + e8 * this.parameters.vvSize.factor[0], this.parameters.vvSize.minSize[0], this.parameters.vvSize.maxSize[0]);
    } else
      g2.has(e4.SIZE) && (v2 *= g2.get(e4.SIZE).data[0]);
    const P3 = m4.camera, L2 = $;
    r8(L2, m4.point);
    const N = v2 * P3.pixelRatio / 2 + 4 * P3.pixelRatio;
    o2(ce[0], L2[0] - N, L2[1] + N, 0), o2(ce[1], L2[0] + N, L2[1] + N, 0), o2(ce[2], L2[0] + N, L2[1] - N, 0), o2(ce[3], L2[0] - N, L2[1] - N, 0);
    for (let e8 = 0; e8 < 4; e8++)
      if (!P3.unprojectFromRenderScreen(ce[e8], ue[e8]))
        return;
    b(P3.eye, ue[0], ue[1], he), b(P3.eye, ue[1], ue[2], pe), b(P3.eye, ue[2], ue[3], me), b(P3.eye, ue[3], ue[0], fe);
    let C3 = Number.MAX_VALUE, y2 = 0;
    const U2 = W3(this.parameters, g2) ? b3.length - 2 : b3.length - 5;
    for (let e8 = 0; e8 < U2; e8 += 3) {
      q[0] = b3[e8] + p[12], q[1] = b3[e8 + 1] + p[13], q[2] = b3[e8 + 2] + p[14];
      const t5 = (e8 + 3) % b3.length;
      if (X[0] = b3[t5] + p[12], X[1] = b3[t5 + 1] + p[13], X[2] = b3[t5 + 2] + p[14], V(he, q) < 0 && V(he, X) < 0 || V(pe, q) < 0 && V(pe, X) < 0 || V(me, q) < 0 && V(me, X) < 0 || V(fe, q) < 0 && V(fe, X) < 0)
        continue;
      if (P3.projectToRenderScreen(q, ee), P3.projectToRenderScreen(X, te), ee[2] < 0 && te[2] > 0) {
        e(Q, q, X);
        const e9 = P3.frustum, t6 = -V(e9[j.NEAR], q) / P(Q, F(e9[j.NEAR]));
        g(Q, Q, t6), u2(q, q, Q), P3.projectToRenderScreen(q, ee);
      } else if (ee[2] > 0 && te[2] < 0) {
        e(Q, X, q);
        const e9 = P3.frustum, t6 = -V(e9[j.NEAR], X) / P(Q, F(e9[j.NEAR]));
        g(Q, Q, t6), u2(X, X, Q), P3.projectToRenderScreen(X, te);
      } else if (ee[2] < 0 && te[2] < 0)
        continue;
      ee[2] = 0, te[2] = 0;
      const r13 = M(b2(ee, te, ie), L2);
      r13 < C3 && (C3 = r13, r3(re, q), r3(se, X), y2 = e8 / 3);
    }
    const F2 = m4.rayBegin, w2 = m4.rayEnd;
    if (C3 < N * N) {
      let e8 = Number.MAX_VALUE;
      if (d(b2(re, se, ie), b2(F2, w2, ae), K)) {
        e(K, K, F2);
        const t5 = s(K);
        g(K, K, 1 / t5), e8 = t5 / x(F2, w2);
      }
      R2(e8, K, y2, false);
    }
  }
  get _layout() {
    const e8 = H2().vec3f(e4.POSITION).vec3f(e4.PREVPOSITION).vec3f(e4.NEXTPOSITION).f32(e4.SUBDIVISIONFACTOR).vec2f(e4.UV0);
    return this.parameters.vvSize ? e8.f32(e4.SIZEFEATUREATTRIBUTE) : e8.f32(e4.SIZE), this.parameters.vvColor ? e8.f32(e4.COLORFEATUREATTRIBUTE) : e8.vec4f(e4.COLOR), this.parameters.vvOpacity && e8.f32(e4.OPACITYFEATUREATTRIBUTE), has("enable-feature:objectAndLayerId-rendering") && e8.vec4u8(e4.OBJECTANDLAYERIDCOLOR), e8;
  }
  createBufferWriter() {
    return new V2(this._layout, this.parameters);
  }
  createGLMaterial(e8) {
    return new z(e8);
  }
  validateParameters(e8) {
    "miter" !== e8.join && (e8.miterLimit = 0), null != e8.markerParameters && (e8.markerScale = e8.markerParameters.width / e8.width);
  }
};
var z = class extends t2 {
  constructor() {
    super(...arguments), this._stipplePattern = null;
  }
  dispose() {
    super.dispose(), this._stippleTextureRepository.release(this._stipplePattern), this._stipplePattern = null;
  }
  _updateOccludeeState(e8) {
    e8.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e8.hasOccludees });
  }
  beginSlot(e8) {
    this._output !== o4.Color && this._output !== o4.Alpha || this._updateOccludeeState(e8);
    const t5 = this._material.parameters.stipplePattern;
    return this._stipplePattern !== t5 && (this._material.setParameters({ stippleTexture: this._stippleTextureRepository.swap(t5, this._stipplePattern) }), this._stipplePattern = t5), this.ensureTechnique(W2, e8);
  }
};
var k = class extends t4 {
  constructor() {
    super(...arguments), this.width = 0, this.color = s2, this.join = "miter", this.cap = r11.BUTT, this.miterLimit = 5, this.writeDepth = true, this.hasPolygonOffset = false, this.stippleTexture = null, this.stipplePreferContinuous = true, this.markerParameters = null, this.markerScale = 1, this.hasSlicePlane = false, this.vvFastUpdate = false, this.isClosed = false, this.falloff = 0, this.innerWidth = 0, this.hasOccludees = false, this.wireframe = false;
  }
};
var V2 = class {
  constructor(e8, t5) {
    this.vertexBufferLayout = e8, this._parameters = t5, this.numJoinSubdivisions = 0;
    const r12 = t5.stipplePattern ? 1 : 0;
    switch (this._parameters.join) {
      case "miter":
      case "bevel":
        this.numJoinSubdivisions = r12;
        break;
      case "round":
        this.numJoinSubdivisions = j2 + r12;
    }
  }
  _isClosed(e8) {
    return W3(this._parameters, e8.attributes);
  }
  allocate(e8) {
    return this.vertexBufferLayout.createBuffer(e8);
  }
  elementCount(e8) {
    const t5 = 2, r12 = e8.attributes.get(e4.POSITION).indices.length / 2 + 1, s7 = this._isClosed(e8);
    let i2 = s7 ? 2 : 2 * t5;
    return i2 += ((s7 ? r12 : r12 - 1) - (s7 ? 0 : 1)) * (2 * this.numJoinSubdivisions + 4), i2 += 2, this._parameters.wireframe && (i2 = 2 + 4 * (i2 - 2)), i2;
  }
  write(e8, t5, r12, s7, a2) {
    var _a, _b, _c;
    const n6 = ne, o8 = oe, l4 = le, u3 = r12.attributes.get(e4.POSITION), m4 = u3.indices, f2 = u3.data.length / 3, d2 = (_a = r12.attributes.get(e4.DISTANCETOSTART)) == null ? void 0 : _a.data;
    m4 && m4.length !== 2 * (f2 - 1) && console.warn("RibbonLineMaterial does not support indices");
    const T2 = ((_b = r12.attributes.get(e4.SIZEFEATUREATTRIBUTE)) == null ? void 0 : _b.data[0]) ?? ((_c = r12.attributes.get(e4.SIZE)) == null ? void 0 : _c.data[0]) ?? 1;
    let _3 = [1, 1, 1, 1], E5 = 0;
    const A6 = this.vertexBufferLayout.fields.has(e4.COLORFEATUREATTRIBUTE);
    A6 ? E5 = r12.attributes.get(e4.COLORFEATUREATTRIBUTE).data[0] : r12.attributes.has(e4.COLOR) && (_3 = r12.attributes.get(e4.COLOR).data);
    const R2 = has("enable-feature:objectAndLayerId-rendering") ? r12.objectAndLayerIdColor : null, O3 = this.vertexBufferLayout.fields.has(e4.OPACITYFEATUREATTRIBUTE), I = O3 ? r12.attributes.get(e4.OPACITYFEATUREATTRIBUTE).data[0] : 0, S2 = new Float32Array(s7.buffer), g2 = has("enable-feature:objectAndLayerId-rendering") ? new Uint8Array(s7.buffer) : null, b3 = this.vertexBufferLayout.stride / 4;
    let v2 = a2 * b3;
    const P3 = v2;
    let L2 = 0;
    const N = d2 ? (e9, t6, r13) => L2 = d2[r13] : (e9, t6, r13) => L2 += x(e9, t6), C3 = has("enable-feature:objectAndLayerId-rendering"), y2 = (e9, t6, r13, s8, i2, a3, n7) => {
      if (S2[v2++] = t6[0], S2[v2++] = t6[1], S2[v2++] = t6[2], S2[v2++] = e9[0], S2[v2++] = e9[1], S2[v2++] = e9[2], S2[v2++] = r13[0], S2[v2++] = r13[1], S2[v2++] = r13[2], S2[v2++] = s8, S2[v2++] = n7, S2[v2++] = i2, S2[v2++] = T2, A6)
        S2[v2++] = E5;
      else {
        const e10 = Math.min(4 * a3, _3.length - 4);
        S2[v2++] = _3[e10], S2[v2++] = _3[e10 + 1], S2[v2++] = _3[e10 + 2], S2[v2++] = _3[e10 + 3];
      }
      O3 && (S2[v2++] = I), C3 && (null != R2 && (g2[4 * v2] = R2[0], g2[4 * v2 + 1] = R2[1], g2[4 * v2 + 2] = R2[2], g2[4 * v2 + 3] = R2[3]), v2++);
    };
    v2 += b3, o2(o8, u3.data[0], u3.data[1], u3.data[2]), e8 && O(o8, o8, e8);
    const j3 = this._isClosed(r12);
    if (j3) {
      const t6 = u3.data.length - 3;
      o2(n6, u3.data[t6], u3.data[t6 + 1], u3.data[t6 + 2]), e8 && O(n6, n6, e8);
    } else
      o2(l4, u3.data[3], u3.data[4], u3.data[5]), e8 && O(l4, l4, e8), y2(o8, o8, l4, 1, G2.LEFT_CAP_START, 0, 0), y2(o8, o8, l4, 1, G2.RIGHT_CAP_START, 0, 0), r3(n6, o8), r3(o8, l4);
    const U2 = j3 ? 0 : 1, F2 = j3 ? f2 : f2 - 1;
    for (let h3 = U2; h3 < F2; h3++) {
      const t6 = (h3 + 1) % f2 * 3;
      o2(l4, u3.data[t6], u3.data[t6 + 1], u3.data[t6 + 2]), e8 && O(l4, l4, e8), N(n6, o8, h3), y2(n6, o8, l4, 0, G2.LEFT_JOIN_END, h3, L2), y2(n6, o8, l4, 0, G2.RIGHT_JOIN_END, h3, L2);
      const r13 = this.numJoinSubdivisions;
      for (let e9 = 0; e9 < r13; ++e9) {
        const t7 = (e9 + 1) / (r13 + 1);
        y2(n6, o8, l4, t7, G2.LEFT_JOIN_END, h3, L2), y2(n6, o8, l4, t7, G2.RIGHT_JOIN_END, h3, L2);
      }
      y2(n6, o8, l4, 1, G2.LEFT_JOIN_START, h3, L2), y2(n6, o8, l4, 1, G2.RIGHT_JOIN_START, h3, L2), r3(n6, o8), r3(o8, l4);
    }
    j3 ? (o2(l4, u3.data[3], u3.data[4], u3.data[5]), e8 && O(l4, l4, e8), L2 = N(n6, o8, F2), y2(n6, o8, l4, 0, G2.LEFT_JOIN_END, U2, L2), y2(n6, o8, l4, 0, G2.RIGHT_JOIN_END, U2, L2)) : (L2 = N(n6, o8, F2), y2(n6, o8, o8, 0, G2.LEFT_CAP_END, F2, L2), y2(n6, o8, o8, 0, G2.RIGHT_CAP_END, F2, L2)), Z2(S2, P3 + b3, S2, P3, b3);
    v2 = Z2(S2, v2 - b3, S2, v2, b3), this._parameters.wireframe && this._addWireframeVertices(s7, P3, v2, b3);
  }
  _addWireframeVertices(e8, t5, r12, s7) {
    const i2 = new Float32Array(e8.buffer, r12 * Float32Array.BYTES_PER_ELEMENT), a2 = new Float32Array(e8.buffer, t5 * Float32Array.BYTES_PER_ELEMENT, r12 - t5);
    let n6 = 0;
    const o8 = (e9) => n6 = Z2(a2, e9, i2, n6, s7);
    for (let l4 = 0; l4 < a2.length - 1; l4 += 2 * s7)
      o8(l4), o8(l4 + 2 * s7), o8(l4 + 1 * s7), o8(l4 + 2 * s7), o8(l4 + 1 * s7), o8(l4 + 3 * s7);
  }
};
function Z2(e8, t5, r12, s7, i2) {
  for (let a2 = 0; a2 < i2; a2++)
    r12[s7++] = e8[t5++];
  return s7;
}
function W3(e8, t5) {
  if (!e8.isClosed)
    return false;
  return t5.get(e4.POSITION).indices.length > 2;
}
function Y2(e8) {
  return e8.anchor === s5.Tip && e8.hideOnShortSegments && "begin-end" === e8.placement && e8.worldSpace;
}
var q = n2();
var X = n2();
var Q = n2();
var K = n2();
var $ = n2();
var ee = x2();
var te = x2();
var re = n2();
var se = n2();
var ie = v();
var ae = v();
var ne = n2();
var oe = n2();
var le = n2();
var ce = [x2(), x2(), x2(), x2()];
var ue = [n2(), n2(), n2(), n2()];
var he = E2();
var pe = E2();
var me = E2();
var fe = E2();

export {
  O2 as O,
  a,
  n5 as n,
  H3 as H
};
//# sourceMappingURL=chunk-WCBHO6BH.js.map
