import {
  a,
  c,
  g,
  r as r4
} from "./chunk-VBLASJK5.js";
import {
  r as r3
} from "./chunk-HXYRQKMI.js";
import {
  C as C2,
  D
} from "./chunk-WKVHVZW2.js";
import {
  m
} from "./chunk-IYU3Q2BA.js";
import "./chunk-L52HB3KV.js";
import "./chunk-TXLJQAAN.js";
import {
  C,
  O2
} from "./chunk-XJICXW6N.js";
import "./chunk-YF5E2R37.js";
import "./chunk-R4SGP2EA.js";
import "./chunk-IRL6OOVK.js";
import "./chunk-3AIILHI5.js";
import "./chunk-QJRGTKPN.js";
import {
  i
} from "./chunk-VIH3KDZO.js";
import "./chunk-LA365FE7.js";
import "./chunk-WIVZ7SMV.js";
import "./chunk-O76UVYOO.js";
import {
  N,
  T
} from "./chunk-QCMUK3QA.js";
import "./chunk-HZSGATFT.js";
import {
  e as e3,
  o as o3,
  r as r2
} from "./chunk-KNMQQRV7.js";
import {
  e as e2,
  o as o2
} from "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import {
  f
} from "./chunk-HWHMO3CO.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import {
  h
} from "./chunk-OCF7OAES.js";
import {
  G,
  _ as _2,
  e,
  o,
  z as z2
} from "./chunk-JZBR4X6W.js";
import {
  _,
  l,
  n as n2,
  t
} from "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import {
  z
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-RUN6MNXL.js";
import {
  ct
} from "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import "./chunk-D25BO7X7.js";
import "./chunk-NDIXNREV.js";
import {
  r2 as r
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import {
  O
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/glb.js
var t2;
!function(t3) {
  t3[t3.JSON = 1313821514] = "JSON", t3[t3.BIN = 5130562] = "BIN";
}(t2 || (t2 = {}));
var e4 = class _e {
  constructor(i6, r5) {
    if (!i6)
      throw new Error("GLB requires a JSON gltf chunk");
    this._length = _e.HEADER_SIZE, this._length += _e.CHUNK_HEADER_SIZE;
    const s4 = n3(i6);
    if (this._length += h2(s4.byteLength, 4), r5 && (this._length += _e.CHUNK_HEADER_SIZE, this._length += r5.byteLength, r5.byteLength % 4))
      throw new Error("Expected BIN chunk length to be divisible by 4 at this point");
    this.buffer = new ArrayBuffer(this._length), this._outView = new DataView(this.buffer), this._writeHeader();
    const _3 = this._writeChunk(s4, 12, t2.JSON, 32);
    r5 && this._writeChunk(r5, _3, t2.BIN);
  }
  _writeHeader() {
    this._outView.setUint32(0, _e.MAGIC, true), this._outView.setUint32(4, _e.VERSION, true), this._outView.setUint32(8, this._length, true);
  }
  _writeChunk(t3, e7, n4, r5 = 0) {
    const s4 = h2(t3.byteLength, 4);
    for (this._outView.setUint32(e7, s4, true), this._outView.setUint32(e7 += 4, n4, true), i2(this._outView.buffer, t3, e7 += 4, 0, t3.byteLength), e7 += t3.byteLength; e7 % 4; )
      r5 && this._outView.setUint8(e7, r5), e7++;
    return e7;
  }
};
function i2(t3, e7, i6, n4, h3) {
  new Uint8Array(t3, i6, h3).set(new Uint8Array(e7, n4, h3), 0);
}
function n3(t3) {
  return new TextEncoder().encode(t3).buffer;
}
function h2(t3, e7) {
  return e7 * Math.ceil(t3 / e7);
}
e4.HEADER_SIZE = 12, e4.CHUNK_HEADER_SIZE = 8, e4.MAGIC = 1179937895, e4.VERSION = 2;

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/types.js
var E;
var A;
var R;
var L;
var o4;
var I;
var N2;
!function(E2) {
  E2[E2.External = 0] = "External", E2[E2.DataURI = 1] = "DataURI", E2[E2.GLB = 2] = "GLB";
}(E || (E = {})), function(E2) {
  E2[E2.External = 0] = "External", E2[E2.DataURI = 1] = "DataURI", E2[E2.GLB = 2] = "GLB";
}(A || (A = {})), function(E2) {
  E2[E2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", E2[E2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(R || (R = {})), function(E2) {
  E2.SCALAR = "SCALAR", E2.VEC2 = "VEC2", E2.VEC3 = "VEC3", E2.VEC4 = "VEC4", E2.MAT2 = "MAT2", E2.MAT3 = "MAT3", E2.MAT4 = "MAT4";
}(L || (L = {})), function(E2) {
  E2[E2.POINTS = 0] = "POINTS", E2[E2.LINES = 1] = "LINES", E2[E2.LINE_LOOP = 2] = "LINE_LOOP", E2[E2.LINE_STRIP = 3] = "LINE_STRIP", E2[E2.TRIANGLES = 4] = "TRIANGLES", E2[E2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", E2[E2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
}(o4 || (o4 = {})), function(E2) {
  E2.OPAQUE = "OPAQUE", E2.MASK = "MASK", E2.BLEND = "BLEND";
}(I || (I = {})), function(E2) {
  E2[E2.NoColor = 0] = "NoColor", E2[E2.FaceColor = 1] = "FaceColor", E2[E2.VertexColor = 2] = "VertexColor";
}(N2 || (N2 = {}));

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/bufferview.js
var i3 = class {
  constructor(t3, s4, i6, r5, n4) {
    this._buffer = t3, this._componentType = i6, this._dataType = r5, this._data = [], this._isFinalized = false, this._accessorIndex = -1, this._accessorAttribute = null, this._accessorMin = null, this._accessorMax = null, s4.bufferViews || (s4.bufferViews = []), this.index = s4.bufferViews.length, this._bufferView = { buffer: t3.index, byteLength: -1, target: n4 };
    const a4 = this._getElementSize();
    a4 >= 4 && n4 !== R.ELEMENT_ARRAY_BUFFER && (this._bufferView.byteStride = a4), s4.bufferViews.push(this._bufferView), this._numComponentsForDataType = this._calculateNumComponentsForDataType();
  }
  push(e7) {
    const t3 = this._data.length;
    if (this._data.push(e7), this._accessorIndex >= 0) {
      const s4 = t3 % this._numComponentsForDataType, i6 = this._accessorMin[s4];
      this._accessorMin[s4] = "number" != typeof i6 ? e7 : Math.min(i6, e7);
      const r5 = this._accessorMax[s4];
      this._accessorMax[s4] = "number" != typeof r5 ? e7 : Math.max(r5, e7);
    }
  }
  get dataSize() {
    return this._data.length * this._sizeComponentType();
  }
  get byteSize() {
    function e7(e8, t3) {
      return t3 * Math.ceil(e8 / t3);
    }
    return e7(this.dataSize, 4);
  }
  getByteOffset() {
    if (!this._isFinalized)
      throw new Error("Cannot get BufferView offset until it is finalized");
    return this._buffer.getByteOffset(this);
  }
  get byteOffset() {
    if (!this._isFinalized)
      throw new Error("Cannot get BufferView offset until it is finalized");
    return this._buffer.getByteOffset(this);
  }
  _createTypedArray(e7, t3) {
    switch (this._componentType) {
      case C2.BYTE:
        return new Int8Array(e7, t3);
      case C2.FLOAT:
        return new Float32Array(e7, t3);
      case C2.SHORT:
        return new Int16Array(e7, t3);
      case C2.UNSIGNED_BYTE:
        return new Uint8Array(e7, t3);
      case C2.UNSIGNED_INT:
        return new Uint32Array(e7, t3);
      case C2.UNSIGNED_SHORT:
        return new Uint16Array(e7, t3);
    }
  }
  writeOutToBuffer(e7, t3) {
    this._createTypedArray(e7, t3).set(this._data);
  }
  writeAsync(e7) {
    if (this._asyncWritePromise)
      throw new Error("Can't write multiple bufferView values asynchronously");
    return this._asyncWritePromise = e7.then((e8) => {
      const t3 = new Uint8Array(e8);
      for (let s4 = 0; s4 < t3.length; ++s4)
        this._data.push(t3[s4]);
      delete this._asyncWritePromise;
    }), this._asyncWritePromise;
  }
  startAccessor(e7) {
    if (this._accessorIndex >= 0)
      throw new Error("Accessor was started without ending the previous one");
    this._accessorIndex = this._data.length, this._accessorAttribute = e7;
    const t3 = this._numComponentsForDataType;
    this._accessorMin = new Array(t3), this._accessorMax = new Array(t3);
  }
  endAccessor() {
    if (this._accessorIndex < 0)
      throw new Error("An accessor was not started, but was attempted to be ended");
    const e7 = this._getElementSize(), t3 = this._numComponentsForDataType, i6 = (this._data.length - this._accessorIndex) / t3;
    if (i6 % 1)
      throw new Error("An accessor was ended with missing component values");
    for (let s4 = 0; s4 < this._accessorMin.length; ++s4)
      "number" != typeof this._accessorMin[s4] && (this._accessorMin[s4] = 0), "number" != typeof this._accessorMax[s4] && (this._accessorMax[s4] = 0);
    const r5 = { byteOffset: e7 * (this._accessorIndex / t3), componentType: this._componentType, count: i6, type: this._dataType, min: this._accessorMin, max: this._accessorMax, name: this._accessorAttribute };
    switch (this._accessorAttribute) {
      case "TEXCOORD_0":
      case "TEXCOORD_1":
      case "COLOR_0":
      case "WEIGHTS_0":
        switch (this._componentType) {
          case C2.UNSIGNED_BYTE:
          case C2.UNSIGNED_SHORT:
            r5.normalized = true;
        }
    }
    return this._accessorIndex = -1, this._accessorAttribute = null, this._accessorMin = null, this._accessorMax = null, r5;
  }
  get finalized() {
    return this._finalizedPromise ? this._finalizedPromise : this._isFinalized ? this._finalizedPromise = Promise.resolve() : this._finalizedPromise = new Promise((e7) => this._finalizedPromiseResolve = e7);
  }
  async finalize() {
    const e7 = this._bufferView, t3 = this._buffer.getViewFinalizePromises(this);
    this._asyncWritePromise && t3.push(this._asyncWritePromise), await Promise.allSettled(t3), this._isFinalized = true, e7.byteOffset = this.getByteOffset(), e7.byteLength = this.dataSize, this._finalizedPromiseResolve && this._finalizedPromiseResolve();
  }
  _getElementSize() {
    return this._sizeComponentType() * this._numComponentsForDataType;
  }
  _sizeComponentType() {
    switch (this._componentType) {
      case C2.BYTE:
      case C2.UNSIGNED_BYTE:
        return 1;
      case C2.SHORT:
      case C2.UNSIGNED_SHORT:
        return 2;
      case C2.UNSIGNED_INT:
      case C2.FLOAT:
        return 4;
    }
  }
  _calculateNumComponentsForDataType() {
    switch (this._dataType) {
      case L.SCALAR:
        return 1;
      case L.VEC2:
        return 2;
      case L.VEC3:
        return 3;
      case L.VEC4:
      case L.MAT2:
        return 4;
      case L.MAT3:
        return 9;
      case L.MAT4:
        return 16;
    }
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/buffer.js
var i4 = class {
  constructor(e7) {
    this._gltf = e7, this._bufferViews = [], this._isFinalized = false, e7.buffers || (e7.buffers = []), this.index = e7.buffers.length;
    const i6 = { byteLength: -1 };
    e7.buffers.push(i6), this._buffer = i6;
  }
  addBufferView(i6, t3, r5) {
    if (this._finalizePromise)
      throw new Error("Cannot add buffer view after fiinalizing buffer");
    const f5 = new i3(this, this._gltf, i6, t3, r5);
    return this._bufferViews.push(f5), f5;
  }
  getByteOffset(e7) {
    let i6 = 0;
    for (const t3 of this._bufferViews) {
      if (t3 === e7)
        return i6;
      i6 += t3.byteSize;
    }
    throw new Error("Given bufferView was not present in this buffer");
  }
  getViewFinalizePromises(e7) {
    const i6 = [];
    for (const t3 of this._bufferViews) {
      if (e7 && t3 === e7)
        return i6;
      i6.push(t3.finalized);
    }
    return i6;
  }
  getArrayBuffer() {
    if (!this._isFinalized)
      throw new Error("Cannot get ArrayBuffer from Buffer before it is finalized");
    const e7 = this._getTotalSize(), i6 = new ArrayBuffer(e7);
    let t3 = 0;
    for (const r5 of this._bufferViews)
      r5.writeOutToBuffer(i6, t3), t3 += r5.byteSize;
    return i6;
  }
  finalize() {
    var _a;
    if (this._finalizePromise)
      throw new Error(`Buffer ${this.index} was already finalized`);
    return this._finalizePromise = Promise.allSettled(this.getViewFinalizePromises()).then(() => {
      this._isFinalized = true;
      const e7 = this.getArrayBuffer();
      this._buffer.byteLength = e7.byteLength, this._buffer.uri = e7;
    }), (_a = this._gltf.extras) == null ? void 0 : _a.promises.push(this._finalizePromise), this._finalizePromise;
  }
  _getTotalSize() {
    let e7 = 0;
    for (const i6 of this._bufferViews)
      e7 += i6.byteSize;
    return e7;
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/geometry.js
function c2(o5, n4) {
  if (o5.components)
    for (const s4 of o5.components)
      s4.faces && "smooth" === s4.shading && e5(s4, n4);
}
function e5(r5, c3) {
  null == c3.normal && (c3.normal = new Float32Array(c3.position.length));
  const e7 = r5.faces, { position: m2, normal: p2 } = c3, h3 = e7.length / 3;
  for (let t3 = 0; t3 < h3; ++t3) {
    const r6 = 3 * e7[3 * t3], c4 = 3 * e7[3 * t3 + 1], l3 = 3 * e7[3 * t3 + 2], h4 = o(a2, m2[r6], m2[r6 + 1], m2[r6 + 2]), g2 = o(f2, m2[c4], m2[c4 + 1], m2[c4 + 2]), u2 = o(i5, m2[l3], m2[l3 + 1], m2[l3 + 2]), b = e(g2, g2, h4), j = e(u2, u2, h4), v2 = _2(b, b, j);
    p2[r6] += v2[0], p2[r6 + 1] += v2[1], p2[r6 + 2] += v2[2], p2[c4] += v2[0], p2[c4 + 1] += v2[1], p2[c4 + 2] += v2[2], p2[l3] += v2[0], p2[l3 + 1] += v2[1], p2[l3 + 2] += v2[2];
  }
  for (let n4 = 0; n4 < p2.length; n4 += 3)
    o(l2, p2[n4], p2[n4 + 1], p2[n4 + 2]), z2(l2, l2), p2[n4] = l2[0], p2[n4 + 1] = l2[1], p2[n4 + 2] = l2[2];
}
var a2 = n2();
var f2 = n2();
var i5 = n2();
var l2 = n2();

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltf.js
var L2 = () => n.getLogger("gltf");
var S = class {
  constructor(e7, t3, s4) {
    this.params = {}, this._materialMap = new Array(), this._imageMap = /* @__PURE__ */ new Map(), this._textureMap = /* @__PURE__ */ new Map(), this.gltf = { asset: { version: "2.0", copyright: e7.copyright, generator: e7.generator }, extras: { options: t3, binChunkBuffer: null, promises: [] } }, s4 && (this.params = s4), this._addScenes(e7);
  }
  _addScenes(e7) {
    this.gltf.scene = e7.defaultScene;
    const t3 = this.gltf.extras, s4 = t3.options.bufferOutputType === E.GLB || t3.options.imageOutputType === A.GLB;
    s4 && (t3.binChunkBuffer = new i4(this.gltf)), e7.forEachScene((e8) => {
      this._addScene(e8);
    }), s4 && t3.binChunkBuffer.finalize();
  }
  _addScene(e7) {
    this.gltf.scenes || (this.gltf.scenes = []);
    const t3 = {};
    e7.name && (t3.name = e7.name), e7.forEachNode((e8) => {
      t3.nodes || (t3.nodes = []), t3.nodes.push(...this._addNodes(e8));
    }), this.gltf.scenes.push(t3);
  }
  _addNodes(e7) {
    this.gltf.nodes || (this.gltf.nodes = []);
    const t3 = {};
    e7.name && (t3.name = e7.name);
    const s4 = e7.translation;
    G(s4, l) || (t3.translation = t(s4));
    const r5 = e7.rotation;
    N(r5, o3) || (t3.rotation = r2(r5));
    const i6 = e7.scale;
    G(i6, _) || (t3.scale = t(i6));
    const a4 = this.gltf.nodes.length;
    if (this.gltf.nodes.push(t3), e7.mesh && e7.mesh.vertexAttributes.position) {
      const s5 = this._createMeshes(e7.mesh), r6 = [a4];
      if (1 === s5.length)
        this._addMesh(t3, s5[0]);
      else
        for (const e8 of s5) {
          const t4 = {};
          this._addMesh(t4, e8), r6.push(this.gltf.nodes.length), this.gltf.nodes.push(t4);
        }
      return r6;
    }
    return e7.forEachNode((e8) => {
      t3.children || (t3.children = []), t3.children.push(...this._addNodes(e8));
    }), [a4];
  }
  _addMesh(e7, t3) {
    var _a;
    (_a = this.gltf).meshes ?? (_a.meshes = []);
    const s4 = this.gltf.meshes.length;
    this.gltf.meshes.push(t3), e7.mesh = s4;
  }
  _createMeshes(t3) {
    const s4 = this.gltf.extras, r5 = s4.options.bufferOutputType === E.GLB;
    let n4;
    n4 = r5 ? s4.binChunkBuffer : new i4(this.gltf), this.params.origin || (this.params.origin = t3.anchor);
    const { ignoreLocalTransform: l3 } = this.params, c3 = l3 ? null : t3.transform, { vertexSpace: h3, spatialReference: u2 } = t3, f5 = h3.origin, p2 = t3.vertexAttributes;
    let g2 = null;
    if ("local" === h3.type) {
      const e7 = z(u2);
      f(F, (c3 == null ? void 0 : c3.localMatrix) ?? o2, [e7, e7, e7]), g2 = O2(p2, F);
    } else {
      const e7 = l3 ? new i({ origin: f5 ? t(f5) : null }) : h3;
      g2 = C(p2, e7, c3, this.params.origin, { geographic: this.params.geographic, unit: "meters" });
    }
    if (null == g2)
      throw new s("Error during gltf export.");
    p2.position && g2.position === p2.position && (g2.position = p2.position.slice()), p2.normal && g2.normal === p2.normal && (g2.normal = p2.normal.slice()), p2.tangent && g2.tangent === p2.tangent && (g2.tangent = p2.tangent.slice()), c2(t3, g2), v(g2);
    const b = n4.addBufferView(C2.FLOAT, L.VEC3, R.ARRAY_BUFFER);
    let O3, w, I2, N3;
    g2.normal && (O3 = n4.addBufferView(C2.FLOAT, L.VEC3, R.ARRAY_BUFFER)), p2.uv && (w = n4.addBufferView(C2.FLOAT, L.VEC2, R.ARRAY_BUFFER)), g2.tangent && (I2 = n4.addBufferView(C2.FLOAT, L.VEC4, R.ARRAY_BUFFER)), p2.color && (N3 = n4.addBufferView(C2.UNSIGNED_BYTE, L.VEC4, R.ARRAY_BUFFER)), b.startAccessor("POSITION"), O3 && O3.startAccessor("NORMAL"), w && w.startAccessor("TEXCOORD_0"), I2 && I2.startAccessor("TANGENT"), N3 && N3.startAccessor("COLOR_0");
    const B = g2.position.length / 3, { position: L3, normal: S2, tangent: y2 } = g2, { color: j, uv: V } = p2;
    for (let e7 = 0; e7 < B; ++e7)
      b.push(L3[3 * e7]), b.push(L3[3 * e7 + 1]), b.push(L3[3 * e7 + 2]), O3 && null != S2 && (O3.push(S2[3 * e7]), O3.push(S2[3 * e7 + 1]), O3.push(S2[3 * e7 + 2])), w && null != V && (w.push(V[2 * e7]), w.push(V[2 * e7 + 1])), I2 && null != y2 && (I2.push(y2[4 * e7]), I2.push(y2[4 * e7 + 1]), I2.push(y2[4 * e7 + 2]), I2.push(y2[4 * e7 + 3])), N3 && null != j && (N3.push(j[4 * e7]), N3.push(j[4 * e7 + 1]), N3.push(j[4 * e7 + 2]), N3.push(j[4 * e7 + 3]));
    const D2 = b.endAccessor(), k = this._addAccessor(b.index, D2);
    let G2, U, P, z3, Y;
    if (O3) {
      const e7 = O3.endAccessor();
      G2 = this._addAccessor(O3.index, e7);
    }
    if (w) {
      const e7 = w.endAccessor();
      U = this._addAccessor(w.index, e7);
    }
    if (I2) {
      const e7 = I2.endAccessor();
      P = this._addAccessor(I2.index, e7);
    }
    if (N3) {
      const e7 = N3.endAccessor();
      z3 = this._addAccessor(N3.index, e7);
    }
    const q = [];
    return t3.components && t3.components.length > 0 && t3.components[0].faces ? (Y = n4.addBufferView(C2.UNSIGNED_INT, L.SCALAR, R.ELEMENT_ARRAY_BUFFER), this._addMeshVertexIndexed(Y, t3.components, q, k, G2, U, P, z3)) : this._addMeshVertexNonIndexed(t3.components, q, k, G2, U, P, z3), b.finalize(), O3 && O3.finalize(), w && w.finalize(), I2 && I2.finalize(), Y && Y.finalize(), N3 && N3.finalize(), r5 || n4.finalize(), q;
  }
  _addMaterial(e7) {
    if (null === e7)
      return;
    const t3 = this._materialMap.indexOf(e7);
    if (-1 !== t3)
      return t3;
    this.gltf.materials || (this.gltf.materials = []);
    const s4 = {};
    switch (e7.alphaMode) {
      case "mask":
        s4.alphaMode = I.MASK;
        break;
      case "auto":
      case "blend":
        s4.alphaMode = I.BLEND;
    }
    0.5 !== e7.alphaCutoff && (s4.alphaCutoff = e7.alphaCutoff), e7.doubleSided && (s4.doubleSided = e7.doubleSided), s4.pbrMetallicRoughness = {};
    const r5 = (e8) => e8 ** 2.1, i6 = (e8) => {
      const t4 = e8.toRgba();
      return t4[0] = r5(t4[0] / 255), t4[1] = r5(t4[1] / 255), t4[2] = r5(t4[2] / 255), t4;
    };
    if (null != e7.color && (s4.pbrMetallicRoughness.baseColorFactor = i6(e7.color)), null != e7.colorTexture && (s4.pbrMetallicRoughness.baseColorTexture = this._createTextureInfo(e7.colorTexture, e7.colorTextureTransform)), null != e7.normalTexture && (s4.normalTexture = this._createTextureInfo(e7.normalTexture, e7.normalTextureTransform)), e7 instanceof m) {
      if (null != e7.emissiveTexture && (s4.emissiveTexture = this._createTextureInfo(e7.emissiveTexture, e7.emissiveTextureTransform)), null != e7.emissiveColor) {
        const t4 = i6(e7.emissiveColor);
        s4.emissiveFactor = [t4[0], t4[1], t4[2]];
      }
      null != e7.occlusionTexture && (s4.occlusionTexture = this._createTextureInfo(e7.occlusionTexture, e7.occlusionTextureTransform)), null != e7.metallicRoughnessTexture && (s4.pbrMetallicRoughness.metallicRoughnessTexture = this._createTextureInfo(e7.metallicRoughnessTexture, e7.metallicRoughnessTextureTransform)), s4.pbrMetallicRoughness.metallicFactor = e7.metallic, s4.pbrMetallicRoughness.roughnessFactor = e7.roughness;
    } else
      s4.pbrMetallicRoughness.metallicFactor = 1, s4.pbrMetallicRoughness.roughnessFactor = 1, L2().warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back.");
    const a4 = this.gltf.materials.length;
    return this.gltf.materials.push(s4), this._materialMap.push(e7), a4;
  }
  _createTextureInfo(e7, t3) {
    const s4 = { index: this._addTexture(e7) };
    return t3 ? (s4.extensions || (s4.extensions = {}), s4.extensions.KHR_texture_transform = { scale: t3.scale, offset: t3.offset, rotation: h(t3.rotation) }, s4) : s4;
  }
  _addTexture(e7) {
    const t3 = this.gltf.textures ?? [];
    return this.gltf.textures = t3, r(this._textureMap, e7, () => {
      const s4 = { sampler: this._addSampler(e7), source: this._addImage(e7) }, r5 = t3.length;
      return t3.push(s4), r5;
    });
  }
  _addImage(e7) {
    const t3 = this._imageMap.get(e7);
    if (null != t3)
      return t3;
    this.gltf.images || (this.gltf.images = []);
    const s4 = {};
    if (e7.url)
      s4.uri = e7.url;
    else {
      const t4 = e7.data;
      s4.extras = t4;
      for (let e8 = 0; e8 < this.gltf.images.length; ++e8)
        if (t4 === this.gltf.images[e8].extras)
          return e8;
      const r6 = this.gltf.extras;
      switch (r6.options.imageOutputType) {
        case A.GLB: {
          const e8 = r6.binChunkBuffer.addBufferView(C2.UNSIGNED_BYTE, L.SCALAR);
          if (r3(t4))
            null != t4.data && e8.writeOutToBuffer(t4.data, 0);
          else {
            const r7 = r4(t4).then(({ data: e9, type: t5 }) => (s4.mimeType = t5, e9));
            e8.writeAsync(r7).then(() => {
              e8.finalize();
            });
          }
          s4.bufferView = e8.index;
          break;
        }
        case A.DataURI:
          if (r3(t4)) {
            L2().warnOnce("Image export for basis compressed textures not available.");
            break;
          }
          s4.uri = a(t4);
          break;
        default:
          if (r3(t4)) {
            L2().warnOnce("Image export for basis compressed textures not available.");
            break;
          }
          r6.promises.push(r4(t4).then(({ data: e8, type: t5 }) => {
            s4.uri = e8, s4.mimeType = t5;
          }));
      }
    }
    const r5 = this.gltf.images.length;
    return this.gltf.images.push(s4), this._imageMap.set(e7, r5), r5;
  }
  _addSampler(e7) {
    this.gltf.samplers || (this.gltf.samplers = []);
    let t3 = D.REPEAT, s4 = D.REPEAT;
    if ("string" == typeof e7.wrap)
      switch (e7.wrap) {
        case "clamp":
          t3 = D.CLAMP_TO_EDGE, s4 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          t3 = D.MIRRORED_REPEAT, s4 = D.MIRRORED_REPEAT;
      }
    else {
      switch (e7.wrap.vertical) {
        case "clamp":
          s4 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          s4 = D.MIRRORED_REPEAT;
      }
      switch (e7.wrap.horizontal) {
        case "clamp":
          t3 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          t3 = D.MIRRORED_REPEAT;
      }
    }
    const r5 = { wrapS: t3, wrapT: s4 };
    for (let a4 = 0; a4 < this.gltf.samplers.length; ++a4)
      if (JSON.stringify(r5) === JSON.stringify(this.gltf.samplers[a4]))
        return a4;
    const i6 = this.gltf.samplers.length;
    return this.gltf.samplers.push(r5), i6;
  }
  _addAccessor(e7, t3) {
    this.gltf.accessors || (this.gltf.accessors = []);
    const s4 = { bufferView: e7, byteOffset: t3.byteOffset, componentType: t3.componentType, count: t3.count, type: t3.type, min: t3.min, max: t3.max, name: t3.name };
    t3.normalized && (s4.normalized = true);
    const r5 = this.gltf.accessors.length;
    return this.gltf.accessors.push(s4), r5;
  }
  _addMeshVertexIndexed(e7, t3, s4, r5, i6, a4, o5, n4) {
    const l3 = /* @__PURE__ */ new Map();
    for (const c3 of t3) {
      e7.startAccessor("INDICES");
      for (let s5 = 0; s5 < c3.faces.length; ++s5)
        e7.push(c3.faces[s5]);
      const t4 = e7.endAccessor(), h3 = { attributes: { POSITION: r5 }, indices: this._addAccessor(e7.index, t4), material: this._addMaterial(c3.material) };
      i6 && "flat" !== c3.shading && (h3.attributes.NORMAL = i6), a4 && (h3.attributes.TEXCOORD_0 = a4), o5 && "flat" !== c3.shading && (h3.attributes.TANGENT = o5), n4 && (h3.attributes.COLOR_0 = n4);
      const u2 = l3.get(c3.name);
      if (u2)
        u2.primitives.push(h3);
      else {
        const e8 = { name: c3.name, primitives: [h3] };
        l3.set(c3.name, e8), s4.push(e8);
      }
    }
  }
  _addMeshVertexNonIndexed(e7, t3, s4, r5, i6, a4, o5) {
    const n4 = { primitives: [] };
    t3.push(n4);
    const l3 = { attributes: { POSITION: s4 } };
    r5 && (l3.attributes.NORMAL = r5), i6 && (l3.attributes.TEXCOORD_0 = i6), a4 && (l3.attributes.TANGENT = a4), o5 && (l3.attributes.COLOR_0 = o5), e7 && (l3.material = this._addMaterial(e7[0].material)), n4.primitives.push(l3);
  }
};
function v({ position: e7, normal: t3, tangent: s4 }) {
  y(e7, 3), y(t3, 3), y(s4, 4);
}
function y(e7, t3) {
  if (null != e7)
    for (let s4 = 1, r5 = 2; s4 < e7.length; s4 += t3, r5 += t3) {
      const t4 = e7[s4], i6 = e7[r5];
      e7[s4] = i6, e7[r5] = -t4;
    }
}
var F = e2();

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/asset.js
var s2 = class {
  constructor() {
    this.copyright = "", this.defaultScene = 0, this.generator = "", this._scenes = [];
  }
  addScene(e7) {
    if (this._scenes.includes(e7))
      throw new Error("Scene already added");
    this._scenes.push(e7);
  }
  removeScene(s4) {
    O(this._scenes, s4);
  }
  forEachScene(e7) {
    this._scenes.forEach(e7);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/scene.js
var d = class {
  constructor() {
    this.name = "", this._nodes = [];
  }
  addNode(d2) {
    if (this._nodes.includes(d2))
      throw new Error("Node already added");
    this._nodes.push(d2);
  }
  forEachNode(d2) {
    this._nodes.forEach(d2);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/node.js
var e6 = class {
  constructor(t3) {
    this.mesh = t3, this.name = "", this.translation = n2(), this.rotation = e3(), this.scale = t(_), this._nodes = [];
  }
  addNode(t3) {
    if (this._nodes.includes(t3))
      throw new Error("Node already added");
    this._nodes.push(t3);
  }
  forEachNode(t3) {
    this._nodes.forEach(t3);
  }
  set rotationAngles(s4) {
    T(this.rotation, s4[0], s4[1], s4[2]);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/index.js
var a3 = "model.gltf";
var f3 = "model.glb";
async function u(u2, p2, m2) {
  var _a;
  const c3 = new S(u2, p2 = p2 || {}, m2);
  let l3 = c3.params;
  l3 ? l3.origin || (l3.origin = new x({ x: -1, y: -1, z: -1 })) : l3 = { origin: new x({ x: -1, y: -1, z: -1 }) };
  const g2 = l3.origin, y2 = c3.gltf, d2 = ((_a = y2.extras) == null ? void 0 : _a.promises) ?? [];
  let j = 1, x2 = 1, b = null;
  await Promise.allSettled(d2);
  const w = { origin: g2 };
  delete y2.extras;
  const B = "number" == typeof p2.jsonSpacing ? p2.jsonSpacing : 4, h3 = JSON.stringify(y2, (e7, t3) => {
    if ("extras" !== e7) {
      if (t3 instanceof ArrayBuffer) {
        if (g(t3))
          switch (p2.imageOutputType) {
            case A.DataURI:
            case A.GLB:
              break;
            case A.External:
            default: {
              const e8 = `img${x2}.png`;
              return x2++, w[e8] = t3, e8;
            }
          }
        switch (p2.bufferOutputType) {
          case E.DataURI:
            return c(t3);
          case E.GLB:
            if (b)
              throw new Error("Already encountered an ArrayBuffer, there should only be one in the GLB format.");
            return void (b = t3);
          case E.External:
          default: {
            const e8 = `data${j}.bin`;
            return j++, w[e8] = t3, e8;
          }
        }
      }
      return t3;
    }
  }, B);
  return p2.bufferOutputType === E.GLB || p2.imageOutputType === A.GLB ? w[f3] = new e4(h3, b).buffer : w[a3] = h3, w;
}
function p(e7, t3) {
  return u(e7, { bufferOutputType: E.GLB, imageOutputType: A.GLB, jsonSpacing: 0 }, t3);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltfexport.js
var s3 = class {
  constructor(e7, o5) {
    this._file = { type: "model/gltf-binary", data: e7 }, this.origin = o5;
  }
  buffer() {
    return Promise.resolve(this._file);
  }
  download(o5) {
    ct(new Blob([this._file.data], { type: this._file.type }), o5);
  }
};
function f4(e7, f5) {
  const d2 = new s2(), l3 = new d();
  return d2.addScene(l3), l3.addNode(new e6(e7)), p(d2, f5).then((e8) => new s3(e8[f3], e8.origin));
}
export {
  f4 as toBinaryGLTF
};
//# sourceMappingURL=gltfexport-IGV4P7TR.js.map
