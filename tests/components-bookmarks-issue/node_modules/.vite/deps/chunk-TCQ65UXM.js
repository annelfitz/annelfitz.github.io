import {
  Z
} from "./chunk-RK2U53CD.js";
import {
  n
} from "./chunk-SCHTG6ZQ.js";
import {
  Ee,
  F,
  T,
  be,
  he,
  l
} from "./chunk-X7VSXJWW.js";
import {
  s
} from "./chunk-C62RZQQX.js";
import {
  i,
  r2 as r
} from "./chunk-7RBRCL6S.js";
import {
  k
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/widgets/FeatureForm/featureFormUtils.js
var d = (e) => "field" === (e == null ? void 0 : e.type);
var c = (e) => "group" === (e == null ? void 0 : e.type);
var f = (e) => "relationship" === (e == null ? void 0 : e.type);
var y = (e) => !c(e) && null != e.group;
var b = (e) => "field" === e.type;
var T2 = (e) => "group" === e.type;
var x = (e) => "relationship" === e.type;
var g = (e) => e.reduce((e2, t) => c(t) ? [...e2, ...t.inputs] : [...e2, t], []);
var O = (e) => g(e).filter(d);
var j = (e) => g(e).filter(f);
var E = (e) => null != e && (v(e, "combo-box") || v(e, "radio-buttons"));
var v = (e, t) => {
  var _a;
  return null != e && ((_a = e.input) == null ? void 0 : _a.type) === t;
};
var V = (e) => null != e && (v(e, "text-box") || v(e, "text-area"));
var U = ({ domain: e, inputType: t = "text-box", dataType: n2 }) => "number" === n2 && "text-box" === t && (!e || "coded-value" !== e.type);
var h = (e) => "items" in e;
var N = { typeFieldName: null, types: [] };
function _(t) {
  const { attributes: r2, fieldsIndex: o, label: i2, timeZone: l2 } = t;
  if (!r2 || "object" != typeof r2)
    return i2;
  const a = Object.keys(r2).filter((e) => i(i2, e)), s2 = a.map((e) => r2[e]), u = a.map((e) => o.get(e)).filter(k);
  return I(i2, A({ values: s2, fields: u, timeZone: l2 }));
}
function A(e) {
  const { fields: t, values: n2 } = e, r2 = e.timeZone ?? void 0, o = t.map((e2, t2) => {
    let o2 = n2[t2];
    if (e2.domain && "coded-value" === e2.domain.type) {
      const t3 = e2.domain.codedValues.find((e3) => e3.code === o2);
      (t3 == null ? void 0 : t3.name) && (o2 = t3.name);
    }
    return (Z(e2) || be(e2)) && (o2 = T(e2, o2, { timeZone: r2, ...F(e2) })), [e2.name, o2];
  });
  return Object.fromEntries(o);
}
function I(e, t) {
  return r(r(e, (e2) => `{${e2.toLowerCase()}}`), Object.fromEntries(Object.entries(t).map(([e2, t2]) => [e2.toLowerCase(), t2])));
}
var L = (e) => {
  var _a, _b;
  return e ? "subtype-sublayer" === e.type ? { typeFieldName: (_a = e.parent) == null ? void 0 : _a.subtypeField, types: ((_b = e.parent) == null ? void 0 : _b.subtypes) ?? [] } : "types" in e && e.types ? { typeFieldName: e.typeIdField, types: e.types.map(({ id: e2, name: t, domains: n2 }) => ({ code: e2, name: t, domains: n2 })) } : N : N;
};
var R = (e, t) => {
  if (!e)
    return true;
  const { operations: n2 } = e;
  switch (t) {
    case "INSERT":
      return n2.supportsAdd;
    case "UPDATE":
    case "DELETE":
      return n2.supportsUpdate;
    default:
      return true;
  }
};
var F2;
!function(e) {
  e.TOO_SHORT = "length-validation-error::too-short";
}(F2 || (F2 = {}));
var D = { type: "number" };
var Z2 = { type: "number", intlOptions: { notation: "scientific" } };
function w(e) {
  return e >= 1e7 || e <= -1e7;
}
function C(e, { validationErrors: t }) {
  return null != e.max && null != e.min ? t.outsideRange : null != e.max ? t.outsideRangeMax : t.outsideRangeMin;
}
var S = (e, t, n2) => {
  const { dataType: r2, error: i2, minLength: s2, value: u, required: d2 } = e, c2 = t == null ? void 0 : t.validationErrors;
  if (!c2 || !i2)
    return null;
  if (d2 && null === u)
    return c2.cannotBeNull;
  if (i2 === l.VALUE_OUT_OF_RANGE || i2 === he.OUT_OF_RANGE) {
    const { field: o, range: i3 } = e, l2 = { type: "date", intlOptions: { timeZone: "date" === o.type && n2 ? n2 : void 0, ...F(o) } }, a = C(i3, t);
    return s(a, i3, { format: { max: "date" === r2 ? l2 : null != i3.max && w(i3.max) ? Z2 : D, min: "date" === r2 ? l2 : null != i3.min && w(i3.min) ? Z2 : D } });
  }
  return i2 === l.INVALID_CODED_VALUE ? c2.invalidCodedValue : i2 === Ee.INVALID_TYPE ? c2.invalidType : i2 === F2.TOO_SHORT ? s(c2.tooShort, { min: s2 }) : null;
};
var M = (e) => {
  var _a;
  if (!e)
    return;
  const t = e.layer, n2 = t && "geometryType" in t ? t.geometryType : void 0, r2 = (_a = e.geometry) == null ? void 0 : _a.type;
  return "polyline" === r2 || "polyline" === n2 ? "line" : r2 || n2 || "table";
};
var G = (e) => {
  var _a;
  const t = [];
  if (e.formTemplate) {
    const { description: r2, title: o } = e.formTemplate;
    (_a = e.fields) == null ? void 0 : _a.forEach((e2) => {
      const i2 = o && i(o, e2.name), l2 = r2 && i(r2, e2.name);
      (i2 || l2) && t.push(e2.name);
    });
  }
  return t;
};
function H(e, t) {
  var _a;
  const n2 = t ?? ("formTemplate" in e && e.formTemplate);
  if (n2) {
    return (((_a = n2.elements) == null ? void 0 : _a.filter(b)) ?? []).some(({ fieldName: t2 }) => !e.fieldsIndex.get(t2));
  }
  return false;
}
function P(e, t) {
  return null == e || t.onValue !== e && t.offValue !== e;
}
function k2(e, n2) {
  var _a;
  switch (n2.objectType) {
    case "any":
      return true;
    case "null":
      return null == e;
    case "code":
      return e === ((_a = n2.codedValue) == null ? void 0 : _a.code);
    case "range":
      return null != e && null != n2.minValue && null != n2.maxValue && +e >= n2.minValue && +e <= n2.maxValue;
    default:
      return n(n2.objectType), false;
  }
}

export {
  d,
  c,
  f,
  y,
  b,
  T2 as T,
  x,
  O,
  j,
  E,
  v,
  V,
  U,
  h,
  _,
  A,
  L,
  R,
  F2 as F,
  S,
  M,
  G,
  H,
  P,
  k2 as k
};
//# sourceMappingURL=chunk-TCQ65UXM.js.map
