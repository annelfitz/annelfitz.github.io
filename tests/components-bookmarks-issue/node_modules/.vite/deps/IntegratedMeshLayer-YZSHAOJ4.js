import {
  f as f2
} from "./chunk-QJ6L2QIQ.js";
import {
  j as j2
} from "./chunk-VXM3PR7E.js";
import "./chunk-VE57JPH4.js";
import {
  a as a3,
  m,
  p,
  y as y2
} from "./chunk-67A4RFMD.js";
import {
  C as C2,
  L
} from "./chunk-YULKNNDN.js";
import "./chunk-A64EK7QM.js";
import {
  I as I2,
  P,
  y as y3
} from "./chunk-SA77Z3WI.js";
import "./chunk-FLBJ53KN.js";
import {
  i
} from "./chunk-QMPD4WXY.js";
import "./chunk-YBPOKK6D.js";
import {
  l
} from "./chunk-AHEDDTVZ.js";
import {
  e as e2
} from "./chunk-XW3FDKYP.js";
import "./chunk-EDPA37RA.js";
import "./chunk-DORNK7ZC.js";
import "./chunk-OWKPWQPA.js";
import "./chunk-CQFVWMFK.js";
import {
  j
} from "./chunk-4ZLXDMI5.js";
import "./chunk-VQWLJR3W.js";
import {
  t
} from "./chunk-UUG4W2PI.js";
import {
  u as u3
} from "./chunk-WW22JHXA.js";
import {
  S
} from "./chunk-ZAM62XN5.js";
import {
  f
} from "./chunk-RKVEKQ5O.js";
import "./chunk-P7J4JFEH.js";
import {
  b
} from "./chunk-G7FOE26O.js";
import "./chunk-USOPZ2Q6.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-AKLOTDO2.js";
import "./chunk-6AQIVLDN.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-RDPH36VD.js";
import "./chunk-LBXFRGMS.js";
import "./chunk-VTH4DAHQ.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import {
  u as u2
} from "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-TPLOIZC7.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import {
  o
} from "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-JCZIM4PO.js";
import {
  I,
  U
} from "./chunk-SAYWXQVM.js";
import {
  u2 as u
} from "./chunk-SBL4URUW.js";
import {
  C,
  v
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a2
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  a
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/layers/support/SceneModifications.js
var m2;
var n2 = m2 = class extends u(V.ofType(f2)) {
  constructor(r) {
    super(r), this.url = null;
  }
  clone() {
    return new m2({ url: this.url, items: this.items.map((r) => r.clone()) });
  }
  toJSON(r) {
    return this.toArray().map((o2) => o2.toJSON(r)).filter((r2) => !!r2.geometry);
  }
  static fromJSON(r, o2) {
    const t2 = new m2();
    for (const e3 of r)
      t2.add(f2.fromJSON(e3, o2));
    return t2;
  }
  static async fromUrl(r, t2, e3) {
    const i2 = { url: I(r), origin: "service" }, c = await U(r, { responseType: "json", signal: e3 == null ? void 0 : e3.signal }), n3 = t2.toJSON(), a5 = [];
    for (const o2 of c.data)
      a5.push(f2.fromJSON({ ...o2, geometry: { ...o2.geometry, spatialReference: n3 } }, i2));
    return new m2({ url: r, items: a5 });
  }
};
e([y({ type: String })], n2.prototype, "url", void 0), n2 = m2 = e([a2("esri.layers.support.SceneModifications")], n2);
var a4 = n2;

// node_modules/@arcgis/core/layers/IntegratedMeshLayer.js
var A = class extends L(l(u3(j(t(S(e2(i(b)))))))) {
  constructor(...e3) {
    super(...e3), this.geometryType = "mesh", this.operationalLayerType = "IntegratedMeshLayer", this.type = "integrated-mesh", this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.profile = "mesh-pyramids", this.modifications = null, this._modificationsSource = null, this.path = null;
  }
  initialize() {
    this.addHandles(v(() => this.modifications, "after-changes", () => this.modifications = this.modifications, C));
  }
  normalizeCtorArgs(e3, t2) {
    return "string" == typeof e3 ? { url: e3, ...t2 } : e3;
  }
  readModifications(e3, t2, o2) {
    this._modificationsSource = { url: u2(e3, o2), context: o2 };
  }
  set elevationInfo(e3) {
    this._set("elevationInfo", e3), this._validateElevationInfo();
  }
  async load(e3) {
    return this.addResolvingPromise(this._doLoad(e3)), this;
  }
  async _doLoad(e3) {
    const t2 = e3 == null ? void 0 : e3.signal;
    try {
      await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e3);
    } catch (o2) {
      a(o2);
    }
    if (await this._fetchService(t2), null != this._modificationsSource) {
      const t3 = await a4.fromUrl(this._modificationsSource.url, this.spatialReference, e3);
      this.setAtOrigin("modifications", t3, this._modificationsSource.context.origin), this._modificationsSource = null;
    }
    await this._fetchIndexAndUpdateExtent(this.nodePages, t2);
  }
  beforeSave() {
    if (null != this._modificationsSource)
      return this.load().then(() => {
      }, () => {
      });
  }
  async saveAs(e3, t2) {
    return this._debouncedSaveOperations(C2.SAVE_AS, { ...t2, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" }, e3);
  }
  async save() {
    const e3 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" };
    return this._debouncedSaveOperations(C2.SAVE, e3);
  }
  validateLayer(e3) {
    if (e3.layerType && "IntegratedMesh" !== e3.layerType)
      throw new s("integrated-mesh-layer:layer-type-not-supported", "IntegratedMeshLayer does not support this layer type", { layerType: e3.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor))
      throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
    if (this.version.major > 1)
      throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
  }
  _getTypeKeywords() {
    return ["IntegratedMeshLayer"];
  }
  _validateElevationInfo() {
    const e3 = this.elevationInfo, t2 = "Integrated mesh layers";
    P(n.getLogger(this), y3(t2, "absolute-height", e3)), P(n.getLogger(this), I2(t2, e3));
  }
};
e([y({ type: String, readOnly: true })], A.prototype, "geometryType", void 0), e([y({ type: ["show", "hide"] })], A.prototype, "listMode", void 0), e([y({ type: ["IntegratedMeshLayer"] })], A.prototype, "operationalLayerType", void 0), e([y({ json: { read: false }, readOnly: true })], A.prototype, "type", void 0), e([y({ type: p, readOnly: true })], A.prototype, "nodePages", void 0), e([y({ type: [a3], readOnly: true })], A.prototype, "materialDefinitions", void 0), e([y({ type: [y2], readOnly: true })], A.prototype, "textureSetDefinitions", void 0), e([y({ type: [m], readOnly: true })], A.prototype, "geometryDefinitions", void 0), e([y({ readOnly: true })], A.prototype, "serviceUpdateTimeStamp", void 0), e([y({ type: a4 }), j2({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "modifications" })], A.prototype, "modifications", void 0), e([o(["web-scene", "portal-item"], "modifications")], A.prototype, "readModifications", null), e([y(f)], A.prototype, "elevationInfo", null), e([y({ type: String, json: { origins: { "web-scene": { read: true, write: true }, "portal-item": { read: true, write: true } }, read: false } })], A.prototype, "path", void 0), A = e([a2("esri.layers.IntegratedMeshLayer")], A);
var P2 = A;
export {
  P2 as default
};
//# sourceMappingURL=IntegratedMeshLayer-YZSHAOJ4.js.map
