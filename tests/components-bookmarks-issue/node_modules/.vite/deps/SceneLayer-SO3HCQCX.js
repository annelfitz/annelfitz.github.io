import {
  j as j3
} from "./chunk-VXM3PR7E.js";
import "./chunk-VE57JPH4.js";
import {
  i as i4,
  m as m4
} from "./chunk-D2U65FA6.js";
import {
  $ as $2
} from "./chunk-N7746YEI.js";
import "./chunk-DH7BG2VH.js";
import "./chunk-KSZESDGM.js";
import "./chunk-CHJMCUAV.js";
import "./chunk-5P74D2TG.js";
import "./chunk-33LWZO2E.js";
import "./chunk-YT66FIGM.js";
import "./chunk-VIKID44H.js";
import "./chunk-3IDXRFXE.js";
import "./chunk-TLU6YG3S.js";
import "./chunk-RLZYC2LS.js";
import "./chunk-WTKF56EK.js";
import "./chunk-3RIV3ECV.js";
import "./chunk-WEER6QME.js";
import "./chunk-IYU3Q2BA.js";
import "./chunk-L52HB3KV.js";
import "./chunk-TXLJQAAN.js";
import "./chunk-XJICXW6N.js";
import "./chunk-YF5E2R37.js";
import "./chunk-R4SGP2EA.js";
import "./chunk-IRL6OOVK.js";
import "./chunk-3AIILHI5.js";
import "./chunk-QJRGTKPN.js";
import "./chunk-VIH3KDZO.js";
import "./chunk-LA365FE7.js";
import {
  m as m2,
  s as s4
} from "./chunk-UYDBB2JF.js";
import {
  n as n3,
  p as p4
} from "./chunk-J6T3FJLS.js";
import {
  a as a4,
  m as m3,
  p as p2,
  y as y3
} from "./chunk-67A4RFMD.js";
import {
  C as C2,
  L
} from "./chunk-YULKNNDN.js";
import "./chunk-A64EK7QM.js";
import {
  I,
  P,
  Z as Z2
} from "./chunk-SA77Z3WI.js";
import {
  $
} from "./chunk-676ANOCK.js";
import "./chunk-6K2UNRXT.js";
import "./chunk-WTKV7W5Z.js";
import "./chunk-D4Y7YHG7.js";
import "./chunk-AL5NKCU5.js";
import "./chunk-6MBDB46F.js";
import "./chunk-D56W4LPT.js";
import "./chunk-BKOYOJBG.js";
import "./chunk-7JR6S3WL.js";
import "./chunk-CSSLIU64.js";
import "./chunk-CJNDQ2LH.js";
import "./chunk-B4E4X2TN.js";
import "./chunk-HS6YI5DU.js";
import "./chunk-CDBOQCLE.js";
import "./chunk-RSRUEM5U.js";
import "./chunk-HFJMEXIX.js";
import "./chunk-VYSGSKHB.js";
import "./chunk-DGJJJ2DD.js";
import "./chunk-UAFQMHYI.js";
import "./chunk-IDPLBNJX.js";
import "./chunk-ZHAZR5C3.js";
import "./chunk-P4MNTMCZ.js";
import {
  p as p6,
  t as t5
} from "./chunk-2CWW7O7M.js";
import "./chunk-FLBJ53KN.js";
import "./chunk-BSPKLAHD.js";
import "./chunk-5DH2QVPW.js";
import "./chunk-GPWQGIYV.js";
import "./chunk-WZJNHZ6H.js";
import "./chunk-XMYPMIYH.js";
import "./chunk-FQLGRQKL.js";
import {
  p as p5
} from "./chunk-JNGJWHJD.js";
import {
  i as i2
} from "./chunk-QMPD4WXY.js";
import "./chunk-YBPOKK6D.js";
import {
  l
} from "./chunk-AHEDDTVZ.js";
import {
  s as s5
} from "./chunk-IHQNQQJC.js";
import {
  i as i3
} from "./chunk-4IKPTZ53.js";
import {
  C as C3
} from "./chunk-DXMBDX2I.js";
import {
  u as u4
} from "./chunk-TUVEYM7U.js";
import "./chunk-5S637BGW.js";
import "./chunk-BFOJPIF7.js";
import "./chunk-GMRQGGML.js";
import "./chunk-BYK4ZOU2.js";
import {
  p as p3
} from "./chunk-OHYLFFUW.js";
import {
  e as e3
} from "./chunk-XW3FDKYP.js";
import "./chunk-Y7RXGLGH.js";
import "./chunk-3JC3OUNW.js";
import "./chunk-RO3CTAP7.js";
import "./chunk-GKMVTGGM.js";
import "./chunk-XGTCDM4C.js";
import {
  Z
} from "./chunk-QNG4TY7L.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import {
  T,
  V as V3
} from "./chunk-2NPNEA6N.js";
import "./chunk-U34ZXOJT.js";
import "./chunk-OKRW5W44.js";
import "./chunk-RGAA5Z76.js";
import "./chunk-Q6RZBEZ6.js";
import "./chunk-PC66NY33.js";
import "./chunk-YY2VB3AE.js";
import "./chunk-VEYMN5N3.js";
import "./chunk-H6NTWZSO.js";
import "./chunk-BMT3OVAP.js";
import {
  b as b3
} from "./chunk-W5ALAOW2.js";
import "./chunk-FHDHOWK5.js";
import "./chunk-Y546C2O5.js";
import "./chunk-IYKBAIQE.js";
import "./chunk-BDRVHR2K.js";
import "./chunk-DVIGFJWY.js";
import "./chunk-LQBHIBXV.js";
import "./chunk-42DUJ2CX.js";
import "./chunk-B35SNV2V.js";
import "./chunk-Z2F5OKVA.js";
import "./chunk-UQA6M3KF.js";
import "./chunk-GLF3KRAL.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-WIVZ7SMV.js";
import "./chunk-O76UVYOO.js";
import "./chunk-QCMUK3QA.js";
import "./chunk-HZSGATFT.js";
import "./chunk-KNMQQRV7.js";
import "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-AKQ765JR.js";
import "./chunk-ERD6I7QP.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-LMO6NZJA.js";
import "./chunk-A5QTLE4Y.js";
import "./chunk-SCHTG6ZQ.js";
import {
  r as r2,
  t as t4
} from "./chunk-YUUTEPX2.js";
import {
  g
} from "./chunk-OHE3HDFF.js";
import {
  f as f3
} from "./chunk-QYC3GV65.js";
import {
  P as P2
} from "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import "./chunk-EDPA37RA.js";
import "./chunk-DORNK7ZC.js";
import "./chunk-OWKPWQPA.js";
import "./chunk-CQFVWMFK.js";
import {
  j as j2
} from "./chunk-4ZLXDMI5.js";
import "./chunk-VQWLJR3W.js";
import {
  t as t3
} from "./chunk-UUG4W2PI.js";
import {
  u as u3
} from "./chunk-WW22JHXA.js";
import {
  S
} from "./chunk-ZAM62XN5.js";
import {
  c,
  f as f2,
  m,
  p,
  y as y2
} from "./chunk-RKVEKQ5O.js";
import "./chunk-P7J4JFEH.js";
import {
  b as b2
} from "./chunk-G7FOE26O.js";
import "./chunk-USOPZ2Q6.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import {
  n as n2
} from "./chunk-JW7VBMHD.js";
import "./chunk-GLLRUDMY.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import {
  i
} from "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import {
  r
} from "./chunk-6IED7TER.js";
import {
  p as p7,
  x as x2
} from "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-AKLOTDO2.js";
import "./chunk-6AQIVLDN.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import {
  t as t2
} from "./chunk-DVI5RM3W.js";
import "./chunk-RDPH36VD.js";
import "./chunk-LBXFRGMS.js";
import {
  s as s3
} from "./chunk-LRW6CHFI.js";
import {
  w as w2
} from "./chunk-VTH4DAHQ.js";
import {
  a as a5
} from "./chunk-GWC53NTZ.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import {
  u as u2
} from "./chunk-CZSTCON2.js";
import {
  F,
  en
} from "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import {
  j
} from "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-TPLOIZC7.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-5LSHHVQ5.js";
import "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import {
  o
} from "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-JCZIM4PO.js";
import {
  U,
  V as V2
} from "./chunk-SAYWXQVM.js";
import {
  f,
  u2 as u
} from "./chunk-SBL4URUW.js";
import {
  C,
  v,
  w
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  e as e2,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3,
  s3 as s2,
  t
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  a as a2,
  b
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  a,
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/layers/support/RangeInfo.js
var s6 = class extends f {
  constructor() {
    super(...arguments), this.name = null, this.field = null, this.currentRangeExtent = null, this.fullRangeExtent = null, this.type = "rangeInfo";
  }
};
e([y({ type: String, json: { read: true, write: true } })], s6.prototype, "name", void 0), e([y({ type: String, json: { read: true, write: true } })], s6.prototype, "field", void 0), e([y({ type: [Number], json: { read: true, write: true } })], s6.prototype, "currentRangeExtent", void 0), e([y({ type: [Number], json: { read: true, write: true } })], s6.prototype, "fullRangeExtent", void 0), e([y({ type: ["rangeInfo"], readOnly: true, json: { read: false, write: true } })], s6.prototype, "type", void 0), s6 = e([a3("esri.layers.support.RangeInfo")], s6);

// node_modules/@arcgis/core/layers/support/PolygonCollection.js
var c2;
var p8 = c2 = class extends u(V.ofType(j)) {
  constructor(e5) {
    super(e5);
  }
  clone() {
    return new c2(this.items.map((e5) => e5.clone()));
  }
  write(e5, r3) {
    return this.toJSON(r3);
  }
  toJSON(e5) {
    var _a;
    const r3 = (_a = e5 == null ? void 0 : e5.layer) == null ? void 0 : _a.spatialReference;
    return r3 ? this.toArray().map((t7) => {
      if (!r3.equals(t7.spatialReference)) {
        if (!F(t7.spatialReference, r3))
          return (e5 == null ? void 0 : e5.messages) && e5.messages.push(new s2("scenefilter:unsupported", "Scene filters with incompatible spatial references are not supported", { modification: this, spatialReference: e5.layer.spatialReference, context: e5 })), null;
        const s8 = new j();
        en(t7, s8, r3), t7 = s8;
      }
      const s7 = t7.toJSON(e5);
      return delete s7.spatialReference, s7;
    }).filter((e6) => null != e6) : ((e5 == null ? void 0 : e5.messages) && e5.messages.push(new s2("scenefilter:unsupported", "Writing Scene filters without context layer is not supported", { modification: this, spatialReference: e5.layer.spatialReference, context: e5 })), this.toArray().map((r4) => r4.toJSON(e5)));
  }
  static fromJSON(e5, r3) {
    const t7 = new c2();
    return e5.forEach((e6) => t7.add(j.fromJSON(e6, r3))), t7;
  }
};
p8 = c2 = e([a3("esri.layers.support.PolygonCollection")], p8);
var l2 = p8;

// node_modules/@arcgis/core/layers/support/SceneFilter.js
var u5;
var g2 = u5 = class extends f {
  constructor(e5) {
    super(e5), this.spatialRelationship = "disjoint", this.geometries = new l2(), this._geometriesSource = null;
  }
  initialize() {
    this.addHandles(v(() => this.geometries, "after-changes", () => this.geometries = this.geometries, C));
  }
  readGeometries(e5, r3, o2) {
    Array.isArray(e5) ? this.geometries = l2.fromJSON(e5, o2) : this._geometriesSource = { url: u2(e5, o2), context: o2 };
  }
  async loadGeometries(e5, o2) {
    if (null == this._geometriesSource)
      return;
    const { url: s7, context: t7 } = this._geometriesSource, i5 = await U(s7, { responseType: "json", signal: o2 == null ? void 0 : o2.signal }), a6 = e5.toJSON(), p9 = i5.data.map((e6) => ({ ...e6, spatialReference: a6 }));
    this.geometries = l2.fromJSON(p9, t7), this._geometriesSource = null;
  }
  clone() {
    const e5 = new u5({ geometries: a(this.geometries), spatialRelationship: this.spatialRelationship });
    return e5._geometriesSource = this._geometriesSource, e5;
  }
};
e([y({ type: ["disjoint", "contains"], nonNullable: true, json: { write: true } })], g2.prototype, "spatialRelationship", void 0), e([y({ type: l2, nonNullable: true, json: { write: true } }), j3({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "geometries", contentAddressed: true })], g2.prototype, "geometries", void 0), e([o(["web-scene", "portal-item"], "geometries")], g2.prototype, "readGeometries", null), g2 = u5 = e([a3("esri.layers.support.SceneFilter")], g2);
var h = g2;

// node_modules/@arcgis/core/support/zipUtils.js
async function e4(e5) {
  const r3 = [];
  for (const n4 of e5)
    n4.name.toLowerCase().endsWith(".zip") ? r3.push(t6(n4)) : r3.push(Promise.resolve(n4));
  return (await Promise.all(r3)).flat();
}
async function t6(e5) {
  const { BlobReader: t7, ZipReader: r3, BlobWriter: n4 } = await import("./zipjs-wrapper-WU4JY5S2.js"), a6 = [], i5 = new r3(new t7(e5));
  return (await i5.getEntries()).forEach((e6) => {
    var _a;
    if (e6.directory || /^__MACOS/i.test(e6.filename))
      return;
    const t8 = new n4(), r4 = (_a = e6.getData) == null ? void 0 : _a.call(e6, t8).then((t9) => new File([t9], e6.filename));
    r4 && a6.push(r4);
  }), Promise.all(a6);
}

// node_modules/@arcgis/core/layers/SceneLayer.js
var we = /* @__PURE__ */ new Set(["3DObject", "Point"]);
var Ie = s5();
var Le = class extends m2(g(L(l(u3(j2(t3(S(e3(i2(i(b2))))))))))) {
  constructor(...e5) {
    super(...e5), this.featureReduction = null, this.rangeInfos = null, this.operationalLayerType = "ArcGISSceneServiceLayer", this.type = "scene", this.fields = null, this.floorInfo = null, this.outFields = null, this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.excludeObjectIds = new V(), this.definitionExpression = null, this.filter = null, this.path = null, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.priority = null, this.semantic = null, this.cachedDrawingInfo = { color: false }, this.popupEnabled = true, this.popupTemplate = null, this.objectIdField = null, this.globalIdField = null, this._fieldUsageInfo = {}, this.screenSizePerspectiveEnabled = true, this.serviceItemId = void 0;
  }
  normalizeCtorArgs(e5, t7) {
    return "string" == typeof e5 ? { url: e5, ...t7 } : e5;
  }
  destroy() {
    this._set("renderer", null);
  }
  getField(e5) {
    return this.fieldsIndex.get(e5);
  }
  getFieldDomain(e5, t7) {
    var _a, _b, _c;
    const r3 = (_b = (_a = this.getFeatureType(t7 == null ? void 0 : t7.feature)) == null ? void 0 : _a.domains) == null ? void 0 : _b[e5];
    return r3 && "inherited" !== r3.type ? r3 : ((_c = this.getField(e5)) == null ? void 0 : _c.domain) ?? null;
  }
  getFeatureType(e5) {
    return e5 && this.associatedLayer ? this.associatedLayer.getFeatureType(e5) : null;
  }
  get types() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.types) ?? [];
  }
  get typeIdField() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.typeIdField) ?? null;
  }
  get templates() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.templates) ?? null;
  }
  get formTemplate() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.formTemplate) ?? null;
  }
  get fieldsIndex() {
    return new Z(this.fields);
  }
  readNodePages(e5, t7, r3) {
    return "Point" === t7.layerType && (e5 = t7.pointNodePages), null == e5 || "object" != typeof e5 ? null : p2.fromJSON(e5, r3);
  }
  set elevationInfo(e5) {
    this._set("elevationInfo", e5), this.loaded && this._validateElevationInfo();
  }
  get effectiveCapabilities() {
    var _a;
    return this._capabilitiesFromAssociatedFeatureLayer((_a = this.associatedLayer) == null ? void 0 : _a.effectiveCapabilities);
  }
  get effectiveEditingEnabled() {
    return null != this.associatedLayer && T(this.associatedLayer);
  }
  get geometryType() {
    return Fe[this.profile] || "mesh";
  }
  set renderer(e5) {
    p7(e5, this.fieldsIndex), this._set("renderer", e5);
  }
  readCachedDrawingInfo(e5) {
    return null != e5 && "object" == typeof e5 || (e5 = {}), null == e5.color && (e5.color = false), e5;
  }
  get capabilities() {
    var _a;
    return this._capabilitiesFromAssociatedFeatureLayer((_a = this.associatedLayer) == null ? void 0 : _a.capabilities);
  }
  _capabilitiesFromAssociatedFeatureLayer(e5) {
    var _a;
    e5 = null != e5 ? e5 : s4;
    const { query: t7, queryRelated: r3, editing: { supportsGlobalId: i5, supportsRollbackOnFailure: s7, supportsUploadWithItemId: o2, supportsGeometryUpdate: a6, supportsReturnServiceEditsInSourceSpatialReference: n4 }, data: { supportsZ: l3, supportsM: p9, isVersioned: d, supportsAttachment: y4 }, operations: { supportsEditing: u6, supportsAdd: c3, supportsUpdate: h2, supportsDelete: f4, supportsQuery: m5, supportsQueryAttachments: g3, supportsAsyncConvert3D: v2 } } = e5, b4 = e5.operations.supportsChangeTracking, w3 = !!((_a = this.associatedLayer) == null ? void 0 : _a.infoFor3D) && n2();
    return { query: t7, queryRelated: r3, editing: { supportsGlobalId: i5, supportsReturnServiceEditsInSourceSpatialReference: n4, supportsRollbackOnFailure: s7, supportsGeometryUpdate: w3 && a6, supportsUploadWithItemId: o2 }, data: { supportsAttachment: y4, supportsZ: l3, supportsM: p9, isVersioned: d }, operations: { supportsQuery: m5, supportsQueryAttachments: g3, supportsEditing: u6 && b4, supportsAdd: w3 && c3 && b4, supportsDelete: w3 && f4 && b4, supportsUpdate: h2 && b4, supportsAsyncConvert3D: v2 } };
  }
  get editingEnabled() {
    var _a;
    return this._isOverridden("editingEnabled") ? this._get("editingEnabled") : ((_a = this.associatedLayer) == null ? void 0 : _a.editingEnabled) ?? false;
  }
  set editingEnabled(e5) {
    this._overrideIfSome("editingEnabled", e5);
  }
  get infoFor3D() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.infoFor3D) ?? null;
  }
  get relationships() {
    var _a;
    return (_a = this.associatedLayer) == null ? void 0 : _a.relationships;
  }
  get defaultPopupTemplate() {
    return this.associatedLayer || this.attributeStorageInfo ? this.createPopupTemplate() : null;
  }
  readObjectIdField(e5, t7) {
    return !e5 && t7.fields && t7.fields.some((t8) => ("esriFieldTypeOID" === t8.type && (e5 = t8.name), !!e5)), e5 || void 0;
  }
  readGlobalIdField(e5, t7) {
    return !e5 && t7.fields && t7.fields.some((t8) => ("esriFieldTypeGlobalID" === t8.type && (e5 = t8.name), !!e5)), e5 || void 0;
  }
  get displayField() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.displayField) ?? null;
  }
  readProfile(e5, t7) {
    const r3 = t7.store.profile;
    return null != r3 && je[r3] ? je[r3] : (n.getLogger(this).error("Unknown or missing profile", { profile: r3, layer: this }), "mesh-pyramids");
  }
  load(e5) {
    return this.addResolvingPromise(this._load(e5)), Promise.resolve(this);
  }
  async _load(e5) {
    const t7 = null != e5 ? e5.signal : null;
    await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e5).catch(a2), await this._fetchService(t7), await Promise.all([this._fetchIndexAndUpdateExtent(this.nodePages, t7), this._setAssociatedFeatureLayer(t7), this._loadFilterGeometries()]), this._validateElevationInfo(), this._applyAssociatedLayerOverrides(), this._populateFieldUsageInfo(), await t2(this, { origin: "service" }, t7), p7(this.renderer, this.fieldsIndex), await this.finishLoadEditablePortalLayer(e5);
  }
  async beforeSave() {
    null != this.filter && (this.filter = this.filter.clone(), await this.load());
  }
  async _loadFilterGeometries() {
    if (this.filter)
      try {
        await this.filter.loadGeometries(this.spatialReference);
      } catch (e5) {
        n.getLogger(this).error("#_loadFilterGeometries()", this, "Failed to load filter geometries. Geometry filter will not be applied for this layer.", { error: e5 }), this.filter = null;
      }
  }
  createQuery() {
    var _a;
    const e5 = new b3();
    return "mesh" === this.geometryType ? ((_a = this.associatedLayer) == null ? void 0 : _a.infoFor3D) && (e5.returnGeometry = true) : (e5.returnGeometry = true, e5.returnZ = true), e5.where = this.definitionExpression || "1=1", e5.sqlFormat = "standard", e5.outFields = ["*"], e5;
  }
  queryExtent(e5, t7) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryExtent(e5 || this.createQuery(), t7));
  }
  queryFeatureCount(e5, t7) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryFeatureCount(e5 || this.createQuery(), t7));
  }
  queryFeatures(e5, t7) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryFeatures(e5 || this.createQuery(), t7)).then((e6) => {
      if (e6 == null ? void 0 : e6.features)
        for (const t8 of e6.features)
          t8.layer = this, t8.sourceLayer = this;
      return e6;
    });
  }
  async queryRelatedFeatures(e5, t7) {
    if (await this.load(), !this.associatedLayer)
      throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    return this.associatedLayer.queryRelatedFeatures(e5, t7);
  }
  async queryRelatedFeaturesCount(e5, t7) {
    if (await this.load(), !this.associatedLayer)
      throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    return this.associatedLayer.queryRelatedFeaturesCount(e5, t7);
  }
  async queryCachedAttributes(e5, t7) {
    const r3 = x2(this.fieldsIndex, await n3(this, p4(this)));
    return $(this.parsedUrl.path, this.attributeStorageInfo ?? [], e5, t7, r3, this.apiKey, this.customParameters);
  }
  async queryCachedFeature(e5, r3) {
    const i5 = await this.queryCachedAttributes(e5, [r3]);
    if (!i5 || 0 === i5.length)
      throw new s("scenelayer:feature-not-in-cached-data", "Feature not found in cached data");
    const s7 = new f3();
    return s7.attributes = i5[0], s7.layer = this, s7.sourceLayer = this, s7;
  }
  queryObjectIds(e5, t7) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryObjectIds(e5 || this.createQuery(), t7));
  }
  queryAttachments(e5, t7) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryAttachments(e5, t7));
  }
  getFieldUsageInfo(e5) {
    const t7 = { supportsLabelingInfo: false, supportsRenderer: false, supportsPopupTemplate: false, supportsLayerQuery: false };
    return this.loaded ? this._fieldUsageInfo[e5] || t7 : (n.getLogger(this).error("#getFieldUsageInfo()", "Unavailable until layer is loaded"), t7);
  }
  createPopupTemplate(e5) {
    return p3(this, e5);
  }
  _getAssociatedLayerForQuery() {
    const e5 = this.associatedLayer;
    return (e5 == null ? void 0 : e5.loaded) ? Promise.resolve(e5) : this._loadAssociatedLayerForQuery();
  }
  async _loadAssociatedLayerForQuery() {
    if (await this.load(), !this.associatedLayer)
      throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    try {
      await this.associatedLayer.load();
    } catch (e5) {
      throw new s("scenelayer:query-not-available", "SceneLayer associated feature layer could not be loaded", { layer: this, error: e5 });
    }
    return this.associatedLayer;
  }
  hasCachedStatistics(e5) {
    return null != this.statisticsInfo && this.statisticsInfo.some((t7) => t7.name === e5);
  }
  async queryCachedStatistics(e5, t7) {
    if (await this.load(t7), !this.statisticsInfo)
      throw new s("scenelayer:no-cached-statistics", "Cached statistics are not available for this layer");
    const r3 = this.fieldsIndex.get(e5);
    if (!r3)
      throw new s("scenelayer:field-unexisting", `Field '${e5}' does not exist on the layer`);
    for (const i5 of this.statisticsInfo)
      if (i5.name === r3.name) {
        const e6 = V2(this.parsedUrl.path, i5.href);
        return U(e6, { query: { f: "json", ...this.customParameters, token: this.apiKey }, responseType: "json", signal: t7 ? t7.signal : null }).then((e7) => e7.data);
      }
    throw new s("scenelayer:no-cached-statistics", "Cached statistics for this attribute are not available");
  }
  async saveAs(e5, t7) {
    return this._debouncedSaveOperations(C2.SAVE_AS, { ...t7, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" }, e5);
  }
  async save() {
    const e5 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" };
    return this._debouncedSaveOperations(C2.SAVE, e5);
  }
  async applyEdits(e5, t7) {
    const { applyEdits: r3 } = await import("./editingSupport-OQAPOMEA.js");
    let i5 = t7;
    await this.load();
    const s7 = this.associatedLayer;
    if (!s7)
      throw new s(`${this.type}-layer:not-editable`, "Service is not editable");
    await s7.load();
    const { globalIdField: o2 } = s7, a6 = !!s7.infoFor3D, l3 = (i5 == null ? void 0 : i5.globalIdUsed) ?? true;
    if (a6 && null == o2)
      throw new s(`${this.type}-layer:not-editable`, "Valid globalIdField expected on editable SceneLayer");
    if (a6 && !l3)
      throw new s(`${this.type}-layer:globalid-required`, "globalIdUsed must not be false for SceneLayer editing as globalIds are required.");
    return w2(s7.url) && a6 && null != e5.deleteFeatures && null != o2 && (i5 = { ...i5, globalIdToObjectId: await V3(s7, e5.deleteFeatures, o2) }), r3(this, s7.source, e5, i5);
  }
  async uploadAssets(e5, t7) {
    if (await this.load(), null == this.associatedLayer)
      throw new s(`${this.type}-layer:not-editable`, "Service is not editable");
    return await this.associatedLayer.load(), this.associatedLayer.uploadAssets(e5, t7);
  }
  on(e5, t7) {
    return super.on(e5, t7);
  }
  async convertMesh(e5, t7) {
    const r3 = (e6) => {
      throw n.getLogger(this).error(".convertMesh()", e6.message), e6;
    };
    await this.load(), this.infoFor3D || r3(new s("invalid:layer", "SceneLayer has no capability for mesh conversion"));
    const i5 = await this.extractAndFilterFiles(e5), s7 = i5.reduce((e6, t8) => r2(this.infoFor3D, t8) ? e6 + 1 : e6, 0);
    0 === s7 && r3(new i4()), s7 > 1 && r3(new m4());
    const o2 = this.spatialReference, a6 = (t7 == null ? void 0 : t7.location) ?? new x({ x: 0, y: 0, z: 0, spatialReference: o2 }), p9 = a6.spatialReference.isGeographic ? "local" : "georeferenced", d = $2.createWithExternalSource(a6, i5, { vertexSpace: p9 }), [y4] = await this.uploadAssets([d], t7);
    return y4;
  }
  async extractAndFilterFiles(e5) {
    await this.load();
    const t7 = this.infoFor3D;
    if (!t7)
      return e5;
    return (await e4(e5)).filter((e6) => t4(t7, e6));
  }
  validateLayer(e5) {
    if (e5.layerType && !we.has(e5.layerType))
      throw new s("scenelayer:layer-type-not-supported", "SceneLayer does not support this layer type", { layerType: e5.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor))
      throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    if (this.version.major > 2)
      throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    function t7(e6, t8) {
      let r3 = false, i5 = false;
      if (null == e6)
        r3 = true, i5 = true;
      else {
        const s7 = t8 && t8.isGeographic;
        switch (e6) {
          case "east-north-up":
          case "earth-centered":
            r3 = true, i5 = s7;
            break;
          case "vertex-reference-frame":
            r3 = true, i5 = !s7;
            break;
          default:
            r3 = false;
        }
      }
      if (!r3)
        throw new s("scenelayer:unsupported-normal-reference-frame", "Normal reference frame is invalid.");
      if (!i5)
        throw new s("scenelayer:incompatible-normal-reference-frame", "Normal reference frame is incompatible with layer spatial reference.");
    }
    t7(this.normalReferenceFrame, this.spatialReference);
  }
  _getTypeKeywords() {
    const e5 = [];
    if ("points" === this.profile)
      e5.push("Point");
    else {
      if ("mesh-pyramids" !== this.profile)
        throw new s("scenelayer:unknown-profile", "SceneLayer:save() encountered an unknown SceneLayer profile: " + this.profile);
      e5.push("3DObject");
    }
    return e5;
  }
  _populateFieldUsageInfo() {
    var _a, _b;
    if (this._fieldUsageInfo = {}, this.fields)
      for (const e5 of this.fields) {
        const t7 = !(!this.attributeStorageInfo || !this.attributeStorageInfo.some((t8) => t8.name === e5.name)), r3 = !!((_b = (_a = this.associatedLayer) == null ? void 0 : _a.fields) == null ? void 0 : _b.some((t8) => t8 && e5.name === t8.name)), i5 = { supportsLabelingInfo: t7, supportsRenderer: t7, supportsPopupTemplate: t7 || r3, supportsLayerQuery: r3 };
        this._fieldUsageInfo[e5.name] = i5;
      }
  }
  _applyAssociatedLayerOverrides() {
    this._applyAssociatedLayerFieldsOverrides(), this._applyAssociatedLayerPopupOverrides(), this._applyAssociatedLayerExtentOverride(), this._applyAssociatedLayerPrivileges();
  }
  _applyAssociatedLayerFieldsOverrides() {
    var _a;
    if (!((_a = this.associatedLayer) == null ? void 0 : _a.fields))
      return;
    let e5 = null;
    for (const t7 of this.associatedLayer.fields) {
      const r3 = this.getField(t7.name);
      r3 ? (!r3.domain && t7.domain && (r3.domain = t7.domain.clone()), r3.editable = t7.editable, r3.nullable = t7.nullable, r3.length = t7.length) : (e5 || (e5 = this.fields ? this.fields.slice() : []), e5.push(t7.clone()));
    }
    e5 && this._set("fields", e5);
  }
  _applyAssociatedLayerPopupOverrides() {
    if (!this.associatedLayer)
      return;
    const e5 = ["popupTemplate", "popupEnabled"], t7 = t(this);
    for (let r3 = 0; r3 < e5.length; r3++) {
      const i5 = e5[r3], s7 = this.originIdOf(i5), o2 = this.associatedLayer.originIdOf(i5);
      s7 < o2 && (o2 === e2.SERVICE || o2 === e2.PORTAL_ITEM) && t7.setAtOrigin(i5, this.associatedLayer[i5], o2);
    }
  }
  _applyAssociatedLayerExtentOverride() {
    var _a, _b, _c, _d, _e, _f, _g;
    const e5 = (_b = (_a = this.associatedLayer) == null ? void 0 : _a.editingInfo) == null ? void 0 : _b.lastEditDate, t7 = (_c = this.associatedLayer) == null ? void 0 : _c.serverGens, r3 = (_d = this.associatedLayer) == null ? void 0 : _d.getAtOrigin("fullExtent", "service");
    if (!n2() || null == ((_e = this.associatedLayer) == null ? void 0 : _e.infoFor3D) || !r3 || !w2((_f = this.associatedLayer) == null ? void 0 : _f.url) || !e5 || ((_g = this.serviceUpdateTimeStamp) == null ? void 0 : _g.lastUpdate) === e5.getTime() || !this.serviceUpdateTimeStamp && (t7 == null ? void 0 : t7.minServerGen) === (t7 == null ? void 0 : t7.serverGen))
      return;
    t(this).setAtOrigin("fullExtent", r3.clone(), e2.SERVICE);
  }
  _applyAssociatedLayerPrivileges() {
    const e5 = this.associatedLayer;
    e5 && (this._set("userHasEditingPrivileges", e5.userHasEditingPrivileges), this._set("userHasFullEditingPrivileges", e5.userHasFullEditingPrivileges), this._set("userHasUpdateItemPrivileges", e5.userHasUpdateItemPrivileges));
  }
  async _setAssociatedFeatureLayer(e5) {
    if (["mesh-pyramids", "points"].includes(this.profile))
      try {
        const { serverUrl: t7, layerId: r3, portalItem: i5 } = await s3(`${this.url}/layers/${this.layerId}`, { sceneLayerItem: this.portalItem, customParameters: this.customParameters, apiKey: this.apiKey, signal: e5 }), s7 = await a5.FeatureLayer();
        this.associatedLayer = new s7({ url: t7, customParameters: this.customParameters, layerId: r3, portalItem: i5 }), await this.associatedLayer.load();
      } catch (t7) {
        b(t7) || this._logWarningOnPopupEnabled();
      }
  }
  async _logWarningOnPopupEnabled() {
    await w(() => this.popupEnabled && null != this.popupTemplate);
    const e5 = `this SceneLayer: ${this.title}`;
    null == this.attributeStorageInfo ? n.getLogger(this).warn(`Associated FeatureLayer could not be loaded and no binary attributes found. Popups will not work on ${e5}`) : n.getLogger(this).info(`Associated FeatureLayer could not be loaded. Falling back to binary attributes for Popups on ${e5}`);
  }
  _validateElevationInfo() {
    const e5 = this.elevationInfo;
    "mesh-pyramids" === this.profile && P(n.getLogger(this), Z2("Mesh scene layers", "relative-to-scene", e5)), P(n.getLogger(this), I("Scene layers", e5));
  }
};
e([y({ types: { key: "type", base: t5, typeMap: { selection: p6 } }, json: { origins: { "web-scene": { name: "layerDefinition.featureReduction", write: true }, "portal-item": { name: "layerDefinition.featureReduction", write: true } } } })], Le.prototype, "featureReduction", void 0), e([y({ type: [s6], json: { read: false, origins: { "web-scene": { name: "layerDefinition.rangeInfos", write: true }, "portal-item": { name: "layerDefinition.rangeInfos", write: true } } } })], Le.prototype, "rangeInfos", void 0), e([y({ json: { read: false } })], Le.prototype, "associatedLayer", void 0), e([y({ type: ["show", "hide"] })], Le.prototype, "listMode", void 0), e([y({ type: ["ArcGISSceneServiceLayer"] })], Le.prototype, "operationalLayerType", void 0), e([y({ json: { read: false }, readOnly: true })], Le.prototype, "type", void 0), e([y({ ...Ie.fields, readOnly: true, json: { read: false, origins: { service: { read: true } } } })], Le.prototype, "fields", void 0), e([y()], Le.prototype, "types", null), e([y()], Le.prototype, "typeIdField", null), e([y()], Le.prototype, "templates", null), e([y()], Le.prototype, "formTemplate", null), e([y({ readOnly: true, clonable: false })], Le.prototype, "fieldsIndex", null), e([y({ type: p5, json: { read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo" } } })], Le.prototype, "floorInfo", void 0), e([y(Ie.outFields)], Le.prototype, "outFields", void 0), e([y({ type: p2, readOnly: true, json: { read: false } })], Le.prototype, "nodePages", void 0), e([o("service", "nodePages", ["nodePages", "pointNodePages"])], Le.prototype, "readNodePages", null), e([y({ type: [a4], readOnly: true })], Le.prototype, "materialDefinitions", void 0), e([y({ type: [y3], readOnly: true })], Le.prototype, "textureSetDefinitions", void 0), e([y({ type: [m3], readOnly: true })], Le.prototype, "geometryDefinitions", void 0), e([y({ readOnly: true })], Le.prototype, "serviceUpdateTimeStamp", void 0), e([y({ readOnly: true })], Le.prototype, "attributeStorageInfo", void 0), e([y({ readOnly: true })], Le.prototype, "statisticsInfo", void 0), e([y({ type: V.ofType(Number), nonNullable: true, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.excludeObjectIds", write: { enabled: true } } })], Le.prototype, "excludeObjectIds", void 0), e([y({ type: String, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], Le.prototype, "definitionExpression", void 0), e([y({ type: h, json: { name: "layerDefinition.polygonFilter", write: { enabled: true, allowNull: true }, origins: { service: { read: false, write: false } } } })], Le.prototype, "filter", void 0), e([y({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], Le.prototype, "path", void 0), e([y(f2)], Le.prototype, "elevationInfo", null), e([y({ readOnly: true, json: { read: false } })], Le.prototype, "effectiveCapabilities", null), e([y({ readOnly: true })], Le.prototype, "effectiveEditingEnabled", null), e([y({ type: String })], Le.prototype, "geometryType", null), e([y(m)], Le.prototype, "labelsVisible", void 0), e([y({ type: [C3], json: { origins: { service: { name: "drawingInfo.labelingInfo", read: { reader: i3 }, write: false } }, name: "layerDefinition.drawingInfo.labelingInfo", read: { reader: i3 }, write: true } })], Le.prototype, "labelingInfo", void 0), e([y(c)], Le.prototype, "legendEnabled", void 0), e([y({ type: Number, json: { origins: { "web-document": { default: 1, write: { enabled: true, target: { opacity: { type: Number }, "layerDefinition.drawingInfo.transparency": { type: Number } } }, read: { source: ["opacity", "layerDefinition.drawingInfo.transparency"], reader(e5, t7) {
  var _a, _b;
  if ("number" == typeof e5 && e5 >= 0 && e5 <= 1)
    return e5;
  const r3 = (_b = (_a = t7.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.transparency;
  return void 0 !== r3 ? r(r3) : void 0;
} } }, "portal-item": { write: true }, service: { read: false } } } })], Le.prototype, "opacity", void 0), e([y({ type: ["Low", "High"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], Le.prototype, "priority", void 0), e([y({ type: ["Labels"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], Le.prototype, "semantic", void 0), e([y({ types: u4, json: { origins: { service: { read: { source: "drawingInfo.renderer" } } }, name: "layerDefinition.drawingInfo.renderer", write: true }, value: null })], Le.prototype, "renderer", null), e([y({ json: { read: false } })], Le.prototype, "cachedDrawingInfo", void 0), e([o("service", "cachedDrawingInfo")], Le.prototype, "readCachedDrawingInfo", null), e([y({ readOnly: true, json: { read: false } })], Le.prototype, "capabilities", null), e([y({ type: Boolean, json: { read: false } })], Le.prototype, "editingEnabled", null), e([y({ readOnly: true, json: { write: false, read: false } })], Le.prototype, "infoFor3D", null), e([y({ readOnly: true, json: { write: false, read: false } })], Le.prototype, "relationships", null), e([y(y2)], Le.prototype, "popupEnabled", void 0), e([y({ type: P2, json: { name: "popupInfo", write: true } })], Le.prototype, "popupTemplate", void 0), e([y({ readOnly: true, json: { read: false } })], Le.prototype, "defaultPopupTemplate", null), e([y({ type: String, json: { read: false } })], Le.prototype, "objectIdField", void 0), e([o("service", "objectIdField", ["objectIdField", "fields"])], Le.prototype, "readObjectIdField", null), e([y({ type: String, json: { read: false } })], Le.prototype, "globalIdField", void 0), e([o("service", "globalIdField", ["globalIdField", "fields"])], Le.prototype, "readGlobalIdField", null), e([y({ readOnly: true, type: String, json: { read: false } })], Le.prototype, "displayField", null), e([y({ type: String, json: { read: false } })], Le.prototype, "profile", void 0), e([o("service", "profile", ["store.profile"])], Le.prototype, "readProfile", null), e([y({ readOnly: true, type: String, json: { origins: { service: { read: { source: "store.normalReferenceFrame" } } }, read: false } })], Le.prototype, "normalReferenceFrame", void 0), e([y(p)], Le.prototype, "screenSizePerspectiveEnabled", void 0), e([y({ json: { read: false, origins: { service: { read: true } } } })], Le.prototype, "serviceItemId", void 0), Le = e([a3("esri.layers.SceneLayer")], Le);
var je = { "mesh-pyramids": "mesh-pyramids", meshpyramids: "mesh-pyramids", "features-meshes": "mesh-pyramids", points: "points", "features-points": "points", lines: "lines", "features-lines": "lines", polygons: "polygons", "features-polygons": "polygons" };
var Fe = { "mesh-pyramids": "mesh", points: "point", lines: "polyline", polygons: "polygon" };
var Se = Le;
export {
  Se as default
};
//# sourceMappingURL=SceneLayer-SO3HCQCX.js.map
