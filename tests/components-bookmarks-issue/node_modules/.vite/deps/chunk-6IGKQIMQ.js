import {
  B2 as B,
  C,
  M,
  a as a3,
  a3 as a4,
  c as c2,
  f as f3,
  h,
  l as l2,
  m as m2,
  n3 as n4,
  p as p3,
  u as u2,
  w as w3,
  x as x2
} from "./chunk-TBCOV2E5.js";
import {
  c,
  f as f2,
  g,
  g2,
  i as i2,
  l2 as l,
  n as n3,
  o as o3,
  p as p2,
  r as r2,
  w as w2,
  y as y4
} from "./chunk-HUFLW46E.js";
import {
  i,
  s as s3,
  u
} from "./chunk-XKG6TWCH.js";
import {
  y as y3
} from "./chunk-XGTCDM4C.js";
import {
  m,
  p
} from "./chunk-BMT3OVAP.js";
import {
  n as n2
} from "./chunk-B647DRFJ.js";
import {
  y as y2
} from "./chunk-J7AMTUNG.js";
import {
  o as o2
} from "./chunk-TGXFDJCS.js";
import {
  j
} from "./chunk-OCF7OAES.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  o
} from "./chunk-YOPMY6TS.js";
import {
  r
} from "./chunk-VIN55KNF.js";
import {
  s as s2
} from "./chunk-IOB3DJMR.js";
import {
  n
} from "./chunk-RUN6MNXL.js";
import {
  f
} from "./chunk-SBL4URUW.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a2
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  a,
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/BaseFunctionArguments.js
var e2 = class extends f {
  constructor() {
    super(...arguments), this.raster = void 0;
  }
};
e([y({ json: { write: true } })], e2.prototype, "raster", void 0), e2 = e([a2("esri.layers.support.rasterFunctions.BaseFunctionArguments")], e2);
var p4 = e2;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ArithmeticFunctionArguments.js
var e3;
var a5 = e3 = class extends p4 {
  constructor() {
    super(...arguments), this.raster2 = void 0;
  }
  get rasters() {
    return [this.raster, this.raster2];
  }
  clone() {
    return new e3({ raster: this.raster, raster2: this.raster2, operation: this.operation });
  }
};
e([y({ json: { write: true } })], a5.prototype, "operation", void 0), e([y({ json: { write: true } })], a5.prototype, "raster2", void 0), e([y({ readOnly: true })], a5.prototype, "rasters", null), a5 = e3 = e([a2("esri.layers.support.rasterFunctions.ArithmeticFunctionArguments")], a5);
var i3 = a5;

// node_modules/@arcgis/core/layers/support/rasterFunctions/BaseRasterFunction.js
var a6 = /* @__PURE__ */ new Set(["slope", "aspect", "curvature", "hillshade", "shadedrelief", "statistics"]);
var u3 = class extends f {
  constructor() {
    super(...arguments), this.functionArguments = null, this.readingBufferSize = 0, this.id = -1, this.isNoopProcess = false, this.rawInputBandIds = [], this.rawSourceRasterInfos = null, this.isInputBandIdsSwizzled = false, this.swizzledBandSelection = [], this.isBranch = false, this._bindingResult = null;
  }
  get supportsGPU() {
    return this._bindingResult.supportsGPU;
  }
  get flatWebGLFunctionChain() {
    var _a;
    const t6 = this.getWebGLProcessorDefinition();
    if (!t6)
      return null;
    const s11 = [t6], { parameters: e11 } = t6;
    let r7 = e11.rasters || e11.raster && [e11.raster];
    for (; r7 == null ? void 0 : r7.length; ) {
      s11.unshift(...r7);
      const t7 = [];
      for (let s12 = 0; s12 < r7.length; s12++) {
        const { parameters: e12 } = r7[s12], n20 = e12.rasters || e12.raster && [e12.raster];
        (n20 == null ? void 0 : n20.length) && t7.push(...n20);
      }
      r7 = t7;
    }
    for (let a30 = s11.length - 1; a30 >= 0; a30--)
      s11[a30].isNoopProcess && s11.splice(a30, 1);
    let n19 = false;
    for (let a30 = 0; a30 < s11.length; a30++) {
      const t7 = s11[a30];
      t7.id = s11.length - a30 - 1;
      const { rasters: e12 } = t7.parameters;
      n19 = n19 || null != e12 && e12.length > 1;
    }
    const i28 = s11.some(({ name: t7 }) => a6.has(t7.toLowerCase())), { rawSourceRasterInfos: o11 } = this;
    return { functions: s11, hasBranches: n19, hasFocalFunction: i28, isSourceSingleBand: 1 === ((_a = o11 == null ? void 0 : o11[0]) == null ? void 0 : _a.bandCount) };
  }
  bind(t6, s11 = false, e11 = -1) {
    this.id = e11 + 1;
    const r7 = this._getRasterValues();
    let n19 = true;
    for (let i28 = 0; i28 < r7.length; i28++) {
      const e12 = r7[i28];
      if (null != e12 && this._isRasterFunctionValue(e12)) {
        const r8 = e12.bind(t6, s11, this.id + i28);
        if (!r8.success)
          return this._bindingResult = r8, r8;
        n19 = n19 && r8.supportsGPU;
      }
    }
    return !this.rasterInfo || s11 ? (this.sourceRasterInfos = this._getSourceRasterInfos(t6), this._bindingResult = this._bindSourceRasters(), this._bindingResult.success && this._patchRasterInfo(), this._bindingResult.supportsGPU = n19 && this._bindingResult.supportsGPU, this.processInputBandIds(), this._bindingResult) : (this._bindingResult = { success: true, supportsGPU: true }, this.processInputBandIds(), this._bindingResult);
  }
  process(t6) {
    const s11 = this._getRasterValues(), e11 = 0 === s11.length ? t6.pixelBlocks ?? t6.primaryPixelBlocks : s11.map((s12) => this._readRasterValue(s12, t6));
    return this._processPixels({ ...t6, pixelBlocks: e11 });
  }
  processInputBandIds() {
    const t6 = this._getRasterValues().filter(this._isRasterFunctionValue);
    let s11;
    if (t6.length > 1) {
      const s12 = t6.map((t7) => t7.processInputBandIds()[0]);
      this.rawInputBandIds = s12, this.isInputBandIdsSwizzled = this.rawInputBandIds.some((t7, s13) => t7 !== s13);
      const e12 = t6.filter((t7) => "ExtractBand" === t7.functionName);
      return e12.length && e12.forEach((t7, s13) => {
        t7.isInputBandIdsSwizzled = true, t7.swizzledBandSelection = [s13, s13, s13];
      }), this.rawInputBandIds;
    }
    const e11 = t6[0];
    if (e11) {
      if (s11 = e11.processInputBandIds(), e11.isInputBandIdsSwizzled)
        return this.rawInputBandIds = s11, s11;
    } else {
      s11 = [];
      const { bandCount: t7 } = this.sourceRasterInfos[0];
      for (let e12 = 0; e12 < t7; e12++)
        s11.push(e12);
    }
    const r7 = this._getInputBandIds(s11);
    return this.isInputBandIdsSwizzled = r7.some((t7, s12) => t7 !== s12), this.rawInputBandIds = r7, this.rawInputBandIds;
  }
  getPrimaryRasters() {
    const t6 = [], s11 = [];
    return this._getPrimaryRasters(this, t6, s11), { rasters: t6, rasterIds: s11 };
  }
  getWebGLProcessorDefinition() {
    const t6 = this._getWebGLParameters(), { raster: s11, rasters: e11 } = this.functionArguments;
    return e11 && Array.isArray(e11) && e11.length ? (t6.rasters = e11.map((t7) => this._isRasterFunctionValue(t7) ? t7.getWebGLProcessorDefinition() : "number" == typeof t7 ? { name: "Constant", parameters: { value: t7 }, pixelType: "f32", id: -1, isNoopProcess: false } : { name: "Identity", parameters: { value: t7 }, pixelType: "f32", id: -1, isNoopProcess: false }), t6.rasters.some((t7) => null != t7) || (t6.rasters = null)) : this._isRasterFunctionValue(s11) && (t6.raster = s11.getWebGLProcessorDefinition()), { name: this.functionName, parameters: t6, pixelType: this.outputPixelType, id: this.id, isNoopProcess: this.isNoopProcess };
  }
  getClippingGeometries() {
    const t6 = [];
    "Clip" === this.functionName && t6.push(this.functionArguments);
    const { raster: s11, rasters: e11 } = this.functionArguments;
    if (e11 && Array.isArray(e11) && e11.length)
      e11.forEach((s12) => {
        if (this._isRasterFunctionValue(s12)) {
          const e12 = s12.getClippingGeometries();
          t6.push(...e12);
        }
      });
    else if (this._isRasterFunctionValue(s11)) {
      const e12 = s11.getClippingGeometries();
      t6.push(...e12);
    }
    return t6;
  }
  _getOutputPixelType(t6) {
    return "unknown" === this.outputPixelType ? t6 : this.outputPixelType ?? t6;
  }
  _getWebGLParameters() {
    return {};
  }
  _getInputBandIds(t6) {
    return t6;
  }
  _removeStatsHistColormapVAT(t6) {
    t6.statistics = null, t6.histograms = null, t6.colormap = null, t6.attributeTable = null;
  }
  _getRasterValues() {
    const { rasterArgumentNames: t6 } = this;
    return "rasters" === t6[0] ? this.functionArguments.rasters ?? [] : t6.flatMap((t7) => this.functionArguments[t7]);
  }
  _getSourceRasterInfos(t6) {
    const s11 = this._getRasterValues(), { rasterInfos: e11, rasterIds: r7 } = t6;
    if (0 === s11.length)
      return e11;
    const n19 = s11.map((t7) => t7 && "object" == typeof t7 && "bind" in t7 && t7.rasterInfo ? t7.rasterInfo : "string" == typeof t7 && r7.includes(t7) ? e11[r7.indexOf(t7)] : "number" != typeof t7 ? e11[0] : void 0), i28 = n19.find((t7) => t7) ?? e11[0];
    return n19.forEach((t7, s12) => {
      void 0 === t7 && (n19[s12] = i28);
    }), n19;
  }
  _getPrimaryRasterId(t6) {
    return t6 == null ? void 0 : t6.rasterId;
  }
  _getPrimaryRasters(t6, s11 = [], e11 = []) {
    for (let r7 = 0; r7 < t6.sourceRasters.length; r7++) {
      const n19 = t6.sourceRasters[r7];
      if ("number" != typeof n19)
        if ("bind" in n19)
          this._getPrimaryRasters(n19, s11, e11);
        else {
          const t7 = n19, r8 = this._getPrimaryRasterId(t7);
          if (null == r8)
            continue;
          e11.includes(r8) || (this.mainPrimaryRasterId === r8 ? (s11.unshift(t7), e11.unshift(r8)) : (s11.push(t7), e11.push(r8)));
        }
    }
  }
  _isRasterFunctionValue(t6) {
    return null != t6 && "object" == typeof t6 && "getWebGLProcessorDefinition" in t6;
  }
  _readRasterValue(t6, s11) {
    const { primaryPixelBlocks: e11 } = s11;
    if (null == t6 || "$$" === t6) {
      const t7 = e11[0];
      return null == t7 ? null : t7.clone();
    }
    if ("string" == typeof t6) {
      const r7 = s11.primaryRasterIds.indexOf(t6);
      return -1 === r7 ? null : e11[r7];
    }
    if ("number" == typeof t6) {
      const s12 = e11[0];
      if (null == s12)
        return null;
      const { width: r7, height: n19, pixelType: o11 } = s12, a30 = new Float32Array(r7 * n19);
      a30.fill(t6);
      const u18 = this.sourceRasterInfos[0].bandCount, p23 = new Array(u18).fill(a30);
      return new g({ width: r7, height: n19, pixelType: o11, pixels: p23 });
    }
    return t6.process(s11);
  }
  _patchRasterInfo() {
    const { rasterInfo: t6 } = this;
    if (!(t6 == null ? void 0 : t6.keyProperties))
      return;
    const { bandCount: s11, keyProperties: e11, statistics: r7, histograms: n19 } = t6, i28 = e11.BandProperties;
    i28 && i28.length !== s11 && (t6.keyProperties = { ...e11, BandProperties: void 0 }), r7 && r7.length !== s11 && (t6.statistics = r7.length > s11 ? r7.slice(0, s11) : null), n19 && n19.length !== s11 && (t6.histograms = n19.length > s11 ? n19.slice(0, s11) : null), e11.BAND_COUNT && Number(e11.BAND_COUNT) !== s11 && (t6.keyProperties = { ...e11, BAND_COUNT: "string" == typeof e11.BAND_COUNT ? String(s11) : s11 });
  }
};
e([y({ json: { write: true } })], u3.prototype, "functionName", void 0), e([y({ json: { write: true } })], u3.prototype, "functionArguments", void 0), e([y()], u3.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } }), s2((t6) => t6 == null ? void 0 : t6.toLowerCase())], u3.prototype, "outputPixelType", void 0), e([y({ json: { write: true } })], u3.prototype, "mainPrimaryRasterId", void 0), e([y()], u3.prototype, "sourceRasters", void 0), e([y({ type: [m2], json: { write: true } })], u3.prototype, "sourceRasterInfos", void 0), e([y({ json: { write: true } })], u3.prototype, "rasterInfo", void 0), e([y({ json: { write: true } })], u3.prototype, "readingBufferSize", void 0), e([y({ json: { write: true } })], u3.prototype, "id", void 0), e([y()], u3.prototype, "isNoopProcess", void 0), e([y()], u3.prototype, "supportsGPU", null), e([y()], u3.prototype, "rawInputBandIds", void 0), e([y()], u3.prototype, "rawSourceRasterInfos", void 0), e([y()], u3.prototype, "isInputBandIdsSwizzled", void 0), e([y()], u3.prototype, "swizzledBandSelection", void 0), e([y()], u3.prototype, "isBranch", void 0), e([y({ readOnly: true })], u3.prototype, "flatWebGLFunctionChain", null), e([y()], u3.prototype, "_bindingResult", void 0), u3 = e([a2("esri.layers.support.rasterFunctions.BaseRasterFunction")], u3);
var p5 = u3;

// node_modules/@arcgis/core/layers/support/rasterFunctionConstants.js
var l3 = { userDefined: -1, lineDetectionHorizontal: 0, lineDetectionVertical: 1, lineDetectionLeftDiagonal: 2, lineDetectionRightDiagonal: 3, gradientNorth: 4, gradientWest: 5, gradientEast: 6, gradientSouth: 7, gradientNorthEast: 8, gradientNorthWest: 9, smoothArithmeticMean: 10, smoothing3x3: 11, smoothing5x5: 12, sharpening3x3: 13, sharpening5x5: 14, laplacian3x3: 15, laplacian5x5: 16, sobelHorizontal: 17, sobelVertical: 18, sharpen: 19, sharpen2: 20, pointSpread: 21, none: 255 };
var h2 = { plus: 1, minus: 2, times: 3, sqrt: 4, power: 5, abs: 10, divide: 23, exp: 25, exp10: 26, exp2: 27, int: 30, float: 32, ln: 35, log10: 36, log2: 37, mod: 44, negate: 45, roundDown: 48, roundUp: 49, square: 53, floatDivide: 64, floorDivide: 65 };
var u4 = { bitwiseAnd: 11, bitwiseLeftShift: 12, bitwiseNot: 13, bitwiseOr: 14, bitwiseRightShift: 15, bitwiseXOr: 16, booleanAnd: 17, booleanNot: 18, booleanOr: 19, booleanXOr: 20, equalTo: 24, greaterThan: 28, greaterThanEqual: 29, lessThan: 33, lessThanEqual: 34, isNull: 31, notEqual: 46 };
var s4 = { acos: 6, asin: 7, atan: 8, atanh: 9, cos: 21, cosh: 22, sin: 51, sinh: 52, tan: 56, tanh: 57, acosh: 59, asinh: 60, atan2: 61 };
var d = { majority: 38, max: 39, mean: 40, med: 41, min: 42, minority: 43, range: 47, stddev: 54, sum: 55, variety: 58, majorityIgnoreNoData: 66, maxIgnoreNoData: 67, meanIgnoreNoData: 68, medIgnoreNoData: 69, minIgnoreNoData: 70, minorityIgnoreNoData: 71, rangeIgnoreNoData: 72, stddevIgnoreNoData: 73, sumIgnoreNoData: 74, varietyIgnoreNoData: 75 };
var p6 = { setNull: 50, conditional: 78 };
var B2 = { ...h2, ...u4, ...s4, ...d, ...p6 };

// node_modules/@arcgis/core/layers/support/rasterFunctions/localUtils.js
var a7 = /* @__PURE__ */ new Map([[s4.acos, { domain: [0, Math.PI], isInteger: false }], [s4.asin, { domain: [-Math.PI / 2, Math.PI / 2], isInteger: false }], [s4.atan, { domain: [-Math.PI / 2, Math.PI / 2], isInteger: false }], [s4.cos, { domain: [-1, 1], isInteger: false }], [s4.sin, { domain: [-1, 1], isInteger: false }], [u4.booleanAnd, { domain: [0, 1], isInteger: true }], [u4.booleanNot, { domain: [0, 1], isInteger: true }], [u4.booleanOr, { domain: [0, 1], isInteger: true }], [u4.booleanXOr, { domain: [0, 1], isInteger: true }], [u4.equalTo, { domain: [0, 1], isInteger: true }], [u4.notEqual, { domain: [0, 1], isInteger: true }], [u4.greaterThan, { domain: [0, 1], isInteger: true }], [u4.greaterThanEqual, { domain: [0, 1], isInteger: true }], [u4.lessThan, { domain: [0, 1], isInteger: true }], [u4.lessThanEqual, { domain: [0, 1], isInteger: true }], [u4.isNull, { domain: [0, 1], isInteger: true }]]);
function l4(t6) {
  return a7.get(t6);
}
var c3 = [0, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 999, 999, 999, 999, 999, 999, 2, 1, 2, 999, 1, 1, 2, 1, 1, 1, 999, 999, 1, 1, 999, 1, 1, 2, 999, 999, 2, 2, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 3, 999, 3];
function f4(t6, e11 = false) {
  const n19 = t6.map((t7) => t7.mask), r7 = n19.filter((t7) => null != t7), o11 = t6[0].pixels[0].length;
  if (0 === r7.length || e11 && r7.length !== n19.length)
    return new Uint8Array(o11).fill(255);
  const s11 = r7[0], a30 = new Uint8Array(s11);
  if (1 === r7.length)
    return a30;
  if (!e11) {
    for (let t7 = 1; t7 < r7.length; t7++) {
      const e12 = r7[t7];
      for (let t8 = 0; t8 < a30.length; t8++)
        a30[t8] && (a30[t8] = e12[t8] ? 255 : 0);
    }
    return a30;
  }
  for (let l16 = 1; l16 < r7.length; l16++) {
    const t7 = r7[l16];
    for (let e12 = 0; e12 < a30.length; e12++)
      0 === a30[e12] && (a30[e12] = t7[e12] ? 255 : 0);
  }
  return a30;
}
function i4(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] + s11[t6]);
  return l16;
}
function u5(e11, n19, r7) {
  const [o11] = e11, s11 = o11.length, a30 = g.createEmptyBand("f32", s11);
  return a30.set(o11), a30;
}
function h3(e11, n19, r7) {
  const [o11] = e11, s11 = o11.length, a30 = g.createEmptyBand(r7, s11);
  for (let t6 = 0; t6 < s11; t6++)
    n19 && !n19[t6] || (a30[t6] = o11[t6] * o11[t6]);
  return a30;
}
function g3(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] - s11[t6]);
  return l16;
}
function p7(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] * s11[t6]);
  return l16;
}
function m3(e11, n19, r7) {
  const [o11] = e11, s11 = o11.length, a30 = g.createEmptyBand(r7, s11);
  for (let t6 = 0; t6 < s11; t6++)
    n19 && !n19[t6] || (a30[t6] = Math.sign(o11[t6]) * Math.floor(Math.abs(o11[t6])));
  return a30;
}
function d2(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] / s11[t6]);
  return l16;
}
function y5(t6, e11, n19) {
  return d2(t6, e11, "f32");
}
function E(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = Math.floor(o11[t6] / s11[t6]));
  return l16;
}
function M2(n19, r7, o11, s11) {
  const a30 = n19[0], l16 = a30.length, c29 = g.createEmptyBand(o11, l16);
  if (s11 === s4.atanh) {
    for (let t6 = 0; t6 < l16; t6++)
      if (r7[t6]) {
        const e11 = a30[t6];
        Math.abs(e11) >= 1 ? r7[t6] = 0 : c29[t6] = Math.atanh(e11);
      }
    return c29;
  }
  const f7 = s11 === s4.asin ? Math.asin : Math.acos;
  for (let t6 = 0; t6 < l16; t6++)
    if (r7[t6]) {
      const e11 = a30[t6];
      Math.abs(e11) > 1 ? r7[t6] = 0 : c29[t6] = f7(e11);
    }
  return c29;
}
function B3(e11, n19, r7, o11) {
  const [s11] = e11, a30 = s11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11(s11[t6]));
  return l16;
}
function I(e11, n19, r7, o11) {
  const [s11, a30] = e11, l16 = s11.length, c29 = g.createEmptyBand(r7, l16);
  for (let t6 = 0; t6 < l16; t6++)
    n19 && !n19[t6] || (c29[t6] = o11(s11[t6], a30[t6]));
  return c29;
}
function w4(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] & s11[t6]);
  return l16;
}
function x3(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] << s11[t6]);
  return l16;
}
function b(e11, n19, r7) {
  const [o11] = e11, s11 = o11.length, a30 = g.createEmptyBand(r7, s11);
  for (let t6 = 0; t6 < s11; t6++)
    n19 && !n19[t6] || (a30[t6] = ~o11[t6]);
  return a30;
}
function A(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] | s11[t6]);
  return l16;
}
function P(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] >> s11[t6]);
  return l16;
}
function T(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] ^ s11[t6]);
  return l16;
}
function k(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] && s11[t6] ? 1 : 0);
  return l16;
}
function N(e11, n19, r7) {
  const [o11] = e11, s11 = o11.length, a30 = g.createEmptyBand(r7, s11);
  for (let t6 = 0; t6 < s11; t6++)
    n19 && !n19[t6] || (a30[t6] = o11[t6] ? 0 : 1);
  return a30;
}
function q(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] || s11[t6] ? 1 : 0);
  return l16;
}
function U(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = (o11[t6] ? 1 : 0) ^ (s11[t6] ? 1 : 0));
  return l16;
}
function F(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] === s11[t6] ? 1 : 0);
  return l16;
}
function j2(e11, n19, r7, o11) {
  const [s11] = e11, a30 = s11.length, l16 = g.createEmptyBand(r7, a30), c29 = o11 === Math.E;
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = c29 ? Math.exp(s11[t6]) : o11 ** s11[t6]);
  return l16;
}
function z(t6, e11, n19) {
  return j2(t6, e11, n19, 10);
}
function O(t6, e11, n19) {
  return j2(t6, e11, n19, 2);
}
function C2(t6, e11, n19) {
  return j2(t6, e11, n19, Math.E);
}
function R(e11, n19, r7, o11) {
  const [s11] = e11, a30 = s11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (s11[t6] <= 0 ? n19[t6] = 0 : l16[t6] = o11(s11[t6]));
  return l16;
}
function S(t6, e11, n19) {
  return R(t6, e11, n19, Math.log10);
}
function X(t6, e11, n19) {
  return R(t6, e11, n19, Math.log2);
}
function v(t6, e11, n19) {
  return R(t6, e11, n19, Math.log);
}
function D(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] > s11[t6] ? 1 : 0);
  return l16;
}
function G(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] >= s11[t6] ? 1 : 0);
  return l16;
}
function H(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] < s11[t6] ? 1 : 0);
  return l16;
}
function J(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] <= s11[t6] ? 1 : 0);
  return l16;
}
function K(e11, n19, r7) {
  const [o11] = e11, s11 = o11.length, a30 = g.createEmptyBand(r7, s11);
  if (!n19)
    return a30;
  for (let t6 = 0; t6 < s11; t6++)
    a30[t6] = n19[t6] ? 0 : 1;
  return a30;
}
function L(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] % s11[t6]);
  return l16;
}
function Q(e11, n19, r7) {
  const [o11] = e11, s11 = o11.length, a30 = g.createEmptyBand(r7, s11);
  for (let t6 = 0; t6 < s11; t6++)
    n19 && !n19[t6] || (a30[t6] = -o11[t6]);
  return a30;
}
function V(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19 && !n19[t6] || (l16[t6] = o11[t6] === s11[t6] ? 0 : 1);
  return l16;
}
function W(e11, n19, r7) {
  const [o11, s11] = e11, a30 = o11.length, l16 = g.createEmptyBand(r7, a30), c29 = new Uint8Array(a30);
  for (let t6 = 0; t6 < a30; t6++)
    null != n19 && !n19[t6] || 0 !== o11[t6] || (l16[t6] = s11[t6], c29[t6] = 255);
  return { band: l16, mask: c29 };
}
function Y(e11, n19, r7) {
  const [o11, s11, a30] = e11, l16 = o11.length, c29 = g.createEmptyBand(r7, l16);
  for (let t6 = 0; t6 < l16; t6++)
    n19 && !n19[t6] || (c29[t6] = o11[t6] ? s11[t6] : a30[t6]);
  return c29;
}
function Z(e11, n19, r7) {
  const o11 = e11.length;
  if (o11 < 2)
    return e11[0];
  const [s11] = e11, a30 = s11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    if (!n19 || n19[t6]) {
      let n20 = s11[t6];
      for (let r8 = 1; r8 < o11; r8++) {
        const o12 = e11[r8][t6];
        n20 < o12 && (n20 = o12);
      }
      l16[t6] = n20;
    }
  return l16;
}
function $(e11, n19, r7) {
  const o11 = e11.length;
  if (o11 < 2)
    return e11[0];
  const [s11] = e11, a30 = s11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    if (!n19 || n19[t6]) {
      let n20 = s11[t6];
      for (let r8 = 1; r8 < o11; r8++) {
        const o12 = e11[r8][t6];
        n20 > o12 && (n20 = o12);
      }
      l16[t6] = n20;
    }
  return l16;
}
function _(e11, n19, r7) {
  const o11 = e11.length;
  if (o11 < 2)
    return e11[0];
  const [s11] = e11, a30 = s11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    if (!n19 || n19[t6]) {
      let n20 = s11[t6], r8 = n20;
      for (let s12 = 1; s12 < o11; s12++) {
        const o12 = e11[s12][t6];
        r8 < o12 ? r8 = o12 : n20 > o12 && (n20 = o12);
      }
      l16[t6] = r8 - n20;
    }
  return l16;
}
function tt(e11, n19, r7) {
  const o11 = e11.length;
  if (o11 < 2)
    return e11[0];
  const [s11] = e11, a30 = s11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    if (!n19 || n19[t6]) {
      let n20 = 0;
      for (let r8 = 0; r8 < o11; r8++)
        n20 += e11[r8][t6];
      l16[t6] = n20 / o11;
    }
  return l16;
}
function et(e11, n19, r7) {
  const o11 = e11.length;
  if (o11 < 2)
    return e11[0];
  const [s11] = e11, a30 = s11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    if (!n19 || n19[t6])
      for (let n20 = 0; n20 < o11; n20++) {
        const r8 = e11[n20];
        l16[t6] += r8[t6];
      }
  return l16;
}
function nt(e11, n19, r7) {
  const o11 = e11.length;
  if (o11 < 2)
    return e11[0];
  const [s11] = e11, a30 = s11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    if (!n19 || n19[t6]) {
      const n20 = new Float32Array(o11);
      let r8 = 0;
      for (let a31 = 0; a31 < o11; a31++) {
        const o12 = e11[a31];
        r8 += o12[t6], n20[a31] = o12[t6];
      }
      r8 /= o11;
      let s12 = 0;
      for (let t7 = 0; t7 < o11; t7++)
        s12 += (n20[t7] - r8) ** 2;
      l16[t6] = Math.sqrt(s12 / o11);
    }
  return l16;
}
function rt(e11, n19, r7) {
  const o11 = e11.length;
  if (o11 < 2)
    return e11[0];
  const s11 = Math.floor(o11 / 2), [a30] = e11, l16 = a30.length, c29 = g.createEmptyBand(r7, l16), f7 = new Float32Array(o11), i28 = o11 % 2 == 1;
  for (let t6 = 0; t6 < l16; t6++)
    if (!n19 || n19[t6]) {
      for (let n20 = 0; n20 < o11; n20++)
        f7[n20] = e11[n20][t6];
      f7.sort(), c29[t6] = i28 ? f7[s11] : (f7[s11] + f7[s11 - 1]) / 2;
    }
  return c29;
}
function ot(e11, n19, r7) {
  const [o11, s11] = e11;
  if (null == s11)
    return o11;
  const a30 = o11.length, l16 = g.createEmptyBand(r7, a30);
  for (let t6 = 0; t6 < a30; t6++)
    n19[t6] && (o11[t6] === s11[t6] ? l16[t6] = o11[t6] : n19[t6] = 0);
  return l16;
}
function st(e11, n19, r7) {
  const o11 = e11.length;
  if (o11 <= 2)
    return ot(e11, n19, r7);
  const s11 = e11[0].length, a30 = g.createEmptyBand(r7, s11), l16 = /* @__PURE__ */ new Map();
  for (let t6 = 0; t6 < s11; t6++)
    if (!n19 || n19[t6]) {
      let n20;
      l16.clear();
      for (let a31 = 0; a31 < o11; a31++)
        n20 = e11[a31][t6], l16.set(n20, l16.has(n20) ? l16.get(n20) + 1 : 1);
      let r8 = 0, s12 = 0;
      for (const t7 of l16.keys())
        r8 = l16.get(t7), r8 > s12 && (s12 = r8, n20 = t7);
      a30[t6] = n20;
    }
  return a30;
}
function at(e11, n19, r7) {
  const o11 = e11.length;
  if (o11 <= 2)
    return ot(e11, n19, r7);
  const s11 = e11[0].length, a30 = g.createEmptyBand(r7, s11), l16 = /* @__PURE__ */ new Map();
  for (let t6 = 0; t6 < s11; t6++)
    if (!n19 || n19[t6]) {
      let n20;
      l16.clear();
      for (let a31 = 0; a31 < o11; a31++)
        n20 = e11[a31][t6], l16.set(n20, l16.has(n20) ? l16.get(n20) + 1 : 1);
      let r8 = 0, s12 = e11.length;
      for (const t7 of l16.keys())
        r8 = l16.get(t7), r8 < s12 && (s12 = r8, n20 = t7);
      a30[t6] = n20;
    }
  return a30;
}
function lt(e11, n19, r7) {
  const o11 = e11.length;
  if (o11 < 2)
    return e11[0];
  const [s11] = e11, a30 = s11.length, l16 = g.createEmptyBand(r7, a30), c29 = /* @__PURE__ */ new Set();
  for (let t6 = 0; t6 < a30; t6++)
    if (!n19 || n19[t6]) {
      let n20;
      c29.clear();
      for (let r8 = 0; r8 < o11; r8++)
        n20 = e11[r8][t6], c29.add(n20);
      l16[t6] = c29.size;
    }
  return l16;
}
var ct = /* @__PURE__ */ new Map();
var ft = /* @__PURE__ */ new Map();
var it = /* @__PURE__ */ new Map();
var ut = /* @__PURE__ */ new Map();
function ht() {
  ct.size || (ct.set(4, Math.sqrt), ct.set(6, Math.acos), ct.set(7, Math.asin), ct.set(8, Math.atan), ct.set(9, Math.atanh), ct.set(10, Math.abs), ct.set(21, Math.cos), ct.set(22, Math.cosh), ct.set(48, Math.floor), ct.set(49, Math.ceil), ct.set(51, Math.sin), ct.set(52, Math.sinh), ct.set(56, Math.tan), ct.set(57, Math.tanh), ct.set(59, Math.acosh), ct.set(60, Math.asinh), ct.set(65, Math.floor), ft.set(5, Math.pow), ft.set(61, Math.atan2), it.set(1, i4), it.set(2, g3), it.set(3, p7), it.set(11, w4), it.set(12, x3), it.set(13, b), it.set(14, A), it.set(15, P), it.set(16, T), it.set(17, k), it.set(18, N), it.set(19, q), it.set(20, U), it.set(23, d2), it.set(24, F), it.set(25, C2), it.set(26, z), it.set(27, O), it.set(28, D), it.set(29, G), it.set(30, m3), it.set(31, K), it.set(32, u5), it.set(33, H), it.set(34, J), it.set(35, v), it.set(36, S), it.set(37, X), it.set(44, L), it.set(45, Q), it.set(46, V), it.set(53, h3), it.set(64, y5), it.set(65, E), it.set(76, Y), it.set(78, Y), ut.set(38, st), ut.set(39, Z), ut.set(40, tt), ut.set(41, rt), ut.set(42, $), ut.set(43, at), ut.set(47, _), ut.set(54, nt), ut.set(55, et), ut.set(58, lt), ut.set(66, st), ut.set(67, Z), ut.set(68, tt), ut.set(69, rt), ut.set(70, $), ut.set(71, at), ut.set(72, _), ut.set(73, nt), ut.set(74, et), ut.set(75, lt));
}
function gt(t6, e11, n19, r7) {
  let [a30, l16] = s3(n19);
  const c29 = i(n19);
  c29 && (a30 -= 1e-5, l16 += 1e-5);
  for (let o11 = 0; o11 < e11.length; o11++)
    if (e11[o11]) {
      const n20 = t6[o11];
      isNaN(n20) || n20 < a30 || n20 > l16 ? e11[o11] = 0 : r7[o11] = c29 ? Math.round(n20) : n20;
    }
}
function pt(o11, s11, l16 = {}) {
  ht();
  let c29 = f4(o11, s11 >= 66 && s11 <= 75);
  const { outputPixelType: i28 = "f32" } = l16, u18 = !ut.has(s11) || l16.processAsMultiband, h6 = u18 ? o11[0].pixels.length : 1, g6 = [];
  for (let f7 = 0; f7 < h6; f7++) {
    const l17 = ut.has(s11) && !u18 ? o11.flatMap((t6) => t6.pixels) : o11.map((t6) => t6.pixels[f7]);
    let h7, p24 = true;
    if (s11 === p6.setNull) {
      const t6 = W(l17, c29, i28);
      h7 = t6.band, c29 = t6.mask, p24 = false;
    } else if (it.has(s11)) {
      h7 = it.get(s11)(l17, c29, "f64");
    } else if (ct.has(s11))
      h7 = s11 === s4.asin || s11 === s4.acos || s11 === s4.atanh ? M2(l17, c29, "f64", s11) : B3(l17, c29, "f64", ct.get(s11));
    else if (ft.has(s11))
      h7 = I(l17, c29, "f64", ft.get(s11));
    else if (ut.has(s11)) {
      h7 = ut.get(s11)(l17, c29, "f64");
    } else
      h7 = l17[0], p24 = false;
    if (p24 && s11 !== u4.isNull && !a7.has(s11)) {
      const e11 = g.createEmptyBand(i28, h7.length);
      c29 || (c29 = new Uint8Array(h7.length).fill(255)), gt(h7, c29, i28, e11), h7 = e11;
    }
    g6.push(h7);
  }
  const p23 = o11[0];
  return new g({ width: p23.width, height: p23.height, pixelType: i28, mask: s11 === u4.isNull ? null : c29, pixels: g6 });
}
function mt(t6, e11, n19) {
  return pt(t6, e11 = [null, 1, 2, 3, 23, 5, 44][e11] ?? 1, { outputPixelType: n19 });
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/ArithmeticFunction.js
var p8 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Arithmetic", this.functionArguments = null, this.rasterArgumentNames = ["raster", "raster2"];
  }
  _bindSourceRasters() {
    const { operation: t6 } = this.functionArguments;
    if (t6 < 1 || t6 > 6)
      return { success: false, supportsGPU: false, error: "unsupported operation" };
    const e11 = this.sourceRasterInfos[0].clone();
    this.outputPixelType = this._getOutputPixelType(e11.pixelType), e11.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(e11), this.rasterInfo = e11;
    return { success: true, supportsGPU: e11.bandCount <= 3 };
  }
  _processPixels(t6) {
    const { pixelBlocks: e11 } = t6;
    return null == (e11 == null ? void 0 : e11[0]) || null == (e11 == null ? void 0 : e11[1]) ? null : mt(e11, this.functionArguments.operation, this.outputPixelType);
  }
  _getWebGLParameters() {
    const { operation: t6 } = this.functionArguments, e11 = ["", "plus", "minus", "times", "divide", "power", "mod"][t6], r7 = this.outputPixelType ?? "f32";
    let [i28, n19] = s3(r7);
    const u18 = i(r7);
    return u18 && (i28 -= 1e-4, n19 += 1e-4), { imageCount: 2, operationName: e11, domainRange: [i28, n19], isOutputRounded: u18 };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], p8.prototype, "functionName", void 0), e([y({ type: i3, json: { write: true, name: "rasterFunctionArguments" } })], p8.prototype, "functionArguments", void 0), e([y()], p8.prototype, "rasterArgumentNames", void 0), p8 = e([a2("esri.layers.support.rasterFunctions.ArithmeticFunction")], p8);
var a8 = p8;

// node_modules/@arcgis/core/layers/support/rasterFunctions/AspectFunctionArguments.js
var t;
var e4 = t = class extends p4 {
  clone() {
    return new t({ raster: this.raster });
  }
};
e4 = t = e([a2("esri.layers.support.rasterFunctions.AspectFunctionArguments")], e4);
var c4 = e4;

// node_modules/@arcgis/core/layers/support/rasterFunctions/AspectFunction.js
var n5 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Aspect", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    var _a;
    const t6 = this.sourceRasterInfos[0];
    this.isGCS = ((_a = t6.spatialReference) == null ? void 0 : _a.isGeographic) ?? false, this.outputPixelType = this._getOutputPixelType("f32");
    const s11 = t6.clone();
    return s11.pixelType = this.outputPixelType, s11.statistics = [{ min: -1, max: 360, avg: 180, stddev: 30 }], s11.histograms = null, s11.colormap = null, s11.attributeTable = null, s11.bandCount = 1, this.rasterInfo = s11, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    var _a;
    const s11 = (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s11)
      return null;
    const { extent: e11, primaryPixelSizes: r7 } = t6, o11 = r7 == null ? void 0 : r7[0], n19 = o11 ?? (e11 ? { x: e11.width / s11.width, y: e11.height / s11.height } : { x: 1, y: 1 });
    return u2(s11, { resolution: n19 });
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], n5.prototype, "functionName", void 0), e([y({ type: c4, json: { write: true, name: "rasterFunctionArguments" } })], n5.prototype, "functionArguments", void 0), e([y()], n5.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], n5.prototype, "isGCS", void 0), n5 = e([a2("esri.layers.support.rasterFunctions.AspectFunction")], n5);
var p9 = n5;

// node_modules/@arcgis/core/layers/support/rasterFunctions/customBandIndexUtils.js
var e5 = /* @__PURE__ */ new Set(["+", "-", "*", "/", "(", ")"]);
function t2(t6, r7) {
  (t6 = t6.replaceAll(" ", "")).startsWith("-") && (t6 = "0" + t6), t6.startsWith("+") && (t6 = t6.slice(1, t6.length));
  const l16 = t6.split(""), o11 = [], s11 = [];
  let a30 = "";
  for (let i28 = 0; i28 < l16.length; i28++) {
    const t7 = l16[i28];
    e5.has(t7) ? (a30.length && s11.push(n6(a30, r7)), o11.push(t7), a30 = "") : a30 = a30.concat(t7);
  }
  return a30.length && s11.push(n6(a30, r7)), { ops: o11, nums: s11 };
}
function n6(e11, t6) {
  return e11.toLowerCase().startsWith("b") ? t6[parseInt(e11.slice(1), 10) - 1] : parseFloat(e11);
}
function r3(e11, t6, n19, r7) {
  if ("number" == typeof n19 && "number" == typeof r7)
    return n19 + r7;
  let l16, o11, s11;
  "number" == typeof n19 ? (s11 = r7, l16 = s11.length, o11 = new Float32Array(l16), o11.fill(n19)) : (l16 = n19.length, o11 = n19, r7.constructor === Number ? (s11 = new Float32Array(l16), s11.fill(r7)) : s11 = r7);
  const a30 = new Float32Array(l16);
  switch (t6) {
    case "+":
      for (let t7 = 0; t7 < l16; t7++)
        (null == e11 || e11[t7]) && (a30[t7] = o11[t7] + s11[t7]);
      break;
    case "-":
      for (let t7 = 0; t7 < l16; t7++)
        (null == e11 || e11[t7]) && (a30[t7] = o11[t7] - s11[t7]);
      break;
    case "*":
      for (let t7 = 0; t7 < l16; t7++)
        (null == e11 || e11[t7]) && (a30[t7] = o11[t7] * s11[t7]);
      break;
    case "/":
      for (let t7 = 0; t7 < l16; t7++)
        (null == e11 || e11[t7]) && s11[t7] && (a30[t7] = o11[t7] / s11[t7]);
      break;
    case "(":
    case ")":
      throw new Error("encountered error with custom band index equation");
  }
  return a30;
}
function l5(e11, t6) {
  e11.splice(t6, 1);
  let n19 = 0, r7 = 0;
  do {
    n19 = 0, r7 = 0;
    for (let t7 = 0; t7 < e11.length; t7++)
      if ("(" === e11[t7])
        n19 = t7;
      else if (")" === e11[t7]) {
        r7 = t7;
        break;
      }
    r7 === n19 + 1 && e11.splice(n19, 2);
  } while (r7 === n19 + 1);
  return e11;
}
function o4(e11) {
  if (1 === e11.length)
    return { opIndex: 0, numIndex: 0 };
  let t6 = 0, n19 = 0;
  for (let s11 = 0; s11 < e11.length; s11++)
    if ("(" === e11[s11])
      t6 = s11;
    else if (")" === e11[s11]) {
      n19 = s11;
      break;
    }
  const r7 = 0 === n19 ? e11 : e11.slice(t6 + 1, n19);
  let l16 = -1;
  for (let s11 = 0; s11 < r7.length; s11++)
    if ("*" === r7[s11] || "/" === r7[s11]) {
      l16 = s11;
      break;
    }
  if (l16 > -1)
    n19 > 0 && (l16 += t6 + 1);
  else {
    for (let e12 = 0; e12 < r7.length; e12++)
      if ("+" === r7[e12] || "-" === r7[e12]) {
        l16 = e12;
        break;
      }
    n19 > 0 && (l16 += t6 + 1);
  }
  let o11 = 0;
  for (let s11 = 0; s11 < l16; s11++)
    "(" === e11[s11] && o11++;
  return { opIndex: l16, numIndex: l16 - o11 };
}
function s5(e11, n19, s11) {
  let a30, { ops: i28, nums: f7 } = t2(s11, n19);
  if (0 === i28.length) {
    const e12 = 1 === f7.length ? f7[0] : n19[0];
    if (e12 instanceof Float32Array)
      return [e12];
    const t6 = new Float32Array(n19[0].length);
    return "number" == typeof e12 ? t6.fill(e12) : t6.set(e12), [t6];
  }
  for (; i28.length > 0; ) {
    const { numIndex: t6, opIndex: n20 } = o4(i28);
    if (a30 = r3(e11, i28[n20], f7[t6], f7[t6 + 1]), 1 === i28.length)
      break;
    i28 = l5(i28, n20), f7.splice(t6, 2, a30);
  }
  return [a30];
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/bandIndexUtils.js
var o5 = new n({ 0: "custom", 1: "ndvi", 2: "savi", 3: "tsavi", 4: "msavi", 5: "gemi", 6: "pvi", 7: "gvitm", 8: "sultan", 9: "vari", 10: "gndvi", 11: "sr", 12: "ndvi-re", 13: "sr-re", 14: "mtvi2", 15: "rtvi-core", 16: "ci-re", 17: "ci-g", 18: "ndwi", 19: "evi", 20: "iron-oxide", 21: "ferrous-minerals", 22: "clay-minerals", 23: "wndwi", 24: "bai", 25: "nbr", 26: "ndbi", 27: "ndmi", 28: "ndsi", 29: "mndwi" }, { useNumericKeys: true });
function a9(n19, o11) {
  if (!o3(n19))
    return n19;
  const { equation: a30, method: s11 } = o11, i28 = o11.bandIndexes.map((n20) => n20 - 1), { pixels: x5, mask: j3 } = n19;
  let q2;
  switch (s11) {
    case "gndvi":
    case "nbr":
    case "ndbi":
    case "ndvi":
    case "ndvi-re":
    case "ndsi":
    case "ndmi":
    case "mndwi":
      q2 = l6(j3, x5[i28[0]], x5[i28[1]]);
      break;
    case "ndwi":
      q2 = l6(j3, x5[i28[1]], x5[i28[0]]);
      break;
    case "sr":
    case "sr-re":
    case "iron-oxide":
    case "ferrous-minerals":
    case "clay-minerals":
      q2 = c5(j3, x5[i28[0]], x5[i28[1]]);
      break;
    case "ci-g":
    case "ci-re":
      q2 = u6(j3, x5[i28[0]], x5[i28[1]]);
      break;
    case "savi":
      q2 = f5(j3, x5[i28[0]], x5[i28[1]], i28[2] + 1);
      break;
    case "tsavi":
      q2 = w5(j3, x5[i28[0]], x5[i28[1]], i28[2] + 1, i28[3] + 1, i28[4] + 1);
      break;
    case "msavi":
      q2 = h4(j3, x5[i28[0]], x5[i28[1]]);
      break;
    case "gemi":
      q2 = m4(j3, x5[i28[0]], x5[i28[1]]);
      break;
    case "pvi":
      q2 = d3(j3, x5[i28[0]], x5[i28[1]], i28[2] + 1, i28[3] + 1);
      break;
    case "gvitm":
      q2 = g4(j3, [x5[i28[0]], x5[i28[1]], x5[i28[2]], x5[i28[3]], x5[i28[4]], x5[i28[5]]]);
      break;
    case "sultan":
      q2 = y6(j3, [x5[i28[0]], x5[i28[1]], x5[i28[2]], x5[i28[3]], x5[i28[4]]]);
      break;
    case "vari":
      q2 = b2(j3, [x5[i28[0]], x5[i28[1]], x5[i28[2]]]);
      break;
    case "mtvi2":
      q2 = v2(j3, [x5[i28[0]], x5[i28[1]], x5[i28[2]]]);
      break;
    case "rtvi-core":
      q2 = k2(j3, [x5[i28[0]], x5[i28[1]], x5[i28[2]]]);
      break;
    case "evi":
      q2 = A2(j3, [x5[i28[0]], x5[i28[1]], x5[i28[2]]]);
      break;
    case "wndwi":
      q2 = p10(j3, [x5[i28[0]], x5[i28[1]], x5[i28[2]]], i28[3] ? i28[3] + 1 : 0.5);
      break;
    case "bai":
      q2 = F2(j3, x5[i28[0]], x5[i28[1]]);
      break;
    case "custom":
      q2 = s5(j3, x5, a30);
      break;
    default:
      return n19;
  }
  const M4 = null != j3 ? new Uint8Array(j3.length) : null;
  null != j3 && null != M4 && M4.set(j3);
  const U2 = new g({ width: n19.width, height: n19.height, pixelType: "f32", pixels: q2, mask: M4 });
  return U2.updateStatistics(), U2;
}
function s6(n19, e11, r7, o11) {
  const { mask: a30, pixels: s11, width: i28, height: l16 } = n19, c29 = s11[r7], u18 = s11[e11], f7 = u18.length, w7 = o11 ? new Uint8Array(f7) : new Float32Array(f7), h6 = o11 ? 100 : 1, m10 = o11 ? 100.5 : 0;
  for (let t6 = 0; t6 < f7; t6++)
    if (null == a30 || a30[t6]) {
      const n20 = c29[t6], e12 = u18[t6], r8 = n20 + e12;
      r8 && (w7[t6] = (n20 - e12) / r8 * h6 + m10);
    }
  const d7 = new g({ width: i28, height: l16, mask: a30, pixelType: o11 ? "u8" : "f32", pixels: [w7] });
  return d7.updateStatistics(), d7;
}
function i5(n19) {
  const t6 = new Float32Array(9);
  return t6[3 * n19[0]] = 1, t6[3 * n19[1] + 1] = 1, t6[3 * n19[2] + 2] = 1, t6;
}
function l6(n19, t6, e11) {
  const r7 = e11.length, o11 = new Float32Array(r7);
  for (let a30 = 0; a30 < r7; a30++)
    if (null == n19 || n19[a30]) {
      const n20 = t6[a30], r8 = e11[a30], s11 = n20 + r8;
      s11 && (o11[a30] = (n20 - r8) / s11);
    }
  return [o11];
}
function c5(n19, t6, e11) {
  const r7 = e11.length, o11 = new Float32Array(r7);
  for (let a30 = 0; a30 < r7; a30++)
    if (null == n19 || n19[a30]) {
      const n20 = t6[a30], r8 = e11[a30];
      r8 && (o11[a30] = n20 / r8);
    }
  return [o11];
}
function u6(n19, t6, e11) {
  const r7 = t6.length, o11 = new Float32Array(r7);
  for (let a30 = 0; a30 < r7; a30++)
    if (null == n19 || n19[a30]) {
      const n20 = t6[a30], r8 = e11[a30];
      r8 && (o11[a30] = n20 / r8 - 1);
    }
  return [o11];
}
function f5(n19, t6, e11, r7) {
  const o11 = e11.length, a30 = new Float32Array(o11);
  for (let s11 = 0; s11 < o11; s11++)
    if (null == n19 || n19[s11]) {
      const n20 = e11[s11], o12 = t6[s11], i28 = o12 + n20 + r7;
      i28 && (a30[s11] = (o12 - n20) / i28 * (1 + r7));
    }
  return [a30];
}
function w5(n19, t6, e11, r7, o11, a30) {
  const s11 = e11.length, i28 = new Float32Array(s11), l16 = -o11 * r7 + a30 * (1 + r7 * r7);
  for (let c29 = 0; c29 < s11; c29++)
    if (null == n19 || n19[c29]) {
      const n20 = e11[c29], a31 = t6[c29], s12 = o11 * a31 + n20 + l16;
      s12 && (i28[c29] = r7 * (a31 - r7 * n20 - o11) / s12);
    }
  return [i28];
}
function h4(n19, t6, e11) {
  const r7 = e11.length, o11 = new Float32Array(r7);
  for (let a30 = 0; a30 < r7; a30++)
    if (null == n19 || n19[a30]) {
      const n20 = e11[a30], r8 = t6[a30], s11 = 2 * r8 + 1;
      o11[a30] = 0.5 * (s11 - Math.sqrt(s11 * s11 - 8 * (r8 - n20)));
    }
  return [o11];
}
function m4(n19, t6, e11) {
  const r7 = e11.length, o11 = new Float32Array(r7);
  for (let a30 = 0; a30 < r7; a30++)
    if (null == n19 || n19[a30]) {
      const n20 = e11[a30], r8 = t6[a30];
      if (1 !== n20 && r8 + n20 + 0.5 !== 0) {
        const t7 = (2 * (r8 * r8 - n20 * n20) + 1.5 * r8 + 0.5 * n20) / (r8 + n20 + 0.5);
        o11[a30] = t7 * (1 - 0.25 * t7) - (n20 - 0.125) / (1 - n20);
      }
    }
  return [o11];
}
function d3(n19, t6, e11, r7, o11) {
  const a30 = e11.length, s11 = new Float32Array(a30), i28 = 1 / Math.sqrt(1 + r7 * r7);
  for (let l16 = 0; l16 < a30; l16++)
    if (null == n19 || n19[l16]) {
      const n20 = e11[l16], a31 = t6[l16];
      s11[l16] = (a31 - r7 * n20 - o11) * i28;
    }
  return [s11];
}
function g4(n19, t6) {
  const [e11, r7, o11, a30, s11, i28] = t6, l16 = e11.length, c29 = new Float32Array(l16);
  for (let u18 = 0; u18 < l16; u18++)
    (null == n19 || n19[u18]) && (c29[u18] = -0.2848 * e11[u18] - 0.2435 * r7[u18] - 0.5436 * o11[u18] + 0.7243 * a30[u18] + 0.084 * s11[u18] - 0.18 * i28[u18]);
  return [c29];
}
function y6(n19, t6) {
  const [e11, r7, o11, a30, s11] = t6, i28 = e11.length, l16 = new Float32Array(i28), c29 = new Float32Array(i28), u18 = new Float32Array(i28);
  for (let f7 = 0; f7 < i28; f7++)
    (null == n19 || n19[f7]) && (l16[f7] = s11[f7] ? a30[f7] / s11[f7] * 100 : 0, c29[f7] = e11[f7] ? a30[f7] / e11[f7] * 100 : 0, u18[f7] = o11[f7] ? r7[f7] / o11[f7] * (a30[f7] / o11[f7]) * 100 : 0);
  return [l16, c29, u18];
}
function b2(n19, t6) {
  const [e11, r7, o11] = t6, a30 = e11.length, s11 = new Float32Array(a30);
  for (let i28 = 0; i28 < a30; i28++)
    if (null == n19 || n19[i28])
      for (i28 = 0; i28 < a30; i28++) {
        const n20 = e11[i28], t7 = r7[i28], a31 = t7 + n20 - o11[i28];
        a31 && (s11[i28] = (t7 - n20) / a31);
      }
  return [s11];
}
function v2(n19, t6) {
  const [e11, r7, o11] = t6, a30 = e11.length, s11 = new Float32Array(a30);
  for (let i28 = 0; i28 < a30; i28++)
    if (null == n19 || n19[i28])
      for (i28 = 0; i28 < a30; i28++) {
        const n20 = e11[i28], t7 = r7[i28], a31 = o11[i28], l16 = Math.sqrt((2 * n20 + 1) ** 2 - (6 * n20 - 5 * Math.sqrt(t7)) - 0.5);
        if (l16) {
          const e12 = 1.5 * (1.2 * (n20 - a31) - 2.5 * (t7 - a31));
          s11[i28] = e12 / l16;
        }
      }
  return [s11];
}
function k2(n19, t6) {
  const [e11, r7, o11] = t6, a30 = e11.length, s11 = new Float32Array(a30);
  for (let i28 = 0; i28 < a30; i28++)
    if (null == n19 || n19[i28])
      for (i28 = 0; i28 < a30; i28++) {
        const n20 = e11[i28], t7 = r7[i28], a31 = o11[i28];
        s11[i28] = 100 * (n20 - t7) - 10 * (n20 - a31);
      }
  return [s11];
}
function A2(n19, t6) {
  const [e11, r7, o11] = t6, a30 = e11.length, s11 = new Float32Array(a30);
  for (let i28 = 0; i28 < a30; i28++)
    if (null == n19 || n19[i28])
      for (i28 = 0; i28 < a30; i28++) {
        const n20 = e11[i28], t7 = r7[i28], a31 = n20 + 6 * t7 - 7.5 * o11[i28] + 1;
        a31 && (s11[i28] = 2.5 * (n20 - t7) / a31);
      }
  return [s11];
}
function p10(n19, t6, e11 = 0.5) {
  const [r7, o11, a30] = t6, s11 = o11.length, i28 = new Float32Array(s11);
  for (let l16 = 0; l16 < s11; l16++)
    if (null == n19 || n19[l16])
      for (l16 = 0; l16 < s11; l16++) {
        const n20 = r7[l16], t7 = o11[l16], s12 = a30[l16], c29 = n20 + e11 * t7 + (1 - e11) * s12;
        c29 && (i28[l16] = (n20 - e11 * t7 - (1 - e11) * s12) / c29);
      }
  return [i28];
}
function F2(n19, t6, e11) {
  const r7 = e11.length, o11 = new Float32Array(r7);
  for (let a30 = 0; a30 < r7; a30++)
    if (null == n19 || n19[a30])
      for (a30 = 0; a30 < r7; a30++) {
        const n20 = (0.1 - t6[a30]) ** 2 + (0.06 - e11[a30]) ** 2;
        n20 && (o11[a30] = 1 / n20);
      }
  return [o11];
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/BandArithmeticFunctionArguments.js
var i6;
var p11 = i6 = class extends p4 {
  constructor() {
    super(...arguments), this.method = "custom";
  }
  clone() {
    return new i6({ method: this.method, bandIndexes: this.bandIndexes, raster: a(this.raster) });
  }
};
e([y({ json: { type: String, write: true } })], p11.prototype, "bandIndexes", void 0), e([o2(o5)], p11.prototype, "method", void 0), p11 = i6 = e([a2("esri.layers.support.rasterFunctions.BandArithmeticFunctionArguments")], p11);
var a10 = p11;

// node_modules/@arcgis/core/layers/support/rasterFunctions/BandArithmeticFunction.js
var o6 = /* @__PURE__ */ new Set(["vari", "mtvi2", "rtvi-core", "evi"]);
var c6 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "BandArithmetic", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    this.outputPixelType = this._getOutputPixelType("f32");
    const e11 = this.sourceRasterInfos[0];
    if (e11.bandCount < 2)
      return { success: false, supportsGPU: false, error: "band-arithmetic-function: source raster has insufficient amount of raster bands" };
    const s11 = e11.clone();
    s11.pixelType = this.outputPixelType, s11.bandCount = "sultan" === this.functionArguments.method ? 3 : 1, this._removeStatsHistColormapVAT(s11), s11.keyProperties = { ...s11.keyProperties, BandProperties: void 0 }, this.rasterInfo = s11;
    return { success: true, supportsGPU: !["custom", "gvitm", "sultan"].includes(this.functionArguments.method) };
  }
  _processPixels(e11) {
    var _a;
    const s11 = (_a = e11.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s11)
      return s11;
    const { method: t6, bandIndexes: r7 } = this.functionArguments, i28 = r7.split(" ").map((e12) => parseFloat(e12));
    return a9(s11, { method: t6, bandIndexes: i28, equation: r7 });
  }
  _getWebGLParameters() {
    const e11 = this.functionArguments.bandIndexes.split(" ").map((e12) => parseFloat(e12) - 1);
    2 === e11.length && e11.push(0);
    const s11 = this.isInputBandIdsSwizzled ? [0, 1, 2] : e11;
    let t6, r7;
    const n19 = new Float32Array(3), { method: a30 } = this.functionArguments;
    switch (a30) {
      case "gndvi":
      case "nbr":
      case "ndbi":
      case "ndvi":
      case "ndvi-re":
      case "ndsi":
      case "ndmi":
      case "mndwi":
        t6 = i5([s11[0], s11[1], 0]), r7 = "ndxi";
        break;
      case "ndwi":
        t6 = i5([s11[1], s11[0], 0]), r7 = "ndxi";
        break;
      case "sr":
      case "sr-re":
      case "iron-oxide":
      case "ferrous-minerals":
      case "clay-minerals":
        t6 = i5([s11[0], s11[1], 0]), r7 = "sr";
        break;
      case "ci-g":
      case "ci-re":
        t6 = i5([s11[0], s11[1], 0]), r7 = "ci";
        break;
      case "savi":
        t6 = i5([s11[0], s11[1], 0]), r7 = "savi", n19[0] = e11[2] + 1;
        break;
      case "tsavi":
        t6 = i5([s11[0], s11[1], 0]), r7 = "tsavi", n19[0] = e11[2] + 1, n19[1] = e11[3] + 1, n19[2] = e11[4] + 1;
        break;
      case "msavi":
        t6 = i5([s11[0], s11[1], 0]), r7 = "msavi";
        break;
      case "gemi":
        t6 = i5([s11[0], s11[1], 0]), r7 = "gemi";
        break;
      case "pvi":
        t6 = i5([s11[0], s11[1], 0]), r7 = "tsavi", n19[0] = e11[2] + 1, n19[1] = e11[3] + 1;
        break;
      case "vari":
        t6 = i5([s11[0], s11[1], s11[2]]), r7 = "vari";
        break;
      case "mtvi2":
        t6 = i5([s11[0], s11[1], s11[2]]), r7 = "mtvi";
        break;
      case "rtvi-core":
        t6 = i5([s11[0], s11[1], s11[2]]), r7 = "rtvicore";
        break;
      case "evi":
        t6 = i5([s11[0], s11[1], s11[2]]), r7 = "evi";
        break;
      case "wndwi":
        t6 = i5([s11[0], s11[1], 0]), r7 = "wndwi", n19[0] = e11[3] ? e11[3] + 1 : 0.5;
        break;
      case "bai":
        t6 = i5([s11[1], s11[0], 0]), r7 = "bai";
        break;
      default:
        t6 = i5([0, 1, 2]), r7 = "custom";
    }
    return { bandIndexMat3: t6, indexType: r7, adjustments: n19 };
  }
  _getInputBandIds(e11) {
    if ("custom" === this.functionArguments.method)
      return e11;
    const s11 = this.functionArguments.bandIndexes.split(" ").map((e12) => parseFloat(e12) - 1), t6 = e11.length, r7 = s11.map((e12) => e12 >= t6 ? t6 - 1 : e12), n19 = o6.has(this.functionArguments.method) ? 3 : 2, i28 = r7.slice(0, n19).map((s12) => e11[s12]);
    return 2 === i28.length && i28.push(0), i28;
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], c6.prototype, "functionName", void 0), e([y({ type: a10, json: { write: true, name: "rasterFunctionArguments" } })], c6.prototype, "functionArguments", void 0), e([y()], c6.prototype, "rasterArgumentNames", void 0), c6 = e([a2("esri.layers.support.rasterFunctions.BandArithmeticFunction")], c6);
var u7 = c6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ClipFunctionArguments.js
var c7;
var n7 = new n({ 1: "outside", 2: "inside" }, { useNumericKeys: true });
var m5 = c7 = class extends p4 {
  constructor() {
    super(...arguments), this.clippingType = "outside";
  }
  clone() {
    return new c7({ clippingGeometry: this.clippingGeometry.clone(), clippingType: this.clippingType });
  }
};
e([y({ types: n2, json: { read: y2, write: true } })], m5.prototype, "clippingGeometry", void 0), e([y({ json: { read: n7.read, write: n7.write } })], m5.prototype, "clippingType", void 0), m5 = c7 = e([a2("esri.layers.support.rasterFunctions.ClipFunctionArguments")], m5);
var a11 = m5;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ClipFunction.js
var i7 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Clip", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0].clone();
    return this.outputPixelType = this._getOutputPixelType(t6.pixelType), t6.pixelType = this.outputPixelType, this.rasterInfo = t6, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    var _a;
    return (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
  }
  _getWebGLParameters() {
    const { clippingGeometry: t6, clippingType: e11 } = this.functionArguments;
    return { clippingGeometry: t6.toJSON(), clippingType: e11 };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], i7.prototype, "functionName", void 0), e([y({ type: a11, json: { write: true, name: "rasterFunctionArguments" } })], i7.prototype, "functionArguments", void 0), e([y()], i7.prototype, "rasterArgumentNames", void 0), e([y()], i7.prototype, "isNoopProcess", void 0), i7 = e([a2("esri.layers.support.rasterFunctions.ClipFunction")], i7);
var p12 = i7;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapFunctionArguments.js
var i8;
var u8 = i8 = class extends p4 {
  castColormapName(o11) {
    if (!o11)
      return null;
    const r7 = o11.toLowerCase();
    return C.includes(r7) ? r7 : null;
  }
  readColorRamp(o11) {
    return p(o11);
  }
  readColorRampName(o11, r7) {
    if (!o11)
      return null;
    const e11 = a3.jsonValues.find((r8) => r8.toLowerCase() === o11.toLowerCase());
    return e11 ? a3.fromJSON(e11) : null;
  }
  clone() {
    var _a;
    return new i8({ colormap: a(this.colormap), colormapName: this.colormapName, colorRamp: (_a = this.colorRamp) == null ? void 0 : _a.clone(), colorRampName: this.colorRampName });
  }
};
e([y({ type: [[Number]], json: { write: true } })], u8.prototype, "colormap", void 0), e([y({ type: String, json: { write: true } })], u8.prototype, "colormapName", void 0), e([s2("colormapName")], u8.prototype, "castColormapName", null), e([y({ types: m, json: { write: true } })], u8.prototype, "colorRamp", void 0), e([o("colorRamp")], u8.prototype, "readColorRamp", null), e([y({ type: a3.apiValues, json: { type: a3.jsonValues, write: a3.write } })], u8.prototype, "colorRampName", void 0), e([o("colorRampName")], u8.prototype, "readColorRampName", null), u8 = i8 = e([a2("esri.layers.support.rasterFunctions.ColormapFunctionArguments")], u8);
var d4 = u8;

// node_modules/@arcgis/core/layers/support/rasterFunctions/colormaps.js
var t3 = [[36, 0, 255], [36, 0, 255], [36, 0, 255], [36, 0, 255], [112, 75, 3], [113, 76, 3], [114, 77, 3], [115, 77, 3], [116, 78, 3], [117, 79, 3], [118, 79, 3], [119, 80, 3], [121, 81, 4], [122, 82, 4], [123, 82, 4], [124, 83, 4], [125, 84, 4], [126, 84, 4], [127, 85, 4], [128, 86, 4], [129, 86, 4], [130, 87, 4], [131, 88, 4], [132, 89, 4], [133, 89, 4], [134, 90, 4], [135, 91, 4], [136, 91, 4], [137, 92, 4], [138, 93, 4], [139, 94, 4], [140, 94, 4], [142, 95, 5], [143, 96, 5], [144, 96, 5], [145, 97, 5], [146, 98, 5], [147, 99, 5], [148, 99, 5], [149, 100, 5], [150, 101, 5], [151, 101, 5], [152, 102, 5], [153, 103, 5], [154, 104, 5], [155, 104, 5], [156, 105, 5], [157, 106, 5], [158, 106, 5], [159, 107, 5], [160, 108, 5], [161, 108, 5], [162, 109, 5], [164, 110, 6], [165, 111, 6], [166, 111, 6], [167, 112, 6], [168, 113, 6], [169, 113, 6], [170, 114, 6], [171, 115, 6], [172, 116, 6], [173, 116, 6], [174, 117, 6], [245, 0, 0], [245, 5, 0], [245, 10, 0], [246, 15, 0], [246, 20, 0], [246, 25, 0], [246, 30, 0], [247, 35, 0], [247, 40, 0], [247, 45, 0], [247, 50, 0], [247, 55, 0], [248, 60, 0], [248, 65, 0], [248, 70, 0], [248, 75, 0], [249, 81, 0], [249, 86, 0], [249, 91, 0], [249, 96, 0], [250, 101, 0], [250, 106, 0], [250, 111, 0], [250, 116, 0], [250, 121, 0], [251, 126, 0], [251, 131, 0], [251, 136, 0], [251, 141, 0], [252, 146, 0], [252, 151, 0], [252, 156, 0], [252, 156, 0], [251, 159, 0], [250, 162, 0], [249, 165, 0], [248, 168, 0], [247, 171, 0], [246, 174, 0], [245, 177, 0], [245, 179, 0], [244, 182, 0], [243, 185, 0], [242, 188, 0], [241, 191, 0], [240, 194, 0], [239, 197, 0], [238, 200, 0], [237, 203, 0], [236, 206, 0], [235, 209, 0], [234, 212, 0], [233, 215, 0], [232, 218, 0], [231, 221, 0], [230, 224, 0], [230, 226, 0], [229, 229, 0], [228, 232, 0], [227, 235, 0], [226, 238, 0], [225, 241, 0], [224, 244, 0], [223, 247, 0], [165, 247, 0], [163, 244, 0], [161, 240, 0], [158, 237, 0], [156, 233, 1], [154, 230, 1], [152, 227, 1], [149, 223, 1], [147, 220, 1], [145, 216, 1], [143, 213, 1], [140, 210, 2], [138, 206, 2], [136, 203, 2], [134, 200, 2], [132, 196, 2], [129, 193, 2], [127, 189, 2], [125, 186, 3], [123, 183, 3], [120, 179, 3], [118, 176, 3], [116, 172, 3], [114, 169, 3], [111, 166, 3], [109, 162, 4], [107, 159, 4], [105, 155, 4], [103, 152, 4], [100, 149, 4], [98, 145, 4], [96, 142, 4], [94, 138, 5], [91, 135, 5], [89, 132, 5], [87, 128, 5], [85, 125, 5], [82, 121, 5], [80, 118, 5], [78, 115, 6], [76, 111, 6], [73, 108, 6], [71, 105, 6], [69, 101, 6], [67, 98, 6], [65, 94, 6], [62, 91, 7], [60, 88, 7], [58, 84, 7], [56, 81, 7], [53, 77, 7], [51, 74, 7], [49, 71, 7], [47, 67, 8], [44, 64, 8], [42, 60, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8]];
var o7 = [[36, 0, 255], [36, 0, 255], [36, 0, 255], [36, 0, 255], [245, 20, 0], [245, 24, 0], [245, 29, 0], [245, 31, 0], [247, 33, 0], [247, 33, 0], [247, 37, 0], [247, 41, 0], [247, 41, 0], [247, 41, 0], [247, 45, 0], [247, 45, 0], [247, 47, 0], [247, 49, 0], [247, 49, 0], [247, 54, 0], [247, 54, 0], [247, 56, 0], [247, 58, 0], [247, 58, 0], [250, 62, 0], [250, 62, 0], [250, 62, 0], [250, 67, 0], [250, 67, 0], [250, 67, 0], [250, 69, 0], [250, 71, 0], [250, 71, 0], [250, 75, 0], [250, 75, 0], [250, 78, 0], [250, 79, 0], [250, 79, 0], [250, 79, 0], [250, 81, 0], [250, 83, 0], [250, 83, 0], [250, 87, 0], [250, 87, 0], [250, 90, 0], [250, 92, 0], [252, 93, 0], [252, 93, 0], [252, 97, 0], [252, 97, 0], [252, 97, 0], [252, 97, 0], [252, 101, 0], [252, 101, 0], [252, 101, 0], [252, 101, 0], [252, 105, 0], [252, 105, 0], [252, 107, 0], [252, 109, 0], [252, 109, 0], [252, 113, 13], [255, 118, 20], [255, 119, 23], [255, 121, 25], [255, 126, 33], [255, 132, 38], [255, 133, 40], [255, 135, 43], [255, 141, 48], [255, 144, 54], [255, 150, 59], [255, 152, 61], [255, 153, 64], [255, 159, 69], [255, 163, 77], [255, 165, 79], [255, 168, 82], [255, 174, 87], [255, 176, 92], [255, 181, 97], [255, 183, 99], [255, 186, 102], [255, 191, 107], [255, 197, 115], [255, 201, 120], [255, 203, 123], [255, 205, 125], [255, 209, 130], [255, 214, 138], [255, 216, 141], [255, 218, 143], [255, 224, 150], [255, 228, 156], [255, 234, 163], [255, 236, 165], [255, 238, 168], [255, 243, 173], [255, 248, 181], [255, 252, 186], [253, 252, 186], [250, 252, 187], [244, 250, 180], [238, 247, 176], [234, 246, 173], [231, 245, 169], [223, 240, 163], [217, 237, 157], [211, 235, 150], [205, 233, 146], [200, 230, 142], [195, 227, 136], [189, 224, 132], [184, 222, 126], [180, 220, 123], [174, 217, 119], [169, 214, 114], [163, 212, 108], [160, 210, 105], [154, 207, 101], [148, 204, 96], [143, 201, 93], [138, 199, 88], [134, 197, 84], [130, 194, 81], [126, 191, 77], [117, 189, 70], [115, 186, 68], [112, 184, 64], [106, 181, 60], [100, 179, 55], [94, 176, 49], [92, 174, 47], [90, 173, 45], [81, 168, 37], [75, 166, 33], [71, 163, 28], [66, 160, 24], [62, 158, 21], [56, 156, 14], [51, 153, 0], [51, 153, 0], [51, 153, 0], [50, 150, 0], [50, 150, 0], [50, 150, 0], [50, 150, 0], [49, 148, 0], [49, 148, 0], [49, 148, 0], [48, 145, 0], [48, 145, 0], [48, 145, 0], [48, 145, 0], [48, 143, 0], [48, 143, 0], [48, 143, 0], [48, 143, 0], [47, 140, 0], [47, 140, 0], [47, 140, 0], [47, 140, 0], [46, 138, 0], [46, 138, 0], [46, 138, 0], [46, 138, 0], [45, 135, 0], [45, 135, 0], [45, 135, 0], [45, 135, 0], [44, 133, 0], [44, 133, 0], [44, 133, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [42, 128, 0], [42, 128, 0], [42, 128, 0], [42, 125, 0], [42, 125, 0], [42, 125, 0], [42, 125, 0], [41, 122, 0], [41, 122, 0], [41, 122, 0], [41, 122, 0], [40, 120, 0], [40, 120, 0], [40, 120, 0], [40, 120, 0], [40, 120, 0], [39, 117, 0], [39, 117, 0], [39, 117, 0], [39, 117, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0]];
function e6(t6, o11) {
  const e11 = [], n19 = [];
  for (let r7 = 0; r7 < t6.length - 1; r7++)
    e11.push({ type: "algorithmic", algorithm: "esriHSVAlgorithm", fromColor: t6[r7].slice(1), toColor: t6[r7 + 1].slice(1) }), n19.push(t6[r7 + 1][0] - t6[r7][0]);
  const s11 = t6[t6.length - 1][0];
  return w3({ type: "multipart", colorRamps: e11 }, { numColors: s11, weights: o11 = o11 ?? n19 });
}
function n8() {
  return e6([[0, 0, 191, 191], [51, 0, 0, 255], [102, 255, 0, 255], [153, 255, 0, 127], [204, 191, 63, 127], [256, 20, 20, 20]]);
}
function s7() {
  const r7 = e6([[0, 255, 255, 255], [70, 0, 255, 0], [80, 205, 173, 193], [100, 150, 150, 150], [110, 120, 51, 100], [130, 120, 100, 200], [140, 28, 3, 144], [160, 6, 0, 55], [180, 10, 25, 30], [201, 6, 7, 27]]);
  for (let t6 = r7.length; t6 < 256; t6++)
    r7.push([6, 27, 7]);
  return r7;
}
function l7() {
  return w3({ type: "algorithmic", algorithm: "esriHSVAlgorithm", fromColor: [0, 0, 0], toColor: [255, 255, 255] });
}
function i9() {
  const r7 = [];
  for (let t6 = 0; t6 < 256; t6++) {
    const t7 = [];
    for (let r8 = 0; r8 < 3; r8++)
      t7.push(Math.round(255 * Math.random()));
    r7.push(t7);
  }
  return r7;
}
function a12() {
  return e6([[0, 38, 41, 54], [69, 79, 82, 90], [131, 156, 156, 156], [256, 253, 253, 241]], [0.268, 0.238, 0.495]);
}
function c8(r7) {
  let e11;
  switch (r7) {
    case "elevation":
      e11 = n8();
      break;
    case "gray":
      e11 = l7();
      break;
    case "hillshade":
      e11 = a12();
      break;
    case "ndvi":
      e11 = t3;
      break;
    case "ndvi2":
      e11 = s7();
      break;
    case "ndvi3":
      e11 = o7;
      break;
    case "random":
      e11 = i9();
  }
  return e11 ? (e11 = e11.map((r8, t6) => [t6, ...r8]), e11) : null;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapFunction.js
var a13 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Colormap", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const o11 = this.sourceRasterInfos[0];
    if (o11.bandCount > 1)
      return { success: false, supportsGPU: false, error: "colormap-function: source data must be single band" };
    let { colormap: r7, colormapName: t6, colorRamp: s11, colorRampName: e11 } = this.functionArguments;
    if (!(r7 == null ? void 0 : r7.length))
      if (s11)
        r7 = B(s11, { interpolateAlpha: true });
      else if (e11) {
        const o12 = c2(e11);
        o12 && (r7 = B(o12));
      } else
        t6 && (r7 = c8(t6));
    if (!(r7 == null ? void 0 : r7.length))
      return { success: false, supportsGPU: false, error: "colormap-function: missing colormap argument" };
    const p23 = this._getOutputPixelType(o11.pixelType);
    this.outputPixelType = p23.startsWith("f") ? "s32" : p23;
    const a30 = o11.clone();
    return a30.pixelType = this.outputPixelType, a30.colormap = r7, a30.bandCount = 1, this.rasterInfo = a30, { success: true, supportsGPU: true };
  }
  _processPixels(o11) {
    var _a;
    let r7 = (_a = o11.pixelBlocks) == null ? void 0 : _a[0];
    return !r7 || i(r7.pixelType) || (r7 = r7.clone(), r7.clamp(this.outputPixelType)), r7;
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], a13.prototype, "functionName", void 0), e([y({ type: d4, json: { write: true, name: "rasterFunctionArguments" } })], a13.prototype, "functionArguments", void 0), e([y()], a13.prototype, "rasterArgumentNames", void 0), e([y()], a13.prototype, "isNoopProcess", void 0), e([y({ json: { write: true } })], a13.prototype, "indexedColormap", void 0), a13 = e([a2("esri.layers.support.rasterFunctions.ColormapFunction")], a13);
var u9 = a13;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CompositeBandFunctionArguments.js
var a14;
var c9 = a14 = class extends p4 {
  constructor() {
    super(...arguments), this.rasters = [];
  }
  writeRasters(r7, s11) {
    s11.rasters = r7.map((r8) => "number" == typeof r8 || "string" == typeof r8 ? r8 : r8.toJSON());
  }
  clone() {
    return new a14({ rasters: a(this.rasters) });
  }
};
e([y({ json: { write: true } })], c9.prototype, "rasters", void 0), e([r("rasters")], c9.prototype, "writeRasters", null), c9 = a14 = e([a2("esri.layers.support.rasterFunctions.CompositeBandFunctionArguments")], c9);
var i10 = c9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CompositeBandFunction.js
var i11 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "CompositeBand", this.functionArguments = null, this.rasterArgumentNames = ["rasters"];
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t6 } = this, e11 = t6[0];
    this.outputPixelType = this._getOutputPixelType(e11.pixelType);
    const s11 = e11.clone();
    if (s11.attributeTable = null, s11.colormap = null, s11.pixelType = this.outputPixelType, s11.bandCount = t6.map(({ bandCount: t7 }) => t7).reduce((t7, e12) => t7 + e12), t6.every(({ statistics: t7 }) => null != t7 && t7.length)) {
      const e12 = [];
      t6.forEach(({ statistics: t7 }) => null != t7 && e12.push(...t7)), s11.statistics = e12;
    }
    if (t6.every(({ histograms: t7 }) => null != t7 && t7.length)) {
      const e12 = [];
      t6.forEach(({ histograms: t7 }) => null != t7 && e12.push(...t7)), s11.histograms = e12;
    }
    s11.bandCount > 1 && (s11.colormap = null, s11.attributeTable = null);
    const r7 = t6.every((t7) => {
      var _a;
      return (_a = t7.keyProperties.BandProperties) == null ? void 0 : _a.length;
    }) ? t6.flatMap((t7) => t7.keyProperties.BandProperties) : void 0;
    s11.keyProperties = { ...s11.keyProperties, BandProperties: r7 }, this.rasterInfo = s11;
    return { success: true, supportsGPU: s11.bandCount <= 3 };
  }
  _processPixels(t6) {
    const { pixelBlocks: e11 } = t6;
    if (!e11)
      return null;
    const s11 = e11 == null ? void 0 : e11[0];
    return null == s11 ? null : r2(e11);
  }
  _getWebGLParameters() {
    return { bandCount: this.rasterInfo.bandCount };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], i11.prototype, "functionName", void 0), e([y({ type: i10, json: { write: true, name: "rasterFunctionArguments" } })], i11.prototype, "functionArguments", void 0), e([y()], i11.prototype, "rasterArgumentNames", void 0), i11 = e([a2("esri.layers.support.rasterFunctions.CompositeBandFunction")], i11);
var a15 = i11;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ContrastBrightnessFunctionArguments.js
var e7;
var n9 = e7 = class extends p4 {
  constructor() {
    super(...arguments), this.contrastOffset = 0, this.brightnessOffset = 0;
  }
  clone() {
    return new e7({ contrastOffset: this.contrastOffset, brightnessOffset: this.brightnessOffset, raster: this.raster });
  }
};
e([y({ json: { write: true } })], n9.prototype, "contrastOffset", void 0), e([y({ json: { write: true } })], n9.prototype, "brightnessOffset", void 0), n9 = e7 = e([a2("esri.layers.support.rasterFunctions.ContrastBrightnessFunctionArguments")], n9);
var i12 = n9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ContrastBrightnessFunction.js
var u10 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "ContrastBrightness", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null;
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t6 } = this, s11 = t6[0];
    if ("u8" !== s11.pixelType)
      return { success: false, supportsGPU: false, error: "Only unsigned 8 bit raster is supported by ContrastBrightness function." };
    this.outputPixelType = this._getOutputPixelType("u8");
    const r7 = s11.clone();
    this._removeStatsHistColormapVAT(r7), this.rasterInfo = r7;
    const { contrastOffset: o11, brightnessOffset: e11 } = this.functionArguments;
    return this.lookup = l2(o11, e11), { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    var _a;
    const s11 = (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
    return null == s11 ? null : f2(s11, { lut: s11.pixels.map(() => this.lookup), offset: 0, outputPixelType: "u8" });
  }
  _getWebGLParameters() {
    const { contrastOffset: t6, brightnessOffset: s11 } = this.functionArguments;
    return { contrastOffset: t6, brightnessOffset: s11 };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], u10.prototype, "functionName", void 0), e([y({ type: i12, json: { write: true, name: "rasterFunctionArguments" } })], u10.prototype, "functionArguments", void 0), e([y()], u10.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], u10.prototype, "lookup", void 0), u10 = e([a2("esri.layers.support.rasterFunctions.ContrastBrightnessFunction")], u10);
var p13 = u10;

// node_modules/@arcgis/core/layers/support/rasterFunctions/mirror.js
function o8(o11, t6, f7, r7, l16) {
  const e11 = Math.floor(r7 / 2);
  for (let c29 = 0; c29 < e11; c29++)
    for (let r8 = 0; r8 < t6; r8++)
      o11[c29 * t6 + r8] = o11[(l16 - 1 - c29) * t6 + r8], o11[(f7 - 1 - c29) * t6 + r8] = o11[(f7 - l16 + c29) * t6 + r8];
  const n19 = Math.floor(l16 / 2);
  for (let c29 = 0; c29 < f7; c29++) {
    const f8 = c29 * t6;
    for (let r8 = 0; r8 < n19; r8++)
      o11[f8 + r8] = o11[f8 + l16 - 1 - r8], o11[f8 + t6 - r8 - 1] = o11[f8 + t6 + r8 - l16];
  }
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/convolutionUtils.js
var l8 = /* @__PURE__ */ new Map();
function o9(e11) {
  const t6 = Math.sqrt(e11.length), n19 = e11.slice(0, t6), l16 = [1];
  for (let o11 = 1; o11 < t6; o11++) {
    let n20 = null;
    for (let l17 = 0; l17 < t6; l17++) {
      const r7 = e11[l17 + o11 * t6], s11 = e11[l17];
      if (null == n20)
        if (0 === s11) {
          if (r7)
            return { separable: false, row: null, col: null };
        } else
          n20 = r7 / s11;
      else if (r7 / s11 !== n20)
        return { separable: false, row: null, col: null };
    }
    if (null == n20)
      return { separable: false, row: null, col: null };
    l16.push(n20);
  }
  return { separable: true, row: n19, col: l16 };
}
function r4(e11, t6, n19, l16, o11, r7, s11) {
  const i28 = new Float32Array(t6 * n19), a30 = r7.length, h6 = s11 ? 0 : l16, c29 = s11 ? l16 : 0, p23 = s11 ? 1 : t6;
  for (let u18 = h6; u18 < n19 - h6; u18++) {
    const n20 = u18 * t6;
    for (let s12 = c29; s12 < t6 - c29; s12++) {
      if (o11 && !o11[n20 + s12])
        continue;
      let t7 = 0;
      for (let o12 = 0; o12 < a30; o12++)
        t7 += e11[n20 + s12 + (o12 - l16) * p23] * r7[o12];
      i28[n20 + s12] = t7;
    }
  }
  return i28;
}
function s8(e11, t6, n19, l16, o11, r7, s11) {
  const i28 = new Float32Array(t6 * n19), a30 = Math.floor(l16 / 2), h6 = Math.floor(o11 / 2);
  for (let c29 = a30; c29 < n19 - a30; c29++) {
    const n20 = c29 * t6;
    for (let c30 = h6; c30 < t6 - h6; c30++) {
      if (r7 && !r7[n20 + c30])
        continue;
      let p23 = 0;
      for (let r8 = 0; r8 < l16; r8++)
        for (let l17 = 0; l17 < o11; l17++)
          p23 += e11[n20 + c30 + (r8 - a30) * t6 + l17 - h6] * s11[r8 * o11 + l17];
      i28[n20 + c30] = p23;
    }
  }
  return i28;
}
function i13(t6, l16, o11 = true) {
  const { pixels: r7, width: i28, height: a30, pixelType: h6, mask: c29 } = t6, p23 = r7.length, u18 = [], { kernel: f7, rows: g6, cols: m10 } = l16;
  for (let e11 = 0; e11 < p23; e11++) {
    const t7 = s8(r7[e11], i28, a30, g6, m10, c29, f7);
    o11 && o8(t7, i28, a30, g6, m10), u18.push(t7);
  }
  return new g({ width: i28, height: a30, pixelType: h6, pixels: u18, mask: c29 });
}
function a16(t6, l16, o11, s11 = true) {
  const { pixels: i28, width: a30, height: h6, pixelType: c29, mask: p23 } = t6, u18 = i28.length, f7 = [], g6 = l16.length, m10 = o11.length, x5 = Math.floor(g6 / 2), w7 = Math.floor(m10 / 2);
  for (let e11 = 0; e11 < u18; e11++) {
    let t7 = r4(i28[e11], a30, h6, x5, p23, l16, true);
    t7 = r4(t7, a30, h6, w7, p23, o11, false), s11 && o8(t7, a30, h6, g6, m10), f7.push(t7);
  }
  return new g({ width: a30, height: h6, pixelType: c29, pixels: f7, mask: p23 });
}
function h5(e11, t6) {
  const n19 = o9(t6.kernel), l16 = false !== t6.mirrorEdges, r7 = n19.separable ? a16(e11, n19.row, n19.col, l16) : i13(e11, t6, l16), { outputPixelType: s11 } = t6;
  return s11 && r7.clamp(s11), r7;
}
l8.set(l3.none, [0, 0, 0, 0, 1, 0, 0, 0, 0]), l8.set(l3.lineDetectionHorizontal, [-1, -1, -1, 2, 2, 2, -1, -1, -1]), l8.set(l3.lineDetectionVertical, [-1, 2, -1, -1, 2, -1, -1, 2, -1]), l8.set(l3.lineDetectionLeftDiagonal, [2, -1, -1, -1, 2, -1, -1, -1, 2]), l8.set(l3.lineDetectionRightDiagonal, [-1, -1, 2, -1, 2, -1, 2, -1, -1]), l8.set(l3.gradientNorth, [-1, -2, -1, 0, 0, 0, 1, 2, 1]), l8.set(l3.gradientWest, [-1, 0, 1, -2, 0, 2, -1, 0, 1]), l8.set(l3.gradientEast, [1, 0, -1, 2, 0, -2, 1, 0, -1]), l8.set(l3.gradientSouth, [1, 2, 1, 0, 0, 0, -1, -2, -1]), l8.set(l3.gradientNorthEast, [0, -1, -2, 1, 0, -1, 2, 1, 0]), l8.set(l3.gradientNorthWest, [-2, -1, 0, -1, 0, 1, 0, 1, 2]), l8.set(l3.smoothArithmeticMean, [0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111]), l8.set(l3.smoothing3x3, [0.0625, 0.125, 0.0625, 0.125, 0.25, 0.125, 0.0625, 0.125, 0.0625]), l8.set(l3.smoothing5x5, [1, 1, 1, 1, 1, 1, 4, 4, 4, 1, 1, 4, 12, 4, 1, 1, 4, 4, 4, 1, 1, 1, 1, 1, 1]), l8.set(l3.sharpening3x3, [-1, -1, -1, -1, 9, -1, -1, -1, -1]), l8.set(l3.sharpening5x5, [-1, -3, -4, -3, -1, -3, 0, 6, 0, -3, -4, 6, 21, 6, -4, -3, 0, 6, 0, -3, -1, -3, -4, -3, -1]), l8.set(l3.laplacian3x3, [0, -1, 0, -1, 4, -1, 0, -1, 0]), l8.set(l3.laplacian5x5, [0, 0, -1, 0, 0, 0, -1, -2, -1, 0, -1, -2, 17, -2, -1, 0, -1, -2, -1, 0, 0, 0, -1, 0, 0]), l8.set(l3.sobelHorizontal, [-1, -2, -1, 0, 0, 0, 1, 2, 1]), l8.set(l3.sobelVertical, [-1, 0, 1, -2, 0, 2, -1, 0, 1]), l8.set(l3.sharpen, [0, -0.25, 0, -0.25, 2, -0.25, 0, -0.25, 0]), l8.set(l3.sharpen2, [-0.25, -0.25, -0.25, -0.25, 3, -0.25, -0.25, -0.25, -0.25]), l8.set(l3.pointSpread, [-0.627, 0.352, -0.627, 0.352, 2.923, 0.352, -0.627, 0.352, -0.627]);

// node_modules/@arcgis/core/layers/support/rasterFunctions/ConvolutionFunctionArguments.js
var p14;
var c10 = p14 = class extends p4 {
  constructor() {
    super(...arguments), this.rows = 3, this.cols = 3, this.kernel = [0, 0, 0, 0, 1, 0, 0, 0, 0];
  }
  set convolutionType(o11) {
    this._set("convolutionType", o11);
    const t6 = l8.get(o11);
    if (!t6 || o11 === l3.userDefined || o11 === l3.none)
      return;
    const s11 = Math.sqrt(t6.length);
    this._set("kernel", t6), this._set("cols", s11), this._set("rows", s11);
  }
  clone() {
    return new p14({ cols: this.cols, rows: this.rows, kernel: [...this.kernel], convolutionType: this.convolutionType, raster: a(this.raster) });
  }
};
e([y({ json: { type: Number, write: true } })], c10.prototype, "rows", void 0), e([y({ json: { type: Number, write: true } })], c10.prototype, "cols", void 0), e([y({ json: { name: "type", type: Number, write: true } })], c10.prototype, "convolutionType", null), e([y({ json: { type: [Number], write: true } })], c10.prototype, "kernel", void 0), c10 = p14 = e([a2("esri.layers.support.rasterFunctions.ConvolutionFunctionArguments")], c10);
var l9 = c10;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ConvolutionFunction.js
var c11 = 25;
var l10 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Convolution", this.rasterArgumentNames = ["raster"];
  }
  get _normalizedKernel() {
    const { kernel: t6, convolutionType: e11 } = this.functionArguments, o11 = t6.reduce((t7, e12) => t7 + e12);
    return -1 === e11 || 0 === o11 || 1 === o11 ? t6 : t6.map((t7) => t7 / o11);
  }
  _bindSourceRasters() {
    const { convolutionType: t6, rows: e11, cols: o11, kernel: n19 } = this.functionArguments;
    if (!Object.values(l3).includes(t6))
      return { success: false, supportsGPU: false, error: `convolution-function: the specified kernel type is not supported ${t6}` };
    if (t6 !== l3.none && e11 * o11 !== n19.length)
      return { success: false, supportsGPU: false, error: "convolution-function: the specified rows and cols do not match the length of the kernel" };
    const r7 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType(r7.pixelType);
    const i28 = r7.clone();
    i28.pixelType = this.outputPixelType;
    const u18 = [l3.none, l3.sharpen, l3.sharpen2, l3.sharpening3x3, l3.sharpening5x5];
    (-1 === t6 || "u8" !== this.outputPixelType && !u18.includes(t6)) && (i28.statistics = null, i28.histograms = null), i28.colormap = null, i28.attributeTable = null, this.rasterInfo = i28;
    return { success: true, supportsGPU: n19.length <= c11 };
  }
  _processPixels(t6) {
    var _a;
    const e11 = (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
    if (null == e11 || this.functionArguments.convolutionType === l3.none)
      return e11;
    const { rows: o11, cols: n19 } = this.functionArguments, { _normalizedKernel: r7 } = this;
    return h5(e11, { kernel: r7, rows: o11, cols: n19, outputPixelType: this.outputPixelType });
  }
  _getWebGLParameters() {
    const t6 = new Float32Array(c11);
    return t6.set(this._normalizedKernel), { kernelRows: this.functionArguments.rows, kernelCols: this.functionArguments.cols, kernel: t6, clampRange: s3(this.outputPixelType) };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], l10.prototype, "functionName", void 0), e([y({ type: l9, json: { write: true, name: "rasterFunctionArguments" } })], l10.prototype, "functionArguments", void 0), e([y()], l10.prototype, "rasterArgumentNames", void 0), e([y()], l10.prototype, "_normalizedKernel", null), l10 = e([a2("esri.layers.support.rasterFunctions.ConvolutionFunction")], l10);
var p15 = l10;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CurvatureFunctionArguments.js
var c12;
var u11 = new n({ 0: "standard", 1: "platform", 2: "profile" }, { useNumericKeys: true });
var i14 = c12 = class extends p4 {
  constructor() {
    super(...arguments), this.curvatureType = "standard", this.zFactor = 1;
  }
  readCurvatureType(r7, e11) {
    return u11.fromJSON(e11.type ?? e11.curvatureType ?? 0);
  }
  clone() {
    return new c12({ curvatureType: this.curvatureType, zFactor: this.zFactor, raster: this.raster });
  }
};
e([y({ json: { write: { target: "type" } } }), o2(u11)], i14.prototype, "curvatureType", void 0), e([o("curvatureType", ["type", "curvatureType"])], i14.prototype, "readCurvatureType", null), e([y({ type: Number, json: { write: true } })], i14.prototype, "zFactor", void 0), i14 = c12 = e([a2("esri.layers.support.rasterFunctions.CurvatureFunctionArguments")], i14);
var n10 = i14;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CurvatureFunction.js
var u12 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Curvature", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    var _a;
    this.outputPixelType = this._getOutputPixelType("f32");
    const t6 = this.sourceRasterInfos[0].clone();
    return t6.pixelType = this.outputPixelType, t6.bandCount = 1, this._removeStatsHistColormapVAT(t6), this.rasterInfo = t6, this.isGCS = ((_a = t6.spatialReference) == null ? void 0 : _a.isGeographic) ?? false, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    var _a;
    const r7 = (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
    if (null == r7)
      return null;
    const { zFactor: e11, curvatureType: s11 } = this.functionArguments, { extent: o11, primaryPixelSizes: u18 } = t6, c29 = u18 == null ? void 0 : u18[0], a30 = c29 ?? (o11 ? { x: o11.width / r7.width, y: o11.height / r7.height } : { x: 1, y: 1 }), p23 = this.isGCS && e11 >= 1 ? e11 * n4 : e11;
    return f3(r7, { zFactor: p23, curvatureType: s11, resolution: a30 });
  }
  _getWebGLParameters() {
    const { zFactor: t6, curvatureType: r7 } = this.functionArguments;
    return { curvatureType: r7, zFactor: this.isGCS && t6 >= 1 ? t6 * n4 : t6 };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], u12.prototype, "functionName", void 0), e([y({ type: n10, json: { write: true, name: "rasterFunctionArguments" } })], u12.prototype, "functionArguments", void 0), e([y()], u12.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], u12.prototype, "isGCS", void 0), u12 = e([a2("esri.layers.support.rasterFunctions.CurvatureFunction")], u12);
var c13 = u12;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ExtractBandFunctionArguments.js
var a17;
var i15 = a17 = class extends p4 {
  constructor() {
    super(...arguments), this.bandIds = [], this.bandNames = [], this.bandWavelengths = [], this.missingBandAction = l.bestMatch;
  }
  clone() {
    var _a, _b, _c;
    return new a17({ bandIds: (_a = this.bandIds) == null ? void 0 : _a.slice(), bandNames: (_b = this.bandNames) == null ? void 0 : _b.slice(), bandWavelengths: (_c = this.bandWavelengths) == null ? void 0 : _c.slice(), missingBandAction: this.missingBandAction, method: this.method, wavelengthMatchTolerance: this.wavelengthMatchTolerance });
  }
};
e([y({ json: { write: true } })], i15.prototype, "bandIds", void 0), e([y({ json: { write: true } })], i15.prototype, "bandNames", void 0), e([y({ json: { write: true } })], i15.prototype, "bandWavelengths", void 0), e([o2({ 0: "name", 1: "wavelength", 2: "id" })], i15.prototype, "method", void 0), e([y({ json: { write: true } })], i15.prototype, "missingBandAction", void 0), e([y({ json: { write: true } })], i15.prototype, "wavelengthMatchTolerance", void 0), i15 = a17 = e([a2("esri.layers.support.rasterFunctions.ExtractBandFunctionArguments")], i15);
var c14 = i15;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ExtractBandFunction.js
var i16 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "ExtractBand", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    var _a;
    const { functionArguments: t6, sourceRasterInfos: n19 } = this, e11 = n19[0], { method: s11, bandNames: r7, bandWavelengths: o11, bandIds: i28, missingBandAction: l16 } = t6, h6 = (r7 == null ? void 0 : r7.length) && ("name" === s11 || "id" !== s11 && !(i28 == null ? void 0 : i28.length)), m10 = (o11 == null ? void 0 : o11.length) && ("wavelength" === s11 || "id" !== s11 && !(i28 == null ? void 0 : i28.length)), p23 = l16 === l.fail, g6 = h6 ? u13(e11, r7) : m10 ? d5(e11, o11, this.functionArguments, p23) : c15(e11, i28, p23);
    if (null == g6) {
      return { success: false, supportsGPU: false, error: `extract-band-function: Invalid ${h6 ? "band names" : m10 ? "band wavelengths" : "band ids"} for the imagery data source` };
    }
    this.functionArguments.bandIds = g6, this.functionArguments.method = "id", this.outputPixelType = this._getOutputPixelType("f32");
    const f7 = e11.clone();
    f7.pixelType = this.outputPixelType, f7.bandCount = g6.length;
    const { statistics: b3, histograms: x5 } = f7;
    null != b3 && b3.length && (f7.statistics = g6.map((t7) => b3[t7] || b3[b3.length - 1])), null != x5 && x5.length && (f7.histograms = g6.map((t7) => x5[t7] || x5[x5.length - 1]));
    let I2 = (_a = f7.keyProperties) == null ? void 0 : _a.BandProperties;
    (I2 == null ? void 0 : I2.length) && (I2 = g6.map((t7) => t7 >= I2.length ? I2[I2.length - 1] : I2[t7]), f7.keyProperties = { ...f7.keyProperties, BandProperties: I2 }), this.rasterInfo = f7;
    return { success: true, supportsGPU: f7.bandCount <= 3 };
  }
  _processPixels(t6) {
    var _a;
    const n19 = (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
    if (null == n19)
      return null;
    const e11 = n19.pixels.length, s11 = this.functionArguments.bandIds.map((t7) => t7 >= e11 ? e11 - 1 : t7);
    return n19.extractBands(s11);
  }
  _getWebGLParameters() {
    let t6;
    if (this.isInputBandIdsSwizzled)
      t6 = this.swizzledBandSelection.length ? this.swizzledBandSelection : [0, 1, 2];
    else {
      t6 = [...this.functionArguments.bandIds], 0 === t6.length ? t6 = [0, 1, 2] : t6.length < 3 && (t6[1] = t6[1] ?? t6[0], t6[2] = t6[2] ?? t6[1]);
      for (let n19 = 0; n19 < 3; n19++)
        t6[n19] = Math.min(t6[n19], 2);
    }
    return { bandIndexMat3: i5(t6) };
  }
  _getInputBandIds(t6) {
    const n19 = t6.length;
    return this.functionArguments.bandIds.map((t7) => t7 >= n19 ? n19 - 1 : t7).map((n20) => t6[n20]);
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], i16.prototype, "functionName", void 0), e([y({ type: c14, json: { write: true, name: "rasterFunctionArguments" } })], i16.prototype, "functionArguments", void 0), e([y()], i16.prototype, "rasterArgumentNames", void 0), i16 = e([a2("esri.layers.support.rasterFunctions.ExtractBandFunction")], i16);
var l11 = i16;
function u13(t6, n19) {
  const e11 = t6.bandInfos.map(({ name: t7 }) => t7.toLowerCase()), s11 = [];
  for (let r7 = 0; r7 < n19.length; r7++) {
    const t7 = n19[r7].toLowerCase();
    let o11 = e11.indexOf(t7);
    if (-1 === o11 && "nearinfrared" === t7 && (o11 = e11.findIndex((t8) => t8.startsWith("nearinfrared_1")), -1 === o11 && (o11 = e11.findIndex((t8) => t8.startsWith("nearinfrared")))), -1 === o11)
      return null;
    s11.push(o11);
  }
  return s11;
}
function c15(t6, n19, e11) {
  const { bandCount: s11 } = t6;
  return !(n19 == null ? void 0 : n19.length) || e11 && n19.some((t7) => t7 < 0 || t7 >= s11) ? null : n19;
}
function d5(t6, n19, { wavelengthMatchTolerance: e11 }, s11) {
  const { bandInfos: r7 } = t6, o11 = [];
  for (let i28 = 0; i28 < r7.length; i28++) {
    const { minWavelength: t7, maxWavelength: n20 } = r7[i28];
    if (!t7 || !n20)
      return null;
    o11.push({ minWavelength: t7, maxWavelength: n20 });
  }
  const a30 = [];
  for (let i28 = 0; i28 < n19.length; i28++) {
    const t7 = n19[i28];
    let r8 = false, l16 = -1, u18 = Number.MAX_VALUE;
    for (let n20 = 0; n20 < o11.length; n20++) {
      const e12 = o11[n20], s12 = t7 >= e12.minWavelength && t7 <= e12.maxWavelength, a31 = Math.abs(t7 - (e12.minWavelength + e12.maxWavelength) / 2);
      s12 ? a31 < u18 && (r8 = true, l16 = n20, u18 = a31) : !r8 && a31 < u18 && (l16 = n20, u18 = a31);
    }
    if (!r8 && e11 && u18 < e11 && (r8 = true), !r8 && s11)
      return null;
    a30.push(l16);
  }
  return a30;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/conversionUtils.js
function i17(i28, s11, a30) {
  const { pixels: l16, width: n19, height: r7, mask: o11, bandMasks: h6 } = i28, p23 = n19 * r7, m10 = (h6 == null ? void 0 : h6.length) ? g.combineBandMasks(h6) : o11, f7 = Math.min(s11.length, l16.length), c29 = a30.startsWith("f"), d7 = !c29 && a30 !== i28.pixelType, [x5, g6] = s3(a30), k4 = g.createEmptyBand(a30, p23);
  for (let t6 = 0; t6 < r7; t6++) {
    let e11 = t6 * n19;
    for (let t7 = 0; t7 < n19; t7++, e11++)
      if (!m10 || m10[e11]) {
        let t8 = 0;
        for (let i29 = 0; i29 < f7; i29++)
          t8 += s11[i29] * l16[i29][e11];
        c29 || (t8 = Math.round(t8), d7 && (t8 = t8 > g6 ? g6 : t8 < x5 ? x5 : t8)), k4[e11] = t8;
      }
  }
  const u18 = new g({ width: n19, height: r7, pixels: [k4], pixelType: a30, mask: m10 });
  return u18.updateStatistics(), u18;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/GrayscaleFunctionArguments.js
var t4;
var a18 = t4 = class extends p4 {
  clone() {
    return new t4({ conversionParameters: [...this.conversionParameters], raster: this.raster });
  }
};
e([y({ type: [Number], json: { write: true } })], a18.prototype, "conversionParameters", void 0), a18 = t4 = e([a2("esri.layers.support.rasterFunctions.GrayscaleFunctionArguments")], a18);
var c16 = a18;

// node_modules/@arcgis/core/layers/support/rasterFunctions/GrayscaleFunction.js
var i18 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Grayscale", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  get _normalizedWeights() {
    const { conversionParameters: t6 } = this.functionArguments, e11 = t6.reduce((t7, e12) => t7 + e12);
    return t6.map((t7) => t7 / e11);
  }
  _bindSourceRasters() {
    const { conversionParameters: t6 } = this.functionArguments;
    if (!(t6 == null ? void 0 : t6.length))
      return { success: false, supportsGPU: false, error: "missing valid conversion parameters." };
    const e11 = this.sourceRasterInfos[0].clone();
    this.outputPixelType = this._getOutputPixelType(e11.pixelType), e11.pixelType = this.outputPixelType;
    const s11 = 3 === t6.length || 3 === e11.bandCount && t6.length > 3;
    return e11.bandCount = 1, this._removeStatsHistColormapVAT(e11), this.rasterInfo = e11, { success: true, supportsGPU: s11 };
  }
  _processPixels(t6) {
    var _a;
    const e11 = (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
    return null == e11 ? null : i17(e11, this._normalizedWeights, this.outputPixelType);
  }
  _getWebGLParameters() {
    return { weights: this._normalizedWeights };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], i18.prototype, "functionName", void 0), e([y({ type: c16, json: { write: true, name: "rasterFunctionArguments" } })], i18.prototype, "functionArguments", void 0), e([y()], i18.prototype, "rasterArgumentNames", void 0), e([y()], i18.prototype, "_normalizedWeights", null), i18 = e([a2("esri.layers.support.rasterFunctions.GrayscaleFunction")], i18);
var u14 = i18;

// node_modules/@arcgis/core/layers/support/rasterFunctions/LocalFunctionArguments.js
var i19;
var a19 = i19 = class extends p4 {
  constructor() {
    super(...arguments), this.rasters = [], this.processAsMultiband = true;
  }
  writeRasters(r7, s11) {
    s11.rasters = r7.map((r8) => "number" == typeof r8 || "string" == typeof r8 ? r8 : r8.toJSON());
  }
  clone() {
    return new i19({ operation: this.operation, processAsMultiband: this.processAsMultiband, rasters: a(this.rasters) });
  }
};
e([y({ json: { write: true } })], a19.prototype, "operation", void 0), e([y({ json: { write: true } })], a19.prototype, "rasters", void 0), e([r("rasters")], a19.prototype, "writeRasters", null), e([y({ json: { write: true } })], a19.prototype, "processAsMultiband", void 0), a19 = i19 = e([a2("esri.layers.support.rasterFunctions.LocalFunctionArguments")], a19);
var c17 = a19;

// node_modules/@arcgis/core/layers/support/rasterFunctions/LocalFunction.js
var m6 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Local", this.functionArguments = null, this.rasterArgumentNames = ["rasters"];
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t6 } = this, s11 = t6[0], { bandCount: e11 } = s11, { processAsMultiband: o11 } = this.functionArguments;
    if (t6.some((t7) => t7.bandCount !== e11))
      return { success: false, supportsGPU: false, error: "local-function: input rasters do not have same band count" };
    const { operation: n19, rasters: r7 } = this.functionArguments, i28 = c3[n19];
    if (!(999 === i28 || r7.length === i28 || r7.length <= 1 && 1 === i28))
      return { success: false, supportsGPU: false, error: `local-function: the length of functionArguments.rasters does not match operation's requirement: ${i28}` };
    const a30 = s11.clone();
    a30.bandCount = 999 !== i28 || o11 ? e11 : 1, this._removeStatsHistColormapVAT(a30), this._updateStatistics(a30), this._updatePixelType(a30), this.rasterInfo = a30;
    return { success: true, supportsGPU: 1 === a30.bandCount && i28 <= 3 && (n19 < 11 || n19 > 16) };
  }
  _processPixels(t6) {
    const { pixelBlocks: s11 } = t6;
    return null == s11 || s11.some((t7) => null == t7) ? null : pt(s11, this.functionArguments.operation, { processAsMultiband: this.functionArguments.processAsMultiband, outputPixelType: this.outputPixelType ?? void 0 });
  }
  _getWebGLParameters() {
    var _a;
    const { operation: t6 } = this.functionArguments, s11 = c3[t6], e11 = ((_a = Object.keys(B2).find((s12) => B2[s12] === t6)) == null ? void 0 : _a.toLowerCase()) ?? "undefined", r7 = this.outputPixelType ?? "f32";
    let [a30, u18] = s3(r7);
    const p23 = i(r7);
    return p23 && (a30 -= 1e-4, u18 += 1e-4), { imageCount: s11, operationName: e11, domainRange: [a30, u18], isOutputRounded: p23 };
  }
  _updateStatistics(t6) {
    var _a, _b;
    const s11 = this.sourceRasterInfos[0], { operation: e11 } = this.functionArguments, o11 = (_a = l4(e11)) == null ? void 0 : _a.domain;
    if (o11) {
      t6.statistics = [];
      for (let s12 = 0; s12 < t6.bandCount; s12++)
        t6.statistics[s12] = { min: o11[0], max: o11[1], avg: (o11[0] + o11[1]) / 2, stddev: (o11[0] + o11[1]) / 10 };
    } else
      45 === e11 && ((_b = s11.statistics) == null ? void 0 : _b.length) && (t6.statistics = s11.statistics.map((t7) => ({ min: -t7.max, max: -t7.min, avg: null != t7.avg ? -t7.avg : void 0, stddev: null != t7.stddev ? -t7.stddev : void 0 })));
  }
  _updatePixelType(t6) {
    const { statistics: s11, pixelType: e11 } = this.sourceRasterInfos[0], { operation: o11 } = this.functionArguments, { domain: i28, isInteger: a30 } = l4(o11) ?? { domain: null, isInteger: false };
    let u18 = "f32";
    if (i28 && a30)
      u18 = u(i28[0], i28[1]);
    else if (30 === o11) {
      const t7 = s11 == null ? void 0 : s11[0];
      u18 = t7 ? u(t7.min, t7.max) : i(e11) ? e11 : "s32";
    } else if (45 === o11 && i(e11)) {
      const t7 = s11 == null ? void 0 : s11.map(({ max: t8 }) => -t8), o12 = s11 == null ? void 0 : s11.map(({ min: t8 }) => -t8), n19 = (t7 == null ? void 0 : t7.length) ? Math.min(...t7) : null, i29 = (o12 == null ? void 0 : o12.length) ? Math.min(...o12) : null;
      u18 = null != n19 && null != i29 ? u(n19, i29) : e11.startsWith("s") ? e11.replace("s", "u") : "u1" === e11 || "u2" === e11 || "u4" === e11 ? "s8" : "u8" === e11 ? "s16" : "s32";
    }
    t6.pixelType = this.outputPixelType = this._getOutputPixelType(u18);
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], m6.prototype, "functionName", void 0), e([y({ type: c17, json: { write: true, name: "rasterFunctionArguments" } })], m6.prototype, "functionArguments", void 0), e([y()], m6.prototype, "rasterArgumentNames", void 0), m6 = e([a2("esri.layers.support.rasterFunctions.LocalFunction")], m6);
var d6 = m6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/MaskFunctionArguments.js
var s9;
var a20 = s9 = class extends p4 {
  constructor() {
    super(...arguments), this.includedRanges = null, this.noDataValues = null, this.noDataInterpretation = n3.matchAny;
  }
  get normalizedNoDataValues() {
    const { noDataValues: t6 } = this;
    if (!(t6 == null ? void 0 : t6.length))
      return null;
    let e11 = false;
    const r7 = t6.map((t7) => {
      if ("number" == typeof t7)
        return e11 = true, [t7];
      if ("string" == typeof t7) {
        const r8 = t7.trim().split(" ").filter((t8) => "" !== t8.trim()).map((t8) => Number(t8));
        return e11 = e11 || r8.length > 0, 0 === r8.length ? null : r8;
      }
      return null;
    });
    return e11 ? r7 : null;
  }
  clone() {
    var _a, _b;
    return new s9({ includedRanges: ((_a = this.includedRanges) == null ? void 0 : _a.slice()) ?? [], noDataValues: ((_b = this.noDataValues) == null ? void 0 : _b.slice()) ?? [], noDataInterpretation: this.noDataInterpretation });
  }
};
e([y({ json: { write: true } })], a20.prototype, "includedRanges", void 0), e([y({ json: { write: true } })], a20.prototype, "noDataValues", void 0), e([y()], a20.prototype, "normalizedNoDataValues", null), e([y({ json: { write: true } })], a20.prototype, "noDataInterpretation", void 0), a20 = s9 = e([a2("esri.layers.support.rasterFunctions.MaskFunctionArguments")], a20);
var i20 = a20;

// node_modules/@arcgis/core/layers/support/rasterFunctions/MaskFunction.js
var c18 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Mask", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0].clone(), { pixelType: e11 } = t6;
    this.outputPixelType = this._getOutputPixelType(e11), t6.pixelType = this.outputPixelType, this.rasterInfo = t6;
    const { includedRanges: s11, normalizedNoDataValues: o11 } = this.functionArguments;
    if (!(s11 == null ? void 0 : s11.length) && !(o11 == null ? void 0 : o11.length))
      return { success: false, supportsGPU: false, error: "missing includedRanges or noDataValues argument" };
    let r7 = [];
    for (let a30 = 0; a30 < t6.bandCount; a30++) {
      const t7 = w2(e11, s11 == null ? void 0 : s11.slice(2 * a30, 2 * a30 + 2), o11 == null ? void 0 : o11[a30]);
      if (null == t7) {
        r7 = null;
        break;
      }
      r7.push(t7);
    }
    this.lookups = r7;
    const n19 = null != o11 && o11.every((t7) => {
      var _a;
      return (t7 == null ? void 0 : t7.length) === ((_a = o11[0]) == null ? void 0 : _a.length);
    });
    return { success: true, supportsGPU: (!s11 || s11.length <= 2 * i2) && (!o11 || n19 && o11[0].length <= i2) };
  }
  _processPixels(t6) {
    var _a;
    const e11 = (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
    if (null == e11)
      return null;
    const { outputPixelType: s11, lookups: o11 } = this, { includedRanges: r7, noDataInterpretation: n19, normalizedNoDataValues: u18 } = this.functionArguments, a30 = n19 === n3.matchAll;
    return g2(e11, { includedRanges: r7, noDataValues: u18, outputPixelType: s11, matchAll: a30, lookups: o11 });
  }
  _getWebGLParameters() {
    var _a;
    const { includedRanges: t6, normalizedNoDataValues: s11 } = this.functionArguments, o11 = new Float32Array(i2);
    o11.fill(j), ((_a = s11 == null ? void 0 : s11[0]) == null ? void 0 : _a.length) && o11.set(s11[0]);
    const r7 = new Float32Array(i2);
    for (let n19 = 0; n19 < r7.length; n19 += 2)
      r7[n19] = (t6 == null ? void 0 : t6[n19]) ?? -j, r7[n19 + 1] = (t6 == null ? void 0 : t6[n19 + 1]) ?? j;
    return t6 && t6.length && r7.set(t6), { bandCount: this.sourceRasterInfos[0].bandCount, noDataValues: o11, includedRanges: r7 };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], c18.prototype, "functionName", void 0), e([y({ type: i20, json: { write: true, name: "rasterFunctionArguments" } })], c18.prototype, "functionArguments", void 0), e([y()], c18.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], c18.prototype, "lookups", void 0), c18 = e([a2("esri.layers.support.rasterFunctions.MaskFunction")], c18);
var p16 = c18;

// node_modules/@arcgis/core/layers/support/rasterFunctions/NDVIFunctionArguments.js
var i21;
var e8 = i21 = class extends p4 {
  constructor() {
    super(...arguments), this.visibleBandID = 0, this.infraredBandID = 1, this.scientificOutput = false;
  }
  clone() {
    const { visibleBandID: r7, infraredBandID: t6, scientificOutput: s11 } = this;
    return new i21({ visibleBandID: r7, infraredBandID: t6, scientificOutput: s11 });
  }
};
e([y({ json: { write: true } })], e8.prototype, "visibleBandID", void 0), e([y({ json: { write: true } })], e8.prototype, "infraredBandID", void 0), e([y({ json: { write: true } })], e8.prototype, "scientificOutput", void 0), e8 = i21 = e([a2("esri.layers.support.rasterFunctions.NDVIFunctionArguments")], e8);
var n11 = e8;

// node_modules/@arcgis/core/layers/support/rasterFunctions/NDVIFunction.js
var u15 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "NDVI", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { scientificOutput: t6, visibleBandID: s11, infraredBandID: r7 } = this.functionArguments;
    this.outputPixelType = this._getOutputPixelType(t6 ? "f32" : "u8");
    const e11 = this.sourceRasterInfos[0], n19 = Math.max(s11, r7);
    if (e11.bandCount < 2 || n19 >= e11.bandCount)
      return { success: false, supportsGPU: false, error: "ndvi-function: source raster has insufficient amount of raster bands" };
    const o11 = e11.clone();
    o11.pixelType = this.outputPixelType, o11.colormap = null, o11.histograms = null, o11.bandCount = 1, o11.keyProperties = { ...o11.keyProperties, BandProperties: void 0 };
    const [i28, u18, a30, c29] = t6 ? [-1, 1, 0, 0.1] : [0, 200, 100, 10];
    return o11.statistics = [{ min: i28, max: u18, avg: a30, stddev: c29 }], this.rasterInfo = o11, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    var _a;
    const s11 = (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s11)
      return null;
    const { visibleBandID: r7, infraredBandID: n19, scientificOutput: o11 } = this.functionArguments;
    return s6(s11, r7, n19, !o11);
  }
  _getWebGLParameters() {
    const { visibleBandID: t6, infraredBandID: s11, scientificOutput: r7 } = this.functionArguments, e11 = this.isInputBandIdsSwizzled ? [0, 1, 2] : [s11, t6, 0];
    return { bandIndexMat3: i5(e11), scaled: !r7 };
  }
  _getInputBandIds(t6) {
    const { visibleBandID: s11, infraredBandID: r7 } = this.functionArguments;
    return [r7, s11, 0].map((s12) => t6[s12]);
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], u15.prototype, "functionName", void 0), e([y({ type: n11, json: { write: true, name: "rasterFunctionArguments" } })], u15.prototype, "functionArguments", void 0), e([y()], u15.prototype, "rasterArgumentNames", void 0), u15 = e([a2("esri.layers.support.rasterFunctions.NDVIFunction")], u15);
var a21 = u15;

// node_modules/@arcgis/core/layers/support/rasterFunctions/RemapFunctionArguments.js
var n12;
var a22 = n12 = class extends p4 {
  constructor() {
    super(...arguments), this.inputRanges = null, this.outputValues = null, this.noDataRanges = null, this.allowUnmatched = false, this.isLastInputRangeInclusive = false;
  }
  clone() {
    return new n12({ inputRanges: [...this.inputRanges], outputValues: [...this.outputValues], noDataRanges: [...this.noDataRanges], allowUnmatched: this.allowUnmatched, isLastInputRangeInclusive: this.isLastInputRangeInclusive });
  }
};
e([y({ json: { write: true } })], a22.prototype, "inputRanges", void 0), e([y({ json: { write: true } })], a22.prototype, "outputValues", void 0), e([y({ json: { write: true } })], a22.prototype, "noDataRanges", void 0), e([y({ json: { write: true } })], a22.prototype, "allowUnmatched", void 0), e([y({ json: { write: true } })], a22.prototype, "isLastInputRangeInclusive", void 0), a22 = n12 = e([a2("esri.layers.support.rasterFunctions.RemapFunctionArguments")], a22);
var r5 = a22;

// node_modules/@arcgis/core/layers/support/rasterFunctions/RemapFunction.js
var m7 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Remap", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null;
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0].clone(), { pixelType: e11 } = t6;
    this.outputPixelType = this._getOutputPixelType(e11), t6.pixelType = this.outputPixelType, t6.colormap = null, t6.histograms = null, t6.bandCount = 1, t6.attributeTable = null;
    const { statistics: s11 } = t6, { allowUnmatched: n19, outputValues: o11, inputRanges: a30, noDataRanges: i28, isLastInputRangeInclusive: l16 } = this.functionArguments;
    if (null != s11 && s11.length && (o11 == null ? void 0 : o11.length))
      if (n19) {
        const e12 = Math.min.apply(null, [...o11, s11[0].min]), n20 = Math.max.apply(null, [...o11, s11[0].max]);
        t6.statistics = [{ ...s11[0], min: e12, max: n20 }];
      } else {
        let e12 = o11[0], n20 = e12;
        for (let t7 = 0; t7 < o11.length; t7++)
          e12 = e12 > o11[t7] ? o11[t7] : e12, n20 = n20 > o11[t7] ? n20 : o11[t7];
        t6.statistics = [{ ...s11[0], min: e12, max: n20 }];
      }
    this.rasterInfo = t6, this.lookup = n19 ? null : y4({ srcPixelType: e11, inputRanges: a30, outputValues: o11, noDataRanges: i28, allowUnmatched: n19, isLastInputRangeInclusive: l16, outputPixelType: this.outputPixelType });
    return { success: true, supportsGPU: (!o11 || o11.length <= i2) && (!i28 || i28.length <= i2) };
  }
  _processPixels(t6) {
    var _a;
    const e11 = (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
    if (null == e11)
      return null;
    const { lookup: s11, outputPixelType: n19 } = this;
    if (s11) {
      const t7 = f2(e11, { lut: [s11.lut], offset: s11.offset, outputPixelType: n19 });
      return null != t7 && s11.mask && (t7.mask = c(e11.pixels[0], e11.mask, s11.mask, s11.offset, "u8")), t7;
    }
    const { inputRanges: o11, outputValues: a30, noDataRanges: u18, allowUnmatched: r7, isLastInputRangeInclusive: c29 } = this.functionArguments;
    return p2(e11, { inputRanges: o11, outputValues: a30, noDataRanges: u18, outputPixelType: n19, allowUnmatched: r7, isLastInputRangeInclusive: c29 });
  }
  _getWebGLParameters() {
    const { allowUnmatched: t6, noDataRanges: s11, isLastInputRangeInclusive: n19 } = this.functionArguments, a30 = new Float32Array(3 * i2), u18 = 1e-5, i28 = this.functionArguments.inputRanges ?? [], l16 = this.functionArguments.outputValues ?? [], p23 = l16.length;
    for (let o11 = 0; o11 < i2; o11++)
      a30[3 * o11] = i28[2 * o11] ?? j - 1, a30[3 * o11 + 1] = i28[2 * o11 + 1] ?? j, a30[3 * o11 + 2] = l16[o11] ?? 0, o11 < p23 && (o11 > 0 && (a30[3 * o11] -= u18), (o11 < p23 - 1 || !n19) && (a30[3 * o11 + 1] -= u18));
    const c29 = new Float32Array(2 * i2);
    c29.fill(j), (s11 == null ? void 0 : s11.length) && c29.set(s11);
    return { allowUnmatched: t6, rangeMaps: a30, noDataRanges: c29, clampRange: s3(this.outputPixelType) };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], m7.prototype, "functionName", void 0), e([y({ type: r5, json: { write: true, name: "rasterFunctionArguments" } })], m7.prototype, "functionArguments", void 0), e([y()], m7.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], m7.prototype, "lookup", void 0), m7 = e([a2("esri.layers.support.rasterFunctions.RemapFunction")], m7);
var g5 = m7;

// node_modules/@arcgis/core/layers/support/rasterFunctions/SlopeFunctionArguments.js
var i22;
var c19 = new n({ 1: "degree", 2: "percent-rise", 3: "adjusted" }, { useNumericKeys: true });
var a23 = i22 = class extends p4 {
  constructor() {
    super(...arguments), this.slopeType = "degree", this.zFactor = 1, this.pixelSizePower = 0.664, this.pixelSizeFactor = 0.024, this.removeEdgeEffect = false;
  }
  clone() {
    return new i22({ slopeType: this.slopeType, zFactor: this.zFactor, pixelSizePower: this.pixelSizePower, pixelSizeFactor: this.pixelSizeFactor, removeEdgeEffect: this.removeEdgeEffect, raster: this.raster });
  }
};
e([o2(c19)], a23.prototype, "slopeType", void 0), e([y({ type: Number, json: { write: true } })], a23.prototype, "zFactor", void 0), e([y({ type: Number, json: { name: "psPower", write: true } })], a23.prototype, "pixelSizePower", void 0), e([y({ type: Number, json: { name: "psZFactor", write: true } })], a23.prototype, "pixelSizeFactor", void 0), e([y({ type: Boolean, json: { write: true } })], a23.prototype, "removeEdgeEffect", void 0), a23 = i22 = e([a2("esri.layers.support.rasterFunctions.SlopeFunctionArguments")], a23);
var m8 = a23;

// node_modules/@arcgis/core/layers/support/rasterFunctions/SlopeFunction.js
var p17 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Slope", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    var _a;
    this.outputPixelType = this._getOutputPixelType("f32");
    const e11 = this.sourceRasterInfos[0].clone();
    return e11.pixelType = this.outputPixelType, e11.statistics = "percent-rise" !== this.functionArguments.slopeType ? [{ min: 0, max: 90, avg: 1, stddev: 1 }] : null, e11.histograms = null, e11.colormap = null, e11.attributeTable = null, e11.bandCount = 1, this.rasterInfo = e11, this.isGCS = ((_a = e11.spatialReference) == null ? void 0 : _a.isGeographic) ?? false, { success: true, supportsGPU: true };
  }
  _processPixels(e11) {
    var _a;
    const t6 = (_a = e11.pixelBlocks) == null ? void 0 : _a[0];
    if (null == t6)
      return null;
    const { zFactor: s11, slopeType: r7, pixelSizePower: o11, pixelSizeFactor: n19 } = this.functionArguments, { isGCS: p23 } = this, { extent: c29, primaryPixelSizes: u18 } = e11, a30 = u18 == null ? void 0 : u18[0], l16 = a30 ?? (c29 ? { x: c29.width / t6.width, y: c29.height / t6.height } : { x: 1, y: 1 });
    return h(t6, { zFactor: s11, slopeType: r7, pixelSizePower: o11, pixelSizeFactor: n19, isGCS: p23, resolution: l16 });
  }
  _getWebGLParameters() {
    const { zFactor: e11, slopeType: t6, pixelSizeFactor: s11, pixelSizePower: r7 } = this.functionArguments;
    return { zFactor: this.isGCS && e11 >= 1 ? e11 * n4 : e11, slopeType: t6, pixelSizeFactor: s11 ?? 0, pixelSizePower: r7 ?? 0 };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], p17.prototype, "functionName", void 0), e([y({ type: m8, json: { write: true, name: "rasterFunctionArguments" } })], p17.prototype, "functionArguments", void 0), e([y()], p17.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], p17.prototype, "isGCS", void 0), p17 = e([a2("esri.layers.support.rasterFunctions.SlopeFunction")], p17);
var c20 = p17;

// node_modules/@arcgis/core/layers/support/rasterFunctions/focalStatUtils.js
var n13 = new n({ 1: "min", 2: "max", 3: "mean", 4: "stddev", 5: "median", 6: "majority", 7: "minority" }, { useNumericKeys: true });
function s10(t6, e11) {
  const { fillNoDataOnly: o11 } = e11, { band: n19, width: s11, height: r7, mask: i28, outBand: l16 } = t6;
  if (o11 && !i28)
    return void l16.set(n19);
  const { statisticsType: a30, kernelRows: c29, kernelCols: f7 } = e11, h6 = "stddev" === a30, m10 = s11 * r7, u18 = new Float64Array(m10), d7 = new Float64Array(m10), y8 = new Uint32Array(m10);
  for (let A3 = 0; A3 < r7; A3++) {
    const t7 = A3 * s11;
    let e12 = 0, o12 = 0, r8 = 0;
    for (let s12 = 0; s12 < f7; s12++)
      i28 && !i28[t7 + s12] || (e12 += n19[t7 + s12], h6 && (o12 += n19[t7 + s12] ** 2), r8++);
    u18[t7] = e12, d7[t7] = o12, y8[t7] = r8;
    for (let l17 = 1; l17 <= s11 - f7; l17++) {
      const s12 = t7 + l17 - 1, a31 = s12 + f7;
      i28 ? (i28[s12] && (r8--, e12 -= n19[s12], h6 && (o12 -= n19[s12] ** 2)), i28[a31] && (r8++, e12 += n19[a31], h6 && (o12 += n19[a31] ** 2))) : (e12 -= n19[s12], e12 += n19[a31], h6 && (o12 -= n19[s12] ** 2, o12 += n19[a31] ** 2)), u18[t7 + l17] = e12, y8[t7 + l17] = r8, h6 && (d7[t7 + l17] = o12);
    }
  }
  const k4 = new Float64Array(m10), w7 = new Float64Array(m10), p23 = new Uint32Array(m10), M4 = c29 * s11;
  for (let A3 = 0; A3 <= s11 - f7; A3++) {
    let t7 = 0, e12 = 0, o12 = 0;
    for (let n20 = 0; n20 < c29; n20++) {
      const r8 = n20 * s11 + A3;
      t7 += u18[r8], o12 += y8[r8], h6 && (e12 += d7[r8]);
    }
    k4[A3] = t7, w7[A3] = e12, p23[A3] = o12;
    for (let n20 = 1; n20 <= r7 - c29; n20++) {
      const r8 = (n20 - 1) * s11 + A3, i29 = r8 + M4;
      t7 -= u18[r8], t7 += u18[i29], o12 -= y8[r8], o12 += y8[i29], h6 && (e12 -= d7[r8], e12 += d7[i29]), k4[n20 * s11 + A3] = t7, w7[n20 * s11 + A3] = e12, p23[n20 * s11 + A3] = o12;
    }
  }
  const g6 = Math.floor(c29 / 2), b3 = Math.floor(f7 / 2);
  for (let A3 = g6; A3 < r7 - g6; A3++) {
    const t7 = A3 * s11;
    for (let e12 = b3; e12 < s11 - b3; e12++) {
      const n20 = (A3 - g6) * s11 + e12 - b3, r8 = p23[n20];
      if (0 === r8 || o11 && (!i28 || i28[t7 + e12]))
        continue;
      const a31 = k4[n20] / r8, c30 = h6 ? Math.sqrt((w7[n20] - k4[n20] * a31) / r8) : a31;
      l16[t7 + e12] = c30, i28 && (i28[t7 + e12] = 255);
    }
  }
}
function r6(t6, e11) {
  const { fillNoDataOnly: o11 } = e11, { band: n19, width: s11, height: r7, mask: i28, outBand: l16 } = t6;
  if (o11 && !i28)
    return void l16.set(n19);
  const { kernelRows: a30, kernelCols: c29, statisticsType: f7 } = e11, h6 = Math.floor(a30 / 2), m10 = Math.floor(c29 / 2), u18 = "min" === f7, d7 = l16.slice(), y8 = new Uint32Array(s11 * r7);
  for (let k4 = h6; k4 < r7 - h6; k4++) {
    const t7 = k4 * s11;
    for (let e12 = m10; e12 < s11 - m10; e12++) {
      let o12 = u18 ? Number.MAX_VALUE : -Number.MAX_VALUE, r8 = 0;
      for (let l17 = 0; l17 < a30; l17++)
        for (let a31 = 0; a31 < c29; a31++) {
          const c30 = t7 + e12 + (l17 - h6) * s11 + a31 - m10;
          i28 && !i28[c30] || (o12 = u18 ? Math.min(o12, n19[c30]) : Math.max(o12, n19[c30]), r8++);
        }
      i28 ? (d7[t7 + e12] = 0 === r8 ? 0 : o12, y8[t7 + e12] = r8) : l16[t7 + e12] = 0 === r8 ? 0 : o12;
    }
  }
  if (i28)
    for (let k4 = h6; k4 < r7 - h6; k4++) {
      const t7 = k4 * s11;
      for (let e12 = m10; e12 < s11 - m10; e12++)
        if (y8[t7 + e12]) {
          if (o11 && i28[t7 + e12])
            continue;
          l16[t7 + e12] = d7[t7 + e12], i28[t7 + e12] = 255;
        }
    }
}
function i23(t6, e11) {
  const { fillNoDataOnly: o11 } = e11, { band: n19, width: s11, height: r7, mask: i28, outBand: l16 } = t6;
  if (o11 && !i28)
    return void l16.set(n19);
  const { kernelRows: a30, kernelCols: c29 } = e11, f7 = Math.floor(a30 / 2), h6 = Math.floor(c29 / 2), m10 = l16.slice(), u18 = new Uint32Array(s11 * r7);
  for (let d7 = f7; d7 < r7 - f7; d7++) {
    const t7 = d7 * s11;
    for (let e12 = h6; e12 < s11 - h6; e12++) {
      if (o11 && i28 && i28[t7 + e12])
        continue;
      const r8 = [];
      for (let o12 = 0; o12 < a30; o12++)
        for (let l17 = 0; l17 < c29; l17++) {
          const a31 = t7 + e12 + (o12 - f7) * s11 + l17 - h6;
          i28 && !i28[a31] || r8.push(n19[a31]);
        }
      r8.length && (r8.sort((t8, e13) => t8 - e13), i28 ? (m10[t7 + e12] = r8[Math.floor((r8.length - 1) / 2)], u18[t7 + e12] = r8.length) : l16[t7 + e12] = r8[Math.floor((r8.length - 1) / 2)]);
    }
  }
  if (i28)
    for (let d7 = f7; d7 < r7 - f7; d7++) {
      const t7 = d7 * s11;
      for (let e12 = h6; e12 < s11 - h6; e12++)
        if (u18[t7 + e12]) {
          if (o11 && i28[t7 + e12])
            continue;
          l16[t7 + e12] = m10[t7 + e12], i28[t7 + e12] = 255;
        }
    }
}
function l12(t6, e11) {
  const { fillNoDataOnly: o11 } = e11, { band: n19, width: s11, height: r7, mask: i28, outBand: l16 } = t6;
  if (o11 && !i28)
    return void l16.set(n19);
  const { kernelRows: a30, kernelCols: c29 } = e11, f7 = Math.floor(a30 / 2), h6 = Math.floor(c29 / 2), m10 = "majority" === e11.statisticsType, u18 = a30 * c29, d7 = l16.slice(), y8 = new Uint32Array(s11 * r7);
  for (let k4 = f7; k4 < r7 - f7; k4++) {
    const t7 = k4 * s11;
    for (let e12 = h6; e12 < s11 - h6; e12++) {
      if (o11 && i28 && i28[t7 + e12])
        continue;
      const r8 = /* @__PURE__ */ new Map();
      for (let o12 = 0; o12 < a30; o12++)
        for (let l17 = 0; l17 < c29; l17++) {
          const a31 = t7 + e12 + (o12 - f7) * s11 + l17 - h6;
          if (i28 && !i28[a31])
            continue;
          const c30 = n19[a31];
          r8.set(c30, r8.has(c30) ? r8.get(c30) + 1 : 1);
        }
      if (0 === r8.size)
        continue;
      let k5 = 0, w7 = 0, p23 = m10 ? 0 : u18 + 1;
      for (const t8 of r8.keys())
        w7 = r8.get(t8), m10 === w7 > p23 && (p23 = w7, k5 = t8);
      i28 ? (d7[t7 + e12] = k5, y8[t7 + e12] = r8.size) : l16[t7 + e12] = k5;
    }
  }
  if (i28)
    for (let k4 = f7; k4 < r7 - f7; k4++) {
      const t7 = k4 * s11;
      for (let e12 = h6; e12 < s11 - h6; e12++)
        if (y8[t7 + e12]) {
          if (o11 && i28[t7 + e12])
            continue;
          l16[t7 + e12] = d7[t7 + e12], i28[t7 + e12] = 255;
        }
    }
}
function a24(t6, n19) {
  const { mask: a30 } = t6, { fillNoDataOnly: c29 } = n19;
  if (c29 && !a30)
    return t6;
  const { pixels: f7, width: h6, height: m10, bandMasks: u18, pixelType: d7 } = t6, y8 = f7.length, k4 = h6 * m10, w7 = [], { kernelRows: p23, kernelCols: M4, statisticsType: g6, mirrorEdges: b3 } = n19;
  if (c29 && !a30)
    return t6;
  const A3 = n19.outputPixelType ?? d7, x5 = [];
  for (let N3 = 0; N3 < y8; N3++) {
    const t7 = f7[N3], d8 = g.createEmptyBand(A3, k4);
    c29 && d8.set(t7);
    const y9 = (u18 == null ? void 0 : u18[N3]) ?? a30, j4 = (y9 == null ? void 0 : y9.slice()) ?? null, B6 = { band: t7, width: h6, height: m10, mask: j4, outBand: d8 };
    switch (g6) {
      case "min":
      case "max":
        r6(B6, n19);
        break;
      case "mean":
      case "stddev":
        s10(B6, n19);
        break;
      case "median":
        i23(B6, n19);
        break;
      case "majority":
      case "minority":
        l12(B6, n19);
    }
    b3 && !c29 && o8(d8, h6, m10, p23, M4), w7.push(d8), j4 && x5.push(j4);
  }
  let j3 = x5[0] ?? a30;
  x5.length !== y8 && (x5.length = 0), y8 > 1 && (u18 == null ? void 0 : u18.length) && (j3 = g.combineBandMasks(u18));
  const B5 = new g({ pixelType: A3, width: h6, height: m10, pixels: w7, bandMasks: u18 && x5.length ? x5 : null, mask: j3 });
  return B5.updateStatistics(), B5;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsFunctionArguments.js
var c21;
var p18 = c21 = class extends p4 {
  constructor() {
    super(...arguments), this.rows = 3, this.cols = 3, this.fillNoDataOnly = false, this.statisticsType = "min";
  }
  clone() {
    return new c21({ rows: this.rows, cols: this.cols, fillNoDataOnly: this.fillNoDataOnly, statisticsType: this.statisticsType, raster: a(this.raster) });
  }
};
e([y({ json: { write: true, read: { source: ["kernelRows", "rows"], reader: (s11, r7) => Number(s11 ?? (r7 == null ? void 0 : r7.kernelRows) ?? 3) } } })], p18.prototype, "rows", void 0), e([y({ json: { write: true, read: { source: ["kernelCols", "cols"], reader: (s11, r7) => Number(s11 ?? (r7 == null ? void 0 : r7.kernelCols) ?? 3) } } })], p18.prototype, "cols", void 0), e([y({ json: { write: true } })], p18.prototype, "fillNoDataOnly", void 0), e([y({ json: { read: { source: ["statisticsType", "type"], reader: (s11, r7) => n13.fromJSON((r7 == null ? void 0 : r7.statisticsType) ?? (r7 == null ? void 0 : r7.type)) ?? "min" }, write: { target: "type" } } }), o2(n13)], p18.prototype, "statisticsType", void 0), p18 = c21 = e([a2("esri.layers.support.rasterFunctions.StatisticsFunctionArguments")], p18);
var l13 = p18;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsFunction.js
var c22 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Statistics", this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { type: t6 } = this.functionArguments.toJSON();
    if (t6 < 1 || t6 > 7)
      return { success: false, supportsGPU: false, error: `statistics-function: the given statistics type is not supported ${t6}` };
    const s11 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType(s11.pixelType);
    const e11 = s11.clone();
    e11.pixelType = this.outputPixelType;
    const { statisticsType: o11 } = this.functionArguments;
    "stddev" === o11 && this._removeStatsHistColormapVAT(e11), this.rasterInfo = e11;
    return { success: true, supportsGPU: e11.bandCount <= 3 && t6 < 5 };
  }
  _processPixels(t6) {
    var _a;
    const s11 = (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s11)
      return s11;
    const { statisticsType: e11, rows: o11, cols: r7, fillNoDataOnly: n19 } = this.functionArguments;
    return a24(s11, { kernelRows: o11, kernelCols: r7, fillNoDataOnly: n19, outputPixelType: this.outputPixelType, statisticsType: e11, mirrorEdges: true });
  }
  _getWebGLParameters() {
    const { rows: t6, cols: s11, statisticsType: e11, fillNoDataOnly: r7 } = this.functionArguments;
    return { fillNoDataOnly: r7, kernelRows: t6, kernelCols: s11, statisticsType: e11, clampRange: s3(this.outputPixelType) };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], c22.prototype, "functionName", void 0), e([y({ type: l13, json: { write: true, name: "rasterFunctionArguments" } })], c22.prototype, "functionArguments", void 0), e([y()], c22.prototype, "rasterArgumentNames", void 0), c22 = e([a2("esri.layers.support.rasterFunctions.StatisticsFunction")], c22);
var p19 = c22;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsHistogramFunctionArguments.js
var c23;
var n14 = c23 = class extends p4 {
  constructor() {
    super(...arguments), this.statistics = null, this.histograms = null;
  }
  readStatistics(t6, s11) {
    if (!(t6 == null ? void 0 : t6.length))
      return null;
    const r7 = [];
    return t6.forEach((t7) => {
      const s12 = { min: t7.min, max: t7.max, avg: t7.avg ?? t7.mean, stddev: t7.stddev ?? t7.standardDeviation };
      r7.push(s12);
    }), r7;
  }
  writeStatistics(t6, s11, r7) {
    if (!(t6 == null ? void 0 : t6.length))
      return;
    const o11 = [];
    t6.forEach((t7) => {
      const s12 = { ...t7, mean: t7.avg, standardDeviation: t7.stddev };
      delete s12.avg, delete s12.stddev, o11.push(s12);
    }), s11[r7] = o11;
  }
  clone() {
    return new c23({ statistics: a(this.statistics), histograms: a(this.histograms) });
  }
};
e([y({ json: { write: true } })], n14.prototype, "statistics", void 0), e([o("statistics")], n14.prototype, "readStatistics", null), e([r("statistics")], n14.prototype, "writeStatistics", null), e([y({ json: { write: true } })], n14.prototype, "histograms", void 0), n14 = c23 = e([a2("esri.layers.support.rasterFunctions.StatisticsHistogramFunctionArguments")], n14);
var p20 = n14;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsHistogramFunction.js
var i24 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "StatisticsHistogram", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType("u8");
    const s11 = t6.clone(), { statistics: o11, histograms: r7 } = this.functionArguments;
    return r7 && (s11.histograms = r7), o11 && (s11.statistics = o11), this.rasterInfo = s11, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    var _a;
    return (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], i24.prototype, "functionName", void 0), e([y({ type: p20, json: { write: true, name: "rasterFunctionArguments" } })], i24.prototype, "functionArguments", void 0), e([y()], i24.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], i24.prototype, "indexedColormap", void 0), e([y()], i24.prototype, "isNoopProcess", void 0), i24 = e([a2("esri.layers.support.rasterFunctions.StatisticsHistogramFunction")], i24);
var n15 = i24;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StretchFunctionArguments.js
var n16;
var p21 = new n({ 0: "none", 3: "standard-deviation", 4: "histogram-equalization", 5: "min-max", 6: "percent-clip", 9: "sigmoid" }, { useNumericKeys: true });
var c24 = n16 = class extends p4 {
  constructor() {
    super(...arguments), this.computeGamma = false, this.dynamicRangeAdjustment = false, this.gamma = [], this.histograms = null, this.statistics = null, this.stretchType = "none", this.useGamma = false;
  }
  writeStatistics(t6, e11, o11) {
    (t6 == null ? void 0 : t6.length) && (Array.isArray(t6[0]) || (t6 = t6.map((t7) => [t7.min, t7.max, t7.avg, t7.stddev])), e11[o11] = t6);
  }
  clone() {
    return new n16({ stretchType: this.stretchType, outputMin: this.outputMin, outputMax: this.outputMax, useGamma: this.useGamma, computeGamma: this.computeGamma, statistics: a(this.statistics), gamma: a(this.gamma), sigmoidStrengthLevel: this.sigmoidStrengthLevel, numberOfStandardDeviations: this.numberOfStandardDeviations, minPercent: this.minPercent, maxPercent: this.maxPercent, histograms: a(this.histograms), dynamicRangeAdjustment: this.dynamicRangeAdjustment, raster: this.raster });
  }
};
e([y({ type: Boolean, json: { write: true } })], c24.prototype, "computeGamma", void 0), e([y({ type: Boolean, json: { name: "dra", write: true } })], c24.prototype, "dynamicRangeAdjustment", void 0), e([y({ type: [Number], json: { write: true } })], c24.prototype, "gamma", void 0), e([y()], c24.prototype, "histograms", void 0), e([y({ type: Number, json: { write: true } })], c24.prototype, "maxPercent", void 0), e([y({ type: Number, json: { write: true } })], c24.prototype, "minPercent", void 0), e([y({ type: Number, json: { write: true } })], c24.prototype, "numberOfStandardDeviations", void 0), e([y({ type: Number, json: { name: "max", write: true } })], c24.prototype, "outputMax", void 0), e([y({ type: Number, json: { name: "min", write: true } })], c24.prototype, "outputMin", void 0), e([y({ type: Number, json: { write: true } })], c24.prototype, "sigmoidStrengthLevel", void 0), e([y({ json: { type: [[Number]], write: true } })], c24.prototype, "statistics", void 0), e([r("statistics")], c24.prototype, "writeStatistics", null), e([o2(p21)], c24.prototype, "stretchType", void 0), e([y({ type: Boolean, json: { write: true } })], c24.prototype, "useGamma", void 0), c24 = n16 = e([a2("esri.layers.support.rasterFunctions.StretchFunctionArguments")], c24);
var u16 = c24;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StretchFunction.js
var c25 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Stretch", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null, this.cutOffs = null;
  }
  _bindSourceRasters() {
    this.lookup = null, this.cutOffs = null;
    const t6 = this.sourceRasterInfos[0], { pixelType: s11 } = t6, { functionArguments: e11 } = this, { dynamicRangeAdjustment: r7, gamma: u18, useGamma: i28 } = e11;
    if (!r7 && ["u8", "u16", "s8", "s16"].includes(s11)) {
      const r8 = p3(e11.toJSON(), { rasterInfo: t6 }), a31 = i(this.outputPixelType) ? "round" : "float";
      this.lookup = a4({ pixelType: s11, ...r8, gamma: i28 ? u18 : null, rounding: a31 }), this.cutOffs = r8;
    } else
      r7 || (this.cutOffs = p3(e11.toJSON(), { rasterInfo: t6 }));
    this.outputPixelType = this._getOutputPixelType(s11);
    const a30 = t6.clone();
    a30.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(a30), "u8" === this.outputPixelType && (a30.keyProperties.DataType = "processed"), this.rasterInfo = a30;
    return { success: true, supportsGPU: !r7 };
  }
  _processPixels(t6) {
    var _a;
    const s11 = (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s11)
      return s11;
    const { lookup: e11 } = this;
    if (e11)
      return f2(s11, { ...e11, outputPixelType: this.rasterInfo.pixelType });
    const { functionArguments: o11 } = this, r7 = this.cutOffs || p3(o11.toJSON(), { rasterInfo: this.sourceRasterInfos[0], pixelBlock: s11 }), i28 = o11.useGamma ? o11.gamma : null;
    return M(s11, { ...r7, gamma: i28, outputPixelType: this.outputPixelType });
  }
  _getWebGLParameters() {
    const { outputMin: t6 = 0, outputMax: s11 = 255, gamma: e11, useGamma: r7 } = this.functionArguments, u18 = this.rasterInfo.bandCount >= 2 ? 3 : 1, i28 = r7 && (e11 == null ? void 0 : e11.length) ? x2(u18, e11) : [1, 1, 1], { minCutOff: n19, maxCutOff: p23 } = this.cutOffs ?? { minCutOff: [0, 0, 0], maxCutOff: [255, 255, 255] };
    1 === n19.length && (n19[1] = n19[2] = n19[0], p23[1] = p23[2] = p23[0]);
    const a30 = new Float32Array(u18);
    let c29;
    for (c29 = 0; c29 < u18; c29++)
      a30[c29] = (s11 - t6) / (p23[c29] - n19[c29]);
    const l16 = i(this.outputPixelType);
    return { bandCount: u18, outMin: t6, outMax: s11, minCutOff: n19, maxCutOff: p23, factor: a30, useGamma: r7, gamma: r7 && e11 ? e11 : [1, 1, 1], gammaCorrection: r7 && i28 ? i28 : [1, 1, 1], stretchType: this.functionArguments.stretchType, isOutputRounded: l16, type: "stretch" };
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], c25.prototype, "functionName", void 0), e([y({ type: u16, json: { write: true, name: "rasterFunctionArguments" } })], c25.prototype, "functionArguments", void 0), e([y()], c25.prototype, "rasterArgumentNames", void 0), e([y({ json: { write: true } })], c25.prototype, "lookup", void 0), e([y({ json: { write: true } })], c25.prototype, "cutOffs", void 0), c25 = e([a2("esri.layers.support.rasterFunctions.StretchFunction")], c25);
var l14 = c25;

// node_modules/@arcgis/core/layers/support/rasterFunctions/TableFunctionArguments.js
var c26;
var a25 = c26 = class extends p4 {
  constructor() {
    super(...arguments), this.attributeTableAsRecordSet = null;
  }
  clone() {
    return new c26({ attributeTableAsRecordSet: a(this.attributeTableAsRecordSet) });
  }
};
e([y({ json: { write: true } })], a25.prototype, "attributeTableAsRecordSet", void 0), a25 = c26 = e([a2("esri.layers.support.rasterFunctions.TableFunctionArguments")], a25);
var i25 = a25;

// node_modules/@arcgis/core/layers/support/rasterFunctions/TableFunction.js
var i26 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Table", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0];
    if (t6.bandCount > 1 || t6.pixelType.startsWith("f"))
      return { success: false, supportsGPU: false, error: "table-function: Source data must be single band and integer pixel type." };
    const { attributeTableAsRecordSet: e11 } = this.functionArguments;
    if (!e11)
      return { success: false, supportsGPU: false, error: "table-function: Missing attributeTableAsRecordSet argument." };
    this.outputPixelType = this._getOutputPixelType(t6.pixelType);
    const s11 = t6.clone();
    return s11.pixelType = this.outputPixelType, s11.bandCount = 1, "thematic" !== s11.dataType && (s11.keyProperties = s11.keyProperties ? { ...s11.keyProperties, DataType: "thematic" } : { DataType: "thematic" }), this.rasterInfo = s11, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    var _a;
    return (_a = t6.pixelBlocks) == null ? void 0 : _a[0];
  }
};
e([y({ json: { write: true, name: "rasterFunction" } })], i26.prototype, "functionName", void 0), e([y({ type: i25, json: { write: true, name: "rasterFunctionArguments" } })], i26.prototype, "functionArguments", void 0), e([y()], i26.prototype, "rasterArgumentNames", void 0), e([y()], i26.prototype, "isNoopProcess", void 0), i26 = e([a2("esri.layers.support.rasterFunctions.TableFunction")], i26);
var n17 = i26;

// node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionHelper.js
var C3 = /* @__PURE__ */ new Map();
function N2(t6, e11) {
  const { rasterFunctionArguments: r7 } = t6;
  if (!r7)
    return;
  (r7.rasters || [r7.raster]).forEach((t7) => {
    t7 && "number" != typeof t7 && ("string" == typeof t7 ? t7.startsWith("http") && (e11.includes(t7) || e11.push(t7)) : "rasterFunctionArguments" in t7 && N2(t7, e11));
  });
}
function R2(t6, n19) {
  if (n19 = n19 ?? {}, "function" in (t6 = a(t6)) && "arguments" in t6 && t6.arguments) {
    const r7 = B4(t6, /* @__PURE__ */ new Map(), n19);
    if (M3(r7), !r7.renderingRule)
      throw new s("raster-function-helper", "Unsupported raster function json.");
    t6 = r7.renderingRule;
  }
  if ("rasterFunction" in t6)
    return D2(t6 = w6(t6), n19);
  throw new s("raster-function-helper", "unsupported raster function json.");
}
function S2(t6, e11) {
  return "rasters" === e11[0] && Array.isArray(t6.rasters) ? t6.rasters : e11.map((e12) => t6[e12]);
}
function v3(t6) {
  return !!(t6 && "object" == typeof t6 && t6.rasterFunction && t6.rasterFunctionArguments);
}
function w6(t6) {
  var _a;
  const { rasterFunction: e11, rasterFunctionArguments: r7 } = t6, n19 = {};
  for (const o11 in r7) {
    let t7 = r7[o11];
    const e12 = o11.toLowerCase();
    if ("rasters" === e12 && Array.isArray(t7))
      n19.rasters = t7.map((t8) => v3(t8) ? w6(t8) : t8);
    else
      switch (v3(t7) && (t7 = w6(t7)), e12) {
        case "dra":
          n19.dra = t7;
          break;
        case "pspower":
          n19.psPower = t7;
          break;
        case "pszfactor":
          n19.psZFactor = t7;
          break;
        case "bandids":
          n19.bandIds = t7;
          break;
        default:
          n19[o11[0].toLowerCase() + o11.slice(1)] = t7;
      }
  }
  return "Local" !== e11 || ((_a = n19.rasters) == null ? void 0 : _a.length) || (n19.rasters = ["$$"]), { ...t6, rasterFunctionArguments: n19 };
}
function D2(t6, r7) {
  var _a, _b;
  const { rasterFunction: n19, rasterFunctionArguments: o11 } = t6, s11 = (_a = t6.outputPixelType) == null ? void 0 : _a.toLowerCase();
  if (null == n19 || !C3.has(n19))
    throw new s("raster-function-helper", `unsupported raster function: ${n19}`);
  const a30 = C3.get(n19), i28 = ("function" == typeof a30.ctor ? a30.ctor : a30.ctor.default).fromJSON({ ...t6, outputPixelType: s11 }), { rasterArgumentNames: c29 } = i28, u18 = [], m10 = S2(o11, c29), l16 = "rasters" === c29[0], p23 = [];
  for (let e11 = 0; e11 < m10.length; e11++) {
    const t7 = m10[e11];
    let n20;
    null == t7 || "string" == typeof t7 && t7.startsWith("$") ? u18.push(r7 == null ? void 0 : r7.raster) : "string" == typeof t7 ? r7[t7] && u18.push(r7[t7]) : "number" != typeof t7 && "rasterFunction" in t7 && (n20 = D2(t7, r7), l16 || (i28.functionArguments[c29[e11]] = n20), u18.push(n20)), l16 && p23.push(n20 ?? t7);
  }
  if (l16 && (i28.functionArguments.rasters = p23), r7) {
    i28.sourceRasters = u18;
    const t7 = (_b = r7.raster) == null ? void 0 : _b.url;
    t7 && (i28.mainPrimaryRasterId = t7);
  }
  return i28;
}
function V2(t6, e11) {
  if (t6 && e11)
    for (const r7 in t6) {
      const n19 = t6[r7];
      n19 && "object" == typeof n19 && "type" in n19 && ("RasterFunctionTemplate" === n19.type ? V2(n19.arguments, e11) : "RasterFunctionVariable" === n19.type && null != e11[n19.name] && (n19.value = e11[n19.name]));
    }
}
function T2(t6, r7) {
  var _a;
  if (!t6 || "object" != typeof t6)
    return t6;
  const { value: n19 } = t6;
  if (!n19 || "object" != typeof n19)
    return t6.isDataset ? "$$" : n19;
  if (Array.isArray(n19))
    return 0 === n19.length ? [] : n19.map((t7) => "object" == typeof t7 && "RasterFunctionVariable" === t7.type ? T2(t7, r7) : t7);
  if ("value" in n19 && ["number", "string", "boolean"].includes(typeof n19.value))
    return n19.value;
  if (t6.isDataset && "Scalar" !== n19.type)
    return "$$";
  if (!("type" in n19))
    return n19;
  let o11 = n19;
  switch (n19.type) {
    case "Scalar":
      o11 = n19.value;
      break;
    case "AlgorithmicColorRamp":
      o11 = k3(n19);
      break;
    case "MultiPartColorRamp":
      o11 = { type: "multipart", colorRamps: n19.ArrayOfColorRamp.map(k3) };
      break;
    case "ArgumentArray":
      if (((_a = n19.elements) == null ? void 0 : _a.length) && "RasterStatistics" !== n19.elements[0].type) {
        const t7 = [];
        for (let o12 = 0; o12 < n19.elements.length; o12++) {
          const s11 = n19.elements[o12], { type: a30 } = s11;
          if (a30)
            if ("RasterFunctionTemplate" === a30) {
              const { renderingRule: e11 } = B4(s11, r7);
              t7.push(e11), null != s11._object_id && r7.set(s11._object_id, e11);
            } else {
              if ("RasterFunctionVariable" !== a30)
                throw new s("raster-function-helper", "unsupported raster function json.");
              {
                const e11 = T2(s11, r7);
                t7.push(e11), null != s11._object_id && r7.set(s11._object_id, e11);
              }
            }
          else
            t7.push(s11);
        }
        o11 = t7;
      } else
        o11 = n19.elements;
  }
  return null != n19._object_id && r7.set(n19._object_id, o11), o11;
}
function k3(e11) {
  const r7 = e11.algorithm ?? "esriHSVAlgorithm";
  let { FromColor: n19, ToColor: o11 } = e11;
  if (!Array.isArray(n19)) {
    const { r: e12, g: r8, b: o12 } = y3({ h: n19.Hue, s: n19.Saturation, v: n19.Value });
    n19 = [e12, r8, o12, n19.AlphaValue];
  }
  if (!Array.isArray(o11)) {
    const { r: e12, g: r8, b: n20 } = y3({ h: o11.Hue, s: o11.Saturation, v: o11.Value });
    o11 = [e12, r8, n20, o11.AlphaValue];
  }
  return { type: "algorithmic", algorithm: r7, fromColor: n19, toColor: o11 };
}
function B4(t6, e11, r7) {
  r7 && V2(t6, r7);
  const n19 = { renderingRule: {}, templates: e11 };
  return x4(t6, n19), n19;
}
function x4(t6, e11) {
  if (!t6 || !e11.renderingRule)
    return;
  const { renderingRule: r7, templates: n19 } = e11, { function: o11, arguments: s11, _object_id: a30 } = t6;
  if (!o11 || !s11)
    return;
  null != a30 && n19.set(a30, r7), r7.rasterFunction = o11.type.replace("Function", ""), r7.outputPixelType = o11.pixelType;
  const i28 = {};
  r7.rasterFunctionArguments = i28;
  for (const c29 in s11) {
    if ("type" === c29 || "object_id" === c29 || "_object_ref_id" === c29)
      continue;
    const t7 = s11[c29];
    t7 && "object" == typeof t7 && "type" in t7 && ("RasterFunctionTemplate" === t7.type || "RasterFunctionVariable" === t7.type) ? ("RasterFunctionVariable" === t7.type ? i28[c29] = T2(t7, n19) : (r7.rasterFunctionArguments[c29] = {}, x4(t7, { renderingRule: r7.rasterFunctionArguments[c29], templates: n19 })), null != t7._object_id && n19.set(t7._object_id, i28[c29])) : i28[c29] = t7;
  }
  switch (i28.DEM && !i28.Raster && (i28.Raster = i28.DEM, delete i28.DEM), r7.rasterFunction) {
    case "Stretch":
      $2(i28);
      break;
    case "Colormap":
      E2(i28);
      break;
    case "Convolution":
      L2(i28);
      break;
    case "Mask":
      O2(i28);
  }
}
function M3(t6) {
  const { renderingRule: r7, templates: n19 } = t6;
  if ("object" != typeof r7 || !(r7 == null ? void 0 : r7.rasterFunctionArguments) || !n19.size)
    return;
  const { rasterFunctionArguments: o11 } = r7;
  for (const s11 in o11) {
    const t7 = o11[s11], r8 = "_object_ref_id" === s11 ? t7 : t7 && "object" == typeof t7 && "_object_ref_id" in t7 ? t7._object_ref_id : null;
    if (null == r8)
      t7 && "object" == typeof t7 && (t7.rasterFunctionArguments && M3({ renderingRule: t7, templates: n19 }), Array.isArray(t7) && t7.forEach((o12, s12) => {
        if ("object" == typeof o12)
          if (null != o12._object_ref_id) {
            if (!n19.has(o12._object_ref_id))
              throw new s("raster-function-helper", `unsupported raster function json. _object_ref_id: ${t7} does not exist`);
            const a30 = n19.get(r8);
            a30 && "object" == typeof a30 ? Object.assign(o12, a30) : t7[s12] = a30;
          } else
            M3({ renderingRule: o12, templates: n19 });
      }));
    else {
      if (!n19.has(r8))
        throw new s("raster-function-helper", `unsupported raster function json. _object_ref_id: ${r8} does not exist`);
      const t8 = n19.get(r8);
      "_object_ref_id" !== s11 ? o11[s11] = t8 : t8 && "object" == typeof t8 && Object.assign(o11, t8);
    }
  }
}
function $2(t6) {
  var _a;
  ((_a = t6.Statistics) == null ? void 0 : _a.length) && "object" == typeof t6.Statistics && (t6.Statistics = t6.Statistics.map((t7) => [t7.min, t7.max, t7.mean, t7.standardDeviation])), null != t6.NumberOfStandardDeviation && (t6.NumberOfStandardDeviations = t6.NumberOfStandardDeviation, delete t6.NumberOfStandardDeviation);
}
function E2(t6) {
  var _a, _b;
  "randomcolorramp" === ((_b = (_a = t6.ColorRamp) == null ? void 0 : _a.type) == null ? void 0 : _b.toLowerCase()) && (delete t6.ColorRamp, t6.ColormapName = "Random"), 0 === t6.ColorSchemeType && delete t6.ColorRamp;
}
function L2(t6) {
  null != t6.ConvolutionType && (t6.Type = t6.ConvolutionType, delete t6.ConvolutionType);
}
function O2(t6) {
  var _a;
  ((_a = t6.NoDataValues) == null ? void 0 : _a.length) && "string" == typeof t6.NoDataValues[0] && (t6.NoDataValues = t6.NoDataValues.filter((t7) => "" !== t7).map((t7) => Number(t7)));
}
C3.set("Arithmetic", { desc: "Arithmetic Function", ctor: a8, rasterArgumentNames: ["rasters"] }), C3.set("Aspect", { desc: "Aspect Function", ctor: p9, rasterArgumentNames: ["raster"] }), C3.set("BandArithmetic", { desc: "Band Arithmetic Function", ctor: u7, rasterArgumentNames: ["raster"] }), C3.set("Colormap", { desc: "Colormap Function", ctor: u9, rasterArgumentNames: ["raster"] }), C3.set("CompositeBand", { desc: "CompositeBand Function", ctor: a15, rasterArgumentNames: ["rasters"] }), C3.set("Convolution", { desc: "Convolution Function", ctor: p15, rasterArgumentNames: ["raster"] }), C3.set("ContrastBrightness", { desc: "Contrast Brightness Function", ctor: p13, rasterArgumentNames: ["raster"] }), C3.set("ExtractBand", { desc: "ExtractBand Function", ctor: l11, rasterArgumentNames: ["raster"] }), C3.set("Curvature", { desc: "Curvature Function", ctor: c13, rasterArgumentNames: ["raster"] }), C3.set("Grayscale", { desc: "Grayscale Function", ctor: u14, rasterArgumentNames: ["raster"] }), C3.set("Clip", { desc: "Clip Function", ctor: p12, rasterArgumentNames: ["raster"] }), C3.set("Local", { desc: "Local Function", ctor: d6, rasterArgumentNames: ["rasters"] }), C3.set("Mask", { desc: "Mask Function", ctor: p16, rasterArgumentNames: ["raster"] }), C3.set("NDVI", { desc: "NDVI Function", ctor: a21, rasterArgumentNames: ["raster"] }), C3.set("Remap", { desc: "Remap Function", ctor: g5, rasterArgumentNames: ["raster"] }), C3.set("Slope", { desc: "Slope Function", ctor: c20, rasterArgumentNames: ["raster"] }), C3.set("Statistics", { desc: "Focal Statistics Function", ctor: p19, rasterArgumentNames: ["raster"] }), C3.set("StatisticsHistogram", { desc: "Statistics Histogram Function", ctor: n15, rasterArgumentNames: ["raster"] }), C3.set("Stretch", { desc: "Stretch Function", ctor: l14, rasterArgumentNames: ["raster"] }), C3.set("Table", { desc: "Attribute Table Function", ctor: n17, rasterArgumentNames: ["raster"] });

// node_modules/@arcgis/core/layers/support/rasterTransforms/BaseRasterTransform.js
var t5 = class extends f {
  get affectsPixelSize() {
    return false;
  }
  forwardTransform(r7) {
    return r7;
  }
  inverseTransform(r7) {
    return r7;
  }
};
e([y()], t5.prototype, "affectsPixelSize", null), e([y({ json: { write: true } })], t5.prototype, "spatialReference", void 0), t5 = e([a2("esri.layers.support.rasterTransforms.BaseRasterTransform")], t5);
var a26 = t5;

// node_modules/@arcgis/core/layers/support/rasterTransforms/GCSShiftTransform.js
var a27;
var n18 = a27 = class extends a26 {
  constructor() {
    super(...arguments), this.type = "gcs-shift", this.tolerance = 1e-8;
  }
  forwardTransform(r7) {
    return "point" === (r7 = r7.clone()).type ? (r7.x > 180 + this.tolerance && (r7.x -= 360), r7) : (r7.xmin >= 180 - this.tolerance ? (r7.xmax -= 360, r7.xmin -= 360) : r7.xmax > 180 + this.tolerance && (r7.xmin = -180, r7.xmax = 180), r7);
  }
  inverseTransform(r7) {
    return "point" === (r7 = r7.clone()).type ? (r7.x < -this.tolerance && (r7.x += 360), r7) : (r7.xmin < -this.tolerance && (r7.xmin += 360, r7.xmax += 360), r7);
  }
  clone() {
    return new a27({ tolerance: this.tolerance });
  }
};
e([o2({ GCSShiftXform: "gcs-shift" })], n18.prototype, "type", void 0), e([y()], n18.prototype, "tolerance", void 0), n18 = a27 = e([a2("esri.layers.support.rasterTransforms.GCSShiftTransform")], n18);
var c27 = n18;

// node_modules/@arcgis/core/layers/support/rasterTransforms/IdentityTransform.js
var e9;
var a28 = e9 = class extends a26 {
  constructor() {
    super(...arguments), this.type = "identity";
  }
  clone() {
    return new e9();
  }
};
e([o2({ IdentityXform: "identity" })], a28.prototype, "type", void 0), a28 = e9 = e([a2("esri.layers.support.rasterTransforms.IdentityTransform")], a28);
var p22 = a28;

// node_modules/@arcgis/core/layers/support/rasterTransforms/PolynomialTransform.js
var l15;
function a29(e11, r7, o11) {
  const { x: t6, y: s11 } = r7;
  if (o11 < 2) {
    return { x: e11[0] + t6 * e11[2] + s11 * e11[4], y: e11[1] + t6 * e11[3] + s11 * e11[5] };
  }
  if (2 === o11) {
    const r8 = t6 * t6, o12 = s11 * s11, i29 = t6 * s11;
    return { x: e11[0] + t6 * e11[2] + s11 * e11[4] + r8 * e11[6] + i29 * e11[8] + o12 * e11[10], y: e11[1] + t6 * e11[3] + s11 * e11[5] + r8 * e11[7] + i29 * e11[9] + o12 * e11[11] };
  }
  const i28 = t6 * t6, n19 = s11 * s11, f7 = t6 * s11, p23 = i28 * t6, l16 = i28 * s11, a30 = t6 * n19, c29 = s11 * n19;
  return { x: e11[0] + t6 * e11[2] + s11 * e11[4] + i28 * e11[6] + f7 * e11[8] + n19 * e11[10] + p23 * e11[12] + l16 * e11[14] + a30 * e11[16] + c29 * e11[18], y: e11[1] + t6 * e11[3] + s11 * e11[5] + i28 * e11[7] + f7 * e11[9] + n19 * e11[11] + p23 * e11[13] + l16 * e11[15] + a30 * e11[17] + c29 * e11[19] };
}
function c28(e11, r7, o11) {
  const { xmin: t6, ymin: s11, xmax: i28, ymax: n19, spatialReference: f7 } = r7;
  let l16 = [];
  if (o11 < 2)
    l16.push({ x: t6, y: n19 }), l16.push({ x: i28, y: n19 }), l16.push({ x: t6, y: s11 }), l16.push({ x: i28, y: s11 });
  else {
    let e12 = 10;
    for (let r8 = 0; r8 < e12; r8++)
      l16.push({ x: t6, y: s11 + (n19 - s11) * r8 / (e12 - 1) }), l16.push({ x: i28, y: s11 + (n19 - s11) * r8 / (e12 - 1) });
    e12 = 8;
    for (let r8 = 1; r8 <= e12; r8++)
      l16.push({ x: t6 + (i28 - t6) * r8 / e12, y: s11 }), l16.push({ x: t6 + (i28 - t6) * r8 / e12, y: n19 });
  }
  l16 = l16.map((r8) => a29(e11, r8, o11));
  const c29 = l16.map((e12) => e12.x), m10 = l16.map((e12) => e12.y);
  return new w({ xmin: Math.min.apply(null, c29), xmax: Math.max.apply(null, c29), ymin: Math.min.apply(null, m10), ymax: Math.max.apply(null, m10), spatialReference: f7 });
}
function m9(e11) {
  const [r7, o11, t6, s11, i28, n19] = e11, f7 = t6 * n19 - i28 * s11, p23 = i28 * s11 - t6 * n19;
  return [(i28 * o11 - r7 * n19) / f7, (t6 * o11 - r7 * s11) / p23, n19 / f7, s11 / p23, -i28 / f7, -t6 / p23];
}
var u17 = l15 = class extends a26 {
  constructor() {
    super(...arguments), this.polynomialOrder = 1, this.type = "polynomial";
  }
  readForwardCoefficients(e11, r7) {
    const { coeffX: o11, coeffY: t6 } = r7;
    if (!(o11 == null ? void 0 : o11.length) || !(t6 == null ? void 0 : t6.length) || o11.length !== t6.length)
      return null;
    const s11 = [];
    for (let i28 = 0; i28 < o11.length; i28++)
      s11.push(o11[i28]), s11.push(t6[i28]);
    return s11;
  }
  writeForwardCoefficients(e11, r7, o11) {
    const t6 = [], s11 = [];
    for (let i28 = 0; i28 < (e11 == null ? void 0 : e11.length); i28++)
      i28 % 2 == 0 ? t6.push(e11[i28]) : s11.push(e11[i28]);
    r7.coeffX = t6, r7.coeffY = s11;
  }
  get inverseCoefficients() {
    let e11 = this._get("inverseCoefficients");
    const r7 = this._get("forwardCoefficients");
    return !e11 && r7 && this.polynomialOrder < 2 && (e11 = m9(r7)), e11;
  }
  set inverseCoefficients(e11) {
    this._set("inverseCoefficients", e11);
  }
  readInverseCoefficients(e11, r7) {
    const { inverseCoeffX: o11, inverseCoeffY: t6 } = r7;
    if (!(o11 == null ? void 0 : o11.length) || !(t6 == null ? void 0 : t6.length) || o11.length !== t6.length)
      return null;
    const s11 = [];
    for (let i28 = 0; i28 < o11.length; i28++)
      s11.push(o11[i28]), s11.push(t6[i28]);
    return s11;
  }
  writeInverseCoefficients(e11, r7, o11) {
    const t6 = [], s11 = [];
    for (let i28 = 0; i28 < (e11 == null ? void 0 : e11.length); i28++)
      i28 % 2 == 0 ? t6.push(e11[i28]) : s11.push(e11[i28]);
    r7.inverseCoeffX = t6, r7.inverseCoeffY = s11;
  }
  get affectsPixelSize() {
    return this.polynomialOrder > 0;
  }
  forwardTransform(e11) {
    if ("point" === e11.type) {
      const r7 = a29(this.forwardCoefficients, e11, this.polynomialOrder);
      return new x({ x: r7.x, y: r7.y, spatialReference: e11.spatialReference });
    }
    return c28(this.forwardCoefficients, e11, this.polynomialOrder);
  }
  inverseTransform(e11) {
    if ("point" === e11.type) {
      const r7 = a29(this.inverseCoefficients, e11, this.polynomialOrder);
      return new x({ x: r7.x, y: r7.y, spatialReference: e11.spatialReference });
    }
    return c28(this.inverseCoefficients, e11, this.polynomialOrder);
  }
  clone() {
    return new l15({ polynomialOrder: this.polynomialOrder, forwardCoefficients: this.forwardCoefficients ? [...this.forwardCoefficients] : null, inverseCoefficients: this.inverseCoefficients ? [...this.inverseCoefficients] : null });
  }
};
e([y({ json: { write: true } })], u17.prototype, "polynomialOrder", void 0), e([y()], u17.prototype, "forwardCoefficients", void 0), e([o("forwardCoefficients", ["coeffX", "coeffY"])], u17.prototype, "readForwardCoefficients", null), e([r("forwardCoefficients")], u17.prototype, "writeForwardCoefficients", null), e([y({ json: { write: true } })], u17.prototype, "inverseCoefficients", null), e([o("inverseCoefficients", ["inverseCoeffX", "inverseCoeffY"])], u17.prototype, "readInverseCoefficients", null), e([r("inverseCoefficients")], u17.prototype, "writeInverseCoefficients", null), e([y()], u17.prototype, "affectsPixelSize", null), e([o2({ PolynomialXform: "polynomial" })], u17.prototype, "type", void 0), u17 = l15 = e([a2("esri.layers.support.rasterTransforms.PolynomialTransform")], u17);
var y7 = u17;

// node_modules/@arcgis/core/layers/support/rasterTransforms/utils.js
var o10 = { GCSShiftXform: c27, IdentityXform: p22, PolynomialXform: y7 };
var e10 = Object.keys(o10);
function f6(r7) {
  const t6 = r7 == null ? void 0 : r7.type;
  return !r7 || e10.includes(t6);
}
function i27(r7) {
  const t6 = r7 == null ? void 0 : r7.type;
  if (!t6)
    return null;
  const n19 = o10[r7 == null ? void 0 : r7.type];
  if (n19) {
    const t7 = new n19();
    return t7.read(r7), t7;
  }
  return null;
}

export {
  N2 as N,
  R2 as R,
  c27 as c,
  y7 as y,
  f6 as f,
  i27 as i
};
//# sourceMappingURL=chunk-6IGKQIMQ.js.map
