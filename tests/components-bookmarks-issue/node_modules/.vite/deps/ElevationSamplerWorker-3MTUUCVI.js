import {
  h
} from "./chunk-UQEUYEWU.js";
import "./chunk-5LIYYE75.js";
import {
  P
} from "./chunk-XJICXW6N.js";
import "./chunk-YF5E2R37.js";
import "./chunk-R4SGP2EA.js";
import "./chunk-IRL6OOVK.js";
import "./chunk-3AIILHI5.js";
import {
  g
} from "./chunk-QJRGTKPN.js";
import "./chunk-VIH3KDZO.js";
import "./chunk-LA365FE7.js";
import "./chunk-WIVZ7SMV.js";
import "./chunk-O76UVYOO.js";
import "./chunk-QCMUK3QA.js";
import "./chunk-HZSGATFT.js";
import "./chunk-KNMQQRV7.js";
import "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import "./chunk-D25BO7X7.js";
import "./chunk-NDIXNREV.js";
import "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import "./chunk-7RBRCL6S.js";
import {
  has
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/ElevationSamplerWorker.js
var r = class {
  async createIndex(e, n) {
    var _a;
    const r2 = new Array();
    if (!((_a = e.vertexAttributes) == null ? void 0 : _a.position))
      return new h();
    const o2 = i(e), s2 = null != n ? await n.invoke("createIndexThread", o2, { transferList: r2 }) : this.createIndexThread(o2).result;
    return a().fromJSON(s2);
  }
  createIndexThread(t) {
    const e = new Float64Array(t.position), n = a();
    return t.components ? s(n, e, t.components.map((t2) => new Uint32Array(t2))) : o(n, e);
  }
};
function o(t, e) {
  const n = new Array(e.length / 9);
  let r2 = 0;
  for (let o2 = 0; o2 < e.length; o2 += 9)
    n[r2++] = c(e, o2, o2 + 3, o2 + 6);
  return t.load(n), { result: t.toJSON() };
}
function s(t, e, n) {
  let r2 = 0;
  for (const i2 of n)
    r2 += i2.length / 3;
  const o2 = new Array(r2);
  let s2 = 0;
  for (const i2 of n)
    for (let t2 = 0; t2 < i2.length; t2 += 3)
      o2[s2++] = c(e, 3 * i2[t2], 3 * i2[t2 + 1], 3 * i2[t2 + 2]);
  return t.load(o2), { result: t.toJSON() };
}
function i(t) {
  const r2 = (g(t.vertexSpace) ? P({ position: t.vertexAttributes.position, normal: null, tangent: null }, t.vertexSpace, t.transform, t.spatialReference).position : t.vertexAttributes.position).buffer;
  return !t.components || t.components.some((t2) => !t2.faces) ? { position: r2 } : { position: r2, components: t.components.map((t2) => t2.faces) };
}
function a() {
  return new h(9, has("esri-csp-restrictions") ? (t) => t : [".minX", ".minY", ".maxX", ".maxY"]);
}
function c(t, e, n, r2) {
  return { minX: Math.min(t[e], t[n], t[r2]), maxX: Math.max(t[e], t[n], t[r2]), minY: Math.min(t[e + 1], t[n + 1], t[r2 + 1]), maxY: Math.max(t[e + 1], t[n + 1], t[r2 + 1]), p0: [t[e], t[e + 1], t[e + 2]], p1: [t[n], t[n + 1], t[n + 2]], p2: [t[r2], t[r2 + 1], t[r2 + 2]] };
}
export {
  r as default
};
//# sourceMappingURL=ElevationSamplerWorker-3MTUUCVI.js.map
