import {
  w as w2
} from "./chunk-6SB3EFZU.js";
import {
  g as g3
} from "./chunk-WOKVMRAD.js";
import {
  T,
  e as e3,
  i as i2
} from "./chunk-46T3D2EU.js";
import {
  w
} from "./chunk-KWLN46JY.js";
import {
  g as g2
} from "./chunk-SA77Z3WI.js";
import {
  d as d2
} from "./chunk-FQLGRQKL.js";
import {
  E,
  F,
  S,
  e as e2,
  j,
  t
} from "./chunk-Z2F5OKVA.js";
import {
  d,
  i,
  l
} from "./chunk-BOAEEYBE.js";
import {
  J
} from "./chunk-2ICUS4HL.js";
import {
  P,
  _,
  e,
  g,
  r,
  s,
  u
} from "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";

// node_modules/@arcgis/core/views/3d/interactive/editingTools/dragEventPipeline3D.js
function U(e4, n2) {
  return C(e4, () => n2);
}
function O(e4) {
  return C(e4, (e5) => e5.plane);
}
function C(r2, t2) {
  const o = n(), l2 = n();
  let s2 = false;
  return (c) => {
    const i3 = t2(c);
    if ("start" === c.action) {
      const t3 = d(c.screenStart, l(t.get())), l3 = g3(r2.state.camera, t3, B);
      null != l3 && (s2 = S(i3, l3, o));
    }
    if (!s2)
      return null;
    const a = d(c.screenEnd, l(t.get())), u2 = g3(r2.state.camera, a, B);
    return null == u2 ? null : S(i3, u2, l2) ? { ...c, renderStart: o, renderEnd: l2, plane: i3, ray: u2 } : null;
  };
}
function P2(e4, n2, t2 = 0, o = null, l2 = null) {
  let s2 = null;
  return (c) => {
    if ("start" === c.action && (s2 = e4.sceneIntersectionHelper.intersectElevationFromScreen(i(c.screenStart.x, c.screenStart.y), n2, t2, l2), null != s2 && null != o && !J(s2, s2, o)))
      return null;
    if (null == s2)
      return null;
    const i3 = e4.sceneIntersectionHelper.intersectElevationFromScreen(i(c.screenEnd.x, c.screenEnd.y), n2, t2, l2);
    return null != i3 && (null == o || J(i3, i3, o)) ? { ...c, mapStart: s2, mapEnd: i3 } : null;
  };
}
function T2(e4, n2, r2, t2 = null, o = null) {
  return P2(e4, r2, g2(n2, e4, r2), t2, o);
}
function D(e4, n2, r2, t2) {
  const o = r2.toMap(e4.screenStart);
  return null != o ? T2(n2, o, r2.elevationInfo, t2) : null;
}
function M(e4, n2) {
  const r2 = q, t2 = z, o = E();
  e4.renderCoordsHelper.worldUpAtPosition(n2, r2);
  const c = _(F(o), r2, e(t2, n2, e4.state.camera.eye));
  return _(c, c, r2), j(n2, c, o);
}
function N(e4, n2, r2) {
  let t2 = null;
  const o = new w2();
  return o.next(U(e4, M(e4, n2))).next(h(e4, n2)).next(k(e4, r2)).next((e5) => {
    e5.mapEnd.x = e5.mapStart.x, e5.mapEnd.y = e5.mapStart.y, t2 = e5;
  }), (e5) => (t2 = null, o.execute(e5), t2);
}
function h(e4, n2) {
  const r2 = n(), l2 = s(n2);
  e4.renderCoordsHelper.worldUpAtPosition(n2, r2);
  const p = n(), m = n(), d3 = (o) => {
    if (e(o, o, n2), e2(r2, o, o), "global" === e4.viewingMode) {
      s(o) * Math.sign(P(r2, o)) < 1e-3 - l2 && e(o, g(o, r2, 1e-3), n2);
    }
    return u(o, o, n2), o;
  };
  return (e5) => (e5.renderStart = d3(r(p, e5.renderStart)), e5.renderEnd = d3(r(m, e5.renderEnd)), e5);
}
function k(e4, n2) {
  const r2 = e4.renderCoordsHelper;
  return (e5) => {
    const t2 = r2.fromRenderCoords(e5.renderStart, new x({ spatialReference: n2 })), o = r2.fromRenderCoords(e5.renderEnd, new x({ spatialReference: n2 }));
    return null != t2 && null != o ? { ...e5, mapStart: t2, mapEnd: o } : null;
  };
}
var G;
function A(e4) {
  let n2 = null;
  return (r2) => {
    switch (r2.action) {
      case "start":
        n2 = e4.disableDisplay();
        break;
      case "end":
      case "cancel":
        null != n2 && (n2.remove(), n2 = null);
    }
    return r2;
  };
}
function F2(n2, t2 = null) {
  const o = T(n2.state.viewingMode);
  o.options.selectionMode = true, o.options.store = e3.MIN, o.options.hud = false;
  const l2 = i(), s2 = { requiresGroundFeedback: true, enableDraped: true, exclude: /* @__PURE__ */ new Set() }, c = n(), i3 = t2 ?? n2.spatialReference, a = (r2) => {
    n2.map.ground && n2.map.ground.opacity < 1 ? s2.exclude.add(w) : s2.exclude.delete(w), n2.sceneIntersectionHelper.intersectIntersectorScreen(d(r2, l2), o, s2);
    const t3 = o.results.min;
    let a2;
    if (t3.getIntersectionPoint(c))
      a2 = t3.intersector === i2.TERRAIN ? G.GROUND : G.OTHER;
    else {
      if (!o.results.ground.getIntersectionPoint(c))
        return null;
      a2 = G.GROUND;
    }
    return { location: n2.renderCoordsHelper.fromRenderCoords(c, new x({ spatialReference: i3 })), surfaceType: a2 };
  };
  let p;
  return (e4) => {
    if ("start" === e4.action) {
      const n4 = a(e4.screenStart);
      p = null != n4 ? n4.location : null;
    }
    if (null == p)
      return null;
    const n3 = a(e4.screenEnd);
    return null != (n3 == null ? void 0 : n3.location) ? { ...e4, mapStart: p, mapEnd: n3.location, surfaceType: n3.surfaceType } : null;
  };
}
!function(e4) {
  e4[e4.GROUND = 0] = "GROUND", e4[e4.OTHER = 1] = "OTHER";
}(G || (G = {}));
var q = n();
var z = n();
var B = d2();

export {
  U,
  O,
  T2 as T,
  D,
  N,
  k,
  G,
  A,
  F2 as F
};
//# sourceMappingURL=chunk-RYDZOUU4.js.map
