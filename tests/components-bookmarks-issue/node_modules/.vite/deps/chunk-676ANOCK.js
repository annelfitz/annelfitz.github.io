import {
  f as f3,
  g
} from "./chunk-6K2UNRXT.js";
import {
  n as n2
} from "./chunk-D56W4LPT.js";
import {
  e as e2,
  n as n3
} from "./chunk-CSSLIU64.js";
import {
  I
} from "./chunk-5DH2QVPW.js";
import {
  I as I2,
  J
} from "./chunk-GPWQGIYV.js";
import {
  Z
} from "./chunk-XMYPMIYH.js";
import {
  b
} from "./chunk-W5ALAOW2.js";
import {
  R
} from "./chunk-WIVZ7SMV.js";
import {
  a as a2
} from "./chunk-O76UVYOO.js";
import {
  e
} from "./chunk-N5GQOIDP.js";
import {
  h
} from "./chunk-HWHMO3CO.js";
import {
  F
} from "./chunk-2ICUS4HL.js";
import {
  D,
  E,
  f as f2,
  u
} from "./chunk-C7NPPGFR.js";
import {
  O,
  o,
  r
} from "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  s3 as s2
} from "./chunk-UWQ3OYA5.js";
import {
  U
} from "./chunk-SAYWXQVM.js";
import {
  s
} from "./chunk-7RBRCL6S.js";
import {
  a2 as a,
  c3 as c,
  has,
  m,
  x
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SProjectionUtil.js
function i(o2, r2, i2, n5) {
  const s4 = e3(o2, r2, i2), c2 = e();
  return R(i2, s4, c2, n5), c2;
}
var n4 = 1;
var s3 = 5 - n4;
function e3(t, a3, i2) {
  const e4 = n(), c2 = t[3], m2 = 2 ** (Math.ceil(Math.log(c2) * Math.LOG2E / s3) * s3 + n4);
  if (i2.isGeographic) {
    const o2 = m2 / s2(i2).radius * 180 / Math.PI, a4 = Math.round(t[1] / o2), n5 = Math.max(-90, Math.min(90, a4 * o2)), s4 = o2 / Math.cos((Math.abs(n5) - o2 / 2) / 180 * Math.PI), c3 = Math.round(t[0] / s4) * s4;
    e4[0] = c3, e4[1] = n5;
  } else {
    const o2 = Math.round(t[0] / m2), r2 = Math.round(t[1] / m2);
    e4[0] = o2 * m2, e4[1] = r2 * m2;
  }
  const h2 = t[2] + a3, M = Math.round(h2 / m2);
  return e4[2] = M * m2, e4;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SUtil.js
function U2(e4) {
  return e4 ? parseInt(e4.substring(e4.lastIndexOf("/") + 1, e4.length), 10) : void 0;
}
function N(e4) {
  var _a;
  if (has("disable-feature:i3s-draco") || !e4)
    return false;
  for (const t of e4)
    for (const e5 of t.geometryBuffers)
      if ("draco" === ((_a = e5.compressedAttributes) == null ? void 0 : _a.encoding))
        return true;
  return false;
}
function k(e4, t, r2, o2) {
  r2.traverse(t, (t2) => {
    const r3 = t2.serviceMbsInIndexSR;
    return (null != r3 && O2(e4, r3)) !== F2.OUTSIDE && (o2(t2), true);
  });
}
function D2(e4, t, r2) {
  let o2 = 0, n5 = 0;
  for (let i2 = 0; i2 < t.length && o2 < e4.length; i2++)
    e4[o2] === t[i2] && (r2(i2) && (e4[n5] = e4[o2], n5++), o2++);
  e4.length = n5;
}
function W(e4, r2, o2) {
  let n5 = 0, i2 = 0;
  for (; n5 < o2.length; ) {
    x(e4, o2[n5]) >= 0 === r2 && (o2[i2] = o2[n5], i2++), n5++;
  }
  o2.length = i2;
}
var _ = u();
function q(e4, t) {
  if (0 === t.rotationScale[1] && 0 === t.rotationScale[2] && 0 === t.rotationScale[3] && 0 === t.rotationScale[5] && 0 === t.rotationScale[6] && 0 === t.rotationScale[7])
    return _[0] = (e4[0] - t.position[0]) / t.rotationScale[0], _[1] = (e4[1] - t.position[1]) / t.rotationScale[4], _[2] = (e4[2] - t.position[0]) / t.rotationScale[0], _[3] = (e4[3] - t.position[1]) / t.rotationScale[4], _;
}
var F2;
function O2(e4, t) {
  const r2 = t[0], o2 = t[1], n5 = t[3], i2 = e4[0] - r2, a3 = r2 - e4[2], s4 = e4[1] - o2, l = o2 - e4[3], c2 = Math.max(i2, a3, 0), u2 = Math.max(s4, l, 0), f4 = c2 * c2 + u2 * u2;
  if (f4 > n5 * n5)
    return F2.OUTSIDE;
  if (f4 > 0)
    return F2.INTERSECTS_CENTER_OUTSIDE;
  return -Math.max(i2, a3, s4, l) > n5 ? F2.INSIDE : F2.INTERSECTS_CENTER_INSIDE;
}
function L(e4, t, r2) {
  const o2 = [], n5 = r2 == null ? void 0 : r2.missingFields, i2 = r2 == null ? void 0 : r2.originalFields;
  for (const a3 of e4) {
    const e5 = a3.toLowerCase();
    let r3 = false;
    for (const n6 of t)
      if (e5 === n6.name.toLowerCase()) {
        o2.push(n6.name), r3 = true, i2 && i2.push(a3);
        break;
      }
    !r3 && n5 && n5.push(a3);
  }
  return o2;
}
async function A(e4, t, r2, n5, i2, a3) {
  if (0 === t.length)
    return [];
  const s4 = e4.attributeStorageInfo;
  if (null != e4.associatedLayer)
    try {
      return await P(e4.associatedLayer, t, r2, n5, a3);
    } catch (l) {
      if (e4.associatedLayer.loaded)
        throw l;
    }
  if (s4) {
    const l = K(t, r2, i2);
    if (null == l)
      throw new s("scenelayer:features-not-loaded", "Tried to query attributes for unloaded features");
    const c2 = e4.parsedUrl.path;
    return (await Promise.all(l.map((t2) => G(c2, s4, t2.node, t2.indices, n5, e4.apiKey, e4.customParameters, a3).then((e5) => {
      for (let r3 = 0; r3 < t2.graphics.length; r3++) {
        const o2 = t2.graphics[r3], n6 = e5[r3];
        if (o2.attributes)
          for (const e6 in o2.attributes)
            e6 in n6 || (n6[e6] = o2.attributes[e6]);
        o2.attributes = n6;
      }
      return t2.graphics;
    })))).flat();
  }
  throw new s("scenelayer:no-attribute-source", "This scene layer does not have a source for attributes available");
}
function K(e4, t, r2) {
  const o2 = /* @__PURE__ */ new Map(), n5 = [], i2 = r2();
  for (const a3 of e4) {
    const e5 = a3.attributes[t];
    for (let t2 = 0; t2 < i2.length; t2++) {
      const r3 = i2[t2], s4 = r3.featureIds.indexOf(e5);
      if (s4 >= 0) {
        let e6 = o2.get(r3.node);
        e6 || (e6 = { node: r3.node, indices: [], graphics: [] }, n5.push(e6), o2.set(r3.node, e6)), e6.indices.push(s4), e6.graphics.push(a3);
        for (let r4 = t2; r4 > 0; r4--)
          i2[r4] = i2[r4 - 1];
        i2[0] = r3;
        break;
      }
    }
  }
  return n5;
}
async function P(e4, t, r2, o2, n5) {
  t.sort((e5, t2) => e5.attributes[r2] - t2.attributes[r2]);
  const i2 = t.map((e5) => e5.attributes[r2]), a3 = [], s4 = L(o2, e4.fields, { originalFields: a3 }), l = await B(e4, i2, s4, n5);
  for (let c2 = 0; c2 < t.length; c2++) {
    const e5 = t[c2], r3 = l[c2], o3 = {};
    if (e5.attributes)
      for (const t2 in e5.attributes)
        o3[t2] = e5.attributes[t2];
    for (let t2 = 0; t2 < a3.length; t2++)
      o3[a3[t2]] = r3[s4[t2]];
    e5.attributes = o3;
  }
  return t;
}
function B(e4, t, n5, i2) {
  const a3 = e4.capabilities.query.maxRecordCount;
  if (null != a3 && t.length > a3) {
    const o2 = m(t, a3);
    return Promise.all(o2.map((t2) => B(e4, t2, n5, i2))).then((e5) => e5.flat());
  }
  const s4 = new b({ objectIds: t, outFields: n5, orderByFields: [e4.objectIdField] });
  return e4.queryFeatures(s4, i2).then((e5) => {
    if (e5 && e5.features && e5.features.length === t.length)
      return e5.features.map((e6) => e6.attributes);
    throw new s("scenelayer:feature-not-in-associated-layer", "Feature not found in associated feature layer");
  });
}
function G(e4, t, r2, o2, n5, i2, a3, s4) {
  return $(e4, t, r2.resources.attributes, o2, n5, i2, a3, s4);
}
async function $(t, r2, o2, n5, i2, a3, s4, l) {
  const c2 = [];
  for (const e4 of r2)
    if (e4 && i2.includes(e4.name)) {
      const r3 = `${t}/nodes/${o2}/attributes/${e4.key}/0`;
      c2.push({ url: r3, storageInfo: e4 });
    }
  const u2 = await Promise.allSettled(c2.map((t2) => U(t2.url, { responseType: "array-buffer", query: { ...s4, token: a3 }, signal: l == null ? void 0 : l.signal }).then((e4) => I(t2.storageInfo, e4.data)))), f4 = [];
  for (const e4 of n5) {
    const t2 = {};
    for (let r3 = 0; r3 < u2.length; r3++) {
      const o3 = u2[r3];
      if ("fulfilled" === o3.status) {
        const n6 = o3.value;
        t2[c2[r3].storageInfo.name] = Q(n6, e4);
      }
    }
    f4.push(t2);
  }
  return f4;
}
!function(e4) {
  e4[e4.OUTSIDE = 0] = "OUTSIDE", e4[e4.INTERSECTS_CENTER_OUTSIDE = 1] = "INTERSECTS_CENTER_OUTSIDE", e4[e4.INTERSECTS_CENTER_INSIDE = 2] = "INTERSECTS_CENTER_INSIDE", e4[e4.INSIDE = 3] = "INSIDE";
}(F2 || (F2 = {}));
var z = -32768;
var V = -(2 ** 31);
function Q(e4, t) {
  if (!e4)
    return null;
  const r2 = e4[t];
  if (c(e4))
    return r2 === z ? null : r2;
  if (a(e4))
    return r2 === V ? null : r2;
  return r2 != r2 ? null : r2;
}
function Z2(e4) {
  const t = e4.store, r2 = t.indexCRS || t.geographicCRS, n5 = void 0 === r2 ? t.indexWKT : void 0;
  if (n5) {
    if (!e4.spatialReference)
      throw new s("layerview:no-store-spatial-reference-wkt-index-and-no-layer-spatial-reference", "Found indexWKT in the scene layer store but no layer spatial reference", {});
    if (n5 !== e4.spatialReference.wkt)
      throw new s("layerview:store-spatial-reference-wkt-index-incompatible", "The indexWKT of the scene layer store does not match the WKT of the layer spatial reference", {});
  }
  const i2 = r2 ? new f(U2(r2)) : e4.spatialReference;
  return i2.equals(e4.spatialReference) ? e4.spatialReference : i2;
}
function H(e4) {
  const t = e4.store, r2 = t.vertexCRS || t.projectedCRS, n5 = void 0 === r2 ? t.vertexWKT : void 0;
  if (n5) {
    if (!e4.spatialReference)
      throw new s("layerview:no-store-spatial-reference-wkt-vertex-and-no-layer-spatial-reference", "Found vertexWKT in the scene layer store but no layer spatial reference", {});
    if (n5 !== e4.spatialReference.wkt)
      throw new s("layerview:store-spatial-reference-wkt-vertex-incompatible", "The vertexWKT of the scene layer store does not match the WKT of the layer spatial reference", {});
  }
  const i2 = r2 ? new f(U2(r2)) : e4.spatialReference;
  return i2.equals(e4.spatialReference) ? e4.spatialReference : i2;
}
function J2(e4, t) {
  return null == t ? "@null" : t === a2(t) ? "@ECEF" : e4.equals(t) ? "" : null != t.wkid ? "@" + t.wkid : null;
}
function X(e4, t, r2) {
  if (!F(e4, t))
    throw new s("layerview:spatial-reference-incompatible", "The spatial reference of this scene layer is incompatible with the spatial reference of the view", {});
  if ("local" === r2 && !ee(e4, t))
    throw new s("layerview:spatial-reference-incompatible", "The spatial reference of this scene layer is incompatible with the spatial reference of the view", {});
}
function Y(e4, t, r2) {
  var _a, _b, _c, _d;
  if (((_a = e4.serviceUpdateTimeStamp) == null ? void 0 : _a.lastUpdate) !== ((_b = t.serviceUpdateTimeStamp) == null ? void 0 : _b.lastUpdate) || !r2.isEmpty || ((_c = e4.associatedLayer) == null ? void 0 : _c.url) !== ((_d = t.associatedLayer) == null ? void 0 : _d.url))
    throw new s("layerview:recycle-failed");
}
function ee(e4, t) {
  return e4.equals(t) || e4.isWGS84 && t.isWebMercator || e4.isWebMercator && t.isWGS84;
}
function te(e4, t, r2) {
  const o2 = Z2(e4), n5 = H(e4);
  X(o2, t, r2), X(n5, t, r2);
}
function re(e4) {
  var _a;
  return (null == e4.geometryType || "triangles" === e4.geometryType) && ((null == e4.topology || "PerAttributeArray" === e4.topology) && null != ((_a = e4.vertexAttributes) == null ? void 0 : _a.position));
}
function oe(e4) {
  var _a;
  if (null == ((_a = e4.store) == null ? void 0 : _a.defaultGeometrySchema) || !re(e4.store.defaultGeometrySchema))
    throw new s("scenelayer:unsupported-geometry-schema", "The geometry schema of this scene layer is not supported.", { url: e4.parsedUrl.path });
}
function ne(e4, t) {
  te(e4, t.spatialReference, t.viewingMode);
}
function ie(e4) {
  var _a;
  return null != e4.geometryType && "points" === e4.geometryType && ((null == e4.topology || "PerAttributeArray" === e4.topology) && ((null == e4.encoding || "" === e4.encoding || "lepcc-xyz" === e4.encoding) && null != ((_a = e4.vertexAttributes) == null ? void 0 : _a.position)));
}
function ae(e4) {
  var _a;
  if (null == ((_a = e4.store) == null ? void 0 : _a.defaultGeometrySchema) || !ie(e4.store.defaultGeometrySchema))
    throw new s("pointcloud:unsupported-geometry-schema", "The geometry schema of this point cloud scene layer is not supported.", {});
}
function se(e4, t) {
  X(e4.spatialReference, t.spatialReference, t.viewingMode);
}
function le(e4) {
  return "simple" === e4.type || "class-breaks" === e4.type || "unique-value" === e4.type;
}
function ce(e4) {
  return "mesh-3d" === e4.type;
}
function ue(e4) {
  var _a;
  if (null == e4 || !le(e4))
    return true;
  if (("unique-value" === e4.type || "class-breaks" === e4.type) && null == e4.defaultSymbol)
    return true;
  const t = e4.getSymbols();
  if (0 === t.length)
    return true;
  for (const r2 of t) {
    if (!ce(r2) || 0 === r2.symbolLayers.length)
      return true;
    for (const e5 of r2.symbolLayers.items)
      if ("fill" !== e5.type || null == ((_a = e5.material) == null ? void 0 : _a.color) || "replace" !== e5.material.colorMixMode)
        return true;
  }
  return false;
}
var fe = g({ color: [0, 0, 0, 0], opacity: 0 });
var pe = class {
  constructor() {
    this.edgeMaterial = null, this.material = null, this.castShadows = true;
  }
};
function me(e4) {
  const t = new pe();
  let r2 = false, o2 = false;
  for (const n5 of e4.symbolLayers.items)
    if ("fill" === n5.type && n5.enabled) {
      const e5 = n5.material, i2 = n5.edges;
      if (null != e5 && !r2) {
        const o3 = e5.color, i3 = e2(e5.colorMixMode);
        t.material = null != o3 ? { color: [o3.r / 255, o3.g / 255, o3.b / 255], alpha: o3.a, colorMixMode: i3 } : { color: [1, 1, 1], alpha: 1, colorMixMode: n3.Multiply }, t.castShadows = n5.castShadows, r2 = true;
      }
      null == i2 || o2 || (t.edgeMaterial = f3(i2, {}), o2 = true);
    }
  return t.material || (t.material = { color: [1, 1, 1], alpha: 1, colorMixMode: n3.Multiply }), t;
}
function de(e4, t) {
  return (0 | e4) + (0 | t) | 0;
}
function he(e4, t, r2, o2, n5, i2, s4) {
  if (!i2 || 0 === i2.length || null == t || !e4.serviceMbsInIndexSR)
    return null;
  const f4 = i(e4.serviceMbsInIndexSR, n5, r2, t);
  h(ve, f4);
  let p = null;
  const m2 = () => {
    if (!p)
      if (p = be, D(we), null != e4.serviceObbInIndexSR) {
        e4.serviceObbInIndexSR.transform(Te, r2, t, n5, s4), Te.getCorners(p);
        for (const e5 of p)
          O(e5, e5, ve), f2(we, e5);
      } else {
        const o3 = e4.serviceMbsInIndexSR;
        if (!o3)
          return;
        const i3 = o3[3];
        n2(Z(o3), r2, Ie, t), O(Ie, Ie, ve), Ie[2] += n5;
        for (let e5 = 0; e5 < 8; ++e5) {
          const t2 = 1 & e5 ? i3 : -i3, r3 = 2 & e5 ? i3 : -i3, o4 = 4 & e5 ? i3 : -i3, n6 = p[e5];
          r(n6, [Ie[0] + t2, Ie[1] + r3, Ie[2] + o4]), f2(we, n6);
        }
      }
  };
  let h2 = 1 / 0, w = -1 / 0;
  const T = (e5) => {
    if ("replace" !== e5.type)
      return;
    const r3 = e5.geometry;
    if (!(r3 == null ? void 0 : r3.hasZ))
      return;
    D(Se);
    const n6 = r3.spatialReference || o2, i3 = r3.rings.reduce((e6, r4) => r4.reduce((e7, r5) => (o(Ie, r5[0], r5[1], r5[2]), n2(Ie, n6, Ie, t), O(Ie, Ie, ve), f2(Se, Ie), Math.min(Ie[2], e7)), e6), 1 / 0);
    m2(), E(we, Se) && (h2 = Math.min(h2, i3), w = Math.max(w, i3));
  };
  if (i2.forEach((e5) => T(e5)), h2 === 1 / 0)
    return null;
  const E2 = (e5, t2, r3) => {
    O(Ie, r3, f4), e5[t2] = Ie[0], e5[t2 + 1] = Ie[1], e5[t2 + 2] = Ie[2], t2 += 24, r3[2] = h2, O(Ie, r3, f4), e5[t2] = Ie[0], e5[t2 + 1] = Ie[1], e5[t2 + 2] = Ie[2], t2 += 24, r3[2] = w, O(Ie, r3, f4), e5[t2] = Ie[0], e5[t2 + 1] = Ie[1], e5[t2 + 2] = Ie[2];
  };
  for (let a3 = 0; a3 < 8; ++a3)
    E2(Ee.data, 3 * a3, p[a3]);
  return J(Ee);
}
function ye(e4) {
  return e4[3] >= 0;
}
function ge(e4) {
  null != e4 && (e4[3] = -1);
}
var be = [n(), n(), n(), n(), n(), n(), n(), n()];
var Se = u();
var we = u();
var Te = new I2();
var Ie = n();
var Ee = { data: new Array(72), size: 3, exclusive: true, stride: 3 };
var ve = e();

export {
  i,
  e3 as e,
  N,
  k,
  D2 as D,
  W,
  q,
  F2 as F,
  O2 as O,
  L,
  A,
  $,
  Q,
  Z2 as Z,
  H,
  J2 as J,
  X,
  Y,
  te,
  oe,
  ne,
  ae,
  se,
  ue,
  fe,
  me,
  de,
  he,
  ye,
  ge
};
//# sourceMappingURL=chunk-676ANOCK.js.map
