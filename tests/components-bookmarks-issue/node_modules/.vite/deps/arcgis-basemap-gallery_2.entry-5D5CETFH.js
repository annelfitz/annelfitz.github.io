import {
  onDisconnectedHelper
} from "./chunk-K4WPYNMJ.js";
import {
  importCoreReactiveUtils,
  newViewsMapView,
  newWebMap,
  newWidgetsBasemapGallery
} from "./chunk-YXW2SI4L.js";
import {
  addHandles,
  checkForView,
  isNotSameViewpoint,
  isNullOrEmptyString,
  referenceElementHelper
} from "./chunk-UXZQL3ZN.js";
import {
  createEvent,
  getElement,
  h,
  registerInstance
} from "./chunk-KMIMZXFW.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/map-components/dist/esm/arcgis-basemap-gallery_2.entry.js
var basemapGalleryCss = "";
var ArcgisBasemapGallery = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.arcgisBasemapGalleryReady = createEvent(this, "arcgisBasemapGalleryReady", 7);
    this.arcgisPropertyChange = createEvent(this, "arcgisPropertyChange", 7);
    this._watchHandles = [];
    this.referenceElement = void 0;
    this.activeBasemap = void 0;
    this.disabled = false;
    this.icon = void 0;
    this.source = void 0;
    this.position = "bottom-left";
    this.view = void 0;
    this.widget = void 0;
  }
  referenceElementWatcher(value) {
    void referenceElementHelper(this, value);
  }
  disabledWatcher(value, old) {
    if (this.widget && value !== old) {
      this.widget.disabled = value;
    }
  }
  iconWatcher(value) {
    if (this.widget) {
      this.widget.icon = value;
    }
  }
  sourceWatcher(value) {
    if (this.widget) {
      this.widget.source = value;
    }
  }
  positionWatcher(value) {
    if (value !== void 0 && this.widget) {
      this.view.ui.move(this.childElem, value);
    }
  }
  viewWatcher(value) {
    if (value !== void 0 && this.widget) {
      this.widget.view = value;
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentDidLoad() {
    const params = this._createParams();
    const widget = await newWidgetsBasemapGallery(params);
    this.widget = widget;
    await this._addWatchers();
    this._addContainer();
    this.arcgisBasemapGalleryReady.emit();
    checkForView(this);
  }
  disconnectedCallback() {
    onDisconnectedHelper(this);
  }
  render() {
    return h("div", { ref: (el) => this.childElem = el });
  }
  //--------------------------------------------------------------------------
  //
  //  Private Interal Methods
  //
  //--------------------------------------------------------------------------
  _addContainer() {
    this.widget.container = this.childElem;
  }
  async _addWatchers() {
    const { watch } = await importCoreReactiveUtils();
    addHandles(this, [
      watch(() => this.widget.source, () => this.source = this.widget.source, {
        initial: true
      }),
      watch(() => this.widget.activeBasemap, (basemap) => {
        this.activeBasemap = basemap;
        this.arcgisPropertyChange.emit({ name: "activeBasemap" });
      }, {
        initial: true
      }),
      watch(() => this.widget.disabled, (value) => this.disabled = value)
    ]);
  }
  _createParams() {
    const params = {};
    if (this.icon) {
      params.icon = this.icon;
    }
    if (this.source) {
      params.source = this.source;
    }
    if (this.view) {
      params.view = this.view;
    }
    return params;
  }
  get el() {
    return getElement(this);
  }
  static get watchers() {
    return {
      "referenceElement": ["referenceElementWatcher"],
      "disabled": ["disabledWatcher"],
      "icon": ["iconWatcher"],
      "source": ["sourceWatcher"],
      "position": ["positionWatcher"],
      "view": ["viewWatcher"]
    };
  }
};
ArcgisBasemapGallery.style = basemapGalleryCss;
var mapCss = ".arcgis-map{padding:0;margin:0;height:100%;width:100%}";
var ArcgisMap = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.arcgisViewReadyChange = createEvent(this, "arcgisViewReadyChange", 7);
    this.arcgisViewChange = createEvent(this, "arcgisViewChange", 7);
    this.arcgisViewClick = createEvent(this, "arcgisViewClick", 7);
    this.arcgisViewDoubleClick = createEvent(this, "arcgisViewDoubleClick", 7);
    this.arcgisViewDrag = createEvent(this, "arcgisViewDrag", 7);
    this.arcgisViewHold = createEvent(this, "arcgisViewHold", 7);
    this.arcgisViewImmediateClick = createEvent(this, "arcgisViewImmediateClick", 7);
    this.arcgisViewImmediateDoubleClick = createEvent(this, "arcgisViewImmediateDoubleClick", 7);
    this.arcgisViewKeyDown = createEvent(this, "arcgisViewKeyDown", 7);
    this.arcgisViewKeyUp = createEvent(this, "arcgisViewKeyUp", 7);
    this.arcgisViewLayerviewCreate = createEvent(this, "arcgisViewLayerviewCreate", 7);
    this.arcgisViewLayerviewCreateError = createEvent(this, "arcgisViewLayerviewCreateError", 7);
    this.arcgisViewLayerviewDestroy = createEvent(this, "arcgisViewLayerviewDestroy", 7);
    this.arcgisViewMouseWheel = createEvent(this, "arcgisViewMouseWheel", 7);
    this.arcgisViewPointerDown = createEvent(this, "arcgisViewPointerDown", 7);
    this.arcgisViewPointerEnter = createEvent(this, "arcgisViewPointerEnter", 7);
    this.arcgisViewPointerLeave = createEvent(this, "arcgisViewPointerLeave", 7);
    this.arcgisViewPointerMove = createEvent(this, "arcgisViewPointerMove", 7);
    this.arcgisViewPointerUp = createEvent(this, "arcgisViewPointerUp", 7);
    this._watchHandles = [];
    this.allLayerViews = void 0;
    this.background = void 0;
    this.basemapView = void 0;
    this.basemap = void 0;
    this.center = void 0;
    this.constraints = void 0;
    this.destroyDisabled = false;
    this.extent = void 0;
    this.fatalError = void 0;
    this.floors = void 0;
    this.gamepad = void 0;
    this.graphics = void 0;
    this.highlightOptions = void 0;
    this.interacting = false;
    this.itemId = void 0;
    this.layerViews = void 0;
    this.magnifier = void 0;
    this.map = void 0;
    this.navigating = false;
    this.navigation = void 0;
    this.padding = void 0;
    this.popup = void 0;
    this.popupEnabled = true;
    this.ready = false;
    this.resizeAlign = void 0;
    this.resolution = void 0;
    this.rotation = 0;
    this.scale = void 0;
    this.spatialReference = void 0;
    this.stationary = void 0;
    this.suspended = true;
    this.theme = void 0;
    this.timeExtent = void 0;
    this.timeZone = "system";
    this.toMap = void 0;
    this.toScreen = void 0;
    this.updating = false;
    this.viewpoint = void 0;
    this.zoom = void 0;
    this.view = void 0;
  }
  backgroundWatcher(value) {
    if (this.view) {
      this.background = value;
    }
  }
  basemapWatcher(value) {
    var _a, _b;
    if (typeof value === "string" && ((_a = this.view) == null ? void 0 : _a.map) && !isNullOrEmptyString(value)) {
      this.view.map.basemap = value;
    } else if ((_b = this.view) == null ? void 0 : _b.map) {
      this.view.map.basemap = value;
    }
  }
  centerWatcher(value, old) {
    if (value !== old && this.view) {
      if (typeof value === "string") {
        const center = value.split(",").map((x) => Number(x));
        if (center[0] !== this.view.center.longitude && center[1] !== this.view.center.latitude) {
          this.view.center = center;
        }
      } else if (Array.isArray(value)) {
        if (value[0] !== this.view.center.longitude && value[1] !== this.view.center.latitude) {
          this.view.center = value;
        }
      } else if (!this.view.center.equals(value)) {
        this.view.center = value;
      }
    }
  }
  constraintsWatcher(value) {
    if (this.view) {
      this.view.constraints = value;
    }
  }
  extentWatcher(value) {
    if (this.view && value && !this.view.extent.equals(value)) {
      this.view.extent = value;
    }
  }
  floorsWatcher(value) {
    if (this.view) {
      this.view.floors = value;
    }
  }
  graphicsWatcher(value) {
    if (this.view) {
      this.view.graphics = value;
    }
  }
  highlightOptionsWatcher(value) {
    if (this.view) {
      this.view.highlightOptions = value;
    }
  }
  itemIdWatcher(value, old) {
    var _a;
    if (value !== old) {
      if ((_a = this.view) == null ? void 0 : _a.map) {
        void this._updateMap();
      } else {
        void this._loadMap();
      }
    }
  }
  mapWatcher(value) {
    if (this.view) {
      this.view.map = value;
    }
  }
  navigationWatcher(value) {
    if (this.view) {
      this.view.navigation = value;
    }
  }
  paddingWatcher(value) {
    if (this.view) {
      this.view.padding = value;
    }
  }
  popupWatcher(value) {
    if (this.view) {
      this.view.popup = value;
    }
  }
  popupEnabledWatcher(value, old) {
    if (value !== old && this.view) {
      this.view.popupEnabled = value;
    }
  }
  resizeAlignWatcher(value) {
    if (this.view) {
      this.view.resizeAlign = value;
    }
  }
  rotationWatcher(value) {
    if (this.view && this.view.rotation !== value) {
      this.view.rotation = value;
    }
  }
  scaleWatcher(value, old) {
    var _a;
    if (!((_a = this.view) == null ? void 0 : _a.interacting) && value != null && value !== old) {
      this.view.scale = value;
    }
  }
  spatialReferenceWatcher(value) {
    if (this.view && value && !this.view.spatialReference.equals(value)) {
      this.view.spatialReference = value;
    }
  }
  themeWatcher(value) {
    if (this.view) {
      this.view.theme = value;
    }
  }
  timeExtentWatcher(value) {
    if (this.view) {
      this.view.timeExtent = value;
    }
  }
  timeZoneWatcher(value) {
    if (this.view) {
      this.view.timeZone = value;
    }
  }
  viewpointWatcher(value) {
    if (this.view && isNotSameViewpoint(this.view.viewpoint, value)) {
      this.view.viewpoint = value;
    }
  }
  zoomWatcher(value, old) {
    var _a;
    if (!((_a = this.view) == null ? void 0 : _a.interacting) && value != null && value !== old) {
      this.view.zoom = value;
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Methods
  //
  //--------------------------------------------------------------------------
  /**
   * Closes the popup.
   */
  async closePopup() {
    var _a;
    (_a = this.view) == null ? void 0 : _a.closePopup();
  }
  /**
   * Destroys the view, and any associated resources, including its map, popup, and UI elements.
   */
  async destroy() {
    if (this.destroyDisabled) {
      this._clearWatchHandles();
      this.view.destroy();
    }
  }
  /**
   * Sets the view to a given target.
   */
  async goTo(target, options) {
    var _a;
    return await ((_a = this.view) == null ? void 0 : _a.goTo(target, options));
  }
  /**
   * Returns hit test results from each layer that intersects the specified screen coordinates.
   */
  async hitTest(screenPoint, options) {
    var _a;
    return await ((_a = this.view) == null ? void 0 : _a.hitTest(screenPoint, options));
  }
  /**
   * Opens the popup at the given location with content defined either explicitly with content or driven
   * from the PopupTemplate of input features.
   */
  async openPopup(options) {
    var _a;
    return void ((_a = this.view) == null ? void 0 : _a.openPopup(options));
  }
  /**
   * Create a screenshot of the current view.
   */
  async takeScreenshot(options) {
    var _a;
    return await ((_a = this.view) == null ? void 0 : _a.takeScreenshot(options));
  }
  /**
   * Call this method to clear any fatal errors resulting from a lost WebGL context.
   */
  async tryFatalErrorRecovery() {
    var _a;
    (_a = this.view) == null ? void 0 : _a.tryFatalErrorRecovery();
  }
  /**
   * Gets the LayerView created on the view for the given layer.
   */
  async whenLayerView(layer) {
    var _a;
    return await ((_a = this.view) == null ? void 0 : _a.whenLayerView(layer));
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    if (!this.view) {
      await this._loadMap();
    }
  }
  componentDidRender() {
    if (this.view && !this.view.container) {
      this.view.container = this.el;
    }
  }
  componentDidLoad() {
    this._proxyEvents();
  }
  disconnectedCallback() {
    void this.destroy();
  }
  render() {
    return h("div", { class: "arcgis-map", ref: (el) => this.el = el });
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  _clearWatchHandles() {
    this._watchHandles.forEach((handle) => handle.remove());
    this._watchHandles = [];
  }
  async _addWatchers() {
    const { watch, when } = await importCoreReactiveUtils();
    addHandles(this, [
      // watch for stationary and emit arcgisViewChange event
      watch(() => this.view.stationary, () => {
        this.stationary = this.view.stationary;
        this.interacting = this.view.interacting;
        this.navigating = this.view.navigating;
        this.arcgisViewChange.emit();
      }, {
        initial: true
      }),
      // when view stationary is true, update these props:
      // zoom, scale, center, rotation, extent, camera, viewpoint
      when(() => this.view.stationary, () => {
        this.center = this.view.center;
        this.extent = this.view.extent;
        this.scale = this.view.scale;
        this.viewpoint = this.view.viewpoint;
        this.zoom = this.view.zoom;
        this.spatialReference = this.view.spatialReference;
      }),
      // watchers for other props to update component
      watch(() => this.view.allLayerViews, () => {
        this.allLayerViews = this.view.allLayerViews;
      }, {
        initial: true
      }),
      watch(() => {
        var _a;
        return (_a = this.view.map) == null ? void 0 : _a.basemap;
      }, () => {
        var _a;
        this.basemap = (_a = this.view.map) == null ? void 0 : _a.basemap;
      }, {
        initial: true
      }),
      watch(() => this.view.fatalError, () => {
        this.fatalError = this.view.fatalError;
      }, {
        initial: true
      }),
      watch(() => this.view.input.gamepad, () => {
        this.gamepad = this.view.input.gamepad;
      }, {
        initial: true
      }),
      watch(() => this.view.graphics, () => {
        this.graphics = this.view.graphics;
      }, {
        initial: true
      }),
      watch(() => this.view.layerViews, () => {
        this.layerViews = this.view.layerViews;
      }, {
        initial: true
      }),
      watch(() => this.view.navigation, () => {
        this.navigation = this.view.navigation;
      }, {
        initial: true
      }),
      watch(() => this.view.map, () => {
        this.map = this.view.map;
      }, {
        initial: true
      }),
      watch(() => this.view.popup, () => {
        this.popup = this.view.popup;
      }, {
        initial: true
      }),
      watch(() => this.view.resolution, () => {
        this.resolution = this.view.resolution;
      }, {
        initial: true
      }),
      watch(() => this.view.rotation, () => {
        this.rotation = this.view.rotation;
      }, {
        initial: true
      }),
      watch(() => this.view.suspended, () => {
        this.suspended = this.view.suspended;
      }, {
        initial: true
      }),
      watch(() => this.view.updating, () => {
        this.updating = this.view.updating;
      }, {
        initial: true
      }),
      // watch for ready and emit arcgisViewReadyChange event
      watch(() => this.view.ready, () => {
        this.ready = this.view.ready;
        this.arcgisViewReadyChange.emit();
      }, {
        initial: true
      })
    ]);
  }
  async _createMap() {
    const mapParams = {};
    if (this.itemId) {
      mapParams.portalItem = await this._createPortalItem();
    }
    if (this.basemap) {
      mapParams.basemap = this.basemap;
    } else if (isNullOrEmptyString(this.itemId)) {
      mapParams.basemap = "topo-vector";
    }
    const map = await newWebMap(mapParams);
    return map;
  }
  async _createPortalItem() {
    const itemProps = {};
    if (this.itemId) {
      itemProps.id = this.itemId;
    }
    return itemProps;
  }
  _createViewParams() {
    const params = {};
    if (this.background) {
      params.background = this.background;
    }
    if (this.center) {
      if (typeof this.center === "string") {
        params.center = this.center.split(",").map((x) => Number(x));
      } else {
        params.center = this.center;
      }
    }
    if (this.constraints) {
      params.constraints = this.constraints;
    }
    if (this.extent) {
      params.extent = this.extent;
    }
    if (this.floors) {
      params.floors = this.floors;
    }
    if (this.graphics) {
      params.graphics = this.graphics;
    }
    if (this.highlightOptions) {
      params.highlightOptions = this.highlightOptions;
    }
    if (this.map) {
      params.map = this.map;
    }
    if (this.navigation) {
      params.navigation = this.navigation;
    }
    if (this.padding) {
      params.padding = this.padding;
    }
    if (this.popup) {
      params.popup = this.popup;
    }
    if (this.popupEnabled !== void 0) {
      params.popupEnabled = this.popupEnabled;
    }
    if (this.rotation !== void 0) {
      params.rotation = this.rotation;
    }
    if (this.scale !== void 0) {
      params.scale = this.scale;
    }
    if (this.spatialReference) {
      params.spatialReference = this.spatialReference;
    }
    if (this.theme) {
      params.theme = this.theme;
    }
    if (this.timeExtent) {
      params.timeExtent = this.timeExtent;
    }
    if (this.timeZone) {
      params.timeZone = this.timeZone;
    }
    if (this.viewpoint) {
      params.viewpoint = this.viewpoint;
    }
    if (this.zoom !== void 0) {
      params.zoom = this.zoom;
    }
    return params;
  }
  async _loadMap() {
    this.map || (this.map = await this._createMap());
    const params = this._createViewParams();
    const view = await newViewsMapView({
      ...params
    });
    this.view = view;
    return void view.when(async () => {
      this.toMap = view.toMap.bind(view);
      this.toScreen = view.toScreen.bind(view);
      await this._addWatchers();
    });
  }
  _proxyEvents() {
    addHandles(this, [
      this.view.on("click", (event) => {
        this.arcgisViewClick.emit(event);
      }),
      this.view.on("double-click", (event) => {
        this.arcgisViewDoubleClick.emit(event);
      }),
      this.view.on("drag", (event) => {
        this.arcgisViewDrag.emit(event);
      }),
      this.view.on("hold", (event) => {
        this.arcgisViewHold.emit(event);
      }),
      this.view.on("immediate-click", (event) => {
        this.arcgisViewImmediateClick.emit(event);
      }),
      this.view.on("immediate-double-click", (event) => {
        this.arcgisViewImmediateDoubleClick.emit(event);
      }),
      this.view.on("key-down", (event) => {
        this.arcgisViewKeyDown.emit(event);
      }),
      this.view.on("key-up", (event) => {
        this.arcgisViewKeyUp.emit(event);
      }),
      this.view.on("layerview-create", (event) => {
        this.arcgisViewLayerviewCreate.emit(event);
      }),
      this.view.on("layerview-create-error", (event) => {
        this.arcgisViewLayerviewCreateError.emit(event);
      }),
      this.view.on("layerview-destroy", (event) => {
        this.arcgisViewLayerviewDestroy.emit(event);
      }),
      this.view.on("mouse-wheel", (event) => {
        this.arcgisViewMouseWheel.emit(event);
      }),
      this.view.on("pointer-down", (event) => {
        this.arcgisViewPointerDown.emit(event);
      }),
      this.view.on("pointer-enter", (event) => {
        this.arcgisViewPointerEnter.emit(event);
      }),
      this.view.on("pointer-leave", (event) => {
        this.arcgisViewPointerLeave.emit(event);
      }),
      this.view.on("pointer-move", (event) => {
        this.arcgisViewPointerMove.emit(event);
      }),
      this.view.on("pointer-up", (event) => {
        this.arcgisViewPointerUp.emit(event);
      })
    ]);
  }
  async _updateMap() {
    var _a;
    if ((_a = this.view) == null ? void 0 : _a.map) {
      this.view.map.destroy();
      const map = await this._createMap();
      this.view.map = map;
    }
  }
  get _hostElement() {
    return getElement(this);
  }
  static get watchers() {
    return {
      "background": ["backgroundWatcher"],
      "basemap": ["basemapWatcher"],
      "center": ["centerWatcher"],
      "constraints": ["constraintsWatcher"],
      "extent": ["extentWatcher"],
      "floors": ["floorsWatcher"],
      "graphics": ["graphicsWatcher"],
      "highlightOptions": ["highlightOptionsWatcher"],
      "itemId": ["itemIdWatcher"],
      "map": ["mapWatcher"],
      "navigation": ["navigationWatcher"],
      "padding": ["paddingWatcher"],
      "popup": ["popupWatcher"],
      "popupEnabled": ["popupEnabledWatcher"],
      "resizeAlign": ["resizeAlignWatcher"],
      "rotation": ["rotationWatcher"],
      "scale": ["scaleWatcher"],
      "spatialReference": ["spatialReferenceWatcher"],
      "theme": ["themeWatcher"],
      "timeExtent": ["timeExtentWatcher"],
      "timeZone": ["timeZoneWatcher"],
      "viewpoint": ["viewpointWatcher"],
      "zoom": ["zoomWatcher"]
    };
  }
};
ArcgisMap.style = mapCss;
export {
  ArcgisBasemapGallery as arcgis_basemap_gallery,
  ArcgisMap as arcgis_map
};
/*! Bundled license information:

@arcgis/map-components/dist/esm/arcgis-basemap-gallery_2.entry.js:
  (*!
   * All material copyright Esri, All Rights Reserved, unless otherwise specified.
   * See https://js.arcgis.com/4.30/esri/copyright.txt for details.
   * v4.30.0-next.13
   *)
*/
//# sourceMappingURL=arcgis-basemap-gallery_2.entry-5D5CETFH.js.map
