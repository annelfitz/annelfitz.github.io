{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/BlendWeights.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport{ScreenSpacePass as e}from\"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js\";import{glsl as o}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as r}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as t}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";const s={maxSearchSteps:8,maxDistanceAreaTex:16};function c(){const c=new r;return c.include(e),c.fragment.uniforms.add(new t(\"edgesTexture\",(e=>e.inputTexture)),new t(\"areaTexture\",(e=>e.areaTexture)),new t(\"searchTexture\",(e=>e.searchTexture))),c.fragment.code.add(o`\n    #define SMAA_AREATEX_PIXEL_SIZE ( 1.0 / vec2( 160.0, 560.0 ) )\n    #define SMAA_AREATEX_SUBTEX_SIZE ( 1.0 / 7.0 )\n\n    vec4 sampleLevelZeroOffset(sampler2D tex, vec2 coord, vec2 offset, vec2 resolution) {\n      return texture(tex, coord + offset.x * resolution, 0.0);\n    }\n\n    float searchLength(sampler2D searchTex, vec2 e, float bias, float scale) {\n      e.r = bias + e.r * scale;\n      return 255.0 * texture( searchTex, e, 0.0 ).r;\n    }\n\n    float searchLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end, vec2 resolution ) {\n      vec2 e = vec2( 0.0, 1.0 );\n      for ( int i = 0; i < ${o.int(s.maxSearchSteps)}; i ++ ) {\n        e = texture( edgesTex, texcoord, 0.0 ).rg;\n        texcoord -= vec2( 2.0, 0.0 ) * resolution;\n        if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n      }\n      texcoord.x += 0.25 * resolution.x;\n      texcoord.x += resolution.x;\n      texcoord.x += 2.0 * resolution.x;\n      texcoord.x -= resolution.x * searchLength(searchTex, e, 0.0, 0.5);\n      return texcoord.x;\n    }\n\n    float searchRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end, vec2 resolution ) {\n      vec2 e = vec2( 0.0, 1.0 );\n      for ( int i = 0; i < ${o.int(s.maxSearchSteps)}; i ++ ) {\n        e = texture( edgesTex, texcoord, 0.0 ).rg;\n        texcoord += vec2( 2.0, 0.0 ) * resolution;\n        if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n      }\n      texcoord.x -= 0.25 * resolution.x;\n      texcoord.x -= resolution.x;\n      texcoord.x -= 2.0 * resolution.x;\n      texcoord.x += resolution.x * searchLength( searchTex, e, 0.5, 0.5 );\n      return texcoord.x;\n    }\n\n    float searchUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end, vec2 resolution ) {\n      vec2 e = vec2( 1.0, 0.0 );\n      for ( int i = 0; i < ${o.int(s.maxSearchSteps)}; i ++ ) {\n        e = texture( edgesTex, texcoord, 0.0 ).rg;\n        texcoord += vec2( 0.0, 2.0 ) * resolution;\n        if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n      }\n      texcoord.y -= 0.25 * resolution.y;\n      texcoord.y -= resolution.y;\n      texcoord.y -= 2.0 * resolution.y;\n      texcoord.y += resolution.y * searchLength( searchTex, e.gr, 0.0, 0.5 );\n      return texcoord.y;\n    }\n\n    float searchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end, vec2 resolution ) {\n      vec2 e = vec2( 1.0, 0.0 );\n      for ( int i = 0; i < ${o.int(s.maxSearchSteps)}; i ++ ) {\n        e = texture( edgesTex, texcoord, 0.0 ).rg;\n        texcoord -= vec2( 0.0, 2.0 ) * resolution;\n        if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n      }\n      texcoord.y += 0.25 * resolution.y;\n      texcoord.y += resolution.y;\n      texcoord.y += 2.0 * resolution.y;\n      texcoord.y -= resolution.y * searchLength( searchTex, e.gr, 0.5, 0.5 );\n      return texcoord.y;\n    }\n\n    vec2 getArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n      vec2 texcoord = float( ${o.int(s.maxDistanceAreaTex)} ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n      texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n      texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n      return texture( areaTex, texcoord, 0.0 ).rg;\n    }\n\n    void main() {\n      vec2 size = vec2(textureSize(edgesTexture, 0));\n      vec2 resolution = 1.0 / size;\n      vec2 pixelCoord = uv * size;\n      vec4 offsets[2];\n      offsets[0] = uv.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );\n      offsets[1] = uv.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );\n      vec4 maxOffset = vec4( offsets[0].xz, offsets[1].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( ${o.int(s.maxSearchSteps)} );\n\n      ivec4 subsampleIndices = ivec4(0.0);\n      vec4 weights = vec4(0.0);\n      vec2 e = texture( edgesTexture, uv ).rg;\n      if ( e.g > 0.0 ) {\n        vec2 d;\n        vec2 coords;\n        coords.x = searchLeft( edgesTexture, searchTexture, offsets[0].xy, maxOffset.x, resolution );\n        coords.y = offsets[1].y;\n        d.x = coords.x;\n        float e1 = texture( edgesTexture, coords, 0.0 ).r;\n        coords.x = searchRight( edgesTexture, searchTexture, offsets[0].zw, maxOffset.y, resolution );\n        d.y = coords.x;\n        d = d * size.x - pixelCoord.x;\n        vec2 sqrt_d = sqrt( abs(d) );\n        coords.y -= 1.0 * resolution.y;\n        float e2 = sampleLevelZeroOffset( edgesTexture, coords, vec2( 1.0, 0.0 ), resolution).r;\n        weights.rg = getArea( areaTexture, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n      }\n\n      if ( e.r > 0.0 ) {\n        vec2 d;\n        vec2 coords;\n        coords.y = searchUp( edgesTexture, searchTexture, offsets[1].xy, maxOffset.z, resolution );\n        coords.x = offsets[0].x;\n        d.x = coords.y;\n        float e1 = texture( edgesTexture, coords, 0.0 ).g;\n        coords.y = searchYDown( edgesTexture, searchTexture, offsets[1].zw, maxOffset.w, resolution );\n        d.y = coords.y;\n        d = d * size.y - pixelCoord.y;\n        vec2 sqrt_d = sqrt(abs(d));\n        coords.y -= 1.0 * resolution.y;\n        float e2 = sampleLevelZeroOffset( edgesTexture, coords, vec2(0.0, 1.0), resolution).g;\n        weights.ba = getArea( areaTexture, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\n        // for some reason the following lines are necessary to prevent\n        // texture lookup precision issues on some Intel integrated graphics chips\n        vec4 dbg = (offsets[0] + offsets[1] + maxOffset + coords.xyyx);\n        weights.r += 0.00000001 * dot(vec4(0, 1, 0, 1), dbg);\n      }\n      fragColor = weights;\n    }`),c}const x=Object.freeze(Object.defineProperty({__proto__:null,build:c},Symbol.toStringTag,{value:\"Module\"}));export{x as B,c as b};\n"],
  "mappings": ";;;;;;;;;;;;;;AAI+X,IAAMA,KAAE,EAAC,gBAAe,GAAE,oBAAmB,GAAE;AAAE,SAAS,IAAG;AAAC,QAAMC,KAAE,IAAIC;AAAE,SAAOD,GAAE,QAAQC,EAAC,GAAED,GAAE,SAAS,SAAS,IAAI,IAAI,EAAE,gBAAgB,OAAG,EAAE,YAAa,GAAE,IAAI,EAAE,eAAe,OAAG,EAAE,WAAY,GAAE,IAAI,EAAE,iBAAiB,OAAG,EAAE,aAAc,CAAC,GAAEA,GAAE,SAAS,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BAe7mB,EAAE,IAAID,GAAE,cAAc,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BAcvB,EAAE,IAAIA,GAAE,cAAc,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BAcvB,EAAE,IAAIA,GAAE,cAAc,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BAcvB,EAAE,IAAIA,GAAE,cAAc,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAarB,EAAE,IAAIA,GAAE,kBAAkB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wHAa8D,EAAE,IAAIA,GAAE,cAAc,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MA0CzI,GAAEC;AAAC;AAAC,IAAM,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,OAAM,EAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["s", "c", "o"]
}
