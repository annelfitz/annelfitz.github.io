{
  "version": 3,
  "sources": ["../../@esri/calcite-components/dist/esm/src/utils/date.ts", "../../@esri/calcite-components/dist/esm/src/components/date-picker/utils.ts"],
  "sourcesContent": ["import { DateLocaleData } from \"../components/date-picker/utils\";\nimport { numberStringFormatter } from \"./locale\";\n\nexport interface HoverRange {\n  focused: \"end\" | \"start\";\n  start: Date;\n  end: Date;\n}\n\n/**\n * Check if date is within a min and max\n *\n * @param date\n * @param min\n * @param max\n */\nexport function inRange(date: Date, min?: Date | string, max?: Date | string): boolean {\n  if (!date) {\n    return;\n  }\n  const time = date.getTime();\n  const afterMin = !(min instanceof Date) || time >= min.getTime();\n  const beforeMax = !(max instanceof Date) || time <= max.getTime();\n  return afterMin && beforeMax;\n}\n\n/**\n * Ensures date is within range,\n * returns min or max if out of bounds\n *\n * @param date\n * @param min\n * @param max\n */\nexport function dateFromRange(date?: any, min?: Date | string, max?: Date | string): Date | null {\n  if (!(date instanceof Date)) {\n    return null;\n  }\n  const time = date.getTime();\n  const beforeMin = min instanceof Date && time < min.getTime();\n  const afterMax = max instanceof Date && time > max.getTime();\n  if (beforeMin) {\n    return min as Date;\n  }\n  if (afterMax) {\n    return max as Date;\n  }\n  return date;\n}\n\n/**\n * Parse an iso8601 string (YYYY-mm-dd) into a valid date.\n * TODO: handle time when time of day UI is added\n *\n * @param iso8601\n * @param isEndDate\n */\nexport function dateFromISO(iso8601: string | Date, isEndDate = false): Date | null {\n  if (iso8601 instanceof Date) {\n    return iso8601;\n  }\n  if (!iso8601 || typeof iso8601 !== \"string\") {\n    return null;\n  }\n  const d = iso8601.split(/[: T-]/).map(parseFloat);\n  const date = new Date(d[0], (d[1] || 1) - 1, d[2] || 1);\n  date.setFullYear(d[0]);\n  if (isNaN(date.getTime())) {\n    throw new Error(`Invalid ISO 8601 date: \"${iso8601}\"`);\n  }\n  if (isEndDate) {\n    return setEndOfDay(date);\n  }\n  return date;\n}\n\n/**\n * Parse a localized date string into a valid Date.\n * return false if date is invalid, or out of range\n *\n * @param value\n * @param localeData\n */\nexport function dateFromLocalizedString(value: string, localeData: DateLocaleData): Date {\n  if (!localeData) {\n    return null;\n  }\n  const { separator } = localeData;\n  const parts = parseDateString(value, localeData);\n\n  const { day, month } = parts;\n  const year = parseCalendarYear(parts.year, localeData);\n\n  const date = new Date(year, month, day);\n  date.setFullYear(year);\n\n  const validDay = day > 0;\n  const validMonth = month > -1;\n  const validDate = !isNaN(date.getTime());\n  const validLength = value.split(separator).filter((c) => c).length > 2;\n  const validYear = year.toString().length > 0;\n\n  if (validDay && validMonth && validDate && validLength && validYear) {\n    return date;\n  }\n  return null;\n}\n\nexport function parseCalendarYear(year: number, localeData: DateLocaleData): number {\n  return processCalendarYear(year, localeData, \"read\");\n}\n\nexport function formatCalendarYear(year: number, localeData: DateLocaleData): number {\n  return processCalendarYear(year, localeData, \"write\");\n}\n\nfunction processCalendarYear(year: number, localeData: DateLocaleData, mode: \"read\" | \"write\"): number {\n  if (localeData[\"default-calendar\"] !== \"buddhist\") {\n    return year;\n  }\n\n  const BUDDHIST_CALENDAR_YEAR_OFFSET = 543;\n  const yearOffset = BUDDHIST_CALENDAR_YEAR_OFFSET * (mode === \"read\" ? -1 : 1);\n\n  return year + yearOffset;\n}\n\n/**\n * Retrieve day, month, and year strings from a localized string\n *\n * @param string\n * @param localeData\n */\nexport function datePartsFromLocalizedString(\n  string: string,\n  localeData: DateLocaleData,\n): { day: string; month: string; year: string } {\n  const { separator, unitOrder } = localeData;\n  const order = getOrder(unitOrder);\n  const values = string.split(separator).map((part) => numberStringFormatter.delocalize(part));\n  const day = values[order.indexOf(\"d\")];\n  const month = values[order.indexOf(\"m\")];\n  const year = values[order.indexOf(\"y\")];\n  return { day, month, year };\n}\n\n/**\n * Return first portion of ISO string (YYYY-mm-dd)\n *\n * @param date\n */\nexport function dateToISO(date?: Date): string {\n  if (date instanceof Date) {\n    return new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().split(\"T\")[0];\n  }\n  return \"\";\n}\n\n/**\n * Retrieve day, month, and year strings from a ISO string (YYYY-mm-dd)\n *\n * @param string\n * @param isoDate\n */\nexport function datePartsFromISO(isoDate: string): { day: string; month: string; year: string } {\n  const dateParts = isoDate.split(\"-\");\n  return { day: dateParts[2], month: dateParts[1], year: dateParts[0] };\n}\n\n/**\n * Check if two dates are the same day, month, year\n *\n * @param d1\n * @param d2\n */\nexport function sameDate(d1: Date, d2: Date): boolean {\n  return (\n    d1 instanceof Date &&\n    d2 instanceof Date &&\n    d1.getDate() === d2.getDate() &&\n    d1.getMonth() === d2.getMonth() &&\n    d1.getFullYear() === d2.getFullYear()\n  );\n}\n\n/**\n * Get a date one month in the past\n *\n * @param date\n */\nexport function prevMonth(date: Date): Date {\n  const month = date.getMonth();\n  const nextDate = new Date(date);\n  nextDate.setMonth(month - 1);\n  // date doesn't exist in new month, use last day\n  if (month === nextDate.getMonth()) {\n    return new Date(date.getFullYear(), month, 0);\n  }\n  return nextDate;\n}\n\n/**\n * Get a date one month in the future\n *\n * @param date\n */\nexport function nextMonth(date: Date): Date {\n  const month = date.getMonth();\n  const nextDate = new Date(date);\n  nextDate.setMonth(month + 1);\n  // date doesn't exist in new month, use last day\n  if ((month + 2) % 7 === nextDate.getMonth() % 7) {\n    return new Date(date.getFullYear(), month + 2, 0);\n  }\n  return nextDate;\n}\n\n/**\n * Parse numeric units for day, month, and year from a localized string\n * month starts at 0 (can pass to date constructor)\n * can return values as number or string\n *\n * @param string\n * @param localeData\n */\nexport function parseDateString(\n  string: string,\n  localeData: DateLocaleData,\n): { day: number; month: number; year: number } {\n  const { day, month, year } = datePartsFromLocalizedString(string, localeData);\n  return {\n    day: parseInt(day),\n    month: parseInt(month) - 1, // this subtracts by 1 because the month in the Date constructor is zero-based https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth\n    year: parseInt(year),\n  };\n}\n\ntype unitOrderSignifier = \"m\" | \"d\" | \"y\";\n\n/**\n * Based on the unitOrder string, find order of month, day, and year for locale\n *\n * @param unitOrder\n */\nexport function getOrder(unitOrder: string): unitOrderSignifier[] {\n  const signifiers: unitOrderSignifier[] = [\"d\", \"m\", \"y\"];\n  const order = unitOrder.toLowerCase();\n  return signifiers.sort((a, b) => order.indexOf(a) - order.indexOf(b));\n}\n\n/**\n * Get number of days between two dates\n *\n * @param date1\n * @param date2\n */\nexport function getDaysDiff(date1: Date, date2: Date): number {\n  const ts1 = date1.getTime();\n  const ts2 = date2.getTime();\n  return (ts1 - ts2) / (1000 * 3600 * 24);\n}\n\n/**\n * Set time of the day to the end.\n *\n * @param {Date} date Date.\n * @returns {Date} Date with time set to end of day .\n */\nexport function setEndOfDay(date: Date): Date {\n  date.setHours(23, 59, 59, 999);\n  return date;\n}\n", "import { getAssetPath } from \"@stencil/core\";\nimport { dateFromISO } from \"../../utils/date\";\nimport { getSupportedLocale } from \"../../utils/locale\";\n\n/**\n * Translation resource data structure\n *\n * @private\n */\nexport interface DateLocaleData {\n  \"default-calendar\": \"gregorian\" | \"buddhist\";\n  separator: string;\n  unitOrder: string;\n  weekStart: number;\n  placeholder: string;\n  days: {\n    abbreviated?: string[];\n    narrow?: string[];\n    short?: string[];\n    wide?: string[];\n  };\n  numerals: string;\n  months: {\n    abbreviated: string[];\n    narrow: string[];\n    wide: string[];\n  };\n  year?: {\n    suffix: string;\n  };\n}\n\n/**\n * CLDR cache.\n * Exported for testing purposes.\n *\n * @private\n */\nexport const translationCache: Record<string, DateLocaleData> = {};\n\n/**\n * CLDR request cache.\n * Exported for testing purposes.\n *\n * @private\n */\nexport const requestCache: Record<string, Promise<DateLocaleData>> = {};\n\n/**\n * Fetch calendar data for a given locale from list of supported languages\n *\n * @param lang\n * @public\n */\nexport async function getLocaleData(lang: string): Promise<DateLocaleData> {\n  const locale = getSupportedLocale(lang);\n  if (translationCache[locale]) {\n    return translationCache[locale];\n  }\n  if (!requestCache[locale]) {\n    requestCache[locale] = fetch(getAssetPath(`./assets/date-picker/nls/${locale}.json`))\n      .then((resp) => resp.json())\n      .catch(() => {\n        console.error(`Translations for \"${locale}\" not found or invalid, falling back to english`);\n        return getLocaleData(\"en\");\n      });\n  }\n\n  const data = await requestCache[locale];\n  translationCache[locale] = data;\n\n  return data;\n}\n\n/**\n *  Maps value to valueAsDate\n *\n * @param value\n */\n\nexport function getValueAsDateRange(value: string[]): Date[] {\n  return value.map((v, index) => dateFromISO(v, index === 1));\n}\n"],
  "mappings": "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",
  "names": []
}
