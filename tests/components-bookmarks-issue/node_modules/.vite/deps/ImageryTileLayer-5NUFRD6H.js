import {
  h as h4,
  i as i4,
  m as m5,
  s as s4,
  x as x2
} from "./chunk-2ARR5VFO.js";
import {
  B as B2,
  E as E2,
  K,
  N as N3,
  S as S2,
  V as V2,
  a as a4,
  c as c4,
  c2 as c5,
  d as d4,
  h as h3,
  l as l4,
  m as m4,
  p as p4,
  t as t2
} from "./chunk-AYKBCBY7.js";
import {
  D as D4,
  a as a5,
  d as d5,
  f as f7,
  g as g3,
  h as h2,
  i as i3,
  o as o4,
  p as p3
} from "./chunk-IOKSWIVD.js";
import "./chunk-54XXLVAD.js";
import "./chunk-KO7QNSNZ.js";
import {
  T as T4
} from "./chunk-G3TGE2VT.js";
import {
  _
} from "./chunk-DCBZOZ54.js";
import "./chunk-5IT6RVBX.js";
import {
  N as N2,
  R as R3,
  c as c3,
  f as f6,
  i as i2,
  y as y4
} from "./chunk-6IGKQIMQ.js";
import {
  C,
  D as D3,
  J,
  T as T3,
  U as U4,
  V,
  Z,
  ee,
  j as j5,
  oe,
  re
} from "./chunk-QQDXHR2B.js";
import {
  B,
  D,
  F,
  L,
  N,
  P,
  R,
  U as U2,
  U2 as U5,
  g as g2,
  h2 as h,
  j as j4,
  m as m2,
  m3,
  n as n5,
  n2 as n6,
  r,
  r2
} from "./chunk-TBCOV2E5.js";
import {
  D as D2,
  E,
  R as R2,
  T as T2,
  U as U3,
  W as W2,
  f2 as f5,
  g,
  l3,
  s2 as s3,
  u2 as u5
} from "./chunk-HUFLW46E.js";
import {
  l as l2,
  u as u4
} from "./chunk-XKG6TWCH.js";
import "./chunk-ECTYMEUP.js";
import "./chunk-JBU54P54.js";
import "./chunk-3FOBZIUS.js";
import "./chunk-YH2IYJYF.js";
import "./chunk-GGHKH3LP.js";
import "./chunk-VS6AHHIY.js";
import {
  l
} from "./chunk-AHEDDTVZ.js";
import {
  f as f4
} from "./chunk-7UUNSIMA.js";
import "./chunk-GMRQGGML.js";
import "./chunk-BYK4ZOU2.js";
import {
  p as p2
} from "./chunk-OHYLFFUW.js";
import {
  e as e2
} from "./chunk-XW3FDKYP.js";
import "./chunk-Y7RXGLGH.js";
import "./chunk-GKMVTGGM.js";
import "./chunk-XGTCDM4C.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import "./chunk-Q6RZBEZ6.js";
import "./chunk-PC66NY33.js";
import "./chunk-YY2VB3AE.js";
import "./chunk-VEYMN5N3.js";
import "./chunk-H6NTWZSO.js";
import "./chunk-BMT3OVAP.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import {
  d as d3
} from "./chunk-F3BQGS35.js";
import {
  y as y2
} from "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-LMO6NZJA.js";
import "./chunk-A5QTLE4Y.js";
import "./chunk-SCHTG6ZQ.js";
import "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import "./chunk-QYC3GV65.js";
import {
  P as P2
} from "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import "./chunk-I2X6UR6L.js";
import {
  A
} from "./chunk-7EQJLP2H.js";
import {
  j as j2
} from "./chunk-4ZLXDMI5.js";
import {
  j as j3,
  p
} from "./chunk-2SYXH2R7.js";
import "./chunk-7JNXJYRU.js";
import {
  f as f3
} from "./chunk-EMYOYGGK.js";
import {
  n as n4
} from "./chunk-6PMFOUWZ.js";
import "./chunk-3KPZ3BQR.js";
import "./chunk-5JYVZQZR.js";
import {
  t
} from "./chunk-UUG4W2PI.js";
import {
  u as u2
} from "./chunk-WW22JHXA.js";
import {
  S
} from "./chunk-ZAM62XN5.js";
import {
  c as c2,
  d as d2
} from "./chunk-RKVEKQ5O.js";
import "./chunk-P7J4JFEH.js";
import {
  b
} from "./chunk-G7FOE26O.js";
import "./chunk-USOPZ2Q6.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-JW7VBMHD.js";
import "./chunk-GLLRUDMY.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import {
  i
} from "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import {
  u as u3
} from "./chunk-WDPG5BMO.js";
import {
  o as o3
} from "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-AKLOTDO2.js";
import "./chunk-6AQIVLDN.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-LBXFRGMS.js";
import {
  y as y3
} from "./chunk-VTH4DAHQ.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import {
  j
} from "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import {
  n as n3
} from "./chunk-Z2PDA67N.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  f as f2
} from "./chunk-MBGZKT2Z.js";
import {
  W2 as W,
  c2 as c,
  s2
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import {
  o as o2
} from "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import {
  a as a3
} from "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import {
  I,
  U
} from "./chunk-SAYWXQVM.js";
import {
  f
} from "./chunk-SBL4URUW.js";
import {
  d
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  o,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  T,
  a3 as a2,
  v as v2
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  a,
  k as k2,
  m,
  u2 as u,
  v
} from "./chunk-JGDJR5EV.js";
import {
  n as n2
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has,
  k
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/layers/support/rasterDatasets/BaseRaster.js
var V3 = 8;
var U6 = 256;
var $ = 0;
var Q = class extends n3(f) {
  constructor() {
    super(...arguments), this._tileFetchQueue = new _({ concurrency: 32, process: (e4, t5) => this._fetchRawTile(e4.pyramidLevel, e4.row, e4.col, { ...e4.options, signal: t5 }) }), this.datasetName = null, this.datasetFormat = null, this.hasUniqueSourceStorageInfo = true, this.rasterInfo = null, this.ioConfig = { sampling: "closest" };
  }
  async init() {
    const e4 = T3();
    this.addResolvingPromise(e4), await this.when();
  }
  normalizeCtorArgs(e4) {
    return (e4 == null ? void 0 : e4.ioConfig) && (e4 = { ...e4, ioConfig: { resolution: null, bandIds: null, sampling: "closest", tileInfo: j3.create(), ...e4.ioConfig } }), e4;
  }
  get _isGlobalWrappableSource() {
    const { rasterInfo: e4 } = this, t5 = D3(e4.spatialReference);
    return null != t5 && e4.extent.width >= t5 / 2;
  }
  get _hasNoneOrGCSShiftTransform() {
    const { transform: e4 } = this.rasterInfo;
    return null == e4 || "gcs-shift" === e4.type;
  }
  set rasterJobHandler(e4) {
    var _a, _b;
    this._set("rasterJobHandler", e4), "Function" === this.datasetFormat && ((_b = (_a = this.primaryRasters) == null ? void 0 : _a.rasters) == null ? void 0 : _b.forEach((t5) => t5.rasterJobHandler = e4));
  }
  get rasterId() {
    return this.url || "rasterId-" + $++;
  }
  set url(e4) {
    this._set("url", y3(e4, n.getLogger(this)));
  }
  async open(e4) {
    throw new s("BaseRaster:open-not-implemented", "open() is not implemented");
  }
  async fetchTile(e4, t5, i7, r6 = {}) {
    const o8 = r6.tileInfo || this.rasterInfo.storageInfo.tileInfo, n9 = this.getTileExtentFromTileInfo(e4, t5, i7, o8);
    return r6 = { noClip: true, ...r6 }, this.fetchPixels(n9, o8.size[0], o8.size[1], r6);
  }
  async identify(e4, t5 = {}) {
    var _a;
    e4 = v2(x, e4).clone().normalize();
    const { multidimensionalDefinition: i7, timeExtent: r6 } = t5, { rasterInfo: o8 } = this, { hasMultidimensionalTranspose: n9, multidimensionalInfo: s5 } = o8;
    let { transposedVariableName: l7 } = t5;
    const c8 = null != s5 && n9 && (null != r6 || h2(i7));
    if (c8 && !l7) {
      l7 = null != i7 && i7.length > 0 ? i7[0].variableName ?? void 0 : s5.variables[0].name, t5 = { ...t5, transposedVariableName: l7 };
    }
    t5 = this._getRequestOptionsWithSliceId(t5);
    const { spatialReference: m10, extent: f11 } = o8, { datumTransformation: u11 } = t5;
    let h9 = j5(e4, m10, u11);
    if (!f11.intersects(h9))
      return { location: h9, value: null };
    if (null != o8.transform) {
      const e5 = o8.transform.inverseTransform(h9);
      if (!o8.nativeExtent.intersects(e5))
        return { location: e5, value: null };
      h9 = e5;
    }
    let p8 = 0;
    const d9 = null != l7 && null != s5 && o8.hasMultidimensionalTranspose;
    if ("Function" === this.datasetFormat) {
      const e5 = this.primaryRasters.rasters[0];
      if (d9)
        return e5.identify(h9, t5);
      const { pixelSize: r7 } = o8, n10 = 3, s6 = r7.x * n10 / 2, l8 = r7.y * n10 / 2, a7 = new w({ xmin: h9.x - s6, xmax: h9.x + s6, ymin: h9.y - l8, ymax: h9.y + l8, spatialReference: m10 }), c9 = { interpolation: "nearest", multidimensionalDefinition: i7, sliceId: t5.sliceId }, { pixelBlock: f12 } = await e5.fetchPixels(a7, n10, n10, c9), { pixelBlock: u12 } = await this.fetchPixels(a7, n10, n10, c9);
      if (null == f12)
        return { location: h9, value: null };
      const p9 = Math.floor(n10 * n10 * 0.5), x6 = !f12.mask || f12.mask[p9] ? f12.pixels.map((e6) => e6[p9]) : null;
      let y8;
      return null != u12 && (y8 = !u12.mask || u12.mask[p9] ? u12.pixels.map((e6) => e6[p9]) : void 0), { location: h9, value: x6, processedValue: y8, pyramidLevel: 0 };
    }
    if (!d9) {
      if (t5.srcResolution) {
        p8 = re(t5.srcResolution, o8, this.ioConfig.sampling).pyramidLevel;
      } else if (p8 = await this.computeBestPyramidLevelForLocation(e4, t5), null == p8)
        return { location: h9, value: null };
    }
    const y7 = this.identifyPixelLocation(h9, p8, null, d9);
    if (null === y7)
      return { location: h9, value: null };
    const { row: g7, col: I5, rowOffset: k5, colOffset: v6, blockWidth: T5 } = y7, b4 = l7 ?? t5.sliceId, P4 = i4(this.rasterId, b4), B3 = `${p8}/${g7}/${I5}`;
    let M2 = m5(P4, null, B3);
    null == M2 && (M2 = this.fetchRawTile(p8, g7, I5, t5), x2(P4, null, B3, M2));
    const _3 = await M2;
    if (!((_a = _3 == null ? void 0 : _3.pixels) == null ? void 0 : _a.length))
      return { location: h9, value: null };
    const C3 = k5 * T5 + v6;
    return this._processIdentifyResult(_3, { srcLocation: h9, position: C3, pyramidLevel: p8, useTransposedTile: !!d9, requestSomeSlices: c8, identifyOptions: t5 });
  }
  async fetchPixels(e4, t5, i7, r6 = {}) {
    e4 = oe(e4), r6 = this._getRequestOptionsWithSliceId(r6);
    const { _hasNoneOrGCSShiftTransform: o8 } = this;
    if (r6.requestRawData && o8)
      return this._fetchPixels(e4, t5, i7, r6);
    const n9 = D3(e4.spatialReference), s5 = V(e4);
    if (null == n9 || 0 === s5 || 1 === s5 && this._isGlobalWrappableSource && o8)
      return this._fetchPixels(e4, t5, i7, r6);
    if (s5 >= 3)
      return { extent: e4, pixelBlock: null };
    const l7 = [], { xmin: a7, xmax: c8 } = e4, m10 = Math.round(n9 / (c8 - a7) * t5), f11 = m10 - Math.round((n9 / 2 - a7) / (c8 - a7) * t5);
    let u11 = 0;
    const h9 = [];
    for (let y7 = 0; y7 <= s5; y7++) {
      const o9 = new w({ xmin: 0 === y7 ? a7 : -n9 / 2, xmax: y7 === s5 ? c8 - n9 * y7 : n9 / 2, ymin: e4.ymin, ymax: e4.ymax, spatialReference: e4.spatialReference }), p9 = 0 === y7 ? m10 - f11 : y7 === s5 ? t5 - u11 : m10;
      u11 += p9, h9.push(p9);
      const d10 = r6.disableWrapAround && y7 > 0 ? null : this._fetchPixels(o9, p9, i7, r6);
      l7.push(d10);
    }
    const p8 = (await Promise.all(l7)).map((e5) => e5 == null ? void 0 : e5.pixelBlock);
    let d9 = null;
    const x6 = { width: t5, height: i7 };
    if (this.rasterJobHandler) {
      d9 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: p8, srcMosaicSize: x6, destDimension: null, coefs: null, sampleSpacing: null, interpolation: "nearest", alignmentInfo: null, blockWidths: h9 }, r6)).pixelBlock;
    } else
      d9 = U3(p8, x6, { blockWidths: h9 });
    return { extent: e4, srcExtent: J(e4, this.rasterInfo.spatialReference, r6.datumTransformation), pixelBlock: d9 };
  }
  async fetchRawPixels(e4, t5, i7, r6 = {}) {
    t5 = { x: Math.floor(t5.x), y: Math.floor(t5.y) };
    const o8 = await this._fetchRawTiles(e4, t5, i7, r6), { nativeExtent: n9, nativePixelSize: s5, storageInfo: l7 } = this.rasterInfo, a7 = 2 ** e4, c8 = s5.x * a7, m10 = s5.y * a7, f11 = new w({ xmin: n9.xmin + c8 * t5.x, xmax: n9.xmin + c8 * (t5.x + i7.width - 1), ymin: n9.ymax - m10 * (t5.y + i7.height - 1), ymax: n9.ymax - m10 * t5.y, spatialReference: n9.spatialReference });
    if (!o8)
      return { extent: f11, srcExtent: f11, pixelBlock: null };
    const { pixelBlocks: u11, mosaicSize: h9 } = o8;
    if (1 === u11.length && null != u11[0] && u11[0].width === i7.width && u11[0].height === i7.height)
      return { extent: f11, srcExtent: f11, pixelBlock: o8.pixelBlocks[0] };
    const p8 = e4 > 0 ? l7.pyramidBlockWidth : l7.blockWidth, d9 = e4 > 0 ? l7.pyramidBlockHeight : l7.blockHeight, x6 = { x: t5.x % p8, y: t5.y % d9 };
    let y7;
    if (this.rasterJobHandler) {
      y7 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: u11, srcMosaicSize: h9, destDimension: i7, clipOffset: x6, clipSize: i7, coefs: null, sampleSpacing: null, interpolation: r6.interpolation, alignmentInfo: null, blockWidths: null }, r6)).pixelBlock;
    } else
      y7 = U3(u11, h9, { clipOffset: x6, clipSize: i7 });
    return { extent: f11, srcExtent: f11, pixelBlock: y7 };
  }
  fetchRawTile(e4, t5, r6, o8) {
    throw new s("BaseRaster:read-not-implemented", "fetchRawTile() is not implemented");
  }
  computeExtent(e4) {
    return J(this.rasterInfo.extent, e4);
  }
  decodePixelBlock(e4, t5) {
    return !this.rasterJobHandler || t5.useCanvas ? j4(e4, t5) : this.rasterJobHandler.decode({ data: e4, options: t5 });
  }
  async request(e4, i7, r6 = 0) {
    const { customFetchParameters: o8 } = this.ioConfig, { range: n9, query: s5, headers: l7 } = i7;
    r6 = r6 ?? i7.retryCount ?? this.ioConfig.retryCount;
    const a7 = n9 ? { Range: `bytes=${n9.from}-${n9.to}` } : null;
    try {
      return await U(e4, { ...i7, query: { ...s5, ...o8 }, headers: { ...l7, ...a7 } });
    } catch (c8) {
      if (r6 > 0)
        return r6--, this.request(e4, i7, r6);
      throw c8;
    }
  }
  getSliceIndex(e4) {
    const { multidimensionalInfo: t5 } = this.rasterInfo;
    return null == t5 || null == e4 || 0 === e4.length ? null : D4(e4, t5);
  }
  getTileExtentFromTileInfo(e4, t5, i7, r6) {
    const o8 = r6.lodAt(e4);
    return this.getTileExtent({ x: o8.resolution, y: o8.resolution }, t5, i7, r6.origin, r6.spatialReference, r6.size);
  }
  updateTileInfo() {
    const { storageInfo: e4, spatialReference: t5, extent: i7, pixelSize: r6 } = this.rasterInfo;
    if (!e4.tileInfo) {
      const o8 = [], n9 = e4.maximumPyramidLevel || 0;
      let s5 = Math.max(r6.x, r6.y), l7 = 1 / 0.0254 * 96 * s5;
      for (let e5 = 0; e5 <= n9; e5++)
        o8.unshift(new p({ level: n9 - e5, resolution: s5, scale: l7 })), s5 *= 2, l7 *= 2;
      const a7 = new x({ x: i7.xmin, y: i7.ymax, spatialReference: t5 });
      e4.tileInfo = new j3({ origin: a7, size: [e4.blockWidth, e4.blockHeight], spatialReference: t5, lods: o8 }), e4.isVirtualTileInfo = true;
    }
  }
  createRemoteDatasetStorageInfo(e4, t5 = 512, i7 = 512, r6) {
    const { width: o8, height: n9, nativeExtent: s5, pixelSize: l7, spatialReference: a7 } = e4, c8 = new x({ x: s5.xmin, y: s5.ymax, spatialReference: a7 });
    null == r6 && (r6 = Math.max(0, Math.round(Math.log(Math.max(o8, n9)) / Math.LN2 - 8)));
    const m10 = this.computeBlockBoundary(s5, 512, 512, { x: s5.xmin, y: s5.ymax }, [l7], r6);
    e4.storageInfo = new n6({ blockWidth: t5, blockHeight: i7, pyramidBlockWidth: t5, pyramidBlockHeight: i7, origin: c8, firstPyramidLevel: 1, maximumPyramidLevel: r6, blockBoundary: m10 });
  }
  async computeBestPyramidLevelForLocation(e4, t5 = {}) {
    return 0;
  }
  computeBlockBoundary(e4, t5, i7, r6, o8, n9 = 0, s5 = 2) {
    if (1 === o8.length && n9 > 0) {
      o8 = [...o8];
      let { x: e5, y: t6 } = o8[0];
      for (let i8 = 0; i8 < n9; i8++)
        e5 *= s5, t6 *= s5, o8.push({ x: e5, y: t6 });
    }
    const l7 = [], { x: a7, y: c8 } = r6;
    for (let m10 = 0; m10 < o8.length; m10++) {
      const { x: r7, y: n10 } = o8[m10];
      l7.push({ minCol: Math.floor((e4.xmin - a7 + 0.1 * r7) / t5 / r7), maxCol: Math.floor((e4.xmax - a7 - 0.1 * r7) / t5 / r7), minRow: Math.floor((c8 - e4.ymax + 0.1 * n10) / i7 / n10), maxRow: Math.floor((c8 - e4.ymin - 0.1 * n10) / i7 / n10) });
    }
    return l7;
  }
  getPyramidPixelSize(e4) {
    const { nativePixelSize: t5 } = this.rasterInfo, { pyramidResolutions: i7, pyramidScalingFactor: r6 } = this.rasterInfo.storageInfo;
    if (0 === e4)
      return t5;
    if (null != i7 && i7.length)
      return i7[e4 - 1];
    const o8 = r6 ** e4;
    return { x: t5.x * o8, y: t5.y * o8 };
  }
  identifyPixelLocation(e4, t5, i7, r6) {
    const { spatialReference: o8, nativeExtent: n9, storageInfo: s5 } = this.rasterInfo, { maximumPyramidLevel: l7, origin: a7, transposeInfo: c8 } = s5, m10 = r6 && null != c8 ? c8.tileSize[0] : s5.blockWidth, f11 = r6 && null != c8 ? c8.tileSize[1] : s5.blockHeight, u11 = j5(e4, o8, i7);
    if (!n9.intersects(u11))
      return null;
    if (t5 < 0 || t5 > l7)
      return null;
    const h9 = this.getPyramidPixelSize(t5), { x: p8, y: d9 } = h9, x6 = (a7.y - u11.y) / d9 / f11, y7 = (u11.x - a7.x) / p8 / m10, g7 = Math.min(f11 - 1, Math.floor((x6 - Math.floor(x6)) * f11)), I5 = Math.min(m10 - 1, Math.floor((y7 - Math.floor(y7)) * m10));
    return { pyramidLevel: t5, row: Math.floor(x6), col: Math.floor(y7), rowOffset: g7, colOffset: I5, blockWidth: m10, srcLocation: u11 };
  }
  getTileExtent(e4, t5, i7, r6, o8, n9) {
    const [s5, l7] = n9, a7 = r6.x + i7 * s5 * e4.x, c8 = a7 + s5 * e4.x, m10 = r6.y - t5 * l7 * e4.y, f11 = m10 - l7 * e4.y;
    return new w({ xmin: a7, xmax: c8, ymin: f11, ymax: m10, spatialReference: o8 });
  }
  getBlockWidthHeight(e4) {
    return { blockWidth: e4 > 0 ? this.rasterInfo.storageInfo.pyramidBlockWidth : this.rasterInfo.storageInfo.blockWidth, blockHeight: e4 > 0 ? this.rasterInfo.storageInfo.pyramidBlockHeight : this.rasterInfo.storageInfo.blockHeight };
  }
  isBlockOutside(e4, t5, i7) {
    const r6 = this.rasterInfo.storageInfo.blockBoundary[e4];
    return !r6 || r6.maxRow < t5 || r6.maxCol < i7 || r6.minRow > t5 || r6.minCol > i7;
  }
  updateImageSpaceRasterInfo(e4) {
    const { extent: t5, pixelSize: i7 } = e4;
    if (-0.5 === t5.xmin && 0.5 === t5.ymax && 1 === i7.x && 1 === i7.y && null == e4.transform)
      return;
    const { width: r6, height: o8 } = e4, n9 = f2.WebMercator;
    e4.spatialReference = n9, e4.extent = e4.nativeExtent = new w({ xmin: -0.5, ymax: 0.5, xmax: r6 - 0.5, ymin: 0.5 - o8, spatialReference: n9 }), e4.isPseudoSpatialReference = true, e4.transform = null, e4.pixelSize = new x({ x: 1, y: 1, spatialReference: n9 });
    const { extent: s5, storageInfo: l7 } = e4;
    if (l7) {
      l7.origin = new x({ x: s5.xmin, y: s5.ymax, spatialReference: n9 });
      const { tileInfo: t6 } = l7;
      if (t6) {
        t6.origin = l7.origin;
        const i8 = (e4.nativePixelSize.x + e4.nativePixelSize.y) / 2;
        t6.lods.forEach((e5, t7) => {
          e5.resolution = i8 * 2 ** t7, e5.scale = 96 * e5.resolution / 0.0254;
        });
      }
    }
  }
  async _fetchPixels(e4, t5, i7, r6 = {}) {
    let o8 = V(e4);
    if (o8 >= 2)
      return { extent: e4, pixelBlock: null };
    const n9 = this._getSourceDataInfo(e4, t5, i7, r6), { pyramidLevel: s5, srcResolution: l7, srcExtent: a7, srcWidth: c8, srcHeight: m10, ul: f11 } = n9;
    if (0 === c8 || 0 === m10)
      return { extent: e4, srcExtent: a7, pixelBlock: null };
    const { rasterInfo: u11 } = this, h9 = u11.transform, p8 = "gcs-shift" === (h9 == null ? void 0 : h9.type), d9 = null != D3(e4.spatialReference);
    !p8 && d9 || (o8 = V(n9.srcExtent, p8));
    const x6 = await this._fetchRawTiles(s5, f11, { width: c8, height: m10, wrapCount: o8 }, r6);
    if (!x6)
      return { extent: e4, srcExtent: a7, pixelBlock: null };
    const y7 = u11.storageInfo, g7 = s5 > 0 ? y7.pyramidBlockWidth : y7.blockWidth, I5 = s5 > 0 ? y7.pyramidBlockHeight : y7.blockHeight;
    let { x: R4, y: w4 } = u11.pixelSize;
    if (s5 > 0) {
      const { pyramidResolutions: e5, pyramidScalingFactor: t6 } = y7;
      if (null != e5 && e5[s5 - 1])
        ({ x: R4, y: w4 } = e5[s5 - 1]);
      else {
        const e6 = t6 ** s5;
        R4 *= e6, w4 *= e6;
      }
    }
    const S6 = u11.spatialReference, k5 = new x({ x: R4, y: w4, spatialReference: S6 }), v6 = g7 === c8 && I5 === m10 && f11.x % g7 == 0 && f11.y % I5 == 0, T5 = new x({ x: (e4.xmax - e4.xmin) / t5, y: (e4.ymax - e4.ymin) / i7, spatialReference: e4.spatialReference }), b4 = !e4.spatialReference.equals(S6), W3 = S6.isGeographic ? 1e-9 : 1e-4, { datumTransformation: j6 } = r6;
    if (!b4 && v6 && 1 === x6.pixelBlocks.length && g7 === t5 && I5 === i7 && X(l7, T5, W3))
      return { extent: e4, srcExtent: a7, srcTilePixelSize: k5, pixelBlock: x6.pixelBlocks[0] };
    const z2 = d9 && null != D3(a7.spatialReference) && this._hasNoneOrGCSShiftTransform, L3 = r6.requestProjectedLocalDirections && this.rasterInfo.dataType.startsWith("vector");
    L3 && !this.rasterJobHandler && await T3();
    const D6 = this.rasterJobHandler ? await this.rasterJobHandler.getProjectionOffsetGrid({ projectedExtent: e4, srcBufferExtent: x6.extent, pixelSize: T5.toJSON(), datumTransformation: j6, rasterTransform: h9, hasWrapAround: o8 > 0 || z2, isAdaptive: false !== this.ioConfig.optimizeProjectionAccuracy, includeGCSGrid: L3 }, r6) : ee({ projectedExtent: e4, srcBufferExtent: x6.extent, pixelSize: T5, datumTransformation: j6, rasterTransform: h9, hasWrapAround: o8 > 0 || z2, isAdaptive: false, includeGCSGrid: L3 });
    let F3;
    const A2 = !r6.requestRawData, G = { rows: D6.spacing[0], cols: D6.spacing[1] }, q = this._hasNoneOrGCSShiftTransform ? this._getRasterTileAlignmentInfo(s5, x6.extent.xmin) : void 0, { pixelBlocks: N4, mosaicSize: V4, isPartiallyFilled: U7 } = x6;
    let $2 = null;
    if (this.rasterJobHandler) {
      const e5 = await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: N4, srcMosaicSize: V4, destDimension: A2 ? { width: t5, height: i7 } : null, coefs: A2 ? D6.coefficients : null, sampleSpacing: A2 ? G : null, projectDirections: L3, gcsGrid: L3 ? D6.gcsGrid : null, isUV: "vector-uv" === this.rasterInfo.dataType, interpolation: r6.interpolation, alignmentInfo: q, blockWidths: null }, r6);
      ({ pixelBlock: F3, localNorthDirections: $2 } = e5);
    } else {
      const e5 = U3(N4, V4, { alignmentInfo: q });
      F3 = A2 ? D2(e5, { width: t5, height: i7 }, D6.coefficients, G, r6.interpolation) : e5, L3 && D6.gcsGrid && ($2 = R2({ width: t5, height: i7 }, D6.gcsGrid), F3 = u5(F3, this.rasterInfo.dataType, $2));
    }
    return r6.requestRawData || L3 ? { extent: e4, srcExtent: a7, srcTilePixelSize: k5, pixelBlock: F3, transformGrid: D6, localNorthDirections: $2, isPartiallyFilled: U7 } : { extent: e4, srcExtent: a7, srcTilePixelSize: k5, pixelBlock: F3 };
  }
  async _fetchRawTiles(e4, t5, i7, r6) {
    const { origin: o8, blockBoundary: n9 } = this.rasterInfo.storageInfo, { blockWidth: s5, blockHeight: l7 } = this.getBlockWidthHeight(e4);
    let { x: a7, y: c8 } = t5, { width: m10, height: f11, wrapCount: u11 } = i7;
    const h9 = this._getRasterTileAlignmentInfo(e4, 0);
    r6.buffer && (a7 -= r6.buffer.cols, c8 -= r6.buffer.rows, m10 += 2 * r6.buffer.cols, f11 += 2 * r6.buffer.rows);
    let p8 = 0, d9 = 0, x6 = 0;
    if (u11 && null != h9) {
      ({ worldColumnCountFromOrigin: d9, originColumnOffset: x6, rightPadding: p8 } = h9);
      d9 * h9.blockWidth - p8 >= a7 + m10 && (p8 = 0);
    }
    const y7 = Math.floor(a7 / s5), g7 = Math.floor(c8 / l7), I5 = Math.floor((a7 + m10 + p8 - 1) / s5), R4 = Math.floor((c8 + f11 + p8 - 1) / l7), w4 = n9[e4];
    if (!w4)
      return null;
    const { minRow: S6, minCol: k5, maxCol: v6, maxRow: T5 } = w4;
    if (0 === u11 && (R4 < S6 || I5 < k5 || g7 > T5 || y7 > v6))
      return null;
    const b4 = new Array();
    let P4 = false;
    const B3 = null == this.ioConfig.allowPartialFill ? r6.allowPartialFill : this.ioConfig.allowPartialFill;
    for (let H = g7; H <= R4; H++)
      for (let t6 = y7; t6 <= I5; t6++) {
        let i8 = t6;
        if (!r6.disableWrapAround && u11 && null != h9 && d9 <= t6 && (i8 = t6 - d9 - x6), H >= S6 && i8 >= k5 && T5 >= H && v6 >= i8) {
          const t7 = this._tileFetchQueue.push({ pyramidLevel: e4, row: H, col: i8, options: r6 }, { signal: r6.signal });
          B3 ? b4.push(new Promise((e5) => {
            t7.then((t8) => e5(t8)).catch(() => {
              P4 = true, e5(null);
            });
          })) : b4.push(t7);
        } else
          b4.push(Promise.resolve(null));
      }
    if (0 === b4.length)
      return null;
    const M2 = await Promise.all(b4), _3 = { height: (R4 - g7 + 1) * l7, width: (I5 - y7 + 1) * s5 }, { spatialReference: C3 } = this.rasterInfo, W3 = this.getPyramidPixelSize(e4), { x: j6, y: z2 } = W3;
    return { extent: new w({ xmin: o8.x + y7 * s5 * j6, xmax: o8.x + (I5 + 1) * s5 * j6, ymin: o8.y - (R4 + 1) * l7 * z2, ymax: o8.y - g7 * l7 * z2, spatialReference: C3 }), pixelBlocks: M2, mosaicSize: _3, isPartiallyFilled: P4 };
  }
  _fetchRawTile(e4, t5, i7, r6) {
    const o8 = this.rasterInfo.storageInfo.blockBoundary[e4];
    if (!o8)
      return Promise.resolve(null);
    const { minRow: n9, minCol: l7, maxCol: a7, maxRow: c8 } = o8;
    if (t5 < n9 || i7 < l7 || t5 > c8 || i7 > a7)
      return Promise.resolve(null);
    const m10 = i4(this.rasterId, r6.sliceId), f11 = `${e4}/${t5}/${i7}`;
    let u11 = m5(m10, r6.registryId, f11);
    if (null == u11) {
      const o9 = new AbortController();
      u11 = this.fetchRawTile(e4, t5, i7, { ...r6, signal: o9.signal }), x2(m10, r6.registryId, f11, u11, o9), u11.catch(() => h4(m10, r6.registryId, f11));
    }
    return r6.signal && m(r6, () => {
      s4(m10, r6.registryId, f11);
    }), u11;
  }
  _computeMagDirValues(e4) {
    var _a;
    const { bandCount: t5, dataType: i7 } = this.rasterInfo;
    if (!(2 === t5 && "vector-magdir" === i7 || "vector-uv" === i7) || 2 !== (e4 == null ? void 0 : e4.length) || !((_a = e4[0]) == null ? void 0 : _a.length))
      return null;
    const r6 = e4[0].length;
    if ("vector-magdir" === i7) {
      const t6 = e4[1].map((e5) => (e5 + 360) % 360);
      return [e4[0], t6];
    }
    const [o8, n9] = e4, s5 = [], l7 = [];
    for (let a7 = 0; a7 < r6; a7++) {
      const [e5, t6] = l3([o8[a7], n9[a7]]);
      s5.push(e5), l7.push(t6);
    }
    return [s5, l7];
  }
  _getRasterTileAlignmentInfo(e4, t5) {
    return null == this._rasterTileAlignmentInfo && (this._rasterTileAlignmentInfo = Z(this.rasterInfo)), null == this._rasterTileAlignmentInfo.pyramidsInfo ? null : { startX: t5, halfWorldWidth: this._rasterTileAlignmentInfo.halfWorldWidth, hasGCSSShiftTransform: this._rasterTileAlignmentInfo.hasGCSSShiftTransform, ...this._rasterTileAlignmentInfo.pyramidsInfo[e4] };
  }
  _getSourceDataInfo(e4, t5, i7, r6 = {}) {
    const o8 = { datumTransformation: r6.datumTransformation, pyramidLevel: 0, pyramidResolution: null, srcExtent: null, srcHeight: 0, srcResolution: null, srcWidth: 0, ul: { x: 0, y: 0 } };
    r6.srcResolution && (o8.srcResolution = r6.srcResolution, this._updateSourceDataInfo(e4, o8));
    const n9 = this.rasterInfo.storageInfo.maximumPyramidLevel || 0, { srcWidth: s5, srcHeight: l7, pyramidLevel: a7 } = o8, c8 = s5 / t5, m10 = l7 / i7, f11 = a7 < n9 && c8 * m10 >= 16, u11 = a7 === n9 && this._requireTooManySrcTiles(s5, l7, t5, i7);
    if (f11 || u11 || (0 === s5 || 0 === l7)) {
      const s6 = new x({ x: (e4.xmax - e4.xmin) / t5, y: (e4.ymax - e4.ymin) / i7, spatialReference: e4.spatialReference });
      let l8 = C(s6, this.rasterInfo.spatialReference, e4, o8.datumTransformation);
      const u12 = !l8 || r6.srcResolution && l8.x + l8.y < r6.srcResolution.x + r6.srcResolution.y;
      if (f11 && r6.srcResolution && u12) {
        const e5 = Math.round(Math.log(Math.max(c8, m10)) / Math.LN2) - 1;
        if (n9 - a7 + 3 >= e5) {
          const t6 = 2 ** e5;
          l8 = { x: r6.srcResolution.x * t6, y: r6.srcResolution.y * t6 };
        }
      }
      l8 && (o8.srcResolution = l8, this._updateSourceDataInfo(e4, o8));
    }
    return this._requireTooManySrcTiles(o8.srcWidth, o8.srcHeight, t5, i7) && (o8.srcWidth = 0, o8.srcHeight = 0), o8;
  }
  _requireTooManySrcTiles(e4, t5, i7, r6) {
    const { tileInfo: o8 } = this.rasterInfo.storageInfo, n9 = Math.ceil(e4 / o8.size[0]) * Math.ceil(t5 / o8.size[1]), s5 = e4 / i7, l7 = t5 / r6, a7 = Math.max(1, (i7 + r6) / 1024);
    return n9 >= U6 * a7 || s5 > V3 || l7 > V3;
  }
  _updateSourceDataInfo(e4, t5) {
    t5.srcWidth = 0, t5.srcHeight = 0;
    const { rasterInfo: i7 } = this, r6 = i7.spatialReference, { srcResolution: o8, datumTransformation: n9 } = t5, { pyramidLevel: s5, pyramidResolution: l7, excessiveReading: a7 } = re(o8, i7, this.ioConfig.sampling);
    if (a7)
      return;
    let c8 = t5.srcExtent || J(e4, r6, n9);
    if (null == c8)
      return;
    const m10 = i7.transform;
    m10 && (c8 = m10.inverseTransform(c8)), t5.srcExtent = c8;
    const { x: f11, y: u11 } = i7.storageInfo.origin, h9 = Math.floor((c8.xmin - f11) / l7.x + 0.1), p8 = Math.floor((u11 - c8.ymax) / l7.y + 0.1), d9 = Math.floor((c8.xmax - f11) / l7.x - 0.1), x6 = Math.floor((u11 - c8.ymin) / l7.y - 0.1), y7 = c8.width < 0.1 * l7.x ? 0 : d9 - h9 + 1, g7 = c8.height < 0.1 * l7.y ? 0 : x6 - p8 + 1;
    t5.pyramidLevel = s5, t5.pyramidResolution = l7, t5.srcWidth = y7, t5.srcHeight = g7, t5.ul = { x: h9, y: p8 };
  }
  _getRequestOptionsWithSliceId(e4) {
    return null != this.rasterInfo.multidimensionalInfo && null == e4.sliceId && (e4 = { ...e4, sliceId: this.getSliceIndex(e4.multidimensionalDefinition) }), e4;
  }
  _processIdentifyResult(e4, t5) {
    const { srcLocation: i7, position: r6, pyramidLevel: o8, useTransposedTile: n9 } = t5, s5 = e4.pixels[0].length / e4.width / e4.height;
    if (!(!e4.mask || e4.mask[r6]))
      return { location: i7, value: null };
    const { multidimensionalInfo: l7 } = this.rasterInfo;
    if (null == l7 || !n9) {
      const t6 = e4.pixels.map((e5) => e5[r6]), n10 = { location: i7, value: t6, pyramidLevel: o8 }, s6 = this._computeMagDirValues(t6.map((e5) => [e5]));
      return (s6 == null ? void 0 : s6.length) && (n10.magdirValue = s6.map((e5) => e5[0])), n10;
    }
    let a7 = e4.pixels.map((e5) => e5.slice(r6 * s5, r6 * s5 + s5)), c8 = this._computeMagDirValues(a7);
    const { requestSomeSlices: m10, identifyOptions: f11 } = t5;
    let h9 = i3(l7, f11.transposedVariableName);
    if (m10) {
      const e5 = a5(h9, f11.multidimensionalDefinition, f11.timeExtent);
      a7 = a7.map((t6) => e5.map((e6) => t6[e6])), c8 = c8 == null ? void 0 : c8.map((t6) => e5.map((e6) => t6[e6])), h9 = e5.map((e6) => h9[e6]);
    }
    const p8 = e4.noDataValues || this.rasterInfo.noDataValue, d9 = { pixels: a7, pixelType: e4.pixelType };
    let x6;
    null != p8 && (l2(d9, p8), x6 = d9.mask);
    return { location: i7, value: null, dataSeries: h9.map((e5, t6) => {
      const i8 = { value: 0 === (x6 == null ? void 0 : x6[t6]) ? null : a7.map((e6) => e6[t6]), multidimensionalDefinition: e5.multidimensionalDefinition.map((e6) => new p3({ ...e6, isSlice: true })) };
      return (c8 == null ? void 0 : c8.length) && (i8.magdirValue = [c8[0][t6], c8[1][t6]]), i8;
    }), pyramidLevel: o8 };
  }
};
function X(e4, t5, i7) {
  return Math.abs(e4.x - t5.x) < i7 && Math.abs(e4.y - t5.y) < i7;
}
e([y()], Q.prototype, "_rasterTileAlignmentInfo", void 0), e([y()], Q.prototype, "_tileFetchQueue", void 0), e([y({ readOnly: true })], Q.prototype, "_isGlobalWrappableSource", null), e([y({ readOnly: true })], Q.prototype, "_hasNoneOrGCSShiftTransform", null), e([y()], Q.prototype, "rasterJobHandler", null), e([y({ readOnly: true })], Q.prototype, "rasterId", null), e([y(d2)], Q.prototype, "url", null), e([y({ type: String, json: { write: true } })], Q.prototype, "datasetName", void 0), e([y({ type: String, json: { write: true } })], Q.prototype, "datasetFormat", void 0), e([y()], Q.prototype, "hasUniqueSourceStorageInfo", void 0), e([y()], Q.prototype, "rasterInfo", void 0), e([y()], Q.prototype, "ioConfig", void 0), e([y()], Q.prototype, "sourceJSON", void 0), Q = e([a2("esri.layers.support.rasterDatasets.BaseRaster")], Q);
var K2 = Q;

// node_modules/@arcgis/core/layers/support/rasterFunctions/clipUtils.js
function n7(e4, i7) {
  if (e4.spatialReference.equals(i7))
    return e4;
  const n9 = W(e4.spatialReference), a7 = W(i7);
  if (n9 === a7)
    return e4;
  const h9 = n9 / a7;
  return { x: e4.x * h9, y: e4.y * h9 };
}
async function a6(t5, e4, n9) {
  if ("extent" === n9.type)
    return o5(t5, e4, n9);
  const { width: a7, height: x6 } = t5, l7 = new Uint8Array(a7 * x6), { contains: m10, intersects: s5 } = await import("./geometryEngine-SEKGYY2X.js");
  return s5(e4, n9) ? "polyline" === n9.type ? r3(t5, e4, n9) : m10(n9, e4) ? t5 : h5(t5, e4, n9) : new g({ pixelType: t5.pixelType, width: a7, height: x6, mask: l7, maskIsAlpha: false, pixels: [...t5.pixels] });
}
function h5(t5, e4, n9) {
  if (!t5)
    return t5;
  const { width: a7, height: h9 } = t5, o8 = e4.width / a7, r6 = e4.height / h9, { xmin: x6, ymax: l7 } = e4;
  let m10;
  if ("extent" === n9.type) {
    const t6 = (n9.xmin - x6) / o8, e5 = (n9.xmax - x6) / o8, i7 = (l7 - n9.ymax) / r6, a8 = (l7 - n9.ymin) / r6;
    m10 = [[[t6, i7], [t6, a8], [e5, a8], [e5, i7], [t6, i7]]];
  } else
    m10 = n9.rings.map((t6) => t6.map(([t7, e5]) => [(t7 - x6) / o8, (l7 - e5) / r6]));
  const s5 = document.createElement("canvas");
  s5.width = a7, s5.height = h9;
  const p8 = s5.getContext("2d");
  p8.fillStyle = "#f00", p8.beginPath(), m10.forEach((t6) => {
    p8.moveTo(t6[0][0], t6[0][1]);
    for (let e5 = 0; e5 < t6.length; e5++)
      p8.lineTo(t6[e5][0], t6[e5][1]);
    p8.closePath();
  }), p8.fill();
  const f11 = p8.getImageData(0, 0, a7, h9).data, y7 = t5.mask, c8 = a7 * h9, M2 = new Uint8Array(c8);
  for (let i7 = 0; i7 < c8; i7++)
    y7 && !y7[i7] || (M2[i7] = f11[4 * i7 + 3] > 127 ? 255 : 0);
  return new g({ pixelType: t5.pixelType, width: a7, height: h9, mask: M2, maskIsAlpha: false, pixels: [...t5.pixels] });
}
function o5(t5, e4, n9) {
  const { width: a7, height: h9 } = t5, o8 = new Uint8Array(a7 * h9), r6 = e4.width / a7, x6 = e4.height / h9;
  if (n9.width / r6 < 0.5 || n9.height / x6 < 0.5)
    return new g({ pixelType: t5.pixelType, width: a7, height: h9, mask: o8, pixels: [...t5.pixels] });
  const { xmin: l7, xmax: m10, ymin: s5, ymax: p8 } = e4, { xmin: f11, xmax: y7, ymin: c8, ymax: M2 } = n9, u11 = Math.max(l7, f11), w4 = Math.min(m10, y7), d9 = Math.max(s5, c8), g7 = Math.min(p8, M2), T5 = 0.5 * r6, k5 = 0.5 * x6;
  if (w4 - u11 < T5 || g7 - d9 < k5 || w4 < l7 + T5 || u11 > m10 - T5 || d9 > p8 - k5 || g7 < s5 + k5)
    return new g({ pixelType: t5.pixelType, width: a7, height: h9, mask: o8, pixels: [...t5.pixels] });
  const A2 = Math.max(0, (u11 - l7) / r6), R4 = Math.min(a7, Math.max(0, (w4 - l7) / r6)), U7 = Math.max(0, (p8 - g7) / x6), j6 = Math.min(h9, Math.max(0, (p8 - d9) / x6)), E3 = Math.round(A2), I5 = Math.round(R4) - 1, P4 = Math.round(U7), v6 = Math.round(j6) - 1;
  if (E3 === I5 && A2 % 1 > 0.5 && R4 % 1 < 0.5 || P4 === v6 && U7 % 1 > 0.5 && j6 % 1 < 0.5)
    return new g({ pixelType: t5.pixelType, width: a7, height: h9, mask: o8, pixels: [...t5.pixels] });
  if (0 === E3 && 0 === P4 && I5 === a7 && v6 === h9)
    return t5;
  const b4 = t5.mask;
  for (let i7 = P4; i7 <= v6; i7++)
    for (let t6 = E3; t6 <= I5; t6++) {
      const e5 = i7 * a7 + t6;
      o8[e5] = b4 ? b4[e5] : 255;
    }
  return new g({ pixelType: t5.pixelType, width: a7, height: h9, mask: o8, pixels: [...t5.pixels] });
}
function r3(t5, e4, n9) {
  const { width: a7, height: h9 } = t5, o8 = new Uint8Array(a7 * h9), r6 = e4.width / a7, x6 = e4.height / h9, { xmin: l7, ymax: m10 } = e4, { paths: s5 } = n9, p8 = t5.mask;
  for (let i7 = 0; i7 < s5.length; i7++) {
    const t6 = s5[i7];
    for (let e5 = 0; e5 < t6.length - 1; e5++) {
      const [i8, n10] = t6[e5], [s6, f11] = t6[e5 + 1];
      let y7 = Math.floor((m10 - n10) / x6), c8 = Math.floor((m10 - f11) / x6);
      if (c8 < y7) {
        const t7 = y7;
        y7 = c8, c8 = t7;
      }
      y7 = Math.max(0, y7), c8 = Math.min(h9 - 1, c8);
      const M2 = (s6 - i8) / (f11 - n10);
      for (let t7 = y7; t7 <= c8; t7++) {
        const e6 = t7 === y7 ? Math.max(n10, f11) : (h9 + 1 - t7) * x6, m11 = t7 === c8 ? Math.min(n10, f11) : e6 - x6;
        let u11 = f11 === n10 ? Math.floor((i8 - l7) / r6) : Math.floor((M2 * (e6 - n10) + i8 - l7) / r6), w4 = f11 === n10 ? Math.floor((s6 - l7) / r6) : Math.floor((M2 * (m11 - n10) + i8 - l7) / r6);
        if (w4 < u11) {
          const t8 = u11;
          u11 = w4, w4 = t8;
        }
        const d9 = t7 * a7;
        u11 = Math.max(0, u11), w4 = Math.min(a7 - 1, w4);
        for (let t8 = d9 + u11; t8 <= d9 + w4; t8++)
          o8[t8] = p8 ? p8[t8] : 255;
      }
    }
  }
  return new g({ pixelType: t5.pixelType, width: a7, height: h9, mask: o8, pixels: [...t5.pixels] });
}
function x3(t5, i7, a7, h9 = true) {
  const { spatialReference: o8 } = t5, { x: r6, y: x6 } = n7(a7, o8);
  let l7, m10, s5;
  const p8 = "extent" === i7.type ? i7 : i7.extent;
  let { xmin: f11, xmax: y7, ymax: c8, ymin: M2 } = p8;
  const { xmin: u11, ymax: w4 } = t5.extent;
  return h9 ? (f11 = u11 + (f11 > u11 ? r6 * Math.round((f11 - u11) / r6) : 0), c8 = w4 - (c8 < w4 ? x6 * Math.round((w4 - c8) / x6) : 0), y7 = u11 + (y7 > u11 ? r6 * Math.round((y7 - u11) / r6) : 0), M2 = w4 - (M2 < w4 ? x6 * Math.round((w4 - M2) / x6) : 0), l7 = new w({ xmin: f11, ymax: c8, xmax: y7, ymin: M2, spatialReference: o8 }), m10 = Math.round(l7.width / r6), s5 = Math.round(l7.height / x6)) : (m10 = Math.floor((y7 - f11) / r6 + 0.8), s5 = Math.floor((c8 - M2) / x6 + 0.8), f11 = u11 + (f11 > u11 ? r6 * Math.floor((f11 - u11) / r6 + 0.1) : 0), c8 = w4 - (c8 < w4 ? x6 * Math.floor((w4 - c8) / x6 + 0.1) : 0), y7 = f11 + m10 * r6, M2 = c8 - s5 * x6, l7 = new w({ xmin: f11, ymax: c8, xmax: y7, ymin: M2, spatialReference: o8 })), { extent: l7, width: m10, height: s5 };
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/FunctionRaster.js
var p5 = 40;
var m6 = class extends K2 {
  constructor() {
    super(...arguments), this.datasetFormat = "Function", this.tileType = "Raster", this.rasterFunction = null, this._clippingGeometry = /* @__PURE__ */ new Map();
  }
  async open(t5) {
    var _a, _b, _c, _d;
    await this.init();
    const { rasterFunction: r6 } = this;
    ((_b = (_a = this.primaryRasters) == null ? void 0 : _a.rasters) == null ? void 0 : _b.length) ? r6.sourceRasters = this.primaryRasters.rasters : (this.primaryRasters = r6.getPrimaryRasters(), this.rasterJobHandler && ((_c = this.primaryRasters.rasters) == null ? void 0 : _c.forEach((t6) => t6.rasterJobHandler = this.rasterJobHandler)));
    const { rasters: s5, rasterIds: i7 } = this.primaryRasters, o8 = s5.map((e4) => e4.rasterInfo ? void 0 : e4.open(t5));
    await Promise.all(o8);
    const n9 = s5.map(({ rasterInfo: t6 }) => t6), a7 = r6.bind({ rasterInfos: n9, rasterIds: i7 });
    if (r6.rawSourceRasterInfos = n9, !a7.success || 0 === n9.length)
      throw new s("raster-function:open", `cannot bind the function: ${a7.error ?? ""}`);
    const l7 = "Table" === r6.functionName ? r6 : (_d = r6.functionArguments) == null ? void 0 : _d.raster;
    "Table" === (l7 == null ? void 0 : l7.functionName) && (r6.rasterInfo.attributeTable = d3.fromJSON(l7.functionArguments.attributeTableAsRecordSet)), await this.syncJobHandler();
    const p8 = n9[0];
    this.hasUniqueSourceStorageInfo = 1 === n9.length || n9.slice(1).every((t6) => h6(t6, p8)), this.set("sourceJSON", s5[0].sourceJSON), this.set("rasterInfo", r6.rasterInfo), await this._updateClipGeometry();
  }
  async syncJobHandler() {
    var _a;
    return (_a = this.rasterJobHandler) == null ? void 0 : _a.updateRasterFunction(this.rasterFunction);
  }
  async fetchPixels(t5, e4, r6, s5 = {}) {
    var _a, _b;
    const { rasters: i7, rasterIds: o8 } = this.primaryRasters;
    let l7 = false;
    const { interpolation: c8 } = s5, p8 = (_a = this.rasterFunction.flatWebGLFunctionChain) == null ? void 0 : _a.hasFocalFunction;
    !s5.requestRawData && p8 && (l7 = 1 === i7.length && !s5.skipRasterFunction, s5 = { ...s5, interpolation: "bilinear", requestRawData: l7 });
    const m10 = i7.map((i8) => i8.fetchPixels(t5, e4, r6, s5)), u11 = await Promise.all(m10), h9 = u11.map((t6) => t6.pixelBlock), f11 = l7 || s5.requestRawData ? u11.map((t6) => t6.srcTilePixelSize) : null;
    if (s5.skipRasterFunction || h9.every((t6) => null == t6))
      return u11[0];
    const d9 = ((_b = u11.find((t6) => null != t6.pixelBlock)) == null ? void 0 : _b.extent) ?? t5;
    let y7 = this.rasterJobHandler ? await this.rasterJobHandler.process({ extent: d9, primaryPixelBlocks: h9, primaryPixelSizes: f11, primaryRasterIds: o8 }) : this.rasterFunction.process({ extent: d9, primaryPixelBlocks: h9, primaryPixelSizes: f11, primaryRasterIds: o8 });
    const { transformGrid: g7 } = u11[0];
    if (!l7 || null == y7 || null == g7) {
      const t6 = s5.noClip ? null : this.getClippingGeometry(d9.spatialReference);
      return s5.noClip || s5.requestRawData || null == y7 || !t6 || (y7 = await a6(y7, d9, t6)), { ...u11[0], pixelBlock: y7 };
    }
    const x6 = { rows: g7.spacing[0], cols: g7.spacing[1] };
    let R4;
    if (this.rasterJobHandler) {
      R4 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: [y7], srcMosaicSize: { width: y7.width, height: y7.height }, destDimension: { width: e4, height: r6 }, coefs: g7.coefficients, sampleSpacing: x6, projectDirections: false, gcsGrid: null, isUV: false, interpolation: c8, alignmentInfo: void 0, blockWidths: null }, s5)).pixelBlock;
    } else
      R4 = D2(y7, { width: e4, height: r6 }, g7.coefficients, x6, c8);
    const w4 = s5.noClip ? null : this.getClippingGeometry(t5.spatialReference);
    return s5.noClip || s5.requestRawData || null == R4 || null == w4 || (R4 = await a6(R4, t5, w4)), { extent: t5, srcExtent: u11[0].srcExtent, pixelBlock: R4 };
  }
  getClippingGeometry(t5) {
    const e4 = this._clippingGeometry.get("0");
    if (!t5 || !e4)
      return e4;
    const r6 = f8(t5);
    let s5 = this._clippingGeometry.get(r6);
    return null != s5 || (s5 = t5.equals(e4.spatialReference) ? e4 : U4(e4, t5), this._clippingGeometry.set(r6, s5)), s5;
  }
  async _updateClipGeometry() {
    const t5 = this.rasterFunction.getClippingGeometries()[0];
    let e4 = t5 == null ? void 0 : t5.clippingGeometry;
    if (e4 && "inside" === t5.clippingType) {
      const { extent: t6 } = this.rasterInfo, { difference: r6, densify: s5 } = await import("./geometryEngine-SEKGYY2X.js");
      let o8 = s5(j.fromExtent(t6), 2 * (t6.width + t6.height) / p5);
      o8 = U4(o8, e4.spatialReference), e4 = r6(o8, e4);
    }
    this._clippingGeometry.clear(), e4 && this._clippingGeometry.set("0", e4);
  }
};
e([y({ type: String, json: { write: true } })], m6.prototype, "datasetFormat", void 0), e([y()], m6.prototype, "tileType", void 0), e([y()], m6.prototype, "rasterFunction", void 0), e([y()], m6.prototype, "primaryRasters", void 0), m6 = e([a2("esri.layers.support.rasterDatasets.FunctionRaster")], m6);
var u6 = m6;
function h6(t5, e4) {
  const { storageInfo: r6, pixelSize: s5, spatialReference: i7, extent: o8 } = t5, { storageInfo: n9, pixelSize: a7, spatialReference: l7, extent: c8 } = e4;
  return s5.x === a7.x && s5.y === a7.y && i7.equals(l7) && o8.equals(c8) && r6.blockHeight === n9.blockHeight && r6.blockWidth === n9.blockWidth && r6.maximumPyramidLevel === n9.maximumPyramidLevel;
}
function f8(t5) {
  return String(t5.wkid ?? t5.wkt ?? t5.wkt2);
}

// node_modules/@arcgis/core/layers/mixins/ImageryTileMixin.js
var L2 = (L3) => {
  let V4 = class extends L3 {
    constructor(...e4) {
      var _a, _b;
      super(...e4), this._isConstructedFromFunctionRaster = false, this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this.bandIds = null, this.copyright = null, this.interpolation = "nearest", this.multidimensionalSubset = null, this.raster = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.spatialReference = null, this.symbolizer = null, this._isConstructedFromFunctionRaster = "Function" === ((_b = (_a = e4[0]) == null ? void 0 : _a.raster) == null ? void 0 : _b.datasetFormat);
    }
    get fullExtent() {
      var _a;
      return (_a = this.serviceRasterInfo) == null ? void 0 : _a.extent;
    }
    set multidimensionalDefinition(e4) {
      this._set("multidimensionalDefinition", e4), this.updateRenderer();
    }
    set rasterFunction(e4) {
      var _a;
      "none" === ((_a = e4 == null ? void 0 : e4.functionName) == null ? void 0 : _a.toLowerCase()) && (e4 = void 0), this._set("rasterFunction", e4), this.updateRasterFunction();
    }
    get rasterInfo() {
      return o(n.getLogger(this), "rasterInfo", { replacement: "serviceRasterInfo", version: "4.29", warnOnce: true }), this._get("serviceRasterInfo");
    }
    set url(e4) {
      this._set("url", y3(e4, n.getLogger(this)));
    }
    set renderer(e4) {
      null == e4 && null == this.rasterFunction ? this._configDefaultRenderer("override") : (this._set("renderer", e4), this.updateRenderer());
    }
    readRenderer(e4, t5, r6) {
      var _a, _b;
      const n9 = (_b = (_a = t5 == null ? void 0 : t5.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.renderer;
      return c4(n9, r6) || void 0;
    }
    async convertVectorFieldData(e4, t5) {
      const { serviceRasterInfo: r6 } = this;
      if (null == e4 || !r6)
        return null;
      const i7 = this._rasterJobHandler.instance, n9 = r6.dataType;
      return i7 ? i7.convertVectorFieldData({ pixelBlock: e4, dataType: n9 }, t5) : f5(e4, n9);
    }
    async computeStatisticsHistograms(e4, t5) {
      e4 = v2(h3, e4).clone();
      const { serviceRasterInfo: r6 } = this, { geometry: i7 } = e4;
      if (null == i7)
        throw new s("imagery-tile-mixin:compute-statistics-histograms", "geometry must be specified");
      let n9 = i7;
      const { spatialReference: s5 } = r6;
      i7.spatialReference.equals(s5) || (await T3(), n9 = "extent" === i7.type ? J(i7, s5) : U4(i7, s5));
      const a7 = e4.pixelSize ?? new x({ x: r6.pixelSize.x, y: r6.pixelSize.y, spatialReference: s5 }), { extent: l7, width: c8, height: d9 } = x3(r6, n9, a7), m10 = await this.fetchPixels(l7, c8, d9, { ...t5, interpolation: "nearest" });
      if (null == m10.pixelBlock)
        throw new s("imagery-tile-mixin:compute-statistics-histograms", "failed to fetch pixels");
      const h9 = await a6(m10.pixelBlock, l7, n9), p8 = this._rasterJobHandler.instance;
      return p8 ? p8.computeStatisticsHistograms({ pixelBlock: h9 }, t5) : m3(h9);
    }
    async createFlowMesh(e4, t5) {
      const r6 = this._rasterJobHandler.instance;
      return r6 ? r6.createFlowMesh(e4, t5) : s3(e4.meshType, e4.simulationSettings, e4.flowData, null != t5.signal ? t5.signal : new AbortController().signal);
    }
    normalizeRasterFetchOptions(e4) {
      var _a, _b;
      const { multidimensionalInfo: t5 } = this.serviceRasterInfo ?? {};
      if (null == t5)
        return e4;
      let r6 = e4.multidimensionalDefinition || this.multidimensionalDefinition;
      (r6 == null ? void 0 : r6.length) || (r6 = d5(this.raster.rasterInfo, { multidimensionalSubset: this.multidimensionalSubset }));
      const i7 = e4.timeExtent || this.timeExtent;
      if (null != r6 && null != i7 && (null != i7.start || null != i7.end)) {
        r6 = r6.map((e5) => e5.clone());
        const n9 = (_b = (_a = t5.variables.find(({ name: e5 }) => e5 === r6[0].variableName)) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find(({ name: e5 }) => "StdTime" === e5), s5 = r6.find(({ dimensionName: e5 }) => "StdTime" === e5);
        if (!n9 || !s5)
          return { ...e4, multidimensionalDefinition: null };
        const { start: o8, end: a7 } = i7, l7 = null == o8 ? null : o8.getTime(), u11 = null == a7 ? null : a7.getTime(), c8 = l7 ?? u11, d9 = u11 ?? l7;
        if (null != n9.values) {
          const e5 = n9.values.filter((e6) => {
            if (Array.isArray(e6)) {
              if (c8 === d9)
                return e6[0] <= c8 && e6[1] >= c8;
              const t6 = e6[0] <= c8 && e6[1] > c8 || e6[0] < d9 && e6[1] >= d9, r7 = e6[0] >= c8 && e6[1] <= d9 || e6[0] < c8 && e6[1] > d9;
              return t6 || r7;
            }
            return c8 === d9 ? e6 === c8 : e6 >= c8 && e6 <= d9;
          });
          if (e5.length) {
            const t6 = e5.sort((e6, t7) => {
              const r7 = Array.isArray(e6) ? e6[0] : e6, i8 = Array.isArray(e6) ? e6[1] : e6, n10 = Array.isArray(t7) ? t7[0] : t7, s6 = Array.isArray(t7) ? t7[1] : t7;
              if (c8 === d9)
                return r7 - n10;
              return Math.abs(i8 - d9) - Math.abs(s6 - d9);
            })[0];
            s5.values = [t6];
          } else
            r6 = null;
        } else if (n9.hasRegularIntervals && n9.extent) {
          const [e5, t6] = n9.extent;
          c8 > t6 || d9 < e5 ? r6 = null : s5.values = c8 === d9 ? [c8] : [Math.max(e5, c8), Math.min(t6, d9)];
        }
      }
      return null != r6 && o4(r6, this.multidimensionalSubset) ? { ...e4, multidimensionalDefinition: null } : { ...e4, multidimensionalDefinition: r6 };
    }
    async updateRasterFunction() {
      var _a, _b, _c;
      if (!this.loaded || "imagery-tile" !== this.type || !this.rasterFunction && !this._cachedRasterFunctionJson || JSON.stringify(this.rasterFunction) === JSON.stringify(this._cachedRasterFunctionJson))
        return;
      if (this._isConstructedFromFunctionRaster && "Function" === this.raster.datasetFormat) {
        const e5 = this.raster.rasterFunction.toJSON();
        return !this.rasterFunction && e5 && this._set("rasterFunction", N3.fromJSON(e5)), void (this._cachedRasterFunctionJson = (_a = this.rasterFunction) == null ? void 0 : _a.toJSON());
      }
      let e4, t5 = this.raster, r6 = false;
      "Function" === t5.datasetFormat ? (e4 = t5.primaryRasters.rasters, t5 = e4[0], r6 = true) : e4 = [t5];
      const { rasterFunction: i7 } = this;
      if (i7) {
        const r7 = { raster: t5 };
        e4.length > 1 && e4.forEach((e5) => r7[e5.url] = e5);
        const n10 = R3(((_b = i7.functionDefinition) == null ? void 0 : _b.toJSON()) ?? i7.toJSON(), r7), s6 = new u6({ rasterFunction: n10 });
        s6.rasterJobHandler = this._rasterJobHandler.instance, await s6.open(), this._cachedRasterFunctionJson = (_c = this.rasterFunction) == null ? void 0 : _c.toJSON(), this.raster = s6;
      } else
        this.raster = t5, this._cachedRasterFunctionJson = null, await t5.when();
      if (this._cachedRendererJson = null, !r6 && !i7)
        return;
      const { bandIds: n9 } = this, { bandCount: s5 } = this.raster.rasterInfo, o8 = (n9 == null ? void 0 : n9.length) ? n9.some((e5) => e5 >= s5) : s5 >= 3;
      n9 && (o8 || this.renderer && "raster-stretch" !== this.renderer.type) && this._set("bandIds", null), this._configDefaultRenderer("auto");
    }
    async updateRenderer() {
      const { loaded: e4, symbolizer: t5 } = this;
      if (!e4 || !t5 || !this.renderer)
        return;
      const { rasterInfo: r6 } = this.raster, i7 = f7(r6, { multidimensionalDefinition: this.multidimensionalDefinition, multidimensionalSubset: this.multidimensionalSubset }), n9 = i7 == null ? void 0 : i7.name, s5 = K({ ...this.renderer.toJSON(), variableName: n9 });
      if (JSON.stringify(this._cachedRendererJson) === JSON.stringify(s5))
        return;
      const o8 = this._rasterJobHandler.instance;
      o8 && (t5.rasterInfo = B2(r6, n9), t5.rendererJSON = s5, t5.bind(), await o8.updateSymbolizer(t5), this._cachedRendererJson = s5);
    }
    async applyRenderer(e4, t5) {
      const r6 = e4 == null ? void 0 : e4.pixelBlock;
      if (!(null != r6 && r6.pixels && r6.pixels.length > 0))
        return null;
      let i7;
      await this.updateRenderer();
      const n9 = this._rasterJobHandler.instance, s5 = this.bandIds ?? [];
      return i7 = n9 ? await n9.symbolize({ ...e4, simpleStretchParams: t5, bandIds: s5 }) : this.symbolizer.symbolize({ ...e4, simpleStretchParams: t5, bandIds: s5 }), i7;
    }
    getTileUrl(e4, t5, r6) {
      return "RasterTileServer" === this.raster.datasetFormat ? `${this.url}/tile/${e4}/${t5}/${r6}` : "";
    }
    getCompatibleTileInfo(e4, t5, r6 = false) {
      if (!this.loaded || null == t5)
        return null;
      if (r6 && e4.equals(this.spatialReference))
        return this.tileInfo;
      const i7 = s2(e4);
      return j3.create({ size: 256, spatialReference: e4, origin: i7 ? { x: i7.origin[0], y: i7.origin[1] } : { x: t5.xmin, y: t5.ymax } });
    }
    getCompatibleFullExtent(e4) {
      return this.loaded ? (this._compatibleFullExtent && this._compatibleFullExtent.spatialReference.equals(e4) || (this._compatibleFullExtent = this.raster.computeExtent(e4)), this._compatibleFullExtent) : null;
    }
    async fetchTile(e4, t5, r6, i7 = {}) {
      var _a;
      if ($2(this), i7.requestAsImageElement) {
        const s6 = this.getTileUrl(e4, t5, r6);
        return U(s6, { responseType: "image", query: { ...this.refreshParameters, ...this.raster.ioConfig.customFetchParameters }, signal: i7.signal }).then((e5) => e5.data);
      }
      const { serviceRasterInfo: s5 } = this;
      if (null != s5.multidimensionalInfo && null == (i7 = this.normalizeRasterFetchOptions(i7)).multidimensionalDefinition) {
        const n9 = i7.tileInfo || s5.storageInfo.tileInfo;
        return { extent: this.raster.getTileExtentFromTileInfo(e4, t5, r6, n9), pixelBlock: null };
      }
      return await this._initJobHandler(), await this.updateRasterFunction(), "raster-shaded-relief" === ((_a = this.renderer) == null ? void 0 : _a.type) && (i7 = { ...i7, buffer: { cols: 1, rows: 1 } }), this.raster.fetchTile(e4, t5, r6, i7);
    }
    async fetchPixels(e4, t5, r6, i7 = {}) {
      return null != this.serviceRasterInfo.multidimensionalInfo && null == (i7 = this.normalizeRasterFetchOptions(i7)).multidimensionalDefinition ? { extent: e4, pixelBlock: null } : (await this._initJobHandler(), await this.updateRasterFunction(), t5 = Math.round(t5), r6 = Math.round(r6), this.raster.fetchPixels(e4, t5, r6, i7));
    }
    async identify(e4, t5 = {}) {
      var _a;
      const { raster: r6, serviceRasterInfo: i7 } = this;
      if (null != i7.multidimensionalInfo) {
        if (!(i7.hasMultidimensionalTranspose && !!(h2(t5.multidimensionalDefinition) || t5.transposedVariableName || t5.timeExtent)) && null == (t5 = this.normalizeRasterFetchOptions(t5)).multidimensionalDefinition)
          return { location: e4, value: null };
      }
      const n9 = (_a = this.multidimensionalSubset) == null ? void 0 : _a.areaOfInterest;
      if (n9 && !n9.contains(e4))
        throw new s("imagery-tile-mixin:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
      return r6.identify(e4, t5);
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    hasStandardTime() {
      var _a, _b, _c;
      const e4 = (_a = this.serviceRasterInfo) == null ? void 0 : _a.multidimensionalInfo;
      if (null == e4 || "standard-time" !== ((_b = this.serviceRasterInfo) == null ? void 0 : _b.dataType))
        return false;
      const t5 = this.multidimensionalDefinition, r6 = (_c = t5 == null ? void 0 : t5[0]) == null ? void 0 : _c.variableName;
      return e4.variables.some((e5) => e5.name === r6 && (!(t5 == null ? void 0 : t5[0].dimensionName) || e5.dimensions.some((e6) => "StdTime" === e6.name)));
    }
    getStandardTimeValue(e4) {
      return new Date(24 * (e4 - 25569) * 3600 * 1e3).toString();
    }
    getMultidimensionalSubsetVariables(e4) {
      var _a;
      const t5 = e4 ?? ((_a = this.serviceRasterInfo) == null ? void 0 : _a.multidimensionalInfo);
      return g3(this.multidimensionalSubset, t5);
    }
    _configDefaultSettings() {
      this._configDefaultInterpolation(), this.multidimensionalDefinition || (this.multidimensionalDefinition = d5(this.raster.rasterInfo, { multidimensionalSubset: this.multidimensionalSubset })), this.rasterFunction && "Function" === this.raster.datasetFormat && (this._cachedRasterFunctionJson = this.rasterFunction.toJSON()), this._configDefaultRenderer();
    }
    _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise)
        return this._rasterJobHandler.connectionPromise;
      const e4 = new t2();
      return this._rasterJobHandler.connectionPromise = e4.initialize().then(async () => {
        $2(this), this._rasterJobHandler.instance = e4, this.raster.rasterJobHandler = e4, "Function" === this.raster.datasetFormat && this.raster.syncJobHandler(), this.rasterFunction && await this.updateRasterFunction().catch(() => {
        }), this.renderer && this.updateRenderer();
      }).catch(() => {
      }), this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null, this.raster && (this.raster.rasterJobHandler = null);
    }
    _configDefaultInterpolation() {
      var _a;
      if (null == this.interpolation) {
        $2(this);
        const { raster: e4 } = this, t5 = S2(e4.rasterInfo, e4.tileType, (_a = this.sourceJSON) == null ? void 0 : _a.defaultResamplingMethod);
        this._set("interpolation", t5);
      }
    }
    _configDefaultRenderer(e4 = "no") {
      var _a, _b;
      $2(this);
      const { rasterInfo: t5 } = this.raster;
      !this.bandIds && t5.bandCount > 1 && (this.bandIds = E2(t5));
      const r6 = f7(t5, { multidimensionalDefinition: this.multidimensionalDefinition, multidimensionalSubset: this.multidimensionalSubset }), i7 = r6 == null ? void 0 : r6.name;
      if (!this.renderer || "override" === e4) {
        const e5 = V2(t5, { bandIds: this.bandIds, variableName: i7 }), r7 = t5.statistics, n10 = r7 && r7.length > 0 ? r7[0] : null, s6 = (n10 == null ? void 0 : n10.max) ?? 0, o9 = (n10 == null ? void 0 : n10.min) ?? 0;
        "WCSServer" === this.raster.datasetFormat && "raster-stretch" === e5.type && (s6 > 1e24 || o9 < -1e24) && (e5.dynamicRangeAdjustment = true, e5.statistics = null, "none" === e5.stretchType && (e5.stretchType = "min-max")), this.renderer = e5;
      }
      const n9 = K({ ...this.renderer.toJSON(), variableName: i7 }), s5 = B2(t5, i7);
      this.symbolizer ? (this.symbolizer.rendererJSON = n9, this.symbolizer.rasterInfo = s5) : this.symbolizer = new U5({ rendererJSON: n9, rasterInfo: s5 });
      const o8 = this.symbolizer.bind();
      if (o8.success) {
        if ("auto" === e4) {
          const { colormap: e5 } = this.raster.rasterInfo, t6 = this.renderer;
          if (null != e5 && "raster-colormap" === t6.type) {
            const e6 = V2(this.raster.rasterInfo);
            JSON.stringify(e6) !== JSON.stringify(t6) && this._configDefaultRenderer("override");
          } else if ("raster-stretch" === t6.type) {
            const e6 = (_a = this.bandIds) == null ? void 0 : _a.length, r7 = (_b = t6.statistics) == null ? void 0 : _b.length;
            !t6.dynamicRangeAdjustment && r7 && e6 && r7 !== e6 && this._configDefaultRenderer("override");
          }
        }
      } else
        n.getLogger(this).warn("imagery-tile-mixin", o8.error || "The given renderer is not supported by the layer."), "auto" === e4 && this._configDefaultRenderer("override");
    }
  };
  function $2(e4) {
    if (!e4.raster || !e4.serviceRasterInfo)
      throw new s("imagery-tile", "no raster");
  }
  return e([y({ clonable: false })], V4.prototype, "_cachedRendererJson", void 0), e([y({ clonable: false })], V4.prototype, "_cachedRasterFunctionJson", void 0), e([y({ clonable: false })], V4.prototype, "_compatibleFullExtent", void 0), e([y({ clonable: false })], V4.prototype, "_isConstructedFromFunctionRaster", void 0), e([y({ clonable: false })], V4.prototype, "_rasterJobHandler", void 0), e([y()], V4.prototype, "bandIds", void 0), e([y({ json: { origins: { service: { read: { source: "copyrightText" } } } } })], V4.prototype, "copyright", void 0), e([y({ json: { read: false } })], V4.prototype, "fullExtent", null), e([y()], V4.prototype, "interpolation", void 0), e([y()], V4.prototype, "ioConfig", void 0), e([y({ type: [p3], json: { write: true } })], V4.prototype, "multidimensionalDefinition", null), e([y({ type: c5, json: { write: true } })], V4.prototype, "multidimensionalSubset", void 0), e([y()], V4.prototype, "raster", void 0), e([y({ type: N3, json: { name: "renderingRule", write: true } })], V4.prototype, "rasterFunction", null), e([y({ readOnly: true })], V4.prototype, "rasterInfo", null), e([y()], V4.prototype, "serviceRasterInfo", void 0), e([y()], V4.prototype, "sourceJSON", void 0), e([y({ readOnly: true, type: f2, json: { read: false } })], V4.prototype, "spatialReference", void 0), e([y({ type: j3 })], V4.prototype, "tileInfo", void 0), e([y(d2)], V4.prototype, "url", null), e([y({ types: l4, json: { name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy() {
    var _a;
    const e4 = "raster-stretch" === ((_a = this.renderer) == null ? void 0 : _a.type) && "none" === this.renderer.stretchType && !this.renderer.useGamma;
    return { enabled: !this.loaded || "Raster" === this.raster.tileType || !e4 };
  } }, origins: { "web-scene": { types: d4, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e4) => ({ enabled: e4 && "vector-field" !== e4.type && "flow" !== e4.type }) } } } } })], V4.prototype, "renderer", null), e([o2("renderer")], V4.prototype, "readRenderer", null), e([y({ clonable: false })], V4.prototype, "symbolizer", void 0), V4 = e([a2("esri.layers.mixins.ImageryTileMixin")], V4), V4;
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/DBFParser.js
function t3(e4) {
  const t5 = e4.fields, r6 = e4.records, n9 = t5.some((e5) => "oid" === e5.name.toLowerCase()) ? "OBJECTID" : "OID", i7 = [{ name: n9, type: "esriFieldTypeOID", alias: "OID" }].concat(t5.map((e5) => ({ name: e5.name, type: "esriFieldType" + e5.typeName, alias: e5.name }))), s5 = i7.map((e5) => e5.name), a7 = [];
  let o8 = 0, l7 = 0;
  return r6.forEach((e5) => {
    const t6 = {};
    for (t6[n9] = o8++, l7 = 1; l7 < s5.length; l7++)
      t6[s5[l7]] = e5[l7 - 1];
    a7.push({ attributes: t6 });
  }), { displayFieldName: "", fields: i7, features: a7 };
}
var r4 = class {
  static get supportedVersions() {
    return [5];
  }
  static parse(r6) {
    const n9 = new DataView(r6), i7 = 3 & n9.getUint8(0);
    if (3 !== i7)
      return { header: { version: i7 }, recordSet: null };
    const s5 = n9.getUint32(4, true), a7 = n9.getUint16(8, true), o8 = n9.getUint16(10, true), l7 = { version: i7, recordCount: s5, headerByteCount: a7, recordByteCount: o8 };
    let p8 = 32;
    const g7 = [], u11 = [];
    let d9;
    if (3 === i7) {
      for (; 13 !== n9.getUint8(p8); )
        d9 = String.fromCharCode(n9.getUint8(p8 + 11)).trim(), g7.push({ name: r(new Uint8Array(r6, p8, 11)), type: d9, typeName: ["String", "Date", "Double", "Boolean", "String", "Integer"][["C", "D", "F", "L", "M", "N"].indexOf(d9)], length: n9.getUint8(p8 + 16) }), p8 += 32;
      if (p8 += 1, g7.length > 0)
        for (; u11.length < s5 && r6.byteLength - p8 > o8; ) {
          const t5 = [];
          32 === n9.getUint8(p8) ? (p8 += 1, g7.forEach((n10) => {
            if ("C" === n10.type)
              t5.push(r(new Uint8Array(r6, p8, n10.length)).trim());
            else if ("N" === n10.type)
              t5.push(parseInt(String.fromCharCode.apply(null, new Uint8Array(r6, p8, n10.length)).trim(), 10));
            else if ("F" === n10.type)
              t5.push(parseFloat(String.fromCharCode.apply(null, new Uint8Array(r6, p8, n10.length)).trim()));
            else if ("D" === n10.type) {
              const e4 = String.fromCharCode.apply(null, new Uint8Array(r6, p8, n10.length)).trim();
              t5.push(new Date(parseInt(e4.substring(0, 4), 10), parseInt(e4.substring(4, 6), 10) - 1, parseInt(e4.substring(6, 8), 10)));
            }
            p8 += n10.length;
          }), u11.push(t5)) : p8 += o8;
        }
    }
    return { header: l7, fields: g7, records: u11, recordSet: t3({ fields: g7, records: u11 }) };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/CloudRaster.js
var g4 = /* @__PURE__ */ new Map();
g4.set("int16", "esriFieldTypeSmallInteger"), g4.set("int32", "esriFieldTypeInteger"), g4.set("int64", "esriFieldTypeInteger"), g4.set("float32", "esriFieldTypeSingle"), g4.set("float64", "esriFieldTypeDouble"), g4.set("text", "esriFieldTypeString");
var y5 = 8;
var x4 = class extends K2 {
  constructor() {
    super(...arguments), this.storageInfo = null, this.datasetFormat = "CRF";
  }
  async open(e4) {
    await this.init();
    const { data: r6 } = await this.request(this.url + "/conf.json", { signal: e4 == null ? void 0 : e4.signal });
    if (!I2(r6))
      throw new s("cloudraster:open", "Invalid or unsupported conf.json.");
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const { storageInfo: o8, rasterInfo: i7 } = S3(r6);
    if ("thematic" === i7.dataType) {
      const e5 = await this._fetchAuxiliaryInformation();
      i7.attributeTable = e5;
    }
    this._set("storageInfo", o8), this._set("rasterInfo", i7), this.ioConfig.retryCount = this.ioConfig.retryCount || 0;
  }
  async fetchRawTile(e4, t5, r6, o8 = {}) {
    const { transposeInfo: i7 } = this.rasterInfo.storageInfo, { transposedVariableName: n9 } = o8, s5 = !(!i7 || !n9), a7 = s5 ? 0 : this.rasterInfo.storageInfo.maximumPyramidLevel - e4;
    if (a7 < 0)
      return null;
    const l7 = this._buildCacheFilePath(a7, t5, r6, o8.multidimensionalDefinition, n9), f11 = this._getIndexRecordFromBundle(t5, r6, s5), c8 = await this.request(l7, { range: { from: 0, to: this.storageInfo.headerSize - 1 }, responseType: "array-buffer", signal: o8.signal });
    if (!c8)
      return null;
    const m10 = z(new Uint8Array(c8.data), f11);
    if (0 === m10.recordSize)
      return null;
    const u11 = await this.request(l7, { range: { from: m10.position, to: m10.position + m10.recordSize }, responseType: "array-buffer", signal: o8.signal });
    if (!u11)
      return null;
    const [p8, d9] = this._getTileSize(s5);
    return this.decodePixelBlock(u11.data, { width: p8, height: d9, planes: null, pixelType: null, returnInterleaved: s5 });
  }
  async _fetchAuxiliaryInformation(e4) {
    const t5 = this.request(this.url + "/conf.vat.json", { signal: e4 }).then((e5) => e5.data).catch(() => null), r6 = this.request(this.url + "/conf.vat.dbf", { responseType: "array-buffer", signal: e4 }).then((e5) => e5.data).catch(() => null), o8 = await Promise.all([t5, r6]);
    let i7;
    if (o8[0]) {
      let e5 = o8[0].fields;
      const t6 = o8[0].values;
      if (e5 && t6) {
        e5 = e5.map((e6) => ({ type: "OID" === e6.name ? "esriFieldTypeOID" : g4.get(e6.type), name: e6.name, alias: e6.alias || e6.name }));
        const r7 = t6.map((e6) => ({ attributes: e6 }));
        e5 && t6 && (i7 = { fields: e5, features: r7 });
      }
    }
    if (!i7 && o8[1]) {
      i7 = r4.parse(o8[1]).recordSet;
    }
    return d3.fromJSON(i7);
  }
  _buildCacheFilePath(e4, t5, r6, o8, i7) {
    const n9 = this._getPackageSize(!!i7), s5 = Math.floor(t5 / n9) * n9, a7 = Math.floor(r6 / n9) * n9, l7 = "R" + b2(s5) + "C" + b2(a7);
    let f11 = "L";
    f11 += e4 >= 10 ? e4.toString() : "0" + e4.toString();
    const { multidimensionalInfo: c8 } = this.rasterInfo, m10 = o8 == null ? void 0 : o8[0];
    if (null == c8 || !m10)
      return `${this.url}/_alllayers/${f11}/${l7}.bundle`;
    let u11 = "_yxs";
    if (!i7) {
      u11 = c8.variables.find((e6) => e6.name === m10.variableName).dimensions[0].values.indexOf(m10.values[0]).toString(16);
      const e5 = 4 - u11.length;
      for (let t6 = 0; t6 < e5; t6++)
        u11 = "0" + u11;
      u11 = "S" + u11;
    }
    const p8 = v3(i7 || m10.variableName);
    return `${this.url}/_alllayers/${p8}/${u11}/${f11}/${l7}.bundle`;
  }
  _getPackageSize(e4 = false) {
    const { transposeInfo: t5 } = this.rasterInfo.storageInfo;
    return e4 && null != t5 ? t5.packetSize ?? 0 : this.storageInfo.packetSize;
  }
  _getTileSize(e4 = false) {
    const { storageInfo: t5 } = this.rasterInfo, { transposeInfo: r6 } = t5;
    return e4 && null != r6 ? r6.tileSize : t5.tileInfo.size;
  }
  _getIndexRecordFromBundle(e4, t5, r6 = false) {
    const o8 = this._getPackageSize(r6), i7 = o8 * (e4 % o8) + t5 % o8;
    if (i7 < 0)
      throw new Error("Invalid level / row / col");
    return 20 + i7 * this.storageInfo.recordSize + 44;
  }
};
function I2(e4) {
  const t5 = ["origin", "extent", "geodataXform", "LODInfos", "blockWidth", "blockHeight", "bandCount", "pixelType", "pixelSizeX", "pixelSizeY", "format", "packetSize"];
  return e4 && "RasterInfo" === e4.type && !t5.some((t6) => !e4[t6]);
}
function S3(e4) {
  var _a, _b, _c, _d, _e;
  const t5 = ["u1", "u2", "u4", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"][e4.pixelType], { bandCount: r6, colormap: o8, blockWidth: l7, blockHeight: f11, firstPyramidLevel: c8, maximumPyramidLevel: m10 } = e4, u11 = (_a = e4.statistics) == null ? void 0 : _a.map((e5) => ({ min: e5.min, max: e5.max, avg: e5.mean, stddev: e5.standardDeviation, median: e5.median, mode: e5.mode })), g7 = ((_d = (_c = (_b = e4.histograms) == null ? void 0 : _b[0]) == null ? void 0 : _c.counts) == null ? void 0 : _d.length) ? e4.histograms : null, x6 = e4.extent.spatialReference, I5 = (_e = e4.geodataXform) == null ? void 0 : _e.spatialReference, S6 = new f2((x6 == null ? void 0 : x6.wkid) || (x6 == null ? void 0 : x6.wkt) || (x6 == null ? void 0 : x6.wkt2) ? x6 : I5);
  let v6 = new w({ xmin: e4.extent.xmin, ymin: e4.extent.ymin, xmax: e4.extent.xmax, ymax: e4.extent.ymax, spatialReference: S6 });
  const z2 = new x({ x: e4.pixelSizeX, y: e4.pixelSizeY, spatialReference: S6 }), b4 = Math.round((v6.xmax - v6.xmin) / z2.x), k5 = Math.round((v6.ymax - v6.ymin) / z2.y), T5 = w2(e4.geodataXform), j6 = T5 ? v6 : null;
  T5 && (v6 = T5.forwardTransform(v6), z2.x = (v6.xmax - v6.xmin) / b4, z2.y = (v6.ymax - v6.ymin) / k5);
  const R4 = e4.properties ?? {}, _3 = e4.format.toLowerCase().replace("cache/", ""), C3 = new x(e4.origin.x, e4.origin.y, S6);
  let F3, P4, L3, D6;
  if (o8 == null ? void 0 : o8.colors)
    for (F3 = [], P4 = 0; P4 < o8.colors.length; P4++)
      L3 = o8.colors[P4], D6 = o8.values ? o8.values[P4] : P4, F3.push([D6, 255 & L3, L3 << 16 >>> 24, L3 << 8 >>> 24, L3 >>> 24]);
  const M2 = e4.LODInfos, O = [];
  for (P4 = 0; P4 < M2.levels.length; P4++)
    O.push(new p({ level: M2.levels[P4], resolution: M2.resolutions[P4], scale: 96 / 0.0254 * M2.resolutions[P4] }));
  const B3 = new j3({ dpi: 96, lods: O, format: _3, origin: C3, size: [l7, f11], spatialReference: S6 }), $2 = { recordSize: y5, packetSize: e4.packetSize, headerSize: e4.packetSize * e4.packetSize * y5 + 64 }, q = [{ maxCol: Math.ceil(b4 / l7) - 1, maxRow: Math.ceil(k5 / f11) - 1, minCol: 0, minRow: 0 }];
  let X2 = 2;
  if (m10 > 0)
    for (P4 = 0; P4 < m10; P4++)
      q.push({ maxCol: Math.ceil(b4 / X2 / l7) - 1, maxRow: Math.ceil(k5 / X2 / f11) - 1, minCol: 0, minRow: 0 }), X2 *= 2;
  const N4 = e4.mdInfo;
  let A2 = null;
  if (N4 && R4._yxs) {
    const e5 = R4._yxs;
    A2 = { packetSize: e5.PacketSize, tileSize: [e5.TileXSize, e5.TileYSize] };
  }
  return { storageInfo: $2, rasterInfo: new m2({ width: b4, height: k5, pixelType: t5, bandCount: r6, extent: v6, nativeExtent: j6, transform: T5, spatialReference: S6, pixelSize: z2, keyProperties: R4, statistics: u11, histograms: g7, multidimensionalInfo: N4, colormap: F3, storageInfo: new n6({ blockWidth: l7, blockHeight: f11, pyramidBlockWidth: l7, pyramidBlockHeight: f11, origin: C3, tileInfo: B3, transposeInfo: A2, firstPyramidLevel: c8, maximumPyramidLevel: m10, blockBoundary: q }) }) };
}
function w2(e4) {
  var _a, _b;
  if (!f6(e4))
    throw new s("cloudraster:open", "the data contains unsupported geodata transform types");
  const r6 = i2(e4);
  if ("identity" === r6.type)
    return null;
  if ("polynomial" !== r6.type || !((_a = r6.forwardCoefficients) == null ? void 0 : _a.length) || !((_b = r6.inverseCoefficients) == null ? void 0 : _b.length))
    throw new s("cloudraster:open", "the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");
  return r6;
}
function v3(e4) {
  return "" === (e4 = e4.trim()) ? "_v" : e4.replaceAll(/[\{|\}\-]/g, "_").replace("\\*", "_v");
}
function z(e4, t5) {
  const r6 = e4.subarray(t5, t5 + 8);
  let o8, i7 = 0;
  for (o8 = 0; o8 < 5; o8++)
    i7 |= (255 & r6[o8]) << 8 * o8;
  const n9 = 1099511627775 & i7;
  for (i7 = 0, o8 = 5; o8 < 8; o8++)
    i7 |= (255 & r6[o8]) << 8 * (o8 - 5);
  return { position: n9, recordSize: 1099511627775 & i7 };
}
function b2(e4) {
  let t5 = e4.toString(16);
  if (4 !== t5.length) {
    let e5 = 4 - t5.length;
    for (; e5-- > 0; )
      t5 = "0" + t5;
  }
  return t5;
}
e([y({ readOnly: true })], x4.prototype, "storageInfo", void 0), e([y({ type: String, json: { write: true } })], x4.prototype, "datasetFormat", void 0), x4 = e([a2("esri.layers.support.rasterDatasets.CloudRaster")], x4);
var k3 = x4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/covJSONParser.js
function i5(e4) {
  return ["x", "e", "east", "long", "longitude"].includes(e4.toLowerCase());
}
function r5(e4) {
  return ["y", "n", "west", "lat", "latitude"].includes(e4.toLowerCase());
}
function o6(e4) {
  const { axes: n9 } = e4.domain, l7 = Object.keys(n9), s5 = [], o8 = [];
  let u11 = -1, m10 = -1, c8 = [];
  for (let t5 = 0; t5 < l7.length; t5++) {
    const e5 = l7[t5];
    i5(e5) ? u11 = t5 : r5(e5) && (m10 = t5);
    const a7 = n9[e5], d10 = [];
    if ("values" in a7) {
      a7.values.forEach((e7) => d10.push("string" == typeof e7 ? new Date(e7).getTime() : e7));
      const e6 = d10[1] - d10[0];
      s5.push([d10[0] - 0.5 * e6, d10[d10.length - 1] + 0.5 * e6]), o8.push(e6);
    } else {
      const { start: e6, stop: t6, num: n10 } = a7, l8 = (t6 - e6) / (n10 - 1);
      s5.push([e6 - 0.5 * l8, t6 + 0.5 * l8]), o8.push(l8);
      for (let s6 = 0; s6 < n10; s6++)
        d10.push(e6 + l8 * s6);
    }
    c8.push({ name: e5, values: d10, extent: [d10[0], d10[d10.length - 1]] });
  }
  u11 > -1 && -1 === m10 ? m10 = 0 === u11 ? 1 : 0 : m10 > -1 && -1 === u11 ? u11 = 0 === m10 ? 1 : 0 : -1 === m10 && -1 === u11 && (u11 = 0, m10 = 1), c8 = c8.filter((e5, t5) => !(t5 === u11 || t5 === m10));
  const { referencing: d9 } = e4.domain, f11 = d9.find((e5) => e5.coordinates.includes(l7[u11])).system.id, p8 = f11 == null ? void 0 : f11.slice(f11.lastIndexOf("/") + 1), h9 = null == p8 || "CRS84" === p8 ? 4326 : Number(p8), g7 = new f2({ wkid: h9 }), [b4, y7] = s5[u11], [x6, j6] = s5[m10], v6 = new w({ xmin: b4, xmax: y7, ymin: x6, ymax: j6, spatialReference: g7 });
  return { width: Math.round(v6.width / o8[u11]), height: Math.round(v6.height / o8[m10]), extent: v6, dimensions: c8 };
}
function u7(e4) {
  const t5 = a3();
  return t5 ? e4[t5] ?? Object.values(e4)[0] : Object.values(e4)[0];
}
function m7() {
  return Math.round(255 * Math.random());
}
function c6(t5) {
  var _a, _b;
  const n9 = {}, { parameters: l7 } = t5;
  if (!l7)
    return n9;
  for (const [s5, a7] of Object.entries(l7)) {
    const { type: t6, description: l8, unit: i7, categoryEncoding: r6, observedProperty: o8 } = a7;
    if ("Parameter" === t6 && (n9[s5] = {}, l8 && (n9[s5].description = u7(l8)), i7 && (n9[s5].unit = i7.label ? u7(i7.label) : null, n9[s5].symbol = (_a = i7.symbol) == null ? void 0 : _a.value), r6)) {
      const t7 = Object.entries(r6).map((e4, t8) => ({ OID: t8, Value: Number(e4[1]), ClassName: e4[0].slice(e4[0].lastIndexOf("/") + 1), Count: 1 }));
      let l9 = false;
      ((_b = o8 == null ? void 0 : o8.categories) == null ? void 0 : _b.length) && (o8.categories.forEach((n10) => {
        if (!n10.id)
          return;
        const s6 = n10.id.slice(n10.id.lastIndexOf("/") + 1), a9 = t7.find((e4) => e4.ClassName === s6);
        if (!a9)
          return;
        const i8 = n10.label ? u7(n10.label) : null;
        if (a9.Label = i8, n10.preferredColor) {
          const t8 = u3.fromHex(n10.preferredColor);
          t8 && (l9 = true, a9.Red = t8.r, a9.Green = t8.g, a9.Blue = t8.b);
        }
      }), l9 && t7.forEach((e4) => {
        null == e4.Red && (e4.Red = m7(), e4.Green = m7(), e4.Blue = m7());
      }));
      const a8 = { objectIdFieldName: "", fields: [{ name: "OID", type: "esriFieldTypeOID", alias: "OID", domain: null }, { name: "Value", type: "esriFieldTypeInteger", alias: "Value", domain: null }, { name: "Count", type: "esriFieldTypeDouble", alias: "Count", domain: null }, { name: "ClassName", type: "esriFieldTypeString", alias: "ClassName", domain: null, length: 50 }, { name: "Label", type: "esriFieldTypeString", alias: "Label", domain: null, length: 50 }], features: t7.map((e4) => ({ attributes: e4 })) };
      l9 && a8.fields.push({ name: "Red", type: "esriFieldTypeInteger", alias: "Red", domain: null }, { name: "Green", type: "esriFieldTypeInteger", alias: "Green", domain: null }, { name: "Blue", type: "esriFieldTypeInteger", alias: "Blue", domain: null }), n9[s5].attributeTable = a8;
    }
  }
  return n9;
}
function d6(e4) {
  let t5 = Number.MAX_VALUE, n9 = -Number.MAX_VALUE;
  for (let l7 = 0; l7 < e4.length; l7++) {
    const s5 = e4[l7];
    null != s5 && (s5 < t5 && (t5 = s5), s5 > n9 && (n9 = s5));
  }
  return u4(t5, n9);
}
function f9(e4, t5, n9) {
  const l7 = e4.map((e5, n10) => ({ name: e5, count: t5[n10] })).sort((e5, t6) => e5.name > t6.name ? -1 : 1), s5 = (a7 = 1, (e5) => a7 *= e5.count);
  var a7;
  const i7 = [...l7.slice(1), { name: "", count: 1 }].reverse().map(s5).reverse();
  let r6 = 0;
  for (let o8 = e4.length - 1; o8 >= 0; o8--) {
    r6 += i7[l7.findIndex(({ name: t6 }) => t6 === e4[o8])] * (n9 % t5[o8]), n9 = Math.floor(n9 / t5[o8]);
  }
  return r6;
}
function p6(e4) {
  var _a;
  const { width: t5, height: n9, extent: s5, dimensions: a7 } = o6(e4), { ranges: i7 } = e4, r6 = Object.keys(i7).sort((e5, t6) => e5 < t6 ? -1 : 1), u11 = [];
  for (let l7 = 0; l7 < r6.length; l7++) {
    const e5 = r6[l7];
    (a7 == null ? void 0 : a7.length) && u11.push({ name: e5, dimensions: a7 });
  }
  const m10 = c6(e4);
  u11.forEach((e5) => m10[e5.name] && Object.assign(e5, m10[e5.name]));
  const p8 = u11.length ? { variables: u11 } : void 0, h9 = [];
  for (let o8 = 0; o8 < r6.length; o8++) {
    const e5 = r6[o8], { values: s6, dataType: u12, axisNames: m11, shape: c8 } = i7[e5], p9 = c8.length > 2 ? o8 * c8.slice(0, -2).reduce((e6, t6) => e6 * t6) : 0, g8 = m11.slice(0, -2), b4 = c8.slice(0, -2), y7 = "float" === u12 ? "f32" : d6(s6), x6 = t5 * n9, j6 = s6.length / x6;
    for (let i8 = 0; i8 < j6; i8++) {
      const e6 = g.createEmptyBand(y7, x6), r7 = new Uint8Array(x6).fill(255);
      let u13 = false;
      const m12 = i8 * x6;
      for (let t6 = 0; t6 < x6; t6++) {
        const n10 = s6[m12 + t6];
        null == n10 ? (r7[t6] = 0, u13 = true) : e6[t6] = n10;
      }
      if (0 === o8 || (a7 == null ? void 0 : a7.length)) {
        const s7 = new g({ width: t5, height: n9, mask: u13 ? r7 : null, pixels: [e6], pixelType: y7 });
        if (s7.updateStatistics(), a7 == null ? void 0 : a7.length) {
          h9[f9(g8, b4, i8) + p9] = s7;
        } else
          h9.push(s7);
      } else {
        const t6 = h9[i8];
        t6.pixels.push(e6), u13 ? t6.mask && (t6.mask = g.combineBandMasks([t6.mask, r7])) : t6.mask = u13 ? r7 : null;
      }
    }
  }
  const g7 = (_a = Object.values(m10).find((e5) => e5.attributeTable)) == null ? void 0 : _a.attributeTable;
  return { extent: s5, pixelBlocks: h9, multidimensionalInfo: p8, attributeTable: g7, bandNames: p8 ? void 0 : r6 };
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/InMemoryRaster.js
var f10 = class extends K2 {
  constructor() {
    super(...arguments), this.datasetFormat = "MEMORY", this.source = null;
  }
  get url() {
    return "";
  }
  async open(t5) {
    await this.init();
    const e4 = this.source, { pixelBlocks: s5, attributeTable: i7, statistics: r6, histograms: o8, name: l7, nativeExtent: n9, transform: m10 } = e4, c8 = s5[0], { width: p8, height: u11, pixelType: f11 } = c8, g7 = e4.extent ?? new w({ xmin: -0.5, ymin: 0.5, xmax: p8 - 0.5, ymax: u11 - 0.5, spatialReference: new f2({ wkid: 3857 }) }), x6 = e4.isPseudoSpatialReference ?? !e4.extent, y7 = { x: g7.width / p8, y: g7.height / u11 }, b4 = { ...e4.keyProperties };
    i7 && (b4.DataType = "Thematic");
    const v6 = new m2({ width: p8, height: u11, pixelType: f11, extent: g7, nativeExtent: n9, attributeTable: i7, transform: m10, pixelSize: y7, spatialReference: g7.spatialReference, bandCount: c8.pixels.length, keyProperties: b4, multidimensionalInfo: e4.multidimensionalInfo, statistics: r6, isPseudoSpatialReference: x6, histograms: o8 });
    this.ioConfig.skipMapInfo && this.updateImageSpaceRasterInfo(v6), this.createRemoteDatasetStorageInfo(v6, 512, 512), this._set("rasterInfo", v6), this.updateTileInfo(), v6.multidimensionalInfo ? await this._buildMDimStats(e4.pixelBlocks, v6.multidimensionalInfo) : await this._buildInMemoryRaster(c8, { width: 512, height: 512 }, t5), v6.multidimensionalInfo || (this.source = null), this.datasetName = l7;
  }
  fetchRawTile(t5, e4, s5, i7 = {}) {
    if (!this._pixelBlockTiles) {
      const { rasterInfo: r7 } = this, [o8, a7] = r7.storageInfo.tileInfo.size, { sliceId: l7 } = i7, { pixelBlocks: n9 } = this.source, c8 = { pixelBlock: null == l7 ? n9[0] : n9[l7], useBilinear: "thematic" !== r7.dataType, tileSize: { width: o8, height: a7 }, level: t5, row: e4, col: s5 }, p8 = this.rasterJobHandler ? this.rasterJobHandler.clipTile(c8, i7) : E(c8);
      return Promise.resolve(p8);
    }
    const r6 = this._pixelBlockTiles.get(`${t5}/${e4}/${s5}`);
    return Promise.resolve(r6);
  }
  async _buildInMemoryRaster(t5, i7, r6) {
    var _a, _b;
    const { rasterInfo: o8 } = this, a7 = o8.storageInfo.maximumPyramidLevel ?? 0, l7 = "thematic" !== o8.dataType, n9 = this.rasterJobHandler ? this.rasterJobHandler.split({ pixelBlock: t5, tileSize: i7, maximumPyramidLevel: a7, useBilinear: l7 }, r6) : Promise.resolve(W2(t5, i7, a7, l7)), m10 = null != o8.statistics, u11 = null != o8.histograms, h9 = this.ioConfig.skipStatistics || m10 ? Promise.resolve({ statistics: null, histograms: null }) : this.rasterJobHandler ? this.rasterJobHandler.estimateStatisticsHistograms({ pixelBlock: t5 }, r6) : Promise.resolve(h(t5)), d9 = await v([n9, h9]);
    if (!d9[0].value && d9[1].value)
      throw new s("inmemory-raster:open", "failed to build in memory raster");
    this._pixelBlockTiles = d9[0].value, m10 || (o8.statistics = (_a = d9[1].value) == null ? void 0 : _a.statistics), u11 || (o8.histograms = (_b = d9[1].value) == null ? void 0 : _b.histograms);
  }
  async _buildMDimStats(t5, e4, s5) {
    for (let i7 = 0; i7 < e4.variables.length; i7++) {
      const r6 = e4.variables[i7];
      if (r6.statistics)
        continue;
      const a7 = r6.dimensions.map((t6) => {
        var _a, _b;
        return new p3({ variableName: r6.name, dimensionName: t6.name, values: [((_a = t6.values) == null ? void 0 : _a[0]) ?? ((_b = t6.extent) == null ? void 0 : _b[0])], isSlice: true });
      }), l7 = D4(a7, e4), m10 = null == l7 ? null : t5[l7];
      if (null == m10)
        continue;
      const c8 = this.rasterJobHandler ? await this.rasterJobHandler.computeStatisticsHistograms({ pixelBlock: m10 }, s5) : m3(m10);
      r6.statistics = c8.statistics, r6.histograms || (r6.histograms = c8.histograms);
    }
  }
};
e([y({ type: String, json: { write: true } })], f10.prototype, "datasetFormat", void 0), e([y()], f10.prototype, "source", void 0), e([y()], f10.prototype, "url", null), f10 = e([a2("esri.layers.support.rasterDatasets.InMemoryRaster")], f10);
var g5 = f10;

// node_modules/@arcgis/core/layers/support/rasterDatasets/CovJSONRaster.js
var m8 = class extends K2 {
  constructor() {
    super(...arguments), this.datasetFormat = "CovJSON";
  }
  async open(e4) {
    await this.init();
    const { extent: t5, pixelBlocks: r6, multidimensionalInfo: s5, attributeTable: a7, bandNames: o8 } = await this._fetchData(e4), { statistics: i7, histograms: n9 } = m3(r6[0]), m10 = o8 == null ? void 0 : o8.map((e5) => ({ BandName: e5 })), h9 = { DataType: a7 ? "Thematic" : s5 ? "Scientific" : "Generic", BandProperties: m10 }, d9 = new g5({ source: { extent: t5, pixelBlocks: r6, attributeTable: a7 ? d3.fromJSON(a7) : null, multidimensionalInfo: s5, statistics: i7, histograms: n9, keyProperties: h9, isPseudoSpatialReference: false } });
    await d9.open(), this._inMemoryRaster = d9;
    const u11 = this.source ? "" : this.url.slice(this.url.lastIndexOf("/") + 1);
    this._set("datasetName", u11.slice(0, u11.indexOf("."))), this._set("rasterInfo", d9.rasterInfo);
  }
  fetchRawTile(e4, t5, r6, s5 = {}) {
    return this._inMemoryRaster.fetchRawTile(e4, t5, r6, s5);
  }
  async _fetchData(e4) {
    var _a, _b, _c, _d;
    const r6 = this.source ?? (await this.request(this.url, { signal: e4 == null ? void 0 : e4.signal })).data, s5 = "imagery-tile-layer:open-coverage-json";
    if ("coverage" !== ((_a = r6.type) == null ? void 0 : _a.toLowerCase()) || "grid" !== ((_c = (_b = r6.domain) == null ? void 0 : _b.domainType) == null ? void 0 : _c.toLowerCase()))
      throw new s(s5, "Only coverage with Grid domain type is supported");
    if (!r6.ranges)
      throw new s(s5, "Missing ranges in the grid coverage data");
    if (!((_d = r6.domain.referencing) == null ? void 0 : _d.length))
      throw new s(s5, "Missing domain referencing in the grid coverage data");
    const a7 = Object.values(r6.ranges);
    for (let n9 = 0; n9 < a7.length; n9++) {
      const { axisNames: e5, shape: r7, type: c8, values: l7 } = a7[n9];
      if (!("ndarray" === c8.toLowerCase() && (l7 == null ? void 0 : l7.length) && (e5 == null ? void 0 : e5.length) && (r7 == null ? void 0 : r7.length)))
        throw new s(s5, "Only ranges with valid NdArray, axisNames, shape, and inline values are supported");
      if (!(i5(e5[e5.length - 1]) && r5(e5[e5.length - 2])))
        throw new s(s5, "Only row-major ordered pixel values are supported. X axis must be the last axis.");
    }
    return p6(r6);
  }
};
e([y({ type: String, json: { write: true } })], m8.prototype, "datasetFormat", void 0), e([y({ constructOnly: true })], m8.prototype, "source", void 0), m8 = e([a2("esri.layers.support.rasterDatasets.CovJSONRaster")], m8);
var h7 = m8;

// node_modules/@arcgis/core/layers/support/rasterDatasets/xmlUtilities.js
function n8(e4, t5) {
  if (!e4 || !t5)
    return [];
  let l7 = t5;
  t5.includes("/") ? (l7 = t5.slice(0, t5.indexOf("/")), t5 = t5.slice(t5.indexOf("/") + 1)) : t5 = "";
  const r6 = [];
  if (t5) {
    const u12 = n8(e4, l7);
    for (let e5 = 0; e5 < u12.length; e5++) {
      n8(u12[e5], t5).forEach((n9) => r6.push(n9));
    }
    return r6;
  }
  const u11 = e4.getElementsByTagNameNS("*", l7);
  if (!u11 || 0 === u11.length)
    return [];
  for (let n9 = 0; n9 < u11.length; n9++)
    r6.push(u11[n9] || u11.item(n9));
  return r6;
}
function e3(t5, l7) {
  if (!t5 || !l7)
    return null;
  let r6 = l7;
  l7.includes("/") ? (r6 = l7.slice(0, l7.indexOf("/")), l7 = l7.slice(l7.indexOf("/") + 1)) : l7 = "";
  const u11 = n8(t5, r6);
  return u11.length > 0 ? l7 ? e3(u11[0], l7) : u11[0] : null;
}
function t4(n9, t5 = null) {
  const l7 = t5 ? e3(n9, t5) : n9;
  let r6;
  return l7 ? (r6 = l7.textContent || l7.nodeValue, r6 ? r6.trim() : null) : null;
}
function l5(e4, t5) {
  const l7 = n8(e4, t5), r6 = [];
  let u11;
  for (let n9 = 0; n9 < l7.length; n9++)
    u11 = l7[n9].textContent || l7[n9].nodeValue, u11 && (u11 = u11.trim(), "" !== u11 && r6.push(u11));
  return r6;
}
function u8(n9, e4) {
  return l5(n9, e4).map((n10) => Number(n10));
}
function o7(n9, e4) {
  const l7 = t4(n9, e4);
  return Number(l7);
}
function i6(n9, e4) {
  var _a;
  const t5 = (_a = n9 == null ? void 0 : n9.nodeName) == null ? void 0 : _a.toLowerCase(), l7 = e4.toLowerCase();
  return t5.slice(t5.lastIndexOf(":") + 1) === l7;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/pamParser.js
function u9(e4, t5) {
  if (!e4 || !t5)
    return null;
  const n9 = [];
  for (let r6 = 0; r6 < e4.length; r6++)
    n9.push(e4[r6]), n9.push(t5[r6]);
  return n9;
}
function c7(e4) {
  const t5 = e3(e4, "GeodataXform"), n9 = d7(o7(t5, "SpatialReference/WKID") || t4(t5, "SpatialReference/WKT"));
  if ("typens:PolynomialXform" !== t5.getAttribute("xsi:type"))
    return { spatialReference: n9, transform: null };
  const s5 = o7(t5, "PolynomialOrder") ?? 1, f11 = u8(t5, "CoeffX/Double"), c8 = u8(t5, "CoeffY/Double"), m10 = u8(t5, "InverseCoeffX/Double"), p8 = u8(t5, "InverseCoeffY/Double"), S6 = u9(f11, c8), C3 = u9(m10, p8);
  return { spatialReference: n9, transform: S6 && C3 && S6.length && C3.length ? new y4({ spatialReference: n9, polynomialOrder: s5, forwardCoefficients: S6, inverseCoefficients: C3 }) : null };
}
function m9(e4) {
  var _a;
  const t5 = o7(e4, "NoDataValue"), n9 = e3(e4, "Histograms/HistItem"), l7 = o7(n9, "HistMin"), o8 = o7(n9, "HistMax"), f11 = o7(n9, "BucketCount"), u11 = (_a = t4(n9, "HistCounts")) == null ? void 0 : _a.split("|").map((e5) => Number(e5));
  let c8, m10, d9, p8;
  n8(e4, "Metadata/MDI").forEach((e5) => {
    const t6 = Number(e5.textContent ?? e5.nodeValue);
    switch (e5.getAttribute("key").toUpperCase()) {
      case "STATISTICS_MINIMUM":
        c8 = t6;
        break;
      case "STATISTICS_MAXIMUM":
        m10 = t6;
        break;
      case "STATISTICS_MEAN":
        d9 = t6;
        break;
      case "STATISTICS_STDDEV":
        p8 = t6;
    }
  });
  const S6 = o7(e4, "Metadata/SourceBandIndex");
  return { noDataValue: t5, histogram: (u11 == null ? void 0 : u11.length) && null != l7 && null != o8 ? { min: l7, max: o8, size: f11 || u11.length, counts: u11 } : null, sourceBandIndex: S6, statistics: null != c8 && null != m10 ? { min: c8, max: m10, avg: d9, stddev: p8 } : null };
}
function d7(e4) {
  if (!e4)
    return null;
  let n9 = Number(e4);
  if (!isNaN(n9) && 0 !== n9)
    return new f2({ wkid: n9 });
  if (e4 = String(e4).trim(), c(e4))
    return new f2({ wkt2: e4 });
  const r6 = e4.toUpperCase();
  if (r6.startsWith("COMPD_CS")) {
    if (!r6.includes("VERTCS") || !r6.includes("GEOGCS") && !r6.startsWith("PROJCS"))
      return null;
    const t5 = r6.indexOf("VERTCS"), s5 = r6.indexOf("PROJCS"), a7 = s5 > -1 ? s5 : r6.indexOf("GEOGCS");
    if (-1 === a7)
      return null;
    const i7 = e4.slice(a7, e4.lastIndexOf("]", t5) + 1).trim(), l7 = e4.slice(t5, e4.lastIndexOf("]")).trim();
    n9 = p7(i7);
    const o8 = new f2(n9 ? { wkid: n9 } : { wkt: i7 }), u11 = p7(l7);
    return u11 && (o8.vcsWkid = u11), o8;
  }
  return r6.startsWith("GEOGCS") || r6.startsWith("PROJCS") ? (n9 = p7(e4), new f2(0 !== n9 ? { wkid: n9 } : { wkt: e4 })) : null;
}
function p7(e4) {
  var _a;
  const t5 = e4.replaceAll("]", "[").replaceAll('"', "").split("[").map((e5) => e5.trim()).filter((e5) => "" !== e5), n9 = t5[t5.length - 1].split(","), r6 = (_a = n9[0]) == null ? void 0 : _a.toLowerCase();
  if (("epsg" === r6 || "esri" === r6) && e4.endsWith('"]]')) {
    const e5 = Number(n9[1]);
    if (!isNaN(e5) && 0 !== e5)
      return e5;
  }
  return 0;
}
function S4(t5) {
  var _a;
  if ("pamdataset" !== ((_a = t5 == null ? void 0 : t5.documentElement.tagName) == null ? void 0 : _a.toLowerCase()))
    return {};
  const a7 = { spatialReference: null, transform: null, metadata: {}, rasterBands: [], statistics: null, histograms: null };
  t5.documentElement.childNodes.forEach((e4) => {
    if (1 === e4.nodeType) {
      if (i6(e4, "SRS")) {
        if (!a7.spatialReference) {
          const t6 = t4(e4);
          a7.spatialReference = d7(t6);
        }
      } else if (i6(e4, "Metadata"))
        if ("xml:ESRI" === e4.getAttribute("domain")) {
          const { spatialReference: t6, transform: n9 } = c7(e4);
          a7.transform = n9, a7.spatialReference || (a7.spatialReference = t6);
        } else {
          n8(e4, "MDI").forEach((e5) => a7.metadata[e5.getAttribute("key")] = t4(e5));
        }
      else if (i6(e4, "PAMRasterBand")) {
        const t6 = m9(e4);
        null != t6.sourceBandIndex && null == a7.rasterBands[t6.sourceBandIndex] ? a7.rasterBands[t6.sourceBandIndex] = t6 : a7.rasterBands.push(t6);
      }
    }
  });
  const i7 = a7.rasterBands;
  if (i7.length) {
    const t6 = !!i7[0].statistics;
    a7.statistics = t6 ? i7.map((e4) => e4.statistics).filter(k) : null;
    const n9 = !!i7[0].histogram;
    a7.histograms = n9 ? i7.map((e4) => e4.histogram).filter(k) : null;
  }
  return a7;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageAuxRaster.js
var h8 = class extends K2 {
  async open(t5) {
    await this.init();
    const s5 = await this._fetchData(t5);
    let { spatialReference: e4, statistics: r6, histograms: a7, transform: o8 } = await this._fetchAuxiliaryData(t5);
    const i7 = !e4;
    i7 && (e4 = new f2({ wkid: 3857 })), (a7 == null ? void 0 : a7.length) && null == r6 && (r6 = g2(a7));
    const { width: m10, height: l7 } = s5;
    let c8 = new w({ xmin: -0.5, ymin: 0.5 - l7, xmax: m10 - 0.5, ymax: 0.5, spatialReference: e4 });
    const h9 = o8 ? o8.forwardTransform(c8) : c8;
    let d9 = true;
    if (o8) {
      const t6 = o8.forwardCoefficients;
      d9 = t6 && 0 === t6[1] && 0 === t6[2], d9 && (o8 = null, c8 = h9);
    }
    const w4 = new g5({ source: { extent: h9, nativeExtent: c8, transform: o8, pixelBlocks: [s5], statistics: r6, histograms: a7, keyProperties: { DateType: "Processed" }, isPseudoSpatialReference: i7 }, ioConfig: { sampling: "closest", skipStatistics: true } });
    this.ioConfig.skipMapInfo && (w4.ioConfig.skipMapInfo = true), await w4.open(), w4.source = null, this._set("rasterInfo", w4.rasterInfo), this._inMemoryRaster = w4;
  }
  fetchRawTile(t5, s5, e4, r6 = {}) {
    return this._inMemoryRaster.fetchRawTile(t5, s5, e4, r6);
  }
  async _fetchData(t5) {
    const { data: e4 } = await this.request(this.url, { responseType: "array-buffer", signal: t5 == null ? void 0 : t5.signal }), r6 = P(e4).toUpperCase();
    if ("JPG" !== r6 && "PNG" !== r6 && "GIF" !== r6 && "BMP" !== r6)
      throw new s("image-aux-raster:open", "the data is not a supported format");
    this._set("datasetFormat", r6);
    const a7 = r6.toLowerCase(), o8 = "gif" === a7 || "bmp" === a7 || !has("ios"), i7 = await this.decodePixelBlock(e4, { format: a7, useCanvas: o8, hasNoZlibMask: true });
    if (null == i7)
      throw new s("image-aux-raster:open", "the data cannot be decoded");
    return i7;
  }
  async _fetchAuxiliaryData(t5) {
    var _a;
    const s5 = t5 == null ? void 0 : t5.signal, { skipExtensions: a7 = [], skipMapInfo: o8 } = this.ioConfig, i7 = o8 || a7.includes("aux.xml") ? null : this.request(this.url + ".aux.xml", { responseType: "xml", signal: s5 }), n9 = this.datasetFormat, l7 = "JPG" === n9 ? "jgw" : "PNG" === n9 ? "pgw" : "BMP" === n9 ? "bpw" : null, p8 = l7 && a7.includes(l7) ? null : this.request(this.url.slice(0, this.url.lastIndexOf(".")) + "." + l7, { responseType: "text", signal: s5 }), f11 = await v([i7, p8]);
    if (s5 == null ? void 0 : s5.aborted)
      throw u();
    const u11 = S4((_a = f11[0].value) == null ? void 0 : _a.data);
    if (!u11.transform) {
      const t6 = f11[1].value ? f11[1].value.data.split("\n").slice(0, 6).map((t7) => Number(t7)) : null;
      u11.transform = 6 === (t6 == null ? void 0 : t6.length) ? new y4({ forwardCoefficients: [t6[4], t6[5], t6[0], -t6[1], t6[2], -t6[3]] }) : null;
    }
    return u11;
  }
};
e([y({ type: String, json: { write: true } })], h8.prototype, "datasetFormat", void 0), h8 = e([a2("esri.layers.support.rasterDatasets.ImageAuxRaster")], h8);
var d8 = h8;

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageServerRaster.js
var g6 = class extends K2 {
  constructor() {
    super(...arguments), this._levelOffset = 0, this._tilemapCache = null, this._slices = null, this.datasetFormat = "RasterTileServer", this.tileType = null;
  }
  async open(e4) {
    var _a, _b;
    await this.init();
    const r6 = e4 == null ? void 0 : e4.signal, a7 = this.sourceJSON ? { data: this.sourceJSON } : await this.request(this.url, { query: { f: "json" }, signal: r6 });
    a7.ssl && (this.url = this.url.replace(/^http:/i, "https:"));
    const l7 = a7.data;
    if (this.sourceJSON = l7, !l7)
      throw new s("imageserverraster:open", "cannot initialize tiled image service, missing service info");
    if (!l7.tileInfo)
      throw new s("imageserverraster:open", "use ImageryLayer to open non-tiled image services");
    this._fixScaleInServiceInfo();
    const m10 = ["jpg", "jpeg", "png", "png8", "png24", "png32", "mixed"];
    this.tileType = l7.cacheType, null == this.tileType && (m10.includes(l7.tileInfo.format.toLowerCase()) ? this.tileType = "Map" : "lerc" === l7.tileInfo.format.toLowerCase() ? this.tileType = "Elevation" : this.tileType = "Raster"), this.datasetName = ((_a = l7.name) == null ? void 0 : _a.slice(l7.name.indexOf("/") + 1)) ?? "";
    const u11 = await this._fetchRasterInfo({ signal: r6 });
    if (null == u11)
      throw new s("image-server-raster:open", "cannot initialize image service");
    p4(u11, l7);
    const h9 = "Map" === this.tileType ? v4(l7.tileInfo, l7) : j3.fromJSON(l7.tileInfo);
    n2(h9);
    const [p8, d9] = this._computeMinMaxLOD(u11, h9), { extent: y7, pixelSize: x6 } = u11, g7 = 0.5 / u11.width * x6.x, I5 = Math.max(x6.x, x6.y), { lods: w4 } = h9;
    ("Map" !== this.tileType && 0 !== l7.maxScale || Math.abs(x6.x - x6.y) > g7 || !w4.some((e5) => Math.abs(e5.resolution - I5) < g7)) && (x6.x = x6.y = p8.resolution, u11.width = Math.ceil((y7.xmax - y7.xmin) / x6.x - 0.1), u11.height = Math.ceil((y7.ymax - y7.ymin) / x6.y - 0.1));
    const j6 = p8.level - d9.level, [M2, b4] = h9.size, T5 = [], _3 = [];
    w4.forEach((e5, t5) => {
      e5.level >= d9.level && e5.level <= p8.level && T5.push({ x: e5.resolution, y: e5.resolution }), t5 < w4.length - 1 && _3.push(Math.round(10 * e5.resolution / w4[t5 + 1].resolution) / 10);
    }), T5.sort((e5, t5) => e5.x - t5.x);
    const O = this.computeBlockBoundary(y7, M2, b4, h9.origin, T5, j6), R4 = T5.length > 1 ? T5.slice(1) : null;
    let z2;
    l7.transposeInfo && (z2 = { tileSize: [l7.transposeInfo.rows, l7.transposeInfo.cols], packetSize: ((_b = u11.keyProperties) == null ? void 0 : _b._yxs.PacketSize) ?? 0 });
    const N4 = _3.length <= 1 || _3.length >= 3 && _3.slice(0, -1).every((e5) => e5 === _3[0]) ? _3[0] ?? 2 : Math.round(10 / (d9.resolution / p8.resolution) ** (-1 / j6)) / 10;
    if (u11.storageInfo = new n6({ blockWidth: h9.size[0], blockHeight: h9.size[1], pyramidBlockWidth: h9.size[0], pyramidBlockHeight: h9.size[1], pyramidResolutions: R4, pyramidScalingFactor: N4, compression: h9.format, origin: h9.origin, firstPyramidLevel: 1, maximumPyramidLevel: j6, tileInfo: h9, transposeInfo: z2, blockBoundary: O }), S5(u11), this._set("rasterInfo", u11), l7.capabilities.toLowerCase().includes("tilemap")) {
      const e5 = { tileInfo: u11.storageInfo.tileInfo, parsedUrl: I(this.url), url: this.url, tileServers: [] };
      this._tilemapCache = new T4({ layer: e5 });
    }
  }
  async fetchRawTile(e4, t5, i7, s5 = {}) {
    const { storageInfo: r6, extent: a7 } = this.rasterInfo, { transposeInfo: l7 } = r6, o8 = null != l7 && !!s5.transposedVariableName;
    if (this._slices && !o8 && null == s5.sliceId)
      return null;
    const n9 = o8 ? 0 : r6.maximumPyramidLevel - e4 + this._levelOffset, c8 = `${this.url}/tile/${n9}/${t5}/${i7}`, m10 = this._slices ? o8 ? { variable: s5.transposedVariableName } : { sliceId: s5.sliceId || 0 } : null, { data: h9 } = await this.request(c8, { query: m10, responseType: "array-buffer", signal: s5.signal });
    if (!h9)
      return null;
    const f11 = o8 ? l7.tileSize : r6.tileInfo.size, p8 = await this.decodePixelBlock(h9, { width: f11[0], height: f11[1], planes: null, pixelType: null, isPoint: "Elevation" === this.tileType, returnInterleaved: o8, noDataValue: this.rasterInfo.noDataValue });
    if (null == p8)
      return null;
    const d9 = r6.blockBoundary[e4];
    if ("jpg" !== r6.compression || i7 > d9.minCol && i7 < d9.maxCol && t5 > d9.minRow && t5 < d9.maxRow)
      return p8;
    const { origin: y7, blockWidth: x6, blockHeight: g7 } = r6, { x: v6, y: S6 } = this.getPyramidPixelSize(e4), I5 = Math.round((a7.xmin - y7.x) / v6) % x6, w4 = Math.round((a7.xmax - y7.x) / v6) % x6 || x6, j6 = Math.round((y7.y - a7.ymax) / S6) % g7, M2 = Math.round((y7.y - a7.ymin) / S6) % g7 || g7, b4 = i7 === d9.minCol ? I5 : 0, T5 = t5 === d9.minRow ? j6 : 0, _3 = i7 === d9.maxCol ? w4 : x6, O = t5 === d9.maxRow ? M2 : g7;
    return T2(p8, { x: b4, y: T5 }, { width: _3 - b4, height: O - T5 }), p8;
  }
  getSliceIndex(e4) {
    if (!this._slices || null == e4 || 0 === e4.length)
      return null;
    const t5 = e4;
    for (let i7 = 0; i7 < this._slices.length; i7++) {
      const e5 = this._slices[i7].multidimensionalDefinition;
      if (e5.length === t5.length && !e5.some((e6) => {
        const i8 = t5.find((t6) => e6.variableName === t6.variableName && t6.dimensionName === e6.dimensionName);
        if (!i8)
          return true;
        return (Array.isArray(e6.values[0]) ? `${e6.values[0][0]}-${e6.values[0][1]}` : e6.values[0]) !== (Array.isArray(i8.values[0]) ? `${i8.values[0][0]}-${i8.values[0][1]}` : i8.values[0]);
      }))
        return i7;
    }
    return null;
  }
  async fetchVariableStatisticsHistograms(e4, t5) {
    var _a, _b, _c;
    const i7 = this.request(this.url + "/statistics", { query: { variable: e4, f: "json" }, signal: t5 }).then((e5) => {
      var _a2;
      return (_a2 = e5.data) == null ? void 0 : _a2.statistics;
    }), s5 = this.request(this.url + "/histograms", { query: { variable: e4, f: "json" }, signal: t5 }).then((e5) => {
      var _a2;
      return (_a2 = e5.data) == null ? void 0 : _a2.histograms;
    }), r6 = await Promise.all([i7, s5]);
    return r6[0] && r6[0].forEach((e5) => {
      e5.avg = e5.mean, e5.stddev = e5.standardDeviation;
    }), ((_c = (_b = (_a = r6[1]) == null ? void 0 : _a[0]) == null ? void 0 : _b.counts) == null ? void 0 : _c.length) || (r6[1] = null), { statistics: r6[0] || null, histograms: r6[1] || null };
  }
  async computeBestPyramidLevelForLocation(e4, t5 = {}) {
    if (!this._tilemapCache)
      return 0;
    let i7 = this.identifyPixelLocation(e4, 0, t5.datumTransformation);
    if (null === i7)
      return null;
    let s5 = 0;
    const { maximumPyramidLevel: r6 } = this.rasterInfo.storageInfo;
    let a7 = r6 - s5 + this._levelOffset;
    const l7 = i7.srcLocation;
    for (; a7 >= 0; ) {
      try {
        if ("available" === await this._tilemapCache.fetchAvailability(a7, i7.row, i7.col, t5))
          break;
      } catch {
      }
      if (a7--, s5++, i7 = this.identifyPixelLocation(l7, s5, t5.datumTransformation), null === i7)
        return null;
    }
    return -1 === a7 || null == i7 ? null : s5;
  }
  async _fetchRasterInfo(e4) {
    const t5 = this.sourceJSON;
    if ("Map" === this.tileType) {
      const e5 = t5.fullExtent || t5.extent, i8 = Math.ceil((e5.xmax - e5.xmin) / t5.pixelSizeX - 0.1), s6 = Math.ceil((e5.ymax - e5.ymin) / t5.pixelSizeY - 0.1), r7 = f2.fromJSON(t5.spatialReference || e5.spatialReference), a8 = new x({ x: t5.pixelSizeX, y: t5.pixelSizeY, spatialReference: r7 });
      return new m2({ width: i8, height: s6, bandCount: 3, extent: w.fromJSON(e5), spatialReference: r7, pixelSize: a8, pixelType: "u8", statistics: null, keyProperties: { DataType: "processed" } });
    }
    const { signal: i7 } = e4, s5 = m4(this.url, this.sourceJSON, { signal: i7, query: this.ioConfig.customFetchParameters }), r6 = t5.hasMultidimensions ? this.request(`${this.url}/slices`, { query: { f: "json" }, signal: i7 }).then((e5) => {
      var _a;
      return (_a = e5.data) == null ? void 0 : _a.slices;
    }).catch(() => null) : null, a7 = await Promise.all([s5, r6]);
    return this._slices = a7[1], a7[0];
  }
  _fixScaleInServiceInfo() {
    const { sourceJSON: e4 } = this;
    e4.minScale && e4.minScale < 0 && (e4.minScale = 0), e4.maxScale && e4.maxScale < 0 && (e4.maxScale = 0);
  }
  _computeMinMaxLOD(e4, t5) {
    const { pixelSize: i7 } = e4, s5 = 0.5 / e4.width * i7.x, { lods: r6 } = t5, a7 = t5.lodAt(Math.max.apply(null, r6.map((e5) => e5.level))), l7 = t5.lodAt(Math.min.apply(null, r6.map((e5) => e5.level))), { tileType: o8 } = this;
    if ("Map" === o8)
      return this._levelOffset = r6[0].level, [a7, l7];
    if ("Raster" === o8) {
      return [r6.find((e5) => e5.resolution === i7.x) ?? a7, l7];
    }
    const { minScale: n9, maxScale: c8 } = this.sourceJSON;
    let m10 = a7;
    c8 > 0 && (m10 = r6.find((e5) => Math.abs(e5.scale - c8) < s5), m10 || (m10 = r6.filter((e5) => e5.scale > c8).sort((e5, t6) => e5.scale > t6.scale ? 1 : -1)[0] ?? a7));
    let u11 = l7;
    return n9 > 0 && (u11 = r6.find((e5) => Math.abs(e5.scale - n9) < s5) ?? l7, this._levelOffset = u11.level - l7.level), [m10, u11];
  }
};
function v4(e4, t5) {
  if (!e4)
    return null;
  const { minScale: i7, maxScale: s5, minLOD: r6, maxLOD: a7 } = t5;
  if (null != r6 && null != a7)
    return j3.fromJSON({ ...e4, lods: e4.lods.filter(({ level: e5 }) => null != e5 && e5 >= r6 && e5 <= a7) });
  if (0 !== i7 && 0 !== s5) {
    const t6 = (e5) => Math.round(1e4 * e5) / 1e4, r7 = i7 ? t6(i7) : 1 / 0, a8 = s5 ? t6(s5) : -1 / 0;
    return j3.fromJSON({ ...e4, lods: e4.lods.filter((e5) => {
      const i8 = t6(e5.scale);
      return i8 <= r7 && i8 >= a8;
    }) });
  }
  return j3.fromJSON(e4);
}
function S5(e4) {
  const { extent: t5, spatialReference: i7 } = e4;
  t5.xmin > -1 && t5.xmax > 181 && (i7 == null ? void 0 : i7.wkid) && i7.isGeographic && (e4.nativeExtent = e4.extent, e4.transform = new c3(), e4.extent = e4.transform.forwardTransform(t5));
}
e([y({ type: String, json: { write: true } })], g6.prototype, "datasetFormat", void 0), e([y()], g6.prototype, "tileType", void 0), g6 = e([a2("esri.layers.support.rasterDatasets.ImageServerRaster")], g6);
var I3 = g6;

// node_modules/@arcgis/core/layers/support/rasterDatasets/MRFRaster.js
var y6 = /* @__PURE__ */ new Map();
y6.set("Int8", "s8"), y6.set("UInt8", "u8"), y6.set("Int16", "s16"), y6.set("UInt16", "u16"), y6.set("Int32", "s32"), y6.set("UInt32", "u32"), y6.set("Float32", "f32"), y6.set("Float64", "f32"), y6.set("Double64", "f32");
var x5 = /* @__PURE__ */ new Map();
x5.set("none", { blobExtension: ".til", isOneSegment: true, decoderFormat: "bip" }), x5.set("lerc", { blobExtension: ".lrc", isOneSegment: false, decoderFormat: "lerc" }), x5.set("deflate", { blobExtension: ".pzp", isOneSegment: true, decoderFormat: "deflate" }), x5.set("jpeg", { blobExtension: ".pjg", isOneSegment: true, decoderFormat: "jpg" });
var w3 = class extends K2 {
  constructor() {
    super(...arguments), this._files = null, this._storageIndex = null, this.datasetFormat = "MRF";
  }
  async open(t5) {
    await this.init(), this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const e4 = t5 ? t5.signal : null, r6 = await this.request(this.url, { responseType: "xml", signal: e4 }), { rasterInfo: s5, files: o8 } = this._parseHeader(r6.data), { skipMapInfo: i7, skipExtensions: a7 = [] } = this.ioConfig;
    if (!a7.includes("aux.xml") && !i7) {
      const e5 = await this._fetchAuxiliaryData(t5);
      null != e5 && (s5.statistics = e5.statistics ?? s5.statistics, s5.histograms = e5.histograms, e5.histograms && null == s5.statistics && (s5.statistics = g2(e5.histograms)));
    }
    i7 && this.updateImageSpaceRasterInfo(s5), this._set("rasterInfo", s5), this._files = o8;
    const n9 = await this.request(o8.index, { responseType: "array-buffer", signal: e4 });
    this._storageIndex = I4(n9.data);
    const { blockWidth: l7, blockHeight: f11 } = this.rasterInfo.storageInfo, c8 = this.rasterInfo.storageInfo.pyramidScalingFactor, { width: m10, height: p8 } = this.rasterInfo, u11 = [], g7 = this._getBandSegmentCount();
    let d9 = 0, y7 = -1;
    for (; d9 < this._storageIndex.length; ) {
      y7++;
      const t6 = Math.ceil(m10 / l7 / c8 ** y7) - 1, e5 = Math.ceil(p8 / f11 / c8 ** y7) - 1;
      d9 += (t6 + 1) * (e5 + 1) * g7 * 4, u11.push({ maxRow: e5, maxCol: t6, minCol: 0, minRow: 0 });
    }
    this.rasterInfo.storageInfo.blockBoundary = u11, y7 > 0 && (this.rasterInfo.storageInfo.firstPyramidLevel = 1, this.rasterInfo.storageInfo.maximumPyramidLevel = y7), this.updateTileInfo();
  }
  async fetchRawTile(t5, e4, r6, s5 = {}) {
    const { blockWidth: i7, blockHeight: a7, blockBoundary: n9 } = this.rasterInfo.storageInfo, l7 = n9[t5];
    if (!l7 || l7.maxRow < e4 || l7.maxCol < r6 || l7.minRow > e4 || l7.minCol > r6)
      return null;
    const { bandCount: f11, pixelType: c8 } = this.rasterInfo, { ranges: m10, actualTileWidth: p8, actualTileHeight: h9 } = this._getTileLocation(t5, e4, r6);
    if (!m10 || 0 === m10.length)
      return null;
    if (0 === m10[0].from && 0 === m10[0].to) {
      const t6 = new Uint8Array(i7 * a7);
      return new g({ width: i7, height: a7, pixels: void 0, mask: t6, validPixelCount: 0 });
    }
    const { bandIds: u11 } = this.ioConfig, g7 = this._getBandSegmentCount(), d9 = [];
    let y7 = 0;
    for (y7 = 0; y7 < g7; y7++)
      u11 && !u11.includes(y7) || d9.push(this.request(this._files.data, { range: { from: m10[y7].from, to: m10[y7].to }, responseType: "array-buffer", signal: s5.signal }));
    const w4 = await Promise.all(d9), I5 = w4.map((t6) => t6.data.byteLength).reduce((t6, e5) => t6 + e5), b4 = new Uint8Array(I5), R4 = [];
    let A2 = 0;
    for (y7 = 0; y7 < g7; y7++)
      R4.push(A2), b4.set(new Uint8Array(w4[y7].data), A2), A2 += w4[y7].data.byteLength;
    const F3 = x5.get(this.rasterInfo.storageInfo.compression).decoderFormat, S6 = await this.decodePixelBlock(b4.buffer, { width: i7, height: a7, format: F3, planes: (u11 == null ? void 0 : u11.length) || f11, offsets: R4, pixelType: c8 });
    if (null == S6)
      return null;
    let { noDataValue: _3 } = this.rasterInfo;
    if (null != _3 && "lerc" !== F3 && !S6.mask && (_3 = _3[0], null != _3)) {
      const t6 = S6.width * S6.height, e5 = new Uint8Array(t6);
      if (Math.abs(_3) > 1e24)
        for (y7 = 0; y7 < t6; y7++)
          Math.abs((S6.pixels[0][y7] - _3) / _3) > 1e-6 && (e5[y7] = 1);
      else
        for (y7 = 0; y7 < t6; y7++)
          S6.pixels[0][y7] !== _3 && (e5[y7] = 1);
      S6.mask = e5;
    }
    let k5 = 0, M2 = 0;
    if (p8 !== i7 || h9 !== a7) {
      let t6 = S6.mask;
      if (t6)
        for (y7 = 0; y7 < a7; y7++)
          if (M2 = y7 * i7, y7 < h9)
            for (k5 = p8; k5 < i7; k5++)
              t6[M2 + k5] = 0;
          else
            for (k5 = 0; k5 < i7; k5++)
              t6[M2 + k5] = 0;
      else
        for (t6 = new Uint8Array(i7 * a7), S6.mask = t6, y7 = 0; y7 < h9; y7++)
          for (M2 = y7 * i7, k5 = 0; k5 < p8; k5++)
            t6[M2 + k5] = 1;
    }
    return S6;
  }
  _getBandSegmentCount() {
    return x5.get(this.rasterInfo.storageInfo.compression).isOneSegment ? 1 : this.rasterInfo.bandCount;
  }
  _getTileLocation(t5, e4, r6) {
    const { blockWidth: s5, blockHeight: o8, pyramidScalingFactor: i7 } = this.rasterInfo.storageInfo, { width: a7, height: n9 } = this.rasterInfo, l7 = this._getBandSegmentCount();
    let f11, c8, m10, p8 = 0, h9 = 0;
    for (m10 = 0; m10 < t5; m10++)
      h9 = i7 ** m10, f11 = Math.ceil(a7 / s5 / h9), c8 = Math.ceil(n9 / o8 / h9), p8 += f11 * c8;
    h9 = i7 ** t5, f11 = Math.ceil(a7 / s5 / h9), c8 = Math.ceil(n9 / o8 / h9), p8 += e4 * f11 + r6, p8 *= 4 * l7;
    const u11 = this._storageIndex.subarray(p8, p8 + 4 * l7);
    let g7 = 0, d9 = 0;
    const y7 = [];
    for (let x6 = 0; x6 < l7; x6++)
      g7 = u11[4 * x6] * 2 ** 32 + u11[4 * x6 + 1], d9 = g7 + u11[4 * x6 + 2] * 2 ** 32 + u11[4 * x6 + 3], y7.push({ from: g7, to: d9 });
    return { ranges: y7, actualTileWidth: r6 < f11 - 1 ? s5 : Math.ceil(a7 / h9) - s5 * (f11 - 1), actualTileHeight: e4 < c8 - 1 ? o8 : Math.ceil(n9 / h9) - o8 * (c8 - 1) };
  }
  _parseHeader(t5) {
    const r6 = e3(t5, "MRF_META/Raster");
    if (!r6)
      throw new s("mrf:open", "not a valid MRF format");
    const s5 = e3(r6, "Size"), o8 = parseInt(s5.getAttribute("x"), 10), n9 = parseInt(s5.getAttribute("y"), 10), f11 = parseInt(s5.getAttribute("c"), 10), p8 = (t4(r6, "Compression") || "none").toLowerCase();
    if (!x5.has(p8))
      throw new s("mrf:open", "currently does not support compression " + p8);
    const h9 = t4(r6, "DataType") || "UInt8", w4 = y6.get(h9);
    if (null == w4)
      throw new s("mrf:open", "currently does not support pixel type " + h9);
    const I5 = e3(r6, "PageSize"), b4 = parseInt(I5.getAttribute("x"), 10), R4 = parseInt(I5.getAttribute("y"), 10), A2 = e3(r6, "DataValues");
    let F3, S6;
    A2 && (S6 = A2.getAttribute("NoData"), null != S6 && (F3 = S6.trim().split(" ").map((t6) => parseFloat(t6))));
    if (e3(t5, "MRF_META/CachedSource"))
      throw new s("mrf:open", "currently does not support MRF referencing other data files");
    const _3 = e3(t5, "MRF_META/GeoTags"), k5 = e3(_3, "BoundingBox");
    let M2, j6 = false;
    if (null != k5) {
      const t6 = parseFloat(k5.getAttribute("minx")), e4 = parseFloat(k5.getAttribute("miny")), r7 = parseFloat(k5.getAttribute("maxx")), s6 = parseFloat(k5.getAttribute("maxy")), o9 = t4(_3, "Projection") || "";
      let i7 = f2.WGS84;
      if ("LOCAL_CS[]" !== o9)
        if (o9.toLowerCase().startsWith("epsg:")) {
          const t7 = Number(o9.slice(5));
          isNaN(t7) || 0 === t7 || (i7 = new f2({ wkid: t7 }));
        } else
          i7 = d7(o9) ?? f2.WGS84;
      else
        j6 = true, i7 = new f2({ wkid: 3857 });
      M2 = new w(t6, e4, r7, s6), M2.spatialReference = i7;
    } else
      j6 = true, M2 = new w({ xmin: -0.5, ymin: 0.5 - n9, xmax: o8 - 0.5, ymax: 0.5, spatialReference: new f2({ wkid: 3857 }) });
    const C3 = e3(t5, "MRF_META/Rsets"), T5 = parseInt((C3 == null ? void 0 : C3.getAttribute("scale")) || "2", 10), L3 = M2.spatialReference, U7 = new n6({ origin: new x({ x: M2.xmin, y: M2.ymax, spatialReference: L3 }), blockWidth: b4, blockHeight: R4, pyramidBlockWidth: b4, pyramidBlockHeight: R4, compression: p8, pyramidScalingFactor: T5 }), B3 = new x({ x: M2.width / o8, y: M2.height / n9, spatialReference: L3 }), E3 = new m2({ width: o8, height: n9, extent: M2, isPseudoSpatialReference: j6, spatialReference: L3, bandCount: f11, pixelType: w4, pixelSize: B3, noDataValue: F3, storageInfo: U7 }), P4 = t4(t5, "datafile"), W3 = t4(t5, "IndexFile");
    return { rasterInfo: E3, files: { mrf: this.url, index: W3 || this.url.replace(".mrf", ".idx"), data: P4 || this.url.replace(".mrf", x5.get(p8).blobExtension) } };
  }
  async _fetchAuxiliaryData(t5) {
    try {
      const { data: e4 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: t5 == null ? void 0 : t5.signal });
      return S4(e4);
    } catch {
      return null;
    }
  }
};
function I4(t5) {
  if (t5.byteLength % 16 > 0)
    throw new Error("invalid array buffer must be multiples of 16");
  let e4, r6, s5, o8, i7, a7;
  if (r2) {
    for (r6 = new Uint8Array(t5), o8 = new ArrayBuffer(t5.byteLength), s5 = new Uint8Array(o8), i7 = 0; i7 < t5.byteLength / 4; i7++)
      for (a7 = 0; a7 < 4; a7++)
        s5[4 * i7 + a7] = r6[4 * i7 + 3 - a7];
    e4 = new Uint32Array(o8);
  } else
    e4 = new Uint32Array(t5);
  return e4;
}
e([y()], w3.prototype, "_files", void 0), e([y()], w3.prototype, "_storageIndex", void 0), e([y({ type: String, json: { write: true } })], w3.prototype, "datasetFormat", void 0), w3 = e([a2("esri.layers.support.rasterDatasets.MRFRaster")], w3);
var b3 = w3;

// node_modules/@arcgis/core/layers/support/rasterDatasets/TIFFRaster.js
var _2 = (e4, t5) => {
  var _a;
  return (_a = e4.get(t5)) == null ? void 0 : _a.values;
};
var F2 = (e4, t5) => {
  var _a, _b;
  return (_b = (_a = e4.get(t5)) == null ? void 0 : _a.values) == null ? void 0 : _b[0];
};
var v5 = class extends K2 {
  constructor() {
    super(...arguments), this._files = null, this._headerInfo = null, this._bufferSize = 1048576, this.datasetFormat = "TIFF";
  }
  async open(e4) {
    var _a, _b, _c, _d;
    await this.init();
    const t5 = e4 ? e4.signal : null, { data: s5 } = await this.request(this.url, { range: { from: 0, to: this._bufferSize }, responseType: "array-buffer", signal: t5 });
    if (!s5)
      throw new s("tiffraster:open", "failed to open url " + this.url);
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1, this.url.lastIndexOf("."));
    const { littleEndian: a7, firstIFDPos: n9, isBigTiff: o8 } = F(s5), f11 = [];
    await this._readIFDs(f11, s5, a7, n9, 0, o8 ? 8 : 4, t5);
    const { imageInfo: l7, rasterInfo: u11 } = k4(f11), p8 = U2(f11), d9 = N(f11);
    if (this._headerInfo = { littleEndian: a7, isBigTiff: o8, ifds: f11, pyramidIFDs: p8, maskIFDs: d9, ...l7 }, this._set("rasterInfo", u11), !l7.isSupported)
      throw new s("tiffraster:open", "this tiff is not supported: " + l7.message);
    if (!l7.tileWidth)
      throw new s("tiffraster:open", "none-tiled tiff is not optimized for access, convert to COG and retry.");
    u11.isPseudoSpatialReference && n.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");
    const y7 = (_b = (_a = f11[0].get("PREDICTOR")) == null ? void 0 : _a.values) == null ? void 0 : _b[0], g7 = (_d = (_c = f11[0].get("SAMPLEFORMAT")) == null ? void 0 : _c.values) == null ? void 0 : _d[0];
    if (3 === g7 && 2 === y7)
      throw new s("tiffraster:open", "unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");
    const { skipMapInfo: T5, skipExtensions: x6 = [] } = this.ioConfig;
    if (!x6.includes("aux.xml") && !T5) {
      const t6 = await this._fetchAuxiliaryMetaData(e4);
      null != t6 && P3(t6, u11);
    }
    x6.includes("vat.dbf") || 1 !== u11.bandCount || "u8" !== u11.pixelType || T5 || (u11.attributeTable = await this._fetchAuxiliaryTable(e4), null != u11.attributeTable && (u11.keyProperties.DataType = "thematic")), T5 && this.updateImageSpaceRasterInfo(u11), this.updateTileInfo();
  }
  async fetchRawTile(e4, t5, r6, i7 = {}) {
    var _a;
    if (!((_a = this._headerInfo) == null ? void 0 : _a.isSupported) || this.isBlockOutside(e4, t5, r6))
      return null;
    const s5 = await this._fetchRawTiffTile(e4, t5, r6, false, i7);
    if (null != s5 && this._headerInfo.hasMaskBand) {
      const a7 = await this._fetchRawTiffTile(e4, t5, r6, true, i7);
      null != a7 && a7.pixels[0] instanceof Uint8Array && (s5.mask = a7.pixels[0]);
    }
    return s5;
  }
  async _readIFDs(e4, t5, r6, i7, s5, a7 = 4, n9) {
    if (!i7)
      return null;
    if (i7 >= t5.byteLength || i7 < 0) {
      t5 = (await this.request(this.url, { range: { from: i7 + s5, to: i7 + s5 + this._bufferSize }, responseType: "array-buffer", signal: n9 })).data, s5 = i7 + s5, i7 = 0;
    }
    const o8 = await this._readIFD(t5, r6, i7, s5, n5.tiffTags, a7, n9);
    if (e4.push(o8.ifd), !o8.nextIFD)
      return null;
    await this._readIFDs(e4, t5, r6, o8.nextIFD - s5, s5, a7, n9);
  }
  async _readIFD(e4, r6, i7, s5, a7 = n5.tiffTags, n9 = 4, o8) {
    var _a, _b;
    if (!e4)
      return null;
    const f11 = B(e4, r6, i7, s5, a7, n9);
    if (f11.success) {
      const i8 = [];
      if ((_a = f11.ifd) == null ? void 0 : _a.forEach((e5) => {
        e5.values || i8.push(e5);
      }), i8.length > 0) {
        const a8 = i8.map((e5) => e5.offlineOffsetSize).filter(k), n10 = Math.min.apply(null, a8.map((e5) => e5[0]));
        if (Math.min.apply(null, a8.map((e5) => e5[0] + e5[1])) - n10 <= this._bufferSize) {
          const { data: t5 } = await this.request(this.url, { range: { from: n10, to: n10 + this._bufferSize }, responseType: "array-buffer", signal: o8 });
          e4 = t5, s5 = n10, i8.forEach((t6) => L(e4, r6, t6, s5));
        }
      }
      if ((_b = f11.ifd) == null ? void 0 : _b.has("GEOKEYDIRECTORY")) {
        const t5 = f11.ifd.get("GEOKEYDIRECTORY"), i9 = t5 == null ? void 0 : t5.values;
        if (i9 && i9.length > 4) {
          const a8 = i9[0] + "." + i9[1] + "." + i9[2], n10 = await this._readIFD(e4, r6, t5.valueOffset + 6 - s5, s5, n5.geoKeys, 2, o8);
          t5.data = n10.ifd, t5.data && t5.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [a8] });
        }
      }
      return f11;
    }
    if (f11.requiredBufferSize && f11.requiredBufferSize !== e4.byteLength) {
      const t5 = await this.request(this.url, { range: { from: s5, to: s5 + f11.requiredBufferSize + 4 }, responseType: "array-buffer", signal: o8 });
      return (e4 = t5.data).byteLength < f11.requiredBufferSize ? null : this._readIFD(e4, r6, 0, s5, n5.tiffTags, 4, o8);
    }
  }
  async _fetchRawTiffTile(e4, t5, r6, i7, s5 = {}) {
    const a7 = this._getTileLocation(e4, t5, r6, i7);
    if (!a7)
      return null;
    const { ranges: n9, actualTileWidth: o8, actualTileHeight: f11, ifd: l7 } = a7, u11 = n9.map((e5) => this.request(this.url, { range: e5, responseType: "array-buffer", signal: s5.signal })), p8 = await Promise.all(u11), c8 = p8.map((e5) => e5.data.byteLength).reduce((e5, t6) => e5 + t6), h9 = 1 === p8.length ? p8[0].data : new ArrayBuffer(c8), m10 = [0], d9 = [0];
    if (p8.length > 1) {
      const e5 = new Uint8Array(h9);
      for (let t6 = 0, r7 = 0; t6 < p8.length; t6++) {
        const i8 = p8[t6].data;
        e5.set(new Uint8Array(i8), r7), m10[t6] = r7, r7 += i8.byteLength, d9[t6] = i8.byteLength;
      }
    }
    const { blockWidth: y7, blockHeight: g7 } = this.getBlockWidthHeight(e4), T5 = await this.decodePixelBlock(h9, { format: "tiff", customOptions: { headerInfo: this._headerInfo, ifd: l7, offsets: m10, sizes: d9 }, width: y7, height: g7, planes: null, pixelType: null });
    if (null == T5)
      return null;
    let x6, w4, I5;
    if (o8 !== y7 || f11 !== g7) {
      let e5 = T5.mask;
      if (e5)
        for (x6 = 0; x6 < g7; x6++)
          if (I5 = x6 * y7, x6 < f11)
            for (w4 = o8; w4 < y7; w4++)
              e5[I5 + w4] = 0;
          else
            for (w4 = 0; w4 < y7; w4++)
              e5[I5 + w4] = 0;
      else
        for (e5 = new Uint8Array(y7 * g7), T5.mask = e5, x6 = 0; x6 < f11; x6++)
          for (I5 = x6 * y7, w4 = 0; w4 < o8; w4++)
            e5[I5 + w4] = 1;
    }
    return T5;
  }
  _getTileLocation(e4, t5, r6, i7 = false) {
    const { firstPyramidLevel: s5, blockBoundary: a7 } = this.rasterInfo.storageInfo, n9 = 0 === e4 ? 0 : e4 - (s5 - 1), { _headerInfo: o8 } = this;
    if (!o8)
      return null;
    const f11 = i7 ? o8.maskIFDs[n9] : 0 === n9 ? o8 == null ? void 0 : o8.ifds[0] : o8 == null ? void 0 : o8.pyramidIFDs[n9 - 1];
    if (!f11)
      return null;
    const l7 = D(f11, o8), u11 = _2(f11, "TILEOFFSETS");
    if (void 0 === u11)
      return null;
    const p8 = _2(f11, "TILEBYTECOUNTS"), { minRow: c8, minCol: h9, maxRow: m10, maxCol: d9 } = a7[n9];
    if (t5 > m10 || r6 > d9 || t5 < c8 || r6 < h9)
      return null;
    const y7 = F2(f11, "IMAGEWIDTH"), T5 = F2(f11, "IMAGELENGTH"), x6 = F2(f11, "TILEWIDTH"), w4 = F2(f11, "TILELENGTH"), I5 = [];
    if (l7) {
      const { bandCount: e5 } = this.rasterInfo;
      for (let i8 = 0; i8 < e5; i8++) {
        const e6 = i8 * (m10 + 1) * (d9 + 1) + t5 * (d9 + 1) + r6;
        I5[i8] = { from: u11[e6], to: u11[e6] + p8[e6] - 1 };
      }
    } else {
      const e5 = t5 * (d9 + 1) + r6;
      I5.push({ from: u11[e5], to: u11[e5] + p8[e5] - 1 });
    }
    for (let g7 = 0; g7 < I5.length; g7++)
      if (null == I5[g7].from || !I5[g7].to || I5[g7].to < 0)
        return null;
    return { ranges: I5, ifd: f11, actualTileWidth: r6 === d9 && y7 % x6 || x6, actualTileHeight: t5 === m10 && T5 % w4 || w4 };
  }
  async _fetchAuxiliaryMetaData(e4) {
    try {
      const { data: t5 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: e4 == null ? void 0 : e4.signal });
      return S4(t5);
    } catch {
      return null;
    }
  }
  async _fetchAuxiliaryTable(e4) {
    try {
      const { data: t5 } = await this.request(this.url + ".vat.dbf", { responseType: "array-buffer", signal: e4 == null ? void 0 : e4.signal }), r6 = r4.parse(t5);
      return (r6 == null ? void 0 : r6.recordSet) ? d3.fromJSON(r6.recordSet) : null;
    } catch {
      return null;
    }
  }
};
function k4(e4) {
  var _a, _b;
  const t5 = R(e4), { width: r6, height: i7, tileWidth: s5, tileHeight: a7, planes: f11, pixelType: l7, compression: u11, firstPyramidLevel: c8, maximumPyramidLevel: h9, pyramidBlockWidth: m10, pyramidBlockHeight: d9, tileBoundary: y7, affine: g7, metadata: x6 } = t5, w4 = ((_a = t5.extent.spatialReference) == null ? void 0 : _a.wkt) || ((_b = t5.extent.spatialReference) == null ? void 0 : _b.wkid);
  let R4 = d7(w4), v6 = !!t5.isPseudoGeographic;
  null == R4 && (v6 = true, R4 = new f2({ wkid: 3857 }));
  const k5 = new w({ ...t5.extent, spatialReference: R4 }), P4 = new x(k5 ? { x: k5.xmin, y: k5.ymax, spatialReference: R4 } : { x: 0, y: 0 }), D6 = new n6({ blockWidth: s5, blockHeight: a7, pyramidBlockWidth: m10, pyramidBlockHeight: d9, compression: u11, origin: P4, firstPyramidLevel: c8, maximumPyramidLevel: h9, blockBoundary: y7 }), O = new x({ x: (k5.xmax - k5.xmin) / r6, y: (k5.ymax - k5.ymin) / i7, spatialReference: R4 }), L3 = x6 ? { BandProperties: x6.bandProperties, DataType: x6.dataType } : {};
  let j6 = null;
  const B3 = F2(e4[0], "PHOTOMETRICINTERPRETATION"), z2 = _2(e4[0], "COLORMAP");
  if (B3 <= 3 && (z2 == null ? void 0 : z2.length) > 3 && z2.length % 3 == 0) {
    j6 = [];
    const e5 = z2.length / 3;
    for (let t6 = 0; t6 < e5; t6++)
      j6.push([t6, z2[t6] >>> 8, z2[t6 + e5] >>> 8, z2[t6 + 2 * e5] >>> 8]);
  }
  const A2 = new m2({ width: r6, height: i7, bandCount: f11, pixelType: l7, pixelSize: O, storageInfo: D6, spatialReference: R4, isPseudoSpatialReference: v6, keyProperties: L3, extent: k5, colormap: j6, statistics: x6 ? x6.statistics : null });
  return (g7 == null ? void 0 : g7.length) && (A2.nativeExtent = new w({ xmin: -0.5, ymin: 0.5 - i7, xmax: r6 - 0.5, ymax: 0.5, spatialReference: R4 }), A2.transform = new y4({ polynomialOrder: 1, forwardCoefficients: [g7[2] + g7[0] / 2, g7[5] - g7[3] / 2, g7[0], g7[3], -g7[1], -g7[4]] }), A2.extent = A2.transform.forwardTransform(A2.nativeExtent), A2.pixelSize = new x({ x: (k5.xmax - k5.xmin) / r6, y: (k5.ymax - k5.ymin) / i7, spatialReference: R4 }), D6.origin.x = -0.5, D6.origin.y = 0.5), { imageInfo: t5, rasterInfo: A2 };
}
function P3(e4, t5) {
  if (t5.statistics = e4.statistics ?? t5.statistics, t5.histograms = e4.histograms, e4.histograms && null == t5.statistics && (t5.statistics = g2(e4.histograms)), e4.transform && null == t5.transform) {
    t5.transform = e4.transform, t5.nativeExtent = t5.extent;
    const r6 = t5.transform.forwardTransform(t5.nativeExtent);
    t5.pixelSize = new x({ x: (r6.xmax - r6.xmin) / t5.width, y: (r6.ymax - r6.ymin) / t5.height, spatialReference: t5.spatialReference }), t5.extent = r6;
  }
  t5.isPseudoSpatialReference && e4.spatialReference && (t5.spatialReference = e4.spatialReference, t5.extent.spatialReference = t5.nativeExtent.spatialReference = t5.storageInfo.origin.spatialReference = t5.spatialReference);
}
e([y()], v5.prototype, "_files", void 0), e([y()], v5.prototype, "_headerInfo", void 0), e([y()], v5.prototype, "_bufferSize", void 0), e([y({ type: String, json: { write: true } })], v5.prototype, "datasetFormat", void 0), v5 = e([a2("esri.layers.support.rasterDatasets.TIFFRaster")], v5);
var D5 = v5;

// node_modules/@arcgis/core/layers/support/rasterDatasets/RasterFactory.js
var u10 = /* @__PURE__ */ new Map();
u10.set("CRF", { desc: "Cloud Raster Format", constructor: k3 }), u10.set("MRF", { desc: "Meta Raster Format", constructor: b3 }), u10.set("TIFF", { desc: "GeoTIFF", constructor: D5 }), u10.set("RasterTileServer", { desc: "Raster Tile Server", constructor: I3 }), u10.set("JPG", { desc: "JPG Raster Format", constructor: d8 }), u10.set("PNG", { desc: "PNG Raster Format", constructor: d8 }), u10.set("GIF", { desc: "GIF Raster Format", constructor: d8 }), u10.set("BMP", { desc: "BMP Raster Format", constructor: d8 }), u10.set("CovJSON", { desc: "COVJSON Raster Format", constructor: h7 }), u10.set("MEMORY", { desc: "In Memory Raster Format", constructor: g5 });
var l6 = class {
  static get supportedFormats() {
    const t5 = /* @__PURE__ */ new Set();
    return u10.forEach((e4, r6) => t5.add(r6)), t5;
  }
  static async open(e4) {
    var _a;
    const { url: r6, ioConfig: s5, source: o8, sourceJSON: a7 } = e4;
    let c8 = e4.datasetFormat ?? (s5 == null ? void 0 : s5.datasetFormat);
    null == c8 && (r6.includes(".") ? c8 = r6.slice(r6.lastIndexOf(".") + 1).toUpperCase() : "coverage" === ((_a = o8 == null ? void 0 : o8.type) == null ? void 0 : _a.toLowerCase()) ? c8 = "CovJSON" : (o8 == null ? void 0 : o8.extent) && o8.pixelblocks && (c8 = "MEMORY")), "OVR" === c8 || "TIF" === c8 ? c8 = "TIFF" : "JPG" === c8 || "JPEG" === c8 || "JFIF" === c8 ? c8 = "JPG" : "COVJSON" === c8 && (c8 = "CovJSON"), r6.toLowerCase().includes("/imageserver") && !r6.toLowerCase().includes("/wcsserver") && (c8 = "RasterTileServer");
    const n9 = { url: r6, source: o8, sourceJSON: a7, datasetFormat: c8, ioConfig: s5 ?? { bandIds: null, sampling: null } };
    if (Object.keys(n9).forEach((t5) => {
      null == n9[t5] && delete n9[t5];
    }), c8) {
      if (!this.supportedFormats.has(c8))
        throw new s("rasterfactory:open", "not a supported format " + c8);
      if ("CRF" === c8 && !(s5 == null ? void 0 : s5.enableCRF))
        throw new s("rasterfactory:open", `cannot open raster: ${r6}`);
      const o9 = new (0, u10.get(c8).constructor)(n9);
      return await o9.open({ signal: e4.signal }), o9;
    }
    const l7 = Array.from(u10.keys()).filter((t5) => "CovJSON" !== t5 && "Memory" !== t5);
    let i7 = 0;
    const m10 = () => {
      if (c8 = l7[i7++], !c8)
        return null;
      if ("CRF" === c8 && !(s5 == null ? void 0 : s5.enableCRF))
        return null;
      const t5 = new (0, u10.get(c8).constructor)(n9);
      return t5.open({ signal: e4.signal }).then(() => t5).catch(() => m10());
    };
    return m10();
  }
  static register(t5, e4, r6) {
    u10.has(t5.toUpperCase()) || u10.set(t5.toUpperCase(), { desc: e4, constructor: r6 });
  }
};

// node_modules/@arcgis/core/layers/ImageryTileLayer.js
var C2 = class extends n4(t(u2(j2(e2(L2(f4(l(f3(S(i(b))))))))))) {
  constructor(...e4) {
    super(...e4), this._primaryRasters = [], this.bandIds = null, this.interpolation = null, this.legendEnabled = true, this.isReference = null, this.listMode = "show", this.sourceJSON = null, this.version = null, this.type = "imagery-tile", this.operationalLayerType = "ArcGISTiledImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.fields = null, this.source = void 0, this._debouncedSaveOperations = k2(async (e5, t5, r6) => {
      const { save: s5, saveAs: i7 } = await import("./imageryUtils-2KIKRXHV.js");
      switch (e5) {
        case A.SAVE:
          return s5(this, t5);
        case A.SAVE_AS:
          return i7(this, r6, t5);
      }
    });
  }
  normalizeCtorArgs(e4, t5) {
    return "string" == typeof e4 ? { url: e4, ...t5 } : e4;
  }
  load(e4) {
    const t5 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e4).catch(a).then(() => this._openRaster(t5))), Promise.resolve(this);
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get rasterFields() {
    var _a;
    const e4 = [new y2({ name: "Raster.ServicePixelValue", alias: "Pixel Value", domain: null, editable: false, length: 50, type: "string" }), new y2({ name: "Raster.ServicePixelValue.Raw", alias: "Raw Pixel Value", domain: null, editable: false, length: 50, type: "string" })], { serviceRasterInfo: t5 } = this, r6 = t5 == null ? void 0 : t5.attributeTable, s5 = null != r6 ? r6.fields : null, i7 = "Raster.";
    if (s5) {
      const t6 = s5.filter((e5) => "oid" !== e5.type && "value" !== e5.name.toLowerCase()).map((e5) => {
        const t7 = e5.clone();
        return t7.name = i7 + e5.name, t7;
      });
      e4.push(...t6);
    }
    const o8 = t5 == null ? void 0 : t5.dataType, a7 = t5 == null ? void 0 : t5.multidimensionalInfo;
    if (("vector-magdir" === o8 || "vector-uv" === o8) && null != a7) {
      const t6 = (_a = a7.variables[0].unit) == null ? void 0 : _a.trim(), r7 = "Magnitude" + (t6 ? ` (${t6})` : "");
      e4.push(new y2({ name: "Raster.Magnitude", alias: r7, domain: null, editable: false, type: "double" })), e4.push(new y2({ name: "Raster.Direction", alias: "Direction ()", domain: null, editable: false, type: "double" }));
    }
    return e4;
  }
  createPopupTemplate(e4) {
    const { rasterFields: t5 } = this, r6 = new Set(t5.map(({ name: e5 }) => e5).filter((e5) => "raster.servicepixelvalue.raw" !== e5.toLowerCase()));
    return p2({ fields: t5, title: this.title }, { ...e4, visibleFieldNames: r6 });
  }
  async generateRasterInfo(e4, t5) {
    if (!(e4 = v2(N3, e4)))
      return this.serviceRasterInfo;
    try {
      const { rasterInfo: r6 } = await this._openFunctionRaster(e4, t5);
      return r6;
    } catch (r6) {
      if (r6 instanceof s)
        throw r6;
      throw new s("imagery-tile-layer", "the given raster function is not supported");
    }
  }
  async save(e4) {
    return this._debouncedSaveOperations(A.SAVE, e4);
  }
  async saveAs(e4, t5) {
    return this._debouncedSaveOperations(A.SAVE_AS, t5, e4);
  }
  write(e4, t5) {
    const r6 = this._primaryRasters[0] ?? this.raster;
    if (this.loaded ? "RasterTileServer" === r6.datasetFormat && ("Raster" === r6.tileType || "Map" === r6.tileType) : this.url && /\/ImageServer(\/|\/?$)/i.test(this.url))
      return super.write(e4, t5);
    if (t5 == null ? void 0 : t5.messages) {
      const e5 = `${t5.origin}/${t5.layerContainerType || "operational-layers"}`;
      t5.messages.push(new s("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e5}'`, { layer: this }));
    }
    return null;
  }
  async _openRaster(e4) {
    let t5 = false;
    if (this.raster)
      await this._openFromRaster(this.raster, e4), t5 = "Function" === this.raster.datasetFormat;
    else {
      const { url: t6, rasterFunction: r7, source: i7 } = this;
      if (!t6 && !i7)
        throw new s("imagery-tile-layer:open", "missing url or source parameter");
      i7 ? await this._openFromSource(i7, e4) : r7 ? await this._openFromUrlWithRasterFunction(t6, r7, e4) : await this._openFromUrl(t6, e4);
    }
    const r6 = this.raster.rasterInfo;
    if (!r6)
      throw new s("imagery-tile-layer:load", "cannot load resources on " + this.url);
    if (this._set("serviceRasterInfo", t5 ? r6 : this._primaryRasters[0].rasterInfo), this._set("spatialReference", r6.spatialReference), this.sourceJSON = this.sourceJSON || this.raster.sourceJSON, null != this.sourceJSON) {
      const e5 = "Map" === this.raster.tileType && null != this.sourceJSON.minLOD && null != this.sourceJSON.maxLOD ? this.sourceJSON : { ...this.sourceJSON, minScale: 0, maxScale: 0 };
      this.read(e5, { origin: "service" });
    } else
      this.read({ tileInfo: this.serviceRasterInfo.storageInfo.tileInfo.toJSON() }, { origin: "service" });
    this.title || (this.title = this.raster.datasetName), "Map" === this.raster.tileType && (this.popupEnabled = false), this._configDefaultSettings(), this.addHandles(d(() => this.customParameters, (e5) => {
      this.raster && (this.raster.ioConfig.customFetchParameters = e5);
    }));
  }
  async _openFromRaster(e4, t5) {
    e4.rasterInfo || await e4.open({ signal: t5 }), this._primaryRasters = "Function" === e4.datasetFormat ? e4.primaryRasters.rasters : [e4], this.url || (this.url = this._primaryRasters[0].url);
  }
  async _openFromUrlWithRasterFunction(e4, t5, r6) {
    const i7 = [e4];
    t5 && N2(t5.toJSON(), i7);
    const o8 = await Promise.all(i7.map((e5) => l6.open({ url: e5, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: r6 }))), a7 = o8.findIndex((e5) => null == e5);
    if (a7 > -1)
      throw new s("imagery-tile-layer:open", `cannot open raster: ${i7[a7]}`);
    return this._primaryRasters = o8, this._initializeWithFunctionRaster(t5);
  }
  async _openFromUrl(e4, t5) {
    const r6 = await l6.open({ url: e4, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: t5 });
    if (null == r6)
      throw new s("imagery-tile-layer:open", `cannot open raster: ${e4}`);
    this._primaryRasters = [r6], this.raster = r6;
  }
  async _openFromSource(e4, t5) {
    var _a;
    const r6 = "the tiled imagery data source is not supported", i7 = "coverage" === ((_a = e4.type) == null ? void 0 : _a.toLowerCase()) ? "CovJSON" : e4.extent && e4.pixelBlock ? "MEMORY" : null;
    if (!i7)
      throw new s("imagery-tile-layer:open", r6);
    "MEMORY" === i7 && (e4 = { extent: e4.extent, pixelBlocks: [e4.pixelBlock] });
    const o8 = await l6.open({ url: "", source: e4, datasetFormat: i7, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: t5 });
    if (null == o8)
      throw new s("imagery-tile-layer:open", r6);
    this._primaryRasters = [o8], this.rasterFunction ? await this._initializeWithFunctionRaster(this.rasterFunction) : this.raster = o8;
  }
  async _openFunctionRaster(e4, t5) {
    var _a;
    const r6 = { raster: this._primaryRasters[0] };
    this._primaryRasters.length > 1 && this._primaryRasters.forEach((e5) => r6[e5.url] = e5);
    const s5 = R3(((_a = e4.functionDefinition) == null ? void 0 : _a.toJSON()) ?? e4.toJSON(), r6), i7 = new u6({ rasterFunction: s5 });
    return await i7.open(t5), i7;
  }
  async _initializeWithFunctionRaster(e4, t5) {
    try {
      this.raster = await this._openFunctionRaster(e4, t5);
    } catch (r6) {
      r6 instanceof s && n.getLogger(this).error("imagery-tile-layer:open", r6.message), n.getLogger(this).warn("imagery-tile-layer:open", "the raster function cannot be applied and is removed"), this._set("rasterFunction", null), this.raster = this._primaryRasters[0];
    }
  }
};
e([y({ clonable: false })], C2.prototype, "_primaryRasters", void 0), e([y({ type: [T], json: { write: { overridePolicy() {
  var _a;
  return { enabled: !this.loaded || "Raster" === this.raster.tileType || "0,1,2" !== ((_a = this.bandIds) == null ? void 0 : _a.join(",")) };
} } } })], C2.prototype, "bandIds", void 0), e([y({ json: { write: { overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType || "bilinear" !== this.interpolation };
} } } }), o3(a4)], C2.prototype, "interpolation", void 0), e([y(c2)], C2.prototype, "legendEnabled", void 0), e([y({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], C2.prototype, "isReference", void 0), e([y({ type: ["show", "hide"] })], C2.prototype, "listMode", void 0), e([y({ json: { read: true, write: true } })], C2.prototype, "blendMode", void 0), e([y()], C2.prototype, "sourceJSON", void 0), e([y({ readOnly: true, json: { origins: { service: { read: { source: "currentVersion" } } } } })], C2.prototype, "version", void 0), e([y({ readOnly: true, json: { read: false } })], C2.prototype, "type", void 0), e([y({ type: ["ArcGISTiledImageServiceLayer"] })], C2.prototype, "operationalLayerType", void 0), e([y({ type: Boolean, value: true, json: { read: { source: "disablePopup", reader: (e4, t5) => !t5.disablePopup }, write: { target: "disablePopup", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
}, writer(e4, t5, r6) {
  t5[r6] = !e4;
} } } })], C2.prototype, "popupEnabled", void 0), e([y({ type: P2, json: { read: { source: "popupInfo" }, write: { target: "popupInfo", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
} } } })], C2.prototype, "popupTemplate", void 0), e([y({ readOnly: true })], C2.prototype, "defaultPopupTemplate", null), e([y({ readOnly: true, type: [y2] })], C2.prototype, "fields", void 0), e([y({ readOnly: true, type: [y2] })], C2.prototype, "rasterFields", null), e([y({ constructOnly: true })], C2.prototype, "source", void 0), C2 = e([a2("esri.layers.ImageryTileLayer")], C2);
var M = C2;
export {
  M as default
};
//# sourceMappingURL=ImageryTileLayer-5NUFRD6H.js.map
