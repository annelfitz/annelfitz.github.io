import {
  e as e6
} from "./chunk-G7RYWCEO.js";
import {
  V as V2,
  m,
  r as r7,
  v
} from "./chunk-EVB3GIFQ.js";
import {
  t as t3
} from "./chunk-BZ24WJCW.js";
import {
  o as o5,
  o2 as o6
} from "./chunk-GN2OLKIL.js";
import {
  r as r6
} from "./chunk-BQGPMKNK.js";
import {
  e as e5,
  f,
  u as u2
} from "./chunk-J5F4VILS.js";
import {
  A,
  _ as _2,
  c as c2,
  l as l2
} from "./chunk-7A5N7G2Z.js";
import {
  i
} from "./chunk-FIHLU3LF.js";
import {
  c
} from "./chunk-OBABKQ6S.js";
import {
  r as r4,
  r2 as r5,
  t as t2
} from "./chunk-ZPC74XHC.js";
import {
  o as o4
} from "./chunk-6ENXMQPD.js";
import {
  S,
  _,
  h,
  o as o3
} from "./chunk-MEEG7XMI.js";
import {
  o as o2
} from "./chunk-LJULTBAY.js";
import {
  N,
  e as e4,
  s as s3
} from "./chunk-TXLJQAAN.js";
import {
  s
} from "./chunk-AL5NKCU5.js";
import {
  n
} from "./chunk-CSSLIU64.js";
import {
  a
} from "./chunk-CJNDQ2LH.js";
import {
  o
} from "./chunk-CDBOQCLE.js";
import {
  n as n2
} from "./chunk-P4MNTMCZ.js";
import {
  l
} from "./chunk-WZJNHZ6H.js";
import {
  e as e3
} from "./chunk-GLF3KRAL.js";
import {
  s as s2,
  u
} from "./chunk-HZSGATFT.js";
import {
  r as r3
} from "./chunk-NFB6O77E.js";
import {
  r as r2
} from "./chunk-AKEHDP75.js";
import {
  H
} from "./chunk-5MMGIT64.js";
import {
  V
} from "./chunk-JZBR4X6W.js";
import {
  e as e2,
  r
} from "./chunk-OIJCMME5.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  t
} from "./chunk-QHK5ZYFW.js";
import {
  has
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/Material/ComponentTechnique.js
var T = class _T extends r4 {
  initializeConfiguration(r9, i3) {
    i3.spherical = r9.viewingMode === l.Global, i3.doublePrecisionRequiresObfuscation = r9.rctx.driverTest.doublePrecisionRequiresObfuscation.result;
  }
  initializeProgram(e8) {
    return new r5(e8.rctx, _T.shader.get().build(this.configuration), M);
  }
  _setPipelineState(e8) {
    const i3 = this.configuration, o7 = i3.integratedMeshMode !== v.None, n3 = e8 === o2.NONE, d = e8 === o2.FrontFace;
    return S({ blending: i3.output !== o.Color && i3.output !== o.Alpha || !i3.blendingEnabled ? null : n3 ? c2 : A(e8), culling: h(i3.cullFace), depthTest: { func: l2(e8) }, depthWrite: n3 || d ? o3 : null, colorWrite: _, stencilWrite: o7 || i3.hasOccludees ? e5 : null, stencilTest: o7 ? u2(N.IntegratedMeshMaskExcluded) : i3.hasOccludees ? f : null, polygonOffset: n3 || d ? i3.hasPolygonOffset ? { factor: 2, units: 2 } : null : _2 });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
};
T.shader = new t2(V2, () => import("./ComponentShader.glsl-5HTPAQEZ.js"));
var M = /* @__PURE__ */ new Map([[e3.POSITION, 0], [e3.NORMAL, 1], [e3.NORMALCOMPRESSED, 1], [e3.COLOR, 2], [e3.UV0, 3], [e3.UVREGION, 4], [e3.COMPONENTINDEX, 5]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/core/material/MaterialBase.js
var e7 = class extends n2 {
  constructor() {
    super(...arguments), this._dirty = true;
  }
  _setDirty() {
    this._dirty = true;
  }
  _setClean() {
    if (this._dirty = false, null != this._parameterBlocks)
      for (const t4 of this._parameterBlocks)
        this[t4]._setClean();
  }
  get dirty() {
    return this._dirty || this._checkParameterBlocksDirty();
  }
  _checkParameterBlocksDirty() {
    if (null == this._parameterBlocks)
      return false;
    for (const t4 of this._parameterBlocks)
      if (this[t4].dirty)
        return true;
    return false;
  }
};
var r8 = class {
  constructor() {
    this._dirty = true;
  }
  _setDirty() {
    this._dirty = true;
  }
  _setClean() {
    this._dirty = false;
  }
  get dirty() {
    return this._dirty;
  }
};
function s4(t4 = {}) {
  return (e8, r9) => {
    const s5 = e8._parameterCount ?? 0;
    if (e8._parameterCount = s5 + 1, t4.vectorOps) {
      const i3 = t4.vectorOps;
      Object.defineProperty(e8, r9, { get() {
        return this[s5];
      }, set(t5) {
        const e9 = this[s5];
        if (null == e9)
          this[s5] = t5;
        else {
          if (i3.equals(e9, t5))
            return;
          i3.copy(e9, t5);
        }
        this._setDirty();
      } });
    } else
      Object.defineProperty(e8, r9, { get() {
        return this[s5];
      }, set(e9) {
        this[s5] !== e9 && (t4.dispose && this[s5] && this[s5].dispose(), this[s5] = e9, this._setDirty());
      } });
  };
}
function i2() {
  return (t4, e8) => {
    const r9 = t4._parameterCount ?? 0;
    t4._parameterCount = r9 + 1, t4._parameterBlocks = t4._parameterBlocks || [], t4._parameterBlocks.push(r9), Object.defineProperty(t4, e8, { get() {
      return this[r9];
    }, set(t5) {
      this[r9] !== t5 && (this[r9] = t5, this._setDirty());
    } });
  };
}

// node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/Material/ComponentMaterial.js
var R = class extends e7 {
  constructor(e8, t4) {
    super(), this.toMapSpace = t4, this.baseColor = r2(1, 1, 1, 1), this.usePBR = false, this.hasParametersFromSource = false, this.mrrFactors = e2(r6), this.emissiveFactor = r(0, 0, 0), this.baseColorTexture = null, this.metallicRoughnessTexture = null, this.emissionTexture = null, this.occlusionTexture = null, this.normalTexture = null, this.objectOpacity = 1, this.commonMaterialParameters = new W(), this.componentParameters = new _3(), this.textureAlphaCutoff = o4, this.alphaDiscardMode = s3.Opaque, this.isIntegratedMesh = false, this.polygonOffsetEnabled = false, this.ellipsoidMode = t3.Earth, this.hasOccludees = false, this._techniqueConfiguration = new m();
    const a2 = new e6(e8.position), n3 = r3(e8.rotationScale);
    s2(n3, n3), u(n3, n3), this.transformNormalGlobalFromModel = n3, this.transformWorldFromModelTL = a2.low, this.transformWorldFromModelTH = a2.high, this.transformWorldFromModelRS = e8.rotationScale;
  }
  dispose() {
    this._technique = t(this._technique), this.baseColorTexture = null, this.metallicRoughnessTexture = null, this.emissionTexture = null, this.occlusionTexture = null, this.normalTexture = null;
  }
  get texture() {
    return null != this.baseColorTexture ? this.baseColorTexture.glTexture : null;
  }
  get textureMetallicRoughness() {
    return null != this.metallicRoughnessTexture ? this.metallicRoughnessTexture.glTexture : null;
  }
  get textureEmissive() {
    return null != this.emissionTexture ? this.emissionTexture.glTexture : null;
  }
  get textureOcclusion() {
    return null != this.occlusionTexture ? this.occlusionTexture.glTexture : null;
  }
  get textureNormal() {
    return null != this.normalTexture ? this.normalTexture.glTexture : null;
  }
  prepareTechnique(e8, t4, r9, o7) {
    const s5 = this._techniqueConfiguration;
    s5.hasVertexColors = o7.colors, s5.hasNormals = o7.hasNormals, s5.textureCoordinateType = o7.textureCoordinates, s5.hasMetallicRoughnessTexture = null != this.metallicRoughnessTexture, s5.hasEmissionTexture = null != this.emissionTexture, s5.hasOcclusionTexture = null != this.occlusionTexture, s5.hasNormalTexture = null != this.normalTexture, s5.transparencyPassType = t4.identifier === o6.Material && null != r9.transparencyPassType ? r9.transparencyPassType : o2.NONE, s5.multipassEnabled = t4.identifier === o6.Material && r9.multipassEnabled, s5.cullAboveGround = t4.identifier === o6.Material && r9.multipassTerrain.cullAboveGround, s5.ellipsoidMode = this.ellipsoidMode, s5.componentData = this.componentParameters.type, s5.cullFace = this.commonMaterialParameters.cullFace, s5.doubleSidedMode = this.commonMaterialParameters.doubleSided ? i.View : i.None, s5.hasColorTexture = null != this.baseColorTexture;
    const a2 = this._computeWhichMaterialPass();
    if (s5.blendingEnabled = a2 === F.Transparent || a2 === F.OpaqueAndTransparent, s5.alphaDiscardMode = this.alphaDiscardMode, s5.integratedMeshMode = this.isIntegratedMesh ? L(r9) ? B(r9) ? v.ColorOverlayWithWater : v.ColorOverlay : v.NoOverlay : v.None, s5.hasPolygonOffset = this.polygonOffsetEnabled, s5.pbrMode = s5.integratedMeshMode === v.ColorOverlayWithWater ? c.WaterOnIntegratedMesh : this.usePBR ? this.hasParametersFromSource ? has("enable-feature:im-shading") && this.isIntegratedMesh ? c.Simplified : c.Schematic : c.Normal : c.Disabled, s5.normalType = o7.needsNormals ? s5.hasNormals ? a.Compressed : a.ScreenDerivative : a.Ground, s5.hasSlicePlane = null != r9.slicePlane && this.commonMaterialParameters.hasSlicePlane, t4.identifier === o6.ShadowMap)
      s5.output = o.Shadow, s5.vertexDiscardMode = r7.None;
    else if (t4.identifier === o6.Highlight)
      s5.output = o.Highlight, s5.vertexDiscardMode = r7.None;
    else {
      switch (a2 === F.OpaqueAndTransparent ? s5.vertexDiscardMode = t4.transparent ? r7.Opaque : r7.Transparent : s5.vertexDiscardMode = r7.None, s5.output = t4.output, s5.receiveAmbientOcclusion = false, s5.receiveShadows = false, t4.output) {
        case o.Color:
          s5.receiveAmbientOcclusion = null != r9.ssao, s5.hasOccludees = r9.hasOccludees, s5.receiveShadows = r9.shadowMap.ready, s5.hasScreenSpaceReflections = null != r9.ssr.lastFrameColor, s5.hasCloudsReflections = null != r9.cloudsFade.data;
          break;
        case o.Alpha:
          s5.hasOccludees = r9.hasOccludees;
          break;
        case o.ObjectAndLayerIdColor:
          s5.objectAndLayerIdColor = true;
      }
      s5.snowCover = this.hasSnowCover(r9);
    }
    return this._technique = e8.releaseAndAcquire(T, s5, this._technique), this._setClean(), this._technique;
  }
  hasSnowCover(e8) {
    return null != e8.weather && e8.weatherVisible && "snowy" === e8.weather.type && "enabled" === e8.weather.snowCover;
  }
  submit(e8, t4, r9) {
    if (0 === this.objectOpacity)
      return;
    const o7 = r9.renderable.geometry, s5 = r9.components, a2 = r9.renderable.meta.cameraDepthSquared, i3 = s5.geometryRanges, l3 = s5.highlightRanges, n3 = s5.defaultShadowMapRanges;
    switch (this._computeWhichMaterialPass()) {
      case F.Opaque:
        e8.materialOpaque.submitDraw(this, o7, i3, a2);
        break;
      case F.Transparent:
        e8.materialTransparent.submitDraw(this, o7, i3, a2);
        break;
      case F.OpaqueAndTransparent:
        e8.materialOpaque.submitDraw(this, o7, i3, a2), e8.materialTransparent.submitDraw(this, o7, i3, a2);
        break;
      case F.IntegratedMesh:
        e8.materialIntegratedMesh.submitDraw(this, o7, i3, a2), k(t4) && e8.highlightIntegratedMesh.submitDraw(this, o7, i3, a2);
    }
    const u3 = this.componentParameters.castShadows !== I.None;
    u3 && e8.shadowMap.submitDraw(this, o7, i3, a2), null != l3 && (e8.highlight.submitDraw(this, o7, l3, a2), u3 && e8.highlightShadowMap.submitDraw(this, o7, l3, a2)), u3 && null != n3 && e8.defaultShadowMap.submitDraw(this, o7, n3, a2);
  }
  _computeWhichMaterialPass() {
    return this.isIntegratedMesh ? F.IntegratedMesh : this.objectOpacity < 1 ? F.Transparent : this.componentParameters.opaqueOverride === I.All ? F.Opaque : this.baseColor[3] < 1 || this.alphaDiscardMode === s3.Blend || this.alphaDiscardMode === s3.MaskBlend ? F.Transparent : this.componentParameters.transparent === I.None ? F.Opaque : this.componentParameters.transparent === I.All ? F.Transparent : F.OpaqueAndTransparent;
  }
};
var F;
var I;
e([s4({ vectorOps: H })], R.prototype, "baseColor", void 0), e([s4()], R.prototype, "usePBR", void 0), e([s4()], R.prototype, "hasParametersFromSource", void 0), e([s4({ vectorOps: V })], R.prototype, "mrrFactors", void 0), e([s4({ vectorOps: V })], R.prototype, "emissiveFactor", void 0), e([s4({ dispose: true })], R.prototype, "baseColorTexture", void 0), e([s4({ dispose: true })], R.prototype, "metallicRoughnessTexture", void 0), e([s4({ dispose: true })], R.prototype, "emissionTexture", void 0), e([s4({ dispose: true })], R.prototype, "occlusionTexture", void 0), e([s4({ dispose: true })], R.prototype, "normalTexture", void 0), e([s4()], R.prototype, "objectOpacity", void 0), e([i2()], R.prototype, "commonMaterialParameters", void 0), e([i2()], R.prototype, "componentParameters", void 0), e([s4()], R.prototype, "textureAlphaCutoff", void 0), e([s4()], R.prototype, "alphaDiscardMode", void 0), e([s4()], R.prototype, "isIntegratedMesh", void 0), e([s4()], R.prototype, "polygonOffsetEnabled", void 0), e([s4()], R.prototype, "ellipsoidMode", void 0), e([s4()], R.prototype, "hasOccludees", void 0), function(e8) {
  e8[e8.Opaque = 0] = "Opaque", e8[e8.Transparent = 1] = "Transparent", e8[e8.OpaqueAndTransparent = 2] = "OpaqueAndTransparent", e8[e8.IntegratedMesh = 3] = "IntegratedMesh";
}(F || (F = {}));
var W = class extends r8 {
  constructor() {
    super(...arguments), this.doubleSided = false, this.cullFace = e4.Back, this.hasSlicePlane = true;
  }
};
e([s4()], W.prototype, "doubleSided", void 0), e([s4()], W.prototype, "cullFace", void 0), e([s4()], W.prototype, "hasSlicePlane", void 0);
var _3 = class extends r8 {
  constructor() {
    super(...arguments), this.externalColor = r2(1, 1, 1, 1), this.externalColorMixMode = n.Multiply, this.castShadows = I.All;
  }
  get transparent() {
    return this.externalColor[3] < 1 ? I.All : I.None;
  }
  get opaqueOverride() {
    return this.externalColorMixMode === n.Replace && 1 === this.externalColor[3] ? I.All : I.None;
  }
  get visible() {
    return this.externalColor[3] > 0 ? I.All : I.None;
  }
  get type() {
    return s.Uniform;
  }
};
e([s4({ vectorOps: H })], _3.prototype, "externalColor", void 0), e([s4()], _3.prototype, "externalColorMixMode", void 0), e([s4()], _3.prototype, "castShadows", void 0), function(e8) {
  e8[e8.All = 0] = "All", e8[e8.Some = 1] = "Some", e8[e8.None = 2] = "None";
}(I || (I = {}));
var E = class extends r8 {
  constructor() {
    super(...arguments), this.texture = null, this.transparent = I.None, this.opaqueOverride = I.None, this.castShadows = I.None;
  }
  get type() {
    return s.Varying;
  }
};
function k(e8) {
  var _a;
  return null != ((_a = e8.overlay) == null ? void 0 : _a.getTexture(o5.Highlight));
}
function B(e8) {
  var _a;
  return null != ((_a = e8.overlay) == null ? void 0 : _a.getTexture(o5.WaterNormal));
}
function L(e8) {
  var _a;
  return null != ((_a = e8.overlay) == null ? void 0 : _a.getTexture(o5.ColorNoRasterImage));
}
e([s4()], E.prototype, "texture", void 0), e([s4()], E.prototype, "transparent", void 0), e([s4()], E.prototype, "opaqueOverride", void 0), e([s4()], E.prototype, "castShadows", void 0);

export {
  M,
  R,
  I,
  _3 as _,
  E
};
//# sourceMappingURL=chunk-5M7PURL4.js.map
