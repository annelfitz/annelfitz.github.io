{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/ShadowHighlight.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport{invert as e,translate as i}from\"../core/libs/gl-matrix-2/math/mat4.js\";import{create as o}from\"../core/libs/gl-matrix-2/factories/mat4f64.js\";import{n as t,e as r}from\"./vec32.js\";import{create as a}from\"../core/libs/gl-matrix-2/factories/vec3f64.js\";import{ScreenSpacePass as l}from\"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js\";import{unoccludedHighlightFlag as s}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{ReadLinearDepth as n}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js\";import{ReadShadowMapPass as h}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";import{CameraSpace as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js\";import{RgbaFloatEncoding as c}from\"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";import{Float2PassUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float3PassUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";import{Float4PassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as v}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as f}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as u}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as w}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as x}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{SnapshotSlot as P}from\"../views/3d/webgl-engine/lib/ShadowMap.js\";const b=.99999,D=.025;function F(o){const a=new w;a.include(h,o),a.include(d),a.include(l);const F=a.fragment;return F.include(c),F.include(n),F.uniforms.add(new x(\"defaultDepthTex\",((e,i)=>i.shadowMap.getSnapshot(P.ExcludeHighlight))),new x(\"highlightDepthTex\",((e,i)=>i.shadowMap.getSnapshot(P.Highlight))),new x(\"depthMap\",((e,i)=>i.linearDepth?.getTexture())),new x(\"highlightTexture\",(e=>e.highlight)),new m(\"uColor\",(e=>e.shadowColor)),new p(\"nearFar\",((e,i)=>i.camera.nearFar)),new v(\"opacity\",(e=>e.shadowOpacity)),new v(\"occludedOpacity\",(e=>e.occludedShadowOpacity)),new v(\"terminationFactor\",(e=>e.opacityElevation*e.dayNightTerminator)),new g(\"lightingMainDirectionView\",((e,i)=>t(y,r(y,i.lighting.mainLight.direction,i.camera.viewInverseTransposeMatrix)))),new u(\"inverseViewMatrix\",((o,t)=>e(M,i(M,t.camera.viewMatrix,t.camera.center))))),F.constants.add(\"unoccludedHighlightFlag\",\"vec4\",s),F.code.add(f`\n    vec3 normalFromDepth(vec3 pixelPos, vec2 fragCoord, ivec2 iuv) {\n      float leftPixelDepth = linearDepthFromRGBA(texelFetch(depthMap, iuv + ivec2(-1, 0), 0), nearFar);\n      float rightPixelDepth = linearDepthFromRGBA(texelFetch(depthMap, iuv + ivec2(1, 0), 0), nearFar);\n      float bottomPixelDepth = linearDepthFromRGBA(texelFetch(depthMap, iuv + ivec2(0, -1), 0), nearFar);\n      float topPixelDepth = linearDepthFromRGBA(texelFetch(depthMap, iuv + ivec2(0, 1), 0), nearFar);\n\n      bool pickLeft = abs(pixelPos.z - leftPixelDepth) < abs(pixelPos.z - rightPixelDepth);\n      bool pickBottom = abs(pixelPos.z - bottomPixelDepth) < abs(pixelPos.z - topPixelDepth);\n\n      vec3 fragCoordHorizontal = pickLeft\n                                  ? vec3(fragCoord + vec2(-1.0, 0.0), leftPixelDepth)\n                                  : vec3(fragCoord + vec2(1.0, 0.0), rightPixelDepth);\n      vec3 fragCoordVertical = pickBottom\n                                  ? vec3(fragCoord + vec2(0.0, -1.0), bottomPixelDepth)\n                                  : vec3(fragCoord + vec2(0.0, 1.0), topPixelDepth);\n\n      vec3 verticalPixelPos = reconstructPosition(fragCoordHorizontal.xy, fragCoordHorizontal.z);\n      vec3 horizontalPixelPos = reconstructPosition(fragCoordVertical.xy, fragCoordVertical.z);\n\n      vec3 normal = normalize(cross(verticalPixelPos - pixelPos, horizontalPixelPos - pixelPos));\n      // Flip normal depending on triangle winding order for consistency\n      return pickLeft == pickBottom ? normal : -normal;\n    }\n\n    void main(void) {\n      vec4 highlightInfo = texture(highlightTexture, uv);\n      float visiblyHighlighted = (1.0 - clamp(distance(unoccludedHighlightFlag, highlightInfo), 0.0, 1.0)) * highlightInfo.a;\n      if (visiblyHighlighted > ${f.float(b)}) {\n        discard;\n      }\n\n      ivec2 iuv = ivec2(uv * vec2(textureSize(depthMap, 0)));\n      float depth = rgba2float(texelFetch(depthMap, iuv, 0));\n      // 0.0 is the clear value of depthMap, which means nothing has been drawn there and we should discard\n      if (depth == 0.0) {\n        discard;\n      }\n\n      float currentPixelDepth = linearDepthFromFloat(depth, nearFar);\n      if (-currentPixelDepth>nearFar.y || -currentPixelDepth<nearFar.x) {\n        discard;\n      }\n\n      vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);\n      vec4 worldSpacePos = inverseViewMatrix * currentPixelPos;\n\n      mat4 shadowMatrix;\n      float linearDepth = -currentPixelDepth;\n      int i = chooseCascade(linearDepth, shadowMatrix);\n      if (i >= numCascades) {\n        discard;\n      }\n\n      vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);\n\n      // vertex completely outside? -> no shadow\n      if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {\n        discard;\n      }\n\n      ivec2 texSize = textureSize(highlightDepthTex, 0);\n      ivec2 uvShadow = ivec2(cascadeCoordinates(i, texSize, lvpos) * vec2(texSize));\n\n      float depthHighlight = readShadowMapDepth(uvShadow, highlightDepthTex);\n      bool shadowHighlight = depthHighlight < lvpos.z;\n      if (!shadowHighlight) {\n        discard;\n      }\n\n      float depthDefault = readShadowMapDepth(uvShadow, defaultDepthTex);\n      bool shadowDefault = depthDefault < lvpos.z;\n\n      vec3 normal = normalFromDepth(currentPixelPos.xyz, gl_FragCoord.xy, iuv);\n      bool shaded = dot(normal, lightingMainDirectionView) < ${f.float(D)};\n\n      float fragOpacity = (shadowDefault || shaded) ? occludedOpacity : opacity;\n      fragColor = vec4(uColor.rgb, uColor.a * fragOpacity * terminationFactor);\n    }\n  `),a}const M=o(),y=a(),S=Object.freeze(Object.defineProperty({__proto__:null,build:F},Symbol.toStringTag,{value:\"Module\"}));export{S,F as b};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAI+tD,IAAM,IAAE;AAAR,IAAe,IAAE;AAAK,SAAS,EAAEA,IAAE;AAAC,QAAMC,KAAE,IAAID;AAAE,EAAAC,GAAE,QAAQ,GAAED,EAAC,GAAEC,GAAE,QAAQ,CAAC,GAAEA,GAAE,QAAQD,EAAC;AAAE,QAAME,KAAED,GAAE;AAAS,SAAOC,GAAE,QAAQ,CAAC,GAAEA,GAAE,QAAQC,EAAC,GAAED,GAAE,SAAS,IAAI,IAAI,EAAE,mBAAmB,CAACE,IAAED,OAAIA,GAAE,UAAU,YAAY,EAAE,gBAAgB,CAAE,GAAE,IAAI,EAAE,qBAAqB,CAACC,IAAED,OAAIA,GAAE,UAAU,YAAY,EAAE,SAAS,CAAE,GAAE,IAAI,EAAE,YAAY,CAACC,IAAED,OAAE;AAJ3iE;AAI6iE,iBAAAA,GAAE,gBAAF,mBAAe;AAAA,GAAa,GAAE,IAAI,EAAE,oBAAoB,CAAAC,OAAGA,GAAE,SAAU,GAAE,IAAIA,GAAE,UAAU,CAAAA,OAAGA,GAAE,WAAY,GAAE,IAAIA,GAAE,WAAW,CAACA,IAAED,OAAIA,GAAE,OAAO,OAAQ,GAAE,IAAIH,GAAE,WAAW,CAAAI,OAAGA,GAAE,aAAc,GAAE,IAAIJ,GAAE,mBAAmB,CAAAI,OAAGA,GAAE,qBAAsB,GAAE,IAAIJ,GAAE,qBAAqB,CAAAI,OAAGA,GAAE,mBAAiBA,GAAE,kBAAmB,GAAE,IAAIA,GAAE,6BAA6B,CAACA,IAAED,OAAI,EAAE,GAAE,EAAE,GAAEA,GAAE,SAAS,UAAU,WAAUA,GAAE,OAAO,0BAA0B,CAAC,CAAE,GAAE,IAAIC,GAAE,qBAAqB,CAACJ,IAAE,MAAI,EAAE,GAAE,EAAE,GAAE,EAAE,OAAO,YAAW,EAAE,OAAO,MAAM,CAAC,CAAE,CAAC,GAAEE,GAAE,UAAU,IAAI,2BAA0B,QAAO,CAAC,GAAEA,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iCA4BllF,EAAE,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+DA8CoB,EAAE,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,GAKtE,GAAED;AAAC;AAAC,IAAM,IAAE,EAAE;AAAV,IAAY,IAAE,EAAE;AAAhB,IAAkB,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,OAAM,EAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["o", "a", "F", "i", "e"]
}
