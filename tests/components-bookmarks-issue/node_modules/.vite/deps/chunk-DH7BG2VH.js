import {
  I
} from "./chunk-KSZESDGM.js";
import {
  e as e4
} from "./chunk-33LWZO2E.js";
import {
  i
} from "./chunk-VIKID44H.js";
import {
  e as e3
} from "./chunk-TLU6YG3S.js";
import {
  A,
  t as t3
} from "./chunk-WEER6QME.js";
import {
  a as a2,
  e as e2,
  t as t2
} from "./chunk-R4SGP2EA.js";
import {
  t
} from "./chunk-42DUJ2CX.js";
import {
  E,
  F,
  X
} from "./chunk-Z2F5OKVA.js";
import {
  e
} from "./chunk-GLF3KRAL.js";
import {
  j
} from "./chunk-HV6S3GY2.js";
import {
  a
} from "./chunk-IGR2BTWR.js";
import {
  n
} from "./chunk-ZPYA32PH.js";
import {
  h
} from "./chunk-OCF7OAES.js";
import {
  o
} from "./chunk-JZBR4X6W.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  L,
  W2 as W
} from "./chunk-UWQ3OYA5.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/polygonUtils.js
function h2(t4, o2, n2, a4) {
  const s = ((t5) => !Array.isArray(t5[0]))(o2) ? (t5, e5) => o2[3 * t5 + e5] : (t5, e5) => o2[t5][e5], c = a4 ? W(a4) / L(a4) : 1;
  return X(t4, (t5, e5) => o(t5, s(e5, 0) * c, s(e5, 1) * c, s(e5, 2)), n2);
}
function j2(e5, r, o2) {
  const i2 = h2(y, e5, r, o2) ? F(y) : [0, 0, 1];
  return Math.abs(i2[2]) > Math.cos(h(80)) ? n.Z : Math.abs(i2[1]) > Math.abs(i2[0]) ? n.Y : n.X;
}
var y = E();
function w2(t4, e5, r) {
  const i2 = j2(t4, (e5.length > 0 ? e5[0] : t4.length / 3) - 1, r);
  if (i2 !== n.Z) {
    t4 = t4.slice();
    for (let e6 = 0; e6 < t4.length; e6 += 3)
      t4[e6 + i2] = t4[e6 + 2];
  }
  return i(t4, e5, 3);
}
function d(t4) {
  const e5 = [[e.POSITION, new t(t4.attributeData.position, t4.indices, 3, true)]], r = A(t4.indices.length);
  return null != t4.attributeData.colorFeature ? e5.push([e.COLORFEATUREATTRIBUTE, new t([t4.attributeData.colorFeature], r, 1, true)]) : t4.attributeData.color && e5.push([e.COLOR, new t(t4.attributeData.color, r, 4, true)]), t4.attributeData.uvMapSpace && e5.push([e.UVMAPSPACE, new t(t4.attributeData.uvMapSpace, t4.indices, 4, true)]), t4.attributeData.boundingRect && e5.push([e.BOUNDINGRECT, new t(t4.attributeData.boundingRect, t4.indices, 9, true)]), new I(t4.material, e5, t4.mapPositions, e4.Mesh, t4.attributeData.objectAndLayerIdColor);
}
function D(t4, e5 = null) {
  const r = [[e.POSITION, new t(t4.attributeData.position, t4.indices, 3, true)], [e.UV0, new t(t4.attributeData.uv0, t4.indices, 2, true)]];
  return new I(t4.material, r, t4.mapPositions, e4.Mesh, e5);
}
function A2(t4) {
  switch (t4.type) {
    case "extent":
      if (t4 instanceof w)
        return j.fromExtent(t4);
      break;
    case "polygon":
      return t4;
  }
  return null;
}
var O = class {
  constructor(t4, e5, r) {
    this.renderData = t4, this.layerUid = e5, this.graphicUid = r, this.outGeometries = new Array();
  }
};

// node_modules/@arcgis/core/geometry/support/triangulationUtils.js
function f(t4) {
  const e5 = g(t4.rings, t4.hasZ, u.CCW_IS_HOLE, t4.spatialReference), s = new Array();
  let c = 0, f2 = 0;
  for (const r of e5.polygons) {
    const t5 = r.count, l = r.index, h4 = a2(e5.position, 3 * l, 3 * t5), g2 = r.holeIndices.map((n2) => n2 - l), a5 = t3(i(h4, g2, 3));
    s.push({ position: h4, faces: a5 }), c += h4.length, f2 += a5.length;
  }
  const a4 = h3(s, c, f2), p2 = Array.isArray(a4.position) ? e3(a4.position, 3, { originalIndices: a4.faces }) : e3(a4.position.buffer, 6, { originalIndices: a4.faces });
  return a4.position = e2(new Float64Array(p2.buffer)), a4.faces = p2.indices, a4;
}
function h3(n2, t4, e5) {
  if (1 === n2.length)
    return n2[0];
  const o2 = t2(t4), r = new Array(e5);
  let l = 0, c = 0, f2 = 0;
  for (const s of n2) {
    for (let n3 = 0; n3 < s.position.length; n3++)
      o2[l++] = s.position[n3];
    for (const n3 of s.faces)
      r[c++] = n3 + f2;
    f2 = l / 3;
  }
  return { position: o2, faces: t3(r) };
}
function g(n2, t4, e5, o2) {
  const r = n2.length, i2 = new Array(r), l = new Array(r), c = new Array(r);
  let f2 = 0, h4 = 0, g2 = 0, d2 = 0;
  for (let s = 0; s < r; ++s)
    d2 += n2[s].length;
  const m = t2(3 * d2);
  let y2 = 0;
  for (let s = r - 1; s >= 0; s--) {
    const d3 = n2[s], A3 = e5 === u.CCW_IS_HOLE && p(d3, t4, o2);
    if (A3 && 1 !== r)
      i2[f2++] = d3;
    else {
      let n3 = d3.length;
      for (let t5 = 0; t5 < f2; ++t5)
        n3 += i2[t5].length;
      const e6 = { index: y2, pathLengths: new Array(f2 + 1), count: n3, holeIndices: new Array(f2) };
      e6.pathLengths[0] = d3.length, d3.length > 0 && (c[g2++] = { index: y2, count: d3.length }), y2 = A3 ? a3(d3, d3.length - 1, -1, m, y2, d3.length, t4) : a3(d3, 0, 1, m, y2, d3.length, t4);
      for (let o3 = 0; o3 < f2; ++o3) {
        const n4 = i2[o3];
        e6.holeIndices[o3] = y2, e6.pathLengths[o3 + 1] = n4.length, n4.length > 0 && (c[g2++] = { index: y2, count: n4.length }), y2 = a3(n4, 0, 1, m, y2, n4.length, t4);
      }
      f2 = 0, e6.count > 0 && (l[h4++] = e6);
    }
  }
  for (let s = 0; s < f2; ++s) {
    const n3 = i2[s];
    n3.length > 0 && (c[g2++] = { index: y2, count: n3.length }), y2 = a3(n3, 0, 1, m, y2, n3.length, t4);
  }
  return l.length = h4, c.length = g2, { position: m, polygons: l, outlines: c };
}
function a3(n2, t4, e5, o2, r, s, i2) {
  r *= 3;
  for (let l = 0; l < s; ++l) {
    const s2 = n2[t4];
    o2[r++] = s2[0], o2[r++] = s2[1], o2[r++] = i2 ? s2[2] : 0, t4 += e5;
  }
  return r / 3;
}
function p(n2, o2, r) {
  if (o2) {
    const o3 = n2.length - 1, s = j2(n2, o3, r);
    if (s === n.X)
      return !a(n2, n.Y, n.Z);
    if (s === n.Y)
      return !a(n2, n.X, n.Z);
  }
  return !a(n2, n.X, n.Y);
}
var u;
!function(n2) {
  n2[n2.NONE = 0] = "NONE", n2[n2.CCW_IS_HOLE = 1] = "CCW_IS_HOLE";
}(u || (u = {}));

export {
  w2 as w,
  d,
  D,
  A2 as A,
  O,
  f,
  g,
  u
};
//# sourceMappingURL=chunk-DH7BG2VH.js.map
