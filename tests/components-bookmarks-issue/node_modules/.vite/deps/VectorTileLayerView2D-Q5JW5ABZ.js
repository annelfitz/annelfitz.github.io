import {
  t
} from "./chunk-WBRPZ7X2.js";
import {
  e as e6,
  h as h2,
  l as l2,
  n as n3,
  t as t2
} from "./chunk-HQRXH4OY.js";
import {
  d as d3,
  r as r3,
  s as s3
} from "./chunk-T7GGEMBH.js";
import {
  m as m2
} from "./chunk-UXMZQA2H.js";
import "./chunk-V2LOXBCS.js";
import {
  u as u3
} from "./chunk-NGAYW4TW.js";
import "./chunk-CTO5W2RR.js";
import {
  i as i2
} from "./chunk-2WUPZJUL.js";
import "./chunk-KN52PCW4.js";
import "./chunk-SFKZ25SS.js";
import "./chunk-NCZU5DB4.js";
import "./chunk-SMDSNUU2.js";
import "./chunk-XTY645DH.js";
import "./chunk-UIOX7MPV.js";
import {
  E as E3
} from "./chunk-HRDKP7QO.js";
import "./chunk-4UOHLZKX.js";
import "./chunk-VJ2I4VSQ.js";
import "./chunk-MCZ4QOSQ.js";
import "./chunk-6XTKBOD7.js";
import "./chunk-IUY6HBLC.js";
import "./chunk-BHOYA5LV.js";
import "./chunk-SCRCLNT5.js";
import {
  e as e5,
  s as s2
} from "./chunk-CHCT3UUA.js";
import {
  c,
  e as e4
} from "./chunk-7FQYGAVT.js";
import {
  L,
  l
} from "./chunk-2IACRN4O.js";
import "./chunk-T3YOCYDS.js";
import {
  E as E2,
  I as I2
} from "./chunk-QO4PGON2.js";
import {
  a as a4,
  i
} from "./chunk-QRQWG4D3.js";
import {
  m
} from "./chunk-5JXZHN2A.js";
import {
  s
} from "./chunk-KTQIY334.js";
import "./chunk-LGIO6OCK.js";
import "./chunk-C5EJV3NW.js";
import "./chunk-XXIDOBRO.js";
import "./chunk-JL4LXZGM.js";
import "./chunk-O556EBAK.js";
import "./chunk-IJD65EMQ.js";
import "./chunk-4YGBWYMD.js";
import "./chunk-TNR6E67I.js";
import "./chunk-QREUCRQ4.js";
import "./chunk-YK3UMVCY.js";
import {
  e as e3
} from "./chunk-IQFWVTUJ.js";
import "./chunk-GB4RVOXH.js";
import "./chunk-JTUYA5FE.js";
import "./chunk-UNTQATE2.js";
import "./chunk-5YY6NZNY.js";
import "./chunk-DCBZOZ54.js";
import "./chunk-5IT6RVBX.js";
import "./chunk-JCP47SOM.js";
import {
  d as d2
} from "./chunk-CXCB57TE.js";
import "./chunk-IWO6JXL2.js";
import "./chunk-AVR3LWTZ.js";
import "./chunk-FFG7BDAP.js";
import "./chunk-I4SHZ6P5.js";
import {
  r as r2
} from "./chunk-JBU54P54.js";
import {
  h
} from "./chunk-UQEUYEWU.js";
import "./chunk-5LIYYE75.js";
import {
  n as n2
} from "./chunk-252ISA6Z.js";
import "./chunk-TLTAGTBA.js";
import "./chunk-2QPP5AGU.js";
import "./chunk-2C26DRKK.js";
import "./chunk-M4RFJU4F.js";
import {
  I,
  O,
  R
} from "./chunk-WKVHVZW2.js";
import "./chunk-VIKID44H.js";
import "./chunk-3AIILHI5.js";
import "./chunk-7JR6S3WL.js";
import "./chunk-YH2IYJYF.js";
import "./chunk-GGHKH3LP.js";
import "./chunk-VS6AHHIY.js";
import "./chunk-XGTCDM4C.js";
import {
  e as e2
} from "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import {
  d,
  p
} from "./chunk-VEYMN5N3.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-HZSGATFT.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import {
  f
} from "./chunk-QYC3GV65.js";
import "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import {
  j
} from "./chunk-2SYXH2R7.js";
import "./chunk-7JNXJYRU.js";
import "./chunk-5JYVZQZR.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-QX66UTIR.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import {
  E,
  a as a3,
  u as u2
} from "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import {
  G
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a2,
  r2 as r
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  b
} from "./chunk-JGDJR5EV.js";
import {
  u
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  a,
  n2 as n
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileManager.js
var r4 = 512;
var n4 = 1e-6;
var a5 = (e7, i3) => e7 + 1 / (1 << 2 * i3);
var h3 = class {
  constructor(i3, t3) {
    this._tiles = /* @__PURE__ */ new Map(), this._tileCache = new e2(40, (e7) => e7.dispose()), this._viewSize = [0, 0], this._visibleTiles = /* @__PURE__ */ new Map(), this.acquireTile = i3.acquireTile, this.releaseTile = i3.releaseTile, this.tileInfoView = i3.tileInfoView, this._container = t3;
  }
  destroy() {
    for (const [e7, i3] of this._tiles)
      i3.dispose();
    this._tiles = null, this._tileCache.clear(), this._tileCache = null;
  }
  update(e7) {
    this._updateCacheSize(e7);
    const i3 = this.tileInfoView, t3 = i3.getTileCoverage(e7.state, 0, true, "smallest");
    if (!t3)
      return true;
    const { spans: l3, lodInfo: r5 } = t3, { level: n5 } = r5, a6 = this._tiles, h6 = /* @__PURE__ */ new Set(), c5 = /* @__PURE__ */ new Set();
    for (const { row: s4, colFrom: _2, colTo: f2 } of l3)
      for (let e8 = _2; e8 <= f2; e8++) {
        const i4 = e3.getId(n5, s4, r5.normalizeCol(e8), r5.getWorldForColumn(e8)), t4 = this._getOrAcquireTile(i4);
        h6.add(i4), t4.processed() ? this._addToContainer(t4) : c5.add(new e3(i4));
      }
    for (const [s4, o] of a6)
      o.isCoverage = h6.has(s4);
    for (const s4 of c5)
      this._findPlaceholdersForMissingTiles(s4, h6);
    let d6 = false;
    for (const [s4, o] of a6)
      o.neededForCoverage = h6.has(s4), o.neededForCoverage || o.isHoldingForFade && i3.intersects(t3, o.key) && h6.add(s4), o.isFading && (d6 = true);
    for (const [s4, o] of this._tiles)
      h6.has(s4) || this._releaseTile(s4);
    return s.pool.release(t3), !d6;
  }
  clear() {
    this._tiles.clear(), this._tileCache.clear(), this._visibleTiles.clear();
  }
  clearCache() {
    this._tileCache.clear();
  }
  getIntersectingTiles(e7, s4, o, r5, n5) {
    const a6 = [0, 0], h6 = [0, 0];
    r5.toMap(a6, e7 - o, s4 + o), r5.toMap(h6, e7 + o, s4 - o);
    const c5 = Math.min(a6[0], h6[0]), d6 = Math.min(a6[1], h6[1]), _2 = Math.max(a6[0], h6[0]), f2 = Math.max(a6[1], h6[1]), T = a3(c5, d6, _2, f2), p3 = u2(), u5 = [];
    for (const [i3, t3] of this._visibleTiles)
      this.tileInfoView.getTileBounds(p3, t3.key), E(T, p3) && u5.push(t3);
    if (null != n5 && n5.length > 0) {
      const e8 = new Set(u5.map((e9) => e9.id)), i3 = n5.filter((i4) => !e8.has(i4.tileKey.id)).map((e9) => this._visibleTiles.get(e9.tileKey.id)).filter((e9) => void 0 !== e9);
      u5.push(...i3);
    }
    return u5;
  }
  _findPlaceholdersForMissingTiles(e7, i3) {
    const t3 = [];
    for (const [s4, o] of this._tiles)
      this._addPlaceholderChild(t3, o, e7, i3);
    const l3 = t3.reduce(a5, 0);
    Math.abs(1 - l3) < n4 || this._addPlaceholderParent(e7.id, i3);
  }
  _addPlaceholderChild(e7, i3, t3, l3) {
    i3.key.level <= t3.level || !i3.hasData() || d4(t3, i3.key) && (this._addToContainer(i3), l3.add(i3.id), e7.push(i3.key.level - t3.level));
  }
  _addPlaceholderParent(e7, i3) {
    const t3 = this._tiles;
    let l3 = e7;
    for (; ; ) {
      if (l3 = c2(l3), !l3 || i3.has(l3))
        return;
      const e8 = t3.get(l3);
      if (e8 && e8.hasData())
        return this._addToContainer(e8), void i3.add(e8.id);
    }
  }
  _getOrAcquireTile(e7) {
    let i3 = this._tiles.get(e7);
    return i3 || (i3 = this._tileCache.pop(e7), i3 || (i3 = this.acquireTile(new e3(e7))), this._tiles.set(e7, i3), i3);
  }
  _releaseTile(e7) {
    const i3 = this._tiles.get(e7);
    this.releaseTile(i3), this._removeFromContainer(i3), this._tiles.delete(e7), i3.hasData() ? this._tileCache.put(e7, i3, 1) : i3.dispose();
  }
  _addToContainer(e7) {
    let i3;
    const t3 = [], l3 = this._container;
    if (l3.contains(e7))
      return;
    const s4 = this._visibleTiles;
    for (const [o, r5] of s4)
      this._canConnectDirectly(e7, r5) && t3.push(r5), null == i3 && this._canConnectDirectly(r5, e7) && (i3 = r5);
    if (null != i3) {
      for (const l4 of t3)
        i3.childrenTiles.delete(l4), e7.childrenTiles.add(l4), l4.parentTile = e7;
      i3.childrenTiles.add(e7), e7.parentTile = i3;
    } else
      for (const o of t3)
        e7.childrenTiles.add(o), o.parentTile = e7;
    s4.set(e7.id, e7), l3.addChild(e7);
  }
  _removeFromContainer(e7) {
    if (this._visibleTiles.delete(e7.id), this._container.removeChild(e7), null != e7.parentTile) {
      e7.parentTile.childrenTiles.delete(e7);
      for (const i3 of e7.childrenTiles)
        null != e7.parentTile && e7.parentTile.childrenTiles.add(i3);
    }
    for (const i3 of e7.childrenTiles)
      i3.parentTile = e7.parentTile;
    e7.parentTile = null, e7.childrenTiles.clear();
  }
  _canConnectDirectly(e7, i3) {
    const t3 = e7.key;
    let { level: l3, row: s4, col: o, world: r5 } = i3.key;
    const n5 = this._visibleTiles;
    for (; l3 > 0; ) {
      if (l3--, s4 >>= 1, o >>= 1, t3.level === l3 && t3.row === s4 && t3.col === o && t3.world === r5)
        return true;
      if (n5.has(`${l3}/${s4}/${o}/${r5}`))
        return false;
    }
    return false;
  }
  _updateCacheSize(e7) {
    const i3 = e7.state.size;
    if (i3[0] === this._viewSize[0] && i3[1] === this._viewSize[1])
      return;
    const t3 = Math.ceil(i3[0] / r4) + 1, l3 = Math.ceil(i3[1] / r4) + 1;
    this._viewSize[0] = i3[0], this._viewSize[1] = i3[1], this._tileCache.maxSize = 5 * t3 * l3;
  }
};
function c2(e7) {
  const [i3, t3, l3, s4] = e7.split("/"), o = parseInt(i3, 10);
  return 0 === o ? null : `${o - 1}/${parseInt(t3, 10) >> 1}/${parseInt(l3, 10) >> 1}/${parseInt(s4, 10)}`;
}
function d4(e7, i3) {
  const t3 = i3.level - e7.level;
  return e7.row === i3.row >> t3 && e7.col === i3.col >> t3 && e7.world === i3.world;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolFader.js
var c3 = 0.5;
var h4 = 1e-6;
var _ = class {
  constructor(e7, i3) {
    this.styleRepository = e7, this._tileToHandle = /* @__PURE__ */ new Map(), this._viewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._declutterViewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._offsetFromScreenCenter = [0, 0], this._completed = false, this._fading = r2(false), this._symbolRepository = new n3(4096, i3, () => new s3()), this._symbolDeclutterer = new e6(i3, this._symbolRepository, (t3, e8, i4) => this._createCollisionJob(t3, e8, i4), (t3, e8) => {
      t3.allSymbolsFadingOut = true, t3.lastOpacityUpdate = e8, r3(t3, e8, true), t3.decluttered = true, t3.requestRender();
    }, (t3, e8) => this.styleRepository.getStyleLayerByUID(t3.styleLayerUID).z - this.styleRepository.getStyleLayerByUID(e8.styleLayerUID).z, (t3) => {
      const e8 = this.styleRepository.getStyleLayerByUID(t3);
      if (this._zoom + h4 < e8.minzoom || this._zoom - h4 >= e8.maxzoom)
        return false;
      const i4 = e8.getLayoutProperty("visibility");
      return !i4 || i4.getValue() !== i.NONE;
    });
  }
  get symbolRepository() {
    return this._symbolRepository;
  }
  _createCollisionJob(t3, e7, i3) {
    return this.updateDecluttererViewState(), new l2(t3, e7, i3, this.styleRepository, this._zoom, this._viewState.rotation);
  }
  get fading() {
    return this._fading.value;
  }
  get decluttererOffset() {
    return this._offsetFromScreenCenter;
  }
  addTile(t3) {
    t3.decluttered = false, this._tileToHandle.set(t3, t3.on("symbols-changed", () => {
      this._symbolRepository.add(t3), this.restartDeclutter();
    })), this._symbolRepository.add(t3), this.restartDeclutter();
  }
  removeTile(t3) {
    const e7 = this._tileToHandle.get(t3);
    e7 && (this._symbolRepository.removeTile(t3), this.restartDeclutter(), e7.remove(), this._tileToHandle.delete(t3));
  }
  update(t3, e7) {
    this._zoom = t3, this._viewState = { scale: e7.scale, rotation: e7.rotation, center: [e7.center[0], e7.center[1]], size: [e7.size[0], e7.size[1]] };
    const i3 = [0, 0];
    e7.toScreen(i3, e7.center);
    const s4 = [0, 0];
    return e7.toScreen(s4, this._declutterViewState.center), this._offsetFromScreenCenter[0] = i3[0] - s4[0], this._offsetFromScreenCenter[1] = i3[1] - s4[1], this._continueDeclutter(), this._completed;
  }
  restartDeclutter() {
    this._completed = false, this._symbolDeclutterer.restart(), this._notifyUnstable();
  }
  clear() {
    this._completed = false, this._symbolRepository = null, this._symbolDeclutterer.restart(), this._tileToHandle.forEach((t3) => t3.remove()), this._tileToHandle.clear();
  }
  get stale() {
    return this._zoom !== this._declutterZoom || this._viewState.size[0] !== this._declutterViewState.size[0] || this._viewState.size[1] !== this._declutterViewState.size[1] || this._viewState.scale !== this._declutterViewState.scale || this._viewState.rotation !== this._declutterViewState.rotation;
  }
  deleteStyleLayers(t3) {
    this._symbolRepository.deleteStyleLayers(t3);
  }
  _continueDeclutter() {
    this._completed && !this.stale || (this._symbolDeclutterer.running || (this.updateDecluttererViewState(), this._symbolDeclutterer.restart()), this._symbolDeclutterer.setScreenSize(this._viewState.size[0], this._viewState.size[1]), this._completed = this._symbolDeclutterer.continue(c), this._completed && this._scheduleNotifyStable());
  }
  _scheduleNotifyStable() {
    null != this._stableNotificationHandle && clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = setTimeout(() => {
      this._stableNotificationHandle = null, this._fading.value = false;
    }, (1 + c3) * e4);
  }
  _notifyUnstable() {
    null != this._stableNotificationHandle && (clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = null), this._fading.value = true;
  }
  updateDecluttererViewState() {
    this._declutterZoom = this._zoom, this._declutterViewState.center[0] = this._viewState.center[0], this._declutterViewState.center[1] = this._viewState.center[1], this._declutterViewState.rotation = this._viewState.rotation, this._declutterViewState.scale = this._viewState.scale, this._declutterViewState.size[0] = this._viewState.size[0], this._declutterViewState.size[1] = this._viewState.size[1], this._offsetFromScreenCenter[0] = 0, this._offsetFromScreenCenter[1] = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileContainer.js
var y2 = 1e-6;
function p2(e7, t3) {
  if (e7) {
    const s4 = e7.getLayoutProperty("visibility");
    if (!s4 || s4.getValue() !== i.NONE && (void 0 === e7.minzoom || e7.minzoom < t3 + y2) && (void 0 === e7.maxzoom || e7.maxzoom >= t3 - y2))
      return true;
  }
  return false;
}
var m3 = class extends i2 {
  constructor(e7) {
    super(e7), this._backgroundTiles = [], this._computeDisplayInfoView(e7);
  }
  destroy() {
    var _a, _b;
    this.removeAllChildren(), (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = null, (_b = this._glyphMosaic) == null ? void 0 : _b.dispose(), this._glyphMosaic = null, null != this._symbolFader && (this._symbolFader.clear(), this._symbolFader = null), this._styleRepository = null, this._backgroundTiles = [];
  }
  get fading() {
    var _a;
    return ((_a = this._symbolFader) == null ? void 0 : _a.fading) ?? false;
  }
  get symbolFader() {
    return this._symbolFader;
  }
  get symbolRepository() {
    var _a;
    return (_a = this._symbolFader) == null ? void 0 : _a.symbolRepository;
  }
  setStyleResources(e7, t3, r5, i3) {
    this._spriteMosaic = e7, this._glyphMosaic = t3, this._styleRepository = r5, this._tileInfoView = i3, this._computeDisplayInfoView(i3), null == this._symbolFader && (this._symbolFader = new _(this._styleRepository, this.children)), this._symbolFader.styleRepository = r5;
  }
  setSpriteMosaic(e7) {
    var _a;
    (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = e7;
  }
  deleteStyleLayers(e7) {
    null != this._symbolFader && this._symbolFader.deleteStyleLayers(e7);
  }
  createRenderParams(e7) {
    return { ...super.createRenderParams(e7), renderPass: null, styleLayer: null, styleLayerUID: -1, glyphMosaic: this._glyphMosaic, spriteMosaic: this._spriteMosaic, hasClipping: !!this._clippingInfos };
  }
  doRender(e7) {
    !this.visible || e7.drawPhase !== E3.MAP && e7.drawPhase !== E3.DEBUG || void 0 === this._spriteMosaic || super.doRender(e7);
  }
  addChild(e7) {
    return super.addChild(e7), null != this._symbolFader ? this._symbolFader.addTile(e7) : e7.decluttered = true, this.requestRender(), e7;
  }
  removeChild(e7) {
    return null != this._symbolFader && this._symbolFader.removeTile(e7), this.requestRender(), super.removeChild(e7);
  }
  renderChildren(e7) {
    const { drawPhase: t3 } = e7;
    t3 !== E3.DEBUG ? this._doRender(e7) : super.renderChildren(e7);
  }
  removeAllChildren() {
    for (let e7 = 0; e7 < this.children.length; e7++) {
      const t3 = this.children[e7];
      null != this._symbolFader && this._symbolFader.removeTile(t3), t3.dispose();
    }
    super.removeAllChildren();
  }
  getStencilTarget() {
    return this.children.filter((e7) => e7.neededForCoverage && e7.hasData());
  }
  restartDeclutter() {
    null != this._symbolFader && this._symbolFader.restartDeclutter();
  }
  _doRender(e7) {
    const { context: t3, state: s4 } = e7, r5 = this._styleRepository;
    if (!r5)
      return;
    const i3 = r5.layers, o = this._displayInfo.scaleToZoom(s4.scale);
    r5.backgroundBucketIds.length > 0 && (e7.renderPass = "background", this._renderBackgroundLayers(e7, r5.backgroundBucketIds, o)), super.renderChildren(e7), e7.drawPhase === E3.MAP && this._fade(o, s4);
    const n5 = this.children.filter((e8) => e8.visible && e8.hasData());
    if (!n5 || 0 === n5.length)
      return t3.bindVAO(), t3.setStencilTestEnabled(true), void t3.setBlendingEnabled(true);
    for (const l3 of n5)
      l3.triangleCount = 0;
    t3.setStencilWriteMask(0), t3.setColorMask(true, true, true, true), t3.setStencilOp(I.KEEP, I.KEEP, I.REPLACE), t3.setStencilTestEnabled(true), t3.setBlendingEnabled(false), t3.setDepthTestEnabled(true), t3.setDepthWriteEnabled(true), t3.setDepthFunction(O.LEQUAL), t3.setClearDepth(1), t3.clear(t3.gl.DEPTH_BUFFER_BIT), e7.renderPass = "opaque";
    for (let l3 = i3.length - 1; l3 >= 0; l3--)
      this._renderStyleLayer(i3[l3], e7, n5);
    t3.setDepthWriteEnabled(false), t3.setBlendingEnabled(true), t3.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e7.renderPass = "translucent";
    for (let l3 = 0; l3 < i3.length; l3++)
      this._renderStyleLayer(i3[l3], e7, n5);
    t3.bindVAO(), t3.setStencilTestEnabled(true), t3.setBlendingEnabled(true);
    for (const l3 of n5)
      l3.debugInfo.display.triangleCount = l3.triangleCount;
  }
  _fade(e7, t3) {
    null != this._symbolFader && (this._symbolFader.update(e7, t3) || this.requestRender());
  }
  _renderStyleLayer(e7, t3, s4) {
    const { displayLevel: l3, painter: o, renderPass: n5 } = t3;
    if (void 0 === e7)
      return;
    const a6 = e7.getLayoutProperty("visibility");
    if (a6 && a6.getValue() === i.NONE)
      return;
    let d6;
    switch (e7.type) {
      case a4.BACKGROUND:
        return;
      case a4.FILL:
        if ("opaque" !== n5 && "translucent" !== t3.renderPass)
          return;
        d6 = "vtlFill";
        break;
      case a4.LINE:
        if ("translucent" !== n5)
          return;
        d6 = "vtlLine";
        break;
      case a4.CIRCLE:
        if ("translucent" !== n5)
          return;
        d6 = "vtlCircle";
        break;
      case a4.SYMBOL:
        if ("translucent" !== n5)
          return;
        d6 = "vtlSymbol";
    }
    if (s4 = e7.type === a4.SYMBOL ? s4.filter((e8) => e8.decluttered) : s4.filter((e8) => e8.neededForCoverage), "vtlSymbol" !== d6 && (0 === s4.length || void 0 !== e7.minzoom && e7.minzoom >= l3 + y2 || void 0 !== e7.maxzoom && e7.maxzoom < l3 - y2))
      return;
    const h6 = e7.uid;
    t3.styleLayerUID = h6, t3.styleLayer = e7;
    for (const r5 of s4)
      if (r5.layerData.has(h6)) {
        o.renderObjects(t3, s4, d6);
        break;
      }
  }
  _renderBackgroundLayers(t3, s4, r5) {
    const { context: l3, painter: n5, state: u5 } = t3, y4 = this._styleRepository;
    let m5 = false;
    for (const e7 of s4) {
      if (y4.getLayerById(e7).type === a4.BACKGROUND && p2(y4.getLayerById(e7), r5)) {
        m5 = true;
        break;
      }
    }
    if (!m5)
      return;
    const f2 = this._tileInfoView, g = f2.getTileCoverage(t3.state, 0, true, "smallest"), { spans: _2, lodInfo: b2 } = g, { level: E4 } = b2, C = u2(), F = [];
    if (this._renderPasses) {
      const e7 = this._renderPasses[0];
      null != this._clippingInfos && (e7.brushes[0].prepareState(t3), e7.brushes[0].drawMany(t3, this._clippingInfos));
    }
    const L2 = this._backgroundTiles;
    let R2, v = 0;
    for (const { row: i3, colFrom: a6, colTo: h6 } of _2)
      for (let t4 = a6; t4 <= h6; t4++) {
        if (v < L2.length)
          R2 = L2[v], R2.key.set(E4, i3, b2.normalizeCol(t4), b2.getWorldForColumn(t4)), f2.getTileBounds(C, R2.key, false), R2.x = C[0], R2.y = C[3], R2.resolution = f2.getTileResolution(E4);
        else {
          const s5 = new e3(E4, i3, b2.normalizeCol(t4), b2.getWorldForColumn(t4)), r6 = f2.getTileBounds(u2(), s5), l4 = f2.getTileResolution(E4);
          R2 = new t(s5, l4, r6[0], r6[3], 512, 512, 4096, 4096), L2.push(R2);
        }
        R2.setTransform(u5), F.push(R2), v++;
      }
    l3.setStencilWriteMask(0), l3.setColorMask(true, true, true, true), l3.setStencilOp(I.KEEP, I.KEEP, I.REPLACE), l3.setStencilFunction(O.EQUAL, 0, 255), l3.setStencilTestEnabled(true);
    for (const e7 of s4) {
      const s5 = y4.getLayerById(e7);
      s5.type === a4.BACKGROUND && p2(s5, r5) && (t3.styleLayerUID = s5.uid, t3.styleLayer = s5, n5.renderObjects(t3, F, "vtlBackground"));
    }
    s.pool.release(g);
  }
  _computeDisplayInfoView(e7) {
    let s4 = e7.tileInfo.lods[0].scale;
    const r5 = Math.max(25, e7.tileInfo.lods.length), i3 = [];
    for (let t3 = 0; t3 <= r5; t3++)
      i3.push(s4), s4 /= 2;
    this._displayInfo = j.create({ scales: i3, size: 512, spatialReference: e7.spatialReference, numLODs: r5 });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileFeatureIndex.js
var y3 = 8;
var c4 = 512;
var u4 = 4096;
var h5 = (e7, t3) => {
  const s4 = e7.vtlSymbol.sourceTile, r5 = t3.vtlSymbol.sourceTile;
  return s4.level !== r5.level ? s4.level - r5.level : s4.row !== r5.row ? s4.row - r5.row : s4.col !== r5.col ? s4.col - r5.col : e7.styleLayerUID - t3.styleLayerUID;
};
var d5 = class _d {
  constructor(e7, t3, s4, r5, i3) {
    this.tileKey = e7, this._index = null, this._styleRepository = null, this._tileHandler = null, this._tileKeyToPBF = /* @__PURE__ */ new Map(), this._tileLayerData = t3, this._styleRepository = s4, this._tileHandler = r5, this._parentLayer = i3;
  }
  static create(e7, t3, s4, r5, i3) {
    return new _d(e7, t3, s4, r5, i3);
  }
  clear() {
    var _a;
    (_a = this._index) == null ? void 0 : _a.clear(), this._tileKeyToPBF.clear();
  }
  async queryAttributes(e7, t3, s4, i3, l3) {
    if (0 === this._tileLayerData.size || !this._styleRepository || !this._tileHandler)
      return [];
    null === this._index && (this._index = new h(100, m4), await this._indexLayers());
    const o = [];
    return this._queryIndex(o, e7, t3, s4, this.tileKey.level, i3), l3 && (l3 == null ? void 0 : l3.length) > 0 && await this._getSymbolsAttributes(o, l3), o;
  }
  async _indexLayers() {
    const e7 = this.tileKey, t3 = this._styleRepository.layers, s4 = await this._getTilePayload(e7);
    for (const [r5, l3] of this._tileLayerData) {
      const o = t3[r5], n5 = s4.find((e8) => e8.sourceName === o.source);
      if (!n5)
        continue;
      const { protobuff: a6, key: y4 } = n5;
      if (l3.type !== E2.SYMBOL) {
        const t4 = 1 << e7.level - y4.level, s5 = e7.row - y4.row * t4, r6 = e7.col - y4.col * t4;
        this._indexLayer(o, a6, e7.level, t4, s5, r6);
      }
    }
  }
  _indexLayer(e7, t3, r5, i3, y4, h6) {
    const d6 = e7.sourceLayer, m5 = e7.getFeatureFilter(), f2 = r5, _2 = r5 + 1, p3 = d2(f2), g = new n2(new Uint8Array(t3), new DataView(t3));
    for (; g.next(); )
      switch (g.tag()) {
        case 3: {
          const t4 = g.getMessage(), s4 = new e5(t4);
          if (t4.release(), s4.name !== d6)
            continue;
          const o = s4.getData(), w2 = s4.extent / i3, x2 = w2 * h6 - p3, b2 = w2 * y4 - p3, I4 = x2 + w2 + 2 * p3, L2 = b2 + w2 + 2 * p3, v = w2 / c4, D2 = u4 / w2, T = w2 * h6, S2 = w2 * y4;
          for (; o.nextTag(2); ) {
            const t5 = o.getMessage(), i4 = new s2(t5, s4);
            if (t5.release(), m5 && !m5.filter(i4, r5))
              continue;
            const n5 = i4.values || {}, y5 = n5._minzoom, c5 = n5._maxzoom;
            if (y5 && y5 >= 10 * _2 || c5 && c5 <= 10 * f2)
              continue;
            const u5 = e7.getFeatureInflatedBounds(i4, f2, s4.extent, v);
            null == u5 || u5[0] > I4 || u5[1] > L2 || u5[2] < x2 || u5[3] < b2 || (u5[0] = (u5[0] - T) * D2, u5[1] = (u5[1] - S2) * D2, u5[2] = (u5[2] - T) * D2, u5[3] = (u5[3] - S2) * D2, this._index.insert(new L(e7, i4, u5, D2, T, S2)));
          }
          break;
        }
        default:
          g.skip();
      }
  }
  async _getSymbolsAttributes(e7, t3) {
    if (!t3 || 0 === t3.length)
      return e7;
    const s4 = [];
    t3.sort(h5);
    let r5 = t3[0].styleLayerUID, i3 = 0;
    for (let a6 = 0; a6 < t3.length; a6++)
      r5 !== t3[a6].styleLayerUID && (s4.push({ from: i3, to: a6, styleLayerUID: r5, sourceTileKey: t3[a6].vtlSymbol.sourceTile }), i3 = a6, r5 = t3[a6].styleLayerUID);
    s4.push({ from: i3, to: t3.length, styleLayerUID: r5, sourceTileKey: t3[t3.length - 1].vtlSymbol.sourceTile });
    const l3 = this._styleRepository.layers;
    let o, n5 = null;
    for (const a6 of s4) {
      const s5 = await this._getTilePayload(a6.sourceTileKey);
      o = l3[a6.styleLayerUID], n5 = !!o && s5.find((e8) => e8.sourceName === o.source), n5 && this._addSymbolsAttributes(e7, t3.slice(a6.from, a6.to).map((e8) => e8.vtlSymbol), r5, n5);
    }
    return e7;
  }
  _addSymbolsAttributes(t3, s4, r5, i3) {
    const l3 = this._styleRepository.layers, o = i3.key, n5 = this.tileKey, a6 = 1 << n5.level - o.level, y4 = n5.row - o.row * a6, c5 = n5.col - o.col * a6;
    this._getSymbolAttributes(i3.protobuff, s4, r5, a6, y4, c5).forEach((s5) => {
      const { attributes: i4, tilePoint: o2 } = s5;
      t3.push({ layerId: l3[r5].id, layerIndex: r5, graphic: new f({ attributes: i4, origin: { type: "vector-tile", layerId: l3[r5].id, layerIndex: r5, layer: this._parentLayer } }), tilePoint: o2 });
    });
  }
  _getSymbolAttributes(e7, t3, r5, i3, o, a6) {
    const y4 = [], c5 = this._styleRepository.layers;
    let h6 = 0;
    t3.sort((e8, t4) => e8.featureIndex - t4.featureIndex);
    const d6 = new n2(new Uint8Array(e7), new DataView(e7));
    for (; d6.next(); )
      switch (d6.tag()) {
        case 3: {
          const e8 = d6.getMessage(), s4 = new e5(e8);
          if (e8.release(), s4.name !== c5[r5].sourceLayer)
            continue;
          const m5 = s4.getData(), f2 = s4.extent / i3, _2 = u4 / f2, p3 = f2 * a6, g = f2 * o;
          let w2 = 0;
          for (; m5.nextTag(2); ) {
            const e9 = m5.getMessage();
            if (w2++ === t3[h6].featureIndex) {
              const t4 = new s2(e9, s4), r6 = t4.values, i4 = t4.getGeometry(), o2 = null != i4 ? [_2 * (i4[0][0].x - p3), _2 * (i4[0][0].y - g)] : null;
              y4.push({ attributes: r6, tilePoint: o2 }), h6++;
            }
            if (e9.release(), h6 === t3.length)
              return y4;
          }
          break;
        }
        default:
          d6.skip();
      }
    return y4;
  }
  _queryIndex(t3, s4, r5, i3, l3, o) {
    var _a;
    const n5 = y3 * i3 * (window.devicePixelRatio || 1);
    return (_a = this._index) == null ? void 0 : _a.search({ minX: s4 - n5, minY: r5 - n5, maxX: s4 + n5, maxY: r5 + n5 }, (n6) => {
      const { layer: a6, feature: y4 } = n6;
      a6.isIntersectingFeature(s4, r5, i3, y4, l3, o, n6) && t3.push({ layerId: a6.id, layerIndex: a6.uid, tilePoint: null, graphic: new f({ attributes: y4.values, origin: { type: "vector-tile", layerId: n6.layer.id, layerIndex: n6.layer.uid, layer: this._parentLayer } }) });
    }), t3;
  }
  async _getTilePayload(e7) {
    return r(this._tileKeyToPBF, e7.id, () => this._tileHandler.fetchTilePBFs(e7)).then((e8) => e8);
  }
};
var m4 = (e7) => ({ minX: e7.bounds[0], minY: e7.bounds[1], maxX: e7.bounds[2], maxY: e7.bounds[3] });

// node_modules/@arcgis/core/views/2d/layers/VectorTileLayerView2D.js
var w = 2;
var I3 = 8;
var D = 512;
var P = class extends m2(u3) {
  constructor() {
    super(...arguments), this._styleChanges = [], this._fetchQueue = null, this._parseQueue = null, this._tileHandlerPromise = null, this._isTileHandlerReady = false;
  }
  get fading() {
    var _a;
    return ((_a = this._vectorTileContainer) == null ? void 0 : _a.fading) ?? false;
  }
  async hitTest(e7, t3) {
    var _a, _b;
    const i3 = this._tileHandlerPromise, s4 = (_a = this._vectorTileContainer) == null ? void 0 : _a.symbolFader;
    if (!i3 || !this._isTileHandlerReady || !s4)
      return;
    await i3;
    let r5 = null;
    const a6 = (_b = this._vectorTileContainer) == null ? void 0 : _b.symbolRepository;
    a6 && (r5 = a6.querySymbols(t3, w, s4.decluttererOffset, {}));
    const l3 = this.view.state, n5 = this._tileManager.getIntersectingTiles(t3.x, t3.y, w, l3, r5);
    if ((!n5 || 0 === n5.length) && 0 === (r5 == null ? void 0 : r5.length))
      return null;
    e7 = e7.clone().normalize();
    const o = [], h6 = [];
    for (const y4 of n5)
      o.push(this._queryTile(h6, e7, w, this.view.state.rotation, y4, r5 == null ? void 0 : r5.filter((e8) => e8.tileKey.id === y4.id)));
    return await Promise.all(o), h6;
  }
  update(e7) {
    if (this._tileHandlerPromise && this._isTileHandlerReady)
      return e7.pixelRatio !== this._tileHandler.devicePixelRatio ? (this._start(), void (this._tileHandler.devicePixelRatio = e7.pixelRatio)) : void (this._styleChanges.length > 0 ? this._tileHandlerPromise = this._applyStyleChanges() : (this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.state = e7.state, this._parseQueue.state = e7.state, this._tileManager.update(e7) || this.requestUpdate(), this._parseQueue.resume(), this._fetchQueue.resume()));
  }
  attach() {
    const { style: e7 } = this.layer.currentStyleInfo;
    this._styleRepository = new l(e7), this._tileInfoView = new t2(this.layer.tileInfo, this.layer.fullExtent), this._vectorTileContainer = new m3(this._tileInfoView), this._tileHandler = new h2(this.layer, this._styleRepository, window.devicePixelRatio || 1, this.layer.tileInfo.lods.length - 1), this.container.addChild(this._vectorTileContainer), this._start(), this.addAttachHandles([this.layer.on("paint-change", (e8) => {
      var _a, _b;
      if (e8.isDataDriven)
        this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: e8 }), this.requestUpdate();
      else {
        const t3 = this._styleRepository, i3 = t3.getLayerById(e8.layer);
        if (!i3)
          return;
        const s4 = i3.type === a4.SYMBOL;
        t3.setPaintProperties(e8.layer, e8.paint), s4 && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), (_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender();
      }
    }), this.layer.on("layout-change", (e8) => {
      var _a, _b;
      const t3 = this._styleRepository, i3 = t3.getLayerById(e8.layer);
      if (!i3)
        return;
      const s4 = d(i3.layout, e8.layout);
      if (null != s4) {
        if (p(s4, "visibility") && 1 === S(s4))
          return t3.setLayoutProperties(e8.layer, e8.layout), i3.type === a4.SYMBOL && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), void ((_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender());
        this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: e8 }), this.requestUpdate();
      }
    }), this.layer.on("style-layer-visibility-change", (e8) => {
      var _a, _b;
      const t3 = this._styleRepository, i3 = t3.getLayerById(e8.layer);
      i3 && (t3.setStyleLayerVisibility(e8.layer, e8.visibility), i3.type === a4.SYMBOL && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), (_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender());
    }), this.layer.on("style-layer-change", (e8) => {
      this._styleChanges.push({ type: I2.LAYER_CHANGED, data: e8 }), this.requestUpdate();
    }), this.layer.on("delete-style-layer", (e8) => {
      this._styleChanges.push({ type: I2.LAYER_REMOVED, data: e8 }), this.requestUpdate();
    }), this.layer.on("load-style", () => this._loadStyle()), this.layer.on("spriteSource-change", (e8) => {
      this._styleChanges.push({ type: I2.SPRITES_CHANGED, data: e8 });
      const t3 = this._styleRepository.layers;
      for (const i3 of t3)
        switch (i3.type) {
          case a4.SYMBOL:
            i3.getLayoutProperty("icon-image") && this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: { layer: i3.id, layout: i3.layout } });
            break;
          case a4.LINE:
            i3.getPaintProperty("line-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i3.id, paint: i3.paint, isDataDriven: i3.isPainterDataDriven() } });
            break;
          case a4.FILL:
            i3.getLayoutProperty("fill-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i3.id, paint: i3.paint, isDataDriven: i3.isPainterDataDriven() } });
        }
      this.requestUpdate();
    })]);
  }
  detach() {
    this._stop(), this.container.removeAllChildren(), this._vectorTileContainer = u(this._vectorTileContainer), this._tileHandler = u(this._tileHandler);
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  supportsSpatialReference(e7) {
    var _a;
    return G((_a = this.layer.tileInfo) == null ? void 0 : _a.spatialReference, e7);
  }
  canResume() {
    let e7 = super.canResume();
    const { currentStyleInfo: t3 } = this.layer;
    if (e7 && (t3 == null ? void 0 : t3.layerDefinition)) {
      const i3 = this.view.scale, { minScale: s4, maxScale: r5 } = t3.layerDefinition;
      (t3 == null ? void 0 : t3.layerDefinition) && (s4 && s4 < i3 && (e7 = false), r5 && r5 > i3 && (e7 = false));
    }
    return e7;
  }
  isUpdating() {
    return this.fading;
  }
  acquireTile(e7) {
    const t3 = this._createVectorTile(e7);
    return this._updatingHandles.addPromise(this._fetchQueue.push(t3.key).then((e8) => this._parseQueue.push({ key: t3.key, data: e8 })).then((e8) => {
      t3.once("attach", () => this.requestUpdate()), t3.setData(e8), this.requestUpdate();
    }).catch((e8) => {
      b(e8) || n.getLogger(this).error(e8);
    })), t3;
  }
  releaseTile(e7) {
    const t3 = e7.key.id;
    this._fetchQueue.abort(t3), this._parseQueue.abort(t3), this.requestUpdate();
  }
  _start() {
    if (this._stop(), this._tileManager = new h3({ acquireTile: (e8) => this.acquireTile(e8), releaseTile: (e8) => this.releaseTile(e8), tileInfoView: this._tileInfoView }, this._vectorTileContainer), !this.layer.currentStyleInfo)
      return;
    const e7 = new AbortController(), t3 = this._tileHandler.start({ signal: e7.signal }).then(() => {
      this._fetchQueue = new m({ tileInfoView: this._tileInfoView, process: (e8, t4) => this._getTileData(e8, t4), concurrency: 15 }), this._parseQueue = new m({ tileInfoView: this._tileInfoView, process: (e8, t4) => this._parseTileData(e8, t4), concurrency: 8 }), this.requestUpdate(), this._isTileHandlerReady = true;
    });
    this._tileHandler.spriteMosaic.then((e8) => {
      this._vectorTileContainer.setStyleResources(e8, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this.requestUpdate();
    }), this._tileHandlerAbortController = e7, this._tileHandlerPromise = t3;
  }
  _stop() {
    if (!this._tileHandlerAbortController || !this._vectorTileContainer)
      return;
    const e7 = this._tileHandlerAbortController;
    e7 && e7.abort(), this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._fetchQueue = u(this._fetchQueue), this._parseQueue = u(this._parseQueue), this._tileManager = u(this._tileManager), this._vectorTileContainer.removeAllChildren();
  }
  async _getTileData(e7, t3) {
    return this._tileHandler.fetchTileData(e7, t3);
  }
  async _parseTileData(e7, t3) {
    return this._tileHandler.parseTileData(e7, t3);
  }
  async _applyStyleChanges() {
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this._tileManager.clearCache();
    const e7 = this._styleChanges;
    try {
      await this._tileHandler.updateStyle(e7);
    } catch (l3) {
      n.getLogger(this).error("error applying vector-tiles style update", l3.message), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true;
    }
    const t3 = this._styleRepository, s4 = /* @__PURE__ */ new Set();
    e7.forEach((e8) => {
      if (e8.type !== I2.LAYER_REMOVED)
        return;
      const i3 = e8.data, r6 = t3.getLayerById(i3.layer);
      r6 && s4.add(r6.uid);
    });
    const r5 = /* @__PURE__ */ new Set();
    e7.forEach((e8) => {
      let i3;
      switch (e8.type) {
        case I2.PAINTER_CHANGED:
          t3.setPaintProperties(e8.data.layer, e8.data.paint), i3 = e8.data.layer;
          break;
        case I2.LAYOUT_CHANGED:
          t3.setLayoutProperties(e8.data.layer, e8.data.layout), i3 = e8.data.layer;
          break;
        case I2.LAYER_REMOVED:
          return void t3.deleteStyleLayer(e8.data.layer);
        case I2.LAYER_CHANGED:
          t3.setStyleLayer(e8.data.layer, e8.data.index), i3 = e8.data.layer.id;
          break;
        case I2.SPRITES_CHANGED:
          this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(e8.data.spriteSource));
      }
      if (i3) {
        const e9 = t3.getLayerById(i3);
        e9 && r5.add(e9.uid);
      }
    });
    const a6 = this._vectorTileContainer.children;
    if (s4.size > 0) {
      const e8 = Array.from(s4);
      this._vectorTileContainer.deleteStyleLayers(e8);
      for (const t4 of a6)
        t4.deleteLayerData(e8);
    }
    if (this._fetchQueue.resume(), this._parseQueue.resume(), r5.size > 0) {
      const e8 = Array.from(r5), t4 = [];
      for (const i3 of a6) {
        const s5 = this._updatingHandles.addPromise(this._fetchQueue.push(i3.key).then((t5) => this._parseQueue.push({ key: i3.key, data: t5, styleLayerUIDs: e8 })).then((e9) => i3.setData(e9)));
        t4.push(s5);
      }
      await Promise.all(t4);
    }
    this._styleChanges = [], this._isTileHandlerReady = true, this.requestUpdate();
  }
  async _loadStyle() {
    const { style: e7 } = this.layer.currentStyleInfo, i3 = a(e7);
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this._styleRepository = new l(i3), this._vectorTileContainer.destroy(), this._tileManager.clear(), this._tileHandlerAbortController.abort(), this._tileHandlerAbortController = new AbortController();
    const { signal: s4 } = this._tileHandlerAbortController;
    try {
      this._tileHandlerPromise = this._tileHandler.setStyle(this._styleRepository, i3, this.layer.tileInfo.lods.length - 1), await this._tileHandlerPromise;
    } catch (n5) {
      if (!b(n5))
        throw n5;
    }
    if (s4.aborted)
      return this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, void this.requestUpdate();
    const a6 = await this._tileHandler.spriteMosaic, l3 = this._vectorTileContainer;
    this._tileInfoView = new t2(this.layer.tileInfo, this.layer.fullExtent), l3.setStyleResources(a6, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this._tileManager = new h3({ acquireTile: (e8) => this.acquireTile(e8), releaseTile: (e8) => this.releaseTile(e8), tileInfoView: this._tileInfoView }, this._vectorTileContainer), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, this.requestUpdate();
  }
  _createVectorTile(e7) {
    const t3 = this._tileInfoView.getTileBounds(u2(), e7), i3 = this._tileInfoView.getTileResolution(e7.level);
    return new d3(e7, i3, t3[0], t3[3], 512, 512, this._styleRepository);
  }
  async _queryTile(e7, t3, i3, s4, r5, a6) {
    if (0 === r5.layerData.size)
      return;
    const l3 = this._ensureTileIndex(r5), n5 = this._tileInfoView.getTileBounds(u2(), r5.key, true), o = I3 * D * ((t3.x - n5[0]) / (n5[2] - n5[0])), h6 = I3 * D * (1 - (t3.y - n5[1]) / (n5[3] - n5[1])), c5 = await l3.queryAttributes(o, h6, i3, s4, a6);
    for (const y4 of c5)
      y4.graphic.geometry = this._tileToMapPoint(y4.tilePoint, r5.transforms.tileUnitsToPixels), e7.push({ type: "graphic", layer: this.layer, graphic: y4.graphic, mapPoint: t3.clone() });
    e7.sort((e8, t4) => t4.graphic.origin.layerIndex - e8.graphic.origin.layerIndex);
  }
  _tileToMapPoint(e7, t3) {
    if (!e7)
      return null;
    const i3 = e7[0] * t3[0] + e7[1] * t3[3] + t3[6], s4 = e7[0] * t3[1] + e7[1] * t3[4] + t3[7], r5 = this.view.state, a6 = [0, 0];
    return r5.toMap(a6, [i3, s4]), new x({ x: a6[0], y: a6[1], spatialReference: r5.spatialReference });
  }
  _ensureTileIndex(e7) {
    let t3 = e7.featureIndex;
    return t3 || (t3 = d5.create(e7.key, e7.layerData, this._styleRepository, this._tileHandler, this.layer), e7.featureIndex = t3), t3;
  }
};
function S(e7) {
  if (null == e7)
    return 0;
  switch (e7.type) {
    case "partial":
      return Object.keys(e7.diff).length;
    case "complete":
      return Math.max(Object.keys(e7.oldValue).length, Object.keys(e7.newValue).length);
    case "collection":
      return Object.keys(e7.added).length + Object.keys(e7.changed).length + Object.keys(e7.removed).length;
  }
}
e([y()], P.prototype, "_isTileHandlerReady", void 0), P = e([a2("esri.views.2d.layers.VectorTileLayerView2D")], P);
var A = P;
export {
  A as default
};
//# sourceMappingURL=VectorTileLayerView2D-Q5JW5ABZ.js.map
