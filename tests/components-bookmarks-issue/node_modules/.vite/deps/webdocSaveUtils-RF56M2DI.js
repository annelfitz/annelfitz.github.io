import {
  n,
  p as p2
} from "./chunk-5T2QNVDA.js";
import {
  U,
  j,
  w as w3
} from "./chunk-YPY24RRU.js";
import "./chunk-O7RKI2QW.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-I2X6UR6L.js";
import {
  p
} from "./chunk-EDPA37RA.js";
import {
  i as i3
} from "./chunk-DORNK7ZC.js";
import {
  i as i2
} from "./chunk-OWKPWQPA.js";
import "./chunk-CQFVWMFK.js";
import "./chunk-HV2SFSJW.js";
import "./chunk-SBARCIDP.js";
import {
  r,
  t
} from "./chunk-VQWLJR3W.js";
import {
  m
} from "./chunk-ZAM62XN5.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import {
  o
} from "./chunk-RDPH36VD.js";
import {
  a,
  f as f2,
  i,
  s as s2
} from "./chunk-LBXFRGMS.js";
import {
  b
} from "./chunk-VTH4DAHQ.js";
import {
  L,
  w as w2
} from "./chunk-HLDUDRTD.js";
import {
  S
} from "./chunk-SLQA5YBV.js";
import {
  Q
} from "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-TPLOIZC7.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import {
  R
} from "./chunk-M5ZB5S5C.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  G
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-JCZIM4PO.js";
import {
  I,
  W
} from "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  w
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import "./chunk-NDIXNREV.js";
import "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/webdoc/support/webdocSaveUtils.js
var A = ["NatGeo_World_Map", "Ocean_Basemap", "USA_Topo_Maps", "World_Imagery", "World_Street_Map", "World_Terrain_Base", "World_Topo_Map", "World_Hillshade", "Canvas/World_Light_Gray_Base", "Canvas/World_Light_Gray_Reference", "Canvas/World_Dark_Gray_Base", "Canvas/World_Dark_Gray_Reference", "Ocean/World_Ocean_Base", "Ocean/World_Ocean_Reference", "Reference/World_Boundaries_and_Places", "Reference/World_Reference_Overlay", "Reference/World_Transportation"].map((e) => e.toLowerCase());
async function O(e, t2, a2) {
  a2 ?? (a2 = {}), T(e, t2), await w(() => !t2.updatingFromView), await t2.load(), await L2(t2), await r(t2), await D(e, t2);
  const o2 = t2.portalItem, i4 = o(o2, "web-map", true), n2 = t2.write({}, i4);
  return await Promise.all(i4.resources.pendingOperations), t(i4, { errorName: `${e.name}:save` }, a2), await V(t2, o2), await we(e, t2, o2, n2, i4), await Promise.all([t2.updateItemThumbnail(), p(t2.resourceReferences, i4)]), o2;
}
async function U2(e, t2, a2, o2) {
  o2 ?? (o2 = {});
  const i4 = E(e, a2);
  await w(() => !t2.updatingFromView), await t2.load(), C(e, t2), await L2(t2), await r(t2), await D(e, t2);
  const n2 = o(i4, "web-map", true), s3 = t2.write({}, n2);
  await Promise.all(n2.resources.pendingOperations), t(n2, { errorName: `${e.name}:save` }, o2), await Y(t2, i4);
  const l = t2.getThumbnailState();
  return await ye(e, t2, i4, s3, n2, o2) && (t2.resourceReferences.portalItem = i4), t2.restoreThumbnailFromState(l), await Promise.all([t2.updateItemThumbnail(), p(t2.resourceReferences, n2)]), i4;
}
function T(t2, r2) {
  if (!r2.portalItem)
    throw new s(`${t2.name}:portal-item-not-set`, "Portal item to save to has not been set on the WebMap");
  i3(r2.portalItem), M(t2, r2.portalItem);
}
function M(t2, r2) {
  if (r2.type !== t2.itemType)
    throw new s(`${t2.name}:portal-item-wrong-type`, `Portal item needs to have type "${t2.itemType}"`);
}
function C(t2, r2) {
  const a2 = r2.allLayers.filter((e) => {
    var _a;
    return "unsupported" === e.type && "KnowledgeGraphLayer" === ((_a = e.resourceInfo) == null ? void 0 : _a.layerType);
  });
  if (a2.length)
    throw new s(`${t2.name}:save-as-invalid-configuration`, `Failed to save a copy of ${t2.name} to prevent persisting invalid configuration. See 'details.layers'`, { layers: a2.toArray() });
}
async function D(t2, a2) {
  var _a;
  if (!((_a = a2.basemap) == null ? void 0 : _a.baseLayers.length))
    throw new s(`${t2.name}:save`, "Map does not have a valid basemap with a base layer.");
  let o2 = null;
  if (await w(() => {
    const e = U(a2.initialViewProperties, a2.basemap);
    return o2 = e.spatialReference, !e.updating;
  }), !G(o2, a2.initialViewProperties.spatialReference))
    throw new s(`${t2.name}:save`, "The spatial reference of the basemap is not compatible with the one from the map.", { expected: a2.initialViewProperties.spatialReference, actual: o2 });
}
function E(e, t2) {
  let r2 = S.from(t2);
  return r2.id && (r2 = r2.clone(), r2.id = null), r2.type || (r2.type = e.itemType), r2.portal || (r2.portal = Q.getDefault()), i3(r2), M(e, r2), r2;
}
function L2(e) {
  const t2 = [];
  return e.basemap && t2.push(e.basemap.load()), e.ground && t2.push(e.ground.load()), Promise.allSettled(t2).then(() => {
  });
}
async function V(e, t2) {
  t2.extent = await ce(e.portalItem, e.initialViewProperties.viewpoint.targetGeometry), await Z(e, t2);
}
var G2 = f2.JSAPI;
var $ = "CollectorDisabled";
var k = "Collector";
var B = "Data Editing";
var N = "OfflineDisabled";
var x = "Offline";
var K = "Workforce Project";
var F = "Workforce Worker";
var H = "Workforce Dispatcher";
var J = "Offline Map Areas";
var q = "FieldMapsDisabled";
var z = f2.DEVELOPER_BASEMAP;
var Q2 = "UtilityNetwork";
var X = "IPS";
async function Y(e, t2) {
  a(t2, $), a(t2, q), a(t2, f2.METADATA), a(t2, N), a(t2, J), a(t2, H), a(t2, K), a(t2, F), await V(e, t2);
}
async function Z(e, t2) {
  i(t2, G2), await ee(e), oe(e, t2), ie(e, t2), ne(e, t2), se(e, t2), le(e, t2), pe(e, t2), t2.typeKeywords && (t2.typeKeywords = t2.typeKeywords.filter((e2, t3, r2) => r2.indexOf(e2) === t3));
}
function ee(e) {
  const t2 = te(e).map((e2) => e2.load()).toArray();
  return Promise.allSettled(t2).then(() => {
  });
}
function te(e) {
  return e.allLayers.concat(e.allTables);
}
function re(e) {
  return te(e).some((e2) => e2.loaded && L(e2) && e2.capabilities.operations.supportsEditing && e2.editingEnabled && ("subtype-group" !== e2.type || e2.sublayers.some((e3) => e3.editingEnabled)));
}
function ae(e) {
  return te(e).filter((e2) => "group" !== e2.type).every((t2) => t2.loaded && fe(e, t2));
}
function oe(e, t2) {
  s2(t2, $) || s2(t2, K) || s2(t2, F) || s2(t2, H) || !re(e) ? a(t2, k) : i(t2, k);
}
function ie(e, t2) {
  re(e) ? i(t2, B) : a(t2, B);
}
function ne(e, t2) {
  !s2(t2, N) && ae(e) ? i(t2, x) : a(t2, x);
}
function se(e, t2) {
  w3(e.basemap) ? i(t2, z) : a(t2, z);
}
function le(e, t2) {
  var _a;
  ((_a = e.utilityNetworks) == null ? void 0 : _a.length) ? i(t2, Q2) : a(t2, Q2);
}
function pe(e, t2) {
  e.ipsInfo ? i(t2, X) : a(t2, X);
}
async function ce(e, t2) {
  const r2 = t2.clone().normalize();
  let a2;
  if (r2.length > 1)
    for (const o2 of r2)
      a2 ? o2.width > a2.width && (a2 = o2) : a2 = o2;
  else
    a2 = r2[0];
  return me(e, a2);
}
async function me(e, t2) {
  const r2 = t2.spatialReference;
  if (r2.isWGS84)
    return t2.clone();
  if (r2.isWebMercator)
    return R(t2);
  const { getGeometryServiceURL: a2 } = await import("./geometryServiceUtils-GBJDXKQL.js"), o2 = await a2(e), i4 = new p2({ geometries: [t2], outSpatialReference: f.WGS84 });
  return (await n(o2, i4))[0];
}
function ue(e) {
  return w2(e) || "map-notes" === e.type || "route" === e.type;
}
function fe(e, t2) {
  return L(t2) && t2.capabilities.operations.supportsSync || ue(t2) && !t2.portalItem || ("tile" === t2.type || "vector-tile" === t2.type) && (t2.capabilities.operations.supportsExportTiles || de(t2) || j(t2)) && t2.spatialReference.equals(e.initialViewProperties.spatialReference);
}
function de(e) {
  return "tile" === e.type && (b(e.url) && A.some((t2) => {
    var _a;
    return (_a = e.url) == null ? void 0 : _a.toLowerCase().includes("/" + t2 + "/");
  }));
}
async function we(e, t2, r2, a2, o2) {
  await r2.update({ data: a2 }), _e(e, t2, r2, a2, o2);
}
async function ye(t2, r2, a2, o2, i4, n2) {
  const s3 = r2.portalItem, l = { item: s3, authenticated: !(!(s3 == null ? void 0 : s3.id) || !s3.portal.user) }, p3 = a2.portal;
  await p3.signIn();
  const { copyAllowed: c, itemReloaded: m2 } = await ge(l, p3);
  if (l.authenticated || (l.authenticated = m2), !c)
    throw new s(`${t2.name}:save-as-copy-not-allowed`, "Owner of this map does not allow others to save a copy");
  const u = await he(a2, l, o2, n2);
  return r2.portalItem = a2, _e(t2, r2, a2, o2, i4), u;
}
async function ge(e, t2) {
  var _a;
  const { item: r2, authenticated: a2 } = e;
  return (r2 == null ? void 0 : r2.id) && ((_a = r2.typeKeywords) == null ? void 0 : _a.includes("useOnly")) ? r2.portal.portalHostname !== t2.portalHostname ? { copyAllowed: false, itemReloaded: false } : (a2 || await r2.reload(), { copyAllowed: "admin" === r2.itemControl || "update" === r2.itemControl, itemReloaded: true }) : { copyAllowed: true, itemReloaded: false };
}
async function he(e, t2, r2, o2) {
  var _a;
  const i4 = e.portal, { item: n2 } = t2, { folder: s3, copyAllResources: l } = o2;
  let p3 = false;
  if (l && (n2 == null ? void 0 : n2.id) && W(n2.portal.url, i4.url) && parseInt(n2.portal.currentVersion, 10) >= 2023) {
    const { total: e2 } = await n2.fetchResources();
    p3 = !!e2;
  }
  if (p3) {
    const t3 = await n2.copy({ copyResources: "all", folder: s3 });
    e.id = t3.id, e.portal = t3.portal;
    const a2 = e.toJSON();
    await e.load(), e.read(a2), await e.update({ data: r2 });
  } else
    await ((_a = i4.user) == null ? void 0 : _a.addItem({ item: e, folder: s3, data: r2 }));
  return p3;
}
function _e(e, r2, a2, n2, s3) {
  m.prototype.read.call(r2, { version: n2.version, authoringApp: n2.authoringApp, authoringAppVersion: n2.authoringAppVersion }, { origin: e.origin, ignoreDefaults: true, url: a2.itemUrl ? I(a2.itemUrl) : void 0 }), i2(s3), r2.resourceInfo = n2;
}
export {
  O as save,
  U2 as saveAs
};
//# sourceMappingURL=webdocSaveUtils-RF56M2DI.js.map
