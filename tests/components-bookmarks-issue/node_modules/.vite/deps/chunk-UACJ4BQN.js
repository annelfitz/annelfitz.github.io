import {
  i as i5,
  x as x3
} from "./chunk-ZZWM6CET.js";
import {
  m as m6,
  r as r8
} from "./chunk-5N67JZXF.js";
import {
  e as e11,
  ke,
  p as p3,
  s as s5,
  s2 as s6,
  u as u7,
  u2 as u8
} from "./chunk-UC6QLXCR.js";
import {
  i as i4,
  l3 as l5,
  r2 as r7
} from "./chunk-WS5XOTML.js";
import {
  R as R2,
  te
} from "./chunk-YYI7TRI3.js";
import {
  P as P2
} from "./chunk-VUHMQQ6M.js";
import {
  c as c6
} from "./chunk-6GQQIJM7.js";
import {
  a as a6
} from "./chunk-6OG4R2CR.js";
import {
  s as s7
} from "./chunk-XCK6RPVT.js";
import {
  l as l4
} from "./chunk-REXEABYB.js";
import {
  E as E3,
  I as I5,
  m as m5
} from "./chunk-QCUK7T7Y.js";
import {
  e as e10
} from "./chunk-2NDIVJST.js";
import {
  C as C2
} from "./chunk-PMFQ2A2V.js";
import {
  f as f3
} from "./chunk-F7X3QPMY.js";
import {
  t as t11
} from "./chunk-CMLG62TA.js";
import {
  t as t10,
  u as u6
} from "./chunk-BEXFYHUM.js";
import {
  a as a5
} from "./chunk-MDGE56IH.js";
import {
  n as n9
} from "./chunk-M5UX4IRZ.js";
import {
  i as i2
} from "./chunk-SI6AVZBW.js";
import {
  o as o7
} from "./chunk-I7LDU4W6.js";
import {
  o as o6
} from "./chunk-SCRCLNT5.js";
import {
  b as b4,
  d as d7
} from "./chunk-M6P775BS.js";
import {
  t as t9
} from "./chunk-KSBIR2KG.js";
import {
  c as c5
} from "./chunk-7A5N7G2Z.js";
import {
  r as r4,
  r2 as r5,
  t as t7
} from "./chunk-ZPC74XHC.js";
import {
  A as A2
} from "./chunk-IVGJRGD2.js";
import {
  t as t6
} from "./chunk-MTLWPXQD.js";
import {
  r as r6
} from "./chunk-JBF6CULO.js";
import {
  c2 as c4,
  u2 as u5
} from "./chunk-3DFMDDMO.js";
import {
  t as t8
} from "./chunk-4BCSYJOQ.js";
import {
  O as O3
} from "./chunk-GMUCR2DJ.js";
import {
  S as S2,
  _ as _3,
  s as s4
} from "./chunk-MEEG7XMI.js";
import {
  J as J2
} from "./chunk-54XXLVAD.js";
import {
  x as x2
} from "./chunk-IJD65EMQ.js";
import {
  e2 as e9,
  m as m4
} from "./chunk-JTUYA5FE.js";
import {
  i as i3
} from "./chunk-UNTQATE2.js";
import {
  s as s3
} from "./chunk-5IT6RVBX.js";
import {
  H
} from "./chunk-YJFPDMSR.js";
import {
  h as h3
} from "./chunk-I4SHZ6P5.js";
import {
  m as m3
} from "./chunk-PGOAFABD.js";
import {
  $
} from "./chunk-BNDDKY53.js";
import {
  F,
  I as I3,
  o as o5
} from "./chunk-QYDOVVH7.js";
import {
  r as r3
} from "./chunk-JBU54P54.js";
import {
  I as I4,
  M,
  Z as Z2,
  k as k2
} from "./chunk-IWZSAF74.js";
import {
  h as h4
} from "./chunk-FMS3CZY7.js";
import {
  O
} from "./chunk-TLTAGTBA.js";
import {
  t as t3
} from "./chunk-2C26DRKK.js";
import {
  e as e5
} from "./chunk-M4RFJU4F.js";
import {
  D,
  E as E2,
  G,
  R,
  T,
  U as U2,
  _ as _2
} from "./chunk-WKVHVZW2.js";
import {
  I as I2
} from "./chunk-KSZESDGM.js";
import {
  e as e8
} from "./chunk-33LWZO2E.js";
import {
  l as l3
} from "./chunk-WEER6QME.js";
import {
  t as t5
} from "./chunk-TXLJQAAN.js";
import {
  b as b3,
  o as o4
} from "./chunk-3AIILHI5.js";
import {
  o as o3
} from "./chunk-CDBOQCLE.js";
import {
  n as n8
} from "./chunk-P4MNTMCZ.js";
import {
  l as l2
} from "./chunk-WZJNHZ6H.js";
import {
  d as d5
} from "./chunk-DRC4XSYG.js";
import {
  Z
} from "./chunk-QNG4TY7L.js";
import {
  e as e6
} from "./chunk-Q6RZBEZ6.js";
import {
  d as d4
} from "./chunk-VEYMN5N3.js";
import {
  a as a4,
  b as b2,
  m as m2
} from "./chunk-W5ALAOW2.js";
import {
  f as f2
} from "./chunk-IYKBAIQE.js";
import {
  c as c3
} from "./chunk-LQBHIBXV.js";
import {
  t as t4
} from "./chunk-42DUJ2CX.js";
import {
  e as e7
} from "./chunk-GLF3KRAL.js";
import {
  n as n7
} from "./chunk-ZLQTPFTL.js";
import {
  d as d6
} from "./chunk-F3BQGS35.js";
import {
  n as n6
} from "./chunk-SCHTG6ZQ.js";
import {
  f
} from "./chunk-QYC3GV65.js";
import {
  d3,
  h,
  h2,
  p2,
  w2 as w4,
  z
} from "./chunk-ZIJHDTB7.js";
import {
  pe
} from "./chunk-X7VSXJWW.js";
import {
  o as o2
} from "./chunk-PJNK3TLV.js";
import {
  u as u4
} from "./chunk-BOAEEYBE.js";
import {
  w as w3
} from "./chunk-VTH4DAHQ.js";
import {
  O as O2
} from "./chunk-HLDUDRTD.js";
import {
  j
} from "./chunk-HV6S3GY2.js";
import {
  E,
  I,
  J,
  U,
  c as c2,
  e as e4,
  i,
  m,
  o,
  u as u3
} from "./chunk-C7NPPGFR.js";
import {
  n as n5
} from "./chunk-OIJCMME5.js";
import {
  n as n4
} from "./chunk-Z2PDA67N.js";
import {
  w as w2
} from "./chunk-IZKCZQUY.js";
import {
  g,
  x
} from "./chunk-M5ZB5S5C.js";
import {
  A,
  C,
  P,
  d as d2,
  p,
  v as v2,
  w
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  _,
  d
} from "./chunk-BVQWKK2V.js";
import {
  S,
  v,
  y2
} from "./chunk-NDIXNREV.js";
import {
  a3,
  n as n3,
  r2
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  a as a2,
  b,
  e as e3,
  s as s2,
  u2,
  y
} from "./chunk-JGDJR5EV.js";
import {
  e as e2,
  l,
  r,
  t as t2,
  u
} from "./chunk-QHK5ZYFW.js";
import {
  a,
  n2,
  s
} from "./chunk-7RBRCL6S.js";
import {
  L,
  c2 as c,
  has,
  k,
  n,
  t3 as t
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/QueryEngine.js
var c7 = $;
var l6 = class extends S {
  get layer() {
    return this.context.layer;
  }
  get spatialReference() {
    return this.context.spatialReference;
  }
  get _queryGeometryType() {
    switch (this.layer.geometryType) {
      case "multipoint":
      case "point":
      case "polygon":
      case "polyline":
        return this.layer.geometryType;
      case "mesh":
        return "polygon";
      default:
        return;
    }
  }
  get defaultQueryJSON() {
    return new b2({ outSpatialReference: this.spatialReference }).toJSON();
  }
  get _dataQueryEngine() {
    return this._ensureDataQueryEngine();
  }
  constructor(e12) {
    super(e12), this._dataQueryEngineInstance = null;
  }
  destroy() {
    this.clear();
  }
  clear() {
    return !!this._dataQueryEngineInstance && (this._dataQueryEngineInstance.destroy(), this._dataQueryEngineInstance = null, true);
  }
  async executeQueryForIdSet(e12, t13, r10) {
    return this._dataQueryEngine.executeQueryForIdSet(this._ensureQueryJSON(e12, t13), r10);
  }
  async executeQueryForCount(e12, t13) {
    return this._dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(e12), t13);
  }
  async executeQueryForExtent(e12, t13) {
    const { count: r10, extent: s9 } = await this._dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(e12), t13);
    return { count: r10, extent: w2.fromJSON(s9) };
  }
  async executeQueryForIds(e12, t13) {
    return this._dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(e12), t13);
  }
  async executeQueryForLatestObservations(e12, t13) {
    const r10 = await this._dataQueryEngine.executeQueryForLatestObservations(this._ensureQueryJSON(e12), t13), s9 = d6.fromJSON(r10);
    return s9.features.forEach((e13) => {
      e13.layer = this.layer, e13.sourceLayer = this.layer;
    }), s9;
  }
  async executeQuery(e12, t13) {
    const r10 = await this._dataQueryEngine.executeQuery(this._ensureQueryJSON(e12), t13), s9 = d6.fromJSON(r10);
    return s9.features.forEach((e13) => {
      e13.layer = this.layer, e13.sourceLayer = this.layer;
    }), s9;
  }
  _ensureQueryJSON(e12, t13) {
    let r10 = this.defaultQueryJSON;
    if (null != e12 && ("outSpatialReference" in e12 && !e12.outSpatialReference && (e12.outSpatialReference = this.spatialReference), r10 = e12.toJSON()), null != t13) {
      const e13 = t13.geometries.map((e14) => e14.toJSON()).reduce((e14, t14) => (e14.rings = e14.rings.concat(t14.rings), e14));
      r10 = { ...r10, sceneFilter: { ...t13, geometry: e13 } };
    }
    return r10;
  }
  _ensureDataQueryEngine() {
    var _a, _b;
    if (this._dataQueryEngineInstance)
      return this._dataQueryEngineInstance;
    const e12 = "timeInfo" in this.layer && ((_a = this.layer.timeInfo) == null ? void 0 : _a.toJSON()) || null, t13 = this.layer.objectIdField, r10 = o2.toJSON(this._queryGeometryType), s9 = ((_b = this.layer.fieldsIndex) == null ? void 0 : _b.toJSON()) || new Z([]), n11 = this.priority, o9 = this.spatialReference.toJSON(), { hasZ: u9, hasM: i7, featureStore: l7, scheduler: p4 } = this.context;
    return this._dataQueryEngineInstance = new c7({ hasZ: u9, hasM: i7, geometryType: r10, fieldsIndex: s9, timeInfo: e12, spatialReference: o9, objectIdField: t13, featureStore: l7, scheduler: p4, priority: n11 }), this._dataQueryEngineInstance;
  }
};
e([y2({ constructOnly: true })], l6.prototype, "context", void 0), e([y2({ constructOnly: true })], l6.prototype, "priority", void 0), e([y2()], l6.prototype, "layer", null), e([y2()], l6.prototype, "spatialReference", null), e([y2()], l6.prototype, "_queryGeometryType", null), e([y2()], l6.prototype, "defaultQueryJSON", null), l6 = e([a3("esri.views.3d.layers.graphics.QueryEngine")], l6);

// node_modules/@arcgis/core/views/3d/layers/support/attributeUtils.js
function n10(n11, t13, e12) {
  if (!e12 || null == t13)
    return null;
  if (!n11)
    return r9(t13, e12);
  const o9 = n11.get(e12);
  return o9 ? t13[o9.name] : null;
}
function r9(n11, r10) {
  const t13 = r10.toLowerCase();
  for (const e12 in n11)
    if (e12.toLowerCase() === t13)
      return n11[e12];
  return null;
}

// node_modules/@arcgis/core/views/3d/layers/support/FeatureVisibilityFilter.js
var f4 = class extends S {
  constructor(e12) {
    super(e12), this._updateTask = null, this._frameTask = null, this._queryEngine = null, this._updateRequested = true, this._updatingHandles = new h3(), this._updateVisibility = async (e13) => {
      if (null == this._compositedFeatureFilter && null == this._sceneFilter || 0 === this.context.getFeatureCount())
        return this._frameTask.schedule(() => this.clear(), e13);
      try {
        const t13 = await this._queryEngine.executeQueryForIdSet(this._compositedFeatureFilter, this._sceneFilter, e13);
        return this._frameTask.schedule(() => {
          this.context.updateFeatureVisibilities((e14) => t13.has(e14));
        }, e13);
      } catch (t13) {
        return a2(t13), n2.getLogger(this).warn(`FeatureFilter query failed: ${t13}`, { error: t13 }), this._frameTask.schedule(() => {
          this.context.setAllFeaturesVisibility(true);
        }, e13);
      }
    };
  }
  initialize() {
    const e12 = I3.FILTER_VISIBILITY, { layer: t13, view: r10 } = this._layerView, { featureStore: i7 } = this.context, s9 = "hasZ" in this._layerView && this._layerView.hasZ, l7 = "hasM" in this._layerView && this._layerView.hasM;
    this._queryEngine = new l6({ context: { spatialReference: r10.spatialReference, layer: t13, scheduler: r10.resourceController.scheduler, featureStore: i7, hasM: l7, hasZ: s9 }, priority: e12 }), this._frameTask = this._layerView.view.resourceController.scheduler.registerTask(e12, this), this._updatingHandles.add(() => [this._compositedFeatureFilter, this._sceneFilter], () => this.reapply(), P);
  }
  destroy() {
    this._updateRequested = false, this._updatingHandles.destroy(), this.clear(), this._updateTask = e2(this._updateTask), this._frameTask = l(this._frameTask), this._queryEngine = u(this._queryEngine), this._set("context", null);
  }
  get updating() {
    return this.running || this._updatingHandles.updating || null != this._updateTask && !this._updateTask.finished;
  }
  get running() {
    return this._updateRequested || this._frameTask.updating;
  }
  get defaultVisibility() {
    return null == this._compositedFeatureFilter && null == this._sceneFilter;
  }
  get _featureFilter() {
    return "filter" in this._layerView ? this._layerView.filter : null;
  }
  get _sceneFilter() {
    return "layerFilter" in this._layerView ? this._layerView.layerFilter : null;
  }
  get _floorFilter() {
    return o7(this._layerView);
  }
  get _timeExtent() {
    return "timeExtent" in this._layerView ? this._layerView.timeExtent : null;
  }
  get _compositedFeatureFilter() {
    const { _featureFilter: e12, _timeExtent: t13, _floorFilter: r10 } = this;
    if (null == t13 && null == r10)
      return e12;
    const i7 = null != e12 ? e12.clone() : new d5();
    if (null != t13 && (i7.timeExtent = null != i7.timeExtent ? i7.timeExtent.intersection(t13) : t13), null != r10) {
      const e13 = null == i7.where || "" === i7.where;
      i7.where = e13 ? r10 : `(${i7.where}) AND (${r10})`;
    }
    return i7;
  }
  get _layerView() {
    return this.context.layerView;
  }
  reapply() {
    this._updateRequested = true;
  }
  clear() {
    this._queryEngine.clear(), this.context.clearFeaturesVisibility();
  }
  runTask(e12) {
    if (this._updateRequested && (this._updateTask = e2(this._updateTask), this._updateTask = d(this._updateVisibility), this._updateRequested = false, e12.madeProgress()), this._frameTask.processQueue(e12), !e12.hasProgressed)
      return o5;
  }
};
e([y2({ constructOnly: true })], f4.prototype, "context", void 0), e([y2()], f4.prototype, "updating", null), e([y2()], f4.prototype, "running", null), e([y2()], f4.prototype, "defaultVisibility", null), e([y2()], f4.prototype, "_featureFilter", null), e([y2()], f4.prototype, "_sceneFilter", null), e([y2()], f4.prototype, "_floorFilter", null), e([y2()], f4.prototype, "_timeExtent", null), e([y2()], f4.prototype, "_compositedFeatureFilter", null), e([y2()], f4.prototype, "_layerView", null), e([y2()], f4.prototype, "_updateTask", void 0), e([y2()], f4.prototype, "_updateRequested", void 0), f4 = e([a3("esri.views.3d.layers.support.FeatureVisibilityFilter")], f4);

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DFeatureProcessor.js
var P3 = class extends S {
  constructor(e12) {
    super(e12), this.type = "graphics-3d", this._randomRotationRenderers = null, this._updatingHandles = new h3(), this.elevationFeatureExpressionEnabled = false, this.scaleVisibilityEnabled = false, this.filterVisibilityEnabled = false, this.frustumVisibilityEnabled = false, this.elevationAlignmentEnabled = false, this.timeExtentEnabled = false, this.setUidToIdOnAdd = true, this.dataExtent = null, this.drapeSourceType = e10.Features, this.preferredUpdatePolicy = C2.ASYNC, this._suspendResumeExtent = null;
  }
  initialize() {
    const e12 = this.owner, t13 = (this.filterVisibilityEnabled || this.timeExtentEnabled) && "multipatch" !== e12.layer.geometryType, i7 = new ke({ owner: this, layer: this.layer, preferredUpdatePolicy: this.preferredUpdatePolicy, elevationFeatureExpressionEnabled: this.elevationFeatureExpressionEnabled, graphicSymbolSupported: false, hasZ: e12.hasZ, hasM: e12.hasM, setUidToIdOnAdd: this.setUidToIdOnAdd, componentFactories: { deconflictor: (t14) => e12.view.deconflictor.addGraphicsOwner(t14), labeler: (t14, i8) => e12.view.labeler.addGraphicsOwner(t14, i8), elevationAlignment: this.elevationAlignmentEnabled ? (t14, i8) => new p3({ graphicsCoreOwner: this, graphicsCore: t14, queryGraphicUIDsInExtent: i8, elevationProvider: e12.view.elevationProvider }) : null, scaleVisibility: this.scaleVisibilityEnabled ? (t14, i8) => new u7({ graphicsCoreOwner: this, layer: this.layer, queryGraphicUIDsInExtent: i8, graphicsCore: t14, basemapTerrain: e12.view.basemapTerrain }) : null, filterVisibility: t13 ? (t14) => new f4({ context: { layerView: e12, ...t14 } }) : null, objectStates: (e13) => new s6(e13) } });
    this._set("graphicsCore", i7), this.frustumVisibilityEnabled && this._set("frustumVisibility", new u8({ graphicsCoreOwner: this })), this.elevationAlignment && this._updatingHandles.add(() => this.layer.elevationInfo, (e13, t14) => {
      d4(e13, t14) && this._updatingHandles.addPromise(this.graphicsCore.elevationInfoChange());
    }), this._updatingHandles.add(() => this.layer.labelsVisible, () => this.graphicsCore.updateVisibilityInfo()), this._updatingHandles.add(() => this.layer.labelingInfo, (e13, t14) => {
      d4(e13, t14) && this.graphicsCore.updateLabelingInfo();
    }), this._updatingHandles.add(() => this.preferredUpdatePolicy, (e13) => this.graphicsCore.preferredUpdatePolicy = e13), this._set("initializePromise", this._initializeAsync()), this._updatingHandles.addPromise(this.initializePromise);
  }
  async _initializeAsync() {
    await y(this.graphicsCore.initializePromise);
    const e12 = this.owner;
    this._updatingHandles.add(() => this.renderer, (e13) => this._updatingHandles.addPromise(this.graphicsCore.rendererChange(e13))), this._updatingHandles.add(() => e12.fullOpacity, () => this.graphicsCore.opacityChange()), this._setupSuspendResumeExtent(), this.updateClippingExtent && (this._updatingHandles.add(() => e12.view.clippingArea, () => this._updateClippingExtent()), this._updateClippingExtent()), this.graphicsCore.startCreateGraphics(), this.graphicsCore.labelsEnabled && await y(this.graphicsCore.updateLabelingInfo());
  }
  destroy() {
    this._updatingHandles.destroy(), this._set("frustumVisibility", u(this.frustumVisibility)), this._set("graphicsCore", u(this.graphicsCore)), this._set("owner", null);
  }
  get layer() {
    return this.owner.layer;
  }
  get dataUpdating() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.dataUpdating) ?? false;
  }
  get renderer() {
    const { renderer: e12, objectIdField: t13 } = this.layer;
    if (!e12 || !t13 || "heatmap" === e12.type || !e12.visualVariables)
      return e12;
    const i7 = e12.visualVariables.findIndex((e13) => "rotation" === e13.type && null != e13.valueExpression && e6(e13.valueExpression) === t13 && (null == e13.axis || "heading" === e13.axis) && "geographic" === e13.rotationType);
    if (i7 < 0)
      return e12;
    const r10 = e12.clone();
    return r10.visualVariables.splice(i7, 1), this._randomRotationRenderers || (this._randomRotationRenderers = /* @__PURE__ */ new WeakMap()), this._randomRotationRenderers.set(r10, t13), r10;
  }
  get scaleVisibility() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.scaleVisibility;
  }
  get filterVisibility() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.filterVisibility;
  }
  get elevationAlignment() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.elevationAlignment;
  }
  get suspendResumeExtentMode() {
    return "suspendResumeExtentMode" in this.owner ? this.owner.suspendResumeExtentMode : "computed";
  }
  get scaleVisibilitySuspended() {
    return null != this.scaleVisibility && this.scaleVisibility.suspended;
  }
  get suspended() {
    return this.owner.suspended;
  }
  get legendEnabled() {
    return null == this.frustumVisibility || !this.frustumVisibility.suspended;
  }
  get suspendInfo() {
    const e12 = {};
    return this.scaleVisibilitySuspended && (e12.outsideScaleRange = true), null != this.frustumVisibility && this.frustumVisibility.suspended && (e12.outsideOfView = true), e12;
  }
  get updating() {
    var _a, _b;
    return !!(((_a = this.graphicsCore) == null ? void 0 : _a.updating) || ((_b = this.frustumVisibility) == null ? void 0 : _b.updating) || this._updatingHandles.updating);
  }
  get updatingRemaining() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.updatingRemaining) ?? 0;
  }
  get featureStore() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.featureStore;
  }
  get view() {
    return this.owner.view;
  }
  get loadedGraphics() {
    return this.owner.loadedGraphics;
  }
  get fullOpacity() {
    var _a;
    return (_a = this.owner) == null ? void 0 : _a.fullOpacity;
  }
  get filter() {
    return "filter" in this.owner ? this.owner.filter : null;
  }
  get slicePlaneEnabled() {
    return this.owner.slicePlaneEnabled;
  }
  get updatePolicy() {
    return this.owner.updatePolicy;
  }
  get featureSpatialReference() {
    return "featureSpatialReference" in this.owner ? this.owner.featureSpatialReference : this.owner.view.spatialReference;
  }
  get graphics3DGraphics() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.graphics3DGraphics;
  }
  get graphics3DGraphicsByObjectID() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.graphics3DGraphicsByObjectID;
  }
  get symbolUpdateType() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.symbolUpdateType;
  }
  get displayFeatureLimit() {
    var _a;
    const e12 = this.view.quality, t13 = (_a = this.graphicsCore) == null ? void 0 : _a.displayFeatureLimit;
    if (1 === e12)
      return t13;
    const i7 = Math.ceil(t13.maximumNumberOfFeatures * e12);
    return new e11(t13.maximumTotalNumberOfVertices, i7, t13.averageSymbolComplexity);
  }
  get usedMemory() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.usedMemory) ?? 0;
  }
  get loadedFeatures() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.numberOfGraphics) ?? 0;
  }
  get usedMemoryPerFeature() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.usedMemoryPerGraphic) ?? 0;
  }
  get unprocessedMemoryEstimate() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.unprocessedMemoryEstimate) ?? 0;
  }
  get performanceInfo() {
    return this.graphicsCore.performanceInfo;
  }
  maskOccludee(e12) {
    var _a;
    const t13 = (_a = this.graphicsCore) == null ? void 0 : _a.objectStates;
    if (!t13)
      return e3();
    const { set: i7, handle: r10 } = t13.acquireSet(t5.MaskOccludee, null);
    return t13.setUid(i7, e12.uid), r10;
  }
  highlight(e12, i7) {
    var _a;
    const r10 = (_a = this.graphicsCore) == null ? void 0 : _a.objectStates;
    if (!r10)
      return e3();
    if (e12 instanceof b2) {
      const { set: t13, handle: s9 } = r10.acquireSet(t5.Highlight, i7);
      return this.owner.queryObjectIds(e12).then((e13) => r10.setObjectIds(t13, e13)), s9;
    }
    if ("number" == typeof e12 || "string" == typeof e12)
      return this.highlight([e12], i7);
    if (e12 instanceof f)
      return this.highlight([e12], i7);
    if ("toArray" in e12 && (e12 = e12.toArray()), Array.isArray(e12) && e12.length > 0) {
      if (e12[0] instanceof f) {
        const t13 = e12;
        if (null == n10(this.layer.fieldsIndex, t13[0].attributes, i7)) {
          const e13 = t13.map((e14) => e14.uid), { set: i8, handle: s9 } = r10.acquireSet(t5.Highlight, null);
          return r10.setUids(i8, e13), s9;
        }
        e12 = t13.map((e13) => n10(this.layer.fieldsIndex, e13.attributes, i7));
      }
      if (Array.isArray(e12) && ("number" == typeof e12[0] || "string" == typeof e12[0])) {
        const t13 = e12, { set: s9, handle: n11 } = r10.acquireSet(t5.Highlight, i7);
        return r10.setObjectIds(s9, t13), n11;
      }
    }
    return e3();
  }
  resetObjectStates() {
    var _a, _b;
    (_b = (_a = this.graphicsCore) == null ? void 0 : _a.objectStates) == null ? void 0 : _b.reset();
  }
  whenGraphicBounds(e12, t13) {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.whenGraphicBounds(e12, t13);
  }
  computeAttachmentOrigin(e12, t13) {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.computeAttachmentOrigin(e12, t13);
  }
  notifyGraphicGeometryChanged(e12) {
    this.graphicsCore.notifyGraphicGeometryChanged(e12);
  }
  notifyGraphicVisibilityChanged(e12) {
    this.graphicsCore.notifyGraphicVisibilityChanged(e12);
  }
  getRenderingInfo(e12, t13, r10) {
    var _a;
    const s9 = i4(e12, { renderer: t13, arcade: r10 });
    if (s9 == null ? void 0 : s9.color) {
      const e13 = s9.color;
      e13[0] = e13[0] / 255, e13[1] = e13[1] / 255, e13[2] = e13[2] / 255;
    }
    if (null != s9 && null != t13 && ((_a = this._randomRotationRenderers) == null ? void 0 : _a.has(t13))) {
      const r11 = this._randomRotationRenderers.get(t13), n11 = e12.attributes[r11], a7 = new i2(0);
      a7.updateFloatArray([n11]), a7.updateUint8Array([173]), s9.heading = 8381e-11 * a7.digest();
    }
    return s9;
  }
  getRenderingInfoAsync(e12, t13, i7, r10) {
    return l5(e12, { renderer: t13, arcade: i7, ...r10 });
  }
  getSymbolLayerSize(e12, t13) {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.getSymbolLayerSize(e12, t13);
  }
  setObjectIdVisibility(e12, t13) {
    var _a;
    (_a = this.graphicsCore) == null ? void 0 : _a.setObjectIdVisibility(e12, t13);
  }
  refreshFilter() {
    null != this.filterVisibility && this.filterVisibility.reapply();
  }
  getGraphics3DGraphicByObjectId(e12) {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.getGraphics3DGraphicByObjectId(e12);
  }
  _updateClippingExtent() {
    const e12 = this.owner.view.clippingArea;
    this.graphicsCore.setClippingExtent(e12, this.owner.view.spatialReference) && (this.updateClippingExtent(e12) || this.graphicsCore.recreateAllGraphics());
  }
  _setupSuspendResumeExtent() {
    (this.frustumVisibility || this.scaleVisibility) && this.addHandles(d2(() => this.suspendResumeExtentMode, () => {
      switch (this.removeHandles(H2), this.suspendResumeExtentMode) {
        case "computed":
          this.addHandles([d2(() => this.graphicsCore.computedExtent, (e12) => this._updateSuspendResumeExtent(e12), P), d2(() => this.graphicsCore.extentPadding, () => this._updateSuspendResumeExtent(this.graphicsCore.computedExtent))], H2);
          break;
        case "data":
          this.addHandles([p(() => this.dataExtent, (e12) => this._updateSuspendResumeExtent(e12), P), d2(() => this.graphicsCore.extentPadding, () => this._updateSuspendResumeExtent(this.dataExtent))], H2);
          break;
        default:
          n6(this.suspendResumeExtentMode);
      }
    }, P));
  }
  _updateSuspendResumeExtent(e12) {
    e12 ? this._suspendResumeExtentChanged(this._extentToSuspendResumeRect(e12, this._suspendResumeExtent)) : this._suspendResumeExtentChanged(null);
  }
  _extentToSuspendResumeRect(e12, t13) {
    const i7 = this.owner.view.spatialReference;
    if (!e12.spatialReference.equals(i7)) {
      if (!x(e12, i7))
        return;
      e12 = g(e12, i7);
    }
    return P2(e12, t13, r7, this.graphicsCore.extentPadding);
  }
  _suspendResumeExtentChanged(e12) {
    null != this.frustumVisibility && this.frustumVisibility.setExtent(e12), null != this.scaleVisibility && this.scaleVisibility.setExtent(e12);
  }
};
e([y2()], P3.prototype, "type", void 0), e([y2({ constructOnly: true })], P3.prototype, "owner", void 0), e([y2()], P3.prototype, "layer", null), e([y2({ readOnly: true })], P3.prototype, "dataUpdating", null), e([y2()], P3.prototype, "renderer", null), e([y2({ constructOnly: true })], P3.prototype, "updateClippingExtent", void 0), e([y2({ constructOnly: true })], P3.prototype, "elevationFeatureExpressionEnabled", void 0), e([y2({ constructOnly: true })], P3.prototype, "graphicsCore", void 0), e([y2({ constructOnly: true })], P3.prototype, "scaleVisibilityEnabled", void 0), e([y2({ constructOnly: true })], P3.prototype, "filterVisibilityEnabled", void 0), e([y2({ constructOnly: true })], P3.prototype, "frustumVisibilityEnabled", void 0), e([y2({ constructOnly: true })], P3.prototype, "elevationAlignmentEnabled", void 0), e([y2({ constructOnly: true })], P3.prototype, "timeExtentEnabled", void 0), e([y2({ constructOnly: true })], P3.prototype, "setUidToIdOnAdd", void 0), e([y2()], P3.prototype, "scaleVisibility", null), e([y2()], P3.prototype, "filterVisibility", null), e([y2()], P3.prototype, "elevationAlignment", null), e([y2({ constructOnly: true })], P3.prototype, "frustumVisibility", void 0), e([y2()], P3.prototype, "initializePromise", void 0), e([y2()], P3.prototype, "suspendResumeExtentMode", null), e([y2()], P3.prototype, "dataExtent", void 0), e([y2()], P3.prototype, "scaleVisibilitySuspended", null), e([y2()], P3.prototype, "suspended", null), e([y2()], P3.prototype, "legendEnabled", null), e([y2()], P3.prototype, "suspendInfo", null), e([y2()], P3.prototype, "updating", null), e([y2()], P3.prototype, "updatingRemaining", null), e([y2()], P3.prototype, "featureStore", null), e([y2()], P3.prototype, "view", null), e([y2()], P3.prototype, "loadedGraphics", null), e([y2()], P3.prototype, "fullOpacity", null), e([y2()], P3.prototype, "filter", null), e([y2()], P3.prototype, "slicePlaneEnabled", null), e([y2()], P3.prototype, "drapeSourceType", void 0), e([y2()], P3.prototype, "updatePolicy", null), e([y2()], P3.prototype, "preferredUpdatePolicy", void 0), e([y2({ readOnly: true })], P3.prototype, "displayFeatureLimit", null), P3 = e([a3("esri.views.3d.layers.graphics.Graphics3DFeatureProcessor")], P3);
var H2 = "suspendResumeExtentMode";

// node_modules/@arcgis/core/views/3d/layers/support/featureReference.js
var t12 = class {
  get isReferenced() {
    return 0 !== this.versions.length;
  }
  get isSingle() {
    return 1 === this.versions.length && 1 === this.versions[0].refCount;
  }
  constructor(e12, t13) {
    this._highestResolutionVersion = null, this.versions = [], this.ref(e12, t13);
  }
  ref(t13, s9) {
    const r10 = this.feature;
    i6.oldVersion = r10, this.feature && Object.defineProperty(t13, "uid", { value: this.feature.uid, configurable: true });
    for (const n11 of this.versions)
      if (n11.resolution === s9) {
        n11.refCount++;
        const s10 = this._highestResolutionVersion === n11 && !h4(t13, n11.feature);
        return (s10 || this._highestResolutionVersion !== n11) && (n11.feature = t13), i6.newVersion = s10 ? t13 : r10, i6;
      }
    const o9 = { feature: t13, resolution: s9, refCount: 1 };
    return this.versions.push(o9), !this._highestResolutionVersion || s9 < this._highestResolutionVersion.resolution ? (i6.newVersion = t13, this._highestResolutionVersion = o9) : i6.newVersion = r10, i6;
  }
  unref(e12) {
    for (let t13 = 0; t13 < this.versions.length; t13++) {
      const s9 = this.versions[t13];
      if (s9.resolution === e12)
        return s9.refCount--, i6.oldVersion = this.feature, 0 === s9.refCount && (this.versions[t13] = this.versions[this.versions.length - 1], this.versions.length--, this._highestResolutionVersion === s9 && (this._recalculateHighestResolutionVersion(), i6.oldVersion = s9.feature)), i6.newVersion = this.feature, i6;
    }
    return null;
  }
  get feature() {
    return this._highestResolutionVersion ? this._highestResolutionVersion.feature : null;
  }
  _recalculateHighestResolutionVersion() {
    if (0 === this.versions.length)
      return void (this._highestResolutionVersion = null);
    let e12 = this.versions[0];
    for (let t13 = 1; t13 < this.versions.length; t13++) {
      const s9 = this.versions[t13];
      s9.resolution < e12.resolution && (e12 = s9);
    }
    this._highestResolutionVersion = e12;
  }
};
var s8 = class {
  get isReferenced() {
    return 0 !== this._refCount;
  }
  get isSingle() {
    return 1 === this._refCount;
  }
  constructor(e12) {
    this._feature = e12, this._refCount = 1;
  }
  ref(t13) {
    return ++this._refCount, i6.oldVersion = this._feature, this.feature && Object.defineProperty(t13, "uid", { value: this.feature.uid, configurable: true }), h4(this._feature, t13) || (this._feature = t13), i6.newVersion = this._feature, i6;
  }
  unref() {
    return i6.oldVersion = this._feature, this._refCount > 0 && (this._refCount--, !this.isReferenced) ? (i6.newVersion = null, i6) : (i6.newVersion = this._feature, i6);
  }
  get feature() {
    return this._feature;
  }
};
var i6 = { oldVersion: null, newVersion: null };

// node_modules/@arcgis/core/views/3d/layers/support/FeatureTile.js
var _4 = 16438;
var d8 = /* @__PURE__ */ new Set();
var m7 = class {
  get featuresMissing() {
    return this._featuresMissing.value;
  }
  set featuresMissing(t13) {
    this._featuresMissing.value = t13;
  }
  get missingAttributes() {
    return this._missingAttributes;
  }
  get fetchFailed() {
    return this._fetchFailed.value;
  }
  set fetchFailed(t13) {
    this._fetchFailed.value = t13;
  }
  get displayingFeatures() {
    return this._displayingFeatures;
  }
  set displayingFeatures(t13) {
    this._displayingFeatures = t13, this.extentIncludingBorrowedFeatures = null;
  }
  get perTileMaximumNumberOfFeaturesExceeded() {
    const t13 = (this.fetchStatus === c8.DONE || this.fetchStatus === c8.FULL) && this.featuresMissing;
    return !this.filtered && (t13 || this.hasFeatureLimit);
  }
  get features() {
    return this._features;
  }
  get featureLimit() {
    return this._featureLimit.value;
  }
  set featureLimit(t13) {
    this._featureLimit.value !== t13 && (this._featureLimit.value = t13, this._estimatedUnusedSizeDirty = true);
  }
  get hasFeatureLimit() {
    return this.featureLimit !== this._featuresLength.value;
  }
  get hasAllFeatures() {
    return !(this.featuresMissing || this.fetchFailed || this.hasFeatureLimit);
  }
  get availableFields() {
    return this._availableFields;
  }
  setFeatures(t13, e12, s9, i7) {
    this._availableFields = s9 ?? d8, this._features = t13, this._featuresLength.value = (t13 == null ? void 0 : t13.length) ?? 0, this._shuffled = false, this._estimatedSize = -1, this._estimatedUnusedSizeDirty = true, this._missingAttributes = i7, t13 && t13.length > 0 ? (this._emptyFeatureRatio.value = e12 / (t13.length + e12), this._numVertices = t13.reduce((t14, e13) => t14 + M(e13.geometry), 0)) : (this._emptyFeatureRatio.value = 0, this._numVertices = 0);
  }
  get emptyFeatureRatio() {
    return this._emptyFeatureRatio.value;
  }
  get numFeatures() {
    return this.hasPreciseFeatureCount ? this._numFeatures : this._features ? this._features.length : 0;
  }
  set numFeatures(t13) {
    this._numFeatures = t13;
  }
  get hasPreciseFeatureCount() {
    return this._numFeatures > F2;
  }
  get needsFeatureCount() {
    return this._numFeatures === F2;
  }
  get numVertices() {
    return this._numVertices;
  }
  constructor(t13) {
    this.descriptor = t13, this.fetchStatus = c8.FETCH_NEEDED, this._features = null, this._featuresLength = r3(0), this._numVertices = 0, this._featureLimit = r3(0), this._featuresMissing = r3(true), this._fetchFailed = r3(false), this._shuffled = false, this._numFeatures = F2, this._emptyFeatureRatio = r3(0), this._estimatedSize = -1, this._estimatedUnusedSize = 0, this._estimatedUnusedSizeDirty = false, this._availableFields = d8, this._displayingFeatures = null, this.alive = true, this.filtered = false;
  }
  get id() {
    return this.descriptor.id;
  }
  get estimatedSize() {
    return this.updateMemoryEstimates(), this._estimatedSize;
  }
  get estimatedUnusedSize() {
    return this._estimatedUnusedSize;
  }
  updateMemoryEstimates() {
    if (this._estimatedSize < 0) {
      if (this._estimatedSize = 0, this._estimatedUnusedSize = 0, this._features)
        for (let t13 = 0; t13 < this._features.length; ++t13) {
          const e12 = Z2(this._features[t13]);
          this._estimatedSize += e12, t13 >= this.featureLimit && (this._estimatedUnusedSize += e12);
        }
      return true;
    }
    if (this._estimatedUnusedSizeDirty) {
      if (this._estimatedUnusedSize = 0, this._estimatedUnusedSizeDirty = false, this._features)
        for (let t13 = this.featureLimit; t13 < this._features.length; ++t13)
          this._estimatedUnusedSize += Z2(this._features[t13]);
      return true;
    }
    return false;
  }
  get isFetching() {
    return this.fetchStatus === c8.FETCHING || this.fetchStatus === c8.REFETCHING;
  }
  get isRefetching() {
    return this.fetchStatus === c8.REFETCHING;
  }
  get needsFetching() {
    return this.fetchStatus === c8.FETCH_NEEDED || this.fetchStatus === c8.REFETCH_NEEDED;
  }
  get needsRefetching() {
    return this.fetchStatus === c8.REFETCH_NEEDED;
  }
  get isFetched() {
    return this.fetchStatus === c8.DONE || this.fetchStatus === c8.FULL;
  }
  resetFetching() {
    this.fetchStatus = this.fetchStatus === c8.REFETCHING ? c8.REFETCH_NEEDED : c8.FETCH_NEEDED;
  }
  get needsDisplayUpdate() {
    return !!this._features && !E4(this._features, this.displayingFeatures, this.featureLimit);
  }
  intersects(t13) {
    return null == t13 || !this.descriptor.extent || (o(t13, o8), E(this.descriptor.extent, o8));
  }
  intersectionIncludingBorrowed(t13, e12) {
    const s9 = null != this.extentIncludingBorrowedFeatures ? this.extentIncludingBorrowedFeatures : this.descriptor.extent;
    return t13 || s9 ? (null != t13 ? (o(t13, e12), U(e12, s9, e12)) : e4(e12, s9), e12) : (e4(e12, J), e12);
  }
  _shuffle(e12) {
    this._features && (this._features.sort((t13, s9) => I4(t13, e12) - I4(s9, e12)), L(this._features, _4), this._shuffled = true, this._estimatedUnusedSizeDirty = true);
  }
  reduceFeatures(t13, e12, s9) {
    if (t13 <= 0)
      return false;
    if (!this._features)
      return this.featureLimit = 0, false;
    let i7 = false;
    this.featureLimit = Math.ceil(this.numFeatures * t13), this.featureLimit > this._features.length && (this.featureLimit = this._features.length, this.fetchStatus === c8.DONE && this._features.length > 0 && (this.fetchStatus = c8.REFETCH_NEEDED, i7 = true)), !this._shuffled && t13 < 1 && this._shuffle(s9);
    const r10 = Math.max(this.featureLimit, Math.ceil(e12 * this.numFeatures));
    return this._features.length > r10 && (this._features.length = r10, this._featuresLength.value = r10, this.featuresMissing = true, this.fetchStatus === c8.FULL && (this.fetchStatus = c8.DONE)), i7;
  }
  get cache() {
    return { availableFields: this._availableFields, features: this._features, numFeatures: this._numFeatures, emptyFeatureRatio: this._emptyFeatureRatio.value, fetchStatus: this.fetchStatus, featuresMissing: this.featuresMissing };
  }
  set cache(t13) {
    var _a;
    this.requestController = null, this._availableFields = t13.availableFields, this._features = t13.features, this._featuresLength.value = ((_a = t13.features) == null ? void 0 : _a.length) ?? 0, this._numFeatures = t13.numFeatures, this._emptyFeatureRatio.value = t13.emptyFeatureRatio, this.fetchStatus = t13.fetchStatus, this.featuresMissing = t13.featuresMissing, this._estimatedSize = -1, this._estimatedUnusedSizeDirty = true;
  }
};
var F2 = -1;
var g2 = -2;
var c8;
function E4(t13, e12, s9) {
  if (null == e12 || null == t13 || s9 !== e12.length || s9 > t13.length)
    return false;
  for (let i7 = 0; i7 < s9; ++i7)
    if (t13[i7] !== e12[i7])
      return false;
  return true;
}
!function(t13) {
  t13[t13.FETCH_NEEDED = 0] = "FETCH_NEEDED", t13[t13.REFETCH_NEEDED = 1] = "REFETCH_NEEDED", t13[t13.FETCHING = 2] = "FETCHING", t13[t13.REFETCHING = 3] = "REFETCHING", t13[t13.DONE = 4] = "DONE", t13[t13.FULL = 5] = "FULL";
}(c8 || (c8 = {}));
var o8 = u3();

// node_modules/@arcgis/core/views/3d/layers/support/FeatureTileFetcher3D.js
var j2 = class extends S {
  set maximumNumberOfFeatures(e12) {
    e12 = e12 || 1 / 0;
    const t13 = this._get("maximumNumberOfFeatures");
    e12 === t13 || e12 < 1 || (this._set("maximumNumberOfFeatures", e12), this._maximumFeaturesUpdated(t13, e12));
  }
  set memoryFactor(e12) {
    this.memoryFactor !== e12 && (this._set("memoryFactor", e12), this._setDirty());
  }
  set lodFactor(e12) {
    this.lodFactor !== e12 && (this._set("lodFactor", e12), this._supportsResolution && this.refetch());
  }
  get useTileCount() {
    return this._useTileCount && null != this.context.query.queryFeatureCount;
  }
  set useTileCount(e12) {
    this._useTileCount = e12, this.notifyChange("useTileCount");
  }
  get updating() {
    var _a;
    return this._dirty || !!this._pendingEdits || this._isFetching || (((_a = this.tileDescriptors) == null ? void 0 : _a.updating) ?? false);
  }
  get memoryForUnusedFeatures() {
    let e12 = 0;
    return this._featureTiles.forEach((t13) => e12 += t13.estimatedUnusedSize), e12;
  }
  get totalVertices() {
    let e12 = 0;
    return this._featureTiles.forEach((t13) => e12 += t13.numVertices), e12;
  }
  get totalFeatures() {
    let e12 = 0;
    return this._featureTiles.forEach((t13) => e12 += t13.numFeatures), e12;
  }
  get hasAllFeatures() {
    if (this._paused || this.dataUpdating)
      return false;
    for (const [, e12] of this._featureTiles)
      if (!this.hasFullGeometries && 0 !== e12.emptyFeatureRatio || !e12.hasAllFeatures)
        return false;
    return true;
  }
  get hasFullGeometries() {
    if (!this._supportsResolution)
      return true;
    return !this.tileDescriptors.find((e12) => null != e12.resolution) || !this.context.capabilities.supportsQuantization && "polyline" !== this.context.geometryType;
  }
  set filterExtent(e12) {
    if (null != e12 && this.context.tilingScheme && !e12.spatialReference.equals(this.context.tilingScheme.spatialReference))
      return void n2.getLogger(this).error("#filterExtent=", "extent needs to be in the same spatial reference as the tiling scheme");
    const t13 = this._get("filterExtent");
    if (t13 === e12 || null != t13 && e12 && t13.equals(e12))
      return;
    const i7 = null != e12 ? e12.clone() : null;
    this._set("filterExtent", i7), this._reclip(i7, t13);
  }
  constructor(e12) {
    super(e12), this._useTileCount = false, this.dataUpdating = false, this.running = false, this.updatingTotal = 0, this.updatingRemaining = 0, this.expectedFeatureDiff = 0, this.maximumNumberOfFeaturesExceeded = false, this._fullRatio = 1, this._farRatio = 1, this._changes = { updates: { adds: new Array(), removes: new Array() }, adds: new Array(), removes: new Array() }, this._frameTask = F, this._dirty = false, this._featureTiles = new s3(), this._displayingFeatureReferences = /* @__PURE__ */ new Map(), this._numDisplayingFeatureReferences = 0, this._suspended = true, this._pendingEdits = null, this._applyEditsTilesUpdated = false, this._isFetching = false;
  }
  initialize() {
    this.addHandles(v2(() => this.tileDescriptors, "change", () => this._setDirty(), { sync: true, onListenerAdd: () => this._setDirty() })), this._objectIdField = this.context.objectIdField, this.FeatureReferenceClass = this.context.capabilities.supportsMultipleResolutions ? t12 : s8;
    const e12 = this.context.scheduler;
    null != e12 && (this._frameTask = e12.registerTask(I3.FEATURE_TILE_FETCHER, this)), this._setDirty();
  }
  destroy() {
    var _a;
    this._frameTask.remove(), this._featureTiles.forEach((e12) => {
      this._cancelFetchTile(e12), this._removeTile(e12);
    }), this._featureTiles.clear(), this._displayingFeatureReferences.clear(), (_a = this._pendingEdits) == null ? void 0 : _a.controller.abort(), this._pendingEdits = null;
  }
  get _paused() {
    return this._suspended || !!this._pendingEdits;
  }
  restart() {
    this._featureTiles.forEach((e12) => {
      this._cancelFetchTile(e12), this._clearTile(e12), this._resetFetchTile(e12);
    }), null != this.context.memoryCache && this.context.memoryCache.clear(), this._setDirty();
  }
  refetch() {
    this._featureTiles.forEach((e12) => {
      this._cancelFetchTile(e12), this._resetFetchTile(e12);
    }), null != this.context.memoryCache && this.context.memoryCache.clear(), this._setDirty();
  }
  suspend() {
    this._suspended || (this._suspended = true, this._pause(), this._setDirty());
  }
  resume() {
    this._suspended && (this._suspended = false, this._unpause());
  }
  getMissingAttributesForFeature(e12) {
    var _a;
    for (const [, t13] of this._featureTiles) {
      const s9 = (_a = t13.missingAttributes) == null ? void 0 : _a.get(e12);
      if (null != s9)
        return s9;
    }
  }
  _pause() {
    this._paused && (this._featureTiles.forEach((e12) => this._cancelFetchTile(e12)), this._updated());
  }
  _unpause() {
    this._paused || (this._setDirty(), this._updated());
  }
  get availableFields() {
    let e12 = null;
    return this._featureTiles.forEach((t13) => {
      null != t13.displayingFeatures && 0 !== t13.displayingFeatures.length && (null == e12 ? e12 = new Set(t13.availableFields) : e12.forEach((s9) => {
        t13.availableFields.has(s9) || e12.delete(s9);
      }));
    }), null != e12 ? e12 : /* @__PURE__ */ new Set();
  }
  applyEdits(e12) {
    this._pendingEdits || (this._pendingEdits = { edits: Promise.resolve(), count: 0, controller: new AbortController() }, this._pause());
    const t13 = this._pendingEdits;
    t13.count++;
    const s9 = t13.edits.then(() => e12.result.catch((e13) => {
      if (b(e13))
        throw e13;
      return null;
    }).then((e13) => e13 ? (this._applyEditsDeleteFeatures(e13.deletedFeatures), this._applyEditsAddUpdateFeatures(e13.addedFeatures, e13.updatedFeatures, t13.controller.signal).then(() => e13)) : e13).then((e13) => (0 == --t13.count && (this._pendingEdits === t13 && (this._pendingEdits = null), null != this.context.memoryCache && this.context.memoryCache.clear(), this._applyEditsTilesUpdated = false, this._unpause()), e13)));
    return t13.edits = s9, this._updated(), s9;
  }
  _applyEditsDeleteFeatures(e12) {
    if (0 === e12.length)
      return;
    const t13 = this.context.globalIdField, i7 = t13 && this.availableFields.has(t13), r10 = /* @__PURE__ */ new Set(), a7 = this._objectIdField;
    e12.forEach(({ objectId: e13, globalId: n11 }) => {
      (!e13 || e13 < 0) && t13 && n11 && (i7 || n2.getLogger(this).errorOncePerTick(`Editing the specified service requires the layer's globalIdField, ${t13} to be included the layer's outFields for updates to be reflected in the view`), e13 = this._objectIdFromGlobalId(n11, a7, t13)), null != e13 && e13 >= 0 && r10.add(e13);
    }), this._featureTiles.forEach((e13) => {
      if (!e13.features)
        return;
      const t14 = e13.features.filter((e14) => !r10.has(I4(e14, this._objectIdField)));
      t14.length !== e13.features.length && (this._applyEditsTileUpdated(), e13.setFeatures(t14, 0, e13.availableFields, e13.missingAttributes), this._invalidateCounts());
    });
  }
  _objectIdFromGlobalId(e12, t13, s9) {
    if (null == e12)
      return null;
    const i7 = this.features.find((t14) => {
      var _a;
      return ((_a = t14.attributes) == null ? void 0 : _a[s9]) === e12;
    });
    return i7 ? I4(i7, t13) : null;
  }
  async _applyEditsAddUpdateFeatures(e12, t13, i7) {
    const { objectIdField: r10, globalIdField: a7 } = this.context, n11 = a7 && this.availableFields.has(a7), o9 = /* @__PURE__ */ new Set(), u9 = /* @__PURE__ */ new Set();
    for (const s9 of e12) {
      const e13 = s9.objectId;
      null != e13 && o9.add(e13);
    }
    for (const { objectId: h7, globalId: d12 } of t13) {
      let e13 = h7;
      (null == e13 || e13 < 0) && a7 && (n11 || n2.getLogger(this).errorOncePerTick(`Editing the specified service requires the layer's globalIdField, ${a7} to be included the layer's outFields for updates to be reflected in the view`), e13 = this._objectIdFromGlobalId(d12, r10, a7)), null != e13 && e13 >= 0 && (o9.add(e13), u9.add(e13));
    }
    if (0 === o9.size)
      return;
    const l7 = [];
    this._featureTiles.forEach((e13) => {
      const t14 = this._applyEditsAddUpdateTile(e13, o9, u9, i7);
      t14 && l7.push(t14);
    }), this._updated(), await Promise.allSettled(l7);
  }
  async _applyEditsAddUpdateTile(e12, t13, s9, i7) {
    if (!e12.features)
      return;
    const r10 = this._createQuery(e12);
    r10.resultType = void 0, r10.cacheHint = false, r10.objectIds = Array.from(t13);
    const a7 = await this._queryFeatures(r10, i7);
    let n11 = null;
    if (s9.size > 0) {
      const t14 = e12.features.filter((e13) => !s9.has(I4(e13, this._objectIdField)));
      t14.length !== e12.features.length && (n11 = t14);
    }
    if (a7.features.length > 0) {
      n11 || (n11 = e12.features.slice());
      for (const e13 of a7.features)
        n11.push(e13);
    }
    n11 && (e12.hasPreciseFeatureCount && (e12.numFeatures = Math.max(e12.numFeatures, n11.length)), this._applyEditsTileUpdated(), e12.setFeatures(n11, 0, q(e12.availableFields, a7.fields), L2(e12.missingAttributes, a7.missingAttributes)), this._invalidateCounts());
  }
  _applyEditsTileUpdated() {
    this._applyEditsTilesUpdated || (this._applyEditsTilesUpdated = true, this._updated());
  }
  _queryFeatures(e12, t13) {
    return this.context.query.queryFeaturesDehydrated(e12, { signal: t13, timeout: V2 });
  }
  _setDirty() {
    this._dirty = true, this._updated();
  }
  runTask(e12) {
    const t13 = this._frameTask.processQueue(e12);
    if (!this._dirty || !this.initialized)
      return t13;
    this._dirty = false;
    const s9 = this._getListOfTiles();
    if (this._markTilesNotAlive(s9), !e12.run(() => this._addTiles(s9, e12)) || !e12.run(() => this._filterExtentTiles(s9, e12)) || !e12.run(() => this._removeTiles(s9, e12)) || e12.done)
      return void this._setDirty();
    const i7 = this._sortTiles(s9);
    e12.run(() => this._showTiles(i7, e12)) && e12.run(() => this._fetchTiles(i7, e12)) && e12.run(() => this._updateMemoryEstimates(i7, e12)) || this._setDirty(), this._updated(), this.updating || this._updateMaximumNumberOfFeaturesExceeded();
  }
  _markTilesNotAlive(e12) {
    for (const t13 of e12)
      t13.alive = false;
  }
  _addTiles(e12, t13) {
    return !(this._suspended || !this.tileDescriptors) && (this.tileDescriptors.forEach((s9) => {
      const i7 = this._featureTiles.get(s9.id);
      i7 ? i7.alive = true : t13.done || (e12.push(this._addTile(s9)), t13.madeProgress());
    }), t13.hasProgressed);
  }
  _filterExtentTiles(e12, t13) {
    for (const s9 of e12) {
      if (t13.done)
        break;
      s9.alive && (s9.filtered = !s9.intersects(this.filterExtent), s9.filtered && (this._clearTile(s9), t13.madeProgress()));
    }
    return t13.hasProgressed;
  }
  _removeTiles(e12, t13) {
    for (let s9 = e12.length - 1; s9 >= 0 && !t13.done; s9--) {
      const i7 = e12[s9];
      i7.alive || (this._removeTile(i7), s9 !== e12.length - 1 && (e12[s9] = e12[e12.length - 1]), e12.pop(), t13.madeProgress());
    }
    return t13.hasProgressed;
  }
  _sortTiles(e12) {
    return e12.sort((e13, t13) => (e13.descriptor.loadPriority ?? 0) - (t13.descriptor.loadPriority ?? 0)), e12;
  }
  _showTiles(e12, t13) {
    const s9 = this._updateRatio(e12), i7 = (e13) => {
      const t14 = this._fullRatio < 1 ? s9(e13) * this._farRatio : 1;
      return e13.reduceFeatures(t14, this.memoryFactor, this._objectIdField) && this._setDirty(), this._showTile(e13);
    };
    for (const r10 of e12)
      if (!t13.run(() => i7(r10))) {
        this._setDirty();
        break;
      }
    return t13.hasProgressed;
  }
  _fetchTiles(e12, t13) {
    if (this._paused)
      return false;
    let i7 = false;
    for (const s9 of e12) {
      if (!s9.needsFetching)
        continue;
      const e13 = null != this.context.memoryCache ? this.context.memoryCache.pop(s9.id) : null;
      if (null == e13) {
        if (this._needsNumFeatures(s9)) {
          const e14 = new AbortController(), r10 = this._fetchTileCount(s9, e14.signal);
          this._handleRequest(s9, r10, e14, () => s9.numFeatures = g2), i7 = true, t13.madeProgress();
        }
        if (t13.done)
          return true;
      } else
        s9.cache = e13, this._setDirty(), this._scheduleUpdated(), t13.madeProgress();
    }
    if (i7)
      return t13.hasProgressed;
    for (const r10 of e12)
      if (r10.needsFetching) {
        const e13 = new AbortController(), i8 = this._fetchTile(r10, e13.signal);
        if (this._handleRequest(r10, i8, e13, (e14) => {
          r10.setFeatures([], 0, null, void 0), this._invalidateCounts(), r10.featuresMissing = false, r10.fetchFailed = true, this.context.logFetchError(n2.getLogger(this), e14);
        }), t13.madeProgress())
          return true;
      }
    return t13.hasProgressed;
  }
  _updateMemoryEstimates(e12, t13) {
    return e12.some((e13) => !t13.run(() => e13.updateMemoryEstimates()) && (this._setDirty(), true)), t13.hasProgressed;
  }
  _reclip(e12, t13) {
    if (!this.initialized)
      return;
    const s9 = new Array();
    this._featureTiles.forEach((i7) => {
      null != i7.displayingFeatures && 0 !== i7.displayingFeatures.length && (i7.intersectionIncludingBorrowed(t13, Q), i7.intersectionIncludingBorrowed(e12, H3), I(Q, H3) || s9.push(i7));
    }), this._refreshDisplayingFeatures(s9), this._updated();
  }
  _refreshDisplayingFeatures(e12) {
    const t13 = /* @__PURE__ */ new Set(), s9 = this._changes.updates;
    for (const i7 of e12)
      if (null != i7.displayingFeatures)
        for (const e13 of i7.displayingFeatures) {
          const i8 = I4(e13, this._objectIdField);
          if (t13.has(i8))
            continue;
          t13.add(i8);
          const r10 = this._displayingFeatureReferences.get(i8).feature;
          s9.removes.push(r10), s9.adds.push(r10);
        }
    this._applyChanges();
  }
  _updated() {
    let e12 = 0;
    if (this._paused || this._featureTiles.forEach((t13) => t13.isFetching ? ++e12 : 0), this._isFetching = e12 > 0, this._set("running", this._dirty), e12 > 0 || this._applyEditsTilesUpdated ? this._set("dataUpdating", true) : this._dirty || this._set("dataUpdating", false), this.updating) {
      let t13 = 0, s9 = 0, i7 = 0, r10 = 0, a7 = 0;
      const n11 = this._displayingFeatureReferences.size / this._numDisplayingFeatureReferences;
      this._featureTiles.forEach((e13) => {
        if (++s9, e13.isFetching && e13.hasPreciseFeatureCount) {
          const t14 = this._maximumFeaturesForTile(e13) * (1 - e13.emptyFeatureRatio), s10 = null != e13.displayingFeatures ? e13.displayingFeatures.length * n11 : 0;
          a7 += t14 - s10;
        }
        e13.needsFetching ? ++r10 : e13.numFeatures > 0 && (++i7, t13 += e13.numFeatures);
      }), r10 += e12;
      let o9 = 0, u9 = 0;
      t13 ? (u9 = t13, o9 = Math.min(r10 * t13 / i7, t13)) : (u9 = s9, o9 = r10), a7 = Math.min(this.maximumNumberOfFeatures - this.features.length, a7), this._set("updatingTotal", u9), this._set("updatingRemaining", o9), this._set("expectedFeatureDiff", a7);
    } else
      this._set("updatingTotal", 0), this._set("updatingRemaining", 0), this._set("expectedFeatureDiff", 0);
    this.debugger && this.debugger.update();
  }
  _updateMaximumNumberOfFeaturesExceeded() {
    const e12 = n3(this._featureTiles, (e13) => e13.perTileMaximumNumberOfFeaturesExceeded);
    this._set("maximumNumberOfFeaturesExceeded", e12);
  }
  _updateRatio(e12) {
    const t13 = U3(e12), s9 = (e13) => 1 / (1 << Math.max(0, t13 - e13.descriptor.lij[0]));
    let i7 = 0, r10 = 0;
    for (const a7 of e12) {
      const e13 = a7.numFeatures;
      i7 += e13, r10 += e13 * s9(a7);
    }
    return this._fullRatio = Math.min(1, this.maximumNumberOfFeatures / i7), this._farRatio = this.maximumNumberOfFeatures / r10, this._scheduleUpdated(), s9;
  }
  _maximumFeaturesUpdated(e12, t13) {
    e12 !== t13 && (t13 > e12 && this._featureTiles.forEach((e13) => {
      if (!e13.featuresMissing)
        return;
      const t14 = this._maximumFeaturesForTile(e13);
      e13.features && (e13.features.length >= t14 || e13.fetchStatus === c8.FULL) || (this._cancelFetchTile(e13), this._resetFetchTile(e13));
    }), this._setDirty());
  }
  _addTile(e12) {
    const t13 = new m7(e12);
    return this._featureTiles.set(t13.id, t13), this._resetFetchTile(t13), this._referenceDisplayingFeaturesFromRelatedTiles(t13), t13;
  }
  _referenceDisplayingFeaturesFromRelatedTiles(e12) {
    const t13 = e12.descriptor.resolution;
    this._featureTiles.forEach((s9) => {
      if (!(null == s9.displayingFeatures || e12 === s9 || e12.descriptor.lij && s9.descriptor.lij && !x3(e12.descriptor.lij, s9.descriptor.lij))) {
        null == e12.displayingFeatures && (e12.displayingFeatures = []), e12.descriptor.extent && s9.descriptor.extent && (null == e12.extentIncludingBorrowedFeatures && (e12.extentIncludingBorrowedFeatures = i(e12.descriptor.extent)), m(e12.extentIncludingBorrowedFeatures, s9.descriptor.extent, e12.extentIncludingBorrowedFeatures));
        for (const i7 of s9.displayingFeatures) {
          e12.displayingFeatures.push(i7);
          const s10 = this._displayingFeatureReferences.get(I4(i7, this._objectIdField));
          s10.ref(s10.feature, t13), this._numDisplayingFeatureReferences++;
        }
      }
    }), e12.featureLimit = null != e12.displayingFeatures ? e12.displayingFeatures.length : 0;
  }
  _removeTile(e12) {
    this._clearTile(e12), this._featureTiles.delete(e12.id);
  }
  _resetFetchTile(e12) {
    e12.filtered = !e12.intersects(this.filterExtent), e12.filtered ? e12.needsFetching && (e12.fetchStatus = c8.DONE) : e12.fetchStatus = c8.FETCH_NEEDED;
  }
  _cancelFetchTile(e12) {
    const t13 = e12.requestController;
    null != t13 && (e12.requestController = null, e12.resetFetching(), t13.abort());
  }
  async _fetchTileCount(e12, t13) {
    return e12.numFeatures = await this._fetchCount(e12, t13), this._updateRatio(this._getListOfTiles()), e12.fetchStatus === c8.REFETCHING ? c8.REFETCH_NEEDED : c8.FETCH_NEEDED;
  }
  async _fetchTile(e12, t13) {
    e12.fetchFailed = false;
    const s9 = this._maximumFeaturesForTile(e12);
    if (s9 <= 0)
      return e12.hasPreciseFeatureCount && 0 === e12.numFeatures || (e12.fetchFailed = true), A3(e12);
    const i7 = this._getMaxRecordCount(e12), r10 = Math.ceil(s9 / i7);
    if (O4(e12) || !this.context.capabilities.supportsMaxRecordCountFactor || e12.numFeatures <= s9 && r10 > b2.MAX_MAX_RECORD_COUNT_FACTOR)
      return this._fetchPagedTile(e12, t13);
    const a7 = this._createQuery(e12);
    if (a7.maxRecordCountFactor = Math.ceil(s9 / i7), e12.isRefetching && e12.features && e12.features.length > 0) {
      const t14 = Math.ceil(e12.features.length / (1 - e12.emptyFeatureRatio) / i7);
      a7.maxRecordCountFactor = Math.max(t14 + 1, a7.maxRecordCountFactor);
    }
    const { features: o9, exceededTransferLimit: u9, fields: l7, missingAttributes: h7 } = await this._queryFeatures(a7, t13), d12 = u9 ? a7.maxRecordCountFactor >= b2.MAX_MAX_RECORD_COUNT_FACTOR ? c8.FULL : c8.DONE : c8.FULL;
    return await this._frameTask.schedule(() => {
      e12.featuresMissing = e12.hasPreciseFeatureCount && o9.length < e12.numFeatures || !!u9;
      const t14 = this._removeEmptyFeatures(o9);
      e12.setFeatures(o9, t14, N(l7), L2(void 0, h7));
    }, t13), s2(t13), this._invalidateCounts(), d12;
  }
  async _fetchCount(e12, t13) {
    return this.context.query.queryFeatureCount(this._createFeatureCountQuery(e12), { signal: t13 });
  }
  async _fetchPagedTile(e12, t13) {
    let s9, i7 = 0, r10 = 0, a7 = 0, o9 = this._maximumFeaturesForTile(e12) - a7;
    const u9 = this._getMaxRecordCount(e12);
    let l7, h7 = null;
    for (; ; ) {
      const d12 = this._createQuery(e12), c10 = this._setPagingParameters(d12, i7, o9, u9), { features: p4, exceededTransferLimit: f7, fields: _5, missingAttributes: m9 } = await this._queryFeatures(d12, t13);
      if (await this._frameTask.schedule(() => {
        c10 && (i7 += d12.num), a7 += p4.length, r10 += this._removeEmptyFeatures(p4), e12.featuresMissing = c10 && e12.hasPreciseFeatureCount && i7 < e12.numFeatures || !!f7, s9 = s9 ? s9.concat(p4) : p4, h7 = q(h7, _5), l7 = L2(l7, m9), e12.setFeatures(s9, r10, h7, l7);
      }, t13), s2(t13), this._invalidateCounts(), this._setDirty(), o9 = this._maximumFeaturesForTile(e12) - a7, !c10 || !f7 || o9 <= 0)
        return f7 ? c8.DONE : c8.FULL;
    }
  }
  _createFeatureCountQuery(e12) {
    const t13 = this._createQuery(e12);
    return this.context.capabilities.supportsCacheHint && (t13.resultType = void 0, t13.cacheHint = true), t13;
  }
  _createQuery(e12) {
    const t13 = this.context.createQuery(), s9 = e12.descriptor.extent;
    if (s9) {
      const e13 = this.context.tilingScheme.spatialReference;
      t13.geometry = c2(s9, e13);
    }
    return this._setResolutionParams(t13, e12), this._useTileQuery(e12) ? t13.resultType = "tile" : this.context.capabilities.supportsCacheHint && (t13.cacheHint = true), t13;
  }
  _setPagingParameters(e12, t13, s9, i7) {
    return !!this.context.capabilities.supportsPagination && (e12.start = t13, s9 > 0 && this.context.capabilities.supportsMaxRecordCountFactor ? (e12.maxRecordCountFactor = Math.ceil(s9 / i7), e12.num = Math.min(e12.maxRecordCountFactor * i7, s9)) : e12.num = Math.min(i7), true);
  }
  _getEffectiveTileResolution(e12) {
    if (null == e12.descriptor.resolution)
      return null;
    const t13 = this.context.viewingMode === l2.Global ? this.context.tilingScheme.resolutionAtLevel(3) : 1 / 0;
    return Math.min(e12.descriptor.resolution, t13) / this.lodFactor;
  }
  get _supportsResolution() {
    return this.context.capabilities.supportsMultipleResolutions && "point" !== this.context.geometryType;
  }
  _setResolutionParams(e12, t13) {
    if (!this._supportsResolution)
      return;
    const s9 = this._getEffectiveTileResolution(t13);
    null != s9 && (this.context.capabilities.supportsQuantization ? e12.quantizationParameters = new a4({ mode: "view", originPosition: "upper-left", tolerance: s9, extent: this.context.fullExtent }) : "polyline" === this.context.geometryType && (e12.maxAllowableOffset = s9));
  }
  _removeEmptyFeatures(e12) {
    const t13 = e12.length;
    for (let s9 = 0; s9 < e12.length; ) {
      const t14 = e12[s9];
      k2(t14.geometry) ? ++s9 : (e12[s9] = e12[e12.length - 1], --e12.length);
    }
    return t13 - e12.length;
  }
  _needsNumFeatures(e12) {
    return this.useTileCount && e12.needsFeatureCount && !O4(e12);
  }
  _getMaxRecordCount(e12) {
    const { tileMaxRecordCount: t13, maxRecordCount: s9 } = this.context;
    return this._useTileQuery(e12) && null != t13 && t13 > 0 && this.context.capabilities.supportsResultType ? t13 : null != s9 && s9 > 0 ? s9 : S3;
  }
  _useTileQuery(e12) {
    return (!O4(e12) || !this.context.capabilities.supportsCacheHint) && this.context.capabilities.supportsResultType;
  }
  _handleRequest(e12, t13, s9, i7) {
    e12.fetchStatus = e12.needsRefetching ? c8.REFETCHING : c8.FETCHING, e12.requestController = s9;
    let r10 = false;
    t13.then((t14) => {
      e12.requestController = null, e12.fetchStatus = t14;
    }).catch((t14) => {
      e12.requestController === s9 && (e12.requestController = null, e12.fetchStatus = c8.DONE), b(t14) ? r10 = true : i7(t14);
    }).then(() => {
      r10 || this._setDirty(), this._scheduleUpdated();
    });
  }
  _scheduleUpdated() {
    this.hasHandles("scheduleUpdated") || this.addHandles(v(() => {
      this.removeHandles("scheduleUpdated"), this._updated();
    }), "scheduleUpdated");
  }
  _showTile(e12) {
    if (null != e12.displayingFeatures && !e12.needsDisplayUpdate)
      return false;
    const t13 = e12.features;
    if (0 === e12.featureLimit || !t13) {
      const t14 = null != e12.displayingFeatures && e12.displayingFeatures.length > 0;
      return this._hideTileFeatures(e12), e12.displayingFeatures = [], t14;
    }
    const s9 = e12.descriptor.resolution, i7 = this._changes.updates, r10 = this._changes.adds, a7 = Math.min(e12.featureLimit, t13.length);
    e12.featureLimit = a7;
    for (let n11 = 0; n11 < a7; ++n11) {
      const e13 = t13[n11], a8 = I4(e13, this._objectIdField), o9 = this._displayingFeatureReferences.get(a8);
      if (o9) {
        const t14 = o9.ref(e13, s9);
        t14.oldVersion !== t14.newVersion && (t14.oldVersion && i7.removes.push(t14.oldVersion), t14.newVersion && i7.adds.push(t14.newVersion));
      } else
        this._displayingFeatureReferences.set(a8, new this.FeatureReferenceClass(e13, s9)), r10.push(e13);
      this._numDisplayingFeatureReferences++;
    }
    return this._hideTileFeatures(e12), this._applyChanges(), e12.displayingFeatures = t13.slice(0, a7), true;
  }
  _hideTile(e12) {
    this._cancelFetchTile(e12), this._hideTileFeatures(e12);
  }
  _hideTileFeatures(e12) {
    if (null == e12.displayingFeatures)
      return;
    const t13 = this._changes.updates, s9 = this._changes.removes;
    for (const i7 of e12.displayingFeatures) {
      const r10 = I4(i7, this._objectIdField), a7 = this._displayingFeatureReferences.get(r10);
      if (!a7)
        continue;
      const n11 = a7.unref(e12.descriptor.resolution);
      this._numDisplayingFeatureReferences--, n11 ? n11.oldVersion !== n11.newVersion && (null == n11.newVersion ? (this._displayingFeatureReferences.delete(r10), n11.oldVersion && s9.push(n11.oldVersion)) : (t13.adds.push(n11.newVersion), n11.oldVersion && t13.removes.push(n11.oldVersion))) : console.error("Hiding unreferenced feature");
    }
    this._applyChanges(), e12.displayingFeatures = null;
  }
  _applyChanges() {
    const e12 = this._changes.updates;
    e12.removes.length > 0 && (this.features.removeMany(e12.removes), e12.removes.length = 0), e12.adds.length > 0 && (this.features.addMany(e12.adds), e12.adds.length = 0);
    const t13 = this._changes.adds, s9 = this._changes.removes, i7 = Math.min(t13.length, s9.length);
    let r10 = 0;
    for (; r10 < i7; ) {
      const e13 = Math.min(r10 + z2, i7);
      this.features.addMany(t13.slice(r10, e13)), this.features.removeMany(s9.slice(r10, e13)), r10 = e13;
    }
    t13.length > i7 && this.features.addMany(0 === r10 ? t13 : t13.slice(r10)), s9.length > i7 && this.features.removeMany(0 === r10 ? s9 : s9.slice(r10)), t13.length = 0, s9.length = 0;
  }
  _clearTile(e12) {
    if (this._hideTile(e12), e12.features && null != this.context.memoryCache) {
      const t13 = 16 + e12.estimatedSize;
      this.context.memoryCache.put(e12.id, e12.cache, t13);
    }
    e12.setFeatures(null, 0, null, void 0), this._invalidateCounts();
  }
  _invalidateCounts() {
    this.notifyChange("totalVertices"), this.notifyChange("totalFeatures"), this.notifyChange("memoryForUnusedFeatures");
  }
  _getListOfTiles() {
    return Array.from(this._featureTiles.values());
  }
  get storedFeatures() {
    return this._getListOfTiles().reduce((e12, t13) => e12 + (t13.features ? t13.features.length : 0), 0);
  }
  get missingTiles() {
    return Array.from(this._featureTiles.values()).reduce((e12, t13) => e12 + (t13.needsFetching || t13.isFetching ? 1 : 0), 0);
  }
  _maximumFeaturesForTile(e12) {
    const t13 = e12.hasPreciseFeatureCount ? e12.numFeatures : 1 / 0, s9 = e12.hasPreciseFeatureCount ? t13 : this.maximumNumberOfFeatures, i7 = this._fullRatio < 1 ? this._farRatio : 1;
    return Math.min(Math.ceil(s9 * i7 / (1 - e12.emptyFeatureRatio)), t13);
  }
  get test() {
    return { process: (e12) => this.runTask(e12), getFeatureTileById: (e12) => this._featureTiles.get(e12), forEachFeatureTile: (e12) => this._featureTiles.forEach(e12) };
  }
};
function O4(e12) {
  return "dummy-tile-full-extent" === e12.id;
}
function U3(e12) {
  let t13 = 0;
  for (const s9 of e12)
    s9.features && s9.features.length > 0 && s9.alive && (t13 = Math.max(t13, s9.descriptor.lij[0]));
  return t13;
}
function P4(e12) {
  const t13 = e12.capabilities.query;
  return { supportsMultipleResolutions: I6(e12), supportsPagination: !(!t13 || !t13.supportsPagination), supportsResultType: !(!t13 || !t13.supportsResultType), supportsCacheHint: !(!t13 || !t13.supportsCacheHint), supportsQuantization: !(!t13 || !t13.supportsQuantization), supportsQuantizationEditMode: !(!t13 || !t13.supportsQuantizationEditMode), supportsMaxRecordCountFactor: !(!t13 || !t13.supportsMaxRecordCountFactor), supportsFormatPBF: !(!t13 || !t13.supportsFormatPBF) };
}
function I6(e12) {
  switch (e12.geometryType) {
    case "polyline":
      return true;
    case "polygon":
      return e12.capabilities && e12.capabilities.query && e12.capabilities.query.supportsQuantization;
    default:
      return false;
  }
}
function A3(e12) {
  return e12.setFeatures([], 0, null, void 0), e12.featuresMissing = false, c8.DONE;
}
function N(e12) {
  return null == e12 ? /* @__PURE__ */ new Set() : new Set(e12.map((e13) => e13.name));
}
function q(e12, t13) {
  if (null == e12 || null == t13)
    return N(t13);
  const s9 = /* @__PURE__ */ new Set();
  for (const { name: i7 } of t13)
    e12.has(i7) && s9.add(i7);
  return s9;
}
function L2(e12, t13) {
  if (!(t13 == null ? void 0 : t13.length))
    return e12;
  e12 ?? (e12 = /* @__PURE__ */ new Map());
  const s9 = () => /* @__PURE__ */ new Set();
  for (const { objectId: i7, attribute: a7 } of t13)
    r2(e12, i7, s9).add(a7);
  return e12;
}
e([y2({ constructOnly: true })], j2.prototype, "features", void 0), e([y2()], j2.prototype, "tileDescriptors", void 0), e([y2({ value: 1 / 0 })], j2.prototype, "maximumNumberOfFeatures", null), e([y2({ value: 1 })], j2.prototype, "memoryFactor", null), e([y2({ value: 1 })], j2.prototype, "lodFactor", null), e([y2()], j2.prototype, "useTileCount", null), e([y2({ readOnly: true })], j2.prototype, "updating", null), e([y2({ readOnly: true })], j2.prototype, "dataUpdating", void 0), e([y2({ readOnly: true })], j2.prototype, "running", void 0), e([y2({ readOnly: true })], j2.prototype, "updatingTotal", void 0), e([y2({ readOnly: true })], j2.prototype, "updatingRemaining", void 0), e([y2({ readOnly: true })], j2.prototype, "expectedFeatureDiff", void 0), e([y2({ readOnly: true })], j2.prototype, "memoryForUnusedFeatures", null), e([y2({ readOnly: true })], j2.prototype, "maximumNumberOfFeaturesExceeded", void 0), e([y2({ readOnly: true })], j2.prototype, "totalVertices", null), e([y2({ readOnly: true })], j2.prototype, "totalFeatures", null), e([y2({ readOnly: true })], j2.prototype, "hasAllFeatures", null), e([y2({ readOnly: true })], j2.prototype, "hasFullGeometries", null), e([y2()], j2.prototype, "filterExtent", null), e([y2({ constructOnly: true })], j2.prototype, "context", void 0), e([y2()], j2.prototype, "_dirty", void 0), e([y2()], j2.prototype, "_suspended", void 0), e([y2()], j2.prototype, "_pendingEdits", void 0), e([y2()], j2.prototype, "_applyEditsTilesUpdated", void 0), e([y2()], j2.prototype, "_paused", null), e([y2()], j2.prototype, "_isFetching", void 0), j2 = e([a3("esri.views.3d.layers.support.FeatureTileFetcher3D")], j2);
var S3 = 2e3;
var Q = u3();
var H3 = u3();
var V2 = 6e5;
var z2 = 200;

// node_modules/@arcgis/core/views/3d/layers/support/FeatureTileFetcher3DDebugger.js
var c9 = [[0, 179, 255], [117, 62, 128], [0, 104, 255], [215, 189, 166], [32, 0, 193], [98, 162, 206], [102, 112, 129], [52, 125, 0], [142, 118, 246], [138, 83, 0], [92, 122, 255], [122, 55, 83], [0, 142, 255], [81, 40, 179], [0, 200, 244], [13, 24, 127], [0, 170, 147], [19, 58, 241], [22, 44, 35]];
var m8 = class {
  constructor(e12, i7, o9) {
    this._loadingGraphics = /* @__PURE__ */ new Map(), this._loadedGraphics = /* @__PURE__ */ new Map(), this._pendingGraphics = /* @__PURE__ */ new Map(), this._dataExtentGraphic = null, this._enabled = true, this._tileFetcher = e12, this._view = o9, this._tilingScheme = new f3(i7), this._loadedSymbols = c9.map((e13) => new h2({ symbolLayers: new V([new h({ material: { color: [e13[0], e13[1], e13[2], 0.6] }, outline: { color: "black", size: 1 } })]) })), this._loadingSymbols = [new h2({ symbolLayers: new V([new h({ material: { color: [200, 200, 200, 0.4] }, outline: { color: [30, 30, 30], size: 1 } })]) })], this._pendingSymbols = [new h2({ symbolLayers: new V([new h({ material: { color: [100, 100, 100, 0.4] }, outline: { color: [30, 30, 30], size: 1 } })]) })], this._dataExtentSymbol = new h2({ symbolLayers: new V([new h({ material: { color: [0, 0, 0, 0] }, outline: { color: "green", size: 4 } })]) });
  }
  destroy() {
    this.enabled = false;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e12) {
    this._enabled = e12, this.update();
  }
  update() {
    this._enabled ? (this._synchronizeMaps(this._loadingGraphics, { filter: (e12) => e12.isFetching, symbols: this._loadingSymbols }), this._synchronizeMaps(this._loadedGraphics, { filter: (e12) => !e12.isFetching, symbols: this._loadedSymbols }), this._synchronizeMaps(this._pendingGraphics, { filter: (e12) => !e12.isFetching, symbols: this._pendingSymbols }), this.showDataExtent(this._tileFetcher.filterExtent)) : (this._loadingGraphics.forEach((e12) => {
      this._view.graphics.removeMany(e12);
    }), this._loadingGraphics.clear(), this._loadedGraphics.forEach((e12) => {
      this._view.graphics.removeMany(e12);
    }), this._loadedGraphics.clear(), this._pendingGraphics.forEach((e12) => {
      this._view.graphics.removeMany(e12);
    }), this._pendingGraphics.clear(), this._dataExtentGraphic && (this._view.graphics.remove(this._dataExtentGraphic), this._dataExtentGraphic = null));
  }
  showDataExtent(t13) {
    if (this._dataExtentGraphic && (this._view.graphics.remove(this._dataExtentGraphic), this._dataExtentGraphic = null), null == t13)
      return;
    const s9 = j.fromExtent(t13);
    this._dataExtentGraphic = new f({ geometry: s9, symbol: this._dataExtentSymbol }), this._view.graphics.add(this._dataExtentGraphic);
  }
  _synchronizeMaps(i7, s9) {
    const r10 = [];
    i7.forEach((e12, t13) => {
      const i8 = this._tileFetcher.test.getFeatureTileById(t13);
      i8 && s9.filter(i8) || (this._view.graphics.removeMany(e12), r10.push(t13));
    }), r10.forEach((e12) => i7.delete(e12)), this._tileFetcher.test.forEachFeatureTile((r11) => {
      if (s9.filter(r11) && !i7.has(r11.id)) {
        const [h7, c10, m9] = r11.descriptor.lij;
        this._tilingScheme.ensureMaxLod(h7);
        const p4 = this._tilingScheme.getExtentGeometry(h7, c10, m9), y3 = [new f({ geometry: p4, symbol: s9.symbols[h7 % s9.symbols.length] }), new f({ geometry: p4.center, symbol: new w4({ verticalOffset: new p2({ screenLength: 40 / 0.75 }), callout: new d3({ color: "white", border: { color: "black" } }), symbolLayers: new V([new z({ text: `${h7}/${c10}/${m9}`, halo: { color: "white", size: 1 / 0.75 }, material: { color: "black" }, size: 16 })]) }) })];
        i7.set(r11.id, y3), this._view.graphics.addMany(y3);
      }
    });
  }
};

// node_modules/@arcgis/core/layers/graphics/controllers/FeatureTileController3D.js
var T2 = class extends n4(S) {
  get dataUpdating() {
    var _a;
    return ((_a = this._tileFetcher) == null ? void 0 : _a.dataUpdating) ?? false;
  }
  set extent(e12) {
    if (null != e12 && !e12.spatialReference.equals(this.layerView.view.spatialReference))
      return void n2.getLogger(this).error("#extent=", "extent needs to be in the same spatial reference as the view");
    const t13 = this._get("extent");
    if (t13 === e12)
      return;
    if (null != t13 && e12 && t13.equals(e12))
      return;
    const i7 = null != e12 ? e12.clone() : null;
    this._set("extent", i7);
  }
  get updating() {
    return !!(null != this._tileFetcher && this._tileFetcher.updating || null != this._fetchDataInfoPromise || "tiles" === this.mode && this.layerView.view.featureTiles && this.layerView.view.featureTiles.updating || this._updatingHandles && this._updatingHandles.updating);
  }
  get updatingTotal() {
    return this.updating && null != this._tileFetcher ? this._tileFetcher.updatingTotal : 0;
  }
  get updatingRemaining() {
    return this.updating && null != this._tileFetcher ? this._tileFetcher.updatingRemaining : 0;
  }
  get expectedFeatureDiff() {
    return this.updating && null != this._tileFetcher ? this._tileFetcher.expectedFeatureDiff : 0;
  }
  get memoryForUnusedFeatures() {
    return null != this._tileFetcher ? this._tileFetcher.memoryForUnusedFeatures : 0;
  }
  get maximumNumberOfFeaturesExceeded() {
    return !(null == this._tileFetcher || !this._tileFetcher.maximumNumberOfFeaturesExceeded);
  }
  get maximumNumberOfFeatures() {
    var _a;
    return ((_a = this.displayFeatureLimit) == null ? void 0 : _a.maximumNumberOfFeatures) ?? 0;
  }
  set maximumNumberOfFeatures(e12) {
    e12 !== this.maximumNumberOfFeatures && this._overrideIfSome("maximumNumberOfFeatures", e12);
  }
  get hasMaximumNumberOfFeaturesOverride() {
    return this._isOverridden("maximumNumberOfFeatures");
  }
  get hasAllFeatures() {
    return this.serviceDataCount === q2.noServiceDataCount && "snapshot" === this.mode && this.hasAllFeaturesInView || this.serviceDataCount === this.graphics.length;
  }
  get hasAllFeaturesInView() {
    var _a;
    return ((_a = this._tileFetcher) == null ? void 0 : _a.hasAllFeatures) ?? false;
  }
  get hasFullGeometries() {
    var _a;
    return ((_a = this._tileFetcher) == null ? void 0 : _a.hasFullGeometries) ?? false;
  }
  get mode() {
    var _a, _b;
    const e12 = this.layerView.layer;
    if ("feature" === e12.type && null != e12.infoFor3D)
      return "snapshot";
    if (this._forceTilesMode)
      return "tiles";
    const t13 = this.layerView.view;
    if (false === ((_b = (_a = t13.qualitySettings) == null ? void 0 : _a.graphics3D) == null ? void 0 : _b.snapshotAvailable) || this.serviceDataCount === q2.noServiceDataCount || this._snapshotLimitExceeded || this.maximumNumberOfFeaturesExceeded || t13.quality < 1)
      return "tiles";
    const i7 = t13 && t13.featureTiles, r10 = i7 && i7.tilingScheme;
    if (e12 && e12.minScale && this.serviceDataExtent && r10) {
      const t14 = this._approximateExtentSizeAtScale(e12.minScale, r10);
      if ((this.serviceDataExtent.width / t14 + this.serviceDataExtent.height / t14) / 2 > q2.maxSnapshotMinScaleFactor)
        return "tiles";
    }
    return !this.maximumNumberOfFeatures || this.serviceDataCount <= this.maximumNumberOfFeatures ? "snapshot" : "tiles";
  }
  get maxTotalSnapshotVertices() {
    var _a;
    const e12 = this._get("maxTotalSnapshotVertices") || 0, t13 = "snapshot" === this.mode && ((_a = this._tileFetcher) == null ? void 0 : _a.totalVertices) || 0;
    return Math.max(e12, t13);
  }
  _approximateExtentSizeAtScale(e12, t13) {
    const i7 = this.layerView.view, r10 = Math.ceil((i7.width / t13.pixelSize + i7.height / t13.pixelSize) / 2), s9 = t13.levels[0];
    return r10 * ((s9.tileSize[0] / (s9.scale / e12) + s9.tileSize[1] / (s9.scale / e12)) / 2);
  }
  get tileDescriptors() {
    const e12 = this.layerView.view.featureTiles;
    return "snapshot" === this.mode ? new V([{ id: "dummy-tile-full-extent", lij: [0, 0, 0] }]) : e12 ? e12.tiles : new V();
  }
  get test() {
    return { fetchDataInfoPromise: this._fetchDataInfoPromise, tileFetcher: this._tileFetcher };
  }
  constructor(e12) {
    super(e12), this.type = "feature-tile-3d", this._updatingHandles = new h3(), this.serviceDataExtent = null, this.serviceDataCount = q2.noServiceDataCount, this._snapshotLimitExceeded = false, this.displayFeatureLimit = null, this._forceTilesMode = false, this._suspended = false, this._tileFetcher = null, this._fetchDataInfoPromise = null, this._fetchDataInfoAbortController = null, this._lifeCycleAbortController = new AbortController();
  }
  initialize() {
    this._updatingHandles.add(() => this.displayFeatureLimit, (e12) => this._updatingHandles.addPromise(this._updateSnapshotLimit(e12, null, this._lifeCycleAbortController.signal))), this._updatingHandles.add(() => this.mode, () => this._modeChanged(), P), this._updatingHandles.add(() => this.mode, (e12, t13) => {
      "tiles" === e12 && "snapshot" === t13 && (this._forceTilesMode = true);
    }, P), this.addResolvingPromise(Promise.resolve().then(() => this._verifyCapabilities()).then(() => this._updatingHandles.addPromise(this._fetchServiceDataInfo())).then(() => this._initializeTileFetcher()));
  }
  _verifyCapabilities() {
    var _a;
    const e12 = this.layerView.layer;
    if ("ogc-feature" !== e12.type && !((_a = O2(e12)) == null ? void 0 : _a.operations.supportsQuery))
      throw new s("graphicscontroller:query-capability-required", "Service requires query capabilities to be used as a feature layer", { layer: e12 });
  }
  destroy() {
    this._cancelFetchServiceDataInfo(), this._tileFetcher = u(this._tileFetcher), this._tilesHandle = l(this._tilesHandle), this._lifeCycleAbortController = e2(this._lifeCycleAbortController), this._updatingHandles.destroy(), this._set("_updatingHandles", null);
  }
  suspend() {
    this._suspended || (this._suspended = true, null != this._tileFetcher && this._tileFetcher.suspend());
  }
  resume() {
    this._suspended && (this._suspended = false, null != this._tileFetcher && this._tileFetcher.resume());
  }
  restart() {
    const e12 = () => {
      null != this._tileFetcher && this._tileFetcher.restart();
    };
    this._updatingHandles.addPromise(this._fetchServiceDataInfo().then(e12, e12));
  }
  refetch() {
    this._refetch({ resetForceTilesMode: false });
  }
  getMissingAttributesForFeature(e12) {
    var _a;
    return (_a = this._tileFetcher) == null ? void 0 : _a.getMissingAttributesForFeature(e12);
  }
  _refetch(e12) {
    const t13 = () => {
      null != this._tileFetcher && (e12.resetForceTilesMode && (this._forceTilesMode = false), this._tileFetcher.refetch());
    };
    this._updatingHandles.addPromise(this._fetchServiceDataInfo().then(t13, t13));
  }
  _initializeTileFetcher() {
    const e12 = this.layerView.view;
    if (!e12)
      return;
    const t13 = w(() => {
      var _a;
      return (_a = e12.featureTiles) == null ? void 0 : _a.tilingScheme;
    }, this._lifeCycleAbortController.signal);
    this._updatingHandles.addPromise(t13), t13.then(() => {
      const { layerView: e13, tileDescriptors: t14 } = this, i7 = e13.layer, r10 = new j2({ context: this.context, filterExtent: this.extent, tileDescriptors: t14, features: this.graphics });
      this._tileFetcher = r10, this._suspended ? r10.suspend() : r10.resume();
      const s9 = this.layerView.view;
      s9 && this.addHandles(d2(() => s9.quality, (e14) => r10.memoryFactor = e14, A));
      const a7 = "polygon" === this.context.geometryType ? "polygonLodFactor" : "polyline" === this.context.geometryType ? "polylineLodFactor" : null;
      a7 && this.addHandles(d2(() => {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.layerView.view) == null ? void 0 : _a.qualitySettings) == null ? void 0 : _b.graphics3D) == null ? void 0 : _c[a7];
      }, (e14) => r10.lodFactor = e14 || 1, P));
      const o9 = (e14) => {
        r10.maximumNumberOfFeatures = e14, r10.useTileCount = this.serviceDataCount > e14;
      }, l7 = (e14) => {
        r10.useTileCount = e14 > this.maximumNumberOfFeatures;
      };
      "ogc-feature" !== i7.type && this._updatingHandles.add(() => i7.createQueryVersion, () => this._dataFilterChanged()), this._updatingHandles.add(() => e13.availableFields, (e14, t15) => this._availableFieldsChanged(t15, e14)), this._updatingHandles.add(() => e13.requiredFields, (e14, t15) => this._requiredFieldsChanged(t15, e14)), "customParameters" in i7 && this._updatingHandles.add(() => i7.customParameters, () => this.restart()), this.addHandles([i7.on("apply-edits", (e14) => this._applyEdits(e14)), d2(() => this.extent, (e14) => r10.filterExtent = e14, C), d2(() => this.tileDescriptors, (e14) => r10.tileDescriptors = e14, C), d2(() => this.maximumNumberOfFeatures, o9, A), d2(() => this.serviceDataCount, l7, A), d2(() => t8.FEATURE_TILE_FETCH_SHOW_TILES, (e14) => {
        e14 && r10 && !r10.debugger ? (r10.debugger = new m8(r10, s9.featureTiles.tilingScheme.toTileInfo(), s9), r10.debugger.update()) : !e14 && this._tileFetcher && r10.debugger && (r10.debugger.destroy(), r10.debugger = null);
      }, A)]), this._supportsExceedsLimitQuery || this._updatingHandles.add(() => this.maxTotalSnapshotVertices, () => this._updatingHandles.addPromise(this._updateSnapshotLimit(this.displayFeatureLimit, null, this._lifeCycleAbortController.signal)));
    }).catch(() => {
    });
  }
  _modeChanged() {
    switch (this.mode) {
      case "tiles":
        this._tilesHandle || (this._tilesHandle = this.layerView.view.featureTiles.addClient());
        break;
      default:
        n2.getLogger(this).warn("Unhandled feature layer mode " + this.mode);
      case "snapshot":
        null != this._tilesHandle && (this._tilesHandle.remove(), this._tilesHandle = null);
    }
  }
  _dataFilterChanged() {
    this._set("maxTotalSnapshotVertices", 0), this.notifyChange("maxTotalSnapshotVertices"), this._refetch({ resetForceTilesMode: true });
  }
  _applyEdits(e12) {
    null != this._tileFetcher && this._tileFetcher.applyEdits(e12).then((e13) => {
      if (e13) {
        if (!this._lifeCycleAbortController)
          throw u2();
        e13.exceededTransferLimit ? this.layerView.layer.refresh() : (e13.deletedFeatures.length || e13.updatedFeatures.length || e13.addedFeatures.length) && this._updatingHandles.addPromise(this._updateServiceDataExtent(this._lifeCycleAbortController.signal));
      }
    }).catch((e13) => {
      if (!b(e13))
        throw e13;
    });
  }
  _availableFieldsChanged(e12, t13) {
    null != this._tileFetcher && A4(this._tileFetcher.availableFields, t13) && this._refetch({ resetForceTilesMode: false });
  }
  _requiredFieldsChanged(e12, t13) {
    null != this._tileFetcher && A4(this._tileFetcher.availableFields, t13) && this.restart();
  }
  _createVertexLimitExceededQuery(e12) {
    var _a;
    const t13 = this.layerView.layer, i7 = t13.createQuery();
    return i7.returnGeometry = false, i7.outStatistics = [new m2({ statisticType: "exceedslimit", maxVertexCount: e12, outStatisticFieldName: "exceedslimit", maxPointCount: 1e8, maxRecordCount: 1e8 })], ((_a = t13.capabilities) == null ? void 0 : _a.query.supportsCacheHint) && (i7.cacheHint = true), i7;
  }
  _createDataInfoQuery() {
    var _a;
    const e12 = this.layerView.layer, t13 = e12.createQuery();
    return t13.returnGeometry = false, t13.outSpatialReference = this.layerView.view.spatialReference, ((_a = e12.capabilities) == null ? void 0 : _a.query.supportsCacheHint) && (t13.cacheHint = true), t13;
  }
  _fullExtentIsAccurate() {
    const e12 = this.layerView.layer;
    if ("definitionExpression" in e12 && e12.definitionExpression)
      return false;
    switch (e12.type) {
      case "feature":
      case "oriented-imagery":
        return w3(e12.url);
      case "csv":
      case "geojson":
      case "ogc-feature":
      case "wfs":
        return true;
      default:
        return;
    }
  }
  async _updateServiceDataExtent(e12) {
    try {
      await this._tryUpdateServiceDataExtent(e12);
    } catch (t13) {
      b(t13) || this._set("serviceDataExtent", a(this.layerView.fullExtentInLocalViewSpatialReference));
    }
  }
  async _tryUpdateServiceDataExtent(e12) {
    var _a;
    const t13 = this.layerView, i7 = t13.layer, r10 = ((_a = i7.capabilities) == null ? void 0 : _a.query.supportsExtent) ?? false, s9 = a(t13.fullExtentInLocalViewSpatialReference), o9 = i7.fullExtent, l7 = this._fullExtentIsAccurate(), n11 = this.serviceDataCount;
    if (r10 && n11 <= q2.maxFeatureCountForExtent && (!s9 || !l7) && "queryExtent" in i7) {
      const t14 = this._createDataInfoQuery(), r11 = await i7.queryExtent(t14, { timeout: q2.queryExtentTimeout, signal: e12 });
      this._set("serviceDataExtent", r11.extent);
    } else if (s9)
      this._set("serviceDataExtent", s9);
    else if (null != o9) {
      const r11 = "portalItem" in i7 ? i7.portalItem : null, s10 = await a5(o9, t13.view.spatialReference, r11, e12);
      this._set("serviceDataExtent", s10);
    } else
      this._set("serviceDataExtent", null);
  }
  async _updateServiceDataCount(e12) {
    const t13 = this.layerView.layer;
    if (!("queryFeatureCount" in t13) || !has("featurelayer-snapshot-enabled"))
      return void this._set("serviceDataCount", q2.noServiceDataCount);
    const r10 = await _(t13.queryFeatureCount(this._createDataInfoQuery(), { timeout: q2.queryStatisticsTimeout, signal: e12 }));
    if (true === r10.ok)
      this._set("serviceDataCount", r10.value);
    else {
      if (b(r10.error))
        throw r10.error;
      this._set("serviceDataCount", q2.noServiceDataCount);
    }
  }
  get _supportsExceedsLimitQuery() {
    const e12 = this.layerView.layer;
    return null != e12.capabilities && e12.capabilities.operations && e12.capabilities.operations.supportsExceedsLimitStatistics;
  }
  get _minimumNumberOfVerticesForGeometry() {
    switch (this.layerView.layer.geometryType) {
      case "point":
      case "multipoint":
        return 1;
      case "polygon":
        return 4;
      case "polyline":
        return 2;
      case "multipatch":
      case "mesh":
        return 3;
      default:
        return 0;
    }
  }
  async _updateSnapshotLimit(e12, t13, r10) {
    if (null == (e12 == null ? void 0 : e12.averageSymbolComplexity))
      return void (this._snapshotLimitExceeded = false);
    const { maximumTotalNumberOfVertices: s9, averageSymbolComplexity: a7 } = e12, { verticesPerFeature: o9, verticesPerCoordinate: l7 } = a7, n11 = o9 <= 0, u9 = this._minimumNumberOfVerticesForGeometry > 1;
    if (!n11 && !u9)
      return void (this._snapshotLimitExceeded = false);
    0 !== o9 && null != t13 && await t13;
    const h7 = Math.min(s9, I7), c10 = this.serviceDataCount, p4 = c10 !== q2.noServiceDataCount;
    let m9 = p4 ? Math.ceil((h7 - c10 * o9) / (l7 || 1)) : Math.ceil(h7 / (l7 || 1));
    if (u9 && (m9 = Math.min(m9, L3)), p4 && this._minimumNumberOfVerticesForGeometry * c10 > m9)
      return void (this._snapshotLimitExceeded = true);
    if (!this._supportsExceedsLimitQuery || !has("featurelayer-snapshot-enabled"))
      return void (this._snapshotLimitExceeded = this.maxTotalSnapshotVertices > m9);
    const f7 = await _(this.layerView.layer.queryFeatures(this._createVertexLimitExceededQuery(m9), { timeout: q2.queryStatisticsTimeout, signal: r10 }));
    if (false === f7.ok) {
      if (b(f7.error))
        throw f7.error;
      return void (this._snapshotLimitExceeded = false);
    }
    const y3 = f7.value.features[0];
    this._snapshotLimitExceeded = !!(y3 == null ? void 0 : y3.attributes) && !!y3.attributes.exceedslimit;
  }
  async _fetchServiceDataInfo() {
    this._cancelFetchServiceDataInfo();
    let e12 = new AbortController();
    const t13 = e12.signal, i7 = this._updateServiceDataCount(t13), r10 = Promise.allSettled([i7, this._updateSnapshotLimit(this.displayFeatureLimit, i7, t13)]), s9 = r10.then(() => this._updateServiceDataExtent(t13)).catch((e13) => {
      b(e13) || n2.getLogger(this).error("#fetchServiceDataInfo()", e13);
    }).then(() => {
      s9 === this._fetchDataInfoPromise && (this._fetchDataInfoPromise = null, this._fetchDataInfoAbortController = null), e12 = null;
    });
    return e12 && (this._fetchDataInfoPromise = s9), this._fetchDataInfoAbortController = e12, r10.then(() => {
    }, () => {
    });
  }
  _cancelFetchServiceDataInfo() {
    const e12 = this._fetchDataInfoAbortController;
    e12 && (this._fetchDataInfoAbortController = null, this._fetchDataInfoPromise = null, e12.abort());
  }
  get performanceInfo() {
    var _a, _b, _c, _d;
    return { storedFeatures: ((_a = this._tileFetcher) == null ? void 0 : _a.storedFeatures) ?? 0, totalFeatures: ((_b = this._tileFetcher) == null ? void 0 : _b.totalFeatures) ?? 0, totalVertices: ((_c = this._tileFetcher) == null ? void 0 : _c.totalVertices) ?? 0, missingTiles: ((_d = this._tileFetcher) == null ? void 0 : _d.missingTiles) ?? 0 };
  }
};
e([y2({ readOnly: true })], T2.prototype, "type", void 0), e([y2({ constructOnly: true })], T2.prototype, "graphics", void 0), e([y2({ constructOnly: true })], T2.prototype, "layerView", void 0), e([y2({ constructOnly: true })], T2.prototype, "context", void 0), e([y2({ readOnly: true })], T2.prototype, "dataUpdating", null), e([y2()], T2.prototype, "extent", null), e([y2()], T2.prototype, "updating", null), e([y2({ readOnly: true })], T2.prototype, "_updatingHandles", void 0), e([y2()], T2.prototype, "updatingTotal", null), e([y2()], T2.prototype, "updatingRemaining", null), e([y2()], T2.prototype, "expectedFeatureDiff", null), e([y2()], T2.prototype, "memoryForUnusedFeatures", null), e([y2()], T2.prototype, "maximumNumberOfFeaturesExceeded", null), e([y2({ readOnly: true })], T2.prototype, "serviceDataExtent", void 0), e([y2({ readOnly: true })], T2.prototype, "serviceDataCount", void 0), e([y2()], T2.prototype, "_snapshotLimitExceeded", void 0), e([y2()], T2.prototype, "displayFeatureLimit", void 0), e([y2({ type: Number })], T2.prototype, "maximumNumberOfFeatures", null), e([y2({ readOnly: true })], T2.prototype, "hasAllFeatures", null), e([y2({ readOnly: true })], T2.prototype, "hasAllFeaturesInView", null), e([y2({ readOnly: true })], T2.prototype, "hasFullGeometries", null), e([y2()], T2.prototype, "_forceTilesMode", void 0), e([y2({ readOnly: true })], T2.prototype, "mode", null), e([y2({ readOnly: true })], T2.prototype, "maxTotalSnapshotVertices", null), e([y2({ readOnly: true })], T2.prototype, "tileDescriptors", null), e([y2()], T2.prototype, "_tileFetcher", void 0), e([y2()], T2.prototype, "_fetchDataInfoPromise", void 0), T2 = e([a3("esri.layers.graphics.controllers.FeatureTileController3D")], T2);
var V3 = 1e4;
var I7 = 1e6;
var H4 = 12e3;
var O5 = 1e4;
var L3 = 5e6;
function A4(e12, t13) {
  if (!t13)
    return false;
  for (const i7 of t13)
    if (!e12.has(i7))
      return true;
  return false;
}
var q2;
!function(e12) {
  function t13() {
    e12.maxFeatureCountForExtent = V3, e12.queryStatisticsTimeout = H4, e12.queryExtentTimeout = O5;
  }
  e12.noServiceDataCount = 1 / 0, e12.maxSnapshotMinScaleFactor = 5, e12.reset = t13;
}(q2 || (q2 = {})), q2.reset();

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/HeatmapTechnique.js
var h5 = class extends n8 {
  constructor() {
    super(...arguments), this.colorRamp = null, this.densityMap = null, this.searchRadius = 1, this.fieldTotal = 0, this.minDensity = 0, this.maxDensity = 100;
  }
};
var d9 = class _d extends r4 {
  constructor(e12, r10) {
    super(e12, r10, () => this.destroy());
  }
  initializeProgram(e12) {
    return new r5(e12.rctx, _d.shader.get().build(this.configuration), O3);
  }
  initializePipeline() {
    return S2({ blending: c5, colorWrite: _3, depthTest: null, depthWrite: null });
  }
  get primitiveType() {
    return E2.TRIANGLE_STRIP;
  }
};
d9.shader = new t7(a6, () => import("./Heatmap.glsl-GJX6GKJH.js"));
var f5 = class extends t9 {
  constructor() {
    super(...arguments), this.usesHalfFloat = false;
  }
};
e([r6()], f5.prototype, "usesHalfFloat", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DrapedHeatmapRenderer.js
var x4 = class extends R2 {
  constructor(t13) {
    super(t13), this.pixelRatio = 1, this._colorRampData = new Uint8ClampedArray(4), this.type = "draped-heatmap", this._heatmapParameters = new h5();
    const e12 = new e9();
    e12.pixelFormat = t13.pixelFormat, e12.internalFormat = t13.internalFormat, e12.dataType = t13.dataType, e12.samplingMode = t13.samplingMode, e12.wrapMode = D.CLAMP_TO_EDGE;
    const r10 = t13.rendererContext.rctx;
    this._densityMap = new x2(r10, e12), this._quad = i5(r10);
    const a7 = new f5();
    a7.usesHalfFloat = t13.dataType !== U2.FLOAT, this._technique = new d9({ rctx: r10, viewingMode: l2.Local }, a7);
  }
  initialize() {
    const t13 = this._colorRampData, e12 = new e9(t13.length / 4, 1);
    e12.wrapMode = D.CLAMP_TO_EDGE, this._colorRamp = new m4(this.rctx, e12, t13), this._heatmapParameters.densityMap = this._densityMap.colorTexture, this.addHandles(d2(() => [this.colorRampData, this.minDensity, this.maxDensity, this.fieldTotal, this.pixelRatio, this.searchRadius], () => this.rendererContext.notifyContentChanged()));
  }
  destroy() {
    this._technique = t2(this._technique), this._densityMap = r(this._densityMap), this._quad = r(this._quad), this._colorRamp = r(this._colorRamp);
  }
  get searchRadius() {
    return this._heatmapParameters.searchRadius;
  }
  set searchRadius(t13) {
    t13 !== this._heatmapParameters.searchRadius && (this._heatmapParameters.searchRadius = t13, this.notifyChange("searchRadius"));
  }
  get minDensity() {
    return this._heatmapParameters.minDensity;
  }
  set minDensity(t13) {
    t13 !== this._heatmapParameters.minDensity && (this._heatmapParameters.minDensity = t13, this.notifyChange("minDensity"));
  }
  get maxDensity() {
    return this._heatmapParameters.maxDensity;
  }
  set maxDensity(t13) {
    t13 !== this._heatmapParameters.maxDensity && (this._heatmapParameters.maxDensity = t13, this.notifyChange("maxDensity"));
  }
  get fieldTotal() {
    return this._heatmapParameters.fieldTotal;
  }
  set fieldTotal(t13) {
    this._heatmapParameters.fieldTotal = t13, this.notifyChange("fieldTotal");
  }
  get colorRampData() {
    return this._colorRampData;
  }
  set colorRampData(t13) {
    const { colorRamp: e12 } = this._heatmapParameters;
    if (null != e12 && t13 !== this._colorRampData) {
      const r10 = e12.descriptor.width, a7 = t13.length / 4;
      a7 !== r10 && e12.resize(a7, 1), e12.setData(t13);
    }
    this._colorRampData = t13;
  }
  get _colorRamp() {
    return this._heatmapParameters.colorRamp;
  }
  set _colorRamp(t13) {
    this._heatmapParameters.colorRamp = t13;
  }
  get hasHighlights() {
    return false;
  }
  get hasWater() {
    return false;
  }
  get rendersOccludedDraped() {
    return false;
  }
  render(t13) {
    const e12 = this._sortedMaterialRenderers;
    if (0 === e12.length)
      return;
    const r10 = this.rctx.getBoundFramebufferObject(), a7 = this.rctx.getViewport(), { pixelRatio: i7 } = this, s9 = Math.ceil(a7.width * i7), o9 = Math.ceil(a7.height * i7);
    this._densityMap.resize(s9, o9), this.rctx.bindFramebuffer(this._densityMap), this.rctx.setViewport(0, 0, s9, o9), this.rctx.clear(_2.COLOR_BUFFER_BIT);
    let n11 = false;
    e12.forAll((e13) => {
      const r11 = e13.prepareTechnique(t13);
      null != r11 && (e13.renderNode(t13, r11), n11 = true);
    }), this.rctx.bindFramebuffer(r10), this.rctx.setViewport(a7.x, a7.y, a7.width, a7.height), n11 && (this.rctx.bindVAO(this._quad), this.rctx.bindTechnique(this._technique, t13.bindParameters, this._heatmapParameters), this.rctx.drawArrays(this._technique.primitiveType, 0, i3(this._quad, "geometry")));
  }
};
e([y2()], x4.prototype, "searchRadius", null), e([y2()], x4.prototype, "minDensity", null), e([y2()], x4.prototype, "maxDensity", null), e([y2()], x4.prototype, "fieldTotal", null), e([y2()], x4.prototype, "pixelRatio", void 0), e([y2()], x4.prototype, "colorRampData", null), e([y2({ constructOnly: true })], x4.prototype, "dataType", void 0), e([y2({ constructOnly: true })], x4.prototype, "samplingMode", void 0), e([y2({ constructOnly: true })], x4.prototype, "pixelFormat", void 0), e([y2({ constructOnly: true })], x4.prototype, "internalFormat", void 0), e([y2()], x4.prototype, "_colorRampData", void 0), x4 = e([a3("esri.views.3d.webgl-engine.lib.DrapedHeatmapRenderer")], x4);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/HeatmapDensityTechnique.js
var d10 = class extends u5 {
  constructor() {
    super(...arguments), this.searchRadius = 128, this.resolutionForScale = 0;
  }
};
var f6 = class _f extends r4 {
  initializeProgram(e12) {
    return new r5(e12.rctx, _f.shader.get().build(this.configuration), O3);
  }
  initializePipeline() {
    return S2({ blending: s4(R.ONE, R.ONE, T.ADD), colorWrite: _3, depthTest: null, depthWrite: null });
  }
  destroy() {
    super.destroy();
  }
};
f6.shader = new t7(s7, () => import("./HeatmapDensity.glsl-KQZNDX6E.js"));
var b5 = class extends t9 {
  constructor() {
    super(...arguments), this.isAttributeDriven = false, this.usesHalfFloat = false;
  }
};
e([r6()], b5.prototype, "isAttributeDriven", void 0), e([r6()], b5.prototype, "usesHalfFloat", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/HeatmapDensityMaterial.js
var h6 = 2;
var b6 = class extends d10 {
  constructor() {
    super(...arguments), this.isAttributeDriven = false, this.usesHalfFloats = false;
  }
};
var T3 = class extends c4 {
  constructor(t13) {
    super(t13, new b6()), this.produces = /* @__PURE__ */ new Map([[A2.DRAPED_MATERIAL, (t14) => t14 === o3.Color]]), this._configuration = new b5();
  }
  getConfiguration() {
    return this._configuration.isAttributeDriven = this.parameters.isAttributeDriven, this._configuration.usesHalfFloat = this.parameters.usesHalfFloats, this._configuration;
  }
  createGLMaterial(t13) {
    return new d11(t13);
  }
  intersect() {
  }
  intersectDraped(r10, s9, i7, a7, o9, n11) {
    const l7 = r10.attributes.get(e7.POSITION), { parameters: c10 } = this, { searchRadius: f7 } = c10, { screenToWorldRatio: m9 } = r10, p4 = f7 * m9 + h6 * m9, b8 = p4 * p4, T4 = l7.data.length / l7.size;
    for (let u9 = 0; u9 < T4; u9++) {
      const r11 = u9 * l7.size, s10 = o4(E5, l7.data[r11], l7.data[r11 + 1]);
      b3(s10, a7) < b8 && o9(n11.dist, n11.normal, -1, false);
    }
  }
  createBufferWriter() {
    return new g3(this.parameters.isAttributeDriven ? I8 : A5);
  }
};
var d11 = class extends t6 {
  beginSlot(t13) {
    return this.ensureTechnique(f6, t13);
  }
};
var g3 = class {
  constructor(t13) {
    this.vertexBufferLayout = t13;
  }
  elementCount(t13) {
    return t13.attributes.get(e7.POSITION).indices.length * v3;
  }
  write(t13, e12, r10, s9, i7) {
    b4(r10.attributes.get(e7.POSITION), t13, s9.position, i7, v3);
    const a7 = r10.attributes.get(e7.POSITION).indices.length, o9 = s9.uv0;
    let n11 = i7;
    for (let u9 = 0; u9 < a7; ++u9)
      o9.setValues(n11++, -1, -1), o9.setValues(n11++, 1, -1), o9.setValues(n11++, 1, 1), o9.setValues(n11++, 1, 1), o9.setValues(n11++, -1, 1), o9.setValues(n11++, -1, -1);
    const f7 = e7.FEATUREATTRIBUTE in s9 ? s9.featureAttribute : null;
    f7 && d7(r10.attributes.get(e7.FEATUREATTRIBUTE), f7, i7, v3);
  }
};
var A5 = H().vec3f(e7.POSITION).vec2f(e7.UV0);
var I8 = A5.clone().f32(e7.FEATUREATTRIBUTE);
var v3 = 6;
var E5 = n7();

// node_modules/@arcgis/core/views/3d/layers/support/HeatmapFeatureProcessor.js
var $2 = 112;
var q3 = class extends S {
  constructor(e12) {
    super(e12), this.type = "heatmap", this.preferredUpdatePolicy = C2.ASYNC, this.dataExtent = null, this.drapeSourceType = e10.Features, this._renderGeometries = /* @__PURE__ */ new Map(), this._fieldTotal = 0, this._drapeSourceRenderer = null, this._dataType = U2.HALF_FLOAT, this._pixelFormat = G.RGBA, this._updatingHandles = new h3(), this.initializePromise = Promise.resolve();
  }
  initialize() {
    this._featureStore = new m3({ geometryType: "esriGeometryPoint", hasZ: this.hasZ, hasM: this.hasM });
    const { dataType: e12, samplingMode: t13, pixelFormat: r10, internalFormat: i7 } = n9(this._renderView.renderingContext, n2.getLogger(this));
    this._dataType = e12, this._pixelFormat = r10;
    const a7 = e12 !== U2.FLOAT;
    this._drapeSourceRenderer = this.view.basemapTerrain.overlayManager.registerDrapeSource(this, x4, { ...this._rendererParameters, dataType: e12, samplingMode: t13, pixelFormat: r10, internalFormat: i7 }), this._material = new T3({ usesHalfFloats: a7 }), this._materialWithField = new T3({ usesHalfFloats: a7, isAttributeDriven: true }), this._filterVisibility = new f4({ context: { layerView: this.owner, featureStore: this.featureStore, getFeatureCount: () => this._loadedPointGraphics.length, setAllFeaturesVisibility: (e13) => this._setAllFeaturesVisibility(e13), clearFeaturesVisibility: () => this._setAllFeaturesVisibility(true), updateFeatureVisibilities: (e13) => this._updateFeatureVisibilities(e13) } }), this._updatingHandles.addOnCollectionChange(() => this._loadedPointGraphics, (e13) => this._onLoadedFeaturesChange(e13), P), this._updatingHandles.addWhen(() => this._materialParameters, (e13) => this._forEachMaterial((t14) => t14.setParameters(e13)), P), this._updatingHandles.add(() => this._rendererParameters, (e13) => this._drapeSourceRenderer.set(e13)), this._updatingHandles.add(() => this._heatmapRendererField, () => {
      this._recreate();
    }, C), this._updatingHandles.add(() => ({ fieldName: this._heatmapRendererFieldName, numeric: this._heatmapRendererFieldIsNumeric }), ({ fieldName: e13, numeric: t14 }) => {
      if (null != e13 && t14) {
        let t15 = 0;
        this._featureStore.forEach((r11) => t15 += r11.attributes[e13] ?? 0), this._fieldTotal = t15;
      } else
        this._fieldTotal = this._featureStore.numFeatures;
    }, P), this.addHandles([d2(() => ({ fieldName: this._heatmapRendererFieldName, field: this._heatmapRendererField }), ({ fieldName: e13, field: t14 }) => {
      e13 && !t14 && n2.getLogger(this).warn(`Heatmap renderer field '${e13}' for layer '${this.layer.title ?? this.layer.id}' not found`);
    }), d2(() => ({ field: this._heatmapRendererField, numeric: this._heatmapRendererFieldIsNumeric }), ({ field: e13, numeric: t14 }) => {
      null == e13 || t14 || n2.getLogger(this).warn(`Heatmap renderer field '${e13.name}' for layer '${this.layer.title ?? this.layer.id}' does not contain numeric values and cannot be used to drive the heatmap density`);
    }), e3(() => this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this))]);
  }
  destroy() {
    this._renderGeometries.clear(), this._material = null, this._materialWithField = null, this._featureStore.clear(), this._featureStore = null, this._updatingHandles.destroy();
  }
  get layer() {
    return this.owner.layer;
  }
  get featureStore() {
    return this._featureStore;
  }
  get updating() {
    return this._updatingHandles.updating || this.filterVisibility.updating;
  }
  get updatingRemaining() {
    return 0;
  }
  get suspendInfo() {
    return {};
  }
  get legendEnabled() {
    return true;
  }
  get filterVisibility() {
    return this._filterVisibility;
  }
  get displayFeatureLimit() {
    var _a, _b, _c, _d;
    const e12 = ((_b = (_a = this.owner) == null ? void 0 : _a.view) == null ? void 0 : _b.quality) ?? 1, t13 = (_d = (_c = this.owner) == null ? void 0 : _c.view) == null ? void 0 : _d.qualitySettings, r10 = t13 ? Math.ceil(t13.heatmap.maxTotalNumberOfFeatures * e12) : 0;
    return new e11(r10 * 6, r10);
  }
  get hasZ() {
    return "hasZ" in this.layer && this.layer.hasZ;
  }
  get hasM() {
    return "hasM" in this.layer && this.layer.hasM;
  }
  get view() {
    return this.owner.view;
  }
  get fullOpacity() {
    return this.owner.fullOpacity;
  }
  get updatePolicy() {
    return this.owner.updatePolicy;
  }
  get scaleVisibilitySuspended() {
    if (!this._isScaleRangeActive)
      return false;
    const { minScale: e12, maxScale: t13 } = this.layer.effectiveScaleRange, { scale: r10 } = this.view;
    return !t10(r10, e12 ?? 0, t13 ?? 0);
  }
  get usedMemory() {
    var _a, _b;
    const e12 = this.usedMemoryPerFeature * this._featureStore.numFeatures, t13 = this._pixelFormat === G.RED ? 1 : 4, r10 = this._dataType === U2.FLOAT ? 4 : 2, i7 = Math.ceil((((_b = (_a = this._overlayRenderer) == null ? void 0 : _a.overlays[0]) == null ? void 0 : _b.resolution) ?? 0) * this._densityMapPixelRatio) ?? 0;
    return i7 * i7 * t13 * r10 + e12;
  }
  get usedMemoryPerFeature() {
    const e12 = this._loadedPointGraphics.find(() => true);
    if (null == e12)
      return 0;
    const t13 = t(e12), r10 = n(), o9 = 6;
    return o9 * c([0, 0, 0], r10) + o9 * c([0, 0], r10) + (this._heatmapRendererFieldIsNumeric ? o9 * r10 : 0) + t13;
  }
  get loadedFeatures() {
    return this._featureStore.numFeatures;
  }
  get unprocessedMemoryEstimate() {
    return 0;
  }
  get performanceInfo() {
    return new s5(this._visibleFeatures, 0, 0);
  }
  get renderer() {
    return this._heatmapRenderer;
  }
  get _overlayRenderer() {
    return this.view.basemapTerrain.overlayManager.renderer;
  }
  get _overlaySpatialReference() {
    return this._overlayRenderer.spatialReference;
  }
  get _rendererParameters() {
    return { ...this._radiusParameter, ...this._densityParameters, ...this._colorRampParameter, ...this._pixelRatioParameter };
  }
  get _materialParameters() {
    return { ...this._radiusParameter, ...this._resolutionForScaleParameter };
  }
  get _densityParameters() {
    const e12 = this._heatmapRenderer;
    if (null == e12)
      return null;
    const { minDensity: t13, maxDensity: r10 } = e12;
    return { minDensity: t13, maxDensity: r10, fieldTotal: this._fieldTotal };
  }
  get _radiusParameter() {
    const e12 = this._heatmapRenderer;
    return e12 ? { searchRadius: u4(this._clampSearchRadius(e12.radius)) } : null;
  }
  get _resolutionForScaleParameter() {
    const e12 = this._heatmapRenderer;
    if (!e12)
      return null;
    const { referenceScale: t13 } = e12;
    return { resolutionForScale: 0 === t13 ? 0 : o6(t13, this.view.spatialReference) };
  }
  get _colorRampParameter() {
    const e12 = this._heatmapRenderer;
    return e12 ? { colorRampData: f2(e12.colorStops) } : null;
  }
  get _pixelRatioParameter() {
    return { pixelRatio: this._densityMapPixelRatio };
  }
  get _densityMapPixelRatio() {
    var _a, _b;
    return ((_b = (_a = this.owner) == null ? void 0 : _a.view) == null ? void 0 : _b.qualitySettings.heatmap.pixelRatio) ?? 1;
  }
  get _renderView() {
    return this.view._stage.renderView;
  }
  get _featuresArePoints() {
    return "point" === this.layer.geometryType;
  }
  get _loadedPointGraphics() {
    return this.owner.loadedGraphics;
  }
  get _heatmapRenderer() {
    const e12 = this.layer.renderer;
    return "heatmap" === (e12 == null ? void 0 : e12.type) ? e12 : null;
  }
  get _heatmapRendererFieldName() {
    var _a;
    return (_a = this._heatmapRenderer) == null ? void 0 : _a.field;
  }
  get _heatmapRendererField() {
    const e12 = this._heatmapRendererFieldName;
    return null != e12 ? this.layer.fieldsIndex.get(e12) : null;
  }
  get _heatmapRendererFieldIsNumeric() {
    const e12 = this._heatmapRendererField;
    return null != e12 && pe(e12);
  }
  get _isScaleRangeActive() {
    const { layer: e12 } = this;
    if (!("effectiveScaleRange" in e12))
      return false;
    const { minScale: t13, maxScale: r10 } = e12.effectiveScaleRange;
    return u6(t13, r10);
  }
  get _visibleFeatures() {
    let e12 = 0;
    return this._renderGeometries.forEach((t13) => {
      t13.visible && ++e12;
    }), e12;
  }
  async whenGraphicBounds() {
    return null;
  }
  computeAttachmentOrigin() {
    return null;
  }
  highlight() {
    return e3();
  }
  maskOccludee() {
    return e3();
  }
  setObjectIdVisibility() {
  }
  refreshFilter() {
    this.filterVisibility.reapply();
  }
  _onLoadedFeaturesChange(e12) {
    if (!this._featuresArePoints)
      return;
    const { objectIdField: t13 } = this.layer;
    this._featureStore.removeManyById(e12.removed.map((e13) => I4(e13, t13))), this._featureStore.addMany(e12.added.map((e13) => {
      const { attributes: r10, centroid: i8, geometry: a8 } = e13, s10 = new t3(O(new e5(), a8), r10, i8 ? O(new e5(), i8) : null, I4(e13, t13));
      return s10.displayId = e13.uid, s10;
    }));
    const i7 = e12.added, a7 = e12.removed;
    this._fieldTotal += this._computeFieldTotalChange(i7, a7);
    const s9 = a7.map(({ uid: e13 }) => {
      const t14 = this._renderGeometries.get(e13);
      return this._renderGeometries.delete(e13), t14;
    }).filter(k), o9 = i7.map((e13) => {
      const t14 = this._pointGraphicToRenderGeometry(e13);
      return this._renderGeometries.set(e13.uid, t14), t14;
    });
    s9.length > 0 && this._drapeSourceRenderer.removeGeometries(s9, E3.REMOVE), o9.length > 0 && this._drapeSourceRenderer.addGeometries(o9, E3.ADD), (o9.length > 0 || s9.length > 0) && (this.filterVisibility.reapply(), this._renderView.requestRender());
  }
  _recreate() {
    if (!this._loadedPointGraphics)
      return;
    const e12 = this._loadedPointGraphics.toArray();
    this._onLoadedFeaturesChange({ added: e12, removed: e12 });
  }
  _pointGraphicToRenderGeometry(e12) {
    const t13 = this._heatmapRendererFieldName, r10 = null != t13 ? this._materialWithField : this._material, i7 = n5();
    c3(e12.geometry, i7, this._overlaySpatialReference), i7[2] = te;
    const a7 = l3(1), s9 = [[e7.POSITION, new t4(i7, a7, i7.length)]], o9 = this._heatmapRendererFieldIsNumeric;
    null != t13 && s9.push([e7.FEATUREATTRIBUTE, new t4([o9 ? e12.attributes[t13] ?? 0 : 0], a7, 1)]);
    const n11 = new m5(new I2(r10, s9, null, e8.Point), { layerUid: this.layer.uid, graphicUid: e12.uid });
    return n11.visible = this.filterVisibility.defaultVisibility, n11;
  }
  _forEachMaterial(e12) {
    e12(this._material), e12(this._materialWithField);
  }
  _computeFieldTotalChange(e12, t13) {
    if (null == this._heatmapRendererFieldName || !this._heatmapRendererFieldIsNumeric)
      return e12.length - t13.length;
    const r10 = this._heatmapRendererFieldName, i7 = (e13, t14) => e13 + (t14.attributes[r10] ?? 0);
    return e12.reduce(i7, 0) - t13.reduce(i7, 0);
  }
  _clampSearchRadius(e12) {
    return e12 > $2 && n2.getLogger(this).warnOnce(`SceneView supports a maximum radius of ${$2} pt for HeatmapRenderer.`), Math.min(e12, $2);
  }
  _updateFeatureVisibilities(e12) {
    const t13 = [];
    this._featureStore.forEach(({ objectId: r10, displayId: i7 }) => {
      const a7 = e12(r10), s9 = this._renderGeometries.get(i7);
      s9 && s9.visible !== a7 && (t13.push(s9), s9.visible = a7);
    }), this._drapeSourceRenderer.modifyGeometries(t13, I5.VISIBILITY);
  }
  _setAllFeaturesVisibility(e12) {
    const t13 = [];
    for (const r10 of this._renderGeometries.values())
      r10.visible !== e12 && (t13.push(r10), r10.visible = e12);
    this._drapeSourceRenderer.modifyGeometries(t13, I5.VISIBILITY);
  }
  get test() {
    return { visibleFeatureCount: this._visibleFeatures };
  }
};
e([y2()], q3.prototype, "type", void 0), e([y2({ constructOnly: true })], q3.prototype, "owner", void 0), e([y2()], q3.prototype, "layer", null), e([y2()], q3.prototype, "featureStore", null), e([y2()], q3.prototype, "updating", null), e([y2()], q3.prototype, "updatingRemaining", null), e([y2()], q3.prototype, "suspendInfo", null), e([y2()], q3.prototype, "legendEnabled", null), e([y2()], q3.prototype, "filterVisibility", null), e([y2()], q3.prototype, "displayFeatureLimit", null), e([y2()], q3.prototype, "preferredUpdatePolicy", void 0), e([y2()], q3.prototype, "hasZ", null), e([y2()], q3.prototype, "hasM", null), e([y2()], q3.prototype, "dataExtent", void 0), e([y2()], q3.prototype, "view", null), e([y2()], q3.prototype, "fullOpacity", null), e([y2()], q3.prototype, "updatePolicy", null), e([y2()], q3.prototype, "drapeSourceType", void 0), e([y2()], q3.prototype, "scaleVisibilitySuspended", null), e([y2()], q3.prototype, "renderer", null), e([y2()], q3.prototype, "_featureStore", void 0), e([y2()], q3.prototype, "_filterVisibility", void 0), e([y2()], q3.prototype, "_overlayRenderer", null), e([y2()], q3.prototype, "_overlaySpatialReference", null), e([y2()], q3.prototype, "_rendererParameters", null), e([y2()], q3.prototype, "_materialParameters", null), e([y2()], q3.prototype, "_densityParameters", null), e([y2()], q3.prototype, "_radiusParameter", null), e([y2()], q3.prototype, "_resolutionForScaleParameter", null), e([y2()], q3.prototype, "_colorRampParameter", null), e([y2()], q3.prototype, "_pixelRatioParameter", null), e([y2()], q3.prototype, "_densityMapPixelRatio", null), e([y2()], q3.prototype, "_renderGeometries", void 0), e([y2()], q3.prototype, "_material", void 0), e([y2()], q3.prototype, "_materialWithField", void 0), e([y2()], q3.prototype, "_renderView", null), e([y2()], q3.prototype, "_featuresArePoints", null), e([y2()], q3.prototype, "_loadedPointGraphics", null), e([y2()], q3.prototype, "_heatmapRenderer", null), e([y2()], q3.prototype, "_heatmapRendererFieldName", null), e([y2()], q3.prototype, "_heatmapRendererField", null), e([y2()], q3.prototype, "_heatmapRendererFieldIsNumeric", null), e([y2()], q3.prototype, "_fieldTotal", void 0), e([y2()], q3.prototype, "_drapeSourceRenderer", void 0), e([y2()], q3.prototype, "_isScaleRangeActive", null), q3 = e([a3("esri.views.3d.layers.support.HeatmapFeatureProcessor")], q3);

// node_modules/@arcgis/core/views/3d/layers/FeatureLikeLayerView3D.js
var b7 = (b8) => {
  let v4 = class extends b8 {
    constructor() {
      super(...arguments), this._dataUpdatingState = O6.NONE, this.controller = null, this.updatePolicy = C2.SYNC, this.suspendResumeExtentMode = "computed", this.slicePlaneEnabled = false, this.fullExtentInLocalViewSpatialReference = null, this.suspendResumeExtent = null, this._controllerCreated = false, this.supportsHeightUnitConversion = true, this._pendingController = null, this.queryEngine = null;
    }
    initialize() {
      const e12 = this.layer;
      if ("isTable" in e12 && e12.isTable)
        return void this.addResolvingPromise(Promise.reject(new s("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: e12 })));
      this.addResolvingPromise(this._validateGeometryType()), this._updatingHandles.add(() => this.layer.renderer, (e13) => this._recreateProcessor(e13), P), this.addResolvingPromise((async () => {
        const e13 = await l4(this);
        this.fullExtentInLocalViewSpatialReference = e13, await this._initializeController();
      })()), this._updatingHandles.add(() => this.updatePolicy, (e13) => this.processor.preferredUpdatePolicy = e13);
      const r10 = () => this.processor.featureStore;
      this.queryEngine = new l6({ context: { spatialReference: this.view.spatialReference, layer: this.layer, scheduler: this.view.resourceController.scheduler, get featureStore() {
        return r10();
      }, hasZ: this.hasZ, hasM: this.hasM }, priority: I3.FEATURE_QUERY_ENGINE }), this.notifyChange("updating");
    }
    destroy() {
      this._destroyPendingController(), this.controller = u(this.controller), this._set("processor", u(this.processor)), this.queryEngine = u(this.queryEngine), this.loadedGraphics = null;
    }
    _destroyPendingController() {
      this._pendingController = u(this._pendingController);
    }
    get dataUpdating() {
      return this._dataUpdatingState !== O6.NONE;
    }
    get legendEnabled() {
      var _a;
      return this.canResume() && ((_a = this.processor) == null ? void 0 : _a.legendEnabled);
    }
    get graphics3DProcessor() {
      var _a;
      return "graphics-3d" === ((_a = this.processor) == null ? void 0 : _a.type) ? this.processor : null;
    }
    get heatmapProcessor() {
      var _a;
      return "heatmap" === ((_a = this.processor) == null ? void 0 : _a.type) ? this.processor : null;
    }
    get symbologySnappingSupported() {
      var _a, _b;
      const e12 = (_b = (_a = this.layer) == null ? void 0 : _a.renderer) == null ? void 0 : _b.getSymbols();
      return (e12 == null ? void 0 : e12.some(J2)) ?? false;
    }
    get hasAllFeatures() {
      return !(!this.controller || !("hasAllFeatures" in this.controller)) && this.controller.hasAllFeatures;
    }
    get hasAllFeaturesInView() {
      return !(!this.controller || !("hasAllFeaturesInView" in this.controller)) && this.controller.hasAllFeaturesInView;
    }
    get hasFullGeometries() {
      return !(!this.controller || !("hasFullGeometries" in this.controller)) && this.controller.hasFullGeometries;
    }
    getHit(e12) {
      var _a;
      let t13;
      return (_a = this.loadedGraphics) == null ? void 0 : _a.forEach((r10) => {
        r10.uid === e12 && (t13 = c6(r10, this.layer));
      }), t13 ? { type: "graphic", graphic: t13, layer: t13.layer } : null;
    }
    whenGraphicBounds(e12, t13) {
      var _a;
      return (_a = this.processor) == null ? void 0 : _a.whenGraphicBounds(e12, t13);
    }
    computeAttachmentOrigin(e12, t13) {
      var _a;
      return (_a = this.processor) == null ? void 0 : _a.computeAttachmentOrigin(e12, t13);
    }
    async elevationAlignPointsInFeatures(e12, r10) {
      const s9 = this.graphics3DProcessor;
      if (null == s9)
        throw new s("featurelayerview3d:missing-processor", "A Graphics3D processor is needed to resolve graphics elevation.");
      return m6(this.view, this.layer, (e13) => s9.getGraphics3DGraphicByObjectId(e13), e12, r10);
    }
    async queryForSymbologySnapping(e12, t13) {
      return this.symbologySnappingSupported ? r8(this.graphics3DProcessor, e12, t13) : { candidates: [], sourceCandidateIndices: [] };
    }
    queryFeatures(e12, t13) {
      return this.queryEngine.executeQuery(this._ensureQuery(e12), t13 == null ? void 0 : t13.signal);
    }
    queryObjectIds(e12, t13) {
      return this.queryEngine.executeQueryForIds(this._ensureQuery(e12), t13 == null ? void 0 : t13.signal);
    }
    queryFeatureCount(e12, t13) {
      return this.queryEngine.executeQueryForCount(this._ensureQuery(e12), t13 == null ? void 0 : t13.signal);
    }
    queryExtent(e12, t13) {
      return this.queryEngine.executeQueryForExtent(this._ensureQuery(e12), t13 == null ? void 0 : t13.signal);
    }
    _ensureQuery(e12) {
      return null == e12 ? this.createQuery() : b2.from(e12);
    }
    highlight(e12) {
      return this.processor.highlight(e12, this.layer.objectIdField);
    }
    maskOccludee(e12) {
      return this.processor.maskOccludee(e12);
    }
    canResume() {
      var _a;
      return super.canResume() && !((_a = this.processor) == null ? void 0 : _a.scaleVisibilitySuspended);
    }
    getSuspendInfo() {
      const e12 = super.getSuspendInfo();
      return this.processor ? { ...e12, ...this.processor.suspendInfo } : e12;
    }
    isUpdating() {
      var _a, _b, _c;
      return !(!this.processor || this.processor.destroyed) && !(this._controllerCreated && !((_a = this.controller) == null ? void 0 : _a.updating) && ((_c = (_b = this.view) == null ? void 0 : _b.basemapTerrain) == null ? void 0 : _c.ready) && !this.processor.updating);
    }
    async _initializeController() {
      const e12 = this.createController();
      this._pendingController = e12, this._setupDataUpdating(e12), await e12.when(), this._setControllerWhenInitialized(e12);
    }
    _setupDataUpdating(e12) {
      "dataUpdating" in e12 && this.addHandles([d2(() => e12.dataUpdating, (e13) => {
        e13 && this._dataUpdatingState === O6.NONE ? this._dataUpdatingState = O6.CONTROLLER : e13 || this._dataUpdatingState !== O6.CONTROLLER || (this._dataUpdatingState = O6.NONE);
      }, C), d2(() => {
        var _a;
        return !!((_a = this.graphics3DProcessor) == null ? void 0 : _a.dataUpdating);
      }, (t13) => {
        t13 && this._dataUpdatingState === O6.CONTROLLER ? this._dataUpdatingState = O6.CORE : t13 || this._dataUpdatingState !== O6.CORE || (this._dataUpdatingState = e12.dataUpdating ? O6.CONTROLLER : O6.NONE);
      }, C)]);
    }
    async _setControllerWhenInitialized(e12) {
      try {
        await this.when();
      } catch (t13) {
      }
      this._controllerCreated = true, this.notifyChange("updating"), this.isResolved() && !this.destroyed ? (await w(() => {
        var _a, _b;
        return (_b = (_a = this.view) == null ? void 0 : _a.basemapTerrain) == null ? void 0 : _b.ready;
      }), this.beforeSetController(e12), this._pendingController = null, this.controller = e12, this.loadedGraphics = e12.graphics, this.notifyChange("updating")) : this._destroyPendingController();
    }
    _updateClippingExtent(e12) {
      if (this.clippingExtent = e12, !this.controller)
        return false;
      switch (this.controller.type) {
        case "stream":
          return false;
        case "feature-tile-3d":
          return this.controller.extent = e12, true;
      }
    }
    async _validateGeometryType() {
      switch (this.layer.geometryType) {
        case "multipatch":
        case "multipoint":
          throw new s("featurelayerview3d:unsupported-geometry-type", "Unsupported geometry type ${geometryType}", { geometryType: this.layer.geometryType });
      }
    }
    _recreateProcessor(e12) {
      var _a, _b;
      const t13 = "heatmap" === (e12 == null ? void 0 : e12.type), r10 = "heatmap" === ((_a = this.processor) == null ? void 0 : _a.type), s9 = this.processor;
      if (s9 && t13 === r10)
        return;
      const i7 = t13 ? new q3({ owner: this }) : new P3({ owner: this, frustumVisibilityEnabled: true, scaleVisibilityEnabled: true, filterVisibilityEnabled: true, timeExtentEnabled: true, elevationAlignmentEnabled: true, elevationFeatureExpressionEnabled: true, preferredUpdatePolicy: this.updatePolicy, updateClippingExtent: (e13) => this._updateClippingExtent(e13) });
      this._set("processor", i7), s9 == null ? void 0 : s9.destroy(), (_b = this.queryEngine) == null ? void 0 : _b.clear(), this.addResolvingPromise(i7.initializePromise);
    }
    get performanceInfo() {
      var _a;
      const e12 = this.controller instanceof T2 ? this.controller : null;
      return new t11(this.processor.usedMemory, (_a = this.loadedGraphics) == null ? void 0 : _a.length, (e12 == null ? void 0 : e12.serviceDataCount) ?? -1, (e12 == null ? void 0 : e12.maximumNumberOfFeatures) ?? -1, 0, this.processor.performanceInfo);
    }
  };
  return e([y2()], v4.prototype, "loadedGraphics", void 0), e([y2()], v4.prototype, "_dataUpdatingState", void 0), e([y2({ readOnly: true })], v4.prototype, "dataUpdating", null), e([y2()], v4.prototype, "suspended", void 0), e([y2({ readOnly: true })], v4.prototype, "legendEnabled", null), e([y2()], v4.prototype, "updating", void 0), e([y2()], v4.prototype, "controller", void 0), e([y2()], v4.prototype, "processor", void 0), e([y2({ readOnly: true })], v4.prototype, "updatePolicy", void 0), e([y2({ readOnly: true })], v4.prototype, "suspendResumeExtentMode", void 0), e([y2({ type: Boolean })], v4.prototype, "slicePlaneEnabled", void 0), e([y2({ readOnly: true })], v4.prototype, "suspendInfo", void 0), e([y2()], v4.prototype, "graphics3DProcessor", null), e([y2()], v4.prototype, "heatmapProcessor", null), e([y2()], v4.prototype, "symbologySnappingSupported", null), e([y2({ readOnly: true })], v4.prototype, "hasAllFeatures", null), e([y2({ readOnly: true })], v4.prototype, "hasAllFeaturesInView", null), e([y2({ readOnly: true })], v4.prototype, "hasFullGeometries", null), v4 = e([a3("esri.views.3d.layers.FeatureLikeLayerView3D")], v4), v4;
};
var O6;
!function(e12) {
  e12[e12.NONE = 0] = "NONE", e12[e12.CONTROLLER = 1] = "CONTROLLER", e12[e12.CORE = 2] = "CORE";
}(O6 || (O6 = {}));

export {
  P4 as P,
  T2 as T,
  n10 as n,
  l6 as l,
  P3 as P2,
  b7 as b
};
//# sourceMappingURL=chunk-UACJ4BQN.js.map
