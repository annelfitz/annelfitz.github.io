import {
  d as d3,
  o as o10,
  t as t3
} from "./chunk-4FXZDEEP.js";
import {
  a as a2
} from "./chunk-KYKKN5I4.js";
import {
  d as d2,
  r as r2
} from "./chunk-XIWETS2Q.js";
import {
  o as o7,
  s as s2,
  t as t2
} from "./chunk-FOCTPJDR.js";
import {
  d
} from "./chunk-QFKFOAJ6.js";
import {
  l
} from "./chunk-MKOOEINB.js";
import {
  o as o9
} from "./chunk-HBRJJENW.js";
import {
  e as e4
} from "./chunk-VHY5K2VE.js";
import {
  o as o6,
  t
} from "./chunk-6ENXMQPD.js";
import {
  P
} from "./chunk-FV43HSGW.js";
import {
  w
} from "./chunk-ZR7OV2EH.js";
import {
  o as o5
} from "./chunk-LJULTBAY.js";
import {
  e as e3
} from "./chunk-6MGK5WBT.js";
import {
  e as e2
} from "./chunk-QR7J3YDY.js";
import {
  s
} from "./chunk-GO2OGJDG.js";
import {
  o as o8
} from "./chunk-UYMREM3D.js";
import {
  o as o4,
  r
} from "./chunk-3AIILHI5.js";
import {
  o as o2
} from "./chunk-CDBOQCLE.js";
import {
  a
} from "./chunk-UAFQMHYI.js";
import {
  o as o3
} from "./chunk-IDPLBNJX.js";
import {
  o
} from "./chunk-P4MNTMCZ.js";
import {
  e
} from "./chunk-GLF3KRAL.js";
import {
  n
} from "./chunk-ZLQTPFTL.js";
import {
  _
} from "./chunk-AKEHDP75.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/HUDOcclusionPass.glsl.js
function i(i2, s3) {
  const { vertex: p, fragment: n2 } = i2;
  p.include(o10), s3.multipassEnabled && (p.include(a2), i2.varyings.add("depth", "float")), p.code.add(o`
  void main(void) {
    vec4 posProjCenter;
    if (dot(position, position) > 0.0) {
      // Render single point to center of the pixel to avoid subpixel filtering to affect the marker color
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      posProjCenter = alignToPixelCenter(posProj, viewport.zw);

      ${s3.multipassEnabled ? o`
        // Don't draw vertices behind geometry
        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){
          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
        }` : ""}

      ${s3.multipassEnabled ? "depth = projectAux.posView.z;" : ""}
      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        // Project out of clip space
        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
      }

    } else {
      // Project out of clip space
      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
    }

    gl_Position = posProjCenter;
    gl_PointSize = 1.0;
  }
  `), i2.include(o9, s3), n2.code.add(o`
  void main() {
    fragColor = vec4(1);
    ${s3.multipassEnabled ? o`
        if(terrainDepthTest(depth)) {
          fragColor.g = 0.5;
        }` : ""}
  }
  `);
}

// node_modules/@arcgis/core/chunks/HUDMaterial.glsl.js
function F(o11) {
  const i2 = new o8(), F2 = o11.signedDistanceFieldEnabled;
  if (i2.include(d3, o11), i2.include(P, o11), o11.occlusionPass)
    return i2.include(i, o11), i2;
  const { vertex: B2, fragment: H2 } = i2;
  i2.include(s2), H2.include(a), H2.include(e4), i2.include(l, o11), i2.include(d, o11), i2.include(t3), i2.varyings.add("vcolor", "vec4"), i2.varyings.add("vtc", "vec2"), i2.varyings.add("vsize", "vec2"), i2.varyings.add("voccluded", "float"), B2.uniforms.add(new e3("viewport", (e5, o12) => o12.camera.fullViewport), new e2("screenOffset", (o12, i3) => o4(T, 2 * o12.screenOffset[0] * i3.camera.pixelRatio, 2 * o12.screenOffset[1] * i3.camera.pixelRatio)), new e2("anchorPosition", (e5) => D(e5)), new e3("materialColor", (e5) => e5.color)), w(B2), F2 && (B2.uniforms.add(new e3("outlineColor", (e5) => e5.outlineColor)), H2.uniforms.add(new e3("outlineColor", (e5) => L(e5) ? e5.outlineColor : _), new o3("outlineSize", (e5) => L(e5) ? e5.outlineSize : 0))), o11.pixelSnappingEnabled && B2.include(o10), o11.hasScreenSizePerspective && (t2(B2), o7(B2)), o11.debugDrawLabelBorder && i2.varyings.add("debugBorderCoords", "vec4"), i2.attributes.add(e.UV0, "vec2"), i2.attributes.add(e.COLOR, "vec4"), i2.attributes.add(e.SIZE, "vec2"), i2.attributes.add(e.FEATUREATTRIBUTE, "vec4"), B2.code.add(o`
    void main(void) {
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      forwardObjectAndLayerIdColor();

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }
      vec2 inputSize;
      ${o11.hasScreenSizePerspective ? o`
            inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
            vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
         ` : o`
            inputSize = size;
            vec2 screenOffsetScaled = screenOffset;`}

      ${o11.vvSize ? "inputSize *= vvScale(featureAttribute).xx;" : ""}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);
      bool visible = testHUDVisibility(posProj);
      voccluded = visible ? 0.0 : 1.0;
    `);
  const U = o`vec2 uv01 = floor(uv0);
vec2 uv = uv0 - uv01;
quadOffset.xy = ((uv01 - anchorPosition) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;`, V = o11.pixelSnappingEnabled ? F2 ? o`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;` : o`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}` : o`posProj += quadOffset;`;
  B2.code.add(o`
    ${o11.occlusionTestEnabled ? "if (visible) {" : ""}
    ${U}
    ${o11.vvColor ? "vcolor = interpolateVVColor(featureAttribute.y) * materialColor;" : "vcolor = color / 255.0 * materialColor;"}

    ${o11.output === o2.ObjectAndLayerIdColor ? o`vcolor.a = 1.0;` : ""}

    bool alphaDiscard = vcolor.a < ${o.float(t)};
    ${F2 ? `alphaDiscard = alphaDiscard && outlineColor.a < ${o.float(t)};` : ""}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${V}
      gl_Position = posProj;
    }

    vtc = uv;

    ${o11.debugDrawLabelBorder ? "debugBorderCoords = vec4(uv01, 1.5 / combinedSize);" : ""}
    vsize = inputSize;
    ${o11.occlusionTestEnabled ? o`} else { vtc = vec2(0.0);
      ${o11.debugDrawLabelBorder ? "debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);}" : "}"}` : ""}
  }
  `), H2.uniforms.add(new s("tex", (e5) => e5.texture));
  const E = o11.debugDrawLabelBorder ? o`(isBorder > 0.0 ? 0.0 : ${o.float(o6)})` : o.float(o6), I = o`
    ${o11.debugDrawLabelBorder ? o`
      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));` : ""}

    ${o11.sampleSignedDistanceFieldTexelCenter ? o`
      // Attempt to sample texel centers to avoid that thin cross outlines
      // disappear with large symbol sizes.
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;
      ` : o`
      vec2 samplePos = vtc;
      `}

    ${F2 ? o`
      vec4 fillPixelColor = vcolor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgba2float(texture(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${E} ||
          fillPixelColor.a + outlinePixelColor.a < ${o.float(t)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        fragColor = vec4(compositeColor, compositeAlpha);
      } else {
        if (fillAlphaFactor < ${E}) {
          discard;
        }

        fragColor = premultiplyAlpha(fillPixelColor);
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      ` : o`
          vec4 texColor = texture(tex, vtc, -0.5);
          if (texColor.a < ${E}) {
            discard;
          }
          fragColor = texColor * premultiplyAlpha(vcolor);
          `}

    // Draw debug border with transparency, so that original texels along border are still partially visible
    ${o11.debugDrawLabelBorder ? o`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);` : ""}
  `;
  switch (o11.output) {
    case o2.Color:
      H2.code.add(o`
        void main() {
          ${I}
          ${o11.transparencyPassType === o5.FrontFace ? "fragColor.rgb /= fragColor.a;" : ""}
        }`);
      break;
    case o2.Alpha:
      H2.code.add(o`
        void main() {
          ${I}
          fragColor = vec4(fragColor.a);
        }`);
      break;
    case o2.ObjectAndLayerIdColor:
      H2.code.add(o`
        void main() {
          ${I}
          outputObjectAndLayerIdColor();
        }`);
      break;
    case o2.Highlight:
      H2.constants.add("occludedHighlightFlag", "vec4", r2), H2.constants.add("unoccludedHighlightFlag", "vec4", d2), H2.code.add(o`
        void main() {
          ${I}
          if (voccluded == 1.0) {
            fragColor = occludedHighlightFlag;
          } else {
            fragColor = unoccludedHighlightFlag;
          }
        }`);
  }
  return i2;
}
function L(e5) {
  return e5.outlineColor[3] > 0 && e5.outlineSize > 0;
}
function D(e5, i2 = T) {
  return e5.textureIsSignedDistanceField ? B(e5.anchorPosition, e5.distanceFieldBoundingBox, i2) : r(i2, e5.anchorPosition), i2;
}
function B(o11, i2, r3) {
  null != i2 ? o4(r3, o11[0] * (i2[2] - i2[0]) + i2[0], o11[1] * (i2[3] - i2[1]) + i2[1]) : o4(r3, 0, 0);
}
var T = n();
var H = Object.freeze(Object.defineProperty({ __proto__: null, build: F, calculateAnchorPosForRendering: D }, Symbol.toStringTag, { value: "Module" }));

export {
  F,
  D,
  H
};
//# sourceMappingURL=chunk-6LT23NJG.js.map
