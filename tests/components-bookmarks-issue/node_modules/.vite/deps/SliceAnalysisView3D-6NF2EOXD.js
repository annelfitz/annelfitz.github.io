import {
  Ai,
  Ci,
  H as H2,
  I,
  Li,
  M,
  Mi,
  Ri,
  Vi,
  _i,
  ai,
  c as c4,
  ci,
  e as e2,
  ei,
  f as f2,
  g as g2,
  gi,
  h as h3,
  j,
  ji,
  li,
  m as m2,
  mi,
  p as p3,
  pi,
  r as r2,
  ri,
  si,
  t as t6,
  t2 as t7,
  ui,
  v as v2,
  xi
} from "./chunk-LBNOZOSP.js";
import {
  h as h2
} from "./chunk-B4G2B67L.js";
import "./chunk-MP3BMLR3.js";
import "./chunk-Y52LFEYF.js";
import {
  t as t4
} from "./chunk-3XPYGI2Z.js";
import {
  l as l2,
  n as n5
} from "./chunk-N3SF7L2P.js";
import {
  U
} from "./chunk-RYDZOUU4.js";
import {
  a as a2,
  v
} from "./chunk-HJ7EOT7R.js";
import {
  o as o3
} from "./chunk-23GKO7D7.js";
import {
  s as s2
} from "./chunk-45P2R3BJ.js";
import "./chunk-6FMD7BOV.js";
import {
  w
} from "./chunk-TKMRXVLK.js";
import {
  p as p2
} from "./chunk-6SB3EFZU.js";
import {
  m
} from "./chunk-WOKVMRAD.js";
import {
  t as t5
} from "./chunk-FXZUN4XG.js";
import "./chunk-3W2U3CD4.js";
import "./chunk-3ENNELTC.js";
import "./chunk-LEFES6LS.js";
import "./chunk-AEAYH74I.js";
import "./chunk-UXQH3C5A.js";
import "./chunk-OOISODT4.js";
import {
  h
} from "./chunk-HBBLDSW6.js";
import "./chunk-VUHMQQ6M.js";
import "./chunk-6GQQIJM7.js";
import "./chunk-PAH4PVZY.js";
import "./chunk-5T7MASZO.js";
import "./chunk-5WKN6K5Z.js";
import "./chunk-WCBHO6BH.js";
import "./chunk-V7NVRGBC.js";
import "./chunk-KCZGCTYM.js";
import "./chunk-46T3D2EU.js";
import {
  H,
  W,
  Z,
  ds
} from "./chunk-RYF27IO3.js";
import "./chunk-2GT6KC2O.js";
import "./chunk-KVZT4PEH.js";
import "./chunk-VIRGWB3Z.js";
import "./chunk-SPYHZ6ZW.js";
import "./chunk-637XZX4A.js";
import "./chunk-PMFQ2A2V.js";
import "./chunk-5IITWVGY.js";
import "./chunk-HHAESKQ6.js";
import "./chunk-4MJOJUFR.js";
import {
  n as n4
} from "./chunk-PTIWH4S7.js";
import "./chunk-L3GUCBXG.js";
import "./chunk-VXM3PR7E.js";
import "./chunk-VE57JPH4.js";
import "./chunk-KWLN46JY.js";
import "./chunk-7KNPDPFB.js";
import "./chunk-M6P775BS.js";
import "./chunk-J5F4VILS.js";
import "./chunk-KSBIR2KG.js";
import "./chunk-XVQGALI7.js";
import "./chunk-XFQIXBHG.js";
import "./chunk-MVSN2HAN.js";
import "./chunk-7A5N7G2Z.js";
import "./chunk-FD7NY4JS.js";
import "./chunk-ZPC74XHC.js";
import "./chunk-IVGJRGD2.js";
import "./chunk-JA2AO4PC.js";
import "./chunk-MTLWPXQD.js";
import "./chunk-ZEMG7GKC.js";
import "./chunk-ECIXBYOQ.js";
import "./chunk-XIWETS2Q.js";
import "./chunk-QFKFOAJ6.js";
import "./chunk-LOPMLCHC.js";
import "./chunk-JIR2YP6A.js";
import "./chunk-LANUNBDP.js";
import "./chunk-JBF6CULO.js";
import "./chunk-DRCNNCTI.js";
import "./chunk-MKOOEINB.js";
import "./chunk-JKOHBDRD.js";
import "./chunk-MDSRD3WV.js";
import "./chunk-3DFMDDMO.js";
import "./chunk-4BCSYJOQ.js";
import "./chunk-GMUCR2DJ.js";
import "./chunk-HBRJJENW.js";
import "./chunk-VHY5K2VE.js";
import "./chunk-6ENXMQPD.js";
import "./chunk-FV43HSGW.js";
import "./chunk-ZR7OV2EH.js";
import "./chunk-U76EZJUZ.js";
import "./chunk-MEEG7XMI.js";
import "./chunk-LJULTBAY.js";
import "./chunk-YKIGDW5O.js";
import "./chunk-6MGK5WBT.js";
import "./chunk-CPZW2LMK.js";
import "./chunk-QR7J3YDY.js";
import "./chunk-GO2OGJDG.js";
import "./chunk-UYMREM3D.js";
import "./chunk-JTUYA5FE.js";
import "./chunk-UNTQATE2.js";
import "./chunk-5YY6NZNY.js";
import "./chunk-YUWVLORR.js";
import "./chunk-7MYYCSEB.js";
import "./chunk-ESK2YRQM.js";
import "./chunk-UNTPHF5R.js";
import "./chunk-YJFPDMSR.js";
import "./chunk-H7T5AB2S.js";
import "./chunk-WKVHVZW2.js";
import "./chunk-KSZESDGM.js";
import "./chunk-CHJMCUAV.js";
import "./chunk-5P74D2TG.js";
import "./chunk-33LWZO2E.js";
import "./chunk-YT66FIGM.js";
import "./chunk-3IDXRFXE.js";
import "./chunk-RLZYC2LS.js";
import "./chunk-WEER6QME.js";
import "./chunk-TXLJQAAN.js";
import "./chunk-R4SGP2EA.js";
import "./chunk-IRL6OOVK.js";
import "./chunk-3AIILHI5.js";
import "./chunk-QJRGTKPN.js";
import "./chunk-VIH3KDZO.js";
import "./chunk-LA365FE7.js";
import {
  _ as _2
} from "./chunk-5Y24AKE7.js";
import "./chunk-UYDBB2JF.js";
import "./chunk-J6T3FJLS.js";
import "./chunk-67A4RFMD.js";
import "./chunk-A64EK7QM.js";
import "./chunk-SA77Z3WI.js";
import "./chunk-676ANOCK.js";
import "./chunk-6K2UNRXT.js";
import "./chunk-WTKV7W5Z.js";
import "./chunk-D4Y7YHG7.js";
import "./chunk-AL5NKCU5.js";
import "./chunk-6MBDB46F.js";
import "./chunk-D56W4LPT.js";
import "./chunk-BKOYOJBG.js";
import "./chunk-7JR6S3WL.js";
import "./chunk-CSSLIU64.js";
import "./chunk-CJNDQ2LH.js";
import "./chunk-B4E4X2TN.js";
import "./chunk-HS6YI5DU.js";
import "./chunk-CDBOQCLE.js";
import "./chunk-RSRUEM5U.js";
import "./chunk-HFJMEXIX.js";
import "./chunk-VYSGSKHB.js";
import "./chunk-DGJJJ2DD.js";
import "./chunk-UAFQMHYI.js";
import "./chunk-IDPLBNJX.js";
import "./chunk-ZHAZR5C3.js";
import "./chunk-P4MNTMCZ.js";
import "./chunk-EWD7I5UU.js";
import "./chunk-4UEJR4VO.js";
import "./chunk-BUEJAM23.js";
import "./chunk-LQR76D5M.js";
import "./chunk-2CWW7O7M.js";
import "./chunk-Q5NCQLSM.js";
import "./chunk-FLBJ53KN.js";
import "./chunk-YH2IYJYF.js";
import "./chunk-BSPKLAHD.js";
import "./chunk-GGHKH3LP.js";
import "./chunk-VS6AHHIY.js";
import "./chunk-5DH2QVPW.js";
import "./chunk-GPWQGIYV.js";
import "./chunk-WZJNHZ6H.js";
import "./chunk-XMYPMIYH.js";
import {
  d as d4
} from "./chunk-FQLGRQKL.js";
import "./chunk-DIT542IP.js";
import "./chunk-HFYOMP47.js";
import "./chunk-TOKUWZQG.js";
import "./chunk-JNGJWHJD.js";
import "./chunk-QMPD4WXY.js";
import "./chunk-OF4YIONV.js";
import "./chunk-YBPOKK6D.js";
import "./chunk-AHEDDTVZ.js";
import "./chunk-Z4ALW6LX.js";
import "./chunk-H4O73SDK.js";
import "./chunk-UVXSAP7V.js";
import "./chunk-IZ3VJLQ6.js";
import "./chunk-DRC4XSYG.js";
import "./chunk-IHQNQQJC.js";
import "./chunk-4IKPTZ53.js";
import "./chunk-DXMBDX2I.js";
import "./chunk-TUVEYM7U.js";
import "./chunk-5S637BGW.js";
import "./chunk-BFOJPIF7.js";
import "./chunk-7UUNSIMA.js";
import "./chunk-GMRQGGML.js";
import "./chunk-BYK4ZOU2.js";
import "./chunk-OHYLFFUW.js";
import "./chunk-XW3FDKYP.js";
import "./chunk-Y7RXGLGH.js";
import "./chunk-3JC3OUNW.js";
import "./chunk-RO3CTAP7.js";
import "./chunk-GKMVTGGM.js";
import "./chunk-XGTCDM4C.js";
import "./chunk-QNG4TY7L.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import "./chunk-2QCWKZIQ.js";
import "./chunk-2NPNEA6N.js";
import "./chunk-U34ZXOJT.js";
import "./chunk-OKRW5W44.js";
import "./chunk-RGAA5Z76.js";
import "./chunk-Q6RZBEZ6.js";
import "./chunk-PC66NY33.js";
import "./chunk-YY2VB3AE.js";
import "./chunk-VEYMN5N3.js";
import "./chunk-H6NTWZSO.js";
import "./chunk-BMT3OVAP.js";
import "./chunk-W5ALAOW2.js";
import "./chunk-FHDHOWK5.js";
import "./chunk-Y546C2O5.js";
import "./chunk-IYKBAIQE.js";
import "./chunk-BDRVHR2K.js";
import "./chunk-DVIGFJWY.js";
import "./chunk-LQBHIBXV.js";
import "./chunk-42DUJ2CX.js";
import "./chunk-B35SNV2V.js";
import {
  E,
  F,
  S as S2,
  V,
  c as c3,
  f,
  t as t3
} from "./chunk-Z2F5OKVA.js";
import "./chunk-UQA6M3KF.js";
import "./chunk-GLF3KRAL.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-WIVZ7SMV.js";
import "./chunk-O76UVYOO.js";
import "./chunk-QCMUK3QA.js";
import "./chunk-HZSGATFT.js";
import "./chunk-KNMQQRV7.js";
import "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import {
  _,
  t as t2
} from "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-AKQ765JR.js";
import "./chunk-ERD6I7QP.js";
import "./chunk-QIT4M76C.js";
import "./chunk-EZL4LTMD.js";
import "./chunk-F3BQGS35.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-LMO6NZJA.js";
import "./chunk-A5QTLE4Y.js";
import {
  n as n3
} from "./chunk-SCHTG6ZQ.js";
import "./chunk-OHE3HDFF.js";
import "./chunk-QYC3GV65.js";
import "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import "./chunk-CQFVWMFK.js";
import "./chunk-7EQJLP2H.js";
import "./chunk-4ZLXDMI5.js";
import "./chunk-EMYOYGGK.js";
import "./chunk-6PMFOUWZ.js";
import "./chunk-3KPZ3BQR.js";
import "./chunk-5JYVZQZR.js";
import "./chunk-UUG4W2PI.js";
import "./chunk-WW22JHXA.js";
import "./chunk-ZAM62XN5.js";
import "./chunk-RKVEKQ5O.js";
import "./chunk-P7J4JFEH.js";
import {
  b
} from "./chunk-G7FOE26O.js";
import "./chunk-USOPZ2Q6.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-LSM34QAB.js";
import {
  c as c2,
  d as d3,
  p
} from "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-JW7VBMHD.js";
import "./chunk-GLLRUDMY.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import {
  c,
  d as d2
} from "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-AKLOTDO2.js";
import "./chunk-6AQIVLDN.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-DVI5RM3W.js";
import "./chunk-LBXFRGMS.js";
import "./chunk-VTH4DAHQ.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import {
  O,
  P,
  g,
  o as o2,
  r,
  s,
  u as u2,
  z
} from "./chunk-JZBR4X6W.js";
import {
  n as n2,
  t
} from "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-TPLOIZC7.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-5LSHHVQ5.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  A as A2,
  C,
  d
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  A,
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  o2 as o
} from "./chunk-JGDJR5EV.js";
import {
  l,
  u
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/3d/terrain/isTerrainSurfaceLayer.js
function a3(a4) {
  switch (a4.type) {
    case "building-scene":
    case "catalog":
    case "catalog-dynamic-group":
    case "catalog-footprint":
    case "csv":
    case "dimension":
    case "feature":
    case "geo-rss":
    case "geojson":
    case "graphics":
    case "group":
    case "integrated-mesh":
    case "integrated-mesh-3dtiles":
    case "kml":
    case "knowledge-graph":
    case "link-chart":
    case "knowledge-graph-sublayer":
    case "line-of-sight":
    case "map-notes":
    case "ogc-feature":
    case "oriented-imagery":
    case "point-cloud":
    case "route":
    case "scene":
    case "stream":
    case "voxel":
    case "subtype-group":
    case "unknown":
    case "unsupported":
    case "wfs":
    case null:
      return false;
    case "base-dynamic":
    case "base-elevation":
    case "base-tile":
    case "bing-maps":
    case "elevation":
    case "imagery":
    case "imagery-tile":
    case "map-image":
    case "media":
    case "open-street-map":
    case "tile":
    case "vector-tile":
    case "video":
    case "wcs":
    case "web-tile":
    case "wms":
    case "wmts":
      return true;
    default:
      return n3(a4.type), false;
  }
}

// node_modules/@arcgis/core/views/3d/analysis/Slice/SliceController.js
var v3 = class extends S {
  constructor(e3) {
    super(e3), this._internalChange = false, this._currentSlicePlane = null;
  }
  initialize() {
    this.addHandles(this.analysis.excludedLayers.on("before-add", (e3) => {
      const i = e3.item;
      null != i && (i instanceof b || i instanceof _2) ? i instanceof b && a3(i) ? (n.getLogger(this).error("excludedLayers", `Layer '${i.title}, id:${i.id}' of type '${i.type}' can not be individually excluded from slicing. Use 'excludeGroundSurface' instead.`), e3.preventDefault()) : this.analysis.excludedLayers.includes(i) && e3.preventDefault() : (n.getLogger(this).error("excludedLayers", "Invalid layer type, layer must derive from Layer or BuildingComponentSublayer"), e3.preventDefault());
    })), V2(this.view, this), this.addHandles([d(() => this.analysisViewData.plane, () => {
      this._internalChange || this._updateSlicePlaneFromBoundedPlane(), this._updateLayerViews();
    }, { sync: true }), d(() => this.analysis.excludeGroundSurface, () => this._updateLayerViews(), { sync: true }), this.analysis.excludedLayers.on("change", () => this._updateLayerViews()), d(() => [this.analysisViewData.active, this.analysisViewData.visible], () => {
      this._updateActiveController(), this._updateViewSlicePlane();
    }, { sync: true }), d(() => this._allLayerAndSubLayerViews, () => this._updateLayerViews())]), this.addHandles([d(() => this.analysis.shape, () => {
      this._internalChange || (this._updateBoundedPlaneFromSlicePlane(), this._updateViewSlicePlane());
    }, { sync: true })], "analysis"), this._updateActiveController(), this._updateBoundedPlaneFromSlicePlane(), this._updateViewSlicePlane();
  }
  destroy() {
    this.analysisViewData.active && (this.analysisViewData.active = false, this.view.slicePlane = null, this._updateActiveController(), this._updateViewSlicePlane()), L(this.view, this), this.set("view", null);
  }
  get _allLayerAndSubLayerViews() {
    const e3 = this.view.allLayerViews.items;
    return e3.concat(e3.filter(xi).flatMap(({ sublayerViews: e4 }) => e4.items));
  }
  _updateBoundedPlaneFromSlicePlane() {
    const e3 = this.analysis.shape, i = this._currentSlicePlane;
    if (null == i && null == e3 || null != i && null != e3 && e3.equals(i))
      return;
    let a4 = null, l3 = null;
    if (null != (e3 == null ? void 0 : e3.position)) {
      const i2 = e3.position.spatialReference, s3 = Li(e3, this.view);
      null == s3 && t5(this.analysis, i2, n.getLogger(this)), a4 = Vi(s3, this.view, { tiltEnabled: this.analysis.tiltEnabled }, W()), null != a4 && (l3 = { heading: e3.heading, tilt: e3.tilt, position: e3.position, width: e3.width, height: e3.height });
    }
    this._currentSlicePlane = l3, this._internalChange = true, this.analysisViewData.plane = a4, this._internalChange = false;
  }
  _updateSlicePlaneFromBoundedPlane() {
    const e3 = this.analysisViewData.plane, a4 = Ri(e3, this.view, this.view.spatialReference, new h2());
    let t8 = null;
    null != a4 && (t8 = { heading: a4.heading, tilt: a4.tilt, position: a4.position, width: a4.width, height: a4.height }), this._currentSlicePlane = t8, this._internalChange = true, this.analysis.shape = a4, this._internalChange = false, this._updateViewSlicePlane();
  }
  _updateActiveController() {
    if (m3)
      return;
    const e3 = _3(this.view);
    if (!e3)
      return;
    if (this.analysisViewData.active)
      null != e3.activeController && e3.activeController !== this ? (m3 = true, e3.activeController.analysisViewData.active = false, m3 = false) : null != e3.activeController && e3.activeController, this._updateLayerViews(), e3.activeController = this;
    else {
      if (null != e3.activeController && e3.activeController !== this)
        return;
      null != e3.activeController && e3.activeController === this && (e3.activeController = null, this._updateLayerViews());
    }
  }
  _updateViewSlicePlane() {
    g3(this.view);
  }
  _updateLayerViews() {
    const e3 = null != this.analysisViewData.plane && this.analysisViewData.visible && this.analysisViewData.active, i = [], a4 = (e4) => {
      "layers" in e4 ? e4.layers.forEach(a4) : i.push(e4);
    };
    this.analysis.excludedLayers.forEach(a4), this.view.allLayerViews.forEach((a5) => {
      a5.destroyed || ("slicePlaneEnabled" in a5 && (a5.slicePlaneEnabled = e3 && !i.includes(a5.layer)), "sublayerViews" in a5 && a5.sublayerViews.forEach((a6) => {
        a6.slicePlaneEnabled = e3 && !i.includes(a6.sublayer);
      }));
    }), null != this.view.basemapTerrain && (this.view.basemapTerrain.slicePlaneEnabled = e3 && !this.analysis.excludeGroundSurface);
  }
};
e([y()], v3.prototype, "view", void 0), e([y()], v3.prototype, "analysis", void 0), e([y()], v3.prototype, "analysisViewData", void 0), e([y()], v3.prototype, "_allLayerAndSubLayerViews", null), v3 = e([a("esri.views.3d.analysis.Slice.SliceController")], v3);
var f3 = /* @__PURE__ */ new Map();
var m3 = false;
function g3(e3) {
  const i = _3(e3), a4 = i == null ? void 0 : i.activeController;
  null != (a4 == null ? void 0 : a4.analysisViewData.plane) && a4.analysisViewData.visible ? e3.slicePlane = a4.analysisViewData.plane : e3.slicePlane = null;
}
function V2(e3, i) {
  var _a;
  f3.has(e3) || f3.set(e3, { all: [], activeController: null }), (_a = f3.get(e3)) == null ? void 0 : _a.all.push(i);
}
function _3(e3) {
  return f3.get(e3);
}
function L(e3, i) {
  if (!f3.has(e3))
    throw new Error("view expected in global slice register");
  const a4 = f3.get(e3), t8 = (a4 == null ? void 0 : a4.all.lastIndexOf(i)) ?? -1;
  if (!a4 || -1 === t8)
    throw new Error("controller expected in global slice register");
  a4.all.splice(t8, 1), 0 === a4.all.length && f3.delete(e3);
}

// node_modules/@arcgis/core/views/3d/analysis/Slice/SliceTool.js
var Vt;
var bt = Vt = class extends o3 {
  constructor(t8) {
    super(t8), this._clock = o, this._previewPlaneOpacity = 1, this.removeIncompleteOnCancel = false, this._layersMode = "none", this.shiftManipulator = null, this.rotateHeadingManipulator = null, this.rotateTiltManipulator = null, this.resizeManipulators = null, this._frameTask = null, this._pointerMoveTimerMs = m2, this._prevPointerMoveTimeout = null, this._previewPlaneGridVisualElement = null, this._previewPlaneOutlineVisualElement = null, this._startPlane = W(), this._previewPlane = null, this._activeKeyModifiers = {}, this._lastCursorPosition = c(), this._resizeHandles = [{ direction: [1, 0] }, { direction: [1, 1] }, { direction: [0, 1] }, { direction: [-1, 1] }, { direction: [-1, 0] }, { direction: [-1, -1] }, { direction: [0, -1] }, { direction: [1, -1] }], this._intersector = t4(t8.view.state.viewingMode);
  }
  initialize() {
    var _a;
    if (null == this.analysis)
      throw new Error("SliceTool requires valid analysis, but null was provided.");
    const t8 = (t9) => {
      this._updateManipulatorsInteractive(t9), t9.grabbing || (null != this.analysisViewData.plane && Z(this.analysisViewData.plane, this._startPlane), this.inputState = null);
    }, e3 = new I(this.view, H2.CENTER_ON_ARROW);
    this.shiftManipulator = e3, this.manipulators.add(e3), this.addHandles([this._createShiftDragPipeline(e3), e3.events.on("grab-changed", (i2) => {
      this._onShiftGrab(i2), t8(e3);
    })]);
    const i = !((_a = this.view._stage) == null ? void 0 : _a.renderView.renderingContext.driverTest.svgPremultipliesAlpha.result), a4 = new g2(this.view, (t9, e4) => l2(this.view.textures, { accentColor: t9, contrastColor: e4, preMultiplyAlpha: i }));
    this.rotateHeadingManipulator = a4, this.manipulators.add(a4), this.addHandles([this._createRotateHeadingDragPipeline(a4), a4.events.on("grab-changed", (e4) => {
      this._onRotateHeadingGrab(e4), t8(a4);
    })]);
    const s3 = new g2(this.view, (t9, e4) => n5(this.view.textures, { accentColor: t9, contrastColor: e4, preMultiplyAlpha: i }));
    this.rotateTiltManipulator = s3, this.manipulators.add(s3), this.addHandles([this._createRotateTiltDragPipeline(s3), s3.events.on("grab-changed", (e4) => {
      this._onRotateTiltGrab(e4), t8(s3);
    })]), this.resizeManipulators = this._resizeHandles.map((e4, i2) => {
      const a5 = new v2(this.view, e4);
      return this.addHandles([this._createResizeDragPipeline(a5), a5.events.on("grab-changed", (e5) => {
        this._onResizeGrab(e5, i2), t8(a5);
      })]), a5;
    }), this.manipulators.addMany(this.resizeManipulators), this._previewPlaneGridVisualElement = ji(this.view), this._previewPlaneOutlineVisualElement = Ai(this.view), this._previewPlaneOutlineVisualElement.width = M, this.addHandles(d(() => [this.analysisViewData.plane, this.analysis.tiltEnabled], () => this._updateManipulators(), C));
    const o4 = d(() => this.state, (t9) => {
      "sliced" === t9 && this.finishToolCreation();
    }, A2);
    this.addHandles([o4, d(() => this.view.state.camera, () => this._onCameraChange())]);
  }
  destroy() {
    this._removeFrameTask(), this._clearPointerMoveTimeout(), this._previewPlaneOutlineVisualElement = u(this._previewPlaneOutlineVisualElement), this._previewPlaneGridVisualElement = u(this._previewPlaneGridVisualElement);
  }
  get state() {
    const t8 = !!this.analysisViewData.plane, e3 = !!this.inputState;
    return t8 ? t8 && e3 ? "slicing" : t8 && !e3 ? "sliced" : "ready" : "ready";
  }
  get cursor() {
    return this._isPlacingSlicePlane || "exclude" === this.layersMode ? "crosshair" : null != this._creatingPointerId ? "grabbing" : null;
  }
  set analysis(t8) {
    if (null == t8)
      throw new Error("SliceTool requires valid analysis, but null was provided.");
    this.removeHandles("analysis"), this._set("analysis", t8);
  }
  get layersMode() {
    return this._layersMode;
  }
  get inputState() {
    return this._get("inputState");
  }
  set inputState(t8) {
    this._set("inputState", t8), this.analysisViewData.showGrid = null != t8 && "resize" === t8.type, this._updateMaterials();
  }
  get _isPlacingSlicePlane() {
    return !this.inputState && !this.analysisViewData.plane && this.active;
  }
  get _creatingPointerId() {
    return null != this.inputState && "shift" === this.inputState.type ? this.inputState.creatingPointerId : null;
  }
  enterExcludeLayerMode() {
    null != this.analysisViewData.plane && (this._layersMode = "exclude", this.active || (this.view.activeTool = this));
  }
  exitExcludeLayerMode() {
    null != this.analysisViewData.plane && (this._layersMode = "none", this.active && (this.view.activeTool = null));
  }
  onDeactivate() {
    this._updatePreviewPlane(null);
  }
  onShow() {
    this._updateVisibility(true);
  }
  onHide() {
    this._updateVisibility(false);
  }
  _updateVisibility(t8) {
    this._updateManipulators(), t8 || this._clearPointerMoveTimeout();
  }
  onInputEvent(t8) {
    switch (t8.type) {
      case "pointer-drag":
        if (!Et(t8))
          return;
        this._isPlacingSlicePlane ? this._onClickPlacePlane(t8) && t8.stopPropagation() : this._onPointerDrag(t8) && t8.stopPropagation();
        break;
      case "pointer-move":
        this._onPointerMove(t8);
        break;
      case "pointer-up":
        this._onPointerUp(t8) && t8.stopPropagation();
        break;
      case "immediate-click":
        if (!Et(t8))
          return;
        this._onClickPlacePlane(t8) && t8.stopPropagation();
        break;
      case "click":
        if (!Et(t8))
          return;
        this._onClickExcludeLayer(t8) && t8.stopPropagation();
        break;
      case "drag":
        this.inputState && t8.stopPropagation();
        break;
      case "key-down":
        this._onKeyDown(t8) && t8.stopPropagation();
        break;
      case "key-up":
        this._onKeyUp(t8) && t8.stopPropagation();
    }
  }
  onEditableChange() {
    this.analysisViewData.editable = this.internallyEditable;
  }
  _onPointerDrag(t8) {
    const e3 = this.inputState;
    if (t8.pointerId === this._creatingPointerId && null != e3 && "shift" === e3.type) {
      const i = n4(t8);
      return this.shiftManipulator.events.emit("drag", { action: e3.hasBeenDragged ? "update" : "start", pointerType: t8.pointerType, start: i, screenPoint: i }), e3.hasBeenDragged = true, true;
    }
    return false;
  }
  _onPointerMove(t8) {
    this._lastCursorPosition.x = t8.x, this._lastCursorPosition.y = t8.y, this._resetPointerMoveTimeout(), "touch" !== t8.pointerType && this._updatePreviewPlane(n4(t8), this._activeKeyModifiers);
  }
  _onCameraChange() {
    this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), this._updateManipulators();
  }
  _onPointerUp(t8) {
    if (t8.pointerId === this._creatingPointerId && null != this.analysisViewData.plane) {
      const e3 = n4(t8);
      return this.shiftManipulator.events.emit("drag", { action: "end", start: e3, screenPoint: e3 }), Z(this.analysisViewData.plane, this._startPlane), this.inputState = null, true;
    }
    return false;
  }
  _onClickPlacePlane(t8) {
    if ("exclude" === this.layersMode)
      return false;
    if (this._isPlacingSlicePlane) {
      const i = n4(t8), a4 = W();
      if (this._pickPlane(i, false, this._activeKeyModifiers, a4)) {
        if ("pointer-drag" === t8.type) {
          const e3 = m(this.view.state.camera, i, St);
          this.inputState = Tt(e3, t8.pointerId, a4.origin, a4);
        }
        return Z(a4, this._startPlane), this.analysis.shape = Ri(a4, this.view, this.view.spatialReference, new h2()), true;
      }
    }
    return false;
  }
  _onClickExcludeLayer(t8) {
    return !("exclude" !== this.layersMode || !this.created) && (this.view.hitTest(n4(t8)).then((t9) => {
      if (t9.results.length) {
        const e3 = t9.results[0], i = "graphic" === (e3 == null ? void 0 : e3.type) && e3.graphic;
        if (i) {
          const t10 = i.sourceLayer || i.layer;
          t10 && this.analysis.excludedLayers.push(t10);
        }
      } else
        t9.ground.layer ? this.analysis.excludedLayers.push(t9.ground.layer) : this.analysis.excludeGroundSurface = true;
    }), this.exitExcludeLayerMode(), true);
  }
  _onKeyDown(t8) {
    return (t8.key === r2 || t8.key === t7) && (this._activeKeyModifiers[t8.key] = true, null != this._previewPlane && this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), true);
  }
  _onKeyUp(t8) {
    return !(t8.key !== r2 && t8.key !== t7 || !this._activeKeyModifiers[t8.key]) && (delete this._activeKeyModifiers[t8.key], null != this._previewPlane && this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), true);
  }
  _onShiftGrab(t8) {
    if ("start" !== t8.action || null == this.analysisViewData.plane || !t8.screenPoint)
      return;
    const e3 = m(this.view.state.camera, t8.screenPoint, St);
    Z(this.analysisViewData.plane, this._startPlane), this.inputState = Tt(e3, null, this.shiftManipulator.renderLocation, this.analysisViewData.plane);
  }
  _createShiftDragPipeline(t8) {
    return p2(t8, (t9, e3, i) => {
      const a4 = this.inputState;
      if (null == a4 || "shift" !== a4.type)
        return;
      const s3 = null != this.analysisViewData.plane ? Z(this.analysisViewData.plane, W()) : null;
      e3.next(U(this.view, a4.shiftPlane)).next(this._shiftDragAdjustSensitivity(a4)).next(this._shiftDragUpdatePlane(a4)), i.next(() => {
        null != s3 && this._updateBoundedPlane(s3);
      });
    });
  }
  _shiftDragAdjustSensitivity(t8) {
    return (e3) => {
      if (null == this.analysisViewData.plane)
        return null;
      const i = 1e-3, a4 = Math.min((1 - Math.abs(P(ds(this.analysisViewData.plane), e3.ray.direction) / s(e3.ray.direction))) / i, 1), s3 = -V(this._startPlane.plane, e3.renderEnd), n6 = -V(this._startPlane.plane, t8.startPoint);
      return t8.depth = t8.depth * (1 - a4) + s3 * a4 - n6, e3;
    };
  }
  _shiftDragUpdatePlane(t8) {
    return () => {
      if (null == this.analysisViewData.plane)
        return;
      const e3 = r(c3.get(), this._startPlane.origin), i = r(c3.get(), ds(this._startPlane));
      g(i, i, -t8.depth), u2(i, i, e3);
      const a4 = H(i, this.analysisViewData.plane.basis1, this.analysisViewData.plane.basis2, W());
      this._updateBoundedPlane(a4);
    };
  }
  _onRotateHeadingGrab(t8) {
    if ("start" !== t8.action || null == this.analysisViewData.plane || !t8.screenPoint)
      return;
    const e3 = li(this.analysisViewData.plane, this.view.renderCoordsHelper, _i.HEADING, E()), i = m(this.view.state.camera, t8.screenPoint, St), a4 = n2();
    S2(e3, i, a4) && (Z(this.analysisViewData.plane, this._startPlane), this.inputState = { type: "rotate", rotatePlane: e3, startPoint: a4 });
  }
  _createRotateHeadingDragPipeline(t8) {
    return p2(t8, (t9, e3, i) => {
      const a4 = this.inputState;
      if (null == a4 || "rotate" !== a4.type)
        return;
      const s3 = null != this.analysisViewData.plane ? Z(this.analysisViewData.plane, W()) : null;
      e3.next(U(this.view, a4.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(a4)).next(this._rotateDragUpdatePlaneFromRotate()), i.next(() => {
        null != s3 && this._updateBoundedPlane(s3);
      });
    });
  }
  _onRotateTiltGrab(t8) {
    if ("start" !== t8.action || null == this.analysisViewData.plane || !t8.screenPoint)
      return;
    const e3 = li(this.analysisViewData.plane, this.view.renderCoordsHelper, _i.TILT, E()), i = m(this.view.state.camera, t8.screenPoint, St), a4 = n2();
    S2(e3, i, a4) && (Z(this.analysisViewData.plane, this._startPlane), this.inputState = { type: "rotate", rotatePlane: e3, startPoint: a4 });
  }
  _createRotateTiltDragPipeline(t8) {
    return p2(t8, (t9, e3, i) => {
      const a4 = this.inputState;
      if (null == a4 || "rotate" !== a4.type)
        return;
      const s3 = null != this.analysisViewData.plane ? Z(this.analysisViewData.plane, W()) : null;
      e3.next(U(this.view, a4.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(a4)).next(this._rotateDragUpdatePlaneFromRotate()), i.next(() => {
        null != s3 && this._updateBoundedPlane(s3);
      });
    });
  }
  _rotateDragRenderPlaneToRotate(t8) {
    return (e3) => {
      if (null == this.analysisViewData.plane)
        return null;
      const i = F(t8.rotatePlane), a4 = w(t8.startPoint, e3.renderEnd, this.analysisViewData.plane.origin, i);
      return { ...e3, rotateAxis: i, rotateAngle: a4 };
    };
  }
  _rotateDragUpdatePlaneFromRotate() {
    return (t8) => {
      if (null == this.analysisViewData.plane)
        return;
      const e3 = p(f.get(), t8.rotateAngle, t8.rotateAxis);
      if (null == e3)
        return;
      const i = O(c3.get(), this._startPlane.basis1, e3), a4 = O(c3.get(), this._startPlane.basis2, e3), s3 = H(this.analysisViewData.plane.origin, i, a4, W());
      this._updateBoundedPlane(s3);
    };
  }
  _onResizeGrab(t8, e3) {
    if ("start" !== t8.action || null == this.analysisViewData.plane || !t8.screenPoint)
      return;
    const i = m(this.view.state.camera, t8.screenPoint, St), a4 = c3.get();
    S2(this.analysisViewData.plane.plane, i, a4) && (Z(this.analysisViewData.plane, this._startPlane), this.inputState = { type: "resize", activeHandleIdx: e3, startPoint: t(a4) });
  }
  _createResizeDragPipeline(t8) {
    return p2(t8, (t9, e3, i) => {
      const a4 = this.inputState;
      if (null == a4 || "resize" !== a4.type || null == this.analysisViewData.plane)
        return;
      const s3 = Z(this.analysisViewData.plane, W());
      e3.next(U(this.view, this.analysisViewData.plane.plane)).next(this._resizeDragUpdatePlane(a4)), i.next(() => {
        this._updateBoundedPlane(s3);
      });
    });
  }
  _resizeDragUpdatePlane(t8) {
    return (e3) => {
      if (null == this.analysisViewData.plane)
        return;
      const i = this._resizeHandles[t8.activeHandleIdx], a4 = ri(i, t8.startPoint, e3.renderEnd, this.view.state.camera, this._startPlane, Z(this.analysisViewData.plane));
      this._updateBoundedPlane(a4);
    };
  }
  _updateBoundedPlane(t8) {
    const e3 = this.analysisViewData;
    if (null == e3)
      throw new Error("valid internal object expected");
    e3.plane = t8;
  }
  _updatePreviewPlane(t8, e3 = {}) {
    let i = this._previewPlane;
    if (this._previewPlane = null, null == t8)
      return this._removeFrameTask(), void this._updateManipulators();
    if (!this.analysisViewData.plane && this.active) {
      const a4 = null != i ? i : W();
      if (i = null != i ? Z(i, kt) : null, this._pickPlane(t8, true, e3, a4)) {
        const t9 = f2;
        let e4 = false;
        null != i && (e4 = P(F(i.plane), F(a4.plane)) < t9 || P(z(c3.get(), i.basis1), z(c3.get(), a4.basis1)) < t9), e4 && (this._previewPlaneOpacity = 0), this._previewPlane = a4;
      }
    }
    null != this._previewPlane && null == this._frameTask && 0 === this._previewPlaneOpacity ? this._frameTask = A({ update: ({ deltaTime: t9 }) => {
      this._previewPlaneOpacity = Math.min(this._previewPlaneOpacity + t9 / (1e3 * p3), 1), this._updateManipulators(), 1 === this._previewPlaneOpacity && this._removeFrameTask();
    } }) : null == this._previewPlane && null != this._frameTask ? this._removeFrameTask() : null != this._previewPlane && this._updateManipulators();
  }
  _removeFrameTask() {
    this._frameTask = l(this._frameTask);
  }
  _pickMinResult(t8) {
    const e3 = d2(t8, t3.get());
    return this.view.sceneIntersectionHelper.intersectToolIntersectorScreen(e3, this._intersector), this._intersector.results.min;
  }
  _pickPlane(t8, e3, i, a4) {
    const s3 = this._pickMinResult(t8), n6 = c3.get();
    if (!s3.getIntersectionPoint(n6))
      return false;
    const r3 = s3.getTransformedNormal(c3.get()), l3 = this.view.state.camera;
    P(r3, l3.viewForward) > 0 && g(r3, r3, -1);
    const o4 = si(n6, l3), h5 = (e3 ? 1 : -1) * o4 * h3, p4 = g(c3.get(), r3, h5);
    u2(p4, p4, n6);
    const u3 = this.analysis.tiltEnabled ? Mi.TILTED : Mi.HORIZONTAL_OR_VERTICAL, c6 = i[r2] ? Mi.VERTICAL : i[t7] ? Mi.HORIZONTAL : u3;
    return ei(p4, r3, o4, o4, l3, c6, this.view.renderCoordsHelper, a4), true;
  }
  _clearPointerMoveTimeout() {
    this._prevPointerMoveTimeout = l(this._prevPointerMoveTimeout);
  }
  _resetPointerMoveTimeout() {
    this._clearPointerMoveTimeout(), this.shiftManipulator.state |= Ci, this.rotateHeadingManipulator.state |= Ci, this.rotateTiltManipulator.state |= Ci, this._prevPointerMoveTimeout = this._clock.setTimeout(() => {
      this.shiftManipulator.state &= ~Ci, this.rotateHeadingManipulator.state &= ~Ci, this.rotateTiltManipulator.state &= ~Ci;
    }, this._pointerMoveTimerMs);
  }
  _updateManipulators() {
    if (Vt.disableEngineLayers)
      return;
    let t8, e3 = false;
    if (null != this.analysisViewData.plane)
      t8 = this.analysisViewData.plane, e3 = false;
    else {
      if (null == this._previewPlane)
        return this.shiftManipulator.available = false, this.rotateHeadingManipulator.available = false, this.rotateTiltManipulator.available = false, this.resizeManipulators.forEach((t9) => t9.available = false), this._previewPlaneOutlineVisualElement.visible = false, void (this._previewPlaneGridVisualElement.visible = false);
      t8 = this._previewPlane, e3 = true;
    }
    const i = ci(t8, f.get());
    e3 ? (this.shiftManipulator.available = false, this.rotateHeadingManipulator.available = false, this.rotateTiltManipulator.available = false, this.resizeManipulators.forEach((t9) => t9.available = false), this._previewPlaneOutlineVisualElement.attached = true, this._previewPlaneGridVisualElement.attached = true, this._previewPlaneOutlineVisualElement.visible = true, this._previewPlaneGridVisualElement.visible = true) : (this.shiftManipulator.available = true, this.rotateHeadingManipulator.available = true, this.rotateTiltManipulator.available = this.analysis.tiltEnabled, this.resizeManipulators.forEach((t9) => t9.available = true), ui(this.shiftManipulator, i, t8, this.view.state.camera), mi(this.rotateHeadingManipulator, i, t8, this.view.renderCoordsHelper), pi(this.rotateTiltManipulator, i, t8), this.resizeManipulators.forEach((e4, a5) => gi(e4, this._resizeHandles[a5], i, t8)), this._previewPlaneOutlineVisualElement.visible = false, this._previewPlaneGridVisualElement.visible = false);
    const a4 = o2(c3.get(), s(t8.basis1), s(t8.basis2), 1), s3 = d3(f.get(), a4), n6 = c2(s3, i, s3);
    this._previewPlaneOutlineVisualElement.transform = n6, this._previewPlaneGridVisualElement.transform = n6, this._updateMaterials();
  }
  _updateMaterials() {
    const t8 = e2(this.view.effectiveTheme);
    t8[3] *= this._previewPlaneOpacity;
    const e3 = t2(t6);
    e3[3] *= this._previewPlaneOpacity, this._previewPlaneOutlineVisualElement.color = t8, this._previewPlaneGridVisualElement.backgroundColor = e3, this._previewPlaneGridVisualElement.gridColor = _;
  }
  _updateManipulatorsInteractive(t8) {
    if (!t8.grabbing)
      return this.shiftManipulator.interactive = true, this.rotateHeadingManipulator.interactive = true, this.rotateTiltManipulator.interactive = true, void this.resizeManipulators.forEach((t9) => {
        t9.interactive = true;
      });
    this.shiftManipulator.interactive = this.shiftManipulator === t8, this.rotateHeadingManipulator.interactive = this.rotateHeadingManipulator === t8, this.rotateTiltManipulator.interactive = this.rotateTiltManipulator === t8, this.resizeManipulators.forEach((e3) => {
      e3.interactive = e3 === t8;
    });
  }
  testData() {
    return { plane: this.analysisViewData.plane, setPointerMoveTimerMs: (t8) => {
      this._pointerMoveTimerMs = t8;
    } };
  }
};
function Tt(t8, e3, i, a4) {
  const s3 = ai(i, ds(a4), t8.direction, E()), n6 = n2();
  return S2(s3, t8, n6) ? { type: "shift", creatingPointerId: e3, hasBeenDragged: false, shiftPlane: s3, depth: 0, startPoint: n6 } : null;
}
function Et(t8) {
  return "mouse" !== t8.pointerType || 0 === t8.button;
}
bt.disableEngineLayers = false, e([y()], bt.prototype, "_clock", void 0), e([y({ constructOnly: true })], bt.prototype, "view", void 0), e([y()], bt.prototype, "analysisViewData", void 0), e([y({ readOnly: true })], bt.prototype, "state", null), e([y({ readOnly: true })], bt.prototype, "cursor", null), e([y()], bt.prototype, "analysis", null), e([y()], bt.prototype, "removeIncompleteOnCancel", void 0), e([y()], bt.prototype, "_layersMode", void 0), e([y()], bt.prototype, "layersMode", null), e([y({ value: null })], bt.prototype, "inputState", null), e([y()], bt.prototype, "_isPlacingSlicePlane", null), e([y()], bt.prototype, "_creatingPointerId", null), bt = Vt = e([a("esri.views.3d.analysis.Slice.SliceTool")], bt);
var kt = W();
var St = d4();
var xt = bt;

// node_modules/@arcgis/core/views/3d/analysis/Slice/SliceVisualization.js
var b2 = class extends S {
  constructor(i) {
    super(i), this._gridVisualElement = null, this._outlineVisualElement = null, this.showGrid = false, this.preview = true;
  }
  initialize() {
    const i = this.analysisViewData;
    if (null == i)
      throw new Error("expected internal object to be valid");
    this._gridVisualElement = ji(this.view), this._outlineVisualElement = Ai(this.view), this.addHandles([d(() => {
      const e3 = null != i.plane && this.analysisViewData.visible, { active: t8 } = this.analysisViewData, { preview: s3, showGrid: o4, view: r3 } = this, { effectiveTheme: l3 } = r3;
      return { visible: e3, active: t8, preview: s3, showGrid: o4, gridColor: c4(l3), outlineColor: e2(l3) };
    }, (i2) => this._updateMaterials(i2), A2), d(() => i.plane, (i2) => this._updatePlane(i2), A2)], "internal");
  }
  destroy() {
    this._gridVisualElement = u(this._gridVisualElement), this._outlineVisualElement = u(this._outlineVisualElement), this.set("view", null);
  }
  _updatePlane(i) {
    if (null == i)
      return;
    this._gridVisualElement.attached = true, this._outlineVisualElement.attached = true;
    const e3 = o2(c3.get(), s(i.basis1), s(i.basis2), 1), t8 = d3(f.get(), e3), s3 = ci(i, f.get()), o4 = c2(t8, s3, t8);
    this._outlineVisualElement.transform = o4, this._gridVisualElement.transform = o4;
  }
  _updateMaterials({ visible: i, active: e3, preview: t8, showGrid: s3, gridColor: o4, outlineColor: r3 }) {
    this._outlineVisualElement.color = r3, this._outlineVisualElement.width = t8 ? M : j, this._outlineVisualElement.stipplePattern = e3 ? null : h(5), this._gridVisualElement.backgroundColor = t6, this._gridVisualElement.gridColor = s3 ? o4 : _, this._gridVisualElement.visible = i, this._outlineVisualElement.visible = i;
  }
};
e([y()], b2.prototype, "view", void 0), e([y()], b2.prototype, "analysis", void 0), e([y()], b2.prototype, "analysisViewData", void 0), e([y()], b2.prototype, "showGrid", void 0), e([y()], b2.prototype, "preview", void 0), b2 = e([a("esri.views.3d.analysis.Slice.SliceVisualization")], b2);

// node_modules/@arcgis/core/views/3d/analysis/SliceAnalysisView3D.js
var h4 = class extends s2(S) {
  constructor(i) {
    super(i), this.type = "slice-view-3d", this.analysis = null, this.tool = null, this.analysisVisualization = null, this.analysisController = null, this.plane = null, this.active = true;
  }
  initialize() {
    this.analysisVisualization = new b2({ view: this.view, analysis: this.analysis, analysisViewData: this }), this.analysisController = new v3({ view: this.view, analysis: this.analysis, analysisViewData: this }), this.addHandles(a2(this, xt));
  }
  destroy() {
    v(this), this.analysisVisualization = u(this.analysisVisualization), this.analysisController = u(this.analysisController);
  }
  get showGrid() {
    var _a;
    return ((_a = this.analysisVisualization) == null ? void 0 : _a.showGrid) ?? false;
  }
  set showGrid(i) {
    this.analysisVisualization && (this.analysisVisualization.showGrid = i);
  }
  get editable() {
    return !this.analysisVisualization.preview;
  }
  set editable(i) {
    this.analysisVisualization.preview = !i;
  }
  get testData() {
    return { visualization: this.analysisVisualization, controller: this.analysisController, tool: this.tool };
  }
};
e([y({ readOnly: true })], h4.prototype, "type", void 0), e([y({ constructOnly: true, nonNullable: true })], h4.prototype, "analysis", void 0), e([y()], h4.prototype, "tool", void 0), e([y()], h4.prototype, "plane", void 0), e([y()], h4.prototype, "active", void 0), e([y()], h4.prototype, "showGrid", null), e([y()], h4.prototype, "editable", null), h4 = e([a("esri.views.3d.analysis.SliceAnalysisView3D")], h4);
var c5 = h4;
export {
  c5 as default
};
//# sourceMappingURL=SliceAnalysisView3D-6NF2EOXD.js.map
