import {
  f as f2
} from "./chunk-DH7BG2VH.js";
import {
  h as h4,
  u as u4,
  y as y3
} from "./chunk-WTKF56EK.js";
import {
  h as h5,
  l as l4
} from "./chunk-3RIV3ECV.js";
import {
  E,
  G as G2,
  I as I3,
  O as O3,
  Q,
  V as V2,
  _ as _2,
  _2 as _3,
  b as b2,
  c as c5,
  d as d2,
  h as h6,
  j as j2
} from "./chunk-XJICXW6N.js";
import {
  A,
  b,
  k,
  w as w2,
  y as y4
} from "./chunk-YF5E2R37.js";
import {
  g as g3,
  h as h3,
  l as l3,
  p as p2,
  u as u3
} from "./chunk-QJRGTKPN.js";
import {
  a as a3,
  i as i3
} from "./chunk-VIH3KDZO.js";
import {
  c as c4
} from "./chunk-LQBHIBXV.js";
import {
  R
} from "./chunk-WIVZ7SMV.js";
import {
  a as a2
} from "./chunk-O76UVYOO.js";
import {
  I as I2
} from "./chunk-QCMUK3QA.js";
import {
  n as n5
} from "./chunk-HZSGATFT.js";
import {
  e as e5,
  o as o2
} from "./chunk-KNMQQRV7.js";
import {
  e as e3
} from "./chunk-N5GQOIDP.js";
import {
  e as e4
} from "./chunk-NFB6O77E.js";
import {
  D as D2,
  I,
  O as O2,
  c as c3,
  f,
  h as h2,
  p
} from "./chunk-HWHMO3CO.js";
import {
  D,
  c as c2,
  i as i2
} from "./chunk-326OSIM5.js";
import {
  l
} from "./chunk-R4CJB3GP.js";
import {
  m
} from "./chunk-ONK5AE7R.js";
import {
  j
} from "./chunk-HV6S3GY2.js";
import {
  O,
  S,
  e as e2,
  g as g2,
  o,
  u as u2,
  y as y2,
  z
} from "./chunk-JZBR4X6W.js";
import {
  _,
  l as l2,
  n as n4,
  r
} from "./chunk-OIJCMME5.js";
import {
  n as n2
} from "./chunk-Z2PDA67N.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  n as n3,
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  G,
  Rt
} from "./chunk-SAYWXQVM.js";
import {
  d,
  v
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  i,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  c2 as c,
  g,
  h,
  s as s2,
  u2 as u
} from "./chunk-JGDJR5EV.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/geometry/support/meshErrors.js
var t = "Mesh must be loaded before applying operations";
var e6 = "Provided component is not part of the list of components";
var n6 = "Expected polygon to be a Polygon instance";
var s3 = "Expected location to be a Point instance";
var i4 = class extends s {
  constructor() {
    super("invalid-input:location", s3);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/bounds.js
function o3([e7, n7, r2, I5, o4, m7], u8, a5, f6) {
  i5 ?? (i5 = new Float64Array(24));
  const s4 = i5;
  return s4[0] = e7, s4[1] = n7, s4[2] = r2, s4[3] = e7, s4[4] = o4, s4[5] = r2, s4[6] = I5, s4[7] = o4, s4[8] = r2, s4[9] = I5, s4[10] = n7, s4[11] = r2, s4[12] = e7, s4[13] = n7, s4[14] = m7, s4[15] = e7, s4[16] = o4, s4[17] = m7, s4[18] = I5, s4[19] = o4, s4[20] = m7, s4[21] = I5, s4[22] = n7, s4[23] = m7, G2({ positions: s4, transform: u8, vertexSpace: a5, inSpatialReference: f6, outSpatialReference: f6, outPositions: s4 }), N(s4, f6);
}
var i5 = null;
function m2(e7) {
  if (0 === e7.length)
    return D;
  const t2 = i2([Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, -Number.POSITIVE_INFINITY, -Number.POSITIVE_INFINITY, -Number.POSITIVE_INFINITY]);
  return c2(t2, e7), t2;
}
function N(n7, r2) {
  const [I5, t2, o4, i6, N3, u8] = m2(n7);
  return new w({ xmin: I5, ymin: t2, zmin: o4, xmax: i6, ymax: N3, zmax: u8, spatialReference: r2 });
}

// node_modules/@arcgis/core/geometry/support/meshUtils/centerAt.js
var p3 = "esri.geometry.support.meshUtils.centerAt";
function l5(e7, t2, r2) {
  var _a;
  if (!((_a = e7.vertexAttributes) == null ? void 0 : _a.position))
    return;
  const { vertexSpace: i6 } = e7, o4 = (r2 == null ? void 0 : r2.origin) ?? e7.anchor, a5 = r2 == null ? void 0 : r2.geographic, c9 = c5(p3, i6, o4.spatialReference, a5);
  g3(i6) ? f3(e7, t2, o4) : c9 ? g4(e7, t2, o4) : d3(e7, t2, o4);
}
function f3(s4, a5, c9) {
  const { vertexSpace: l7 } = s4;
  if (!g3(l7))
    return;
  const f6 = u5, g7 = j3;
  if (!c4(a5, g7, s4.spatialReference))
    return void n.getLogger(p3).error(`Failed to project centerAt location (wkid:${a5.spatialReference.wkid}) to mesh spatial reference (wkid:${s4.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  if (!c4(c9, f6, s4.spatialReference)) {
    const t2 = s4.origin;
    f6[0] = t2.x, f6[1] = t2.y, f6[2] = t2.z, n.getLogger(p3).error(`Failed to project specified origin (wkid:${c9.spatialReference.wkid}) to mesh spatial reference (wkid:${s4.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  }
  const d6 = e2(b3, g7, f6);
  l7.origin = u2(n4(), l7.origin, d6);
}
function g4(e7, t2, r2) {
  const i6 = Q(e7.vertexAttributes, r2), { position: o4, normal: n7, tangent: s4 } = I3(i6, t2, false);
  e7.vertexAttributes.position = o4, e7.vertexAttributes.normal = n7, e7.vertexAttributes.tangent = s4, e7.vertexAttributesChanged();
}
function d3(t2, r2, i6) {
  const n7 = u5, s4 = j3;
  if (c4(r2, s4, t2.spatialReference)) {
    if (!c4(i6, n7, t2.spatialReference)) {
      const r3 = t2.origin;
      n7[0] = r3.x, n7[1] = r3.y, n7[2] = r3.z, n.getLogger(p3).error(`Failed to project specified origin (wkid:${i6.spatialReference.wkid}) to mesh spatial reference (wkid:${t2.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
    }
    m3(t2.vertexAttributes.position, s4, n7), t2.vertexAttributesChanged();
  } else
    n.getLogger(p3).error(`Failed to project centerAt location (wkid:${r2.spatialReference.wkid}) to mesh spatial reference (wkid:${t2.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
}
function m3(e7, t2, r2) {
  if (e7)
    for (let i6 = 0; i6 < e7.length; i6 += 3)
      for (let o4 = 0; o4 < 3; o4++)
        e7[i6 + o4] += t2[o4] - r2[o4];
}
var j3 = n4();
var u5 = n4();
var b3 = n4();

// node_modules/@arcgis/core/geometry/support/meshUtils/loadExternal.js
async function c6(e7, n7, r2) {
  const { source: o4 } = n7, { loadGLTFMesh: i6 } = await h(import("./loadGLTFMesh-RURX4BWJ.js"), r2), a5 = await f4(o4, r2);
  s2(r2);
  const c9 = i6(new x({ x: 0, y: 0, z: 0, spatialReference: e7.spatialReference }), a5.url, { resolveFile: u6(a5), signal: r2 == null ? void 0 : r2.signal, expectedType: a5.type });
  c9.then(() => a5.dispose(), () => a5.dispose());
  const { vertexAttributes: m7, components: p6 } = await c9;
  e7.vertexAttributes = m7, e7.components = p6;
}
function u6(e7) {
  const t2 = Rt(e7.url);
  return (s4) => {
    const n7 = G(s4, t2, t2), r2 = n7 ? n7.replace(/^ *\.\//, "") : null;
    return (r2 ? e7.files.get(r2) : null) ?? s4;
  };
}
async function f4(t2, s4) {
  if (Array.isArray(t2)) {
    if (!t2.length)
      throw new s("mesh-load-external:missing-assets", "There must be at least one file to load");
    return t2[0] instanceof File ? h7(t2) : y5(t2, s4);
  }
  return p4(t2);
}
async function m4(e7, t2) {
  const { parts: n7, assetMimeType: r2, assetName: o4 } = e7;
  if (1 === n7.length)
    return new j4(n7[0].partUrl);
  const i6 = await e7.toBlob(t2);
  return s2(t2), j4.fromBlob(i6, x2(o4, r2));
}
function p4(e7) {
  return j4.fromBlob(e7, x2(e7.name, e7.type));
}
function h7(e7) {
  return T(e7.map((e8) => ({ name: e8.name, mimeType: e8.type, source: p4(e8) })));
}
async function y5(e7, t2) {
  const i6 = await g(e7.map(async (e8) => {
    const n7 = await m4(e8);
    return s2(t2), { name: e8.assetName, mimeType: e8.assetMimeType, source: n7 };
  }));
  if (c(t2))
    throw i6.forEach((e8) => e8.source.dispose()), u();
  return T(i6);
}
var w3 = /^model\/gltf\+json$/;
var d4 = /^model\/gltf-binary$/;
var g5 = /\.gltf$/i;
var b4 = /\.glb$/i;
function T(t2) {
  const s4 = /* @__PURE__ */ new Map();
  let n7, r2 = null;
  for (const { name: e7, mimeType: o4, source: i6 } of t2)
    null === r2 && (w3.test(o4) || g5.test(e7) ? (r2 = i6.url, n7 = "gltf") : (d4.test(o4) || b4.test(e7)) && (r2 = i6.url, n7 = "glb")), s4.set(e7, i6.url), i6.files.forEach((e8, t3) => s4.set(t3, e8));
  if (null == r2)
    throw new s("mesh-load-external:missing-files", "Missing files to load external mesh source");
  return new j4(r2, () => t2.forEach(({ source: e7 }) => e7.dispose()), s4, n7);
}
var j4 = class _j {
  constructor(e7, t2 = () => {
  }, s4 = /* @__PURE__ */ new Map(), n7) {
    this.url = e7, this.dispose = t2, this.files = s4, this.type = n7;
  }
  static fromBlob(e7, t2) {
    const s4 = URL.createObjectURL(e7);
    return new _j(s4, () => URL.revokeObjectURL(s4), void 0, t2);
  }
};
function x2(e7, t2) {
  return w3.test(t2) || g5.test(e7) ? "gltf" : d4.test(t2) || g5.test(e7) ? "glb" : void 0;
}

// node_modules/@arcgis/core/geometry/support/meshUtils/Metadata.js
var a4 = class extends l {
  constructor() {
    super(), this.externalSources = new V(), this._explicitDisplaySource = null, this.addHandles(v(() => this.externalSources, "after-remove", ({ item: e7 }) => {
      e7 === this._explicitDisplaySource && (this._explicitDisplaySource = null);
    }, { sync: true, onListenerRemove: () => this._explicitDisplaySource = null }));
  }
  get displaySource() {
    return this._explicitDisplaySource ?? this._implicitDisplaySource;
  }
  set displaySource(e7) {
    if (null != e7 && !u4(e7))
      throw new Error("Cannot use this source for display: it is not in a supported format.");
    this._explicitDisplaySource = e7, e7 && this.externalSources.every((r2) => !y3(r2, e7)) && this.externalSources.add(e7);
  }
  clearSources() {
    this.externalSources.removeAll();
  }
  getExternalSourcesOnService(e7) {
    return this.externalSources.items.filter((r2) => h4(r2, e7));
  }
  get _implicitDisplaySource() {
    return this.externalSources.find(u4);
  }
};
e([y()], a4.prototype, "externalSources", void 0), e([y()], a4.prototype, "displaySource", null), e([y()], a4.prototype, "_implicitDisplaySource", null), e([y()], a4.prototype, "_explicitDisplaySource", void 0), a4 = e([a("esri.geometry.support.meshUtils.Metadata")], a4);

// node_modules/@arcgis/core/geometry/support/meshUtils/primitives.js
function l6() {
  const { faceDescriptions: t2, faceVertexOffsets: e7, uvScales: r2 } = M, n7 = 4 * t2.length, o4 = new Float64Array(3 * n7), s4 = new Float32Array(3 * n7), a5 = new Float32Array(2 * n7), i6 = new Uint32Array(2 * t2.length * 3);
  let l7 = 0, c9 = 0, f6 = 0, u8 = 0;
  for (let h9 = 0; h9 < t2.length; h9++) {
    const n8 = t2[h9], p6 = l7 / 3;
    for (const t3 of e7)
      i6[u8++] = p6 + t3;
    const m7 = n8.corners;
    for (let t3 = 0; t3 < 4; t3++) {
      const e8 = m7[t3];
      let i7 = 0;
      a5[f6++] = 0.25 * r2[t3][0] + n8.uvOrigin[0], a5[f6++] = n8.uvOrigin[1] - 0.25 * r2[t3][1];
      for (let t4 = 0; t4 < 3; t4++)
        0 !== n8.axis[t4] ? (o4[l7++] = 0.5 * n8.axis[t4], s4[c9++] = n8.axis[t4]) : (o4[l7++] = 0.5 * e8[i7++], s4[c9++] = 0);
    }
  }
  return { position: o4, normal: s4, uv: a5, faces: i6 };
}
function c7(t2, e7) {
  const r2 = t2.components[0], n7 = r2.faces, s4 = F[e7], a5 = 6 * s4, i6 = new Array(6), l7 = new Array(n7.length - 6);
  let c9 = 0, f6 = 0;
  for (let o4 = 0; o4 < n7.length; o4++)
    o4 >= a5 && o4 < a5 + 6 ? i6[c9++] = n7[o4] : l7[f6++] = n7[o4];
  if (null != t2.vertexAttributes.uv) {
    const e8 = new Float32Array(t2.vertexAttributes.uv), r3 = 4 * s4 * 2, n8 = [0, 1, 1, 1, 1, 0, 0, 0];
    for (let t3 = 0; t3 < n8.length; t3++)
      e8[r3 + t3] = n8[t3];
    t2.vertexAttributes.uv = e8;
  }
  return t2.components = [new h5({ faces: i6, material: r2.material }), new h5({ faces: l7 })], t2;
}
function f5(t2 = 0) {
  const e7 = Math.round(8 * 2 ** t2), r2 = 2 * e7, n7 = (e7 - 1) * (r2 + 1) + 2 * r2, o4 = new Float64Array(3 * n7), s4 = new Float32Array(3 * n7), a5 = new Float32Array(2 * n7), i6 = new Uint32Array(3 * ((e7 - 1) * r2 * 2));
  let l7 = 0, c9 = 0, f6 = 0, u8 = 0;
  for (let h9 = 0; h9 <= e7; h9++) {
    const t3 = h9 / e7 * Math.PI + 0.5 * Math.PI, n8 = Math.cos(t3), p6 = Math.sin(t3);
    b5[2] = p6;
    const m7 = 0 === h9 || h9 === e7, w5 = m7 ? r2 - 1 : r2;
    for (let g7 = 0; g7 <= w5; g7++) {
      const t4 = g7 / w5 * 2 * Math.PI;
      b5[0] = -Math.sin(t4) * n8, b5[1] = Math.cos(t4) * n8;
      for (let e8 = 0; e8 < 3; e8++)
        o4[l7] = 0.5 * b5[e8], s4[l7] = b5[e8], ++l7;
      a5[c9++] = (g7 + (m7 ? 0.5 : 0)) / r2, a5[c9++] = h9 / e7, 0 !== h9 && g7 !== r2 && (h9 !== e7 && (i6[f6++] = u8, i6[f6++] = u8 + 1, i6[f6++] = u8 - r2), 1 !== h9 && (i6[f6++] = u8, i6[f6++] = u8 - r2, i6[f6++] = u8 - r2 - 1)), u8++;
    }
  }
  return { position: o4, normal: s4, uv: a5, faces: i6 };
}
function u7(t2 = 0) {
  const e7 = 5, r2 = Math.round(16 * 2 ** t2), n7 = (e7 - 1) * (r2 + 1) + 2 * r2, o4 = new Float64Array(3 * n7), s4 = new Float32Array(3 * n7), a5 = new Float32Array(2 * n7), i6 = new Uint32Array(3 * (4 * r2));
  let l7 = 0, c9 = 0, f6 = 0, u8 = 0, h9 = 0;
  for (let p6 = 0; p6 <= e7; p6++) {
    const t3 = 0 === p6 || p6 === e7, n8 = p6 <= 1 || p6 >= e7 - 1, m7 = 2 === p6 || 4 === p6, w5 = t3 ? r2 - 1 : r2;
    for (let g7 = 0; g7 <= w5; g7++) {
      const v3 = g7 / w5 * 2 * Math.PI, A3 = t3 ? 0 : 0.5;
      b5[0] = A3 * Math.sin(v3), b5[1] = A3 * -Math.cos(v3), b5[2] = p6 <= 2 ? 0.5 : -0.5;
      for (let t4 = 0; t4 < 3; t4++)
        o4[l7++] = b5[t4], s4[c9++] = n8 ? 2 === t4 ? p6 <= 1 ? 1 : -1 : 0 : 2 === t4 ? 0 : b5[t4] / A3;
      a5[f6++] = (g7 + (t3 ? 0.5 : 0)) / r2, a5[f6++] = p6 <= 1 ? 1 * p6 / 3 : p6 <= 3 ? 1 * (p6 - 2) / 3 + 1 / 3 : 1 * (p6 - 4) / 3 + 2 / 3, m7 || 0 === p6 || g7 === r2 || (p6 !== e7 && (i6[u8++] = h9, i6[u8++] = h9 + 1, i6[u8++] = h9 - r2), 1 !== p6 && (i6[u8++] = h9, i6[u8++] = h9 - r2, i6[u8++] = h9 - r2 - 1)), h9++;
    }
  }
  return { position: o4, normal: s4, uv: a5, faces: i6 };
}
function h8(t2, e7) {
  const r2 = "number" == typeof e7 ? e7 : null != e7 ? e7.width : 1, n7 = "number" == typeof e7 ? e7 : null != e7 ? e7.height : 1;
  switch (t2) {
    case "up":
    case "down":
      return { width: r2, depth: n7 };
    case "north":
    case "south":
      return { width: r2, height: n7 };
    case "east":
    case "west":
      return { depth: r2, height: n7 };
  }
}
function p5(t2) {
  const e7 = v2.facingAxisOrderSwap[t2], r2 = v2.position, n7 = v2.normal, o4 = new Float64Array(r2.length), s4 = new Float32Array(n7.length);
  let a5 = 0;
  for (let i6 = 0; i6 < 4; i6++) {
    const t3 = a5;
    for (let i7 = 0; i7 < 3; i7++) {
      const l7 = e7[i7], c9 = Math.abs(l7) - 1, f6 = l7 >= 0 ? 1 : -1;
      o4[a5] = r2[t3 + c9] * f6, s4[a5] = n7[t3 + c9] * f6, a5++;
    }
  }
  return { position: o4, normal: s4, uv: new Float32Array(v2.uv), faces: new Uint32Array(v2.faces), isPlane: true };
}
var m5 = 1;
var w4 = 2;
var g6 = 3;
var v2 = { position: [-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0], normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], uv: [0, 1, 1, 1, 1, 0, 0, 0], faces: [0, 1, 2, 0, 2, 3], facingAxisOrderSwap: { east: [g6, m5, w4], west: [-g6, -m5, w4], north: [-m5, g6, w4], south: [m5, -g6, w4], up: [m5, w4, g6], down: [m5, -w4, -g6] } };
function A2(t2, e7, r2) {
  t2.isPlane || x3(t2), d5(t2, y6(r2 == null ? void 0 : r2.size, r2 == null ? void 0 : r2.unit, e7.spatialReference));
  const { vertexAttributes: n7, vertexSpace: i6, transform: l7 } = V2(t2, e7, { vertexSpace: r2 == null ? void 0 : r2.vertexSpace, geographic: r2 == null ? void 0 : r2.geographic });
  return { vertexAttributes: new l4({ ...n7, uv: t2.uv }), vertexSpace: i6, transform: l7, components: [new h5({ faces: t2.faces, material: (r2 == null ? void 0 : r2.material) || null })], spatialReference: e7.spatialReference };
}
function x3(t2) {
  for (let e7 = 0; e7 < t2.position.length; e7 += 3)
    t2.position[e7 + 2] += 0.5;
}
function y6(t2, e7, r2) {
  const n7 = _3(e7, r2);
  if (null == t2 && 1 === n7)
    return null;
  if (null == t2)
    return [n7, n7, n7];
  if ("number" == typeof t2) {
    const e8 = t2 * n7;
    return [e8, e8, e8];
  }
  return [null != t2.width ? t2.width * n7 : n7, null != t2.depth ? t2.depth * n7 : n7, null != t2.height ? t2.height * n7 : n7];
}
function d5(t2, n7) {
  if (null != n7) {
    O4[0] = n7[0], O4[4] = n7[1], O4[8] = n7[2];
    for (let r2 = 0; r2 < t2.position.length; r2 += 3) {
      for (let e7 = 0; e7 < 3; e7++)
        b5[e7] = t2.position[r2 + e7];
      S(b5, b5, O4);
      for (let e7 = 0; e7 < 3; e7++)
        t2.position[r2 + e7] = b5[e7];
    }
    if (n7[0] !== n7[1] || n7[1] !== n7[2]) {
      O4[0] = 1 / n7[0], O4[4] = 1 / n7[1], O4[8] = 1 / n7[2];
      for (let n8 = 0; n8 < t2.normal.length; n8 += 3) {
        for (let e7 = 0; e7 < 3; e7++)
          b5[e7] = t2.normal[n8 + e7];
        S(b5, b5, O4), z(b5, b5);
        for (let e7 = 0; e7 < 3; e7++)
          t2.normal[n8 + e7] = b5[e7];
      }
    }
  }
}
var M = { faceDescriptions: [{ axis: [0, -1, 0], uvOrigin: [0, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [1, 0, 0], uvOrigin: [0.25, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 1, 0], uvOrigin: [0.5, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [-1, 0, 0], uvOrigin: [0.75, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [0, 0, 1], uvOrigin: [0, 0.375], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 0, -1], uvOrigin: [0, 0.875], corners: [[-1, 1], [1, 1], [1, -1], [-1, -1]] }], uvScales: [[0, 0], [1, 0], [1, 1], [0, 1]], faceVertexOffsets: [0, 1, 2, 0, 2, 3] };
var F = { south: 0, east: 1, north: 2, west: 3, up: 4, down: 5 };
var b5 = n4();
var O4 = e4();

// node_modules/@arcgis/core/geometry/support/meshUtils/vertexSpaceConversion.js
function c8(o4, c9, { vertexSpace: f6, spatialReference: a5 }) {
  if ("georeferenced" === f6.type) {
    const r2 = o4;
    if (!c4(c9, r2, a5))
      return false;
    const { origin: e7 } = f6;
    return e2(o4, r2, e7), true;
  }
  const p6 = a2(a5), l7 = o4;
  if (!c4(c9, l7, p6))
    return false;
  const { origin: j5 } = f6, u8 = m6;
  if (!R(a5, j5, u8, p6))
    return false;
  const g7 = h2(m6, u8);
  return null != g7 && (O(o4, l7, g7), true);
}
var m6 = e3();

// node_modules/@arcgis/core/geometry/support/meshUtils/rotate.js
var V3 = "esri.geometry.support.meshUtils.rotate";
function D3(e7, t2, r2) {
  var _a;
  if (!((_a = e7.vertexAttributes) == null ? void 0 : _a.position) || 0 === t2[3])
    return;
  const { spatialReference: o4, vertexSpace: i6 } = e7, s4 = (r2 == null ? void 0 : r2.origin) ?? e7.anchor, a5 = r2 == null ? void 0 : r2.geographic, n7 = c5(V3, i6, o4, a5);
  p2(e7) ? E2(e7, t2, s4) : n7 ? O5(e7, t2, s4) : B(e7, t2, s4);
}
function E2(t2, r2, l7) {
  t2.transform ?? (t2.transform = new d2());
  const { vertexSpace: c9, transform: f6, spatialReference: u8 } = t2, [j5, v3, A3] = c9.origin, w5 = new x({ x: j5, y: v3, z: A3, spatialReference: u8 }), R2 = H;
  if (w5.equals(l7))
    o(R2, 0, 0, 0);
  else if (!c8(R2, l7, t2))
    return void n.getLogger(V3).error(`Failed to project specified origin (wkid:${l7.spatialReference.wkid}) to mesh (wkid:${u8.wkid}) ${c9.type} vertex space. Projection may be possible after calling projection.load().`);
  I2(W, y4(r2), A(r2));
  const P2 = D2(I4, W, l2, _, R2), { localMatrix: S3 } = f6, T3 = c3(I4, P2, S3);
  f6.scale = O2(n4(), T3), f(T3, T3, y2(H, f6.scale)), f6.rotation = k(T3), f6.translation = I(n4(), T3);
}
function O5(e7, r2, o4) {
  const i6 = e7.spatialReference, s4 = a2(i6), a5 = Q2;
  c4(o4, a5, s4) || c4(e7.origin, a5, s4);
  const n7 = e7.vertexAttributes.position, l7 = e7.vertexAttributes.normal, c9 = e7.vertexAttributes.tangent, m7 = new Float64Array(n7.length), f6 = null != l7 ? new Float32Array(l7.length) : null, p6 = null != c9 ? new Float32Array(c9.length) : null;
  R(s4, a5, K, s4), n5(N2, K);
  const g7 = J;
  S(y4(J), y4(r2), N2), g7[3] = r2[3], O3(n7, i6, m7), null != l7 && null != f6 && j2(l7, n7, m7, i6, f6), null != c9 && null != p6 && h6(c9, n7, m7, i6, p6), G3(m7, g7, 3, a5), E(m7, n7, i6), null != l7 && null != f6 && (G3(f6, g7, 3), _2(f6, n7, m7, i6, l7)), null != c9 && null != p6 && (G3(p6, g7, 4), b2(p6, n7, m7, i6, c9)), e7.vertexAttributesChanged();
}
function B(t2, r2, o4) {
  const i6 = Q2;
  if (!c4(o4, i6, t2.spatialReference)) {
    const r3 = t2.origin;
    i6[0] = r3.x, i6[1] = r3.y, i6[2] = r3.z, n.getLogger(V3).error(`Failed to project specified origin (wkid:${o4.spatialReference.wkid}) to mesh spatial reference (wkid:${t2.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  }
  G3(t2.vertexAttributes.position, r2, 3, i6), G3(t2.vertexAttributes.normal, r2, 3), G3(t2.vertexAttributes.tangent, r2, 4), t2.vertexAttributesChanged();
}
function G3(e7, t2, r2, o4 = l2) {
  if (null != e7) {
    p(K, A(t2), y4(t2));
    for (let t3 = 0; t3 < e7.length; t3 += r2) {
      for (let r3 = 0; r3 < 3; r3++)
        H[r3] = e7[t3 + r3] - o4[r3];
      O(H, H, K);
      for (let r3 = 0; r3 < 3; r3++)
        e7[t3 + r3] = H[r3] + o4[r3];
    }
  }
}
var H = n4();
var I4 = e3();
var J = b();
var K = e3();
var N2 = e4();
var Q2 = n4();
var W = e5();

// node_modules/@arcgis/core/geometry/support/meshUtils/scale.js
var $ = "esri.geometry.support.meshUtils.scale";
function P(e7, t2, r2) {
  var _a;
  if (!((_a = e7.vertexAttributes) == null ? void 0 : _a.position))
    return;
  const { vertexSpace: o4, spatialReference: i6 } = e7, s4 = (r2 == null ? void 0 : r2.origin) ?? e7.anchor, n7 = r2 == null ? void 0 : r2.geographic, a5 = c5($, o4, i6, n7);
  p2(e7) ? S2(e7, t2, s4) : a5 ? U(e7, t2, s4) : C(e7, t2, s4);
}
function S2(n7, f6, u8) {
  n7.transform ?? (n7.transform = new d2());
  const { vertexSpace: j5, transform: h9, spatialReference: b6 } = n7, [v3, w5, A3] = j5.origin, k2 = new x({ x: v3, y: w5, z: A3, spatialReference: b6 }), y7 = q;
  if (k2.equals(u8))
    o(y7, 0, 0, 0);
  else if (!c8(y7, u8, n7))
    return void n.getLogger($).error(`Failed to project specified origin (wkid:${u8.spatialReference.wkid}) to mesh (wkid:${b6.wkid}) ${j5.type} vertex space. Projection may be possible after calling projection.load().`);
  const R2 = o(z2, f6, f6, f6), P2 = D2(M2, o2, l2, R2, y7), { localMatrix: S3 } = h9, U2 = c3(M2, P2, S3);
  h9.scale = O2(n4(), U2), f(U2, U2, y2(q, h9.scale)), h9.rotation = k(U2), h9.translation = I(n4(), U2);
}
function U(e7, t2, r2) {
  const o4 = e7.spatialReference, i6 = a2(o4), s4 = T2;
  c4(r2, s4, i6) || c4(e7.origin, s4, i6);
  const n7 = e7.vertexAttributes.position, a5 = e7.vertexAttributes.normal, l7 = e7.vertexAttributes.tangent, c9 = new Float64Array(n7.length), f6 = null != a5 ? new Float32Array(a5.length) : null, p6 = null != l7 ? new Float32Array(l7.length) : null;
  O3(n7, o4, c9), null != a5 && null != f6 && j2(a5, n7, c9, o4, f6), null != l7 && null != p6 && h6(l7, n7, c9, o4, p6), L(c9, t2, s4), E(c9, n7, o4), null != a5 && null != f6 && _2(f6, n7, c9, o4, a5), null != l7 && null != p6 && b2(p6, n7, c9, o4, l7), e7.vertexAttributesChanged();
}
function C(t2, r2, o4) {
  const i6 = T2;
  if (!c4(o4, i6, t2.spatialReference)) {
    const r3 = t2.origin;
    i6[0] = r3.x, i6[1] = r3.y, i6[2] = r3.z, n.getLogger($).error(`Failed to project specified origin (wkid:${o4.spatialReference.wkid}) to mesh spatial reference (wkid:${t2.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  }
  L(t2.vertexAttributes.position, r2, i6), t2.vertexAttributesChanged();
}
function L(e7, t2, r2 = l2) {
  if (e7)
    for (let o4 = 0; o4 < e7.length; o4 += 3) {
      for (let t3 = 0; t3 < 3; t3++)
        q[t3] = e7[o4 + t3] - r2[t3];
      g2(q, q, t2);
      for (let t3 = 0; t3 < 3; t3++)
        e7[o4 + t3] = q[t3] + r2[t3];
    }
}
var q = n4();
var z2 = n4();
var M2 = e3();
var T2 = n4();

// node_modules/@arcgis/core/geometry/Mesh.js
var H2;
var K2 = "esri.geometry.Mesh";
function J2() {
  return n.getLogger(K2);
}
var Q3 = { base: null, key: "type", defaultKeyValue: "georeferenced", typeMap: { georeferenced: i3, local: a3 } };
var X = H2 = class extends m.LoadableMixin(n2(n3)) {
  constructor(e7) {
    super(e7), this.components = null, this.vertexSpace = new i3(), this.transform = null, this.metadata = new a4(), this.hasZ = true, this.hasM = false, this.vertexAttributes = new l4(), this.type = "mesh";
  }
  initialize() {
    (0 === this.metadata.externalSources.length || this.vertexAttributes.position.length) && (this.loadStatus = "loaded"), this.when(() => {
      this.addHandles(d(() => {
        var _a;
        return { vertexAttributes: this.vertexAttributes, components: (_a = this.components) == null ? void 0 : _a.map((e7) => e7.clone()) };
      }, () => this._clearSources(), { once: true, sync: true }));
    });
  }
  get hasExtent() {
    var _a;
    return this.loaded ? this.vertexAttributes.position.length > 0 && (!this.components || this.components.length > 0) : null != ((_a = this.metadata.displaySource) == null ? void 0 : _a.extent);
  }
  get _transformedExtent() {
    const { components: e7, spatialReference: t2, vertexAttributes: r2, vertexSpace: o4 } = this, s4 = r2.position;
    if (0 === s4.length || e7 && 0 === e7.length)
      return new w({ xmin: 0, ymin: 0, zmin: 0, xmax: 0, ymax: 0, zmax: 0, spatialReference: t2 });
    if (g3(o4)) {
      const { _untransformedBounds: e8, transform: r3 } = this;
      return o3(e8, r3, o4, t2);
    }
    return N(s4, t2);
  }
  get _untransformedBounds() {
    return m2(this.vertexAttributes.position);
  }
  get anchor() {
    const e7 = u3(this.vertexSpace, this.spatialReference);
    if (null != e7)
      return e7;
    const { center: t2, zmin: r2 } = this._transformedExtent;
    return new x({ x: t2.x, y: t2.y, z: r2, spatialReference: this.spatialReference });
  }
  get origin() {
    const e7 = u3(this.vertexSpace, this.spatialReference);
    return null != e7 ? e7 : this._transformedExtent.center;
  }
  get extent() {
    var _a, _b;
    return this.loaded || null == ((_b = (_a = this.metadata) == null ? void 0 : _a.displaySource) == null ? void 0 : _b.extent) ? this._transformedExtent : this.metadata.displaySource.extent.clone();
  }
  addComponent(e7) {
    this._checkIfLoaded("addComponent()") && (this.components || (this.components = []), this.components.push(h5.from(e7)), this.notifyChange("components"));
  }
  removeComponent(e7) {
    if (this._checkIfLoaded("removeComponent()")) {
      if (this.components) {
        const t2 = this.components.indexOf(e7);
        if (-1 !== t2)
          return this.components.splice(t2, 1), void this.notifyChange("components");
      }
      J2().error("removeComponent()", e6);
    }
  }
  rotate(e7, t2, r2, o4) {
    return w2(e7, t2, r2, Y), D3(this, Y, o4), this;
  }
  offset(e7, t2, r2) {
    if (!this._checkIfLoaded("offset()"))
      return this;
    const { vertexSpace: o4, vertexAttributes: s4 } = this, n7 = s4 == null ? void 0 : s4.position;
    if (!n7)
      return this;
    if (g3(o4)) {
      const [s5, n8, i6] = o4.origin;
      o4.origin = r(s5 + e7, n8 + t2, i6 + r2);
    } else {
      for (let o5 = 0; o5 < n7.length; o5 += 3)
        n7[o5] += e7, n7[o5 + 1] += t2, n7[o5 + 2] += r2;
      this.vertexAttributesChanged();
    }
    return this;
  }
  scale(e7, t2) {
    return this._checkIfLoaded("scale()") ? (P(this, e7, t2), this) : this;
  }
  centerAt(e7, t2) {
    return this._checkIfLoaded("centerAt()") ? (l5(this, e7, t2), this) : this;
  }
  load(e7) {
    const { metadata: { displaySource: t2 } } = this;
    return t2 && this.addResolvingPromise(c6(this, t2, e7)), Promise.resolve(this);
  }
  addExternalSources(e7) {
    this.metadata.externalSources.addMany(e7);
  }
  updateDisplaySource(e7) {
    this.metadata.displaySource = e7;
  }
  clone() {
    return this.cloneWithVertexSpace(this.vertexSpace.clone());
  }
  cloneWithVertexSpace(e7) {
    var _a;
    let t2 = null;
    if (this.components) {
      const e8 = /* @__PURE__ */ new Map(), r3 = /* @__PURE__ */ new Map();
      t2 = this.components.map((t3) => t3.cloneWithDeduplication(e8, r3));
    }
    const r2 = { components: t2, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes.clone(), vertexSpace: e7, transform: ((_a = this.transform) == null ? void 0 : _a.clone()) ?? null, metadata: this.metadata.clone() };
    return new H2(r2);
  }
  cloneShallow() {
    return new H2({ components: this.components, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes, vertexSpace: this.vertexSpace.clone(), transform: this.transform, metadata: this.metadata });
  }
  vertexAttributesChanged() {
    this.notifyChange("vertexAttributes");
  }
  async toBinaryGLTF(e7) {
    const t2 = import("./gltfexport-IGV4P7TR.js"), r2 = this.load(), o4 = await Promise.all([t2, r2]), { toBinaryGLTF: s4 } = o4[0];
    return s4(this, e7);
  }
  get memoryUsage() {
    let e7 = 0;
    if (e7 += this.vertexAttributes.memoryUsage, null != this.components)
      for (const t2 of this.components)
        e7 += t2.memoryUsage;
    return e7;
  }
  _clearSources() {
    this.metadata.clearSources();
  }
  _checkIfLoaded(e7) {
    return !!this.loaded || (J2().error(e7, t), false);
  }
  static createBox(e7, t2) {
    if (!(e7 instanceof x))
      return J2().error(".createBox()", s3), null;
    const r2 = new H2(A2(l6(), e7, t2));
    return (t2 == null ? void 0 : t2.imageFace) && "all" !== t2.imageFace ? c7(r2, t2.imageFace) : r2;
  }
  static createSphere(e7, t2) {
    return e7 instanceof x ? new H2(A2(f5((t2 == null ? void 0 : t2.densificationFactor) || 0), e7, t2)) : (J2().error(".createSphere()", s3), null);
  }
  static createCylinder(e7, t2) {
    return e7 instanceof x ? new H2(A2(u7((t2 == null ? void 0 : t2.densificationFactor) || 0), e7, t2)) : (J2().error(".createCylinder()", s3), null);
  }
  static createPlane(e7, t2) {
    if (!(e7 instanceof x))
      return J2().error(".createPlane()", s3), null;
    const r2 = (t2 == null ? void 0 : t2.facing) ?? "up", o4 = h8(r2, t2 == null ? void 0 : t2.size);
    return new H2(A2(p5(r2), e7, { ...t2, size: o4 }));
  }
  static createFromPolygon(e7, t2) {
    if (!(e7 instanceof j))
      return J2().error(".createFromPolygon()", n6), null;
    const r2 = f2(e7);
    return new H2({ vertexAttributes: new l4({ position: r2.position }), components: [new h5({ faces: r2.faces, shading: "flat", material: (t2 == null ? void 0 : t2.material) ?? null })], spatialReference: e7.spatialReference, vertexSpace: new i3() });
  }
  static async createFromGLTF(e7, t2, r2) {
    if (!(e7 instanceof x)) {
      const e8 = new i4();
      throw J2().error(".createfromGLTF()", e8.message), e8;
    }
    const { loadGLTFMesh: o4 } = await h(import("./loadGLTFMesh-RURX4BWJ.js"), r2);
    return new H2(await o4(e7, t2, r2));
  }
  static async createFromFiles(e7, o4, s4) {
    i(J2(), "`Mesh.createFromFiles` is deprecated in favor of 'SceneLayer.convertMesh'", { replacement: "SceneLayer.convertMesh", version: "4.29" });
    const n7 = (e8) => J2().error(".createFromFiles()", e8.message);
    if (!(e7 instanceof x)) {
      const e8 = new i4();
      throw n7(e8), e8;
    }
    if (!(s4 == null ? void 0 : s4.layer))
      throw new s("invalid:no-layer", "SceneLayer required for file to mesh conversion.");
    return s4.layer.convertMesh(o4, { location: e7, ...s4 });
  }
  static createWithExternalSource(e7, t2, r2) {
    var _a;
    const o4 = (r2 == null ? void 0 : r2.extent) ?? null, { x: s4, y: n7, z: i6, spatialReference: a5 } = e7, c9 = ((_a = r2 == null ? void 0 : r2.transform) == null ? void 0 : _a.clone()) ?? new d2(), p6 = r(s4, n7, i6 ?? 0), m7 = h3((r2 == null ? void 0 : r2.vertexSpace) ?? l3(a5), p6), h9 = { source: t2, extent: o4 }, u8 = new a4();
    return u8.externalSources.push(h9), new H2({ metadata: u8, transform: c9, vertexSpace: m7, spatialReference: a5 });
  }
  static createIncomplete(e7, t2) {
    var _a;
    const { x: o4, y: s4, z: n7, spatialReference: i6 } = e7, a5 = ((_a = t2 == null ? void 0 : t2.transform) == null ? void 0 : _a.clone()) ?? new d2(), c9 = r(o4, s4, n7 ?? 0), p6 = h3((t2 == null ? void 0 : t2.vertexSpace) ?? l3(i6), c9), m7 = new H2({ transform: a5, vertexSpace: p6, spatialReference: i6 });
    return m7.addResolvingPromise(Promise.reject(new s("mesh-incomplete", "Mesh resources are not complete"))), m7;
  }
};
e([y({ type: [h5], json: { write: true } })], X.prototype, "components", void 0), e([y({ nonNullable: true, types: Q3, constructOnly: true, json: { write: true } })], X.prototype, "vertexSpace", void 0), e([y({ type: d2, json: { write: true } })], X.prototype, "transform", void 0), e([y({ constructOnly: true })], X.prototype, "metadata", void 0), e([y()], X.prototype, "hasExtent", null), e([y()], X.prototype, "_transformedExtent", null), e([y()], X.prototype, "_untransformedBounds", null), e([y()], X.prototype, "anchor", null), e([y()], X.prototype, "origin", null), e([y({ readOnly: true, json: { read: false } })], X.prototype, "extent", null), e([y({ readOnly: true, json: { read: false, write: true, default: true } })], X.prototype, "hasZ", void 0), e([y({ readOnly: true, json: { read: false, write: true, default: false } })], X.prototype, "hasM", void 0), e([y({ type: l4, nonNullable: true, json: { write: true } })], X.prototype, "vertexAttributes", void 0), X = H2 = e([a(K2)], X);
var Y = b();
var $2 = X;

export {
  $2 as $
};
//# sourceMappingURL=chunk-N7746YEI.js.map
