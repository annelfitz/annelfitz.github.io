import {
  a as a3,
  o as o2
} from "./chunk-WRDY34WB.js";
import "./chunk-6K5SKR4X.js";
import "./chunk-6BCJJDKK.js";
import {
  t as t2
} from "./chunk-UANQJYHL.js";
import "./chunk-DNFHDQRJ.js";
import {
  f,
  y as y2
} from "./chunk-TO6UIATU.js";
import "./chunk-IB7OUIEK.js";
import "./chunk-WCBCYPOZ.js";
import "./chunk-3FTSPLRV.js";
import "./chunk-OMRW2J7M.js";
import "./chunk-UXQH3C5A.js";
import "./chunk-K3DEHPDR.js";
import "./chunk-I6RS7YIS.js";
import {
  a as a2
} from "./chunk-PGADGS3I.js";
import {
  J
} from "./chunk-54XXLVAD.js";
import "./chunk-KO7QNSNZ.js";
import {
  i,
  n,
  r
} from "./chunk-A2COVLMU.js";
import {
  h as h2
} from "./chunk-I4SHZ6P5.js";
import {
  m
} from "./chunk-PGOAFABD.js";
import "./chunk-63NZBHDP.js";
import {
  $
} from "./chunk-BNDDKY53.js";
import "./chunk-BECEVYQR.js";
import "./chunk-S243OWEZ.js";
import {
  I
} from "./chunk-QYDOVVH7.js";
import "./chunk-YSXT2SWC.js";
import "./chunk-DGRFM5OL.js";
import "./chunk-AOAT6HYL.js";
import "./chunk-YH3SFFF7.js";
import "./chunk-JBU54P54.js";
import "./chunk-UQEUYEWU.js";
import "./chunk-5LIYYE75.js";
import "./chunk-UWZ4CRJK.js";
import {
  ot
} from "./chunk-TLTAGTBA.js";
import "./chunk-2QPP5AGU.js";
import {
  t
} from "./chunk-2C26DRKK.js";
import "./chunk-M4RFJU4F.js";
import "./chunk-WVKWBQ7C.js";
import "./chunk-RK2U53CD.js";
import "./chunk-YPY24RRU.js";
import "./chunk-O7RKI2QW.js";
import "./chunk-BMB27ANS.js";
import "./chunk-3FOBZIUS.js";
import "./chunk-3AIILHI5.js";
import "./chunk-JKLFCJPR.js";
import {
  x
} from "./chunk-SA77Z3WI.js";
import "./chunk-BKOYOJBG.js";
import "./chunk-VS6AHHIY.js";
import "./chunk-XMYPMIYH.js";
import "./chunk-FQLGRQKL.js";
import "./chunk-GKMVTGGM.js";
import {
  Z
} from "./chunk-QNG4TY7L.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import "./chunk-W5ALAOW2.js";
import "./chunk-FHDHOWK5.js";
import "./chunk-IYKBAIQE.js";
import "./chunk-BDRVHR2K.js";
import "./chunk-B35SNV2V.js";
import "./chunk-Z2F5OKVA.js";
import "./chunk-UQA6M3KF.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-KNMQQRV7.js";
import "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-ERD6I7QP.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import "./chunk-I2X6UR6L.js";
import "./chunk-HV2SFSJW.js";
import "./chunk-SBARCIDP.js";
import "./chunk-3KPZ3BQR.js";
import "./chunk-5JYVZQZR.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import {
  o
} from "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-6AQIVLDN.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import {
  B,
  F,
  H
} from "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import {
  j
} from "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-PWPXYWXV.js";
import "./chunk-545NO6M2.js";
import "./chunk-5LSHHVQ5.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  P,
  d as d2,
  v
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import {
  d
} from "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  g,
  h,
  s
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import "./chunk-7RBRCL6S.js";
import {
  z
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var z2 = "graphics-collections";
var O = class extends S {
  get updating() {
    return this._updatingHandles.updating;
  }
  get _hasZ() {
    const e2 = this.view;
    return null != e2 && "3d" === e2.type && "map-notes" !== this.layerSource.layer.type;
  }
  get _snappingElevationAligner() {
    const { view: e2 } = this, { layer: t3 } = this.layerSource, o3 = null != e2 && "3d" === e2.type;
    if (!o3 || "map-notes" === t3.type)
      return i();
    const s2 = async (o4, s3) => (await h(e2.whenLayerView(t3), s3)).elevationAlignPointsInFeatures(o4, s3);
    return i(o3, { elevationInfo: t3.elevationInfo, alignPointsInFeatures: s2 });
  }
  get _snappingElevationFilter() {
    const { view: e2 } = this, t3 = null != e2 && "3d" === e2.type && "map-notes" !== this.layerSource.layer.type;
    return r(t3);
  }
  get _symbologySnappingFetcher() {
    const { view: e2 } = this, { layer: t3 } = this.layerSource, o3 = null != e2 && "3d" === e2.type, s2 = this._extrudedPolygonSymbolsCount > 0;
    return o3 && "map-notes" !== t3.type && s2 ? n(s2, async (o4, s3) => {
      const r2 = await e2.whenLayerView(t3);
      return s(s3), r2.queryForSymbologySnapping({ candidates: o4, spatialReference: e2.spatialReference }, s3);
    }) : n();
  }
  constructor(e2) {
    super(e2), this.availability = 1, this._sources = { multipoint: null, point: null, polygon: null, polyline: null }, this._loadedWkids = /* @__PURE__ */ new Set(), this._loadedWkts = /* @__PURE__ */ new Set(), this._pendingAdds = [], this._extrudedPolygonSymbolsCount = 0, this._updatingHandles = new h2(), this._memoizedMakeGetGroundElevation = t2(o2);
  }
  destroy() {
    for (const e2 of this._pendingAdds)
      e2.task.abort();
    this._pendingAdds.length = 0, this._mapSources((e2) => this._destroySource(e2)), this._updatingHandles.destroy();
  }
  initialize() {
    this._updatingHandles.add(() => this.getGraphicsLayers(), (e3) => {
      this._updatingHandles.removeHandles(z2);
      for (const t4 of e3)
        this._addMany(t4.graphics.toArray()), this.addHandles([t4.on("graphic-update", (e4) => this._onGraphicUpdate(e4)), this._updatingHandles.addOnCollectionChange(() => t4.graphics, (e4) => this._onGraphicsChanged(e4))], z2);
    }, P);
    const { view: e2 } = this, { layer: t3 } = this.layerSource;
    null != e2 && "3d" === e2.type && "map-notes" !== t3.type && e2.elevationProvider && this.addHandles([e2.elevationProvider.on("elevation-change", ({ context: e3 }) => {
      x(e3, t3.elevationInfo) && this._snappingElevationAligner.notifyElevationSourceChange();
    }), d2(() => t3.elevationInfo, () => this._snappingElevationAligner.notifyElevationSourceChange(), P), v(() => t3, ["edits", "apply-edits", "graphic-update"], () => this._symbologySnappingFetcher.notifySymbologyChange())]);
  }
  async fetchCandidates(e2, t3) {
    const { point: o3, coordinateHelper: { spatialReference: s2 } } = e2, r2 = await g(this._mapSources((o4) => this._fetchCandidatesForSource(o4, e2, t3)));
    s(t3);
    const a4 = this._memoizedMakeGetGroundElevation(this.view, s2), p = r2.flat().map((e3) => a3(e3, a4));
    return f(o3, p), p;
  }
  async _fetchCandidatesForSource(e2, t3, o3) {
    var _a;
    const s2 = y2(t3, ((_a = this.view) == null ? void 0 : _a.type) ?? "2d"), r2 = await e2.queryEngine.executeQueryForSnapping(s2, o3);
    s(o3);
    const n2 = await this._snappingElevationAligner.alignCandidates(r2.candidates, t3.coordinateHelper.spatialReference, o3);
    s(o3);
    const a4 = await this._symbologySnappingFetcher.fetch(n2, o3);
    s(o3);
    const p = 0 === a4.length ? n2 : [...n2, ...a4];
    return this._snappingElevationFilter.filter(s2, p);
  }
  refresh() {
  }
  _onGraphicUpdate(e2) {
    if (this.getGraphicsLayers().some((t3) => t3.graphics.includes(e2.graphic)))
      switch (e2.property) {
        case "geometry":
        case "visible":
          this._remove(e2.graphic), this._addMany([e2.graphic]);
      }
  }
  _onGraphicsChanged(e2) {
    for (const t3 of e2.removed)
      this._remove(t3);
    this._addMany(e2.added);
  }
  _addMany(e2) {
    const t3 = [], o3 = /* @__PURE__ */ new Map();
    for (const s2 of e2)
      null != s2.geometry && (this._needsInitializeProjection(s2.geometry.spatialReference) ? (t3.push(s2.geometry.spatialReference), o3.set(s2.uid, s2)) : this._add(s2));
    this._createPendingAdd(t3, o3);
  }
  _createPendingAdd(e2, t3) {
    if (!e2.length)
      return;
    const r2 = d(async (o3) => {
      await H(e2.map((e3) => ({ source: e3, dest: this.spatialReference })), { signal: o3 }), this._markLoadedSpatialReferences(e2);
      for (const [, e3] of t3)
        this._add(e3);
    });
    this._updatingHandles.addPromise(r2.promise);
    const i2 = { task: r2, graphics: t3 }, n2 = () => z(this._pendingAdds, i2);
    r2.promise.then(n2, n2), this._pendingAdds.push(i2);
  }
  _markLoadedSpatialReferences(e2) {
    for (const t3 of e2) {
      null != t3.wkid && this._loadedWkids.add(t3.wkid);
      const e3 = t3.wkt2 || t3.wkt;
      e3 && this._loadedWkts.add(e3);
    }
  }
  _add(e2) {
    if (null == e2.geometry || !e2.visible)
      return;
    let t3 = e2.geometry;
    if ("mesh" === t3.type)
      return;
    "extent" === t3.type && (t3 = j.fromExtent(t3));
    const o3 = this._ensureSource(t3.type);
    if (null == o3)
      return;
    const s2 = this._createOptimizedFeature(e2.uid, t3);
    null != s2 && (o3.featureStore.add(s2), J(e2.symbol) && this._extrudedPolygonSymbolsCount++);
  }
  _needsInitializeProjection(e2) {
    if (null != e2.wkid && this._loadedWkids.has(e2.wkid))
      return false;
    const t3 = e2.wkt2 || e2.wkt;
    return (!t3 || !this._loadedWkts.has(t3)) && !F(e2, this.spatialReference);
  }
  _createOptimizedFeature(e2, t3) {
    const o3 = B(a2(t3), this.spatialReference);
    if (!o3)
      return null;
    const s2 = this._ensureGeometryHasZ(o3), r2 = ot(s2, this._hasZ, false);
    return new t(r2, { [U]: e2 }, null, e2);
  }
  _ensureGeometryHasZ(e2) {
    if (!this._hasZ)
      return e2;
    const t3 = (e3) => {
      for (; e3.length < 3; )
        e3.push(0);
    }, o3 = e2.clone();
    switch (o3.hasZ = true, o3.type) {
      case "point":
        o3.z = o3.z ?? 0;
        break;
      case "multipoint":
        o3.points.forEach(t3);
        break;
      case "polyline":
        o3.paths.forEach((e3) => e3.forEach(t3));
        break;
      case "polygon":
        o3.rings.forEach((e3) => e3.forEach(t3));
    }
    return o3;
  }
  _ensureSource(e2) {
    const t3 = this._sources[e2];
    if (null != t3)
      return t3;
    const o3 = this._createSource(e2);
    return this._sources[e2] = o3, o3;
  }
  _createSource(e2) {
    const t3 = o.toJSON(e2), o3 = this._hasZ, s2 = new m({ geometryType: t3, hasZ: o3, hasM: false });
    return { featureStore: s2, queryEngine: new $({ featureStore: s2, fieldsIndex: Z.fromLayerJSON({ fields: [{ name: U, type: "esriFieldTypeOID", alias: U }] }), geometryType: t3, hasM: false, hasZ: o3, objectIdField: U, spatialReference: this.spatialReference, priority: I.SNAPPING, scheduler: null != this.view && "3d" === this.view.type ? this.view.resourceController.scheduler : null }), type: e2 };
  }
  _remove(e2) {
    this._mapSources((t3) => this._removeFromSource(t3, e2));
    for (const t3 of this._pendingAdds)
      t3.graphics.delete(e2.uid), 0 === t3.graphics.size && t3.task.abort();
  }
  _removeFromSource(e2, t3) {
    const o3 = t3.uid;
    e2.featureStore.has(o3) && (e2.featureStore.removeById(t3.uid), J(t3.symbol) && this._extrudedPolygonSymbolsCount--);
  }
  _destroySource(e2) {
    e2.queryEngine.destroy(), this._sources[e2.type] = null;
  }
  _mapSources(e2) {
    const { point: t3, polygon: o3, polyline: s2, multipoint: r2 } = this._sources, i2 = [];
    return null != t3 && i2.push(e2(t3)), null != o3 && i2.push(e2(o3)), null != s2 && i2.push(e2(s2)), null != r2 && i2.push(e2(r2)), i2;
  }
};
e([y()], O.prototype, "getGraphicsLayers", void 0), e([y({ constructOnly: true })], O.prototype, "layerSource", void 0), e([y({ constructOnly: true })], O.prototype, "spatialReference", void 0), e([y({ constructOnly: true })], O.prototype, "view", void 0), e([y({ readOnly: true })], O.prototype, "updating", null), e([y({ readOnly: true })], O.prototype, "availability", void 0), e([y()], O.prototype, "_hasZ", null), e([y()], O.prototype, "_snappingElevationAligner", null), e([y()], O.prototype, "_snappingElevationFilter", null), e([y()], O.prototype, "_symbologySnappingFetcher", null), e([y()], O.prototype, "_extrudedPolygonSymbolsCount", void 0), O = e([a("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], O);
var U = "OBJECTID";
export {
  O as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-XK4VOLZL.js.map
