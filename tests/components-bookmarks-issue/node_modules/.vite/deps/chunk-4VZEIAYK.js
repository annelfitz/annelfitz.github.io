import {
  l as l6,
  s as s6
} from "./chunk-LVTZ43ZA.js";
import {
  r as r4
} from "./chunk-JZMK5M5U.js";
import {
  c as c2,
  t as t2
} from "./chunk-OOISODT4.js";
import {
  a as a2
} from "./chunk-V7NVRGBC.js";
import {
  T
} from "./chunk-46T3D2EU.js";
import {
  d as d2,
  l as l5
} from "./chunk-BSYULFZQ.js";
import {
  u as u5
} from "./chunk-SCRCLNT5.js";
import {
  a,
  n as n6,
  r as r3
} from "./chunk-YKIGDW5O.js";
import {
  l as l4
} from "./chunk-ESK2YRQM.js";
import {
  n as n4
} from "./chunk-D56W4LPT.js";
import {
  l as l3
} from "./chunk-WZJNHZ6H.js";
import {
  c,
  i as i2
} from "./chunk-LQBHIBXV.js";
import {
  R as R2
} from "./chunk-WIVZ7SMV.js";
import {
  n as n5,
  u as u4
} from "./chunk-HZSGATFT.js";
import {
  e as e2
} from "./chunk-N5GQOIDP.js";
import {
  e as e3
} from "./chunk-NFB6O77E.js";
import {
  f as f2
} from "./chunk-QYC3GV65.js";
import {
  R,
  b as b2,
  l as l2,
  p as p2
} from "./chunk-HWHMO3CO.js";
import {
  E,
  I,
  N,
  P as P2,
  S as S2,
  h as h2,
  i,
  o as o2,
  s as s5,
  w as w2
} from "./chunk-326OSIM5.js";
import {
  B,
  C,
  D
} from "./chunk-2ICUS4HL.js";
import {
  u as u2
} from "./chunk-HV6S3GY2.js";
import {
  H,
  b,
  u as u3
} from "./chunk-C7NPPGFR.js";
import {
  M,
  h,
  l,
  m
} from "./chunk-OCF7OAES.js";
import {
  O,
  P,
  S,
  U,
  _ as _2,
  e,
  g,
  j,
  o,
  p,
  r as r2,
  s as s4,
  u,
  x as x2,
  z
} from "./chunk-JZBR4X6W.js";
import {
  n as n3,
  r,
  t
} from "./chunk-OIJCMME5.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  d,
  n as n2,
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  s3
} from "./chunk-UWQ3OYA5.js";
import {
  _
} from "./chunk-BVQWKK2V.js";
import {
  s as s2
} from "./chunk-JGDJR5EV.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/views/3d/camera/intersectionUtils.js
function u6(e4, r5, t3, n7) {
  return null != e4.renderCoordsHelper.fromRenderCoords(r5.eye, M2, n7) && b(t3, M2);
}
function f3(e4, r5) {
  return e4.elevationProvider ? e4.elevationProvider.getElevation(r5[0], r5[1], r5[2], e4.renderCoordsHelper.spatialReference, "ground") ?? 0 : 0;
}
function g2(o3, s7, a3, c3) {
  const l7 = o3.state.camera.clone();
  s7 && a3 && c3 && (l7.eye = s7, l7.center = a3, l7.up = c3), m2(o3, l7.ray, b3) || r2(b3, l7.center);
  const d4 = o3.state.constraints, u8 = d4.minimumPoiDistance;
  if (p(l7.eye, b3) < u8) {
    const r5 = d4.collision.enabled;
    r2(w3, l7.viewForward), g(w3, w3, u8), r5 ? l7.eye = e(M2, b3, w3) : u(b3, l7.eye, w3);
    const s8 = o3.renderCoordsHelper, a4 = s8.getAltitude(l7.eye), c4 = d4.collision.elevationMargin;
    r5 && a4 < c4 && (e(w3, b3, l7.eye), l7.eye = s8.setAltitude(M2, c4, l7.eye), u(b3, l7.eye, w3));
  }
  return l7.center = b3, l7;
}
function p3(e4, t3, n7) {
  if (!e4.state.isGlobal || !e4.stateManager.constraintsManager)
    return false;
  const i3 = f3(e4, t3), o3 = e4.stateManager.constraintsManager.nearFarHeuristic, { far: s7 } = o3.compute(t3, n7, e4.renderDataExtent, i3, H2), a3 = s7 * s7;
  return p(t3, n7) > a3;
}
function m2(e4, r5, t3) {
  let n7 = v[e4.viewingMode];
  n7 || (n7 = T(e4.state.viewingMode), n7.options.backfacesTerrain = !e4.state.isGlobal, n7.options.invisibleTerrain = true, v[e4.viewingMode] = n7);
  const { isGlobal: i3 } = e4.state;
  return !(!e4.sceneIntersectionHelper.intersectRay(r5, n7, t3) || p3(e4, r5.origin, t3)) || (!(!e4.renderCoordsHelper.intersectManifold(r5, 0, t3) || p3(e4, r5.origin, t3)) || !!i3 && y(r5, t3, s3(e4.spatialReference).radius));
}
function y(e4, r5, n7) {
  const a3 = P(e4.origin, e4.origin) - n7 * n7, c3 = a3 > 0 ? Math.sqrt(a3) / 3 : 1;
  return g(r5, e4.direction, c3 / s4(e4.direction)), u(r5, r5, e4.origin), true;
}
var v = {};
var M2 = n3();
var b3 = n3();
var w3 = n3();
var H2 = { near: 0, far: 0 };

// node_modules/@arcgis/core/views/3d/support/cameraUtilsInternal.js
var f4 = n3();
var m3 = n3();
function h3() {
  return { direction: n3(), up: n3() };
}
function u7(l7, h5, u8, p4, b5) {
  let d4 = z(f4, l7), g4 = P(d4, p4);
  const j3 = g4 > 0;
  g4 = Math.abs(g4), g4 > 0.99 && (g4 = Math.abs(P(h5, p4)), g4 < 0.99 ? (r2(d4, h5), j3 && g(d4, d4, -1)) : d4 = null);
  let k3 = 0;
  if (d4) {
    g(m3, p4, P(p4, d4)), e(d4, d4, m3);
    const o3 = P(d4, b5) / (s4(d4) * s4(b5));
    _2(m3, d4, b5);
    k3 = (P(m3, p4) > 0 ? 1 : -1) * M(m(o3));
  }
  const v4 = M(m(-P(p4, l7) / s4(l7)));
  return u8 ? (u8.heading = k3, u8.tilt = v4, u8) : { heading: k3, tilt: v4 };
}

// node_modules/@arcgis/core/chunks/cameraUtilsPlanar.js
var j2 = r(0, 1, 0);
var d3 = r(0, 0, 1);
var g3 = e2();
var y2 = n3();
var x3 = n3();
function h4(t3, i3, c3, s7 = h3()) {
  const { direction: m4, up: l7 } = s7;
  return R(g3, -h(i3)), l2(g3, g3, h(c3)), O(m4, d3, g3), g(m4, m4, -1), O(l7, j2, g3), s7;
}
function b4(t3, e4, o3, r5) {
  return u7(e4, o3, r5, d3, j2);
}
function v2(t3, e4, o3, r5) {
  const i3 = h4(t3, o3, r5), n7 = n3();
  return g(n7, i3.direction, -e4), u(n7, n7, t3), { up: i3.up, eye: n7, heading: o3, tilt: r5 };
}
function R3(e4) {
  return M(e4);
}
function _3(t3) {
  return h(t3);
}
function E2(t3, e4, o3, r5, i3) {
  const n7 = t3.renderSpatialReference, a3 = t3.map && t3.spatialReference || e4.spatialReference;
  return c(e4, y2, n7), c(e4, x3, n7), y2[0] -= o3 / 2, x3[0] += o3 / 2, y2[1] -= r5 / 2, x3[1] += r5 / 2, n4(y2, n7, y2, a3), n4(x3, n7, x3, a3), i3 ? (i3.xmin = y2[0], i3.ymin = y2[1], i3.xmax = x3[0], i3.ymax = x3[1], i3.spatialReference = a3) : i3 = new w(y2[0], y2[1], x3[0], x3[1], a3), i3;
}
var H3 = Object.freeze(Object.defineProperty({ __proto__: null, directionToHeadingTilt: b4, eyeForCenterWithHeadingTilt: v2, eyeTiltToLookAtTilt: _3, headingTiltToDirectionUp: h4, lookAtTiltToEyeTilt: R3, toExtent: E2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/cameraUtilsSpherical.js
var I2 = r(0, 0, 1);
var P3 = z(n3(), r(1, 1, 1));
var U2 = new n6(-180, 180);
var v3 = e2();
var w4 = n3();
var q = n3();
function S3(t3, e4, i3, a3 = h3()) {
  _2(w4, t3, I2), 0 === P(w4, w4) && _2(w4, t3, P3), p2(v3, -h(e4), t3), b2(v3, v3, -h(i3), w4);
  const { up: s7, direction: p4 } = a3;
  return _2(s7, w4, t3), z(s7, s7), O(s7, s7, v3), z(p4, t3), j(p4, p4), O(p4, p4, v3), a3;
}
function _4(t3, e4, o3, i3) {
  const a3 = w4, r5 = q;
  return z(a3, t3), _2(q, a3, I2), 0 === P(q, q) && _2(q, a3, P3), _2(r5, q, a3), u7(e4, o3, i3, a3, r5);
}
function k(t3, e4, i3, r5) {
  const n7 = { eye: n3(), up: null, tilt: r5, heading: i3 }, s7 = w4;
  s7[0] = t3[0], s7[1] = t3[2], s7[2] = -t3[1];
  const c3 = e4, l7 = h(i3), m4 = h(r5), f5 = Math.sin(l7), h5 = Math.cos(l7), y3 = Math.sin(m4), d4 = Math.cos(m4), g4 = s4(s7);
  let j3;
  if (Math.abs(m4) < 1e-8)
    j3 = c3 + g4;
  else {
    const t4 = g4 / y3, e5 = l(c3 / t4), o3 = Math.PI - m4 - e5;
    j3 = t4 * Math.sin(o3);
  }
  const T2 = d4 * c3, b5 = c3 * c3 * (y3 * y3), x4 = h5 * h5 * b5, R4 = j3 - T2, I4 = R4 * R4, P4 = x4 * (x4 + I4 - s7[1] * s7[1]);
  if (P4 < 0)
    return g(n7.eye, s7, j3 / g4), n7.tilt = 0, H4(n7, t3);
  const U3 = Math.sqrt(P4), v4 = s7[1] * R4, q3 = x4 + I4;
  let S4;
  if (S4 = h5 > 0 ? -U3 + v4 : U3 + v4, Math.abs(q3) < 1e-8)
    return g4 < 1e-8 ? (n7.eye[0] = 0, n7.eye[1] = 0, n7.eye[2] = c3) : g(n7.eye, s7, j3 / g4), n7.tilt = 0, E3(n7.eye), H4(n7, t3);
  n7.eye[1] = S4 / q3;
  const _6 = f5 * f5 * b5, k3 = y3 * c3, W3 = h5 * k3 * n7.eye[1], z3 = n7.eye[1] * n7.eye[1], A2 = 1 - z3, C3 = Math.sqrt(A2), F2 = x4 * z3 + _6 - 2 * W3 * C3 * R4 + A2 * I4;
  return Math.abs(F2) < 1e-8 ? (g(n7.eye, s7, j3 / g4), n7.tilt = 0, E3(n7.eye), H4(n7, t3)) : (n7.eye[0] = (A2 * (j3 * s7[0] - T2 * s7[0]) - k3 * C3 * (s7[0] * n7.eye[1] * h5 + s7[2] * f5)) / F2, n7.eye[2] = (A2 * (j3 * s7[2] - T2 * s7[2]) - k3 * C3 * (s7[2] * n7.eye[1] * h5 - s7[0] * f5)) / F2, g(n7.eye, n7.eye, j3), E3(n7.eye), H4(n7, t3));
}
function E3(t3) {
  const e4 = t3[1];
  t3[1] = -t3[2], t3[2] = e4;
}
function H4(t3, e4) {
  const o3 = S3(e4, t3.heading, t3.tilt);
  return t3.up = o3.up, t3;
}
function W(t3, e4, o3) {
  const r5 = s4(e4), n7 = Math.sqrt(o3 * o3 + r5 * r5 - 2 * o3 * r5 * Math.cos(Math.PI - t3)), s7 = l(o3 / (n7 / Math.sin(t3)));
  return M(t3 - s7);
}
function z2(t3, e4, i3) {
  const r5 = h(t3), n7 = s4(e4);
  return l(i3 / (n7 / Math.sin(r5))) + r5;
}
function A(t3, a3, r5, n7, s7) {
  let c3, l7, m4, f5;
  const h5 = a3.latitude, p4 = s3(t3.spatialReference).radius, u8 = a3.longitude, y3 = l6(h5, r5, p4) / 2;
  c3 = u8 - y3, l7 = u8 + y3;
  const M3 = h(h5), b5 = (1 + Math.sin(M3)) / (1 - Math.sin(M3)), x4 = (b5 + 1) * Math.tan(n7 / p4 / 2), I4 = x4 * x4;
  function P4(t4) {
    const o3 = Math.PI / 2;
    return (t4 = r3.normalize(t4, -o3)) > o3 && (t4 = Math.PI - t4), t4;
  }
  if (m4 = 1.5 * Math.PI - 2 * Math.atan(0.5 * (x4 + Math.sqrt(4 * b5 + I4))), f5 = m4 + n7 / p4, m4 = P4(m4), f5 = P4(f5), f5 < m4) {
    const t4 = f5;
    f5 = m4, m4 = t4;
  }
  if (m4 = Math.max(M(m4), -90), f5 = Math.min(M(f5), 90), l7 = U2.monotonic(c3, l7), l7 - c3 > 180) {
    const t4 = (l7 - c3 - 180) / 2;
    c3 += t4, l7 -= t4;
  }
  const v4 = t3.spatialReference && t3.spatialReference.isGeographic ? t3.spatialReference : f.WGS84;
  return s7 ? (s7.xmin = c3, s7.ymin = m4, s7.xmax = l7, s7.ymax = f5, s7.spatialReference = v4) : s7 = new w(c3, m4, l7, f5, v4), t3.spatialReference && t3.spatialReference.isWebMercator && d(s7, false, s7), s7;
}
var C2 = Object.freeze(Object.defineProperty({ __proto__: null, directionToHeadingTilt: _4, eyeForCenterWithHeadingTilt: k, eyeTiltToLookAtTilt: z2, headingTiltToDirectionUp: S3, lookAtTiltToEyeTilt: W, toExtent: A }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/support/cameraUtils.js
var D2 = () => n.getLogger("esri.views.3d.support.cameraUtils");
var H5 = 39.37;
var L = 96;
var G = 1;
var q2 = 8;
var E4 = 5;
var O2 = 1;
var I3 = n3();
var k2 = { heading: 0, tilt: 0 };
var J = n3();
var V = new n6(-20037508342788905e-9, 20037508342788905e-9);
var F = new n6(-180, 180);
var W2;
function X(e4) {
  return e4.spatialReference ?? f.WGS84;
}
function K(e4) {
  return "global" === e4.viewingMode ? C2 : H3;
}
function Y(e4, t3, n7, r5, o3) {
  return K(e4).headingTiltToDirectionUp(t3, n7, r5, o3);
}
function N2(e4, t3) {
  if (null == t3)
    return null;
  const n7 = e4.renderSpatialReference, o3 = K(e4).headingTiltToDirectionUp, i3 = n3();
  if (!c(t3.position, i3, n7))
    return null;
  const l7 = o3(i3, t3.heading, t3.tilt);
  g(l7.direction, l7.direction, e4.state.camera.distance), u(l7.direction, l7.direction, i3);
  const s7 = g2(e4, i3, l7.direction, l7.up);
  return s7.fov = h(t3.fov), s7.row = t3.layout.row, s7.rows = t3.layout.rows, s7.column = t3.layout.column, s7.columns = t3.layout.columns, s7;
}
!function(e4) {
  e4[e4.LOCKED = 0] = "LOCKED", e4[e4.ADJUST = 1] = "ADJUST";
}(W2 || (W2 = {}));
var Z = n3();
function B2(t3, n7, r5) {
  const i3 = t3.renderSpatialReference, a3 = ne(t3, n7.eye, n7.viewForward, n7.up, k2);
  let c3 = X(t3);
  return n4(n7.eye, i3, Z, c3) || (c3 = f.WGS84, n4(n7.eye, i3, Z, c3)), null == r5 ? r5 = new d2(new x(Z, c3), a3.heading, a3.tilt, M(n7.fov)) : (r5.position.x = Z[0], r5.position.y = Z[1], r5.position.z = Z[2], r5.position.spatialReference = c3, r5.heading = a3.heading, r5.tilt = a3.tilt, r5.fov = M(n7.fov)), r5.layout.row = n7.row, r5.layout.rows = n7.rows, r5.layout.column = n7.column, r5.layout.columns = n7.columns, r5;
}
function Q(e4, t3, n7) {
  const o3 = e4.state.camera, i3 = o3.width / 2 / o3.pixelRatio;
  e4.renderCoordsHelper.viewingMode === l3.Global && null != n7 && (t3 *= Math.cos(h(n7))), t3 /= e4.renderCoordsHelper.unitInMeters;
  return i3 / (L * H5 / t3) / Math.tan(o3.fovX / 2);
}
function $(e4, t3, n7) {
  const o3 = e4.state.camera, i3 = t3 * Math.tan(o3.fovX / 2), a3 = o3.width / 2 / o3.pixelRatio;
  let c3 = L * H5 / (a3 / i3);
  return e4.renderCoordsHelper.viewingMode === l3.Global && null != n7 && (c3 /= Math.cos(h(n7))), c3 * e4.renderCoordsHelper.unitInMeters;
}
async function _5(e4, t3, n7, r5, o3, i3) {
  return te(e4, t3, Q(e4, n7, t3.latitude), r5, o3, i3);
}
function ee(e4, t3, n7, r5, o3, i3) {
  return ze(e4, ce(e4, r5.heading, r5.tilt, t3, n7, o3), r5.fov, i3);
}
async function te(e4, t3, n7, r5, o3, a3) {
  const c3 = await le(e4, r5.heading, r5.tilt, t3, n7, o3, a3);
  return s2(a3), be(e4, c3, r5.fov, a3);
}
function ne(e4, t3, n7, r5, o3) {
  return K(e4).directionToHeadingTilt(t3, n7, r5, o3);
}
function re(e4, t3) {
  return !!(e4.basemapTerrain && e4.renderCoordsHelper.fromRenderCoords(t3, J, e4.spatialReference) && e4.elevationProvider && (a2(e4.elevationProvider, J) ?? 0) > J[2] - O2);
}
async function oe(e4, t3, n7) {
  if (re(e4, t3))
    return true;
  const { elevationProvider: r5, spatialReference: o3, renderCoordsHelper: a3 } = e4;
  if (null == r5 || !a3.fromRenderCoords(t3, J, o3))
    return false;
  const [c3, l7, s7] = J, u8 = await r5.queryElevation(c3, l7, s7, o3, "ground", n7) ?? 0;
  return s2(n7), u8 > s7 - O2;
}
async function ie(e4, t3, n7) {
  const r5 = n3();
  if (null == t3)
    return r2(r5, e4.state.camera.center);
  if (t3 instanceof x) {
    const { renderSpatialReference: o3, basemapTerrain: a3, elevationProvider: c3 } = e4, l7 = t3.spatialReference;
    if (await i2(t3, r5, o3, 0, { signal: n7 }), s2(n7), null == t3.z && null != a3 && null != c3) {
      const o4 = await c3.queryElevation(t3.x, t3.y, t3.z ?? 0, l7, "ground", n7);
      s2(n7), null != o4 && e4.renderCoordsHelper.setAltitude(r5, o4);
    }
    return r5;
  }
  return r2(r5, t3);
}
function ae(e4, t3) {
  const n7 = n3();
  if (null == t3)
    return r2(n7, e4.state.camera.center);
  if (t3 instanceof x) {
    if (!c(t3, n7, e4.renderSpatialReference))
      return null;
    const { basemapTerrain: r5, elevationProvider: o3 } = e4;
    if (null == t3.z && null != r5 && null != o3) {
      const r6 = a2(o3, t3);
      null != r6 && e4.renderCoordsHelper.setAltitude(n7, r6);
    }
    return n7;
  }
  return r2(n7, t3);
}
function ce(e4, t3, n7, r5, o3, i3) {
  return se(e4, t3, n7, r5 instanceof x ? r5 : null, ae(e4, r5), o3, i3);
}
async function le(e4, t3, n7, r5, o3, a3, c3) {
  const l7 = r5 instanceof x ? r5 : null, s7 = await ie(e4, r5, c3);
  return s2(c3), ue(e4, t3, n7, l7, s7, o3, a3, c3);
}
function se(e4, t3, n7, r5, o3, i3, a3) {
  if (null == o3)
    return null;
  if (!r5 && (r5 = new x({ spatialReference: X(e4) }), !t2(o3, e4.renderSpatialReference, r5)))
    return null;
  const c3 = fe(e4, t3, n7, o3, i3, a3);
  if (me(e4, n7, a3) && re(e4, c3.eye)) {
    const { tilt: a4, mode: c4 } = pe(e4, n7, o3, i3);
    return se(e4, t3, a4, r5, o3, i3, c4);
  }
  return de(c3, o3);
}
async function ue(e4, t3, n7, r5, o3, a3, c3, l7) {
  r5 || (r5 = new x({ spatialReference: X(e4) }), await c2(o3, e4.renderSpatialReference, r5, { signal: l7 }) || (r5 = null)), s2(l7);
  const s7 = fe(e4, t3, n7, o3, a3, c3);
  if (me(e4, n7, c3) && await oe(e4, s7.eye, l7)) {
    s2(l7);
    const { tilt: c4, mode: s8 } = pe(e4, n7, o3, a3);
    return ue(e4, t3, c4, r5, o3, a3, s8, l7);
  }
  return de(s7, o3);
}
function fe(e4, t3, n7, r5, o3, i3) {
  const a3 = xe(e4, t3, n7, r5, o3 = Math.max(o3, e4.state.constraints.minimumPoiDistance), i3);
  return (0, K(e4).eyeForCenterWithHeadingTilt)(r5, o3, a3.heading, a3.tilt);
}
function me(e4, t3, n7) {
  const r5 = e4.map.ground.navigationConstraint;
  return n7 === W2.ADJUST && "global" === e4.viewingMode && t3 > 0 && (null == r5 || "stay-above" === r5.type);
}
function pe(e4, t3, n7, r5) {
  const o3 = Se(e4, n7, r5, je(e4, r5, t3, n7));
  return { tilt: o3, mode: t3 - o3 < 1 ? W2.LOCKED : W2.ADJUST };
}
function de(e4, t3) {
  return { ...e4, center: t(t3) };
}
function he(e4, t3) {
  const { state: n7, spatialReference: r5 } = e4, o3 = t3.spatialReference;
  return n7.isGlobal && r4(o3, l3.Global) || n7.isLocal && r5.equals(o3);
}
function ge(e4, t3) {
  let n7, r5, o3;
  if (e4.state.isGlobal) {
    const e5 = new x(t3.xmin, t3.ymin, t3.spatialReference), i4 = new x(t3.xmax, t3.ymax, t3.spatialReference), a4 = t3.spatialReference.isGeographic ? F : V;
    n7 = new x({ x: a4.center(e5.x, i4.x), y: (i4.y + e5.y) / 2, z: null != t3.zmax && null != t3.zmin ? (t3.zmax + t3.zmin) / 2 : void 0, spatialReference: t3.spatialReference });
    const c4 = s3(t3.spatialReference), l8 = s6(n7, e5, i4);
    r5 = l8.lon, o3 = l8.lat, a4.diff(e5.x, i4.x) > a4.range / 2 && (r5 += c4.halfCircumference), r5 = Math.min(r5, c4.halfCircumference), o3 = Math.min(o3, c4.halfCircumference);
  } else {
    const i4 = e4.renderSpatialReference ?? t3.spatialReference;
    i4.equals(t3.spatialReference) || (t3 = B(t3, i4)), r5 = t3.xmax - t3.xmin, o3 = t3.ymax - t3.ymin;
    const a4 = null != t3.zmax && null != t3.zmin ? (t3.zmax + t3.zmin) / 2 : void 0;
    n7 = new x({ x: t3.xmin + 0.5 * r5, y: t3.ymin + 0.5 * o3, z: a4, spatialReference: i4 });
  }
  const i3 = null != t3.zmax && null != t3.zmin ? t3.zmax - t3.zmin : 0, a3 = e4.state.camera, c3 = 1 / Math.tan(a3.fovX / 2), l7 = 1 / Math.tan(a3.fovY / 2), s7 = 1 / Math.tan(a3.fov / 2);
  return { center: n7, distance: Math.max(0.5 * r5 * c3, 0.5 * o3 * l7, 0.5 * i3 * s7) / G };
}
async function ye(e4, t3, n7, r5, o3, a3) {
  const c3 = he(e4, t3) ? t3 : await D(t3, e4.spatialReference, { signal: a3 });
  s2(a3);
  const { center: l7, distance: s7 } = ge(e4, c3), u8 = await le(e4, n7, r5, l7, s7, o3, a3);
  return s2(a3), be(e4, u8, e4.camera.fov, a3);
}
function ve(e4, t3, n7, r5, o3, i3) {
  let a3;
  try {
    a3 = he(e4, t3) ? t3 : B(t3, e4.spatialReference);
  } catch (u8) {
    return null;
  }
  const { center: c3, distance: l7 } = ge(e4, a3), s7 = ce(e4, n7, r5, c3, l7, o3);
  return null == s7 ? null : ze(e4, s7, e4.camera.fov, i3);
}
function we(e4, t3, n7) {
  const r5 = e4.renderSpatialReference, o3 = new x({ spatialReference: X(e4) });
  if (!t2(n7, r5, o3))
    return null;
  const i3 = Math.tan(t3.fovX / 2), a3 = Math.tan(t3.fovY / 2), c3 = U(t3.eye, n7), s7 = 2 * c3 * i3 * G, u8 = 2 * c3 * a3 * G;
  return "global" === e4.viewingMode ? A(e4, o3, s7, u8) : E2(e4, o3, s7, u8);
}
function Re(e4, t3, n7) {
  const r5 = e4.pointsOfInterest.centerOnSurfaceFrequent.distance;
  if (Math.log(n7 / r5) / Math.LN2 > q2)
    return true;
  const o3 = t3, i3 = e4.pointsOfInterest.centerOnSurfaceFrequent.renderLocation;
  return x2(o3, i3) / (Math.tan(0.5 * e4.state.camera.fov) * r5) > E4;
}
function xe(e4, t3, n7, r5, o3, i3) {
  let a3 = 0;
  return i3 === W2.ADJUST && Re(e4, r5, o3) ? (t3 = 0, a3 = Te(e4, o3, n7, r5)) : a3 = Ce(e4, r5, o3, n7), a3 = e4.state.constraints.clampTilt(o3, a3), { heading: t3, tilt: n7 = Se(e4, r5, o3, a3) };
}
var Me = 0.7;
function Te(e4, t3, n7, r5) {
  const o3 = Ce(e4, r5, t3, n7);
  if (!e4.state.constraints.tilt)
    return o3;
  const i3 = e4.state.constraints.tilt(t3);
  i3.max = Math.min(i3.max, 0.5 * Math.PI);
  const a3 = i3.min * (1 - Me) + i3.max * Me;
  return Math.min(o3, a3);
}
function je(e4, t3, n7, r5) {
  let o3 = Ce(e4, r5, t3, n7);
  if (!e4.state.constraints.tilt)
    return o3;
  const i3 = e4.state.constraints.tilt(t3);
  return o3 = Math.min(o3, 0.5 * Math.PI), i3.min * (1 - Me) + o3 * Me;
}
function Se(e4, t3, n7, r5) {
  return K(e4).lookAtTiltToEyeTilt(r5, t3, n7);
}
function Ce(e4, t3, n7, r5) {
  return K(e4).eyeTiltToLookAtTilt(r5, t3, n7);
}
function ze(t3, n7, r5, o3) {
  if (null == n7)
    return null;
  const i3 = t3.renderSpatialReference, a3 = new x({ spatialReference: X(t3) });
  return t2(n7.eye, i3, a3) ? (o3 ?? (o3 = new d2()), o3.position = a3, o3.heading = n7.heading, o3.tilt = n7.tilt, o3.fov = r5, o3) : null;
}
async function be(t3, n7, r5, o3) {
  const a3 = t3.renderSpatialReference, c3 = new x({ spatialReference: X(t3) });
  return await c2(n7.eye, a3, c3, { signal: o3 }), s2(o3), new d2(c3, n7.heading, n7.tilt, r5);
}
function Ue(e4, t3) {
  var _a;
  const n7 = (_a = e4.basemapTerrain) == null ? void 0 : _a.tilingScheme;
  if (n7)
    return n7.levelAtScale(t3);
  D2().error("#scaleToZoom()", "Cannot compute zoom from scale without a tiling scheme");
}
function Pe(e4, t3) {
  var _a;
  const n7 = (_a = e4.basemapTerrain) == null ? void 0 : _a.tilingScheme;
  if (n7)
    return n7.scaleAtLevel(t3);
  D2().error("#zoomToScale()", "Cannot compute scale from zoom without a tiling scheme");
}
function Ae(e4, t3) {
  return n4(t3.center, e4.renderSpatialReference, I3, f.WGS84), $(e4, t3.distance, I3[1]);
}

// node_modules/@arcgis/core/views/3d/support/viewpointUtils.js
var it = 0.66;
function st(t3) {
  return 360 - a.normalize(t3);
}
function ct(t3) {
  return a.normalize(360 - t3);
}
function lt(t3, e4, n7) {
  const a3 = e4.camera;
  if (null != a3)
    return ut(a3, X(t3));
  const { targetGeometry: r5 } = e4;
  if (null == r5)
    return null;
  const { camera: o3, mode: i3 } = pt(t3, e4.rotation, n7);
  if ("point" === r5.type)
    return gt(t3, e4, r5, o3, i3);
  const s7 = r5.extent;
  return null == s7 ? null : ve(t3, s7, o3.heading, o3.tilt, i3);
}
async function mt(t3, e4, n7, a3) {
  const r5 = e4.camera;
  if (null != r5)
    return ft(r5, X(t3), a3);
  const { targetGeometry: o3 } = e4;
  if (null == o3)
    throw new Error("Viewpoint has no targetGeometry!");
  const { camera: i3, mode: s7 } = pt(t3, e4.rotation, n7);
  if ("point" === o3.type)
    return yt(t3, e4, o3, i3, s7, a3);
  const c3 = o3.extent;
  if (null == c3)
    throw new Error("Target geometry has no extent!");
  return ye(t3, c3, i3.heading, i3.tilt, s7, a3);
}
function ut(t3, e4) {
  const n7 = t3.position;
  let a3;
  try {
    a3 = C(n7, e4);
  } catch (o3) {
    return null;
  }
  if (!a3)
    return null;
  const r5 = t3.clone();
  return r5.position = a3.clone(), r5;
}
async function ft(t3, e4, n7) {
  const a3 = t3.position, r5 = await D(a3, e4, { signal: n7 });
  s2(n7);
  const o3 = t3.clone();
  return o3.position = r5.clone(), o3;
}
function pt(t3, e4, n7) {
  const a3 = B2(t3, t3.state.camera);
  let r5 = W2.ADJUST;
  return null != e4 && (a3.heading = st(e4), r5 = W2.LOCKED), null != n7 && (a3.tilt = n7), { camera: a3, mode: r5 };
}
function gt(t3, e4, n7, a3, r5) {
  const o3 = t3.spatialReference;
  let i3;
  try {
    i3 = C(n7.clone(), o3);
  } catch (c3) {
    return null;
  }
  if (!i3)
    return null;
  const s7 = null != e4.scale ? Q(t3, e4.scale, i3.latitude) : t3.state.camera.distance;
  return ee(t3, i3, s7, a3, r5);
}
async function yt(t3, e4, n7, a3, r5, o3) {
  const s7 = t3.spatialReference, c3 = await D(n7.clone(), s7, { signal: o3 });
  s2(o3);
  const l7 = null != e4.scale ? Q(t3, e4.scale, c3.latitude) : t3.state.camera.distance;
  return te(t3, c3, l7, a3, r5, o3);
}
function ht(t3, e4, a3 = null) {
  return null == a3 && (a3 = new l5()), vt(t3, null, e4.clone(), a3);
}
async function dt(e4, a3, r5) {
  const i3 = Ot(e4, a3);
  if (!i3)
    throw new s("viewpointutils-create:no-target", "Missing target for creating viewpoint");
  const s7 = new d2({ fov: e4.camera.fov }), c3 = new l5({ camera: s7 });
  if (i3.target instanceof l5) {
    return Pt(await Gt(e4, i3.target, i3, r5, c3));
  }
  if (i3.target instanceof d2)
    return Pt(await St(e4, i3.target, r5, c3));
  const l7 = null != i3.scale || null != i3.zoom;
  if (i3.target instanceof w) {
    const t3 = i3.target.xmin === i3.target.xmax || i3.target.ymin === i3.target.ymax;
    return Pt(l7 || t3 ? await Tt(e4, i3, i3.target.center, s7, r5, c3) : await Et(e4, i3, i3.target, s7, r5, c3));
  }
  const m4 = { boundingBox: P2(), hasZ: false, screenSpaceObjects: [] }, u8 = l7 ? xt(e4, i3) : void 0;
  if (await zt(e4, i3.target, u8, m4, r5), isFinite(m4.boundingBox[0])) {
    let t3;
    if (E(m4.boundingBox, Ut), qt.x = Ut[0], qt.y = Ut[1], qt.z = Ut[2], qt.spatialReference = e4.spatialReference, isFinite(qt.z) && m4.hasZ ? t3 = w2(m4.boundingBox) : (qt.z = void 0, t3 = H(S2(m4.boundingBox, It))), l7 || t3)
      return Pt(await Tt(e4, i3, qt, s7, r5, c3));
    const n7 = Dt(e4, m4.screenSpaceObjects);
    return Pt(await Ft(e4, i3, qt, m4.boundingBox, n7, s7, r5, c3));
  }
  return i3.position ? Pt(await Mt(e4, i3, s7, c3, r5)) : Pt(await Zt(e4, i3, s7, r5, c3));
}
function wt(t3, e4) {
  return null == e4.scale && null != e4.zoom ? Pe(t3, e4.zoom) : e4.scale;
}
function xt(t3, e4) {
  const n7 = wt(t3, e4);
  return n7 ? u5(n7) : void 0;
}
function jt(t3, e4) {
  let n7 = false;
  return null != e4.heading ? (t3.heading = e4.heading, n7 = true) : null != e4.rotation && (t3.heading = st(e4.rotation), n7 = true), null != e4.tilt && (t3.tilt = e4.tilt, n7 = true), null != e4.fov && (t3.fov = e4.fov), n7;
}
function vt(t3, e4, n7, a3) {
  const r5 = t3.spatialReference || f.WGS84;
  if (null == (e4 = null != e4 ? e4 : N2(t3, n7)))
    return a3;
  const o3 = new x({ spatialReference: r5 });
  return t2(e4.center, t3.renderSpatialReference, o3) ? (a3.targetGeometry = o3, a3.scale = Ae(t3, e4), a3.rotation = ct(n7.heading), a3.camera = n7, a3) : a3;
}
async function bt(t3, e4, n7, a3) {
  var _a;
  const r5 = () => new s("viewpointutils:invalid-geometry", "The target is missing a valid geometry");
  if (!e4)
    throw r5();
  "mesh" === e4.type && (e4 = e4.extent);
  const i3 = e4.spatialReference, s7 = t3.spatialReference, c3 = t3.basemapTerrain.spatialReference;
  if (!e4.hasZ && t3.basemapTerrain) {
    let n8;
    switch (e4.type) {
      case "point":
        n8 = e4;
        break;
      case "multipoint":
      case "polyline":
        n8 = (_a = e4.extent) == null ? void 0 : _a.center;
        break;
      case "extent":
        n8 = e4.center;
        break;
      case "polygon":
        n8 = e4.centroid;
    }
    null != n8 && null != c3 && null != t3.elevationProvider ? (n8 = await D(n8, c3, { signal: a3 }), Ut[2] = a2(t3.elevationProvider, n8) ?? 0) : Ut[2] = 0;
  }
  const l7 = Wt[e4.type], m4 = new Array();
  if (l7(e4, e4.hasZ ? (t4) => {
    m4.push([t4[0], t4[1], t4[2]]);
  } : (t4) => {
    m4.push([t4[0], t4[1]]);
  }, Ut), 0 === m4.length)
    throw r5();
  const u8 = await D(new u2({ spatialReference: i3, hasZ: e4.hasZ, hasM: false, points: m4 }), s7, { signal: a3 });
  if (e4.hasZ && (n7.hasZ = true), e4.hasZ)
    for (const [o3, f5, p4] of u8.points)
      Ut[0] = o3, Ut[1] = f5, Ut[2] = p4, h2(n7.boundingBox, Ut);
  else
    for (const [o3, f5] of u8.points)
      Ut[0] = o3, Ut[1] = f5, h2(n7.boundingBox, Ut);
}
async function Rt(t3, e4, n7, r5, o3) {
  const i3 = await _(t3.whenViewForGraphic(e4));
  if (false === i3.ok || null == i3.value || !("whenGraphicBounds" in i3.value))
    return void await bt(t3, e4.geometry, r5, o3);
  const s7 = i3.value, c3 = await _(s7.whenGraphicBounds(e4, { minDemResolution: n7 }));
  if (false === c3.ok || !c3.value)
    return void await bt(t3, e4.geometry, r5, o3);
  const { screenSpaceObjects: l7, boundingBox: m4 } = c3.value;
  o2(r5.boundingBox, m4), l7 && l7.forEach((t4) => {
    r5.screenSpaceObjects.push(t4);
  }), isFinite(m4[2]) && (r5.hasZ = true);
}
async function zt(t3, n7, a3, r5, o3) {
  var _a;
  if (Array.isArray(n7) && 2 === n7.length) {
    const e4 = n7[0], a4 = n7[1];
    if ("number" == typeof e4 && "number" == typeof a4)
      return qt.x = e4, qt.y = a4, qt.z = void 0, qt.spatialReference = ((_a = t3.spatialReference) == null ? void 0 : _a.isGeographic) ? t3.spatialReference : f.WGS84, void await bt(t3, qt, r5, o3);
  }
  n7 && "map" in n7 && "function" == typeof n7.map ? await Promise.allSettled(n7.map((e4) => zt(t3, e4, a3, r5, o3))) : n7 instanceof n2 ? await bt(t3, n7, r5, o3) : n7 instanceof f2 && await Rt(t3, n7, a3, r5, o3);
}
async function Gt(t3, e4, n7, a3, r5) {
  if (null != e4.camera)
    return St(t3, e4.camera, a3, r5);
  r5.scale = e4.scale, r5.rotation = e4.rotation, r5.targetGeometry = null != e4.targetGeometry ? e4.targetGeometry.clone() : null, r5.camera = null, null != n7.heading ? r5.rotation = ct(n7.heading) : null != n7.rotation && (r5.rotation = n7.rotation);
  const o3 = wt(t3, n7);
  return null != o3 && (r5.scale = o3), r5.camera = await mt(t3, r5, n7.tilt, a3), r5;
}
async function St(t3, e4, n7, a3) {
  const r5 = t3.spatialReference, o3 = await D(e4.position, r5, { signal: n7 });
  return (e4 = e4.clone()).fov = t3.camera.fov, e4.position = o3, vt(t3, null, e4, a3);
}
async function Bt(t3, e4, n7, a3, r5, o3, i3) {
  const s7 = t3.renderSpatialReference;
  return await i2(e4, Lt, s7, 0, { signal: i3 }), await i2(n7, Kt, s7, 0, { signal: i3 }), o3.targetGeometry = new x(e4), r5.position = new x(n7), e(Jt, Lt, Kt), ne(t3, Kt, Jt, a3.up, r5), o3.scale = $(t3, x2(Kt, Lt), o3.targetGeometry.latitude), o3.rotation = ct(r5.heading), o3.camera = r5, o3;
}
async function Tt(t3, e4, n7, a3, r5, i3) {
  if (null == n7)
    throw new s("createfromcenter", "invalid point");
  i3.targetGeometry = n7.clone();
  const s7 = g2(t3);
  if (e4.position)
    return Bt(t3, i3.targetGeometry, e4.position, s7, a3, i3, r5);
  if (e4.zoomFactor) {
    const a4 = s7.distance / e4.zoomFactor, r6 = g(Ut, s7.viewForward, -a4);
    s7.eye = u(Ut, s7.center, r6), i3.scale = $(t3, a4, n7.latitude);
  }
  B2(t3, s7, a3);
  const c3 = jt(a3, e4) ? W2.LOCKED : W2.ADJUST;
  if (!e4.zoomFactor) {
    const o3 = wt(t3, e4);
    if (null == o3) {
      const { renderSpatialReference: e5 } = t3;
      await i2(n7, Ut, e5, 0, { signal: r5 }), l4(s7.frustum, Ut) ? i3.scale = $(t3, x2(s7.eye, Ut), n7.latitude) : i3.scale = Ae(t3, s7);
    } else
      i3.scale = o3;
    i3.camera = await _5(t3, i3.targetGeometry, i3.scale, a3, c3, r5);
  }
  return i3;
}
async function Mt(t3, e4, n7, a3, r5) {
  const o3 = g2(t3);
  r2(Jt, o3.viewForward), ne(t3, o3.eye, Jt, o3.up, Nt);
  const i3 = t3.spatialReference, { position: s7 } = e4;
  if (s7) {
    const t4 = await D(s7, i3, { signal: r5 });
    n7.position = t4;
  } else
    n7.position = new x();
  return n7.heading = null != e4.heading ? e4.heading : Nt.heading, n7.tilt = null != e4.tilt ? e4.tilt : Nt.tilt, vt(t3, null, n7, a3);
}
async function Zt(t3, e4, n7, a3, r5) {
  const o3 = g2(t3), { spatialReference: i3, renderSpatialReference: s7 } = t3, c3 = new x({ spatialReference: i3 });
  return t2(o3.center, s7, c3) ? Tt(t3, e4, c3, n7, a3, r5) : Tt(t3, e4, null, n7, a3, r5);
}
async function Et(t3, e4, n7, a3, r5, o3) {
  o3.targetGeometry = n7.clone();
  const i3 = g2(t3);
  B2(t3, i3, a3);
  const s7 = jt(a3, e4) ? W2.LOCKED : W2.ADJUST;
  return o3.camera = await ye(t3, n7, a3.heading, a3.tilt, s7, r5), o3;
}
function At(t3, e4, n7, a3, r5) {
  let o3 = 0;
  null != n7.z ? o3 = n7.z : t3.basemapTerrain && t3.elevationProvider && (o3 = a2(t3.elevationProvider, n7)), o(Ut, n7.x, n7.y, o3), R2(t3.spatialReference, Ut, Vt, t3.renderSpatialReference), n5(Ct, Vt), u4(Ct, Ct), P2(kt);
  const i3 = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]];
  for (let s7 = 0; s7 < i3.length; s7++) {
    const e5 = i3[s7];
    let n8 = a3[e5[2]];
    isFinite(n8) || (n8 = o3), o(Ut, a3[e5[0]], a3[e5[1]], n8), n4(Ut, t3.spatialReference, Ut, t3.renderSpatialReference), h2(kt, S(Ut, Ut, Ct));
  }
  const l7 = s5(kt), m4 = N(kt), u8 = I(kt), f5 = 1 / Math.tan(e4.fovX / 2), p4 = 1 / Math.tan(e4.fovY / 2), g4 = 0.5 * Math.sqrt(l7 * l7 + u8 * u8) * Math.max(p4, f5) + 0.5 * m4, y3 = 0.5 * m4 * p4 + 0.5 * Math.max(l7, u8);
  return Math.max(g4, y3) / r5;
}
async function Ft(t3, e4, n7, a3, r5, o3, i3, s7) {
  s7.targetGeometry = n7.clone();
  const c3 = g2(t3), l7 = At(t3, c3, n7, a3, r5);
  B2(t3, c3, o3);
  const m4 = jt(o3, e4) ? W2.LOCKED : W2.ADJUST;
  return s7.scale = $(t3, l7, s7.targetGeometry.latitude), s7.camera = await _5(t3, s7.targetGeometry, s7.scale, o3, m4, i3), s7;
}
function Ot(t3, e4) {
  if (!e4 || !t3.spatialReference)
    return null;
  const n7 = { target: void 0 };
  return "declaredClass" in e4 || Array.isArray(e4) ? n7.target = e4 : (Object.assign(n7, e4), e4.center && !n7.target && (n7.target = e4.center)), n7;
}
function Pt(t3) {
  return null != (t3 == null ? void 0 : t3.camera) && (t3.rotation = ct(t3.camera.heading)), t3;
}
function Dt(t3, e4) {
  const n7 = it;
  if (!e4.length)
    return n7;
  let a3 = Number.NEGATIVE_INFINITY;
  for (let r5 = 0; r5 < e4.length; r5++) {
    const t4 = e4[r5].screenSpaceBoundingRect;
    a3 = Math.max(a3, Math.abs(t4[0]), Math.abs(t4[1]), Math.abs(t4[2]), Math.abs(t4[3]));
  }
  return n7 - a3 / Math.min(t3.width, t3.height) * 2;
}
var Ut = n3();
var Vt = e2();
var Ct = e3();
var kt = i();
var It = u3();
var Jt = n3();
var Kt = n3();
var Lt = n3();
var Nt = { heading: 0, tilt: 0 };
var qt = new x();
var Wt = { point(t3, e4, n7) {
  n7[0] = t3.x, n7[1] = t3.y, null != t3.z && (n7[2] = t3.z), e4(n7);
}, polygon(t3, e4, n7) {
  const a3 = t3.hasZ;
  for (let r5 = 0; r5 < t3.rings.length; r5++) {
    const o3 = t3.rings[r5];
    for (let t4 = 0; t4 < o3.length; t4++)
      n7[0] = o3[t4][0], n7[1] = o3[t4][1], a3 && (n7[2] = o3[t4][2]), e4(n7);
  }
}, polyline(t3, e4, n7) {
  const a3 = t3.hasZ;
  for (let r5 = 0; r5 < t3.paths.length; r5++) {
    const o3 = t3.paths[r5];
    for (let t4 = 0; t4 < o3.length; t4++)
      n7[0] = o3[t4][0], n7[1] = o3[t4][1], a3 && (n7[2] = o3[t4][2]), e4(n7);
  }
}, multipoint(t3, e4, n7) {
  const a3 = t3.points, r5 = t3.hasZ;
  for (let o3 = 0; o3 < a3.length; o3++)
    n7[0] = a3[o3][0], n7[1] = a3[o3][1], r5 && (n7[2] = a3[o3][2]), e4(n7);
}, extent(t3, e4, n7) {
  null != t3.zmin && null != t3.zmax ? (e4(o(n7, t3.xmin, t3.ymin, t3.zmin)), e4(o(n7, t3.xmax, t3.ymin, t3.zmin)), e4(o(n7, t3.xmin, t3.ymax, t3.zmin)), e4(o(n7, t3.xmax, t3.ymax, t3.zmin)), e4(o(n7, t3.xmin, t3.ymin, t3.zmax)), e4(o(n7, t3.xmax, t3.ymin, t3.zmax)), e4(o(n7, t3.xmin, t3.ymax, t3.zmax)), e4(o(n7, t3.xmax, t3.ymax, t3.zmax))) : (e4(o(n7, t3.xmin, t3.ymin, n7[2])), e4(o(n7, t3.xmax, t3.ymin, n7[2])), e4(o(n7, t3.xmin, t3.ymax, n7[2])), e4(o(n7, t3.xmax, t3.ymax, n7[2])));
} };

export {
  u6 as u,
  f3 as f,
  g2 as g,
  h3 as h,
  W2 as W,
  Y,
  N2 as N,
  B2 as B,
  Q,
  $,
  ne,
  ce,
  ve,
  we,
  Ue,
  Pe,
  lt,
  mt,
  ht,
  dt
};
//# sourceMappingURL=chunk-4VZEIAYK.js.map
