import {
  t
} from "./chunk-DGRFM5OL.js";
import {
  D,
  L,
  Q
} from "./chunk-676ANOCK.js";
import {
  d
} from "./chunk-DRC4XSYG.js";
import {
  j
} from "./chunk-RKVEKQ5O.js";
import {
  x
} from "./chunk-PWPXYWXV.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/views/3d/layers/support/DefinitionExpressionSceneLayerView.js
var t2 = (t4) => {
  let p = class extends t4 {
    constructor() {
      super(...arguments), this._definitionExpressionErrors = 0, this._maxDefinitionExpressionErrors = 20, this.logError = (r) => {
        this._definitionExpressionErrors < this._maxDefinitionExpressionErrors && n.getLogger(this).error("Error while evaluating definitionExpression: " + r), this._definitionExpressionErrors++, this._definitionExpressionErrors === this._maxDefinitionExpressionErrors && n.getLogger(this).error("Further errors are ignored");
      };
    }
    get parsedDefinitionExpression() {
      var _a;
      if (!((_a = this.i3slayer) == null ? void 0 : _a.definitionExpression))
        return null;
      try {
        const r = x.create(this.i3slayer.definitionExpression, this.i3slayer.fieldsIndex);
        if (!r.isStandardized)
          return n.getLogger(this).error("definitionExpression is using non standard function"), null;
        const e2 = [], s = r.fieldNames;
        return L(s, this.i3slayer.fields, { missingFields: e2 }), e2.length > 0 ? (n.getLogger(this).error(`definitionExpression references unknown fields: ${e2.join(", ")}`), null) : (this._definitionExpressionErrors = 0, r);
      } catch (r) {
        return n.getLogger(this).error("Failed to parse definitionExpression: " + r), null;
      }
    }
    get definitionExpressionFields() {
      return this.parsedDefinitionExpression ? this.parsedDefinitionExpression.fieldNames : [];
    }
    _evaluateClause(r, i) {
      try {
        return r.testFeature(i);
      } catch (e2) {
        return this.logError(e2), false;
      }
    }
    _addDefinitionExpressionToQuery(r) {
      if (!this.parsedDefinitionExpression)
        return r;
      const i = this.i3slayer.definitionExpression, e2 = r.clone();
      return e2.where ? e2.where = `(${i}) AND (${e2.where})` : e2.where = i, e2;
    }
  };
  return e([y({ readOnly: true })], p.prototype, "parsedDefinitionExpression", null), e([y({ readOnly: true })], p.prototype, "definitionExpressionFields", null), p = e([a("esri.views.3d.layers.support.DefinitionExpressionSceneLayerView")], p), p;
};

// node_modules/@arcgis/core/views/3d/layers/support/TemporalSceneLayerView.js
var u = (s) => {
  let n3 = class extends s {
    constructor() {
      super(...arguments), this.timeExtent = null;
    }
    get mergedFilter() {
      var _a;
      const { filter: t4, timeExtent: e2 } = this;
      if (null == e2)
        return t4;
      const r = (t4 == null ? void 0 : t4.clone()) ?? new d();
      return null != e2 && (r.timeExtent = ((_a = r.timeExtent) == null ? void 0 : _a.intersection(e2)) ?? e2), r;
    }
    getTimeFilterDependencies() {
      const { timeInfo: t4 } = this.i3slayer;
      if (null == t4)
        return [];
      const { startField: e2, endField: r } = t4;
      return [e2, r];
    }
    addTimeFilter(t4, e2) {
      if (null == e2)
        return;
      const { timeInfo: r } = this.i3slayer;
      if (null == r)
        return;
      const { startField: s2, endField: i, useTime: o } = r;
      if (!o || null == s2 && null == i)
        return;
      const n4 = r.toJSON(), l = e2.toJSON();
      t4.push((t5, e3) => m(t5, e3, n4, l));
    }
  };
  return e([y(j)], n3.prototype, "timeExtent", void 0), e([y()], n3.prototype, "mergedFilter", null), n3 = e([a("esri.views.3d.layers.support.TemporalSceneLayerView")], n3), n3;
};
function m(t4, e2, r, i) {
  var _a;
  const o = (_a = e2.attributeInfo) == null ? void 0 : _a.attributeData;
  if (null == o)
    return;
  const { startTimeField: l, endTimeField: u3 } = r;
  if (!!(null != l && null == o[l] || null != u3 && null == o[u3]))
    return;
  const m2 = t(r, i, new a2(o));
  if (null == m2)
    return;
  const { featureIds: c } = e2;
  D(t4, c, m2);
}
var a2 = class {
  constructor(t4) {
    this.attributeData = t4;
  }
  getAttribute(t4, e2) {
    return Q(this.attributeData[e2], t4);
  }
  getAttributeAsTimestamp(t4, e2) {
    const r = this.getAttribute(t4, e2);
    return "string" == typeof r ? new Date(r).getTime() : "number" == typeof r || null == r ? r : null;
  }
};

// node_modules/@arcgis/core/core/maybeUpdating.js
var n2 = "updating";
function t3(n3) {
  return "updating" === n3 ? null : n3;
}
function u2(n3) {
  return "updating" === n3;
}

export {
  n2 as n,
  t3 as t,
  u2 as u,
  t2,
  u as u2
};
//# sourceMappingURL=chunk-FU2UQ2HG.js.map
