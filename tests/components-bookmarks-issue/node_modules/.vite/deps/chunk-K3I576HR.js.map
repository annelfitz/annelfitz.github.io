{
  "version": 3,
  "sources": ["../../@esri/calcite-components/dist/esm/src/components/color-picker/utils.ts"],
  "sourcesContent": ["import { ColorValue, HSLA, HSVA, RGB, RGBA } from \"./interfaces\";\nimport Color from \"color\";\n\nexport const hexChar = /^[0-9A-F]$/i;\nconst shorthandHex = /^#[0-9A-F]{3}$/i;\nconst longhandHex = /^#[0-9A-F]{6}$/i;\nconst shorthandHexWithAlpha = /^#[0-9A-F]{4}$/i;\nconst longhandHexWithAlpha = /^#[0-9A-F]{8}$/i;\n\nexport const alphaToOpacity = (alpha: number): number => Number((alpha * 100).toFixed());\n\nexport const opacityToAlpha = (opacity: number): number => Number((opacity / 100).toFixed(2));\n\nexport function isValidHex(hex: string, hasAlpha = false): boolean {\n  return isShorthandHex(hex, hasAlpha) || isLonghandHex(hex, hasAlpha);\n}\n\nexport function canConvertToHexa(hex: string): boolean {\n  const validHex = isValidHex(hex, false);\n  const validHexa = isValidHex(hex, true);\n  return !validHexa && validHex;\n}\n\nfunction evaluateHex(hex: string, length: number, pattern: RegExp): boolean {\n  if (!hex) {\n    return false;\n  }\n\n  return hex.length === length && pattern.test(hex);\n}\n\nexport function isShorthandHex(hex: string, hasAlpha = false): boolean {\n  const hexLength = hasAlpha ? 5 : 4;\n  const hexPattern = hasAlpha ? shorthandHexWithAlpha : shorthandHex;\n\n  return evaluateHex(hex, hexLength, hexPattern);\n}\n\nexport function isLonghandHex(hex: string, hasAlpha = false): boolean {\n  const hexLength = hasAlpha ? 9 : 7;\n  const hexPattern = hasAlpha ? longhandHexWithAlpha : longhandHex;\n\n  return evaluateHex(hex, hexLength, hexPattern);\n}\n\nexport function normalizeHex(hex: string, hasAlpha = false, convertFromHexToHexa = false): string {\n  hex = hex.toLowerCase();\n\n  if (!hex.startsWith(\"#\")) {\n    hex = `#${hex}`;\n  }\n\n  if (isShorthandHex(hex, hasAlpha)) {\n    return rgbToHex(hexToRGB(hex, hasAlpha));\n  }\n\n  if (hasAlpha && convertFromHexToHexa && isValidHex(hex, false /* we only care about RGB hex for conversion */)) {\n    const isShorthand = isShorthandHex(hex, false);\n    return rgbToHex(hexToRGB(`${hex}${isShorthand ? \"f\" : \"ff\"}`, true));\n  }\n\n  return hex;\n}\n\nexport function hexify(color: Color, hasAlpha = false): string {\n  return hasAlpha ? color.hexa() : color.hex();\n}\n\nexport function rgbToHex(color: RGB | RGBA): string {\n  const { r, g, b } = color;\n\n  const rChars = numToHex(r);\n  const gChars = numToHex(g);\n  const bChars = numToHex(b);\n  const alphaChars = \"a\" in color ? numToHex(color.a * 255) : \"\";\n\n  return `#${rChars}${gChars}${bChars}${alphaChars}`.toLowerCase();\n}\n\nfunction numToHex(num: number): string {\n  return num.toString(16).padStart(2, \"0\");\n}\n\nexport function normalizeAlpha<T extends RGBA | HSVA | HSLA>(colorObject: ReturnType<Color[\"object\"]>): T {\n  const normalized = { ...colorObject, a: colorObject.alpha ?? 1 /* Color() will omit alpha if 1 */ };\n  delete normalized.alpha;\n\n  return normalized as T;\n}\n\nexport function normalizeColor(alphaColorObject: RGBA | HSVA | HSLA): ReturnType<Color[\"object\"]> {\n  const normalized = { ...alphaColorObject, alpha: alphaColorObject.a ?? 1 };\n  delete normalized.a;\n\n  return normalized;\n}\n\nexport function hexToRGB(hex: string, hasAlpha = false): RGB | RGBA {\n  if (!isValidHex(hex, hasAlpha)) {\n    return null;\n  }\n\n  hex = hex.replace(\"#\", \"\");\n\n  let r: number;\n  let g: number;\n  let b: number;\n  let a: number;\n  const isShorthand = hex.length === 3 || hex.length === 4;\n\n  if (isShorthand) {\n    const [first, second, third, fourth] = hex.split(\"\");\n\n    r = parseInt(`${first}${first}`, 16);\n    g = parseInt(`${second}${second}`, 16);\n    b = parseInt(`${third}${third}`, 16);\n    a = parseInt(`${fourth}${fourth}`, 16) / 255;\n  } else {\n    r = parseInt(hex.slice(0, 2), 16);\n    g = parseInt(hex.slice(2, 4), 16);\n    b = parseInt(hex.slice(4, 6), 16);\n    a = parseInt(hex.slice(6, 8), 16) / 255;\n  }\n\n  return isNaN(a) ? { r, g, b } : { r, g, b, a };\n}\n\n// these utils allow users to pass enum values as strings without having to access the enum\n// based on the approach suggested by https://github.com/microsoft/TypeScript/issues/17690#issuecomment-321365759,\nconst enumify = <T extends { [index: string]: U }, U extends string>(x: T) => x;\ntype Enumify<T> = T[keyof T];\n\nexport const CSSColorMode = enumify({\n  HEX: \"hex\",\n  HEXA: \"hexa\",\n  RGB_CSS: \"rgb-css\",\n  RGBA_CSS: \"rgba-css\",\n  HSL_CSS: \"hsl-css\",\n  HSLA_CSS: \"hsla-css\",\n});\ntype CSSColorMode = Enumify<typeof CSSColorMode>;\n\nexport const ObjectColorMode = enumify({\n  RGB: \"rgb\",\n  RGBA: \"rgba\",\n  HSL: \"hsl\",\n  HSLA: \"hsla\",\n  HSV: \"hsv\",\n  HSVA: \"hsva\",\n});\ntype ObjectColorMode = Enumify<typeof ObjectColorMode>;\n\nexport type SupportedMode = CSSColorMode | ObjectColorMode;\n\nexport type Format = \"auto\" | SupportedMode;\n\nexport function parseMode(colorValue: ColorValue): SupportedMode | null {\n  if (typeof colorValue === \"string\") {\n    if (colorValue.startsWith(\"#\")) {\n      const { length } = colorValue;\n\n      if (length === 4 || length === 7) {\n        return CSSColorMode.HEX;\n      }\n      if (length === 5 || length === 9) {\n        return CSSColorMode.HEXA;\n      }\n    }\n\n    if (colorValue.startsWith(\"rgba(\")) {\n      return CSSColorMode.RGBA_CSS;\n    }\n\n    if (colorValue.startsWith(\"rgb(\")) {\n      return CSSColorMode.RGB_CSS;\n    }\n\n    if (colorValue.startsWith(\"hsl(\")) {\n      return CSSColorMode.HSL_CSS;\n    }\n\n    if (colorValue.startsWith(\"hsla(\")) {\n      return CSSColorMode.HSLA_CSS;\n    }\n  }\n\n  if (typeof colorValue === \"object\") {\n    if (hasChannels(colorValue, \"r\", \"g\", \"b\")) {\n      return hasChannels(colorValue, \"a\") ? ObjectColorMode.RGBA : ObjectColorMode.RGB;\n    }\n\n    if (hasChannels(colorValue, \"h\", \"s\", \"l\")) {\n      return hasChannels(colorValue, \"a\") ? ObjectColorMode.HSLA : ObjectColorMode.HSL;\n    }\n\n    if (hasChannels(colorValue, \"h\", \"s\", \"v\")) {\n      return hasChannels(colorValue, \"a\") ? ObjectColorMode.HSVA : ObjectColorMode.HSV;\n    }\n  }\n\n  return null;\n}\n\nfunction hasChannels(colorObject: Exclude<ColorValue, string> | null, ...channels: string[]): boolean {\n  return channels.every((channel) => channel && colorObject && `${channel}` in colorObject);\n}\n\nexport function colorEqual(value1: Color | null, value2: Color | null): boolean {\n  return value1?.rgb().array().toString() === value2?.rgb().array().toString();\n}\n\nexport function alphaCompatible(mode: SupportedMode): boolean {\n  return (\n    mode === CSSColorMode.HEXA ||\n    mode === CSSColorMode.RGBA_CSS ||\n    mode === CSSColorMode.HSLA_CSS ||\n    mode === ObjectColorMode.RGBA ||\n    mode === ObjectColorMode.HSLA ||\n    mode === ObjectColorMode.HSVA\n  );\n}\n\nexport function toAlphaMode(mode: SupportedMode): SupportedMode {\n  const alphaMode =\n    mode === CSSColorMode.HEX\n      ? CSSColorMode.HEXA\n      : mode === CSSColorMode.RGB_CSS\n        ? CSSColorMode.RGBA_CSS\n        : mode === CSSColorMode.HSL_CSS\n          ? CSSColorMode.HSLA_CSS\n          : mode === ObjectColorMode.RGB\n            ? ObjectColorMode.RGBA\n            : mode === ObjectColorMode.HSL\n              ? ObjectColorMode.HSLA\n              : mode === ObjectColorMode.HSV\n                ? ObjectColorMode.HSVA\n                : mode;\n\n  return alphaMode;\n}\n\nexport function toNonAlphaMode(mode: SupportedMode): SupportedMode {\n  const nonAlphaMode =\n    mode === CSSColorMode.HEXA\n      ? CSSColorMode.HEX\n      : mode === CSSColorMode.RGBA_CSS\n        ? CSSColorMode.RGB_CSS\n        : mode === CSSColorMode.HSLA_CSS\n          ? CSSColorMode.HSL_CSS\n          : mode === ObjectColorMode.RGBA\n            ? ObjectColorMode.RGB\n            : mode === ObjectColorMode.HSLA\n              ? ObjectColorMode.HSL\n              : mode === ObjectColorMode.HSVA\n                ? ObjectColorMode.HSV\n                : mode;\n\n  return nonAlphaMode;\n}\n"],
  "mappings": "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",
  "names": []
}
