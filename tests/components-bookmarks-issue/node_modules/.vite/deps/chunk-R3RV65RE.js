import {
  e as e2
} from "./chunk-FD7NY4JS.js";
import {
  o as o5
} from "./chunk-ZEMG7GKC.js";
import {
  a
} from "./chunk-XIWETS2Q.js";
import {
  d as d2
} from "./chunk-QFKFOAJ6.js";
import {
  l
} from "./chunk-LOPMLCHC.js";
import {
  i,
  t as t2
} from "./chunk-DRCNNCTI.js";
import {
  l as l2
} from "./chunk-MKOOEINB.js";
import {
  o as o7
} from "./chunk-HBRJJENW.js";
import {
  e as e4
} from "./chunk-VHY5K2VE.js";
import {
  t
} from "./chunk-6ENXMQPD.js";
import {
  P
} from "./chunk-FV43HSGW.js";
import {
  d,
  f
} from "./chunk-ZR7OV2EH.js";
import {
  o as o4
} from "./chunk-LJULTBAY.js";
import {
  e as e3
} from "./chunk-6MGK5WBT.js";
import {
  o as o6
} from "./chunk-UYMREM3D.js";
import {
  o as o2
} from "./chunk-CDBOQCLE.js";
import {
  o as o3
} from "./chunk-IDPLBNJX.js";
import {
  o
} from "./chunk-P4MNTMCZ.js";
import {
  e
} from "./chunk-GLF3KRAL.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/PatternStyle.js
var a2;
!function(a3) {
  a3[a3.Horizontal = 0] = "Horizontal", a3[a3.Vertical = 1] = "Vertical", a3[a3.Cross = 2] = "Cross", a3[a3.ForwardDiagonal = 3] = "ForwardDiagonal", a3[a3.BackwardDiagonal = 4] = "BackwardDiagonal", a3[a3.DiagonalCross = 5] = "DiagonalCross", a3[a3.COUNT = 6] = "COUNT";
}(a2 || (a2 = {}));

// node_modules/@arcgis/core/chunks/Pattern.glsl.js
var S = 0.70710678118;
var C = S;
var x = 0.08715574274;
function T(T2) {
  const R2 = new o6(), $ = T2.multipassEnabled && (T2.output === o2.Color || T2.output === o2.Alpha), { vertex: D, fragment: L, attributes: V, varyings: A } = R2;
  d(D, T2), R2.include(o5, T2), R2.include(e2, T2), R2.include(l2, T2), R2.include(d2, T2), T2.draped ? D.uniforms.add(new o3("worldToScreenRatio", (e5, o8) => 1 / o8.screenToPCSRatio)) : V.add(e.BOUNDINGRECT, "mat3"), V.add(e.POSITION, "vec3"), V.add(e.UVMAPSPACE, "vec4"), T2.vvColor && V.add(e.COLORFEATUREATTRIBUTE, "float"), A.add("vColor", "vec4"), A.add("vpos", "vec3"), A.add("vuv", "vec2"), $ && A.add("depth", "float"), D.uniforms.add(new e3("uColor", (e5) => e5.color));
  const O = T2.style === a2.ForwardDiagonal || T2.style === a2.BackwardDiagonal || T2.style === a2.DiagonalCross;
  O && D.code.add(o`
      const mat2 rotate45 = mat2(${o.float(S)}, ${o.float(-C)},
                                 ${o.float(C)}, ${o.float(S)});
    `), T2.draped || (f(D, T2), D.uniforms.add(new o3("worldToScreenPerDistanceRatio", (e5, o8) => 1 / o8.camera.perScreenPixelRatio)), D.code.add(o`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {
float projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);
return center + halfVector * clamp(projectedLength, -1.0, 1.0);
}`), D.code.add(o`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {
float d = dot(planeNormal, planePoint);
float t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);
return rayOrigin + t * rayDir;
}`), D.code.add(o`
      float boundingRectDistanceToCamera() {
        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);
        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);
        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);
        vec3 n = normalize(cross(halfU, halfV));

        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);

        float viewAngle = dot(viewDir, n);
        float minViewAngle = ${o.float(x)};

        if (abs(viewAngle) < minViewAngle) {
          // view direction is (almost) parallel to plane -> clamp it to min angle
          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;
          viewDir = normalize(viewDir + normalComponent * n);
        }

        // intersect view direction with infinite plane that contains bounding rect
        vec3 planeProjected = intersectRayPlane(viewDir, cameraPosition, n, center);

        // clip to bounds by projecting to u and v line segments individually
        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);
        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);

        // use to calculate the closest point to camera on bounding rect
        vec3 closestPoint = uProjected + vProjected - center;

        return length(closestPoint - cameraPosition);
      }
    `)), D.code.add(o`
    vec2 scaledUV() {
      vec2 uv = uvMapSpace.xy ${O ? " * rotate45" : ""};
      vec2 uvCellOrigin = uvMapSpace.zw ${O ? " * rotate45" : ""};

      ${T2.draped ? "" : o`
            float distanceToCamera = boundingRectDistanceToCamera();
            float worldToScreenRatio = worldToScreenPerDistanceRatio / distanceToCamera;
          `}

      // Logarithmically discretize ratio to avoid jittering
      float step = 0.1;
      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);

      vec2 uvOffset = mod(uvCellOrigin * discreteWorldToScreenRatio, ${o.float(T2.patternSpacing)});
      return uvOffset + (uv * discreteWorldToScreenRatio);
    }
  `);
  const z = T2.output === o2.LinearDepth;
  return z && (R2.include(l, T2), i(R2), t2(R2)), D.code.add(o`
    void main(void) {
      vuv = scaledUV();
      vpos = position;
      ${$ ? "depth = (view * vec4(vpos, 1.0)).z;" : ""}
      forwardNormalizedVertexColor();
      forwardObjectAndLayerIdColor();
      ${T2.hasVertexColors ? "vColor *= uColor;" : T2.vvColor ? "vColor = uColor * interpolateVVColor(colorFeatureAttribute);" : "vColor = uColor;"}
      gl_Position = ${z ? o`transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);` : o`transformPosition(proj, view, vpos);`}
    }
  `), R2.include(P, T2), L.include(e4), T2.draped && L.uniforms.add(new o3("texelSize", (e5, o8) => 1 / o8.camera.pixelRatio)), T2.output === o2.Highlight && R2.include(a, T2), $ && R2.include(o7, T2), T2.output !== o2.Highlight && (L.code.add(o`
      const float lineWidth = ${o.float(T2.lineWidth)};
      const float spacing = ${o.float(T2.patternSpacing)};
      const float spacingINV = ${o.float(1 / T2.patternSpacing)};

      float coverage(float p, float txlSize) {
        p = mod(p, spacing);

        float halfTxlSize = txlSize / 2.0;

        float start = p - halfTxlSize;
        float end = p + halfTxlSize;

        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;
        coverage -= min(lineWidth, mod(start, spacing));
        coverage -= max(lineWidth - mod(end, spacing), 0.0);

        return coverage / txlSize;
      }
    `), T2.draped || L.code.add(o`const int maxSamples = 5;
float sampleAA(float p) {
vec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));
float fwidth = dxdy.x + dxdy.y;
ivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));
vec2 invSamples = 1.0 / vec2(samples);
float accumulator = 0.0;
for (int j = 0; j < maxSamples; j++) {
if(j >= samples.y) {
break;
}
for (int i = 0; i < maxSamples; i++) {
if(i >= samples.x) {
break;
}
vec2 step = vec2(i,j) * invSamples - 0.5;
accumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);
}
}
accumulator /= float(samples.x * samples.y);
return accumulator;
}`)), L.code.add(o`
    void main() {
      discardBySlice(vpos);
      ${$ ? "terrainDepthTest(depth);" : ""}
      vec4 color = vColor;
      color = highlightSlice(color, vpos);

      ${T2.output !== o2.Highlight ? o`color.a *= ${P2(T2)};` : ""}

      ${T2.output === o2.ObjectAndLayerIdColor ? o`color.a = 1.0;` : ""}

      if (color.a < ${o.float(t)}) {
        discard;
      }

      ${T2.output === o2.Alpha ? o`fragColor = vec4(color.a);` : ""}

      ${T2.output === o2.Color ? o`fragColor = color; ${T2.transparencyPassType === o4.Color ? "fragColor = premultiplyAlpha(fragColor);" : ""}` : ""}
      ${T2.output === o2.Highlight ? o`outputHighlight();` : ""}
      ${T2.output === o2.LinearDepth ? o`outputDepth(linearDepth);` : ""};
      ${T2.output === o2.ObjectAndLayerIdColor ? o`outputObjectAndLayerIdColor();` : ""}
    }
  `), R2;
}
function P2(e5) {
  function o8(o9) {
    return e5.draped ? o`coverage(vuv.${o9}, texelSize)` : o`sampleAA(vuv.${o9})`;
  }
  switch (e5.style) {
    case a2.ForwardDiagonal:
    case a2.Horizontal:
      return o8("y");
    case a2.BackwardDiagonal:
    case a2.Vertical:
      return o8("x");
    case a2.DiagonalCross:
    case a2.Cross:
      return o`
        1.0 - (1.0 - ${o8("x")}) * (1.0 - ${o8("y")})
      `;
    default:
      return "0.0";
  }
}
var R = Object.freeze(Object.defineProperty({ __proto__: null, build: T }, Symbol.toStringTag, { value: "Module" }));

export {
  a2 as a,
  T,
  R
};
//# sourceMappingURL=chunk-R3RV65RE.js.map
