{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/LineMarker.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport{markerTextureSize as e,markerSymbolSize as r,markerTipThicknessFactor as o}from\"../views/3d/support/engineContent/marker.js\";import{addLinearDepth as i,addCalculateLinearDepth as a}from\"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";import{ShaderOutput as t}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";import{SliceDraw as n}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{RibbonVertexPosition as s}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";import{OutputDepth as l}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{MarkerSizing as c}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js\";import{multipassTerrainTest as d}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{symbolAlphaCutoff as p}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";import{ColorConversion as v}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{RgbaFloatEncoding as m}from\"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";import{addProjViewLocalOrigin as f,addViewNormal as h,addPixelRatio as g}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float2PassUniform as u}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4PassUniform as w}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as y}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as S}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as b}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as P}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as x}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{TransparencyPassType as z}from\"../views/3d/webgl-engine/lib/TransparencyPassType.js\";import{VertexAttribute as L}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{LineMarkerSpace as j,LineMarkerAnchor as C}from\"../views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js\";function M(M){const D=new P,k=M.multipassEnabled&&(M.output===t.Color||M.output===t.Alpha),N=M.space===j.World;D.include(s,M),D.include(c,M),M.output===t.LinearDepth&&D.include(l,M);const{vertex:T,fragment:A}=D;return A.include(m),f(T,M),D.attributes.add(L.POSITION,\"vec3\"),D.attributes.add(L.PREVPOSITION,\"vec3\"),D.attributes.add(L.UV0,\"vec2\"),D.varyings.add(\"vColor\",\"vec4\"),D.varyings.add(\"vpos\",\"vec3\"),D.varyings.add(\"vUV\",\"vec2\"),D.varyings.add(\"vSize\",\"float\"),i(D),k&&D.varyings.add(\"depth\",\"float\"),M.hasTip&&D.varyings.add(\"vLineWidth\",\"float\"),T.uniforms.add(new u(\"nearFar\",((e,r)=>r.camera.nearFar)),new w(\"viewport\",((e,r)=>r.camera.fullViewport))),T.code.add(S`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`),T.code.add(S`void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nfloat interpolation = (-vnp - pos.z) / (prev.z - pos.z);\nprev = mix(pos, prev, interpolation);\n}\n}`),N?(D.attributes.add(L.NORMAL,\"vec3\"),h(T),T.constants.add(\"tiltThreshold\",\"float\",.7),T.code.add(S`vec3 perpendicular(vec3 v) {\nvec3 n = (viewNormal * vec4(normal.xyz, 1.0)).xyz;\nvec3 n2 = cross(v, n);\nvec3 forward = vec3(0.0, 0.0, 1.0);\nfloat tiltDot = dot(forward, n);\nreturn abs(tiltDot) < tiltThreshold ? n : n2;\n}`)):T.code.add(S`vec2 perpendicular(vec2 v) {\nreturn vec2(v.y, -v.x);\n}`),T.code.add(S`\n      #define vecN ${N?\"vec3\":\"vec2\"}\n\n      vecN normalizedSegment(vecN pos, vecN prev) {\n        vecN segment = pos - prev;\n        float segmentLen = length(segment);\n\n        // normalize or zero if too short\n        return (segmentLen > 0.001) ? segment / segmentLen : ${N?\"vec3(0.0, 0.0, 0.0)\":\"vec2(0.0, 0.0)\"};\n      }\n\n      vecN displace(vecN pos, vecN prev, float displacementLen) {\n        vecN segment = normalizedSegment(pos, prev);\n\n        vecN displacementDirU = perpendicular(segment);\n        vecN displacementDirV = segment;\n\n        ${M.anchor===C.Tip?\"pos -= 0.5 * displacementLen * displacementDirV;\":\"\"}\n\n        return pos + displacementLen * (uv0.x * displacementDirU + uv0.y * displacementDirV);\n      }\n    `),M.space===j.Screen&&(T.uniforms.add(new b(\"inverseProjectionMatrix\",((e,r)=>r.camera.inverseProjectionMatrix))),T.code.add(S`vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}`),T.code.add(S`bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}`),T.uniforms.add(new y(\"perScreenPixelRatio\",((e,r)=>r.camera.perScreenPixelRatio))),T.code.add(S`\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ${M.hasCap?\"\\n                if(prev.z > posLeft.z) {\\n                  vec2 diff = posLeft.xy - posRight.xy;\\n                  planeOrigin.xy += perpendicular(diff) / 2.0;\\n                }\\n              \":\"\"};\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  `)),g(T),a(D),T.code.add(S`void main(void) {\nif (uv0.y == 0.0) {\ngl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n}\nelse {\nfloat lineWidth = getLineWidth();\nfloat screenMarkerSize = getScreenMarkerSize();\nvec4 pos  = view * vec4(position, 1.0);\nvec4 prev = view * vec4(prevPosition, 1.0);\nclip(pos, prev);`),N?(M.hideOnShortSegments&&T.code.add(S`if (areWorldMarkersHidden(pos, prev)) {\ngl_Position = vec4(1e038, 1e038, 1e038, 1.0);\nreturn;\n}`),T.code.add(S`pos.xyz = displace(pos.xyz, prev.xyz, getWorldMarkerSize(pos));\nvec4 displacedPosScreen = projectAndScale(pos);`)):(T.code.add(S`vec4 posScreen = projectAndScale(pos);\nvec4 prevScreen = projectAndScale(prev);\nvec4 displacedPosScreen = posScreen;\ndisplacedPosScreen.xy = displace(posScreen.xy, prevScreen.xy, screenMarkerSize);`),M.space===j.Screen&&T.code.add(S`vec2 displacementDirU = perpendicular(normalizedSegment(posScreen.xy, prevScreen.xy));\nvec3 lineRight = inverseProject(posScreen + lineWidth * vec4(displacementDirU.xy, 0.0, 0.0));\nvec3 lineLeft = pos.xyz + (pos.xyz - lineRight);\npos = toFront(displacedPosScreen, lineLeft, lineRight, prev.xyz, lineWidth);\ndisplacedPosScreen = projectAndScale(pos);`)),T.code.add(S`\n        ${k?\"depth = pos.z;\":\"\"}\n        linearDepth = calculateLinearDepth(nearFar,pos.z);\n\n        // Convert back into NDC\n        displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n        // Convert texture coordinate into [0,1]\n        vUV = (uv0 + 1.0) / 2.0;\n\n        ${N?\"\":\"vUV *= displacedPosScreen.w;\"}\n\n        ${M.hasTip?\"vLineWidth = lineWidth;\":\"\"}\n\n        vSize = screenMarkerSize;\n        vColor = getColor();\n\n        // Use camera space for slicing\n        vpos = pos.xyz;\n\n        gl_Position = displacedPosScreen;\n      }\n    }\n  `),k&&D.include(d,M),D.include(n,M),A.uniforms.add(new w(\"intrinsicColor\",(e=>e.color)),new x(\"tex\",(e=>e.markerTexture))),A.include(v),D.constants.add(\"texelSize\",\"float\",1/e),A.code.add(S`float markerAlpha(vec2 samplePos) {\nsamplePos += vec2(0.5, -0.5) * texelSize;\nfloat sdf = rgba2float(texture(tex, samplePos)) - 0.5;\nfloat distance = sdf * vSize;\ndistance -= 0.5;\nreturn clamp(0.5 - distance, 0.0, 1.0);\n}`),M.hasTip&&(D.constants.add(\"relativeMarkerSize\",\"float\",r/e),D.constants.add(\"relativeTipLineWidth\",\"float\",o),A.code.add(S`\n    float tipAlpha(vec2 samplePos) {\n      // Convert coordinates s.t. they are in pixels and relative to the tip of an arrow marker\n      samplePos -= vec2(0.5, 0.5 + 0.5 * relativeMarkerSize);\n      samplePos *= vSize;\n\n      float halfMarkerSize = 0.5 * relativeMarkerSize * vSize;\n      float halfTipLineWidth = 0.5 * max(1.0, relativeTipLineWidth * vLineWidth);\n\n      ${N?\"halfTipLineWidth *= fwidth(samplePos.y);\":\"\"}\n\n      float distance = max(abs(samplePos.x) - halfMarkerSize, abs(samplePos.y) - halfTipLineWidth);\n      return clamp(0.5 - distance, 0.0, 1.0);\n    }\n  `)),D.constants.add(\"symbolAlphaCutoff\",\"float\",p),A.code.add(S`\n  void main() {\n    discardBySlice(vpos);\n    ${k?\"terrainDepthTest(depth);\":\"\"}\n\n    vec4 finalColor = intrinsicColor * vColor;\n\n    ${N?\"vec2 samplePos = vUV;\":\"vec2 samplePos = vUV * gl_FragCoord.w;\"}\n\n    ${M.hasTip?\"finalColor.a *= max(markerAlpha(samplePos), tipAlpha(samplePos));\":\"finalColor.a *= markerAlpha(samplePos);\"}\n\n    ${M.output===t.ObjectAndLayerIdColor?S`finalColor.a = 1.0;`:\"\"}\n\n    if (finalColor.a < symbolAlphaCutoff) {\n      discard;\n    }\n\n    ${M.output===t.Alpha?S`fragColor = vec4(finalColor.a);`:\"\"}\n    ${M.output===t.Color?S`fragColor = highlightSlice(finalColor, vpos);`:\"\"}\n    ${M.output===t.Color&&M.transparencyPassType===z.Color?\"fragColor = premultiplyAlpha(fragColor);\":\"\"}\n    ${M.output===t.Highlight?S`fragColor = vec4(1.0);`:\"\"}\n    ${M.output===t.LinearDepth?S`outputDepth(linearDepth);`:\"\"}\n  }\n  `),D}const D=Object.freeze(Object.defineProperty({__proto__:null,build:M},Symbol.toStringTag,{value:\"Module\"}));export{D as L,M as b};\n"],
  "mappings": "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",
  "names": ["M", "D", "o", "p", "n", "t", "e", "s", "w"]
}
