import {
  g
} from "./chunk-YQQSFFN3.js";
import {
  a2 as a4,
  f4 as f2,
  k as k2,
  n as n6,
  n3 as n7,
  s as s3
} from "./chunk-4IJED6JM.js";
import {
  M as M2,
  d as d3,
  o as o2,
  s as s2,
  t as t3
} from "./chunk-C5EJV3NW.js";
import {
  l as l2
} from "./chunk-XXIDOBRO.js";
import {
  a as a3,
  l
} from "./chunk-ZPU7GNG4.js";
import {
  M,
  kt
} from "./chunk-AVR3LWTZ.js";
import {
  j2 as j,
  t as t2,
  v
} from "./chunk-DGRFM5OL.js";
import {
  n as n5
} from "./chunk-AOAT6HYL.js";
import {
  pt,
  rt
} from "./chunk-TLTAGTBA.js";
import {
  t
} from "./chunk-2C26DRKK.js";
import {
  e as e2
} from "./chunk-M4RFJU4F.js";
import {
  U
} from "./chunk-WKVHVZW2.js";
import {
  p
} from "./chunk-3JC3OUNW.js";
import {
  Z
} from "./chunk-QNG4TY7L.js";
import {
  d as d2
} from "./chunk-VEYMN5N3.js";
import {
  b
} from "./chunk-W5ALAOW2.js";
import {
  d
} from "./chunk-326OSIM5.js";
import {
  e
} from "./chunk-VEODBKUJ.js";
import {
  o as o3
} from "./chunk-AG6JXA4M.js";
import {
  y
} from "./chunk-J7AMTUNG.js";
import {
  a as a2
} from "./chunk-HV6S3GY2.js";
import {
  u
} from "./chunk-C7NPPGFR.js";
import {
  o,
  r
} from "./chunk-QLL2YG25.js";
import {
  m,
  n as n3,
  n2 as n4
} from "./chunk-545NO6M2.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  n as n2
} from "./chunk-QHK5ZYFW.js";
import {
  a,
  c2 as c,
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has,
  k
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Writer.js
var t4 = 1.25;
var r2 = class {
  get length() {
    return this._pos;
  }
  constructor(t9, r9) {
    this._pos = 0;
    const e5 = r9 ? this._roundToNearest(r9, t9.BYTES_PER_ELEMENT) : 40;
    this._array = new ArrayBuffer(e5), this._buffer = new t9(this._array), this._ctor = t9, this._i16View = new Int16Array(this._array);
  }
  _roundToNearest(t9, r9) {
    const e5 = Math.round(t9);
    return 1 === r9 ? e5 : e5 + (r9 - e5 % r9);
  }
  _ensureSize(r9) {
    if (this._pos + r9 >= this._buffer.length) {
      const e5 = this._roundToNearest((this._array.byteLength + r9 * this._buffer.BYTES_PER_ELEMENT) * t4, this._buffer.BYTES_PER_ELEMENT), s9 = new ArrayBuffer(e5), i4 = new this._ctor(s9);
      i4.set(this._buffer, 0), this._array = s9, this._buffer = i4, this._i16View = new Int16Array(this._array);
    }
  }
  ensureSize(t9) {
    this._ensureSize(t9);
  }
  writeF32(t9) {
    this._ensureSize(1);
    const r9 = this._pos;
    return new Float32Array(this._array, 4 * this._pos, 1)[0] = t9, this._pos++, r9;
  }
  push(t9) {
    this._ensureSize(1);
    const r9 = this._pos;
    return this._buffer[this._pos++] = t9, r9;
  }
  writeFixed(t9) {
    this._buffer[this._pos++] = t9;
  }
  setValue(t9, r9) {
    this._buffer[t9] = r9;
  }
  i1616Add(t9, r9, e5) {
    this._i16View[2 * t9] += r9, this._i16View[2 * t9 + 1] += e5;
  }
  getValue(t9) {
    return this._buffer[t9];
  }
  getValueF32(t9) {
    return new Float32Array(this._array, 4 * t9, 1)[0];
  }
  incr(t9) {
    if (this._buffer.length < t9)
      throw new Error("Increment index overflows the target buffer");
    this._buffer[t9]++;
  }
  decr(t9) {
    this._buffer[t9]--;
  }
  writeRegion(t9) {
    this._ensureSize(t9.length);
    const r9 = this._pos;
    return this._buffer.set(t9, this._pos), this._pos += t9.length, r9;
  }
  writeManyFrom(t9, r9, e5) {
    this._ensureSize(e5 - r9);
    for (let s9 = r9; s9 !== e5; s9++)
      this.writeFixed(t9._buffer[s9]);
  }
  buffer() {
    const t9 = this._array.slice(0, 4 * this._pos);
    return this.destroy(), t9;
  }
  toArray() {
    return [...this._buffer];
  }
  seek(t9) {
    this._pos = t9;
  }
  destroy() {
    this._array = null, this._buffer = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexDataWriter.js
var e3 = 6;
var i = 4;
var r3 = class {
  constructor(r9, s9, n15, c5 = 0) {
    const h = e3 * c5 * Uint32Array.BYTES_PER_ELEMENT, u2 = i * c5 * n15, _3 = n15 / 4, o6 = s9.attributes.find((t9) => "pos" === t9.name || "position" === t9.name);
    if (!o6)
      throw new Error("InternalError: Unable to find position attribute");
    this.layout = { ...s9, position: o6 }, this._indices = new r2(Uint32Array, h), this._vertices = new r2(Uint32Array, u2), this._metrics = new r2(Uint32Array, 0), this._metricCountOffset = this._metrics.push(0), this._strideInt = _3, this._instanceId = r9;
  }
  serialize(t9) {
    const e5 = this._indices.buffer(), i4 = this._vertices.buffer(), r9 = this._metrics.length ? this._metrics.buffer() : null;
    return t9.push(e5, i4), { instanceId: this._instanceId, layout: this.layout, indices: e5, vertices: i4, metrics: r9 };
  }
  get strideInt() {
    return this._strideInt;
  }
  get vertexCount() {
    return this._vertices.length / this._strideInt;
  }
  get indexCount() {
    return this._indices.length;
  }
  get indexWriter() {
    return this._indices;
  }
  get vertexWriter() {
    return this._vertices;
  }
  get metricWriter() {
    return this._metrics;
  }
  vertexEnsureSize(t9) {
    this._vertices.ensureSize(t9);
  }
  indexEnsureSize(t9) {
    this._indices.ensureSize(t9);
  }
  writeIndex(t9) {
    this._indices.push(t9);
  }
  writeVertex(t9) {
    this._vertices.push(t9);
  }
  writeVertexRegion(t9) {
    this._vertices.writeRegion(t9);
  }
  writeVertexF32(t9) {
    this._vertices.writeF32(t9);
  }
  writeMetric(t9) {
    this._metrics.incr(this._metricCountOffset), t9.serialize(this._metrics);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MeshData.js
var n8 = class {
  constructor(e5, r9 = 0) {
    this._id = e5, this._sizeHint = r9, this._entityRecordCountOffset = 0, this._entityCountOffset = 0, this._entityIdIndex = 0, this._entitySortKeyIndex = 0, this._instanceIdToVertexData = /* @__PURE__ */ new Map(), this._recordIndexStart = 0, this._recordIndexCount = 0, this._recordVertexStart = 0, this._recordVertexCount = 0, this._current = { metric: null, writer: null, start: 0, sortKey: 0, instanceId: 0, layoutHash: 0, indexStart: 0, vertexStart: 0, textureKey: 0, metricBoxLenPointer: 0 }, this._entities = new r2(Uint32Array, this._sizeHint * s2.byteSizeHint), this._entityCountOffset = this._entities.push(0);
  }
  get id() {
    return this._id;
  }
  serialize() {
    const t9 = new Array(), e5 = [], r9 = this._entities.buffer();
    for (const i4 of this._instanceIdToVertexData.values())
      e5.push(i4.serialize(t9));
    return { message: { data: e5, entities: r9 }, transferList: t9 };
  }
  vertexCount() {
    var _a;
    return ((_a = this._current.writer) == null ? void 0 : _a.vertexCount) ?? 0;
  }
  indexCount() {
    var _a;
    return ((_a = this._current.writer) == null ? void 0 : _a.indexCount) ?? 0;
  }
  vertexEnsureSize(t9) {
    this._current.writer.vertexEnsureSize(t9);
  }
  indexEnsureSize(t9) {
    this._current.writer.indexEnsureSize(t9);
  }
  vertexWrite(t9) {
    this._current.writer.writeVertex(t9);
  }
  vertexWriteRegion(t9) {
    this._current.writer.writeVertexRegion(t9);
  }
  vertexWriteF32(t9) {
    this._current.writer.writeVertexF32(t9);
  }
  recordBounds(t9, e5, r9, i4) {
  }
  indexWrite(t9) {
    this._current.writer.writeIndex(t9);
  }
  metricStart(t9) {
    this._current.metric = t9;
  }
  metricEnd() {
    const t9 = this._current.writer;
    this._current.metric.bounds.length && t9.writeMetric(this._current.metric);
  }
  metricBoxWrite(t9) {
    this._current.metric.bounds.push(t9);
  }
  entityStart(t9, e5 = t9) {
    this._entityIdIndex = this._entities.push(t9), this._entitySortKeyIndex = this._entities.writeF32(e5), this._entityRecordCountOffset = this._entities.push(0);
  }
  entityRecordCount() {
    return this._entities.getValue(this._entityRecordCountOffset);
  }
  entityEnd() {
    0 === this.entityRecordCount() ? this._entities.seek(this._entityIdIndex) : this._entities.incr(this._entityCountOffset);
  }
  recordCount() {
    return this._entities.getValue(this._entityRecordCountOffset);
  }
  recordStart(t9, e5, r9 = 0) {
    this._current.writer = this._getVertexWriter(t9, e5), this._current.indexStart = this._current.writer.indexCount, this._current.vertexStart = this._current.writer.vertexCount, this._current.instanceId = t9, this._current.layoutHash = e5.hash, this._current.textureKey = r9;
  }
  recordEnd(t9 = 0) {
    const r9 = this._current.vertexStart, i4 = this._current.writer.vertexCount - r9;
    if (!i4)
      return false;
    const n15 = this._current.indexStart, s9 = this._current.writer.indexCount - n15;
    return this._recordIndexStart = n15, this._recordIndexCount = s9, this._recordVertexStart = r9, this._recordVertexCount = i4, this._entities.incr(this._entityRecordCountOffset), t3.write(this._entities, this._current.instanceId, this._current.textureKey, n15, s9, r9, i4, t9), true;
  }
  copyLast(t9, r9) {
    const i4 = this._recordVertexStart + this._recordVertexCount;
    this._entities.incr(this._entityRecordCountOffset), t3.write(this._entities, this._current.instanceId, this._current.textureKey, this._recordIndexStart + this._recordIndexCount, this._recordIndexCount, i4, this._recordVertexCount, 0);
    const n15 = this._current.writer.indexWriter, s9 = this._current.writer.vertexWriter, o6 = this._recordIndexStart + this._recordIndexCount, c5 = this._recordVertexCount;
    for (let e5 = this._recordIndexStart; e5 !== o6; e5++) {
      const t10 = n15.getValue(e5);
      n15.push(t10 + c5);
    }
    const u2 = this._current.writer.layout.stride / Uint32Array.BYTES_PER_ELEMENT, h = this._recordVertexStart * u2, _3 = (this._recordVertexStart + this._recordVertexCount) * u2;
    for (let e5 = h; e5 !== _3; e5++) {
      const t10 = s9.getValue(e5);
      s9.push(t10);
    }
    const d5 = this._current.writer.layout.position, a9 = d5.packPrecisionFactor ?? 1, x2 = d5.offset / Uint32Array.BYTES_PER_ELEMENT, y3 = t9 * a9, f5 = r9 * a9;
    for (let e5 = i4 * u2; e5 <= s9.length; e5 += u2)
      s9.i1616Add(e5 + x2, y3, f5);
    this.recordEnd();
  }
  copyLastFrom(t9, e5, r9) {
    const i4 = t9._entities.getValue(t9._entityIdIndex);
    if (i4 !== this._entities.getValue(this._entityIdIndex)) {
      const e6 = t9._entities.getValueF32(t9._entitySortKeyIndex);
      this.entityStart(i4, e6);
    }
    this.recordStart(t9._current.instanceId, t9._current.writer.layout, t9._current.textureKey);
    const n15 = this._current.writer.layout.stride / Uint32Array.BYTES_PER_ELEMENT, s9 = this._current.vertexStart, o6 = t9._current.vertexStart - s9, c5 = this._current.writer.indexWriter, u2 = this._current.writer.vertexWriter, h = t9._current.writer.indexWriter, _3 = t9._current.writer.vertexWriter;
    for (let l5 = t9._current.indexStart; l5 !== h.length; l5++) {
      const t10 = h.getValue(l5);
      c5.push(t10 - o6);
    }
    for (let l5 = t9._current.vertexStart * n15; l5 !== _3.length; l5++) {
      const t10 = _3.getValue(l5);
      u2.push(t10);
    }
    const d5 = this._current.writer.layout.position, a9 = d5.packPrecisionFactor ?? 1, x2 = d5.offset / Uint32Array.BYTES_PER_ELEMENT, y3 = e5 * a9, f5 = r9 * a9;
    for (let l5 = s9 * n15; l5 <= u2.length; l5 += n15)
      u2.i1616Add(l5 + x2, y3, f5);
    this.recordEnd();
  }
  _getVertexWriter(t9, e5) {
    const { stride: i4 } = e5, n15 = this._instanceIdToVertexData;
    return n15.has(t9) || n15.set(t9, new r3(t9, e5, i4, this._sizeHint)), n15.get(t9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/grouping.js
function e4(e5, o6) {
  let r9;
  if ("string" == typeof e5)
    r9 = c(e5 + `-seed(${o6})`);
  else {
    let t9 = 12;
    r9 = e5 ^ o6;
    do {
      r9 = 107 * (r9 >> 8 ^ r9) + t9 | 0;
    } while (0 != --t9);
  }
  return (1 + r9 / (1 << 31)) / 2;
}
function o4(t9) {
  return Math.floor(e4(t9, r4) * n9);
}
var r4 = 53290320;
var n9 = 10;

// node_modules/@arcgis/core/views/2d/layers/features/support/AComputedField.js
var s4 = class {
  destroy() {
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/DictionaryValue.js
var r5 = class extends s4 {
  constructor(e5) {
    super(), this._value = e5;
  }
  resize(e5) {
  }
  read(e5, r9) {
    return this._value;
  }
  readWithDefault(e5, r9, t9) {
    return this._value;
  }
  referencesScale() {
    return false;
  }
  referencesGeometry() {
    return false;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/MeshWriterInputEvaluator.js
var n10 = () => n.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");
async function c2(e5, r9, t9 = false) {
  const { defaultValue: s9, valueExpressionInfo: a9, value: o6 } = r9;
  if (a9) {
    const { expression: o7 } = a9, i4 = await e5.createComputedField({ expression: o7 }, t9);
    return i4 ? { ...r9, computed: i4, defaultValue: s9 } : null;
  }
  return { ...r9, computed: new r5(o6), defaultValue: s9 };
}
async function m2(e5, r9) {
  const { defaultValue: t9, valueExpressionInfo: s9 } = r9, { expression: a9 } = s9, o6 = await e5.createComputedField({ expression: a9 });
  return o6 ? { ...r9, computed: o6, defaultValue: t9 } : null;
}
var p2 = (e5) => "boolean" != typeof e5 && "number" != typeof e5 && "valueExpressionInfo" in e5;
var f3 = (e5) => e5.some((e6) => {
  for (const r9 in e6) {
    const t9 = e6[r9];
    if (p2(t9))
      return true;
  }
  return false;
});
var l3 = class _l {
  static async create(r9, t9, s9) {
    const a9 = {}, o6 = /* @__PURE__ */ new Map(), i4 = /* @__PURE__ */ new Map(), n15 = /* @__PURE__ */ new Map(), u2 = /* @__PURE__ */ new Map(), d5 = /* @__PURE__ */ new Map();
    for (const l5 in s9.params) {
      const h = s9.params[l5];
      if (null != h && "object" == typeof h)
        if (Array.isArray(h)) {
          if ("object" == typeof h[0])
            throw new Error(`InternalError: Cannot handle ${l5}. Nested array params are not supported`);
          a9[l5] = h;
        } else if ("valueExpressionInfo" in h) {
          if (h.value) {
            a9[l5] = h.value;
            continue;
          }
          const e5 = await m2(r9, h);
          if (!e5) {
            a9[l5] = h.defaultValue;
            continue;
          }
          o6.set(l5, e5), a9[l5] = null;
        } else
          switch (h.type) {
            case "cim-effect-infos":
              if (h.effectInfos.some((e5) => e5.overrides.length)) {
                i4.set(l5, { effects: await Promise.all(h.effectInfos.map(async (t10) => {
                  const s10 = t10.overrides.map((e5) => c2(r9, e5));
                  return { effect: t10.effect, compiledOverrides: (await Promise.all(s10)).filter(k) };
                })) });
                break;
              }
              a9[l5] = h.effectInfos.map((e5) => e5.effect);
              break;
            case "cim-marker-placement-info":
              h.overrides.length && n15.set(l5, { placementInfo: h, compiledOverrides: (await Promise.all(h.overrides.map((e5) => c2(r9, e5)))).filter(k) }), a9[l5] = h.placement;
              break;
            case "text-rasterization-param": {
              if (h.overrides.length) {
                const t10 = h.overrides.map((e5) => c2(r9, e5, h.useLegacyLabelEvaluationRules));
                u2.set(l5, { compiledOverrides: (await Promise.all(t10)).filter(k), rasterizationParam: h, objectIdToResourceId: /* @__PURE__ */ new Map() });
                continue;
              }
              const s10 = { type: "cim-rasterization-info", resource: h.resource };
              a9[l5] = await t9.fetchResourceImmediate(s10) ?? null;
              break;
            }
            case "sprite-rasterization-param": {
              if (h.overrides.length) {
                const t10 = h.overrides.map((e5) => c2(r9, e5));
                u2.set(l5, { compiledOverrides: (await Promise.all(t10)).filter(k), rasterizationParam: h, objectIdToResourceId: /* @__PURE__ */ new Map() });
                continue;
              }
              if ("animated" === h.resource.type) {
                u2.set(l5, { compiledOverrides: [], rasterizationParam: h, objectIdToResourceId: /* @__PURE__ */ new Map() });
                continue;
              }
              const s10 = { type: "cim-rasterization-info", resource: h.resource };
              a9[l5] = await t9.fetchResourceImmediate(s10) ?? null;
              break;
            }
            case "cim-marker-transform-param": {
              const { params: e5 } = h;
              if (f3(e5)) {
                const t10 = { compiledMarkerInfos: [] };
                await Promise.all(e5.map(async (e6) => {
                  const s10 = { props: {} };
                  for (const t11 in e6)
                    if (p2(e6[t11])) {
                      const a10 = await m2(r9, e6[t11]);
                      s10.compiledExpressionMap || (s10.compiledExpressionMap = /* @__PURE__ */ new Map());
                      const o7 = s10.compiledExpressionMap;
                      a10 && o7.set(t11, a10);
                    } else
                      s10.props[t11] = e6[t11];
                  t10.compiledMarkerInfos.push(s10);
                })), d5.set(l5, t10);
              } else
                a9[l5] = { type: "cim-marker-transform-info", infos: e5 };
              break;
            }
            default:
              a9[l5] = h;
          }
      else
        a9[l5] = h;
    }
    return new _l(s9, a9, o6, i4, n15, u2, d5);
  }
  constructor(e5, r9, t9, s9, a9, o6, i4) {
    this.inputMeshParams = e5, this._resolvedMeshParams = r9, this._dynamicProperties = t9, this._dynamicEffectProperties = s9, this._dynamicPlacementProperties = a9, this._dynamicAsyncProperties = o6, this._dynamicTransformProperties = i4, this.evaluator = (e6) => e6;
  }
  get hasDynamicProperties() {
    return !!(this._dynamicProperties.size || this._dynamicAsyncProperties.size || this._dynamicEffectProperties.size || this._dynamicTransformProperties.size || this._dynamicPlacementProperties.size);
  }
  get evaluatedMeshParams() {
    return this._evaluatedMeshParams || (this._evaluatedMeshParams = this.evaluator(this._resolvedMeshParams)), this._evaluatedMeshParams;
  }
  enqueueRequest(e5, s9, i4) {
    for (const m6 of this._dynamicAsyncProperties.values()) {
      const p5 = a(m6.rasterizationParam.resource);
      "animated" === m6.rasterizationParam.resource.type && m6.rasterizationParam.resource.randomizeStartTime && (p5.primitiveName = "__RESERVED__PRIMITIVE__NAME__", p5.startGroup = o4(s9.getObjectId() || 0));
      for (const { primitiveName: e6, propertyName: t9, computed: a9, defaultValue: l5, valueExpressionInfo: u2 } of m6.compiledOverrides)
        try {
          const r9 = "animated" === m6.rasterizationParam.resource.type ? p5.primitiveName : e6;
          o2(p5, r9, t9, a9, s9, i4, l5);
        } catch (c5) {
          n10().errorOnce(new s("invalid-arcade-expression", `Encountered an error when evaluating the arcade expression '${u2 == null ? void 0 : u2.expression}' (primitive: '${e6}', property: '${t9}')`, c5));
        }
      const f5 = e5.enqueueRequest({ type: "cim-rasterization-info", resource: p5 });
      m6.objectIdToResourceId.set(s9.getObjectId(), f5);
    }
  }
  evaluateMeshParams(e5, r9, t9) {
    for (const [s9, a9] of this._dynamicProperties.entries())
      this._resolvedMeshParams[s9] = a9.computed.readWithDefault(r9, t9, a9.defaultValue);
    for (const [s9, a9] of this._dynamicPlacementProperties.entries())
      for (const { computed: e6, defaultValue: o6, propertyName: i4 } of a9.compiledOverrides) {
        const n15 = e6.readWithDefault(r9, t9, o6);
        a9.placementInfo.placement[i4] = n15, this._resolvedMeshParams[s9] = a9.placementInfo.placement;
      }
    for (const [s9, a9] of this._dynamicEffectProperties.entries())
      for (const e6 of a9.effects) {
        for (const { computed: s10, defaultValue: a10, propertyName: o6 } of e6.compiledOverrides) {
          const i4 = s10.readWithDefault(r9, t9, a10);
          e6.effect[o6] = i4;
        }
        this._resolvedMeshParams[s9] = a9.effects.map((e7) => e7.effect);
      }
    for (const [s9, a9] of this._dynamicTransformProperties.entries()) {
      const e6 = { type: "cim-marker-transform-info", infos: [] };
      for (const s10 of a9.compiledMarkerInfos) {
        const a10 = { ...s10.props };
        if (s10.compiledExpressionMap)
          for (const [e7, o6] of s10.compiledExpressionMap) {
            const s11 = o6.computed.readWithDefault(r9, t9, o6.defaultValue);
            a10[e7] = "number" == typeof s11 || "boolean" == typeof s11 ? s11 : o6.defaultValue;
          }
        e6.infos.push(a10);
      }
      this._resolvedMeshParams[s9] = e6;
    }
    for (const [s9, a9] of this._dynamicAsyncProperties.entries()) {
      const t10 = a9.objectIdToResourceId.get(r9.getObjectId());
      if (null == t10)
        continue;
      const o6 = e5.getResource(t10);
      this._resolvedMeshParams[s9] = o6;
    }
    return this._evaluatedMeshParams = this.evaluator(this._resolvedMeshParams), this.evaluatedMeshParams;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/createMeshWriter.js
async function n11(t9, n15, a9, i4, o6, s9, c5) {
  const f5 = a4[a9], m6 = await l3.create(t9, n15, o6), p5 = new f5.constructor(i4, m6, s9, c5);
  return await p5.loadDependencies(), p5;
}
async function i2(e5, r9, a9, i4) {
  return Promise.all(a9.map((a10) => n11(e5, r9, a10.meshWriterName, n6(a10.id), a10.options, i4, a10.optionalAttributes)));
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/AResourceProxy.js
var s5 = class {
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/ResourceProxy.js
var s6 = class extends s5 {
  constructor(e5) {
    super(), this._fetcher = e5, this._controller = new AbortController(), this._pendingIds = /* @__PURE__ */ new Set(), this._pendingRequests = [], this._resourceIdToResource = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._controller.abort();
  }
  get _abortOptions() {
    return { signal: this._controller.signal };
  }
  enqueueRequest(r9) {
    const s9 = M2(r9.resource), o6 = c(JSON.stringify(s9));
    return this._pendingIds.has(o6) || (this._pendingIds.add(o6), this._pendingRequests.push({ ...r9, resourceId: o6 })), o6;
  }
  async fetchEnqueuedResources() {
    const e5 = this._pendingRequests;
    this._pendingIds.clear(), this._pendingRequests = [];
    const t9 = await this._fetcher.fetch(e5, this._abortOptions);
    for (let r9 = 0; r9 < t9.length; r9++) {
      const s9 = e5[r9].resourceId;
      this._resourceIdToResource.set(s9, t9[r9]);
    }
  }
  async fetchResourceImmediate(e5) {
    const t9 = await this._fetcher.fetch([e5], this._abortOptions);
    if (1 !== t9.length)
      throw new Error("FeaturePipelineResourceProxy: failed to fetch resources");
    return t9[0];
  }
  async fetchDictionaryResourceImmediate(e5) {
    const t9 = await this._fetcher.fetchDictionary([e5], this._abortOptions);
    if (1 !== t9.length)
      throw new Error("FeaturePipelineResourceProxy: failed to fetch dictionary resources");
    return t9[0];
  }
  getResource(e5) {
    return this._resourceIdToResource.get(e5);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/CachedField.js
var r6 = class extends s4 {
  constructor(e5) {
    super(), this._field = e5;
  }
  resize(e5) {
    throw new Error("Method not implemented.");
  }
  read(e5, r9) {
    return e5.readAttribute(this._field);
  }
  readWithDefault(e5, r9) {
    return e5.readAttribute(this._field);
  }
  referencesScale() {
    return false;
  }
  referencesGeometry() {
    return false;
  }
};

// node_modules/@arcgis/core/views/2d/arcade/callExpressionWithCursor.js
function r7(r9, n15, t9) {
  var _a;
  if (null == r9)
    return null;
  const u2 = n15.readArcadeFeature();
  n15.contextTimeZone = (_a = t9.$view) == null ? void 0 : _a.timeZone;
  try {
    return r9.evaluate({ ...t9, $feature: u2 }, r9.services);
  } catch (a9) {
    return n.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:", a9), null;
  }
}
function n12(e5) {
  return null == e5 || e5 === 1 / 0 || e5 === -1 / 0 || "number" == typeof e5 && isNaN(e5);
}
function t5(e5, r9, t9, u2) {
  var _a;
  if (null == e5)
    return null != u2 ? u2 : null;
  const a9 = r9.readArcadeFeature();
  r9.contextTimeZone = (_a = t9.$view) == null ? void 0 : _a.timeZone;
  const o6 = e5.evaluate({ ...t9, $feature: a9 }, e5.services);
  return n12(o6) ? null != u2 ? u2 : null : o6;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedExpression.js
var c3 = class _c extends s4 {
  static async create(t9, s9) {
    const a9 = await o3(t9, s9.spatialReference, s9.fields), i4 = c(t9);
    return new _c(a9, i4);
  }
  constructor(e5, r9) {
    super(), this._compiled = e5, this._cacheKey = r9;
  }
  resize(e5) {
  }
  read(e5, r9) {
    return this.referencesScale() || "system" !== r9.$view.timeZone ? r7(this._compiled, e5, r9) : this._readCached(e5, r9);
  }
  readWithDefault(e5, r9, t9) {
    return this.referencesScale() || "system" !== r9.$view.timeZone ? t5(this._compiled, e5, r9, t9) : this._readWithDefaultCached(e5, r9, t9);
  }
  referencesScale() {
    var _a;
    return ((_a = this._compiled) == null ? void 0 : _a.referencesScale()) ?? false;
  }
  referencesGeometry() {
    var _a;
    return ((_a = this._compiled) == null ? void 0 : _a.referencesGeometry()) ?? false;
  }
  _readCached(e5, r9) {
    if (e5.setCache(this._cacheKey), e5.hasCachedValue())
      return e5.getCachedValue();
    const s9 = r7(this._compiled, e5, r9);
    return e5.setCachedValue(s9), s9;
  }
  _readWithDefaultCached(e5, r9, t9) {
    if (e5.setCache(this._cacheKey), e5.hasCachedValue())
      return e5.getCachedValue();
    const a9 = t5(this._compiled, e5, r9, t9);
    return e5.setCachedValue(a9), a9;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedLegacyLabelExpression.js
var a5 = class _a extends s4 {
  static async create(t9, s9) {
    const l5 = p(t9);
    return new _a((r9) => l5.replaceAll(/{[^}]*}/g, (t10) => {
      const s10 = t10.slice(1, -1), a9 = r9.metadata.fieldsIndex.get(s10);
      if (null == a9)
        return t10;
      const l6 = r9.readAttribute(s10);
      return null == l6 ? "" : g(l6, a9);
    }));
  }
  constructor(e5) {
    super(), this._evaluator = e5;
  }
  resize(e5) {
  }
  read(e5, r9) {
    return this._evaluator(e5);
  }
  readWithDefault(e5, r9, s9) {
    const a9 = this._evaluator(e5);
    return n12(a9) ? s9 : a9;
  }
  referencesScale() {
    return false;
  }
  referencesGeometry() {
    return false;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/NormalizedField.js
var r8 = class extends s4 {
  constructor(e5, r9) {
    super(), this._field = e5, this._normalizationInfo = r9;
  }
  resize(e5) {
    throw new Error("Method not implemented.");
  }
  read(e5, r9) {
    return this._readNormalized(e5);
  }
  readWithDefault(e5, r9) {
    return this._readNormalized(e5);
  }
  referencesScale() {
    return false;
  }
  referencesGeometry() {
    return false;
  }
  _readNormalized(e5) {
    const r9 = e5.readAttribute(this._field);
    if (null == r9)
      return null;
    const { normalizationField: t9, normalizationTotal: i4, normalizationType: o6 } = this._normalizationInfo, a9 = e5.readAttribute(t9);
    switch (o6 ?? "esriNormalizeByField") {
      case "esriNormalizeByField":
        return a9 ? a9 ? r9 / a9 : void 0 : null;
      case "esriNormalizeByLog":
        return Math.log(r9) * Math.LOG10E;
      case "esriNormalizeByPercentOfTotal":
        return i4 ? r9 / i4 * 100 : null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/StaticBitSet.js
var t6 = class _t {
  static fromBuffer(e5, s9) {
    return new _t(e5, s9);
  }
  static create(e5, s9 = 4294967295) {
    const r9 = new Uint32Array(Math.ceil(e5 / 32));
    return new _t(r9, s9);
  }
  constructor(t9, e5) {
    this._mask = 0, this._buf = t9, this._mask = e5;
  }
  _getIndex(t9) {
    return Math.floor(t9 / 32);
  }
  has(t9) {
    const e5 = this._mask & t9;
    return !!(this._buf[this._getIndex(e5)] & 1 << e5 % 32);
  }
  hasRange(t9, e5) {
    let s9 = t9, r9 = e5;
    for (; s9 % 32 && s9 !== r9; ) {
      if (this.has(s9))
        return true;
      s9++;
    }
    for (; r9 % 32 && s9 !== r9; ) {
      if (this.has(s9))
        return true;
      r9--;
    }
    if (s9 === r9)
      return false;
    for (let h = s9 / 32; h !== r9 / 32; h++) {
      if (this._buf[h])
        return true;
    }
    return false;
  }
  set(t9) {
    const e5 = this._mask & t9, s9 = this._getIndex(e5), r9 = 1 << e5 % 32;
    this._buf[s9] |= r9;
  }
  setRange(t9, e5) {
    let s9 = t9, r9 = e5;
    for (; s9 % 32 && s9 !== r9; )
      this.set(s9++);
    for (; r9 % 32 && s9 !== r9; )
      this.set(r9--);
    if (s9 !== r9)
      for (let h = s9 / 32; h !== r9 / 32; h++)
        this._buf[h] = 4294967295;
  }
  unset(t9) {
    const e5 = this._mask & t9, s9 = this._getIndex(e5), r9 = 1 << e5 % 32;
    this._buf[s9] &= 4294967295 ^ r9;
  }
  resize(t9) {
    const e5 = this._buf, s9 = new Uint32Array(Math.ceil(t9 / 32));
    s9.set(e5), this._buf = s9;
  }
  or(t9) {
    for (let e5 = 0; e5 < this._buf.length; e5++)
      this._buf[e5] |= t9._buf[e5];
    return this;
  }
  and(t9) {
    for (let e5 = 0; e5 < this._buf.length; e5++)
      this._buf[e5] &= t9._buf[e5];
    return this;
  }
  xor(t9) {
    for (let e5 = 0; e5 < this._buf.length; e5++)
      this._buf[e5] ^= t9._buf[e5];
    return this;
  }
  ior(t9) {
    for (let e5 = 0; e5 < this._buf.length; e5++)
      this._buf[e5] |= ~t9._buf[e5];
    return this;
  }
  iand(t9) {
    for (let e5 = 0; e5 < this._buf.length; e5++)
      this._buf[e5] &= ~t9._buf[e5];
    return this;
  }
  ixor(t9) {
    for (let e5 = 0; e5 < this._buf.length; e5++)
      this._buf[e5] ^= ~t9._buf[e5];
    return this;
  }
  any() {
    for (let t9 = 0; t9 < this._buf.length; t9++)
      if (this._buf[t9])
        return true;
    return false;
  }
  copy(t9) {
    for (let e5 = 0; e5 < this._buf.length; e5++)
      this._buf[e5] = t9._buf[e5];
    return this;
  }
  clone() {
    return new _t(this._buf.slice(), this._mask);
  }
  clear() {
    for (let t9 = 0; t9 < this._buf.length; t9++)
      this._buf[t9] = 0;
    return this;
  }
  forEachSet(t9) {
    for (let e5 = 0; e5 < this._buf.length; e5++) {
      let s9 = this._buf[e5], r9 = 32 * e5;
      if (s9)
        for (; s9; ) {
          1 & s9 && t9(r9), s9 >>>= 1, r9++;
        }
    }
  }
  countSet() {
    let t9 = 0;
    return this.forEachSet((e5) => {
      t9++;
    }), t9;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/whereUtils.js
var a6 = () => n.getLogger("esri.views.2d.layers.features.support.whereUtils");
var n13 = { getAttribute: (e5, r9) => e5.readAttribute(r9) };
async function o5(r9, o6) {
  try {
    const s9 = await e(r9, o6);
    if (!s9.isStandardized) {
      const r10 = new s("mapview - bad input", "Unable to apply filter's definition expression, as expression is not standardized.", s9);
      a6().error(r10);
    }
    return (e5) => {
      const t9 = e5.readArcadeFeature();
      try {
        return s9.testFeature(t9, n13);
      } catch (o7) {
        return a6().warn("mapview-bad-where-clause", "Encountered an error when evaluating where clause", r9), true;
      }
    };
  } catch (s9) {
    return a6().warn("mapview-bad-where-clause", "Encountered an error when evaluating where clause", r9), (e5) => true;
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedAttributeStorage.js
var a7 = () => n.getLogger("esri.views.2d.layers.features.support.ComputedAttributeStorage");
var c4 = 4294967295;
function m3(t9, e5, s9) {
  if (!(t9.length > e5))
    for (; t9.length <= e5; )
      t9.push(s9);
}
var p3 = class {
  constructor(t9) {
    this._numerics = [], this._strings = [], this._allocatedSize = 256, this._bitsets = [], this._instanceIds = [], this._bounds = [], this._dirtyBitset = this.getBitset(this.createBitset()), this.compilationOptions = t9;
  }
  createBitset() {
    const t9 = this._bitsets.length;
    return this._bitsets.push(t6.create(this._allocatedSize, n7)), t9 + 1;
  }
  async createComputedField(e5, s9 = false) {
    if (e5.expression)
      try {
        if (!this.compilationOptions)
          throw new Error("InternalError: Compilation options not defined");
        if (s9)
          return a5.create(e5.expression, this.compilationOptions);
        return await c3.create(e5.expression, this.compilationOptions);
      } catch (d5) {
        const s10 = new s("featurelayer", "Failed to compile arcade expression", { error: d5, expression: e5.expression });
        return a7().error(s10), null;
      }
    if (e5.normalizationType || e5.normalizationField)
      return new r8(e5.field, e5);
    if (e5.field)
      return new r6(e5.field);
    const i4 = new s("featurelayer", "Unable to create computed field. No expression or field found", { info: e5 });
    return a7().error(i4), null;
  }
  async createWhereClause(t9) {
    return t9 ? o5(t9, this.compilationOptions.fields) : null;
  }
  getBitset(t9) {
    return this._bitsets[t9 - 1];
  }
  getComputedNumeric(t9, e5) {
    return this.getComputedNumericAtIndex(t9 & n7, 0);
  }
  setComputedNumeric(t9, e5, s9) {
    return this.setComputedNumericAtIndex(t9 & n7, s9, 0);
  }
  getComputedString(t9, e5) {
    return this.getComputedStringAtIndex(t9 & n7, 0);
  }
  setComputedString(t9, e5, s9) {
    return this.setComputedStringAtIndex(t9 & n7, 0, s9);
  }
  getComputedNumericAtIndex(t9, e5) {
    const s9 = t9 & n7;
    return this._ensureNumeric(e5, s9), this._numerics[e5][s9];
  }
  setComputedNumericAtIndex(t9, e5, s9) {
    const r9 = t9 & n7;
    this._ensureNumeric(e5, r9), this._numerics[e5][r9] = s9;
  }
  getPackedChunkId(t9) {
    const e5 = t9 & n7;
    return this._ensureInstanceId(e5), this._instanceIds[e5];
  }
  setPackedChunkId(t9, e5) {
    const s9 = t9 & n7;
    this._ensureInstanceId(s9), this._instanceIds[s9] = e5;
  }
  getComputedStringAtIndex(t9, e5) {
    const s9 = t9 & n7;
    return this._ensureString(e5, s9), this._strings[e5][s9];
  }
  setComputedStringAtIndex(t9, e5, s9) {
    const r9 = t9 & n7;
    this._ensureString(e5, r9), this._strings[e5][r9] = s9;
  }
  getXMin(t9) {
    return this._bounds[4 * (t9 & n7)];
  }
  getYMin(t9) {
    return this._bounds[4 * (t9 & n7) + 1];
  }
  getXMax(t9) {
    return this._bounds[4 * (t9 & n7) + 2];
  }
  getYMax(t9) {
    return this._bounds[4 * (t9 & n7) + 3];
  }
  setBounds(t9, e5, s9 = false) {
    const r9 = t9 & n7;
    if (!s9 && !this._dirtyBitset.has(t9))
      return this._bounds[4 * r9] !== c4;
    this._dirtyBitset.unset(t9);
    const n15 = e5.readGeometryWorldSpace();
    if (m3(this._bounds, 4 * r9 + 4, 0), !n15 || !n15.coords.length)
      return this._bounds[4 * r9] = c4, this._bounds[4 * r9 + 1] = c4, this._bounds[4 * r9 + 2] = c4, this._bounds[4 * r9 + 3] = c4, false;
    let o6 = 1 / 0, u2 = 1 / 0, d5 = -1 / 0, h = -1 / 0;
    return n15.forEachVertex((t10, e6) => {
      o6 = Math.min(o6, t10), u2 = Math.min(u2, e6), d5 = Math.max(d5, t10), h = Math.max(h, e6);
    }), this._bounds[4 * r9] = o6, this._bounds[4 * r9 + 1] = u2, this._bounds[4 * r9 + 2] = d5, this._bounds[4 * r9 + 3] = h, true;
  }
  getBounds(t9, e5) {
    const i4 = this.getXMin(e5), r9 = this.getYMin(e5), n15 = this.getXMax(e5), o6 = this.getYMax(e5);
    return d(t9, i4, r9, n15, o6), i4 !== c4;
  }
  _ensureNumeric(t9, e5) {
    this._numerics[t9] || (this._numerics[t9] = []);
    m3(this._numerics[t9], e5, 0);
  }
  _ensureInstanceId(t9) {
    m3(this._instanceIds, t9, 0);
  }
  _ensureString(t9, e5) {
    this._strings[t9] || (this._strings[t9] = []);
    m3(this._strings[t9], e5, null);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureMetadata.js
var i3 = class {
  constructor(i4) {
    this._options = i4, this._fieldsIndex = "fieldsIndex" in i4 ? Z.fromJSON(i4.fieldsIndex) : new Z(i4.fields), i4.spatialReference && (this._spatialReference = f.fromJSON(i4.spatialReference)), this._arcadeSchema = { fields: this.fieldsIndex.fields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, objectIdField: this.objectIdField, globalIdField: this._options.globalIdField, spatialReference: this._spatialReference, timeInfo: this._options.timeInfo, typeIdField: this._options.typeIdField ?? void 0, types: this._options.types ?? void 0, subtypeField: this._options.subtypeField, subtypes: this._options.subtypes ?? void 0 };
  }
  get fieldsIndex() {
    return this._fieldsIndex;
  }
  get geometryType() {
    return this._options.geometryType;
  }
  get subtypeField() {
    return this._options.subtypeField;
  }
  get timeInfo() {
    return this._options.timeInfo;
  }
  get objectIdField() {
    return this._options.objectIdField;
  }
  get globalIdField() {
    return this._options.globalIdField;
  }
  get arcadeSchema() {
    return this._arcadeSchema;
  }
  get spatialReference() {
    return this._spatialReference;
  }
  get timeReferenceUnknownClient() {
    return this._options.timeReferenceUnknownClient;
  }
};
var s7 = class _s extends i3 {
  static create(e5) {
    return new _s({ fields: [], objectIdField: "uid", geometryType: null, spatialReference: e5, globalIdField: null, subtypeField: null, subtypes: null, timeInfo: null, typeIdField: null, types: null, timeReferenceUnknownClient: null });
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/debug.js
var n14 = (n15, l5) => n15 && ((...n16) => l5.warn("DEBUG:", ...n16)) || (() => null);
var l4 = false;

// node_modules/@arcgis/core/views/2d/layers/features/support/DisplayIdGenerator.js
var t7 = class {
  constructor(e5) {
    this.data = e5, this._referenceCount = 0;
  }
  increment() {
    this._referenceCount += 1;
  }
  decrement() {
    this._referenceCount -= 1;
  }
  empty() {
    return 0 === this._referenceCount;
  }
};
var s8 = class {
  constructor() {
    this._freeIdsGenerationA = [], this._freeIdsGenerationB = [], this._idCounter = 1, this._freeIds = this._freeIdsGenerationA, this._objectIdToDisplayId = /* @__PURE__ */ new Map();
  }
  createIdForObjectId(s9) {
    let r9 = this._objectIdToDisplayId.get(s9);
    return r9 ? r9.increment() : (r9 = new t7(s3(this._getFreeId(), false)), r9.increment(), this._objectIdToDisplayId.set(s9, r9)), r9.data;
  }
  releaseIdForObjectId(e5) {
    const t9 = this._objectIdToDisplayId.get(e5);
    t9 && (t9.decrement(), t9.empty() && (this._objectIdToDisplayId.delete(e5), this._freeIds.push(t9.data)));
  }
  releaseAll() {
    for (const e5 of this._objectIdToDisplayId.values())
      this._freeIds.push(e5.data);
    this._objectIdToDisplayId.clear();
  }
  incrementGeneration() {
    this._freeIds = this._freeIds === this._freeIdsGenerationA ? this._freeIdsGenerationB : this._freeIdsGenerationA;
  }
  _getFreeId() {
    return this._freeIds.length ? this._freeIds.pop() : this._idCounter++;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureStoreQueryAdapter.js
var t8 = class {
  getObjectId(t9) {
    return t9.getObjectId();
  }
  getAttributes(t9) {
    return t9.readAttributes();
  }
  getAttribute(t9, e5) {
    return t9.readAttribute(e5);
  }
  getAttributeAsTimestamp(t9, e5) {
    return t9.readAttributeAsTimestamp(e5);
  }
  cloneWithGeometry(t9, e5) {
    return t9;
  }
  getGeometry(t9) {
    return t9.readGeometryWorldSpace();
  }
  getCentroid(t9, e5) {
    return t9.readCentroidForDisplay();
  }
};
t8.Shared = new t8();

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureFilter.js
var d4 = 1;
var m4 = 2;
var p4 = class _p {
  constructor(t9) {
    this._geometryBounds = u(), this._idToVisibility = /* @__PURE__ */ new Map(), this._serviceInfo = t9;
  }
  static async create(t9) {
    const e5 = new _p(t9);
    return await e5.update(t9.filterJSON, t9.spatialReference), e5;
  }
  get hash() {
    return this._hash;
  }
  check(t9) {
    return this._applyFilter(t9);
  }
  clear() {
    const t9 = this._resetAllHiddenIds();
    return this.update(), { show: t9, hide: [] };
  }
  invalidate() {
    this._idToVisibility.forEach((t9, e5) => {
      this._idToVisibility.set(e5, 0);
    });
  }
  setKnownIds(t9) {
    for (const e5 of t9)
      this._idToVisibility.set(e5, d4);
  }
  setTrue(t9) {
    const e5 = [], i4 = [], s9 = new Set(t9);
    return this._idToVisibility.forEach((t10, r9) => {
      const o6 = !!(this._idToVisibility.get(r9) & d4), a9 = s9.has(r9);
      !o6 && a9 ? e5.push(r9) : o6 && !a9 && i4.push(r9), this._idToVisibility.set(r9, a9 ? d4 | m4 : 0);
    }), { show: e5, hide: i4 };
  }
  createQuery() {
    const { geometry: t9, spatialRel: e5, where: i4, timeExtent: s9, objectIds: r9 } = this;
    return b.fromJSON({ geometry: t9, spatialRel: e5, where: i4, timeExtent: s9, objectIds: r9 });
  }
  async update(t9, e5) {
    this._hash = JSON.stringify(t9);
    const i4 = await j(t9, null, e5);
    await Promise.all([this._setGeometryFilter(i4), this._setIdFilter(i4), this._setAttributeFilter(i4), this._setTimeFilter(i4)]);
  }
  async _setAttributeFilter(t9) {
    if (!(t9 == null ? void 0 : t9.where))
      return this._clause = null, void (this.where = null);
    this._clause = await o5(t9.where, this._serviceInfo.fieldsIndex), this.where = t9.where;
  }
  _setIdFilter(t9) {
    this._idsToShow = (t9 == null ? void 0 : t9.objectIds) && new Set(t9.objectIds), this._idsToHide = (t9 == null ? void 0 : t9.hiddenIds) && new Set(t9.hiddenIds), this.objectIds = t9 == null ? void 0 : t9.objectIds;
  }
  async _setGeometryFilter(t9) {
    if (!(t9 == null ? void 0 : t9.geometry))
      return this._spatialQueryOperator = null, this.geometry = null, void (this.spatialRel = null);
    const e5 = t9.geometry, i4 = t9.spatialRel || "esriSpatialRelIntersects", r9 = await v(i4, e5, this._serviceInfo.geometryType, this._serviceInfo.hasZ, this._serviceInfo.hasM);
    a2(this._geometryBounds, e5), this._spatialQueryOperator = r9, this.geometry = e5, this.spatialRel = i4;
  }
  _setTimeFilter(i4) {
    if (this.timeExtent = this._timeOperator = null, i4 == null ? void 0 : i4.timeExtent)
      if (this._serviceInfo.timeInfo)
        this.timeExtent = i4.timeExtent, this._timeOperator = t2(this._serviceInfo.timeInfo, i4.timeExtent, t8.Shared);
      else {
        const s9 = new s("feature-layer-view:time-filter-not-available", "Unable to apply time filter, as layer doesn't have time metadata.", i4.timeExtent);
        n.getLogger("esri.views.2d.layers.features.controllers.FeatureFilter").error(s9);
      }
  }
  _applyFilter(t9) {
    return this._filterByGeometry(t9) && this._filterById(t9) && this._filterByTime(t9) && this._filterByExpression(t9);
  }
  _filterByExpression(t9) {
    return !this.where || this._clause(t9);
  }
  _filterById(t9) {
    var _a, _b;
    return (!((_a = this._idsToHide) == null ? void 0 : _a.size) || !this._idsToHide.has(t9.getObjectId())) && (!((_b = this._idsToShow) == null ? void 0 : _b.size) || this._idsToShow.has(t9.getObjectId()));
  }
  _filterByGeometry(t9) {
    if (!this.geometry)
      return true;
    const e5 = t9.readGeometryWorldSpace();
    return !!e5 && this._spatialQueryOperator(e5);
  }
  _filterByTime(t9) {
    return null == this._timeOperator || this._timeOperator(t9);
  }
  _resetAllHiddenIds() {
    const t9 = [];
    return this._idToVisibility.forEach((e5, i4) => {
      e5 & d4 || (this._idToVisibility.set(i4, d4), t9.push(i4));
    }), t9;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/AttributeStore.js
function g2(t9, e5) {
  if (!t9 || !e5)
    return t9;
  switch (e5) {
    case "radius":
    case "distance":
      return 2 * t9;
    case "diameter":
    case "width":
      return t9;
    case "area":
      return Math.sqrt(t9);
  }
  return t9;
}
var f4 = () => n.getLogger("esri.views.layers.2d.features.support.AttributeStore");
var _ = n14(l4, f4());
var y2 = { sharedArrayBuffer: has("esri-shared-array-buffer"), atomics: has("esri-atomics") };
var m5 = class {
  constructor(t9, e5, i4) {
    this.size = 0, this.texelSize = 4, this.dirtyStart = 0, this.dirtyEnd = 0;
    const { pixelType: s9, layout: r9, textureOnly: n15 } = e5;
    this.textureOnly = n15 || false, this.pixelType = s9, this.layout = r9, this._resetRange(), this.size = t9, this.isLocal = i4, n15 || (this.data = this._initData(s9, t9));
  }
  get buffer() {
    var _a;
    return (_a = this.data) == null ? void 0 : _a.buffer;
  }
  unsetComponentAllTexels(t9, e5) {
    const i4 = this.data;
    for (let s9 = 0; s9 < this.size * this.size; s9++)
      i4[s9 * this.texelSize + t9] &= ~e5;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponentAllTexels(t9, e5) {
    const i4 = this.data;
    for (let s9 = 0; s9 < this.size * this.size; s9++)
      i4[s9 * this.texelSize + t9] |= 255 & e5;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponent(t9, e5, i4) {
    const s9 = this.data;
    for (const r9 of i4)
      s9[r9 * this.texelSize + t9] |= e5, this.dirtyStart = Math.min(this.dirtyStart, r9), this.dirtyEnd = Math.max(this.dirtyEnd, r9);
  }
  setComponentTexel(t9, e5, i4) {
    this.data[i4 * this.texelSize + t9] |= e5, this.dirtyStart = Math.min(this.dirtyStart, i4), this.dirtyEnd = Math.max(this.dirtyEnd, i4);
  }
  unsetComponentTexel(t9, e5, i4) {
    this.data[i4 * this.texelSize + t9] &= ~e5, this.dirtyStart = Math.min(this.dirtyStart, i4), this.dirtyEnd = Math.max(this.dirtyEnd, i4);
  }
  getData(t9, e5) {
    const i4 = f2(t9);
    return this.data[i4 * this.texelSize + e5];
  }
  setData(t9, e5, i4) {
    const s9 = f2(t9), r9 = 1 << e5;
    this.layout & r9 ? null != this.data && (this.data[s9 * this.texelSize + e5] = i4, this.dirtyStart = Math.min(this.dirtyStart, s9), this.dirtyEnd = Math.max(this.dirtyEnd, s9)) : f4().error("mapview-attributes-store", "Tried to set a value for a texel's readonly component");
  }
  expand(t9) {
    if (this.size = t9, !this.textureOnly) {
      const e5 = this._initData(this.pixelType, t9), i4 = this.data;
      e5.set(i4), this.data = e5;
    }
  }
  toMessage() {
    const t9 = this.dirtyStart, e5 = this.dirtyEnd, i4 = this.texelSize;
    if (t9 > e5)
      return null;
    this._resetRange();
    const s9 = !this.isLocal, r9 = this.pixelType, n15 = this.layout, a9 = this.data;
    return { start: t9, end: e5, data: s9 && a9.slice(t9 * i4, (e5 + 1) * i4) || null, pixelType: r9, layout: n15 };
  }
  _initData(t9, e5) {
    const i4 = ArrayBuffer, s9 = d3(t9), r9 = new s9(new i4(e5 * e5 * 4 * s9.BYTES_PER_ELEMENT));
    for (let n15 = 0; n15 < r9.length; n15 += 4)
      r9[n15 + 1] = 255;
    return r9;
  }
  _resetRange() {
    this.dirtyStart = 2147483647, this.dirtyEnd = 0;
  }
};
var b2 = class {
  constructor(t9) {
    this._client = t9, this._filters = [], this._blocks = new Array(), this._attributeComputeInfo = null, this._abortController = new AbortController(), this._size = kt, this._idsToHighlight = /* @__PURE__ */ new Map(), this._referencesScale = false, this._referencesGeometry = false, this._initialized = false, this.version = 0, this._idGenerator = new s8(), this._epoch = 1;
  }
  destroy() {
    this._abortController.abort();
  }
  _initialize() {
    if (null != this._blockDescriptors)
      return;
    const t9 = U.FLOAT;
    _(`Creating AttributeStore ${y2.sharedArrayBuffer ? "with" : "without"} shared memory`), this._blockDescriptors = [{ pixelType: U.UNSIGNED_BYTE, layout: 1 }, { pixelType: U.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: U.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: t9, layout: 15 }, { pixelType: t9, layout: 15 }, { pixelType: t9, layout: 15 }, { pixelType: t9, layout: 15 }], this._blocks = this._blockDescriptors.map(() => null);
  }
  get referencesScale() {
    return this._referencesScale;
  }
  get referencesGeometry() {
    return this._referencesGeometry;
  }
  get hasHighlight() {
    return this._idsToHighlight.size > 0;
  }
  createDisplayIdForObjectId(t9) {
    return this._idGenerator.createIdForObjectId(t9);
  }
  releaseDisplayIdForObjectId(t9) {
    return this._idGenerator.releaseIdForObjectId(t9);
  }
  incrementDisplayIdGeneration() {
    this._idGenerator.incrementGeneration();
  }
  releaseAllIds() {
    this._idGenerator.releaseAll();
  }
  async update(t9, e5, s9, r9, n15 = 0) {
    const a9 = d2(this._schema, t9);
    if (this.version = n15, a9 && (has("esri-2d-update-debug") && console.debug(`Version[${n15}] AttributeStore.update`, { changed: a9 }), this._schema = t9, this._attributeComputeInfo = null, this._initialize(), null != t9))
      if (s9 && (this._filters = await Promise.all(t9.filters.map((t10) => t10 ? p4.create({ geometryType: s9.geometryType, hasM: false, hasZ: false, timeInfo: s9.timeInfo, fieldsIndex: s9.fieldsIndex, spatialReference: r9 ?? s9.spatialReference, filterJSON: t10 }) : null))), "subtype" !== t9.type)
        this._attributeComputeInfo = { isSubtype: false, map: /* @__PURE__ */ new Map() }, await Promise.all(t9.bindings.map(async (t10) => {
          const i4 = await this._bind(e5, t10);
          this._referencesGeometry = this._referencesGeometry || ((i4 == null ? void 0 : i4.referencesGeometry()) ?? false), this._referencesScale = this._referencesScale || ((i4 == null ? void 0 : i4.referencesScale()) ?? false);
        }));
      else {
        this._attributeComputeInfo = { isSubtype: true, subtypeField: t9.subtypeField, map: /* @__PURE__ */ new Map() }, this._referencesScale = false, this._referencesGeometry = false;
        for (const i4 in t9.bindings) {
          const s10 = t9.bindings[i4];
          await Promise.all(s10.map(async (t10) => {
            const s11 = await this._bind(e5, t10, parseInt(i4, 10));
            this._referencesGeometry = this._referencesGeometry || ((s11 == null ? void 0 : s11.referencesGeometry()) ?? false), this._referencesScale = this._referencesScale || ((s11 == null ? void 0 : s11.referencesScale()) ?? false);
          }));
        }
      }
  }
  setHighlight(t9, e5) {
    const i4 = this._getBlock(0);
    i4.unsetComponentAllTexels(0, (1 << l2.length) - 1);
    for (const { displayId: s9, highlightFlags: r9 } of t9) {
      if (null == s9)
        continue;
      const t10 = f2(s9);
      i4.setComponent(0, r9, [t10]);
    }
    this._idsToHighlight.clear();
    for (const { objectId: s9, highlightFlags: r9 } of t9)
      this._idsToHighlight.set(s9, r9);
    for (const { objectId: s9, highlightFlags: r9 } of e5)
      this._idsToHighlight.set(s9, r9);
  }
  setData(t9, e5, i4, s9) {
    const r9 = f2(t9);
    this._ensureSizeForTexel(r9), this._getBlock(e5).setData(t9, i4, s9);
  }
  getData(t9, e5, i4) {
    return this._getBlock(e5).getData(t9, i4);
  }
  getHighlightFlags(t9) {
    return this._idsToHighlight.get(t9) || 0;
  }
  unsetAttributeData(t9) {
    const e5 = f2(t9);
    this._getBlock(0).setData(e5, 0, 0);
  }
  setAttributeData(t9, e5, i4) {
    const s9 = f2(t9);
    this._ensureSizeForTexel(s9), this._getBlock(0).setData(s9, 0, this.getFilterFlags(e5));
    const r9 = this._attributeComputeInfo, o6 = 1, h = 4;
    let c5 = null;
    r9 && (c5 = r9.isSubtype ? r9.map.get(e5.readAttribute(r9.subtypeField)) : r9.map, (c5 == null ? void 0 : c5.size) && c5.forEach((t10, r10) => {
      var _a;
      const a9 = r10 * o6 % h, c6 = Math.floor(r10 * o6 / h), d5 = this._getBlock(c6 + M.VV);
      let u2 = (_a = t10.field) == null ? void 0 : _a.read(e5, i4);
      t10.valueRepresentation && (u2 = g2(u2, t10.valueRepresentation));
      (null === u2 || isNaN(u2) || u2 === 1 / 0 || u2 === -1 / 0) && (u2 = k2), d5.setData(s9, a9, u2);
    }));
  }
  get epoch() {
    return this._epoch;
  }
  sendUpdates() {
    const t9 = this._blocks.map((t10) => null != t10 ? t10.toMessage() : null), e5 = this._getInitArgs();
    has("esri-2d-log-updating") && console.log("AttributeStore: _doSendUpdate.start"), this._client.update({ initArgs: e5, blockData: t9, version: this.version, sendUpdateEpoch: this._epoch }), this._epoch += 1, has("esri-2d-log-updating") && console.log("AttributeStore: _doSendUpdate.end");
  }
  _ensureSizeForTexel(t9) {
    for (; t9 >= this._size * this._size; )
      if (this._expand())
        return;
  }
  async _bind(t9, e5, i4) {
    const s9 = await t9.createComputedField(e5), { valueRepresentation: r9 } = e5, n15 = this._attributeComputeInfo;
    if (n15.isSubtype) {
      const t10 = n15.map.get(i4) ?? /* @__PURE__ */ new Map();
      t10.set(e5.binding, { field: s9, valueRepresentation: r9 }), n15.map.set(i4, t10);
    } else
      n15.map.set(e5.binding, { field: s9, valueRepresentation: r9 });
    return s9;
  }
  _getInitArgs() {
    return this._initialized ? null : (this._initialized = true, this._getBlock(M.Animation), this._getBlock(M.GPGPU), { blockSize: this._size, blockDescriptors: this._blocks.map((t9) => null != t9 ? { textureOnly: t9.textureOnly, buffer: t9.buffer, pixelType: t9.pixelType } : null) });
  }
  _getBlock(t9) {
    const e5 = this._blocks[t9];
    if (null != e5)
      return e5;
    _(`Initializing AttributeBlock at index ${t9}`);
    const i4 = new m5(this._size, this._blockDescriptors[t9], this._client.isLocal);
    return this._blocks[t9] = i4, this._initialized = false, i4;
  }
  _expand() {
    if (this._size < this._schema.capabilities.maxTextureSize) {
      const t9 = this._size <<= 1;
      _("Expanding block size to", t9, this._blocks);
      for (const e5 of this._blocks)
        e5 == null ? void 0 : e5.expand(t9);
      return this._initialized = false, this._size = t9, 0;
    }
    return f4().error(new s("mapview-limitations", "Maximum number of onscreen features exceeded.")), -1;
  }
  isVisible(t9) {
    return !!(this._getBlock(0).getData(t9, 0) & 1 << l2.length);
  }
  getFilterFlags(t9) {
    let e5 = 0;
    for (let s9 = 0; s9 < this._filters.length; s9++) {
      const i5 = !!(1 << s9), r9 = this._filters[s9];
      e5 |= (!i5 || null == r9 || r9.check(t9) ? 1 : 0) << s9;
    }
    let i4 = 0;
    if (this._idsToHighlight.size) {
      const e6 = t9.getObjectId();
      i4 = this.getHighlightFlags(e6);
    }
    return e5 << l2.length | i4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetCache.js
var a8 = class {
  constructor(a9) {
    this._valid = t6.create(a9), this._data = new Array(a9);
  }
  has(t9) {
    return this._valid.has(t9);
  }
  set(t9, a9) {
    this._valid.set(t9), this._data[t9] = a9;
  }
  get(t9) {
    return this._data[t9];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReader.js
var g3 = has("featurelayer-simplify-thresholds") ?? [0.5, 0.5, 0.5, 0.5];
var _2 = g3[0];
var x = g3[1];
var b3 = g3[2];
var T = g3[3];
var I = has("featurelayer-simplify-payload-size-factors") ?? [1, 2, 4];
var A = I[0];
var D = I[1];
var F = I[2];
var S = has("featurelayer-simplify-mobile-factor") ?? 2;
var j2 = has("esri-mobile");
var B = 4294967295;
function C(e5, t9, r9) {
  if (!(e5.length > t9))
    for (; e5.length <= t9; )
      e5.push(r9);
}
var M3 = class {
  constructor(e5) {
    this.metadata = e5, this.type = "FeatureSetReader", this._deleted = null, this._joined = [], this._objectIdToIndex = null, this._boundsBuffer = [], this._caches = /* @__PURE__ */ new Map(), this.arcadeDeclaredClass = "esri.arcade.Feature", this._contextTimeZone = null;
  }
  get isEmpty() {
    return null != this._deleted && this._deleted.countSet() === this.getSize();
  }
  getAreaSimplificationThreshold(e5, t9) {
    let r9 = 1;
    const s9 = j2 ? S : 1;
    t9 > 4e6 ? r9 = F * s9 : t9 > 1e6 ? r9 = D * s9 : t9 > 5e5 ? r9 = A * s9 : t9 > 1e5 && (r9 = s9);
    let i4 = 0;
    return e5 > 4e3 ? i4 = T * r9 : e5 > 2e3 ? i4 = b3 * r9 : e5 > 100 ? i4 = x : e5 > 15 && (i4 = _2), i4;
  }
  parseTimestampOffset(e5) {
    return e5;
  }
  getBounds(e5) {
    if (C(this._boundsBuffer, 4 * this.getIndex() + 4, 0), this.getBoundsXMin() === B)
      return false;
    if (0 === this.getBoundsXMin()) {
      const t10 = this.readGeometryWorldSpace();
      if (!t10)
        return this.setBoundsXMin(B), false;
      let r10 = 1 / 0, s10 = 1 / 0, i5 = -1 / 0, a9 = -1 / 0;
      return t10.forEachVertex((e6, t11) => {
        r10 = Math.min(r10, e6), s10 = Math.min(s10, t11), i5 = Math.max(i5, e6), a9 = Math.max(a9, t11);
      }), this.setBoundsXMin(r10), this.setBoundsYMin(s10), this.setBoundsXMax(i5), this.setBoundsYMax(a9), d(e5, r10, s10, i5, a9), true;
    }
    const t9 = this.getBoundsXMin(), r9 = this.getBoundsYMin(), s9 = this.getBoundsXMax(), i4 = this.getBoundsYMax();
    return d(e5, t9, r9, s9, i4), true;
  }
  getBoundsXMin() {
    return this._boundsBuffer[4 * this.getIndex()];
  }
  setBoundsXMin(e5) {
    this._boundsBuffer[4 * this.getIndex()] = e5;
  }
  getBoundsYMin() {
    return this._boundsBuffer[4 * this.getIndex() + 1];
  }
  setBoundsYMin(e5) {
    this._boundsBuffer[4 * this.getIndex() + 1] = e5;
  }
  getBoundsXMax() {
    return this._boundsBuffer[4 * this.getIndex() + 2];
  }
  setBoundsXMax(e5) {
    this._boundsBuffer[4 * this.getIndex() + 2] = e5;
  }
  getBoundsYMax() {
    return this._boundsBuffer[4 * this.getIndex() + 3];
  }
  setBoundsYMax(e5) {
    this._boundsBuffer[4 * this.getIndex() + 3] = e5;
  }
  readAttributeAsTimestamp(e5) {
    const t9 = this.readAttribute(e5);
    return "string" == typeof t9 ? new Date(t9).getTime() : "number" == typeof t9 || null == t9 ? t9 : null;
  }
  readAttribute(e5, t9 = false) {
    const r9 = this._readAttribute(e5, t9);
    if (void 0 !== r9)
      return r9;
    for (const s9 of this._joined) {
      s9.setIndex(this.getIndex());
      const r10 = s9._readAttribute(e5, t9);
      if (void 0 !== r10)
        return r10;
    }
  }
  readAttributes() {
    const e5 = this._readAttributes();
    for (const t9 of this._joined) {
      t9.setIndex(this.getIndex());
      const r9 = t9._readAttributes();
      for (const t10 of Object.keys(r9))
        e5[t10] = r9[t10];
    }
    return e5;
  }
  joinAttributes(e5) {
    this._joined.push(e5);
  }
  removeIds(e5) {
    if (null == this._objectIdToIndex) {
      const e6 = /* @__PURE__ */ new Map(), r10 = this.getCursor();
      for (; r10.next(); ) {
        const s9 = r10.getObjectId();
        n2(s9), e6.set(s9, r10.getIndex());
      }
      this._objectIdToIndex = e6;
    }
    const r9 = this._objectIdToIndex;
    for (const t9 of e5.values())
      r9.has(t9) && this._removeAtIndex(r9.get(t9));
  }
  readOptimizedFeatureWorldSpace() {
    const e5 = this.readGeometryWorldSpace(), t9 = this.readAttributes(), r9 = this.readCentroidWorldSpace(), s9 = new t(e5, t9, r9);
    return s9.objectId = this.getObjectId(), s9.displayId = this.getDisplayId(), s9;
  }
  readLegacyFeatureForDisplay() {
    const e5 = this.readCentroidForDisplay();
    return { attributes: this.readAttributes(), geometry: this.readLegacyGeometryForDisplay(), centroid: (e5 && { x: e5.coords[0], y: e5.coords[1] }) ?? null };
  }
  readLegacyFeatureWorldSpace() {
    const e5 = this.readCentroidWorldSpace();
    return { attributes: this.readAttributes(), geometry: this._readLegacyGeometryWorldSpace(), centroid: (e5 && { x: e5.coords[0], y: e5.coords[1] }) ?? null };
  }
  readLegacyGeometryForDisplay() {
    const e5 = this.readGeometryForDisplay();
    return rt(e5, this.geometryType, false, false);
  }
  readXForDisplay() {
    return this._readX();
  }
  readYForDisplay() {
    return this._readY();
  }
  readXWorldSpace() {
    const e5 = this._readX(), t9 = this.getInTransform();
    return null == t9 ? e5 : e5 * t9.scale[0] + t9.translate[0];
  }
  readYWorldSpace() {
    const e5 = this._readY(), t9 = this.getInTransform();
    return null == t9 ? e5 : t9.translate[1] - e5 * t9.scale[1];
  }
  readGeometryForDisplay() {
    const e5 = this._readGeometryDeltaDecoded(true);
    if (!e5) {
      const e6 = this._createGeometryFromServerCentroid();
      return e6 ? e6.deltaDecode() : null;
    }
    return e5;
  }
  readGeometryWorldSpace() {
    let e5 = this._readGeometry();
    if (e5 || (e5 = this._createGeometryFromServerCentroid()), !e5)
      return null;
    const t9 = e5.clone(), r9 = this.getInTransform();
    return null != r9 && pt(t9, t9, this.hasZ, this.hasM, r9), t9;
  }
  readCentroidForDisplay() {
    const e5 = this.readGeometryForDisplay();
    return e5 ? this._computeDisplayCentroid(e5) : this._readServerCentroid();
  }
  readCentroidWorldSpace() {
    const e5 = this.readGeometryForDisplay(), t9 = e5 ? this._computeDisplayCentroid(e5) : this._readServerCentroid();
    if (!t9)
      return null;
    const r9 = t9.clone(), s9 = this.getInTransform();
    return null != s9 && pt(r9, r9, this.hasZ, this.hasM, s9), r9;
  }
  setCache(e5) {
    let t9 = this._caches.get(e5);
    null == t9 && (t9 = new a8(this.getSize()), this._caches.set(e5, t9)), this._activeCache = t9;
  }
  setCachedValue(e5) {
    this._activeCache.set(this.getIndex(), e5);
  }
  hasCachedValue() {
    return this._activeCache.has(this.getIndex());
  }
  getCachedValue() {
    return this._activeCache.get(this.getIndex());
  }
  _readGeometryDeltaDecoded(e5) {
    const t9 = this._readGeometry(e5);
    return "esriGeometryPoint" !== this.geometryType && t9 && this.getInTransform() ? t9.deltaDecode() : t9;
  }
  get contextTimeZone() {
    return this._contextTimeZone;
  }
  set contextTimeZone(e5) {
    this._contextTimeZone = e5;
  }
  readArcadeFeature() {
    return this;
  }
  hasField(e5) {
    return this.fields.has(e5) || this._joined.some((t9) => t9.hasField(e5));
  }
  geometry() {
    const e5 = this.readGeometryWorldSpace(), t9 = rt(e5, this.geometryType, this.hasZ, this.hasM), r9 = y(t9);
    if (r9) {
      if (!this.metadata.spatialReference)
        throw new Error("InternalError: Expected spatial reference to be defined");
      r9.spatialReference = this.metadata.spatialReference;
    }
    return r9;
  }
  autocastArcadeDate(t9, r9) {
    return r9 && r9 instanceof Date ? this.isUnknownDateTimeField(t9) ? m.unknownDateJSToArcadeDate(r9) : m.dateJSAndZoneToArcadeDate(r9, this.contextTimeZone ?? o) : r9;
  }
  isUnknownDateTimeField(e5) {
    return this.metadata.fieldsIndex.getTimeZone(e5) === r;
  }
  field(t9) {
    let i4 = this.fields.get(t9);
    if (i4)
      switch (i4.type) {
        case "date-only":
        case "esriFieldTypeDateOnly":
          return n3.fromReader(this.readAttribute(t9, false));
        case "time-only":
        case "esriFieldTypeTimeOnly":
          return n4.fromReader(this.readAttribute(t9, false));
        case "esriFieldTypeTimestampOffset":
        case "timestamp-offset":
          return m.fromReaderAsTimeStampOffset(this.readAttribute(t9, false));
        case "date":
        case "esriFieldTypeDate":
          return this.autocastArcadeDate(t9, this.readAttribute(t9, true));
        default:
          return this.readAttribute(t9, false);
      }
    for (const o6 of this._joined)
      if (o6.setIndex(this.getIndex()), i4 = o6.fields.get(t9), i4)
        switch (i4.type) {
          case "date-only":
          case "esriFieldTypeDateOnly":
            return n3.fromReader(o6._readAttribute(t9, false));
          case "time-only":
          case "esriFieldTypeTimeOnly":
            return n4.fromReader(o6._readAttribute(t9, false));
          case "esriFieldTypeTimestampOffset":
          case "timestamp-offset":
            return m.fromReaderAsTimeStampOffset(o6._readAttribute(t9, false));
          case "date":
          case "esriFieldTypeDate":
            return this.autocastArcadeDate(t9, o6._readAttribute(t9, true));
          default:
            return this.readAttribute(t9, false);
        }
    throw new Error(`Field ${t9} does not exist`);
  }
  setField(e5, t9) {
    throw new Error("Unable to update feature attribute values, feature is readonly");
  }
  keys() {
    return this.fields.fields.map((e5) => e5.name);
  }
  castToText(e5 = false) {
    if (!e5)
      return JSON.stringify(this.readLegacyFeatureForDisplay());
    const t9 = this.readLegacyFeatureForDisplay();
    if (!t9)
      return JSON.stringify(null);
    const r9 = { geometry: t9.geometry, attributes: { ...t9.attributes ?? {} } };
    for (const s9 in r9.attributes) {
      const e6 = r9.attributes[s9];
      e6 instanceof Date && (r9.attributes[s9] = e6.getTime());
    }
    return JSON.stringify(r9);
  }
  gdbVersion() {
    return null;
  }
  fullSchema() {
    return this.metadata.arcadeSchema;
  }
  castAsJson(e5 = null) {
    var _a;
    return { attributes: this._readAttributes(), geometry: true === (e5 == null ? void 0 : e5.keepGeometryType) ? this.geometry() : ((_a = this.geometry()) == null ? void 0 : _a.toJSON()) ?? null };
  }
  castAsJsonAsync(e5 = null, t9 = null) {
    return Promise.resolve(this.castAsJson(t9));
  }
  _getExists() {
    return null == this._deleted || !this._deleted.has(this.getIndex());
  }
  _computeDisplayCentroid(e5) {
    if (null == this.getInTransform())
      return n5(new e2(), e5, this.hasM, this.hasZ);
    const t9 = a3.fromOptimized(e5, this.geometryType);
    t9.yFactor *= -1;
    const r9 = l(t9);
    return r9 ? (r9[1] *= -1, new e2([], r9)) : null;
  }
  copyInto(e5) {
    e5._joined = this._joined, e5._deleted = this._deleted, e5._objectIdToIndex = this._objectIdToIndex, e5._boundsBuffer = this._boundsBuffer, e5._activeCache = this._activeCache, e5._caches = this._caches, e5._contextTimeZone = this._contextTimeZone;
  }
  _readLegacyGeometryWorldSpace() {
    const e5 = this.readGeometryWorldSpace();
    return rt(e5, this.geometryType, false, false);
  }
  _createGeometryFromServerCentroid() {
    const e5 = this._readServerCentroid();
    if (!e5)
      return null;
    const [t9, r9] = e5.coords;
    return this._createQuantizedExtrudedGeometry(t9, r9);
  }
  _createQuantizedExtrudedGeometry(e5, t9) {
    return "esriGeometryPolyline" === this.geometryType ? this._createQuantizedExtrudedLine(e5, t9) : this._createQuantizedExtrudedQuad(e5, t9);
  }
  _createQuantizedExtrudedQuad(e5, t9) {
    return new e2([5], [e5 - 1, t9, 1, -1, 1, 1, -1, 1, -1, -1]);
  }
  _createQuantizedExtrudedLine(e5, t9) {
    return new e2([2], [e5 - 1, t9 + 1, 1, -1]);
  }
  _removeAtIndex(e5) {
    null == this._deleted && (this._deleted = t6.create(this.getSize())), this._deleted.set(e5);
  }
};

export {
  n8 as n,
  e4 as e,
  r5 as r,
  n11 as n2,
  i2 as i,
  s6 as s,
  n12 as n3,
  t6 as t,
  p3 as p,
  t8 as t2,
  p4 as p2,
  i3 as i2,
  s7 as s2,
  a8 as a,
  M3 as M,
  b2 as b
};
//# sourceMappingURL=chunk-6ZDDHEYR.js.map
