import {
  _,
  i
} from "./chunk-K3DEHPDR.js";
import {
  c
} from "./chunk-BOAEEYBE.js";
import {
  M
} from "./chunk-OCF7OAES.js";
import {
  e
} from "./chunk-JGDJR5EV.js";

// node_modules/@arcgis/core/views/input/ViewEvents.js
var i2 = ["click", "double-click", "immediate-click", "immediate-double-click", "hold", "drag", "key-down", "key-up", "pointer-down", "pointer-move", "pointer-up", "pointer-drag", "mouse-wheel", "pointer-enter", "pointer-leave", "gamepad", "focus", "blur"];
var o = {};
function s(t2) {
  return !!o[t2];
}
function p(t2) {
  for (const e2 of t2)
    if (!s(e2))
      return false;
  return true;
}
i2.forEach((t2) => {
  o[t2] = true;
});
var c2 = class {
  constructor(t2) {
    this._handlers = /* @__PURE__ */ new Map(), this._counter = 0, this._handlerCounts = /* @__PURE__ */ new Map(), this.view = t2, this.inputManager = null;
  }
  connect(t2) {
    t2 && this.disconnect(), this.inputManager = t2, this._handlers.forEach(({ handler: t3, priority: e2 }, n) => {
      var _a;
      return (_a = this.inputManager) == null ? void 0 : _a.installHandlers(n, [t3], e2);
    });
  }
  disconnect() {
    this.inputManager && this._handlers.forEach((t2, e2) => {
      var _a;
      return (_a = this.inputManager) == null ? void 0 : _a.uninstallHandlers(e2);
    }), this.inputManager = null;
  }
  destroy() {
    this.disconnect(), this._handlers.clear(), this.view = null;
  }
  on(e2, n, a, i3) {
    const o2 = Array.isArray(e2) ? e2 : e2.split(",");
    if (!p(o2))
      return o2.some(s) && console.error("Error: registering input events and other events on the view at the same time is not supported."), null;
    let c3, u2;
    Array.isArray(n) ? u2 = n : (c3 = n, u2 = []), "function" == typeof a ? c3 = a : i3 = a, i3 = null != i3 ? i3 : _.DEFAULT;
    const d2 = this._createUniqueGroupName(), m2 = new l(this.view, o2, u2, c3);
    this._handlers.set(d2, { handler: m2, priority: i3 });
    for (const t2 of o2) {
      const e3 = this._handlerCounts.get(t2) || 0;
      this._handlerCounts.set(t2, e3 + 1);
    }
    return this.inputManager && this.inputManager.installHandlers(d2, [m2], i3), e(() => this._removeHandler(d2, o2));
  }
  hasHandler(t2) {
    return !!this._handlerCounts.get(t2);
  }
  _removeHandler(t2, e2) {
    if (this._handlers.has(t2)) {
      this._handlers.delete(t2);
      for (const t3 of e2) {
        const e3 = this._handlerCounts.get(t3);
        void 0 === e3 ? console.error("Trying to remove handler for event that has no handlers registered: ", t3) : 1 === e3 ? this._handlerCounts.delete(t3) : this._handlerCounts.set(t3, e3 - 1);
      }
    }
    this.inputManager && this.inputManager.uninstallHandlers(t2);
  }
  _createUniqueGroupName() {
    return this._counter += 1, `viewEvents_${this._counter}`;
  }
};
var l = class extends i {
  constructor(t2, e2, n, a) {
    super(true), this._latestDragStart = void 0, this.view = t2;
    for (const r of e2)
      switch (r) {
        case "click":
          this.registerIncoming("click", n, (e3) => a(m(t2, e3)));
          break;
        case "double-click":
          this.registerIncoming("double-click", n, (e3) => a(g(t2, e3)));
          break;
        case "immediate-click":
          this.registerIncoming("immediate-click", n, (e3) => a(v(t2, e3)));
          break;
        case "immediate-double-click":
          this.registerIncoming("immediate-double-click", n, (e3) => a(y(t2, e3)));
          break;
        case "hold":
          this.registerIncoming("hold", n, (e3) => a(h(t2, e3)));
          break;
        case "drag":
          this.registerIncoming("drag", n, (t3) => {
            const e3 = this._wrapDrag(t3);
            e3 && a(e3);
          });
          break;
        case "key-down":
          this.registerIncoming("key-down", n, (t3) => a(f(t3)));
          break;
        case "key-up":
          this.registerIncoming("key-up", n, (t3) => a(k(t3)));
          break;
        case "pointer-down":
          this.registerIncoming("pointer-down", n, (t3) => a(I(t3, "pointer-down")));
          break;
        case "pointer-move":
          this.registerIncoming("pointer-move", n, (t3) => a(I(t3, "pointer-move")));
          break;
        case "pointer-up":
          this.registerIncoming("pointer-up", n, (t3) => a(I(t3, "pointer-up")));
          break;
        case "pointer-drag":
          this.registerIncoming("pointer-drag", n, (t3) => a(D(t3)));
          break;
        case "mouse-wheel":
          this.registerIncoming("mouse-wheel", n, (t3) => a(P(t3)));
          break;
        case "pointer-enter":
          this.registerIncoming("pointer-enter", n, (t3) => a(I(t3, "pointer-enter")));
          break;
        case "pointer-leave":
          this.registerIncoming("pointer-leave", n, (t3) => a(I(t3, "pointer-leave")));
          break;
        case "gamepad":
          this.registerIncoming("gamepad", n, (t3) => {
            a(_2(t3));
          });
          break;
        case "focus":
          this.registerIncoming("focus", n, (t3) => {
            a(u(t3));
          });
          break;
        case "blur":
          this.registerIncoming("blur", n, (t3) => {
            a(d(t3));
          });
      }
  }
  _wrapDrag(t2) {
    const n = t2.data, { x: a, y: r } = n.center, { action: i3, pointerType: o2, button: s2 } = n;
    if ("start" === i3 && (this._latestDragStart = n), !this._latestDragStart)
      return;
    const p2 = n.pointer.native, c3 = n.buttons, { cancelable: l2, timestamp: u2 } = t2, d2 = { x: this._latestDragStart.center.x, y: this._latestDragStart.center.y };
    return "end" === i3 && (this._latestDragStart = void 0), { type: "drag", action: i3, x: a, y: r, origin: d2, pointerType: o2, button: s2, buttons: c3, radius: n.radius, angle: M(n.angle), native: p2, timestamp: u2, cancelable: l2, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
};
function u(t2) {
  return { type: "focus", timestamp: t2.timestamp, native: t2.data.native, cancelable: t2.cancelable, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
}
function d(t2) {
  return { type: "blur", timestamp: t2.timestamp, native: t2.data.native, cancelable: t2.cancelable, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
}
function m(t2, e2) {
  const { pointerType: a, button: r, buttons: i3, x: o2, y: s2, native: p2, eventId: c3 } = e2.data, { cancelable: l2, timestamp: u2 } = e2;
  return { type: "click", pointerType: a, button: r, buttons: i3, x: o2, y: s2, native: p2, timestamp: u2, screenPoint: c(o2, s2), mapPoint: b(t2, o2, s2), eventId: c3, cancelable: l2, stopPropagation: () => e2.stopPropagation(), async: (t3) => e2.async(t3), preventDefault: () => e2.preventDefault() };
}
function g(t2, e2) {
  const { pointerType: n, button: a, buttons: r, x: i3, y: o2, native: s2, eventId: p2 } = e2.data, { cancelable: c3, timestamp: l2 } = e2;
  return { type: "double-click", pointerType: n, button: a, buttons: r, x: i3, y: o2, native: s2, timestamp: l2, mapPoint: b(t2, i3, o2), eventId: p2, cancelable: c3, stopPropagation: () => e2.stopPropagation(), async: (t3) => e2.async(t3), preventDefault: () => e2.preventDefault() };
}
function v(t2, e2) {
  const { pointerType: n, button: a, buttons: r, x: i3, y: o2, native: s2, eventId: p2 } = e2.data, c3 = s2.pointerId, { cancelable: l2, timestamp: u2 } = e2;
  return { type: "immediate-click", pointerId: c3, pointerType: n, button: a, buttons: r, x: i3, y: o2, native: s2, timestamp: u2, mapPoint: b(t2, i3, o2), eventId: p2, cancelable: l2, stopPropagation: () => e2.stopPropagation(), async: (t3) => e2.async(t3), preventDefault: () => e2.preventDefault() };
}
function y(t2, e2) {
  const { pointerType: n, button: a, buttons: r, x: i3, y: o2, native: s2, eventId: p2 } = e2.data, c3 = s2.pointerId, { cancelable: l2, timestamp: u2 } = e2;
  return { type: "immediate-double-click", pointerId: c3, pointerType: n, button: a, buttons: r, x: i3, y: o2, native: s2, timestamp: u2, mapPoint: b(t2, i3, o2), eventId: p2, cancelable: l2, stopPropagation: () => e2.stopPropagation(), async: (t3) => e2.async(t3), preventDefault: () => e2.preventDefault() };
}
function h(t2, e2) {
  const { pointerType: n, button: a, buttons: r, x: i3, y: o2, native: s2 } = e2.data, { cancelable: p2, timestamp: c3 } = e2;
  return { type: "hold", pointerType: n, button: a, buttons: r, x: i3, y: o2, native: s2, timestamp: c3, mapPoint: b(t2, i3, o2), cancelable: p2, stopPropagation: () => e2.stopPropagation(), async: (t3) => e2.async(t3), preventDefault: () => e2.preventDefault() };
}
function b(t2, e2, a) {
  return t2.toMap(c(e2, a), { exclude: [] });
}
function f(t2) {
  const { key: e2, repeat: n, native: a } = t2.data, { cancelable: r, timestamp: i3 } = t2;
  return { type: "key-down", key: e2, repeat: n, native: a, timestamp: i3, cancelable: r, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
}
function k(t2) {
  const { key: e2, native: n } = t2.data, { cancelable: a, timestamp: r } = t2;
  return { type: "key-up", key: e2, native: n, timestamp: r, cancelable: a, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
}
function I(t2, e2) {
  const { x: n, y: a, button: r, buttons: i3, native: o2, eventId: s2 } = t2.data, p2 = o2.pointerId, c3 = o2.pointerType, { cancelable: l2, timestamp: u2 } = t2;
  return { type: e2, x: n, y: a, pointerId: p2, pointerType: c3, button: r, buttons: i3, native: o2, timestamp: u2, eventId: s2, cancelable: l2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
}
function D(t2) {
  const { x: e2, y: n, buttons: a, native: r, eventId: i3 } = t2.data.currentEvent, { button: o2 } = t2.data.startEvent, s2 = t2.data.startEvent.native.pointerId, p2 = t2.data.startEvent.native.pointerType, c3 = t2.data.action, l2 = { x: t2.data.startEvent.x, y: t2.data.startEvent.y }, { cancelable: u2, timestamp: d2 } = t2;
  return { type: "pointer-drag", x: e2, y: n, pointerId: s2, pointerType: p2, button: o2, buttons: a, action: c3, origin: l2, native: r, timestamp: d2, eventId: i3, cancelable: u2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
}
function P(t2) {
  const { cancelable: e2, data: n, timestamp: a } = t2, { x: r, y: i3, deltaY: o2, native: s2 } = n;
  return { type: "mouse-wheel", x: r, y: i3, deltaY: o2, native: s2, timestamp: a, cancelable: e2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
}
function _2(t2) {
  const { action: e2, state: n, device: a } = t2.data, { cancelable: r, timestamp: i3 } = t2, { buttons: o2, axes: s2 } = n;
  return { type: "gamepad", device: a, timestamp: i3, action: e2, buttons: o2, axes: s2, cancelable: r, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
}

export {
  i2 as i,
  c2 as c
};
//# sourceMappingURL=chunk-XKMZJHKM.js.map
