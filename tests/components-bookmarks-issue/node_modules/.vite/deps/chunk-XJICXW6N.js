import {
  A,
  C as C2,
  q,
  y as y2,
  z as z4
} from "./chunk-YF5E2R37.js";
import {
  o as o2,
  t as t2
} from "./chunk-R4SGP2EA.js";
import {
  T,
  i as i2
} from "./chunk-IRL6OOVK.js";
import {
  f as f5,
  g,
  u as u2
} from "./chunk-QJRGTKPN.js";
import {
  i,
  n as n5,
  r as r3,
  s
} from "./chunk-LA365FE7.js";
import {
  R
} from "./chunk-WIVZ7SMV.js";
import {
  a as a2
} from "./chunk-O76UVYOO.js";
import {
  I
} from "./chunk-QCMUK3QA.js";
import {
  j as j2,
  n as n4,
  u,
  z as z3
} from "./chunk-HZSGATFT.js";
import {
  e as e5
} from "./chunk-KNMQQRV7.js";
import {
  e as e3,
  o
} from "./chunk-N5GQOIDP.js";
import {
  e as e4
} from "./chunk-NFB6O77E.js";
import {
  B,
  C,
  P,
  c,
  f as f4,
  h
} from "./chunk-HWHMO3CO.js";
import {
  F
} from "./chunk-2ICUS4HL.js";
import {
  n as n3
} from "./chunk-GBF2OQAY.js";
import {
  G,
  O,
  S,
  z as z2
} from "./chunk-JZBR4X6W.js";
import {
  e as e2,
  l,
  n as n2,
  r as r2,
  t
} from "./chunk-OIJCMME5.js";
import {
  f as f3
} from "./chunk-M5ZB5S5C.js";
import {
  f2,
  j,
  k,
  p,
  z
} from "./chunk-UWQ3OYA5.js";
import {
  f
} from "./chunk-SBL4URUW.js";
import {
  r,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/geometry/support/MeshTransform.js
var A2;
var v = A2 = class extends f {
  constructor(t4) {
    super(t4), this.translation = n2(), this.rotationAxis = e2(C2), this.rotationAngle = 0, this.scale = r2(1, 1, 1);
  }
  get rotation() {
    return q(this.rotationAxis, this.rotationAngle);
  }
  set rotation(t4) {
    this.rotationAxis = t(y2(t4)), this.rotationAngle = z4(t4);
  }
  get localMatrix() {
    const t4 = e3();
    return I(M, y2(this.rotation), A(this.rotation)), P(t4, M, this.translation, this.scale), t4;
  }
  get localMatrixInverse() {
    return h(e3(), this.localMatrix);
  }
  applyLocal(t4, o3) {
    return O(o3, t4, this.localMatrix);
  }
  applyLocalInverse(t4, o3) {
    return O(o3, t4, this.localMatrixInverse);
  }
  equals(t4) {
    return this === t4 || null != t4 && B(this.localMatrix, t4.localMatrix);
  }
  clone() {
    const t4 = { translation: t(this.translation), rotationAxis: t(this.rotationAxis), rotationAngle: this.rotationAngle, scale: t(this.scale) };
    return new A2(t4);
  }
};
e([y({ type: [Number], nonNullable: true, json: { write: true } })], v.prototype, "translation", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], v.prototype, "rotationAxis", void 0), e([y({ type: Number, nonNullable: true, json: { write: true } })], v.prototype, "rotationAngle", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], v.prototype, "scale", void 0), e([y()], v.prototype, "rotation", null), e([y()], v.prototype, "localMatrix", null), e([y()], v.prototype, "localMatrixInverse", null), v = A2 = e([a("esri.geometry.support.MeshTransform")], v);
var M = e5();
var d = v;

// node_modules/@arcgis/core/geometry/support/meshUtils/geographicUtils.js
function t3(e6, r4) {
  return e6.isGeographic || e6.isWebMercator && (r4 ?? true);
}
function i3(e6, r4) {
  switch (e6.type) {
    case "georeferenced":
      return r4.isGeographic;
    case "local":
      return r4.isGeographic || r4.isWebMercator;
  }
}
function c2(t4, c3, a3, p2) {
  if (void 0 !== p2) {
    r(n.getLogger(t4), "option: geographic", { replacement: "use mesh vertexSpace and spatial reference to control how operations are performed", version: "4.29", warnOnce: true });
    const i4 = "local" === c3.type;
    if (!g(c3) || p2 === i4) {
      return a3.isGeographic || a3.isWebMercator && p2;
    }
    n.getLogger(t4).warnOnce(`Specifying the 'geographic' parameter (${p2}) for a Mesh vertex space of type "${c3.type}" is not supported. This parameter will be ignored.`);
  }
  return i3(c3, a3);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/projection.js
var d2 = () => n.getLogger("esri.geometry.support.meshUtils.normalProjection");
function j3(r4, e6, t4, o3, n6) {
  return V(o3) ? (v2(L.TO_PCPF, i2.fromTypedArray(r4), T.fromTypedArray(e6), T.fromTypedArray(t4), o3, i2.fromTypedArray(n6)), n6) : (d2().error("Cannot convert spatial reference to PCPF"), n6);
}
function _(r4, e6, t4, o3, n6) {
  return V(o3) ? (v2(L.FROM_PCPF, i2.fromTypedArray(r4), T.fromTypedArray(e6), T.fromTypedArray(t4), o3, i2.fromTypedArray(n6)), n6) : (d2().error("Cannot convert to spatial reference from PCPF"), n6);
}
function O2(r4, e6, t4) {
  return n3(r4, e6, 0, t4, a2(e6), 0, r4.length / 3), t4;
}
function E(r4, e6, t4) {
  return n3(r4, a2(t4), 0, e6, t4, 0, r4.length / 3), e6;
}
function M2(r4, o3, n6) {
  return j2(w, n6), n5(o3, r4, w), z3(w) || s(o3, o3), o3;
}
function R2(r4, o3, n6) {
  if (j2(w, n6), n5(o3, r4, w, 4), z3(w) || s(o3, o3, 4), r4 !== o3)
    for (let e6 = 3; e6 < r4.length; e6 += 4)
      o3[e6] = r4[e6];
  return o3;
}
function h2(r4, e6, t4, o3, n6) {
  if (!V(o3))
    return d2().error("Cannot convert spatial reference to PCPF"), n6;
  v2(L.TO_PCPF, i2.fromTypedArray(r4, 4 * Float32Array.BYTES_PER_ELEMENT), T.fromTypedArray(e6), T.fromTypedArray(t4), o3, i2.fromTypedArray(n6, 4 * Float32Array.BYTES_PER_ELEMENT));
  for (let f6 = 3; f6 < r4.length; f6 += 4)
    n6[f6] = r4[f6];
  return n6;
}
function b(r4, e6, t4, o3, n6) {
  if (!V(o3))
    return d2().error("Cannot convert to spatial reference from PCPF"), n6;
  v2(L.FROM_PCPF, i2.fromTypedArray(r4, 16), T.fromTypedArray(e6), T.fromTypedArray(t4), o3, i2.fromTypedArray(n6, 16));
  for (let f6 = 3; f6 < r4.length; f6 += 4)
    n6[f6] = r4[f6];
  return n6;
}
function v2(r4, e6, t4, f6, i4, m) {
  if (!e6)
    return;
  const l2 = t4.count, u3 = a2(i4);
  if (x(i4))
    for (let c3 = 0; c3 < l2; c3++)
      f6.getVec(c3, U), e6.getVec(c3, S2), R(u3, U, k2, u3), n4(w, k2), r4 === L.FROM_PCPF && u(w, w), S(S2, S2, w), m.setVec(c3, S2);
  else
    for (let s2 = 0; s2 < l2; s2++) {
      f6.getVec(s2, U), e6.getVec(s2, S2), R(u3, U, k2, u3), n4(w, k2);
      const i5 = f3(t4.get(s2, 1));
      let l3 = Math.cos(i5);
      r4 === L.TO_PCPF && (l3 = 1 / l3), w[0] *= l3, w[1] *= l3, w[2] *= l3, w[3] *= l3, w[4] *= l3, w[5] *= l3, r4 === L.FROM_PCPF && u(w, w), S(S2, S2, w), z2(S2, S2), m.setVec(s2, S2);
    }
  return m;
}
function V(r4) {
  return x(r4) || B2(r4);
}
function x(r4) {
  return r4.isWGS84 || k(r4) || f2(r4) || p(r4);
}
function B2(r4) {
  return r4.isWebMercator;
}
var L;
!function(r4) {
  r4[r4.TO_PCPF = 0] = "TO_PCPF", r4[r4.FROM_PCPF = 1] = "FROM_PCPF";
}(L || (L = {}));
var U = n2();
var S2 = n2();
var k2 = e3();
var w = e4();

// node_modules/@arcgis/core/geometry/support/meshUtils/georeference.js
function E2(t4, n6, e6) {
  return t3(n6.spatialReference, e6 == null ? void 0 : e6.geographic) ? I2(t4, n6, false, e6) : H(t4, n6, e6);
}
function O3(t4, n6 = o) {
  const { position: e6, normal: r4, tangent: o3 } = t4;
  return { position: r3(new Float64Array(e6.length), e6, n6), normal: null != r4 ? M2(r4, new Float32Array(r4.length), n6) : null, tangent: null != o3 ? R2(o3, new Float32Array(o3.length), n6) : null };
}
function P2(t4, n6, e6, r4) {
  const { position: o3, normal: i4, tangent: a3 } = t4;
  if (!g(n6))
    return { position: o3, normal: i4, tangent: a3 };
  const l2 = u2(n6, r4);
  return E2(O3(t4, e6 == null ? void 0 : e6.localMatrix), l2, { geographic: "local" === n6.type });
}
function V2(t4, n6, e6) {
  const r4 = f5(n6, e6), o3 = n6.spatialReference, i4 = g(r4);
  if (!i4)
    return { vertexAttributes: E2(t4, n6, e6), vertexSpace: r4, transform: null };
  const { position: a3, normal: l2, tangent: s2 } = t4, c3 = i3(r4, o3);
  switch (r4.type) {
    case "georeferenced":
      return c3 ? { vertexAttributes: I2(t4, n6, i4, e6), vertexSpace: r4, transform: null } : { vertexAttributes: { position: a3, normal: l2, tangent: s2 }, vertexSpace: r4, transform: new d() };
    case "local":
      return { vertexAttributes: { position: a3, normal: l2, tangent: s2 }, vertexSpace: r4, transform: new d() };
  }
}
function W(t4, n6, e6) {
  return t3(n6.spatialReference, e6 == null ? void 0 : e6.geographic) ? Q(t4, n6, e6) : N(t4, n6, e6);
}
function C3(t4, n6, e6, r4, o3) {
  if (!g(n6))
    return W(t4, r4, o3);
  const { spatialReference: i4 } = r4, a3 = P2(t4, n6, e6, i4);
  return r4.equals(u2(n6, i4)) ? N(a3, r4, o3) : W(a3, r4, o3);
}
function G2({ positions: t4, transform: n6, vertexSpace: e6, inSpatialReference: i4, outSpatialReference: a3, outPositions: s2, localMode: f6 }) {
  const y3 = e6.origin ?? l, A3 = null != e6.origin ? (n6 == null ? void 0 : n6.localMatrix) ?? o : o;
  if ("georeferenced" === e6.type) {
    const n7 = s2 ?? t2(t4.length);
    if (C(A3, o) ? o2(n7, t4) : r3(n7, t4, A3), !G(y3, l)) {
      const [t5, e7, r4] = y3;
      for (let o3 = 0; o3 < n7.length; o3 += 3)
        n7[o3] += t5, n7[o3 + 1] += e7, n7[o3 + 2] += r4;
    }
    return n3(n7, i4, 0, n7, a3, 0, n7.length / 3), n7;
  }
  let w2 = i4;
  const R3 = a2(i4);
  w2 = a3.isWebMercator && f6 || !F(i4, R3) ? w2 : R3, R(i4, y3, tt, w2), c(tt, tt, A3);
  const b2 = s2 ?? t2(t4.length);
  return r3(b2, t4, tt), n3(b2, w2, 0, b2, a3, 0, b2.length / 3), b2;
}
function H(t4, n6, e6) {
  const r4 = new Float64Array(t4.position.length), o3 = t4.position, i4 = n6.x, a3 = n6.y, l2 = n6.z ?? 0, s2 = _2(e6 ? e6.unit : null, n6.spatialReference);
  for (let c3 = 0; c3 < o3.length; c3 += 3)
    r4[c3] = o3[c3] * s2 + i4, r4[c3 + 1] = o3[c3 + 1] * s2 + a3, r4[c3 + 2] = o3[c3 + 2] * s2 + l2;
  return { position: r4, normal: t4.normal, tangent: t4.tangent };
}
function I2(t4, n6, e6, r4) {
  const o3 = n6.spatialReference, i4 = X(n6, r4, tt), a3 = new Float64Array(t4.position.length), l2 = J(t4.position, i4, o3, a3), s2 = j2(et, i4), c3 = K(l2, a3, t4.normal, s2, o3), u3 = L2(l2, a3, t4.tangent, s2, o3);
  if (e6) {
    const { x: t5, y: e7, z: r5 } = n6;
    i(l2, l2, [-t5, -e7, -(r5 ?? 0)]);
  }
  return { position: l2, normal: c3, tangent: u3 };
}
function J(t4, n6, e6, r4) {
  r3(r4, t4, n6);
  const o3 = new Float64Array(t4.length);
  return E(r4, o3, e6);
}
function K(t4, n6, e6, r4, o3) {
  if (null == e6)
    return null;
  const i4 = new Float32Array(e6.length);
  return n5(i4, e6, r4), _(i4, t4, n6, o3, i4), i4;
}
function L2(t4, n6, e6, r4, o3) {
  if (null == e6)
    return null;
  const i4 = new Float32Array(e6.length);
  n5(i4, e6, r4, 4);
  for (let a3 = 3; a3 < i4.length; a3 += 4)
    i4[a3] = e6[a3];
  return b(i4, t4, n6, o3, i4), i4;
}
function N(t4, n6, e6) {
  const r4 = new Float64Array(t4.position.length), o3 = t4.position, i4 = n6.x, a3 = n6.y, l2 = n6.z ?? 0, s2 = _2(e6 ? e6.unit : null, n6.spatialReference);
  for (let c3 = 0; c3 < o3.length; c3 += 3)
    r4[c3] = (o3[c3] - i4) / s2, r4[c3 + 1] = (o3[c3 + 1] - a3) / s2, r4[c3 + 2] = (o3[c3 + 2] - l2) / s2;
  return { position: r4, normal: t4.normal, tangent: t4.tangent };
}
function Q(t4, n6, e6) {
  const r4 = n6.spatialReference;
  X(n6, e6, tt);
  const o3 = h(nt, tt), a3 = new Float64Array(t4.position.length), l2 = Y(t4.position, r4, o3, a3), s2 = j2(et, o3);
  return { position: l2, normal: Z(t4.normal, t4.position, a3, r4, s2), tangent: $(t4.tangent, t4.position, a3, r4, s2) };
}
function X(t4, n6, e6) {
  R(t4.spatialReference, [t4.x, t4.y, t4.z ?? 0], e6, a2(t4.spatialReference));
  const r4 = _2(n6 ? n6.unit : null, t4.spatialReference);
  return f4(e6, e6, [r4, r4, r4]), e6;
}
function Y(t4, n6, e6, r4) {
  const o3 = O2(t4, n6, r4), i4 = new Float64Array(o3.length);
  return r3(i4, o3, e6), i4;
}
function Z(t4, n6, e6, r4, o3) {
  if (null == t4)
    return null;
  const i4 = j3(t4, n6, e6, r4, new Float32Array(t4.length));
  return n5(i4, i4, o3), i4;
}
function $(t4, n6, e6, r4, o3) {
  if (null == t4)
    return null;
  const i4 = h2(t4, n6, e6, r4, new Float32Array(t4.length));
  return n5(i4, i4, o3, 4), i4;
}
function _2(e6, r4) {
  if (null == e6)
    return 1;
  const o3 = z(r4);
  return 1 / j(o3, "meters", e6);
}
var tt = e3();
var nt = e3();
var et = e4();

export {
  d,
  c2 as c,
  j3 as j,
  _,
  O2 as O,
  E,
  M2 as M,
  R2 as R,
  h2 as h,
  b,
  E2,
  O3 as O2,
  P2 as P,
  V2 as V,
  W,
  C3 as C,
  G2 as G,
  I2 as I,
  Q,
  _2
};
//# sourceMappingURL=chunk-XJICXW6N.js.map
