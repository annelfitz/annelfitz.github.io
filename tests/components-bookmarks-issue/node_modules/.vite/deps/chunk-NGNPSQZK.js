import {
  t as t2
} from "./chunk-E5PVY3UF.js";
import {
  t
} from "./chunk-2C26DRKK.js";
import {
  e
} from "./chunk-M4RFJU4F.js";
import {
  d2 as d,
  pe
} from "./chunk-X7VSXJWW.js";
import {
  C
} from "./chunk-UWQ3OYA5.js";
import {
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/layers/graphics/sources/geojson/geojson.js
var c = { LineString: "esriGeometryPolyline", MultiLineString: "esriGeometryPolyline", MultiPoint: "esriGeometryMultipoint", Point: "esriGeometryPoint", Polygon: "esriGeometryPolygon", MultiPolygon: "esriGeometryPolygon" };
function u(e2) {
  return c[e2];
}
function* l(e2) {
  switch (e2.type) {
    case "Feature":
      yield e2;
      break;
    case "FeatureCollection":
      for (const t3 of e2.features)
        t3 && (yield t3);
  }
}
function* f(e2) {
  if (e2)
    switch (e2.type) {
      case "Point":
        yield e2.coordinates;
        break;
      case "LineString":
      case "MultiPoint":
        yield* e2.coordinates;
        break;
      case "MultiLineString":
      case "Polygon":
        for (const t3 of e2.coordinates)
          yield* t3;
        break;
      case "MultiPolygon":
        for (const t3 of e2.coordinates)
          for (const e3 of t3)
            yield* e3;
    }
}
function* p(e2, t3 = {}) {
  const { geometryType: n, objectIdField: i } = t3;
  for (const s2 of e2) {
    const { geometry: e3, properties: c2, id: l2 } = s2;
    if (e3 && u(e3.type) !== n)
      continue;
    const f2 = c2 || {};
    let p2;
    i && (p2 = f2[i], null == l2 || p2 || (f2[i] = p2 = l2));
    const a2 = new t(e3 ? h(new e(), e3, t3) : null, f2, null, p2 ?? void 0);
    yield a2;
  }
}
function a(e2) {
  for (const t3 of e2)
    if (t3.length > 2)
      return true;
  return false;
}
function y(e2) {
  return !g(e2);
}
function d2(e2) {
  return g(e2);
}
function g(e2) {
  let t3 = 0;
  for (let n = 0; n < e2.length; n++) {
    const o = e2[n], r = e2[(n + 1) % e2.length];
    t3 += o[0] * r[1] - r[0] * o[1];
  }
  return t3 <= 0;
}
function m(e2) {
  const t3 = e2[0], n = e2[e2.length - 1];
  return t3[0] === n[0] && t3[1] === n[1] && t3[2] === n[2] || e2.push(t3), e2;
}
function h(e2, t3, n) {
  switch (t3.type) {
    case "LineString":
      return w(e2, t3, n);
    case "MultiLineString":
      return P(e2, t3, n);
    case "MultiPoint":
      return j(e2, t3, n);
    case "MultiPolygon":
      return b(e2, t3, n);
    case "Point":
      return S(e2, t3, n);
    case "Polygon":
      return F(e2, t3, n);
  }
}
function w(e2, t3, n) {
  return M(e2, t3.coordinates, n), e2;
}
function P(e2, t3, n) {
  for (const o of t3.coordinates)
    M(e2, o, n);
  return e2;
}
function j(e2, t3, n) {
  return M(e2, t3.coordinates, n), e2;
}
function b(e2, t3, n) {
  for (const o of t3.coordinates) {
    G(e2, o[0], n);
    for (let t4 = 1; t4 < o.length; t4++)
      k(e2, o[t4], n);
  }
  return e2;
}
function S(e2, t3, n) {
  return O(e2, t3.coordinates, n), e2;
}
function F(e2, t3, n) {
  const o = t3.coordinates;
  G(e2, o[0], n);
  for (let r = 1; r < o.length; r++)
    k(e2, o[r], n);
  return e2;
}
function G(e2, t3, n) {
  const o = m(t3);
  y(o) ? T(e2, o, n) : M(e2, o, n);
}
function k(e2, t3, n) {
  const o = m(t3);
  d2(o) ? T(e2, o, n) : M(e2, o, n);
}
function M(e2, t3, n) {
  for (const o of t3)
    O(e2, o, n);
  e2.lengths.push(t3.length);
}
function T(e2, t3, n) {
  for (let o = t3.length - 1; o >= 0; o--)
    O(e2, t3[o], n);
  e2.lengths.push(t3.length);
}
function O(e2, t3, n) {
  const [o, r, i] = t3;
  e2.coords.push(o, r), n.hasZ && e2.coords.push(i || 0);
}
function L(t3) {
  switch (typeof t3) {
    case "string":
      return t2(t3) ? "esriFieldTypeDate" : "esriFieldTypeString";
    case "number":
      return "esriFieldTypeDouble";
    default:
      return "unknown";
  }
}
function E(e2, o = 4326) {
  if (!e2)
    throw new s("geojson-layer:empty", "GeoJSON data is empty");
  if ("Feature" !== e2.type && "FeatureCollection" !== e2.type)
    throw new s("geojson-layer:unsupported-geojson-object", "missing or not supported GeoJSON object type", { data: e2 });
  const { crs: r } = e2;
  if (!r)
    return;
  const i = "string" == typeof r ? r : "name" === r.type ? r.properties.name : "EPSG" === r.type ? r.properties.code : null, s2 = C({ wkid: o }) ? new RegExp(".*(CRS84H?|4326)$", "i") : new RegExp(`.*(${o})$`, "i");
  if (!i || !s2.test(i))
    throw new s("geojson:unsupported-crs", "unsupported GeoJSON 'crs' member", { crs: r });
}
function I(e2, t3 = {}) {
  const n = [], o = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
  let c2, p2 = false, y2 = null, d3 = false, { geometryType: g2 = null } = t3, m2 = false;
  for (const s2 of l(e2)) {
    const { geometry: e3, properties: t4, id: l2 } = s2;
    if (!e3 || (g2 || (g2 = u(e3.type)), u(e3.type) === g2)) {
      if (!p2) {
        p2 = a(f(e3));
      }
      if (d3 || (d3 = null != l2, d3 && (c2 = typeof l2, t4 && (y2 = Object.keys(t4).filter((e4) => t4[e4] === l2)))), t4 && y2 && d3 && null != l2 && (y2.length > 1 ? y2 = y2.filter((e4) => t4[e4] === l2) : 1 === y2.length && (y2 = t4[y2[0]] === l2 ? y2 : [])), !m2 && t4) {
        let e4 = true;
        for (const s3 in t4) {
          if (o.has(s3))
            continue;
          const c3 = t4[s3];
          if (null == c3) {
            e4 = false, r.add(s3);
            continue;
          }
          const u2 = L(c3);
          if ("unknown" === u2) {
            r.add(s3);
            continue;
          }
          r.delete(s3), o.add(s3);
          const l3 = d(s3);
          l3 && n.push({ name: l3, alias: s3, type: u2 });
        }
        m2 = e4;
      }
    }
  }
  const h2 = d(1 === (y2 == null ? void 0 : y2.length) && y2[0] || null) ?? void 0;
  if (h2) {
    for (const i of n)
      if (i.name === h2 && pe(i)) {
        i.type = "esriFieldTypeOID";
        break;
      }
  }
  return { fields: n, geometryType: g2, hasZ: p2, objectIdFieldName: h2, objectIdFieldType: c2, unknownFields: Array.from(r) };
}
function N(e2, t3) {
  return Array.from(p(l(e2), t3));
}

export {
  u,
  E,
  I,
  N
};
//# sourceMappingURL=chunk-NGNPSQZK.js.map
