import {
  w
} from "./chunk-K3L4UH6D.js";
import {
  t as t4
} from "./chunk-DVI5RM3W.js";
import {
  e as e2
} from "./chunk-RDPH36VD.js";
import {
  a,
  c,
  e,
  i,
  n,
  o,
  s as s2,
  t as t3,
  u
} from "./chunk-JNR6JC57.js";
import {
  s as s3
} from "./chunk-LBXFRGMS.js";
import {
  t as t2
} from "./chunk-4WS4UHOQ.js";
import {
  t
} from "./chunk-LT6KUDSQ.js";
import "./chunk-LRW6CHFI.js";
import {
  p
} from "./chunk-VTH4DAHQ.js";
import {
  a as a2
} from "./chunk-GWC53NTZ.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import {
  Q
} from "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import "./chunk-NDIXNREV.js";
import "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/portal/support/layersLoader.js
async function b(e3, t5) {
  const r = e3.instance.portalItem;
  if (r == null ? void 0 : r.id)
    return await r.load(t5), g(e3), e3.validateItem && e3.validateItem(r), L(e3, t5);
}
function g(t5) {
  const r = t5.instance.portalItem;
  if (!(r == null ? void 0 : r.type) || !t5.supportedTypes.includes(r.type))
    throw new s("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}'", { type: r == null ? void 0 : r.type, expectedType: t5.supportedTypes.join(", ") });
}
async function L(e3, t5) {
  const r = e3.instance, o2 = r.portalItem;
  if (!o2)
    return;
  const { url: n2, title: s4 } = o2, l = e2(o2, "portal-item");
  if ("group" === r.type)
    return v(r, l, e3);
  n2 && "media" !== r.type && r.read({ url: n2 }, l);
  const c2 = new e(), u2 = await F(e3, c2, t5);
  return u2 && r.read(u2, l), r.resourceReferences = { portalItem: o2, paths: l.readResourcePaths ?? [] }, "subtype-group" !== r.type && r.read({ title: s4 }, l), t4(r, l);
}
async function v(t5, r, a3) {
  const o2 = t5.portalItem;
  if (!t5.sourceIsPortalItem)
    return;
  const { title: n2, type: s4 } = o2;
  if ("Group Layer" === s4) {
    if (!s3(o2, "Map"))
      throw new s("portal:invalid-layer-item-typekeyword", "'Group Layer' item without 'Map' type keyword is not supported");
    return j(t5);
  }
  return t5.read({ title: n2 }, r), S(t5, a3);
}
async function j(e3) {
  const t5 = e3.portalItem, r = await t5.fetchData("json");
  if (!r)
    return;
  const a3 = e2(t5, "web-map");
  e3.read(r, a3), await w(e3, r, { context: a3 }), e3.resourceReferences = { portalItem: t5, paths: a3.readResourcePaths ?? [] };
}
async function S(t5, r) {
  var _a;
  let o2;
  const { portalItem: n2 } = t5;
  if (!n2)
    return;
  const s4 = n2.type, i2 = r.layerModuleTypeMap;
  switch (s4) {
    case "Feature Service":
    case "Feature Collection":
      o2 = i2.FeatureLayer;
      break;
    case "Stream Service":
      o2 = i2.StreamLayer;
      break;
    case "Scene Service":
      o2 = i2.SceneLayer;
      break;
    default:
      throw new s("portal:unsupported-item-type-as-group", `The item type '${s4}' is not supported as a 'IGroupLayer'`);
  }
  const y = new e();
  let [f, m] = await Promise.all([o2(), F(r, y)]), d = () => f;
  if ("Feature Service" === s4) {
    const e3 = (_a = s2(m)) == null ? void 0 : _a.customParameters;
    m = n2.url ? await a(m, n2.url, y) : {}, d = await R(m, i2) || d;
    const r2 = await E(n2.url, { customParameters: e3, loadContext: y });
    return await P(t5, d, m, r2);
  }
  return "Scene Service" === s4 && n2.url && (m = await o(n2, m, y)), u(m) > 0 ? await P(t5, d, m) : await T(t5, d);
}
async function T(e3, t5) {
  var _a, _b;
  const { portalItem: r } = e3;
  if (!(r == null ? void 0 : r.url))
    return;
  const a3 = await t(r.url);
  a3 && P(e3, t5, { layers: (_a = a3.layers) == null ? void 0 : _a.map(t3), tables: (_b = a3.tables) == null ? void 0 : _b.map(t3) });
}
async function P(e3, t5, r, a3) {
  var _a;
  let o2 = r.layers || [];
  const s4 = r.tables || [];
  if ("Feature Collection" === ((_a = e3.portalItem) == null ? void 0 : _a.type) ? (o2.forEach((e4, t6) => {
    var _a2;
    e4.id = t6, "Table" === ((_a2 = e4 == null ? void 0 : e4.layerDefinition) == null ? void 0 : _a2.type) && s4.push(e4);
  }), o2 = o2.filter((e4) => {
    var _a2;
    return "Table" !== ((_a2 = e4 == null ? void 0 : e4.layerDefinition) == null ? void 0 : _a2.type);
  })) : (o2.reverse(), s4.reverse()), o2.forEach((o3) => {
    const n2 = a3 == null ? void 0 : a3(o3);
    if (n2 || !a3) {
      const a4 = M(e3, t5(o3), r, o3, n2);
      e3.add(a4);
    }
  }), s4.length) {
    const t6 = await a2.FeatureLayer();
    s4.forEach((o3) => {
      const n2 = a3 == null ? void 0 : a3(o3);
      if (n2 || !a3) {
        const a4 = M(e3, t6, r, o3, n2);
        e3.tables.add(a4);
      }
    });
  }
}
function M(e3, t5, r, a3, o2) {
  const n2 = e3.portalItem, i2 = { portalItem: n2.clone(), layerId: a3.id };
  null != a3.url && (i2.url = a3.url);
  const l = new t5(i2);
  if ("sourceJSON" in l && (l.sourceJSON = o2), "subtype-group" !== l.type && "catalog" !== l.type && (l.sublayerTitleMode = "service-name"), "Feature Collection" === n2.type) {
    const e4 = { origin: "portal-item", portal: n2.portal || Q.getDefault() };
    l.read(a3, e4);
    const t6 = r.showLegend;
    null != t6 && l.read({ showLegend: t6 }, e4);
  }
  return l;
}
async function F(e3, t5, r) {
  if (false === e3.supportsData)
    return;
  const a3 = e3.instance, o2 = a3.portalItem;
  if (!o2)
    return;
  let n2 = null;
  try {
    n2 = await o2.fetchData("json", r);
  } catch (s4) {
  }
  if (D(a3)) {
    let e4 = null;
    const r2 = await x(o2, n2, t5);
    if (((n2 == null ? void 0 : n2.layers) || (n2 == null ? void 0 : n2.tables)) && r2 > 0) {
      if (null == a3.layerId) {
        const e5 = c(a3.type), t6 = e5 ? n(n2, e5)[0] : s2(n2);
        t6 && (a3.layerId = t6.id);
      }
      e4 = C(n2, a3), e4 && null != n2.showLegend && (e4.showLegend = n2.showLegend);
    }
    return r2 > 1 && "sublayerTitleMode" in a3 && "service-name" !== a3.sublayerTitleMode && (a3.sublayerTitleMode = "item-title-and-service-name"), e4;
  }
  return n2;
}
async function x(e3, r, a3) {
  var _a, _b, _c, _d, _e;
  if ((r == null ? void 0 : r.layers) && (r == null ? void 0 : r.tables))
    return u(r);
  const o2 = p(e3.url);
  if (!o2)
    return 1;
  const n2 = await a3.fetchServiceMetadata(o2.url.path, { customParameters: (_a = s2(r)) == null ? void 0 : _a.customParameters }).catch(() => null);
  return (((_b = r == null ? void 0 : r.layers) == null ? void 0 : _b.length) ?? ((_c = n2 == null ? void 0 : n2.layers) == null ? void 0 : _c.length) ?? 0) + (((_d = r == null ? void 0 : r.tables) == null ? void 0 : _d.length) ?? ((_e = n2 == null ? void 0 : n2.tables) == null ? void 0 : _e.length) ?? 0);
}
function C(e3, t5) {
  var _a, _b;
  const { layerId: r } = t5, a3 = ((_a = e3.layers) == null ? void 0 : _a.find((e4) => e4.id === r)) || ((_b = e3.tables) == null ? void 0 : _b.find((e4) => e4.id === r));
  return a3 && k(a3, t5) ? a3 : null;
}
function D(e3) {
  return "stream" !== e3.type && "layerId" in e3;
}
function k(e3, t5) {
  const r = "layerType" in e3 && e3.layerType, { type: a3 } = t5;
  return !("feature" === a3 && r || "catalog" === a3 && !r || "oriented-imagery" === a3 && !r || "subtype-group" === a3 && !r);
}
async function E(e3, t5) {
  const { layersJSON: a3 } = await t2(e3, t5);
  if (!a3)
    return null;
  const o2 = [...a3.layers, ...a3.tables];
  return (e4) => o2.find((t6) => t6.id === e4.id);
}
async function R(e3, t5) {
  const { layers: r } = e3;
  if (!(r == null ? void 0 : r.length))
    return;
  const a3 = /* @__PURE__ */ new Set(), o2 = [];
  for (const { layerType: i2 } of r) {
    const e4 = i2 ?? "FeatureLayer";
    if (a3.has(e4))
      continue;
    a3.add(e4);
    const r2 = t5[i(e4)];
    o2.push(r2());
  }
  const n2 = await Promise.all(o2), s4 = /* @__PURE__ */ new Map();
  return Array.from(a3).forEach((e4, t6) => {
    s4.set(e4, n2[t6]);
  }), ({ layerType: e4 }) => {
    const t6 = e4 ?? "FeatureLayer";
    return s4.get(t6);
  };
}
export {
  b as load
};
//# sourceMappingURL=layersLoader-AWL4ECXO.js.map
