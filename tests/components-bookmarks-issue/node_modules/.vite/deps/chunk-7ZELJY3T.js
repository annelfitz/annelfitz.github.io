import {
  p
} from "./chunk-BSG4F4MT.js";
import {
  A,
  C,
  d as d2,
  w
} from "./chunk-Z4Y53NDM.js";
import {
  d
} from "./chunk-BVQWKK2V.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  b,
  c2 as c,
  s
} from "./chunk-JGDJR5EV.js";
import {
  e as e2
} from "./chunk-QHK5ZYFW.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/widgets/support/InteractiveAnalysisViewModel.js
var u;
!function(s2) {
  s2[s2.PENDING = 0] = "PENDING", s2[s2.WAIT_FOR_VIEW_READY = 1] = "WAIT_FOR_VIEW_READY", s2[s2.RUNNING = 2] = "RUNNING";
}(u || (u = {}));
var _ = class extends p {
  constructor(s2 = {}) {
    super(s2), this.analysisView = null, this._reconnectViewTask = null, this._parentChangeFromReconnect = false, this._startUserOperation = null;
    const t = s2 == null ? void 0 : s2.analysis;
    null != t ? this.analysis = t : (this._set("analysis", this.constructAnalysis()), this._set("isAnalysisOwner", true));
  }
  normalizeCtorArgs(s2) {
    const { analysis: t, ...i } = s2;
    return i;
  }
  initialize() {
    this.addHandles([d2(() => {
      var _a;
      return (_a = this.analysis) == null ? void 0 : _a.parent;
    }, (s2) => {
      this._parentChangeFromReconnect || s2 === this.view || this._set("isAnalysisOwner", false);
      const t = !this._parentChangeFromReconnect;
      this._parentChangeFromReconnect = false, t && this._scheduleViewReconnect();
    }, C), d2(() => ({ view: this.view, ready: null != this.view && this.view.ready, supported: this.supported }), ({ view: s2 }, t) => {
      const i = t == null ? void 0 : t.view;
      s2 !== i && (this._startUserOperation = e2(this._startUserOperation), this._disconnectFromView(i)), this._scheduleViewReconnect();
    }, A), d2(() => this.analysis.isEditable, (s2, t) => {
      null != this.analysisView && (s2 && !t && null == this.tool ? this.createTool() : s2 || !t || null == this.tool || this.tool.active || this.removeTool());
    })]);
  }
  destroy() {
    this._reconnectViewTask = e2(this._reconnectViewTask), this._startUserOperation = e2(this._startUserOperation), null != this.analysisView && (this.analysisView.visible = void 0), this._disconnectFromView(this.view), null != this.analysis && this.isAnalysisOwner && (this.analysis.destroy(), this._set("analysis", null));
  }
  set analysis(s2) {
    s2 !== this._get("analysis") && (this._startUserOperation = e2(this._startUserOperation), this._disconnectFromView(this.view), this._setExternalAnalysis(s2), this._scheduleViewReconnect());
  }
  get ready() {
    return null != this.analysisView && !this.connectingToView;
  }
  get connectingToView() {
    return null != this._reconnectViewTask;
  }
  get isAnalysisOwner() {
    return this._get("isAnalysisOwner");
  }
  set visible(s2) {
    this._set("visible", s2), null != this.analysisView && (this.analysisView.visible = s2);
  }
  async start() {
    if (!this.visible)
      return void n.getLogger(this).warn("Cannot start analysis when not visible");
    this.clear();
    const s2 = { task: null, abort: null, state: u.PENDING }, e3 = d(async (t) => {
      s2.state = u.WAIT_FOR_VIEW_READY, await w(() => this.ready, t), s2.state = u.RUNNING, this.createTool({ interactive: true });
    });
    return s2.task = e3, s2.abort = () => e3.abort(), this._startUserOperation = s2, e3.promise;
  }
  clear() {
    this._startUserOperation = e2(this._startUserOperation), this.removeTool(), this.analysis.clear();
  }
  onConnectToAnalysisView(s2) {
  }
  onDisconnectFromAnalysisView() {
  }
  _scheduleViewReconnect() {
    this._reconnectViewTask = e2(this._reconnectViewTask);
    const s2 = d(async (t) => {
      try {
        await this._reconnectView(t);
      } catch (e3) {
        if (s(t), !b(e3))
          return void n.getLogger(this).warn("Failed to use analysis in view model", e3);
        throw e3;
      } finally {
        s2 === this._reconnectViewTask && (this._reconnectViewTask = null);
      }
    });
    this._reconnectViewTask = s2;
  }
  async _reconnectView(s2) {
    const { view: t } = this, i = null != t && t.ready && this.supported, e3 = this.analysis;
    if (this._startUserOperation = V(this._startUserOperation), this._disconnectFromView(t), i && null != t && null != e3) {
      if (this.isAnalysisOwner) {
        if (null != e3.parent)
          return void this.logError("expected owned analysis to have null parent when connecting to view");
        this._parentChangeFromReconnect = true, t.analyses.add(e3);
      }
      this.analysisView = await t.whenAnalysisView(e3), c(s2) ? this._startUserOperation = V(this._startUserOperation) : (this.analysisView.visible = this.visible, this.onConnectToAnalysisView(this.analysisView), this.createTool());
    }
  }
  _disconnectFromView(s2) {
    this.removeTool(), null != s2 && this.isAnalysisOwner && (this._parentChangeFromReconnect = true, s2.analyses.remove(this.analysis), this.analysis.clear()), this.analysisView = null, this.onDisconnectFromAnalysisView();
  }
  _setExternalAnalysis(s2) {
    null == this.analysisView || this.isAnalysisOwner || (this.analysisView.visible = true), this.analysisView = null, this._set("isAnalysisOwner", false), this._set("analysis", s2), this._parentChangeFromReconnect = false;
  }
  get testInfo() {
    return { analysisView: this.analysisView };
  }
};
function V(s2) {
  return null != s2 && s2.state >= u.RUNNING ? (s2.abort(), null) : s2;
}
e([y({ nonNullable: true })], _.prototype, "analysis", null), e([y()], _.prototype, "analysisView", void 0), e([y()], _.prototype, "ready", null), e([y()], _.prototype, "connectingToView", null), e([y({ readOnly: true })], _.prototype, "isAnalysisOwner", null), e([y({ type: Boolean, value: true })], _.prototype, "visible", null), e([y()], _.prototype, "_reconnectViewTask", void 0), _ = e([a("esri.widgets.support.InteractiveAnalysisViewModel")], _);

export {
  _
};
//# sourceMappingURL=chunk-7ZELJY3T.js.map
