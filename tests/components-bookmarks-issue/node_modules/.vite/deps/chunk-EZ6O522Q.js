import {
  P
} from "./chunk-LHVWC4RW.js";
import {
  m
} from "./chunk-ZQTY6DQZ.js";
import {
  d
} from "./chunk-XIWETS2Q.js";
import {
  f
} from "./chunk-7QHIE4SQ.js";
import {
  e as e5
} from "./chunk-6MGK5WBT.js";
import {
  o as o3
} from "./chunk-HSOVRETF.js";
import {
  i as i2
} from "./chunk-CPZW2LMK.js";
import {
  e as e4
} from "./chunk-QR7J3YDY.js";
import {
  s
} from "./chunk-GO2OGJDG.js";
import {
  o as o4
} from "./chunk-UYMREM3D.js";
import {
  e as e3
} from "./chunk-HFJMEXIX.js";
import {
  e as e2
} from "./chunk-VYSGSKHB.js";
import {
  a
} from "./chunk-UAFQMHYI.js";
import {
  o as o2
} from "./chunk-IDPLBNJX.js";
import {
  o
} from "./chunk-P4MNTMCZ.js";
import {
  e
} from "./chunk-N5GQOIDP.js";
import {
  h,
  i
} from "./chunk-HWHMO3CO.js";
import {
  O,
  z
} from "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";

// node_modules/@arcgis/core/chunks/ShadowHighlight.glsl.js
var b = 0.99999;
var D = 0.025;
function F(o5) {
  const a2 = new o4();
  a2.include(m, o5), a2.include(f), a2.include(o3);
  const F2 = a2.fragment;
  return F2.include(a), F2.include(i2), F2.uniforms.add(new s("defaultDepthTex", (e6, i3) => i3.shadowMap.getSnapshot(P.ExcludeHighlight)), new s("highlightDepthTex", (e6, i3) => i3.shadowMap.getSnapshot(P.Highlight)), new s("depthMap", (e6, i3) => {
    var _a;
    return (_a = i3.linearDepth) == null ? void 0 : _a.getTexture();
  }), new s("highlightTexture", (e6) => e6.highlight), new e5("uColor", (e6) => e6.shadowColor), new e4("nearFar", (e6, i3) => i3.camera.nearFar), new o2("opacity", (e6) => e6.shadowOpacity), new o2("occludedOpacity", (e6) => e6.occludedShadowOpacity), new o2("terminationFactor", (e6) => e6.opacityElevation * e6.dayNightTerminator), new e2("lightingMainDirectionView", (e6, i3) => z(y, O(y, i3.lighting.mainLight.direction, i3.camera.viewInverseTransposeMatrix))), new e3("inverseViewMatrix", (o6, t) => h(M, i(M, t.camera.viewMatrix, t.camera.center)))), F2.constants.add("unoccludedHighlightFlag", "vec4", d), F2.code.add(o`
    vec3 normalFromDepth(vec3 pixelPos, vec2 fragCoord, ivec2 iuv) {
      float leftPixelDepth = linearDepthFromRGBA(texelFetch(depthMap, iuv + ivec2(-1, 0), 0), nearFar);
      float rightPixelDepth = linearDepthFromRGBA(texelFetch(depthMap, iuv + ivec2(1, 0), 0), nearFar);
      float bottomPixelDepth = linearDepthFromRGBA(texelFetch(depthMap, iuv + ivec2(0, -1), 0), nearFar);
      float topPixelDepth = linearDepthFromRGBA(texelFetch(depthMap, iuv + ivec2(0, 1), 0), nearFar);

      bool pickLeft = abs(pixelPos.z - leftPixelDepth) < abs(pixelPos.z - rightPixelDepth);
      bool pickBottom = abs(pixelPos.z - bottomPixelDepth) < abs(pixelPos.z - topPixelDepth);

      vec3 fragCoordHorizontal = pickLeft
                                  ? vec3(fragCoord + vec2(-1.0, 0.0), leftPixelDepth)
                                  : vec3(fragCoord + vec2(1.0, 0.0), rightPixelDepth);
      vec3 fragCoordVertical = pickBottom
                                  ? vec3(fragCoord + vec2(0.0, -1.0), bottomPixelDepth)
                                  : vec3(fragCoord + vec2(0.0, 1.0), topPixelDepth);

      vec3 verticalPixelPos = reconstructPosition(fragCoordHorizontal.xy, fragCoordHorizontal.z);
      vec3 horizontalPixelPos = reconstructPosition(fragCoordVertical.xy, fragCoordVertical.z);

      vec3 normal = normalize(cross(verticalPixelPos - pixelPos, horizontalPixelPos - pixelPos));
      // Flip normal depending on triangle winding order for consistency
      return pickLeft == pickBottom ? normal : -normal;
    }

    void main(void) {
      vec4 highlightInfo = texture(highlightTexture, uv);
      float visiblyHighlighted = (1.0 - clamp(distance(unoccludedHighlightFlag, highlightInfo), 0.0, 1.0)) * highlightInfo.a;
      if (visiblyHighlighted > ${o.float(b)}) {
        discard;
      }

      ivec2 iuv = ivec2(uv * vec2(textureSize(depthMap, 0)));
      float depth = rgba2float(texelFetch(depthMap, iuv, 0));
      // 0.0 is the clear value of depthMap, which means nothing has been drawn there and we should discard
      if (depth == 0.0) {
        discard;
      }

      float currentPixelDepth = linearDepthFromFloat(depth, nearFar);
      if (-currentPixelDepth>nearFar.y || -currentPixelDepth<nearFar.x) {
        discard;
      }

      vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);
      vec4 worldSpacePos = inverseViewMatrix * currentPixelPos;

      mat4 shadowMatrix;
      float linearDepth = -currentPixelDepth;
      int i = chooseCascade(linearDepth, shadowMatrix);
      if (i >= numCascades) {
        discard;
      }

      vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);

      // vertex completely outside? -> no shadow
      if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
        discard;
      }

      ivec2 texSize = textureSize(highlightDepthTex, 0);
      ivec2 uvShadow = ivec2(cascadeCoordinates(i, texSize, lvpos) * vec2(texSize));

      float depthHighlight = readShadowMapDepth(uvShadow, highlightDepthTex);
      bool shadowHighlight = depthHighlight < lvpos.z;
      if (!shadowHighlight) {
        discard;
      }

      float depthDefault = readShadowMapDepth(uvShadow, defaultDepthTex);
      bool shadowDefault = depthDefault < lvpos.z;

      vec3 normal = normalFromDepth(currentPixelPos.xyz, gl_FragCoord.xy, iuv);
      bool shaded = dot(normal, lightingMainDirectionView) < ${o.float(D)};

      float fragOpacity = (shadowDefault || shaded) ? occludedOpacity : opacity;
      fragColor = vec4(uColor.rgb, uColor.a * fragOpacity * terminationFactor);
    }
  `), a2;
}
var M = e();
var y = n();
var S = Object.freeze(Object.defineProperty({ __proto__: null, build: F }, Symbol.toStringTag, { value: "Module" }));

export {
  F,
  S
};
//# sourceMappingURL=chunk-EZ6O522Q.js.map
