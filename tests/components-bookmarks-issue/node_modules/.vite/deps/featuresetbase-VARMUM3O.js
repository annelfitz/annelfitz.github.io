import {
  l
} from "./chunk-TXFZLIFM.js";
import {
  l as l2
} from "./chunk-OPQLV3CH.js";
import {
  t as t2
} from "./chunk-6P4ZZRYH.js";
import {
  A,
  B as B2,
  F,
  I,
  L,
  a as a2,
  a2 as a3,
  b,
  c,
  e,
  e2,
  f,
  g,
  j,
  k,
  k2,
  q
} from "./chunk-C6TZTCBW.js";
import {
  D as D2,
  u
} from "./chunk-SMJBRBFJ.js";
import "./chunk-ZJQ6M76T.js";
import {
  D
} from "./chunk-MVNKR6NA.js";
import {
  N
} from "./chunk-PMK5VFGV.js";
import {
  B,
  G2 as G,
  H,
  He,
  Ne,
  Q,
  Re,
  U,
  V,
  X,
  Y,
  _,
  a,
  ae,
  ee,
  ge,
  he,
  me,
  r,
  te,
  v2 as v,
  y as y2
} from "./chunk-YGY4RCQM.js";
import {
  t
} from "./chunk-GEMKWQ3Q.js";
import "./chunk-J7CIAQLK.js";
import "./chunk-RDZ6JJOO.js";
import "./chunk-QD3CP3I4.js";
import "./chunk-5P57RIA4.js";
import "./chunk-AC67ONZX.js";
import "./chunk-ZOUC7PLM.js";
import "./chunk-F2EHRKUX.js";
import "./chunk-2636VFVY.js";
import "./chunk-252ISA6Z.js";
import "./chunk-TLTAGTBA.js";
import "./chunk-2QPP5AGU.js";
import "./chunk-2C26DRKK.js";
import "./chunk-M4RFJU4F.js";
import "./chunk-MGFAIE2L.js";
import "./chunk-ONKWNPIN.js";
import {
  We
} from "./chunk-EWD7I5UU.js";
import "./chunk-4UEJR4VO.js";
import "./chunk-BUEJAM23.js";
import "./chunk-LQR76D5M.js";
import "./chunk-2CWW7O7M.js";
import "./chunk-Q5NCQLSM.js";
import "./chunk-FLBJ53KN.js";
import "./chunk-YH2IYJYF.js";
import "./chunk-GGHKH3LP.js";
import "./chunk-VS6AHHIY.js";
import "./chunk-DIT542IP.js";
import "./chunk-HFYOMP47.js";
import "./chunk-TOKUWZQG.js";
import "./chunk-JNGJWHJD.js";
import "./chunk-QMPD4WXY.js";
import "./chunk-OF4YIONV.js";
import "./chunk-YBPOKK6D.js";
import "./chunk-AHEDDTVZ.js";
import "./chunk-Z4ALW6LX.js";
import "./chunk-H4O73SDK.js";
import "./chunk-UVXSAP7V.js";
import "./chunk-IZ3VJLQ6.js";
import "./chunk-DRC4XSYG.js";
import "./chunk-IHQNQQJC.js";
import "./chunk-4IKPTZ53.js";
import "./chunk-DXMBDX2I.js";
import "./chunk-TUVEYM7U.js";
import "./chunk-5S637BGW.js";
import "./chunk-BFOJPIF7.js";
import "./chunk-7UUNSIMA.js";
import "./chunk-GMRQGGML.js";
import "./chunk-BYK4ZOU2.js";
import "./chunk-OHYLFFUW.js";
import "./chunk-XW3FDKYP.js";
import "./chunk-Y7RXGLGH.js";
import "./chunk-3JC3OUNW.js";
import "./chunk-RO3CTAP7.js";
import "./chunk-GKMVTGGM.js";
import "./chunk-XGTCDM4C.js";
import "./chunk-QNG4TY7L.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import "./chunk-2QCWKZIQ.js";
import "./chunk-2NPNEA6N.js";
import "./chunk-U34ZXOJT.js";
import "./chunk-OKRW5W44.js";
import "./chunk-RGAA5Z76.js";
import "./chunk-Q6RZBEZ6.js";
import "./chunk-PC66NY33.js";
import "./chunk-YY2VB3AE.js";
import "./chunk-VEYMN5N3.js";
import "./chunk-H6NTWZSO.js";
import "./chunk-BMT3OVAP.js";
import "./chunk-W5ALAOW2.js";
import "./chunk-FHDHOWK5.js";
import "./chunk-Y546C2O5.js";
import "./chunk-IYKBAIQE.js";
import "./chunk-BDRVHR2K.js";
import "./chunk-DVIGFJWY.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-AKQ765JR.js";
import "./chunk-ERD6I7QP.js";
import "./chunk-QIT4M76C.js";
import "./chunk-EZL4LTMD.js";
import "./chunk-F3BQGS35.js";
import {
  y
} from "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-LMO6NZJA.js";
import "./chunk-A5QTLE4Y.js";
import "./chunk-SCHTG6ZQ.js";
import "./chunk-YUUTEPX2.js";
import "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import "./chunk-OHE3HDFF.js";
import "./chunk-QYC3GV65.js";
import "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import "./chunk-I2X6UR6L.js";
import "./chunk-7EQJLP2H.js";
import "./chunk-4ZLXDMI5.js";
import "./chunk-SBARCIDP.js";
import "./chunk-EMYOYGGK.js";
import "./chunk-6PMFOUWZ.js";
import "./chunk-3KPZ3BQR.js";
import "./chunk-5JYVZQZR.js";
import "./chunk-UUG4W2PI.js";
import "./chunk-WW22JHXA.js";
import "./chunk-ZAM62XN5.js";
import "./chunk-RKVEKQ5O.js";
import "./chunk-P7J4JFEH.js";
import "./chunk-G7FOE26O.js";
import "./chunk-USOPZ2Q6.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-JW7VBMHD.js";
import "./chunk-GLLRUDMY.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-AKLOTDO2.js";
import "./chunk-6AQIVLDN.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-DVI5RM3W.js";
import "./chunk-LBXFRGMS.js";
import "./chunk-VTH4DAHQ.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import {
  Q as Q2
} from "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-TPLOIZC7.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import {
  x
} from "./chunk-PWPXYWXV.js";
import {
  m
} from "./chunk-545NO6M2.js";
import "./chunk-5LSHHVQ5.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import "./chunk-NDIXNREV.js";
import "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  S
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/arcade/functions/featuresetbase.js
function X2(e3) {
  if (1 === e3.length) {
    if (U(e3[0]))
      return l("distinct", e3[0], -1);
    if (Q(e3[0]))
      return l("distinct", e3[0].toArray(), -1);
  }
  return l("distinct", e3, -1);
}
async function ee2(e3, t3, n) {
  const a4 = e3.getVariables();
  if (a4.length > 0) {
    const i = [];
    for (let e4 = 0; e4 < a4.length; e4++) {
      const r3 = { name: a4[e4] };
      i.push(await t3.evaluateIdentifier(n, r3));
    }
    const r2 = {};
    for (let e4 = 0; e4 < a4.length; e4++)
      r2[a4[e4]] = i[e4];
    return e3.parameters = r2, e3;
  }
  return e3;
}
function te2(e3, t3, n = null) {
  for (const a4 in e3)
    if (a4.toLowerCase() === t3.toLowerCase())
      return e3[a4];
  return n;
}
function ne(e3) {
  if (null === e3)
    return null;
  const t3 = { type: te2(e3, "type", ""), name: te2(e3, "name", "") };
  if ("range" === t3.type)
    t3.range = te2(e3, "range", []);
  else {
    t3.codedValues = [];
    for (const n of te2(e3, "codedValues", []))
      t3.codedValues.push({ name: te2(n, "name", ""), code: te2(n, "code", null) });
  }
  return t3;
}
function ae2(e3) {
  if (null === e3)
    return null;
  const t3 = {}, n = te2(e3, "wkt");
  null !== n && (t3.wkt = n);
  const a4 = te2(e3, "wkid");
  return null !== a4 && (t3.wkid = a4), t3;
}
function ie(e3) {
  if (null === e3)
    return null;
  const t3 = { hasZ: te2(e3, "hasz", false), hasM: te2(e3, "hasm", false) }, n = te2(e3, "spatialreference");
  null != n && (t3.spatialReference = ae2(n));
  const a4 = te2(e3, "x", null);
  if (null !== a4)
    return t3.x = a4, t3.y = te2(e3, "y", null), t3.hasZ && (t3.z = te2(e3, "z", null)), t3.hasM && (t3.m = te2(e3, "m", null)), t3;
  const i = te2(e3, "rings", null);
  if (null !== i)
    return t3.rings = i, t3;
  const r2 = te2(e3, "paths", null);
  if (null !== r2)
    return t3.paths = r2, t3;
  const s = te2(e3, "points", null);
  if (null !== s)
    return t3.points = s, t3;
  for (const o of ["xmin", "xmax", "ymin", "ymax", "zmin", "zmax", "mmin", "mmax"]) {
    const n2 = te2(e3, o, null);
    null !== n2 && (t3[o] = n2);
  }
  return t3;
}
function re(e3, t3) {
  for (const n of t3)
    if (n === e3)
      return true;
  return false;
}
function se(e3) {
  return !!e3.layerDefinition && (!!e3.featureSet && (false !== re(e3.layerDefinition.geometryType, ["", null, "esriGeometryNull", "esriGeometryPoint", "esriGeometryPolyline", "esriGeometryPolygon", "esriGeometryMultipoint", "esriGeometryEnvelope"]) && (false !== U(e3.layerDefinition.fields) && false !== U(e3.featureSet.features))));
}
function oe(e3) {
  return "utc" === (e3 == null ? void 0 : e3.toLowerCase()) ? "UTC" : "unknown" === (e3 == null ? void 0 : e3.toLowerCase()) ? "Unknown" : e3;
}
function le(q2) {
  "async" === q2.mode && (q2.functions.timezone = function(t3, r2) {
    return q2.standardFunctionAsync(t3, r2, async (s, o, l3) => {
      var _a, _b;
      if (ae(l3, 1, 2, t3, r2), te(l3[0]))
        return "Unknown";
      if (ee(l3[0]))
        return "Unknown";
      if (B(l3[0])) {
        if (await l3[0].load(), 1 === l3.length || null === l3[1])
          return l3[0].datesInUnknownTimezone ? oe("unknown") : oe(l3[0].dateFieldsTimeZone);
        if (!(l3[1] instanceof N) || false === l3[1].hasField("type"))
          throw new a(t3, r.InvalidParameter, r2);
        const e3 = l3[1].field("type");
        if (false === G(e3))
          throw new a(t3, r.InvalidParameter, r2);
        switch (me(e3).toLowerCase()) {
          case "preferredtimezone":
            return oe(l3[0].preferredTimeZone);
          case "editfieldsinfo":
            return oe(((_a = l3[0].editFieldsInfo) == null ? void 0 : _a.timeZone) ?? null);
          case "timeinfo":
            return oe(((_b = l3[0].timeInfo) == null ? void 0 : _b.timeZone) ?? null);
          case "field":
            if (l3[1].hasField("fieldname") && G(l3[1].field("fieldname")))
              return oe(l3[0].fieldTimeZone(me(l3[1].field("fieldname"))));
        }
        throw new a(t3, r.InvalidParameter, r2);
      }
      const f2 = he(l3[0], He(t3));
      if (null === f2)
        return null;
      const u2 = f2.timeZone;
      return "system" === u2 ? m.systemTimeZoneCanonicalName : "utc" === u2.toLowerCase() ? "UTC" : "unknown" === u2.toLowerCase() ? "Unknown" : u2;
    });
  }, q2.functions.sqltimestamp = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      ae(s, 1, 3, e3, t3);
      const o = s[0];
      if (X(o)) {
        if (1 === s.length)
          return o.toSQLWithKeyword();
        if (2 === s.length)
          return o.changeTimeZone(me(s[1])).toSQLWithKeyword();
        throw new a(e3, r.InvalidParameter, t3);
      }
      if (ee(o))
        return o.toSQLWithKeyword();
      if (B(o)) {
        if (3 !== s.length)
          throw new a(e3, r.InvalidParameter, t3);
        await o.load();
        const n2 = me(s[1]);
        if (ee(s[2]))
          return s[2].toSQLWithKeyword();
        if (false === X(s[2]))
          throw new a(e3, r.InvalidParameter, t3);
        const r3 = o.fieldTimeZone(n2);
        return null === r3 ? s[2].toSQLWithKeyword() : s[2].changeTimeZone(r3).toSQLWithKeyword();
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "sqltimestamp", min: 2, max: 4 }), q2.functions.featuresetbyid = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, (n, r2, o) => {
      if (ae(o, 2, 4, e3, t3), o[0] instanceof e) {
        const n2 = me(o[1]);
        let r3 = Y(o[2], null);
        const s = Ne(Y(o[3], true));
        if (null === r3 && (r3 = ["*"]), false === U(r3))
          throw new a(e3, r.InvalidParameter, t3);
        return o[0].featureSetById(n2, s, r3);
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "featuresetbyid", min: 2, max: 4 }), q2.functions.getfeatureset = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      if (ae(s, 1, 2, e3, t3), H(s[0])) {
        let t4 = Y(s[1], "datasource");
        return null === t4 && (t4 = "datasource"), t4 = me(t4).toLowerCase(), j(s[0].fullSchema(), t4, e3.lrucache, e3.interceptor, e3.spatialReference ?? null);
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "getfeatureset", min: 1, max: 2 }), q2.functions.featuresetbyportalitem = function(e3, n) {
    return q2.standardFunctionAsync(e3, n, (r2, s, o) => {
      var _a, _b;
      if (ae(o, 2, 5, e3, n), null === o[0])
        throw new a(e3, r.PortalRequired, n);
      if (o[0] instanceof t2) {
        const t3 = me(o[1]), r3 = me(o[2]);
        let s2 = Y(o[3], null);
        const f3 = Ne(Y(o[4], true));
        if (null === s2 && (s2 = ["*"]), false === U(s2))
          throw new a(e3, r.InvalidParameter, n);
        let u3;
        return u3 = ((_a = e3.services) == null ? void 0 : _a.portal) ? e3.services.portal : Q2.getDefault(), u3 = l2(o[0], u3), q(t3, r3, e3.spatialReference ?? null, s2, f3, u3, e3.lrucache, e3.interceptor);
      }
      if (false === G(o[0]))
        throw new a(e3, r.PortalRequired, n);
      const f2 = me(o[0]), u2 = me(o[1]);
      let c2 = Y(o[2], null);
      const d = Ne(Y(o[3], true));
      if (null === c2 && (c2 = ["*"]), false === U(c2))
        throw new a(e3, r.InvalidParameter, n);
      return q(f2, u2, e3.spatialReference ?? null, c2, d, ((_b = e3.services) == null ? void 0 : _b.portal) ?? Q2.getDefault(), e3.lrucache, e3.interceptor);
    });
  }, q2.signatures.push({ name: "featuresetbyportalitem", min: 2, max: 5 }), q2.functions.featuresetbyname = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, (n, r2, o) => {
      if (ae(o, 2, 4, e3, t3), o[0] instanceof e) {
        const n2 = me(o[1]);
        let r3 = Y(o[2], null);
        const s = Ne(Y(o[3], true));
        if (null === r3 && (r3 = ["*"]), false === U(r3))
          throw new a(e3, r.InvalidParameter, t3);
        return o[0].featureSetByName(n2, s, r3);
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "featuresetbyname", min: 2, max: 4 }), q2.functions.featureset = function(e3, t3) {
    return q2.standardFunction(e3, t3, (r2, s, o) => {
      ae(o, 1, 1, e3, t3);
      const l3 = { layerDefinition: { geometryType: "", objectIdField: "", globalIdField: "", typeIdField: "", hasM: false, hasZ: false, fields: [] }, featureSet: { geometryType: "", features: [] } };
      if (G(o[0])) {
        const e4 = JSON.parse(o[0]);
        void 0 !== e4.layerDefinition ? (l3.layerDefinition = e4.layerDefinition, l3.featureSet = e4.featureSet, e4.layerDefinition.spatialReference && (l3.layerDefinition.spatialReference = e4.layerDefinition.spatialReference)) : (l3.featureSet.features = e4.features, l3.featureSet.geometryType = e4.geometryType, l3.layerDefinition.geometryType = l3.featureSet.geometryType, l3.layerDefinition.objectIdField = e4.objectIdFieldName ?? "", l3.layerDefinition.typeIdField = e4.typeIdFieldName, l3.layerDefinition.globalIdField = e4.globalIdFieldName, l3.layerDefinition.fields = e4.fields, e4.spatialReference && (l3.layerDefinition.spatialReference = e4.spatialReference));
      } else {
        if (!(o[0] instanceof N))
          throw new a(e3, r.InvalidParameter, t3);
        {
          const n = JSON.parse(o[0].castToText(true)), r3 = te2(n, "layerdefinition");
          if (null !== r3) {
            l3.layerDefinition.geometryType = te2(r3, "geometrytype", ""), l3.featureSet.geometryType = l3.layerDefinition.geometryType, l3.layerDefinition.globalIdField = te2(r3, "globalidfield", ""), l3.layerDefinition.objectIdField = te2(r3, "objectidfield", ""), l3.layerDefinition.typeIdField = te2(r3, "typeidfield", ""), l3.layerDefinition.hasZ = true === te2(r3, "hasz", false), l3.layerDefinition.hasM = true === te2(r3, "hasm", false);
            const e4 = te2(r3, "spatialreference");
            e4 && (l3.layerDefinition.spatialReference = ae2(e4));
            const t4 = [];
            for (const n2 of te2(r3, "fields", [])) {
              const e5 = { name: te2(n2, "name", ""), alias: te2(n2, "alias", ""), type: te2(n2, "type", ""), nullable: te2(n2, "nullable", true), editable: te2(n2, "editable", true), length: te2(n2, "length", null), domain: ne(te2(n2, "domain")) };
              t4.push(e5);
            }
            l3.layerDefinition.fields = t4;
            const a4 = te2(n, "featureset");
            if (a4) {
              const e5 = {};
              for (const n2 of t4)
                e5[n2.name.toLowerCase()] = n2.name;
              for (const t5 of te2(a4, "features", [])) {
                const n2 = {}, a5 = te2(t5, "attributes", {});
                for (const t6 in a5)
                  n2[e5[t6.toLowerCase()]] = a5[t6];
                l3.featureSet.features.push({ attributes: n2, geometry: ie(te2(t5, "geometry")) });
              }
            }
          } else {
            l3.layerDefinition.hasZ = true === te2(n, "hasz", false), l3.layerDefinition.hasM = true === te2(n, "hasm", false), l3.layerDefinition.geometryType = te2(n, "geometrytype", ""), l3.featureSet.geometryType = l3.layerDefinition.geometryType, l3.layerDefinition.objectIdField = te2(n, "objectidfieldname", ""), l3.layerDefinition.typeIdField = te2(n, "typeidfieldname", "");
            const r4 = te2(n, "spatialreference");
            r4 && (l3.layerDefinition.spatialReference = ae2(r4));
            const s2 = [], o2 = te2(n, "fields", null);
            if (!U(o2))
              throw new a(e3, r.InvalidParameter, t3);
            for (const e4 of o2) {
              const t4 = { name: te2(e4, "name", ""), alias: te2(e4, "alias", ""), type: te2(e4, "type", ""), nullable: te2(e4, "nullable", true), editable: te2(e4, "editable", true), length: te2(e4, "length", null), domain: ne(te2(e4, "domain")) };
              s2.push(t4);
            }
            l3.layerDefinition.fields = s2;
            const f2 = {};
            for (const e4 of s2)
              f2[e4.name.toLowerCase()] = e4.name;
            let u2 = te2(n, "features", null);
            if (U(u2))
              for (const e4 of u2) {
                const t4 = {}, n2 = te2(e4, "attributes", {});
                for (const e5 in n2)
                  t4[f2[e5.toLowerCase()]] = n2[e5];
                l3.featureSet.features.push({ attributes: t4, geometry: ie(te2(e4, "geometry", null)) });
              }
            else
              u2 = null, l3.featureSet.features = u2;
          }
        }
      }
      if (false === se(l3))
        throw new a(e3, r.InvalidParameter, t3);
      return l3.layerDefinition.geometryType || (l3.layerDefinition.geometryType = "esriGeometryNull"), f.create(l3, e3.spatialReference);
    });
  }, q2.signatures.push({ name: "featureset", min: 1, max: 1 }), q2.functions.filter = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      if (ae(s, 2, 2, e3, t3), U(s[0]) || Q(s[0])) {
        const n2 = [];
        let r3, o = s[0];
        if (o instanceof t && (o = o.toArray()), !_(s[1]))
          throw new a(e3, r.InvalidParameter, t3);
        r3 = s[1].createFunction(e3);
        for (const e4 of o) {
          const t4 = r3(e4);
          S(t4) ? true === await t4 && n2.push(e4) : true === t4 && n2.push(e4);
        }
        return n2;
      }
      if (B(s[0])) {
        const t4 = await s[0].load(), n2 = x.create(s[1], t4.getFieldsIndex(), t4.dateFieldsTimeZoneDefaultUTC), a4 = n2.getVariables();
        if (a4.length > 0) {
          const t5 = [];
          for (let n3 = 0; n3 < a4.length; n3++) {
            const i2 = { name: a4[n3] };
            t5.push(await q2.evaluateIdentifier(e3, i2));
          }
          const i = {};
          for (let e4 = 0; e4 < a4.length; e4++)
            i[a4[e4]] = t5[e4];
          return n2.parameters = i, new c({ parentfeatureset: s[0], whereclause: n2 });
        }
        return new c({ parentfeatureset: s[0], whereclause: n2 });
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "filter", min: 2, max: 2 }), q2.functions.orderby = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      if (ae(s, 2, 2, e3, t3), B(s[0])) {
        const e4 = new e2(s[1]);
        return new a2({ parentfeatureset: s[0], orderbyclause: e4 });
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "orderby", min: 2, max: 2 }), q2.functions.top = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      if (ae(s, 2, 2, e3, t3), B(s[0]))
        return new a3({ parentfeatureset: s[0], topnum: s[1] });
      if (U(s[0]))
        return ge(s[1]) >= s[0].length ? s[0].slice(0) : s[0].slice(0, ge(s[1]));
      if (Q(s[0]))
        return ge(s[1]) >= s[0].length() ? s[0].slice(0) : s[0].slice(0, ge(s[1]));
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "top", min: 2, max: 2 }), q2.functions.first = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (n, a4, i) => {
      if (ae(i, 1, 1, e3, t3), B(i[0])) {
        const t4 = await i[0].first(n.abortSignal);
        if (null !== t4) {
          const n2 = D.createFromGraphicLikeObject(t4.geometry, t4.attributes, i[0], e3.timeZone);
          return n2._underlyingGraphic = t4, n2;
        }
        return t4;
      }
      return U(i[0]) ? 0 === i[0].length ? null : i[0][0] : Q(i[0]) ? 0 === i[0].length() ? null : i[0].get(0) : null;
    });
  }, q2.signatures.push({ name: "first", min: 1, max: 1 }), q2.functions.attachments = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (r2, s, o) => {
      ae(o, 1, 2, e3, t3);
      const l3 = { minsize: -1, maxsize: -1, types: null, returnMetadata: false };
      if (o.length > 1) {
        if (o[1] instanceof N) {
          if (o[1].hasField("minsize") && (l3.minsize = ge(o[1].field("minsize"))), o[1].hasField("metadata") && (l3.returnMetadata = Ne(o[1].field("metadata"))), o[1].hasField("maxsize") && (l3.maxsize = ge(o[1].field("maxsize"))), o[1].hasField("types")) {
            const e4 = Re(o[1].field("types"), false);
            e4.length > 0 && (l3.types = e4);
          }
        } else if (null !== o[1])
          throw new a(e3, r.InvalidParameter, t3);
      }
      if (H(o[0])) {
        let t4 = o[0]._layer;
        return t4 instanceof We && (t4 = g(t4, e3.spatialReference, ["*"], true, e3.lrucache, e3.interceptor)), null === t4 ? [] : false === B(t4) ? [] : (await t4.load(), t4.queryAttachments(o[0].field(t4.objectIdField), l3.minsize, l3.maxsize, l3.types, l3.returnMetadata));
      }
      if (null === o[0])
        return [];
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "attachments", min: 1, max: 2 }), q2.functions.featuresetbyrelationshipname = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      ae(s, 2, 4, e3, t3);
      const o = s[0], l3 = me(s[1]);
      let d = Y(s[2], null);
      const m2 = Ne(Y(s[3], true));
      if (null === d && (d = ["*"]), false === U(d))
        throw new a(e3, r.InvalidParameter, t3);
      if (null === s[0])
        return null;
      if (!H(s[0]))
        throw new a(e3, r.InvalidParameter, t3);
      let y3 = o._layer;
      if (y3 instanceof We && (y3 = g(y3, e3.spatialReference, ["*"], true, e3.lrucache, e3.interceptor)), null === y3)
        return null;
      if (false === B(y3))
        return null;
      y3 = await y3.load();
      const w = y3.relationshipMetaData().filter((e4) => e4.name === l3);
      if (0 === w.length)
        return null;
      if (void 0 !== w[0].relationshipTableId && null !== w[0].relationshipTableId && w[0].relationshipTableId > -1)
        return k2(y3, w[0], o.field(y3.objectIdField), y3.spatialReference, d, m2, e3.lrucache, e3.interceptor);
      let g2 = y3.serviceUrl();
      if (!g2)
        return null;
      g2 = "/" === g2.charAt(g2.length - 1) ? g2 + w[0].relatedTableId.toString() : g2 + "/" + w[0].relatedTableId.toString();
      const I2 = await F(g2, y3.spatialReference, d, m2, e3.lrucache, e3.interceptor);
      await I2.load();
      let D3 = I2.relationshipMetaData();
      if (D3 = D3.filter((e4) => e4.id === w[0].id), false === o.hasField(w[0].keyField) || null === o.field(w[0].keyField)) {
        const e4 = await y3.getFeatureByObjectId(o.field(y3.objectIdField), [w[0].keyField]);
        if (e4) {
          const t4 = x.create(D3[0].keyField + "= @id", I2.getFieldsIndex(), I2.dateFieldsTimeZoneDefaultUTC);
          return t4.parameters = { id: e4.attributes[w[0].keyField] }, I2.filter(t4);
        }
        return new u({ parentfeatureset: I2 });
      }
      const T = x.create(D3[0].keyField + "= @id", I2.getFieldsIndex(), I2.dateFieldsTimeZoneDefaultUTC);
      return T.parameters = { id: o.field(w[0].keyField) }, I2.filter(T);
    });
  }, q2.signatures.push({ name: "featuresetbyrelationshipname", min: 2, max: 4 }), q2.functions.featuresetbyassociation = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      ae(s, 2, 3, e3, t3);
      const o = s[0], l3 = me(Y(s[1], "")).toLowerCase(), u2 = G(s[2]) ? me(s[2]) : null;
      if (null === s[0])
        return null;
      if (!H(s[0]))
        throw new a(e3, r.InvalidParameter, t3);
      let c2 = o._layer;
      if (c2 instanceof We && (c2 = g(c2, e3.spatialReference, ["*"], true, e3.lrucache, e3.interceptor)), null === c2)
        return null;
      if (false === B(c2))
        return null;
      await c2.load();
      const m2 = c2.serviceUrl(), y3 = await A(m2, e3.spatialReference);
      let w = null, I2 = null, D3 = false;
      if (null !== u2 && "" !== u2 && void 0 !== u2) {
        for (const e4 of y3.terminals)
          e4.terminalName === u2 && (I2 = e4.terminalId);
        null === I2 && (D3 = true);
      }
      const T = y3.associations.getFieldsIndex(), E = T.get("TOGLOBALID").name, A2 = T.get("FROMGLOBALID").name, x2 = T.get("TOTERMINALID").name, S2 = T.get("FROMTERMINALID").name, L2 = T.get("FROMNETWORKSOURCEID").name, C = T.get("TONETWORKSOURCEID").name, v2 = T.get("ASSOCIATIONTYPE").name, P = T.get("ISCONTENTVISIBLE").name, k3 = T.get("OBJECTID").name;
      for (const e4 of c2.fields)
        if ("global-id" === e4.type) {
          w = o.field(e4.name);
          break;
        }
      let O = null, z = new B2(new y({ name: "percentalong", alias: "percentalong", type: "double" }), x.create("0", y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC)), H2 = new B2(new y({ name: "side", alias: "side", type: "string" }), x.create("''", y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC));
      const W = "globalid", G2 = "globalId", K = {};
      for (const e4 in y3.lkp)
        K[e4] = y3.lkp[e4].sourceId;
      const q3 = new b(new y({ name: "classname", alias: "classname", type: "string" }), null, K);
      let B3 = "";
      switch (l3) {
        case "midspan": {
          B3 = `((${E}='${w}') OR ( ${A2}='${w}')) AND (${v2} IN (5))`, q3.codefield = x.create(`CASE WHEN (${E}='${w}') THEN ${L2} ELSE ${C} END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC);
          const e4 = y2(L.findField(y3.associations.fields, A2));
          e4.name = W, e4.alias = W, O = new B2(e4, x.create(`CASE WHEN (${A2}='${w}') THEN ${E} ELSE ${A2} END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC)), z = y3.unVersion >= 4 ? new I(L.findField(y3.associations.fields, T.get("PERCENTALONG").name)) : new B2(new y({ name: "percentalong", alias: "percentalong", type: "double" }), x.create("0", y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC));
          break;
        }
        case "junctionedge": {
          B3 = `((${E}='${w}') OR ( ${A2}='${w}')) AND (${v2} IN (4,6))`, q3.codefield = x.create(`CASE WHEN (${E}='${w}') THEN ${L2} ELSE ${C} END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC);
          const e4 = y2(L.findField(y3.associations.fields, A2));
          e4.name = W, e4.alias = W, O = new B2(e4, x.create(`CASE WHEN (${A2}='${w}') THEN ${E} ELSE ${A2} END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC)), H2 = new B2(new y({ name: "side", alias: "side", type: "string" }), x.create(`CASE WHEN (${v2}=4) THEN 'from' ELSE 'to' END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC));
          break;
        }
        case "connected": {
          let e4 = `${E}='@T'`, t4 = `${A2}='@T'`;
          null !== I2 && (e4 += ` AND ${x2}=@A`, t4 += ` AND ${S2}=@A`), B3 = "((" + e4 + ") OR (" + t4 + "))", B3 = v(B3, "@T", w ?? ""), e4 = v(e4, "@T", w ?? ""), null !== I2 && (e4 = v(e4, "@A", I2.toString()), B3 = v(B3, "@A", I2.toString())), q3.codefield = x.create("CASE WHEN " + e4 + ` THEN ${L2} ELSE ${C} END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC);
          const n2 = y2(L.findField(y3.associations.fields, A2));
          n2.name = W, n2.alias = W, O = new B2(n2, x.create("CASE WHEN " + e4 + ` THEN ${A2} ELSE ${E} END`, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC));
          break;
        }
        case "container":
          B3 = `${E}='${w}' AND ${v2} = 2`, null !== I2 && (B3 += ` AND ${x2} = ` + I2.toString()), q3.codefield = L2, B3 = "( " + B3 + " )", O = new k(L.findField(y3.associations.fields, A2), W, W);
          break;
        case "content":
          B3 = `(${A2}='${w}' AND ${v2} = 2)`, null !== I2 && (B3 += ` AND ${S2} = ` + I2.toString()), q3.codefield = C, B3 = "( " + B3 + " )", O = new k(L.findField(y3.associations.fields, E), W, W);
          break;
        case "structure":
          B3 = `(${E}='${w}' AND ${v2} = 3)`, null !== I2 && (B3 += ` AND ${x2} = ` + I2.toString()), q3.codefield = L2, B3 = "( " + B3 + " )", O = new k(L.findField(y3.associations.fields, A2), W, G2);
          break;
        case "attached":
          B3 = `(${A2}='${w}' AND ${v2} = 3)`, null !== I2 && (B3 += ` AND ${S2} = ` + I2.toString()), q3.codefield = C, B3 = "( " + B3 + " )", O = new k(L.findField(y3.associations.fields, E), W, G2);
          break;
        default:
          throw new a(e3, r.InvalidParameter, t3);
      }
      D3 && (B3 = "1 <> 1");
      return new L({ parentfeatureset: y3.associations, adaptedFields: [new I(L.findField(y3.associations.fields, k3)), new I(L.findField(y3.associations.fields, P)), O, H2, q3, z], extraFilter: B3 ? x.create(B3, y3.associations.getFieldsIndex(), y3.associations.dateFieldsTimeZoneDefaultUTC) : null });
    });
  }, q2.signatures.push({ name: "featuresetbyassociation", min: 2, max: 6 }), q2.functions.groupby = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (r2, s, o) => {
      if (ae(o, 3, 3, e3, t3), !B(o[0]))
        throw new a(e3, r.InvalidParameter, t3);
      const l3 = await o[0].load(), f2 = [], u2 = [];
      let c2 = false, d = [];
      if (G(o[1]))
        d.push(o[1]);
      else if (o[1] instanceof N)
        d.push(o[1]);
      else if (U(o[1]))
        d = o[1];
      else {
        if (!Q(o[1]))
          throw new a(e3, r.InvalidParameter, t3);
        d = o[1].toArray();
      }
      for (const m2 of d)
        if (G(m2)) {
          const e4 = x.create(me(m2), l3.getFieldsIndex(), l3.dateFieldsTimeZoneDefaultUTC), t4 = true === D2(e4) ? me(m2) : "%%%%FIELDNAME";
          f2.push({ name: t4, expression: e4 }), "%%%%FIELDNAME" === t4 && (c2 = true);
        } else {
          if (!(m2 instanceof N))
            throw new a(e3, r.InvalidParameter, t3);
          {
            const n = m2.hasField("name") ? m2.field("name") : "%%%%FIELDNAME", r3 = m2.hasField("expression") ? m2.field("expression") : "";
            if ("%%%%FIELDNAME" === n && (c2 = true), !n)
              throw new a(e3, r.InvalidParameter, t3);
            f2.push({ name: n, expression: x.create(r3 || n, l3.getFieldsIndex(), l3.dateFieldsTimeZoneDefaultUTC) });
          }
        }
      if (d = [], G(o[2]))
        d.push(o[2]);
      else if (U(o[2]))
        d = o[2];
      else if (Q(o[2]))
        d = o[2].toArray();
      else {
        if (!(o[2] instanceof N))
          throw new a(e3, r.InvalidParameter, t3);
        d.push(o[2]);
      }
      for (const m2 of d) {
        if (!(m2 instanceof N))
          throw new a(e3, r.InvalidParameter, t3);
        {
          const n = m2.hasField("name") ? m2.field("name") : "", r3 = m2.hasField("statistic") ? m2.field("statistic") : "", s2 = m2.hasField("expression") ? m2.field("expression") : "";
          if (!n || !r3 || !s2)
            throw new a(e3, r.InvalidParameter, t3);
          u2.push({ name: n, statistic: r3.toLowerCase(), expression: x.create(s2, l3.getFieldsIndex(), l3.dateFieldsTimeZoneDefaultUTC) });
        }
      }
      if (c2) {
        const e4 = {};
        for (const n of l3.fields)
          e4[n.name.toLowerCase()] = 1;
        for (const n of f2)
          "%%%%FIELDNAME" !== n.name && (e4[n.name.toLowerCase()] = 1);
        for (const n of u2)
          "%%%%FIELDNAME" !== n.name && (e4[n.name.toLowerCase()] = 1);
        let t4 = 0;
        for (const n of f2)
          if ("%%%%FIELDNAME" === n.name) {
            for (; 1 === e4["field_" + t4.toString()]; )
              t4++;
            e4["field_" + t4.toString()] = 1, n.name = "FIELD_" + t4.toString();
          }
      }
      for (const t4 of f2)
        await ee2(t4.expression, q2, e3);
      for (const t4 of u2)
        await ee2(t4.expression, q2, e3);
      return o[0].groupby(f2, u2);
    });
  }, q2.signatures.push({ name: "groupby", min: 3, max: 3 }), q2.functions.distinct = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (r2, s, o) => {
      if (B(o[0])) {
        ae(o, 2, 2, e3, t3);
        const r3 = await o[0].load(), s2 = [];
        let l3 = [];
        if (G(o[1]))
          l3.push(o[1]);
        else if (o[1] instanceof N)
          l3.push(o[1]);
        else if (U(o[1]))
          l3 = o[1];
        else {
          if (!Q(o[1]))
            throw new a(e3, r.InvalidParameter, t3);
          l3 = o[1].toArray();
        }
        let f2 = false;
        for (const o2 of l3)
          if (G(o2)) {
            const e4 = x.create(me(o2), r3.getFieldsIndex(), r3.dateFieldsTimeZoneDefaultUTC), t4 = true === D2(e4) ? me(o2) : "%%%%FIELDNAME";
            s2.push({ name: t4, expression: e4 }), "%%%%FIELDNAME" === t4 && (f2 = true);
          } else {
            if (!(o2 instanceof N))
              throw new a(e3, r.InvalidParameter, t3);
            {
              const n = o2.hasField("name") ? o2.field("name") : "%%%%FIELDNAME", l4 = o2.hasField("expression") ? o2.field("expression") : "";
              if ("%%%%FIELDNAME" === n && (f2 = true), !n)
                throw new a(e3, r.InvalidParameter, t3);
              s2.push({ name: n, expression: x.create(l4 || n, r3.getFieldsIndex(), r3.dateFieldsTimeZoneDefaultUTC) });
            }
          }
        if (f2) {
          const e4 = {};
          for (const n of r3.fields)
            e4[n.name.toLowerCase()] = 1;
          for (const n of s2)
            "%%%%FIELDNAME" !== n.name && (e4[n.name.toLowerCase()] = 1);
          let t4 = 0;
          for (const n of s2)
            if ("%%%%FIELDNAME" === n.name) {
              for (; 1 === e4["field_" + t4.toString()]; )
                t4++;
              e4["field_" + t4.toString()] = 1, n.name = "FIELD_" + t4.toString();
            }
        }
        for (const t4 of s2)
          await ee2(t4.expression, q2, e3);
        return o[0].groupby(s2, []);
      }
      return X2(o);
    });
  }, q2.functions.getfeaturesetinfo = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (a4, i, r2) => {
      if (ae(r2, 1, 1, e3, t3), !B(r2[0]))
        return null;
      const s = await r2[0].getFeatureSetInfo();
      return s ? N.convertObjectToArcadeDictionary({ layerId: s.layerId, layerName: s.layerName, itemId: s.itemId, serviceLayerUrl: s.serviceLayerUrl, webMapLayerId: s.webMapLayerId ?? null, webMapLayerTitle: s.webMapLayerTitle ?? null, className: null, objectClassId: null }, He(e3), false, false) : null;
    });
  }, q2.signatures.push({ name: "getfeaturesetinfo", min: 1, max: 1 }), q2.functions.filterbysubtypecode = function(e3, t3) {
    return q2.standardFunctionAsync(e3, t3, async (n, r2, s) => {
      if (ae(s, 2, 2, e3, t3), B(s[0])) {
        const n2 = await s[0].load(), r3 = s[1];
        if (!V(r3))
          throw new a(e3, r.InvalidParameter, t3);
        if (n2.subtypeField) {
          const e4 = x.create(`${n2.subtypeField}= ${s[1]}`, n2.getFieldsIndex(), n2.dateFieldsTimeZoneDefaultUTC);
          return new c({ parentfeatureset: s[0], whereclause: e4 });
        }
        if (null === n2.typeIdField || "" === n2.typeIdField)
          throw new a(e3, r.FeatureSetDoesNotHaveSubtypes, t3);
        const o = x.create(`${n2.typeIdField}= ${s[1]}`, n2.getFieldsIndex(), n2.dateFieldsTimeZoneDefaultUTC);
        return new c({ parentfeatureset: s[0], whereclause: o });
      }
      throw new a(e3, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "filterbysubtypecode", min: 2, max: 2 }));
}
export {
  le as registerFunctions
};
//# sourceMappingURL=featuresetbase-VARMUM3O.js.map
