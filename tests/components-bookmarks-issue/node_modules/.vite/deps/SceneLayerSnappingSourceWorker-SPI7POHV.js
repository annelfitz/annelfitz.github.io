import {
  Y
} from "./chunk-7MYYCSEB.js";
import "./chunk-ESK2YRQM.js";
import {
  m
} from "./chunk-L7WI7KB2.js";
import "./chunk-3GY64OYE.js";
import "./chunk-QIEXJLRX.js";
import "./chunk-UNTPHF5R.js";
import "./chunk-YJFPDMSR.js";
import "./chunk-FFG7BDAP.js";
import "./chunk-H7T5AB2S.js";
import "./chunk-WKVHVZW2.js";
import {
  b,
  j,
  v
} from "./chunk-3IDXRFXE.js";
import "./chunk-TLU6YG3S.js";
import "./chunk-RLZYC2LS.js";
import "./chunk-WEER6QME.js";
import "./chunk-IRL6OOVK.js";
import "./chunk-3AIILHI5.js";
import {
  Z,
  st,
  w
} from "./chunk-XMYPMIYH.js";
import "./chunk-FQLGRQKL.js";
import "./chunk-B35SNV2V.js";
import "./chunk-Z2F5OKVA.js";
import "./chunk-UQA6M3KF.js";
import "./chunk-GLF3KRAL.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-KNMQQRV7.js";
import "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import {
  q,
  u,
  x
} from "./chunk-JZBR4X6W.js";
import {
  n,
  t
} from "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  s
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/sceneLayerSnappingUtils.js
var t2 = 1e3;
function e2(t3, e3, a2) {
  const m2 = w(), p = Z(m2);
  return q(p, p, t3, 0.5), q(p, p, e3, 0.5), m2[3] = x(p, t3), u(p, p, a2), m2;
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorker.js
var f = class {
  constructor() {
    this._idToComponent = /* @__PURE__ */ new Map(), this._components = new Y((e3) => e3.bounds), this._edges = new Y((e3) => e3.bounds), this._tmpLineSegment = v(), this._tmpP1 = n(), this._tmpP2 = n(), this._tmpP3 = n(), this.remoteClient = null;
  }
  async fetchCandidates(e3, o) {
    await Promise.resolve(), s(o), await this._ensureEdgeLocations(e3, o);
    const s2 = [];
    return this._edges.forEachNeighbor((t3) => (this._addCandidates(e3, t3, s2), s2.length < t2), e3.bounds), { result: { candidates: s2 } };
  }
  async _ensureEdgeLocations(e3, t3) {
    const o = [];
    if (this._components.forEachNeighbor((e4) => {
      if (null == e4.info) {
        const { id: t4, uid: s3 } = e4;
        o.push({ id: t4, uid: s3 });
      }
      return true;
    }, e3.bounds), !o.length)
      return;
    const s2 = { components: o }, n2 = await this.remoteClient.invoke("fetchAllEdgeLocations", s2, t3 ?? {});
    for (const i of n2.components)
      this._setFetchEdgeLocations(i);
  }
  async add(e3) {
    const t3 = new j2(e3.id, e3.bounds);
    return this._idToComponent.set(t3.id, t3), this._components.add([t3]), { result: {} };
  }
  async remove(e3) {
    const t3 = this._idToComponent.get(e3.id);
    if (t3) {
      const e4 = [];
      this._edges.forEachNeighbor((o) => (o.component === t3 && e4.push(o), true), t3.bounds), this._edges.remove(e4), this._components.remove([t3]), this._idToComponent.delete(t3.id);
    }
    return { result: {} };
  }
  _setFetchEdgeLocations(e3) {
    const t3 = this._idToComponent.get(e3.id);
    if (null == t3 || e3.uid !== t3.uid)
      return;
    const o = m.createView(e3.locations), s2 = new Array(o.count), n2 = n(), r = n();
    for (let i = 0; i < o.count; i++) {
      o.position0.getVec(i, n2), o.position1.getVec(i, r);
      const c2 = e2(n2, r, e3.origin), d2 = new w2(t3, i, c2);
      s2[i] = d2;
    }
    this._edges.add(s2);
    const { objectIds: c, origin: d } = e3;
    t3.info = { locations: o, objectIds: c, origin: d };
  }
  _addCandidates(e3, t3, o) {
    const { info: n2 } = t3.component, { origin: i, objectIds: r } = n2, c = n2.locations, d = c.position0.getVec(t3.index, this._tmpP1), a2 = c.position1.getVec(t3.index, this._tmpP2);
    u(d, d, i), u(a2, a2, i);
    const p = r[c.componentIndex.get(t3.index)];
    this._addEdgeCandidate(e3, p, d, a2, o), b2(e3, p, d, o), b2(e3, p, a2, o);
  }
  _addEdgeCandidate(e3, t3, o, s2, i) {
    if (!e3.returnEdge)
      return;
    const c = Z(e3.bounds), u2 = b(o, s2, this._tmpLineSegment), h = j(u2, c, this._tmpP3);
    st(e3.bounds, h) && i.push({ type: "edge", objectId: t3, target: t(h), distance: x(c, h), start: t(o), end: t(s2) });
  }
};
f = e([a("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")], f);
var _ = f;
function b2(e3, t3, o, s2) {
  if (!e3.returnVertex || !st(e3.bounds, o))
    return;
  const i = Z(e3.bounds);
  s2.push({ type: "vertex", objectId: t3, target: t(o), distance: x(i, o) });
}
var j2 = class _j {
  constructor(e3, t3) {
    this.id = e3, this.bounds = t3, this.info = null, this.uid = ++_j.uid;
  }
};
j2.uid = 0;
var w2 = class {
  constructor(e3, t3, o) {
    this.component = e3, this.index = t3, this.bounds = o;
  }
};
export {
  _ as default
};
//# sourceMappingURL=SceneLayerSnappingSourceWorker-SPI7POHV.js.map
