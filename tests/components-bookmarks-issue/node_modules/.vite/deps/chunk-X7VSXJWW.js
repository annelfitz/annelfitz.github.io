import {
  e
} from "./chunk-VEODBKUJ.js";
import {
  i as i2
} from "./chunk-AG6JXA4M.js";
import {
  e as e2
} from "./chunk-OCF7OAES.js";
import {
  E,
  I,
  i,
  j,
  k,
  x
} from "./chunk-QLL2YG25.js";
import {
  DateTime,
  FixedOffsetZone
} from "./chunk-NIDZ6R4E.js";
import {
  c
} from "./chunk-7MT4ACA4.js";
import {
  t4 as t2
} from "./chunk-NDIXNREV.js";
import {
  f
} from "./chunk-QHK5ZYFW.js";
import {
  o,
  s,
  t
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/widgets/support/dataUtils.js
function n(n2) {
  return "number" == typeof n2;
}
function t3(n2) {
  return "string" == typeof n2 || n2 instanceof String;
}

// node_modules/@arcgis/core/widgets/support/dateUtils.js
var y = i;
var p = { date: null, time: null, timeZoneOffset: null };
var h = /* @__PURE__ */ new Map([["hours", 3600], ["minutes", 60], ["seconds", 1], ["deciseconds", 0.1], ["centiseconds", 0.01], ["milliseconds", 1e-3]]);
var v = "yyyy-MM-dd";
var S = "TT";
var M;
!function(t5) {
  t5.HM = "HH:mm", t5.HMS = "HH:mm:ss", t5.HMS_MS = "HH:mm:ss.SSS";
}(M || (M = {}));
var O = [M.HMS_MS, M.HMS, M.HM, S];
var w = "latn";
var Z = /* @__PURE__ */ new Set(["date-only", "time-only", "timestamp-offset"]);
var H = (t5) => "valueAsDate" in t5;
function j2(t5) {
  return { locale: c(), numberingSystem: w, zone: t5 ?? y };
}
function g(t5, e3) {
  return null === t5 ? null : DateTime.fromMillis(t5, j2(e3));
}
function V(t5, e3) {
  if (null == t5 || !t3(t5) || "" === t5) {
    if (e3) {
      const t6 = DateTime.local().setZone(e3);
      return { date: null, time: null, timeZoneOffset: t6.isValid ? t6.offset.toString() : null };
    }
    return p;
  }
  const n2 = DateTime.fromISO(t5, { setZone: true });
  return { date: n2.toFormat(v, j2()), time: n2.toFormat(M.HMS_MS, j2()), timeZoneOffset: n2.offset.toString() };
}
function I2(t5, e3) {
  if (null == t5 || !n(t5) || isNaN(t5))
    return p;
  const n2 = g(t5, e3);
  return n2 ? { date: n2.toFormat(v, j2(e3)), time: n2.toFormat(S, j2(e3)) } : p;
}
function F(t5) {
  switch (t5.type) {
    case "date":
    default:
      return E("short-date-short-time");
    case "date-only":
      return E("short-date");
    case "time-only":
      return E("short-time");
    case "timestamp-offset":
      return { ...E("short-date-short-time"), timeZone: void 0, timeZoneName: "short" };
  }
}
function T(t5, e3, n2) {
  if (!t5 || null == e3)
    return null;
  switch (t5.type) {
    case "date":
      return j(e3, n2);
    case "date-only":
      return k(e3, n2);
    case "time-only":
      return I(e3, n2);
    case "timestamp-offset":
      return x(e3, n2);
    default:
      return null;
  }
}
function b(t5) {
  const { dateComponent: e3, defaultTimeZone: n2, timeComponent: o3, timeZoneComponent: l2, oldValue: r2 } = t5;
  if (!(e3 == null ? void 0 : e3.value) || !(o3 == null ? void 0 : o3.value))
    return null;
  const { year: i3, month: u3, day: m3 } = DateTime.fromFormat(e3.value, v), { hour: s3, minute: d3, second: y3, millisecond: p3 } = D(o3, i) ?? DateTime.now(), h3 = V(r2, n2), S3 = null != (l2 == null ? void 0 : l2.value) ? parseInt(l2.value, 10) : null != h3.timeZoneOffset ? parseInt(h3.timeZoneOffset, 10) : (/* @__PURE__ */ new Date()).getTimezoneOffset(), M3 = FixedOffsetZone.instance(S3), O3 = DateTime.fromObject({ year: i3, month: u3, day: m3, hour: s3, minute: d3, second: y3, millisecond: p3 }, { zone: M3 });
  return O3.isValid ? O3.toISO({ includeOffset: true }) : null;
}
function C(t5) {
  const { dateComponent: e3, timeComponent: n2, timeZone: o3, max: l2, min: r2, oldValue: i3 } = t5, u3 = D(e3, o3);
  let a2 = !!t5.applyRange;
  if (!u3)
    return null;
  let m3 = null;
  if (null != (n2 == null ? void 0 : n2.value)) {
    const t6 = D(n2, o3), e4 = Date.now(), r3 = null != l2 && l2 < e4 ? l2 : e4, i4 = DateTime.fromMillis(r3, j2(o3)), a3 = u3 || i4, { year: s4, month: c3, day: d3 } = a3, { hour: y3, minute: p3, second: h3, millisecond: v3 } = t6 || i4;
    m3 = a3.set({ year: s4, month: c3, day: d3, hour: y3, minute: p3, second: h3, millisecond: v3 });
  } else {
    const t6 = g(A({ value: i3 ?? Date.now(), max: l2, min: r2 }), o3), { year: e4, month: n3, day: s4 } = u3, { hour: f3, minute: c3, second: d3, millisecond: y3 } = t6;
    a2 = true, m3 = u3.set({ year: e4, month: n3, day: s4, hour: f3, minute: c3, second: d3, millisecond: y3 });
  }
  if (!m3.isValid)
    return null;
  const s3 = m3.toMillis();
  return a2 ? A({ value: s3, max: l2, min: r2 }) : s3;
}
function D(t5, e3) {
  if (null == (t5 == null ? void 0 : t5.value) || Array.isArray(t5.value))
    return null;
  let n2 = null;
  return n2 = H(t5) ? DateTime.fromFormat(t5.value, v, j2(e3)) : E2(t5.value), (n2 == null ? void 0 : n2.isValid) ? n2 : null;
}
function N(t5) {
  const { max: e3, min: n2, value: o3 } = t5;
  return !isNaN(o3) && (!(null != e3 && o3 > e3) && !(null != n2 && o3 < n2));
}
function A(t5) {
  const { max: n2, min: o3, value: l2 } = t5;
  return null != n2 && null != o3 ? e2(l2, o3, n2) : null != n2 && l2 > n2 ? n2 : null != o3 && l2 < o3 ? o3 : l2;
}
function z(e3) {
  if (!e3)
    return "";
  const n2 = e3.split(".").at(0);
  if (!n2 || n2.length < 1)
    throw new s("invalid time-only field", `Cannot parse valid time-only field value from ${e3}`);
  const o3 = n2.split(":"), l2 = new Array(3);
  for (let t5 = 0; t5 < 3; t5++) {
    const e4 = o3.at(t5) ?? "";
    l2[t5] = e4.padStart(2, "0");
  }
  return l2.join(":");
}
function U(t5, e3) {
  switch (e3) {
    case "date":
      return t5.getTime();
    case "date-only":
      return t5.toISODate();
    case "time-only":
      return z(t5.toISOTime(true, false));
    case "timestamp-offset":
      return t5.toISOString(false);
    default:
      return null;
  }
}
function _(t5) {
  return !!t5 && "object" == typeof t5 && "getTime" in t5 && "toISOString" in t5 && "timeZone" in t5;
}
function k2(t5) {
  if (!t5 || !t3(t5))
    return null;
  const e3 = DateTime.fromFormat(t5, v);
  return e3.isValid ? e3 : null;
}
function E2(t5) {
  return t5 && t3(t5) ? f(O, (e3) => {
    const n2 = DateTime.fromFormat(t5, e3);
    return n2.isValid ? n2 : null;
  }) ?? null : null;
}
function R(t5) {
  if (!t5 || !t3(t5))
    return null;
  const e3 = DateTime.fromISO(t5);
  return e3.isValid ? e3 : null;
}
function $(t5) {
  const { type: e3, range: n2, value: o3 } = t5;
  if (null == o3 || !n2 || o3 === n2.min || o3 === n2.max)
    return true;
  if ("date" === e3)
    return N({ value: o3, min: n2.min, max: n2.max });
  const { rawMax: l2, rawMin: r2 } = n2;
  let i3 = null, u3 = null, a2 = null;
  switch (e3) {
    case "date-only":
      i3 = k2(l2), u3 = k2(r2), a2 = k2(o3);
      break;
    case "time-only":
      i3 = E2(l2), u3 = E2(r2), a2 = E2(o3);
      break;
    case "timestamp-offset":
      i3 = R(l2), u3 = R(r2), a2 = R(o3);
  }
  return !a2 || N({ value: a2.valueOf(), min: u3 == null ? void 0 : u3.valueOf(), max: i3 == null ? void 0 : i3.valueOf() });
}

// node_modules/@arcgis/core/layers/support/domainUtils.js
var l;
!function(e3) {
  e3.VALUE_OUT_OF_RANGE = "domain-validation-error::value-out-of-range", e3.INVALID_CODED_VALUE = "domain-validation-error::invalid-coded-value";
}(l || (l = {}));
var t4 = /* @__PURE__ */ new Set(["integer", "small-integer", "big-integer", "esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeBigInteger"]);
function r(e3) {
  return null != e3 && t4.has(e3.type);
}
function a(e3) {
  return null != e3 && ("date-only" === e3.type || "esriFieldTypeDateOnly" === e3.type);
}
function u(e3) {
  return null != e3 && ("timestamp-offset" === e3.type || "esriFieldTypeTimestampOffset" === e3.type);
}
function o2(e3) {
  return null != e3 && ("time-only" === e3.type || "esriFieldTypeTimeOnly" === e3.type);
}
function s2(e3, n2) {
  const i3 = e3 == null ? void 0 : e3.domain;
  if (!i3)
    return null;
  switch (i3.type) {
    case "range": {
      const { min: i4, max: t5 } = m(e3);
      if (null != i4 && +n2 < i4 || null != t5 && +n2 > t5)
        return l.VALUE_OUT_OF_RANGE;
      break;
    }
    case "coded-value":
    case "codedValue":
      if (null == i3.codedValues || i3.codedValues.every((e4) => null == e4 || e4.code !== n2))
        return l.INVALID_CODED_VALUE;
  }
  return null;
}
function m(e3, n2) {
  const i3 = n2 ?? (e3 == null ? void 0 : e3.domain);
  if (!i3 || "range" !== i3.type)
    return;
  const l2 = "range" in i3 ? i3.range[0] : i3.minValue, t5 = "range" in i3 ? i3.range[1] : i3.maxValue, s3 = r(e3);
  return a(e3) || o2(e3) || u(e3) ? { ...d(e3, t5, l2), isInteger: s3 } : { min: null != l2 && "number" == typeof l2 ? l2 : null, max: null != t5 && "number" == typeof t5 ? t5 : null, rawMin: l2, rawMax: t5, isInteger: s3 };
}
function d(l2, t5, r2) {
  var _a, _b, _c, _d, _e2, _f;
  return a(l2) ? { min: (_a = k2(r2)) == null ? void 0 : _a.toMillis(), max: (_b = k2(t5)) == null ? void 0 : _b.toMillis(), rawMin: r2, rawMax: t5 } : o2(l2) ? { min: (_c = E2(r2)) == null ? void 0 : _c.toMillis(), max: (_d = E2(t5)) == null ? void 0 : _d.toMillis(), rawMin: r2, rawMax: t5 } : u(l2) ? { min: (_e2 = R(r2)) == null ? void 0 : _e2.toMillis(), max: (_f = R(t5)) == null ? void 0 : _f.toMillis(), rawMin: r2, rawMax: t5 } : { max: null, min: null };
}

// node_modules/@arcgis/core/layers/support/fieldUtils.js
var u2 = /^([0-9_])/;
var f2 = /[^a-z0-9_\u0080-\uffff]+/gi;
function d2(e3) {
  if (null == e3)
    return null;
  return e3.trim().replaceAll(f2, "_").replace(u2, "F$1") || null;
}
var c2 = ["field", "field2", "field3", "normalizationField", "rotationInfo.field", "proportionalSymbolInfo.field", "proportionalSymbolInfo.normalizationField", "colorInfo.field", "colorInfo.normalizationField"];
var m2 = ["field", "normalizationField"];
function p2(e3, n2) {
  if (null != e3 && null != n2) {
    for (const i3 of Array.isArray(e3) ? e3 : [e3])
      if (y2(c2, i3, n2), "visualVariables" in i3 && i3.visualVariables)
        for (const e4 of i3.visualVariables)
          y2(m2, e4, n2);
  }
}
function y2(e3, t5, r2) {
  if (e3)
    for (const l2 of e3) {
      const e4 = t(l2, t5), o3 = e4 && "function" != typeof e4 && r2.get(e4);
      o3 && o(l2, o3.name, t5);
    }
}
function g2(e3, n2) {
  var _a;
  if (null != e3 && ((_a = n2 == null ? void 0 : n2.fields) == null ? void 0 : _a.length))
    if ("startField" in e3) {
      const i3 = n2.get(e3.startField), t5 = n2.get(e3.endField);
      e3.startField = (i3 == null ? void 0 : i3.name) ?? null, e3.endField = (t5 == null ? void 0 : t5.name) ?? null;
    } else {
      const i3 = n2.get(e3.startTimeField), t5 = n2.get(e3.endTimeField);
      e3.startTimeField = (i3 == null ? void 0 : i3.name) ?? null, e3.endTimeField = (t5 == null ? void 0 : t5.name) ?? null;
    }
}
var F2 = /* @__PURE__ */ new Set();
function I3(e3, n2) {
  return e3 && n2 ? (F2.clear(), b2(F2, e3, n2), Array.from(F2).sort()) : [];
}
function b2(e3, n2, i3) {
  var _a;
  if (i3)
    if ((_a = n2 == null ? void 0 : n2.fields) == null ? void 0 : _a.length)
      if (i3.includes("*"))
        for (const { name: t5 } of n2.fields)
          e3.add(t5);
      else
        for (const t5 of i3)
          w2(e3, n2, t5);
    else {
      if (i3.includes("*"))
        return e3.clear(), void e3.add("*");
      for (const n3 of i3)
        null != n3 && e3.add(n3);
    }
}
function w2(e3, n2, i3) {
  if ("string" == typeof i3)
    if (n2) {
      const t5 = n2.get(i3);
      t5 && e3.add(t5.name);
    } else
      e3.add(i3);
}
function x2(e3, n2) {
  return null == n2 || null == e3 ? [] : n2.includes("*") ? (e3.fields ?? []).map((e4) => e4.name) : n2;
}
function T2(e3, n2, i3 = 1) {
  if (!n2 || !e3)
    return [];
  if (n2.includes("*"))
    return ["*"];
  const t5 = I3(e3, n2);
  return t5.length / e3.fields.length >= i3 ? ["*"] : t5;
}
async function h2(e3, n2, i3) {
  var _a;
  if (!i3)
    return;
  const { arcadeUtils: t5 } = await i2(), r2 = t5.extractFieldNames(i3, (_a = n2 == null ? void 0 : n2.fields) == null ? void 0 : _a.map((e4) => e4.name));
  for (const l2 of r2)
    w2(e3, n2, l2);
}
async function E3(n2, i3, t5) {
  if (t5 && "1=1" !== t5) {
    const l2 = await e(t5, i3);
    if (!l2.isStandardized)
      throw new s("fieldUtils:collectFilterFields", "Where clause is not standardized", { where: t5 });
    b2(n2, i3, l2.fieldNames);
  }
}
function _2({ displayField: e3, fields: n2 }) {
  return e3 || ((n2 == null ? void 0 : n2.length) ? S2(n2, "name-or-title") || S2(n2, "unique-identifier") || S2(n2, "type-or-category") || A2(n2) : null);
}
function A2(e3) {
  for (const n2 of e3) {
    if (!(n2 == null ? void 0 : n2.name))
      continue;
    const e4 = n2.name.toLowerCase();
    if (e4.includes("name") || e4.includes("title"))
      return n2.name;
  }
  return null;
}
function S2(e3, n2) {
  for (const i3 of e3)
    if ((i3 == null ? void 0 : i3.valueType) && i3.valueType === n2)
      return i3.name;
  return null;
}
async function v2(e3, n2) {
  var _a;
  if (!n2)
    return;
  const i3 = (_a = n2.elevationInfo) == null ? void 0 : _a.featureExpressionInfo;
  return i3 ? i3.collectRequiredFields(e3, n2.fieldsIndex) : void 0;
}
function $2(e3, n2, i3) {
  i3.onStatisticExpression ? h2(e3, n2, i3.onStatisticExpression.expression) : e3.add(i3.onStatisticField);
}
async function L(e3, n2, i3) {
  if (!n2 || !i3 || !("fields" in i3))
    return;
  const t5 = [], r2 = i3.popupTemplate;
  t5.push(D2(e3, n2, r2)), i3.fields && t5.push(...i3.fields.map(async (i4) => $2(e3, n2.fieldsIndex, i4))), await Promise.all(t5);
}
async function D2(e3, n2, i3) {
  const t5 = [];
  (i3 == null ? void 0 : i3.expressionInfos) && t5.push(...i3.expressionInfos.map((i4) => h2(e3, n2.fieldsIndex, i4.expression)));
  const r2 = i3 == null ? void 0 : i3.content;
  if (Array.isArray(r2))
    for (const l2 of r2)
      "expression" === l2.type && l2.expressionInfo && t5.push(h2(e3, n2.fieldsIndex, l2.expressionInfo.expression));
  await Promise.all(t5);
}
async function M2(e3, n2, i3) {
  n2 && (n2.timeInfo && (i3 == null ? void 0 : i3.timeExtent) && b2(e3, n2.fieldsIndex, [n2.timeInfo.startField, n2.timeInfo.endField]), n2.floorInfo && b2(e3, n2.fieldsIndex, [n2.floorInfo.floorField]), null != (i3 == null ? void 0 : i3.where) && await E3(e3, n2.fieldsIndex, i3.where));
}
async function O2(e3, n2, i3) {
  n2 && i3 && await Promise.all(i3.map((i4) => V2(e3, n2, i4)));
}
async function V2(e3, n2, i3) {
  n2 && i3 && (i3.valueExpression ? await h2(e3, n2.fieldsIndex, i3.valueExpression) : i3.field && w2(e3, n2.fieldsIndex, i3.field));
}
function j3(e3) {
  return e3 ? I3(e3.fieldsIndex, z2(e3)) : [];
}
function R2(e3) {
  if (!e3)
    return [];
  const n2 = e3.geometryFieldsInfo;
  return n2 ? I3(e3.fieldsIndex, [n2.shapeAreaField, n2.shapeLengthField]) : [];
}
var C2 = /* @__PURE__ */ new Set(["oid", "global-id", "guid"]);
var G = /* @__PURE__ */ new Set(["oid", "global-id"]);
var k3 = [/^fnode_$/i, /^tnode_$/i, /^lpoly_$/i, /^rpoly_$/i, /^poly_$/i, /^shape$/i, /^shape_$/i, /^subclass$/i, /^subclass_$/i, /^rings_ok$/i, /^rings_nok$/i, /perimeter/i, /objectid/i, /_i$/i];
function X(e3) {
  const n2 = /* @__PURE__ */ new Set();
  P(e3).forEach((e4) => n2.add(e4)), R2(e3).forEach((e4) => n2.add(e4.toLowerCase()));
  const i3 = e3 && "infoFor3D" in e3 ? e3.infoFor3D : void 0;
  return i3 && (Object.values(i3.assetMapFieldRoles).forEach((e4) => n2.add(e4.toLowerCase())), Object.values(i3.transformFieldRoles).forEach((e4) => n2.add(e4.toLowerCase()))), Array.from(n2);
}
function z2(e3) {
  if (!e3)
    return [];
  const n2 = "editFieldsInfo" in e3 && e3.editFieldsInfo;
  if (!n2)
    return [];
  const { creationDateField: i3, creatorField: t5, editDateField: r2, editorField: l2 } = n2;
  return [i3, t5, r2, l2].filter(Boolean);
}
function P(e3) {
  return z2(e3).map((e4) => e4.toLowerCase());
}
function q(e3, n2) {
  var _a;
  return e3.editable && !C2.has(e3.type) && !P(n2).includes(((_a = e3.name) == null ? void 0 : _a.toLowerCase()) ?? "");
}
function B(e3, n2) {
  var _a;
  const i3 = ((_a = e3.name) == null ? void 0 : _a.toLowerCase()) ?? "";
  return !(null != (n2 == null ? void 0 : n2.objectIdField) && i3 === n2.objectIdField.toLowerCase() || null != (n2 == null ? void 0 : n2.globalIdField) && i3 === n2.globalIdField.toLowerCase() || X(n2).includes(i3) || G.has(e3.type) || k3.some((e4) => e4.test(i3)));
}
async function J(e3, n2) {
  const { labelingInfo: i3, fieldsIndex: t5 } = n2;
  (i3 == null ? void 0 : i3.length) && await Promise.all(i3.map((n3) => W(e3, t5, n3)));
}
async function W(e3, n2, i3) {
  if (!i3)
    return;
  const t5 = i3.getLabelExpression(), r2 = i3.where;
  if ("arcade" === t5.type)
    await h2(e3, n2, t5.expression);
  else {
    const i4 = t5.expression.match(/{[^}]*}/g);
    i4 && i4.forEach((i5) => {
      w2(e3, n2, i5.slice(1, -1));
    });
  }
  await E3(e3, n2, r2);
}
function H2(e3) {
  const n2 = e3.defaultValue;
  return void 0 !== n2 && re(e3, n2) ? n2 : e3.nullable ? null : void 0;
}
function K(e3) {
  const n2 = "string" == typeof e3 ? { type: e3 } : e3;
  return ye(n2) ? 255 : "esriFieldTypeDate" === n2.type || "date" === n2.type ? 8 : void 0;
}
function Q(e3) {
  return "number" == typeof e3 && !isNaN(e3) && isFinite(e3);
}
function Z2(e3) {
  return null === e3 || Q(e3);
}
function ee(e3) {
  return null === e3 || Number.isInteger(e3);
}
function ne(e3) {
  return null != e3 && "string" == typeof e3;
}
function ie(e3) {
  return null === e3 || ne(e3);
}
function te() {
  return true;
}
function re(e3, n2) {
  let i3;
  switch (e3.type) {
    case "date":
    case "integer":
    case "long":
    case "small-integer":
    case "big-integer":
    case "esriFieldTypeDate":
    case "esriFieldTypeInteger":
    case "esriFieldTypeLong":
    case "esriFieldTypeSmallInteger":
    case "esriFieldTypeBigInteger":
      i3 = e3.nullable ? ee : Number.isInteger;
      break;
    case "double":
    case "single":
    case "esriFieldTypeSingle":
    case "esriFieldTypeDouble":
      i3 = e3.nullable ? Z2 : Q;
      break;
    case "string":
    case "esriFieldTypeString":
      i3 = e3.nullable ? ie : ne;
      break;
    default:
      i3 = te;
  }
  return 1 === arguments.length ? i3 : i3(n2);
}
var le = ["integer", "small-integer", "big-integer"];
var oe = ["single", "double"];
var se = [...le, ...oe];
var ae = ["esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeBigInteger"];
var ue = ["esriFieldTypeSingle", "esriFieldTypeDouble"];
var fe = /* @__PURE__ */ new Set([...le, ...ae]);
var de = /* @__PURE__ */ new Set([...oe, ...ue]);
var ce = t2(fe, de);
function me(e3) {
  return null != e3 && fe.has(e3.type);
}
function pe(e3) {
  return null != e3 && ce.has(e3.type);
}
function ye(e3) {
  return null != e3 && ("string" === e3.type || "esriFieldTypeString" === e3.type);
}
function ge(e3) {
  return null != e3 && ("date" === e3.type || "esriFieldTypeDate" === e3.type);
}
function Fe(e3) {
  return null != e3 && ("date-only" === e3.type || "esriFieldTypeDateOnly" === e3.type);
}
function Ie(e3) {
  return null != e3 && ("timestamp-offset" === e3.type || "esriFieldTypeTimestampOffset" === e3.type);
}
function be(e3) {
  return null != e3 && ("time-only" === e3.type || "esriFieldTypeTimeOnly" === e3.type);
}
function we(e3) {
  return null != e3 && ("oid" === e3.type || "esriFieldTypeOID" === e3.type);
}
function xe(e3) {
  return null != e3 && ("global-id" === e3.type || "esriFieldTypeGlobalID" === e3.type);
}
function Te(e3, n2) {
  return null === Ae(e3, n2);
}
var he;
var Ee;
function _e(e3) {
  return null == e3 || "number" == typeof e3 && isNaN(e3) ? null : e3;
}
function Ae(e3, n2) {
  return null == e3 || e3.nullable && null === n2 ? null : pe(e3) && !Se(e3.type, Number(n2)) ? he.OUT_OF_RANGE : re(e3, n2) ? e3.domain ? s2(e3, n2) : null : Ee.INVALID_TYPE;
}
function Se(e3, n2) {
  const i3 = "string" == typeof e3 ? ve(e3) : e3;
  if (!i3)
    return false;
  const t5 = i3.min, r2 = i3.max;
  return i3.isInteger ? Number.isInteger(n2) && n2 >= t5 && n2 <= r2 : n2 >= t5 && n2 <= r2;
}
function Ne(e3, n2) {
  const i3 = m(e3, n2);
  return i3 || (pe(e3) ? ve(e3.type) : void 0);
}
function ve(e3) {
  switch (e3) {
    case "esriFieldTypeSmallInteger":
    case "small-integer":
      return Le;
    case "esriFieldTypeInteger":
    case "integer":
      return De;
    case "esriFieldTypeBigInteger":
    case "big-integer":
      return Me;
    case "esriFieldTypeSingle":
    case "single":
      return Oe;
    case "esriFieldTypeDouble":
    case "double":
      return Ve;
  }
}
!function(e3) {
  e3.OUT_OF_RANGE = "numeric-range-validation-error::out-of-range";
}(he || (he = {})), function(e3) {
  e3.INVALID_TYPE = "type-validation-error::invalid-type";
}(Ee || (Ee = {}));
var Le = { min: -32768, max: 32767, isInteger: true, rawMin: -32768, rawMax: 32767 };
var De = { min: -2147483648, max: 2147483647, isInteger: true, rawMin: -2147483648, rawMax: 2147483647 };
var Me = { min: -Number.MAX_SAFE_INTEGER, max: Number.MAX_SAFE_INTEGER, isInteger: true, rawMin: -Number.MAX_SAFE_INTEGER, rawMax: Number.MAX_SAFE_INTEGER };
var Oe = { min: -34e37, max: 12e37, isInteger: false, rawMin: -34e37, rawMax: 12e37 };
var Ve = { min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isInteger: false, rawMin: -Number.MAX_VALUE, rawMax: Number.MAX_VALUE };
function Ue(e3, n2, i3) {
  switch (e3) {
    case l.INVALID_CODED_VALUE:
      return `Value ${i3} is not in the coded domain - field: ${n2.name}, domain: ${JSON.stringify(n2.domain)}`;
    case l.VALUE_OUT_OF_RANGE:
      return `Value ${i3} is out of the range of valid values - field: ${n2.name}, domain: ${JSON.stringify(n2.domain)}`;
    case Ee.INVALID_TYPE:
      return `Value ${i3} is not a valid value for the field type - field: ${n2.name}, type: ${n2.type}, nullable: ${n2.nullable}`;
    case he.OUT_OF_RANGE: {
      const { min: e4, max: t5 } = ve(n2.type);
      return `Value ${i3} is out of range for the number type - field: ${n2.name}, type: ${n2.type}, value range is ${e4} to ${t5}`;
    }
  }
}
function je(e3, n2) {
  return !Re(e3, n2, null);
}
function Re(e3, n2, i3) {
  if (!(n2 == null ? void 0 : n2.attributes) || !e3) {
    if (null != i3)
      for (const n3 of e3 ?? [])
        i3.add(n3);
    return true;
  }
  const t5 = new Set(Object.keys(n2.attributes));
  let r2 = false;
  for (const l2 of e3)
    if (!t5.has(l2)) {
      if (r2 = true, null == i3)
        break;
      i3.add(l2);
    }
  return r2;
}
function Ge(e3) {
  return !!e3 && ["raster.itempixelvalue", "raster.servicepixelvalue"].some((n2) => e3.toLowerCase().startsWith(n2));
}

export {
  n,
  t3 as t,
  h,
  v,
  S,
  w,
  Z,
  j2 as j,
  V,
  I2 as I,
  F,
  T,
  b,
  C,
  z,
  U,
  _,
  $,
  l,
  s2 as s,
  m,
  d,
  d2,
  p2 as p,
  g2 as g,
  I3 as I2,
  b2,
  w2,
  x2 as x,
  T2,
  h2,
  _2,
  v2,
  L,
  M2 as M,
  O2 as O,
  j3 as j2,
  X,
  P,
  q,
  B,
  J,
  H2 as H,
  K,
  me,
  pe,
  ye,
  ge,
  Fe,
  Ie,
  be,
  we,
  xe,
  Te,
  he,
  Ee,
  _e,
  Ae,
  Ne,
  Ue,
  je,
  Re,
  Ge
};
//# sourceMappingURL=chunk-X7VSXJWW.js.map
