import {
  m
} from "./chunk-ZQTY6DQZ.js";
import {
  f
} from "./chunk-7QHIE4SQ.js";
import {
  o as o2
} from "./chunk-HSOVRETF.js";
import {
  i as i2
} from "./chunk-CPZW2LMK.js";
import {
  e as e3
} from "./chunk-QR7J3YDY.js";
import {
  s
} from "./chunk-GO2OGJDG.js";
import {
  o as o3
} from "./chunk-UYMREM3D.js";
import {
  e as e2
} from "./chunk-HFJMEXIX.js";
import {
  a
} from "./chunk-UAFQMHYI.js";
import {
  o
} from "./chunk-P4MNTMCZ.js";
import {
  e
} from "./chunk-N5GQOIDP.js";
import {
  h,
  i
} from "./chunk-HWHMO3CO.js";

// node_modules/@arcgis/core/chunks/ShadowCastAccumulate.glsl.js
var m2 = 255;
var w = 1 / m2;
function u(a2) {
  const m3 = new o3(), u2 = m3.fragment;
  return u2.include(a), u2.include(i2), m3.include(f), m3.include(o2), m3.include(m, a2), u2.uniforms.add(new s("shadowMap", (e4, r) => r.shadowMap.depthTexture), new s("depthMap", (e4, r) => {
    var _a;
    return (_a = r.linearDepth) == null ? void 0 : _a.getTexture();
  }), new e2("inverseViewMatrix", (a3, o4) => h(g, i(g, o4.camera.viewMatrix, o4.camera.center))), new e3("nearFar", (e4, r) => r.camera.nearFar)), u2.constants.add("sampleValue", "float", w), m3.outputs.add("sampleCount", "float"), u2.code.add(o`void main(void) {
float depth = rgba2float(texture(depthMap, uv));
if (depth == 0.0) {
discard;
}
float currentPixelDepth = linearDepthFromFloat(depth, nearFar);
if (-currentPixelDepth > nearFar.y || -currentPixelDepth < nearFar.x) {
discard;
}
vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);
vec4 worldSpacePos = inverseViewMatrix * currentPixelPos;
mat4 shadowMatrix;
float linearDepth = -currentPixelDepth;
int i = chooseCascade(linearDepth, shadowMatrix);
if (i >= numCascades) {
discard;
}
vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);
if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
discard;
}
ivec2 texSize = textureSize(shadowMap, 0);
ivec2 uvShadow = ivec2(cascadeCoordinates(i, texSize, lvpos) * vec2(texSize));
float depthShadow = readShadowMapDepth(uvShadow, shadowMap);
bool shadow = depthShadow < lvpos.z;
if (!shadow) {
discard;
}
sampleCount = sampleValue;
}`), m3;
}
var g = e();
var f2 = Object.freeze(Object.defineProperty({ __proto__: null, ShadowCastMaxSamples: m2, build: u }, Symbol.toStringTag, { value: "Module" }));

export {
  m2 as m,
  u,
  f2 as f
};
//# sourceMappingURL=chunk-HMX5RG2W.js.map
