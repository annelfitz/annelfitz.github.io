import {
  L as L2,
  R as R2,
  T,
  b,
  d as d3,
  j as j4,
  v as v2
} from "./chunk-X5YTZ5V2.js";
import {
  e as e5
} from "./chunk-XTC23A5V.js";
import {
  u as u5
} from "./chunk-RUJWNMKZ.js";
import {
  F as F2,
  d as d4,
  r as r3,
  u as u4
} from "./chunk-EIFRMATR.js";
import {
  l as l5
} from "./chunk-ZIKY3AX6.js";
import {
  F,
  Z
} from "./chunk-M4ETSXXR.js";
import {
  c,
  m
} from "./chunk-BOU46AXG.js";
import {
  j as j3,
  w,
  x
} from "./chunk-7IFMSG3H.js";
import {
  r as r2
} from "./chunk-JASPUPTW.js";
import {
  R,
  v
} from "./chunk-B473F3N3.js";
import {
  l as l4
} from "./chunk-6SB3EFZU.js";
import {
  c as c2,
  e2 as e4,
  t as t2,
  t2 as t3
} from "./chunk-LEFES6LS.js";
import {
  f as f4
} from "./chunk-OMRW2J7M.js";
import {
  J,
  W
} from "./chunk-RYF27IO3.js";
import {
  U,
  a as a3,
  d as d2,
  f as f3,
  h as h2,
  i as i2,
  j as j2,
  l as l3,
  o as o3,
  s
} from "./chunk-PMQ5HDZI.js";
import {
  h
} from "./chunk-NAWP2ZCR.js";
import {
  a as a2
} from "./chunk-FMS3CZY7.js";
import {
  M,
  e as e3,
  f as f2,
  j,
  k as k2,
  l as l2,
  o as o2,
  u as u3
} from "./chunk-3AIILHI5.js";
import {
  $,
  p
} from "./chunk-SA77Z3WI.js";
import {
  t
} from "./chunk-Z2F5OKVA.js";
import {
  f
} from "./chunk-QYC3GV65.js";
import {
  g,
  k,
  u as u2
} from "./chunk-JZBR4X6W.js";
import {
  l,
  r
} from "./chunk-OIJCMME5.js";
import {
  n
} from "./chunk-TPLOIZC7.js";
import {
  L
} from "./chunk-UWQ3OYA5.js";
import {
  A,
  d
} from "./chunk-Z4Y53NDM.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import {
  S,
  i3 as i,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  e as e2
} from "./chunk-JGDJR5EV.js";
import {
  u
} from "./chunk-QHK5ZYFW.js";

// node_modules/@arcgis/core/views/interactive/tooltip/fields/TooltipField.js
var p2 = class extends S {
  constructor(t4) {
    super(t4), this.actual = null, this.committed = null, this.id = n(), this.inputValue = null, this.readOnly = false, this.suffix = null, this.unlockOnVertexPlacement = true, this.visible = true;
  }
  get dirty() {
    return null != this.inputValue;
  }
  get locked() {
    return null != this.committed;
  }
  lock(t4) {
    this.inputValue = null, this.committed = t4 ?? this.actual;
  }
  unlock() {
    this.committed = null, this.inputValue = null;
  }
};
e([y()], p2.prototype, "actual", void 0), e([y()], p2.prototype, "committed", void 0), e([y()], p2.prototype, "dirty", null), e([y()], p2.prototype, "format", void 0), e([y()], p2.prototype, "formatForInputMode", void 0), e([y()], p2.prototype, "id", void 0), e([y()], p2.prototype, "inputValue", void 0), e([y()], p2.prototype, "locked", null), e([y()], p2.prototype, "name", void 0), e([y()], p2.prototype, "parse", void 0), e([y()], p2.prototype, "readOnly", void 0), e([y()], p2.prototype, "suffix", void 0), e([y()], p2.prototype, "title", void 0), e([y()], p2.prototype, "unlockOnVertexPlacement", void 0), e([y()], p2.prototype, "visible", void 0), p2 = e([a("esri.views.interactive.tooltip.fields.TooltipField")], p2);

// node_modules/@arcgis/core/views/interactive/tooltip/fields/TooltipFieldElevation.js
var c3 = class extends p2 {
  constructor(t4) {
    super(t4), this.showAsZ = false;
  }
  normalizeCtorArgs(t4) {
    const e6 = (t5) => t5.inputUnitInfos.verticalLength.unit;
    return { name: "elevation", actual: h2, parse: F2((t5, o4) => a3(t5, e6(o4))), format: (t5, o4) => o4.formatters.verticalLength(t5), formatForInputMode: (t5, o4) => o4.formatters.scalar(s(t5, e6(o4))), suffix: (t5) => t5.inputUnitInfos.verticalLength.abbreviation, title: (t5) => t5.messages.sketch[this.showAsZ ? "z" : "elevation"], unlockOnVertexPlacement: false, ...t4 };
  }
};
e([y()], c3.prototype, "showAsZ", void 0), c3 = e([a("esri.views.interactive.tooltip.fields.TooltipFieldElevation")], c3);

// node_modules/@arcgis/core/views/interactive/tooltip/fields/fields.js
var d5 = (a4) => {
  const n2 = (t4) => t4.inputUnitInfos.direction.unit, i3 = (t4) => t4.sketchOptions.values.effectiveDirectionMode;
  return new p2({ name: "direction", actual: U, parse: F2((t4, r4) => o3(t4, n2(r4), "geographic")), format: (t4, e6) => {
    const r4 = i3(e6), a5 = w(t4, r4);
    switch (r4) {
      case j3.Absolute:
        return e6.formatters.direction(a5);
      case j3.Relative:
        return e6.formatters.directionRelative(a5);
      case j3.RelativeBilateral:
        return e6.formatters.directionRelativeBilateral(a5);
    }
  }, formatForInputMode: (t4, e6) => {
    const a5 = w(t4, i3(e6));
    return e6.formatters.scalar(s(a5, n2(e6)));
  }, suffix: (t4) => t4.inputUnitInfos.direction.abbreviation, title: (t4) => {
    const e6 = i3(t4), { absolute: r4, relative: a5 } = t4.messages.sketch.direction;
    switch (e6) {
      case j3.Absolute:
        return r4;
      case j3.Relative:
      case j3.RelativeBilateral:
        return a5;
    }
  }, ...a4 });
};
var g2 = (t4) => {
  const e6 = (t5) => t5.inputUnitInfos.length.unit;
  return new p2({ name: "distance", actual: h2, parse: F2((t5, r4) => a3(Math.max(t5, 0), e6(r4))), format: (t5, e7) => e7.formatters.length(t5), formatForInputMode: (t5, a4) => a4.formatters.scalar(s(t5, e6(a4))), suffix: (t5) => t5.inputUnitInfos.length.abbreviation, title: (t5) => t5.messages.sketch.distance, ...t4 });
};
var h3 = (t4) => new c3(t4);
var v3 = (t4) => {
  const e6 = (t5) => t5.inputUnitInfos.area.unit;
  return new p2({ name: "area", actual: d2, parse: F2((t5, r4) => l3(t5, e6(r4))), format: (t5, e7) => e7.formatters.area(t5), formatForInputMode: (t5, a4) => a4.formatters.scalar(s(t5, e6(a4))), suffix: (t5) => t5.inputUnitInfos.area.abbreviation, title: (t5) => t5.messages.sketch.area, ...t4 });
};
var I = (t4) => U2("longitude", { name: "x", ...t4 });
var b2 = (t4) => U2("latitude", { name: "y", ...t4 });
function U2(r4, a4) {
  return new p2({ actual: U, parse: F2((t4) => o3(t4, "degrees", "geographic")), format: (t4, e6) => e6.formatters.decimalDegrees(t4), formatForInputMode: (t4) => d4(t4), suffix: (t4) => t4.inputUnitInfos.longitudeLatitude.abbreviation, title: (t4) => t4.messages.sketch[r4], ...a4 });
}
function x2(t4) {
  return F3("x", { name: "x", ...t4 });
}
function w2(t4) {
  return F3("y", { name: "y", ...t4 });
}
function F3(t4, e6) {
  return new p2({ actual: i2(0), parse: F2((t5) => i2(t5)), format: (t5, e7) => e7.formatters.scalar(t5), formatForInputMode: (t5, e7) => e7.formatters.scalar(t5), title: (e7) => e7.messages.sketch[t4], ...e6 });
}

// node_modules/@arcgis/core/views/interactive/tooltip/DrawTooltipInfos.js
var v4 = class extends r3 {
  constructor(t4) {
    super(t4), this.type = "draw-point", this.longitude = I(), this.latitude = b2(), this.x = x2(), this.y = w2(), this.elevation = h3(), this.geographic = false;
  }
  get effectiveX() {
    return this.geographic ? this.longitude : this.x;
  }
  get effectiveY() {
    return this.geographic ? this.latitude : this.y;
  }
  get allFields() {
    return [this.effectiveX, this.effectiveY, this.elevation];
  }
};
e([y()], v4.prototype, "type", void 0), e([y()], v4.prototype, "longitude", void 0), e([y()], v4.prototype, "latitude", void 0), e([y()], v4.prototype, "x", void 0), e([y()], v4.prototype, "y", void 0), e([y()], v4.prototype, "elevation", void 0), e([y()], v4.prototype, "geographic", void 0), e([y()], v4.prototype, "effectiveX", null), e([y()], v4.prototype, "effectiveY", null), e([y()], v4.prototype, "allFields", null), e([y()], v4.prototype, "helpMessage", void 0), v4 = e([a("esri.views.interactive.tooltip.DrawTooltipInfos.DrawPointTooltipInfo")], v4);
var u6 = class extends r3 {
  constructor(t4) {
    super(t4), this.type = "draw-polyline", this.direction = d5(), this.distance = g2({ title: (t5) => t5.messages.sketch.distance }), this.elevation = h3(), this.totalLength = g2({ format: (t5, e6) => e6.formatters.totalLength(t5), title: (t5) => t5.messages.sketch.totalLength, readOnly: true });
  }
  get allFields() {
    return [this.direction, this.distance, this.elevation, this.totalLength];
  }
};
e([y()], u6.prototype, "type", void 0), e([y()], u6.prototype, "direction", void 0), e([y()], u6.prototype, "distance", void 0), e([y()], u6.prototype, "elevation", void 0), e([y()], u6.prototype, "totalLength", void 0), e([y()], u6.prototype, "allFields", null), e([y()], u6.prototype, "helpMessage", void 0), u6 = e([a("esri.views.interactive.tooltip.DrawTooltipInfos.DrawPolylineTooltipInfo")], u6);
var f5 = class extends r3 {
  constructor(t4) {
    super(t4), this.type = "draw-polygon", this.direction = d5(), this.distance = g2({ title: (t5) => t5.messages.sketch.distance }), this.elevation = h3(), this.area = v3({ readOnly: true });
  }
  get allFields() {
    return [this.direction, this.distance, this.elevation, this.area];
  }
};
e([y()], f5.prototype, "type", void 0), e([y()], f5.prototype, "distance", void 0), e([y()], f5.prototype, "elevation", void 0), e([y()], f5.prototype, "area", void 0), e([y()], f5.prototype, "allFields", null), e([y()], f5.prototype, "helpMessage", void 0), f5 = e([a("esri.views.interactive.tooltip.DrawTooltipInfos.DrawPolygonTooltipInfo")], f5);
var g3 = class extends r3 {
  constructor(t4) {
    super(t4), this.type = "draw-mesh", this.elevation = h3();
  }
  get allFields() {
    return [this.elevation];
  }
};
e([y()], g3.prototype, "type", void 0), e([y()], g3.prototype, "elevation", void 0), e([y()], g3.prototype, "allFields", null), e([y()], g3.prototype, "helpMessage", void 0), g3 = e([a("esri.views.interactive.tooltip.DrawTooltipInfos.DrawMeshTooltipInfo")], g3);
var w3 = class extends r3 {
  constructor(t4) {
    super(t4), this.type = "draw-rectangle", this.xSize = h2, this.ySize = h2, this.area = d2;
  }
  get allFields() {
    return [];
  }
};
e([y()], w3.prototype, "type", void 0), e([y()], w3.prototype, "xSize", void 0), e([y()], w3.prototype, "ySize", void 0), e([y()], w3.prototype, "area", void 0), e([y()], w3.prototype, "allFields", null), w3 = e([a("esri.views.interactive.tooltip.DrawTooltipInfos.DrawRectangleTooltipInfo")], w3);
var m2 = class extends r3 {
  constructor(t4) {
    super(t4), this.type = "draw-circle", this.radius = null, this.xSize = null, this.ySize = null, this.area = d2;
  }
  get allFields() {
    return [];
  }
};
e([y()], m2.prototype, "type", void 0), e([y()], m2.prototype, "radius", void 0), e([y()], m2.prototype, "xSize", void 0), e([y()], m2.prototype, "ySize", void 0), e([y()], m2.prototype, "area", void 0), e([y()], m2.prototype, "allFields", null), m2 = e([a("esri.views.interactive.tooltip.DrawTooltipInfos.DrawCircleTooltipInfo")], m2);

// node_modules/@arcgis/core/views/draw/DrawGraphicTool.js
var Q = class {
  constructor() {
    this.committedVertices = null, this.cursorVertex = null, this.full = null, this.outline = null, this.cursorEdge = null, this.circle = null, this.rectangle = null;
  }
};
var W2 = class extends o.EventedMixin(l4) {
  constructor(e6) {
    super(e6), this._graphic = null, this._createOperationGeometry = null, this.defaultZ = 0, this.directionOptions = null, this.geometryType = null, this.hasZ = true, this.geometryToPlace = null, this.mode = null, this.snappingManager = null, this.snapToScene = false, this.sketchOptions = new l5();
  }
  initialize() {
    this.internalGraphicsLayer = new h({ listMode: "hide", internal: true }), this.view.map.layers.add(this.internalGraphicsLayer);
    const e6 = this.drawOperation = this.makeDrawOperation(), { sketchOptions: t4 } = this, i3 = this.view.type;
    this.tooltipInfos = { point: new v4({ sketchOptions: t4, viewType: i3 }), polyline: new u6({ sketchOptions: t4, viewType: i3 }), polygon: new f5({ sketchOptions: t4, viewType: i3 }), mesh: new g3({ sketchOptions: t4, viewType: i3 }), rectangle: new w3({ sketchOptions: t4 }), circle: new m2({ sketchOptions: t4 }) }, this.tooltip = new u4({ view: this.view }), this._initializeConstraints(), this.addHandles([e6.on("vertex-add", (e7) => this.onVertexAdd(e7)), e6.on("vertex-remove", (e7) => this.onVertexRemove(e7)), e6.on("vertex-update", (e7) => this.onVertexUpdate(e7)), e6.on("cursor-update", (e7) => this.onCursorUpdate(e7)), e6.on("cursor-remove", () => this._updateGraphic()), e6.on("complete", (e7) => this.onComplete(e7)), d(() => this.cursor, (t5) => e6.cursor = t5, A), i(() => this._updateTooltipInfo()), i(() => {
      e6.constraintZ = this._constraintZ;
    })]), this.finishToolCreation();
  }
  destroy() {
    this.drawOperation = u(this.drawOperation), this.tooltip = u(this.tooltip), this._destroyAllVisualizations(), this.view.map.remove(this.internalGraphicsLayer), this.internalGraphicsLayer = u(this.internalGraphicsLayer), this._set("view", null);
  }
  get _defaultElevation() {
    const e6 = L(this._drawSpatialReference);
    return a3(this.defaultZ * e6, "meters");
  }
  get _inputModeAvailable() {
    var _a;
    const { inputEnabled: e6, visibleElements: t4 } = this.sketchOptions.tooltips;
    return e6 && true === ((_a = this.activeTooltipInfo) == null ? void 0 : _a.editableFields.some(({ name: e7 }) => "longitude" === e7 || "latitude" === e7 || "x" === e7 || "y" === e7 ? t4.coordinate : t4[e7]));
  }
  get _drawSpatialReference() {
    return this.drawOperation.coordinateHelper.spatialReference;
  }
  get canRedo() {
    return this.drawOperation.canRedo;
  }
  get canUndo() {
    return this.drawOperation.canUndo;
  }
  set centered(e6) {
    this._set("centered", e6), this._updateGraphic();
  }
  get cursor() {
    return this._get("cursor");
  }
  set cursor(e6) {
    this._set("cursor", e6);
  }
  set enabled(e6) {
    this.drawOperation.interactive = e6, this._set("enabled", e6);
  }
  set forceUniformSize(e6) {
    this._set("forceUniformSize", e6), this._updateGraphic();
  }
  get graphic() {
    return this._graphic;
  }
  set graphicSymbol(e6) {
    this._set("graphicSymbol", e6), null != this._graphic && (this._graphic.symbol = e6);
  }
  get updating() {
    var _a;
    return ((_a = this.drawOperation) == null ? void 0 : _a.updating) ?? false;
  }
  completeCreateOperation() {
    this.drawOperation.complete();
  }
  onInputEvent(e6) {
    if (!this.destroyed)
      return "key-down" === e6.type && e6.key === f4.enterInputMode && this._inputModeAvailable ? (this.tooltip.enterInputMode(), void e6.stopPropagation()) : void this.drawOperation.onInputEvent(e6);
  }
  redo() {
    this.drawOperation.redo();
  }
  reset() {
  }
  undo() {
    this.drawOperation.undo(), 0 === this.drawOperation.numCommittedVertices && this._initializeConstraints();
  }
  _destroyAllVisualizations() {
    this.removeHandles(Y.outline), this.removeHandles(Y.regularVertices), this.removeHandles(Y.activeVertex), this.removeHandles(Y.activeEdge), this.removeHandles(X);
  }
  _createOrUpdateGraphic(e6) {
    if (null != this._graphic)
      return this.updateGraphicGeometry(e6), this._graphic;
    const i3 = new f({ ...this.graphicProperties, symbol: this.graphicSymbol });
    return this._graphic = i3, this.updateGraphicGeometry(e6), this.internalGraphicsLayer.add(i3), this.addHandles(this.initializeGraphic(i3)), this.notifyChange("graphic"), this.addHandles(e2(() => {
      this.internalGraphicsLayer.remove(i3), this._graphic === i3 && (this._graphic = null);
    }), X), i3;
  }
  updateGraphicGeometry(e6) {
    this._graphic.geometry = e6;
  }
  _getCreateOperationGeometry(e6 = { operationComplete: false }) {
    var _a, _b;
    if (null == this.drawOperation)
      return;
    const { coordinateHelper: t4, view: i3, visualizationCursorVertex: o4, lastVertex: r4, committedVertices: n2, geometryIncludingUncommittedVertices: s2, numCommittedVertices: a4 } = this.drawOperation;
    if (!(a4 > 0 || null != o4))
      return;
    const l6 = e6.operationComplete ? n2 : s2, c4 = l6.length, p3 = null != o4 ? t4.pointToArray(o4) : null, u7 = this._drawSpatialReference, h5 = "3d" === i3.type && "global" === i3.viewingMode, d7 = new Q();
    d7.committedVertices = n2, d7.cursorVertex = p3;
    const { geometryType: m3 } = this;
    switch (m3) {
      case "point":
      case "mesh":
        d7.full = t4.arrayToPoint(l6[0]);
        break;
      case "multipoint":
        d7.full = c4 > 0 ? d3(l6, u7) : null;
        break;
      case "polyline":
      case "polygon":
        c4 > 0 && (d7.full = "polygon" === m3 ? j4([l6], u7, h5, true) : R2([l6], u7, h5), d7.cursorEdge = null != p3 && r4 && !a2(o4, r4) ? R2([[p3, t4.pointToArray(r4)]], u7, h5) : null, d7.outline = c4 > 1 ? d7.full : null);
        break;
      case "circle":
      case "rectangle": {
        if (d7.committedVertices = d7.cursorVertex = null, !c4)
          break;
        const t5 = F(i3, l6[0]), o5 = l6[0], r5 = t5.makeMapPoint(o5[0] + ee * i3.resolution, o5[1]);
        "circle" === m3 ? 1 === c4 && e6.operationComplete ? d7.circle = L2([o5, r5], t5, true) : 2 === c4 && (this.forceUniformSize ? d7.circle = L2(l6, t5, this.centered) : d7.rectangle = v2(l6, t5, this.centered)) : 1 === c4 && e6.operationComplete ? d7.rectangle = T([o5, r5], t5, true) : 2 === c4 && (d7.rectangle = this.forceUniformSize ? T(l6, t5, this.centered) : b(l6, t5, this.centered)), d7.full = null != d7.circle ? d7.circle.geometry : (_a = d7.rectangle) == null ? void 0 : _a.geometry, d7.outline = "polygon" === ((_b = d7.full) == null ? void 0 : _b.type) ? d7.full : null;
        break;
      }
      default:
        return null;
    }
    return d7;
  }
  initializeGraphic(e6) {
    return e2();
  }
  onComplete(e6) {
    if (!this.drawOperation)
      return;
    this._updateGraphic();
    let t4 = null;
    if (this.drawOperation.isCompleted) {
      const e7 = this._getCreateOperationGeometry({ operationComplete: true });
      null != e7 && (t4 = this._createOrUpdateGraphic(e7.full));
    }
    this._createOperationGeometry = null, this.emit("complete", { graphic: t4, ...e6 });
  }
  onCursorUpdate(e6) {
    this._updateGraphic(), this.emit("cursor-update", e6);
  }
  onDeactivate() {
    const { drawOperation: e6 } = this;
    e6 && (e6.isCompleted || e6.cancel());
  }
  onOutlineChanged(e6) {
    return e2();
  }
  onCursorEdgeChanged(e6) {
    return e2();
  }
  onVertexAdd(e6) {
    var _a;
    this._unlockConstraintsOnVertexAddOrRemove(), this._updateGraphic(), this._lockElevationOnVertexAdd((_a = e6.vertices.at(0)) == null ? void 0 : _a.coordinates), this.emit("vertex-add", e6);
  }
  onVertexRemove(e6) {
    this._unlockConstraintsOnVertexAddOrRemove(), this._updateGraphic(), this.emit("vertex-remove", e6);
  }
  onVertexUpdate(e6) {
    this._updateGraphic(), this.emit("vertex-update", e6);
  }
  _updateGraphic() {
    const e6 = this._getCreateOperationGeometry();
    this._createOperationGeometry = e6, null != e6 ? (null != e6.cursorEdge ? this.addHandles(this.onCursorEdgeChanged(e6.cursorEdge), Y.activeEdge) : this.removeHandles(Y.activeEdge), null != e6.outline ? this.addHandles(this.onOutlineChanged(e6.outline), Y.outline) : this.removeHandles(Y.outline), null != e6.committedVertices ? this.addHandles(this.onRegularVerticesChanged(e6.committedVertices), Y.regularVertices) : this.removeHandles(Y.regularVertices), null != e6.cursorVertex ? this.addHandles(this.onActiveVertexChanged(e6.cursorVertex), Y.activeVertex) : this.removeHandles(Y.activeVertex), null != e6.full ? this._createOrUpdateGraphic(e6.full) : this.removeHandles(X)) : this._destroyAllVisualizations();
  }
  get activeTooltipInfo() {
    var _a;
    const { drawOperation: e6, graphic: t4, view: i3 } = this;
    if (!e6)
      return null;
    const o4 = this.tooltipInfos, r4 = (_a = t4 == null ? void 0 : t4.geometry) == null ? void 0 : _a.type;
    switch (this.geometryType) {
      case "point":
        return "2d" === i3.type && 0 === this.defaultZ ? null : "point" === r4 ? o4.point : null;
      case "polyline":
        return "polyline" === r4 ? o4.polyline : null;
      case "polygon":
        return "polygon" === r4 ? o4.polygon : null;
      case "rectangle":
        return "polygon" === r4 ? o4.rectangle : null;
      case "circle":
        return "polygon" === r4 ? o4.circle : null;
      case "mesh":
        return "mesh" === r4 ? o4.mesh : null;
      default:
        return null;
    }
  }
  _updateTooltipInfo() {
    const { activeTooltipInfo: e6, tooltip: t4, sketchOptions: i3 } = this;
    switch (e6 == null ? void 0 : e6.type) {
      case "draw-point":
        this._updateDrawPointTooltipInfo(e6);
        break;
      case "draw-polyline":
        this._updateDrawPolylineTooltipInfo(e6);
        break;
      case "draw-polygon":
        this._updateDrawPolygonTooltipInfo(e6);
        break;
      case "draw-rectangle":
        this._updateDrawRectangleTooltipInfo(e6);
        break;
      case "draw-circle":
        this._updateDrawCircleTooltipInfo(e6);
        break;
      case "draw-mesh":
        this.updateDrawMeshTooltipInfo(e6);
    }
    t4.view = this.view, t4.info = i3.tooltips.effectiveEnabled ? e6 : null;
  }
  _updateDrawPointTooltipInfo(e6) {
    const { drawOperation: t4, graphic: i3, view: o4, sketchOptions: r4 } = this, { coordinateHelper: n2, cursorVertex: s2 } = t4, a4 = i3 == null ? void 0 : i3.geometry;
    if ("point" !== (a4 == null ? void 0 : a4.type))
      return;
    if (e6.sketchOptions = r4, e6.viewType = o4.type, e6.helpMessage = e5("point", a4), this.updateLocation(e6, a4), this.updateElevation(e6.elevation), !s2)
      return void (t4.constraints = void 0);
    const l6 = Z(s2, o4, this._drawSpatialReference, this._constraintElevationInfo, n2.hasZ(), r4.values.effectiveDirectionMode);
    t4.constraints = { context: l6, x: e6.x.committed, y: e6.y.committed, longitude: e6.longitude.committed, latitude: e6.latitude.committed, elevation: e6.elevation.committed };
  }
  _updateDrawPolylineTooltipInfo(e6) {
    const t4 = this._createOperationGeometry, i3 = null != t4 ? t4.full : null;
    "polyline" === (i3 == null ? void 0 : i3.type) && (this._updatePolylineOrPolygonCommon(e6), e6.totalLength.actual = this.drawOperation.lastVertex ? c(i3) ?? h2 : null, e6.sketchOptions = this.sketchOptions, e6.viewType = this.view.type, e6.helpMessage = e5("polyline", i3));
  }
  _updateDrawPolygonTooltipInfo(e6) {
    const t4 = this._createOperationGeometry, i3 = null != t4 ? t4.full : null;
    "polygon" === (i3 == null ? void 0 : i3.type) && (this._updatePolylineOrPolygonCommon(e6), e6.area.actual = this.drawOperation.lastVertex ? u5(i3) ?? d2 : null, e6.sketchOptions = this.sketchOptions, e6.viewType = this.view.type, e6.helpMessage = e5("polygon", i3));
  }
  _updatePolylineOrPolygonCommon(e6) {
    const { view: t4, drawOperation: i3, sketchOptions: o4 } = this, { coordinateHelper: r4, cursorVertex: n2, lastVertex: a4, secondToLastVertex: c4 } = i3, p3 = o4.values.effectiveDirectionMode, u7 = a4 && n2 ? m(a4, n2) ?? h2 : null;
    if (e6.distance.actual = u7, e6.distance.readOnly = null == a4, e6.direction.actual = null, e6.direction.readOnly = true, a4 && n2 && ("absolute" === p3 || c4)) {
      const t5 = x(c4, a4, n2, p3);
      e6.direction.actual = t5 ?? j2, e6.direction.readOnly = false;
    }
    this.updateElevation(e6.elevation);
    const h5 = n2 ?? a4;
    if (h5) {
      const o5 = Z(h5, t4, this._drawSpatialReference, this._constraintElevationInfo, r4.hasZ(), p3);
      i3.constraints = { context: o5, distance: e6.distance.committed, direction: e6.direction.committed, elevation: e6.elevation.committed };
    } else
      i3.constraints = void 0;
  }
  updateDrawMeshTooltipInfo(e6) {
  }
  _updateDrawRectangleTooltipInfo(e6) {
    e6.sketchOptions = this.sketchOptions, e6.xSize = this._xSize ?? h2, e6.ySize = this._ySize ?? h2, e6.area = this._fullGeometryArea ?? d2;
  }
  _updateDrawCircleTooltipInfo(e6) {
    const { forceUniformSize: t4 } = this;
    e6.sketchOptions = this.sketchOptions, e6.radius = t4 ? this._circleRadius ?? h2 : null, e6.xSize = t4 ? null : this._xSize ?? h2, e6.ySize = t4 ? null : this._ySize ?? h2, e6.area = this._fullGeometryArea ?? d2;
  }
  get _circleRadius() {
    var _a;
    const e6 = this._createOperationGeometry;
    return null != ((_a = e6 == null ? void 0 : e6.circle) == null ? void 0 : _a.center) && null != e6.circle.edge ? m(e6.circle.center, e6.circle.edge) : null;
  }
  get _xSize() {
    var _a, _b;
    const e6 = (_b = (_a = this._createOperationGeometry) == null ? void 0 : _a.rectangle) == null ? void 0 : _b.midpoints;
    return null != e6 ? m(e6.left, e6.right) : null;
  }
  get _ySize() {
    var _a, _b;
    const e6 = (_b = (_a = this._createOperationGeometry) == null ? void 0 : _a.rectangle) == null ? void 0 : _b.midpoints;
    return null != e6 ? m(e6.top, e6.bottom) : null;
  }
  get _fullGeometryArea() {
    var _a;
    const e6 = (_a = this._createOperationGeometry) == null ? void 0 : _a.full;
    return "polygon" !== (e6 == null ? void 0 : e6.type) ? null : u5(e6);
  }
  updateLocation(e6, t4) {
    r2(t4.spatialReference) ? (e6.geographic = true, e6.latitude.actual = o3(t4.latitude ?? 0, "degrees", "geographic"), e6.longitude.actual = o3(t4.longitude ?? 0, "degrees", "geographic")) : (e6.geographic = false, e6.x.actual = i2(t4.x), e6.y.actual = i2(t4.y));
  }
  updateElevation(e6) {
    const { drawOperation: t4, _drawSpatialReference: i3 } = this, o4 = (t4 == null ? void 0 : t4.cursorVertex) ?? (t4 == null ? void 0 : t4.lastVertex);
    e6.actual = R(o4) ?? this._defaultElevation, e6.visible = "3d" === this.view.type && this.hasZ, e6.readOnly = false, e6.showAsZ = !r2(i3);
  }
  get _constraintElevationInfo() {
    var _a;
    return ((_a = this.drawOperation) == null ? void 0 : _a.elevationInfo) ?? $;
  }
  get _constraintZ() {
    const { geometryType: e6 } = this;
    switch (e6) {
      case "point":
      case "mesh":
      case "polyline":
      case "polygon": {
        const t4 = this.tooltipInfos[e6].elevation.committed;
        if (!t4)
          return;
        return f3(t4, "meters") / L(this._drawSpatialReference);
      }
      default:
        return;
    }
  }
  _initializeConstraints() {
    const { directionOptions: e6, drawOperation: t4, geometryType: i3, tooltipInfos: o4, sketchOptions: r4 } = this, n2 = (e7) => {
      var _a;
      const i4 = (_a = t4.elevationInfo) == null ? void 0 : _a.mode, r5 = o4[e7].elevation;
      "relative-to-ground" === i4 || "relative-to-scene" === i4 || "on-the-ground" === i4 ? r5.lock(this._defaultElevation) : r5.unlock();
    }, s2 = (t5) => {
      if (e6) {
        const i4 = o4[t5].direction;
        i4.committed = e6.angle, i4.unlockOnVertexPlacement = false, r4.values.directionMode = e6.mode;
      }
    };
    switch (i3) {
      case "polygon":
      case "polyline":
        n2(i3), s2(i3);
        break;
      case "point":
      case "mesh":
        n2(i3);
    }
  }
  _lockElevationOnVertexAdd(e6) {
    const { activeTooltipInfo: t4, drawOperation: i3, view: o4 } = this, r4 = this._constraintElevationInfo;
    if ("2d" === o4.type || !e6 || "absolute-height" !== r4.mode || 1 !== (i3 == null ? void 0 : i3.numCommittedVertices) || !t4 || "draw-polyline" !== t4.type && "draw-polygon" !== t4.type || t4.elevation.locked)
      return;
    const [n2, s2, a4] = e6, l6 = this._getConvertedVertexElevation(n2, s2, a4, r4);
    null != l6 && t4.elevation.lock(l6);
  }
  _unlockConstraintsOnVertexAddOrRemove() {
    var _a;
    (_a = this.activeTooltipInfo) == null ? void 0 : _a.allFields.forEach((e6) => {
      e6.unlockOnVertexPlacement && e6.unlock();
    });
  }
  _getConvertedVertexElevation(e6, t4, i3, o4) {
    const { view: r4, drawOperation: n2 } = this;
    if ("3d" !== r4.type || !n2)
      return;
    const s2 = this._drawSpatialReference;
    i3 ?? (i3 = 0);
    const a4 = n2.elevationInfo, l6 = p(r4, e6, t4, i3, s2, a4, o4);
    return v(l6, s2) ?? this._defaultElevation;
  }
};
e([y()], W2.prototype, "_createOperationGeometry", void 0), e([y()], W2.prototype, "_defaultElevation", null), e([y()], W2.prototype, "_inputModeAvailable", null), e([y({ value: true })], W2.prototype, "centered", null), e([y()], W2.prototype, "cursor", null), e([y({ nonNullable: true })], W2.prototype, "defaultZ", void 0), e([y({ constructOnly: true })], W2.prototype, "directionOptions", void 0), e([y()], W2.prototype, "drawOperation", void 0), e([y({ value: true })], W2.prototype, "enabled", null), e([y({ value: true })], W2.prototype, "forceUniformSize", null), e([y({ constructOnly: true })], W2.prototype, "geometryType", void 0), e([y()], W2.prototype, "graphic", null), e([y({ constructOnly: true })], W2.prototype, "graphicProperties", void 0), e([y()], W2.prototype, "graphicSymbol", null), e([y({ constructOnly: true })], W2.prototype, "hasZ", void 0), e([y({ constructOnly: true })], W2.prototype, "geometryToPlace", void 0), e([y({ constructOnly: true })], W2.prototype, "mode", void 0), e([y()], W2.prototype, "snappingManager", void 0), e([y()], W2.prototype, "snapToScene", void 0), e([y()], W2.prototype, "tooltip", void 0), e([y()], W2.prototype, "tooltipInfos", void 0), e([y({ constructOnly: true, type: l5 })], W2.prototype, "sketchOptions", void 0), e([y()], W2.prototype, "updating", null), e([y({ constructOnly: true, nonNullable: true })], W2.prototype, "view", void 0), e([y()], W2.prototype, "activeTooltipInfo", null), e([y()], W2.prototype, "_circleRadius", null), e([y()], W2.prototype, "_xSize", null), e([y()], W2.prototype, "_ySize", null), e([y()], W2.prototype, "_fullGeometryArea", null), e([y()], W2.prototype, "_constraintElevationInfo", null), e([y()], W2.prototype, "_constraintZ", null), W2 = e([a("esri.views.draw.DrawGraphicTool")], W2);
var X = Symbol("create-operation-graphic");
var Y = { outline: Symbol("outline-visual"), regularVertices: Symbol("regular-vertices-visual"), activeVertex: Symbol("active-vertex-visual"), activeEdge: Symbol("active-edge-visual") };
function $2(e6) {
  switch (e6) {
    case "point":
    case "polyline":
    case "polygon":
    case "multipoint":
      return e6;
    case "circle":
    case "rectangle":
      return "segment";
    case "mesh":
      return "point";
  }
}
var ee = 48;

// node_modules/@arcgis/core/views/interactive/editGeometry/support/editPlaneUtils.js
function d6(o4, i3) {
  return T2(o4, i3, false);
}
function E(o4, i3) {
  return T2(o4, i3, true);
}
function T2(o4, i3, r4) {
  if (o4 instanceof t2) {
    if (o4.operation instanceof t3)
      return V(o4.operation, i3, r4), true;
    if (o4.operation instanceof e4)
      return h4(o4.operation, i3, r4), true;
    if (o4.operation instanceof c2)
      return v5(o4.operation, i3, r4), true;
  }
  return false;
}
function V(o4, i3, r4 = false) {
  const t4 = r4 ? -1 : 1, s2 = r(t4 * o4.dx, t4 * o4.dy, t4 * o4.dz);
  u2(i3.origin, i3.origin, s2), J(i3);
}
function h4(o4, i3, r4 = false) {
  const t4 = r4 ? -o4.angle : o4.angle;
  k(i3.basis1, i3.basis1, l, t4), k(i3.basis2, i3.basis2, l, t4), J(i3);
}
function v5(i3, r4, t4 = false) {
  const s2 = t4 ? 1 / i3.factor1 : i3.factor1, n2 = t4 ? 1 / i3.factor2 : i3.factor2;
  g(r4.basis1, r4.basis1, s2), g(r4.basis2, r4.basis2, n2), k2(r4.origin, r4.origin, i3.origin, i3.axis1, s2), k2(r4.origin, r4.origin, i3.origin, i3.axis2, n2), J(r4);
}
function F4(o4, c4, f6, m3) {
  m3 || (m3 = W());
  const p3 = o2(t.get(), o4[1], -o4[0]), g4 = o2(t.get(), Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), N = o2(t.get(), Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY), j5 = t.get();
  c4.components.forEach((n2) => n2.vertices.forEach(({ pos: n3 }) => {
    o2(j5, j(o4, n3), j(p3, n3)), f2(g4, g4, j5), M(N, N, j5);
  }));
  const l6 = 1e-6, x3 = o2(t.get(), N[0] - g4[0] < l6 ? f6 / 2 : 0, N[1] - g4[1] < l6 ? f6 / 2 : 0);
  return e3(g4, g4, x3), u3(N, N, x3), l2(m3.basis1, o4, (N[0] - g4[0]) / 2), l2(m3.basis2, p3, (N[1] - g4[1]) / 2), o2(m3.origin, g4[0] * o4[0] + g4[1] * p3[0], g4[0] * o4[1] + g4[1] * p3[1]), u3(m3.origin, m3.origin, m3.basis1), u3(m3.origin, m3.origin, m3.basis2), J(m3), m3;
}

export {
  h3 as h,
  W2 as W,
  $2 as $,
  d6 as d,
  E,
  F4 as F
};
//# sourceMappingURL=chunk-XRMNBR5S.js.map
