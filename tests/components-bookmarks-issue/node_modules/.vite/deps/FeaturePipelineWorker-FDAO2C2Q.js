import {
  o as o6
} from "./chunk-4NON4JA7.js";
import {
  n as n7
} from "./chunk-H7MCWZPK.js";
import {
  o as o5
} from "./chunk-O64IB52L.js";
import "./chunk-5JXZHN2A.js";
import {
  h as h2
} from "./chunk-KTQIY334.js";
import "./chunk-QWREIIJ5.js";
import {
  M,
  a as a3,
  b as b3,
  i as i2,
  i2 as i3,
  n as n5,
  n3 as n6,
  p as p2,
  p2 as p3,
  r as r2,
  s as s5,
  t2 as t4
} from "./chunk-6ZDDHEYR.js";
import "./chunk-YQQSFFN3.js";
import {
  i as i4
} from "./chunk-32X2FZ3S.js";
import {
  d2 as d5
} from "./chunk-4IJED6JM.js";
import "./chunk-LGIO6OCK.js";
import "./chunk-C5EJV3NW.js";
import "./chunk-XXIDOBRO.js";
import "./chunk-JL4LXZGM.js";
import "./chunk-O556EBAK.js";
import "./chunk-IJD65EMQ.js";
import "./chunk-4YGBWYMD.js";
import "./chunk-ZPU7GNG4.js";
import "./chunk-TNR6E67I.js";
import "./chunk-7O3VD45U.js";
import "./chunk-QREUCRQ4.js";
import "./chunk-YK3UMVCY.js";
import {
  e as e3
} from "./chunk-IQFWVTUJ.js";
import {
  A,
  R,
  S as S3
} from "./chunk-KQFC3S3U.js";
import {
  $ as $2
} from "./chunk-ZSZM2Q3P.js";
import "./chunk-GB4RVOXH.js";
import "./chunk-JTUYA5FE.js";
import "./chunk-UNTQATE2.js";
import "./chunk-5YY6NZNY.js";
import {
  _
} from "./chunk-DCBZOZ54.js";
import "./chunk-5IT6RVBX.js";
import "./chunk-N4HNOQVJ.js";
import "./chunk-MTQHYT7Y.js";
import "./chunk-JCP47SOM.js";
import "./chunk-CXCB57TE.js";
import "./chunk-IWO6JXL2.js";
import {
  a as a2
} from "./chunk-AVR3LWTZ.js";
import {
  r as r3
} from "./chunk-BO2EKMB5.js";
import "./chunk-FFG7BDAP.js";
import "./chunk-I4SHZ6P5.js";
import "./chunk-NGNPSQZK.js";
import "./chunk-C6M5UQQR.js";
import "./chunk-E5PVY3UF.js";
import {
  $
} from "./chunk-BNDDKY53.js";
import {
  o as o4
} from "./chunk-BECEVYQR.js";
import "./chunk-S243OWEZ.js";
import "./chunk-QYDOVVH7.js";
import "./chunk-YSXT2SWC.js";
import {
  j as j2,
  x
} from "./chunk-DGRFM5OL.js";
import "./chunk-AOAT6HYL.js";
import "./chunk-YH3SFFF7.js";
import "./chunk-JBU54P54.js";
import "./chunk-5LIYYE75.js";
import {
  S as S2,
  c as c3,
  d as d4
} from "./chunk-F2EHRKUX.js";
import "./chunk-ZECONJNT.js";
import "./chunk-UWZ4CRJK.js";
import {
  b as b2,
  h
} from "./chunk-2636VFVY.js";
import {
  n as n4
} from "./chunk-252ISA6Z.js";
import {
  K,
  N,
  Nt,
  O,
  at,
  ct,
  et,
  ft,
  gt,
  nt,
  pt,
  rt,
  w
} from "./chunk-TLTAGTBA.js";
import "./chunk-2QPP5AGU.js";
import {
  s as s3,
  t as t3
} from "./chunk-2C26DRKK.js";
import {
  e as e2
} from "./chunk-M4RFJU4F.js";
import "./chunk-WVKWBQ7C.js";
import "./chunk-RK2U53CD.js";
import "./chunk-YPY24RRU.js";
import "./chunk-O7RKI2QW.js";
import "./chunk-BMB27ANS.js";
import "./chunk-3FOBZIUS.js";
import "./chunk-WKVHVZW2.js";
import "./chunk-VIKID44H.js";
import "./chunk-RLZYC2LS.js";
import "./chunk-3AIILHI5.js";
import "./chunk-ONKWNPIN.js";
import "./chunk-JKLFCJPR.js";
import "./chunk-BSPKLAHD.js";
import {
  c as c4
} from "./chunk-GGHKH3LP.js";
import "./chunk-VS6AHHIY.js";
import "./chunk-3JC3OUNW.js";
import "./chunk-RO3CTAP7.js";
import "./chunk-GKMVTGGM.js";
import {
  Z
} from "./chunk-QNG4TY7L.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import {
  d as d3,
  p,
  s as s4,
  y as y2
} from "./chunk-VEYMN5N3.js";
import {
  b
} from "./chunk-W5ALAOW2.js";
import "./chunk-FHDHOWK5.js";
import "./chunk-Y546C2O5.js";
import "./chunk-IYKBAIQE.js";
import {
  m as m2
} from "./chunk-BDRVHR2K.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-ERD6I7QP.js";
import "./chunk-EZL4LTMD.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import "./chunk-I2X6UR6L.js";
import "./chunk-HV2SFSJW.js";
import "./chunk-SBARCIDP.js";
import {
  j
} from "./chunk-2SYXH2R7.js";
import "./chunk-7JNXJYRU.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-A5Q7MMP6.js";
import {
  i
} from "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-X7VSXJWW.js";
import {
  n as n3
} from "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import {
  u as u2
} from "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import {
  c as c2
} from "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import {
  w as w2
} from "./chunk-VTH4DAHQ.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-PWPXYWXV.js";
import "./chunk-545NO6M2.js";
import "./chunk-5LSHHVQ5.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import {
  f as f2
} from "./chunk-MBGZKT2Z.js";
import {
  W2 as W,
  o as o3
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import {
  U
} from "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  d as d2
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import {
  o as o2
} from "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  S,
  r2 as r,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  t as t2
} from "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  L,
  c2 as c,
  d,
  f2 as f,
  m,
  o,
  s as s2
} from "./chunk-JGDJR5EV.js";
import {
  n as n2,
  u
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has,
  t
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/2d/layers/features/PipelineConnectionHandlers.js
var e4 = class {
  constructor(e10) {
    this._client = e10, this.layerView = this._client.createInvokeProxy("", { ignoreConnectionErrors: true }), this.container = this._client.createInvokeProxy("container", { ignoreConnectionErrors: true }), this.eventLog = this._client.createInvokeProxy("eventLog", { ignoreConnectionErrors: true });
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MultiTileMeshData.js
var i5 = 1;
var n8 = 2;
var h3 = 4;
var o7 = 8;
var c5 = 16;
var a4 = 32;
var l = 64;
var f3 = 128;
function u3(e10) {
  switch (e10) {
    case i5:
    case o7:
    case a4:
      return -1;
    case n8:
    case l:
      return 0;
    case h3:
    case c5:
    case f3:
      return 1;
  }
}
function m3(e10) {
  switch (e10) {
    case i5:
    case n8:
    case h3:
      return -1;
    case o7:
    case c5:
      return 0;
    case a4:
    case l:
    case f3:
      return 1;
  }
}
var _2 = i5 | o7 | a4;
var d6 = h3 | c5 | f3;
var p4 = i5 | n8 | h3;
var y3 = a4 | l | f3;
var g = class {
  constructor(e10, s17, r11, i10 = 0) {
    this.tileKey = e10, this._bufferingEnabled = s17, this._sizeHint = i10, this._meshes = { self: new n5(this.id, this._sizeHint), neighbors: new Array() }, this._currentRecordOverlaps = 0, this._currentEntityOverlaps = 0, this._copyBufferedDataIntoSelf = r11 && this._bufferingEnabled && 0 === e10.level;
  }
  get id() {
    return this.tileKey.id;
  }
  vertexCount() {
    return this._meshes.self.vertexCount();
  }
  indexCount() {
    return this._meshes.self.indexCount();
  }
  indexEnsureSize(e10) {
    this._meshes.self.indexEnsureSize(e10);
  }
  entityStart(e10, s17 = e10) {
    this._currentEntityOverlaps = 0, this._meshes.self.entityStart(e10, s17);
  }
  entityRecordCount() {
    return this._meshes.self.entityRecordCount();
  }
  entityEnd() {
    if (this._meshes.self.entityEnd(), this._bufferingEnabled) {
      if (this._copyBufferedDataIntoSelf)
        return;
      for (let e10 = 0; e10 < 8; e10++) {
        const s17 = 1 << e10;
        !!(this._currentEntityOverlaps & s17) && this._meshes.neighbors[e10].entityEnd();
      }
    }
  }
  recordStart(e10, s17, t12) {
    this._currentRecordOverlaps = 0, this._meshes.self.recordStart(e10, s17, t12);
  }
  recordEnd(e10 = 0) {
    const s17 = this._meshes.self.recordEnd(this._currentRecordOverlaps);
    return s17 && 0 !== this._currentRecordOverlaps ? (this._copyIntoNeighbors(), this._currentEntityOverlaps |= this._currentRecordOverlaps, true) : s17;
  }
  recordBounds(e10, s17, t12, r11) {
    this._bufferingEnabled && this._addOverlap(e10, s17, t12, r11);
  }
  recordCount() {
    return this._meshes.self.recordCount();
  }
  metricStart(e10) {
    this._meshes.self.metricStart(e10);
  }
  metricBoxWrite(e10) {
    this._meshes.self.metricBoxWrite(e10);
  }
  metricEnd() {
    this._meshes.self.metricEnd();
  }
  vertexWrite(e10) {
    this._meshes.self.vertexWrite(e10);
  }
  vertexWriteF32(e10) {
    this._meshes.self.vertexWriteF32(e10);
  }
  vertexWriteRegion(e10) {
    this._meshes.self.vertexWriteRegion(e10);
  }
  indexWrite(e10) {
    this._meshes.self.indexWrite(e10);
  }
  serialize(s17) {
    const t12 = { message: [], transferList: [] }, i10 = this._meshes.self.serialize();
    return t12.message.push({ tileId: this.tileKey.id, ...i10.message }), t12.transferList.push(...i10.transferList), this._meshes.neighbors.forEach((i11, n16) => {
      const h6 = i11.serialize(), o18 = 1 << n16, c10 = u3(o18), a14 = m3(o18), l7 = o5(new e3(this.tileKey), c10, a14, s17);
      t12.message.push({ tileId: l7.id, ...h6.message }), t12.transferList.push(...h6.transferList);
    }), t12;
  }
  _addOverlap(e10, t12, r11, i10) {
    const n16 = Math.min(a2 / 2, r11), h6 = Math.min(a2 / 2, i10), o18 = 255 ^ ((e10 < 0 + n16 ? d6 : e10 >= a2 - n16 ? _2 : d6 | _2) | (t12 < 0 + h6 ? y3 : t12 >= a2 - h6 ? p4 : y3 | p4));
    this._currentRecordOverlaps |= o18;
  }
  _copyIntoNeighbors() {
    for (let e10 = 0; e10 < 8; e10++) {
      const r11 = 1 << e10;
      if (!!(this._currentRecordOverlaps & r11)) {
        if (this._copyBufferedDataIntoSelf) {
          const e11 = -u3(r11) * a2, t12 = -m3(r11) * a2;
          this._meshes.self.copyLast(e11, t12);
          continue;
        }
        if (!this._meshes.neighbors[e10]) {
          const s17 = Math.floor(this._sizeHint / 16);
          this._meshes.neighbors[e10] = new n5(r11, s17);
        }
        const i10 = this._meshes.neighbors[e10], n16 = -u3(r11) * a2, h6 = -m3(r11) * a2;
        i10.copyLastFrom(this._meshes.self, n16, h6);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/MeshFactory.js
var s6 = class {
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var e5 = class _e {
  constructor() {
    this._defaultResult = null, this._backgroundFillResult = null;
  }
  static async from(s17, r11, l7, u7) {
    const n16 = new _e();
    return n16.setDefault(await i2(s17, r11, l7.meshes, u7)), n16;
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(t12) {
    this._defaultResult = t12;
  }
  getBackgroundFill() {
    return this._backgroundFillResult;
  }
  setBackgroundFill(t12) {
    this._backgroundFillResult = t12;
  }
  match(t12, e10) {
    const s17 = this.doMatch(t12, e10) || this.getDefault();
    if (s17 && s17.length > 0) {
      const t13 = this.getBackgroundFill();
      if (t13)
        return [...t13, ...s17];
    }
    return s17;
  }
  getSortKey(t12, e10) {
    return 0;
  }
  doMatch(t12, e10) {
    return null;
  }
  async fetchResources(t12, e10) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/DictionaryMatcher.js
var s7 = class _s extends e5 {
  static async fromDictionaryRenderer(t12, e10, r11) {
    return new _s(t12, e10, r11);
  }
  constructor(t12, e10, s17) {
    super(), this._storage = t12, this._schema = e10, this._viewParams = s17, this._hashToGroup = /* @__PURE__ */ new Map();
  }
  get fieldMap() {
    return this._schema.fieldMap;
  }
  async fetchResources(t12, e10) {
    const s17 = e10.getCursor(), r11 = [];
    for (; s17.next(); )
      r11.push(this._updateMeshWriterGroup(t12, s17));
    await Promise.all(r11);
  }
  match(t12, e10) {
    const s17 = t12.getAttributeHash();
    return this._hashToGroup.get(s17);
  }
  async _updateMeshWriterGroup(e10, s17) {
    const r11 = s17.readLegacyFeatureForDisplay(), a14 = s17.getAttributeHash();
    if (this._hashToGroup.has(a14))
      return;
    this._hashToGroup.set(a14, null);
    const h6 = await e10.fetchDictionaryResourceImmediate({ type: "dictionary-request", feature: r11 });
    if (!h6)
      return;
    const i10 = await i2(this._storage, e10, h6.meshes, this._viewParams);
    this._hashToGroup.set(a14, i10);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/IntervalMatcher.js
var s8 = class _s extends e5 {
  constructor(t12, e10) {
    super(), this._intervals = [], this._isMaxInclusive = e10, this._field = t12;
  }
  static async fromIntervalSchema(e10, i10, a14, r11) {
    const n16 = await e10.createComputedField(a14), l7 = new _s(n16, a14.isMaxInclusive);
    await Promise.all(a14.intervals.map(async (s17) => {
      const a15 = await i2(e10, i10, s17.meshes, r11);
      l7.add(s17, a15);
    }));
    const c10 = await i2(e10, i10, a14.defaultSymbol, r11);
    l7.setDefault(c10);
    const u7 = await i2(e10, i10, a14.backgroundFill, r11);
    return l7.setBackgroundFill(u7), l7;
  }
  add(t12, e10) {
    this._intervals.push({ interval: t12, result: e10 }), this._intervals.sort((t13, e11) => t13.interval.min - e11.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  doMatch(t12, e10) {
    var _a;
    const s17 = (_a = this._field) == null ? void 0 : _a.read(t12, e10);
    if (null == s17 || isNaN(s17) || s17 === 1 / 0 || s17 === -1 / 0)
      return null;
    for (let i10 = 0; i10 < this._intervals.length; i10++) {
      const { interval: t13, result: e11 } = this._intervals[i10], a14 = s17 >= t13.min, r11 = this._isMaxInclusive ? s17 <= t13.max : s17 < t13.max;
      if (a14 && r11)
        return e11;
    }
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/LabelMatcher.js
var s9 = class _s extends e5 {
  static async fromLabelSchema(a14, r11, t12, l7) {
    const c10 = t12.classes.map(async (s17) => {
      const t13 = await i2(a14, r11, s17.meshes, l7);
      return { minScale: s17.minScale, maxScale: s17.maxScale, meshes: t13, expression: null, where: await a14.createWhereClause(s17.where) };
    }), i10 = await Promise.all(c10);
    return new _s(i10);
  }
  constructor(e10) {
    super(), this._labels = e10;
  }
  match(e10, a14) {
    if (!this._labels.length)
      return null;
    const s17 = this._getLabels(a14.$view.scale), r11 = [];
    for (const t12 of s17)
      t12.where && !t12.where(e10) || r11.push(...t12.meshes);
    return r11;
  }
  _getLabels(e10) {
    return this._labels.filter((a14) => this._validForTileScale(a14, e10));
  }
  _validForTileScale(e10, a14) {
    const s17 = a14 - a14 / 4, r11 = a14 + a14 / 2;
    return (!e10.minScale || e10.minScale >= s17) && (!e10.maxScale || e10.maxScale <= r11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/MapMatcher.js
var l2 = class _l extends e5 {
  constructor(e10, t12) {
    super(), this._defaultSymbolSortKey = 0, this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fields = [], this._fields = e10, this._separator = t12 || "";
  }
  static async fromMatcherSchema(t12, s17, r11, i10) {
    const u7 = r11.expression ? [t12.createComputedField({ expression: r11.expression })] : [r11.field ? t12.createComputedField({ field: r11.field }) : null, r11.field2 ? t12.createComputedField({ field: r11.field2 }) : null, r11.field3 ? t12.createComputedField({ field: r11.field3 }) : null], a14 = (await Promise.all(u7)).filter((e10) => !!e10), o18 = new _l(a14, r11.fieldDelimiter), n16 = await i2(t12, s17, r11.defaultSymbol, i10);
    o18.setDefault(n16);
    const d9 = await i2(t12, s17, r11.backgroundFill, i10);
    return o18.setBackgroundFill(d9), await Promise.all(r11.map.map(async (l7, r12) => {
      const u8 = await i2(t12, s17, l7.symbol, i10);
      "<Null>" === l7.value ? o18.setNullResult(u8) : o18.add(l7.value, u8, r12 + 1);
    })), o18;
  }
  setNullResult(e10) {
    this._nullResult = e10;
  }
  getSortKey(e10, t12) {
    const l7 = this._getValueFromFields(e10, t12);
    if (null == l7 || "" === l7 || "<Null>" === l7)
      return 0;
    const s17 = this._resultsMap.get(l7.toString());
    return s17 ? s17.sortKey : this._defaultSymbolSortKey;
  }
  add(e10, t12, l7) {
    this._resultsMap.set(e10.toString(), { meshWriters: t12, sortKey: l7 }), this._defaultSymbolSortKey = Math.max(this._defaultSymbolSortKey, l7 + 1);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  doMatch(e10, t12) {
    var _a;
    const l7 = this._getValueFromFields(e10, t12);
    if (null !== this._nullResult && (null == l7 || "" === l7 || "<Null>" === l7))
      return this._nullResult;
    if (null == l7)
      return null;
    const s17 = l7.toString();
    return (_a = this._resultsMap.get(s17)) == null ? void 0 : _a.meshWriters;
  }
  _getValueFromFields(e10, t12) {
    const l7 = [];
    for (const s17 of this._fields) {
      const r11 = s17.read(e10, t12);
      null == r11 || "" === r11 ? l7.push("<Null>") : l7.push(r11);
    }
    return l7.join(this._separator);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/createMatcher.js
async function c6(c10, u7, i10, h6) {
  switch (i10.type) {
    case "simple":
    case "heatmap":
    case "dot-density":
    case "pie-chart":
      return e5.from(c10, u7, i10, h6);
    case "interval":
      return s8.fromIntervalSchema(c10, u7, i10, h6);
    case "dictionary":
      return s7.fromDictionaryRenderer(c10, i10, h6);
    case "label":
      return s9.fromLabelSchema(c10, u7, i10, h6);
    case "map":
      return l2.fromMatcherSchema(c10, u7, i10, h6);
    case "subtype":
      return n9.fromSubtypes(c10, u7, i10, h6);
    case "cluster":
      return o8.fromClusterSchema(c10, u7, i10, h6);
    default:
      throw new Error("Impl");
  }
}
var n9 = class _n extends e5 {
  constructor(e10, t12) {
    super(), this._subMatchers = e10, this._subtypeField = t12;
  }
  static async fromSubtypes(e10, t12, r11, s17) {
    const a14 = /* @__PURE__ */ new Map(), o18 = [];
    for (const n16 in r11.renderers) {
      const u7 = parseInt(n16, 10), i10 = c6(e10, t12, r11.renderers[n16], s17).then((e11) => a14.set(u7, e11));
      o18.push(i10);
    }
    return await Promise.all(o18), new _n(a14, r11.subtypeField);
  }
  match(e10, t12) {
    const r11 = e10.readAttribute(this._subtypeField), s17 = this._subMatchers.get(r11);
    return s17 ? s17.match(e10, t12) : null;
  }
};
var o8 = class _o extends e5 {
  static async fromClusterSchema(e10, t12, r11, s17) {
    const [a14, n16] = await Promise.all([c6(e10, t12, r11.feature, s17), c6(e10, t12, r11.cluster, s17)]);
    return new _o(a14, n16);
  }
  constructor(e10, t12) {
    super(), this._featureMatcher = e10, this._clusterMatcher = t12;
  }
  match(e10, t12) {
    return 1 === e10.readAttribute("cluster_count") ? this._featureMatcher.match(e10, t12) : this._clusterMatcher.match(e10, t12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/FeatureMeshFactory.js
var s10 = class _s extends s6 {
  static async create(e10, o18, r11, c10) {
    const i10 = await c6(e10, o18, r11.symbology, c10), a14 = r11.labels ? await c6(e10, o18, r11.labels, c10) : null;
    return new _s(i10, a14);
  }
  constructor(e10, t12) {
    super(), this._symbology = e10, this._labels = t12;
  }
  destroy() {
  }
  async enqueueMatcherRequests(e10, t12) {
    var _a;
    await Promise.all([this._symbology.fetchResources(e10, t12), (_a = this._labels) == null ? void 0 : _a.fetchResources(e10, t12)]);
  }
  enqueueWriterRequests(e10, t12, s17) {
    const o18 = this._symbology.match(t12, s17);
    if (o18) {
      for (const r11 of o18)
        r11.enqueueRequest(e10, t12, s17);
      if (this._labels) {
        const o19 = this._labels.match(t12, s17);
        if (!o19)
          return;
        for (const r11 of o19)
          r11.enqueueRequest(e10, t12, s17);
      }
    }
  }
  write(e10, t12, s17, o18, r11) {
    const c10 = this._symbology.match(s17, o18);
    if (!c10)
      return;
    for (const i10 of c10)
      i10.write(e10, t12, s17, o18, r11);
    if (e10.entityRecordCount() >= 1 && this._labels) {
      const i10 = this._labels.match(s17, o18);
      if (!i10)
        return;
      for (const a14 of i10)
        a14.setReferences(c10), a14.write(e10, t12, s17, o18, r11);
    }
  }
  getSortKey(e10, t12) {
    return this._symbology.getSortKey(e10, t12);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/ProcessorTileMessageQueue.js
var e6 = class {
  constructor(e10) {
    this._outstandingMessages = [], this._queue = new _({ concurrency: e10.concurrency, process: (s17) => e10.process(s17) });
  }
  async push(s17) {
    if (s17.end)
      return await Promise.all(this._outstandingMessages), await this._queue.push(s17), void (this._outstandingMessages = []);
    const e10 = this._queue.push(s17);
    return this._outstandingMessages.push(e10), e10;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/ComputedAggregateField.js
var s11 = class _s {
  static async create(i10, e10) {
    var _a;
    if ("count" === e10.statisticType) {
      const i11 = new r2(1);
      return new _s(e10.name, e10.alias, e10.type, e10.statisticType, i11);
    }
    const a14 = await i10.createComputedField({ expression: (_a = e10.onStatisticExpression) == null ? void 0 : _a.expression, field: e10.onStatisticField });
    return new _s(e10.name, e10.alias, e10.type, e10.statisticType, a14);
  }
  constructor(t12, s17, i10, e10, a14) {
    this.name = t12, this.alias = s17, this.type = i10, this.statisticType = e10, this.computed = a14;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/AProcessorStrategy.js
var t5 = class {
  constructor(t12) {
    this.subscription = t12, this.handledChunks = /* @__PURE__ */ new Set();
  }
  destroy() {
  }
};
var e7 = class {
  constructor(t12, e10) {
    this._source = t12, this._attributeStore = e10, this._sendStates = /* @__PURE__ */ new Map();
  }
  destroy() {
  }
  get enablePixelBuffering() {
    return true;
  }
  onSubscribe(t12) {
    const e10 = this.createState(t12);
    this._sendStates.set(t12.key.id, e10), this.updateChunks();
  }
  onUnsubscribe(t12) {
    var _a;
    (_a = this._sendStates.get(t12.key.id)) == null ? void 0 : _a.destroy(), this._sendStates.delete(t12.key.id);
  }
  invalidate() {
    const t12 = Array.from(this._sendStates.values());
    this._sendStates.clear();
    for (const e10 of t12)
      e10.destroy(), this.onSubscribe(e10.subscription);
  }
  invalidateAttributeData() {
  }
  getFeatureObjectIdsForAggregate(t12) {
    throw new Error("InternalError: AggregateId lookup not supported");
  }
  getDisplayIds(t12) {
    return this.displayMap(t12, (t13) => t13, (t13) => t13);
  }
  getDisplayAndObjectIds(t12) {
    return this.displayMap(t12, (t13) => t13, (t13, e10, s17) => [t13, s17]);
  }
  afterUpdateChunks() {
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/AAggregateStrategy.js
var i6 = class extends e7 {
  constructor(t12, r11, s17, o18) {
    super(t12, r11), this.spatialReference = s17, this.aggregateFields = o18, this.events = new o2(), this.featureAdapter = o4;
  }
  get aggregateQueryEngine() {
    return this._aggregateQueryEngine || (this._aggregateQueryEngine = new $({ featureStore: this, fieldsIndex: this._metadata.fieldsIndex, geometryType: this._metadata.geometryType, objectIdField: this._metadata.objectIdField, spatialReference: this.spatialReference })), this._aggregateQueryEngine;
  }
  removeChunks(e10) {
  }
  forEach(e10) {
    return this.forEachAggregateWorldSpace(e10);
  }
  forEachInBounds(e10, t12) {
  }
  forEachBounds(e10, a14) {
    const s17 = i();
    for (const t12 of e10) {
      const e11 = gt(s17, t12.geometry, false, false);
      e11 && a14(e11);
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceMessage.js
var e8 = class {
  constructor(e10, i10, t12, s17, r11) {
    this.subscription = e10, this.reader = i10, this.clear = t12, this.end = s17, this.debugInfo = r11, this.type = "append";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e10, i10, t12) {
    return { type: "append", clear: this.clear, id: this.id, append: e10, end: this.end, debugInfo: this.debugInfo, subscriptionVesrion: this.subscription.version, version: i10, attributeEpoch: t12 };
  }
};
var i7 = class {
  constructor(e10, i10, t12, s17, r11) {
    this.subscription = e10, this.reader = i10, this.remove = t12, this.end = s17, this.debugInfo = r11, this.type = "update";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e10, i10, t12) {
    return { type: "update", id: this.id, modify: e10, debugInfo: this.debugInfo, remove: this.remove, version: i10, subscriptionVesrion: this.subscription.version, end: this.end, attributeEpoch: t12 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderJSON.js
var u4 = class _u extends M {
  static fromFeatures(t12, r11) {
    const { objectIdField: s17, geometryType: i10 } = r11, n16 = et([], t12, i10, false, false, s17);
    for (let e10 = 0; e10 < n16.length; e10++)
      n16[e10].displayId = t12[e10].displayId;
    return _u.fromOptimizedFeatures(n16, r11);
  }
  static fromFeatureSet(e10, r11) {
    const s17 = ct(e10, r11.objectIdField);
    return _u.fromOptimizedFeatureSet(s17, r11);
  }
  static fromOptimizedFeatureSet(e10, t12) {
    const r11 = _u.fromOptimizedFeatures(e10.features, t12);
    return r11._exceededTransferLimit = e10.exceededTransferLimit, r11._transform = e10.transform, r11._fieldsIndex = new Z(e10.fields), r11;
  }
  static fromOptimizedFeatures(e10, t12, r11) {
    const s17 = new _u(e10, t12);
    return s17._fieldsIndex = t12.fieldsIndex, s17._transform = r11, s17;
  }
  static empty(e10) {
    return new _u([], e10);
  }
  constructor(e10, t12) {
    super(t12), this._exceededTransferLimit = false, this._featureIndex = -1, this._fieldsIndex = null, this._geometryType = t12.geometryType, this._features = e10;
  }
  get fields() {
    return this._fieldsIndex;
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasFeatures() {
    return !!this._features.length;
  }
  get hasNext() {
    return this._featureIndex + 1 < this._features.length;
  }
  get exceededTransferLimit() {
    return this._exceededTransferLimit;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get _current() {
    return this._features[this._featureIndex];
  }
  removeIds(e10) {
    const t12 = new Set(e10);
    this._features = this._features.filter((e11) => !(null != e11.objectId && t12.has(e11.objectId)));
  }
  getSize() {
    return this._features.length;
  }
  getCursor() {
    return this.copy();
  }
  getInTransform() {
    return this._transform;
  }
  getAttributeHash() {
    let e10 = "";
    for (const t12 in this._current.attributes)
      e10 += this._current.attributes[t12];
    return e10;
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e10) {
    this._featureIndex = e10;
  }
  getObjectId() {
    var _a;
    return (_a = this._current) == null ? void 0 : _a.objectId;
  }
  getDisplayId() {
    return this._current.displayId;
  }
  setDisplayId(e10) {
    this._current.displayId = e10;
  }
  copy() {
    const e10 = new _u(this._features, this.metadata);
    return this.copyInto(e10), e10;
  }
  next() {
    for (; ++this._featureIndex < this._features.length && !this._getExists(); )
      ;
    return this._featureIndex < this._features.length;
  }
  readGeometryArea() {
    return s3(this._current) ? Nt(this._current.geometry, 2) : 0;
  }
  _readX() {
    return s3(this._current) ? this._current.geometry.coords[0] : 0;
  }
  _readY() {
    return s3(this._current) ? this._current.geometry.coords[1] : 0;
  }
  _readGeometry() {
    return s3(this._current) ? this._current.geometry ?? null : null;
  }
  _readServerCentroid() {
    return this._current.centroid;
  }
  _readAttribute(e10, t12) {
    var _a;
    if (!this._fieldsIndex) {
      const t13 = this._current.attributes[e10];
      if (void 0 !== t13)
        return t13;
      const r12 = e10.toLowerCase();
      for (const e11 in this._current.attributes)
        if (e11.toLowerCase() === r12)
          return this._current.attributes[e11];
      return;
    }
    const r11 = this._fieldsIndex.get(e10);
    if (!r11)
      return;
    let s17 = this._current.attributes[r11.name];
    return null == s17 ? s17 : ("esriFieldTypeTimestampOffset" === ((_a = this.fields.get(e10)) == null ? void 0 : _a.type) && (s17 = this.parseTimestampOffset(s17)), t12 && this.fields.isDateField(e10) ? new Date(s17) : s17);
  }
  _readAttributes() {
    return this._current.attributes;
  }
  copyInto(e10) {
    super.copyInto(e10), e10._featureIndex = this._featureIndex, e10._transform = this._transform, e10._fieldsIndex = this._fieldsIndex;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/BinningStrategy.js
var g2 = class extends t5 {
  constructor(e10, t12) {
    super(e10), this.bins = /* @__PURE__ */ new Map(), this.done = false, this._store = t12;
  }
  reset() {
    this.destroy(), this.bins.clear(), this.done = false, this.handledChunks.clear();
  }
  destroy() {
    var _a;
    const e10 = this.subscription.tile.key.level;
    for (const t12 of this.bins.values()) {
      const s17 = (_a = t12.cachedFeature) == null ? void 0 : _a.objectId;
      null != s17 && this._store.releaseDisplayIdForObjectId(`${s17}.${e10}`);
    }
  }
  *featuresWorldSpace() {
    for (const e10 of this.bins.values()) {
      const s17 = e10.cachedFeature;
      if (s17) {
        const e11 = s17.clone();
        e11.geometry && pt(e11.geometry, e11.geometry, false, false, this.subscription.tile.transform), yield e11;
      }
    }
  }
  getGeohashBounds(t12, s17) {
    const r11 = this.subscription.tile;
    return S3(r11.extent, r11.resolution, s17, t12);
  }
};
var y4 = class _y extends i6 {
  static async create(e10, t12, s17, r11, i10) {
    const n16 = new p2({ spatialReference: t12 }), l7 = e10.fixedBinLevel, d9 = await Promise.all(e10.fields.map(async (e11) => s11.create(n16, e11))), p7 = e10.featureFilter ? await p3.create({ geometryType: s17.metadata.geometryType, hasM: false, hasZ: false, timeInfo: s17.metadata.timeInfo, fieldsIndex: s17.metadata.fieldsIndex, spatialReference: t12, filterJSON: e10.featureFilter }) : null;
    return await x(t12, f2.WGS84), new _y({ fields: d9, geohashLevel: l7, spatialReference: t12, featureFilter: p7, timeZone: i10 }, e10.fields, s17, r11);
  }
  constructor(e10, t12, s17, r11) {
    super(s17, r11, e10.spatialReference, e10.fields), this._indexOptions = e10, this._metadata = new i3({ geometryType: "esriGeometryPolygon", objectIdField: "aggregateId", fields: t12, globalIdField: null, spatialReference: s17.metadata.spatialReference, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, typeIdField: null, types: null });
  }
  createState(e10) {
    return new g2(e10, this._attributeStore);
  }
  async *applyOverride(e10) {
    for (const t12 of this._sendStates.values()) {
      t12.reset();
      const e11 = new e8(t12.subscription, u4.empty(this._source.metadata), true, false, {});
      yield e11;
    }
  }
  displayMap(e10, t12, s17) {
    const r11 = new Map(e10.map((e11) => [t12(e11), e11])), o18 = [];
    for (const a14 of this._sendStates.values())
      for (const e11 of a14.featuresWorldSpace()) {
        const { objectId: t13, displayId: a15 } = e11, i10 = r11.get(t13);
        if (null != i10) {
          const e12 = s17(a15, i10, t13);
          o18.push(e12), r11.delete(t13);
        }
      }
    return o18;
  }
  getDisplayFeatures(e10) {
    const t12 = new Set(e10), r11 = /* @__PURE__ */ new Set(), o18 = [];
    for (const a14 of this._sendStates.values())
      for (const e11 of a14.featuresWorldSpace())
        t12.has(e11.displayId) && !r11.has(e11.objectId) && (e11.geometry && o18.push({ ...nt(e11, this._metadata.geometryType, false, false), displayId: e11.displayId }), r11.add(e11.objectId));
    return { features: [], aggregates: o18 };
  }
  getFeatureObjectIdsForAggregate(e10) {
    for (const t12 of this._sendStates.values())
      for (const s17 of t12.bins.values())
        if (s17.id === e10)
          return Array.from(s17.objectIds);
    return [];
  }
  async *updateChunks() {
    if (this._source.chunks().length)
      for (const e10 of this._sendStates.values())
        yield* this._update(e10, this._source);
  }
  forEachAggregateWorldSpace(e10) {
    for (const t12 of this._sendStates.values())
      for (const s17 of t12.featuresWorldSpace())
        e10(s17);
  }
  async *_update(e10, t12) {
    const { handledChunks: s17, subscription: o18, bins: a14 } = e10, { spatialReference: i10, geohashLevel: n16 } = this._indexOptions, l7 = o18.tile;
    if (e10.done)
      return;
    for (const r11 of t12.chunks()) {
      if (s17.has(r11.chunkId))
        continue;
      s17.add(r11.chunkId);
      const t13 = r11.queryInfo;
      if ("tileId" in t13) {
        const e11 = new e3(t13.tileId);
        if (e11.level !== l7.level || e11.world !== l7.key.world)
          continue;
      }
      const o19 = r11.getGeohashIndex(this._indexOptions), d9 = e10.getGeohashBounds(i10, n16);
      null != d9 && o19.putBins(a14, d9);
    }
    const c10 = [], u7 = o18.tile.transform, p7 = o18.tile.key.level;
    for (const d9 of a14.values()) {
      if (d9.cachedFeature)
        d9.cachedFeature.attributes = d9.getAttributes();
      else {
        const e11 = d9.getGeometry(this.spatialReference, u7), t13 = new t3(e11, d9.getAttributes(), null);
        e11 || (t13.centroid = d9.getGeometryCentroid(this.spatialReference, u7)), t13.objectId = d9.id, t13.displayId = this._attributeStore.createDisplayIdForObjectId(`${t13.objectId}.${p7}`), d9.cachedFeature = t13;
      }
      c10.push(d9.cachedFeature);
    }
    this.events.emit("changed"), e10.done = !t12.updateTracking.updating;
    const m7 = u4.fromOptimizedFeatures(c10, this._metadata, u7), g4 = m7.getCursor(), y8 = e10.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.timeZone);
    for (; g4.next(); )
      this._attributeStore.setAttributeData(g4.getDisplayId(), g4, y8);
    const b5 = new i7(e10.subscription, m7, [], e10.done, {});
    yield b5;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AccumulatedStatistics.js
var e9 = Math.PI / 180;
var s12 = class _s {
  static create(t12) {
    return new _s(t12.map((t13) => i8(t13)));
  }
  constructor(t12) {
    this._statistics = t12;
  }
  values() {
    return this._statistics.values();
  }
  insert(t12, e10) {
    for (const s17 of this._statistics)
      s17.insert(t12, e10);
  }
  merge(t12) {
    for (let e10 = 0; e10 < this._statistics.length; e10++) {
      const s17 = this._statistics[e10], i10 = t12._statistics[e10];
      if (s17.field.name !== i10.field.name)
        throw new Error("InternalError: Tried to merge incompatible statistics");
      s17.merge(i10);
    }
  }
  clone() {
    return new _s(this._statistics.map((t12) => t12.clone()));
  }
};
function i8(t12) {
  switch (t12.statisticType) {
    case "min":
      return new r4(t12);
    case "max":
      return new u5(t12);
    case "avg":
      return new c7(t12);
    case "avg_angle":
      return new h4(t12);
    case "sum":
    case "count":
      return new a5(t12);
    case "mode":
      return new o9(t12);
  }
}
var n10 = class {
  constructor(t12) {
    this.field = t12;
  }
  insert(e10, s17) {
    if (!this.field.computed)
      return;
    const i10 = this.field.computed.read(e10, s17);
    n6(i10) || this._insertValue(i10);
  }
};
var r4 = class _r extends n10 {
  constructor() {
    super(...arguments), this.type = "min", this.value = Number.MAX_VALUE;
  }
  _insertValue(t12) {
    this.value = Math.min(this.value, t12);
  }
  merge(t12) {
    this.value = Math.min(this.value, t12.value);
  }
  clone() {
    const t12 = new _r(this.field);
    return t12.value = this.value, t12;
  }
};
var u5 = class _u extends n10 {
  constructor() {
    super(...arguments), this.type = "max", this.value = Number.MIN_VALUE;
  }
  _insertValue(t12) {
    this.value = Math.max(this.value, t12);
  }
  merge(t12) {
    this.value = Math.max(this.value, t12.value);
  }
  clone() {
    const t12 = new _u(this.field);
    return t12.value = this.value, t12;
  }
};
var a5 = class _a extends n10 {
  constructor() {
    super(...arguments), this.type = "sum", this.value = 0;
  }
  _insertValue(t12) {
    this.value += t12;
  }
  merge(t12) {
    this.value += t12.value;
  }
  clone() {
    const t12 = new _a(this.field);
    return t12.value = this.value, t12;
  }
};
var c7 = class _c extends n10 {
  constructor() {
    super(...arguments), this.type = "avg", this._total = 0, this._count = 0;
  }
  get value() {
    return this._total / this._count;
  }
  _insertValue(t12) {
    this._total += t12, this._count += 1;
  }
  merge(t12) {
    this._total += t12._total, this._count += t12._count;
  }
  clone() {
    const t12 = new _c(this.field);
    return t12._total = this._total, t12._count = this._count, t12;
  }
};
var h4 = class _h extends n10 {
  constructor() {
    super(...arguments), this.type = "avg_angle", this._x = 0, this._y = 0, this._count = 0;
  }
  get value() {
    const t12 = this._x / this._count, e10 = this._y / this._count, s17 = 180 / Math.PI;
    return Math.atan2(e10, t12) * s17;
  }
  _insertValue(t12) {
    this._x = this._x + Math.cos(t12 * e9), this._y = this._y + Math.sin(t12 * e9), this._count += 1;
  }
  merge(t12) {
    this._x += t12._x, this._y += t12._y, this._count += t12._count;
  }
  clone() {
    const t12 = new _h(this.field);
    return t12._x = this._x, t12._y = this._y, t12._count = this._count, t12;
  }
};
var o9 = class _o extends n10 {
  constructor() {
    super(...arguments), this._frequencies = /* @__PURE__ */ new Map();
  }
  get value() {
    let t12, e10 = 0;
    for (const [s17, i10] of this._frequencies.entries())
      i10 > e10 && (e10 = i10, t12 = s17);
    return t12;
  }
  _insertValue(t12) {
    const e10 = this._frequencies.get(t12);
    null != e10 ? this._frequencies.set(t12, e10 + 1) : this._frequencies.set(t12, 1);
  }
  merge(t12) {
    for (const [e10, s17] of t12._frequencies.entries()) {
      const t13 = this._frequencies.get(e10);
      null != t13 ? this._frequencies.set(e10, t13 + s17) : this._frequencies.set(e10, s17);
    }
  }
  clone() {
    const t12 = new _o(this.field);
    return t12._frequencies = new Map(this._frequencies), t12;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridCell.js
var o10 = class _o {
  static createId(t12, r11) {
    return `${t12}.${r11}`;
  }
  static create(t12, r11, e10, s17) {
    return new _o(t12, r11, s12.create(e10), s17);
  }
  constructor(t12, r11, e10, s17) {
    this.gridX = t12, this.gridY = r11, this._statistics = e10, this._worldUnitsPerCell = s17, this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._objectIds = /* @__PURE__ */ new Set();
  }
  get id() {
    return _o.createId(this.gridX, this.gridY);
  }
  get count() {
    return this._count;
  }
  get statistics() {
    return this._statistics;
  }
  get objectIds() {
    return this._objectIds;
  }
  get firstObjectId() {
    return this._objectIds.values().next().value;
  }
  get centroidXWorld() {
    return this._xWorldTotal / this._count;
  }
  get centroidYWorld() {
    return this._yWorldTotal / this._count;
  }
  clone() {
    const t12 = new _o(this.gridX, this.gridY, this._statistics.clone(), this._worldUnitsPerCell);
    return t12._count = this._count, t12._xWorldTotal = this._xWorldTotal, t12._yWorldTotal = this._yWorldTotal, t12._firstFeatureAttributes = this._firstFeatureAttributes, t12._objectIds = new Set(this._objectIds), t12;
  }
  insert(t12, r11, e10, s17) {
    0 === this._count ? this._firstFeatureAttributes = t12.readAttributes() : this._firstFeatureAttributes = null, this._count += 1, this._xWorldTotal += e10, this._yWorldTotal += s17, this._statistics.insert(t12, r11), this._objectIds.add(t12.getObjectId());
  }
  merge(t12) {
    if (0 !== t12._count) {
      this._count += t12._count, this._firstFeatureAttributes = t12._firstFeatureAttributes, this._xWorldTotal += t12._xWorldTotal, this._yWorldTotal += t12._yWorldTotal, this._statistics.merge(t12._statistics);
      for (const r11 of t12._objectIds.values())
        this._objectIds.add(r11);
    }
  }
  getCentroidX(r11) {
    return null == r11 ? this.centroidXWorld : N(r11, this.centroidXWorld);
  }
  getCentroidY(t12) {
    return null == t12 ? this.centroidYWorld : w(t12, this.centroidYWorld);
  }
  getCentroid(t12) {
    const r11 = new e2([], [this.centroidXWorld, this.centroidYWorld]);
    if (null != t12) {
      const i10 = new e2();
      return at(i10, r11, false, false, "esriGeometryPoint", t12);
    }
    return r11;
  }
  getGeometricCentroid(t12) {
    const r11 = this.gridX * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, i10 = this.gridY * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, o18 = new e2([], [r11, i10]);
    if (null != t12) {
      const r12 = new e2();
      return at(r12, o18, false, false, "esriGeometryPoint", t12);
    }
    return o18;
  }
  getAttributes() {
    const t12 = { aggregateId: this.id };
    for (const r11 of this._statistics.values())
      t12[r11.field.name] = r11.value;
    return null != this._firstFeatureAttributes ? { ...t12, ...this._firstFeatureAttributes } : t12;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridSpatialIndex.js
var o11 = 96;
function l3(i10, s17) {
  return W(i10) * o3 * o11 / s17;
}
var r5 = class {
  constructor(e10) {
    this._options = e10, this._cells = /* @__PURE__ */ new Map(), this._pixelsPerMapUnit = l3(e10.spatialReference, e10.scale);
  }
  insert(e10, t12) {
    const i10 = e10.getCursor(), s17 = { $view: { scale: this._options.scale, timeZone: this._options.timeZone } };
    for (; i10.next(); )
      this._insertFeature(i10, s17, t12);
  }
  putCellsInBounds(e10, t12) {
    const [i10, s17, o18, l7] = t12, r11 = Math.floor(i10 * this._pixelsPerMapUnit / this._options.cellSize), n16 = Math.floor(s17 * this._pixelsPerMapUnit / this._options.cellSize), c10 = Math.ceil(o18 * this._pixelsPerMapUnit / this._options.cellSize), p7 = Math.ceil(l7 * this._pixelsPerMapUnit / this._options.cellSize);
    for (let a14 = n16; a14 <= p7; a14++)
      for (let t13 = r11; t13 <= c10; t13++) {
        const i11 = `${t13}.${a14}`, s18 = this._cells.get(i11);
        if (!s18)
          continue;
        const o19 = e10.get(s18.id);
        o19 ? s18 && !e10.has(s18.id) && o19.merge(s18) : e10.set(s18.id, s18.clone());
      }
  }
  putCells(e10) {
    for (const t12 of this._cells.values()) {
      const i10 = e10.get(t12.id);
      i10 ? i10.merge(t12) : e10.set(t12.id, t12.clone());
    }
  }
  _insertFeature(e10, t12, s17) {
    const { featureFilter: o18 } = this._options;
    if (null !== o18 && !o18.check(e10))
      return;
    let l7 = 0, r11 = 0;
    if ("esriGeometryPoint" === e10.geometryType)
      l7 = e10.readXWorldSpace(), r11 = e10.readYWorldSpace();
    else {
      if (s17) {
        const t14 = e10.readCentroidForDisplay();
        if (null == t14)
          return;
        const [s18, o19] = t14.coords;
        if (s18 < 0 || s18 > a2 || o19 < 0 || o19 > a2)
          return;
      }
      const t13 = e10.readCentroidWorldSpace();
      if (null == t13)
        return;
      l7 = t13.coords[0], r11 = t13.coords[1];
    }
    const n16 = l7 * this._pixelsPerMapUnit, c10 = r11 * this._pixelsPerMapUnit, p7 = Math.floor(n16 / this._options.cellSize), a14 = Math.floor(c10 / this._options.cellSize);
    this._getCellOrCreate(p7, a14).insert(e10, t12, l7, r11);
  }
  _getCellOrCreate(e10, t12) {
    const i10 = o10.createId(e10, t12);
    let o18 = this._cells.get(i10);
    if (!o18) {
      const l7 = 1 * this._options.cellSize / this._pixelsPerMapUnit;
      o18 = o10.create(e10, t12, this._options.fields, l7), this._cells.set(i10, o18);
    }
    return o18;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/support/WithDisplayId.js
var s13 = class {
  constructor(s17, t12) {
    this.inner = s17, this.displayId = t12;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/ClusterStrategy.js
var _3 = 128;
var m4 = class extends t5 {
  constructor(e10) {
    super(e10), this.didSend = false, this.done = false;
  }
};
var y5 = class {
  constructor(e10, t12, s17, i10, r11) {
    this._level = e10, this._scale = t12, this._indexOptions = s17, this._clusterRadius = i10, this._store = r11, this._cells = /* @__PURE__ */ new Map(), this._handledChunks = /* @__PURE__ */ new Set(), this._statistics = /* @__PURE__ */ new Map(), this._clusters = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._clearClusters();
  }
  _clearClusters() {
    for (const e10 of this._clusters.values())
      this._store.releaseDisplayIdForObjectId(e10.inner.id);
    this._clusters.clear();
  }
  *aggregatesWorldSpace() {
    for (const e10 of this._clusters.values()) {
      const s17 = e10.inner.getCentroid(null), i10 = new t3(s17, e10.inner.getAttributes(), null);
      i10.objectId = e10.inner.id, i10.displayId = e10.displayId, yield i10;
    }
  }
  clusters() {
    return this._clusters.values();
  }
  updateChunks(e10, t12) {
    let s17 = false;
    for (const a14 of e10) {
      const e11 = a14.queryInfo;
      if ("tileId" in e11) {
        if (new e3(e11.tileId).level !== this._level)
          continue;
      }
      if (!this._handledChunks.has(a14.normalizedChunkId)) {
        this._handledChunks.add(a14.normalizedChunkId), s17 = true;
        a14.getGridIndex({ ...this._indexOptions, scale: this._scale }).putCells(this._cells);
      }
    }
    const i10 = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 }, r11 = l3(this._indexOptions.spatialReference, this._scale), n16 = this._indexOptions.cellSize;
    for (const { subscription: a14 } of t12) {
      const e11 = a14.tile.bounds, t13 = Math.floor(e11[0] * r11 / n16), s18 = Math.floor(e11[1] * r11 / n16), l7 = Math.ceil(e11[2] * r11 / n16), o18 = Math.ceil(e11[3] * r11 / n16);
      i10.xMin = Math.min(i10.xMin, t13), i10.yMin = Math.min(i10.yMin, s18), i10.xMax = Math.max(i10.xMax, l7), i10.yMax = Math.max(i10.yMax, o18);
    }
    return null != this._lastCellBounds && i10.xMin === this._lastCellBounds.xMin && i10.yMin === this._lastCellBounds.yMin && i10.yMin === this._lastCellBounds.yMin && i10.yMax === this._lastCellBounds.yMax || (s17 = true, this._lastCellBounds = i10), s17 && this._clusterCells(i10), s17;
  }
  async updateStatistics(e10) {
    let t12 = false;
    for (const s17 of this._clusters.values())
      s17.inner.count > 1 && (t12 = this._updateAggregateStatistics(this._statistics, s17.inner) || t12);
    if (t12) {
      const t13 = Array.from(this._statistics.entries()).map(([e11, t14]) => ({ fieldName: e11, minValue: t14.minValue, maxValue: t14.maxValue }));
      await e10.container.updateStatistics(this._level, t13);
    }
  }
  createAggregateFeatures(e10, r11) {
    const n16 = e10.subscription, a14 = [], l7 = n16.tile.transform;
    for (const o18 of this._clusters.values()) {
      let e11 = o18.inner.getCentroidX(l7);
      const r12 = o18.inner.getCentroidY(l7), d9 = n16.tile.lod, c10 = d9.wrap ? d9.worldSize[0] : null, u7 = 1 === o18.inner.count ? o18.inner.firstObjectId : o18.inner.id, h6 = o18.displayId;
      if (null != c10)
        if (1 === c10) {
          const n17 = new e2([], [e11, r12]), l8 = new t3(n17, o18.inner.getAttributes(), null);
          l8.geometry.coords[0] -= a2, l8.objectId = u7, l8.displayId = h6, a14.push(l8);
          const d10 = new e2([], [e11, r12]), c11 = new t3(d10, o18.inner.getAttributes(), null);
          c11.geometry.coords[0] += a2, c11.objectId = u7, c11.displayId = h6, a14.push(c11);
        } else
          e11 > a2 + a2 / 2 ? e11 -= c10 * a2 : e11 < -a2 / 2 && (e11 += c10 * a2);
      if (e11 < a2 + _3 && e11 >= -_3 && r12 < a2 + _3 && r12 >= -_3) {
        const i10 = new e2([], [e11, r12]), n17 = new t3(i10, o18.inner.getAttributes(), null);
        n17.objectId = u7, n17.displayId = h6, a14.push(n17);
      }
    }
    return u4.fromOptimizedFeatures(a14, r11, n16.tile.transform);
  }
  _clusterCells(e10) {
    let t12 = Array.from(this._cells.values());
    t12 = t12.sort((e11, t13) => t13.count - e11.count);
    const s17 = [];
    for (const n16 of this._clusters.values())
      s17.push(n16.inner.id);
    this._clusters.clear();
    const i10 = this._clusterRadius * (1 / l3(this._indexOptions.spatialReference, this._scale)), r11 = 1 + this._clusterRadius / this._indexOptions.cellSize, l7 = /* @__PURE__ */ new Set();
    for (const a14 of t12) {
      if (l7.has(a14.id))
        continue;
      if (a14.gridX < e10.xMin || a14.gridX > e10.xMax || a14.gridY < e10.yMin || a14.gridY > e10.yMax)
        continue;
      const t13 = this._store.createDisplayIdForObjectId(a14.id), s18 = new s13(a14.clone(), t13);
      l7.add(a14.id), this._clusters.set(a14.id, s18);
      const o18 = a14.centroidXWorld, c10 = a14.centroidYWorld;
      for (let e11 = a14.gridY - r11; e11 <= a14.gridY + r11; e11++)
        for (let t14 = a14.gridX - r11; t14 <= a14.gridX + r11; t14++) {
          if (e11 === a14.gridY && t14 === a14.gridX)
            continue;
          const r12 = this._cells.get(o10.createId(t14, e11));
          if (!r12 || l7.has(r12.id))
            continue;
          const d9 = Math.abs(r12.centroidXWorld - o18), u7 = Math.abs(r12.centroidYWorld - c10);
          d9 < i10 && u7 < i10 && (s18.inner.merge(r12), l7.add(r12.id));
        }
    }
    for (const n16 of s17)
      this._store.releaseDisplayIdForObjectId(n16);
  }
  _updateAggregateStatistics(e10, t12) {
    let s17 = false;
    for (const i10 of t12.statistics.values()) {
      if ("esriFieldTypeString" === i10.field.type)
        continue;
      const t13 = i10.value, r11 = i10.field, n16 = e10.get(r11.name);
      if (n16) {
        const { minValue: e11, maxValue: i11 } = n16, r12 = Math.min(n16.minValue, t13), a14 = Math.max(n16.maxValue, t13);
        e11 === r12 && i11 === a14 || (n16.minValue = r12, n16.maxValue = a14, s17 = true);
      } else
        e10.set(r11.name, { minValue: t13, maxValue: t13 }), s17 = true;
    }
    return s17;
  }
};
var S4 = class _S extends i6 {
  static async create(e10, t12, s17, i10, n16, a14) {
    const l7 = new p2({ spatialReference: s17 }), o18 = { fields: await Promise.all(t12.fields.map(async (e11) => s11.create(l7, e11))), spatialReference: s17, featureFilter: t12.featureFilter ? await p3.create({ geometryType: i10.metadata.geometryType, hasM: false, hasZ: false, timeInfo: i10.metadata.timeInfo, fieldsIndex: i10.metadata.fieldsIndex, spatialReference: s17, filterJSON: t12.featureFilter }) : null, cellSize: t12.clusterRadius / 4, timeZone: a14 };
    return new _S(e10, t12.clusterRadius, o18, t12.fields, i10, n16);
  }
  constructor(e10, t12, s17, i10, r11, n16) {
    super(r11, n16, s17.spatialReference, s17.fields), this._connection = e10, this._clusterRadius = t12, this._indexOptions = s17, this._cellsPerScale = /* @__PURE__ */ new Map(), this._metadata = new i3({ geometryType: "esriGeometryPoint", objectIdField: "aggregateId", fields: [...i10, ...this._source.metadata.fieldsIndex.fields, { name: "aggregateId", alias: "aggregateId", type: "esriFieldTypeOID" }], globalIdField: null, spatialReference: r11.metadata.spatialReference, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, typeIdField: null, types: null });
  }
  get enablePixelBuffering() {
    return false;
  }
  invalidate() {
    super.invalidate();
    for (const e10 of this._cellsPerScale.values())
      e10.destroy();
    this._cellsPerScale.clear();
  }
  onSubscribe(e10) {
    super.onSubscribe(e10), this._requiredLevel = e10.tile.level, this._requiredScale = e10.tile.scale;
  }
  createState(e10) {
    return new m4(e10);
  }
  async *applyOverride(e10) {
    for (const t12 of this._cellsPerScale.values())
      t12.destroy();
    this._cellsPerScale.clear();
    for (const t12 of this._sendStates.values())
      t12.done = false;
  }
  displayMap(e10, t12, s17) {
    const i10 = new Map(e10.map((e11) => [t12(e11), e11])), r11 = [], n16 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const a14 of n16.clusters()) {
      const e11 = i10.get(a14.inner.id);
      if (null == e11) {
        if (1 === a14.inner.count) {
          const e12 = i10.get(a14.inner.firstObjectId);
          if (null != e12) {
            const t13 = s17(a14.displayId, e12, a14.inner.firstObjectId);
            r11.push(t13), i10.delete(a14.inner.firstObjectId);
          }
        }
      } else {
        const t13 = s17(a14.displayId, e11, a14.inner.id);
        r11.push(t13), i10.delete(a14.inner.id);
      }
    }
    return r11;
  }
  getDisplayFeatures(t12) {
    const s17 = new Set(t12), i10 = /* @__PURE__ */ new Set(), r11 = [], n16 = [], a14 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const l7 of a14.aggregatesWorldSpace())
      if (s17.has(l7.displayId) && !i10.has(l7.displayId)) {
        const t13 = nt(l7, this._metadata.geometryType, false, false);
        if (i10.add(l7.displayId), 1 === t13.attributes.cluster_count) {
          r11.push({ ...t13, displayId: l7.displayId });
          continue;
        }
        n16.push({ ...t13, displayId: l7.displayId });
      }
    return { features: r11, aggregates: n16 };
  }
  getFeatureObjectIdsForAggregate(e10) {
    const t12 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s17 of t12.clusters())
      if (s17.inner.id === e10)
        return Array.from(s17.inner.objectIds);
    return [];
  }
  async *updateChunks() {
    const e10 = this._source.chunks();
    if (!e10.length)
      return;
    const t12 = this._getClusterState(this._requiredLevel, this._requiredScale), s17 = Array.from(this._sendStates.values()).filter((e11) => e11.subscription.tile.level === this._requiredLevel);
    if (t12.updateChunks(e10, s17) || !this._source.updateTracking.updating)
      for (const n16 of s17)
        n16.subscription.tile.level === this._requiredLevel && (n16.didSend = false, n16.done = false);
    const i10 = Array.from(this._sendStates.values()).filter((e11) => e11.done).map((e11) => e11.subscription.tile.key), r11 = new Set(i10);
    for (const n16 of this._sendStates.values()) {
      if (this._source.updateTracking.updating) {
        if (i10.some((e11) => e11.containsChild(n16.subscription.tile.key)))
          continue;
        if (n16.subscription.tile.key.getChildKeys().every((e11) => r11.has(e11)))
          continue;
      }
      n16.didSend || n16.subscription.tile.level !== this._requiredLevel || (n16.didSend = true, yield* this._update(n16, t12, this._source));
    }
    await t12.updateStatistics(this._connection);
  }
  forEachAggregateWorldSpace(e10) {
    if (null == this._requiredLevel || null == this._requiredScale)
      return;
    const t12 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s17 of t12.aggregatesWorldSpace())
      e10(s17);
  }
  _getClusterState(e10, t12) {
    if (null == e10 || null == t12)
      throw new Error("InternalError: Level and scale must be defined");
    let s17 = this._cellsPerScale.get(t12);
    return s17 || (s17 = new y5(e10, t12, this._indexOptions, this._clusterRadius, this._attributeStore), this._cellsPerScale.set(t12, s17)), s17;
  }
  async *_update(e10, t12, s17) {
    if (e10.done)
      return;
    const i10 = t12.createAggregateFeatures(e10, this._metadata);
    this.events.emit("changed"), e10.done = !s17.updateTracking.updating;
    const r11 = i10.getCursor(), n16 = e10.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.timeZone);
    for (; r11.next(); )
      this._attributeStore.setAttributeData(r11.getDisplayId(), r11, n16);
    const a14 = new e8(e10.subscription, i10, true, e10.done, {});
    yield a14;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureSpatialIndex.js
var t6 = class _t {
  static fromReader(o18) {
    const e10 = [], r11 = o18.copy(), a14 = i();
    for (; r11.next(); ) {
      r11.getBounds(a14) && e10.push(r11.getIndex());
    }
    const i10 = i4(9, (n16) => (r11.setIndex(n16), { minX: r11.getBoundsXMin(), minY: r11.getBoundsYMin(), maxX: r11.getBoundsXMax(), maxY: r11.getBoundsYMax() }));
    return i10.load(e10), new _t(i10);
  }
  constructor(n16) {
    this._index = n16;
  }
  search(n16) {
    const s17 = { minX: n16[0], minY: n16[1], maxX: n16[2], maxY: n16[3] };
    return this._index.search(s17);
  }
};

// node_modules/@arcgis/core/geohash/GeohashTree.js
var a6 = class _a {
  static create(t12, e10, s17, o18) {
    const i10 = s12.create(t12), r11 = new Array(32);
    for (let h6 = 0; h6 < r11.length; h6++)
      r11[h6] = null;
    return new _a(i10, e10, s17, o18, r11);
  }
  constructor(t12, e10, s17, o18, i10) {
    this._statistics = t12, this.xNode = e10, this.yNode = s17, this.depth = o18, this.children = i10, this._objectIds = /* @__PURE__ */ new Set(), this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._xGeohashTotal = 0, this._yGeohashTotal = 0, this.next = null;
  }
  get id() {
    return `${this.xNode}.${this.yNode}`;
  }
  get objectIds() {
    return this._objectIds;
  }
  clone() {
    const t12 = new _a(this._statistics.clone(), this.xNode, this.yNode, this.depth, this.children);
    return t12._count = this._count, t12._xWorldTotal = this._xWorldTotal, t12._yWorldTotal = this._yWorldTotal, t12._xGeohashTotal = this._xGeohashTotal, t12._yGeohashTotal = this._yGeohashTotal, t12.next = this.next, t12.cachedFeature = this.cachedFeature, t12._objectIds = new Set(this._objectIds), t12;
  }
  insert(t12, e10, s17, o18, i10, r11) {
    this._count += 1, this._xWorldTotal += e10, this._yWorldTotal += s17, this._xGeohashTotal += o18, this._yGeohashTotal += i10, this._statistics.insert(t12, r11), this._objectIds.add(t12.getObjectId());
  }
  merge(t12) {
    if (0 !== t12._count) {
      this._count += t12._count, this._xWorldTotal += t12._xWorldTotal, this._yWorldTotal += t12._yWorldTotal, this._xGeohashTotal += t12._xWorldTotal, this._yGeohashTotal += t12._yWorldTotal, this._statistics.merge(t12._statistics);
      for (const e10 of t12._objectIds.values())
        this._objectIds.add(e10);
    }
  }
  getGeometry(t12, i10) {
    const n16 = this._getLngLatBounds(), [a14, l7, c10, d9] = n16, _6 = j2({ rings: [[[a14, l7], [a14, d9], [c10, d9], [c10, l7], [a14, l7]]] }, f2.WGS84, t12), u7 = K(new e2(), _6, false, false);
    if (null != i10) {
      return at(new e2(), u7, false, false, "esriGeometryPolygon", i10, false, false);
    }
    return u7;
  }
  getGeometryCentroid(t12, s17) {
    const n16 = this._getLngLatBounds(), [a14, l7, c10, d9] = n16, _6 = j2({ x: (a14 + c10) / 2, y: (l7 + d9) / 2 }, f2.WGS84, t12), u7 = O(new e2(), _6);
    if (null != s17) {
      return at(new e2(), u7, false, false, "esriGeometryPoint", s17, false, false);
    }
    return u7;
  }
  getAttributes() {
    const t12 = { aggregateId: this.id };
    for (const e10 of this._statistics.values())
      t12[e10.field.name] = e10.value;
    return t12.aggregateCount = this._count, t12;
  }
  _getLngLatBounds() {
    const e10 = this.depth, s17 = Math.ceil(e10 / 2), o18 = Math.floor(e10 / 2), i10 = 30 - (3 * s17 + 2 * o18), r11 = 30 - (2 * s17 + 3 * o18), h6 = this.xNode << i10, n16 = this.yNode << r11;
    return R({ geohashX: h6, geohashY: n16 }, this.depth);
  }
};
var l4 = class {
  constructor(t12) {
    this._fields = t12, this._root = a6.create(this._fields, 0, 0, 0);
  }
  destroy() {
  }
  insert(t12, e10, s17, o18, i10, r11, h6) {
    let n16 = this._root, l7 = 0, c10 = 0, d9 = 0;
    for (; null !== n16; ) {
      if (n16.insert(t12, e10, s17, o18, i10, h6), l7 >= r11)
        return;
      const _6 = Math.ceil((l7 + 1) / 2), u7 = Math.floor((l7 + 1) / 2), g4 = 1 - l7 % 2, x2 = 30 - (3 * _6 + 2 * u7), y8 = 30 - (2 * _6 + 3 * u7), f7 = (o18 & 7 * g4 + 3 * (1 - g4) << x2) >> x2, m7 = (i10 & 3 * g4 + 7 * (1 - g4) << y8) >> y8, T = f7 + m7 * (8 * g4 + 4 * (1 - g4));
      c10 = c10 << 3 * g4 + 2 * (1 - g4) | f7, d9 = d9 << 2 * g4 + 3 * (1 - g4) | m7, null == n16.children[T] && (n16.children[T] = a6.create(this._fields, c10, d9, l7 + 1)), l7 += 1, n16 = n16.children[T];
    }
  }
  putBins(t12, e10) {
    for (const s17 of this.getNodes(e10)) {
      const e11 = t12.get(s17.id);
      e11 ? e11.merge(s17) : t12.set(s17.id, s17.clone());
    }
  }
  getNodes(t12) {
    const e10 = [], { geohashBounds: s17, level: o18 } = t12;
    let i10 = this._root;
    for (; null !== i10; ) {
      const t13 = i10.depth, r11 = i10.xNode, h6 = i10.yNode;
      if (t13 >= o18) {
        e10.push(i10), i10 = i10.next;
        continue;
      }
      const n16 = Math.ceil((t13 + 1) / 2), a14 = Math.floor((t13 + 1) / 2), l7 = 1 - t13 % 2, c10 = 30 - (3 * n16 + 2 * a14), d9 = 30 - (2 * n16 + 3 * a14), _6 = ~((1 << c10) - 1), u7 = ~((1 << d9) - 1), g4 = (s17.xLL & _6) >> c10, x2 = (s17.yLL & u7) >> d9, y8 = (s17.xTR & _6) >> c10, f7 = (s17.yTR & u7) >> d9, m7 = r11 << 3 * l7 + 2 * (1 - l7), T = h6 << 2 * l7 + 3 * (1 - l7), p7 = m7 + 8 * l7 + 4 * (1 - l7), G = T + 4 * l7 + 8 * (1 - l7), j3 = Math.max(m7, g4), W2 = Math.max(T, x2), N2 = Math.min(p7, y8), b5 = Math.min(G, f7);
      let w3 = null, I2 = null;
      for (let e11 = W2; e11 <= b5; e11++)
        for (let t14 = j3; t14 <= N2; t14++) {
          const s18 = t14 - m7 + (e11 - T) * (8 * l7 + 4 * (1 - l7)), o19 = i10.children[s18];
          o19 && (w3 || (w3 = o19, w3.next = i10.next), I2 && (I2.next = o19), I2 = o19, o19.next = i10.next);
        }
      i10 = w3 || i10.next;
    }
    return e10;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GeohashSpatialIndex.js
var o12 = class {
  constructor(t12) {
    this._options = t12, this._tree = new l4(t12.fields);
  }
  insert(e10, t12) {
    const r11 = e10.getCursor(), o18 = { $view: { scale: 0, timeZone: this._options.timeZone } };
    for (; r11.next(); )
      this._insertFeature(r11, o18, t12);
  }
  putBins(e10, t12) {
    this._tree.putBins(e10, t12);
  }
  _insertFeature(e10, o18, s17) {
    const { featureFilter: i10, geohashLevel: n16, spatialReference: a14 } = this._options;
    if (null !== i10 && !i10.check(e10))
      return;
    let l7 = 0, c10 = 0;
    if ("esriGeometryPoint" === e10.geometryType)
      l7 = e10.readXWorldSpace(), c10 = e10.readYWorldSpace();
    else {
      if (s17) {
        const t13 = e10.readCentroidForDisplay();
        if (null == t13)
          return;
        const [o19, s18] = t13.coords;
        if (o19 < 0 || o19 > a2 || s18 < 0 || s18 > a2)
          return;
      }
      const t12 = e10.readCentroidWorldSpace();
      if (null == t12)
        return;
      l7 = t12.coords[0], c10 = t12.coords[1];
    }
    const h6 = A(l7, c10, n16, a14);
    h6 && this._tree.insert(e10, l7, c10, h6[0], h6[1], n16, o18);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderIndirect.js
var a7 = class _a extends M {
  static from(e10, r11) {
    return new _a(e10.copy(), r11);
  }
  constructor(e10, r11) {
    super(e10.metadata), this._currentIndex = -1, this._displayTranslationX = 0, this._displayTranslationY = 0, this._displayScaleX = 1, this._displayScaleY = 1, this._reader = e10, this._indices = r11, this._isPoint = "esriGeometryPoint" === e10.geometryType;
  }
  setTransformForDisplay(e10) {
    const r11 = this._reader.getInTransform();
    if (null == r11) {
      const [r12, t13] = e10.scale, [s18, a15] = e10.translate;
      return this._displayTranslationX = -s18 / r12, this._displayScaleX = 1 / r12, this._displayTranslationY = a15 / t13, this._displayScaleY = 1 / -t13, void (this._displayTransform = e10);
    }
    const [t12, s17] = r11.scale, [a14, i10] = r11.translate, [d9, n16] = e10.scale, [o18, l7] = e10.translate;
    if (this._displayScaleX = t12 / d9, this._displayTranslationX = (a14 - o18) / d9, this._displayScaleY = s17 / n16, this._displayTranslationY = (-i10 + l7) / n16, !this._isPoint && r11)
      throw new Error("InternalError: Relative transformations not supported for non-point features");
    this._displayTransform = e10;
  }
  getInTransform() {
    return this._reader.getInTransform();
  }
  get fields() {
    return this._reader.fields;
  }
  get hasNext() {
    return this._currentIndex + 1 < this._indices.length;
  }
  getSize() {
    return this._indices.length;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const e10 = new _a(this._reader.copy(), this._indices);
    return e10._currentIndex = this._currentIndex, e10._displayTransform = this._displayTransform, e10._displayTranslationX = this._displayTranslationX, e10._displayTranslationY = this._displayTranslationY, e10._displayScaleX = this._displayScaleX, e10._displayScaleY = this._displayScaleY, e10;
  }
  get contextTimeZone() {
    return this._reader.contextTimeZone;
  }
  set contextTimeZone(e10) {
    this._reader.contextTimeZone = e10;
  }
  _nextIndex() {
    return ++this._currentIndex < this._indices.length && (this._reader.setIndex(this._indices[this._currentIndex]), true);
  }
  next() {
    for (; this._nextIndex() && !this._reader._getExists(); )
      ;
    return this._currentIndex < this._indices.length;
  }
  readXForDisplay() {
    return this._reader.readXForDisplay() * this._displayScaleX + this._displayTranslationX;
  }
  readYForDisplay() {
    return this._reader.readYForDisplay() * this._displayScaleY + this._displayTranslationY;
  }
  readGeometryForDisplay() {
    const r11 = this._reader.readGeometryForDisplay();
    if (!this._displayTransform)
      return r11;
    const s17 = new e2();
    return at(s17, r11, this.hasZ, this.hasM, this.geometryType, this._displayTransform), s17.deltaDecode();
  }
  readCentroidForDisplay() {
    var _a2;
    const e10 = (_a2 = this._reader.readCentroidForDisplay()) == null ? void 0 : _a2.clone();
    if (e10) {
      const [r11, t12] = e10.coords;
      e10.coords[0] = r11 * this._displayScaleX + this._displayTranslationX, e10.coords[1] = t12 * this._displayScaleY + this._displayTranslationY;
    }
    return e10;
  }
  get geometryType() {
    return this._reader.geometryType;
  }
  get hasFeatures() {
    return this._reader.hasFeatures;
  }
  get exceededTransferLimit() {
    return this._reader.exceededTransferLimit;
  }
  get hasZ() {
    return this._reader.hasZ;
  }
  get hasM() {
    return this._reader.hasM;
  }
  readAttribute(e10, r11 = false) {
    return this._reader.readAttribute(e10, r11);
  }
  readAttributes() {
    return this._reader.readAttributes();
  }
  joinAttributes(e10) {
    return this._reader.joinAttributes(e10);
  }
  getBounds(e10) {
    return this._reader.getBounds(e10);
  }
  getAttributeHash() {
    return this._reader.getAttributeHash();
  }
  getObjectId() {
    return this._reader.getObjectId();
  }
  getDisplayId() {
    return this._reader.getDisplayId();
  }
  setDisplayId(e10) {
    return this._reader.setDisplayId(e10);
  }
  setIndex(e10) {
    return this._reader.setIndex(e10);
  }
  getIndex() {
    return this._reader.getIndex();
  }
  readXWorldSpace() {
    return this._reader.readXWorldSpace();
  }
  readYWorldSpace() {
    return this._reader.readYWorldSpace();
  }
  _readX() {
    return this._reader.readXForDisplay();
  }
  _readY() {
    return this._reader.readYForDisplay();
  }
  _readServerCentroid() {
    return this._reader._readServerCentroid();
  }
  readLegacyFeatureForDisplay() {
    const e10 = this.readCentroidForDisplay();
    return { attributes: this.readAttributes(), geometry: this.readLegacyGeometryForDisplay(), centroid: (e10 && { x: e10.coords[0], y: e10.coords[1] }) ?? null };
  }
  readLegacyGeometryForDisplay() {
    const e10 = this.readGeometryForDisplay();
    return rt(e10, this.geometryType, false, false);
  }
  readGeometryArea() {
    return this._reader.readGeometryArea();
  }
  readGeometryWorldSpace() {
    return this._reader.readGeometryWorldSpace();
  }
  _readGeometry() {
    return this._reader._readGeometry();
  }
  _readAttribute(e10, r11) {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  _readAttributes() {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  readArcadeFeature() {
    return this._reader.readArcadeFeature();
  }
  geometry() {
    return this._reader.geometry();
  }
  field(e10) {
    return this.readAttribute(e10, true);
  }
  hasField(e10) {
    return this._reader.hasField(e10);
  }
  setField(e10, r11) {
    return this._reader.setField(e10, r11);
  }
  keys() {
    return this._reader.keys();
  }
  castToText(e10 = false) {
    return this._reader.castToText(e10);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/ASourceChunk.js
var r6 = class {
  size() {
    return this.reader.getSize();
  }
  get fields() {
    return this.reader.fields;
  }
  invalidate() {
    this._geohashIndex = null, this._geohashIndexHash = null, this._spatialIndex = null, this._gridIndex = null, this._gridIndexHash = null;
  }
  queryFeaturesInBounds(e10) {
    const t12 = this._getSpatialIndex().search(e10);
    return a7.from(this.reader, t12);
  }
  getGeohashIndex(e10) {
    const i10 = JSON.stringify(e10);
    return i10 !== this._geohashIndexHash && (this._geohashIndexHash = i10, this._geohashIndex = new o12(e10), this._geohashIndex.insert(this.reader, this.isTiled)), this._geohashIndex;
  }
  getGridIndex(e10) {
    const t12 = JSON.stringify(e10);
    return t12 !== this._gridIndexHash && (this._gridIndexHash = t12, this._gridIndex = new r5(e10), this._gridIndex.insert(this.reader, this.isTiled)), this._gridIndex;
  }
  _getSpatialIndex() {
    return this._spatialIndex || (this._spatialIndex = t6.fromReader(this.reader)), this._spatialIndex;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/OverrideChunk.js
var t7 = class extends r6 {
  constructor(e10) {
    super(), this.metadata = e10, this.chunkId = "override", this.normalizedChunkId = "override", this.removed = /* @__PURE__ */ new Set(), this.overriddenIds = /* @__PURE__ */ new Set(), this._features = [];
  }
  get reader() {
    return u4.fromOptimizedFeatures(this._features, this.metadata);
  }
  get queryInfo() {
    return {};
  }
  get first() {
    return false;
  }
  get end() {
    return false;
  }
  get isTiled() {
    return false;
  }
  applyOverrides(e10) {
    super.invalidate();
    const { reader: r11, removed: t12 } = e10, s17 = [], d9 = /* @__PURE__ */ new Set(), o18 = r11.getCursor(), i10 = new Set(t12);
    for (this.overriddenIds.clear(); o18.next(); ) {
      const e11 = o18.readOptimizedFeatureWorldSpace(), r12 = e11.objectId;
      s17.push(e11), d9.add(r12), this.overriddenIds.add(r12), this.removed.delete(r12);
    }
    for (const n16 of this._features) {
      const e11 = n16.objectId;
      i10.has(e11) || d9.has(e11) || (s17.push(n16), this.overriddenIds.add(e11));
    }
    this._features = s17;
    for (const n16 of d9.values())
      this.removed.delete(n16);
    for (const n16 of t12)
      this.removed.add(n16), this.overriddenIds.add(n16);
  }
  getTileReader(e10) {
    if (!this._features.length)
      return null;
    const r11 = this.queryFeaturesInBounds(e10.bounds);
    return r11.setTransformForDisplay(e10.transform), r11;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/FeatureUpdateStrategy.js
var a8 = class extends t5 {
};
var o13 = class extends e7 {
  constructor(e10, t12, s17) {
    super(e10, t12), this._timeZone = s17, this.handledChunks = /* @__PURE__ */ new Set(), this.handledChunksForIdCreation = /* @__PURE__ */ new Set(), this.handledChunksForAttributeData = /* @__PURE__ */ new Set(), this._streamLayerDeferredObjectIdsToRemove = [];
  }
  destroy() {
    super.destroy();
    for (const e10 of this._source.chunks())
      this._cleanupChunkIds(e10);
  }
  invalidateAttributeData() {
    this.handledChunksForAttributeData.clear();
  }
  onSubscribe(e10) {
    super.onSubscribe(e10), this._evalOptions = e10.tile.createArcadeEvaluationOptions(this._timeZone);
  }
  createState(e10) {
    return new a8(e10);
  }
  get aggregateQueryEngine() {
    return null;
  }
  displayMap(e10, t12, s17) {
    const r11 = new Map(e10.map((e11) => [t12(e11), e11])), n16 = [];
    for (const a14 of this._source.chunks()) {
      const e11 = a14.reader.getCursor();
      for (; e11.next(); ) {
        const t13 = e11.getObjectId(), a15 = e11.getDisplayId(), o18 = r11.get(t13);
        if (null != o18) {
          const e12 = s17(a15, o18, t13);
          n16.push(e12), r11.delete(t13);
        }
      }
    }
    return n16;
  }
  getDisplayFeatures(e10) {
    const t12 = new Set(e10), s17 = /* @__PURE__ */ new Set(), r11 = [];
    for (const n16 of this._source.chunks()) {
      const e11 = n16.reader.getCursor();
      for (; e11.next(); ) {
        const n17 = e11.getObjectId(), a14 = e11.getDisplayId();
        t12.has(a14) && !s17.has(n17) && (r11.push({ ...e11.readLegacyFeatureWorldSpace(), displayId: a14 }), s17.add(n17));
      }
    }
    return { features: r11, aggregates: [] };
  }
  async *applyOverride(e10) {
    const t12 = [], r11 = e10.reader.getCursor();
    for (; r11.next(); ) {
      const e11 = r11.getObjectId();
      t12.push(e11);
      const s17 = this._attributeStore.createDisplayIdForObjectId(e11);
      r11.setDisplayId(s17), this._attributeStore.setAttributeData(s17, r11, this._evalOptions);
    }
    const a14 = this.getDisplayIds(t12), o18 = this.getDisplayIds(e10.removed), d9 = new t7(this._source.metadata);
    d9.applyOverrides(e10), this.handledChunks.add(d9.chunkId), this.handledChunksForAttributeData.add(d9.chunkId), this.handledChunksForIdCreation.add(d9.chunkId);
    for (const n16 of this._sendStates.values())
      n16.handledChunks.add(d9.chunkId), yield new i7(n16.subscription, null, a14, false, d9.queryInfo);
    for (const n16 of this._sendStates.values()) {
      const e11 = d9.getTileReader(n16.subscription.tile);
      yield new i7(n16.subscription, e11, o18, false, d9.queryInfo);
    }
    for (const s17 of e10.removed)
      this._attributeStore.releaseDisplayIdForObjectId(s17);
  }
  async *updateChunks() {
    if (this._source.chunks().length) {
      await this._updateAttributeData();
      for (const e10 of this._sendStates.values())
        yield* this._update(e10);
    }
  }
  removeChunks(e10) {
    for (const t12 of e10)
      this.handledChunks.delete(t12.chunkId), this.handledChunksForAttributeData.delete(t12.chunkId), this._cleanupChunkIds(t12);
  }
  afterUpdateChunks() {
    for (const e10 of this._streamLayerDeferredObjectIdsToRemove)
      this._attributeStore.releaseDisplayIdForObjectId(e10);
    this._streamLayerDeferredObjectIdsToRemove = [];
  }
  _cleanupChunkIds(e10) {
    if (this.handledChunksForIdCreation.has(e10.chunkId)) {
      const t12 = e10.reader.getCursor();
      for (; t12.next(); ) {
        const e11 = t12.getObjectId();
        this._source.isStream ? this._streamLayerDeferredObjectIdsToRemove.push(e11) : this._attributeStore.releaseDisplayIdForObjectId(e11);
      }
      this.handledChunksForIdCreation.delete(e10.chunkId);
    }
  }
  async _updateAttributeData() {
    for (const e10 of this._source.chunks()) {
      const { chunkId: t12, reader: s17 } = e10;
      if (!this.handledChunksForIdCreation.has(t12)) {
        this.handledChunksForIdCreation.add(t12);
        const e11 = s17.getCursor();
        for (; e11.next(); ) {
          const t13 = this._attributeStore.createDisplayIdForObjectId(e11.getObjectId());
          e11.setDisplayId(t13);
        }
      }
    }
    for (const e10 of this._source.chunks())
      if (!this.handledChunksForAttributeData.has(e10.chunkId)) {
        this.handledChunksForAttributeData.add(e10.chunkId);
        const t12 = e10.reader.getCursor();
        for (; t12.next(); ) {
          const e11 = t12.getDisplayId();
          this._attributeStore.setAttributeData(e11, t12, this._evalOptions);
        }
      }
  }
  *_update(e10) {
    const { subscription: t12, handledChunks: s17 } = e10;
    for (const n16 of this._source.chunks()) {
      const { chunkId: a14 } = n16;
      if (s17.has(a14))
        continue;
      s17.add(a14);
      const o18 = n16.getTileReader(t12.tile);
      o18 && (yield new e8(e10.subscription, o18, false, n16.end, n16.queryInfo));
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/Processor.js
var _4 = class {
  constructor(t12, e10) {
    this._connection = t12, this._source = e10, this._version = 1, this._proxy = new s5({ fetch: (t13, e11) => this._connection.layerView.fetch(t13, e11), fetchDictionary: (t13, e11) => this._connection.layerView.fetchDictionary(t13, e11) }), this._attributeStore = new b3({ isLocal: false, update: (t13) => this._connection.container.updateAttributeView(t13) });
  }
  destroy() {
    var _a;
    this._proxy.destroy(), (_a = this._strategy) == null ? void 0 : _a.destroy(), this._attributeStore.destroy();
  }
  get aggregateQueryEngine() {
    var _a;
    return (_a = this._strategy) == null ? void 0 : _a.aggregateQueryEngine;
  }
  getDisplayFeatures(t12) {
    return this._strategy ? this._strategy.getDisplayFeatures(t12) : { features: [], aggregates: [] };
  }
  getFeatureObjectIdsForAggregate(t12) {
    return this._strategy ? this._strategy.getFeatureObjectIdsForAggregate(t12) : [];
  }
  onSubscribe(t12) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.onSubscribe(t12);
  }
  onUnsubscribe(t12) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.onUnsubscribe(t12);
  }
  async update(t12, e10, s17, o18, c10) {
    var _a;
    const h6 = t12.processor, u7 = d3(this._schema, h6);
    if (!u7 && !o18)
      return;
    has("esri-2d-update-debug") && console.debug(`Version[${this._version}] SymbolProcessor.update`, { changes: u7, schema: h6 }), this._schema = h6;
    const g4 = f2.fromJSON(t12.source.mutable.dataFilter.outSpatialReference), d9 = new p2({ fields: this._source.metadata.fieldsIndex, spatialReference: g4 });
    return await this._attributeStore.update(h6.storage, d9, this._source.metadata, g4, e10), (_a = this._strategy) == null ? void 0 : _a.invalidateAttributeData(), o18 || p(u7, "mesh") ? (p(u7, "mesh.strategy") && await this._updateStrategy(h6.mesh.strategy, g4, c10, h6.mesh.timeZone), this._updateSortKey(d9, "sortKey" in h6.mesh ? h6.mesh.sortKey : null), (p(u7, "mesh.factory") || "dictionary" === h6.mesh.factory.symbology.type) && (this._factory = await s10.create(d9, this._proxy, h6.mesh.factory, s17)), this._invalidate(), this._version = e10, this._connection.container.updateRenderState(this._version)) : void 0;
  }
  async applyOverride(t12) {
    if (!this._strategy)
      return;
    const e10 = this._strategy.applyOverride(t12);
    for await (const r11 of e10)
      try {
        await this._process(r11);
      } catch (s17) {
      }
    this._source.applyOverride(t12);
  }
  async updateChunks() {
    var _a;
    await this._doUpdateChunks(), (_a = this._strategy) == null ? void 0 : _a.afterUpdateChunks();
  }
  async removeChunks(t12) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.removeChunks(t12), this._attributeStore.incrementDisplayIdGeneration();
  }
  updateHighlight({ highlights: t12 }) {
    if (!this._strategy)
      return void this._attributeStore.setHighlight(t12.map(({ objectId: t13, highlightFlags: e11 }) => ({ objectId: t13, highlightFlags: e11, displayId: -1 })), t12);
    const e10 = this._strategy.displayMap(t12, ({ objectId: t13 }) => t13, (t13, { highlightFlags: e11 }, s17) => ({ objectId: s17, displayId: t13, highlightFlags: e11 }));
    this._attributeStore.setHighlight(e10, t12);
  }
  async _doUpdateChunks() {
    if (!this._strategy)
      return;
    const t12 = this._strategy.updateChunks(), s17 = [], r11 = /* @__PURE__ */ new Map();
    for await (const a14 of t12) {
      let t13 = r11.get(a14.id);
      null == t13 && (t13 = new e6({ concurrency: 16, process: (t14) => this._process(t14) }), r11.set(a14.id, t13));
      const i10 = t13.push(a14).catch((t14) => f(t14));
      s17.push(i10);
    }
    try {
      await Promise.all(s17);
    } catch (i10) {
    }
    has("esri-2d-update-debug") && console.log("SendUpdates"), this._attributeStore.sendUpdates(), has("esri-2d-update-debug") && console.log("SendUpdates.await");
  }
  async _updateStrategy(t12, e10, s17, r11) {
    var _a;
    switch ((_a = this._strategy) == null ? void 0 : _a.destroy(), t12.type) {
      case "feature":
        this._strategy = new o13(this._source, this._attributeStore, r11);
        break;
      case "binning":
        this._strategy = await y4.create(t12, e10, this._source, this._attributeStore, r11);
        break;
      case "cluster":
        this._strategy = await S4.create(this._connection, t12, e10, this._source, this._attributeStore, r11);
    }
    for (const i10 of s17)
      this._strategy.onSubscribe(i10);
  }
  async _updateSortKey(e10, s17) {
    var _a;
    if (this._sortInfo = u((_a = this._sortInfo) == null ? void 0 : _a.computed), null != s17) {
      const t12 = s17.byRenderer ? null : await e10.createComputedField(s17);
      this._sortInfo = { ...s17, computed: t12 };
    }
  }
  _invalidate() {
    this._strategy && this._strategy.invalidate();
  }
  async _process(t12) {
    const e10 = t12.subscription;
    if (has("esri-2d-update-debug")) {
      const s17 = e10.tile;
      console.debug(`Version[${this._version}] Tile[${s17.key.id}, end=${t12.end}] Processor._process`);
    }
    await this._fetchResources(t12), s2(e10.signal);
    const r11 = await this._write(t12, e10.tile.createArcadeEvaluationOptions(this._schema.mesh.timeZone)), i10 = e10.tile.tileInfoView.tileInfo.isWrappable, { message: a14, transferList: o18 } = r11.serialize(i10), n16 = t12.createMessage(a14, this._version, this._attributeStore.epoch);
    if (s2(e10.signal), await this._connection.container.onMessage(n16, { signal: e10.signal, transferList: o18 }), this._attributeStore.sendUpdates(), has("esri-2d-update-debug")) {
      const s17 = e10.tile;
      console.debug(`Version[${this._version}] Tile[${s17.key.id}, end=${t12.end}] Processor._process.await`);
    }
  }
  async _fetchResources(t12) {
    await this._fetchMatcherResources(t12), await this._fetchWriterResources(t12);
  }
  async _fetchMatcherResources(t12) {
    if (t12.reader)
      return this._factory.enqueueMatcherRequests(this._proxy, t12.reader);
  }
  async _fetchWriterResources(t12) {
    if (!t12.reader)
      return;
    const e10 = t12.reader.getCursor(), s17 = t12.subscription.tile.createArcadeEvaluationOptions(this._schema.mesh.timeZone);
    for (; e10.next(); )
      this._factory.enqueueWriterRequests(this._proxy, e10, s17);
    await this._proxy.fetchEnqueuedResources();
  }
  async _write(t12, e10) {
    var _a;
    const s17 = t12.subscription.tile, r11 = (_a = t12.reader) == null ? void 0 : _a.getCursor(), i10 = (r11 == null ? void 0 : r11.getSize()) ?? 0, a14 = s17.tileInfoView.tileInfo.isWrappable, n16 = new g(s17.key, this._strategy.enablePixelBuffering, a14, i10);
    if (!r11)
      return n16;
    const c10 = s17.createArcadeEvaluationOptions(this._schema.mesh.timeZone);
    for (; r11.next(); ) {
      const t13 = this._getSortKeyValue(r11, e10);
      n16.entityStart(r11.getDisplayId(), t13), this._factory.write(n16, this._proxy, r11, c10, s17.level), n16.entityEnd();
    }
    return n16;
  }
  _getSortKeyValue(t12, e10) {
    if (!this._sortInfo)
      return 0;
    const { computed: s17, order: r11, byRenderer: i10 } = this._sortInfo, a14 = i10 ? this._factory.getSortKey(t12, e10) : s17 == null ? void 0 : s17.read(t12, e10);
    return null == a14 || isNaN(a14) ? 0 : a14 * ("asc" === r11 ? -1 : 1);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureStoreStatistics.js
var t8 = class _t {
  static from(e10) {
    let n16 = 0, r11 = 0, o18 = 0;
    return e10.forEach((t12) => {
      const e11 = t12._readGeometry();
      e11 && (r11 += e11.isPoint ? 1 : e11.lengths.reduce((t13, e12) => t13 + e12, 0), o18 += e11.isPoint ? 1 : e11.lengths.length, n16 += 1);
    }), new _t(n16, r11, o18);
  }
  constructor(t12, e10, n16) {
    this.featureCount = t12, this.vertexCount = e10, this.ringCount = n16;
  }
  toJSON() {
    return { featureCount: this.featureCount, ringCount: this.featureCount, vertexCount: this.featureCount };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceQueryInfo.js
var s14 = 4;
function o14(t12, a14) {
  const { service: s17 } = t12, o18 = s17.orderByFields ?? a14.objectIdField + " ASC", n16 = s17.source, l7 = { returnCentroid: !(null !== n16 && "object" == typeof n16 && "path" in n16 && w2(n16.path)) && "esriGeometryPolygon" === a14.geometryType, returnGeometry: true, timeReferenceUnknownClient: a14.timeReferenceUnknownClient ?? void 0, outSpatialReference: f2.fromJSON(t12.mutable.dataFilter.outSpatialReference), orderByFields: [o18], where: t12.mutable.dataFilter.definitionExpression ?? "1=1", outFields: t12.mutable.availableFields };
  if ("feature" === t12.type) {
    const { gdbVersion: r11, historicMoment: i10, timeExtent: a15 } = t12.mutable.dataFilter;
    return { ...l7, gdbVersion: r11, historicMoment: i10 ? new Date(i10) : null, timeExtent: a15 ? c2.fromJSON(a15) : null, outFields: t12.mutable.availableFields };
  }
  return l7;
}
var n11 = class _n {
  static fromSchema(e10, t12) {
    const r11 = "feature" === e10.type ? e10.mutable.dataFilter.queryScaleRanges : [];
    return new _n(o14(e10, t12), r11, t12.subtypeField, e10.mutable.dataFilter.customParameters, t12.geometryType, e10.service.queryMetadata.capabilities);
  }
  constructor(e10, t12, r11, i10, a14, s17) {
    this._queryParams = e10, this._queryScaleRanges = t12, this._subtypeField = r11, this._customParameters = i10, this._geometryType = a14, this._capabilities = s17;
  }
  get pageSize() {
    if (null == this._capabilities)
      throw new Error("InternalError: Service does not support paged queries");
    const { query: e10 } = this._capabilities, t12 = e10.supportsMaxRecordCountFactor ? s14 : null, r11 = (e10.maxRecordCount ?? 8e3) * (t12 ?? 1);
    return Math.min(8e3, r11);
  }
  updateFields(e10) {
    this._queryParams.outFields = e10;
  }
  createPatchFieldsQuery(e10, t12) {
    const r11 = e10.clone();
    if ("*" === this._queryParams.outFields[0]) {
      if ("*" === (r11.outFields ?? [])[0])
        return null;
      r11.outFields = this._queryParams.outFields;
    } else {
      const e11 = new Set(this._queryParams.outFields), i10 = [];
      for (const r12 of e11)
        t12.hasField(r12) || i10.push(r12);
      if (0 === i10.length)
        return null;
      r11.outFields = i10;
    }
    return r11.returnGeometry = false, r11.returnCentroid = false, r11.quantizationParameters = null, r11.cacheHint = true, { inner: r11, customParameters: this._customParameters };
  }
  createQuery(e10 = {}) {
    if (!this._queryParams)
      throw new Error("InternalError: queryInfo should be defined");
    return { inner: new b({ ...this._queryParams, ...e10 }), customParameters: this._customParameters };
  }
  createTileQuery(e10, r11) {
    if (null == this._capabilities)
      throw new Error("InternalError: Service does not support tile queries");
    const i10 = this.createQuery(r11), a14 = i10.inner;
    if (this._queryScaleRanges.length) {
      const r12 = this._queryScaleRanges.filter((t12) => (!t12.minScale || t12.minScale >= e10.maxScale) && (!t12.maxScale || t12.maxScale <= e10.minScale)).map((e11) => e11.subtypeCode);
      if (r12.length) {
        const e11 = `${this._subtypeField} IN (${r12})`;
        a14.where = n3(a14.where, e11);
      }
    }
    return a14.quantizationParameters = r11.quantizationParameters ?? e10.getQuantizationParameters(), a14.resultType = "tile", a14.geometry = e10.extent, this._capabilities.query.supportsQuantization ? "esriGeometryPolyline" === this._geometryType && (a14.maxAllowableOffset = e10.resolution * has("feature-polyline-generalization-factor")) : "esriGeometryPolyline" !== this._geometryType && "esriGeometryPolygon" !== this._geometryType || (a14.maxAllowableOffset = e10.resolution, "esriGeometryPolyline" === this._geometryType && (a14.maxAllowableOffset *= has("feature-polyline-generalization-factor"))), a14.defaultSpatialReferenceEnabled = this._capabilities.query.supportsDefaultSpatialReference, a14.compactGeometryEnabled = this._capabilities.query.supportsCompactGeometry, this._capabilities.query.supportsMaxRecordCountFactor && (a14.maxRecordCountFactor = s14), i10;
  }
  createPagedTileQuery(e10, t12) {
    const r11 = this.pageSize;
    return this.createTileQuery(e10, { start: r11 * t12, num: r11, returnExceededLimitFeatures: true });
  }
  createPagedQuery(e10) {
    const t12 = this.pageSize;
    return this.createQuery({ start: t12 * e10, num: t12, returnExceededLimitFeatures: true, maxRecordCountFactor: s14 });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamMessenger.js
var o15 = 2500;
var a9 = class extends S {
  constructor(e10) {
    super(), this._connection = e10, this._enabledEventTypes = /* @__PURE__ */ new Set(), this._updateInfo = { websocket: 0, client: 0 }, this._lastTime = performance.now(), this.addHandles([d2(() => {
      var _a;
      return ((_a = this._strategy) == null ? void 0 : _a.connectionStatus) ?? "disconnected";
    }, (e11) => {
      this._layerView.setProperty({ propertyName: "pipelineConnectionStatus", value: e11 });
    }, { initial: true }), d2(() => {
      var _a;
      return ((_a = this._strategy) == null ? void 0 : _a.errorString) || null;
    }, (e11) => this._layerView.setProperty({ propertyName: "pipelineErrorString", value: e11 }), { initial: true })]);
  }
  destroy() {
    this._strategy = null, this.removeAllHandles();
  }
  get _layerView() {
    return this._connection.layerView;
  }
  set strategy(e10) {
    null == this._strategy && this._resetUpdateInfo(performance.now());
    const t12 = "event-handles";
    this.removeHandles(t12), null != e10 && this.addHandles([e10.events.on("data-received", (e11) => this._onFeature(e11)), e10.events.on("message-received", (e11) => this._onWebSocketMessage(e11)), e10.events.on("features-updated", (e11) => this._onUpdate(e11)), e10.events.on("tick", () => this._onTick())], t12), this._strategy = e10;
  }
  updateCustomParameters(e10) {
    var _a;
    null != e10 && ((_a = this._strategy) == null ? void 0 : _a.updateCustomParameters(e10));
  }
  sendMessageToSocket(e10) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.sendMessageToSocket(e10);
  }
  sendMessageToClient(e10) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.sendMessageToClient(e10);
  }
  enableEvent(e10, t12) {
    t12 ? this._enabledEventTypes.add(e10) : this._enabledEventTypes.delete(e10);
  }
  disconnect() {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.disconnect();
  }
  connect() {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.connect();
  }
  clear() {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.clear();
  }
  _onWebSocketMessage(e10) {
    this._enabledEventTypes.has("message-received") && this._layerView.emitEvent({ name: "message-received", event: e10 });
  }
  _onFeature(e10) {
    this._updateInfo.websocket++, this._enabledEventTypes.has("data-received") && this._layerView.emitEvent({ name: "data-received", event: { attributes: e10.attributes, centroid: e10.centroid, geometry: e10.geometry } });
  }
  _onUpdate(e10) {
    this._updateInfo.client += e10;
  }
  _onTick() {
    const e10 = performance.now(), t12 = e10 - this._lastTime;
    if (t12 > o15) {
      const s17 = Math.round(this._updateInfo.client / (t12 / 1e3)), n16 = Math.round(this._updateInfo.websocket / (t12 / 1e3));
      this._resetUpdateInfo(e10), this._layerView.emitEvent({ name: "update-rate", event: { client: s17, websocket: n16 } });
    }
  }
  _resetUpdateInfo(e10) {
    this._lastTime = e10, this._updateInfo.client = 0, this._updateInfo.websocket = 0;
  }
};
e([y()], a9.prototype, "_strategy", void 0), a9 = e([a("esri.views.2d.layers.features.sources.StreamMessenger")], a9);

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ALoadStrategy.js
var r7 = class {
  constructor(r11) {
    this._store = r11, this._controller = new AbortController();
  }
  destroy() {
    this._controller.abort();
  }
  get _options() {
    return { signal: this._controller.signal };
  }
  async queryOverride(r11) {
    throw new Error("InternalError: LoadStrategy does not support fetching");
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFHeader.js
var n12 = 268435455;
var o16 = class {
  constructor() {
    this.hasFeatures = false, this.exceededTransferLimit = false, this.fieldCount = 0, this.featureCount = 0, this.objectIdFieldIndex = 0, this.vertexCount = 0, this.offsets = { attributes: new Array(), geometry: new Array() }, this.centroid = new Array();
  }
};
function a10(a14, i10, c10 = false) {
  var _a;
  const f7 = 1, d9 = 3, u7 = 9, g4 = 12, l7 = 13, p7 = 15, h6 = a14.asUnsafe(), b5 = h6.pos(), w3 = new o16();
  let m7 = 0, y8 = 0;
  const k = 1, x2 = 2, I2 = 4, L2 = 3;
  let A2 = null, F = null, C = null, S5 = false;
  const j3 = [];
  for (; h6.next(); )
    switch (h6.tag()) {
      case f7:
        A2 = h6.getString();
        break;
      case d9:
        F = h6.getString();
        break;
      case g4:
        C = h6.processMessage(h);
        break;
      case u7:
        if (w3.exceededTransferLimit = h6.getBool(), w3.exceededTransferLimit) {
          w3.offsets.geometry = c10 ? new Float64Array(8e3) : new Int32Array(8e3), w3.centroid = c10 ? new Float64Array(16e3) : new Int32Array(16e3);
          for (let e10 = 0; e10 < w3.centroid.length; e10++)
            w3.centroid[e10] = n12;
        }
        break;
      case l7: {
        const e10 = h6.processMessage(b2);
        e10.index = m7++, j3.push(e10);
        break;
      }
      case p7: {
        const e10 = h6.getLength(), t12 = h6.pos() + e10;
        if (!w3.exceededTransferLimit) {
          const e11 = w3.offsets.geometry, t13 = w3.centroid;
          e11.push(0), t13.push(n12), t13.push(n12);
        }
        !S5 && w3.exceededTransferLimit && (S5 = true, w3.offsets.attributes = c10 ? new Float64Array(8e3 * m7) : new Uint32Array(8e3 * m7));
        let s17 = y8 * m7;
        for (; h6.pos() < t12 && h6.next(); )
          switch (h6.tag()) {
            case k: {
              if (S5)
                w3.offsets.attributes[s17++] = h6.pos();
              else {
                w3.offsets.attributes.push(h6.pos());
              }
              const e11 = h6.getLength();
              h6.skipLen(e11);
              break;
            }
            case x2:
              if (i10) {
                const e11 = h6.getLength(), t13 = h6.pos() + e11;
                for (; h6.pos() < t13 && h6.next(); )
                  switch (h6.tag()) {
                    case L2: {
                      h6.getUInt32();
                      const e12 = h6.getSInt64(), t14 = h6.getSInt64();
                      w3.centroid[2 * y8] = e12, w3.centroid[2 * y8 + 1] = t14;
                      break;
                    }
                    default:
                      h6.skip();
                  }
              } else {
                w3.offsets.geometry[y8] = h6.pos();
                const e11 = h6.getLength();
                w3.vertexCount += e11, h6.skipLen(e11);
              }
              break;
            case I2: {
              const e11 = h6.getLength(), t13 = h6.pos() + e11;
              for (; h6.pos() < t13 && h6.next(); )
                switch (h6.tag()) {
                  case L2: {
                    h6.getUInt32();
                    const e12 = h6.getSInt64(), t14 = h6.getSInt64();
                    w3.centroid[2 * y8] = e12, w3.centroid[2 * y8 + 1] = t14;
                    break;
                  }
                  default:
                    h6.skip();
                }
              break;
            }
            default:
              h6.skip();
          }
        y8++, w3.hasFeatures = true;
        break;
      }
      default:
        h6.skip();
    }
  const U2 = A2 || F;
  if (!U2)
    throw new s("FeatureSet has no objectId or globalId field name");
  return w3.fields = new Z(j3), w3.featureCount = y8, w3.fieldCount = m7, w3.objectIdFieldIndex = (_a = w3.fields.get(U2)) == null ? void 0 : _a.index, w3.transform = C, w3.displayIds = new Uint32Array(w3.featureCount), w3.groupIds = new Uint16Array(w3.featureCount), h6.move(b5), w3;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBF.js
var o17 = true;
var d7 = 268435455;
var u6 = 128;
var c8 = 128e3;
var g3 = { small: { delta: new Int32Array(u6), decoded: new Int32Array(u6) }, large: { delta: new Int32Array(c8), decoded: new Int32Array(c8) } };
function _5(e10) {
  return e10 <= g3.small.delta.length ? g3.small : (e10 <= g3.large.delta.length || (g3.large.delta = new Int32Array(Math.round(1.25 * e10)), g3.large.decoded = new Int32Array(Math.round(1.25 * e10))), g3.large);
}
function f4(r11) {
  try {
    const e10 = 2, t12 = new n4(new Uint8Array(r11), new DataView(r11));
    for (; t12.next(); ) {
      if (t12.tag() === e10)
        return l5(t12.getMessage());
      t12.skip();
    }
  } catch (n16) {
    const r12 = new s("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: n16 });
    n.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(r12);
  }
  return null;
}
function l5(e10) {
  const t12 = 1;
  for (; e10.next(); ) {
    if (e10.tag() === t12)
      return e10.getMessage();
    e10.skip();
  }
  return null;
}
function I(e10) {
  const t12 = 1, r11 = 2, s17 = 3, n16 = 4, a14 = 5, i10 = 6, h6 = 7, o18 = 8, d9 = 9, u7 = e10.getLength(), c10 = e10.pos() + u7;
  for (; e10.pos() < c10 && e10.next(); )
    switch (e10.tag()) {
      case t12:
        return e10.getString();
      case r11:
        return e10.getFloat();
      case s17:
        return e10.getDouble();
      case n16:
        return e10.getSInt32();
      case a14:
        return e10.getUInt32();
      case i10:
        return e10.getInt64();
      case h6:
        return e10.getUInt64();
      case o18:
        return e10.getSInt64();
      case d9:
        return e10.getBool();
      default:
        return e10.skip(), null;
    }
  return null;
}
function p5(e10, t12, r11, s17, n16, a14) {
  return 0.5 * Math.abs(e10 * s17 + r11 * a14 + n16 * t12 - e10 * a14 - r11 * t12 - n16 * s17);
}
function y6(e10, t12, r11, s17) {
  return 0 === e10 * s17 - r11 * t12 && e10 * r11 + t12 * s17 > 0;
}
var m5 = class _m extends M {
  static fromBuffer(e10, t12, r11 = false) {
    const s17 = t12.geometryType, n16 = f4(e10), a14 = a10(n16, "esriGeometryPoint" === s17, r11);
    return new _m(n16, a14, t12);
  }
  constructor(e10, t12, r11) {
    super(r11), this._hasNext = false, this._isPoints = false, this._featureIndex = -1, this._featureOffset = 0, this._cache = { area: 0, unquantGeometry: void 0, geometry: void 0, centroid: void 0, legacyFeature: void 0, optFeature: void 0 }, this._parseCaches = new Array(), this._geometryType = r11.geometryType, this._reader = e10, this._header = t12, this._hasNext = t12.hasFeatures, this._isPoints = "esriGeometryPoint" === r11.geometryType;
  }
  get _size() {
    return this._header.featureCount;
  }
  get fields() {
    return this._header.fields;
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get hasFeatures() {
    return this._header.hasFeatures;
  }
  get hasNext() {
    return this._hasNext;
  }
  get exceededTransferLimit() {
    return this._header.exceededTransferLimit;
  }
  getSize() {
    return this._size;
  }
  getInTransform() {
    return this._header.transform;
  }
  getCursor() {
    return this.copy();
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e10) {
    this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0, this._featureIndex = e10;
  }
  getAttributeHash() {
    let e10 = "";
    for (const t12 of this._header.fields.fields)
      e10 += this._readAttributeAtIndex(t12.index) + ".";
    return e10;
  }
  getObjectId() {
    return this._readAttributeAtIndex(this._header.objectIdFieldIndex);
  }
  getDisplayId() {
    return this._header.displayIds[this._featureIndex];
  }
  setDisplayId(e10) {
    this._header.displayIds[this._featureIndex] = e10;
  }
  readGeometryArea() {
    return this._cache.area || this._readGeometry(true), this._cache.area;
  }
  copy() {
    const e10 = this._reader.clone(), t12 = new _m(e10, this._header, this.metadata);
    return this.copyInto(t12), t12;
  }
  next() {
    for (this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0; ++this._featureIndex < this._size && !this._getExists(); )
      ;
    return this._featureIndex < this._size;
  }
  _readX() {
    return this._header.centroid[2 * this._featureIndex];
  }
  _readY() {
    return this._header.centroid[2 * this._featureIndex + 1];
  }
  _readServerCentroid() {
    const e10 = this._header.centroid[2 * this._featureIndex], t12 = this._header.centroid[2 * this._featureIndex + 1];
    return e10 === d7 ? null : new e2([], [e10, t12]);
  }
  _readGeometry(e10 = false) {
    if (void 0 === this._cache.geometry) {
      let r11 = null;
      if (this._isPoints) {
        if (this._header.centroid[2 * this._featureIndex] === d7)
          return null;
        const e11 = this._header.centroid[2 * this._featureIndex], t12 = this._header.centroid[2 * this._featureIndex + 1];
        r11 = new e2([], [e11, t12]);
      } else {
        const s17 = this._header.offsets.geometry[this._featureIndex], n16 = this._reader;
        if (0 === s17)
          return null;
        n16.move(s17);
        try {
          r11 = e10 ? this._parseGeometryForDisplay(n16) : this._parseGeometry(n16);
        } catch (t12) {
          return console.error("Failed to parse geometry!", t12), null;
        }
      }
      return 0 === (r11 == null ? void 0 : r11.coords.length) && (r11 = null), this._cache.geometry = r11, r11;
    }
    return this._cache.geometry;
  }
  _readAttribute(e10, t12) {
    var _a;
    const r11 = this._header.fields.get(e10);
    if (null == r11)
      return;
    let s17 = this._readAttributeAtIndex(r11.index);
    "esriFieldTypeTimestampOffset" === ((_a = this.fields.get(e10)) == null ? void 0 : _a.type) && (s17 = this.parseTimestampOffset(s17));
    const n16 = this._header.fields.isDateField(r11.name);
    return t12 ? null == s17 ? s17 : n16 ? new Date(s17) : s17 : s17;
  }
  _readAttributes() {
    const e10 = {};
    for (const t12 of this._header.fields.fields)
      e10[t12.name] = this._readAttributeAtIndex(t12.index);
    return e10;
  }
  copyInto(e10) {
    super.copyInto(e10), e10._featureIndex = this._featureIndex, e10._featureOffset = this._featureOffset, e10._hasNext = this._hasNext, e10._parseCaches = this._parseCaches;
  }
  _readAttributeAtIndex(e10) {
    let t12 = this._parseCaches[e10];
    if (t12 || (t12 = new a3(this.getSize()), this._parseCaches[e10] = t12), t12.has(this._featureIndex))
      return t12.get(this._featureIndex);
    const r11 = this._header.offsets.attributes[this._featureIndex * this._header.fieldCount + e10], s17 = this._reader;
    s17.move(r11);
    const n16 = I(s17);
    return t12.set(this._featureIndex, n16), n16;
  }
  _readGeometryDeltaDecoded(e10 = false) {
    if (void 0 === this._cache.unquantGeometry) {
      const t12 = this._readGeometry(e10);
      if (!t12)
        return this._cache.unquantGeometry = void 0, null;
      if (!this.getInTransform())
        return this._cache.unquantGeometry = t12, t12;
      const r11 = _5(t12.coords.length).decoded, s17 = t12.clone(r11), n16 = s17.coords;
      let a14 = 0;
      for (const e11 of s17.lengths) {
        for (let t13 = 1; t13 < e11; t13++) {
          const e12 = 2 * (a14 + t13), r12 = 2 * (a14 + t13 - 1);
          n16[e12] += n16[r12], n16[e12 + 1] += n16[r12 + 1];
        }
        a14 += e11;
      }
      return this._cache.unquantGeometry = s17, s17;
    }
    return this._cache.unquantGeometry;
  }
  _parseGeometry(e10) {
    const t12 = 2, r11 = 3, s17 = e10.asUnsafe(), a14 = s17.getLength(), i10 = s17.pos() + a14, h6 = [], o18 = [];
    for (; s17.pos() < i10 && s17.next(); )
      switch (s17.tag()) {
        case t12: {
          const e11 = s17.getUInt32(), t13 = s17.pos() + e11;
          for (; s17.pos() < t13; )
            o18.push(s17.getUInt32());
          break;
        }
        case r11: {
          const e11 = s17.getUInt32(), t13 = s17.pos() + e11;
          for (h6.push(s17.getSInt64()), h6.push(s17.getSInt64()), this.hasZ && s17.getSInt64(), this.hasM && s17.getSInt64(); s17.pos() < t13; )
            h6.push(s17.getSInt64()), h6.push(s17.getSInt64()), this.hasZ && s17.getSInt64(), this.hasM && s17.getSInt64();
          break;
        }
        default:
          s17.skip();
      }
    return new e2(o18, h6);
  }
  _parseGeometryForDisplay(e10) {
    const t12 = 2, s17 = 3, a14 = e10.asUnsafe(), i10 = a14.getLength(), h6 = a14.pos() + i10, d9 = [], u7 = [];
    let c10 = 0, g4 = 0, f7 = null, l7 = 0;
    const I2 = "esriGeometryPolygon" === this.geometryType;
    for (; a14.pos() < h6 && a14.next(); )
      switch (a14.tag()) {
        case t12: {
          const e11 = a14.getUInt32(), t13 = a14.pos() + e11;
          for (; a14.pos() < t13; ) {
            const e12 = a14.getUInt32();
            d9.push(e12), c10 += e12;
          }
          f7 = _5(2 * c10).delta;
          break;
        }
        case s17: {
          a14.getUInt32();
          const e11 = 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
          n2(f7);
          for (const t13 of d9)
            if (g4 + e11 * t13 > f7.length)
              for (let e12 = 0; e12 < t13; e12++)
                a14.getSInt32(), a14.getSInt32(), this.hasZ && a14.getSInt32(), this.hasM && a14.getSInt32();
            else if (I2 && o17) {
              const e12 = this.getAreaSimplificationThreshold(t13, this._header.vertexCount);
              let r11 = 2, s18 = 1;
              const n16 = false;
              let i11 = a14.getSInt32(), h7 = a14.getSInt32();
              f7[g4++] = i11, f7[g4++] = h7, this.hasZ && a14.getSInt32(), this.hasM && a14.getSInt32();
              let o18 = a14.getSInt32(), d10 = a14.getSInt32();
              for (this.hasZ && a14.getSInt32(), this.hasM && a14.getSInt32(); r11 < t13; ) {
                let t14 = a14.getSInt32(), n17 = a14.getSInt32();
                this.hasZ && a14.getSInt32(), this.hasM && a14.getSInt32();
                const u8 = i11 + o18, c11 = h7 + d10;
                p5(i11, h7, u8, c11, u8 + t14, c11 + n17) >= e12 ? (l7 += -0.5 * (u8 - i11) * (c11 + h7), s18 > 1 && y6(f7[g4 - 2], f7[g4 - 1], o18, d10) ? (f7[g4 - 2] += o18, f7[g4 - 1] += d10) : (f7[g4++] = o18, f7[g4++] = d10, s18++), i11 = u8, h7 = c11) : (t14 += o18, n17 += d10), o18 = t14, d10 = n17, r11++;
              }
              s18 < 3 || n16 ? g4 -= 2 * s18 : (l7 += -0.5 * (i11 + o18 - i11) * (h7 + d10 + h7), y6(f7[g4 - 2], f7[g4 - 1], o18, d10) ? (f7[g4 - 2] += o18, f7[g4 - 1] += d10, u7.push(s18)) : (f7[g4++] = o18, f7[g4++] = d10, u7.push(++s18)));
            } else {
              let e12 = 0, r11 = a14.getSInt32(), s18 = a14.getSInt32();
              this.hasZ && a14.getSInt32(), this.hasM && a14.getSInt32(), f7[g4++] = r11, f7[g4++] = s18, e12 += 1;
              for (let n16 = 1; n16 < t13; n16++) {
                const t14 = a14.getSInt32(), i11 = a14.getSInt32(), h7 = r11 + t14, o18 = s18 + i11;
                l7 += -0.5 * (h7 - r11) * (o18 + s18), this.hasZ && a14.getSInt32(), this.hasM && a14.getSInt32(), n16 > 2 && y6(f7[g4 - 2], f7[g4 - 1], t14, i11) ? (f7[g4 - 2] += t14, f7[g4 - 1] += i11) : (f7[g4++] = t14, f7[g4++] = i11, e12 += 1), r11 = h7, s18 = o18;
              }
              u7.push(e12);
            }
          break;
        }
        default:
          a14.skip();
      }
    return this._cache.area = l7, u7.length ? new e2(u7, f7) : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/support/queryAdapters.js
var c9 = class {
  constructor(e10, t12) {
    this.service = e10, this._metadata = t12;
  }
  destroy() {
  }
};
function m6(e10, t12) {
  switch (e10.type) {
    case "memory":
      return new l6(e10, t12);
    case "ogc":
      return new f5(e10, t12);
    case "feature-service":
      return e10.queryMetadata.capabilities.query.supportsFormatPBF && has("featurelayer-pbf") ? new y7(e10, t12) : new d8(e10, t12);
  }
}
async function p6(t12) {
  const a14 = new c4();
  return await a14.open(t12, {}), a14;
}
var l6 = class extends c9 {
  constructor(e10, t12) {
    super(e10, t12), this._portsOpen = p6(e10.source).then((e11) => this.client = e11);
  }
  destroy() {
    this.client.close(), this.client = null;
  }
  async executeQuery(e10, t12) {
    await this._portsOpen;
    const a14 = await this.client.invoke("queryFeatures", e10.toJSON(), t12);
    return u4.fromFeatureSet(a14, this._metadata);
  }
};
var y7 = class extends c9 {
  async executeQuery(e10, t12) {
    const { data: a14 } = await d4(this.service.source, e10, t12), r11 = !e10.quantizationParameters;
    return m5.fromBuffer(a14, this._metadata, r11);
  }
};
var d8 = class extends c9 {
  async executeQuery(e10, s17) {
    var _a;
    const { source: i10, queryMetadata: u7 } = this.service, c10 = u7.capabilities;
    if (null != e10.quantizationParameters && !c10.query.supportsQuantization) {
      const u8 = e10.clone(), c11 = m2(u8.quantizationParameters);
      u8.quantizationParameters = null;
      const { data: m8 } = await c3(i10, u8, this._metadata.spatialReference, s17), p7 = ct(m8, this._metadata.objectIdField);
      return ft(c11, p7), u4.fromOptimizedFeatureSet(p7, this._metadata);
    }
    const { data: m7 } = await c3(i10, e10, this._metadata.spatialReference, s17);
    return "esriGeometryPoint" === this._metadata.geometryType && (m7.features = (_a = m7.features) == null ? void 0 : _a.filter((e11) => {
      if (null != e11.geometry) {
        const t12 = e11.geometry;
        return Number.isFinite(t12.x) && Number.isFinite(t12.y);
      }
      return true;
    })), u4.fromFeatureSet(m7, this._metadata);
  }
};
var f5 = class extends c9 {
  async executeQuery(e10, a14) {
    const { capabilities: i10 } = this.service.queryMetadata;
    if (e10.quantizationParameters && !i10.query.supportsQuantization) {
      const i11 = e10.clone(), o19 = m2(i11.quantizationParameters);
      i11.quantizationParameters = null;
      const u7 = await $2(this.service.source, e10, a14);
      return ft(o19, u7), u4.fromOptimizedFeatureSet(u7, this._metadata);
    }
    const o18 = await $2(this.service.source, e10, a14);
    return u4.fromOptimizedFeatureSet(o18, this._metadata);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/AFetchLoadStrategy.js
var a11 = class extends r7 {
  constructor(e10, t12, r11, o18, a14) {
    super(r11), this._serviceInfo = e10, this._queryInfo = t12, this._metadata = o18, this._eventLog = a14, this._queue = new _({ concurrency: 16, process: async (e11) => {
      var _a2;
      const t13 = { signal: (_a2 = e11.options) == null ? void 0 : _a2.signal, query: e11.query.customParameters };
      return this._adapter.executeQuery(e11.query.inner, t13);
    } }), this._adapter = m6(e10, o18);
  }
  async updateFields(r11) {
    this._queryInfo.updateFields(r11);
    const s17 = Array.from(this._store.chunks()).map(async (e10) => {
      const r12 = b.fromJSON(e10.queryInfo.queryJSON);
      if (r12)
        try {
          return await this._tryUpdateFields(e10.reader, r12), null;
        } catch (s18) {
          return s18;
        }
    }), o18 = (await Promise.all(s17)).filter((e10) => e10);
    if (o18.length)
      throw new s("featurelayer-query", "Encountered errors when downloading fields", { errors: o18 });
  }
  async queryOverride({ edits: e10 }) {
    const t12 = [], r11 = [];
    for (const o18 of e10.removed)
      null != o18.objectId && -1 !== o18.objectId ? t12.push(o18.objectId) : r11.push(o18.globalId);
    r11.length && t12.push(...this._mapGlobalIdsToObjectIds(r11));
    const s17 = e10.addOrModified.map(({ objectId: e11 }) => e11);
    let n16;
    if (s17.length) {
      const e11 = this._queryInfo.createQuery({ objectIds: s17 });
      n16 = await this._fetch(e11);
    } else
      n16 = u4.empty(this._metadata);
    return { reader: n16, removed: t12 };
  }
  _mapGlobalIdsToObjectIds(e10) {
    const t12 = new Set(e10), r11 = this._metadata.globalIdField;
    if (null == r11)
      throw new Error("InternalError: Recieved an edit with globalIds, but not supported by the service");
    const s17 = [];
    return this._store.forEachUnsafe((e11) => {
      const o18 = e11.readAttribute(r11);
      t12.has(o18) && s17.push(e11.getObjectId());
    }), s17;
  }
  async _fetch(e10, t12) {
    const r11 = await this._enqueue(e10, t12);
    return await this._tryUpdateFields(r11, e10.inner), r11;
  }
  async _tryUpdateFields(e10, t12) {
    const r11 = this._queryInfo.createPatchFieldsQuery(t12, e10);
    if (!r11)
      return;
    const s17 = await this._enqueue(r11, this._options);
    e10.joinAttributes(s17);
  }
  async _enqueue(e10, t12) {
    return this._eventLog.onEvent({ type: "fetchStart" }), this._queue.push({ query: e10, options: t12 }).finally(() => {
      this._eventLog.onEvent({ type: "fetchEnd", done: 0 === this._queue.length });
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ATileLoadStrategy.js
var s15 = class extends a11 {
  constructor() {
    super(...arguments), this._chunksById = /* @__PURE__ */ new Map();
  }
  unload(e10) {
    this._removeChunks(e10.tile);
  }
  _addChunk(e10) {
    const s17 = e10.tile.id;
    this._chunksById.has(s17) || this._chunksById.set(s17, []);
    const t12 = e10.size();
    (t12 || e10.first || e10.end) && (has("esri-2d-update-debug") && console.debug(`Chunk[${e10.chunkId}] ATileLoadStrategy.addChunk [count=${t12}]`), this._chunksById.get(s17).push(e10), this._store.insert(e10));
  }
  _removeChunks(e10) {
    const s17 = this._chunksById.get(e10.key.id) ?? [];
    for (const t12 of s17)
      has("esri-2d-update-debug") && console.debug(`Tile[${e10.key.id}] Chunk[${t12.chunkId}] ATileLoadStrategy.removeChunk`), this._store.remove(t12);
    this._chunksById.delete(e10.key.id);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/DrillDownTileSourceChunk.js
var i9 = class extends r6 {
  constructor(e10, i10, t12, r11, s17, h6) {
    var _a, _b;
    super(), this._reader = e10, this._queryJSON = i10, this._tile = t12, this._sourceTile = r11, this._sourceTileDepth = s17, this._end = h6, this.chunkId = `${this._tile.key.id}.${(_a = this._sourceTile) == null ? void 0 : _a.key.id}${this._end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${(_b = this._sourceTile) == null ? void 0 : _b.key.normalizedId}${this._end ? "e" : ""}`;
  }
  get queryInfo() {
    var _a;
    return { type: "drill-down-tile", chunkId: this.chunkId, tileId: this._tile.key.id, queryJSON: this._queryJSON, sourceTileDepth: this._sourceTileDepth, sourceTileId: (_a = this._sourceTile) == null ? void 0 : _a.key.id, size: this.size(), end: this.end };
  }
  get first() {
    return 0 === this._sourceTileDepth;
  }
  get reader() {
    return this._reader;
  }
  get end() {
    return this._end;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e10) {
    return this._tile.key.id === e10.key.id ? this.reader : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/DrillDownTileLoadStrategy.js
var r8 = class {
  constructor(t12, s17) {
    this.subscription = t12, this._tileIdToResult = /* @__PURE__ */ new Map(), this._controller = new AbortController(), m(t12.options, () => this._controller.abort()), m(s17, () => this._controller.abort());
  }
  get(t12) {
    return this._tileIdToResult.get(t12);
  }
  set(t12, e10) {
    this._tileIdToResult.set(t12, e10);
  }
  get options() {
    return { signal: this._controller.signal };
  }
};
var n13 = class extends s15 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  get about() {
    return { willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  async load(e10) {
    this._loadStates.has(e10.key.id) || this._loadStates.set(e10.key.id, new r8(e10, this._options));
    const s17 = this._loadStates.get(e10.key.id);
    let n16;
    try {
      for await (const i10 of this._fetchChunkInfos(s17, e10.tile, 0)) {
        const { queryJSON: s18, reader: r11, sourceTile: n17, sourceTileDepth: l8, tile: a14 } = i10, u7 = new i9(r11, s18, a14, n17, l8, false);
        s2(e10.options), this._addChunk(u7);
      }
    } catch (a14) {
      n16 = a14;
    }
    const l7 = new i9(u4.empty(this._metadata), null, e10.tile, null, -1, true);
    if (this._addChunk(l7), n16)
      throw n16;
  }
  unload(t12) {
    super.unload(t12), this._loadStates.delete(t12.key.id);
  }
  async *_fetchChunkInfos(t12, e10, s17) {
    let o18 = t12.get(e10.id);
    const i10 = !!o18;
    if (o18 || (o18 = await this._fetchChunkInfo(t12, e10, s17), t12.set(e10.id, o18)), o18.reader.exceededTransferLimit && s17 < has("featurelayer-query-max-depth"))
      for (const r11 of e10.createChildTiles())
        yield* this._fetchChunkInfos(t12, r11, s17 + 1);
    else
      i10 || (yield o18);
  }
  async _fetchChunkInfo(t12, e10, s17) {
    const o18 = t12.subscription.tile.getQuantizationParameters(), i10 = this._queryInfo.createTileQuery(e10, { returnExceededLimitFeatures: false, quantizationParameters: o18 });
    return { reader: await this._fetch(i10, t12.subscription.options), queryJSON: i10.inner.toJSON(), tile: t12.subscription.tile, sourceTile: e10, sourceTileDepth: s17 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/PagedTileSourceChunk.js
var t9 = class extends r6 {
  constructor(e10, t12, i10, r11, s17) {
    super(), this._reader = e10, this._queryJSON = t12, this._tile = i10, this._page = r11, this._end = s17, this.chunkId = `${this._tile.key.id}.${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${this._page}${this.end ? "e" : ""}`;
  }
  get queryInfo() {
    return { type: "paged-tile", chunkId: this.chunkId, tileId: this._tile.key.id, queryJSON: this._queryJSON, page: this._page, size: this.size(), end: this.end };
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get page() {
    return this._page;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e10) {
    return this._tile.key.id === e10.key.id ? this.reader : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/PagedTileLoadStrategy.js
var n14 = class {
  constructor(t12, e10) {
    this.subscription = t12, this._pages = /* @__PURE__ */ new Set(), this._controller = new AbortController(), this._done = false, m(t12.options, () => this._controller.abort()), m(e10, () => this._controller.abort());
  }
  resetAbortController() {
    this._controller = new AbortController();
  }
  get pageStart() {
    let t12 = -1;
    for (const e10 of this._pages.values())
      t12 = Math.max(t12, e10);
    return t12 + 1;
  }
  get done() {
    return this._done;
  }
  get options() {
    return { signal: this._controller.signal };
  }
  add(t12, e10) {
    this._pages.add(t12), this._done = this._done || e10;
  }
};
var a12 = class extends s15 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  get about() {
    return { willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  async load(e10) {
    this._loadStates.has(e10.key.id) || this._loadStates.set(e10.key.id, new n14(e10, this._options));
    const o18 = this._loadStates.get(e10.key.id);
    let s17;
    o18.resetAbortController();
    try {
      await this._fetchPages(o18);
    } catch (l7) {
      s17 = l7;
    }
    const a14 = new t9(u4.empty(this._metadata), null, e10.tile, -1, true);
    if (c(o18.options) || this._addChunk(a14), s17)
      throw s17;
  }
  unload(t12) {
    super.unload(t12), this._loadStates.delete(t12.key.id);
  }
  async _fetchPages(t12) {
    const o18 = 4, s17 = 20;
    let r11 = 0, i10 = t12.pageStart, n16 = 1;
    for (; r11 < s17 && !t12.done; ) {
      const s18 = [];
      for (let e10 = 0; e10 < n16; e10++)
        s18.push(this._fetchChunk(t12, i10++));
      const a14 = await Promise.all(s18);
      for (const o19 of a14)
        (0 !== o19.size() || o19.first) && (t12.add(o19.page, !o19.reader.exceededTransferLimit), s2(t12.options), this._addChunk(o19));
      r11++, n16 = Math.min(n16 + 1, o18);
    }
  }
  async _fetchChunk(t12, e10) {
    const o18 = t12.subscription.tile, s17 = this._queryInfo.createPagedTileQuery(o18, e10), i10 = await this._fetch(s17, t12.options);
    return new t9(i10, s17.inner.toJSON(), o18, e10, false);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/FeatureSnapshotSourceChunk.js
var t10 = class extends r6 {
  constructor(e10, t12, r11, s17) {
    super(), this._reader = e10, this._queryJSON = t12, this._page = r11, this._end = s17, this.chunkId = `${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = this.chunkId;
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get queryInfo() {
    return { type: "snapshot", chunkId: this.chunkId, queryJSON: this._queryJSON, page: this._page, size: this.size(), end: this.end };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e10) {
    const t12 = this.queryFeaturesInBounds(e10.bounds);
    return t12.setTransformForDisplay(e10.transform), t12;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/SnapshotLoadStrategy.js
var a13 = class extends a11 {
  constructor(t12, e10, o18, s17, n16, a14) {
    super(t12, e10, o18, n16, a14), this._random = new t(1e3), this._featureCount = s17;
  }
  get about() {
    return { willQueryAllFeatures: true, willQueryFullResolutionGeometry: true };
  }
  load(t12) {
    return null == this._promise && (this._promise = this._downloadPages(this._featureCount)), this._promise;
  }
  unload(t12) {
  }
  async _downloadPages(e10) {
    const r11 = Math.ceil(e10 / this._queryInfo.pageSize), o18 = Array.from({ length: r11 }, (t12, e11) => e11).sort((t12, e11) => this._random.getInt() - this._random.getInt()), a14 = await Promise.all(o18.map((t12) => this._downloadPage(t12))), i10 = new t10(u4.empty(this._metadata), null, -1, true);
    this._store.insert(i10);
    const u7 = a14.filter((t12) => t12);
    if (u7.length)
      throw new s("featurelayer-query", "Encountered errors when downloading data", { errors: u7 });
  }
  async _downloadPage(t12) {
    try {
      const r11 = this._queryInfo.createPagedQuery(t12), o18 = await this._fetch(r11, this._options), n16 = new t10(o18, r11.inner.toJSON(), t12, false);
      return s2(this._options), this._store.insert(n16), null;
    } catch (r11) {
      return r11;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamConnectionState.js
var s16 = class extends S {
  constructor(r11) {
    super(r11);
  }
  get connectionStatus() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.connectionStatus;
  }
  get errorString() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.errorString;
  }
};
e([y()], s16.prototype, "connection", void 0), e([y()], s16.prototype, "connectionStatus", null), e([y()], s16.prototype, "errorString", null), s16 = e([a("esri.views.2d.layers.features.sources.StreamConnectionState")], s16);

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamFeatureStore.js
var t11 = class {
  constructor(e10, t12) {
    this._metadata = e10, this._onUpdate = t12, this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._objectIdToFeature.size;
  }
  get reader() {
    return u4.fromFeatures([...this._objectIdToFeature.values()], this._metadata);
  }
  add(e10) {
    this._objectIdToFeature.set(e10.objectId, e10);
  }
  forEach(e10) {
    this._objectIdToFeature.forEach(e10);
  }
  removeById(e10) {
    const t12 = this._objectIdToFeature.get(e10);
    return t12 ? (this._objectIdToFeature.delete(e10), t12) : null;
  }
  clear() {
    this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  update(e10, t12) {
    this._onUpdate((e10 == null ? void 0 : e10.length) ?? 0);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/StreamSourceChunk.js
var r9 = class extends r6 {
  constructor(e10) {
    super(), this._reader = e10, this.chunkId = "stream-chunk", this.normalizedChunkId = "stream-chunk";
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return true;
  }
  get end() {
    return true;
  }
  get queryInfo() {
    return { type: "stream", chunkId: this.chunkId, size: this.size(), end: this.end };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e10) {
    const r11 = this.queryFeaturesInBounds(e10.bounds);
    return r11.setTransformForDisplay(e10.transform), r11;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/StreamLoadStrategy.js
var h5 = class extends r7 {
  constructor(t12, s17, o18, a14, c10) {
    super(o18), this._service = t12, this._dataFilter = s17, this._streamOptions = a14, this._metadata = c10, this._connectionState = new s16(), this._forceRefresh = false, this.events = new o2();
    const { objectIdField: h6, timeInfo: m7 } = this._metadata, { purgeOptions: d9 } = s17;
    this._stagingStore = new t11(this._metadata, (e10) => this.events.emit("features-updated", e10)), this._manager = new o6(this._stagingStore, h6, m7, d9), this.connect();
  }
  destroy() {
    super.destroy(), this.disconnect();
  }
  get about() {
    return { willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  get connectionStatus() {
    return this._connectionState.connectionStatus;
  }
  get errorString() {
    var _a;
    return (_a = this._connectionState) == null ? void 0 : _a.errorString;
  }
  async refresh() {
    const e10 = null != this._chunk;
    this._manager.checkForUpdates() || !e10 || this._forceRefresh ? (this._chunk && this._store.remove(this._chunk), this._forceRefresh = false, this._chunk = new r9(this._stagingStore.reader), this._store.insert(this._chunk), this.events.emit("tick")) : this.events.emit("tick");
  }
  async updateFields(e10) {
    throw new Error("Updating available fields not supported for StreamLayer");
  }
  async load(e10) {
  }
  unload(e10) {
  }
  disconnect() {
    var _a;
    this._connection = u(this._connection), this._connectionState.connection = null, (_a = this._handlesGroup) == null ? void 0 : _a.remove();
  }
  connect() {
    if (null != this._connection)
      return;
    const { geometryType: e10, spatialReference: s17 } = this._metadata, { maxReconnectionAttempts: n16, maxReconnectionInterval: i10, geometryDefinition: r11, definitionExpression: a14, customParameters: c10 } = this._dataFilter;
    this._connection = r3(this._service.source, s17, this._streamOptions.outSR, e10, a14, r11, n16, i10, c10), this._handlesGroup = o([this._connection.on("data-received", (e11) => this._onFeature(e11)), this._connection.on("message-received", (e11) => this._onWebSocketMessage(e11))]), this._connectionState.connection = this._connection;
  }
  clear() {
    this._manager.checkForUpdates(), this._stagingStore.clear(), this._forceRefresh = true;
  }
  updateCustomParameters(e10) {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.updateCustomParameters(e10);
  }
  sendMessageToSocket(e10) {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.sendMessageToSocket(e10);
  }
  sendMessageToClient(e10) {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.sendMessageToClient(e10);
  }
  _onWebSocketMessage(e10) {
    if ("type" in e10)
      switch (e10.type) {
        case "delete":
          if (e10.objectIds)
            for (const t12 of e10.objectIds)
              this._manager.removeById(t12);
          if (e10.trackIds)
            for (const t12 of e10.trackIds)
              this._manager.removeByTrackId(t12);
          break;
        case "clear":
          this.clear();
      }
    this.events.emit("message-received", e10);
  }
  _onFeature(e10) {
    try {
      this._manager.add(e10), this.events.emit("data-received", e10);
    } catch (t12) {
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/SourceChunkStore.js
var n15 = class {
  constructor(s17) {
    this._onChange = s17, this._chunks = /* @__PURE__ */ new Map(), this._chunksToRemove = [], this.events = new o2(), this.featureAdapter = new t4();
  }
  destroy() {
    this.clear();
  }
  clear() {
    for (const e10 of this._chunks.values())
      this._chunksToRemove.push(e10);
    this._chunks.clear(), null != this._overrideChunk && this._chunksToRemove.push(this._overrideChunk), this._overrideChunk = null;
  }
  *chunks() {
    this._overrideChunk && (yield this._overrideChunk), yield* this._chunks.values();
  }
  insert(e10) {
    var _a;
    has("esri-2d-update-debug") && console.debug(`Chunk[${e10.chunkId}] SourceChunkStore.insert`), ((_a = this._overrideChunk) == null ? void 0 : _a.overriddenIds.size) && e10.reader.removeIds(this._overrideChunk.overriddenIds), this._chunks.set(e10.chunkId, e10), this.events.emit("changed"), this._onChange();
  }
  remove(e10) {
    has("esri-2d-update-debug") && console.debug(`Chunk[${e10.chunkId}] SourceChunkStore.remove`), this._chunks.delete(e10.chunkId), this._chunksToRemove.push(e10);
  }
  cleanupRemovedChunks() {
    const e10 = this._chunksToRemove;
    return this._chunksToRemove = [], e10;
  }
  applyOverrides(e10, s17) {
    null == this._overrideChunk && (this._overrideChunk = new t7(s17)), this._overrideChunk.applyOverrides(e10);
    for (const o18 of this._chunks.values())
      o18.reader.removeIds(this._overrideChunk.overriddenIds), o18.invalidate();
  }
  forEach(e10) {
    const s17 = /* @__PURE__ */ new Set();
    for (const o18 of this.chunks()) {
      const r11 = o18.reader.getCursor();
      for (; r11.next(); ) {
        const o19 = r11.getObjectId();
        s17.has(o19) || (e10(r11.copy()), s17.add(o19));
      }
    }
  }
  forEachUnsafe(e10) {
    const s17 = /* @__PURE__ */ new Set();
    for (const o18 of this.chunks()) {
      const r11 = o18.reader.getCursor();
      for (; r11.next(); ) {
        const o19 = r11.getObjectId();
        s17.has(o19) || (e10(r11), s17.add(o19));
      }
    }
  }
  forEachInBounds(e10, s17) {
    const o18 = /* @__PURE__ */ new Set();
    for (const r11 of this.chunks()) {
      const n16 = r11.queryFeaturesInBounds(e10);
      for (; n16.next(); ) {
        const e11 = n16.getObjectId();
        o18.has(e11) || (s17(n16.copy()), o18.add(e11));
      }
    }
  }
  forEachBounds(e10, o18) {
    const r11 = i();
    for (const s17 of e10) {
      s17.getBounds(r11) && o18(r11);
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSource.js
var v = class {
  constructor(e10, t12, s17, r11) {
    this._aggregateAdapter = e10, this._subscriptions = t12, this._onChange = s17, this._connection = r11, this._updateTracking = new d5({ debugName: "FeatureSource" }), this._didInvalidateData = false, this._store = new n15(this._onChange);
  }
  destroy() {
    var _a, _b;
    (_a = this._strategy) == null ? void 0 : _a.destroy(), this._store.destroy(), (_b = this._streamMessenger) == null ? void 0 : _b.destroy();
  }
  get _eventLog() {
    return this._connection.eventLog;
  }
  get metadata() {
    if (!this._metadata)
      throw new Error("InternalError: Metadata not defined. Was update called?");
    return this._metadata;
  }
  get service() {
    return this._schema.service;
  }
  get store() {
    return this._store;
  }
  get streamMessenger() {
    return null == this._streamMessenger && this._initStreamMessenger(), this._streamMessenger;
  }
  get statistics() {
    return t8.from(this._store);
  }
  get updateTracking() {
    return this._updateTracking;
  }
  get queryEngine() {
    if (!this._queryEngine) {
      if (!this._schema)
        return null;
      const { dataFilter: e10 } = this._schema.mutable, t12 = this._schema.mutable.availableFields, s17 = this._metadata;
      this._queryEngine = new $({ featureStore: this._store, fieldsIndex: s17.fieldsIndex, geometryType: s17.geometryType, objectIdField: s17.objectIdField, hasM: false, hasZ: false, spatialReference: e10.outSpatialReference, cacheSpatialQueries: true, aggregateAdapter: this._aggregateAdapter, timeInfo: s17.timeInfo, definitionExpression: e10.definitionExpression, availableFields: t12 });
    }
    return this._queryEngine;
  }
  get isStream() {
    return "stream" === this._schema.type;
  }
  chunks() {
    return Array.from(this._store.chunks());
  }
  cleanupRemovedChunks() {
    return this._store.cleanupRemovedChunks();
  }
  onSubscribe(e10) {
    var _a;
    this._eventLog.onEvent({ type: "subscribe", tile: e10.tile.id });
    const t12 = (_a = this._strategy) == null ? void 0 : _a.load(e10);
    t12 && (t12.then(() => this._eventLog.onEvent({ type: "loaded", tile: e10.tile.id })).catch((t13) => this._eventLog.onEvent({ type: "error", tile: e10.tile.id, error: t13 })), this._updateTracking.addPromise(t12));
  }
  onResume(e10) {
    var _a;
    this._updateTracking.addPromise(d((_a = this._strategy) == null ? void 0 : _a.load(e10)));
  }
  onUnsubscribe(e10) {
    var _a;
    this._eventLog.onEvent({ type: "unsubscribe", tile: e10.tile.id }), (_a = this._strategy) == null ? void 0 : _a.unload(e10);
  }
  getOverride(e10) {
    return this._updateTracking.addPromise(this._doGetOverride(e10));
  }
  applyOverride(e10) {
    this._didInvalidateData = true, this._store.applyOverrides(e10, this.metadata);
  }
  async update(e10, t12) {
    var _a, _b, _c;
    const s17 = e10.source, n16 = d3((_a = this._schema) == null ? void 0 : _a.mutable, s17.mutable);
    if (!n16)
      return false;
    if (has("esri-2d-update-debug") && console.debug(`Version[${t12}] FeatureSource.update`, { changes: n16 }), this._schema = s17, this._metadata = new i3(this._schema.service.metadata), (_b = this._queryEngine) == null ? void 0 : _b.destroy(), this._queryEngine = null, "feature" === this._schema.type && null != this._schema.service.queryMetadata.lastEditDate && (this._lastEditDate = this._schema.service.queryMetadata.lastEditDate), null == this._streamMessenger && "stream" === this._schema.type && this._initStreamMessenger(), y2(n16, "sourceRefreshVersion") && ((_c = this._strategy) == null ? void 0 : _c.refresh))
      return await this._strategy.refresh(), true;
    if ("feature" === s17.type && y2(n16, "availableFields")) {
      if (await this._queryLastEditDateChanged() || this._didInvalidateData)
        this._didInvalidateData = false, await this._updateStrategy(t12);
      else {
        this._eventLog.onEvent({ type: "updateFieldsStart" });
        try {
          await this._strategy.updateFields(s17.mutable.availableFields), this._eventLog.onEvent({ type: "updateFieldsEnd" });
        } catch (o18) {
          this._eventLog.onEvent({ type: "updateFieldsError", error: o18 });
        }
      }
      return false;
    }
    return !(!s4(n16, "dataFilter") && !s4(n16, "sourceRefreshVersion")) && (await this._updateStrategy(t12), true);
  }
  _initStreamMessenger() {
    null == this._streamMessenger && (this._streamMessenger = new a9(this._connection));
  }
  async _doGetOverride(e10) {
    return this._strategy.queryOverride(e10);
  }
  async _queryLastEditDateChanged() {
    if (null == this._lastEditDate)
      return false;
    const t12 = this._schema.service.source, s17 = { ...t12.query, f: "json" }, r11 = (await U(t12.path, { query: s17, responseType: "json" })).data.editingInfo.lastEditDate;
    return r11 !== this._lastEditDate && (this._lastEditDate = r11, true);
  }
  async _createStrategy() {
    const e10 = this.service, t12 = "isSourceHosted" in e10 && e10.isSourceHosted, s17 = Array.isArray(e10.source), r11 = e10.source && "collection" in e10.source, a14 = t12 || s17 || r11;
    if ("stream" === this._schema.type) {
      const e11 = new h5(this._schema.service, this._schema.mutable.dataFilter, this._store, { outSR: this._schema.mutable.dataFilter.outSpatialReference }, this.metadata);
      return this._streamMessenger.strategy = e11, e11;
    }
    const i10 = n11.fromSchema(this._schema, this._metadata), n16 = await this._supportSnapshotMode(this._schema, i10);
    return n16 ? new a13(this._schema.service, i10, this._store, n16.featureCount, this.metadata, this._eventLog) : a14 ? new a12(this._schema.service, i10, this._store, this.metadata, this._eventLog) : new n13(this._schema.service, i10, this._store, this.metadata, this._eventLog);
  }
  async _updateStrategy(e10) {
    var _a;
    const t12 = await this._createStrategy();
    this._eventLog.onEvent({ type: "updateStrategyStart", about: t12.about });
    const r11 = !!this._strategy;
    this._store.clear(), (_a = this._strategy) == null ? void 0 : _a.destroy(), this._strategy = t12, has("esri-2d-update-debug") && console.debug(`Version[${e10}] FeatureSource.updateStrategy`, { strategy: t12 });
    const a14 = Array.from(this._subscriptions.values());
    if (!a14.length)
      return void this._eventLog.onEvent({ type: "updateStrategyEnd" });
    const i10 = Promise.all(a14.map((e11) => this._strategy.load(e11).then(() => this._eventLog.onEvent({ type: "loaded", tile: e11.tile.id })).catch((t13) => this._eventLog.onEvent({ type: "error", tile: e11.tile.id, error: t13 }))));
    this._updateTracking.addPromise(i10);
    try {
      r11 && await i10;
    } catch (n16) {
      f(n16);
    }
    this._eventLog.onEvent({ type: "updateStrategyEnd" }), has("esri-2d-update-debug") && console.debug(`Version[${e10}] FeatureSource.updateStrategyEnd`, { strategy: t12 });
  }
  async _supportSnapshotMode(e10, t12) {
    const { queryMetadata: s17 } = e10.service, r11 = s17.snapshotInfo;
    if (!r11 || !r11.supportsSnapshotMinThreshold || !r11.snapshotCountThresholds)
      return null;
    const a14 = e10.service.source, i10 = t12.createQuery();
    i10.inner.orderByFields = [], i10.inner.returnGeometry = false;
    const n16 = (await S2(a14, i10.inner, { query: i10.customParameters })).data.count, { min: h6, max: d9 } = r11.snapshotCountThresholds;
    return n16 <= h6 || r11.supportsSnapshotMaxThreshold && n16 < d9 ? { featureCount: n16 } : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureTileSubscription.js
var r10 = class {
  constructor(r11, s17) {
    this._handles = new r(), this._abortController = new AbortController(), this._resolver = L(), this._isDone = false, this._aborted = false, this.tile = r11, this._version = s17, this._handles.add([]);
  }
  destroy() {
    this.pause(), this._handles.destroy();
  }
  get key() {
    return this.tile.key;
  }
  get version() {
    return this._version;
  }
  set version(t12) {
    this._version = t12;
  }
  get signal() {
    return this._abortController.signal;
  }
  get options() {
    return { signal: this._abortController.signal };
  }
  get done() {
    return this._resolver.promise;
  }
  get isDone() {
    return this._isDone;
  }
  resolve() {
    this._isDone = true, this._resolver.resolve();
  }
  get paused() {
    return this._aborted;
  }
  resume() {
    this._abortController = new AbortController(), this._aborted = false;
  }
  pause() {
    this._aborted || (this._aborted = true, this._abortController.abort());
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorker.js
var f6 = class {
  constructor(e10) {
    this.inner = e10, this.resolver = L();
  }
};
var b4 = class {
  constructor() {
    this._aggregateAdapter = { getFeatureObjectIds: (e10) => this._processor.getFeatureObjectIdsForAggregate(e10) }, this._subscriptions = /* @__PURE__ */ new Map(), this._updateRequested = false, this._updateSubscriptionRequests = [], this._updateHighlightRequests = [];
  }
  destroy() {
    this._subscriptions.clear(), this._processor.destroy(), this._source.destroy(), this._handles.remove(), this._updateOverridesRequest = null, this._tileInfoView = null;
  }
  onDetach() {
    this.destroy(), this._initialize(this._connection);
  }
  _initialize(e10) {
    this._source = new v(this._aggregateAdapter, this._subscriptions, () => this._requestUpdate(), e10), this._processor = new _4(e10, this._source), this._handles = o([d2(() => this._source.updateTracking.updating, () => {
      this._requestUpdate(), this._connection.layerView.setUpdating({ data: this._source.updateTracking.updating, pipeline: true });
    })]);
  }
  set remoteClient(e10) {
    this._connection = new e4(e10), this._initialize(this._connection);
  }
  get features() {
    const t12 = this._source.queryEngine;
    if (!t12)
      throw new s("no-queryEngine", "No query engine defined");
    return t12;
  }
  get aggregates() {
    const t12 = this._processor.aggregateQueryEngine;
    if (!t12)
      throw new s("no-queryEngine", "No aggregate query engine defined");
    return t12;
  }
  get processor() {
    return this._processor;
  }
  get streamMessenger() {
    return this._source.streamMessenger;
  }
  getDisplayFeatures(e10) {
    return this._processor.getDisplayFeatures(e10);
  }
  async updateSchema(e10, t12) {
    return has("esri-2d-update-debug") && this._updateSchemaRequest && console.error("InternalError: Schema already updating"), this._updateSchemaRequest = new f6({ schema: e10, version: t12 }), this._requestUpdate(), this._updateSchemaRequest.resolver.promise;
  }
  updateSubscriptions(e10) {
    const t12 = new f6(e10);
    return this._updateSubscriptionRequests.push(t12), this._requestUpdate(), t12.resolver.promise;
  }
  updateHighlight(e10) {
    const t12 = new f6(e10);
    return this._updateHighlightRequests.push(t12), this._requestUpdate(), t12.resolver.promise;
  }
  async onEdits(t12) {
    if (null != this._updateOverridesRequest)
      throw new s("InternalError - Already processing an edit");
    this._updateOverridesRequest = new f6(t12);
    const s17 = this._updateOverridesRequest.resolver.promise;
    return this._requestUpdate(), s17;
  }
  queryStatistics() {
    return this._source.statistics.toJSON();
  }
  async queryVisibleFeatures(e10, t12) {
    return this.features.executeQuery(e10, t12);
  }
  async queryHeatmapStatistics(e10) {
    const t12 = Math.round(u2(e10.radius));
    let s17 = Number.POSITIVE_INFINITY, i10 = Number.NEGATIVE_INFINITY;
    const r11 = "string" == typeof e10.fieldOffset, o18 = e10.fieldOffset ?? 0, n16 = Array.from(this._subscriptions.values()), a14 = this._source.chunks(), d9 = t12 ** 2, p7 = 3 / (Math.PI * d9), h6 = 2 * t12, l7 = Math.ceil(a2 / h6);
    for (const u7 of n16) {
      const t13 = u7.tile, n17 = new Float64Array(l7 * l7);
      for (const s18 of a14) {
        const i11 = s18.getTileReader(t13);
        if (!i11)
          continue;
        const u8 = i11.getCursor();
        for (; u8.next(); ) {
          let t14 = 1;
          if (null != e10.field) {
            const s20 = u8.readAttribute(e10.field);
            t14 = r11 ? -1 * +s20 : +s20 + o18;
          }
          const s19 = u8.readXForDisplay() / h6, i12 = u8.readYForDisplay() / h6, a15 = Math.floor(s19), c10 = Math.floor(i12);
          if (a15 < 0 || c10 < 0 || a15 >= l7 || c10 >= l7)
            continue;
          const g4 = ((0.5 + a15 - s19) * h6) ** 2 + ((0.5 + c10 - i12) * h6) ** 2;
          if (g4 > d9)
            continue;
          const _6 = t14 * (p7 * (1 - g4 / d9) ** 2);
          n17[c10 + a15 * l7] += _6;
        }
      }
      for (let e11 = 0; e11 < n17.length; e11++)
        s17 = Math.min(s17, n17[e11]), i10 = Math.max(i10, n17[e11]);
    }
    return { max: i10, min: s17 };
  }
  async getSampleFeatures(e10) {
    const t12 = this._source.chunks();
    if (t12.reduce((e11, t13) => e11 + t13.size(), 0) <= e10.minFeatureCount) {
      if (!this._source.updateTracking.updating) {
        const e11 = [];
        return this._source.store.forEachUnsafe((t13) => e11.push(t13.readLegacyFeatureWorldSpace())), e11;
      }
      return null;
    }
    const s17 = /* @__PURE__ */ new Set(), i10 = [], r11 = t12.map((e11) => e11.reader.getCursor()), n16 = new t(), u7 = 3 * e10.sampleSize;
    for (let o18 = 0; o18 < u7 && i10.length < e10.sampleSize; o18++) {
      const e11 = r11[n16.getIntRange(0, t12.length - 1)];
      if (0 === e11.getSize())
        continue;
      const o19 = n16.getIntRange(0, e11.getSize() - 1);
      e11.setIndex(o19);
      const u8 = e11.getObjectId();
      s17.has(u8) || (s17.add(u8), i10.push(e11.readLegacyFeatureWorldSpace()));
    }
    return i10.length >= e10.sampleSize ? i10 : null;
  }
  _requestUpdate() {
    this._updateRequested || (this._updateRequested = true, t2(() => this._scheduleNextUpdate()));
  }
  _scheduleNextUpdate() {
    this._updateRequested && (this._ongoingUpdate || (this._ongoingUpdate = this._doUpdate().finally(() => {
      this._ongoingUpdate = null, this._scheduleNextUpdate();
    }), this._updateRequested = false));
  }
  _subscribe(e10) {
    const t12 = e10.tileId;
    if (this._subscriptions.has(t12)) {
      const s18 = this._subscriptions.get(t12);
      return void (s18.paused && (has("esri-2d-update-debug") && console.debug(`Tile[${t12}] Pipeline.resume`), s18.resume(), s18.version = e10.version, this._source.onResume(s18)));
    }
    has("esri-2d-update-debug") && console.debug(`Tile[${t12}] Pipeline.subscribe`);
    const s17 = new n7(this._tileInfoView, t12), i10 = new r10(s17, e10.version);
    this._subscriptions.set(t12, i10), this._source.onSubscribe(i10), this._processor.onSubscribe(i10);
  }
  _unsubscribe(e10) {
    const t12 = this._subscriptions.get(e10);
    t12 && (has("esri-2d-update-debug") && console.debug(`Tile[${e10}] Pipeline.unsubscribe`), this._source.onUnsubscribe(t12), this._processor.onUnsubscribe(t12), this._subscriptions.delete(t12.key.id), t12.destroy());
  }
  _pauseSubscription(e10) {
    const t12 = this._subscriptions.get(e10);
    t12 && (has("esri-2d-update-debug") && console.debug(`Tile[${e10}] Pipeline.pause`), t12.pause());
  }
  async _doUpdate() {
    if (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateStart"), await this._connection.layerView.setUpdating({ data: this._source.updateTracking.updating, pipeline: true }), this._updateSubscriptionRequests.length) {
      const e11 = this._updateSubscriptionRequests;
      this._updateSubscriptionRequests = [];
      for (const t13 of e11)
        this._doUpdateSubscriptions(t13.inner), t13.resolver.resolve();
    }
    const e10 = this._updateSchemaRequest;
    if (this._updateSchemaRequest = null, null != e10) {
      const { schema: t13, version: s18 } = e10.inner;
      await this._doUpdateSchema(t13, s18);
    }
    const t12 = this._updateOverridesRequest;
    if (this._updateOverridesRequest = null, null != t12) {
      has("esri-2d-update-debug") && console.debug("Pipeline.applyEditOverride", t12.inner);
      const e11 = await this._source.getOverride(t12.inner);
      await this._processor.applyOverride(e11), has("esri-2d-update-debug") && console.debug("Pipeline.endEditOverride", t12.inner);
    }
    if (this._updateHighlightRequests.length) {
      const e11 = this._updateHighlightRequests;
      this._updateHighlightRequests = [];
      for (const t13 of e11)
        this._processor.updateHighlight(t13.inner), t13.resolver.resolve();
    }
    const s17 = this._source.cleanupRemovedChunks();
    this._processor.removeChunks(s17);
    try {
      this._subscriptions.size && (has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksStart"), await this._processor.updateChunks(), has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksEnd"));
    } catch (r11) {
      f(r11);
    }
    null != t12 && t12.resolver.resolve(), null != e10 && e10.resolver.resolve(), this._updateRequested ? (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=true]"), await this._connection.layerView.setUpdating({ data: this._source.updateTracking.updating, pipeline: true })) : (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=false, After flush]"), await this._connection.layerView.setUpdating({ data: this._source.updateTracking.updating, pipeline: this._updateRequested }));
  }
  async _doUpdateSchema(e10, t12) {
    var _a;
    if (has("esri-2d-update-debug") && console.debug(`Version[${t12}] Pipeline.updateStart`, { schema: e10 }), !this._tileInfoView) {
      const t13 = j.fromJSON(e10.source.tileInfoJSON);
      this._tileInfoView = new h2(t13);
    }
    const s17 = { tileInfo: (_a = this._tileInfoView) == null ? void 0 : _a.tileInfo };
    try {
      const i10 = await this._source.update(e10, t12), r11 = Array.from(this._subscriptions.values());
      await this._processor.update(e10, t12, s17, i10, r11);
    } catch (i10) {
      console.error(i10);
    }
    has("esri-2d-update-debug") && console.debug(`Version[${t12}] Pipeline.updateEnd`);
  }
  _doUpdateSubscriptions(e10) {
    if (has("esri-2d-update-debug") && console.debug("Pipeline.updateSubscriptions", e10), !this._tileInfoView) {
      const t12 = j.fromJSON(e10.tileInfoJSON);
      this._tileInfoView = new h2(t12);
    }
    for (const t12 of e10.subscribe)
      this._subscribe(t12);
    for (const t12 of e10.unsubscribe)
      this._unsubscribe(t12);
    if (has("featurelayer-query-pausing-enabled"))
      for (const t12 of e10.pause)
        this._pauseSubscription(t12);
  }
};
export {
  b4 as default
};
//# sourceMappingURL=FeaturePipelineWorker-FDAO2C2Q.js.map
