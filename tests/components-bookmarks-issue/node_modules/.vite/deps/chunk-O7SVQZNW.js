import {
  o as o3
} from "./chunk-67GTVIII.js";
import {
  n as n5
} from "./chunk-I7LDU4W6.js";
import {
  i as i3,
  o as o2
} from "./chunk-SCRCLNT5.js";
import {
  n as n4
} from "./chunk-7VV4JAZJ.js";
import {
  n as n3,
  p as p2
} from "./chunk-J6T3FJLS.js";
import {
  R
} from "./chunk-G7YFDDME.js";
import {
  f as f3
} from "./chunk-QYC3GV65.js";
import {
  f as f4,
  i as i2,
  s as s3
} from "./chunk-I2X6UR6L.js";
import {
  b2 as b
} from "./chunk-X7VSXJWW.js";
import {
  n
} from "./chunk-VEODBKUJ.js";
import {
  i as i4
} from "./chunk-AG6JXA4M.js";
import {
  n as n2
} from "./chunk-B647DRFJ.js";
import {
  i
} from "./chunk-PJNK3TLV.js";
import {
  p,
  y as y2
} from "./chunk-J7AMTUNG.js";
import {
  y as y3
} from "./chunk-HU5IGOTI.js";
import {
  c
} from "./chunk-I5RCKVDX.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  f as f2
} from "./chunk-MBGZKT2Z.js";
import {
  W2 as W,
  d2 as d
} from "./chunk-UWQ3OYA5.js";
import {
  o
} from "./chunk-YOPMY6TS.js";
import {
  r as r2
} from "./chunk-VIN55KNF.js";
import {
  U
} from "./chunk-SAYWXQVM.js";
import {
  f
} from "./chunk-SBL4URUW.js";
import {
  v as v2
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a,
  r2 as r,
  v
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  e as e2,
  k as k2,
  s as s2
} from "./chunk-JGDJR5EV.js";
import {
  s
} from "./chunk-7RBRCL6S.js";
import {
  has,
  k
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/rest/operations/identify.js
function o4(e3, r3) {
  const { dpi: n6, gdbVersion: s4, geometry: o5, geometryPrecision: a5, height: m3, historicMoment: p4, layerOption: f6, mapExtent: y4, maxAllowableOffset: u3, returnFieldName: c2, returnGeometry: d3, returnUnformattedValues: g, returnZ: x, spatialReference: h, timeExtent: b2, tolerance: E, width: O } = e3.toJSON(), { dynamicLayers: S3, layerDefs: j, layerIds: N } = l(e3), $ = null != (r3 == null ? void 0 : r3.geometry) ? r3.geometry : null, I = { historicMoment: p4, geometryPrecision: a5, maxAllowableOffset: u3, returnFieldName: c2, returnGeometry: d3, returnUnformattedValues: g, returnZ: x, tolerance: E }, R3 = $ && $.toJSON() || o5;
  I.imageDisplay = `${O},${m3},${n6}`, s4 && (I.gdbVersion = s4), R3 && (delete R3.spatialReference, I.geometry = JSON.stringify(R3), I.geometryType = p(R3));
  const U3 = h ?? (R3 == null ? void 0 : R3.spatialReference) ?? (y4 == null ? void 0 : y4.spatialReference);
  if (U3 && (I.sr = d(U3)), I.time = b2 ? [b2.start, b2.end].join(",") : null, y4) {
    const { xmin: e4, ymin: t, xmax: r4, ymax: i5 } = y4;
    I.mapExtent = `${e4},${t},${r4},${i5}`;
  }
  return j && (I.layerDefs = j), S3 && !j && (I.dynamicLayers = S3), I.layers = "popup" === f6 ? "visible" : f6, N && !S3 && (I.layers += `:${N.join(",")}`), I;
}
function l(e3) {
  var _a, _b;
  const { mapExtent: t, floors: i5, width: o5, sublayers: l2, layerIds: m3, layerOption: p4, gdbVersion: f6 } = e3, y4 = (_b = (_a = l2 == null ? void 0 : l2.find((e4) => null != e4.layer)) == null ? void 0 : _a.layer) == null ? void 0 : _b.serviceSublayers, u3 = "popup" === p4, c2 = {}, d3 = i3({ extent: t, width: o5, spatialReference: t == null ? void 0 : t.spatialReference }), g = [], x = (e4) => {
    const t2 = 0 === d3, r3 = 0 === e4.minScale || d3 <= e4.minScale, i6 = 0 === e4.maxScale || d3 >= e4.maxScale;
    if (e4.visible && (t2 || r3 && i6))
      if (e4.sublayers)
        e4.sublayers.forEach(x);
      else {
        if (false === (m3 == null ? void 0 : m3.includes(e4.id)) || u3 && (!e4.popupTemplate || !e4.popupEnabled))
          return;
        g.unshift(e4);
      }
  };
  if (l2 == null ? void 0 : l2.forEach(x), l2 && !g.length)
    c2.layerIds = [];
  else {
    const e4 = n4(g, y4, f6), t2 = g.map((e5) => {
      const t3 = n5(i5, e5);
      return e5.toExportImageJSON(t3);
    });
    if (e4)
      c2.dynamicLayers = JSON.stringify(t2);
    else {
      if (l2) {
        let e6 = g.map(({ id: e7 }) => e7);
        m3 && (e6 = e6.filter((e7) => m3.includes(e7))), c2.layerIds = e6;
      } else
        (m3 == null ? void 0 : m3.length) && (c2.layerIds = m3);
      const e5 = a2(i5, g);
      if (null != e5 && e5.length) {
        const t3 = {};
        for (const r3 of e5)
          r3.definitionExpression && (t3[r3.id] = r3.definitionExpression);
        Object.keys(t3).length && (c2.layerDefs = JSON.stringify(t3));
      }
    }
  }
  return c2;
}
function a2(t, r3) {
  const i5 = !!(t == null ? void 0 : t.length), s4 = r3.filter((e3) => null != e3.definitionExpression || i5 && null != e3.floorInfo);
  return s4.length ? s4.map((r4) => {
    const i6 = n5(t, r4), s5 = n(i6, r4.definitionExpression);
    return { id: r4.id, definitionExpression: s5 ?? void 0 };
  }) : null;
}

// node_modules/@arcgis/core/rest/support/IdentifyParameters.js
var a3;
var u = a3 = class extends f {
  static from(t) {
    return v(a3, t);
  }
  constructor(t) {
    super(t), this.dpi = 96, this.floors = null, this.gdbVersion = null, this.geometry = null, this.geometryPrecision = null, this.height = 400, this.historicMoment = null, this.layerIds = null, this.layerOption = "top", this.mapExtent = null, this.maxAllowableOffset = null, this.returnFieldName = true, this.returnGeometry = false, this.returnM = false, this.returnUnformattedValues = true, this.returnZ = false, this.spatialReference = null, this.sublayers = null, this.timeExtent = null, this.tolerance = null, this.width = 400;
  }
  writeHistoricMoment(t, e3) {
    e3.historicMoment = t && t.getTime();
  }
};
e([y({ type: Number, json: { write: true } })], u.prototype, "dpi", void 0), e([y()], u.prototype, "floors", void 0), e([y({ type: String, json: { write: true } })], u.prototype, "gdbVersion", void 0), e([y({ types: n2, json: { read: y2, write: true } })], u.prototype, "geometry", void 0), e([y({ type: Number, json: { write: true } })], u.prototype, "geometryPrecision", void 0), e([y({ type: Number, json: { write: true } })], u.prototype, "height", void 0), e([y({ type: Date })], u.prototype, "historicMoment", void 0), e([r2("historicMoment")], u.prototype, "writeHistoricMoment", null), e([y({ type: [Number], json: { write: true } })], u.prototype, "layerIds", void 0), e([y({ type: ["top", "visible", "all", "popup"], json: { write: true } })], u.prototype, "layerOption", void 0), e([y({ type: w, json: { write: true } })], u.prototype, "mapExtent", void 0), e([y({ type: Number, json: { write: true } })], u.prototype, "maxAllowableOffset", void 0), e([y({ type: Boolean, json: { write: true } })], u.prototype, "returnFieldName", void 0), e([y({ type: Boolean, json: { write: true } })], u.prototype, "returnGeometry", void 0), e([y({ type: Boolean, json: { write: true } })], u.prototype, "returnM", void 0), e([y({ type: Boolean, json: { write: true } })], u.prototype, "returnUnformattedValues", void 0), e([y({ type: Boolean, json: { write: true } })], u.prototype, "returnZ", void 0), e([y({ type: f2, json: { write: true } })], u.prototype, "spatialReference", void 0), e([y()], u.prototype, "sublayers", void 0), e([y({ type: c, json: { write: true } })], u.prototype, "timeExtent", void 0), e([y({ type: Number, json: { write: true } })], u.prototype, "tolerance", void 0), e([y({ type: Number, json: { write: true } })], u.prototype, "width", void 0), u = a3 = e([a("esri.rest.support.IdentifyParameters")], u);
var d2 = u;

// node_modules/@arcgis/core/rest/support/IdentifyResult.js
var u2 = class extends f {
  constructor(r3) {
    super(r3), this.displayFieldName = null, this.feature = null, this.layerId = null, this.layerName = null;
  }
  readFeature(r3, t) {
    return f3.fromJSON({ attributes: { ...t.attributes }, geometry: { ...t.geometry } });
  }
  writeFeature(r3, e3) {
    if (!r3)
      return;
    const { attributes: t, geometry: o5 } = r3;
    t && (e3.attributes = { ...t }), null != o5 && (e3.geometry = o5.toJSON(), e3.geometryType = i.toJSON(o5.type));
  }
};
e([y({ type: String, json: { write: true } })], u2.prototype, "displayFieldName", void 0), e([y({ type: f3 })], u2.prototype, "feature", void 0), e([o("feature", ["attributes", "geometry"])], u2.prototype, "readFeature", null), e([r2("feature")], u2.prototype, "writeFeature", null), e([y({ type: Number, json: { write: true } })], u2.prototype, "layerId", void 0), e([y({ type: String, json: { write: true } })], u2.prototype, "layerName", void 0), u2 = e([a("esri.rest.support.IdentifyResult")], u2);
var m = u2;

// node_modules/@arcgis/core/rest/identify.js
async function f5(u3, i5, f6) {
  const c2 = (i5 = a4(i5)).geometry ? [i5.geometry] : [], l2 = f4(u3);
  return l2.path += "/identify", R(c2).then((e3) => {
    const t = o4(i5, { geometry: e3 == null ? void 0 : e3[0] }), u4 = s3({ ...l2.query, f: "json", ...t }), a5 = i2(u4, f6);
    return U(l2.path, a5).then(m2).then((r3) => p3(r3, i5.sublayers));
  });
}
function m2(r3) {
  const e3 = r3.data;
  return e3.results = e3.results || [], e3.exceededTransferLimit = Boolean(e3.exceededTransferLimit), e3.results = e3.results.map((r4) => m.fromJSON(r4)), e3;
}
function a4(r3) {
  return r3 = d2.from(r3);
}
function p3(r3, e3) {
  if (!(e3 == null ? void 0 : e3.length))
    return r3;
  const t = /* @__PURE__ */ new Map();
  function o5(r4) {
    t.set(r4.id, r4), r4.sublayers && r4.sublayers.forEach(o5);
  }
  e3.forEach(o5);
  for (const s4 of r3.results)
    s4.feature.sourceLayer = t.get(s4.layerId);
  return r3;
}

// node_modules/@arcgis/core/views/layers/support/MapServiceLayerViewHelper.js
var G = null;
function S2(e3, t) {
  return "tile" === t.type || "map-image" === t.type;
}
var U2 = class extends S {
  constructor(e3) {
    super(e3), this._featuresResolutions = /* @__PURE__ */ new WeakMap(), this.highlightGraphics = null, this.highlightGraphicUpdated = null, this.updateHighlightedFeatures = k2(async (e4) => {
      this.destroyed || this.updatingHandles.addPromise(this._updateHighlightedFeaturesGeometries(e4).catch(() => {
      }));
    });
  }
  initialize() {
    const e3 = (e4) => {
      this.updatingHandles.addPromise(this._updateHighlightedFeaturesSymbols(e4).catch(() => {
      })), this.updateHighlightedFeatures(this._highlightGeometriesResolution);
    };
    this.addHandles([v2(() => this.highlightGraphics, "change", (t) => e3(t.added), { onListenerAdd: (t) => e3(t) })]);
  }
  async fetchPopupFeaturesAtLocation(e3, t) {
    var _a, _b;
    const { layerView: { layer: r3, view: { scale: s4 } } } = this;
    if (!e3)
      throw new s("fetchPopupFeatures:invalid-area", "Nothing to fetch without area", { layer: r3 });
    const i5 = _(r3.sublayers, s4, t);
    if (!i5.length)
      return [];
    const a5 = await A(r3, i5);
    if (!((((_b = (_a = r3.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsIdentify) ?? true) && r3.version >= 10.5) && !a5)
      throw new s("fetchPopupFeatures:not-supported", "query operation is disabled for this service", { layer: r3 });
    return a5 ? this._fetchPopupFeaturesUsingQueries(e3, i5, t) : this._fetchPopupFeaturesUsingIdentify(e3, i5, t);
  }
  clearHighlights() {
    var _a;
    (_a = this.highlightGraphics) == null ? void 0 : _a.removeAll();
  }
  highlight(e3) {
    const r3 = this.highlightGraphics;
    if (!r3)
      return e2();
    let o5 = null;
    if (e3 instanceof f3 ? o5 = [e3] : V.isCollection(e3) && e3.length > 0 ? o5 = e3.toArray() : Array.isArray(e3) && e3.length > 0 && (o5 = e3), o5 = o5 == null ? void 0 : o5.filter(k), !(o5 == null ? void 0 : o5.length))
      return e2();
    for (const t of o5) {
      const e4 = t.sourceLayer;
      null != e4 && "geometryType" in e4 && "point" === e4.geometryType && (t.visible = false);
    }
    return r3.addMany(o5), e2(() => r3.removeMany(o5 ?? []));
  }
  async _updateHighlightedFeaturesSymbols(e3) {
    const { layerView: { view: t }, highlightGraphics: r3, highlightGraphicUpdated: s4 } = this;
    if (r3 && s4)
      for (const i5 of e3) {
        const e4 = i5.sourceLayer && "renderer" in i5.sourceLayer && i5.sourceLayer.renderer;
        i5.sourceLayer && "geometryType" in i5.sourceLayer && "point" === i5.sourceLayer.geometryType && e4 && "getSymbolAsync" in e4 && e4.getSymbolAsync(i5).then(async (o5) => {
          var _a;
          o5 || (o5 = new y3());
          let a5 = null;
          const n6 = "visualVariables" in e4 ? (_a = e4.visualVariables) == null ? void 0 : _a.find((e5) => "size" === e5.type) : void 0;
          n6 && (G || (G = (await import("./visualVariableUtils-OMMRO36I.js")).getSize), a5 = G(n6, i5, { view: t.type, scale: t.scale, shape: "simple-marker" === o5.type ? o5.style : null })), a5 || (a5 = "width" in o5 && "height" in o5 && null != o5.width && null != o5.height ? Math.max(o5.width, o5.height) : "size" in o5 ? o5.size : 16), r3.includes(i5) && (i5.symbol = new y3({ style: "square", size: a5, xoffset: "xoffset" in o5 ? o5.xoffset : 0, yoffset: "yoffset" in o5 ? o5.yoffset : 0 }), s4(i5, "symbol"), i5.visible = true);
        });
      }
  }
  async _updateHighlightedFeaturesGeometries(e3) {
    const { layerView: { layer: t, view: r3 }, highlightGraphics: s4, highlightGraphicUpdated: i5 } = this;
    if (this._highlightGeometriesResolution = e3, !i5 || !(s4 == null ? void 0 : s4.length) || !t.capabilities.operations.supportsQuery)
      return;
    const o5 = this._getTargetResolution(e3), a5 = /* @__PURE__ */ new Map();
    for (const c2 of s4)
      if (!this._featuresResolutions.has(c2) || this._featuresResolutions.get(c2) > o5) {
        const e4 = c2.sourceLayer;
        r(a5, e4, () => /* @__PURE__ */ new Map()).set(c2.getObjectId(), c2);
      }
    const l2 = Array.from(a5, ([e4, t2]) => {
      const s5 = e4.createQuery();
      return s5.objectIds = [...t2.keys()], s5.outFields = [e4.objectIdField], s5.returnGeometry = true, s5.maxAllowableOffset = o5, s5.outSpatialReference = r3.spatialReference, e4.queryFeatures(s5);
    }), p4 = await Promise.all(l2);
    if (!this.destroyed)
      for (const { features: n6 } of p4)
        for (const e4 of n6) {
          const t2 = e4.sourceLayer, r4 = a5.get(t2).get(e4.getObjectId());
          r4 && s4.includes(r4) && (r4.geometry = e4.geometry, i5(r4, "geometry"), this._featuresResolutions.set(r4, o5));
        }
  }
  _getTargetResolution(e3) {
    const t = e3 * W(this.layerView.view.spatialReference), r3 = t / 16;
    return r3 <= 10 ? 0 : e3 / t * r3;
  }
  async _fetchPopupFeaturesUsingIdentify(e3, t, r3) {
    const s4 = await this._createIdentifyParameters(e3, t, r3);
    if (null == s4)
      return [];
    const { results: i5 } = await f5(this.layerView.layer.parsedUrl, s4, r3);
    return i5.map((e4) => e4.feature);
  }
  async _createIdentifyParameters(e3, t, r3) {
    const { floors: s4, layer: i5, timeExtent: o5, view: { spatialReference: a5, scale: n6 } } = this.layerView;
    if (!t.length)
      return null;
    await Promise.all(t.map(({ sublayer: e4 }) => e4.load(r3).catch(() => {
    })));
    const l2 = Math.min(has("mapservice-popup-identify-max-tolerance"), i5.allSublayers.reduce((e4, t2) => t2.renderer ? o3({ renderer: t2.renderer, pointerType: r3 == null ? void 0 : r3.pointerType }) : e4, 2)), p4 = this.createFetchPopupFeaturesQueryGeometry(e3, l2), c2 = o2(n6, a5), u3 = Math.round(p4.width / c2), h = new w({ xmin: p4.center.x - c2 * u3, ymin: p4.center.y - c2 * u3, xmax: p4.center.x + c2 * u3, ymax: p4.center.y + c2 * u3, spatialReference: p4.spatialReference });
    return new d2({ floors: s4, gdbVersion: "gdbVersion" in i5 ? i5.gdbVersion : void 0, geometry: e3, height: u3, layerOption: "popup", mapExtent: h, returnGeometry: true, spatialReference: a5, sublayers: i5.sublayers, timeExtent: o5, tolerance: l2, width: u3 });
  }
  async _fetchPopupFeaturesUsingQueries(e3, t, r3) {
    const { layerView: { floors: i5, timeExtent: o5 } } = this, a5 = t.map(async ({ sublayer: t2, popupTemplate: s4 }) => {
      var _a;
      if (await t2.load(r3).catch(() => {
      }), t2.capabilities && !t2.capabilities.operations.supportsQuery)
        return [];
      const a6 = t2.createQuery(), n6 = o3({ renderer: t2.renderer, pointerType: r3 == null ? void 0 : r3.pointerType }), l2 = this.createFetchPopupFeaturesQueryGeometry(e3, n6), c2 = /* @__PURE__ */ new Set(), [u3] = await Promise.all([n3(t2, s4), (_a = t2.renderer) == null ? void 0 : _a.collectRequiredFields(c2, t2.fieldsIndex)]);
      s2(r3), b(c2, t2.fieldsIndex, u3);
      const h = Array.from(c2).sort();
      if (a6.geometry = l2, a6.outFields = h, a6.timeExtent = o5, i5) {
        const e4 = i5.clone(), r4 = n5(e4, t2);
        null != r4 && (a6.where = a6.where ? `(${a6.where}) AND (${r4})` : r4);
      }
      const y4 = this._getTargetResolution(l2.width / n6), m3 = await R2(s4);
      s2(r3);
      const f6 = "point" === t2.geometryType || m3 && m3.arcadeUtils.hasGeometryOperations(s4);
      f6 || (a6.maxAllowableOffset = y4);
      let { features: b2 } = await t2.queryFeatures(a6, r3);
      const v3 = f6 ? 0 : y4;
      b2 = await T(t2, b2, r3);
      for (const e4 of b2)
        this._featuresResolutions.set(e4, v3);
      return b2;
    });
    return (await Promise.allSettled(a5)).reduce((e4, t2) => "fulfilled" === t2.status ? [...e4, ...t2.value] : e4, []).filter(k);
  }
};
function _(e3, t, r3) {
  const s4 = [];
  if (!e3)
    return s4;
  const i5 = (e4) => {
    const o5 = 0 === e4.minScale || t <= e4.minScale, a5 = 0 === e4.maxScale || t >= e4.maxScale;
    if (e4.visible && o5 && a5) {
      if (e4.sublayers)
        e4.sublayers.forEach(i5);
      else if (e4.popupEnabled) {
        const t2 = p2(e4, { ...r3, defaultPopupTemplateEnabled: false });
        null != t2 && s4.unshift({ sublayer: e4, popupTemplate: t2 });
      }
    }
  };
  return e3.map(i5), s4;
}
function R2(e3) {
  var _a;
  return ((_a = e3.expressionInfos) == null ? void 0 : _a.length) || Array.isArray(e3.content) && e3.content.some((e4) => "expression" === e4.type) ? i4() : Promise.resolve();
}
async function A(e3, t) {
  var _a, _b;
  if ((_b = (_a = e3.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsQuery)
    return true;
  try {
    return await Promise.any(t.map(({ sublayer: e4 }) => e4.load().then(() => e4.capabilities.operations.supportsQuery)));
  } catch {
    return false;
  }
}
async function T(e3, t, r3) {
  const s4 = e3.renderer;
  return s4 && "defaultSymbol" in s4 && !s4.defaultSymbol && (t = s4.valueExpression ? await Promise.all(t.map((e4) => s4.getSymbolAsync(e4, r3).then((t2) => t2 ? e4 : null))).then((e4) => e4.filter((e5) => null != e5)) : t.filter((e4) => null != s4.getSymbol(e4))), t;
}
e([y({ constructOnly: true })], U2.prototype, "createFetchPopupFeaturesQueryGeometry", void 0), e([y({ constructOnly: true })], U2.prototype, "layerView", void 0), e([y({ constructOnly: true })], U2.prototype, "highlightGraphics", void 0), e([y({ constructOnly: true })], U2.prototype, "highlightGraphicUpdated", void 0), e([y({ constructOnly: true })], U2.prototype, "updatingHandles", void 0), U2 = e([a("esri.views.layers.support.MapServiceLayerViewHelper")], U2);

export {
  S2 as S,
  U2 as U
};
//# sourceMappingURL=chunk-O7SVQZNW.js.map
