import {
  o as o5
} from "./chunk-ZEMG7GKC.js";
import {
  o as o7
} from "./chunk-HBRJJENW.js";
import {
  e as e4
} from "./chunk-VHY5K2VE.js";
import {
  t
} from "./chunk-6ENXMQPD.js";
import {
  P
} from "./chunk-FV43HSGW.js";
import {
  d,
  f,
  p
} from "./chunk-ZR7OV2EH.js";
import {
  o as o4
} from "./chunk-LJULTBAY.js";
import {
  e as e3
} from "./chunk-6MGK5WBT.js";
import {
  o as o6
} from "./chunk-UYMREM3D.js";
import {
  o as o2
} from "./chunk-CDBOQCLE.js";
import {
  e as e2
} from "./chunk-VYSGSKHB.js";
import {
  o as o3
} from "./chunk-IDPLBNJX.js";
import {
  o
} from "./chunk-P4MNTMCZ.js";
import {
  e
} from "./chunk-GLF3KRAL.js";
import {
  n
} from "./chunk-AKEHDP75.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ScreenSizeScaling.glsl.js
function o8(o9, c) {
  if (!c.screenSizeEnabled)
    return;
  const n2 = o9.vertex;
  f(n2, c), n2.uniforms.add(new o3("perScreenPixelRatio", (e5, i) => i.camera.perScreenPixelRatio), new o3("screenSizeScale", (e5) => e5.screenSizeScale)), n2.code.add(o`float computeRenderPixelSizeAt( vec3 pWorld ){
vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);
float viewDirectionDistance = abs(dot(viewForward, pWorld - cameraPosition));
return viewDirectionDistance * perScreenPixelRatio;
}
vec3 screenSizeScaling(vec3 position, vec3 anchor){
return position * screenSizeScale * computeRenderPixelSizeAt(anchor) + anchor;
}`);
}

// node_modules/@arcgis/core/chunks/ShadedColorMaterial.glsl.js
function p2(e5) {
  const p3 = new o6(), b2 = e5.multipassEnabled && (e5.output === o2.Color || e5.output === o2.Alpha);
  p3.include(o5, e5), p3.include(o8, e5), p3.include(P, e5);
  const { vertex: h2, fragment: C } = p3;
  return C.include(e4), d(h2, e5), C.uniforms.add(new e3("uColor", (e6) => e6.color)), p3.attributes.add(e.POSITION, "vec3"), p3.varyings.add("vWorldPosition", "vec3"), b2 && p3.varyings.add("depth", "float"), e5.screenSizeEnabled && p3.attributes.add(e.OFFSET, "vec3"), e5.shadingEnabled && (p(h2), p3.attributes.add(e.NORMAL, "vec3"), p3.varyings.add("vViewNormal", "vec3")), h2.code.add(o`
    void main(void) {
      vWorldPosition = ${e5.screenSizeEnabled ? "screenSizeScaling(offset, position)" : "position"};
  `), e5.shadingEnabled && h2.code.add(o`vec3 worldNormal = normal;
vViewNormal = (viewNormal * vec4(worldNormal, 1)).xyz;`), h2.code.add(o`
    ${b2 ? "depth = (view * vec4(vWorldPosition, 1.0)).z;" : ""}
    gl_Position = transformPosition(proj, view, vWorldPosition);
  }
  `), b2 && p3.include(o7, e5), C.code.add(o`
    void main() {
      discardBySlice(vWorldPosition);
      ${b2 ? "terrainDepthTest(depth);" : ""}
    `), e5.shadingEnabled ? (C.uniforms.add(new e2("shadingDirection", (e6) => e6.shadingDirection)), C.uniforms.add(new e3("shadedColor", (e6) => w(e6.shadingTint, e6.color))), C.code.add(o`vec3 viewNormalNorm = normalize(vViewNormal);
float shadingFactor = 1.0 - clamp(-dot(viewNormalNorm, shadingDirection), 0.0, 1.0);
vec4 finalColor = mix(uColor, shadedColor, shadingFactor);`)) : C.code.add(o`vec4 finalColor = uColor;`), C.code.add(o`
      ${e5.output === o2.ObjectAndLayerIdColor ? o`finalColor.a = 1.0;` : ""}
      if (finalColor.a < ${o.float(t)}) {
        discard;
      }
      ${e5.output === o2.Alpha ? o`fragColor = vec4(finalColor.a);` : ""}

      ${e5.output === o2.Color ? o`fragColor = highlightSlice(finalColor, vWorldPosition); ${e5.transparencyPassType === o4.Color ? "fragColor = premultiplyAlpha(fragColor);" : ""}` : ""}
    }
    `), p3;
}
function w(e5, o9) {
  const r = 1 - e5[3], i = e5[3] + o9[3] * r;
  return 0 === i ? (b[3] = i, b) : (b[0] = (e5[0] * e5[3] + o9[0] * o9[3] * r) / i, b[1] = (e5[1] * e5[3] + o9[1] * o9[3] * r) / i, b[2] = (e5[2] * e5[3] + o9[2] * o9[3] * r) / i, b[3] = o9[3], b);
}
var b = n();
var h = Object.freeze(Object.defineProperty({ __proto__: null, build: p2 }, Symbol.toStringTag, { value: "Module" }));

export {
  p2 as p,
  h
};
//# sourceMappingURL=chunk-AEAYH74I.js.map
