import {
  B as B2
} from "./chunk-ZJXOOEWD.js";
import {
  C as C4,
  D as D3,
  G as G2,
  M,
  R,
  Y as Y2,
  a as a3,
  b as b2,
  e as e14,
  s as s5
} from "./chunk-J3NVEAU3.js";
import {
  f as f3,
  i as i5,
  t as t9,
  x as x2
} from "./chunk-Q2ACSSMW.js";
import {
  o as o5
} from "./chunk-J6WYS6OG.js";
import {
  a as a2
} from "./chunk-52QXS2S5.js";
import {
  o as o4
} from "./chunk-ARNGZTAW.js";
import {
  n as n8
} from "./chunk-UACJ4BQN.js";
import {
  ke,
  l as l4,
  u as u6
} from "./chunk-UC6QLXCR.js";
import {
  u as u5
} from "./chunk-YWPIIZFL.js";
import {
  A as A5
} from "./chunk-VUHMQQ6M.js";
import {
  G,
  e as e13,
  i as i4
} from "./chunk-46T3D2EU.js";
import {
  C as C3
} from "./chunk-PMFQ2A2V.js";
import {
  e as e12
} from "./chunk-GDBENMUU.js";
import {
  t as t8
} from "./chunk-BMTOVJNA.js";
import {
  t as t7
} from "./chunk-CMLG62TA.js";
import {
  o as o3
} from "./chunk-7E37N35O.js";
import {
  f as f2
} from "./chunk-QJ6L2QIQ.js";
import {
  L as L3
} from "./chunk-KWLN46JY.js";
import {
  p as p2
} from "./chunk-M6P775BS.js";
import {
  g as g2
} from "./chunk-XVQGALI7.js";
import {
  d as d3
} from "./chunk-4GGEQMYI.js";
import {
  t as t6
} from "./chunk-4BCSYJOQ.js";
import {
  h as h3
} from "./chunk-MUMDKJ7Y.js";
import {
  A as A4,
  L as L2,
  e as e10,
  j,
  w as w2
} from "./chunk-4OVQYUQW.js";
import {
  c as c3,
  r as r3
} from "./chunk-BYRUCUF7.js";
import {
  e as e11
} from "./chunk-CXP4BHPO.js";
import {
  t as t5
} from "./chunk-QIEXJLRX.js";
import {
  e as e9
} from "./chunk-UNTPHF5R.js";
import {
  E as E2
} from "./chunk-ECTYMEUP.js";
import {
  h as h2
} from "./chunk-I4SHZ6P5.js";
import {
  I as I3
} from "./chunk-QYDOVVH7.js";
import {
  S as S4
} from "./chunk-YPY24RRU.js";
import {
  t as t4
} from "./chunk-WEER6QME.js";
import {
  t as t3
} from "./chunk-R4SGP2EA.js";
import {
  v as v3
} from "./chunk-SA77Z3WI.js";
import {
  A as A3,
  D as D2,
  F as F2,
  J,
  O as O3,
  Q,
  de,
  e as e8,
  fe,
  he,
  i as i2,
  me,
  ne,
  oe,
  q,
  ue,
  ye
} from "./chunk-676ANOCK.js";
import {
  A as A2
} from "./chunk-WTKV7W5Z.js";
import {
  n as n5
} from "./chunk-D56W4LPT.js";
import {
  e as e6
} from "./chunk-BKOYOJBG.js";
import {
  n as n6
} from "./chunk-CSSLIU64.js";
import {
  I as I2
} from "./chunk-GPWQGIYV.js";
import {
  l as l3
} from "./chunk-WZJNHZ6H.js";
import {
  B,
  V as V2,
  Z
} from "./chunk-XMYPMIYH.js";
import {
  d as d2
} from "./chunk-VEYMN5N3.js";
import {
  n as n7,
  s as s4
} from "./chunk-HZSGATFT.js";
import {
  t as t2
} from "./chunk-KNMQQRV7.js";
import {
  e as e5,
  r as r2
} from "./chunk-N5GQOIDP.js";
import {
  e as e7
} from "./chunk-NFB6O77E.js";
import {
  r
} from "./chunk-AKEHDP75.js";
import {
  s as s3
} from "./chunk-5MMGIT64.js";
import {
  p,
  v as v2
} from "./chunk-LMO6NZJA.js";
import {
  f
} from "./chunk-QYC3GV65.js";
import {
  I,
  c as c2
} from "./chunk-HWHMO3CO.js";
import {
  k as k2,
  w2 as w
} from "./chunk-ZIJHDTB7.js";
import {
  C as C2,
  D,
  O as O2,
  P as P2,
  S as S3,
  c,
  i
} from "./chunk-326OSIM5.js";
import {
  I2 as I4
} from "./chunk-X7VSXJWW.js";
import {
  i as i3
} from "./chunk-AG6JXA4M.js";
import {
  u as u4
} from "./chunk-WDPG5BMO.js";
import {
  F
} from "./chunk-2ICUS4HL.js";
import {
  W,
  n as n4
} from "./chunk-GBF2OQAY.js";
import {
  E,
  u as u3
} from "./chunk-C7NPPGFR.js";
import {
  x
} from "./chunk-OCF7OAES.js";
import {
  K,
  O,
  S as S2,
  Y,
  e as e4,
  g,
  o as o2,
  u as u2
} from "./chunk-JZBR4X6W.js";
import {
  n as n3
} from "./chunk-OIJCMME5.js";
import {
  P,
  d
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import {
  A,
  S,
  e3,
  v,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a,
  n as n2
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  l as l2
} from "./chunk-C26KUZ46.js";
import {
  L,
  b,
  e as e2,
  m,
  s as s2
} from "./chunk-JGDJR5EV.js";
import {
  l,
  u
} from "./chunk-QHK5ZYFW.js";
import {
  h,
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import {
  C,
  U,
  has,
  k,
  t4 as t,
  z
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SGeometryUtil.js
function u7(t12, e17, r5) {
  const n13 = t3(24);
  return (i9) => {
    let u9 = i9.meta.featureExtents;
    if (null == u9) {
      u9 = new Float64Array(6 * i9.meta.featureIds.length), i9.meta.featureExtents = u9;
      for (let t13 = 0; t13 < u9.length; t13 += 6)
        u9[t13] = Number.POSITIVE_INFINITY;
    }
    const l6 = new Float64Array(u9.buffer, 6 * i9.index * Float64Array.BYTES_PER_ELEMENT, 6);
    return l6[0] === Number.POSITIVE_INFINITY && (c4(i9.index, r5, i9.meta.objectHandle, n13, 0), n4(n13, e17, 0, n13, t12, 0, 8) ? (O2(l6, C2), c(l6, n13, 0, 8)) : O2(l6, D)), l6;
  };
}
function c4(r5, o9, n13, a8, m2) {
  const s8 = o9.getComponentAabb(n13, r5, p3), f4 = o9.getObjectTransform(n13);
  for (let i9 = 0; i9 < 8; ++i9)
    I5[0] = 1 & i9 ? s8[0] : s8[3], I5[1] = 2 & i9 ? s8[1] : s8[4], I5[2] = 4 & i9 ? s8[2] : s8[5], S2(I5, I5, f4.rotationScale), u2(I5, I5, f4.position), a8[m2++] = I5[0], a8[m2++] = I5[1], a8[m2++] = I5[2];
  return a8;
}
var l5 = 24;
var p3 = i();
var I5 = n3();

// node_modules/@arcgis/core/views/3d/layers/II3SMeshView3D.js
var n9;
var o6;
var E3;
!function(n13) {
  n13[n13.VISIBLE_ONLY = 0] = "VISIBLE_ONLY", n13[n13.ALL = 1] = "ALL", n13[n13.QUERYABLE = 2] = "QUERYABLE";
}(n9 || (n9 = {})), function(n13) {
  n13[n13.EXIT = 0] = "EXIT", n13[n13.CONTINUE = 1] = "CONTINUE", n13[n13.SKIP = 2] = "SKIP";
}(o6 || (o6 = {})), function(n13) {
  n13[n13.Absolute = 0] = "Absolute", n13[n13.RelativeToGround = 1] = "RelativeToGround", n13[n13.OnTheGround = 2] = "OnTheGround";
}(E3 || (E3 = {}));

// node_modules/@arcgis/core/geometry/support/UByteArray.js
function e15(e17, n13 = false) {
  return e17 <= U ? n13 ? new Array(e17).fill(0) : new Array(e17) : new Uint8Array(e17);
}

// node_modules/@arcgis/core/views/3d/support/GraphicsMap.js
var r4 = class extends o {
  constructor() {
    super(...arguments), this._map = /* @__PURE__ */ new Map();
  }
  clear() {
    if (this._map.size > 0) {
      const e17 = this.toArray();
      this._map.clear(), this.emit("change", { added: [], removed: e17 });
    }
  }
  get length() {
    return this._map.size;
  }
  get(e17) {
    return this._map.get(e17);
  }
  addMany(e17) {
    if (0 === e17.length)
      return;
    const t12 = /* @__PURE__ */ new Set();
    for (let o9 = 0; o9 < e17.length; o9++) {
      const r6 = e17[o9], s8 = r6.objectId, n13 = this._map.get(s8);
      n13 ? (t12.add(s8), r6 !== n13 && (e17[o9] = n13), n13.refCount || (n13.refCount = 0), ++n13.refCount) : (r6.refCount = 1, this._map.set(s8, r6));
    }
    const r5 = t12.size > 0 ? e17.filter((e18) => !t12.has(e18.objectId)) : e17;
    r5.length > 0 && this.emit("change", { added: r5, removed: [] });
  }
  removeMany(e17) {
    const t12 = [];
    for (const r5 of e17) {
      const e18 = r5.objectId, o9 = this._map.get(e18);
      null != o9 && (!o9.refCount || --o9.refCount <= 0) && (this._map.delete(e18), t12.push(r5));
    }
    t12.length > 0 && this.emit("change", { added: [], removed: t12 });
  }
  removeManyByObjectId(e17) {
    const t12 = [];
    for (const r5 of e17) {
      const e18 = this._map.get(r5);
      null != e18 && (!e18.refCount || --e18.refCount <= 0) && (this._map.delete(r5), t12.push(e18));
    }
    t12.length > 0 && this.emit("change", { added: [], removed: t12 });
  }
  toArray() {
    return [...this._map.values()];
  }
  find(e17) {
    let r5;
    return n2(this._map, (t12) => !!e17(t12) && (r5 = t12, true)), r5;
  }
  forEach(e17) {
    this._map.forEach((t12) => e17(t12));
  }
};

// node_modules/@arcgis/core/views/3d/support/LimitGraphicsMap.js
var i6 = class extends o {
  constructor(e17) {
    super(), this._limit = e17, this._all = new r4(), this._active = new a4(this), this._pending = /* @__PURE__ */ new Map(), this._handle = this._all.on("change", (e18) => this._handleChanges(e18));
  }
  destroy() {
    this._handle.remove();
  }
  get length() {
    return this._active.length;
  }
  toArray() {
    return this._active.toArray();
  }
  find(e17) {
    return this._active.find(e17);
  }
  forEach(e17) {
    this._active.forEach(e17);
  }
  addMany(e17) {
    this._all.addMany(e17);
  }
  removeManyByObjectId(e17) {
    this._all.removeManyByObjectId(e17);
  }
  _handleChanges(e17) {
    let t12 = e17.removed;
    if (this._pending.size > 0) {
      t12 = new Array();
      for (const s9 of e17.removed)
        this._pending.delete(s9.objectId) || t12.push(s9);
    }
    let s8 = this._limit - this._active.length + t12.length;
    s8 < e17.added.length && (this._active.removeMany(t12), t12 = [], h4.reset(1 - this._limit / (this._active.length + e17.added.length)), this._active.forEach((e18) => {
      h4.sample() && (t12.push(e18), this._pending.set(e18.objectId, e18));
    }), s8 = this._limit - this._active.length + t12.length);
    let i9 = e17.added;
    if (s8 < e17.added.length) {
      i9 = new Array(), h4.reset(s8 / e17.added.length);
      for (const t13 of e17.added)
        h4.sample() ? i9.push(t13) : this._pending.set(t13.objectId, t13);
    }
    const n13 = s8 - i9.length;
    n13 > 0 && this._pending.size > 0 && (h4.reset(n13 / this._pending.size), this._pending.forEach((e18) => {
      h4.sample() && (i9.push(e18), this._pending.delete(e18.objectId));
    })), this._active.addAndRemove(i9, t12);
  }
};
var n10 = class {
  constructor() {
    this._percentage = 1, this._last = -1, this._index = 0;
  }
  reset(e17) {
    this._percentage = e17, this._last = -1;
  }
  sample() {
    const e17 = Math.floor(this._index * this._percentage);
    return ++this._index, e17 !== this._last && (this._last = e17, true);
  }
};
var h4 = new n10();
var a4 = class {
  constructor(e17) {
    this._parent = e17, this._map = /* @__PURE__ */ new Map();
  }
  get length() {
    return this._map.size;
  }
  forEach(e17) {
    this._map.forEach((t12) => e17(t12));
  }
  find(e17) {
    let s8;
    return n2(this._map, (t12) => !!e17(t12) && (s8 = t12, true)), s8;
  }
  toArray() {
    return [...this._map.values()];
  }
  addAndRemove(e17, t12) {
    for (const s8 of e17)
      this._map.set(s8.objectId, s8);
    for (const s8 of t12)
      this._map.delete(s8.objectId);
    (e17.length > 0 || t12.length > 0) && this._parent.emit("change", { added: e17, removed: t12 });
  }
  removeMany(e17) {
    for (const t12 of e17)
      this._map.delete(t12.objectId);
    e17.length > 0 && this._parent.emit("change", { added: [], removed: e17 });
  }
};

// node_modules/@arcgis/core/views/3d/layers/I3SMeshViewLabeler.js
var G3 = class {
  constructor(e17, t12) {
    this.meta = e17, this.index = t12;
  }
};
var D4 = class {
  constructor(e17, t12) {
    this.graphic = e17, this.geometry = t12, this.components = [], this.overridesDirty = false;
  }
};
var w3 = class extends S {
  get updating() {
    var _a;
    return ((_a = this._graphicsCore) == null ? void 0 : _a.updating) ?? false;
  }
  constructor(e17) {
    super(e17), this.loadedGraphics = new i6(5e4), this.slicePlaneEnabled = false, this._renderingInfo = { symbol: new w() }, this._featuresMap = /* @__PURE__ */ new Map();
  }
  initialize() {
    const e17 = this.view.basemapTerrain;
    this._graphicsCore = new ke({ owner: this, layer: this.layer, preferredUpdatePolicy: C3.ASYNC, elevationFeatureExpressionEnabled: false, graphicSymbolSupported: false, getRenderingInfoWithoutRenderer: true, hasZ: true, hasM: false, componentFactories: { deconflictor: (e18) => this.view.deconflictor.addGraphicsOwner(e18), labeler: (e18, t12) => this.view.labeler.addGraphicsOwner(e18, t12, { emptySymbolLabelSupported: true, elevationInfoOverride: { mode: "absolute-height", offset: 0 }, disablePlacement: { logEntityDescription: "3D Object Scene Layer features" } }), scaleVisibility: (t12, r5) => new u6({ graphicsCoreOwner: this, layer: this.layer, queryGraphicUIDsInExtent: r5, graphicsCore: t12, basemapTerrain: e17, layerScaleEnabled: false }) } }), this._graphicsCore.initializePromise.then(() => this._graphicsCore.startCreateGraphics()).catch(() => {
    }), this.addHandles(d(() => this.layer.labelingInfo, (e18, t12) => {
      d2(e18, t12) && this._graphicsCore.updateLabelingInfo();
    }));
  }
  destroy() {
    this._graphicsCore = u(this._graphicsCore), this.loadedGraphics = u(this.loadedGraphics), this.view = null;
  }
  addNodeMeta(e17, t12) {
    let r5 = 0;
    const o9 = e17.filteredIds, s8 = this.view.spatialReference, i9 = [];
    for (let a8 = 0; a8 < e17.featureIds.length; a8++) {
      const p4 = e17.featureIds[a8];
      let c7 = null == o9;
      if (o9 && r5 < o9.length && p4 === o9[r5] && (c7 = true, r5++), !this._enabledForFeatureInNode(e17, a8))
        continue;
      const h7 = this._featuresMap.get(p4);
      if (h7) {
        h7.components.push(new G3(e17, a8)), this._updateLabelPosition(p4);
        continue;
      }
      const l6 = t12(a8, e17), d4 = e6(0, 0, 0, s8), u9 = { objectId: p4, uid: e3(), attributes: l6, visible: c7, geometry: d4 }, m2 = new D4(u9, d4);
      m2.components.push(new G3(e17, a8)), this._featuresMap.set(p4, m2), this._updateLabelGeometry(p4), i9.push(u9);
    }
    this.loadedGraphics.addMany(i9);
  }
  updateLabelPositions(e17) {
    const t12 = this.view.renderCoordsHelper;
    this._forEachGraphic(e17, (r5, o9, s8) => {
      const i9 = this._graphicsCore.getGraphics3DGraphicById(o9.uid);
      null != i9 && this._updateLabelGeometry(e17.featureIds[r5]) && i9.alignWithAbsoluteElevation(s8.z ?? 0, t12, false);
    });
  }
  setNodeMetaAttributes(e17, t12) {
    const r5 = new Array();
    this._forEachGraphic(e17, (s8, i9) => {
      const a8 = t12(s8, e17);
      h(i9.attributes, a8) || (i9.attributes = a8, r5.push(i9.uid));
    }), this._graphicsCore.updateLabelingInfo(r5);
  }
  applyFilterChange(e17) {
    this._forEachFeature(e17, (t12, r5, o9) => {
      if (!this._enabledForFeatureInNode(e17, t12)) {
        const o10 = e17.featureIds[t12];
        switch (this._removeFeature(r5, e17, t12)) {
          case F3.REMOVED:
            this.loadedGraphics.removeManyByObjectId([o10]);
            break;
          case F3.MODIFIED:
            this._updateLabelPosition(o10);
        }
        return;
      }
      const s8 = r5.graphic, i9 = s8.visible;
      i9 !== o9 && (s8.visible = o9, C5.graphic = s8, C5.property = "visible", C5.oldValue = i9, C5.newValue = o9, this._graphicsCore.graphicUpdateHandler(C5));
    });
  }
  removeNodeMeta(e17) {
    const t12 = [];
    this._forEachGraphic(e17, (r5) => {
      const o9 = e17.featureIds[r5], s8 = this._featuresMap.get(o9);
      if (!s8)
        return;
      switch (this._removeFeature(s8, e17, r5)) {
        case F3.MODIFIED:
          this._updateLabelPosition(o9);
          break;
        case F3.REMOVED:
          t12.push(o9);
      }
    }), this.loadedGraphics.removeManyByObjectId(t12);
  }
  _removeFeature(e17, t12, o9) {
    const s8 = e17.components.length;
    return C(e17.components, (e18) => !(e18.meta === t12 && e18.index === o9)), 0 === e17.components.length ? (this._featuresMap.delete(t12.featureIds[o9]), F3.REMOVED) : s8 !== e17.components.length ? F3.MODIFIED : F3.UNMODIFIED;
  }
  getRenderingInfo() {
    return this._renderingInfo;
  }
  notifyGraphicGeometryChanged() {
  }
  notifyGraphicVisibilityChanged() {
  }
  _updateLabelPosition(e17) {
    const t12 = this._featuresMap.get(e17);
    t12 && this._updateLabelGeometry(e17) && (this.loadedGraphics.removeManyByObjectId([e17]), this.loadedGraphics.addMany([t12.graphic]));
  }
  _updateLabelGeometry(e17) {
    const t12 = this._featuresMap.get(e17);
    if (!t12)
      return false;
    const r5 = t12.geometry, o9 = this.view.spatialReference, i9 = this.view.renderCoordsHelper, a8 = r5.x, n13 = r5.y, p4 = r5.z ?? 0, c7 = t12.components.length, h7 = t3(c7 * l5);
    let d4 = 0;
    for (const { meta: s8, index: l6 } of t12.components)
      c4(l6, this.collection, s8.objectHandle, h7, d4), d4 += l5;
    return n4(h7, i9.spatialReference, 0, h7, o9, 0, h7.length / 3), O2(O4, C2), c(O4, h7), r5.x = (O4[0] + O4[3]) / 2, r5.y = (O4[1] + O4[4]) / 2, r5.z = O4[5], !x(r5.x, a8) || !x(r5.y, n13) || !x(r5.z, p4);
  }
  _forEachGraphic(e17, t12) {
    this._forEachFeature(e17, (r5, { graphic: o9, geometry: s8 }, i9) => {
      this._enabledForFeatureInNode(e17, r5) && t12(r5, o9, s8, i9);
    });
  }
  _forEachFeature(e17, t12) {
    let r5 = 0;
    for (let o9 = 0; o9 < e17.featureIds.length; o9++) {
      const s8 = this._featuresMap.get(e17.featureIds[o9]);
      let i9 = null == e17.filteredIds;
      e17.filteredIds && e17.filteredIds[r5] === e17.featureIds[o9] && (i9 = true, r5++), s8 && t12(o9, s8, i9);
    }
  }
  _enabledForFeatureInNode(e17, t12) {
    var _a;
    return e17.node.index < 0 || !((_a = this.overrides) == null ? void 0 : _a.featureHasGeometryChanges(e17.featureIds[t12]));
  }
  get updatePolicy() {
    return this._graphicsCore.effectiveUpdatePolicy;
  }
  get usedMemory() {
    return this._graphicsCore.usedMemory;
  }
  get unloadedMemoryEstimate() {
    return this._graphicsCore.unprocessedMemoryEstimate;
  }
  get test() {
    return { graphicsCore: this._graphicsCore };
  }
};
e([y()], w3.prototype, "view", void 0), e([y()], w3.prototype, "layer", void 0), e([y()], w3.prototype, "collection", void 0), e([y()], w3.prototype, "loadedGraphics", void 0), e([y()], w3.prototype, "overrides", void 0), e([y()], w3.prototype, "updating", null), e([y()], w3.prototype, "slicePlaneEnabled", void 0), e([y()], w3.prototype, "_graphicsCore", void 0), w3 = e([a("esri.views.3d.layers.I3SMeshViewLabeler")], w3);
var C5 = { graphic: null, property: null, oldValue: null, newValue: null };
var F3;
!function(e17) {
  e17[e17.UNMODIFIED = 0] = "UNMODIFIED", e17[e17.MODIFIED = 1] = "MODIFIED", e17[e17.REMOVED = 2] = "REMOVED";
}(F3 || (F3 = {}));
var O4 = i();
var L4 = w3;

// node_modules/@arcgis/core/views/3d/layers/I3SMeshViewPerformanceInfo.js
var e16 = class extends t7 {
  constructor(t12, e17, r5, s8, o9, i9, p4) {
    super(t12, 0, 0, 0, e17), this.gpuMB = r5, this.geometryMB = s8, this.textureMB = o9, this.unloadedMB = i9, this.idbHitRate = p4;
  }
};

// node_modules/@arcgis/core/views/3d/layers/I3SMeshWorkerHandle.js
var h5 = class extends h3 {
  constructor(s8) {
    super("SceneLayerWorker", "process", { process: (s9) => [s9.geometryBuffer], project: (s9) => [s9.positions.buffer], transformNormals: (s9) => [s9.normals.buffer] }, s8, { hasInitialize: true });
  }
  setModifications(s8, e17, o9, t12) {
    const r5 = { context: s8, modifications: a5(e17, o9, t12), isGeodetic: t12.isGeographic };
    this.broadcast(r5, "setModifications");
  }
  setLegacySchema(s8, e17) {
    const o9 = JSON.stringify(e17);
    return this.broadcast({ context: s8, jsonSchema: o9 }, "setLegacySchema");
  }
  destroyContext(s8) {
    return this.broadcast(s8, "destroyContext");
  }
  project(s8, e17) {
    return this.invokeMethod("project", s8, e17);
  }
  transformNormals(s8, e17) {
    return this.invokeMethod("transformNormals", s8, e17);
  }
};
var n11 = new l2({ deallocator: null });
var u8 = n3();
function a5(e17, o9, t12) {
  n11.clear();
  let h7 = 1 / 0, a8 = 1 / 0, c7 = -1 / 0, f4 = -1 / 0, l6 = false;
  for (const d4 of o9) {
    const e18 = "clip" === d4.type ? e10.Inside : "mask" === d4.type ? e10.Outside : e10.Replace, o10 = d4.geometry;
    let m3 = (s8) => s8;
    if (o10.spatialReference) {
      if (!F(o10.spatialReference, t12)) {
        n.getLogger("esri.views.3d.layers.I3SMeshWorkerHandle").warn("Can't project modification polygon into layer spatial reference, ignoring modification");
        continue;
      }
      m3 = (s8) => (n5(s8, o10.spatialReference, u8, t12), u8);
    } else
      o10.hasZ || (u8[2] = 0, m3 = (s8) => (u8[0] = s8[0], u8[1] = s8[1], u8));
    l6 = l6 || e18 === e10.Outside, n11.push(e18), n11.push(o10.rings.length);
    for (const s8 of o10.rings) {
      n11.push(s8.length);
      for (const e19 of s8) {
        const s9 = m3(e19);
        n11.push(s9[0]), n11.push(s9[1]), n11.push(s9[2]), h7 = Math.min(h7, s9[0]), a8 = Math.min(a8, s9[1]), c7 = Math.max(c7, s9[0]), f4 = Math.max(f4, s9[1]);
      }
    }
  }
  if (null != e17)
    if (l6) {
      const s8 = 1e-4;
      n11.push(e10.Inside), n11.push(2), n11.push(4), n11.push(h7 - s8), n11.push(a8 - s8), n11.push(0), n11.push(c7 + s8), n11.push(a8 - s8), n11.push(0), n11.push(c7 + s8), n11.push(f4 + s8), n11.push(0), n11.push(h7 - s8), n11.push(f4 + s8), n11.push(0), n11.push(4), n11.push(e17[0]), n11.push(e17[1]), n11.push(0), n11.push(e17[2]), n11.push(e17[1]), n11.push(0), n11.push(e17[2]), n11.push(e17[3]), n11.push(0), n11.push(e17[0]), n11.push(e17[3]), n11.push(0);
    } else
      n11.push(e10.Outside), n11.push(1), n11.push(4), n11.push(e17[0]), n11.push(e17[1]), n11.push(0), n11.push(e17[2]), n11.push(e17[1]), n11.push(0), n11.push(e17[2]), n11.push(e17[3]), n11.push(0), n11.push(e17[0]), n11.push(e17[3]), n11.push(0);
  n11.push(e10.Finished);
  const m2 = new Float64Array(n11.length);
  for (let s8 = 0; s8 < n11.length; ++s8)
    m2[s8] = n11.at(s8);
  return m2;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/Highlights.js
var s6 = class {
  constructor() {
    this.ids = /* @__PURE__ */ new Set();
  }
};
var h6 = class {
  constructor({ collection: t12, forAllFeatures: e17, forAllFeaturesOfNode: i9 }) {
    this._highlights = [], this._collection = t12, this._forAllFeatures = e17, this._forAllFeaturesOfNode = i9;
  }
  destroy() {
    this._highlights.forEach((t12) => this._releaseSet(t12)), this._highlights = null;
  }
  acquireSet() {
    const i9 = new s6();
    this._highlights.push(i9);
    const h7 = e2(() => {
      this._highlights && (this._releaseSet(i9), z(this._highlights, i9));
    });
    return { set: i9, handle: h7 };
  }
  setFeatureIds(t12, e17) {
    e17.forEach((e18) => t12.ids.add(e18)), this._initializeSet(t12);
  }
  _initializeSet(t12) {
    this._forAllFeatures((e17, s8, h7) => (t12.ids.has(e17) && this._collection.addComponentHighlight(h7.objectHandle, s8), o6.CONTINUE));
  }
  _releaseSet(t12) {
    this._forAllFeatures((e17, s8, h7) => (t12.ids.has(e17) && this._collection.removeComponentHighlight(h7.objectHandle, s8), o6.CONTINUE));
  }
  objectCreated(t12) {
    this._highlights.forEach((e17) => {
      this._forAllFeaturesOfNode(t12, (s8, h7) => (e17.ids.has(s8) && this._collection.addComponentHighlight(t12.objectHandle, h7), o6.CONTINUE));
    });
  }
  objectDeleted(t12) {
    this._collection.clearHighlights(t12.objectHandle);
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SAsyncElevationUpdater.js
var a6 = class extends S {
  constructor(t12, e17, s8, r5) {
    super({}), this._updateExtent = e17, this._updateNode = s8, this._getElevationMode = r5, this.running = false, this._extentSet = new l4(), this._nodeSet = /* @__PURE__ */ new Set();
    const i9 = this._taskPriority, n13 = t12.registerTask(this._taskPriority, this);
    this.addHandles(n13), this._task = n13, this._lastTaskPriority = i9;
  }
  get _taskPriority() {
    const t12 = this._getElevationMode();
    return t12 && t12 === E3.RelativeToGround ? I3.ELEVATION_ALIGNMENT_SCENE : I3.ELEVATION_ALIGNMENT;
  }
  _updateTaskPriority() {
    const t12 = this._taskPriority;
    t12 !== this._lastTaskPriority && (this._task.priority = t12, this._lastTaskPriority = t12);
  }
  normalizeCtorArgs() {
    return {};
  }
  addExtent(t12) {
    this._extentSet.add(t12), this._updateTaskPriority(), this.running = true;
  }
  schedule(t12) {
    this._nodeSet.add(t12), this._updateTaskPriority(), this.running = true;
  }
  remove(t12) {
    this._nodeSet.delete(t12), this._updateRunning();
  }
  runTask(t12) {
    const e17 = this._extentSet;
    for (t12.run(() => e17.merge(t12)); !e17.empty && !t12.done; ) {
      const s9 = this._updateExtent(e17.pop());
      null != s9 && s9.forAll((t13) => this.schedule(t13)), t12.madeProgress();
    }
    if (t12.done)
      return;
    const s8 = this._nodeSet;
    for (const r5 of s8)
      if (s8.delete(r5), this._updateNode(r5), t12.madeProgress(), t12.done)
        break;
    this._updateRunning();
  }
  _updateRunning() {
    this.running = this._nodeSet.size > 0 || this._extentSet.size > 0;
  }
};
e([y()], a6.prototype, "running", void 0), a6 = e([a("esri.views.3d.layers.i3s.I3SAsyncElevationUpdater")], a6);

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SCrossfadeHelper.js
var o7 = class {
  constructor() {
    this.lodCrossfadeSignedDuration = 0;
  }
};
var i7 = class {
  constructor(e17) {
    this._view = e17, this._preRenderFrameTaskHandle = null, this._currentFrameStartTime = null, this._numFadingNodes = 0;
  }
  destroy() {
    var _a;
    (_a = this._preRenderFrameTaskHandle) == null ? void 0 : _a.remove(), this._preRenderFrameTaskHandle = null, this._view = null;
  }
  get updating() {
    return this._numFadingNodes > 0;
  }
  stopNodeFading(s8) {
    null != s8.lodCrossfadeProgress && (this._numFadingNodes--, s8.lodCrossfadeProgress = null, 0 === this._numFadingNodes && (null != this._preRenderFrameTaskHandle && (this._preRenderFrameTaskHandle = l(this._preRenderFrameTaskHandle)), this._view.notifyLODUpdate(), this._view.notifyUpdate()));
  }
  _startNodeFading(e17, d4, o9) {
    0 === this._numFadingNodes && (this._preRenderFrameTaskHandle = A({ preRender: (e18) => this._updateAllNodeFading(e18) }), this._view.notifyLODUpdate()), null == e17.lodCrossfadeProgress && (this._numFadingNodes++, this._view.notifyUpdate()), e17.lodCrossfadeSignedDuration = o9, e17.lodCrossfadeProgress = d4;
  }
  _updateAllNodeFading(e17) {
    const s8 = this._view.nodeCrossfadingEnabled;
    this._view.foreachCrossfadeNode((d4, o9) => {
      if (null != (d4 == null ? void 0 : d4.lodCrossfadeProgress)) {
        const i9 = d4.lodCrossfadeSignedDuration, t12 = i9 > 0 ? this._view.fullOpacity : 0, r5 = e17.deltaTime / i9, a8 = d4.lodCrossfadeProgress + Math.abs(r5), n13 = !s8 || a8 >= 1 || 0 === i9, l6 = t12 - (n13 ? 0 : i9 > 0 ? 1 : -1) * (1 - a8);
        n13 ? (this.stopNodeFading(d4), i9 < 0 && this._view.markNodeToRemove(o9)) : d4.lodCrossfadeProgress = a8, this._view.setNodeOpacityByIndex(o9, l6);
      }
    }), this._view.removeMarkedNodes();
  }
  stopAllNodeFading() {
    this._view.foreachCrossfadeNode((e17, s8) => {
      if (null != (e17 == null ? void 0 : e17.lodCrossfadeProgress)) {
        this.stopNodeFading(e17);
        const d4 = e17.lodCrossfadeSignedDuration;
        d4 < 0 && this._view.markNodeToRemove(s8);
        const o9 = d4 > 0 ? this._view.fullOpacity : 0;
        this._view.setNodeOpacityByIndex(s8, o9);
      }
    }), this._view.removeMarkedNodes();
  }
  fadeNode(e17, s8, o9, i9) {
    null == this._currentFrameStartTime && (this._currentFrameStartTime = Date.now());
    const r5 = this._view, a8 = r5.nodeCrossfadingEnabled, n13 = o9 === a3.FadeIn ? r5.fullOpacity : 0, l6 = a8 ? i9 ? o9 === a3.FadeIn ? r5.lodCrossfadeinDuration : r5.lodCrossfadeoutDuration : r5.lodCrossfadeUncoveredDuration : 0, h7 = this._view.getNodeOpacityByIndex(e17);
    if (a8 && h7 !== n13 && l6 > 0) {
      const e18 = 1 - Math.abs(n13 - h7);
      this._startNodeFading(s8, e18, t10(o9) * l6);
    } else
      this.stopNodeFading(s8), this._view.setNodeOpacityByIndex(e17, n13), o9 === a3.FadeOut && this._view.removeNode(e17);
  }
  isNodeFullyFadedIn(e17) {
    const s8 = this._view.getNodeCrossfadeMetaData(e17);
    return null == s8 || null == s8.lodCrossfadeProgress && this._view.getNodeOpacityByIndex(e17) === this._view.fullOpacity;
  }
};
function t10(e17) {
  return e17 === a3.FadeIn ? 1 : -1;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SIntersectionHandler.js
var c5 = class {
  constructor(e17) {
    this.type = i4.I3S, this._needVerticalOffset = false, this.layerUid = e17.layerUid, this.sublayerUid = e17.sublayerUid, this._collection = e17.collection, this._traverseNodeHierarchy = e17.traverseNodeHierarchy, this.slicePlaneEnabled = e17.slicePlaneEnabled, this.isGround = e17.isGround;
  }
  updateElevationAlignState(t12, i9) {
    this._needVerticalOffset = t12 && i9 === l3.Global;
  }
  intersect(e17, s8, c7, d4, u9, b3) {
    const f4 = b3 ?? false, m2 = e17.results, h7 = e17.options.store === e13.ALL, y2 = e17.ray.direction, p4 = e17.tolerance;
    let R2 = (e18) => e18, g3 = (e18) => e18;
    const I6 = L3(e17.verticalOffset ?? (this._needVerticalOffset ? 0 : null));
    null != e17.verticalOffset && null != I6 && (R2 = (e18) => I6.applyToMbs(e18), g3 = (e18) => I6.applyToObb(e18));
    const v4 = new p2(f4, e17.options.normalRequired), O5 = (n13, l6) => {
      var _a;
      if (0 === n13.childrenLoaded)
        return false;
      const o9 = ((_a = n13.serviceObbInRenderSR) == null ? void 0 : _a.isValid) ? n13.serviceObbInRenderSR : null;
      return !(o9 && !g3(o9).intersectRay(c7, y2, p4)) && (!l6 || !o9 && ye(n13.serviceMbsInRenderSR) && !a7(R2(n13.serviceMbsInRenderSR), c7, y2, p4) || null != n13.geometryObbInRenderSR && !g3(n13.geometryObbInRenderSR).intersectRay(c7, y2, p4) || this._collection.intersect(l6, c7, d4, p4, I6, v4, (t12, l7, o10, a8) => {
        if (l7 < 0 || null != s8 && !s8(c7, d4, l7))
          return;
        const u10 = (e18) => {
          const r5 = new o4(this.layerUid, this.sublayerUid, n13.index, t12, a8);
          e18.set(this.type, r5, l7, o10);
        };
        if (this.isGround && (null == m2.ground.dist || l7 < m2.ground.dist) && u10(m2.ground), !e17.options.isFiltered && ((null == m2.min.dist || l7 < m2.min.dist) && u10(m2.min), (null == m2.max.dist || l7 > m2.max.dist) && u10(m2.max), h7)) {
          const t13 = G(e17.ray);
          u10(t13), e17.results.all.push(t13);
        }
      }), true);
    };
    this._traverseNodeHierarchy(O5);
  }
};
function a7(e17, t12, i9, r5 = 0) {
  const s8 = e17[3] + r5, n13 = t12[0] - e17[0], l6 = t12[1] - e17[1], o9 = t12[2] - e17[2], c7 = i9[0], a8 = i9[1], d4 = i9[2], u9 = c7 * n13 + a8 * l6 + d4 * o9;
  return u9 * u9 - (c7 * c7 + a8 * a8 + d4 * d4) * (n13 * n13 + l6 * l6 + o9 * o9 - s8 * s8) >= 0;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/IDBCache.js
var o8 = 14;
var i8 = class {
  constructor(t12, s8, r5 = o8) {
    this._version = r5, this._db = null, this._quotaReductionPromise = null, this._gcCounter = 0, this._hit = 0, this._miss = 0, this._destroyed = false, this.gcFrequency = 50, this.maxByteSize = E2.GIGABYTES, this.quotaReductionFactor = 0.2, this._dbName = t12, this._storeName = s8;
  }
  init() {
    return Promise.resolve().then(() => {
      const e17 = indexedDB.open(this._dbName, this._version);
      return e17.onupgradeneeded = (t12) => {
        const s8 = e17.result, r5 = e17.transaction, o9 = s8.objectStoreNames.contains(this._storeName) ? r5.objectStore(this._storeName) : s8.createObjectStore(this._storeName), i9 = s8.objectStoreNames.contains("last_access") ? r5.objectStore("last_access") : s8.createObjectStore("last_access");
        i9.indexNames.contains("date") || i9.createIndex("date", "date", { unique: false }), i9.indexNames.contains("byteSize") || i9.createIndex("byteSize", "byteSize", { unique: false }), t12.oldVersion < this._version && (o9.clear(), i9.clear());
      }, c6(e17);
    }).then((e17) => {
      this._destroyed ? e17.close() : this._db = e17;
    });
  }
  destroy() {
    this._db && (this._db.close(), this._db = null), this._destroyed = true;
  }
  get initialized() {
    return null != this._db;
  }
  getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
  put(e17, s8) {
    if (null == this._db)
      return Promise.reject(new s("indexedb:not-initialized", "IndexedDB Cache is not initialized"));
    return (null != this._quotaReductionPromise ? this._quotaReductionPromise : Promise.resolve()).then(() => this._put(e17, s8)).catch((t12) => {
      if (t12 && "QuotaExceededError" === t12.name)
        return null == this._quotaReductionPromise && (this._quotaReductionPromise = this._getCacheSize().then((e18) => this._removeLeastRecentlyAccessed(s8.byteSize + Math.ceil(e18 * this.quotaReductionFactor))), this._quotaReductionPromise.then(() => this._quotaReductionPromise = null, () => this._quotaReductionPromise = null)), this._quotaReductionPromise.then(() => this._put(e17, s8));
      throw t12;
    }).then(() => {
      this._gcCounter--, this._gcCounter < 0 && null != this._db && (this._gcCounter = this.gcFrequency, this._getCacheSize().then((e18) => this._removeLeastRecentlyAccessed(e18 - this.maxByteSize)));
    });
  }
  get(e17, t12) {
    const o9 = this._db;
    if (null == o9)
      return Promise.resolve(void 0);
    let i9 = null;
    return Promise.resolve().then(() => {
      const r5 = o9.transaction(this._storeName, "readonly");
      i9 = m(t12, () => {
        r5.abort();
      });
      return c6(r5.objectStore(this._storeName).get(e17));
    }).then((t13) => {
      if (null == t13)
        ++this._miss;
      else if (this._db) {
        ++this._hit;
        this._db.transaction("last_access", "readwrite").objectStore("last_access").put({ date: Date.now(), byteSize: t13.byteSize }, e17);
      }
      return null != i9 && i9.remove(), t13;
    }).catch(() => {
      ++this._miss, s2(t12), null != i9 && i9.remove();
    });
  }
  remove(e17) {
    const t12 = this._db;
    return null == t12 ? Promise.resolve() : Promise.resolve().then(async () => {
      const s8 = t12.transaction([this._storeName, "last_access"], "readwrite"), r5 = s8.objectStore(this._storeName), o9 = s8.objectStore("last_access"), i9 = r5.delete(e17), a8 = o9.delete(e17);
      await Promise.all([c6(i9), c6(a8), n12(s8)]);
    });
  }
  _put(e17, t12) {
    const s8 = this._db;
    if (null == s8)
      return Promise.resolve();
    const r5 = s8.transaction([this._storeName, "last_access"], "readwrite"), o9 = r5.objectStore(this._storeName), i9 = r5.objectStore("last_access"), a8 = o9.put(t12, e17), l6 = i9.put({ date: Date.now(), byteSize: t12.byteSize }, e17);
    return Promise.all([c6(a8), c6(l6), n12(r5)]);
  }
  _removeLeastRecentlyAccessed(e17) {
    if (e17 <= 0 || !this._db)
      return Promise.resolve();
    const t12 = this._db.transaction([this._storeName, "last_access"], "readwrite"), s8 = t12.objectStore(this._storeName), r5 = t12.objectStore("last_access");
    let o9 = 0;
    const i9 = r5.index("date").openCursor(null, "next");
    return i9.onsuccess = () => {
      const t13 = i9.result;
      null != t13 && (null != t13.value.byteSize && (o9 += t13.value.byteSize), s8.delete(t13.primaryKey), r5.delete(t13.primaryKey), o9 < e17 && t13.continue());
    }, n12(t12);
  }
  _getCacheSize() {
    const e17 = this._db;
    if (null == e17)
      return Promise.resolve(0);
    const t12 = e17.transaction("last_access"), s8 = t12.objectStore("last_access");
    let r5 = 0;
    const o9 = s8.index("byteSize").openKeyCursor();
    return o9.onsuccess = () => {
      const e18 = o9.result;
      if (!e18)
        return;
      const t13 = e18.key;
      null != t13 && (r5 += t13), e18.continue();
    }, n12(t12).then(() => r5);
  }
};
function n12(e17) {
  return new Promise((t12, s8) => {
    e17.oncomplete = () => t12(), e17.onerror = () => s8(e17.error), e17.onabort = () => s8(e17.error);
  });
}
function c6(e17) {
  return new Promise((t12, s8) => {
    "done" === e17.readyState ? null != e17.error ? s8(e17.error) : t12(e17.result) : (e17.onsuccess = () => t12(e17.result), e17.onerror = () => s8(e17.error));
  });
}

// node_modules/@arcgis/core/views/3d/layers/i3s/IDBMockCache.js
var t11 = /* @__PURE__ */ new WeakMap();
var s7 = class {
  constructor(s8, e17) {
    switch (this._miss = 0, this._hit = 0, this.initialized = true, e17) {
      case "layer":
        this._data = /* @__PURE__ */ new Map();
        break;
      case "view": {
        const e18 = t11.get(s8);
        if (e18) {
          this._data = e18;
          break;
        }
        const i9 = /* @__PURE__ */ new Map();
        this._data = i9, t11.set(s8, i9);
      }
    }
  }
  init() {
    return Promise.resolve();
  }
  async get(t12, s8) {
    if (this._data.has(t12))
      return this._hit++, this._data.get(t12) ?? void 0;
    this._miss++;
  }
  destroy() {
  }
  put(t12, s8) {
    return this._data.set(t12, s8), Promise.resolve();
  }
  remove(t12) {
    return this._data.delete(t12), Promise.resolve();
  }
  getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
};

// node_modules/@arcgis/core/views/3d/layers/I3SMeshView3D.js
var xt = "esri.views.3d.layers.I3SMeshView3D";
var Ot = () => n.getLogger(xt);
var Et = [1, 1, 1, 1];
var jt = class extends o7 {
  constructor(e17, t12, i9, s8, r5, o9, n13, a8, l6) {
    super(), this.node = e17, this.featureIds = t12, this.objectHandle = i9, this.cachedRendererVersion = s8, this.attributeInfo = r5, this.material = o9, this.textures = n13, this.anchorIds = a8, this.anchors = l6, this.cachedElevationAnchors = null, this.cachedEdgeMaterials = new Array(), this.edgeMemoryUsage = 0;
  }
};
var wt;
!function(e17) {
  e17[e17.CastShadows = 4] = "CastShadows", e17[e17.Pickable = 5] = "Pickable";
}(wt || (wt = {}));
var Rt = 23;
var St = 100 * E2.MEGABYTES;
var At = (t12) => {
  let o9 = class extends t12 {
    constructor(...e17) {
      super(e17), this._needsNormals = true, this._updatingHandles = new h2(), this._nodeId2Meta = /* @__PURE__ */ new Map(), this._nodeId2MetaReloading = /* @__PURE__ */ new Map(), this._i3sWasmLoaded = false, this._snappingSourcesTrackers = [], this._hasLoadedPBRTextures = false, this._asyncModuleLoading = 0, this._addTasks = /* @__PURE__ */ new Map(), this._currentRenderer = null, this._rendererVersion = 0, this._colorVariable = null, this._opacityVariable = null, this._rendererFields = null, this._symbologyFields = null, this._symbologyOverride = null, this._symbologyOverrideFields = null, this._symbolInfos = /* @__PURE__ */ new Map(), this._visibleGeometryChangedSchedulerHandle = null, this._hasComponentData = false, this._hasVertexColors = false, this._nodeColorOverride = null, this.updating = true, this.holeFilling = "auto", this._hasColors = false, this._hasTextures = false, this._hasData = false, this.slicePlaneEnabled = false, this._modifications = new Array(), this.ignoresMemoryFactor = false, this._layerUrl = "", this._cacheKeySuffix = null, this._planetRadiusInGlobalMode = 0, this._elevationTask = null, this._filters = [], this._arcade = null, this._tmpAttributeOnlyGraphic = new f(null, null, {}), this._crossfadeHelper = new i7(this);
    }
    get lodCrossfadeoutDuration() {
      return 0;
    }
    get lodCrossfadeinDuration() {
      return 0;
    }
    get lodCrossfadeUncoveredDuration() {
      return 0;
    }
    get layerUid() {
      return this.i3slayer && this.i3slayer.uid;
    }
    get sublayerUid() {
      return null;
    }
    get layerId() {
      return this.i3slayer && this.i3slayer.id;
    }
    get sublayerId() {
      return null;
    }
    get contentVisible() {
      var _a;
      return !this.suspended && ((_a = this._controller) == null ? void 0 : _a.rootNodeVisible);
    }
    get legendEnabled() {
      var _a;
      return this.contentVisible && true === ((_a = this.i3slayer) == null ? void 0 : _a.legendEnabled);
    }
    get updatingProgressValue() {
      var _a;
      return ((_a = this._controller) == null ? void 0 : _a.updatingProgress) ?? 0;
    }
    get hasTexturesOrVertexColors() {
      return this._hasData ? this._hasTextures || this._hasColors ? "yes" : "probably-not" : "unknown";
    }
    get rendererTextureUsage() {
      return ue(this._currentRenderer) ? this._usePBR || this._hasLoadedPBRTextures ? s5.AllTexturesPBR : s5.AllTextures : this._usePBR || this._hasLoadedPBRTextures ? s5.GeometryTexturesPBR : s5.GeometryTextures;
    }
    get elevationOffset() {
      const e17 = null != this.i3slayer ? this.i3slayer.elevationInfo : null;
      return null != e17 && "absolute-height" === e17.mode ? v3(e17, this.i3slayer.spatialReference) : 0;
    }
    get elevationInfo() {
      const e17 = null != this.i3slayer ? this.i3slayer.elevationInfo : null;
      if (null == e17)
        return new $t(E3.Absolute, 0);
      const t13 = v3(e17, this.i3slayer.spatialReference);
      switch (e17.mode) {
        case "absolute-height":
          return new $t(E3.Absolute, t13);
        case "relative-to-ground":
          return new $t(E3.RelativeToGround, t13);
        case "on-the-ground":
          return new $t(E3.OnTheGround, 0);
        default:
          return new $t(E3.Absolute, 0);
      }
    }
    get supportedTextureEncodings() {
      return R(this.view._stage.renderView.capabilities);
    }
    get uncompressedTextureDownsamplingEnabled() {
      var _a;
      const e17 = (_a = this.view) == null ? void 0 : _a.qualitySettings.sceneService.uncompressedTextureDownsamplingEnabled, t13 = !(this.supportedTextureEncodings & e14.DDS_S3TC);
      return e17 && t13;
    }
    get clientGeometry() {
      return this.i3sOverrides.geometryOverrides;
    }
    get elevationRange() {
      const e17 = this._nodeId2Meta, t13 = new e11();
      for (const i9 of e17.values()) {
        if (null == i9)
          continue;
        const { node: { serviceMbsInIndexSR: e18 } } = i9, [s8, r5, o10, n13] = e18;
        t13.expandElevationRangeValues(o10 - n13, o10 + n13);
      }
      return t13.elevationRangeValid ? t13 : null;
    }
    get fullExtent() {
      return this.i3slayer.fullExtent;
    }
    initialize() {
      var _a;
      const e17 = has("enable-feature:idb-mock-cache");
      this._idbCache = e17 ? new s7(this.view, e17) : new i8("esri-scenelayer-cache", "geometries"), this._preLoadBasis(), this.addResolvingPromise(this.i3slayer.indexInfo);
      const t13 = this.view.resourceController, i9 = t13.memoryController;
      this.i3sOverrides = new G2({ view: this.view, layer: this.i3slayer, memoryController: i9 }), this._worker = new h5(e12(t13)), this.addResolvingPromise(this._worker.promise);
      const s8 = this.i3slayer.store;
      this._worker.setLegacySchema(this.uid, s8.defaultGeometrySchema), oe(this.i3slayer), ne(this.i3slayer, this.view), this._layerUrl = this.i3slayer.parsedUrl.path, this._controller = new Y2({ layerView: this, worker: this._worker }), this._gpuMemoryEstimate = 0, this._texMemoryEstimate = 0, this._geoMemoryEstimate = 0, this._stage = this.view._stage, this._collection = this._stage.renderView.componentObjectCollection, this.resetHighlights();
      const r5 = s8.defaultGeometrySchema;
      if (this._isIntegratedMesh || !r5)
        this._hasComponentData = false;
      else {
        const e18 = r5.featureAttributes;
        this._hasComponentData = !!(e18 && e18.faceRange && e18.id);
      }
      this._hasVertexColors = null != ((r5 == null ? void 0 : r5.vertexAttributes.color) ?? null) && !((_a = this.i3slayer.cachedDrawingInfo) == null ? void 0 : _a.color);
      const o10 = this.view.resourceController.memoryController.newCache(`sl-${this.uid}`, (e18) => this._deleteComponentObject(e18));
      this._memCache = o10;
      const n13 = this._controller, a8 = this._nodeId2Meta, l6 = this._nodeId2MetaReloading, d4 = (e18) => {
        const t14 = n13.index;
        if (!t14)
          return;
        const i10 = t14.rootNode;
        if (!i10)
          return;
        const s9 = (t15) => {
          const i11 = t15.index, s10 = a8.get(i11) || l6.get(i11);
          return e18(t15, (s10 == null ? void 0 : s10.objectHandle) ?? null);
        };
        t14.traverse(i10, s9);
      };
      this._intersectionHandler = new c5({ layerUid: this.layerUid, sublayerUid: this.sublayerUid, collection: this._collection, slicePlaneEnabled: this.slicePlaneEnabled, isGround: this._isIntegratedMesh, traverseNodeHierarchy: d4 }), this._updatingHandles.add(() => this.layerUid, (e18) => this._intersectionHandler.layerUid = e18), this._updatingHandles.add(() => this.sublayerUid, (e18) => this._intersectionHandler.sublayerUid = e18), this._elevationProvider = new x2({ view: this.view, layerElevationSource: this, intersectionHandler: this._intersectionHandler }), this._hasLoadedPBRTextures = this._usePBR, this._updatingHandles.add(() => this.view.clippingArea, () => this._clippingAreaChanged(), P), this._updatingHandles.add(() => this.fullOpacity, (e18) => this._opacityChange(e18)), this._updatingHandles.add(() => this.slicePlaneEnabled, (e18) => this._slicePlaneEnabledChange(e18)), this._updatingHandles.add(() => this.elevationOffset, (e18, t14) => {
        this._reloadAll(t14), this._controller.invalidateVisibilityObbs();
      }), this._updatingHandles.add(() => this.elevationInfo, (e18, t14) => this._elevationInfoChanged(e18, t14), P), this._updatingHandles.add(() => !this.suspended && this.elevationInfo.mode !== E3.Absolute, (e18, t14) => {
        e18 ? this.addHandles(this.view.basemapTerrain.on("elevation-change", ({ extent: e19 }) => this._ensureElevationTask().addExtent(e19)), Yt) : t14 && this.removeHandles(Yt);
      }, P), this._updatingHandles.add(() => this._usePBR, (e18) => this._updatePBR(e18));
      const c7 = () => {
        this._reloadAll(), this.clearMemCache();
      };
      this._updatingHandles.add(() => this.rendererTextureUsage, c7), this._updatingHandles.add(() => this.uncompressedTextureDownsamplingEnabled, c7), this._updatingHandles.add(() => this.contentVisible, (e18) => this._contentVisibleChanged(e18), P), this._updatingHandles.add(() => this.i3slayer.labelsVisible, () => this._labelingChanged(), P), this._updatingHandles.add(() => this.i3slayer.labelingInfo, () => this._labelingChanged(), P), this._updatingHandles.add(() => this._modifications, () => this._modificationsChanged(), P), this.addHandles([d(() => t6.I3S_TREE_SHOW_TILES, (e18) => {
        if (e18 && !this._treeDebugger) {
          const e19 = this._controller.crsIndex;
          import("./I3STreeDebugger-2PZ4O6YN.js").then(({ I3STreeDebugger: t14 }) => {
            !this._treeDebugger && t6.I3S_TREE_SHOW_TILES && (this._treeDebugger = new t14({ lv: this, view: this.view, nodeSR: e19 }));
          });
        } else
          e18 || t6.I3S_TREE_SHOW_TILES || (this._treeDebugger = u(this._treeDebugger));
      }, P), d(() => t6.I3S_SHOW_MODIFICATIONS, () => this._showModifications(), P)]), this._cacheKeySuffix = J(this.i3slayer.spatialReference, this.view.renderSpatialReference), this._idbCache.init().catch((e18) => Ot().warn(`Failed to initialize IndexedDB cache: ${e18}`));
      const { view: u9 } = this, { viewingMode: _, renderCoordsHelper: g3 } = u9;
      this._planetRadiusInGlobalMode = "local" === _ ? 0 : g3.referenceEllipsoid.radius;
    }
    destroy() {
      this._clearAddTasks(), this._elevationTask = u(this._elevationTask), this.i3sOverrides = u(this.i3sOverrides), this._elevationProvider && (this._elevationProvider.objectsChanged(this.getVisibleObbs()), this.view.elevationProvider.unregister(this._elevationProvider), this._elevationProvider = null), this._intersectionHandler && (this._stage.view.sceneIntersectionHelper.removeIntersectionHandler(this._intersectionHandler), this._intersectionHandler = null);
      const e17 = this._worker;
      e17 && (e17.destroyContext(this.uid).then(() => e17.destroy()), this._worker = null), this._removeAllNodeDataFromStage(), this._memCache = u(this._memCache), this._collection = null, this._stage = null, this._edgeView = null, this._labeler = u(this._labeler), this._treeDebugger = u(this._treeDebugger), this._controller = u(this._controller), this._highlights.destroy(), this._nodeId2Meta.clear(), this._nodeId2MetaReloading.clear(), this._crossfadeHelper = u(this._crossfadeHelper), this.emit("visible-geometry-changed"), this._visibleGeometryChangedSchedulerHandle && (this._visibleGeometryChangedSchedulerHandle.remove(), this._visibleGeometryChangedSchedulerHandle = null), this._updatingHandles = u(this._updatingHandles);
    }
    _memEstimateTextureAdded(e17) {
      const t13 = e17.memoryEstimate;
      return this._gpuMemoryEstimate += t13, this._texMemoryEstimate += t13, t13;
    }
    _memEstimateTextureRemoved(e17) {
      if (null != e17) {
        const t13 = e17.memoryEstimate;
        this._gpuMemoryEstimate -= t13, this._texMemoryEstimate -= t13;
      }
    }
    _memEstimateGeometryAdded(e17) {
      const t13 = this._collection.getObjectGPUMemoryUsage(e17);
      return this._gpuMemoryEstimate += t13, this._geoMemoryEstimate += t13, t13;
    }
    _memEstimateGeometryRemoved(e17) {
      const t13 = this._collection.getObjectGPUMemoryUsage(e17);
      this._gpuMemoryEstimate -= t13, this._geoMemoryEstimate -= t13;
    }
    isNodeLoaded(e17) {
      return this._nodeId2Meta.has(e17);
    }
    isNodeReloading(e17) {
      return this._nodeId2MetaReloading.has(e17);
    }
    get usedMemory() {
      let e17 = null != this._labeler ? this._labeler.usedMemory : 0;
      return this._nodeId2Meta.forEach((t13) => e17 += null != t13 ? t13.node.memory : 0), this._nodeId2MetaReloading.forEach((t13) => e17 += null != t13 ? t13.node.memory : 0), e17;
    }
    get unloadedMemory() {
      return (null != this._controller ? this._controller.unloadedMemoryEstimate : 0) + (null != this._labeler ? this._labeler.unloadedMemoryEstimate : 0);
    }
    _labelingChanged() {
      if (!(B2(this.i3slayer) && this._supportsLabeling))
        return void (null != this._labeler && (this._labeler.destroy(), this._labeler = null));
      if (null != this._labeler)
        return;
      const e17 = new L4({ view: this.view, layer: this.i3slayer, collection: this._collection, overrides: this.i3sOverrides });
      this._nodeId2Meta.forEach((t13) => null != t13 && this._addMetaToLabeler(e17, t13)), this._labeler = e17;
    }
    _loadAsyncModule(e17) {
      return ++this._asyncModuleLoading, e17.then((e18) => (--this._asyncModuleLoading, e18), (e18) => {
        throw --this._asyncModuleLoading, e18;
      });
    }
    _modificationsChanged() {
      if (!this._i3sWasmLoaded && this.hasModifications)
        return this._i3sWasmLoaded = j().then(() => {
          this._i3sWasmLoaded = true, this._modificationsChanged(), this.notifyUpdate();
        }), void this.notifyUpdate();
      if (true !== this._i3sWasmLoaded)
        return;
      const e17 = this.uid, t13 = this.i3slayer.spatialReference;
      this._worker.setModifications(e17, this._layerClippingArea, this._modifications, t13);
      const i9 = a5(this._layerClippingArea, this._modifications, t13);
      w2({ context: e17, modifications: i9, isGeodetic: t13.isGeographic }), this._controller.modificationsChanged();
      const s8 = this.hasModifications ? new l2() : null;
      this._nodeId2Meta.forEach((e18, t14) => {
        null == e18 ? (this._nodeId2Meta.delete(t14), this._controller.updateLoadStatus(t14, false)) : e18.node.hasModifications ? (this._nodeId2Meta.delete(t14), this._nodeId2MetaReloading.set(t14, e18)) : null != s8 && s8.push(e18.node);
      }), this.notifyChange("elevationRange"), null != s8 && this._nodeId2MetaReloading.forEach((e18) => s8.push(e18.node)), null != s8 && s8.length > 0 && (this.updateNodeModificationStatus(s8), s8.forAll((e18) => {
        if (e18.imModificationImpact !== r3.Culled) {
          const t14 = this._nodeId2Meta.get(e18.index);
          this._controller.invalidateGeometryVisibility(e18.index), null != t14 ? (this._nodeId2Meta.delete(e18.index), this._nodeId2MetaReloading.set(e18.index, t14), this.notifyChange("elevationRange")) : this._nodeId2Meta.has(e18.index) && (this._nodeId2Meta.delete(e18.index), this._controller.updateLoadStatus(e18.index, false));
        }
      })), this.clearMemCache(), this._controller.restartNodeLoading(), this._showModifications();
    }
    _showModifications() {
      if (null != this._modificationGraphics && (this.view.graphics.removeMany(this._modificationGraphics), this._modificationGraphics = null), !t6.I3S_SHOW_MODIFICATIONS || 0 === this._modifications.length)
        return;
      const e17 = { clip: [227, 227, 79, 0.8], mask: [227, 139, 79, 0.8], replace: [139, 227, 79, 0.8] }, t13 = { type: "simple-fill", outline: { color: [255, 255, 255], width: 1 } };
      this._modificationGraphics = new Array();
      for (const s8 of this._modifications) {
        const r5 = s8.geometry;
        r5.spatialReference = this.i3slayer.spatialReference;
        const o10 = { ...t13, color: e17[s8.type] };
        this._modificationGraphics.push(new f({ geometry: r5, symbol: o10 }));
      }
      this.view.graphics.addMany(this._modificationGraphics);
    }
    _addMetaToLabeler(e17, t13) {
      e17.addNodeMeta(t13, (e18, t14) => this._createAttributes(e18, t14));
    }
    _contentVisibleChanged(e17) {
      e17 ? (this.view.elevationProvider.register(this._elevationContext, this._elevationProvider), this._stage.view.sceneIntersectionHelper.addIntersectionHandler(this._intersectionHandler)) : (this._removeAllNodeDataFromStage(), this.view.elevationProvider && this.view.elevationProvider.unregister(this._elevationProvider), this._stage.view.sceneIntersectionHelper.removeIntersectionHandler(this._intersectionHandler));
    }
    getLoadedAttributes(e17) {
      const t13 = this._nodeId2Meta.get(e17);
      if (null != (t13 == null ? void 0 : t13.attributeInfo))
        return t13.attributeInfo.loadedAttributes;
    }
    getAttributeData(e17) {
      const t13 = this._nodeId2Meta.get(e17);
      if (null != (t13 == null ? void 0 : t13.attributeInfo))
        return t13.attributeInfo.attributeData;
    }
    setAttributeData(e17, t13) {
      const i9 = this._nodeId2Meta.get(e17);
      null != (i9 == null ? void 0 : i9.attributeInfo) && (i9.attributeInfo.attributeData = t13, this._attributeValuesChanged(i9));
    }
    async updateAttributes(e17, t13, i9) {
      const s8 = this._nodeId2Meta.get(e17);
      null != s8 && (await this.i3sOverrides.applyAttributeOverrides(s8.featureIds, t13, i9, this._controller.requiredAttributes), s8.attributeInfo = t13, this._controller.reschedule(() => this._attributeValuesChanged(s8), i9).catch((e18) => {
        b(e18) || Ot().warn("Error while updating attribute values. Layer might not display correctly.", e18);
      }));
    }
    _attributeValuesChanged(e17) {
      e17.cachedRendererVersion = this._getInvalidRendererVersion(), e17.filteredIds = null, null != this._labeler && this._labeler.setNodeMetaAttributes(e17, (e18, t13) => this._createAttributes(e18, t13)), this._updateEngineObject(e17);
    }
    clearMemCache() {
      null != this._memCache && this._memCache.clear();
    }
    getVisibleNodes() {
      const e17 = new Array();
      return this._nodeId2Meta.forEach((t13) => null != t13 && e17.push(t13.node)), e17;
    }
    getVisibleObbs() {
      const e17 = new Array();
      return this._nodeId2Meta.forEach((t13) => {
        if (null != t13) {
          const i9 = this.getNodeComponentObb(t13.node);
          null != i9 && e17.push(i9);
        }
      }), e17;
    }
    getNodeComponentObb(e17) {
      const t13 = this._nodeId2Meta.get(e17.index) ?? this._nodeId2MetaReloading.get(e17.index);
      return null != t13 ? this._collection.getComponentObb(t13.objectHandle) : null;
    }
    getLoadedNodeIndices(e17) {
      this._nodeId2Meta.forEach((t13, i9) => e17.push(i9)), this._nodeId2MetaReloading.forEach((t13, i9) => e17.push(i9));
    }
    _preLoadBasis() {
      var _a;
      !has("disable-feature:i3s-basis") && this.supportedTextureEncodings & e14.Basis && ((_a = this.i3slayer.textureSetDefinitions) == null ? void 0 : _a.some((e17) => e17.formats.some((e18) => "basis" === e18.format || "ktx2" === e18.format))) && g2();
    }
    _getVertexBufferLayout(e17, t13) {
      const i9 = { hasTexture: Lt(e17.params.material), hasNormals: t13.normal, hasRegions: t13.uvRegion };
      return t5(o5(this._getGeometryParameters(i9)));
    }
    _getObjectIdField() {
      return this.i3slayer.objectIdField || o3;
    }
    _getGlobalIdField() {
      var _a;
      return (_a = this.i3slayer.associatedLayer) == null ? void 0 : _a.globalIdField;
    }
    _findGraphicNodeAndIndex(e17) {
      const t13 = n8(this.i3slayer.fieldsIndex, e17.attributes, this._getObjectIdField());
      let i9 = null;
      return n2(this._nodeId2Meta, (e18) => {
        if (null == e18)
          return false;
        const s8 = e18.featureIds.indexOf(t13);
        return -1 !== s8 && (i9 = { node: e18.node, index: s8 }, true);
      }), i9;
    }
    _getGraphicIndices(e17, t13) {
      const i9 = this._nodeId2Meta.get(e17.index);
      if (null == i9)
        return [];
      const s8 = [], r5 = this._getObjectIdField(), o10 = this.i3slayer.fieldsIndex;
      for (const n13 of t13) {
        const e18 = n8(o10, n13.attributes, r5), t14 = i9.featureIds.indexOf(e18);
        -1 !== t14 && s8.push(t14);
      }
      return s8;
    }
    whenGraphicBounds(e17) {
      const t13 = this._findGraphicNodeAndIndex(e17);
      if (!t13)
        return Promise.reject();
      const i9 = this._getAABB(t13.node.index, t13.index);
      return null == i9 ? Promise.reject() : Promise.resolve({ boundingBox: i9, screenSpaceObjects: [] });
    }
    getAABBFromIntersectorTarget(e17) {
      return null == e17.nodeIndex || null == e17.componentIndex ? null : this._getAABB(e17.nodeIndex, e17.componentIndex);
    }
    _getAABB(e17, t13) {
      const i9 = this._nodeId2Meta.get(e17);
      if (null == (i9 == null ? void 0 : i9.featureIds) || t13 >= i9.featureIds.length)
        return null;
      const s8 = i9.objectHandle, r5 = c4(t13, this._collection, s8, t3(24), 0), o10 = this.view.renderSpatialReference, n13 = this.view.spatialReference;
      if (!n4(r5, o10, 0, r5, n13, 0, 8))
        return null;
      const a8 = P2();
      return c(a8, r5, 0, 8), a8;
    }
    whenGraphicAttributes(e17, t13) {
      return A3(this.i3slayer, e17, this._getObjectIdField(), t13, () => [...this._nodeId2Meta.values()].filter(k));
    }
    getGraphicFromIntersectorTarget(e17) {
      if (null == e17.nodeIndex || null == e17.componentIndex)
        return null;
      const t13 = this._nodeId2Meta.get(e17.nodeIndex);
      return null == (t13 == null ? void 0 : t13.featureIds) || e17.componentIndex >= t13.featureIds.length ? null : this._createGraphic(e17.componentIndex, t13);
    }
    _getCacheKey(e17) {
      return `${this._layerUrl}/v${Rt}/${e17}${this._cacheKeySuffix}`;
    }
    _getMemCacheKey(e17, t13 = this.elevationOffset) {
      return e17 + "#" + t13;
    }
    get _idbCacheEnabled() {
      return !this._controller.disableIDBCache && !this.hasModifications && 0 === this.elevationOffset && null != this._cacheKeySuffix;
    }
    loadCachedGPUData(e17) {
      return null != this._memCache ? this._memCache.pop(this._getMemCacheKey(e17)) : null;
    }
    deleteCachedGPUData(e17) {
      null != e17 && this._deleteComponentObject(e17);
    }
    _cacheGPUData(e17, t13 = this.elevationOffset) {
      if (null == this._memCache)
        return void this._deleteComponentObject(e17);
      const i9 = this._controller.indexDepth - e17.node.level;
      this._memCache.put(this._getMemCacheKey(e17.node.index, t13), e17, e17.node.memory, i9);
    }
    loadMissingTextures(e17, t13, i9, s8) {
      const r5 = (e17 == null ? void 0 : e17.filter((e18, i10) => {
        if (!(e18.usage & this.rendererTextureUsage))
          return false;
        if (null == t13)
          return true;
        const s9 = D3(e18.encodings, this.supportedTextureEncodings), r6 = t13[i10];
        return !!(null == (r6 == null ? void 0 : r6.data) || s9 && r6.encoding !== s9.encoding);
      })) ?? [];
      return 0 === r5.length ? Promise.resolve(false) : i9(r5, s8).then((i10) => {
        let s9 = 0;
        for (let r6 = 0; r6 < e17.length; r6++)
          s9 < i10.length && i10[s9].id === e17[r6].id && (t13[r6] = i10[s9], s9++);
        return true;
      });
    }
    loadCachedNodeData(e17, t13, i9) {
      return this._idbCacheEnabled ? this._idbCache.get(this._getCacheKey(e17.id), t13).then((s8) => null == s8 ? null : s8.nodeVersion !== e17.version ? (this._idbCache.remove(this._getCacheKey(e17.id)), null) : (this.elevationInfo.mode === E3.Absolute && (e17.geometryObbInRenderSR = I2.fromData(s8.geometryObbData)), this.loadMissingTextures(s8.requiredTextures, s8.textureData, i9, t13).then((i10) => (i10 && this._idbCache.initialized && null != s8.textureData && (s8.byteSize = qt(s8.transformedGeometry, s8.textureData), s8.textureData.every(Bt) && zt(e17, s8) && this._idbCache.put(this._getCacheKey(e17.id), s8).catch((t14) => Ot().warn(`Failed to update node with textures in IndexedDB cache: ${e17.id}: ${t14}`))), s2(t13), s8)))) : Promise.resolve(null);
    }
    addNode(e17, t13, i9) {
      return kt(t13) ? null == t13.geometryBuffer ? (this._addNodeMeta(e17.index, null), Promise.resolve()) : this._addData(e17, t13.attributeDataInfo, () => this._transformNode(e17, t13, i9).then((s8) => this._safeReschedule(() => {
        if (null == s8)
          return e17.hasModifications = false, this._addCachedNodeData(e17, null, i9);
        e17.hasModifications = s8.transformedGeometry.hasModifications;
        const { obb: r5, componentOffsets: o10, featureIds: n13, anchorIds: a8, anchors: l6, transformedGeometry: d4 } = s8, h7 = this._controller.crsIndex, c7 = this.view.renderSpatialReference, u9 = i2(e17.serviceMbsInIndexSR, this.elevationOffset, h7, c7), _ = o2(Qt, r5.center.x, r5.center.y, r5.center.z);
        O(_, _, u9);
        const g3 = new I2(_, [r5.extents.x, r5.extents.y, r5.extents.z], t2(r5.orientation.x, r5.orientation.y, r5.orientation.z, r5.orientation.w));
        this.elevationInfo.mode === E3.Absolute && (e17.geometryObbInRenderSR = g3), t13.geometryData.componentOffsets = o10, n13 && (t13.geometryData.featureIds = Array.from(n13)), t13.geometryData.anchorIds = a8, t13.geometryData.anchors = l6;
        const m2 = { nodeVersion: e17.version, geometryData: t13.geometryData, requiredTextures: t13.requiredTextures, textureData: t13.textureData, transformedGeometry: d4, globalTrafo: u9, geometryObbData: g3.data, byteSize: qt(d4, t13.textureData) };
        if (this._idbCacheEnabled && this._idbCache.initialized && zt(e17, m2)) {
          const t14 = null != m2.textureData ? m2.textureData.map((e18) => Bt(e18) ? e18 : null) : null;
          this._idbCache.put(this._getCacheKey(e17.id), { ...m2, textureData: t14 }).catch((t15) => Ot().warn(`Failed to store node in IndexedDB cache: ${e17.id}: ${t15}`));
        }
        return this._addCachedNodeData(e17, m2, i9);
      }, i9))) : Promise.reject();
    }
    getElevationRange(e17) {
      const t13 = new e11(), i9 = this._controller, { index: s8 } = i9;
      if (!s8)
        return t13;
      const { rootNode: r5 } = s8;
      if (!r5)
        return t13;
      const o10 = this._nodeId2Meta, n13 = e17[3], a8 = i9.viewportQueries, l6 = this._planetRadiusInGlobalMode, { view: d4 } = this, { renderCoordsHelper: h7 } = d4, c7 = h7.referenceEllipsoid.radius, u9 = this._collection, _ = (i10) => {
        const { childrenLoaded: s9 } = i10;
        if (0 === s9)
          return false;
        const r6 = a8.getAndUpdateVisibilityObbInRenderSR(i10);
        let d5 = null, _2 = -1;
        if (r6) {
          if (_2 = r6.radius, !r6.intersectSphereWithMBS(e17, _2))
            return false;
        } else
          d5 = a8.getServiceMbsInRenderSR(i10), d5 && (_2 = d5[3]);
        if (_2 >= 0 && n13 >= 1 * _2)
          return null != r6 ? ei(t13, r6, l6) : null != d5 && d5[3] >= 0 && ti(t13, d5, l6), false;
        const g3 = Zt;
        if (g3.elevationRangeMin = 1 / 0, g3.elevationRangeMax = -1 / 0, (null != r6 || null != d5) && (null != r6 ? ei(g3, r6, l6) : null != d5 && ti(g3, d5, l6), g3.elevationRangeMin >= t13.elevationRangeMin && g3.elevationRangeMax <= t13.elevationRangeMax))
          return false;
        const m2 = o10.get(i10.index);
        if (m2) {
          const { geometryObbInRenderSR: s10 } = i10;
          if (!s10 || s10.intersectSphereWithMBS(e17)) {
            if (s10) {
              if (n13 > 0 * s10.radius)
                return ei(t13, s10, l6), false;
            }
            const { objectHandle: e18 } = m2, i11 = u9.getObjectTransform(e18), r7 = h7.getAltitude(i11.position);
            u9.expandRangeWithComponentObjectElevationRange(e18, r7, c7, t13);
          }
        }
        return s9 - (m2 ? 1 : 0) > 0;
      };
      return s8.traverse(r5, _), t13;
    }
    computeVisibilityObb(e17) {
      return he(e17, this.view.renderSpatialReference, this._controller.crsIndex, this.i3slayer.spatialReference, this.elevationOffset, this._modifications, this.view.renderCoordsHelper.sphericalPCPF);
    }
    _transformNode(e17, t13, i9) {
      var _a;
      const s8 = t13.geometryData.geometries ?? [], r5 = new Array(s8.length);
      for (let f4 = 0; f4 < s8.length; ++f4)
        r5[f4] = this._getVertexBufferLayout(s8[f4], t13.geometryDescriptor);
      const o10 = e17.serviceMbsInIndexSR, n13 = this.elevationOffset, a8 = this._controller.crsIndex, l6 = this._controller.crsVertex, d4 = this.view.renderSpatialReference, h7 = e8(o10, n13, a8), c7 = i2(o10, n13, a8, d4), u9 = W(a8, l6), _ = W(l6, d4);
      if (null == u9 || null == _)
        return Promise.resolve(null);
      const g3 = this.i3slayer.normalReferenceFrame, m2 = t13.normalReferenceFrame ?? g3 ?? "none", p4 = { context: this.uid, geometryBuffer: t13.geometryBuffer, geometryData: t13.geometryData, geometryDescriptor: t13.geometryDescriptor, layouts: r5, localOrigin: h7, globalTrafo: c7, mbs: o10, obbData: (_a = e17.serviceObbInIndexSR) == null ? void 0 : _a.data, elevationOffset: n13, needNormals: this._needsNormals && this._controller.isMeshPyramid, normalReferenceFrame: m2, indexToVertexProjector: u9, vertexToRenderProjector: _ };
      return this._worker.invoke(p4, i9);
    }
    get _supportsNodeCrossFading() {
      var _a, _b;
      return !((_b = (_a = this.view) == null ? void 0 : _a._stage) == null ? void 0 : _b.renderer.shadowsEnabled);
    }
    get nodeCrossfadingEnabled() {
      return this._supportsNodeCrossFading && (this.lodCrossfadeinDuration > 0 || this.lodCrossfadeoutDuration > 0 || this.lodCrossfadeUncoveredDuration > 0);
    }
    get nodeFadeoutEnabled() {
      return this._supportsNodeCrossFading && this.lodCrossfadeoutDuration > 0;
    }
    _setNewNodeOpacity(e17) {
      const t13 = this.nodeCrossfadingEnabled ? 0 : this.fullOpacity;
      this._setNodeOpacity(e17, t13);
    }
    addCachedGPUData(e17, t13, i9) {
      if (this.elevationInfo.mode === E3.Absolute && (e17.geometryObbInRenderSR = this._collection.getComponentObb(t13.objectHandle).clone()), !this._controller.isGeometryVisible(e17))
        return void this._cacheGPUData(t13);
      null != this._labeler && this._addMetaToLabeler(this._labeler, t13);
      const s8 = e17.index;
      this._addNodeMeta(s8, t13), this.updateNodeState(s8, i9), this._collection.setObjectVisibility(t13.objectHandle, true), this._updateMaterial(t13), this._setNewNodeOpacity(t13), this.elevationInfo.mode !== E3.Absolute && this._ensureElevationTask().schedule(s8), this._updateEngineObject(t13), this._highlights.objectCreated(t13), null != this._treeDebugger && this._treeDebugger.update();
    }
    addCachedNodeData(e17, t13, i9, s8) {
      return this._addData(e17, i9, () => this._addCachedNodeData(e17, t13, s8));
    }
    async deleteCachedNodeData(e17) {
      if (this._idbCacheEnabled)
        return this._idbCache.remove(this._getCacheKey(e17));
    }
    async _addCachedNodeData(e17, t13, i9) {
      var _a;
      if (!this.contentVisible || !this._controller.isGeometryVisible(e17))
        return void this._removeNodeStageData(e17.index, this.elevationOffset, this._nodeId2MetaReloading);
      if (null == t13)
        return void this._addNodeMeta(e17.index, null);
      const s8 = this._addTasks.get(e17.index), { geometryData: r5, transformedGeometry: o10, globalTrafo: n13 } = t13;
      await this.i3sOverrides.applyAttributeOverrides(r5.featureIds, s8.attributeInfo, i9, this._controller.requiredAttributes);
      const a8 = null != t13.textureData ? t13.textureData.filter((e18) => null != e18 && !!(e18.usage & this.rendererTextureUsage)) : [];
      !has("disable-feature:i3s-basis") && a8.some((e18) => null != e18 && (e18.encoding === e14.Basis || e18.encoding === e14.KTX2)) && await g2(), e17.memory = 0;
      const { componentOffsets: l6, geometries: d4, featureIds: h7, anchorIds: c7, anchors: u9 } = r5, _ = this._collection, g3 = d4[0], { layout: m2, indices: p4, interleavedVertexData: f4, positionData: b3, hasColors: y2 } = o10, { material: v4, geometryParameters: w4 } = this._materialParameters(g3, m2), R2 = l6 || new Uint32Array([0, p4 ? p4.length : f4.byteLength / m2[0].stride]), S5 = { vertices: { data: f4, count: f4.byteLength / m2[0].stride, layoutParameters: w4 }, positionData: { positions: e9(b3.data), indices: t4(b3.indices) }, indices: p4, componentOffsets: R2 }, T = g3.transformation ? r2(g3.transformation) : e5();
      c2(T, n13, T);
      const N = I(n3(), T), V3 = n7(e7(), T), F4 = this.view.renderSpatialReference, H = this.view.basemapTerrain.spatialReference, G4 = I2.fromData(t13.geometryObbData).center, k3 = [1, 1, 1];
      f3(G4, F4, k3, H) || Ot().errorOnce("Unsupported coordinate system for IM overlay");
      const B3 = n3();
      n5(G4, F4, B3, H);
      const q2 = e7();
      s4(q2, V3);
      const W2 = n3();
      S2(W2, K(W2, G4, N), q2);
      const K2 = B3[0] - W2[0] * k3[0], $ = B3[1] - W2[1] * k3[1], Q2 = _.createObject(new t9(r(K2, $, k3[0], k3[1]), new i5(N, V3), I2.fromData(t13.geometryObbData), S5)), X = w4.textureCoordinates === d3.Atlas, { textures: Y3, texturePromise: J2 } = this._initMaterialAndTextures(Q2, v4, a8, X);
      e17.memory += this._memEstimateGeometryAdded(Q2), e17.memory += Y3.reduce((e18, t14) => e18 + (null != t14 ? this._memEstimateTextureAdded(t14) : 0), 0);
      const te = !!v4.hasParametersFromSource, ie = "blend" !== v4.alphaMode && v4.metallicRoughness.baseColorFactor[3] >= 1, se = new jt(e17, h7, Q2, this._getInvalidRendererVersion(), s8.attributeInfo, { hasParametersFromSource: te, isOpaque: ie }, Y3, c7, u9);
      s8.meta = se, !this._hasTextures && ((_a = t13.requiredTextures) == null ? void 0 : _a.some(({ usage: e18 }) => !!(e18 & s5.ColorTextures))) && (this._hasTextures = true), this._hasData = true, this._hasColors = this._hasColors || y2, this._hasTextures = this._hasTextures || !!e17.resources.texture, this.notifyChange("hasTexturesOrVertexColors");
      const re = this.slicePlaneEnabled;
      return Promise.all([this._addOrUpdateEdgeRendering(se), J2]).then(([t14, s9]) => (null != t14 && t14.updateObjectVisibility(se.objectHandle, false).catch((e18) => Dt(e18, this.i3slayer.title)), this._safeReschedule(() => {
        const i10 = this._addTasks.get(e17.index);
        if (!i10)
          return;
        if (this._addNodeMeta(e17.index, se), i10.meta = null, !this.contentVisible)
          return void this._removeNodeStageData(e17.index, this.elevationOffset);
        _.setObjectVisibility(Q2, true), null != t14 && t14.updateObjectVisibility(se.objectHandle, true).catch((e18) => Dt(e18, this.i3slayer.title)), se.attributeInfo = i10.attributeInfo;
        const s10 = se.cachedRendererVersion !== this._rendererVersion, r6 = re !== this.slicePlaneEnabled;
        this._updateElevationOffsets(se);
        const o11 = se.elevationOffsets;
        this._updateComponentData(se);
        const n14 = this._applyFiltersToNode(se);
        (s10 || null != t14 && (r6 || n14 || o11)) && this._addOrUpdateEdgeRendering(se), null != this._labeler && this._addMetaToLabeler(this._labeler, se), this._visibleGeometryChanged(se, Tt.ADD), this._highlights.objectCreated(se), this._updateMaterial(se), this._setNewNodeOpacity(se), null != this._treeDebugger && this._treeDebugger.update();
      }, i9))).catch((e18) => {
        throw null != s8.meta && (this._cacheGPUData(s8.meta), s8.meta = null), e18;
      });
    }
    _addNodeMeta(e17, t13) {
      if (this._removeNodeStageData(e17, this.elevationOffset, this._nodeId2MetaReloading), this._nodeId2Meta.has(e17)) {
        Ot().error("Removing duplicated node");
        const t14 = this._nodeId2Meta.get(e17);
        null != t14 && this._deleteComponentObject(t14);
      } else
        this._controller.updateLoadStatus(e17, true);
      null != t13 && (t13.lodCrossfadeProgress = null, this.nodeCrossfadingEnabled && Kt(t13.cachedEdgeMaterials, 0)), this._nodeId2Meta.set(e17, t13), this.notifyChange("elevationRange");
    }
    _updateElevationOffsets(e17) {
      const t13 = this.view.renderSpatialReference, i9 = this._controller.crsIndex, s8 = this.elevationInfo, r5 = this.view.basemapTerrain, o10 = r5.spatialReference, n13 = s8.mode;
      if (null == t13 || null == o10 || n13 === E3.Absolute)
        return void (e17.elevationOffsets = null);
      const a8 = this._collection.getObjectTransform(e17.objectHandle);
      e17.elevationOffsets = e17.elevationOffsets ?? [];
      const l6 = Qt, d4 = Xt, h7 = n13 === E3.OnTheGround, c7 = this.view.renderCoordsHelper, u9 = e17.featureIds.length, _ = (() => {
        var _a;
        if (e17.cachedElevationAnchors)
          return e17.cachedElevationAnchors;
        const s9 = t3(3 * u9);
        e17.cachedElevationAnchors = s9;
        for (let r6 = 0; r6 < u9; r6++) {
          const n14 = 3 * r6, h8 = ((_a = e17.anchorIds) == null ? void 0 : _a.indexOf(r6)) ?? -1;
          e17.anchors && h8 >= 0 ? (o2(l6, e17.anchors[3 * h8], e17.anchors[3 * h8 + 1], e17.anchors[3 * h8 + 2]), u2(l6, l6, Z(e17.node.serviceMbsInIndexSR)), n5(l6, i9, l6, o10), s9[n14] = l6[0], s9[n14 + 1] = l6[1], s9[n14 + 2] = c7.getAltitude(l6)) : (this._collection.getComponentAabb(e17.objectHandle, r6, d4, true), o2(l6, (d4[0] + d4[3]) / 2, (d4[1] + d4[4]) / 2, d4[2]), S2(l6, l6, a8.rotationScale), u2(l6, l6, a8.position), s9[n14 + 2] = c7.getAltitude(l6), n5(l6, t13, l6, o10), s9[n14] = l6[0], s9[n14 + 1] = l6[1]);
        }
        return s9;
      })(), g3 = s8.offset, m2 = e17.elevationOffsets, p4 = (e18, t14) => {
        const i10 = h7 ? _[3 * e18 + 2] : 0;
        m2[e18] = g3 + (null != t14 ? t14 - i10 : 0);
      };
      r5.getElevations(_, u9, p4);
    }
    _ensureElevationTask() {
      return null != this._elevationTask || (this._elevationTask = new a6(this.view.resourceController.scheduler, (e17) => {
        const t13 = this._controller.updateElevationChanged(e17, this.view.basemapTerrain.spatialReference);
        return null != t13 ? t13.filterInPlace((e18) => null != this._nodeId2Meta.get(e18)) : null;
      }, (e17) => {
        const t13 = this._nodeId2Meta.get(e17);
        this._nodeElevationAlignmentChanged(t13);
      }, () => {
        var _a;
        return (_a = this.elevationInfo) == null ? void 0 : _a.mode;
      })), this._elevationTask;
    }
    _elevationInfoChanged(e17, t13) {
      const i9 = e17.mode !== E3.Absolute, s8 = !!t13 && t13 !== e17 && t13.mode !== E3.Absolute;
      this._intersectionHandler.updateElevationAlignState(i9, this.view.state.viewingMode), i9 && !s8 && this._controller.removeAllGeometryObbs(), this._nodeId2Meta.forEach((e18) => this._nodeElevationAlignmentChanged(e18));
    }
    _nodeElevationAlignmentChanged(e17) {
      null != e17 && (this._updateElevationOffsets(e17), this._updateComponentData(e17), this._updateEdgeRendering(e17), null != this._labeler && this._labeler.updateLabelPositions(e17), this._updateSnappingSources(e17, Tt.UPDATE));
    }
    _safeReschedule(e17, t13) {
      return s2(t13), this._controller.reschedule(e17, t13);
    }
    _materialParameters(e17, t13) {
      const i9 = null != e17.params.material ? e17.params.material : b2(), s8 = t13.some((e18) => "uvRegion" === e18.name), r5 = t13.some((e18) => "normalCompressed" === e18.name), o10 = Lt(i9);
      return { geometryParameters: this._getGeometryParameters({ hasTexture: o10, hasNormals: r5, hasRegions: s8 }), material: i9 };
    }
    _initMaterialAndTextures(e17, t13, i9, s8) {
      const r5 = this._stage.renderView, o10 = i9.map((e18) => C4(e18, t13, s8, r5));
      this._stage.addMany(o10);
      let n13 = null;
      return this._collection.updateMaterial(e17, (e18) => {
        n13 = M(e18, t13, o10, i9, this.view._stage.renderView.textureRepository, { rendererTextureUsage: this.rendererTextureUsage, usePBR: this._usePBR, isIntegratedMesh: this._isIntegratedMesh, slicePlaneEnabled: this.slicePlaneEnabled, viewSpatialReference: this.view.spatialReference }), this._updateMaterialOverlay(e18);
      }), { textures: o10, texturePromise: n13 };
    }
    _getGeometryParameters(e17) {
      return { textureCoordinates: e17.hasTexture ? e17.hasRegions ? d3.Atlas : d3.Default : d3.None, colors: this._hasVertexColors, hasNormals: e17.hasNormals && this._needsNormals, needsNormals: this._needsNormals };
    }
    _addData(e17, t13, i9) {
      let s8 = this._addTasks.get(e17.index);
      return s8 ? s8.attributeInfo = t13 : (s8 = { ...L(), attributeInfo: t13, meta: null }, this._addTasks.set(e17.index, s8), i9().then(s8.resolve, s8.reject).then(() => this._addTasks.delete(e17.index)).catch((t14) => {
        throw this._addTasks.delete(e17.index), t14;
      })), s8.promise;
    }
    _clearAddTasks() {
      this._addTasks.forEach((e17) => {
        null != e17.meta && (this._cacheGPUData(e17.meta), e17.meta = null);
      }), this._addTasks.clear();
    }
    _clippingAreaChanged() {
      const e17 = this.view.renderSpatialReference, t13 = this.i3slayer.spatialReference, i9 = u3();
      this._renderClippingArea = u5(this.view.clippingArea, i9, e17) ? i9 : null;
      const s8 = u3();
      this._layerClippingArea = u5(this.view.clippingArea, s8, t13) ? s8 : null, this._filterChange(), this._controller && this._controller.updateClippingArea(this.view.clippingArea), this._isIntegratedMesh && this._modificationsChanged();
    }
    get hasGeometryFilter() {
      return false;
    }
    _geometryFilterChange() {
      const e17 = this.hasGeometryFilter;
      this._controller.geometryFilterChanged(e17), this._applyFilters(e17);
    }
    _filterChange() {
      this._applyFilters(this.hasGeometryFilter);
    }
    _applyFilters(e17) {
      this._filters = this.getFilters(), e17 ? this._controller && this._controller.requestUpdate() : this._nodeId2Meta.forEach((e18) => {
        null != e18 && this._applyFiltersToNode(e18) && (this._addOrUpdateEdgeRendering(e18), this._visibleGeometryChanged(e18, Tt.UPDATE));
      });
    }
    getFilters() {
      const e17 = [], t13 = this._renderClippingArea;
      return null != t13 && e17.push((e18, i9) => this._boundingRectFilter(e18, i9, t13)), e17;
    }
    addSqlFilter(e17, t13, i9) {
      if (null != t13) {
        const s8 = t13.fieldNames;
        e17.push((e18, r5) => this._sqlFilter(e18, r5, t13, s8, i9));
      }
    }
    _sqlFilter(e17, t13, i9, s8, r5) {
      var _a;
      const o10 = {}, n13 = this._createLayerGraphic(o10), a8 = this.i3slayer.objectIdField, l6 = t13.featureIds, d4 = (_a = t13.attributeInfo) == null ? void 0 : _a.attributeData;
      s8.every((e18) => e18 === a8 || null != (d4 == null ? void 0 : d4[e18])) && D2(e17, l6, (e18) => {
        o10[a8] = l6[e18];
        for (const i10 of s8)
          i10 !== a8 && (o10[i10] = d4 ? Q(d4[i10], e18) : null);
        try {
          return i9.testFeature(n13);
        } catch (t14) {
          return r5(t14), false;
        }
      });
    }
    _boundingRectNodeTest(e17, t13) {
      return a2(e17.node.serviceMbsInIndexSR, this._controller.crsIndex, Gt, this.view.renderSpatialReference), O3(t13, Gt);
    }
    _boundingRectFeatureTest(e17, t13, i9) {
      return this._collection.getComponentAabb(e17.objectHandle, t13, Nt), S3(Nt, Vt), E(i9, Vt);
    }
    _boundingRectFilter(e17, t13, i9) {
      const s8 = this._collection, r5 = this._boundingRectNodeTest(t13, i9);
      if (r5 === F2.INSIDE)
        return;
      if (r5 === F2.OUTSIDE)
        return void (e17.length = 0);
      const o10 = s8.getComponentCount(t13.objectHandle);
      if (o10.invisible + o10.visible !== t13.featureIds.length)
        return;
      const n13 = this._transformClippingArea(Ft, i9, t13.objectHandle);
      D2(e17, t13.featureIds, (e18) => this._boundingRectFeatureTest(t13, e18, n13));
    }
    _transformClippingArea(e17, t13, i9) {
      const s8 = this._collection.getObjectTransform(i9), r5 = s8.position, o10 = s8.rotationScale;
      return e17[0] = (t13[0] - r5[0]) / o10[0], e17[1] = (t13[1] - r5[1]) / o10[4], e17[2] = (t13[2] - r5[0]) / o10[0], e17[3] = (t13[3] - r5[1]) / o10[4], e17;
    }
    async _addOrUpdateEdgeRendering(e17, t13 = true) {
      const i9 = e17.objectHandle, { hasEdges: s8, perFeatureEdgeMaterials: r5 } = this._getFilteredEdgeMaterials(e17), o10 = { hasSlicePlane: this.slicePlaneEnabled };
      let n13 = this._edgeView;
      if (s8 && !n13 && (n13 = this._edgeView = await this._stage.renderer.loadEdgeView()), !n13)
        return null;
      const a8 = n13.hasObject(i9);
      if (s8 && a8) {
        if (this.nodeCrossfadingEnabled) {
          Kt(r5, this.getNodeOpacity(e17));
        }
        return n13.updateAllComponentMaterials(i9, r5, o10, t13).catch((e18) => Dt(e18, this.i3slayer.title)), n13.updateObjectVisibility(i9, true).catch((e18) => Dt(e18, this.i3slayer.title)), n13.updateAllVerticalOffsets(i9, e17.elevationOffsets).catch((e18) => Dt(e18, this.i3slayer.title)), n13;
      }
      return s8 && !a8 ? this._collection.addEdges(i9, n13, r5, o10).then((t14) => (e17.edgeMemoryUsage = t14, e17.node.memory += t14, n13.updateAllVerticalOffsets(i9, e17.elevationOffsets).catch((e18) => Dt(e18, this.i3slayer.title)), n13)) : (!s8 && a8 && (e17.node.memory -= e17.edgeMemoryUsage, e17.edgeMemoryUsage = 0, n13.removeObject(i9)), null);
    }
    _applyFiltersToNode(e17) {
      return !!this._applyFiltersToNodeComponents(e17) && (null != this._labeler && this._labeler.applyFilterChange(e17), true);
    }
    _applyFiltersToNodeComponents(e17) {
      const t13 = this._collection, i9 = t13.getComponentCount(e17.objectHandle), s8 = null != e17.filteredIds, r5 = 0 === i9.invisible;
      if (t13.setAllComponentVisibilities(e17.objectHandle, "all"), 0 === this._filters.length)
        return e17.filteredIds = null, !r5;
      if (this._updateCachedFilteredIds(e17), s8 && e17.filteredIds === e17.featureIds)
        return !r5;
      const o10 = this._computeFilteredComponentIndices(e17);
      return t13.setAllComponentVisibilities(e17.objectHandle, o10), true;
    }
    _updateCachedFilteredIds(e17) {
      null != e17.filteredIds && e17.appliedFilters === this._filters || (e17.filteredIds = this._computeFilteredIds(e17), e17.appliedFilters = this._filters);
    }
    _computeFilteredIds(e17) {
      const t13 = e17.featureIds.slice();
      for (const i9 of this._filters)
        if (i9(t13, e17), 0 === t13.length)
          break;
      return t13.length === e17.featureIds.length ? e17.featureIds : t13;
    }
    _computeFilteredComponentIndices(e17) {
      const t13 = new Array(), i9 = e17.filteredIds;
      return null != i9 && e17.featureIds.forEach((e18, s8) => {
        i9[t13.length] === e18 && t13.push(s8);
      }), t13;
    }
    _removeAllNodeDataFromStage(e17 = this.elevationOffset) {
      this._nodeId2Meta.forEach((t13, i9) => this._removeNodeStageData(i9, e17)), this._nodeId2MetaReloading.forEach((t13, i9) => this._removeNodeStageData(i9, e17, this._nodeId2MetaReloading)), this._elevationTask = u(this._elevationTask);
    }
    removeNode(e17) {
      const t13 = this.elevationOffset;
      this._removeNodeStageData(e17, t13), this._removeNodeStageData(e17, t13, this._nodeId2MetaReloading), null != this._elevationTask && this._elevationTask.remove(e17);
    }
    _removeNodeStageData(e17, t13, i9 = this._nodeId2Meta) {
      i9.has(e17) && this._controller.updateLoadStatus(e17, false);
      const s8 = i9.get(e17);
      null != s8 ? (this._collection.setObjectVisibility(s8.objectHandle, false), null != this._edgeView && this._edgeView.hasObject(s8.objectHandle) && this._edgeView.updateObjectVisibility(s8.objectHandle, false).catch((e18) => Dt(e18, this.i3slayer.title)), this._visibleGeometryChanged(s8, Tt.REMOVE), null != this._labeler && this._labeler.removeNodeMeta(s8), i9.delete(e17), this._highlights.objectDeleted(s8), i9 === this._nodeId2Meta ? (this._cacheGPUData(s8, t13), this.nodeCrossfadingEnabled && this._crossfadeHelper.stopNodeFading(s8)) : this._deleteComponentObject(s8), null != this._treeDebugger && this._treeDebugger.update()) : i9.delete(e17);
    }
    _deleteComponentObject(e17) {
      if (null != this._edgeView && this._edgeView.removeObject(e17.objectHandle), this._memEstimateGeometryRemoved(e17.objectHandle), this._collection.destroyObject(e17.objectHandle), e17.textures)
        for (const t13 of e17.textures)
          this._memEstimateTextureRemoved(t13), this._stage.remove(t13);
    }
    updateNodeState(e17, t13) {
      const i9 = this._nodeId2Meta.get(e17);
      null != i9 && this._collection.updateMaterial(i9.objectHandle, (e18) => e18.polygonOffsetEnabled = t13 === c3.Hole);
    }
    updateNodeIndex(e17, t13) {
      if (this._nodeId2Meta.has(e17)) {
        const i10 = this._nodeId2Meta.get(e17);
        this._nodeId2Meta.delete(e17), this._nodeId2Meta.set(t13, i10), this.notifyChange("elevationRange");
      }
      const i9 = this._nodeId2MetaReloading.get(e17);
      i9 && (this._nodeId2MetaReloading.delete(e17), this._nodeId2MetaReloading.set(t13, i9));
    }
    _invalidateAllSymbols() {
      this._rendererVersion = de(this._rendererVersion, 1), this._controller && this._controller.requestUpdate();
    }
    _getInvalidRendererVersion() {
      return de(this._rendererVersion, -1);
    }
    async _rendererChange(e17) {
      if (this._currentRenderer = e17, this.notifyChange("rendererTextureUsage"), this._rendererVersion = de(this._rendererVersion, 1), this._rendererFields = null, this._colorVariable = null, this._opacityVariable = null, this._invalidateAllSymbols(), e17 && (this._rendererFields = await e17.getRequiredFields(this.i3slayer.fieldsIndex)), this._updateSymbologyFields(), !this._arcade && e17 && "arcadeRequired" in e17 && e17.arcadeRequired && (this._arcade = await i3()), e17 && "visualVariables" in e17 && e17.visualVariables)
        for (const t13 of e17.visualVariables)
          "color" === t13.type ? this._colorVariable = t13 : "opacity" === t13.type ? this._opacityVariable = t13 : Ot().warn(`Unsupported visual variable type for 3D Object Scene Services: ${t13.type}`);
      if (e17)
        for (const t13 of e17.getSymbols())
          "mesh-3d" !== t13.type && Ot().error(`Symbols of type '${t13.type}' are not supported for 3D Object Scene Services.`);
      this._controller && this._controller.requestUpdate();
    }
    _getCachedEdgeMaterials(e17) {
      return this._hasComponentData && e17.cachedRendererVersion !== this._rendererVersion && this._updateCachedRendererData(e17), e17.cachedEdgeMaterials;
    }
    _getComponentParameters(e17) {
      this._hasComponentData && e17.cachedRendererVersion !== this._rendererVersion && this._updateCachedRendererData(e17);
      const t13 = e17.cachedSymbology;
      return (i9, s8) => {
        var _a;
        const r5 = 5 * i9;
        if (s3(s8.externalColor, t13[r5] / 255, t13[r5 + 1] / 255, t13[r5 + 2] / 255, t13[r5 + 3] / 255), null != this._stage.renderView.objectAndLayerIdRenderHelper) {
          const t14 = e17.featureIds[i9], r6 = S4(this.view.map, this.layerUid);
          this._stage.renderView.objectAndLayerIdRenderHelper.setUidToObjectAndLayerId(t14, t14, this.layerId, this.layerUid + "_" + this.sublayerId, this.layerPopupEnabledAndHasTemplate && !r6, e17.node.resources.attributes, i9, this.sublayerId), s8.objectAndLayerIdColor = this._stage.renderView.getObjectAndLayerIdColor({ graphicUid: t14, layerUid: this.layerUid + "_" + this.sublayerId });
        }
        s8.externalColorMixMode = t13[r5 + 4] & (1 << wt.CastShadows) - 1, s8.castShadows = !!(t13[r5 + 4] & 1 << wt.CastShadows), s8.pickable = !!(t13[r5 + 4] & 1 << wt.Pickable), s8.elevationOffset = ((_a = e17.elevationOffsets) == null ? void 0 : _a[i9]) ?? 0;
      };
    }
    _getSymbolInfo(e17, t13) {
      const i9 = e17 == null ? void 0 : e17.getSymbol(t13, { arcade: this._arcade });
      if (!(i9 instanceof k2))
        return null;
      const s8 = i9.id;
      if (this._symbolInfos.has(s8))
        return this._symbolInfos.get(s8);
      const r5 = me(i9);
      return this._symbolInfos.set(s8, r5), r5;
    }
    _setSymbologyOverride(e17, t13) {
      this._symbologyOverride !== e17 && (this._symbologyOverride = e17, this._symbologyOverrideFields = t13, this._invalidateAllSymbols(), this._updateSymbologyFields());
    }
    _updateSymbologyFields() {
      this._symbologyFields = null != this._symbologyOverrideFields && this._symbologyOverrideFields.length > 0 ? null != this._rendererFields && this._rendererFields.length > 0 ? I4(this.i3slayer.fieldsIndex, [...this._rendererFields, ...this._symbologyOverrideFields]) : this._symbologyOverrideFields : this._rendererFields;
    }
    _updateCachedRendererData(e17) {
      var _a;
      if (e17.cachedRendererVersion = this._rendererVersion, !this._hasComponentData)
        return;
      const t13 = this._tmpAttributeOnlyGraphic, i9 = {};
      t13.attributes = i9;
      const s8 = this._currentRenderer, r5 = (_a = e17.attributeInfo) == null ? void 0 : _a.attributeData, o10 = null != e17.featureIds ? this.i3slayer.objectIdField : null, n13 = null != r5 && null != this._symbologyFields && this._symbologyFields.length > 0;
      let a8 = null, l6 = null;
      if (n13 && null != this._symbologyFields) {
        a8 = [], l6 = [];
        for (const e18 of this._symbologyFields) {
          const t14 = r5[e18];
          t14 && (a8.push(e18), l6.push(t14));
        }
      }
      e17.cachedSymbology || (e17.cachedSymbology = e15(5 * e17.featureIds.length));
      const d4 = { color: Ht, castShadows: true, pickable: true, colorMixMode: n6.Multiply, edgeMaterial: null }, h7 = this.fullOpacity, c7 = this.nodeCrossfadingEnabled ? this.getNodeOpacity(e17) : h7;
      let u9 = null, _ = A2.OPAQUE, g3 = fe, m2 = 0;
      for (let p4 = 0; p4 < e17.featureIds.length; p4++) {
        if (null != o10 && (i9[o10] = e17.featureIds[p4]), n13 && a8)
          for (let e18 = 0; e18 < a8.length; e18++)
            i9[a8[e18]] = Q(l6[e18], p4);
        const r6 = s8 ? this._getSymbolInfo(s8, t13) : null;
        let h8 = null, f4 = null;
        if (s8 && "visualVariables" in s8) {
          if (this._colorVariable) {
            const e18 = p(this._colorVariable, t13, { color: Ut, arcade: this._arcade });
            e18 && (h8 = Ht, h8[0] = e18.r / 255, h8[1] = e18.g / 255, h8[2] = e18.b / 255, this._opacityVariable || null === e18.a || (f4 = e18.a));
          }
          this._opacityVariable && (f4 = v2(this._opacityVariable, t13, { arcade: this._arcade }));
        }
        if (r6 == null ? void 0 : r6.material) {
          const e18 = r6.material;
          h8 = null == h8 || null == f4 ? A5(h8, f4, e18.color, e18.alpha, Et, Ht) : A5(h8, f4, null, null, Et, Ht);
        }
        if (null == h8 && (h8 = Ht, h8[0] = 1, h8[1] = 1, h8[2] = 1, h8[3] = 1), d4.pickable = true, d4.castShadows = !r6 || r6.castShadows, d4.colorMixMode = (r6 == null ? void 0 : r6.material) ? r6.material.colorMixMode : n6.Multiply, d4.edgeMaterial = r6 ? r6.edgeMaterial : null, null != this._symbologyOverride && (d4.color = h8, this._symbologyOverride(t13, d4), h8 = d4.color), null != this._nodeColorOverride && (this._nodeColorOverride(e17.node, h8), d4.colorMixMode = n6.Replace), null != d4.edgeMaterial) {
          const t14 = h8[3] <= 0 ? A2.INVISIBLE : h8[3] >= 1 && (e17.material.isOpaque || d4.colorMixMode === n6.Replace) ? A2.OPAQUE : A2.TRANSPARENT;
          d4.edgeMaterial === u9 && t14 === _ || (g3 = { ...d4.edgeMaterial, opacity: c7, objectTransparency: t14 }, u9 = d4.edgeMaterial, _ = t14), e17.cachedEdgeMaterials[p4] = g3;
        } else
          e17.cachedEdgeMaterials[p4] = fe;
        e17.cachedSymbology[m2++] = Math.round(255 * h8[0]), e17.cachedSymbology[m2++] = Math.round(255 * h8[1]), e17.cachedSymbology[m2++] = Math.round(255 * h8[2]), e17.cachedSymbology[m2++] = Math.round(255 * h8[3]), e17.cachedSymbology[m2++] = d4.colorMixMode | +d4.castShadows << wt.CastShadows | +d4.pickable << wt.Pickable;
      }
    }
    _getFilteredEdgeMaterials(e17) {
      const t13 = this._getCachedEdgeMaterials(e17);
      this.nodeCrossfadingEnabled || Kt(t13, this.fullOpacity);
      const i9 = e17.filteredIds;
      if (null == i9) {
        return { hasEdges: t13.some((e18) => e18 !== fe), perFeatureEdgeMaterials: t13 };
      }
      let s8 = 0, r5 = false;
      const o10 = t13.map((t14, o11) => e17.featureIds[o11] !== i9[s8] ? fe : (r5 = r5 || t14 !== fe, s8++, t14));
      return { hasEdges: r5, perFeatureEdgeMaterials: o10 };
    }
    _updateComponentData(e17) {
      if (!this._hasComponentData)
        return;
      const t13 = e17.objectHandle, i9 = this._getComponentParameters(e17);
      this._collection.setComponentData(t13, i9), this._stage.renderView.requestRender();
    }
    _reloadAll(e17 = this.elevationOffset) {
      this._removeAllNodeDataFromStage(e17), null != this._controller && this._controller.restartNodeLoading();
    }
    _opacityChange(e17) {
      this.nodeCrossfadingEnabled && this._crossfadeHelper.stopAllNodeFading(), this._nodeId2Meta.forEach((t13) => {
        null != t13 && (this._collection.updateMaterial(t13.objectHandle, (t14) => t14.objectOpacity = e17), Kt(t13.cachedEdgeMaterials, e17), this._updateEdgeRendering(t13));
      });
    }
    _updateMaterial(e17) {
      this._collection.updateMaterial(e17.objectHandle, (e18) => {
        e18.commonMaterialParameters.hasSlicePlane = this.slicePlaneEnabled, e18.usePBR = this._usePBR, this._updateMaterialOverlay(e18);
      });
    }
    _updateMaterialOverlay(e17) {
    }
    _updateEngineObject(e17) {
      this._updateComponentData(e17), this._applyFiltersToNode(e17), this._addOrUpdateEdgeRendering(e17), this._visibleGeometryChanged(e17, Tt.UPDATE);
    }
    _slicePlaneEnabledChange(e17) {
      this._intersectionHandler && (this._intersectionHandler.slicePlaneEnabled = e17), null != this._labeler && (this._labeler.slicePlaneEnabled = e17), this._nodeId2Meta.forEach((t13) => {
        null != t13 && (this._collection.updateMaterial(t13.objectHandle, (t14) => t14.commonMaterialParameters.hasSlicePlane = e17), this._updateEdgeRendering(t13, false));
      });
    }
    _updatePBR(e17) {
      this._nodeId2Meta.forEach((t13) => {
        null != t13 && this._collection.updateMaterial(t13.objectHandle, (t14) => t14.usePBR = e17);
      }), this._hasLoadedPBRTextures = true;
    }
    get _usePBR() {
      return this._needsNormals && this.view.qualitySettings.physicallyBasedRenderingEnabled;
    }
    _updateEdgeRendering(e17, t13 = true) {
      null != this._edgeView && this._edgeView.hasObject(e17.objectHandle) && this._addOrUpdateEdgeRendering(e17, t13);
    }
    _forAllNodes(e17) {
      this._nodeId2Meta.forEach(e17);
    }
    _ignoreClientNodeOverriddenFeatures(e17) {
      return this.i3sOverrides.hasGeometryChanges ? (t13, i9, s8) => s8.node.index >= 0 && this.i3sOverrides.featureHasGeometryChanges(t13) ? o6.CONTINUE : e17(t13, i9, s8) : e17;
    }
    _forAllFeatures(e17, t13, i9) {
      n2(this._nodeId2Meta, (s8) => {
        if (null == s8)
          return false;
        if (null != t13) {
          switch (t13(s8)) {
            case o6.EXIT:
              return true;
            case o6.SKIP:
              return false;
          }
        }
        let r5 = o6.CONTINUE;
        switch (i9) {
          case n9.ALL:
            r5 = this._forAllFeaturesOfNode(s8, e17);
            break;
          case n9.VISIBLE_ONLY:
            r5 = this._forAllVisibleFeaturesOfNode(s8, e17);
            break;
          case n9.QUERYABLE:
            r5 = this._forAllQueryableFeaturesOfNode(s8, e17);
        }
        return r5 === o6.EXIT;
      });
    }
    _forAllFeaturesOfNode(e17, t13) {
      let i9 = o6.CONTINUE;
      const s8 = e17.featureIds;
      for (let r5 = 0; r5 < s8.length; r5++)
        if (i9 = t13(s8[r5], r5, e17), i9 === o6.EXIT)
          return i9;
      return i9;
    }
    _forAllVisibleFeaturesOfNode(e17, t13) {
      let i9 = o6.CONTINUE;
      const s8 = e17.featureIds;
      return this._collection.forEachVisibleComponent(e17.objectHandle, (r5) => (i9 = t13(s8[r5], r5, e17), i9 === o6.CONTINUE)), i9;
    }
    _forAllQueryableFeaturesOfNode(e17, t13) {
      const i9 = this._ignoreClientNodeOverriddenFeatures(t13);
      if (null == this._renderClippingArea)
        return this._forAllFeaturesOfNode(e17, i9);
      const s8 = this._boundingRectNodeTest(e17, this._renderClippingArea);
      if (s8 === F2.OUTSIDE)
        return o6.CONTINUE;
      if (s8 === F2.INSIDE)
        return this._forAllFeaturesOfNode(e17, i9);
      const r5 = o6.CONTINUE, o10 = e17.featureIds, n13 = e17.objectHandle, a8 = q(this._renderClippingArea, this._collection.getObjectTransform(n13));
      for (let l6 = 0; l6 < o10.length; l6++) {
        if (!this._boundingRectFeatureTest(e17, l6, a8))
          continue;
        const t14 = i9(o10[l6], l6, e17);
        if (t14 === o6.EXIT)
          return t14;
      }
      return r5;
    }
    _createAttributes(e17, t13) {
      var _a;
      const i9 = {};
      null != t13.featureIds && (i9[this._getObjectIdField()] = t13.featureIds[e17]);
      const s8 = (_a = t13.attributeInfo) == null ? void 0 : _a.attributeData;
      if (null != s8)
        for (const r5 of Object.keys(s8))
          i9[r5] = Q(s8[r5], e17);
      return i9;
    }
    _createGraphic(e17, t13) {
      return this._createLayerGraphic(this._createAttributes(e17, t13));
    }
    highlight(e17) {
      if ("number" == typeof e17 || e17 instanceof f ? e17 = [e17] : e17 instanceof V && (e17 = e17.toArray()), Array.isArray(e17) && e17.length > 0) {
        if (e17[0] instanceof f) {
          const t13 = e17, i9 = this.i3slayer.fieldsIndex, s8 = this._getObjectIdField(), r5 = t13.map((e18) => n8(i9, e18.attributes, s8)), { set: o10, handle: n13 } = this._highlights.acquireSet();
          return this._highlights.setFeatureIds(o10, r5), n13;
        }
        if ("number" == typeof e17[0]) {
          const t13 = e17, { set: i9, handle: s8 } = this._highlights.acquireSet();
          return this._highlights.setFeatureIds(i9, t13), s8;
        }
      }
      return e2();
    }
    resetHighlights() {
      u(this._highlights), this._highlights = new h6({ collection: this._collection, forAllFeatures: (e17) => this._forAllFeatures(e17, null, n9.ALL), forAllFeaturesOfNode: (e17, t13) => this._forAllFeaturesOfNode(e17, t13) });
    }
    _visibleGeometryChanged(e17, t13) {
      if (!this._elevationProvider)
        return;
      const i9 = this.getNodeComponentObb(e17.node);
      i9 && this._elevationProvider.objectChanged(i9), null == this._visibleGeometryChangedSchedulerHandle && (this._visibleGeometryChangedSchedulerHandle = v(() => {
        this.emit("visible-geometry-changed"), this._visibleGeometryChangedSchedulerHandle = null;
      })), this._updateSnappingSources(e17, t13);
    }
    get performanceInfo() {
      return new e16(this.usedMemory, this._nodeId2Meta.size, Math.round(this._gpuMemoryEstimate / 1048576), Math.round(this._geoMemoryEstimate / 1048576), Math.round(this._texMemoryEstimate / 1048576), Math.round(this.unloadedMemory / 1048576), this._idbCacheEnabled ? Math.round(100 * this._idbCache.getHitRate()) : 0);
    }
    get test() {
      const e17 = this, t13 = (e18) => {
        this._nodeColorOverride = e18, this._invalidateAllSymbols();
      };
      return { controller: this._controller, labeler: this._labeler, get visibleObjectIds() {
        const t14 = [];
        return e17._forAllFeatures((e18) => (t14.push(e18), o6.CONTINUE), null, n9.VISIBLE_ONLY), t14.sort((e18, t15) => e18 - t15), t14;
      }, get numNodes() {
        return e17._nodeId2Meta.size;
      }, get loadedNodes() {
        return Array.from(e17._nodeId2Meta.keys()).sort((e18, t14) => e18 - t14);
      }, setNodeColorOverride: t13, setNodeColoring: (e18) => {
        if ("client-nodes" === e18)
          t13((e19, t14) => {
            e19.index < 0 ? (t14[0] = 1, t14[1] = 0, t14[2] = 0) : (t14[0] = 1, t14[1] = 1, t14[2] = 1);
          });
        else
          t13(null);
      } };
    }
    getNodeOpacityByIndex(e17) {
      const t13 = this._nodeId2Meta.get(e17);
      return this.getNodeOpacity(t13);
    }
    getNodeOpacity(e17) {
      return null != e17 ? this._collection.getMaterial(e17.objectHandle).objectOpacity : 0;
    }
    isNodeFullyFadedIn(e17) {
      return this._crossfadeHelper.isNodeFullyFadedIn(e17);
    }
    getNodeCrossfadeMetaData(e17) {
      return this._nodeId2Meta.get(e17);
    }
    markNodeToRemove(e17) {
      this._controller && this._controller.markNodeToRemove(e17);
    }
    removeMarkedNodes() {
      this._controller && this._controller.removeMarkedNodes();
    }
    foreachCrossfadeNode(e17) {
      this._nodeId2Meta.forEach(e17);
    }
    fadeNode(e17, t13, i9) {
      if (!this.nodeCrossfadingEnabled)
        return;
      const s8 = this._nodeId2Meta.get(e17);
      null != s8 && this._crossfadeHelper.fadeNode(e17, s8, t13, i9);
    }
    setNodeOpacityByIndex(e17, t13) {
      const i9 = this._nodeId2Meta.get(e17);
      null != i9 && this._setNodeOpacity(i9, t13);
    }
    _setNodeOpacity(e17, t13) {
      this._collection.updateMaterial(e17.objectHandle, (e18) => e18.objectOpacity = t13), this._setNodeEdgeOpacity(e17, t13);
    }
    _setNodeEdgeOpacity(e17, t13) {
      if (null == this._edgeView || !e17.cachedEdgeMaterials)
        return;
      Kt(e17.cachedEdgeMaterials, t13);
      const i9 = e17.objectHandle;
      this._edgeView.hasObject(i9) && this._edgeView.updateAllComponentOpacities(i9, t13).catch((e18) => Dt(e18, this.i3slayer.title));
    }
    get hasModifications() {
      return this._isIntegratedMesh && null != this._layerClippingArea || this._modifications && this._modifications.length > 0;
    }
    updateNodeModificationStatus(e17) {
      const t13 = e17.length;
      if (!this.hasModifications || t13 <= 0 || true !== this._i3sWasmLoaded)
        return;
      const i9 = this.uid, s8 = Wt(e17);
      if (s8) {
        const t14 = { context: i9, buffer: s8.buffer };
        L2(t14);
        const r5 = new Float64Array(s8.buffer);
        e17.forAll((e18, t15) => {
          const i10 = r5[t15], s9 = A4(i10);
          e18.imModificationImpact = s9, s9 !== r3.Unmodified && this._controller.invalidateGeometryVisibility(e18.index);
        });
      }
    }
    notifyUpdate() {
      this.notifyChange("updating");
    }
    notifyLODUpdate() {
      this._controller.notifyLODUpdate();
    }
    isUpdating() {
      var _a;
      return !(!this._controller || !this._controller.updating) || !!this._visibleGeometryChangedSchedulerHandle || null != this._labeler && this._labeler.updating || ((_a = this._crossfadeHelper) == null ? void 0 : _a.updating) || this._i3sWasmLoaded instanceof Promise || this._asyncModuleLoading > 0 || null != this._elevationTask && this._elevationTask.running;
    }
    trackSnappingSources(e17) {
      const t13 = { events: e17, fetchEdgeLocations: async (e18, t14, i9) => {
        const s8 = this._nodeId2Meta.get(e18);
        if (null == s8)
          throw new Error("invalid-node");
        const { origin: r5, buffer: o10 } = await this._collection.extractEdgeInformation(s8.objectHandle, t14, i9);
        return this._snappingLocationsApplyElevation(s8, o10, r5), { type: "components", objectIds: s8.featureIds, locations: o10, origin: r5 };
      }, remove: () => z(this._snappingSourcesTrackers, t13) };
      return this._snappingSourcesTrackers.push(t13), this._nodeId2Meta.forEach((t14, i9) => {
        if (null == t14)
          return;
        const s8 = this._controller.getRenderMbs(t14.node);
        s8 && e17.add(i9, s8);
      }), t13;
    }
    _snappingLocationsApplyElevation(e17, t13, i9) {
      if (!e17.elevationOffsets || this.elevationInfo.mode === E3.Absolute)
        return;
      const s8 = t13.position0, r5 = t13.position1, o10 = t13.componentIndex, n13 = n3(), a8 = n3(), l6 = (e18, t14) => {
        u2(e18, e18, i9), this.view.renderCoordsHelper.worldUpAtPosition(e18, a8), u2(e18, e18, g(a8, a8, t14)), e4(e18, e18, i9);
      };
      for (let d4 = 0; d4 < s8.count; d4++) {
        const t14 = e17.elevationOffsets[o10.get(d4)];
        s8.getVec(d4, n13), l6(n13, t14), s8.setVec(d4, n13), r5.getVec(d4, n13), l6(n13, t14), r5.setVec(d4, n13);
      }
    }
    _updateSnappingSources(e17, t13) {
      const { index: i9 } = e17.node, s8 = this._controller.getRenderMbs(e17.node);
      if (null != s8)
        for (const r5 of this._snappingSourcesTrackers)
          t13 !== Tt.REMOVE && t13 !== Tt.UPDATE || r5.events.remove(i9), t13 !== Tt.ADD && t13 !== Tt.UPDATE || r5.events.add(i9, s8);
    }
  };
  return e([y()], o9.prototype, "_hasLoadedPBRTextures", void 0), e([y()], o9.prototype, "_asyncModuleLoading", void 0), e([y()], o9.prototype, "_visibleGeometryChangedSchedulerHandle", void 0), e([y()], o9.prototype, "view", void 0), e([y()], o9.prototype, "i3slayer", void 0), e([y()], o9.prototype, "_controller", void 0), e([y()], o9.prototype, "_labeler", void 0), e([y()], o9.prototype, "updating", void 0), e([y()], o9.prototype, "suspended", void 0), e([y()], o9.prototype, "contentVisible", null), e([y({ readOnly: true })], o9.prototype, "legendEnabled", null), e([y()], o9.prototype, "holeFilling", void 0), e([y(t8)], o9.prototype, "updatingProgress", void 0), e([y()], o9.prototype, "updatingProgressValue", null), e([y()], o9.prototype, "hasTexturesOrVertexColors", null), e([y()], o9.prototype, "rendererTextureUsage", null), e([y()], o9.prototype, "elevationOffset", null), e([y()], o9.prototype, "elevationInfo", null), e([y({ type: Boolean })], o9.prototype, "slicePlaneEnabled", void 0), e([y()], o9.prototype, "supportedTextureEncodings", null), e([y()], o9.prototype, "uncompressedTextureDownsamplingEnabled", null), e([y({ type: [f2] })], o9.prototype, "_modifications", void 0), e([y({ readOnly: true })], o9.prototype, "clientGeometry", null), e([y()], o9.prototype, "elevationRange", null), e([y()], o9.prototype, "fullExtent", null), e([y()], o9.prototype, "_elevationTask", void 0), e([y({ readOnly: true })], o9.prototype, "_usePBR", null), o9 = e([a(xt)], o9), o9;
};
function Dt(e17, t12) {
  b(e17) || Ot().warn("Error while processing edges. Edges on this layer might not display correctly", t12, e17);
}
var Tt;
!function(e17) {
  e17[e17.ADD = 0] = "ADD", e17[e17.REMOVE = 1] = "REMOVE", e17[e17.UPDATE = 2] = "UPDATE";
}(Tt || (Tt = {}));
var Nt = i();
var Vt = u3();
var Ft = u3();
var Pt = new I2();
var Ht = [0, 0, 0, 0];
var Ut = new u4([0, 0, 0, 0]);
var Gt = B(0, 0, 0, 0);
function Lt(e17) {
  if (null == e17)
    return false;
  const t12 = e17.metallicRoughness;
  return t12 && t12.baseColorTextureId >= 0 || t12 && t12.metallicRoughnessTextureId >= 0 || e17.normalTextureId >= 0 || e17.emissiveTextureId >= 0 || e17.occlusionTextureId >= 0;
}
function kt(e17) {
  return "geometryData" in e17;
}
function Bt(e17) {
  return null != e17 && t(e17.data);
}
function qt(e17, t12) {
  let i9 = 1024 + e17.interleavedVertexData.byteLength + (e17.indices ? e17.indices.byteLength : 0) + e17.positionData.data.byteLength + e17.positionData.indices.byteLength;
  if (null != t12)
    for (const s8 of t12)
      null != s8 && t(s8.data) && (i9 += s8.data.byteLength);
  return i9;
}
function zt(e17, t12) {
  return t12.byteSize > St ? (Ot().warn(`Node is too big to store in IndexedDB cache: ${e17.id} (${t12.byteSize} bytes)`), false) : t12.byteSize > 0;
}
function Wt(e17) {
  if (0 === e17.length)
    return;
  const t12 = 10 * e17.length, i9 = new Float64Array(t12);
  let s8 = 0;
  return e17.forAll((e18) => {
    let t13 = e18.serviceObbInIndexSR;
    null == t13 && (t13 = Pt, t13.center = Z(e18.serviceMbsInIndexSR), t13.halfSize = [e18.serviceMbsInIndexSR[3], e18.serviceMbsInIndexSR[3], e18.serviceMbsInIndexSR[3]]);
    const r5 = t13.data;
    i9[s8++] = r5[0], i9[s8++] = r5[1], i9[s8++] = r5[2], i9[s8++] = r5[3], i9[s8++] = r5[4], i9[s8++] = r5[5], i9[s8++] = r5[6], i9[s8++] = r5[7], i9[s8++] = r5[8], i9[s8++] = r5[9];
  }), i9;
}
function Kt(e17, t12) {
  e17.forEach((e18) => e18.opacity = t12);
}
var $t = class {
  constructor(e17, t12) {
    this.mode = e17, this.offset = t12;
  }
};
var Qt = n3();
var Xt = i();
var Yt = "elevation-change";
var Jt = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]];
var Zt = new e11();
function ei(e17, t12, i9) {
  let s8 = e17.elevationRangeMin, r5 = e17.elevationRangeMax;
  const o9 = i9;
  if (o9 > 0) {
    t12.getCorners(Jt);
    for (const e18 of Jt) {
      const t13 = Y(e18) - o9;
      s8 = Math.min(s8, t13), r5 = Math.max(r5, t13);
    }
  } else {
    t12.getCorners(Jt);
    for (const e18 of Jt) {
      const t13 = e18[2];
      s8 = Math.min(s8, t13), r5 = Math.max(r5, t13);
    }
  }
  e17.expandElevationRangeValues(s8, r5);
}
function ti(e17, t12, i9) {
  const s8 = Z(t12), r5 = i9 > 0 ? Y(s8) - i9 : s8[2], o9 = V2(t12);
  e17.expandElevationRangeValues(r5 - o9, r5 + o9);
}

export {
  u7 as u,
  n9 as n,
  o6 as o,
  At
};
//# sourceMappingURL=chunk-UZQHEI2J.js.map
