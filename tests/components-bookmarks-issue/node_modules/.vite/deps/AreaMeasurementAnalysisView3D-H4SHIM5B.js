import {
  g as g2,
  h as h7,
  j as j3,
  m as m3,
  p as p3
} from "./chunk-IZ6ZAGHW.js";
import {
  c as c3
} from "./chunk-SSVYYDUI.js";
import {
  e as e7
} from "./chunk-TIIBPE7N.js";
import {
  e as e6
} from "./chunk-EPOP3OQ6.js";
import {
  k
} from "./chunk-OEXKWOWE.js";
import "./chunk-QKSE6KAV.js";
import {
  _ as _3,
  f as f6,
  m as m2
} from "./chunk-3UHI6U3P.js";
import "./chunk-UEYTNVS4.js";
import {
  h as h6
} from "./chunk-NIRB3OB6.js";
import "./chunk-CA3XJ2RX.js";
import {
  f as f4,
  r as r9,
  u as u4
} from "./chunk-JASPUPTW.js";
import "./chunk-HWBFFWYY.js";
import {
  h as h5,
  l as l4
} from "./chunk-B473F3N3.js";
import {
  s as s3
} from "./chunk-45P2R3BJ.js";
import {
  f as f5,
  t as t6
} from "./chunk-FXZUN4XG.js";
import {
  a as a7
} from "./chunk-3W2U3CD4.js";
import "./chunk-3ENNELTC.js";
import {
  E2 as E4,
  P as P3,
  a as a6,
  p as p2
} from "./chunk-LEFES6LS.js";
import "./chunk-3FTSPLRV.js";
import "./chunk-UXQH3C5A.js";
import {
  h as h4
} from "./chunk-HBBLDSW6.js";
import "./chunk-5T7MASZO.js";
import "./chunk-WCBHO6BH.js";
import {
  a as a5
} from "./chunk-V7NVRGBC.js";
import "./chunk-KCZGCTYM.js";
import {
  f as f3
} from "./chunk-VIRGWB3Z.js";
import {
  e as e5
} from "./chunk-637XZX4A.js";
import "./chunk-PMFQ2A2V.js";
import "./chunk-HHAESKQ6.js";
import "./chunk-4MJOJUFR.js";
import "./chunk-G4YIJOSP.js";
import {
  a as a4,
  l as l3,
  s as s2
} from "./chunk-PMQ5HDZI.js";
import {
  r as r5
} from "./chunk-7KNPDPFB.js";
import "./chunk-M6P775BS.js";
import "./chunk-J5F4VILS.js";
import {
  t as t5
} from "./chunk-KSBIR2KG.js";
import "./chunk-XVQGALI7.js";
import "./chunk-XFQIXBHG.js";
import "./chunk-MVSN2HAN.js";
import {
  A as A3,
  E as E3,
  l as l2
} from "./chunk-7A5N7G2Z.js";
import {
  r as r6,
  r2 as r7,
  t as t4
} from "./chunk-ZPC74XHC.js";
import {
  A as A4
} from "./chunk-IVGJRGD2.js";
import {
  t as t3
} from "./chunk-MTLWPXQD.js";
import "./chunk-ECIXBYOQ.js";
import "./chunk-QFKFOAJ6.js";
import "./chunk-LOPMLCHC.js";
import "./chunk-JIR2YP6A.js";
import "./chunk-LANUNBDP.js";
import {
  r as r8
} from "./chunk-JBF6CULO.js";
import "./chunk-DRCNNCTI.js";
import "./chunk-MKOOEINB.js";
import "./chunk-JKOHBDRD.js";
import "./chunk-MDSRD3WV.js";
import {
  h as h3,
  u2 as u3
} from "./chunk-3DFMDDMO.js";
import "./chunk-4BCSYJOQ.js";
import {
  O
} from "./chunk-GMUCR2DJ.js";
import "./chunk-HBRJJENW.js";
import "./chunk-VHY5K2VE.js";
import "./chunk-6ENXMQPD.js";
import "./chunk-FV43HSGW.js";
import "./chunk-ZR7OV2EH.js";
import "./chunk-U76EZJUZ.js";
import {
  S as S3,
  _ as _2,
  l,
  o as o4
} from "./chunk-MEEG7XMI.js";
import {
  o as o3
} from "./chunk-LJULTBAY.js";
import "./chunk-LO5UMUY4.js";
import "./chunk-YKIGDW5O.js";
import "./chunk-6MGK5WBT.js";
import "./chunk-CPZW2LMK.js";
import "./chunk-QR7J3YDY.js";
import "./chunk-GO2OGJDG.js";
import "./chunk-UYMREM3D.js";
import "./chunk-JTUYA5FE.js";
import "./chunk-UNTQATE2.js";
import "./chunk-5YY6NZNY.js";
import "./chunk-7MYYCSEB.js";
import "./chunk-ESK2YRQM.js";
import "./chunk-UNTPHF5R.js";
import "./chunk-YJFPDMSR.js";
import "./chunk-ECTYMEUP.js";
import "./chunk-H7T5AB2S.js";
import {
  R as R2
} from "./chunk-WKVHVZW2.js";
import {
  I as I2
} from "./chunk-KSZESDGM.js";
import {
  S as S2
} from "./chunk-CHJMCUAV.js";
import "./chunk-5P74D2TG.js";
import "./chunk-33LWZO2E.js";
import "./chunk-YT66FIGM.js";
import "./chunk-VIKID44H.js";
import "./chunk-3IDXRFXE.js";
import "./chunk-RLZYC2LS.js";
import {
  t as t2
} from "./chunk-WEER6QME.js";
import "./chunk-TXLJQAAN.js";
import "./chunk-R4SGP2EA.js";
import "./chunk-IRL6OOVK.js";
import {
  m,
  o as o2,
  r as r4
} from "./chunk-3AIILHI5.js";
import "./chunk-SA77Z3WI.js";
import {
  n as n5
} from "./chunk-D56W4LPT.js";
import "./chunk-BKOYOJBG.js";
import "./chunk-7JR6S3WL.js";
import "./chunk-B4E4X2TN.js";
import "./chunk-HS6YI5DU.js";
import {
  i
} from "./chunk-CDBOQCLE.js";
import "./chunk-RSRUEM5U.js";
import "./chunk-HFJMEXIX.js";
import "./chunk-VYSGSKHB.js";
import "./chunk-UAFQMHYI.js";
import "./chunk-IDPLBNJX.js";
import "./chunk-ZHAZR5C3.js";
import "./chunk-P4MNTMCZ.js";
import "./chunk-BSPKLAHD.js";
import "./chunk-WZJNHZ6H.js";
import {
  w
} from "./chunk-XMYPMIYH.js";
import "./chunk-FQLGRQKL.js";
import {
  E as E2,
  F as F2,
  G as G2,
  R,
  q as q2
} from "./chunk-XGTCDM4C.js";
import {
  c as c2
} from "./chunk-LQBHIBXV.js";
import {
  t
} from "./chunk-42DUJ2CX.js";
import "./chunk-B35SNV2V.js";
import "./chunk-Z2F5OKVA.js";
import {
  b,
  d as d2,
  p
} from "./chunk-UQA6M3KF.js";
import {
  e as e4
} from "./chunk-GLF3KRAL.js";
import {
  n as n6,
  r as r3
} from "./chunk-ZLQTPFTL.js";
import {
  a as a3
} from "./chunk-O76UVYOO.js";
import "./chunk-HZSGATFT.js";
import "./chunk-KNMQQRV7.js";
import {
  e as e3
} from "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import {
  n as n4,
  r as r2
} from "./chunk-AKEHDP75.js";
import {
  E,
  a as a2
} from "./chunk-5MMGIT64.js";
import "./chunk-SCHTG6ZQ.js";
import "./chunk-S5I4QKJD.js";
import {
  I,
  q
} from "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-326OSIM5.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-WMUEII2O.js";
import "./chunk-6QNF7OHN.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import {
  C as C2,
  F
} from "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import {
  D,
  f as f2
} from "./chunk-C7NPPGFR.js";
import {
  n as n3
} from "./chunk-ZPYA32PH.js";
import {
  c,
  h as h2
} from "./chunk-OCF7OAES.js";
import {
  P as P2,
  _,
  e as e2,
  g,
  j as j2,
  r,
  u as u2,
  x as x2,
  z
} from "./chunk-JZBR4X6W.js";
import {
  n as n2
} from "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-LGQXPGTM.js";
import "./chunk-2SDMYJDE.js";
import "./chunk-C62RZQQX.js";
import {
  h
} from "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import {
  G
} from "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import {
  A3 as A2,
  J,
  K,
  Z,
  j,
  s3 as s,
  se,
  v
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import {
  f
} from "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  A,
  C,
  P,
  d
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import {
  u
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/geometry/projection/projectDirection.js
function f7(t7, f8, a8, n8, p5) {
  r(i2, t7), u2(m4, t7, f8), n5(i2, a8, i2, p5), n5(m4, a8, m4, p5), e2(n8, m4, i2), z(n8, n8);
}
var i2 = n2();
var m4 = n2();

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/MeasurementData.js
var J2 = class {
  get numVertices() {
    return this._length;
  }
  get hasStagedVertex() {
    return this._hasCursorPoint;
  }
  constructor(e8) {
    this.validMeasurement = false, this.positionsWorld = [], this.positionsRender = [], this.positionsFittedWorld = [], this.positionsFittedRender = [], this.positionsGeodesic = [], this.positionsSpherical = [], this.positionsStereographic = [], this.pathSegmentLengths = [], this.geodesicPathSegmentLengths = [], this.perimeterSegmentLengths = [], this.intersectingSegments = /* @__PURE__ */ new Set(), this.geodesicIntersectingSegments = /* @__PURE__ */ new Set(), this.triangleIndices = null, this.geodesicTriangleIndices = null, this.areaCentroidWorldCoords = n2(), this.areaCentroidRenderCoords = n2(), this.geodesicAreaCentroidRenderCoords = n2(), this.fittingMode = null, this.area = null, this.geodesicArea = null, this.pathLength = null, this.geodesicPathLength = null, this.perimeterLength = null, this._length = 0, this._centroidRenderCoords = n2(), this._planeWorldCoords = n4(), this._worldUp = n2(), this._worldTangent = n2(), this._frame = [n2(), n2(), n2()], this._pathVersion = -1, this._hasCursorPoint = false, this._mode = null, this._tempU = n2(), this._tempV = n2(), this._tempVec3 = n2(), this._tempSphere = w(), this._sceneView = e8;
    const t7 = l4(e8.spatialReference);
    this._measurementSR = t7, this._lengthMeasurementUnit = Z(t7) ?? "meters", this._areaMeasurementUnit = se(t7) ?? "square-meters";
  }
  update(e8, t7, s4, i3, o5, n8) {
    const r11 = null != t7, h9 = this._pathVersion === e8.version, a8 = this._hasCursorPoint === r11, l5 = this._mode === o5;
    return !(h9 && !n8 && a8 && l5 && e8.isValidPolygon) && (this._pathVersion = e8.version, this._hasCursorPoint = r11, this._updateCursorSegmentLength(e8, t7), this._update(e8, t7, s4, i3, o5), true);
  }
  _update(e8, s4, i3, o5, n8) {
    const r11 = this._sceneView.renderSpatialReference, h9 = this._measurementSR, a8 = i3.spatialReference;
    let l5 = e8.numVertices;
    const d4 = !(null == s4 || s4.equals(e8.lastPoint) || l5 > 2 && s4.equals(e8.firstPoint));
    d4 && (l5 += 1);
    const g5 = !e8.polygonIsClosed && l5 > 2, c5 = e8.polygonIsClosed || g5;
    this._resize(l5);
    const p5 = a3(a8), m7 = null != a8 && r9(a8) ? a8 : null, u6 = null != m7 && F(a8, p5), { positionsGeodesic: _6, positionsWorld: S4, positionsRender: L, positionsSpherical: C3 } = this, P4 = (e9, t7) => {
      K2(i3.elevationProvider, e9), c2(e9, S4[t7], h9), c2(e9, L[t7], r11), u6 && (c2(e9, _6[t7], m7), c2(e9, C3[t7], p5), z(C3[t7], C3[t7]));
    };
    e8.forEachVertexPosition((e9, t7) => P4(e9, t7)), d4 && P4(s4, l5 - 1);
    const U2 = this._updatePathLengths(c5);
    if (this.pathLength = this._length > 1 ? a4(U2, this._lengthMeasurementUnit) : null, u6) {
      const e9 = this._updateGeodesicPathLengths(c5, m7);
      this.geodesicPathLength = null != e9 && this._length > 1 ? e9 : null;
    } else
      this.geodesicPathLength = null;
    if (this._updateMode(n8), !c5)
      return this.area = null, this.geodesicArea = null, this.perimeterLength = null, this.triangleIndices = null, this.geodesicTriangleIndices = null, this.intersectingSegments.clear(), this.geodesicIntersectingSegments.clear(), void (this.validMeasurement = false);
    this._updateAreaAndPerimeterLength(i3, r11, h9, o5), u6 && this._updateGeodesicArea(i3, m7), this.validMeasurement = true;
  }
  getData() {
    return { validMeasurement: this.validMeasurement, numVertices: this.numVertices, hasStagedVertex: this.hasStagedVertex, positionsRender: this.positionsRender, positionsFittedWorld: this.positionsFittedWorld, positionsFittedRender: this.positionsFittedRender, intersectingSegments: this.intersectingSegments, geodesicIntersectingSegments: this.geodesicIntersectingSegments, triangleIndices: this.triangleIndices, geodesicTriangleIndices: this.geodesicTriangleIndices, areaCentroidRenderCoords: this.areaCentroidRenderCoords, geodesicAreaCentroidRenderCoords: this.geodesicAreaCentroidRenderCoords, area: this.area, geodesicArea: this.geodesicArea, pathLength: this.pathLength, geodesicPathLength: this.geodesicPathLength, perimeterLength: this.perimeterLength, actualMeasurementMode: this.actualMeasurementMode };
  }
  _resize(e8) {
    for (e8 < this._length && (this.positionsWorld.length = e8, this.positionsRender.length = e8, this.positionsFittedWorld.length = e8, this.positionsFittedRender.length = e8, this.positionsGeodesic.length = e8, this.positionsSpherical.length = e8, this.positionsStereographic.length = e8, this.pathSegmentLengths.length = e8, this.geodesicPathSegmentLengths.length = e8, this.perimeterSegmentLengths.length = e8, this._length = e8); this._length < e8; )
      this.positionsWorld.push(n2()), this.positionsRender.push(n2()), this.positionsFittedWorld.push(n6()), this.positionsFittedRender.push(n2()), this.positionsGeodesic.push(n2()), this.positionsSpherical.push(n2()), this.positionsStereographic.push(n6()), this.pathSegmentLengths.push(0), this.geodesicPathSegmentLengths.push(0), this.perimeterSegmentLengths.push(0), ++this._length;
  }
  _updatePathLengths(e8) {
    const t7 = this.positionsWorld, s4 = this.pathSegmentLengths;
    let i3 = 0;
    const o5 = this._length;
    for (let n8 = 0; n8 < o5; ++n8) {
      const r11 = s4[n8] = x2(t7[n8], t7[(n8 + 1) % o5]);
      (n8 < o5 - 1 || e8) && (i3 += r11);
    }
    return i3;
  }
  _updateGeodesicPathLengths(e8, i3) {
    const o5 = this.positionsGeodesic, n8 = this.geodesicPathSegmentLengths;
    let r11 = 0;
    const h9 = this._length;
    for (let t7 = 0; t7 < h9; ++t7) {
      const a8 = u4(o5[t7], o5[(t7 + 1) % h9], i3);
      if (null == a8)
        return null;
      const l5 = s2(a8, "meters").value, d4 = n8[t7] = l5;
      (t7 < h9 - 1 || e8) && (r11 += d4);
    }
    return a4(r11, "meters");
  }
  _updateAreaAndPerimeterLength(e8, t7, s4, i3) {
    const o5 = e8.renderCoordsHelper, n8 = this.positionsWorld, h9 = this.positionsRender, a8 = this.positionsFittedWorld, l5 = this.positionsFittedRender, f8 = this._planeWorldCoords, S4 = this._centroidRenderCoords;
    d2(h9, S4), o5.worldUpAtPosition(S4, this._worldUp), o5.worldBasisAtPosition(S4, n3.X, this._worldTangent), f7(S4, this._worldUp, t7, this._worldUp, s4), f7(S4, this._worldTangent, t7, this._worldTangent, s4), n8.length > 2 && h7(n8, f8), this.fittingMode = this._selectFittingMode(f8, n8, this._worldUp, i3);
    let L = 0;
    if ("horizontal" === this.fittingMode) {
      let e9 = -1 / 0;
      h9.forEach((t8, s5) => {
        const i4 = o5.getAltitude(h9[s5]);
        i4 > e9 && (e9 = i4, L = s5);
      });
    }
    const C3 = n8[L];
    let M = f8, j4 = this._worldTangent;
    "horizontal" === this.fittingMode ? M = this._worldUp : "vertical" === this.fittingMode && (M = this._tempVec3, j4 = this._worldUp, b(f8, this._worldUp, M)), r(this._frame[2], M), b(j4, M, this._frame[0]), _(this._frame[1], this._frame[0], this._frame[2]), j2(this._frame[1], this._frame[1]);
    const R3 = this._tempVec3, v2 = this._tempU, V = this._tempV;
    for (let d4 = 0; d4 < this._length; ++d4) {
      const e9 = a8[d4], i4 = l5[d4];
      e2(R3, n8[d4], C3), o2(e9, P2(this._frame[0], R3), P2(this._frame[1], R3)), g(v2, this._frame[0], e9[0]), g(V, this._frame[1], e9[1]), u2(R3, v2, V), u2(R3, R3, C3), n5(R3, s4, i4, t7);
    }
    this.perimeterLength = this._length > 0 ? this._updatePerimeterLengths() : null, d2(l5, this.areaCentroidRenderCoords), n5(this.areaCentroidRenderCoords, t7, this.areaCentroidWorldCoords, s4), this._updateIntersectingSegments(), this.area = 0 === this.intersectingSegments.size ? this._computeArea() : null;
  }
  _updateGeodesicArea(e8, t7) {
    const { renderCoordsHelper: s4, spatialReference: i3 } = e8, { positionsSpherical: o5, positionsStereographic: n8 } = this, h9 = this._tempVec3, a8 = j3(o5, h9);
    if (!a8)
      return void (this.geodesicArea = null);
    const l5 = this._tempU, d4 = this._tempV;
    p(h9, l5, d4);
    for (let g5 = 0; g5 < this._length; ++g5) {
      const e9 = P2(o5[g5], l5), t8 = P2(o5[g5], d4), s5 = P2(o5[g5], h9);
      o2(n8[g5], e9 / s5, t8 / s5);
    }
    g(h9, h9, s(i3).radius), s4.toRenderCoords(h9, a3(i3), this.geodesicAreaCentroidRenderCoords), this._updateGeodesicIntersectingSegments(), this.geodesicArea = a8 && 0 === this.geodesicIntersectingSegments.size ? this._computeGeodesicArea(t7) : null;
  }
  _updatePerimeterLengths() {
    const e8 = this.positionsFittedWorld, s4 = this.perimeterSegmentLengths;
    let i3 = 0;
    for (let t7 = 0; t7 < this._length; ++t7) {
      i3 += s4[t7] = m(e8[t7], e8[(t7 + 1) % this._length]);
    }
    return a4(i3, this._lengthMeasurementUnit);
  }
  _updateIntersectingSegments() {
    const e8 = this.positionsFittedWorld, t7 = this.intersectingSegments;
    t7.clear();
    for (let s4 = 0; s4 < this._length; ++s4)
      for (let i3 = s4 + 2; i3 < this._length; ++i3) {
        if ((i3 + 1) % this._length === s4)
          continue;
        const o5 = e8[s4], n8 = e8[(s4 + 1) % this._length], r11 = e8[i3], h9 = e8[(i3 + 1) % this._length];
        G(o5, n8, r11, h9) && (t7.add(s4), t7.add(i3));
      }
  }
  _computeArea() {
    const e8 = this.positionsFittedWorld, t7 = this.triangleIndices = t2(k(e8));
    let s4 = 0;
    for (let i3 = 0; i3 < t7.length; i3 += 3)
      s4 += S2(e8[t7[i3]], e8[t7[i3 + 1]], e8[t7[i3 + 2]]);
    return l3(s4, this._areaMeasurementUnit);
  }
  _updateGeodesicIntersectingSegments() {
    const e8 = this.positionsStereographic, t7 = this.geodesicIntersectingSegments;
    t7.clear();
    for (let s4 = 0; s4 < this._length; ++s4)
      for (let i3 = s4 + 2; i3 < this._length; ++i3) {
        if ((i3 + 1) % this._length === s4)
          continue;
        const o5 = e8[s4], n8 = e8[(s4 + 1) % this._length], r11 = e8[i3], h9 = e8[(i3 + 1) % this._length];
        G(o5, n8, r11, h9) && (t7.add(s4), t7.add(i3));
      }
  }
  _computeGeodesicArea(e8) {
    const t7 = this.positionsGeodesic, o5 = this.positionsStereographic, n8 = this.geodesicTriangleIndices = t2(k(o5));
    let r11 = 0;
    for (let i3 = 0; i3 < n8.length; i3 += 3) {
      const o6 = m3(t7[n8[i3]], t7[n8[i3 + 1]], t7[n8[i3 + 2]], e8);
      if (null == o6)
        return null;
      r11 += s2(o6, "square-meters").value;
    }
    return l3(r11, "square-meters");
  }
  _selectFittingMode(t7, s4, i3, o5) {
    const n8 = s4.map((e8) => Math.abs(p3(t7, e8))).reduce((e8, t8) => Math.max(e8, t8), 0);
    g2(s4, this._tempSphere);
    const r11 = n8 / (2 * this._tempSphere[3]), h9 = r11 < o5.maxRelativeErrorCoplanar, a8 = r11 < o5.maxRelativeErrorAlmostCoplanar;
    let l5 = "horizontal";
    if (h9)
      l5 = "oblique";
    else if (a8) {
      l5 = Math.abs(P2(i3, t7)) > Math.cos(h2(o5.verticalAngleThreshold)) ? "horizontal" : "vertical";
    }
    return l5;
  }
  _updateCursorSegmentLength(e8, t7) {
    var _a;
    const s4 = e8.lastPoint;
    e8.isValidPolygon || null == s4 || null == t7 ? (this.geodesicStagedSegmentLength = null, this.stagedSegmentLength = null) : (this.geodesicStagedSegmentLength = f4(s4, t7), this.stagedSegmentLength = (_a = h5(s4, t7)) == null ? void 0 : _a.direct);
  }
  _updateMode(e8) {
    if (e8 === e7.Auto) {
      this.actualMeasurementMode = "euclidean";
      let e9 = 0;
      null != this.geodesicPathLength && (e9 += this.geodesicPathLength.value), e9 > N && (this.actualMeasurementMode = "geodesic");
    } else
      this.actualMeasurementMode = e8 === e7.Euclidean ? "euclidean" : "geodesic";
    null == this.geodesicPathLength && (this.actualMeasurementMode = "euclidean"), this._mode = e8;
  }
};
function K2(e8, t7) {
  t7.hasZ || (t7.z = a5(e8, t7, "ground") ?? 0);
}
var N = 1e5;

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/AreaMeasurementController.js
var n7 = class extends S {
  constructor(t7) {
    super(t7);
  }
  initialize() {
    this._measurementDataManager = new J2(this.view), this.addHandles([this.analysisViewData.path.on("change", () => this._update()), d(() => this.analysisViewData.stagedPoint, () => this._update(), C), d(() => this.analysisViewData.mode, () => this._update(), C)]), this._update();
  }
  _update(t7 = false) {
    const { analysisViewData: a8, view: e8 } = this, s4 = { maxRelativeErrorCoplanar: 5e-3, maxRelativeErrorAlmostCoplanar: 0.01, verticalAngleThreshold: 80 };
    this._measurementDataManager.update(a8.path, a8.stagedPoint, e8, s4, a8.mode, t7) && (a8.measurementData = this._measurementDataManager.getData());
  }
};
e([y({ constructOnly: true })], n7.prototype, "view", void 0), e([y({ constructOnly: true })], n7.prototype, "analysis", void 0), e([y({ constructOnly: true })], n7.prototype, "analysisViewData", void 0), n7 = e([a("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementController")], n7);

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/AreaMeasurementPathHelper.js
var g3 = class extends o.EventedAccessor {
  constructor(e8 = {}) {
    super(e8), this._version = 0, this._internalGeometryChange = false, this._extent = D();
  }
  set areaMeasurement(e8) {
    this._set("areaMeasurement", e8), null != e8 && null != this.view && this._initialize(e8, this.view);
  }
  set view(e8) {
    this._set("view", e8), null != e8 && null != this.areaMeasurement && this._initialize(this.areaMeasurement, e8);
  }
  get constructed() {
    return null != this.areaMeasurement && null != this.view;
  }
  get version() {
    return this._version;
  }
  get isEmptyPolygon() {
    return !this.constructed || 0 === this._editGeometry.components.length;
  }
  get isValidPolygon() {
    return this.constructed && this.polygonIsClosed;
  }
  get extent() {
    if (this.constructed && this._editGeometry.components.length > 0 && this._editGeometry.components[0].vertices.length > 0) {
      const e8 = D(this._extent);
      return this.forEachVertex((t7) => {
        f2(e8, t7.pos);
      }), e8;
    }
    return null;
  }
  get spatialReference() {
    return this.constructed ? this._editGeometry.coordinateHelper.spatialReference : null;
  }
  _initialize(e8, t7) {
    this.removeAllHandles(), this.addHandles(d(() => e8.geometry, () => {
      this._updateEditGeometryFromModelGeometry(e8, t7);
    }, A)), this._makeDirty(true);
  }
  _makeDirty(e8 = false) {
    this.notifyChange("polygonIsClosed"), this.notifyChange("isValidPolygon"), this.notifyChange("initialized"), this.notifyChange("extent"), e8 && this.notifyChange("numVertices");
  }
  _updateEditGeometryFromModelGeometry(e8, t7) {
    if (this._version++, this._internalGeometryChange)
      return;
    this.removeHandles("EditGeometry");
    let r11 = e8.geometry;
    if (null != r11) {
      const i3 = C2(r11, t7.spatialReference);
      null == i3 && t6(e8, r11.spatialReference, n.getLogger(this)), r11 = i3;
    }
    this._editGeometryOperations = null != r11 ? E4.fromGeometry(r11, t7.state.viewingMode) : new E4(new p2("polygon", P3(true, false, t7.spatialReference)), t7.state.viewingMode), this._makeDirty(true), this.emit("change"), this.addHandles(this._editGeometry.on("change", (t8) => {
      this._makeDirty(null != t8.addedVertices || null != t8.removedVertices), this._internalGeometryChange = true, e8.geometry = this.numVertices > 0 ? this._editGeometry.geometry : null, this._internalGeometryChange = false;
    }), "EditGeometry");
  }
  get _editGeometry() {
    return this._editGeometryOperations.data;
  }
  get vertices() {
    const e8 = [];
    return this.forEachVertex((t7) => {
      e8.push(t7);
    }), e8;
  }
  get numVertices() {
    return this.constructed && this._editGeometry.components.length > 0 ? this._editGeometry.components[0].vertices.length : 0;
  }
  get polygonIsClosed() {
    return this._editGeometry.components.length > 0 && this._editGeometry.components[0].isClosed();
  }
  get firstPoint() {
    if (this.constructed && this._editGeometry.components.length > 0) {
      const e8 = this._editGeometry.components[0].getFirstVertex();
      if (null != e8)
        return this._editGeometry.coordinateHelper.vectorToPoint(e8.pos);
    }
    return null;
  }
  get lastPoint() {
    if (this.constructed && this._editGeometry.components.length > 0) {
      const e8 = this._editGeometry.components[0].getLastVertex();
      if (null != e8)
        return this._editGeometry.coordinateHelper.vectorToPoint(e8.pos);
    }
    return null;
  }
  getVertex(e8) {
    if (!this.constructed || 0 === this._editGeometry.components.length || 0 === this._editGeometry.components[0].vertices.length)
      return null;
    const t7 = this._editGeometry.components[0].vertices[0];
    let o5 = t7;
    do {
      if (o5.index === e8)
        return o5;
      o5 = o5.rightEdge.rightVertex;
    } while (o5 !== t7 && null != o5);
    return null;
  }
  getVertexPositionAsPoint(e8) {
    return this._editGeometry.coordinateHelper.vectorToPoint(e8.pos);
  }
  getVertexPositionAsPointFromIndex(e8) {
    return this._editGeometry.coordinateHelper.vectorToPoint(this.getVertex(e8).pos);
  }
  forEachVertex(e8) {
    this.constructed && this._editGeometry.components.length > 0 && this._editGeometry.components[0].iterateVertices(e8);
  }
  forEachVertexPosition(e8) {
    const t7 = this._editGeometry.coordinateHelper;
    this.forEachVertex((o5, r11) => {
      t7.vectorToPoint(o5.pos, _4), e8(_4, r11);
    });
  }
  clear() {
    null != this.areaMeasurement && (this.areaMeasurement.geometry = null);
  }
  add(e8) {
    if (!this.constructed)
      return null;
    if (0 === this._editGeometry.components.length) {
      const e9 = this.view;
      this._editGeometry.components.push(new a6(e9.spatialReference, e9.state.viewingMode));
    }
    const t7 = this._editGeometryOperations.appendVertex(this._editGeometry.coordinateHelper.pointToVector(e8));
    return this.emit("change"), t7;
  }
  close() {
    if (!this.constructed || 0 === this._editGeometry.components.length)
      return null;
    const e8 = this._editGeometryOperations.closeComponent(this._editGeometry.components[0]);
    return this.emit("change"), e8;
  }
  ensureContains(e8, t7 = "") {
    let o5 = false;
    if (this._editGeometry.components.forEach((t8) => {
      t8.iterateVertices((t9) => {
        t9 === e8 && (o5 = true);
      });
    }), !o5)
      throw new Error(`vertex doesnt exist ${t7}`);
    return o5;
  }
  setVertexPosition(e8, t7) {
    if (!this.constructed)
      return null;
    const o5 = this._editGeometryOperations.setVertexPosition(e8, this._editGeometry.coordinateHelper.pointToVector(t7));
    return this.emit("change"), o5;
  }
  equals(e8) {
    if (this.numVertices !== e8.numVertices)
      return false;
    let t7 = true;
    return this.forEachVertexPosition((o5, r11) => {
      const i3 = e8.getVertexPositionAsPointFromIndex(r11);
      o5.equals(i3) || (t7 = false);
    }), !!t7;
  }
};
e([y({ value: null })], g3.prototype, "areaMeasurement", null), e([y({ value: null })], g3.prototype, "view", null), e([y()], g3.prototype, "isEmptyPolygon", null), e([y()], g3.prototype, "isValidPolygon", null), e([y()], g3.prototype, "extent", null), e([y()], g3.prototype, "spatialReference", null), e([y()], g3.prototype, "numVertices", null), e([y()], g3.prototype, "polygonIsClosed", null), g3 = e([a("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementPathHelper")], g3);
var _4 = new x();

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/CheckerBoardTechnique.js
var d3 = class _d extends r6 {
  initializeProgram(e8) {
    return new r7(e8.rctx, _d.shader.get().build(this.configuration), O);
  }
  _setPipelineState(e8) {
    const r11 = this.configuration, t7 = e8 === o3.NONE, s4 = e8 === o3.FrontFace;
    return S3({ blending: r11.transparent ? t7 ? g4 : A3(e8) : null, depthTest: { func: l2(e8) }, depthWrite: t7 ? r11.writeDepth ? o4 : null : E3(e8), colorWrite: _2, polygonOffset: t7 || s4 ? r11.polygonOffset ? h8 : null : { factor: -1, units: -25 } });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
};
d3.shader = new t4(c3, () => import("./CheckerBoard.glsl-MFADKYTV.js"));
var h8 = { factor: 0, units: -25 };
var g4 = l(R2.SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE_MINUS_SRC_ALPHA);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/CheckerBoardTechniqueConfiguration.js
var r10 = class extends t5 {
  constructor() {
    super(...arguments), this.transparencyPassType = o3.NONE, this.transparent = false, this.writeDepth = true, this.polygonOffset = false, this.multipassEnabled = false, this.cullAboveGround = false;
  }
};
e([r8({ count: o3.COUNT })], r10.prototype, "transparencyPassType", void 0), e([r8()], r10.prototype, "transparent", void 0), e([r8()], r10.prototype, "writeDepth", void 0), e([r8()], r10.prototype, "polygonOffset", void 0), e([r8()], r10.prototype, "multipassEnabled", void 0), e([r8()], r10.prototype, "cullAboveGround", void 0), e([r8({ constValue: false })], r10.prototype, "occlusionPass", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/CheckerBoardMaterial.js
var u5 = class extends e5 {
  constructor(r11) {
    super(r11, new m5()), this.produces = /* @__PURE__ */ new Map([[A4.OPAQUE_MATERIAL, (r12) => i(r12) && !this.parameters.transparent], [A4.TRANSPARENT_MATERIAL, (r12) => i(r12) && this.parameters.transparent && this.parameters.writeDepth], [A4.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL, (r12) => i(r12) && this.parameters.transparent && !this.parameters.writeDepth]]), this._configuration = new r10();
  }
  getConfiguration(r11, t7) {
    return this._configuration.transparent = this.parameters.transparent, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.polygonOffset = this.parameters.polygonOffset, this._configuration.transparencyPassType = t7.transparencyPassType, this._configuration.multipassEnabled = t7.multipassEnabled, this._configuration.cullAboveGround = t7.multipassTerrain.cullAboveGround, this._configuration;
  }
  createGLMaterial(r11) {
    return new c4(r11);
  }
  createBufferWriter() {
    return new r5(f3);
  }
};
var c4 = class extends t3 {
  beginSlot(r11) {
    return this.ensureTechnique(d3, r11);
  }
};
var m5 = class extends u3 {
  constructor() {
    super(...arguments), this.size = r3(1, 1), this.color1 = r2(0.75, 0.75, 0.75, 1), this.color2 = r2(0.5, 0.5, 0.5, 1), this.transparent = false, this.writeDepth = true, this.polygonOffset = false;
  }
};

// node_modules/@arcgis/core/views/3d/interactive/visualElements/MeasurementAreaVisualElement.js
var _5 = class extends a7 {
  constructor(e8) {
    super(e8), this._checkerBoardMaterial = null, this._renderOccluded = h3.OccludeAndTransparent, this._geometry = null, this._size = r3(1, 1), this._color1 = r2(1, 0.5, 0, 0.5), this._color2 = r2(1, 1, 1, 0.5), this.applyProperties(e8);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e8) {
    e8 !== this._renderOccluded && (this._renderOccluded = e8, this._updateMaterial());
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e8) {
    this._geometry = e8, this.recreateGeometry();
  }
  get size() {
    return this._size;
  }
  set size(e8) {
    r4(this._size, e8), this._updateMaterial();
  }
  get color1() {
    return this._color1;
  }
  set color1(e8) {
    E(e8, this._color1) || (a2(this._color1, e8), this._updateMaterial());
  }
  get color2() {
    return this._color2;
  }
  set color2(e8) {
    E(e8, this._color2) || (a2(this._color2, e8), this._updateMaterial());
  }
  _updateMaterial() {
    null != this._checkerBoardMaterial && this._checkerBoardMaterial.setParameters({ size: this._size, color1: this._color1, color2: this._color2, renderOccluded: this._renderOccluded });
  }
  createExternalResources() {
    this._checkerBoardMaterial = new u5({ size: this._size, color1: this._color1, color2: this._color2, transparent: true, writeDepth: false, polygonOffset: true, renderOccluded: h3.OccludeAndTransparent, isDecoration: this.isDecoration });
  }
  destroyExternalResources() {
    this._checkerBoardMaterial = null;
  }
  forEachExternalMaterial(e8) {
    null != this._checkerBoardMaterial && e8(this._checkerBoardMaterial);
  }
  createGeometries(r11) {
    if (null == this._geometry || null == this._checkerBoardMaterial)
      return;
    const t7 = p4;
    I(t7, this.transform);
    const s4 = this._geometry, c5 = [], a8 = n2();
    s4.position.forEach((e8) => {
      e2(a8, e8, t7), c5.push(a8[0], a8[1], a8[2]);
    });
    const l5 = [];
    s4.uv.forEach((e8) => {
      l5.push(e8[0], e8[1]);
    });
    const d4 = new I2(this._checkerBoardMaterial, [[e4.POSITION, new t(c5, s4.triangleIndices, 3, true)], [e4.UV0, new t(l5, s4.triangleIndices, 2, true)]]);
    r11.addGeometry(d4);
  }
};
var p4 = n2();

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/AreaMeasurementVisualization.js
var F3 = class extends S {
  get _parameters() {
    const { accentColor: e8, textColor: t7 } = this.view.effectiveTheme, o5 = E2(e8), l5 = F2(e8, 0.5), c5 = F2(G2(e8), 0.5), m7 = G2(t7, q2.Low);
    return { accentColor: o5, transparentAccentColor: l5, transparentContrastColor: c5, intersectingLineColor: [1, 0.2, 0, 1], textColor: t7, textBackgroundColor: R(m7, 0.6), textCalloutColor: R(m7, 0.5), pathLineWidth: 3, perimeterLineWidth: 2, projectionLineWidth: 2, projectionLineStippleSize: 5, labelDistance: 25 };
  }
  get visible() {
    return this.analysisViewData.visible;
  }
  get _renderUnits() {
    const e8 = this.view.renderCoordsHelper.spatialReference;
    return Z(e8) ?? "meters";
  }
  get testData() {
    return { labels: { area: this._areaLabel, perimeterLength: this._perimeterLengthLabel } };
  }
  constructor(e8) {
    super(e8), this._path = null, this._intersectedPath = null, this._perimeter = null, this._intersectedPerimeter = null, this._projectionLines = null, this._measurementArea = null, this._areaLabel = null, this._perimeterLengthLabel = null, this._pathSegments = [], this._perimeterSegments = [], this._origin = n2(), this._originTransform = e3(), this.messages = null, this.viewData = B, this.areaLabel = null, this.perimeterLengthLabel = null, this.loadingMessages = true;
  }
  initialize() {
    const { analysisViewData: e8, _parameters: t7, view: i3 } = this;
    this._path = new f5({ view: i3, attached: true, width: t7.pathLineWidth, polygonOffset: true, renderOccluded: h3.OccludeAndTransparent, isDecoration: true }), this._intersectedPath = new f5({ view: i3, attached: true, width: t7.pathLineWidth, polygonOffset: true, renderOccluded: h3.OccludeAndTransparent, isDecoration: true }), this._perimeter = new f5({ view: i3, attached: true, width: t7.perimeterLineWidth, polygonOffset: true, renderOccluded: h3.OccludeAndTransparent, isDecoration: true }), this._intersectedPerimeter = new f5({ view: i3, attached: true, width: t7.perimeterLineWidth, color: t7.intersectingLineColor, polygonOffset: true, renderOccluded: h3.OccludeAndTransparent, isDecoration: true }), this._projectionLines = new f5({ view: i3, attached: true, width: t7.projectionLineWidth, stipplePattern: h4(t7.projectionLineStippleSize), polygonOffset: true, renderOccluded: h3.OccludeAndTransparent, isDecoration: true }), this._measurementArea = new _5({ view: i3, attached: true, isDecoration: true });
    const r11 = { attached: true, view: i3, isDecoration: true };
    this._areaLabel = new f6({ ...r11, fontSize: G3.Large }), this._perimeterLengthLabel = new f6({ ...r11, fontSize: G3.Small }), this.addHandles([d(() => [e8.mode, this.visible, e8.unit, e8.measurementData, e8.stagedPoint], () => this._update(), A), d(() => {
      var _a;
      return (_a = i3.state) == null ? void 0 : _a.camera;
    }, () => this._updateLabels(), A), f(() => this._updateMessageBundle()), d(() => this._parameters, ({ accentColor: e9, transparentAccentColor: t8, transparentContrastColor: i4, textColor: r12, textBackgroundColor: s4, textCalloutColor: n8 }) => {
      const { _path: a8, _intersectedPath: o5, _perimeter: l5, _projectionLines: c5, _measurementArea: m7, _areaLabel: h9, _perimeterLengthLabel: d4 } = this;
      a8.color = e9, o5.color = e9, l5.color = e9, c5.color = e9, m7.color1 = t8, m7.color2 = i4, h9.textColor = r12, h9.backgroundColor = s4, h9.calloutColor = n8, d4.textColor = r12, d4.backgroundColor = s4, d4.calloutColor = n8;
    }, P)]), this._updateMessageBundle();
  }
  destroy() {
    this._measurementArea = u(this._measurementArea), this._path = u(this._path), this._intersectedPath = u(this._intersectedPath), this._perimeter = u(this._perimeter), this._intersectedPerimeter = u(this._intersectedPerimeter), this._areaLabel = u(this._areaLabel), this._perimeterLengthLabel = u(this._perimeterLengthLabel), this._projectionLines = u(this._projectionLines), this.set("view", null);
  }
  _update() {
    if (this.destroyed || !this.view.ready || !this.view.renderCoordsHelper)
      return;
    const { analysisViewData: { measurementData: e8 }, analysisViewData: t7 } = this;
    null != e8 && (this._updateViewData(e8, t7.path), this._updateOrigin(), this._updatePathSegments(), this._updatePerimeterSegments(), this._updateArea(), this._updateProjectionLines(), this._updateLabels());
  }
  _updateViewData(e8, t7) {
    const i3 = e8.validMeasurement, r11 = "geodesic" === e8.actualMeasurementMode, s4 = r11 ? e8.geodesicArea : e8.area;
    let n8 = 1;
    if (s4) {
      const e9 = I3(s4, this.analysisViewData.unit);
      n8 = c(Math.sqrt(e9.value) / Math.sqrt(300)), n8 *= Math.sqrt(j(1, e9.unit, "square-meters")), n8 = j(n8, "meters", this._renderUnits);
    }
    const a8 = { validMeasurement: i3, numVertices: e8.numVertices, hasStagedVertex: e8.hasStagedVertex, path: t7, mode: e8.actualMeasurementMode, positionsRender: e8.positionsRender, positionsFittedWorld: e8.positionsFittedWorld, positionsFittedRender: e8.positionsFittedRender, intersectingSegments: r11 ? e8.geodesicIntersectingSegments : e8.intersectingSegments, triangleIndices: r11 ? e8.geodesicTriangleIndices : e8.triangleIndices, areaCentroid: r11 ? e8.geodesicAreaCentroidRenderCoords : e8.areaCentroidRenderCoords, perimeterLengthLabelSegmentIndex: 0, area: r11 ? e8.geodesicArea : e8.area, pathLength: r11 ? e8.geodesicPathLength : e8.pathLength, perimeterLength: e8.perimeterLength, checkerSize: n8 };
    this._set("viewData", a8);
  }
  _updateOrigin() {
    const e8 = this.viewData;
    d2(e8.positionsRender, this._origin), q(this._originTransform, this._origin), this._measurementArea.transform = this._originTransform, this._projectionLines.transform = this._originTransform;
  }
  _createSegments(e8) {
    const t7 = this.viewData, i3 = this.view.renderCoordsHelper.spatialReference, r11 = t7.mode, s4 = [], n8 = [], a8 = [], o5 = t7.numVertices, l5 = t7.validMeasurement ? o5 : o5 - 1;
    for (let m7 = 0; m7 < l5; ++m7) {
      const l6 = t7[e8][m7], c6 = t7[e8][(m7 + 1) % o5];
      let h9 = null;
      switch (r11) {
        case "euclidean":
          h9 = new m2(l6, c6);
          break;
        case "geodesic":
          h9 = new _3(l6, c6, i3);
      }
      t7.intersectingSegments.has(m7) ? a8.push(h9) : n8.push(h9), s4.push(h9);
    }
    let c5 = null;
    return t7.validMeasurement && t7.hasStagedVertex && l5 >= 2 ? c5 = s4[s4.length - 2] : t7.hasStagedVertex && l5 >= 1 && (c5 = s4[s4.length - 1]), { all: s4, nonIntersecting: n8, intersecting: a8, stagedSegment: c5 };
  }
  _updatePathSegments() {
    const { visible: e8 } = this, t7 = this._createSegments("positionsRender");
    this._path.setGeometryFromSegments(t7.nonIntersecting, this._origin), this._path.visible = e8, this._intersectedPath.setGeometryFromSegments(t7.intersecting, this._origin), this._intersectedPath.visible = e8, this._pathSegments = t7.all;
  }
  _updatePerimeterSegments() {
    const e8 = this.visible && "euclidean" === this.viewData.mode, t7 = this._createSegments("positionsFittedRender");
    this._perimeter.setGeometryFromSegments(t7.nonIntersecting, this._origin), this._perimeter.visible = e8, this._intersectedPerimeter.setGeometryFromSegments(t7.intersecting, this._origin), this._intersectedPerimeter.visible = e8, this._perimeterSegments = t7.all;
  }
  _updateArea() {
    const e8 = this.viewData;
    switch (e8.mode) {
      case "euclidean":
        this._updateAreaEuclidean(e8);
        break;
      case "geodesic":
        this._updateAreaGeodesic();
    }
  }
  _updateAreaEuclidean(e8) {
    const t7 = this.visible;
    e8.validMeasurement && 0 === e8.intersectingSegments.size && e8.triangleIndices ? (this._measurementArea.geometry = { uv: e8.positionsFittedWorld, position: e8.positionsFittedRender, triangleIndices: e8.triangleIndices }, this._measurementArea.size = [e8.checkerSize, e8.checkerSize], this._measurementArea.visible = t7) : this._measurementArea.visible = false;
  }
  _updateAreaGeodesic() {
    this._measurementArea.visible = false;
  }
  _updateProjectionLines() {
    const e8 = this.viewData, t7 = this.visible, i3 = e8.mode, r11 = e8.numVertices;
    if (r11 > 0 && e8.validMeasurement && "euclidean" === i3) {
      const i4 = [];
      for (let t8 = 0; t8 < r11; ++t8) {
        const r12 = n2();
        e2(r12, e8.positionsRender[t8], this._origin);
        const s4 = n2();
        e2(s4, e8.positionsFittedRender[t8], this._origin), i4.push([r12, s4]);
      }
      this._projectionLines.geometry = i4, this._projectionLines.visible = t7;
    } else
      this._projectionLines.geometry = null, this._projectionLines.visible = false;
  }
  _updateLabels() {
    if (this.destroyed)
      return;
    const { viewData: e8 } = this, { area: t7, path: i3 } = e8;
    if (!i3)
      return;
    const r11 = this.visible, s4 = z2(this.messages, t7, this.analysisViewData.unit);
    if (null != s4 ? (this._areaLabel.geometry = { type: "point", point: e8.areaCentroid }, this._areaLabel.text = s4, this._areaLabel.visible = e8.validMeasurement && 0 === e8.intersectingSegments.size && r11) : this._areaLabel.visible = false, this._set("areaLabel", s4), e8.validMeasurement && 0 === e8.intersectingSegments.size) {
      const t8 = "geodesic" === e8.mode || !e8.validMeasurement, i4 = t8 ? e8.pathLength : e8.perimeterLength, s5 = W(this.messages, i4, this.analysisViewData.unit);
      this._set("perimeterLengthLabel", s5), this._perimeterLengthLabel.distance = this._parameters.labelDistance, this._perimeterLengthLabel.anchor = "top", this._perimeterLengthLabel.text = s5, this._perimeterLengthLabel.visible = true;
      let n8 = true;
      for (let r12 = 0; r12 < e8.numVertices; ++r12) {
        const i5 = (e8.perimeterLengthLabelSegmentIndex + r12) % e8.numVertices, s6 = t8 ? this._pathSegments[i5] : this._perimeterSegments[i5];
        if (n8 = true, this._perimeterLengthLabel.geometry = { type: "segment", segment: s6, sampleLocation: "center" }, !this._perimeterLengthLabel.overlaps(this._areaLabel))
          break;
        n8 = false;
      }
      this._perimeterLengthLabel.visible = n8 && r11;
    } else
      this._perimeterLengthLabel.visible = false;
  }
  _updateMessageBundle() {
    this.loadingMessages = true, h("esri/core/t9n/Units").then((e8) => {
      this.messages = e8, this.view && this._update();
    }).finally(() => {
      this.loadingMessages = false;
    });
  }
};
function z2(e8, t7, i3) {
  return e8 && t7 && h6(e8, t7, U(t7, i3));
}
function I3(e8, t7) {
  return s2(e8, U(e8, t7));
}
function U(e8, t7) {
  switch (t7) {
    case "metric":
      return K(e8.value, e8.unit);
    case "imperial":
      return A2(e8.value, e8.unit);
    default:
      return t7;
  }
}
function W(e8, t7, i3) {
  return e8 && t7 && h6(e8, t7, T(t7, i3));
}
function T(e8, t7) {
  const i3 = E5(t7);
  switch (i3) {
    case "metric":
      return v(e8.value, e8.unit);
    case "imperial":
      return J(e8.value, e8.unit);
    default:
      return i3;
  }
}
function E5(e8) {
  switch (e8) {
    case "metric":
    case "ares":
    case "hectares":
      return "metric";
    case "imperial":
    case "acres":
      return "imperial";
    case "square-inches":
      return "inches";
    case "square-feet":
      return "feet";
    case "square-yards":
      return "yards";
    case "square-miles":
      return "miles";
    case "square-us-feet":
      return "us-feet";
    case "square-millimeters":
      return "millimeters";
    case "square-centimeters":
      return "centimeters";
    case "square-decimeters":
      return "decimeters";
    case "square-meters":
      return "meters";
    case "square-kilometers":
      return "kilometers";
  }
  throw new Error("unhandled area unit");
}
var G3;
e([y()], F3.prototype, "_parameters", null), e([y()], F3.prototype, "view", void 0), e([y()], F3.prototype, "messages", void 0), e([y()], F3.prototype, "analysis", void 0), e([y()], F3.prototype, "viewData", void 0), e([y()], F3.prototype, "analysisViewData", void 0), e([y({ readOnly: true })], F3.prototype, "areaLabel", void 0), e([y({ readOnly: true })], F3.prototype, "perimeterLengthLabel", void 0), e([y()], F3.prototype, "loadingMessages", void 0), e([y()], F3.prototype, "visible", null), e([y()], F3.prototype, "_renderUnits", null), F3 = e([a("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementVisualization")], F3), function(e8) {
  e8[e8.Small = 12] = "Small", e8[e8.Large = 16] = "Large";
}(G3 || (G3 = {}));
var B = { validMeasurement: false, numVertices: 0, hasStagedVertex: false, path: null, mode: null, positionsRender: null, positionsFittedWorld: null, positionsFittedRender: null, intersectingSegments: null, triangleIndices: null, areaCentroid: null, perimeterLengthLabelSegmentIndex: null, checkerSize: null, area: null, pathLength: null, perimeterLength: null };

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurementAnalysisView3D.js
var m6 = class extends s3(S) {
  constructor(e8) {
    super(e8), this.type = "area-measurement-view-3d", this.analysis = null, this.measurementData = null, this.lastDraggedVertex = null, this.stagedPoint = null, this.mode = e7.Auto;
  }
  initialize() {
    const { analysis: e8, view: t7 } = this;
    this.path = new g3({ view: t7, areaMeasurement: e8 }), this.analysisVisualization = new F3({ view: t7, analysis: e8, analysisViewData: this }), this.analysisController = new n7({ view: t7, analysis: e8, analysisViewData: this });
  }
  destroy() {
    this.analysisController = u(this.analysisController), this.analysisVisualization = u(this.analysisVisualization), this.path.destroy();
  }
  get updating() {
    var _a;
    return !!((_a = this.analysisVisualization) == null ? void 0 : _a.loadingMessages);
  }
  get result() {
    const { measurementData: e8 } = this;
    return null == e8 ? { area: null, mode: null, perimeter: null } : "euclidean" === e8.actualMeasurementMode ? { area: e8.area, perimeter: e8.perimeterLength, mode: "euclidean" } : { area: e8.geodesicArea, perimeter: e8.pathLength, mode: "geodesic" };
  }
  get viewData() {
    return this.analysisVisualization.viewData;
  }
  get validMeasurement() {
    return this.path.isValidPolygon;
  }
  get unit() {
    return this.analysis.unit ?? this._defaultUnit;
  }
  get testData() {
    return { visualization: this.analysisVisualization, controller: this.analysisController };
  }
};
e([y({ readOnly: true })], m6.prototype, "type", void 0), e([y({ constructOnly: true, nonNullable: true })], m6.prototype, "analysis", void 0), e([y()], m6.prototype, "updating", null), e([y()], m6.prototype, "analysisVisualization", void 0), e([y()], m6.prototype, "analysisController", void 0), e([y()], m6.prototype, "result", null), e([y()], m6.prototype, "measurementData", void 0), e([y()], m6.prototype, "viewData", null), e([y()], m6.prototype, "validMeasurement", null), e([y()], m6.prototype, "path", void 0), e([y()], m6.prototype, "lastDraggedVertex", void 0), e([y()], m6.prototype, "stagedPoint", void 0), e([y()], m6.prototype, "mode", void 0), e([y()], m6.prototype, "unit", null), e([y(e6)], m6.prototype, "_defaultUnit", void 0), m6 = e([a("esri.views.3d.analysis.AreaMeasurementAnalysisView3D")], m6);
var y2 = m6;
export {
  y2 as default
};
//# sourceMappingURL=AreaMeasurementAnalysisView3D-H4SHIM5B.js.map
