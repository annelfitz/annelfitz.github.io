import {
  n as n3,
  o,
  r as r4,
  t
} from "./chunk-HXYRQKMI.js";
import {
  C,
  D,
  E as E2,
  L as L2
} from "./chunk-WKVHVZW2.js";
import {
  i as i2,
  l as l2
} from "./chunk-WEER6QME.js";
import {
  A,
  B,
  E,
  F,
  L,
  O,
  V,
  c as c2,
  d,
  g as g3,
  i as i3,
  q,
  u as u2,
  w,
  x
} from "./chunk-IRL6OOVK.js";
import {
  e as e3
} from "./chunk-LA365FE7.js";
import {
  r as r2
} from "./chunk-DVIGFJWY.js";
import {
  v
} from "./chunk-QCMUK3QA.js";
import {
  e as e2
} from "./chunk-KNMQQRV7.js";
import {
  e,
  r as r3
} from "./chunk-N5GQOIDP.js";
import {
  n as n2
} from "./chunk-SCHTG6ZQ.js";
import {
  b as b2,
  c,
  f,
  g as g2,
  i
} from "./chunk-HWHMO3CO.js";
import {
  U,
  _,
  nt,
  ot,
  tt
} from "./chunk-SAYWXQVM.js";
import {
  _ as _2
} from "./chunk-BVQWKK2V.js";
import {
  r2 as r
} from "./chunk-I2RC5KWA.js";
import {
  a,
  g,
  s as s2
} from "./chunk-JGDJR5EV.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import {
  I,
  b,
  l,
  u2 as u,
  y
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/chunks/vec4.js
function t2(t7, r8, f5) {
  if (t7.count !== r8.count)
    return void e3().error("source and destination buffers need to have the same number of elements");
  const n9 = t7.count, o7 = f5[0], u7 = f5[1], s5 = f5[2], d3 = f5[3], a3 = f5[4], i6 = f5[5], c5 = f5[6], p2 = f5[7], l7 = f5[8], m3 = f5[9], y2 = f5[10], B2 = f5[11], h = f5[12], S = f5[13], b3 = f5[14], g4 = f5[15], M = t7.typedBuffer, v2 = t7.typedBufferStride, _3 = r8.typedBuffer, j = r8.typedBufferStride;
  for (let e6 = 0; e6 < n9; e6++) {
    const t8 = e6 * v2, r9 = e6 * j, f6 = _3[r9], n10 = _3[r9 + 1], w2 = _3[r9 + 2], z2 = _3[r9 + 3];
    M[t8] = o7 * f6 + a3 * n10 + l7 * w2 + h * z2, M[t8 + 1] = u7 * f6 + i6 * n10 + m3 * w2 + S * z2, M[t8 + 2] = s5 * f6 + c5 * n10 + y2 * w2 + b3 * z2, M[t8 + 3] = d3 * f6 + p2 * n10 + B2 * w2 + g4 * z2;
  }
}
function r5(e6, t7, r8) {
  f2(e6.typedBuffer, t7.typedBuffer, r8, e6.typedBufferStride, t7.typedBufferStride);
}
function f2(t7, r8, f5, n9 = 4, o7 = n9) {
  if (t7.length / n9 != r8.length / o7)
    return void e3().error("source and destination buffers need to have the same number of elements");
  const u7 = t7.length / n9, s5 = f5[0], d3 = f5[1], a3 = f5[2], i6 = f5[3], c5 = f5[4], p2 = f5[5], l7 = f5[6], m3 = f5[7], y2 = f5[8];
  let B2 = 0, h = 0;
  for (let e6 = 0; e6 < u7; e6++) {
    const e7 = r8[B2], f6 = r8[B2 + 1], u8 = r8[B2 + 2], S = r8[B2 + 3];
    t7[h] = s5 * e7 + i6 * f6 + l7 * u8, t7[h + 1] = d3 * e7 + c5 * f6 + m3 * u8, t7[h + 2] = a3 * e7 + p2 * f6 + y2 * u8, t7[h + 3] = S, B2 += o7, h += n9;
  }
}
function n4(e6, t7) {
  const r8 = Math.min(e6.count, t7.count), f5 = e6.typedBuffer, n9 = e6.typedBufferStride, o7 = t7.typedBuffer, u7 = t7.typedBufferStride;
  for (let s5 = 0; s5 < r8; s5++) {
    const e7 = s5 * n9, t8 = s5 * u7, r9 = o7[t8], d3 = o7[t8 + 1], a3 = o7[t8 + 2], i6 = r9 * r9 + d3 * d3 + a3 * a3;
    if (i6 > 0) {
      const t9 = 1 / Math.sqrt(i6);
      f5[e7] = t9 * r9, f5[e7 + 1] = t9 * d3, f5[e7 + 2] = t9 * a3;
    }
  }
}
function o2(e6, t7, r8) {
  u3(e6.typedBuffer, t7, r8, e6.typedBufferStride);
}
function u3(e6, t7, r8, f5 = 4) {
  const n9 = Math.min(e6.length / f5, t7.count), o7 = t7.typedBuffer, u7 = t7.typedBufferStride;
  let s5 = 0, d3 = 0;
  for (let a3 = 0; a3 < n9; a3++)
    e6[d3] = r8 * o7[s5], e6[d3 + 1] = r8 * o7[s5 + 1], e6[d3 + 2] = r8 * o7[s5 + 2], e6[d3 + 3] = r8 * o7[s5 + 3], s5 += u7, d3 += f5;
}
var s3 = Object.freeze(Object.defineProperty({ __proto__: null, normalize: n4, scale: u3, scaleView: o2, transformMat3: f2, transformMat3View: r5, transformMat4: t2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec2.js
function o3(e6, t7) {
  n5(e6.typedBuffer, t7.typedBuffer, e6.typedBufferStride, t7.typedBufferStride);
}
function n5(o7, n9, l7 = 2, u7 = l7) {
  const i6 = n9.length / 2;
  let a3 = 0, d3 = 0;
  if (y(n9) || l(n9)) {
    for (let e6 = 0; e6 < i6; ++e6)
      o7[a3] = n9[d3], o7[a3 + 1] = n9[d3 + 1], a3 += l7, d3 += u7;
    return;
  }
  const c5 = I(n9);
  if (b(n9))
    for (let e6 = 0; e6 < i6; ++e6)
      o7[a3] = Math.max(n9[d3] / c5, -1), o7[a3 + 1] = Math.max(n9[d3 + 1] / c5, -1), a3 += l7, d3 += u7;
  else
    for (let e6 = 0; e6 < i6; ++e6)
      o7[a3] = n9[d3] / c5, o7[a3 + 1] = n9[d3 + 1] / c5, a3 += l7, d3 += u7;
}
function l3(e6, t7, r8, f5) {
  const o7 = e6.typedBuffer, n9 = e6.typedBufferStride, l7 = (f5 == null ? void 0 : f5.count) ?? e6.count;
  let u7 = ((f5 == null ? void 0 : f5.dstIndex) ?? 0) * n9;
  for (let i6 = 0; i6 < l7; ++i6)
    o7[u7] = t7, o7[u7 + 1] = r8, u7 += n9;
}
var u4 = Object.freeze(Object.defineProperty({ __proto__: null, fill: l3, normalizeIntegerBuffer: n5, normalizeIntegerBufferView: o3 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec43.js
function e4(e6, f5) {
  t3(e6.typedBuffer, f5, e6.typedBufferStride);
}
function t3(e6, t7, f5 = 4) {
  const o7 = t7.typedBuffer, r8 = t7.typedBufferStride, n9 = t7.count;
  let u7 = 0, c5 = 0;
  for (let d3 = 0; d3 < n9; ++d3)
    e6[u7] = o7[c5], e6[u7 + 1] = o7[c5 + 1], e6[u7 + 2] = o7[c5 + 2], e6[u7 + 3] = o7[c5 + 3], u7 += f5, c5 += r8;
}
function f3(e6, t7, f5, o7, r8, n9) {
  const u7 = e6.typedBuffer, c5 = e6.typedBufferStride, d3 = (n9 == null ? void 0 : n9.count) ?? e6.count;
  let l7 = ((n9 == null ? void 0 : n9.dstIndex) ?? 0) * c5;
  for (let p2 = 0; p2 < d3; ++p2)
    u7[l7] = t7, u7[l7 + 1] = f5, u7[l7 + 2] = o7, u7[l7 + 3] = r8, l7 += c5;
}
var o4 = Object.freeze(Object.defineProperty({ __proto__: null, copy: t3, copyView: e4, fill: f3 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/glTF/DefaultLoadingContext.js
var n6 = class {
  constructor(r8) {
    this._streamDataRequester = r8;
  }
  async loadJSON(r8, e6) {
    return this._load("json", r8, e6);
  }
  async loadBinary(r8, e6) {
    return tt(r8) ? (s2(e6), nt(r8)) : this._load("binary", r8, e6);
  }
  async loadImage(r8, e6) {
    return this._load("image", r8, e6);
  }
  async _load(a3, o7, i6) {
    if (null == this._streamDataRequester)
      return (await U(o7, { responseType: m[a3] })).data;
    const n9 = await _2(this._streamDataRequester.request(o7, a3, i6));
    if (true === n9.ok)
      return n9.value;
    throw a(n9.error), new s("", `Request for resource failed: ${n9.error}`);
  }
};
var m = { image: "image", binary: "array-buffer", json: "json", "image+type": void 0 };

// node_modules/@arcgis/core/views/3d/glTF/LoaderResult.js
function r6(e6 = {}) {
  return { color: [1, 1, 1], opacity: 1, alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false, castShadows: true, receiveShadows: true, receiveAmbientOcclustion: true, textureColor: null, textureNormal: null, textureOcclusion: null, textureEmissive: null, textureMetallicRoughness: null, colorTextureTransform: null, normalTextureTransform: null, occlusionTextureTransform: null, emissiveTextureTransform: null, metallicRoughnessTextureTransform: null, emissiveFactor: [0, 0, 0], metallicFactor: 1, roughnessFactor: 1, colorMixMode: "multiply", ...e6 };
}
function l4(r8, l7 = {}) {
  return { data: r8, parameters: { wrap: { s: D.REPEAT, t: D.REPEAT, ...l7.wrap }, noUnpackFlip: true, mipmap: false, ...l7 } };
}

// node_modules/@arcgis/core/chunks/scalar.js
function e5(e6, t7) {
  const o7 = e6.count;
  t7 || (t7 = new e6.TypedArrayConstructor(o7));
  for (let r8 = 0; r8 < o7; r8++)
    t7[r8] = e6.get(r8);
  return t7;
}
var t4 = Object.freeze(Object.defineProperty({ __proto__: null, makeDense: e5 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/glTF/internal/BinaryStreamReader.js
var t5 = class {
  constructor(t7) {
    this._data = t7, this._offset4 = 0, this._dataUint32 = new Uint32Array(this._data, 0, Math.floor(this._data.byteLength / 4));
  }
  readUint32() {
    const t7 = this._offset4;
    return this._offset4 += 1, this._dataUint32[t7];
  }
  readUint8Array(t7) {
    const s5 = 4 * this._offset4;
    return this._offset4 += t7 / 4, new Uint8Array(this._data, s5, t7);
  }
  remainingBytes() {
    return this._data.byteLength - 4 * this._offset4;
  }
};

// node_modules/@arcgis/core/views/3d/glTF/internal/enums.js
var A2;
var E3;
!function(A3) {
  A3.SCALAR = "SCALAR", A3.VEC2 = "VEC2", A3.VEC3 = "VEC3", A3.VEC4 = "VEC4", A3.MAT2 = "MAT2", A3.MAT3 = "MAT3", A3.MAT4 = "MAT4";
}(A2 || (A2 = {})), function(A3) {
  A3[A3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", A3[A3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(E3 || (E3 = {}));

// node_modules/@arcgis/core/views/3d/glTF/internal/fillDefaults.js
var t6 = { baseColorFactor: [1, 1, 1, 1], metallicFactor: 1, roughnessFactor: 1 };
var a2 = { pbrMetallicRoughness: t6, emissiveFactor: [0, 0, 0], alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false };
var l5 = { ESRI_externalColorMixMode: "tint", ESRI_receiveShadows: true, ESRI_receiveAmbientOcclusion: true };
var i4 = (e6 = {}) => {
  const o7 = { ...t6, ...e6.pbrMetallicRoughness }, r8 = s4({ ...l5, ...e6.extras });
  return { ...a2, ...e6, pbrMetallicRoughness: o7, extras: r8 };
};
function s4(o7) {
  switch (o7.ESRI_externalColorMixMode) {
    case "multiply":
    case "tint":
    case "ignore":
    case "replace":
      break;
    default:
      n2(o7.ESRI_externalColorMixMode), o7.ESRI_externalColorMixMode = "tint";
  }
  return o7;
}
var c3 = { magFilter: L2.LINEAR, minFilter: L2.LINEAR_MIPMAP_LINEAR, wrapS: D.REPEAT, wrapT: D.REPEAT };
var n7 = (e6) => ({ ...c3, ...e6 });

// node_modules/@arcgis/core/views/3d/glTF/internal/pathUtils.js
function r7(r8) {
  let e6, t7;
  return r8.replace(/^(.*\/)?([^/]*)$/, (r9, a3, i6) => (e6 = a3 || "", t7 = i6 || "", "")), { dirPart: e6, filePart: t7 };
}

// node_modules/@arcgis/core/views/3d/glTF/internal/Resource.js
var k = { MAGIC: 1179937895, CHUNK_TYPE_JSON: 1313821514, CHUNK_TYPE_BIN: 5130562, MIN_HEADER_LENGTH: 20 };
var Y = class _Y {
  constructor(t7, r8, o7, n9) {
    if (this._context = t7, this.uri = r8, this.json = o7, this._glbBuffer = n9, this._bufferLoaders = /* @__PURE__ */ new Map(), this._textureLoaders = /* @__PURE__ */ new Map(), this._textureCache = /* @__PURE__ */ new Map(), this._materialCache = /* @__PURE__ */ new Map(), this._nodeParentMap = /* @__PURE__ */ new Map(), this._nodeTransformCache = /* @__PURE__ */ new Map(), this._supportedExtensions = ["KHR_texture_basisu", "KHR_texture_transform"], this._baseUri = r7(this.uri).dirPart, this._checkVersionSupported(), this._checkRequiredExtensionsSupported(), null == o7.scenes)
      throw new s("gltf-loader-unsupported-feature", "Scenes must be defined.");
    if (null == o7.meshes)
      throw new s("gltf-loader-unsupported-feature", "Meshes must be defined");
    if (null == o7.nodes)
      throw new s("gltf-loader-unsupported-feature", "Nodes must be defined.");
    this._computeNodeParents();
  }
  static async load(t7, r8, o7) {
    if (tt(r8)) {
      const e6 = ot(r8);
      if (e6 && "model/gltf-binary" !== e6.mediaType)
        try {
          const o9 = JSON.parse(e6.isBase64 ? atob(e6.data) : e6.data);
          return new _Y(t7, r8, o9);
        } catch {
        }
      const o8 = nt(r8);
      if (_Y._isGLBData(o8))
        return this._fromGLBData(t7, r8, o8);
    }
    if (ee.test(r8) || "gltf" === (o7 == null ? void 0 : o7.expectedType)) {
      const e6 = await t7.loadJSON(r8, o7);
      return new _Y(t7, r8, e6);
    }
    const i6 = await t7.loadBinary(r8, o7);
    if (_Y._isGLBData(i6))
      return this._fromGLBData(t7, r8, i6);
    if (te.test(r8) || "glb" === (o7 == null ? void 0 : o7.expectedType))
      throw new s("gltf-loader-invalid-glb", "This is not a valid glb file.");
    const u7 = await t7.loadJSON(r8, o7);
    return new _Y(t7, r8, u7);
  }
  static _isGLBData(e6) {
    if (null == e6)
      return false;
    const t7 = new t5(e6);
    return t7.remainingBytes() >= 4 && t7.readUint32() === k.MAGIC;
  }
  static async _fromGLBData(e6, t7, r8) {
    const o7 = await _Y._parseGLBData(r8);
    return new _Y(e6, t7, o7.json, o7.binaryData);
  }
  static async _parseGLBData(r8) {
    const o7 = new t5(r8);
    if (o7.remainingBytes() < 12)
      throw new s("gltf-loader-error", "glb binary data is insufficiently large.");
    const n9 = o7.readUint32(), s5 = o7.readUint32(), a3 = o7.readUint32();
    if (n9 !== k.MAGIC)
      throw new s("gltf-loader-error", "Magic first 4 bytes do not fit to expected glb value.");
    if (r8.byteLength < a3)
      throw new s("gltf-loader-error", "glb binary data is smaller than header specifies.");
    if (2 !== s5)
      throw new s("gltf-loader-unsupported-feature", "An unsupported glb container version was detected. Only version 2 is supported.");
    let i6, u7, f5 = 0;
    for (; o7.remainingBytes() >= 8; ) {
      const r9 = o7.readUint32(), n10 = o7.readUint32();
      if (0 === f5) {
        if (n10 !== k.CHUNK_TYPE_JSON)
          throw new s("gltf-loader-error", "First glb chunk must be JSON.");
        if (r9 < 0)
          throw new s("gltf-loader-error", "No JSON data found.");
        i6 = await n3(o7.readUint8Array(r9));
      } else if (1 === f5) {
        if (n10 !== k.CHUNK_TYPE_BIN)
          throw new s("gltf-loader-unsupported-feature", "Second glb chunk expected to be BIN.");
        u7 = o7.readUint8Array(r9);
      } else
        n.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] More than 2 glb chunks detected. Skipping.");
      f5 += 1;
    }
    if (!i6)
      throw new s("gltf-loader-error", "No glb JSON chunk detected.");
    return { json: i6, binaryData: u7 };
  }
  async getBuffer(t7, r8) {
    const o7 = this.json.buffers[t7];
    if (null == o7.uri) {
      if (null == this._glbBuffer)
        throw new s("gltf-loader-error", "glb buffer not present");
      return this._glbBuffer;
    }
    const n9 = await this._getBufferLoader(t7, r8);
    if (n9.byteLength !== o7.byteLength)
      throw new s("gltf-loader-error", "Buffer byte lengths should match.");
    return n9;
  }
  async _getBufferLoader(e6, t7) {
    const r8 = this._bufferLoaders.get(e6);
    if (r8)
      return r8;
    const o7 = this.json.buffers[e6].uri, n9 = this._context.loadBinary(this._resolveUri(o7), t7).then((e7) => new Uint8Array(e7));
    return this._bufferLoaders.set(e6, n9), n9;
  }
  async getAccessor(t7, r8) {
    if (!this.json.accessors)
      throw new s("gltf-loader-unsupported-feature", "Accessors missing.");
    const o7 = this.json.accessors[t7];
    if (null == (o7 == null ? void 0 : o7.bufferView))
      throw new s("gltf-loader-unsupported-feature", "Some accessor does not specify a bufferView.");
    if (o7.type in [A2.MAT2, A2.MAT3, A2.MAT4])
      throw new s("gltf-loader-unsupported-feature", `AttributeType ${o7.type} is not supported`);
    const n9 = this.json.bufferViews[o7.bufferView], s5 = await this.getBuffer(n9.buffer, r8), a3 = X[o7.type], i6 = $[o7.componentType], u7 = a3 * i6, f5 = n9.byteStride || u7;
    return { raw: s5.buffer, byteStride: f5, byteOffset: s5.byteOffset + (n9.byteOffset || 0) + (o7.byteOffset || 0), entryCount: o7.count, isDenselyPacked: f5 === u7, componentCount: a3, componentByteSize: i6, componentType: o7.componentType, min: o7.min, max: o7.max, normalized: !!o7.normalized };
  }
  async getIndexData(e6, t7) {
    if (null == e6.indices)
      return;
    const r8 = await this.getAccessor(e6.indices, t7);
    if (r8.isDenselyPacked)
      switch (r8.componentType) {
        case C.UNSIGNED_BYTE:
          return new Uint8Array(r8.raw, r8.byteOffset, r8.entryCount);
        case C.UNSIGNED_SHORT:
          return new Uint16Array(r8.raw, r8.byteOffset, r8.entryCount);
        case C.UNSIGNED_INT:
          return new Uint32Array(r8.raw, r8.byteOffset, r8.entryCount);
      }
    else
      switch (r8.componentType) {
        case C.UNSIGNED_BYTE:
          return e5(Q(d, r8));
        case C.UNSIGNED_SHORT:
          return e5(Q(g3, r8));
        case C.UNSIGNED_INT:
          return e5(Q(B, r8));
      }
  }
  async getPositionData(t7, r8) {
    if (null == t7.attributes.POSITION)
      throw new s("gltf-loader-unsupported-feature", "No POSITION vertex data found.");
    const o7 = await this.getAccessor(t7.attributes.POSITION, r8);
    if (o7.componentType !== C.FLOAT)
      throw new s("gltf-loader-unsupported-feature", "Expected type FLOAT for POSITION vertex attribute, but found " + C[o7.componentType]);
    if (3 !== o7.componentCount)
      throw new s("gltf-loader-unsupported-feature", "POSITION vertex attribute must have 3 components, but found " + o7.componentCount.toFixed());
    return Q(i3, o7);
  }
  async getNormalData(t7, r8) {
    if (null == t7.attributes.NORMAL)
      throw new s("gltf-loader-error", "No NORMAL vertex data found.");
    const o7 = await this.getAccessor(t7.attributes.NORMAL, r8);
    if (o7.componentType !== C.FLOAT)
      throw new s("gltf-loader-unsupported-feature", "Expected type FLOAT for NORMAL vertex attribute, but found " + C[o7.componentType]);
    if (3 !== o7.componentCount)
      throw new s("gltf-loader-unsupported-feature", "NORMAL vertex attribute must have 3 components, but found " + o7.componentCount.toFixed());
    return Q(i3, o7);
  }
  async getTangentData(t7, r8) {
    if (null == t7.attributes.TANGENT)
      throw new s("gltf-loader-error", "No TANGENT vertex data found.");
    const o7 = await this.getAccessor(t7.attributes.TANGENT, r8);
    if (o7.componentType !== C.FLOAT)
      throw new s("gltf-loader-unsupported-feature", "Expected type FLOAT for TANGENT vertex attribute, but found " + C[o7.componentType]);
    if (4 !== o7.componentCount)
      throw new s("gltf-loader-unsupported-feature", "TANGENT vertex attribute must have 4 components, but found " + o7.componentCount.toFixed());
    return new c2(o7.raw, o7.byteOffset, o7.byteStride, o7.byteOffset + o7.byteStride * o7.entryCount);
  }
  async getTextureCoordinates(t7, r8) {
    if (null == t7.attributes.TEXCOORD_0)
      throw new s("gltf-loader-error", "No TEXCOORD_0 vertex data found.");
    const o7 = await this.getAccessor(t7.attributes.TEXCOORD_0, r8);
    if (2 !== o7.componentCount)
      throw new s("gltf-loader-unsupported-feature", "TEXCOORD_0 vertex attribute must have 2 components, but found " + o7.componentCount.toFixed());
    if (o7.componentType === C.FLOAT)
      return Q(u2, o7);
    if (!o7.normalized)
      throw new s("gltf-loader-unsupported-feature", "Integer component types are only supported for a normalized accessor for TEXCOORD_0.");
    return W(o7);
  }
  async getVertexColors(t7, r8) {
    if (null == t7.attributes.COLOR_0)
      throw new s("gltf-loader-error", "No COLOR_0 vertex data found.");
    const o7 = await this.getAccessor(t7.attributes.COLOR_0, r8);
    if (4 !== o7.componentCount && 3 !== o7.componentCount)
      throw new s("gltf-loader-unsupported-feature", "COLOR_0 attribute must have 3 or 4 components, but found " + o7.componentCount.toFixed());
    if (4 === o7.componentCount) {
      if (o7.componentType === C.FLOAT)
        return Q(c2, o7);
      if (o7.componentType === C.UNSIGNED_BYTE)
        return Q(x, o7);
      if (o7.componentType === C.UNSIGNED_SHORT)
        return Q(L, o7);
    } else if (3 === o7.componentCount) {
      if (o7.componentType === C.FLOAT)
        return Q(i3, o7);
      if (o7.componentType === C.UNSIGNED_BYTE)
        return Q(O, o7);
      if (o7.componentType === C.UNSIGNED_SHORT)
        return Q(E, o7);
    }
    throw new s("gltf-loader-unsupported-feature", "Unsupported component type for COLOR_0 attribute: " + C[o7.componentType]);
  }
  hasPositions(e6) {
    return void 0 !== e6.attributes.POSITION;
  }
  hasNormals(e6) {
    return void 0 !== e6.attributes.NORMAL;
  }
  hasVertexColors(e6) {
    return void 0 !== e6.attributes.COLOR_0;
  }
  hasTextureCoordinates(e6) {
    return void 0 !== e6.attributes.TEXCOORD_0;
  }
  hasTangents(e6) {
    return void 0 !== e6.attributes.TANGENT;
  }
  async getMaterial(e6, t7, r8) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    let o7 = e6.material ? this._materialCache.get(e6.material) : void 0;
    if (!o7) {
      const n9 = null != e6.material ? i4(this.json.materials[e6.material]) : i4(), s5 = n9.pbrMetallicRoughness, a3 = this.hasVertexColors(e6), i6 = this.getTexture(s5.baseColorTexture, t7), u7 = this.getTexture(n9.normalTexture, t7), f5 = r8 ? this.getTexture(n9.occlusionTexture, t7) : void 0, l7 = r8 ? this.getTexture(n9.emissiveTexture, t7) : void 0, d3 = r8 ? this.getTexture(s5.metallicRoughnessTexture, t7) : void 0, c5 = null != e6.material ? e6.material : -1;
      o7 = { alphaMode: n9.alphaMode, alphaCutoff: n9.alphaCutoff, color: s5.baseColorFactor, doubleSided: !!n9.doubleSided, colorTexture: await i6, normalTexture: await u7, name: n9.name, id: c5, occlusionTexture: await f5, emissiveTexture: await l7, emissiveFactor: n9.emissiveFactor, metallicFactor: s5.metallicFactor, roughnessFactor: s5.roughnessFactor, metallicRoughnessTexture: await d3, hasVertexColors: a3, ESRI_externalColorMixMode: n9.extras.ESRI_externalColorMixMode, colorTextureTransform: (_b = (_a = s5 == null ? void 0 : s5.baseColorTexture) == null ? void 0 : _a.extensions) == null ? void 0 : _b.KHR_texture_transform, normalTextureTransform: (_d = (_c = n9.normalTexture) == null ? void 0 : _c.extensions) == null ? void 0 : _d.KHR_texture_transform, occlusionTextureTransform: (_f = (_e = n9.occlusionTexture) == null ? void 0 : _e.extensions) == null ? void 0 : _f.KHR_texture_transform, emissiveTextureTransform: (_h = (_g = n9.emissiveTexture) == null ? void 0 : _g.extensions) == null ? void 0 : _h.KHR_texture_transform, metallicRoughnessTextureTransform: (_j = (_i = s5 == null ? void 0 : s5.metallicRoughnessTexture) == null ? void 0 : _i.extensions) == null ? void 0 : _j.KHR_texture_transform, receiveAmbientOcclusion: n9.extras.ESRI_receiveAmbientOcclusion, receiveShadows: n9.extras.ESRI_receiveShadows };
    }
    return o7;
  }
  async getTexture(t7, o7) {
    if (!t7)
      return;
    if (0 !== (t7.texCoord || 0))
      throw new s("gltf-loader-unsupported-feature", "Only TEXCOORD with index 0 is supported.");
    const n9 = t7.index, s5 = this.json.textures[n9], a3 = n7(null != s5.sampler ? this.json.samplers[s5.sampler] : {}), i6 = Z(s5), u7 = this.json.images[i6], f5 = await this._loadTextureImageData(n9, s5, o7);
    return r(this._textureCache, n9, () => {
      const t8 = (e6) => 33071 === e6 || 33648 === e6 || 10497 === e6, r8 = (t9) => {
        throw new s("gltf-loader-error", `Unexpected TextureSampler WrapMode: ${t9}`);
      };
      return { data: f5, wrapS: t8(a3.wrapS) ? a3.wrapS : r8(a3.wrapS), wrapT: t8(a3.wrapT) ? a3.wrapT : r8(a3.wrapT), minFilter: a3.minFilter, name: u7.name, id: n9 };
    });
  }
  getNodeTransform(e6) {
    if (void 0 === e6)
      return q2;
    let t7 = this._nodeTransformCache.get(e6);
    if (!t7) {
      const r8 = this.getNodeTransform(this._getNodeParent(e6)), o7 = this.json.nodes[e6];
      o7.matrix ? t7 = c(e(), r8, o7.matrix) : o7.translation || o7.rotation || o7.scale ? (t7 = r3(r8), o7.translation && i(t7, t7, o7.translation), o7.rotation && (z[3] = v(z, o7.rotation), b2(t7, t7, z[3], z)), o7.scale && f(t7, t7, o7.scale)) : t7 = r3(r8), this._nodeTransformCache.set(e6, t7);
    }
    return t7;
  }
  _resolveUri(e6) {
    return _(e6, this._baseUri);
  }
  _getNodeParent(e6) {
    return this._nodeParentMap.get(e6);
  }
  _checkVersionSupported() {
    const e6 = r2.parse(this.json.asset.version, "glTF");
    J.validate(e6);
  }
  _checkRequiredExtensionsSupported() {
    const t7 = this.json;
    if (t7.extensionsRequired) {
      if (!t7.extensionsRequired.every((e6) => this._supportedExtensions.includes(e6)))
        throw new s("gltf-loader-unsupported-feature", "gltf loader was not able to load unsupported feature. Required extensions: " + t7.extensionsRequired.join(", "));
    }
  }
  _computeNodeParents() {
    this.json.nodes.forEach((e6, t7) => {
      e6.children && e6.children.forEach((e7) => {
        this._nodeParentMap.set(e7, t7);
      });
    });
  }
  async _loadTextureImageData(e6, t7, r8) {
    const o7 = this._textureLoaders.get(e6);
    if (o7)
      return o7;
    const n9 = this._createTextureLoader(t7, r8);
    return this._textureLoaders.set(e6, n9), n9;
  }
  async _createTextureLoader(t7, r8) {
    const o7 = Z(t7), n9 = this.json.images[o7];
    if (n9.uri) {
      if (n9.uri.endsWith(".ktx2")) {
        const e6 = await this._context.loadBinary(this._resolveUri(n9.uri), r8);
        return new t(new Uint8Array(e6));
      }
      return this._context.loadImage(this._resolveUri(n9.uri), r8);
    }
    if (null == n9.bufferView)
      throw new s("gltf-loader-unsupported-feature", "Image bufferView must be defined.");
    if (null == n9.mimeType)
      throw new s("gltf-loader-unsupported-feature", "Image mimeType must be defined.");
    const s5 = this.json.bufferViews[n9.bufferView], a3 = await this.getBuffer(s5.buffer, r8);
    if (null != s5.byteStride)
      throw new s("gltf-loader-unsupported-feature", "byteStride not supported for image buffer");
    const i6 = a3.byteOffset + (s5.byteOffset || 0);
    return o(new Uint8Array(a3.buffer, i6, s5.byteLength), n9.mimeType);
  }
  async getLoadedBuffersSize() {
    if (this._glbBuffer)
      return this._glbBuffer.byteLength;
    const e6 = await g(Array.from(this._bufferLoaders.values())), t7 = await g(Array.from(this._textureLoaders.values()));
    return e6.reduce((e7, t8) => e7 + ((t8 == null ? void 0 : t8.byteLength) ?? 0), 0) + t7.reduce((e7, t8) => e7 + (t8 ? r4(t8) ? t8.data.byteLength : t8.width * t8.height * 4 : 0), 0);
  }
};
var q2 = g2(e(), Math.PI / 2);
var J = new r2(2, 0, "glTF");
var z = e2();
var X = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
var $ = { [C.BYTE]: 1, [C.UNSIGNED_BYTE]: 1, [C.SHORT]: 2, [C.UNSIGNED_SHORT]: 2, [C.FLOAT]: 4, [C.INT]: 4, [C.UNSIGNED_INT]: 4 };
function W(e6) {
  switch (e6.componentType) {
    case C.BYTE:
      return new V(e6.raw, e6.byteOffset, e6.byteStride, e6.byteOffset + e6.byteStride * e6.entryCount);
    case C.UNSIGNED_BYTE:
      return new A(e6.raw, e6.byteOffset, e6.byteStride, e6.byteOffset + e6.byteStride * e6.entryCount);
    case C.SHORT:
      return new q(e6.raw, e6.byteOffset, e6.byteStride, e6.byteOffset + e6.byteStride * e6.entryCount);
    case C.UNSIGNED_SHORT:
      return new w(e6.raw, e6.byteOffset, e6.byteStride, e6.byteOffset + e6.byteStride * e6.entryCount);
    case C.UNSIGNED_INT:
      return new F(e6.raw, e6.byteOffset, e6.byteStride, e6.byteOffset + e6.byteStride * e6.entryCount);
    case C.FLOAT:
      return new u2(e6.raw, e6.byteOffset, e6.byteStride, e6.byteOffset + e6.byteStride * e6.entryCount);
  }
}
function Q(e6, t7) {
  return new e6(t7.raw, t7.byteOffset, t7.byteStride, t7.byteOffset + t7.byteStride * (t7.entryCount - 1) + t7.componentByteSize * t7.componentCount);
}
function Z(t7) {
  if (void 0 !== t7.extensions && null !== t7.extensions.KHR_texture_basisu)
    return t7.extensions.KHR_texture_basisu.source;
  if (null !== t7.source)
    return t7.source;
  throw new s("gltf-loader-unsupported-feature", "Source is expected to be defined for a texture. It can also be omitted in favour of an KHR_texture_basisu extension tag.");
}
var ee = /\.gltf$/i;
var te = /\.glb$/i;

// node_modules/@arcgis/core/views/3d/glTF/loader.js
var n8 = 0;
async function l6(o7, r8, a3 = {}, l7 = true) {
  var _a, _b;
  const m3 = await Y.load(o7, r8, a3), p2 = "gltf_" + n8++, T = { lods: [], materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), meta: u5(m3) }, f5 = !(!m3.json.asset.extras || "symbolResource" !== m3.json.asset.extras.ESRI_type), x2 = (_b = (_a = m3.json.asset.extras) == null ? void 0 : _a.ESRI_webstyleSymbol) == null ? void 0 : _b.webstyle, g4 = /* @__PURE__ */ new Map();
  await c4(m3, async (o8, r9, s5, n9) => {
    var _a2;
    const u7 = g4.get(s5) ?? 0;
    g4.set(s5, u7 + 1);
    const c5 = void 0 !== o8.mode ? o8.mode : E2.TRIANGLES, f6 = c5 === E2.TRIANGLES || c5 === E2.TRIANGLE_STRIP || c5 === E2.TRIANGLE_FAN ? c5 : null;
    if (null == f6)
      return void n.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] Unsupported primitive mode (" + E2[c5] + "). Skipping primitive.");
    if (!m3.hasPositions(o8))
      return void n.getLogger("esri.views.3d.glTF").warn("Skipping primitive without POSITION vertex attribute.");
    const x3 = m3.getPositionData(o8, a3), h2 = m3.getMaterial(o8, a3, l7), w2 = m3.hasNormals(o8) ? m3.getNormalData(o8, a3) : null, v2 = m3.hasTangents(o8) ? m3.getTangentData(o8, a3) : null, S = m3.hasTextureCoordinates(o8) ? m3.getTextureCoordinates(o8, a3) : null, R = m3.hasVertexColors(o8) ? m3.getVertexColors(o8, a3) : null, _3 = m3.getIndexData(o8, a3), E4 = { name: n9, transform: r3(r9), attributes: { position: await x3, normal: w2 ? await w2 : null, texCoord0: S ? await S : null, color: R ? await R : null, tangent: v2 ? await v2 : null }, indices: await _3, primitiveType: f6, material: d2(T, await h2, p2) };
    let I2 = null;
    null != ((_a2 = T.meta) == null ? void 0 : _a2.ESRI_lod) && "screenSpaceRadius" === T.meta.ESRI_lod.metric && (I2 = T.meta.ESRI_lod.thresholds[s5]), T.lods[s5] = T.lods[s5] || { parts: [], name: n9, lodThreshold: I2 }, T.lods[s5].parts[u7] = E4;
  });
  for (const e6 of T.lods)
    e6.parts = e6.parts.filter((e7) => !!e7);
  const h = await m3.getLoadedBuffersSize();
  return { model: T, meta: { isEsriSymbolResource: f5, uri: m3.uri, ESRI_webstyle: x2 }, customMeta: {}, size: h };
}
function u5(e6) {
  const t7 = e6.json;
  let o7 = null;
  return t7.nodes.forEach((e7) => {
    const t8 = e7.extras;
    null != t8 && (t8.ESRI_proxyEllipsoid || t8.ESRI_lod) && (o7 = t8);
  }), o7;
}
async function c4(t7, o7) {
  const r8 = t7.json, s5 = r8.scenes[r8.scene || 0].nodes, a3 = s5.length > 1, i6 = [];
  for (const e6 of s5) {
    const t8 = r8.nodes[e6];
    if (i6.push(n9(e6, 0)), m2(t8) && !a3) {
      t8.extensions.MSFT_lod.ids.forEach((e7, t9) => n9(e7, t9 + 1));
    }
  }
  async function n9(s6, a4) {
    const l7 = r8.nodes[s6], u7 = t7.getNodeTransform(s6);
    if (null != l7.weights && n.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] Morph targets are not supported."), null != l7.mesh) {
      const e6 = r8.meshes[l7.mesh];
      for (const t8 of e6.primitives)
        i6.push(o7(t8, u7, a4, e6.name));
    }
    for (const e6 of l7.children || [])
      i6.push(n9(e6, a4));
  }
  await Promise.all(i6);
}
function m2(e6) {
  var _a;
  return ((_a = e6.extensions) == null ? void 0 : _a.MSFT_lod) && Array.isArray(e6.extensions.MSFT_lod.ids);
}
function d2(e6, t7, s5) {
  const a3 = (t8) => {
    const o7 = `${s5}_tex_${t8 && t8.id}${(t8 == null ? void 0 : t8.name) ? "_" + t8.name : ""}`;
    if (t8 && !e6.textures.has(o7)) {
      const s6 = l4(t8.data, { wrap: { s: t8.wrapS, t: t8.wrapT }, mipmap: p.has(t8.minFilter), noUnpackFlip: true });
      e6.textures.set(o7, s6);
    }
    return o7;
  }, i6 = `${s5}_mat_${t7.id}_${t7.name}`;
  if (!e6.materials.has(i6)) {
    const r8 = r6({ color: [t7.color[0], t7.color[1], t7.color[2]], opacity: t7.color[3], alphaMode: t7.alphaMode, alphaCutoff: t7.alphaCutoff, doubleSided: t7.doubleSided, colorMixMode: t7.ESRI_externalColorMixMode, textureColor: t7.colorTexture ? a3(t7.colorTexture) : void 0, textureNormal: t7.normalTexture ? a3(t7.normalTexture) : void 0, textureOcclusion: t7.occlusionTexture ? a3(t7.occlusionTexture) : void 0, textureEmissive: t7.emissiveTexture ? a3(t7.emissiveTexture) : void 0, textureMetallicRoughness: t7.metallicRoughnessTexture ? a3(t7.metallicRoughnessTexture) : void 0, emissiveFactor: [t7.emissiveFactor[0], t7.emissiveFactor[1], t7.emissiveFactor[2]], colorTextureTransform: t7.colorTextureTransform, normalTextureTransform: t7.normalTextureTransform, occlusionTextureTransform: t7.occlusionTextureTransform, emissiveTextureTransform: t7.emissiveTextureTransform, metallicRoughnessTextureTransform: t7.metallicRoughnessTextureTransform, metallicFactor: t7.metallicFactor, roughnessFactor: t7.roughnessFactor, receiveShadows: t7.receiveShadows, receiveAmbientOcclustion: t7.receiveAmbientOcclusion });
    e6.materials.set(i6, r8);
  }
  return i6;
}
var p = /* @__PURE__ */ new Set([L2.LINEAR_MIPMAP_LINEAR, L2.LINEAR_MIPMAP_NEAREST]);

// node_modules/@arcgis/core/views/3d/glTF/internal/indexUtils.js
function o5(r8, t7) {
  switch (t7) {
    case E2.TRIANGLES:
      return f4(r8);
    case E2.TRIANGLE_STRIP:
      return u6(r8);
    case E2.TRIANGLE_FAN:
      return i5(r8);
  }
}
function f4(e6) {
  return "number" == typeof e6 ? l2(e6) : u(e6) ? new Uint16Array(e6) : e6;
}
function u6(r8) {
  const t7 = "number" == typeof r8 ? r8 : r8.length;
  if (t7 < 3)
    return [];
  const n9 = t7 - 2, o7 = i2(3 * n9);
  if ("number" == typeof r8) {
    let r9 = 0;
    for (let t8 = 0; t8 < n9; t8 += 1)
      t8 % 2 == 0 ? (o7[r9++] = t8, o7[r9++] = t8 + 1, o7[r9++] = t8 + 2) : (o7[r9++] = t8 + 1, o7[r9++] = t8, o7[r9++] = t8 + 2);
  } else {
    let t8 = 0;
    for (let e6 = 0; e6 < n9; e6 += 1)
      e6 % 2 == 0 ? (o7[t8++] = r8[e6], o7[t8++] = r8[e6 + 1], o7[t8++] = r8[e6 + 2]) : (o7[t8++] = r8[e6 + 1], o7[t8++] = r8[e6], o7[t8++] = r8[e6 + 2]);
  }
  return o7;
}
function i5(r8) {
  const t7 = "number" == typeof r8 ? r8 : r8.length;
  if (t7 < 3)
    return new Uint16Array(0);
  const e6 = t7 - 2, n9 = e6 <= 65536 ? new Uint16Array(3 * e6) : new Uint32Array(3 * e6);
  if ("number" == typeof r8) {
    let r9 = 0;
    for (let t8 = 0; t8 < e6; ++t8)
      n9[r9++] = 0, n9[r9++] = t8 + 1, n9[r9++] = t8 + 2;
    return n9;
  }
  const o7 = r8[0];
  let f5 = r8[1], u7 = 0;
  for (let i6 = 0; i6 < e6; ++i6) {
    const t8 = r8[i6 + 2];
    n9[u7++] = o7, n9[u7++] = f5, n9[u7++] = t8, f5 = t8;
  }
  return n9;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultMaterial_COLOR_GAMMA.js
var o6 = 2.1;

export {
  r5 as r,
  f2 as f,
  n4 as n,
  o2 as o,
  u3 as u,
  o3 as o2,
  n5 as n2,
  l3 as l,
  e4 as e,
  t3 as t,
  f3 as f2,
  n6 as n3,
  l6 as l2,
  o5 as o3,
  o6 as o4
};
//# sourceMappingURL=chunk-VVAVEXL2.js.map
