import {
  e as e2,
  h,
  i
} from "./chunk-JQRZ6RJ7.js";
import {
  o as o2
} from "./chunk-YUUTEPX2.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  d
} from "./chunk-BVQWKK2V.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  L,
  o3 as o,
  s as s2
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/widgets/Editor/Upload.js
var h2 = class extends S {
  constructor() {
    super({}), this.files = [], this.progress = 0, this._uploadTask = null, this._layer = null;
  }
  destroy() {
    this.cancel(), this.files = [], this._layer = null, this._uploadTask = null;
  }
  get state() {
    const e3 = this._uploadTask;
    return e3 && 0 !== this.files.length ? e3.finished ? e3.error ? "error" : "success" : "pending" : "default";
  }
  get result() {
    var _a;
    return ((_a = this._uploadTask) == null ? void 0 : _a.value) ?? null;
  }
  get error() {
    var _a;
    return ((_a = this._uploadTask) == null ? void 0 : _a.error) ?? null;
  }
  uploadTo(e3) {
    this.cancel(), this.files = [], this._layer = e3, this._uploadTask = d(async (r) => {
      const o3 = await y2(e3);
      s2(r), this.progress = 0, this.files = o3;
      const t = i(e2.upload, (e4) => {
        this.progress = e4;
      }, "Upload.uploadTo");
      if (0 === o3.length)
        return null;
      s2(r);
      const l = await e3.extractAndFilterFiles(o3);
      s2(r), l.length > 0 && (this.files = l);
      const a2 = new x({ x: 0, y: 0, z: 0, spatialReference: e3.spatialReference }), n = await e3.convertMesh(l, { location: a2, signal: r, onProgress: t.makeOnProgress("createFromFiles") });
      if (s2(r), !n)
        throw new s("editor:upload", "could not upload or convert model");
      const u = l.reduce((e4, r2) => e4 + r2.size, 0), h3 = t.simulate("loadMesh", h(u));
      try {
        await n.load();
      } finally {
        h3.remove();
      }
      return n;
    });
  }
  retry() {
    this._layer && this.uploadTo(this._layer);
  }
  cancel() {
    var _a;
    (_a = this._uploadTask) == null ? void 0 : _a.abort();
  }
};
e([y()], h2.prototype, "files", void 0), e([y()], h2.prototype, "progress", void 0), e([y()], h2.prototype, "state", null), e([y()], h2.prototype, "result", null), e([y()], h2.prototype, "error", null), e([y()], h2.prototype, "_uploadTask", void 0), e([y()], h2.prototype, "_layer", void 0), h2 = e([a("esri.widgets.Editor.Upload")], h2);
var f = null;
async function y2(e3) {
  const { resolve: r, promise: o3 } = L(), s3 = document.createElement("input");
  s3.type = "file", s3.multiple = false, s3.accept = [...o2(e3.infoFor3D), ".zip"].join(","), s3.style.display = "none", document.body.appendChild(s3);
  const i2 = o(s3, "change", () => r(s3.files ? Array.from(s3.files) : []));
  return f ? f(s3) : s3.click(), o3.finally(() => {
    i2.remove(), s3.remove();
  });
}
function g(e3) {
  f = (r) => {
    Promise.resolve().then(() => e3).then((e4) => {
      if (!f)
        return;
      const o3 = new DataTransfer();
      e4.forEach((e5) => o3.items.add(e5)), r.files = o3.files, r.dispatchEvent(new Event("change"));
    });
  };
}
function j() {
  f = null;
}
export {
  h2 as Upload,
  j as clearPromptForFilesStub,
  g as stubFilePickerToSelect
};
//# sourceMappingURL=Upload-JCZBEMWS.js.map
