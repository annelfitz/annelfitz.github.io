import {
  h,
  r
} from "./chunk-LGMX4E7L.js";
import {
  A,
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/views/3d/support/MemoryManagedView.js
function e2(e3) {
  return "usedMemory" in e3 && "unloadedMemory" in e3 && "ignoresMemoryFactor" in e3;
}

// node_modules/@arcgis/core/views/3d/support/MemoryController.js
function l(e3) {
  return new p({ view: e3 });
}
var d = 0.1;
var u = 1;
var m = 1;
var n2 = 0.75;
var c = 0.6;
var _ = 1.3;
var p = class extends S {
  constructor(e3) {
    super(e3), this._quality = 1, this._usedMemory = 0, this._updating = false, this._stableQuality = 0, this._downscaleMemoryUsed = 0, this._canFastRecover = false, this._memoryPredicted = 0, this._cacheStorage = new h(), this._warnMemoryUsage = null, this._numQualityChanges = 0, this._maxMemory = 750, this._additionalCacheMemory = 0, this.addHandles(A({ prepare: () => this._updateMemory() }));
  }
  destroy() {
    this._cacheStorage.destroy();
  }
  get maxMemory() {
    return this._maxMemory;
  }
  set maxMemory(e3) {
    null == e3 || e3 <= 0 || (this._stableQuality = 0, this._canFastRecover = false, this._maxMemory < e3 && this._updateQuality(u), this._maxMemory = e3);
  }
  get additionalCacheMemory() {
    return this._additionalCacheMemory;
  }
  set additionalCacheMemory(e3) {
    null != e3 && (this._additionalCacheMemory = e3);
  }
  get memoryFactor() {
    return this._quality;
  }
  get updating() {
    return this._updating;
  }
  get usedMemory() {
    return this._usedMemory;
  }
  get usedCacheMemory() {
    return this._cacheStorage.size;
  }
  newCache(e3, t) {
    return new r(e3, this._cacheStorage, t);
  }
  resetStableQuality() {
    this._stableQuality = 0;
  }
  disableMemCache() {
    this.additionalCacheMemory = -4096;
  }
  update() {
    if (this._memoryPredicted <= 0 && !this._updating)
      return;
    let e3 = this._layersUpdating();
    if (this._memoryPredicted < c && this._canFastRecover)
      this._downscaleMemoryUsed = 0, this._stableQuality = 0, this._canFastRecover = false, this._updateQuality(u);
    else if (e3)
      (this._memoryPredicted > 1.1 * m || this._usedMemory > m) && (this._stableQuality > 0 ? (this._downscaleMemoryUsed = 0, this._updateQuality(this._stableQuality)) : this._quality > d && this._downscaleMemoryUsed < this._usedMemory && (this._updateQuality(this._quality / _), this._downscaleMemoryUsed = this._usedMemory, this._canFastRecover = false));
    else if (this._downscaleMemoryUsed = 0, this._usedMemory > m)
      this._stableQuality = 0, this._canFastRecover = false, e3 = this._updateQuality(this._quality / _), this._downscaleMemoryUsed = this._memoryPredicted;
    else if (this._stableQuality !== this._quality)
      if (this._usedMemory < n2 && this._quality < u) {
        this._stableQuality = this._quality;
        const t = 0.05;
        e3 = this._updateQuality(this._quality + t);
      } else
        this._quality < 1 && (this._canFastRecover = true);
    this._updating = e3;
  }
  _updateQuality(e3) {
    return (e3 = Math.min(Math.max(e3, d), u)) !== this._quality && (this._quality = e3, ++this._numQualityChanges, true);
  }
  _layersUpdating() {
    return this.view.allLayerViews.some((e3) => !!e3.updating);
  }
  _updateMemory() {
    var _a, _b, _c, _d, _e;
    if (!this.view)
      return;
    (_b = (_a = this.view._stage) == null ? void 0 : _a.renderer) == null ? void 0 : _b.tick();
    const e3 = (_d = (_c = this.view._stage) == null ? void 0 : _c.renderer) == null ? void 0 : _d.usedMemory;
    let t = (((_e = this.view.basemapTerrain) == null ? void 0 : _e.usedMemory) ?? 0) + (e3 ? e3.fbos + e3.edges + e3.plugins : 0), s = 0;
    this.view.allLayerViews && this.view.allLayerViews.forEach((e4) => {
      if (e2(e4)) {
        const i = e4.ignoresMemoryFactor ? this._quality : 1;
        t += e4.usedMemory * i, s += e4.unloadedMemory * i;
      }
    });
    const a2 = null == this._warnMemoryUsage || Math.round(10 * t) !== Math.round(10 * this._warnMemoryUsage), r2 = 1048576 * this.maxMemory;
    if (t > r2 && a2) {
      this._warnMemoryUsage = t;
      const e4 = (e5) => (e5 / 1048576).toLocaleString(void 0, { maximumFractionDigits: 1 }) + " MB", a3 = Math.round(100 * this._quality);
      n.getLogger(this).warn(`Memory Limit exceeded! Limit: ${e4(r2)} Current: ${e4(t)} Projected: ${e4(t + s)} Quality: ${a3}%`);
    }
    this._usedMemory = t / r2, this._memoryPredicted = (t + s) / r2;
    const o = r2 - t;
    this._cacheStorage.maxSize = Math.max(0, o + 1048576 * this.additionalCacheMemory);
  }
  get test() {
    const e3 = this;
    return { cacheStorage: this._cacheStorage, resetQualityChanges: () => {
      const t = e3._numQualityChanges;
      return e3._numQualityChanges = 0, t;
    }, disableMemCache: () => e3.disableMemCache() };
  }
};
e([y({ constructOnly: true })], p.prototype, "view", void 0), e([y()], p.prototype, "maxMemory", null), e([y()], p.prototype, "additionalCacheMemory", null), e([y({ readOnly: true })], p.prototype, "memoryFactor", null), e([y({ readOnly: true })], p.prototype, "updating", null), e([y({ readOnly: true })], p.prototype, "usedMemory", null), e([y({ readOnly: true })], p.prototype, "usedCacheMemory", null), e([y()], p.prototype, "_quality", void 0), e([y()], p.prototype, "_usedMemory", void 0), e([y()], p.prototype, "_updating", void 0), e([y()], p.prototype, "_stableQuality", void 0), e([y()], p.prototype, "_maxMemory", void 0), e([y()], p.prototype, "_additionalCacheMemory", void 0), p = e([a("esri.views.3d.support.MemoryController")], p);

export {
  l,
  d
};
//# sourceMappingURL=chunk-O7GHSWFW.js.map
