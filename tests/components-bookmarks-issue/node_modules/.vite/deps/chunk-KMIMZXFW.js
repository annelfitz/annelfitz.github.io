import {
  __glob
} from "./chunk-Z4ZPL3B3.js";

// import("./**/*.entry.js") in node_modules/@arcgis/map-components/dist/esm/index-2198b48c.js
var globImport_entry_js = __glob({
  "./arcgis-area-measurement-2d.entry.js": () => import("./arcgis-area-measurement-2d.entry-IHZPCWJR.js"),
  "./arcgis-area-measurement-3d.entry.js": () => import("./arcgis-area-measurement-3d.entry-WMAPK244.js"),
  "./arcgis-attachments.entry.js": () => import("./arcgis-attachments.entry-YOE27EL3.js"),
  "./arcgis-basemap-gallery_2.entry.js": () => import("./arcgis-basemap-gallery_2.entry-5D5CETFH.js"),
  "./arcgis-basemap-layer-list.entry.js": () => import("./arcgis-basemap-layer-list.entry-PTVCA42M.js"),
  "./arcgis-basemap-toggle.entry.js": () => import("./arcgis-basemap-toggle.entry-TUGMGFXM.js"),
  "./arcgis-bookmarks.entry.js": () => import("./arcgis-bookmarks.entry-LNAU7WFG.js"),
  "./arcgis-building-explorer.entry.js": () => import("./arcgis-building-explorer.entry-CHJ2NWED.js"),
  "./arcgis-compass.entry.js": () => import("./arcgis-compass.entry-ZW33K5TK.js"),
  "./arcgis-coordinate-conversion.entry.js": () => import("./arcgis-coordinate-conversion.entry-PLLBOOYT.js"),
  "./arcgis-daylight.entry.js": () => import("./arcgis-daylight.entry-BDJQUCV3.js"),
  "./arcgis-directional-pad.entry.js": () => import("./arcgis-directional-pad.entry-SGIVQC3K.js"),
  "./arcgis-directions.entry.js": () => import("./arcgis-directions.entry-L5GWQI5P.js"),
  "./arcgis-directline-measurement-3d.entry.js": () => import("./arcgis-directline-measurement-3d.entry-5UXXEQ5C.js"),
  "./arcgis-distance-measurement-2d.entry.js": () => import("./arcgis-distance-measurement-2d.entry-55APJJI6.js"),
  "./arcgis-editor.entry.js": () => import("./arcgis-editor.entry-F5GJRR22.js"),
  "./arcgis-elevation-profile.entry.js": () => import("./arcgis-elevation-profile.entry-NWYCWDHI.js"),
  "./arcgis-expand.entry.js": () => import("./arcgis-expand.entry-KXFPJBET.js"),
  "./arcgis-feature-form.entry.js": () => import("./arcgis-feature-form.entry-TMMNO7BU.js"),
  "./arcgis-feature-table.entry.js": () => import("./arcgis-feature-table.entry-5PXVCY2T.js"),
  "./arcgis-feature-templates.entry.js": () => import("./arcgis-feature-templates.entry-XGXQVCNR.js"),
  "./arcgis-feature.entry.js": () => import("./arcgis-feature.entry-F233GV2X.js"),
  "./arcgis-features.entry.js": () => import("./arcgis-features.entry-TKEQ2A4I.js"),
  "./arcgis-floor-filter.entry.js": () => import("./arcgis-floor-filter.entry-BF2VFQCC.js"),
  "./arcgis-fullscreen.entry.js": () => import("./arcgis-fullscreen.entry-SRVT5MMW.js"),
  "./arcgis-histogram-range-slider.entry.js": () => import("./arcgis-histogram-range-slider.entry-SWY3VUYQ.js"),
  "./arcgis-histogram.entry.js": () => import("./arcgis-histogram.entry-MXT636CX.js"),
  "./arcgis-home.entry.js": () => import("./arcgis-home.entry-KZF2O3WS.js"),
  "./arcgis-layer-list.entry.js": () => import("./arcgis-layer-list.entry-LBU5HGU4.js"),
  "./arcgis-legend.entry.js": () => import("./arcgis-legend.entry-BF7NCTVX.js"),
  "./arcgis-line-of-sight.entry.js": () => import("./arcgis-line-of-sight.entry-ANWZETNE.js"),
  "./arcgis-locate.entry.js": () => import("./arcgis-locate.entry-XFASFRKH.js"),
  "./arcgis-measurement.entry.js": () => import("./arcgis-measurement.entry-O73N623O.js"),
  "./arcgis-navigation-toggle.entry.js": () => import("./arcgis-navigation-toggle.entry-UU7OZKBI.js"),
  "./arcgis-placement.entry.js": () => import("./arcgis-placement.entry-5CKX5BZV.js"),
  "./arcgis-print.entry.js": () => import("./arcgis-print.entry-7OA3FF3C.js"),
  "./arcgis-scale-bar.entry.js": () => import("./arcgis-scale-bar.entry-VQ5NZTLO.js"),
  "./arcgis-scale-range-slider.entry.js": () => import("./arcgis-scale-range-slider.entry-XRQDE3MY.js"),
  "./arcgis-scene.entry.js": () => import("./arcgis-scene.entry-PX42CJPQ.js"),
  "./arcgis-search.entry.js": () => import("./arcgis-search.entry-DP4XBGIM.js"),
  "./arcgis-shadow-cast.entry.js": () => import("./arcgis-shadow-cast.entry-VWVHDWVV.js"),
  "./arcgis-sketch.entry.js": () => import("./arcgis-sketch.entry-MOBT2HZP.js"),
  "./arcgis-slice.entry.js": () => import("./arcgis-slice.entry-QNRUW7V3.js"),
  "./arcgis-slider.entry.js": () => import("./arcgis-slider.entry-U2LSGNU6.js"),
  "./arcgis-swipe.entry.js": () => import("./arcgis-swipe.entry-YCNJFCNY.js"),
  "./arcgis-table-list.entry.js": () => import("./arcgis-table-list.entry-A6N4RUPA.js"),
  "./arcgis-time-slider.entry.js": () => import("./arcgis-time-slider.entry-SLRAK6IO.js"),
  "./arcgis-track.entry.js": () => import("./arcgis-track.entry-UJT3D6BB.js"),
  "./arcgis-utility-network-associations.entry.js": () => import("./arcgis-utility-network-associations.entry-JUUX2GJZ.js"),
  "./arcgis-utility-network-trace.entry.js": () => import("./arcgis-utility-network-trace.entry-NUIWJQFS.js"),
  "./arcgis-utility-network-validate-topology.entry.js": () => import("./arcgis-utility-network-validate-topology.entry-4WAM5GMX.js"),
  "./arcgis-value-picker.entry.js": () => import("./arcgis-value-picker.entry-4U5P4WOM.js"),
  "./arcgis-version-management-service-item_2.entry.js": () => import("./arcgis-version-management-service-item_2.entry-GJOW6C25.js"),
  "./arcgis-version-management-version-item_2.entry.js": () => import("./arcgis-version-management-version-item_2.entry-JVUJVQMQ.js"),
  "./arcgis-version-management.entry.js": () => import("./arcgis-version-management.entry-2OHPY4U6.js"),
  "./arcgis-weather.entry.js": () => import("./arcgis-weather.entry-36ITHFB3.js"),
  "./arcgis-zoom.entry.js": () => import("./arcgis-zoom.entry-XZ2FQRO4.js")
});

// node_modules/@arcgis/map-components/dist/esm/index-2198b48c.js
var NAMESPACE = "arcgis-map-components";
var BUILD = (
  /* arcgis-map-components */
  { allRenderFn: true, appendChildSlotFix: false, asyncLoading: true, asyncQueue: false, attachStyles: true, cloneNodeFix: false, cmpDidLoad: true, cmpDidRender: true, cmpDidUnload: false, cmpDidUpdate: false, cmpShouldUpdate: false, cmpWillLoad: true, cmpWillRender: false, cmpWillUpdate: false, connectedCallback: false, constructableCSS: true, cssAnnotations: true, devTools: false, disconnectedCallback: true, element: false, event: true, experimentalSlotFixes: false, formAssociated: false, hasRenderFn: true, hostListener: false, hostListenerTarget: false, hostListenerTargetBody: false, hostListenerTargetDocument: false, hostListenerTargetParent: false, hostListenerTargetWindow: false, hotModuleReplacement: false, hydrateClientSide: false, hydrateServerSide: false, hydratedAttribute: true, hydratedClass: false, initializeNextTick: false, invisiblePrehydration: true, isDebug: false, isDev: false, isTesting: false, lazyLoad: true, lifecycle: true, lifecycleDOMEvents: false, member: true, method: true, mode: false, observeAttribute: true, profile: false, prop: true, propBoolean: true, propMutable: true, propNumber: true, propString: true, reflect: true, scoped: false, scopedSlotTextContentFix: false, scriptDataOpts: false, shadowDelegatesFocus: false, shadowDom: true, slot: true, slotChildNodesFix: false, slotRelocation: true, state: true, style: true, svg: false, taskQueue: true, transformTagName: false, updatable: true, vdomAttribute: true, vdomClass: true, vdomFunctional: false, vdomKey: false, vdomListener: true, vdomPropOrAttr: true, vdomRef: true, vdomRender: true, vdomStyle: false, vdomText: true, vdomXlink: false, watchCallback: true }
);
var scopeId;
var contentRef;
var hostTagName;
var useNativeShadowDom = false;
var checkSlotFallbackVisibility = false;
var checkSlotRelocate = false;
var isSvgMode = false;
var queuePending = false;
var getAssetPath = (path) => {
  const assetUrl = new URL(path, plt.$resourcesUrl$);
  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
};
var createTime = (fnName, tagName = "") => {
  {
    return () => {
      return;
    };
  }
};
var uniqueTime = (key, measureText) => {
  {
    return () => {
      return;
    };
  }
};
var HYDRATED_CSS = "{visibility:hidden}[hydrated]{visibility:inherit}";
var SLOT_FB_CSS = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
var EMPTY_OBJ = {};
var isDef = (v) => v != null;
var isComplexType = (o) => {
  o = typeof o;
  return o === "object" || o === "function";
};
function queryNonceMetaTagContent(doc2) {
  var _a, _b, _c;
  return (_c = (_b = (_a = doc2.head) === null || _a === void 0 ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) === null || _b === void 0 ? void 0 : _b.getAttribute("content")) !== null && _c !== void 0 ? _c : void 0;
}
var h = (nodeName, vnodeData, ...children) => {
  let child = null;
  let slotName = null;
  let simple = false;
  let lastSimple = false;
  const vNodeChildren = [];
  const walk = (c) => {
    for (let i = 0; i < c.length; i++) {
      child = c[i];
      if (Array.isArray(child)) {
        walk(child);
      } else if (child != null && typeof child !== "boolean") {
        if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
          child = String(child);
        }
        if (simple && lastSimple) {
          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
        } else {
          vNodeChildren.push(simple ? newVNode(null, child) : child);
        }
        lastSimple = simple;
      }
    }
  };
  walk(children);
  if (vnodeData) {
    if (vnodeData.name) {
      slotName = vnodeData.name;
    }
    {
      const classData = vnodeData.className || vnodeData.class;
      if (classData) {
        vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k) => classData[k]).join(" ");
      }
    }
  }
  const vnode = newVNode(nodeName, null);
  vnode.$attrs$ = vnodeData;
  if (vNodeChildren.length > 0) {
    vnode.$children$ = vNodeChildren;
  }
  {
    vnode.$name$ = slotName;
  }
  return vnode;
};
var newVNode = (tag, text) => {
  const vnode = {
    $flags$: 0,
    $tag$: tag,
    $text$: text,
    $elm$: null,
    $children$: null
  };
  {
    vnode.$attrs$ = null;
  }
  {
    vnode.$name$ = null;
  }
  return vnode;
};
var Host = {};
var isHost = (node) => node && node.$tag$ === Host;
var parsePropertyValue = (propValue, propType) => {
  if (propValue != null && !isComplexType(propValue)) {
    if (propType & 4) {
      return propValue === "false" ? false : propValue === "" || !!propValue;
    }
    if (propType & 2) {
      return parseFloat(propValue);
    }
    if (propType & 1) {
      return String(propValue);
    }
    return propValue;
  }
  return propValue;
};
var getElement = (ref) => getHostRef(ref).$hostElement$;
var createEvent = (ref, name, flags) => {
  const elm = getElement(ref);
  return {
    emit: (detail) => {
      return emitEvent(elm, name, {
        bubbles: !!(flags & 4),
        composed: !!(flags & 2),
        cancelable: !!(flags & 1),
        detail
      });
    }
  };
};
var emitEvent = (elm, name, opts) => {
  const ev = plt.ce(name, opts);
  elm.dispatchEvent(ev);
  return ev;
};
var rootAppliedStyles = /* @__PURE__ */ new WeakMap();
var registerStyle = (scopeId2, cssText, allowCS) => {
  let style = styles.get(scopeId2);
  if (supportsConstructableStylesheets && allowCS) {
    style = style || new CSSStyleSheet();
    if (typeof style === "string") {
      style = cssText;
    } else {
      style.replaceSync(cssText);
    }
  } else {
    style = cssText;
  }
  styles.set(scopeId2, style);
};
var addStyle = (styleContainerNode, cmpMeta, mode) => {
  var _a;
  const scopeId2 = getScopeId(cmpMeta);
  const style = styles.get(scopeId2);
  styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc;
  if (style) {
    if (typeof style === "string") {
      styleContainerNode = styleContainerNode.head || styleContainerNode;
      let appliedStyles = rootAppliedStyles.get(styleContainerNode);
      let styleElm;
      if (!appliedStyles) {
        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
      }
      if (!appliedStyles.has(scopeId2)) {
        {
          styleElm = doc.createElement("style");
          styleElm.innerHTML = style;
          const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
          if (nonce != null) {
            styleElm.setAttribute("nonce", nonce);
          }
          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
        }
        if (cmpMeta.$flags$ & 4) {
          styleElm.innerHTML += SLOT_FB_CSS;
        }
        if (appliedStyles) {
          appliedStyles.add(scopeId2);
        }
      }
    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
    }
  }
  return scopeId2;
};
var attachStyles = (hostRef) => {
  const cmpMeta = hostRef.$cmpMeta$;
  const elm = hostRef.$hostElement$;
  const flags = cmpMeta.$flags$;
  const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
  const scopeId2 = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta);
  if (flags & 10) {
    elm["s-sc"] = scopeId2;
    elm.classList.add(scopeId2 + "-h");
  }
  endAttachStyles();
};
var getScopeId = (cmp, mode) => "sc-" + cmp.$tagName$;
var setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
  if (oldValue !== newValue) {
    let isProp = isMemberInElement(elm, memberName);
    let ln = memberName.toLowerCase();
    if (memberName === "class") {
      const classList = elm.classList;
      const oldClasses = parseClassList(oldValue);
      const newClasses = parseClassList(newValue);
      classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
      classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
    } else if (memberName === "ref") {
      if (newValue) {
        newValue(elm);
      }
    } else if (!isProp && memberName[0] === "o" && memberName[1] === "n") {
      if (memberName[2] === "-") {
        memberName = memberName.slice(3);
      } else if (isMemberInElement(win, ln)) {
        memberName = ln.slice(2);
      } else {
        memberName = ln[2] + memberName.slice(3);
      }
      if (oldValue || newValue) {
        const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);
        memberName = memberName.replace(CAPTURE_EVENT_REGEX, "");
        if (oldValue) {
          plt.rel(elm, memberName, oldValue, capture);
        }
        if (newValue) {
          plt.ael(elm, memberName, newValue, capture);
        }
      }
    } else {
      const isComplex = isComplexType(newValue);
      if ((isProp || isComplex && newValue !== null) && !isSvg) {
        try {
          if (!elm.tagName.includes("-")) {
            const n = newValue == null ? "" : newValue;
            if (memberName === "list") {
              isProp = false;
            } else if (oldValue == null || elm[memberName] != n) {
              elm[memberName] = n;
            }
          } else {
            elm[memberName] = newValue;
          }
        } catch (e) {
        }
      }
      if (newValue == null || newValue === false) {
        if (newValue !== false || elm.getAttribute(memberName) === "") {
          {
            elm.removeAttribute(memberName);
          }
        }
      } else if ((!isProp || flags & 4 || isSvg) && !isComplex) {
        newValue = newValue === true ? "" : newValue;
        {
          elm.setAttribute(memberName, newValue);
        }
      }
    }
  }
};
var parseClassListRegex = /\s/;
var parseClassList = (value) => !value ? [] : value.split(parseClassListRegex);
var CAPTURE_EVENT_SUFFIX = "Capture";
var CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + "$");
var updateElement = (oldVnode, newVnode, isSvgMode2, memberName) => {
  const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
  {
    for (memberName in oldVnodeAttrs) {
      if (!(memberName in newVnodeAttrs)) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
      }
    }
  }
  for (memberName in newVnodeAttrs) {
    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
  }
};
var createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
  var _a;
  const newVNode2 = newParentVNode.$children$[childIndex];
  let i = 0;
  let elm;
  let childNode;
  let oldVNode;
  if (!useNativeShadowDom) {
    checkSlotRelocate = true;
    if (newVNode2.$tag$ === "slot") {
      if (scopeId) {
        parentElm.classList.add(scopeId + "-s");
      }
      newVNode2.$flags$ |= newVNode2.$children$ ? (
        // slot element has fallback content
        2
      ) : (
        // slot element does not have fallback content
        1
      );
    }
  }
  if (newVNode2.$text$ !== null) {
    elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);
  } else if (newVNode2.$flags$ & 1) {
    elm = newVNode2.$elm$ = doc.createTextNode("");
  } else {
    elm = newVNode2.$elm$ = doc.createElement(newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$);
    {
      updateElement(null, newVNode2, isSvgMode);
    }
    if (isDef(scopeId) && elm["s-si"] !== scopeId) {
      elm.classList.add(elm["s-si"] = scopeId);
    }
    if (newVNode2.$children$) {
      for (i = 0; i < newVNode2.$children$.length; ++i) {
        childNode = createElm(oldParentVNode, newVNode2, i, elm);
        if (childNode) {
          elm.appendChild(childNode);
        }
      }
    }
  }
  elm["s-hn"] = hostTagName;
  {
    if (newVNode2.$flags$ & (2 | 1)) {
      elm["s-sr"] = true;
      elm["s-fs"] = (_a = newVNode2.$attrs$) === null || _a === void 0 ? void 0 : _a.slot;
      elm["s-cr"] = contentRef;
      elm["s-sn"] = newVNode2.$name$ || "";
      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
        {
          putBackInOriginalLocation(oldParentVNode.$elm$, false);
        }
      }
    }
  }
  return elm;
};
var putBackInOriginalLocation = (parentElm, recursive) => {
  var _a;
  plt.$flags$ |= 1;
  const oldSlotChildNodes = parentElm.childNodes;
  for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {
    const childNode = oldSlotChildNodes[i];
    if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
      parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
      childNode["s-ol"].remove();
      childNode["s-ol"] = void 0;
      childNode["s-sh"] = void 0;
      if (childNode.nodeType === 1) {
        childNode.setAttribute("slot", (_a = childNode["s-sn"]) !== null && _a !== void 0 ? _a : "");
      }
      checkSlotRelocate = true;
    }
    if (recursive) {
      putBackInOriginalLocation(childNode, recursive);
    }
  }
  plt.$flags$ &= ~1;
};
var addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
  let containerElm = parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
  let childNode;
  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
    containerElm = containerElm.shadowRoot;
  }
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnodes[startIdx]) {
      childNode = createElm(null, parentVNode, startIdx, parentElm);
      if (childNode) {
        vnodes[startIdx].$elm$ = childNode;
        containerElm.insertBefore(childNode, referenceNode(before));
      }
    }
  }
};
var removeVnodes = (vnodes, startIdx, endIdx) => {
  for (let index = startIdx; index <= endIdx; ++index) {
    const vnode = vnodes[index];
    if (vnode) {
      const elm = vnode.$elm$;
      nullifyVNodeRefs(vnode);
      if (elm) {
        {
          checkSlotFallbackVisibility = true;
          if (elm["s-ol"]) {
            elm["s-ol"].remove();
          } else {
            putBackInOriginalLocation(elm, true);
          }
        }
        elm.remove();
      }
    }
  }
};
var updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let node;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {
      patch(oldStartVnode, newStartVnode, isInitialRender);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {
      patch(oldEndVnode, newEndVnode, isInitialRender);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
      }
      patch(oldStartVnode, newEndVnode, isInitialRender);
      parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
      }
      patch(oldEndVnode, newStartVnode, isInitialRender);
      parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      {
        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);
        newStartVnode = newCh[++newStartIdx];
      }
      if (node) {
        {
          parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
        }
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
  }
};
var isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {
  if (leftVNode.$tag$ === rightVNode.$tag$) {
    if (leftVNode.$tag$ === "slot") {
      return leftVNode.$name$ === rightVNode.$name$;
    }
    return true;
  }
  return false;
};
var referenceNode = (node) => {
  return node && node["s-ol"] || node;
};
var parentReferenceNode = (node) => (node["s-ol"] ? node["s-ol"] : node).parentNode;
var patch = (oldVNode, newVNode2, isInitialRender = false) => {
  const elm = newVNode2.$elm$ = oldVNode.$elm$;
  const oldChildren = oldVNode.$children$;
  const newChildren = newVNode2.$children$;
  const tag = newVNode2.$tag$;
  const text = newVNode2.$text$;
  let defaultHolder;
  if (text === null) {
    {
      if (tag === "slot")
        ;
      else {
        updateElement(oldVNode, newVNode2, isSvgMode);
      }
    }
    if (oldChildren !== null && newChildren !== null) {
      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);
    } else if (newChildren !== null) {
      if (oldVNode.$text$ !== null) {
        elm.textContent = "";
      }
      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
    } else if (oldChildren !== null) {
      removeVnodes(oldChildren, 0, oldChildren.length - 1);
    }
  } else if (defaultHolder = elm["s-cr"]) {
    defaultHolder.parentNode.textContent = text;
  } else if (oldVNode.$text$ !== text) {
    elm.data = text;
  }
};
var updateFallbackSlotVisibility = (elm) => {
  const childNodes = elm.childNodes;
  for (const childNode of childNodes) {
    if (childNode.nodeType === 1) {
      if (childNode["s-sr"]) {
        const slotName = childNode["s-sn"];
        childNode.hidden = false;
        for (const siblingNode of childNodes) {
          if (siblingNode !== childNode) {
            if (siblingNode["s-hn"] !== childNode["s-hn"] || slotName !== "") {
              if (siblingNode.nodeType === 1 && (slotName === siblingNode.getAttribute("slot") || slotName === siblingNode["s-sn"])) {
                childNode.hidden = true;
                break;
              }
            } else {
              if (siblingNode.nodeType === 1 || siblingNode.nodeType === 3 && siblingNode.textContent.trim() !== "") {
                childNode.hidden = true;
                break;
              }
            }
          }
        }
      }
      updateFallbackSlotVisibility(childNode);
    }
  }
};
var relocateNodes = [];
var markSlotContentForRelocation = (elm) => {
  let node;
  let hostContentNodes;
  let j;
  for (const childNode of elm.childNodes) {
    if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
      hostContentNodes = node.parentNode.childNodes;
      const slotName = childNode["s-sn"];
      for (j = hostContentNodes.length - 1; j >= 0; j--) {
        node = hostContentNodes[j];
        if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"] && !BUILD.experimentalSlotFixes) {
          if (isNodeLocatedInSlot(node, slotName)) {
            let relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
            checkSlotFallbackVisibility = true;
            node["s-sn"] = node["s-sn"] || slotName;
            if (relocateNodeData) {
              relocateNodeData.$nodeToRelocate$["s-sh"] = childNode["s-hn"];
              relocateNodeData.$slotRefNode$ = childNode;
            } else {
              node["s-sh"] = childNode["s-hn"];
              relocateNodes.push({
                $slotRefNode$: childNode,
                $nodeToRelocate$: node
              });
            }
            if (node["s-sr"]) {
              relocateNodes.map((relocateNode) => {
                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                  relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
                  if (relocateNodeData && !relocateNode.$slotRefNode$) {
                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                  }
                }
              });
            }
          } else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {
            relocateNodes.push({
              $nodeToRelocate$: node
            });
          }
        }
      }
    }
    if (childNode.nodeType === 1) {
      markSlotContentForRelocation(childNode);
    }
  }
};
var isNodeLocatedInSlot = (nodeToRelocate, slotName) => {
  if (nodeToRelocate.nodeType === 1) {
    if (nodeToRelocate.getAttribute("slot") === null && slotName === "") {
      return true;
    }
    if (nodeToRelocate.getAttribute("slot") === slotName) {
      return true;
    }
    return false;
  }
  if (nodeToRelocate["s-sn"] === slotName) {
    return true;
  }
  return slotName === "";
};
var nullifyVNodeRefs = (vNode) => {
  {
    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
  }
};
var renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
  var _a, _b, _c, _d;
  const hostElm = hostRef.$hostElement$;
  const cmpMeta = hostRef.$cmpMeta$;
  const oldVNode = hostRef.$vnode$ || newVNode(null, null);
  const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
  hostTagName = hostElm.tagName;
  if (cmpMeta.$attrsToReflect$) {
    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
    cmpMeta.$attrsToReflect$.map(([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]);
  }
  if (isInitialLoad && rootVnode.$attrs$) {
    for (const key of Object.keys(rootVnode.$attrs$)) {
      if (hostElm.hasAttribute(key) && !["key", "ref", "style", "class"].includes(key)) {
        rootVnode.$attrs$[key] = hostElm[key];
      }
    }
  }
  rootVnode.$tag$ = null;
  rootVnode.$flags$ |= 4;
  hostRef.$vnode$ = rootVnode;
  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
  {
    scopeId = hostElm["s-sc"];
  }
  {
    contentRef = hostElm["s-cr"];
    useNativeShadowDom = (cmpMeta.$flags$ & 1) !== 0;
    checkSlotFallbackVisibility = false;
  }
  patch(oldVNode, rootVnode, isInitialLoad);
  {
    plt.$flags$ |= 1;
    if (checkSlotRelocate) {
      markSlotContentForRelocation(rootVnode.$elm$);
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        if (!nodeToRelocate["s-ol"]) {
          const orgLocationNode = doc.createTextNode("");
          orgLocationNode["s-nr"] = nodeToRelocate;
          nodeToRelocate.parentNode.insertBefore(nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
        }
      }
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        const slotRefNode = relocateData.$slotRefNode$;
        if (slotRefNode) {
          const parentNodeRef = slotRefNode.parentNode;
          let insertBeforeNode = slotRefNode.nextSibling;
          {
            let orgLocationNode = (_a = nodeToRelocate["s-ol"]) === null || _a === void 0 ? void 0 : _a.previousSibling;
            while (orgLocationNode) {
              let refNode = (_b = orgLocationNode["s-nr"]) !== null && _b !== void 0 ? _b : null;
              if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === refNode.parentNode) {
                refNode = refNode.nextSibling;
                if (!refNode || !refNode["s-nr"]) {
                  insertBeforeNode = refNode;
                  break;
                }
              }
              orgLocationNode = orgLocationNode.previousSibling;
            }
          }
          if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
            if (nodeToRelocate !== insertBeforeNode) {
              if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
              }
              parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
              if (nodeToRelocate.nodeType === 1) {
                nodeToRelocate.hidden = (_c = nodeToRelocate["s-ih"]) !== null && _c !== void 0 ? _c : false;
              }
            }
          }
        } else {
          if (nodeToRelocate.nodeType === 1) {
            if (isInitialLoad) {
              nodeToRelocate["s-ih"] = (_d = nodeToRelocate.hidden) !== null && _d !== void 0 ? _d : false;
            }
            nodeToRelocate.hidden = true;
          }
        }
      }
    }
    if (checkSlotFallbackVisibility) {
      updateFallbackSlotVisibility(rootVnode.$elm$);
    }
    plt.$flags$ &= ~1;
    relocateNodes.length = 0;
  }
};
var attachToAncestor = (hostRef, ancestorComponent) => {
  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
    ancestorComponent["s-p"].push(new Promise((r) => hostRef.$onRenderResolve$ = r));
  }
};
var scheduleUpdate = (hostRef, isInitialLoad) => {
  {
    hostRef.$flags$ |= 16;
  }
  if (hostRef.$flags$ & 4) {
    hostRef.$flags$ |= 512;
    return;
  }
  attachToAncestor(hostRef, hostRef.$ancestorComponent$);
  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
  return writeTask(dispatch);
};
var dispatchHooks = (hostRef, isInitialLoad) => {
  const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
  const instance = hostRef.$lazyInstance$;
  let maybePromise;
  if (isInitialLoad) {
    {
      maybePromise = safeCall(instance, "componentWillLoad");
    }
  }
  endSchedule();
  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
};
var enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn) : fn();
var isPromisey = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === "function";
var updateComponent = async (hostRef, instance, isInitialLoad) => {
  var _a;
  const elm = hostRef.$hostElement$;
  const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
  const rc = elm["s-rc"];
  if (isInitialLoad) {
    attachStyles(hostRef);
  }
  const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
  {
    callRender(hostRef, instance, elm, isInitialLoad);
  }
  if (rc) {
    rc.map((cb) => cb());
    elm["s-rc"] = void 0;
  }
  endRender();
  endUpdate();
  {
    const childrenPromises = (_a = elm["s-p"]) !== null && _a !== void 0 ? _a : [];
    const postUpdate = () => postUpdateComponent(hostRef);
    if (childrenPromises.length === 0) {
      postUpdate();
    } else {
      Promise.all(childrenPromises).then(postUpdate);
      hostRef.$flags$ |= 4;
      childrenPromises.length = 0;
    }
  }
};
var callRender = (hostRef, instance, elm, isInitialLoad) => {
  try {
    instance = instance.render();
    {
      hostRef.$flags$ &= ~16;
    }
    {
      hostRef.$flags$ |= 2;
    }
    {
      {
        {
          renderVdom(hostRef, instance, isInitialLoad);
        }
      }
    }
  } catch (e) {
    consoleError(e, hostRef.$hostElement$);
  }
  return null;
};
var postUpdateComponent = (hostRef) => {
  const tagName = hostRef.$cmpMeta$.$tagName$;
  const elm = hostRef.$hostElement$;
  const endPostUpdate = createTime("postUpdate", tagName);
  const instance = hostRef.$lazyInstance$;
  const ancestorComponent = hostRef.$ancestorComponent$;
  {
    safeCall(instance, "componentDidRender");
  }
  if (!(hostRef.$flags$ & 64)) {
    hostRef.$flags$ |= 64;
    {
      addHydratedFlag(elm);
    }
    {
      safeCall(instance, "componentDidLoad");
    }
    endPostUpdate();
    {
      hostRef.$onReadyResolve$(elm);
      if (!ancestorComponent) {
        appDidLoad();
      }
    }
  } else {
    endPostUpdate();
  }
  {
    hostRef.$onInstanceResolve$(elm);
  }
  {
    if (hostRef.$onRenderResolve$) {
      hostRef.$onRenderResolve$();
      hostRef.$onRenderResolve$ = void 0;
    }
    if (hostRef.$flags$ & 512) {
      nextTick(() => scheduleUpdate(hostRef, false));
    }
    hostRef.$flags$ &= ~(4 | 512);
  }
};
var appDidLoad = (who) => {
  {
    addHydratedFlag(doc.documentElement);
  }
  nextTick(() => emitEvent(win, "appload", { detail: { namespace: NAMESPACE } }));
};
var safeCall = (instance, method, arg) => {
  if (instance && instance[method]) {
    try {
      return instance[method](arg);
    } catch (e) {
      consoleError(e);
    }
  }
  return void 0;
};
var addHydratedFlag = (elm) => elm.setAttribute("hydrated", "");
var getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
var setValue = (ref, propName, newVal, cmpMeta) => {
  const hostRef = getHostRef(ref);
  const elm = hostRef.$hostElement$;
  const oldVal = hostRef.$instanceValues$.get(propName);
  const flags = hostRef.$flags$;
  const instance = hostRef.$lazyInstance$;
  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
  const didValueChange = newVal !== oldVal && !areBothNaN;
  if ((!(flags & 8) || oldVal === void 0) && didValueChange) {
    hostRef.$instanceValues$.set(propName, newVal);
    if (instance) {
      if (cmpMeta.$watchers$ && flags & 128) {
        const watchMethods = cmpMeta.$watchers$[propName];
        if (watchMethods) {
          watchMethods.map((watchMethodName) => {
            try {
              instance[watchMethodName](newVal, oldVal, propName);
            } catch (e) {
              consoleError(e, elm);
            }
          });
        }
      }
      if ((flags & (2 | 16)) === 2) {
        scheduleUpdate(hostRef, false);
      }
    }
  }
};
var proxyComponent = (Cstr, cmpMeta, flags) => {
  var _a;
  const prototype = Cstr.prototype;
  if (cmpMeta.$members$) {
    if (Cstr.watchers) {
      cmpMeta.$watchers$ = Cstr.watchers;
    }
    const members = Object.entries(cmpMeta.$members$);
    members.map(([memberName, [memberFlags]]) => {
      if (memberFlags & 31 || flags & 2 && memberFlags & 32) {
        Object.defineProperty(prototype, memberName, {
          get() {
            return getValue(this, memberName);
          },
          set(newValue) {
            setValue(this, memberName, newValue, cmpMeta);
          },
          configurable: true,
          enumerable: true
        });
      } else if (flags & 1 && memberFlags & 64) {
        Object.defineProperty(prototype, memberName, {
          value(...args) {
            var _a2;
            const ref = getHostRef(this);
            return (_a2 = ref === null || ref === void 0 ? void 0 : ref.$onInstancePromise$) === null || _a2 === void 0 ? void 0 : _a2.then(() => {
              var _a3;
              return (_a3 = ref.$lazyInstance$) === null || _a3 === void 0 ? void 0 : _a3[memberName](...args);
            });
          }
        });
      }
    });
    if (flags & 1) {
      const attrNameToPropName = /* @__PURE__ */ new Map();
      prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {
        plt.jmp(() => {
          var _a2;
          const propName = attrNameToPropName.get(attrName);
          if (this.hasOwnProperty(propName)) {
            newValue = this[propName];
            delete this[propName];
          } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && this[propName] == newValue) {
            return;
          } else if (propName == null) {
            const hostRef = getHostRef(this);
            const flags2 = hostRef === null || hostRef === void 0 ? void 0 : hostRef.$flags$;
            if (flags2 && !(flags2 & 8) && flags2 & 128 && newValue !== oldValue) {
              const instance = hostRef.$lazyInstance$;
              const entry = (_a2 = cmpMeta.$watchers$) === null || _a2 === void 0 ? void 0 : _a2[attrName];
              entry === null || entry === void 0 ? void 0 : entry.forEach((callbackName) => {
                if (instance[callbackName] != null) {
                  instance[callbackName].call(instance, newValue, oldValue, attrName);
                }
              });
            }
            return;
          }
          this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
        });
      };
      Cstr.observedAttributes = Array.from(/* @__PURE__ */ new Set([
        ...Object.keys((_a = cmpMeta.$watchers$) !== null && _a !== void 0 ? _a : {}),
        ...members.filter(
          ([_, m]) => m[0] & 15
          /* MEMBER_FLAGS.HasAttribute */
        ).map(([propName, m]) => {
          var _a2;
          const attrName = m[1] || propName;
          attrNameToPropName.set(attrName, propName);
          if (m[0] & 512) {
            (_a2 = cmpMeta.$attrsToReflect$) === null || _a2 === void 0 ? void 0 : _a2.push([propName, attrName]);
          }
          return attrName;
        })
      ]));
    }
  }
  return Cstr;
};
var initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {
  let Cstr;
  if ((hostRef.$flags$ & 32) === 0) {
    hostRef.$flags$ |= 32;
    {
      Cstr = loadModule(cmpMeta);
      if (Cstr.then) {
        const endLoad = uniqueTime();
        Cstr = await Cstr;
        endLoad();
      }
      if (!Cstr.isProxied) {
        {
          cmpMeta.$watchers$ = Cstr.watchers;
        }
        proxyComponent(
          Cstr,
          cmpMeta,
          2
          /* PROXY_FLAGS.proxyState */
        );
        Cstr.isProxied = true;
      }
      const endNewInstance = createTime("createInstance", cmpMeta.$tagName$);
      {
        hostRef.$flags$ |= 8;
      }
      try {
        new Cstr(hostRef);
      } catch (e) {
        consoleError(e);
      }
      {
        hostRef.$flags$ &= ~8;
      }
      {
        hostRef.$flags$ |= 128;
      }
      endNewInstance();
    }
    if (Cstr.style) {
      let style = Cstr.style;
      const scopeId2 = getScopeId(cmpMeta);
      if (!styles.has(scopeId2)) {
        const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
        endRegisterStyles();
      }
    }
  }
  const ancestorComponent = hostRef.$ancestorComponent$;
  const schedule = () => scheduleUpdate(hostRef, true);
  if (ancestorComponent && ancestorComponent["s-rc"]) {
    ancestorComponent["s-rc"].push(schedule);
  } else {
    schedule();
  }
};
var fireConnectedCallback = (instance) => {
};
var connectedCallback = (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    const cmpMeta = hostRef.$cmpMeta$;
    const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
    if (!(hostRef.$flags$ & 1)) {
      hostRef.$flags$ |= 1;
      {
        if (
          // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
          cmpMeta.$flags$ & (4 | 8)
        ) {
          setContentReference(elm);
        }
      }
      {
        let ancestorComponent = elm;
        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
          if (ancestorComponent["s-p"]) {
            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
            break;
          }
        }
      }
      if (cmpMeta.$members$) {
        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
            const value = elm[memberName];
            delete elm[memberName];
            elm[memberName] = value;
          }
        });
      }
      {
        initializeComponent(elm, hostRef, cmpMeta);
      }
    } else {
      if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$lazyInstance$)
        ;
      else if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$onReadyPromise$) {
        hostRef.$onReadyPromise$.then(() => fireConnectedCallback());
      }
    }
    endConnected();
  }
};
var setContentReference = (elm) => {
  const contentRefElm = elm["s-cr"] = doc.createComment("");
  contentRefElm["s-cn"] = true;
  elm.insertBefore(contentRefElm, elm.firstChild);
};
var disconnectInstance = (instance) => {
  {
    safeCall(instance, "disconnectedCallback");
  }
};
var disconnectedCallback = async (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$lazyInstance$) {
      disconnectInstance(hostRef.$lazyInstance$);
    } else if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$onReadyPromise$) {
      hostRef.$onReadyPromise$.then(() => disconnectInstance(hostRef.$lazyInstance$));
    }
  }
};
var bootstrapLazy = (lazyBundles, options = {}) => {
  var _a;
  const endBootstrap = createTime();
  const cmpTags = [];
  const exclude = options.exclude || [];
  const customElements = win.customElements;
  const head = doc.head;
  const metaCharset = head.querySelector("meta[charset]");
  const dataStyles = doc.createElement("style");
  const deferredConnectedCallbacks = [];
  let appLoadFallback;
  let isBootstrapping = true;
  Object.assign(plt, options);
  plt.$resourcesUrl$ = new URL(options.resourcesUrl || "./", doc.baseURI).href;
  let hasSlotRelocation = false;
  lazyBundles.map((lazyBundle) => {
    lazyBundle[1].map((compactMeta) => {
      var _a2;
      const cmpMeta = {
        $flags$: compactMeta[0],
        $tagName$: compactMeta[1],
        $members$: compactMeta[2],
        $listeners$: compactMeta[3]
      };
      if (cmpMeta.$flags$ & 4) {
        hasSlotRelocation = true;
      }
      {
        cmpMeta.$members$ = compactMeta[2];
      }
      {
        cmpMeta.$attrsToReflect$ = [];
      }
      {
        cmpMeta.$watchers$ = (_a2 = compactMeta[4]) !== null && _a2 !== void 0 ? _a2 : {};
      }
      const tagName = cmpMeta.$tagName$;
      const HostElement = class extends HTMLElement {
        // StencilLazyHost
        constructor(self) {
          super(self);
          self = this;
          registerHost(self, cmpMeta);
          if (cmpMeta.$flags$ & 1) {
            {
              {
                self.attachShadow({ mode: "open" });
              }
            }
          }
        }
        connectedCallback() {
          if (appLoadFallback) {
            clearTimeout(appLoadFallback);
            appLoadFallback = null;
          }
          if (isBootstrapping) {
            deferredConnectedCallbacks.push(this);
          } else {
            plt.jmp(() => connectedCallback(this));
          }
        }
        disconnectedCallback() {
          plt.jmp(() => disconnectedCallback(this));
        }
        componentOnReady() {
          return getHostRef(this).$onReadyPromise$;
        }
      };
      cmpMeta.$lazyBundleId$ = lazyBundle[0];
      if (!exclude.includes(tagName) && !customElements.get(tagName)) {
        cmpTags.push(tagName);
        customElements.define(tagName, proxyComponent(
          HostElement,
          cmpMeta,
          1
          /* PROXY_FLAGS.isElementConstructor */
        ));
      }
    });
  });
  if (hasSlotRelocation) {
    dataStyles.innerHTML += SLOT_FB_CSS;
  }
  {
    dataStyles.innerHTML += cmpTags + HYDRATED_CSS;
  }
  if (dataStyles.innerHTML.length) {
    dataStyles.setAttribute("data-styles", "");
    const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
    if (nonce != null) {
      dataStyles.setAttribute("nonce", nonce);
    }
    head.insertBefore(dataStyles, metaCharset ? metaCharset.nextSibling : head.firstChild);
  }
  isBootstrapping = false;
  if (deferredConnectedCallbacks.length) {
    deferredConnectedCallbacks.map((host) => host.connectedCallback());
  } else {
    {
      plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30));
    }
  }
  endBootstrap();
};
var setNonce = (nonce) => plt.$nonce$ = nonce;
var hostRefs = /* @__PURE__ */ new WeakMap();
var getHostRef = (ref) => hostRefs.get(ref);
var registerInstance = (lazyInstance, hostRef) => hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);
var registerHost = (hostElement, cmpMeta) => {
  const hostRef = {
    $flags$: 0,
    $hostElement$: hostElement,
    $cmpMeta$: cmpMeta,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  {
    hostRef.$onInstancePromise$ = new Promise((r) => hostRef.$onInstanceResolve$ = r);
  }
  {
    hostRef.$onReadyPromise$ = new Promise((r) => hostRef.$onReadyResolve$ = r);
    hostElement["s-p"] = [];
    hostElement["s-rc"] = [];
  }
  return hostRefs.set(hostElement, hostRef);
};
var isMemberInElement = (elm, memberName) => memberName in elm;
var consoleError = (e, el) => (0, console.error)(e, el);
var cmpModules = /* @__PURE__ */ new Map();
var loadModule = (cmpMeta, hostRef, hmrVersionId) => {
  const exportName = cmpMeta.$tagName$.replace(/-/g, "_");
  const bundleId = cmpMeta.$lazyBundleId$;
  const module = cmpModules.get(bundleId);
  if (module) {
    return module[exportName];
  }
  if (!hmrVersionId || !BUILD.hotModuleReplacement) {
    const processMod = (importedModule) => {
      cmpModules.set(bundleId, importedModule);
      return importedModule[exportName];
    };
    switch (bundleId) {
      case "arcgis-basemap-gallery_2":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-basemap-gallery_2.entry-5D5CETFH.js"
        ).then(processMod, consoleError);
      case "arcgis-area-measurement-2d":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-area-measurement-2d.entry-IHZPCWJR.js"
        ).then(processMod, consoleError);
      case "arcgis-area-measurement-3d":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-area-measurement-3d.entry-WMAPK244.js"
        ).then(processMod, consoleError);
      case "arcgis-attachments":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-attachments.entry-YOE27EL3.js"
        ).then(processMod, consoleError);
      case "arcgis-basemap-layer-list":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-basemap-layer-list.entry-PTVCA42M.js"
        ).then(processMod, consoleError);
      case "arcgis-basemap-toggle":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-basemap-toggle.entry-TUGMGFXM.js"
        ).then(processMod, consoleError);
      case "arcgis-bookmarks":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-bookmarks.entry-LNAU7WFG.js"
        ).then(processMod, consoleError);
      case "arcgis-building-explorer":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-building-explorer.entry-CHJ2NWED.js"
        ).then(processMod, consoleError);
      case "arcgis-compass":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-compass.entry-ZW33K5TK.js"
        ).then(processMod, consoleError);
      case "arcgis-coordinate-conversion":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-coordinate-conversion.entry-PLLBOOYT.js"
        ).then(processMod, consoleError);
      case "arcgis-daylight":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-daylight.entry-BDJQUCV3.js"
        ).then(processMod, consoleError);
      case "arcgis-directional-pad":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-directional-pad.entry-SGIVQC3K.js"
        ).then(processMod, consoleError);
      case "arcgis-directions":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-directions.entry-L5GWQI5P.js"
        ).then(processMod, consoleError);
      case "arcgis-directline-measurement-3d":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-directline-measurement-3d.entry-5UXXEQ5C.js"
        ).then(processMod, consoleError);
      case "arcgis-distance-measurement-2d":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-distance-measurement-2d.entry-55APJJI6.js"
        ).then(processMod, consoleError);
      case "arcgis-editor":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-editor.entry-F5GJRR22.js"
        ).then(processMod, consoleError);
      case "arcgis-elevation-profile":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-elevation-profile.entry-NWYCWDHI.js"
        ).then(processMod, consoleError);
      case "arcgis-feature":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-feature.entry-F233GV2X.js"
        ).then(processMod, consoleError);
      case "arcgis-feature-form":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-feature-form.entry-TMMNO7BU.js"
        ).then(processMod, consoleError);
      case "arcgis-feature-table":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-feature-table.entry-5PXVCY2T.js"
        ).then(processMod, consoleError);
      case "arcgis-feature-templates":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-feature-templates.entry-XGXQVCNR.js"
        ).then(processMod, consoleError);
      case "arcgis-features":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-features.entry-TKEQ2A4I.js"
        ).then(processMod, consoleError);
      case "arcgis-floor-filter":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-floor-filter.entry-BF2VFQCC.js"
        ).then(processMod, consoleError);
      case "arcgis-fullscreen":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-fullscreen.entry-SRVT5MMW.js"
        ).then(processMod, consoleError);
      case "arcgis-histogram":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-histogram.entry-MXT636CX.js"
        ).then(processMod, consoleError);
      case "arcgis-histogram-range-slider":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-histogram-range-slider.entry-SWY3VUYQ.js"
        ).then(processMod, consoleError);
      case "arcgis-home":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-home.entry-KZF2O3WS.js"
        ).then(processMod, consoleError);
      case "arcgis-layer-list":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-layer-list.entry-LBU5HGU4.js"
        ).then(processMod, consoleError);
      case "arcgis-legend":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-legend.entry-BF7NCTVX.js"
        ).then(processMod, consoleError);
      case "arcgis-line-of-sight":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-line-of-sight.entry-ANWZETNE.js"
        ).then(processMod, consoleError);
      case "arcgis-locate":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-locate.entry-XFASFRKH.js"
        ).then(processMod, consoleError);
      case "arcgis-measurement":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-measurement.entry-O73N623O.js"
        ).then(processMod, consoleError);
      case "arcgis-navigation-toggle":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-navigation-toggle.entry-UU7OZKBI.js"
        ).then(processMod, consoleError);
      case "arcgis-placement":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-placement.entry-5CKX5BZV.js"
        ).then(processMod, consoleError);
      case "arcgis-print":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-print.entry-7OA3FF3C.js"
        ).then(processMod, consoleError);
      case "arcgis-scale-bar":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-scale-bar.entry-VQ5NZTLO.js"
        ).then(processMod, consoleError);
      case "arcgis-scale-range-slider":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-scale-range-slider.entry-XRQDE3MY.js"
        ).then(processMod, consoleError);
      case "arcgis-scene":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-scene.entry-PX42CJPQ.js"
        ).then(processMod, consoleError);
      case "arcgis-search":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-search.entry-DP4XBGIM.js"
        ).then(processMod, consoleError);
      case "arcgis-shadow-cast":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-shadow-cast.entry-VWVHDWVV.js"
        ).then(processMod, consoleError);
      case "arcgis-sketch":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-sketch.entry-MOBT2HZP.js"
        ).then(processMod, consoleError);
      case "arcgis-slice":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-slice.entry-QNRUW7V3.js"
        ).then(processMod, consoleError);
      case "arcgis-slider":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-slider.entry-U2LSGNU6.js"
        ).then(processMod, consoleError);
      case "arcgis-swipe":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-swipe.entry-YCNJFCNY.js"
        ).then(processMod, consoleError);
      case "arcgis-table-list":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-table-list.entry-A6N4RUPA.js"
        ).then(processMod, consoleError);
      case "arcgis-time-slider":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-time-slider.entry-SLRAK6IO.js"
        ).then(processMod, consoleError);
      case "arcgis-track":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-track.entry-UJT3D6BB.js"
        ).then(processMod, consoleError);
      case "arcgis-utility-network-associations":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-utility-network-associations.entry-JUUX2GJZ.js"
        ).then(processMod, consoleError);
      case "arcgis-utility-network-trace":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-utility-network-trace.entry-NUIWJQFS.js"
        ).then(processMod, consoleError);
      case "arcgis-utility-network-validate-topology":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-utility-network-validate-topology.entry-4WAM5GMX.js"
        ).then(processMod, consoleError);
      case "arcgis-value-picker":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-value-picker.entry-4U5P4WOM.js"
        ).then(processMod, consoleError);
      case "arcgis-version-management":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-version-management.entry-2OHPY4U6.js"
        ).then(processMod, consoleError);
      case "arcgis-weather":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-weather.entry-36ITHFB3.js"
        ).then(processMod, consoleError);
      case "arcgis-zoom":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-zoom.entry-XZ2FQRO4.js"
        ).then(processMod, consoleError);
      case "arcgis-version-management-service-item_2":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-version-management-service-item_2.entry-GJOW6C25.js"
        ).then(processMod, consoleError);
      case "arcgis-version-management-version-item_2":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-version-management-version-item_2.entry-JVUJVQMQ.js"
        ).then(processMod, consoleError);
      case "arcgis-expand":
        return import(
          /* webpackMode: "lazy" */
          "./arcgis-expand.entry-KXFPJBET.js"
        ).then(processMod, consoleError);
    }
  }
  return /* @vite-ignore */ /* webpackInclude: /\.entry\.js$/ */ /* webpackExclude: /\.system\.entry\.js$/ */ /* webpackMode: "lazy" */ globImport_entry_js(`./${bundleId}.entry.js${""}`).then((importedModule) => {
    {
      cmpModules.set(bundleId, importedModule);
    }
    return importedModule[exportName];
  }, consoleError);
};
var styles = /* @__PURE__ */ new Map();
var win = typeof window !== "undefined" ? window : {};
var doc = win.document || { head: {} };
var plt = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (h2) => h2(),
  raf: (h2) => requestAnimationFrame(h2),
  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
  ce: (eventName, opts) => new CustomEvent(eventName, opts)
};
var promiseResolve = (v) => Promise.resolve(v);
var supportsConstructableStylesheets = (() => {
  try {
    new CSSStyleSheet();
    return typeof new CSSStyleSheet().replaceSync === "function";
  } catch (e) {
  }
  return false;
})();
var queueDomReads = [];
var queueDomWrites = [];
var queueTask = (queue, write) => (cb) => {
  queue.push(cb);
  if (!queuePending) {
    queuePending = true;
    if (write && plt.$flags$ & 4) {
      nextTick(flush);
    } else {
      plt.raf(flush);
    }
  }
};
var consume = (queue) => {
  for (let i = 0; i < queue.length; i++) {
    try {
      queue[i](performance.now());
    } catch (e) {
      consoleError(e);
    }
  }
  queue.length = 0;
};
var flush = () => {
  consume(queueDomReads);
  {
    consume(queueDomWrites);
    if (queuePending = queueDomReads.length > 0) {
      plt.raf(flush);
    }
  }
};
var nextTick = (cb) => promiseResolve().then(cb);
var writeTask = queueTask(queueDomWrites, true);

export {
  getAssetPath,
  h,
  Host,
  getElement,
  createEvent,
  bootstrapLazy,
  setNonce,
  registerInstance
};
/*! Bundled license information:

@arcgis/map-components/dist/esm/index-2198b48c.js:
  (*!
   * All material copyright Esri, All Rights Reserved, unless otherwise specified.
   * See https://js.arcgis.com/4.30/esri/copyright.txt for details.
   * v4.30.0-next.13
   *)
*/
//# sourceMappingURL=chunk-KMIMZXFW.js.map
