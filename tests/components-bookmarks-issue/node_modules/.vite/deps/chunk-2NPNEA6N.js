import {
  r
} from "./chunk-U34ZXOJT.js";
import {
  m
} from "./chunk-OKRW5W44.js";
import {
  c
} from "./chunk-RGAA5Z76.js";
import {
  A
} from "./chunk-Q6RZBEZ6.js";
import {
  b as b2
} from "./chunk-W5ALAOW2.js";
import {
  d
} from "./chunk-AKQ765JR.js";
import {
  k2 as k
} from "./chunk-ZIJHDTB7.js";
import {
  e
} from "./chunk-VEODBKUJ.js";
import {
  x
} from "./chunk-HLDUDRTD.js";
import {
  n
} from "./chunk-RUN6MNXL.js";
import {
  t3 as t
} from "./chunk-SAYWXQVM.js";
import {
  b
} from "./chunk-BVQWKK2V.js";
import {
  u3 as u
} from "./chunk-I2RC5KWA.js";
import {
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/layers/support/featureLayerUtils.js
var f = new n({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryMultiPatch: "multipatch" });
async function m2(t2, e2, r2, o) {
  const a = await G(t2);
  if (await h(t2, e2, o), !a.addAttachment)
    throw new s(o, "Layer source does not support addAttachment capability");
  return a.addAttachment(e2, r2);
}
function h(t2, e2, r2) {
  var _a, _b;
  const { attributes: o } = e2, { objectIdField: a } = t2;
  return ((_b = (_a = t2.capabilities) == null ? void 0 : _a.data) == null ? void 0 : _b.supportsAttachment) ? e2 ? o ? a && o[a] ? Promise.resolve() : Promise.reject(new s(r2, `feature is missing the identifying attribute ${a}`)) : Promise.reject(new s(r2, "'attributes' are required on a feature to query attachments")) : Promise.reject(new s(r2, "A feature is required to add/delete/update attachments")) : Promise.reject(new s(r2, "this layer doesn't support attachments"));
}
async function w(t2, e2, r2, o, a) {
  const s2 = await G(t2);
  if (await h(t2, e2, a), !s2.updateAttachment)
    throw new s(a, "Layer source does not support updateAttachment capability");
  return s2.updateAttachment(e2, r2, o);
}
async function b3(t2, e2, r2) {
  const { applyEdits: n2 } = await import("./editingSupport-OQAPOMEA.js"), o = await t2.load(), { source: a, globalIdField: s2 } = o;
  let i = r2;
  return ("feature" === o.type ? o.infoFor3D : null) && null != e2.deleteFeatures && null != s2 && (i = { ...i, globalIdToObjectId: await V(t2, e2.deleteFeatures, s2) }), n2(o, a, e2, r2);
}
async function g(t2, e2, r2) {
  const { uploadAssets: n2 } = await import("./editingSupport-OQAPOMEA.js"), o = await t2.load();
  return n2(o, o.source, e2, r2);
}
async function j(t2, e2, r2, o) {
  const a = await G(t2);
  if (await h(t2, e2, o), !a.deleteAttachments)
    throw new s(o, "Layer source does not support deleteAttachments capability");
  return a.deleteAttachments(e2, r2);
}
async function I(t2, e2, r2) {
  const o = (await t2.load({ signal: e2 == null ? void 0 : e2.signal })).source;
  if (!o.fetchRecomputedExtents)
    throw new s(r2, "Layer source does not support fetchUpdates capability");
  return o.fetchRecomputedExtents(e2);
}
async function q(t2, e2, r2, o) {
  var _a, _b;
  e2 = c.from(e2), await t2.load();
  const a = t2.source, s2 = t2.capabilities;
  if (!((_a = s2 == null ? void 0 : s2.data) == null ? void 0 : _a.supportsAttachment))
    throw new s(o, "this layer doesn't support attachments");
  const { attachmentTypes: i, objectIds: u2, globalIds: c2, num: l, size: d2, start: y, where: f2 } = e2;
  if (!((_b = s2 == null ? void 0 : s2.operations) == null ? void 0 : _b.supportsQueryAttachments)) {
    if ((i == null ? void 0 : i.length) > 0 || (c2 == null ? void 0 : c2.length) > 0 || (d2 == null ? void 0 : d2.length) > 0 || l || y || f2)
      throw new s(o, "when 'capabilities.operations.supportsQueryAttachments' is false, only objectIds is supported", e2);
  }
  if (!((u2 == null ? void 0 : u2.length) || (c2 == null ? void 0 : c2.length) || f2))
    throw new s(o, "'objectIds', 'globalIds', or 'where' are required to perform attachment query", e2);
  if (!a.queryAttachments)
    throw new s(o, "Layer source does not support queryAttachments capability", e2);
  return a.queryAttachments(e2);
}
async function F(t2, e2, r2, o) {
  const a = await G(t2);
  if (!a.queryObjectIds)
    throw new s(o, "Layer source does not support queryObjectIds capability");
  return a.queryObjectIds(b2.from(e2) ?? t2.createQuery(), r2);
}
async function A2(t2, e2, r2, o) {
  const a = await G(t2);
  if (!a.queryFeatureCount)
    throw new s(o, "Layer source does not support queryFeatureCount capability");
  return a.queryFeatureCount(b2.from(e2) ?? t2.createQuery(), r2);
}
async function O(t2, e2, r2, o) {
  const a = await G(t2);
  if (!a.queryExtent)
    throw new s(o, "Layer source does not support queryExtent capability");
  return a.queryExtent(b2.from(e2) ?? t2.createQuery(), r2);
}
async function P(t2, e2, r2, o) {
  const a = await G(t2);
  if (!a.queryRelatedFeatures)
    throw new s(o, "Layer source does not support queryRelatedFeatures capability");
  return a.queryRelatedFeatures(d.from(e2), r2);
}
async function E(t2, e2, r2, o) {
  const a = await G(t2);
  if (!a.queryRelatedFeaturesCount)
    throw new s(o, "Layer source does not support queryRelatedFeaturesCount capability");
  return a.queryRelatedFeaturesCount(d.from(e2), r2);
}
async function S(t2) {
  const e2 = t2.source;
  if (e2 == null ? void 0 : e2.refresh)
    try {
      const { dataChanged: r2, updates: n2 } = await e2.refresh();
      if (null != n2 && (t2.sourceJSON = { ...t2.sourceJSON, ...n2 }, t2.read(n2, { origin: "service", url: t2.parsedUrl })), r2)
        return true;
    } catch {
    }
  if (t2.definitionExpression)
    try {
      return (await e(t2.definitionExpression, t2.fieldsIndex)).hasDateFunctions;
    } catch {
    }
  return false;
}
function x2(t2) {
  var _a, _b;
  const e2 = new b2(), r2 = (_a = t2.capabilities) == null ? void 0 : _a.data, n2 = (_b = t2.capabilities) == null ? void 0 : _b.query;
  e2.historicMoment = t2.historicMoment, e2.gdbVersion = t2.gdbVersion, e2.returnGeometry = true, n2 && (e2.compactGeometryEnabled = n2.supportsCompactGeometry, e2.defaultSpatialReferenceEnabled = n2.supportsDefaultSpatialReference), r2 && (r2.supportsZ && null != t2.returnZ && (e2.returnZ = t2.returnZ), r2.supportsM && null != t2.returnM && (e2.returnM = t2.returnM)), e2.outFields = ["*"];
  const { timeOffset: o, timeExtent: a } = t2;
  return e2.timeExtent = null != o && null != a ? a.offset(-o.value, o.unit) : a || null, e2.multipatchOption = "multipatch" === t2.geometryType ? "xyFootprint" : null, e2;
}
function R(t2) {
  const { globalIdField: e2, fields: r2 } = t2;
  if (e2)
    return e2;
  if (r2) {
    for (const n2 of r2)
      if ("esriFieldTypeGlobalID" === n2.type)
        return n2.name;
  }
}
function M(t2) {
  const { objectIdField: e2, fields: r2 } = t2;
  if (e2)
    return e2;
  if (r2) {
    for (const n2 of r2)
      if ("esriFieldTypeOID" === n2.type)
        return n2.name;
  }
}
function C(t2) {
  return t2.currentVersion ? t2.currentVersion : t2.hasOwnProperty("capabilities") || t2.hasOwnProperty("drawingInfo") || t2.hasOwnProperty("hasAttachments") || t2.hasOwnProperty("htmlPopupType") || t2.hasOwnProperty("relationships") || t2.hasOwnProperty("timeInfo") || t2.hasOwnProperty("typeIdField") || t2.hasOwnProperty("types") ? 10 : 9.3;
}
async function G(t2) {
  return (await t2.load()).source;
}
async function L(e2, r2) {
  if (!t)
    return;
  if (t.findCredential(e2))
    return;
  let n2;
  try {
    const o = await x(e2, r2);
    o && (n2 = await t.checkSignInStatus(`${o}/sharing`));
  } catch (o) {
  }
  if (n2)
    try {
      const n3 = null != r2 ? r2.signal : null;
      await t.getCredential(e2, { signal: n3 });
    } catch (o) {
    }
}
async function Q(t2, e2, r2) {
  var _a;
  const n2 = (_a = t2.parsedUrl) == null ? void 0 : _a.path;
  n2 && t2.authenticationTriggerEvent === e2 && await L(n2, r2);
}
function T(t2) {
  var _a;
  return !((_a = t2.sourceJSON) == null ? void 0 : _a.isMultiServicesView) && (t2.userHasUpdateItemPrivileges || t2.editingEnabled);
}
var v = u({ types: k });
function D(t2, e2) {
  var _a;
  if (t2.defaultSymbol)
    return ((_a = t2.types) == null ? void 0 : _a.length) ? new A({ defaultSymbol: v(t2.defaultSymbol, t2, e2), field: t2.typeIdField, uniqueValueInfos: t2.types.map((t3) => ({ id: t3.id, symbol: v(t3.symbol, t3, e2) })) }) : new m({ symbol: v(t2.defaultSymbol, t2, e2) });
}
function U(t2) {
  var _a, _b, _c;
  let e2 = (_a = t2.sourceJSON) == null ? void 0 : _a.cacheMaxAge;
  if (!e2)
    return false;
  const r2 = (_c = (_b = t2.editingInfo) == null ? void 0 : _b.lastEditDate) == null ? void 0 : _c.getTime();
  return null == r2 || (e2 *= 1e3, Date.now() - r2 < e2);
}
async function V(t2, e2, n2) {
  if (null == e2)
    return null;
  const o = [], { objectIdField: a } = t2;
  if (e2.forEach((t3) => {
    let e3 = null;
    if ("attributes" in t3) {
      const { attributes: r2 } = t3;
      e3 = { globalId: r2[n2], objectId: null != r2[a] && -1 !== r2[a] ? r2[a] : null };
    } else
      e3 = { globalId: t3.globalId, objectId: null != t3.objectId && -1 !== t3.objectId ? t3.objectId : null };
    null != e3.globalId && (null != e3.objectId && -1 !== e3.objectId || o.push(e3.globalId));
  }), 0 === o.length)
    return null;
  const s2 = t2.createQuery();
  s2.where = o.map((t3) => `${n2}='${t3}'`).join(" OR "), s2.returnGeometry = false, s2.outFields = [a, n2], s2.cacheHint = false;
  const u2 = await b(r(t2, s2));
  if (!u2.ok)
    return null;
  const c2 = /* @__PURE__ */ new Map(), l = u2.value.features;
  for (const r2 of l) {
    const t3 = r2.attributes[n2], e3 = r2.attributes[a];
    null != t3 && null != e3 && -1 !== e3 && c2.set(t3, e3);
  }
  return c2;
}

export {
  f,
  m2 as m,
  w,
  b3 as b,
  g,
  j,
  I,
  q,
  F,
  A2 as A,
  O,
  P,
  E,
  S,
  x2 as x,
  R,
  M,
  C,
  Q,
  T,
  D,
  U,
  V
};
//# sourceMappingURL=chunk-2NPNEA6N.js.map
