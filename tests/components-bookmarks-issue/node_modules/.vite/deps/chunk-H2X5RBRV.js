import {
  e as e5
} from "./chunk-5HWGOVOV.js";
import {
  S as S2
} from "./chunk-CGJEHQM2.js";
import {
  r as r2
} from "./chunk-MYIS6GAM.js";
import {
  E as E2,
  P as P2,
  r
} from "./chunk-CRYY7ZCN.js";
import {
  e as e4
} from "./chunk-YBFQVZX5.js";
import {
  a as a4,
  l,
  p as p3
} from "./chunk-ZIKY3AX6.js";
import {
  c as c3
} from "./chunk-VGQTAP4F.js";
import {
  q,
  u as u3
} from "./chunk-YSRCOU2A.js";
import {
  D
} from "./chunk-TKMRXVLK.js";
import {
  E2 as E
} from "./chunk-LEFES6LS.js";
import {
  N
} from "./chunk-TO6UIATU.js";
import {
  p as p2
} from "./chunk-OMRW2J7M.js";
import {
  a as a3
} from "./chunk-5SYJEI74.js";
import {
  n as n3
} from "./chunk-PTIWH4S7.js";
import {
  _
} from "./chunk-K3DEHPDR.js";
import {
  h as h4
} from "./chunk-NAWP2ZCR.js";
import {
  h as h3
} from "./chunk-I4SHZ6P5.js";
import {
  a as a2,
  c as c2,
  f,
  s as s3
} from "./chunk-SA77Z3WI.js";
import {
  n as n2
} from "./chunk-SCHTG6ZQ.js";
import {
  c2 as c,
  h as h2,
  j2 as j
} from "./chunk-ZIJHDTB7.js";
import {
  S
} from "./chunk-G5EVVNIJ.js";
import {
  y as y2
} from "./chunk-HU5IGOTI.js";
import {
  d as d2
} from "./chunk-C24MEKSO.js";
import {
  m
} from "./chunk-HLDUDRTD.js";
import {
  B,
  F,
  b,
  k
} from "./chunk-2ICUS4HL.js";
import {
  e as e3
} from "./chunk-IGR2BTWR.js";
import {
  G,
  s3 as s2
} from "./chunk-UWQ3OYA5.js";
import {
  A,
  P,
  d,
  p,
  v,
  w
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  h,
  u2
} from "./chunk-JGDJR5EV.js";
import {
  e as e2,
  u
} from "./chunk-QHK5ZYFW.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/views/3d/interactive/editingTools/ManipulatedObject3DGraphic.js
var g = Symbol();
var l2 = class extends o.EventedAccessor {
  get operations() {
    return this._operations;
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get elevationInfo() {
    return a2(this.graphic);
  }
  get visible() {
    return this._graphicState.displaying;
  }
  get isDraped() {
    return this._graphicState.isDraped;
  }
  get origin() {
    return D(this.view, this.graphic);
  }
  constructor(t) {
    super(t), this._updatingHandles = new h3();
  }
  destroy() {
    this._operations = u(this._operations), this._updatingHandles.destroy();
  }
  initialize() {
    this._graphicState = new e4({ graphic: this.graphic }), this._graphicState.on("changed", () => this.emit("committed")), this.addHandles(this.view.trackGraphicState(this._graphicState)), this.addHandles(this._updatingHandles.add(() => this.graphic.geometry, (t) => {
      var _a, _b;
      const e7 = (_a = this._operations) == null ? void 0 : _a.data.geometry;
      if (t !== e7) {
        if (!t || "multipoint" === (t == null ? void 0 : t.type) || "extent" === (t == null ? void 0 : t.type))
          return u(this._operations), this.removeHandles(g), void (this._operations = null);
        if ((_b = this._operations) == null ? void 0 : _b.trySetGeometry(t))
          this.emit("modified-externally");
        else {
          u(this._operations), this.removeHandles(g);
          const e8 = E.fromGeometry(t, this.view.state.viewingMode);
          this._operations = e8, this.addHandles(e8.data.on("change", () => this.graphic.geometry = e8.data.geometry), g);
        }
      }
    }, P));
  }
  createManipulator(t) {
    return new S2({ view: this.view, graphic: this.graphic, ...t });
  }
  maskOccludee() {
    return this.view.maskOccludee(this.graphic);
  }
  endInteraction() {
    const t = this.graphic.geometry;
    "mesh" === (t == null ? void 0 : t.type) && this.graphic.notifyMeshTransformChanged({ action: a3.UpdateFastLocalOrigin });
  }
  toMap(t) {
    return this.view.toMap(t, { include: [this.graphic] });
  }
};
e([y({ constructOnly: true })], l2.prototype, "view", void 0), e([y({ constructOnly: true })], l2.prototype, "graphic", void 0), e([y()], l2.prototype, "_operations", void 0), e([y()], l2.prototype, "operations", null), e([y()], l2.prototype, "updating", null), l2 = e([a("esri.views.3d.interactive.editingTools.ManipulatedObject3DGraphic")], l2);

// node_modules/@arcgis/core/views/3d/interactive/editingTools/reshape/isSupportedObject.js
function e6(t) {
  return n4(t).result;
}
function n4(e7) {
  var _a;
  if (e7.graphic && "graphics" !== ((_a = e7.graphic.layer) == null ? void 0 : _a.type))
    return { result: P2.GRAPHICS_LAYER_MISSING };
  if (!e7.operations)
    return { result: P2.GEOMETRY_MISSING };
  if (f(e7.elevationInfo))
    return { result: P2.ELEVATION_MODE_UNSUPPORTED };
  const o2 = e7.operations.data.type, n6 = e7.operations.data.geometry;
  return "point" === o2 || "mesh" === o2 || "polyline" === o2 || "polygon" === o2 ? { result: P2.SUPPORTED, geometry: n6 } : { result: P2.GEOMETRY_TYPE_UNSUPPORTED };
}

// node_modules/@arcgis/core/views/3d/interactive/editingTools/transform/isSupportedGraphic.js
function r3(r4) {
  var _a;
  if ("graphics" !== ((_a = r4.layer) == null ? void 0 : _a.type))
    return P2.GRAPHICS_LAYER_MISSING;
  if (null == r4.geometry)
    return P2.GEOMETRY_MISSING;
  switch (r4.geometry.type) {
    case "point":
      break;
    case "polygon":
    case "polyline":
    case "multipoint":
    case "extent":
    case "mesh":
      return P2.SUPPORTED;
    default:
      return P2.GEOMETRY_TYPE_UNSUPPORTED;
  }
  const s4 = null != r4.symbol && "point-3d" === r4.symbol.type && r4.symbol.symbolLayers;
  if (!s4 || !s4.some((e7) => "object" === e7.type))
    return P2.SYMBOL_TYPE_UNSUPPORTED;
  return "on-the-ground" !== s3(r4) && c2(r4) ? P2.ELEVATION_MODE_UNSUPPORTED : P2.SUPPORTED;
}

// node_modules/@arcgis/core/widgets/Sketch/support/OperationHandle.js
var n5 = class extends o.EventedAccessor {
  constructor(e7) {
    super(e7), this.cancelled = false, this.history = { undo: [], redo: [] }, this.type = null;
  }
  get tool() {
    if (!this.activeComponent)
      return null;
    switch (this.activeComponent.type) {
      case "graphic-mover":
      case "move-3d":
        return "move";
      case "box":
      case "transform-3d":
        return "transform";
      case "reshape":
      case "reshape-3d":
        return "reshape";
      case "draw-2d":
      case "draw-3d":
        return this.activeComponent.geometryType;
      default:
        n2(this.activeComponent);
    }
    return null;
  }
  addToHistory(e7) {
    this.history.redo = [], this.history.undo.push(e7);
  }
  resetHistory() {
    this.history.redo = [], this.history.undo = [];
  }
  canUndo() {
    return this.history.undo.length > 0;
  }
  canRedo() {
    return this.history.redo.length > 0;
  }
  complete() {
    this._reset(), this.onEnd(), this.emit("complete");
  }
  cancel() {
    this.cancelled = true, this.complete();
  }
  _reset() {
    var _a;
    (_a = this.activeComponent) == null ? void 0 : _a.reset();
  }
  refreshComponent() {
    const e7 = this.activeComponent;
    e7 && ("box" !== e7.type && "reshape" !== e7.type && "graphic-mover" !== e7.type || e7.refresh());
  }
  set undo(e7) {
    this._set("undo", () => {
      this.canUndo() && e7();
    });
  }
  set redo(e7) {
    this._set("redo", () => {
      this.canRedo() && e7();
    });
  }
};
e([y()], n5.prototype, "activeComponent", void 0), e([y()], n5.prototype, "cancelled", void 0), e([y()], n5.prototype, "history", void 0), e([y()], n5.prototype, "tool", null), e([y()], n5.prototype, "type", void 0), e([y()], n5.prototype, "canUndo", null), e([y()], n5.prototype, "canRedo", null), e([y()], n5.prototype, "onEnd", void 0), e([y()], n5.prototype, "undo", null), e([y()], n5.prototype, "redo", null), e([y()], n5.prototype, "toggleTool", void 0), e([y()], n5.prototype, "addToSelection", void 0), e([y()], n5.prototype, "removeFromSelection", void 0), n5 = e([a("esri.widgets.Sketch.support.OperationHandle")], n5);
var p4 = class extends n5 {
};
e([y()], p4.prototype, "activeComponent", void 0), p4 = e([a("esri.widgets.Sketch.support.OperationHandle.CreateOperationHandle")], p4);
var i = class extends n5 {
};
e([y()], i.prototype, "activeComponent", void 0), i = e([a("esri.widgets.Sketch.support.OperationHandle.UpdateOperationHandle")], i);

// node_modules/@arcgis/core/widgets/Sketch/SketchViewModel.js
var J = { defaultZ: 0 };
var Q = { reshapeOptions: { edgeOperation: "split", shapeOperation: "move", vertexOperation: "move" }, enableMoveAllGraphics: true, enableRotation: true, enableScaling: true, multipleSelectionEnabled: true, preserveAspectRatio: false, toggleToolOnClick: true, enableZ: true, highlightOptions: { enabled: true }, tool: "transform" };
var X = class extends o.EventedAccessor {
  constructor(e7) {
    var _a;
    super(e7), this._numUpdating = 0, this._defaultSnappingManager = null, this._internalGraphicsLayer = new h4({ listMode: "hide", internal: true, title: "SVM Internal" }), this._operationHandle = null, this._viewHandlesKey = "viewHandles", this.activeFillSymbol = null, this.activeLineSymbol = null, this.activeVertexSymbol = null, this.allowDeleteKey = true, this.layer = null, this.pointSymbol = new y2({ style: "circle", size: 6, color: [255, 255, 255], outline: { color: [50, 50, 50], width: 1 } }), this.polygonSymbol = new S({ color: [150, 150, 150, 0.2], outline: { color: [50, 50, 50], width: 2 } }), this.polylineSymbol = new d2({ color: [130, 130, 130, 1], width: 2 }), this.meshSymbol = new c({ symbolLayers: new V([new h2()]) }), this.updateGraphics = new V(), this.updateOnGraphicClick = true, this.vertexSymbol = new y2({ style: "circle", size: 6, color: [255, 255, 255], outline: { color: [50, 50, 50], width: 1 } }), this.sketchOptions = new l(), this._moduleLoaderAbortController = null, this._viewReadyAbortController = null, this._originalPopupEnabled = null, this.defaultCreateOptions = J, this.defaultUpdateOptions = Q, this.snappingOptions = ((_a = e7 == null ? void 0 : e7.snappingManager) == null ? void 0 : _a.options) ?? (e7 == null ? void 0 : e7.snappingOptions) ?? new u3();
  }
  initialize() {
    this.addHandles([v(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.map) == null ? void 0 : _b.layers;
    }, "change", (e7) => {
      e7.removed.includes(this.layer) && this.cancel();
    }), v(() => {
      var _a;
      return (_a = this.layer) == null ? void 0 : _a.graphics;
    }, "change", (e7) => {
      if (null != this._operationHandle)
        for (const t of e7.removed)
          this.updateGraphics.includes(t) && (this.updateGraphics.length > 1 ? this._operationHandle.removeFromSelection(t) : this._operationHandle.cancel());
    }), d(() => {
      var _a;
      return ((_a = this.layer) == null ? void 0 : _a.elevationInfo) ?? null;
    }, (e7) => {
      e7 !== this._internalGraphicsLayer.elevationInfo && (this.cancel(), this._internalGraphicsLayer.elevationInfo = e7);
    }, A), d(() => this.view, (e7) => {
      this._defaultSnappingManager = u(this._defaultSnappingManager), e7 && (this.snappingManager || (this._defaultSnappingManager = new q({ view: e7, options: this.snappingOptions })), "2d" === e7.type ? import("./editingTools-BZ74ALSO.js") : "3d" === e7.type && (import("./editingTools-QRJGL4QH.js"), import("./GraphicsLayerView3D-TPDTNDCM.js")));
    }, A), d(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.spatialReference;
    }, (e7, t) => {
      e7 && t && !e7.equals(t) && this.cancel();
    })]), N(this);
  }
  destroy() {
    this.cancel(), this._removeDefaultLayer(), this._defaultSnappingManager = u(this._defaultSnappingManager), this._set("snappingManager", null), this._set("view", null), this.emit("destroy");
  }
  get _defaultUpdateTool() {
    var _a;
    return "3d" === ((_a = this.view) == null ? void 0 : _a.type) ? "move" : "transform";
  }
  get updating() {
    return this._numUpdating > 0 || null != this.snappingManager && this.snappingManager.updating;
  }
  get activeTool() {
    var _a;
    return ((_a = this._operationHandle) == null ? void 0 : _a.tool) ?? null;
  }
  get activeComponent() {
    var _a;
    return ((_a = this._operationHandle) == null ? void 0 : _a.activeComponent) ?? null;
  }
  get createGraphic() {
    return null == this.activeComponent || "draw-3d" !== this.activeComponent.type && "draw-2d" !== this.activeComponent.type ? this._get("createGraphic") : this.activeComponent.graphic;
  }
  get defaultCreateOptions() {
    return this._get("defaultCreateOptions");
  }
  set defaultCreateOptions(e7) {
    this._set("defaultCreateOptions", { ...J, ...e7 });
  }
  get defaultUpdateOptions() {
    return this._get("defaultUpdateOptions");
  }
  set defaultUpdateOptions(e7) {
    this._set("defaultUpdateOptions", { ...Q, ...e7, reshapeOptions: { ...Q.reshapeOptions, ...e7 == null ? void 0 : e7.reshapeOptions }, highlightOptions: { ...Q.highlightOptions, ...e7 == null ? void 0 : e7.highlightOptions } });
  }
  get labelOptions() {
    return this.sketchOptions.labels;
  }
  set labelOptions(e7) {
    this.sketchOptions.labels = e7;
  }
  get snappingOptions() {
    var _a;
    return ((_a = this.snappingManager) == null ? void 0 : _a.options) ?? this._get("snappingOptions");
  }
  set snappingOptions(e7) {
    null != this._defaultSnappingManager && (this._defaultSnappingManager.options = e7), this._set("snappingOptions", e7);
  }
  get snappingManager() {
    return this._isOverridden("snappingManager") && this._get("snappingManager"), this._defaultSnappingManager;
  }
  set snappingManager(e7) {
    if (e7)
      this._isOverridden("snappingManager") || (this._defaultSnappingManager = u(this._defaultSnappingManager)), this._override("snappingManager", e7);
    else {
      const { view: e8 } = this;
      !this._defaultSnappingManager && e8 && (this._defaultSnappingManager = new q({ options: this.snappingOptions, view: e8 })), this._clearOverride("snappingManager");
    }
  }
  get state() {
    var _a;
    const e7 = !(!((_a = this.view) == null ? void 0 : _a.ready) || !this.layer), t = this._operationHandle;
    return e7 && t ? "active" : e7 ? "ready" : "disabled";
  }
  get tooltipOptions() {
    return this.sketchOptions.tooltips;
  }
  set tooltipOptions(e7) {
    this.sketchOptions.tooltips = e7;
  }
  get valueOptions() {
    return this.sketchOptions.values;
  }
  set valueOptions(e7) {
    this.sketchOptions.values = e7;
  }
  get view() {
    return this._get("view");
  }
  set view(e7) {
    const t = this._get("view");
    if (t) {
      const { container: e8, map: o3 } = t;
      e8 && (t.cursor = null), o3 == null ? void 0 : o3.remove(this._internalGraphicsLayer), this.removeHandles(this._viewHandlesKey), this.cancel();
    }
    const o2 = "view-ready";
    this.removeHandles(o2), e7 && this.addHandles(p(() => e7.ready, (t2) => {
      this.removeHandles(this._viewHandlesKey), t2 && this.addHandles(this._generateViewHandles(e7), this._viewHandlesKey);
    }, A), o2), this._set("view", e7);
  }
  cancel() {
    this._moduleLoaderAbortController = e2(this._moduleLoaderAbortController), this._viewReadyAbortController = e2(this._viewReadyAbortController), this._operationHandle && this._operationHandle.cancel();
  }
  complete() {
    this._operationHandle && this._operationHandle.complete();
  }
  delete() {
    const { state: e7, updateGraphics: t } = this;
    if ("active" === e7 && t.length) {
      const { activeTool: e8, layer: o2 } = this, i2 = t.toArray();
      o2.removeMany(i2), this.cancel(), this._emitDeleteEvent({ graphics: i2, tool: e8 });
    }
  }
  duplicate() {
    if ("active" === this.state && this.updateGraphics.length) {
      const e7 = this.updateGraphics.map((e8) => e8.clone()).toArray();
      return this.layer.addMany(e7), this.emit("duplicate", { graphics: e7, type: "duplicate" }), e7;
    }
    return [];
  }
  async create(e7, t) {
    this.cancel(), await this._waitViewReady();
    const { view: o2, layer: i2 } = this;
    if (!o2 || "disabled" === this.state)
      throw i2 || this._logMissingLayer(), u2();
    if (null != o2.activeTool && (o2.activeTool = null), !e7)
      return void this._logError("sketch:missing-parameter", "Missing parameter 'tool'.");
    e5(o2, this._internalGraphicsLayer);
    const a5 = await this._setupCreateOperation(e7, t);
    if (null == a5 || this.destroyed)
      return void o2.map.remove(this._internalGraphicsLayer);
    const r4 = () => {
      var _a;
      if (a5 === this._operationHandle) {
        const t2 = this.createGraphic, o3 = this._operationHandle.cancelled;
        this._operationHandle.destroy(), this._operationHandle = null, this._set("createGraphic", null), ((_a = this.view) == null ? void 0 : _a.map) && this.view.map.remove(this._internalGraphicsLayer), a5.cancelled || null == t2 || i2.add(t2), this.emit("create", { graphic: t2, state: o3 ? "cancel" : "complete", tool: e7, toolEventInfo: null, type: "create" });
      }
    };
    a5.on("complete", r4), this._operationHandle = a5, o2.ready && o2.focus();
  }
  async place(e7, t) {
    return this.create("mesh", { mode: "click", hasZ: e7.hasZ, geometryToPlace: e7, ...t });
  }
  async update(e7, t) {
    this.cancel(), await this._waitViewReady();
    const { layer: o2, view: i2, state: a5 } = this;
    if (!i2 || "disabled" === a5)
      throw o2 || this._logMissingLayer(), u2();
    null != i2.activeTool && (i2.activeTool = null);
    const r4 = Array.isArray(e7) ? e7 : [e7];
    if (null == e7 || !(r4 == null ? void 0 : r4.length))
      return void this._logError("sketch:missing-parameter", "Missing parameter 'graphics'.");
    if (r4.some((e8) => e8.layer !== o2 ? (this._logError("sketch:invalid-parameter", "Parameter 'graphics' contains one or more graphics missing from the supplied GraphicsLayer."), true) : null == e8.geometry && (this._logError("sketch:invalid-parameter", "Parameter 'graphics' contains one or more graphics with an unsupported geometry."), true)))
      return;
    const s4 = await this._setupUpdateOperation(r4, t);
    this.destroyed || null == s4 || ne(s4) || (e5(i2, this._internalGraphicsLayer), this._setUpdateOperationHandle(s4, t), this.emit("update", { graphics: r4, state: "start", aborted: false, tool: s4.tool, toolEventInfo: null, type: "update" }));
  }
  async _updateSpatialReference(e7) {
    const t = this.view;
    if (t) {
      this._beginAsyncOperation(), e7 = Array.isArray(e7) ? e7 : [e7];
      for (const o2 of e7)
        null == o2.geometry || "mesh" === o2.geometry.type || G(o2.geometry.spatialReference, t.spatialReference) || (F(o2.geometry.spatialReference, t.spatialReference) || b() || await k(), o2.geometry = B(o2.geometry, t.spatialReference));
      this._endAsyncOperation();
    } else
      this._logMissingView();
  }
  undo() {
    var _a;
    this.canUndo() && ((_a = this._operationHandle) == null ? void 0 : _a.undo());
  }
  redo() {
    var _a;
    this.canRedo() && ((_a = this._operationHandle) == null ? void 0 : _a.redo());
  }
  canUndo() {
    return !(!this._operationHandle || !this._operationHandle.canUndo());
  }
  canRedo() {
    return !(!this._operationHandle || !this._operationHandle.canRedo());
  }
  toggleUpdateTool() {
    this._operationHandle && this._operationHandle.toggleTool && this._operationHandle.toggleTool();
  }
  async _getFirstHit(e7) {
    const t = this.view;
    if (!t)
      return this._logMissingView(), null;
    if ("2d" === t.type) {
      const o3 = [];
      t.map.allLayers.forEach((e8) => {
        "vector-tile" !== e8.type && "imagery" !== e8.type || o3.push(e8);
      });
      const i3 = await t.hitTest(e7, { exclude: o3 });
      return r2(i3.results);
    }
    const o2 = [t.map.ground];
    t.map.allLayers.forEach((e8) => {
      m(e8.type) && o2.push(e8);
    });
    const i2 = await t.hitTest(e7, { exclude: o2 });
    if (i2.results.length > 0) {
      const e8 = i2.results[0];
      if (null != e8 && "graphic" === e8.type && e8.graphic && (!i2.ground.mapPoint || t.map.ground.opacity < 1 || i2.ground.distance - (e8.distance ?? 0) > -Math.min(3 * i2.ground.distance, "global" === t.viewingMode ? s2(t.renderCoordsHelper.spatialReference).radius / t.renderCoordsHelper.unitInMeters : Number.POSITIVE_INFINITY)))
        return e8;
    }
    return null;
  }
  _generateViewHandles(e7) {
    return [e7.on("immediate-click", async (t) => {
      var _a;
      const o2 = "active" === this.state && "create" === ((_a = this._operationHandle) == null ? void 0 : _a.type);
      if ("disabled" === this.state || o2 || !this.updateOnGraphicClick)
        return;
      this._beginAsyncOperation();
      const i2 = await t.async(() => this._getFirstHit(n3(t)));
      let a5 = null;
      if (null != i2) {
        const o3 = i2.graphic;
        this.updateGraphics.includes(o3) || o3.layer === this.layer ? (t.stopPropagation(), a5 = o3) : "2d" !== e7.type || this._isComponentGraphic(o3) || "active" !== this.state || this.cancel();
      } else
        "active" === this.state && this.cancel();
      null == a5 || this.updateGraphics.includes(a5) || await this.update([a5], { ...this.defaultUpdateOptions, reshapeOptions: { ...this.defaultUpdateOptions.reshapeOptions } }), this._endAsyncOperation();
    }, _.WIDGET)];
  }
  async _setupCreateOperation(e7, t) {
    const o2 = this.view;
    if (!o2)
      return this._logMissingView(), null;
    const i2 = { hasZ: "3d" === o2.type, ...this.defaultCreateOptions, ...t }, a5 = await this._setupDrawGraphicTool(e7, o2, i2);
    return null == a5 ? null : (o2.tools.add(a5), o2.activeTool = a5, this._setupCreateOperationHandle(a5));
  }
  async _setupDrawGraphicTool(e7, t, o2) {
    if ("multipoint" === e7 && "3d" === t.type)
      return this._logError("sketch:create", "Multipoint geometries are not supported in SceneView."), null;
    if (!t)
      return this._logMissingView(), null;
    const { cursor: i2, defaultZ: a5, hasZ: r4, geometryToPlace: s4, graphicProperties: n6, mode: p5, preserveAspectRatio: l3 } = o2, h5 = "rectangle" === e7 || "circle" === e7 ? "hybrid" : "click", c4 = l3 ?? "rectangle" !== e7, d3 = { centered: "rectangle" !== e7 && !("circle" === e7 && !c4), cursor: i2, defaultZ: a5, forceUniformSize: c4, graphicProperties: n6, geometryToPlace: s4, geometryType: e7, graphicSymbol: this._getGraphicSymbolFromTool(e7), hasZ: r4, mode: p5 ?? h5, snappingManager: this.snappingManager, snapToScene: false, view: t };
    return "2d" === t.type ? this._makeDrawGraphicTool2D(d3) : this._makeDrawGraphicTool3D(d3);
  }
  async _makeDrawGraphicTool2D(e7) {
    const t = await this._requireModule(import("./editingTools-BZ74ALSO.js"));
    return ne(t) || this.destroyed ? null : new t.module.DrawGraphicTool2D({ ...e7, activeVertexSymbol: this.activeVertexSymbol, regularVerticesSymbol: this.vertexSymbol, activeLineSymbol: this.activeLineSymbol, activeFillSymbol: oe(e7.geometryType) ? this.activeFillSymbol : null, sketchOptions: this.sketchOptions });
  }
  async _makeDrawGraphicTool3D(e7) {
    const t = await this._requireModule(import("./editingTools-QRJGL4QH.js"));
    if (ne(t) || this.destroyed)
      return null;
    const { elevationInfo: o2 } = this.layer;
    return new t.module.DrawGraphicTool3D({ ...e7, elevationInfo: o2, snapToScene: true, sketchOptions: this.sketchOptions });
  }
  _setupCreateOperationHandle(e7) {
    const t = this.view;
    if (!t)
      return this._logMissingView(), null;
    let o2 = null;
    const i2 = e7.forceUniformSize, a5 = e7.centered, r4 = [t.on("key-down", (t2) => {
      if (t2.key === p2.pan)
        t2.stopPropagation(), t2.repeat || (e7.enabled = false);
      else if (t2.key === p2.complete)
        t2.stopPropagation(), e7.completeCreateOperation();
      else if (t2.key !== p2.vertexAdd || t2.repeat)
        t2.key === p2.undo ? (t2.stopPropagation(), s4.undo()) : t2.key === p2.redo ? (t2.stopPropagation(), s4.redo()) : t2.key !== p2.constraint || "rectangle" !== e7.geometryType && "circle" !== e7.geometryType || t2.repeat ? t2.key === p2.center && (t2.repeat || (e7.centered = !a5, t2.stopPropagation())) : (e7.forceUniformSize = !i2, t2.stopPropagation());
      else {
        const o3 = e7.drawOperation.geometryType;
        "polyline" !== o3 && "polygon" !== o3 && "multipoint" !== o3 || (t2.stopPropagation(), e7.drawOperation.commitStagedVertex());
      }
    }, _.WIDGET), t.on("key-up", (t2) => {
      t2.key === p2.pan ? e7.enabled = true : t2.key !== p2.constraint || "rectangle" !== e7.geometryType && "circle" !== e7.geometryType ? t2.key === p2.center && (e7.centered = a5, t2.stopPropagation()) : (e7.forceUniformSize = i2, t2.stopPropagation());
    }, _.WIDGET), e7.on("vertex-add", (t2) => {
      switch (o2 = null == o2 ? "start" : "active", t2.operation) {
        case "apply":
          this.emit("create", { graphic: e7.graphic, state: o2, tool: this.activeTool, toolEventInfo: t2, type: "create" });
          break;
        case "undo":
          this._emitUndoEvent({ graphics: [e7.graphic], tool: e7.geometryType });
          break;
        case "redo":
          this._emitRedoEvent({ graphics: [e7.graphic], tool: e7.geometryType });
      }
    }), e7.on("cursor-update", (t2) => {
      e7.drawOperation.numCommittedVertices > 0 && this.emit("create", { graphic: e7.graphic, state: "active", tool: this.activeTool, toolEventInfo: { coordinates: t2.vertices[0].coordinates, type: "cursor-update" }, type: "create" });
    }), e7.on("vertex-remove", (t2) => {
      switch (t2.operation) {
        case "apply":
          this.emit("create", { graphic: e7.graphic, state: "active", tool: this.activeTool, toolEventInfo: t2, type: "create" });
          break;
        case "undo":
          this._emitUndoEvent({ graphics: [e7.graphic], tool: e7.geometryType });
          break;
        case "redo":
          this._emitRedoEvent({ graphics: [e7.graphic], tool: e7.geometryType });
      }
    }), e7.on("complete", (e8) => {
      this._set("createGraphic", e8.graphic), o2 = "complete", e8.aborted ? s4 && s4.cancel() : s4 && s4.complete();
    }), d(() => this._getGraphicSymbolFromTool(e7.geometryType), (t2) => {
      e7.graphicSymbol = t2;
    })], s4 = new p4({ activeComponent: e7, tool: e7.geometryType, type: "create", onEnd: () => {
      var _a;
      r4.forEach((e8) => e8.remove()), r4.length = 0, (_a = t.tools) == null ? void 0 : _a.remove(e7);
    }, undo: () => {
      e7.canUndo && e7.undo();
    }, redo: () => {
      e7.canRedo && e7.redo();
    }, canUndo: () => e7.canUndo, canRedo: () => e7.canRedo });
    return s4;
  }
  _getGraphicSymbolFromTool(e7) {
    switch (e7) {
      case "point":
      case "multipoint":
        return this.pointSymbol;
      case "polyline":
        return this.polylineSymbol;
      case "circle":
      case "rectangle":
      case "polygon":
        return this.polygonSymbol;
      case "mesh":
        return this.meshSymbol;
    }
  }
  async _setupUpdateOperation(e7, t) {
    var _a;
    const { layer: o2, view: i2 } = this;
    if (!i2)
      return this._logMissingView(), null;
    const a5 = { tool: this._defaultUpdateTool, ...this.defaultUpdateOptions, ...t, reshapeOptions: { ...this.defaultUpdateOptions.reshapeOptions, ...t == null ? void 0 : t.reshapeOptions }, highlightOptions: { ...this.defaultUpdateOptions.highlightOptions, ...t == null ? void 0 : t.highlightOptions } };
    let r4 = a5.tool;
    for (const s4 of e7)
      o2.remove(s4), o2.add(s4);
    if ("3d" === i2.type) {
      if (0 === e7.length)
        return null;
      switch (r4) {
        case "move":
          return this._setupMove3DOperation(e7, a5, i2, r4);
        case "reshape": {
          if (e7.length > 1)
            return this._logError("sketch:reshape-multiple", "Reshape operation does not support multiple graphics."), null;
          const t2 = new l2({ view: i2, graphic: e7[0] }), o3 = e6(t2);
          return o3 === P2.SUPPORTED ? this._setupReshape3DOperation(t2, a5, i2) : (t2.destroy(), this._logError("sketch:reshape", `Reshape operation not supported for provided graphic(s) (${E2(o3)}).`), null);
        }
        case "transform":
          return this._setupGraphicTransform3DOperation(e7, a5, i2);
      }
    }
    switch (r4) {
      case "move":
        return this._setupMove2DOperation(e7, a5, i2);
      case "reshape":
        return e7.length > 1 ? (this._logError("sketch:reshape-multiple", "Reshape operation does not support multiple graphics."), null) : this._setupTransformOrReshape2DOperation(e7, r4, a5, i2);
      case "transform":
        if (1 === e7.length) {
          const t2 = (_a = e7[0].geometry) == null ? void 0 : _a.type;
          "point" !== t2 && "multipoint" !== t2 || (r4 = "reshape");
        }
        return this._setupTransformOrReshape2DOperation(e7, r4, a5, i2);
    }
  }
  async _setupMove3DOperation(e7, t, o2, i2, a5 = false) {
    const r4 = /* @__PURE__ */ new Map(), s4 = () => {
      r4.forEach((e8) => e8.destroy()), r4.clear();
    };
    for (const c4 of e7) {
      const e8 = new l2({ view: o2, graphic: c4 }), t2 = r(e8);
      if (t2 !== P2.SUPPORTED)
        return s4(), this._logError("sketch:move", `Move operation not supported for provided graphic(s) (${E2(t2)}).`), null;
      r4.set(c4, e8);
    }
    const n6 = await this._requireModule(import("./editingTools-QRJGL4QH.js"));
    if (ne(n6))
      return s4(), n6;
    const p5 = new n6.module.MoveTool3D({ view: o2, enableZ: t.enableZ, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions });
    o2.tools.add(p5), p5.objects.addMany(Array.from(r4.values())), a5 || this.updateGraphics.addMany(e7);
    const l3 = [], h5 = new i({ activeComponent: p5, tool: i2, type: "update", onEnd: () => {
      var _a;
      l3.forEach((e8) => e8.remove()), l3.length = 0, (_a = o2.tools) == null ? void 0 : _a.remove(p5), p5.destroyed || p5.destroy(), s4();
    }, undo: () => {
      ie(h5, this.updateGraphics.toArray()), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: i2 });
    }, redo: () => {
      ae(h5, this.updateGraphics.toArray()), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: i2 });
    }, addToSelection: (e8) => {
      this.updateGraphics.push(e8);
      const t2 = new l2({ view: o2, graphic: e8 });
      r4.set(e8, t2), p5.objects.push(t2), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e8], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: (e8) => {
      const t2 = this.updateGraphics.indexOf(e8);
      if (h5.history.undo.forEach((e9) => e9.updates.splice(t2, 1)), h5.history.redo.forEach((e9) => e9.updates.splice(t2, 1)), this.updateGraphics.remove(e8), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e8], type: "selection-change" }, type: "update" }), 0 === this.updateGraphics.length)
        return void h5.complete();
      const o3 = r4.get(e8);
      o3 && (p5.objects.remove(o3), o3.destroy(), r4.delete(e8));
    }, toggleTool: async () => {
      if (1 !== this.updateGraphics.length || false === t.toggleToolOnClick)
        return;
      if ("transform" !== i2)
        return;
      const e8 = this.updateGraphics.at(0), a6 = new l2({ view: o2, graphic: e8 });
      if (e6(a6) !== P2.SUPPORTED)
        return void a6.destroy();
      h5.onEnd(), h5.destroy();
      const r5 = await this._setupReshape3DOperation(a6, t, o2, true);
      ne(r5) || this._setUpdateOperationHandle(r5, t);
    } });
    return l3.push(...this._getHandlesForComponent(h5, t), o2.on("immediate-click", (e8) => this._getCommonUpdateOperationClickHandlers(h5, e8, t), _.WIDGET), o2.on("key-down", (e8) => {
      this._getCommonUpdateOperationKeyDownHandlers(h5, e8);
    }, _.WIDGET)), h5;
  }
  _setupGraphicTransform3DOperation(e7, t, o2, i2 = false) {
    if (1 === e7.length && r3(e7[0]) === P2.SUPPORTED) {
      const a5 = e7[0], r4 = a5.geometry;
      if (null != r4 && ("point" === r4.type || "mesh" === r4.type))
        return this._setupPointTransform3DOperation(a5, t, o2);
      if (null != r4 && ("polygon" === r4.type || "polyline" === r4.type))
        return this._setupPolyTransform3DOperation(a5, t, o2, i2);
    }
    return this._setupMove3DOperation(e7, t, o2, "transform", i2);
  }
  async _setupPointTransform3DOperation(e7, t, o2) {
    const i2 = "transform", { enableRotation: a5, enableScaling: r4, enableZ: s4 } = t, n6 = await this._requireModule(import("./editingTools-QRJGL4QH.js"));
    if (ne(n6))
      return n6;
    const p5 = new l2({ graphic: e7, view: o2 }), l3 = new n6.module.TransformTool3D({ object: p5, view: o2, enableRotation: a5, enableScaling: r4, enableZ: s4, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions });
    o2.tools.add(l3), this.updateGraphics.add(e7);
    const h5 = [], c4 = new i({ activeComponent: l3, tool: i2, type: "update", onEnd: () => {
      var _a;
      h5.forEach((e8) => e8.remove()), h5.length = 0, (_a = o2.tools) == null ? void 0 : _a.remove(l3), l3.destroyed || l3.destroy(), p5.destroy();
    }, undo: () => {
      ie(c4, this.updateGraphics.toArray()), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: i2 });
    }, redo: () => {
      ae(c4, this.updateGraphics.toArray()), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: i2 });
    }, addToSelection: async (e8) => {
      this.updateGraphics.add(e8), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e8], removed: [], type: "selection-change" }, type: "update" }), c4.onEnd(), c4.destroy();
      const i3 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t, o2, "transform", true);
      ne(i3) || this._setUpdateOperationHandle(i3, t);
    }, removeFromSelection: (e8) => {
      this.updateGraphics.remove(e8), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e8], type: "selection-change" }, type: "update" }), c4.complete();
    }, toggleTool: () => {
    } });
    return h5.push(...this._getHandlesForComponent(c4, t), o2.on("immediate-click", (e8) => this._getCommonUpdateOperationClickHandlers(c4, e8, t), _.WIDGET), o2.on("key-down", (e8) => {
      this._getCommonUpdateOperationKeyDownHandlers(c4, e8);
    }, _.WIDGET)), c4;
  }
  async _setupPolyTransform3DOperation(e7, t, o2, i2 = false) {
    var _a, _b;
    const a5 = "transform", { enableRotation: r4, enableScaling: s4, enableZ: n6, preserveAspectRatio: p5 } = t, l3 = await this._requireModule(import("./editingTools-QRJGL4QH.js"));
    if (ne(l3))
      return l3;
    const h5 = (_b = (_a = this.view) == null ? void 0 : _a.inputManager) == null ? void 0 : _b.isModifierKeyDown(p2.constraint), c4 = new l2({ view: o2, graphic: e7 }), d3 = new l3.module.ExtentTransformTool({ object: c4, view: o2, enableRotation: r4, enableScaling: s4, enableZ: n6, preserveAspectRatio: !!p5 != !!h5, sketchOptions: this.sketchOptions });
    o2.tools.add(d3), i2 || this.updateGraphics.add(e7);
    const u4 = [], y3 = new i({ activeComponent: d3, tool: a5, type: "update", onEnd: () => {
      var _a2;
      u4.forEach((e8) => e8.remove()), u4.length = 0, (_a2 = o2.tools) == null ? void 0 : _a2.remove(d3), d3.destroyed || d3.destroy(), c4.destroy();
    }, canUndo: () => d3.canUndo, undo: () => {
      d3.undo(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: a5 });
    }, canRedo: () => d3.canRedo, redo: () => {
      d3.redo(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: a5 });
    }, addToSelection: async (e8) => {
      this.updateGraphics.add(e8), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e8], removed: [], type: "selection-change" }, type: "update" }), y3.onEnd(), y3.destroy();
      const i3 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t, o2, "transform", true);
      ne(i3) || this._setUpdateOperationHandle(i3, t);
    }, removeFromSelection: (e8) => {
      this.updateGraphics.remove(e8), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e8], type: "selection-change" }, type: "update" }), y3.complete();
    }, toggleTool: async () => {
      if (1 !== this.updateGraphics.length || false === t.toggleToolOnClick)
        return;
      const e8 = this.updateGraphics.at(0), i3 = new l2({ view: o2, graphic: e8 });
      if (e6(i3) !== P2.SUPPORTED)
        return void i3.destroy();
      y3.onEnd(), y3.destroy();
      const a6 = await this._setupReshape3DOperation(i3, t, o2, true);
      ne(a6) || this._setUpdateOperationHandle(a6, t);
    } });
    return u4.push(...this._getHandlesForComponent(y3, t), o2.on("immediate-click", (e8) => this._getCommonUpdateOperationClickHandlers(y3, e8, t), _.WIDGET), o2.on("key-down", (e8) => this._getCommonUpdateOperationKeyDownHandlers(y3, e8), _.WIDGET), o2.on("key-down", (e8) => {
      e8.key !== p2.constraint || e8.repeat || (d3.preserveAspectRatio = !d3.preserveAspectRatio, e8.stopPropagation());
    }, _.WIDGET), o2.on("key-up", (e8) => {
      e8.key === p2.constraint && (d3.preserveAspectRatio = !d3.preserveAspectRatio, e8.stopPropagation());
    }, _.WIDGET)), y3;
  }
  async _setupMove2DOperation(e7, t, o2) {
    const i2 = "move";
    this.updateGraphics.addMany(e7), await this._updateSpatialReference(e7);
    const a5 = await this._getGraphicMover(e7, t, o2);
    if (ne(a5))
      return a5;
    const r4 = new i({ activeComponent: a5, tool: i2, type: "update", onEnd: () => {
      var _a;
      this._displayDefaultCursor(), p5.forEach((e8) => e8.remove()), n6.forEach((e8) => e8.remove()), p5 = [], n6 = [], a5.destroy(), (_a = this._internalGraphicsLayer) == null ? void 0 : _a.removeMany([...this.updateGraphics.toArray()]);
    }, undo: () => {
      const e8 = this.updateGraphics.toArray();
      ie(r4, e8), r4.refreshComponent(), this._emitUndoEvent({ graphics: e8, tool: i2 });
    }, redo: () => {
      const e8 = this.updateGraphics.toArray();
      ae(r4, e8), r4.refreshComponent(), this._emitRedoEvent({ graphics: e8, tool: i2 });
    }, addToSelection: async (e8) => {
      await this._updateSpatialReference(e8), this.updateGraphics.push(e8), a5.graphics = this.updateGraphics.toArray(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e8], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: (e8) => {
      const t2 = this.updateGraphics.indexOf(e8);
      r4.history.undo.forEach((e9) => e9.updates.splice(t2, 1)), r4.history.redo.forEach((e9) => e9.updates.splice(t2, 1)), this.updateGraphics.remove(e8);
      const o3 = this.updateGraphics.toArray();
      this.emit("update", { graphics: o3, state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e8], type: "selection-change" }, type: "update" }), 0 !== this.updateGraphics.length ? a5.graphics = o3 : r4.complete();
    } });
    let s4 = false, n6 = [o2.on("immediate-click", (e8) => this._getCommonUpdateOperationClickHandlers(r4, e8, t), _.WIDGET), o2.on("key-down", (e8) => {
      this._getCommonUpdateOperationKeyDownHandlers(r4, e8), e8.key !== p2.constraint || e8.repeat || (s4 = true, a5.enableMoveAllGraphics = !a5.enableMoveAllGraphics);
    }, _.WIDGET), o2.on("key-up", (e8) => {
      e8.key === p2.constraint && s4 && (s4 = false, a5.enableMoveAllGraphics = !a5.enableMoveAllGraphics);
    }, _.WIDGET)], p5 = this._getHandlesForComponent(r4, t);
    return r4;
  }
  async _setupReshape3DOperation(e7, t, o2, i2 = false) {
    const a5 = "reshape", r4 = await this._requireModule(import("./editingTools-QRJGL4QH.js"));
    if (ne(r4))
      return r4;
    const s4 = t.reshapeOptions, n6 = new r4.module.ReshapeTool3D({ view: o2, object: e7, enableZVertex: t.enableZ && "move" === (s4 == null ? void 0 : s4.vertexOperation), enableZShape: t.enableZ && "move" === (s4 == null ? void 0 : s4.shapeOperation), enableMoveObject: "move" === (s4 == null ? void 0 : s4.shapeOperation) || "move-xy" === (s4 == null ? void 0 : s4.shapeOperation), enableMidpoints: "split" === (s4 == null ? void 0 : s4.edgeOperation), enableEdgeOffset: "offset" === (s4 == null ? void 0 : s4.edgeOperation), snappingManager: this.snappingManager, sketchOptions: this.sketchOptions });
    o2.tools.add(n6), i2 || this.updateGraphics.add(e7.graphic);
    const p5 = [], l3 = new i({ activeComponent: n6, tool: a5, type: "update", onEnd: () => {
      var _a;
      p5.forEach((e8) => e8.remove()), p5.length = 0, (_a = o2.tools) == null ? void 0 : _a.remove(n6), n6.destroyed || n6.destroy(), e7.destroy();
    }, canUndo: () => n6.canUndo, undo: () => {
      n6.undo(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: a5 });
    }, canRedo: () => n6.canRedo, redo: () => {
      n6.redo(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: a5 });
    }, addToSelection: async (e8) => {
      this.updateGraphics.add(e8), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e8], removed: [], type: "selection-change" }, type: "update" }), l3.onEnd(), l3.destroy();
      const i3 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t, o2, "transform", true);
      ne(i3) || this._setUpdateOperationHandle(i3, t);
    }, removeFromSelection: (e8) => {
      this.updateGraphics.remove(e8), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e8], type: "selection-change" }, type: "update" }), l3.complete();
    }, toggleTool: async () => {
      if (false === t.toggleToolOnClick)
        return;
      l3.onEnd(), l3.destroy();
      const e8 = await this._setupGraphicTransform3DOperation(this.updateGraphics.toArray(), t, o2, true);
      ne(e8) || this._setUpdateOperationHandle(e8, t);
    } });
    return p5.push(...this._getHandlesForComponent(l3, t), o2.on("immediate-click", (e8) => this._getCommonUpdateOperationClickHandlers(l3, e8, t), _.WIDGET), o2.on("key-down", (e8) => {
      this._getCommonUpdateOperationKeyDownHandlers(l3, e8);
    }, _.WIDGET)), l3;
  }
  async _setupTransformOrReshape2DOperation(e7, t, o2, i2) {
    this.updateGraphics.addMany(e7), await this._updateSpatialReference(e7);
    const a5 = "transform" === t ? await this._getBox(e7, o2, i2) : await this._getReshape(e7, o2, i2);
    if (ne(a5))
      return a5;
    const r4 = new i({ activeComponent: a5, type: "update", onEnd: () => {
      n6.forEach((e8) => e8.remove()), s4.forEach((e8) => e8.remove()), n6 = [], s4 = [], r4.activeComponent && !r4.activeComponent.destroyed && r4.activeComponent.destroy(), this._internalGraphicsLayer.removeMany(this.updateGraphics.toArray());
    }, undo: () => {
      ie(r4, this.updateGraphics.toArray()), r4.refreshComponent(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: r4.tool });
    }, redo: () => {
      ae(r4, this.updateGraphics.toArray()), r4.refreshComponent(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: r4.tool });
    }, addToSelection: async (e8) => {
      let t2 = r4.activeComponent;
      if ("reshape" === (t2 == null ? void 0 : t2.type)) {
        const t3 = [...this.updateGraphics, e8];
        this.updateGraphics.removeAll(), r4.onEnd(), r4.destroy();
        const a6 = await this._setupTransformOrReshape2DOperation(t3, "transform", o2, i2);
        if (ne(a6))
          return;
        this._setUpdateOperationHandle(a6, o2);
      } else
        this.updateGraphics.add(e8), t2.graphics = this.updateGraphics.toArray(), t2.refresh(), r4.resetHistory();
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e8], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: async (e8) => {
      const t2 = this.updateGraphics.indexOf(e8);
      r4.history.undo.forEach((e9) => e9.updates.splice(t2, 1)), r4.history.redo.forEach((e9) => e9.updates.splice(t2, 1)), this.updateGraphics.remove(e8);
      const o3 = this.updateGraphics.toArray();
      if (0 === o3.length)
        r4.complete();
      else {
        const e9 = o3[0].geometry;
        1 !== o3.length || null == e9 || "point" !== e9.type && "multipoint" !== e9.type ? r4.activeComponent.graphics = o3 : r4.toggleTool();
      }
      this.emit("update", { graphics: o3, state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e8], type: "selection-change" }, type: "update" });
    }, toggleTool: async () => {
      var _a;
      if (this.updateGraphics.length > 1)
        return;
      const e8 = this.updateGraphics.at(0), t2 = e8.geometry;
      if (null != t2 && ("reshape" === r4.tool && ("point" === t2.type || "multipoint" === t2.type) || "transform" === r4.tool && "extent" === t2.type))
        return;
      let a6 = null;
      "transform" === r4.tool ? a6 = await this._getReshape([e8], o2, i2) : "reshape" === r4.tool && (a6 = await this._getBox([e8], o2, i2)), ne(a6) || ((_a = r4.activeComponent) == null ? void 0 : _a.destroy(), r4.activeComponent = a6, r4.activeComponent && (n6.forEach((e9) => e9.remove()), n6 = this._getHandlesForComponent(r4, o2)));
    } });
    let s4 = [i2.on("immediate-click", (e8) => this._getCommonUpdateOperationClickHandlers(r4, e8, o2), _.WIDGET), i2.on("key-down", (e8) => {
      if (this._getCommonUpdateOperationKeyDownHandlers(r4, e8), e8.key === p2.constraint && !e8.repeat && r4) {
        const e9 = r4.activeComponent;
        e9 && "box" === e9.type && (e9.preserveAspectRatio = !e9.preserveAspectRatio);
      }
    }, _.WIDGET), i2.on("key-up", (e8) => {
      if (e8.key === p2.constraint && r4) {
        const e9 = r4.activeComponent;
        e9 && "box" === e9.type && (e9.preserveAspectRatio = !e9.preserveAspectRatio);
      }
    }, _.WIDGET)], n6 = this._getHandlesForComponent(r4, o2);
    return r4;
  }
  async _getGraphicMover(e7, t, o2) {
    const { enableMoveAllGraphics: i2, highlightOptions: a5 } = t, r4 = await this._requireModule(import("./GraphicMover-2X35TFZR.js"));
    return ne(r4) ? r4 : new r4.module.default({ enableMoveAllGraphics: i2, highlightsEnabled: !!(a5 == null ? void 0 : a5.enabled), indicatorsEnabled: false, graphics: e7, view: o2, callbacks: { onGraphicMoveStart: ({ dx: e8, dy: t2, graphic: o3 }) => {
      this._displayGrabbingCursor(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e8, dy: t2, mover: o3, type: "move-start" }, type: "update" });
    }, onGraphicMove: ({ dx: e8, dy: t2, graphic: o3 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e8, dy: t2, mover: o3, type: "move" }, type: "update" }), onGraphicMoveStop: ({ dx: e8, dy: t2, graphic: o3 }) => {
      this._displayPointerCursor(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e8, dy: t2, mover: o3, type: "move-stop" }, type: "update" });
    }, onGraphicPointerOver: () => this._displayPointerCursor(), onGraphicPointerOut: () => this._displayDefaultCursor() } });
  }
  async _getBox(e7, t, o2) {
    var _a, _b;
    const { enableRotation: i2, enableScaling: a5, highlightOptions: r4, preserveAspectRatio: s4 } = t, n6 = await this._requireModule(import("./Box-Q7ZSFDVV.js"));
    if (ne(n6))
      return n6;
    const p5 = (_b = (_a = this.view) == null ? void 0 : _a.inputManager) == null ? void 0 : _b.isModifierKeyDown(p2.constraint);
    return new n6.module.default({ graphics: e7, enableRotation: i2, enableScaling: a5, highlightsEnabled: !!(r4 == null ? void 0 : r4.enabled), preserveAspectRatio: !!s4 != !!p5, layer: this._internalGraphicsLayer, view: o2, sketchOptions: this.sketchOptions, callbacks: { onMoveStart: (e8) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8 }, type: "update" }), onMove: (e8) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8 }, type: "update" }), onMoveStop: (e8) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8 }, type: "update" }), onScaleStart: (e8) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8 }, type: "update" }), onScale: (e8) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8 }, type: "update" }), onScaleStop: (e8) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8 }, type: "update" }), onRotateStart: (e8) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8 }, type: "update" }), onRotate: (e8) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8 }, type: "update" }), onRotateStop: (e8) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8 }, type: "update" }) } });
  }
  async _getReshape(e7, t, o2) {
    var _a, _b, _c;
    const i2 = "split" === ((_a = t.reshapeOptions) == null ? void 0 : _a.edgeOperation), a5 = "move" === ((_b = t.reshapeOptions) == null ? void 0 : _b.shapeOperation), r4 = !!((_c = t.highlightOptions) == null ? void 0 : _c.enabled), s4 = await this._requireModule(import("./Reshape-JKVJ7HT7.js"));
    return ne(s4) ? s4 : new s4.module.default({ enableMidpoints: i2, enableMovement: a5, graphic: e7[0], highlightsEnabled: r4, layer: this._internalGraphicsLayer, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions, view: o2, callbacks: { onReshapeStart: (e8) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8 }, type: "update" }), onReshape: (e8) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8 }, type: "update" }), onReshapeStop: ({ mover: e8, type: t2 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e8, type: t2 }, type: "update" }), onMoveStart: ({ dx: e8, dy: t2, mover: o3, type: i3 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e8, dy: t2, mover: o3, type: i3 }, type: "update" }), onMove: ({ dx: e8, dy: t2, mover: o3, type: i3 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e8, dy: t2, mover: o3, type: i3 }, type: "update" }), onMoveStop: ({ dx: e8, dy: t2, mover: o3, type: i3 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e8, dy: t2, mover: o3, type: i3 }, type: "update" }), onVertexAdd: ({ added: e8, type: t2, vertices: o3 }) => {
      const i3 = e8.map((e9) => e3(e9.geometry));
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: i3, vertices: o3, type: t2 }, type: "update" });
    }, onVertexRemove: ({ removed: e8, type: t2, vertices: o3 }) => {
      const i3 = e8.map((e9) => e3(e9.geometry));
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { removed: i3, vertices: o3, type: t2 }, type: "update" });
    } } });
  }
  _getHandlesForComponent(e7, t) {
    const o2 = e7.activeComponent;
    if (!o2)
      return [];
    switch (o2.type) {
      case "graphic-mover":
        return [o2.on("graphic-click", ({ graphic: t2, viewEvent: o3 }) => {
          var _a;
          ((_a = o3.native) == null ? void 0 : _a.shiftKey) && (o3.stopPropagation(), e7.removeFromSelection(t2));
        }), o2.on("graphic-move-start", (t2) => e7.addToHistory(se(t2.allGraphics)))];
      case "box":
        return [o2.on("graphic-click", (o3) => this._onTransformOrReshape2DGraphicClick(e7, t, o3)), o2.on("move-start", (t2) => e7.addToHistory(se(t2.graphics))), o2.on("rotate-start", (t2) => e7.addToHistory(se(t2.graphics))), o2.on("scale-start", (t2) => e7.addToHistory(se(t2.graphics)))];
      case "reshape":
        return [o2.on("graphic-click", (o3) => this._onTransformOrReshape2DGraphicClick(e7, t, o3)), o2.on("move-start", (t2) => e7.addToHistory(se([t2.mover]))), o2.on("reshape-start", (t2) => e7.addToHistory(se([t2.graphic]))), o2.on("vertex-add", (t2) => e7.addToHistory(se([t2.oldGraphic]))), o2.on("vertex-remove", (t2) => e7.addToHistory(se([t2.oldGraphic])))];
      case "move-3d":
        return [o2.events.on("move-start", (t2) => {
          e7.addToHistory(se(t2.objects.map(({ graphic: e8 }) => e8))), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: 0, dy: 0, mover: t2.objects.length > 0 ? t2.objects[0].graphic : null, type: "move-start" }, type: "update" });
        }), o2.events.on("move", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e8.dx, dy: e8.dy, mover: e8.objects.length > 0 ? e8.objects[0].graphic : null, type: "move" }, type: "update" });
        }), o2.events.on("move-stop", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: 0, dy: 0, mover: e8.objects.length > 0 ? e8.objects[0].graphic : null, type: "move-stop" }, type: "update" });
        }), o2.events.on("immediate-click", (o3) => {
          o3.shiftKey ? this._toggleSelection([o3.object.graphic], e7, t) : e7.toggleTool();
        })];
      case "transform-3d":
        return [o2.events.on("record-undo", ({ record: t2 }) => {
          e7.addToHistory({ updates: [t2] });
        }), o2.events.on("translate-start", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e8.object.graphic, dx: e8.dxScreen, dy: e8.dyScreen, type: "move-start" }, type: "update" });
        }), o2.events.on("translate-stop", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e8.object.graphic, dx: e8.dxScreen, dy: e8.dyScreen, type: "move-stop" }, type: "update" });
        }), o2.events.on("rotate-start", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e8.object.graphic, angle: e8.angle, type: "rotate-start" }, type: "update" });
        }), o2.events.on("rotate-stop", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e8.object.graphic, angle: e8.angle, type: "rotate-stop" }, type: "update" });
        }), o2.events.on("scale-start", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e8.object.graphic, xScale: e8.xScale, yScale: e8.yScale, type: "scale-start" }, type: "update" });
        }), o2.events.on("scale-stop", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e8.object.graphic, xScale: e8.xScale, yScale: e8.yScale, type: "scale-stop" }, type: "update" });
        }), o2.events.on("translate", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e8.object.graphic, dx: e8.dxScreen, dy: e8.dyScreen, type: "move" }, type: "update" });
        }), o2.events.on("rotate", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e8.object.graphic, angle: e8.angle, type: "rotate" }, type: "update" });
        }), o2.events.on("scale", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e8.object.graphic, xScale: e8.xScale, yScale: e8.yScale, type: "scale" }, type: "update" });
        }), o2.events.on("immediate-click", (o3) => {
          o3.shiftKey ? this._toggleSelection([o3.object.graphic], e7, t) : e7.toggleTool();
        })];
      case "reshape-3d":
        return [o2.events.on("reshape", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8, mover: e8.object.graphic }, type: "update" });
        }), o2.events.on("move", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e8, mover: e8.object.graphic }, type: "update" });
        }), o2.events.on("vertex-add", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: e8, type: "update" });
        }), o2.events.on("vertex-remove", (e8) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: e8, type: "update" });
        }), o2.events.on("immediate-click", (o3) => {
          o3.shiftKey ? this._toggleSelection([o3.object.graphic], e7, t) : e7.toggleTool();
        })];
    }
  }
  _onTransformOrReshape2DGraphicClick(e7, t, o2) {
    var _a;
    const { graphic: i2, viewEvent: a5 } = o2;
    return ((_a = a5.native) == null ? void 0 : _a.shiftKey) && i2.layer === this.layer ? (a5.stopPropagation(), e7.removeFromSelection(i2)) : t.toggleToolOnClick ? (a5.stopPropagation(), e7.toggleTool()) : void 0;
  }
  _setUpdateOperationHandle(e7, t) {
    var _a;
    this._operationHandle = e7;
    const o2 = (_a = this.view) == null ? void 0 : _a.map;
    this._disablePopup(t);
    const i2 = () => {
      if (e7 === this._operationHandle) {
        const i3 = this.updateGraphics.toArray(), a5 = this._operationHandle.tool;
        this._operationHandle.destroy(), this._operationHandle = null, this._internalGraphicsLayer.removeMany(this.updateGraphics.toArray()), this.updateGraphics.removeAll(), o2 && o2.remove(this._internalGraphicsLayer), this._restorePopup(t), this.emit("update", { graphics: i3, state: "complete", aborted: e7.cancelled, tool: a5, toolEventInfo: null, type: "update" });
      }
    };
    e7.on("complete", i2);
  }
  async _getCommonUpdateOperationClickHandlers(e7, t, o2) {
    const i2 = n3(t), a5 = await t.async(() => this._getFirstHit(i2));
    if (null == a5)
      return void e7.complete();
    if (t.native.shiftKey && this._toggleSelection([a5.graphic], e7, o2))
      return void t.stopPropagation();
    this.updateGraphics.includes(a5.graphic) ? t.stopPropagation() : e7.complete();
  }
  _toggleSelection(e7, t, o2) {
    const i2 = !!o2.multipleSelectionEnabled;
    return e7.some((e8) => null != e8 && (!(!i2 || e8.layer !== this.layer) && (this.updateGraphics.includes(e8) ? t.removeFromSelection(e8) : t.addToSelection(e8), true)));
  }
  _getCommonUpdateOperationKeyDownHandlers(e7, t) {
    if (!e7)
      return;
    const o2 = t.key;
    o2 === p2.undo && e7.canUndo() ? (t.stopPropagation(), e7.undo()) : o2 === p2.redo && e7.canRedo() ? (t.stopPropagation(), e7.redo()) : o2 === p2.cancel ? (t.stopPropagation(), e7.cancel()) : this.allowDeleteKey && p2.delete.includes(o2) && this._onDeleteKey(t);
  }
  _onDeleteKey(e7) {
    var _a;
    if (!this._operationHandle || "update" !== this._operationHandle.type)
      return;
    const t = this.activeComponent, o2 = this.updateGraphics.toArray();
    null != t && "reshape-3d" !== t.type && ("reshape" !== t.type || 1 === o2.length && "point" === ((_a = o2[0].geometry) == null ? void 0 : _a.type)) && (e7.stopPropagation(), this.delete());
  }
  _removeDefaultLayer() {
    var _a, _b;
    this._internalGraphicsLayer && ((_b = (_a = this.view) == null ? void 0 : _a.map) == null ? void 0 : _b.remove(this._internalGraphicsLayer), this._internalGraphicsLayer = u(this._internalGraphicsLayer));
  }
  _isComponentGraphic(e7) {
    var _a;
    const { activeComponent: t } = this;
    return !(!e7 || null == t) && (((_a = e7.attributes) == null ? void 0 : _a.esriSketchTool) || "draw-2d" === t.type && t.graphic === e7 || ("box" === t.type || "reshape" === t.type) && t.isUIGraphic(e7));
  }
  _displayPointerCursor() {
    var _a;
    ((_a = this.view) == null ? void 0 : _a.container) && "pointer" !== this.view.cursor && (this.view.cursor = "pointer");
  }
  _displayGrabbingCursor() {
    var _a;
    ((_a = this.view) == null ? void 0 : _a.container) && "grabbing" !== this.view.cursor && (this.view.cursor = "grabbing");
  }
  _displayDefaultCursor() {
    var _a;
    ((_a = this.view) == null ? void 0 : _a.container) && null !== this.view.cursor && (this.view.cursor = null);
  }
  _logError(e7, t, o2) {
    n.getLogger(this).error(new s(e7, t, o2));
  }
  async _requireModule(e7) {
    const t = new AbortController();
    this._moduleLoaderAbortController = t;
    const o2 = await e7;
    return this._moduleLoaderAbortController !== t || t.signal.aborted ? { requireError: "aborted" } : { module: o2 };
  }
  _emitUndoEvent(e7) {
    this.emit("undo", { ...e7, type: "undo" });
  }
  _emitRedoEvent(e7) {
    this.emit("redo", { ...e7, type: "redo" });
  }
  _emitDeleteEvent(e7) {
    this.emit("delete", { ...e7, type: "delete" });
  }
  get test() {
    return { operationHandle: this._operationHandle, snappingManager: this.snappingManager, defaultUpdateOptions: Q };
  }
  wait() {
    return w(() => !this.updating);
  }
  _beginAsyncOperation() {
    this._numUpdating += 1, this.notifyChange("updating");
  }
  _endAsyncOperation() {
    this._numUpdating -= 1, this.notifyChange("updating");
  }
  _disablePopupEnabled(e7) {
    var _a;
    return "3d" !== ((_a = this.view) == null ? void 0 : _a.type) || this.updateOnGraphicClick || ((e7 == null ? void 0 : e7.toggleToolOnClick) ?? false);
  }
  _disablePopup(e7) {
    this._disablePopupEnabled(e7) && this.view && null == this._originalPopupEnabled && (this._originalPopupEnabled = this.view.popupEnabled, this.view.popupEnabled = false);
  }
  _restorePopup(e7) {
    this._disablePopupEnabled(e7) && this.view && null != this._originalPopupEnabled && (this.view.popupEnabled = this._originalPopupEnabled, this._originalPopupEnabled = null);
  }
  async _waitViewReady() {
    const e7 = this.view;
    e7 ? (e2(this._viewReadyAbortController), this._viewReadyAbortController = new AbortController(), await h(w(() => e7 == null ? void 0 : e7.ready), this._viewReadyAbortController.signal)) : this._logMissingView();
  }
  _logMissingView() {
    this._logError("sketch:missing-property", te("view"));
  }
  _logMissingLayer() {
    this._logError(ee, te("layer"));
  }
};
e([y()], X.prototype, "_defaultSnappingManager", void 0), e([y()], X.prototype, "updating", null), e([y()], X.prototype, "_operationHandle", void 0), e([y({ readOnly: true })], X.prototype, "activeTool", null), e([y()], X.prototype, "activeFillSymbol", void 0), e([y()], X.prototype, "activeLineSymbol", void 0), e([y()], X.prototype, "activeVertexSymbol", void 0), e([y()], X.prototype, "allowDeleteKey", void 0), e([y({ readOnly: true })], X.prototype, "createGraphic", null), e([y()], X.prototype, "defaultCreateOptions", null), e([y()], X.prototype, "defaultUpdateOptions", null), e([y({ type: c3, nonNullable: true })], X.prototype, "labelOptions", null), e([y()], X.prototype, "layer", void 0), e([y({ types: j })], X.prototype, "pointSymbol", void 0), e([y({ types: j })], X.prototype, "polygonSymbol", void 0), e([y({ types: j })], X.prototype, "polylineSymbol", void 0), e([y()], X.prototype, "meshSymbol", void 0), e([y({ type: u3, nonNullable: true })], X.prototype, "snappingOptions", null), e([y()], X.prototype, "snappingManager", null), e([y({ readOnly: true })], X.prototype, "state", null), e([y({ type: p3, nonNullable: true })], X.prototype, "tooltipOptions", null), e([y({ readOnly: true })], X.prototype, "updateGraphics", void 0), e([y()], X.prototype, "updateOnGraphicClick", void 0), e([y({ type: a4, nonNullable: true })], X.prototype, "valueOptions", null), e([y({ types: j })], X.prototype, "vertexSymbol", void 0), e([y({ value: null })], X.prototype, "view", null), e([y({ constructOnly: true, type: l })], X.prototype, "sketchOptions", void 0), X = e([a("esri.widgets.Sketch.SketchViewModel")], X);
var ee = "sketch:missing-property";
var te = (e7) => `Property '${e7}' is missing on SketchViewModel.`;
function oe(e7) {
  return "polygon" === e7 || "rectangle" === e7 || "circle" === e7;
}
function ie(e7, t) {
  re("undo", e7.history.undo, e7.history.redo, t);
}
function ae(e7, t) {
  re("redo", e7.history.redo, e7.history.undo, t);
}
function re(e7, t, o2, i2) {
  const a5 = t.pop();
  if (!a5)
    return;
  const r4 = a5.updates, s4 = [];
  i2.forEach((t2, o3) => {
    const i3 = r4[o3];
    null != i3 && ("geometry" in i3 && null != i3.geometry && (s4.push({ geometry: t2.geometry }), t2.geometry = i3.geometry), "symbol" in i3 && null != i3.symbol && (s4.push({ symbol: t2.symbol }), t2.symbol = i3.symbol), "undo" in i3 && (s4.push(i3), i3[e7](t2)));
  }), o2.push({ updates: s4 });
}
function se(e7) {
  return { updates: e7.map((e8) => ({ geometry: e8.geometry })) };
}
function ne(e7) {
  return "requireError" in e7 && "aborted" === e7.requireError;
}
var pe = X;

export {
  pe
};
//# sourceMappingURL=chunk-H2X5RBRV.js.map
