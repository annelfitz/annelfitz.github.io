import {
  a as a2
} from "./chunk-XIWETS2Q.js";
import {
  i as i2,
  n as n4
} from "./chunk-DRCNNCTI.js";
import {
  P,
  u
} from "./chunk-FV43HSGW.js";
import {
  o as o6
} from "./chunk-U76EZJUZ.js";
import {
  o as o7
} from "./chunk-R2MAAYED.js";
import {
  e as e4
} from "./chunk-QR7J3YDY.js";
import {
  o as o8
} from "./chunk-UYMREM3D.js";
import {
  o as o5
} from "./chunk-3AIILHI5.js";
import {
  o as o3
} from "./chunk-CDBOQCLE.js";
import {
  o as o4
} from "./chunk-RSRUEM5U.js";
import {
  e as e3
} from "./chunk-HFJMEXIX.js";
import {
  a
} from "./chunk-UAFQMHYI.js";
import {
  n as n3,
  o as o2
} from "./chunk-P4MNTMCZ.js";
import {
  e as e2
} from "./chunk-GLF3KRAL.js";
import {
  n as n2
} from "./chunk-ZLQTPFTL.js";
import {
  e
} from "./chunk-N5GQOIDP.js";
import {
  c,
  q
} from "./chunk-HWHMO3CO.js";
import {
  i,
  v
} from "./chunk-326OSIM5.js";
import {
  j
} from "./chunk-OCF7OAES.js";
import {
  o
} from "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";

// node_modules/@arcgis/core/chunks/PointRenderer.glsl.js
var y = class extends n3 {
  constructor() {
    super(...arguments), this.clipBox = i(v), this.useFixedSizes = false, this.useRealWorldSymbolSizes = false, this.scaleFactor = 1, this.minSizePx = 0, this.size = 0, this.sizePx = 0;
  }
  get fixedSize() {
    return this.drawScreenSpace ? this.sizePx : this.size;
  }
  get screenMinSize() {
    return this.useFixedSizes ? 0 : this.minSizePx;
  }
  get drawScreenSpace() {
    return this.useFixedSizes && !this.useRealWorldSymbolSizes;
  }
};
var O = class extends u {
  constructor(e5, i3, o9) {
    super(e5), this.origin = e5, this.isLeaf = i3, this.splatSize = o9;
  }
};
function R(r) {
  const a3 = new o8(), n5 = r.output === o3.Color, c2 = r.output === o3.LinearDepth, l = r.output === o3.Highlight, { vertex: g, fragment: w } = a3;
  return a3.include(P, r), a3.attributes.add(e2.POSITION, "vec3"), a3.attributes.add(e2.COLOR, "vec3"), g.uniforms.add(new o6("modelView", (e5, r2) => c(B, r2.camera.viewMatrix, q(B, e5.origin))), new e3("proj", (e5, i3) => i3.camera.projectionMatrix), new o7("screenMinMaxSize", (e5, i3, o9) => o5(_, o9.useFixedSizes ? 0 : o9.minSizePx * i3.camera.pixelRatio, F(e5.isLeaf) * i3.camera.pixelRatio)), r.useFixedSizes ? new e4("pointScale", (e5, i3) => o5(_, e5.fixedSize * i3.camera.pixelRatio, i3.camera.fullHeight)) : new o7("pointScale", (e5, i3, o9) => o5(_, e5.splatSize * o9.scaleFactor * i3.camera.pixelRatio, i3.camera.fullHeight / i3.camera.pixelRatio))), r.clippingEnabled ? g.uniforms.add(new o4("clipMin", (e5, i3, o9) => o(L, o9.clipBox[0] - e5.origin[0], o9.clipBox[1] - e5.origin[1], o9.clipBox[2] - e5.origin[2])), new o4("clipMax", (e5, i3, o9) => o(L, o9.clipBox[3] - e5.origin[0], o9.clipBox[4] - e5.origin[1], o9.clipBox[5] - e5.origin[2]))) : (g.constants.add("clipMin", "vec3", [-j, -j, -j]), g.constants.add("clipMax", "vec3", [j, j, j])), c2 ? (i2(a3), n4(a3), a3.varyings.add("depth", "float")) : r.output !== o3.Highlight && a3.varyings.add("vColor", "vec3"), g.code.add(o2`
    void main(void) {
      // Move clipped points outside of clipspace
      if (position.x < clipMin.x || position.y < clipMin.y || position.z < clipMin.z ||
        position.x > clipMax.x || position.y > clipMax.y || position.z > clipMax.z) {
        gl_Position = vec4(0.0,0.0,0.0,2.0);
        gl_PointSize = 0.0;
        return;
      }

      if (rejectBySlice(position)) {
        gl_Position = vec4(0.0,0.0,0.0,2.0);
        gl_PointSize = 0.0;
        return;
      }

      // Position in camera space
      vec4 camera = modelView * vec4(position, 1.0);

      float pointSize = pointScale.x;
      vec4 position = proj * camera;
     ${r.drawScreenSize ? o2`
      float clampedScreenSize = pointSize;` : o2`
      float pointRadius = 0.5 * pointSize;
      vec4 cameraOffset = camera + vec4(0.0, pointRadius, 0.0, 0.0);
      vec4 positionOffset = proj * cameraOffset;
      float radius = abs(positionOffset.y - position.y);
      float viewHeight = pointScale.y;
      // screen diameter = (2 * r / w) * (h / 2)
      float screenPointSize = (radius / position.w) * viewHeight;
      float clampedScreenSize = clamp(screenPointSize, screenMinMaxSize.x, screenMinMaxSize.y);
      // Shift towards camera, to move rendered point out of terrain i.e. to
      // the camera-facing end of the virtual point when considering it as a
      // 3D sphere.
      camera.xyz -= normalize(camera.xyz) * pointRadius * clampedScreenSize / screenPointSize;
      position = proj * camera;`}

     gl_PointSize = clampedScreenSize;
     gl_Position = position;

     ${c2 ? o2`depth = calculateLinearDepth(nearFar, camera.z);` : ""}
     ${n5 ? o2`vColor = color;` : ""}
    }
  `), w.include(a, r), l && a3.include(a2, r), w.code.add(o2`
    void main(void) {
      vec2 vOffset = gl_PointCoord - vec2(0.5, 0.5);
      float r2 = dot(vOffset, vOffset);

      if (r2 > 0.25) {
        discard;
      }
      ${c2 ? o2`fragColor = float2rgba(depth);` : ""}
      ${l ? o2`outputHighlight();` : ""}
      ${n5 ? o2`fragColor = vec4(vColor, 1.0);` : ""}
    }
  `), a3;
}
function F(e5) {
  return e5 ? 256 : 64;
}
var B = e();
var L = n();
var _ = n2();
var C = Object.freeze(Object.defineProperty({ __proto__: null, PointRendererDrawParameters: O, PointRendererPassParameters: y, build: R, getMaxPointSizeScreenspace: F }, Symbol.toStringTag, { value: "Module" }));

export {
  y,
  O,
  R,
  F,
  C
};
//# sourceMappingURL=chunk-PISHMHPI.js.map
