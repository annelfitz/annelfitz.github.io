import {
  a
} from "./chunk-5YY6NZNY.js";
import {
  A,
  B,
  C,
  G,
  P,
  c
} from "./chunk-WKVHVZW2.js";

// node_modules/@arcgis/core/views/webgl/getDataTypeBytes.js
function s(s2) {
  switch (s2) {
    case C.BYTE:
    case C.UNSIGNED_BYTE:
      return 1;
    case C.SHORT:
    case C.UNSIGNED_SHORT:
      return 2;
    case C.FLOAT:
    case C.INT:
    case C.UNSIGNED_INT:
      return 4;
  }
}

// node_modules/@arcgis/core/views/webgl/Util.js
function o(e) {
  const r = e.gl;
  switch (r.getError()) {
    case r.NO_ERROR:
      return null;
    case r.INVALID_ENUM:
      return "An unacceptable value has been specified for an enumerated argument";
    case r.INVALID_VALUE:
      return "An unacceptable value has been specified for an argument";
    case r.INVALID_OPERATION:
      return "The specified command is not allowed for the current state";
    case r.INVALID_FRAMEBUFFER_OPERATION:
      return "The currently bound framebuffer is not framebuffer complete";
    case r.OUT_OF_MEMORY:
      return "Not enough memory is left to execute the command";
    case r.CONTEXT_LOST_WEBGL:
      return "WebGL context is lost";
  }
  return "Unknown error";
}
function i(e, r) {
  return e.vertexBuffers[r].usedMemory / R(e.layout[r]);
}
function R(e) {
  return e[0].stride;
}
function E(r, t, s2, a2, c2 = 0) {
  var _a;
  const i2 = r.gl;
  r.bindBuffer(s2);
  for (const R2 of a2) {
    const s3 = t.get(R2.name);
    if (void 0 === s3) {
      console.warn(`There is no location for vertex attribute '${R2.name}' defined.`);
      continue;
    }
    const a3 = c2 * R2.stride;
    if (R2.count <= 4)
      i2.vertexAttribPointer(s3, R2.count, R2.type, R2.normalized, R2.stride, R2.offset + a3), i2.enableVertexAttribArray(s3), R2.divisor > 0 && r.gl.vertexAttribDivisor(s3, R2.divisor);
    else if (9 === R2.count)
      for (let e = 0; e < 3; e++)
        i2.vertexAttribPointer(s3 + e, 3, R2.type, R2.normalized, R2.stride, R2.offset + 12 * e + a3), i2.enableVertexAttribArray(s3 + e), R2.divisor > 0 && r.gl.vertexAttribDivisor(s3 + e, R2.divisor);
    else if (16 === R2.count)
      for (let e = 0; e < 4; e++)
        i2.vertexAttribPointer(s3 + e, 4, R2.type, R2.normalized, R2.stride, R2.offset + 16 * e + a3), i2.enableVertexAttribArray(s3 + e), R2.divisor > 0 && ((_a = r.gl) == null ? void 0 : _a.vertexAttribDivisor(s3 + e, R2.divisor));
    else
      console.error("Unsupported vertex attribute element count: " + R2.count);
    if (a()) {
      const e = o(r), t2 = s(R2.type), s4 = R2.offset, c3 = Math.round(t2 / s4) !== t2 / s4 ? `. Offset not a multiple of stride. DataType requires ${t2} bytes, but descriptor has an offset of ${s4}` : "";
      e && console.error(`Unable to bind vertex attribute "${R2.name}" with baseInstanceOffset ${a3}${c3}:`, e, R2);
    }
  }
}
function _(e, t, s2, a2) {
  var _a, _b, _c;
  const c2 = e.gl;
  e.bindBuffer(s2);
  for (const r of a2) {
    const s3 = t.get(r.name);
    if (r.count <= 4)
      c2.disableVertexAttribArray(s3), r.divisor && r.divisor > 0 && ((_a = e.gl) == null ? void 0 : _a.vertexAttribDivisor(s3, 0));
    else if (9 === r.count)
      for (let t2 = 0; t2 < 3; t2++)
        c2.disableVertexAttribArray(s3 + t2), r.divisor && r.divisor > 0 && ((_b = e.gl) == null ? void 0 : _b.vertexAttribDivisor(s3 + t2, 0));
    else if (16 === r.count)
      for (let t2 = 0; t2 < 4; t2++)
        c2.disableVertexAttribArray(s3 + t2), r.divisor && r.divisor > 0 && ((_c = e.gl) == null ? void 0 : _c.vertexAttribDivisor(s3 + t2, 0));
    else
      console.error("Unsupported vertex attribute element count: " + r.count);
  }
  e.unbindBuffer(A.ARRAY_BUFFER);
}
function u(e) {
  switch (e) {
    case G.ALPHA:
    case G.LUMINANCE:
    case G.RED:
    case G.RED_INTEGER:
    case P.R8:
    case P.R8I:
    case P.R8UI:
    case P.R8_SNORM:
    case B.STENCIL_INDEX8:
      return 1;
    case G.LUMINANCE_ALPHA:
    case G.RG:
    case G.RG_INTEGER:
    case P.RGBA4:
    case P.R16F:
    case P.R16I:
    case P.R16UI:
    case P.RG8:
    case P.RG8I:
    case P.RG8UI:
    case P.RG8_SNORM:
    case P.RGB565:
    case P.RGB5_A1:
    case B.DEPTH_COMPONENT16:
      return 2;
    case G.DEPTH_COMPONENT:
    case G.RGB:
    case G.RGB_INTEGER:
    case P.RGB8:
    case P.RGB8I:
    case P.RGB8UI:
    case P.RGB8_SNORM:
    case P.SRGB8:
    case B.DEPTH_COMPONENT24:
      return 3;
    case G.DEPTH_STENCIL:
    case G.DEPTH24_STENCIL8:
    case G.RGBA:
    case G.RGBA_INTEGER:
    case P.RGBA8:
    case P.R32F:
    case P.R11F_G11F_B10F:
    case P.RG16F:
    case P.R32I:
    case P.R32UI:
    case P.RG16I:
    case P.RG16UI:
    case P.RGBA8I:
    case P.RGBA8UI:
    case P.RGBA8_SNORM:
    case P.SRGB8_ALPHA8:
    case P.RGB9_E5:
    case P.RGB10_A2UI:
    case P.RGB10_A2:
    case B.DEPTH_STENCIL:
    case B.DEPTH_COMPONENT32F:
    case B.DEPTH24_STENCIL8:
      return 4;
    case B.DEPTH32F_STENCIL8:
      return 5;
    case P.RGB16F:
    case P.RGB16I:
    case P.RGB16UI:
      return 6;
    case P.RG32F:
    case P.RG32I:
    case P.RG32UI:
    case P.RGBA16F:
    case P.RGBA16I:
    case P.RGBA16UI:
      return 8;
    case P.RGB32F:
    case P.RGB32I:
    case P.RGB32UI:
      return 12;
    case P.RGBA32F:
    case P.RGBA32I:
    case P.RGBA32UI:
      return 16;
    case c.COMPRESSED_RGB_S3TC_DXT1_EXT:
    case c.COMPRESSED_RGBA_S3TC_DXT1_EXT:
      return 0.5;
    case c.COMPRESSED_RGBA_S3TC_DXT3_EXT:
    case c.COMPRESSED_RGBA_S3TC_DXT5_EXT:
      return 1;
    case c.COMPRESSED_R11_EAC:
    case c.COMPRESSED_SIGNED_R11_EAC:
    case c.COMPRESSED_RGB8_ETC2:
    case c.COMPRESSED_SRGB8_ETC2:
    case c.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
    case c.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return 0.5;
    case c.COMPRESSED_RG11_EAC:
    case c.COMPRESSED_SIGNED_RG11_EAC:
    case c.COMPRESSED_RGBA8_ETC2_EAC:
    case c.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
      return 1;
  }
  return 0;
}

export {
  s,
  o,
  i,
  E,
  _,
  u
};
//# sourceMappingURL=chunk-UNTQATE2.js.map
