import {
  s as s2
} from "./chunk-ADU5ETX4.js";
import {
  d as d4
} from "./chunk-NXOQIUV7.js";
import {
  a as a3,
  o as o3
} from "./chunk-WRDY34WB.js";
import "./chunk-6K5SKR4X.js";
import "./chunk-6BCJJDKK.js";
import {
  t as t3
} from "./chunk-UANQJYHL.js";
import "./chunk-DNFHDQRJ.js";
import {
  v as v2
} from "./chunk-TO6UIATU.js";
import "./chunk-IB7OUIEK.js";
import "./chunk-WCBCYPOZ.js";
import "./chunk-3FTSPLRV.js";
import "./chunk-OMRW2J7M.js";
import "./chunk-UXQH3C5A.js";
import {
  $,
  W,
  as
} from "./chunk-RYF27IO3.js";
import {
  t as t2
} from "./chunk-BEXFYHUM.js";
import "./chunk-K3DEHPDR.js";
import "./chunk-I6RS7YIS.js";
import {
  h as h3
} from "./chunk-MUMDKJ7Y.js";
import {
  h as h2
} from "./chunk-I4SHZ6P5.js";
import {
  E
} from "./chunk-YSXT2SWC.js";
import "./chunk-JBU54P54.js";
import "./chunk-3IDXRFXE.js";
import "./chunk-3AIILHI5.js";
import {
  x as x2
} from "./chunk-SA77Z3WI.js";
import {
  e as e4
} from "./chunk-BKOYOJBG.js";
import "./chunk-YH2IYJYF.js";
import "./chunk-GGHKH3LP.js";
import "./chunk-VS6AHHIY.js";
import "./chunk-XMYPMIYH.js";
import "./chunk-FQLGRQKL.js";
import "./chunk-W5ALAOW2.js";
import "./chunk-FHDHOWK5.js";
import "./chunk-B35SNV2V.js";
import "./chunk-Z2F5OKVA.js";
import "./chunk-UQA6M3KF.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-KNMQQRV7.js";
import "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-ERD6I7QP.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-QYC3GV65.js";
import "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import {
  j as j2,
  p
} from "./chunk-2SYXH2R7.js";
import {
  t
} from "./chunk-7JNXJYRU.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import {
  o as o2
} from "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-6AQIVLDN.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import {
  c as c2
} from "./chunk-HLDUDRTD.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-WNNYD62G.js";
import {
  j
} from "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import {
  a as a2,
  c
} from "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import {
  o
} from "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  A,
  C,
  P,
  d as d3,
  v
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import {
  d as d2
} from "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  d,
  e as e3,
  h,
  k as k2,
  l,
  s
} from "./chunk-JGDJR5EV.js";
import {
  e as e2
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import "./chunk-7RBRCL6S.js";
import {
  k
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/tileUtils.js
function a4(r, e5) {
  return $(e5.extent, c3), as(c3, o(n2, r.x, r.y, 0));
}
var c3 = W();
var n2 = n();

// node_modules/@arcgis/core/views/2d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles2D.js
var p2 = class extends S {
  get tiles() {
    const e5 = this.tilesCoveringView, t4 = null != this.pointOfInterest ? this.pointOfInterest : this.view.center;
    return e5.sort((e6, i) => a4(t4, e6) - a4(t4, i)), e5;
  }
  _scaleEnabled() {
    return t2(this.view.scale, this.layer.minScale || 0, this.layer.maxScale || 0);
  }
  get tilesCoveringView() {
    if (!this.view.ready || !this.view.featuresTilingScheme || !this.view.state || null == this.tileInfo)
      return [];
    if (!this._scaleEnabled)
      return [];
    const { spans: e5, lodInfo: t4 } = this.view.featuresTilingScheme.getTileCoverage(this.view.state, 0), { level: i } = t4, r = [];
    for (const { row: o4, colFrom: s3, colTo: n4 } of e5)
      for (let e6 = s3; e6 <= n4; e6++) {
        const s4 = t4.normalizeCol(e6), n5 = new t(null, i, o4, s4);
        this.tileInfo.updateTileInfo(n5), r.push(n5);
      }
    return r;
  }
  get tileInfo() {
    var _a;
    return ((_a = this.view.featuresTilingScheme) == null ? void 0 : _a.tileInfo) ?? null;
  }
  get tileSize() {
    return null != this.tileInfo ? this.tileInfo.size[0] : 256;
  }
  constructor(e5) {
    super(e5), this.pointOfInterest = null;
  }
  initialize() {
    this.addHandles(d3(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.state) == null ? void 0 : _b.viewpoint;
    }, () => this.notifyChange("tilesCoveringView"), C));
  }
};
e([y({ readOnly: true })], p2.prototype, "tiles", null), e([y({ readOnly: true })], p2.prototype, "_scaleEnabled", null), e([y({ readOnly: true })], p2.prototype, "tilesCoveringView", null), e([y({ readOnly: true })], p2.prototype, "tileInfo", null), e([y({ readOnly: true })], p2.prototype, "tileSize", null), e([y({ constructOnly: true })], p2.prototype, "view", void 0), e([y({ constructOnly: true })], p2.prototype, "layer", void 0), e([y()], p2.prototype, "pointOfInterest", void 0), p2 = e([a("esri.views.2d.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles2D")], p2);

// node_modules/@arcgis/core/views/3d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles3D.js
var p3 = class extends S {
  get tiles() {
    const e5 = this.tilesCoveringView, t4 = this._effectivePointOfInterest;
    if (null != t4) {
      const r = e5.map((e6) => a4(t4, e6));
      for (let i = 1; i < r.length; i++)
        if (r[i - 1] > r[i])
          return e5.sort((e6, r2) => a4(t4, e6) - a4(t4, r2)), e5.slice();
    }
    return e5;
  }
  get tilesCoveringView() {
    var _a, _b;
    return this._filterTiles((_b = (_a = this.view.featureTiles) == null ? void 0 : _a.tiles) == null ? void 0 : _b.toArray()).map(u);
  }
  get tileInfo() {
    var _a, _b;
    return ((_b = (_a = this.view.featureTiles) == null ? void 0 : _a.tilingScheme) == null ? void 0 : _b.toTileInfo()) ?? null;
  }
  get tileSize() {
    var _a;
    return ((_a = this.view.featureTiles) == null ? void 0 : _a.tileSize) ?? 256;
  }
  get _effectivePointOfInterest() {
    var _a;
    const e5 = this.pointOfInterest;
    return null != e5 ? e5 : (_a = this.view.pointsOfInterest) == null ? void 0 : _a.focus.location;
  }
  constructor(e5) {
    super(e5), this.pointOfInterest = null;
  }
  initialize() {
    this.addHandles(d3(() => this.view.featureTiles, (e5) => {
      this.removeHandles(f), e5 && this.addHandles(e5.addClient(), f);
    }, P));
  }
  _filterTiles(e5) {
    if (null == e5)
      return [];
    return e5.filter((e6) => {
      const t4 = e6.measures;
      if (t4.visibility === s2.VISIBLE_ON_SURFACE) {
        const e7 = t4.screenRect;
        return Math.abs(e7[3] - e7[1]) > a5;
      }
      return false;
    });
  }
};
function u({ lij: [e5, t4, r], extent: i }) {
  return new t(`${e5}/${t4}/${r}`, e5, t4, r, i);
}
e([y({ readOnly: true })], p3.prototype, "tiles", null), e([y({ readOnly: true })], p3.prototype, "tilesCoveringView", null), e([y({ readOnly: true })], p3.prototype, "tileInfo", null), e([y({ readOnly: true })], p3.prototype, "tileSize", null), e([y({ constructOnly: true })], p3.prototype, "view", void 0), e([y()], p3.prototype, "pointOfInterest", void 0), e([y()], p3.prototype, "_effectivePointOfInterest", null), p3 = e([a("esri.views.3d.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles3D")], p3);
var a5 = 50;
var f = "feature-tiles";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/WorkerTileTreeDebugger.js
var n3 = class extends d4 {
  constructor(e5) {
    super(e5);
  }
  initialize() {
    const e5 = setInterval(() => this._fetchDebugInfo(), 2e3);
    this.addHandles(e3(() => clearInterval(e5)));
  }
  getTiles() {
    if (!this._debugInfo)
      return [];
    const e5 = /* @__PURE__ */ new Map(), t4 = /* @__PURE__ */ new Map();
    this._debugInfo.storedTiles.forEach((t5) => {
      e5.set(t5.data.id, t5.featureCount);
    }), this._debugInfo.pendingTiles.forEach((r2) => {
      e5.set(r2.data.id, r2.featureCount), t4.set(r2.data.id, r2.state);
    });
    const r = (r2) => {
      const o5 = t4.get(r2), s3 = e5.get(r2) ?? "?";
      return o5 ? `${o5}:${s3}
${r2}` : `store:${s3}
${r2}`;
    }, o4 = /* @__PURE__ */ new Map();
    return this._debugInfo.storedTiles.forEach((e6) => {
      o4.set(e6.data.id, e6.data);
    }), this._debugInfo.pendingTiles.forEach((e6) => {
      o4.set(e6.data.id, e6.data);
    }), Array.from(o4.values()).map((e6) => ({ lij: [e6.level, e6.row, e6.col], geometry: j.fromExtent(c(e6.extent, this.view.spatialReference)), label: r(e6.id) }));
  }
  _fetchDebugInfo() {
    this.handle.getDebugInfo(null).then((e5) => {
      this._debugInfo = e5, this.update();
    });
  }
};
e([y({ constructOnly: true })], n3.prototype, "handle", void 0), n3 = e([a("esri.views.interactive.snapping.featureSources.WorkerTileTreeDebugger")], n3);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorkerHandle.js
var h4 = class extends S {
  get updating() {
    return this._updatingHandles.updating || this._workerHandleUpdating;
  }
  constructor(e5) {
    super(e5), this._updatingHandles = new h2(), this._suspendController = null, this.schedule = null, this.hasZ = false, this.elevationAlignPointsInFeatures = async (e6) => {
      const t4 = [];
      for (const { points: i } of e6.pointsInFeatures)
        for (const { z: e7 } of i)
          t4.push(e7);
      return { elevations: t4, drapedObjectIds: /* @__PURE__ */ new Set(), failedObjectIds: /* @__PURE__ */ new Set() };
    }, this.queryForSymbologySnapping = async () => ({ candidates: [], sourceCandidateIndices: [] }), this.availability = 0, this._workerHandleUpdating = true, this._editId = 0, this.updateOutFields = k2(async (e6, t4) => {
      await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateOutFields", [...e6], t4)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
    });
  }
  destroy() {
    this._suspendController = e2(this._suspendController), this._workerHandle.destroy(), this._updatingHandles.destroy();
  }
  initialize() {
    this._workerHandle = new g(this.schedule, { alignElevation: async (e5, { signal: t4 }) => ({ result: await this.elevationAlignPointsInFeatures(e5.query, t4) }), getSymbologyCandidates: async (e5, { signal: t4 }) => ({ result: await this.queryForSymbologySnapping(e5, t4) }) }), this.addHandles([this._workerHandle.on("notify-updating", ({ updating: e5 }) => this._workerHandleUpdating = e5), this._workerHandle.on("notify-availability", ({ availability: e5 }) => this._set("availability", e5))]);
  }
  async setup(e5, t4) {
    var _a;
    const i = y2(e5.layer);
    if (null == i)
      return;
    const o4 = { configuration: c4(e5.configuration), serviceInfo: i, spatialReference: e5.spatialReference.toJSON(), hasZ: this.hasZ, elevationInfo: (_a = e5.layer.elevationInfo) == null ? void 0 : _a.toJSON() };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setup", o4, t4)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
  }
  async configure(e5, t4) {
    const i = c4(e5);
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("configure", i, t4)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
  }
  async refresh(e5) {
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("refresh", {}, e5)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, e5));
  }
  async fetchCandidates(e5, t4) {
    const { point: i, filter: o4, coordinateHelper: n4 } = e5, a7 = { ...e5, point: e4(i[0], i[1], i[2], n4.spatialReference.toJSON()), filter: o4 == null ? void 0 : o4.toJSON() };
    return this._workerHandle.invoke(a7, t4);
  }
  async updateTiles(e5, t4) {
    const i = { tiles: e5.tiles, tileInfo: null != e5.tileInfo ? e5.tileInfo.toJSON() : null, tileSize: e5.tileSize };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateTiles", i, t4)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
  }
  async applyEdits(e5, t4) {
    var _a, _b, _c;
    const o4 = this._editId++, n4 = { id: o4 };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("beginApplyEdits", n4, t4));
    const s3 = await this._updatingHandles.addPromise(h(e5.result, t4)), r = { id: o4, edits: { addedFeatures: ((_a = s3.addedFeatures) == null ? void 0 : _a.map(({ objectId: e6 }) => e6).filter(k)) ?? [], deletedFeatures: ((_b = s3.deletedFeatures) == null ? void 0 : _b.map(({ objectId: e6, globalId: t5 }) => ({ objectId: e6, globalId: t5 }))) ?? [], updatedFeatures: ((_c = s3.updatedFeatures) == null ? void 0 : _c.map(({ objectId: e6 }) => e6).filter(k)) ?? [] } };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("endApplyEdits", r, t4)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
  }
  getDebugInfo(e5) {
    return this._workerHandle.invokeMethod("getDebugInfo", {}, e5);
  }
  async notifyElevationSourceChange() {
    await this._workerHandle.invokeMethod("notifyElevationSourceChange", {});
  }
  async notifySymbologyChange() {
    await this._workerHandle.invokeMethod("notifySymbologyChange", {});
  }
  async setSymbologySnappingSupported(e5) {
    await this._workerHandle.invokeMethod("setSymbologySnappingSupported", e5);
  }
  async setSuspended(e5) {
    var _a;
    (_a = this._suspendController) == null ? void 0 : _a.abort(), this._suspendController = new AbortController(), await this._workerHandle.invokeMethod("setSuspended", e5, this._suspendController.signal);
  }
};
function c4(e5) {
  return { filter: null != e5.filter ? e5.filter.toJSON() : null, customParameters: e5.customParameters, viewType: e5.viewType };
}
function y2(e5) {
  var _a, _b;
  return "multipatch" === e5.geometryType || "mesh" === e5.geometryType ? null : { url: ((_a = e5.parsedUrl) == null ? void 0 : _a.path) ?? "", fieldsIndex: e5.fieldsIndex.toJSON(), geometryType: o2.toJSON(e5.geometryType), capabilities: e5.capabilities, objectIdField: e5.objectIdField, globalIdField: e5.globalIdField, spatialReference: e5.spatialReference.toJSON(), timeInfo: (_b = e5.timeInfo) == null ? void 0 : _b.toJSON() };
}
e([y({ constructOnly: true })], h4.prototype, "schedule", void 0), e([y({ constructOnly: true })], h4.prototype, "hasZ", void 0), e([y({ constructOnly: true })], h4.prototype, "elevationAlignPointsInFeatures", void 0), e([y({ constructOnly: true })], h4.prototype, "queryForSymbologySnapping", void 0), e([y({ readOnly: true })], h4.prototype, "updating", null), e([y({ readOnly: true })], h4.prototype, "availability", void 0), e([y()], h4.prototype, "_workerHandleUpdating", void 0), h4 = e([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")], h4);
var g = class extends h3 {
  constructor(e5, t4) {
    super("FeatureServiceSnappingSourceWorker", "fetchCandidates", {}, e5, { strategy: "dedicated", client: t4 });
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTilesSimple.js
var a6 = class extends S {
  get tiles() {
    return [new t("0/0/0", 0, 0, 0, a2(-1e8, -1e8, 1e8, 1e8))];
  }
  get tileInfo() {
    return new j2({ origin: new x({ x: -1e8, y: 1e8, spatialReference: this.layer.spatialReference }), size: [512, 512], lods: [new p({ level: 0, scale: 1, resolution: 390625 })], spatialReference: this.layer.spatialReference });
  }
  get tileSize() {
    return this.tileInfo.size[0];
  }
  constructor(e5) {
    super(e5), this.pointOfInterest = null;
  }
};
e([y({ readOnly: true })], a6.prototype, "tiles", null), e([y({ readOnly: true })], a6.prototype, "tileInfo", null), e([y({ readOnly: true })], a6.prototype, "tileSize", null), e([y({ constructOnly: true })], a6.prototype, "layer", void 0), e([y()], a6.prototype, "pointOfInterest", void 0), a6 = e([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTilesSimple")], a6);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/FeatureServiceSnappingSource.js
var F = class extends S {
  get _updateTilesParameters() {
    return { tiles: this._tilesOfInterest.tiles, tileInfo: this._tilesOfInterest.tileInfo, tileSize: this._tilesOfInterest.tileSize };
  }
  get _layerView() {
    var _a;
    return (_a = this.view) == null ? void 0 : _a.allLayerViews.find((e5) => e5.layer === this._layer);
  }
  get _isSuspended() {
    var _a;
    if (c2(this._layer)) {
      if (!this.layerSource.sublayerSources.some((e5) => e5.enabled && e5.layer.visible))
        return true;
    }
    return !!this.view && (false !== ((_a = this._layerView) == null ? void 0 : _a.suspended) || !this.layerSource.enabled);
  }
  get updating() {
    var _a;
    return ((_a = this._workerHandle) == null ? void 0 : _a.updating) || this._updatingHandles.updating;
  }
  get _outFields() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { view: e5, _layerView: t4, layerSource: r } = this, { layer: i } = r, { fieldsIndex: s3, timeInfo: o4, floorInfo: a7, subtypeField: n4 } = i, l2 = t4 && "filter" in t4 ? t4.filter : null, d5 = (l2 == null ? void 0 : l2.where) && "1=1" !== l2.where ? this._getOrLoadWhereFields(l2.where, s3) : [];
    if ((l2 == null ? void 0 : l2.timeExtent) && o4) {
      const { startField: e6, endField: t5 } = o4, r2 = ((_a = s3.get(e6)) == null ? void 0 : _a.name) ?? e6, i2 = ((_b = s3.get(t5)) == null ? void 0 : _b.name) ?? t5;
      r2 && d5.push(r2), i2 && d5.push(i2);
    }
    if ((e5 == null ? void 0 : e5.map) && v2(e5.map) && ((_c = e5.map.utilityNetworks) == null ? void 0 : _c.find((e6) => e6.isUtilityLayer(i)))) {
      const e6 = (_d = i.fieldsIndex.get("assetGroup")) == null ? void 0 : _d.name, t5 = (_e = i.fieldsIndex.get("assetType")) == null ? void 0 : _e.name;
      e6 && t5 && (d5.push(e6), d5.push(t5));
    }
    if (i && (a7 == null ? void 0 : a7.floorField) && ((_f = e5 == null ? void 0 : e5.floors) == null ? void 0 : _f.length)) {
      const e6 = ((_g = s3.get(a7.floorField)) == null ? void 0 : _g.name) ?? a7.floorField;
      e6 && d5.push(e6);
    }
    if (n4) {
      const e6 = ((_h = s3.get(n4)) == null ? void 0 : _h.name) ?? n4;
      e6 && d5.push(e6);
    }
    return new Set(d5);
  }
  get configuration() {
    const { view: e5 } = this, { apiKey: t4, customParameters: r } = this._layer, i = null != e5 ? e5.type : "2d";
    return { filter: this._layer.createQuery(), customParameters: t4 ? { ...r, token: t4 } : r, viewType: i };
  }
  get availability() {
    var _a;
    return ((_a = this._workerHandle) == null ? void 0 : _a.availability) ?? 0;
  }
  get _layer() {
    return this.layerSource.layer;
  }
  constructor(e5) {
    super(e5), this._updatingHandles = new h2(), this._workerHandle = null, this._debug = null, this._memoizedMakeGetGroundElevation = t3(o3);
  }
  initialize() {
    let e5;
    const t4 = this.view;
    if (null == t4 || t4.destroyed)
      this._tilesOfInterest = new a6({ layer: this._layer }), e5 = this._workerHandle = new h4();
    else
      switch (t4.type) {
        case "2d":
          this._tilesOfInterest = new p2({ view: t4, layer: this._layer }), e5 = this._workerHandle = new h4();
          break;
        case "3d": {
          const { resourceController: r } = t4, i = this._layer;
          this._tilesOfInterest = new p3({ view: t4 }), e5 = this._workerHandle = new h4({ schedule: (e6) => r.immediate.schedule(e6), hasZ: this._layer.hasZ && (this._layer.returnZ ?? true), elevationAlignPointsInFeatures: async (e6, r2) => {
            const s3 = await t4.whenLayerView(i);
            return s(r2), s3.elevationAlignPointsInFeatures(e6, r2);
          }, queryForSymbologySnapping: async (e6, r2) => {
            const s3 = await t4.whenLayerView(i);
            return s(r2), s3.queryForSymbologySnapping(e6, r2);
          } }), this.addHandles([t4.elevationProvider.on("elevation-change", ({ context: t5 }) => {
            const { elevationInfo: r2 } = i;
            x2(t5, r2) && d(e5.notifyElevationSourceChange());
          }), d3(() => i.elevationInfo, () => d(e5.notifyElevationSourceChange()), P), d3(() => {
            var _a, _b;
            return (_b = (_a = this._layerView) == null ? void 0 : _a.processor) == null ? void 0 : _b.renderer;
          }, () => d(e5.notifySymbologyChange()), P), d3(() => {
            var _a;
            return ((_a = this._layerView) == null ? void 0 : _a.symbologySnappingSupported) ?? false;
          }, (t5) => d(e5.setSymbologySnappingSupported(t5)), P), v(() => {
            var _a;
            return (_a = this._layerView) == null ? void 0 : _a.layer;
          }, ["edits", "apply-edits", "graphic-update"], () => e5.notifySymbologyChange())]);
          break;
        }
      }
    this.addHandles([l(e5)]), d(e5.setup({ layer: this._layer, spatialReference: this.spatialReference, configuration: this.configuration }, null)), this._updatingHandles.add(() => this._updateTilesParameters, () => d(e5.updateTiles(this._updateTilesParameters, null)), P), this.addHandles([d3(() => this.configuration, (t5) => d(e5.configure(t5, null)), C), d3(() => this._outFields, (t5) => d(e5.updateOutFields(t5)), P), d3(() => this._isSuspended, (t5) => d(e5.setSuspended(t5)), A)]), null != t4 && this.addHandles(d3(() => E.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES, (r) => {
      r && !this._debug ? (this._debug = new n3({ view: t4, handle: e5 }), this.addHandles(l(this._debug), "debug")) : !r && this._debug && this.removeHandles("debug");
    }, P)), this.addHandles(this.layerSource.layer.on("apply-edits", (t5) => {
      d(e5.applyEdits(t5, null));
    }));
  }
  destroy() {
    this._updatingHandles.destroy();
  }
  refresh() {
    var _a;
    (_a = this._workerHandle) == null ? void 0 : _a.refresh(null);
  }
  async fetchCandidates(e5, t4) {
    const { coordinateHelper: r, point: i } = e5;
    this._tilesOfInterest.pointOfInterest = r.arrayToPoint(i);
    const s3 = this._memoizedMakeGetGroundElevation(this.view, r.spatialReference);
    return (await this._workerHandle.fetchCandidates({ ...e5 }, t4)).candidates.map((e6) => a3(e6, s3));
  }
  getDebugInfo(e5) {
    return this._workerHandle.getDebugInfo(e5);
  }
  _getOrLoadWhereFields(e5, t4) {
    const { _whereModule: i } = this;
    if (!this._loadWhereModuleTask && !i) {
      const e6 = d2(async () => {
        const e7 = await import("./WhereClause-C6DQYYGT.js");
        return this._whereModule = e7.WhereClause, this._whereModule;
      });
      return this._loadWhereModuleTask = e6, this._updatingHandles.addPromise(e6.promise), [];
    }
    if (!i)
      return [];
    try {
      return i.create(e5, t4).fieldNames;
    } catch (s3) {
      return [];
    }
  }
};
e([y({ constructOnly: true })], F.prototype, "spatialReference", void 0), e([y({ constructOnly: true })], F.prototype, "layerSource", void 0), e([y({ constructOnly: true })], F.prototype, "view", void 0), e([y()], F.prototype, "_tilesOfInterest", void 0), e([y({ readOnly: true })], F.prototype, "_updateTilesParameters", null), e([y()], F.prototype, "_layerView", null), e([y()], F.prototype, "_isSuspended", null), e([y({ readOnly: true })], F.prototype, "updating", null), e([y()], F.prototype, "_outFields", null), e([y({ readOnly: true })], F.prototype, "configuration", null), e([y({ readOnly: true })], F.prototype, "availability", null), e([y()], F.prototype, "_loadWhereModuleTask", void 0), e([y()], F.prototype, "_whereModule", void 0), F = e([a("esri.views.interactive.snapping.featureSources.FeatureServiceSnappingSource")], F);
export {
  F as FeatureServiceSnappingSource
};
//# sourceMappingURL=FeatureServiceSnappingSource-5S4UHPWZ.js.map
