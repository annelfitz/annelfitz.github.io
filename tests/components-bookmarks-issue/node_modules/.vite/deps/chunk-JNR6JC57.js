import {
  s as s3
} from "./chunk-LBXFRGMS.js";
import {
  i
} from "./chunk-4WS4UHOQ.js";
import {
  t
} from "./chunk-LT6KUDSQ.js";
import {
  s as s2
} from "./chunk-LRW6CHFI.js";
import {
  a
} from "./chunk-GWC53NTZ.js";
import {
  g
} from "./chunk-HLDUDRTD.js";
import {
  S
} from "./chunk-SLQA5YBV.js";
import {
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/layers/support/LayerLoadContext.js
var e = class {
  constructor() {
    this._serviceMetadatas = /* @__PURE__ */ new Map(), this._itemDatas = /* @__PURE__ */ new Map();
  }
  async fetchServiceMetadata(e2, a3) {
    const s5 = this._serviceMetadatas.get(e2);
    if (s5)
      return s5;
    const r = await t(e2, a3);
    return this._serviceMetadatas.set(e2, r), r;
  }
  async fetchItemData(t3) {
    const { id: e2 } = t3;
    if (!e2)
      return null;
    const { _itemDatas: a3 } = this;
    if (a3.has(e2))
      return a3.get(e2);
    const s5 = await t3.fetchData();
    return a3.set(e2, s5), s5;
  }
  async fetchCustomParameters(t3, e2) {
    const a3 = await this.fetchItemData(t3);
    return a3 && "object" == typeof a3 && (e2 ? e2(a3) : a3.customParameters) || null;
  }
};

// node_modules/@arcgis/core/portal/support/loadUtils.js
function t2(e2) {
  const t3 = { id: e2.id, name: e2.name }, a3 = i(e2.type);
  return "FeatureLayer" !== a3 && (t3.layerType = a3), t3;
}
async function a2(e2, r, a3) {
  var _a, _b, _c;
  if (null == (e2 == null ? void 0 : e2.layers) || null == (e2 == null ? void 0 : e2.tables)) {
    const l2 = await a3.fetchServiceMetadata(r, { customParameters: (_a = s4(e2)) == null ? void 0 : _a.customParameters });
    (e2 = e2 || {}).layers = e2.layers || ((_b = l2 == null ? void 0 : l2.layers) == null ? void 0 : _b.map(t2)), e2.tables = e2.tables || ((_c = l2 == null ? void 0 : l2.tables) == null ? void 0 : _c.map(t2));
  }
  return e2;
}
function s4(e2) {
  if (!e2)
    return null;
  const { layers: r, tables: t3 } = e2;
  return (r == null ? void 0 : r.length) ? r[0] : (t3 == null ? void 0 : t3.length) ? t3[0] : null;
}
function l(e2, r) {
  if (null == r)
    return null;
  return [...e2.layers || [], ...e2.tables || []].find((e3) => e3.id === r);
}
function n(e2, r) {
  return [...e2.layers || [], ...e2.tables || []].filter(({ layerType: e3 }) => "FeatureLayer" === r ? !e3 : e3 === r);
}
function u(e2) {
  var _a, _b;
  return (((_a = e2 == null ? void 0 : e2.layers) == null ? void 0 : _a.length) ?? 0) + (((_b = e2 == null ? void 0 : e2.tables) == null ? void 0 : _b.length) ?? 0);
}
function c(e2) {
  switch (e2) {
    case "catalog":
      return "CatalogLayer";
    case "feature":
      return "FeatureLayer";
    case "oriented-imagery":
      return "OrientedImageryLayer";
    case "subtype-group":
      return "SubtypeGroupLayer";
  }
  return null;
}
function i2(e2) {
  switch (e2) {
    case "CatalogLayer":
      return "CatalogLayer";
    case "OrientedImageryLayer":
      return "OrientedImageryLayer";
    case "SubtypeGroupLayer":
      return "SubtypeGroupLayer";
  }
  return "FeatureLayer";
}
async function o(r, a3, l2) {
  var _a, _b, _c, _d;
  if (!(r == null ? void 0 : r.url))
    return a3 ?? {};
  if (a3 ?? (a3 = {}), !a3.layers) {
    const e2 = await l2.fetchServiceMetadata(r.url);
    a3.layers = (_a = e2.layers) == null ? void 0 : _a.map(t2);
  }
  const { serverUrl: n2, portalItem: u2 } = await s2(r.url, { sceneLayerItem: r, customParameters: (_b = s4(a3)) == null ? void 0 : _b.customParameters }).catch(() => ({ serverUrl: null, portalItem: null }));
  if (null == n2)
    return a3.tables = [], a3;
  if (!a3.tables && u2) {
    const e2 = await u2.fetchData();
    if (e2 == null ? void 0 : e2.tables)
      a3.tables = e2.tables.map(t2);
    else {
      const r2 = await l2.fetchServiceMetadata(n2, { customParameters: (_c = s4(e2)) == null ? void 0 : _c.customParameters });
      a3.tables = (_d = r2 == null ? void 0 : r2.tables) == null ? void 0 : _d.map(t2);
    }
  }
  if (a3.tables)
    for (const e2 of a3.tables)
      e2.url = `${n2}/${e2.id}`;
  return a3;
}

// node_modules/@arcgis/core/portal/support/portalLayers.js
async function p(e2) {
  let { portalItem: a3 } = e2;
  !a3 || a3 instanceof S || (a3 = new S(a3));
  const r = await L(a3);
  return new (0, r.constructor)({ portalItem: a3, ...r.properties });
}
async function L(e2) {
  await e2.load();
  const a3 = new e();
  return w(await d(e2, a3));
}
async function d(a3, r) {
  switch (a3.type) {
    case "3DTiles Service":
      return g2();
    case "CSV":
      return C();
    case "Feature Collection":
      return I(a3);
    case "Feature Service":
      return S2(a3, r);
    case "Feed":
      return U();
    case "GeoJson":
      return j();
    case "Group Layer":
      return V();
    case "Image Service":
      return h(a3, r);
    case "KML":
      return P();
    case "Map Service":
      return N(a3, r);
    case "Media Layer":
      return W();
    case "Scene Service":
      return v(a3, r);
    case "Stream Service":
      return M();
    case "Vector Tile Service":
      return T();
    case "WFS":
      return F();
    case "WMS":
      return G();
    case "WMTS":
      return b();
    default:
      throw new s("portal:unknown-item-type", "Unknown item type '${type}'", { type: a3.type });
  }
}
async function w(e2) {
  const a3 = e2.className, r = a[a3];
  return { constructor: await r(), properties: e2.properties };
}
async function N(e2, a3) {
  return await D(e2, a3) ? { className: "TileLayer" } : { className: "MapImageLayer" };
}
async function S2(e2, a3) {
  const r = await J(e2, a3);
  if ("object" == typeof r) {
    const { sourceJSON: e3, className: a4 } = r, t3 = { sourceJSON: e3 };
    return null != r.id && (t3.layerId = r.id), { className: a4 || "FeatureLayer", properties: t3 };
  }
  return { className: "GroupLayer" };
}
async function v(e2, r) {
  var _a;
  const t3 = await J(e2, r, async () => {
    try {
      if (!e2.url)
        return [];
      const { serverUrl: t4 } = await s2(e2.url, { sceneLayerItem: e2 }), s5 = await r.fetchServiceMetadata(t4);
      return (s5 == null ? void 0 : s5.tables) ?? [];
    } catch {
      return [];
    }
  });
  if ("object" == typeof t3) {
    const a3 = {};
    let c2;
    if (null != t3.id ? (a3.layerId = t3.id, c2 = `${e2.url}/layers/${t3.id}`) : c2 = e2.url, (_a = e2.typeKeywords) == null ? void 0 : _a.length) {
      for (const r2 of Object.keys(g))
        if (e2.typeKeywords.includes(r2))
          return { className: g[r2] };
    }
    const n2 = await r.fetchServiceMetadata(c2, { customParameters: await r.fetchCustomParameters(e2, (e3) => {
      var _a2;
      return (_a2 = s4(e3)) == null ? void 0 : _a2.customParameters;
    }) });
    return { className: g[n2 == null ? void 0 : n2.layerType] || "SceneLayer", properties: a3 };
  }
  if (false === t3) {
    const a3 = await r.fetchServiceMetadata(e2.url);
    if ("Voxel" === (a3 == null ? void 0 : a3.layerType))
      return { className: "VoxelLayer" };
  }
  return { className: "GroupLayer" };
}
async function I(e2) {
  await e2.load();
  const a3 = s3(e2, "Map Notes"), r = s3(e2, "Markup");
  if (a3 || r)
    return { className: "MapNotesLayer" };
  if (s3(e2, "Route Layer"))
    return { className: "RouteLayer" };
  const t3 = await e2.fetchData();
  return 1 === u(t3) ? { className: "FeatureLayer" } : { className: "GroupLayer" };
}
async function h(e2, a3) {
  var _a, _b, _c;
  await e2.load();
  const r = ((_a = e2.typeKeywords) == null ? void 0 : _a.map((e3) => e3.toLowerCase())) ?? [];
  if (r.includes("elevation 3d layer"))
    return { className: "ElevationLayer" };
  if (r.includes("tiled imagery"))
    return { className: "ImageryTileLayer" };
  const t3 = await a3.fetchItemData(e2), s5 = t3 == null ? void 0 : t3.layerType;
  if ("ArcGISTiledImageServiceLayer" === s5)
    return { className: "ImageryTileLayer" };
  if ("ArcGISImageServiceLayer" === s5)
    return { className: "ImageryLayer" };
  const c2 = await a3.fetchServiceMetadata(e2.url, { customParameters: await a3.fetchCustomParameters(e2) }), n2 = (_b = c2.cacheType) == null ? void 0 : _b.toLowerCase(), o2 = (_c = c2.capabilities) == null ? void 0 : _c.toLowerCase().includes("tilesonly");
  return "map" === n2 || o2 ? { className: "ImageryTileLayer" } : { className: "ImageryLayer" };
}
function M() {
  return { className: "StreamLayer" };
}
function T() {
  return { className: "VectorTileLayer" };
}
function j() {
  return { className: "GeoJSONLayer" };
}
function g2() {
  return { className: "IntegratedMesh3DTilesLayer" };
}
function C() {
  return { className: "CSVLayer" };
}
function P() {
  return { className: "KMLLayer" };
}
function F() {
  return { className: "WFSLayer" };
}
function G() {
  return { className: "WMSLayer" };
}
function b() {
  return { className: "WMTSLayer" };
}
function U() {
  return { className: "StreamLayer" };
}
function V() {
  return { className: "GroupLayer" };
}
function W() {
  return { className: "MediaLayer" };
}
async function D(e2, a3) {
  const { tileInfo: r } = await a3.fetchServiceMetadata(e2.url, { customParameters: await a3.fetchCustomParameters(e2) });
  return r;
}
async function J(e2, a3, t3) {
  const { url: s5, type: c2 } = e2, n2 = "Feature Service" === c2;
  if (!s5)
    return {};
  if (/\/\d+$/.test(s5)) {
    if (n2) {
      const t4 = await a3.fetchServiceMetadata(s5, { customParameters: await a3.fetchCustomParameters(e2, (e3) => {
        var _a;
        return (_a = s4(e3)) == null ? void 0 : _a.customParameters;
      }) });
      return { id: t4.id, className: i(t4.type), sourceJSON: t4 };
    }
    return {};
  }
  await e2.load();
  let f = await a3.fetchItemData(e2);
  if (n2) {
    const e3 = await a2(f, s5, a3), r = K(e3);
    if ("object" == typeof r) {
      const a4 = l(e3, r.id);
      r.className = i2(a4 == null ? void 0 : a4.layerType);
    }
    return r;
  }
  "Scene Service" === c2 && (f = await o(e2, f, a3));
  if (u(f) > 0)
    return K(f);
  const p2 = await a3.fetchServiceMetadata(s5);
  return t3 && (p2.tables = await t3()), K(p2);
}
function K(e2) {
  var _a;
  return 1 === u(e2) && { id: (_a = s4(e2)) == null ? void 0 : _a.id };
}

export {
  e,
  t2 as t,
  a2 as a,
  s4 as s,
  n,
  u,
  c,
  i2 as i,
  o,
  p,
  d
};
//# sourceMappingURL=chunk-JNR6JC57.js.map
