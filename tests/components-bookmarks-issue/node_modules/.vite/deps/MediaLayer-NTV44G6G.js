import {
  X,
  a as a2,
  b as b2,
  d as d2,
  l
} from "./chunk-3KF6TCFQ.js";
import {
  m as m2
} from "./chunk-PYZXYYZX.js";
import "./chunk-ALYZBARC.js";
import "./chunk-PGADGS3I.js";
import "./chunk-VE57JPH4.js";
import {
  o as o4
} from "./chunk-63NZBHDP.js";
import "./chunk-UQEUYEWU.js";
import "./chunk-5LIYYE75.js";
import "./chunk-L52HB3KV.js";
import "./chunk-3AIILHI5.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-HZSGATFT.js";
import "./chunk-NFB6O77E.js";
import "./chunk-3VMVD66K.js";
import {
  A
} from "./chunk-7EQJLP2H.js";
import {
  j
} from "./chunk-4ZLXDMI5.js";
import {
  n as n4
} from "./chunk-6PMFOUWZ.js";
import "./chunk-3KPZ3BQR.js";
import "./chunk-5JYVZQZR.js";
import {
  t
} from "./chunk-UUG4W2PI.js";
import {
  u
} from "./chunk-WW22JHXA.js";
import {
  S
} from "./chunk-ZAM62XN5.js";
import "./chunk-RKVEKQ5O.js";
import "./chunk-P7J4JFEH.js";
import {
  b
} from "./chunk-G7FOE26O.js";
import "./chunk-USOPZ2Q6.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-R4CJB3GP.js";
import {
  n as n3
} from "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-AKLOTDO2.js";
import "./chunk-6AQIVLDN.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-LBXFRGMS.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import {
  m
} from "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import {
  B,
  H
} from "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import {
  o as o3
} from "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-TPLOIZC7.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import {
  n as n2
} from "./chunk-Z2PDA67N.js";
import {
  w,
  x
} from "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  G
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import {
  o as o2
} from "./chunk-YOPMY6TS.js";
import {
  r
} from "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import {
  s as s3
} from "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  d
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  e as e2,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  k,
  s as s2
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/layers/support/LocalMediaElementSource.js
var w2 = { key: "type", defaultKeyValue: "image", base: d2, typeMap: { image: b2, video: a2 } };
var M = V.ofType(w2);
var I = class extends m.LoadableMixin(n2(o.EventedAccessor)) {
  constructor(e3) {
    super(e3), this._index = new o4(), this._elementViewsMap = /* @__PURE__ */ new Map(), this._elementsIndexes = /* @__PURE__ */ new Map(), this._elementsChangedHandler = (e4) => {
      for (const s4 of e4.removed) {
        const e5 = this._elementViewsMap.get(s4);
        this._elementViewsMap.delete(s4), this._index.delete(e5), this.removeHandles(e5), e5.destroy(), this.notifyChange("fullExtent");
      }
      const { spatialReference: t2 } = this;
      for (const s4 of e4.added) {
        if (this._elementViewsMap.get(s4))
          continue;
        const e5 = new m2({ spatialReference: t2, element: s4 });
        this._elementViewsMap.set(s4, e5);
        const r2 = d(() => e5.coords, () => this._updateIndexForElement(e5, false));
        this._updateIndexForElement(e5, true), this.addHandles(r2, e5);
      }
      this._elementsIndexes.clear(), this.elements.forEach((e5, t3) => this._elementsIndexes.set(e5, t3)), this.emit("refresh");
    }, this.elements = new M();
  }
  async load(e3) {
    if (s2(e3), !this.spatialReference) {
      const e4 = this.elements.find((e5) => {
        var _a;
        return null != ((_a = e5.georeference) == null ? void 0 : _a.coords);
      });
      this._set("spatialReference", e4 ? e4.georeference.coords.spatialReference : f.WGS84);
    }
    return this._elementsChangedHandler({ added: this.elements.items, removed: [] }), this.addHandles(this.elements.on("change", this._elementsChangedHandler)), this;
  }
  destroy() {
    this._index.clear(), this._elementViewsMap.clear(), this._elementsIndexes.clear();
  }
  set elements(e3) {
    this._set("elements", n3(e3, this._get("elements"), M));
  }
  get fullExtent() {
    if ("not-loaded" === this.loadStatus)
      return null;
    const e3 = this._index.fullBounds;
    return null == e3 ? null : new w({ xmin: e3[0], ymin: e3[1], xmax: e3[2], ymax: e3[3], spatialReference: this.spatialReference });
  }
  set spatialReference(e3) {
    "not-loaded" === this.loadStatus ? this._set("spatialReference", e3) : n.getLogger(this).error("#spatialReference", "spatialReference cannot be changed after the source is loaded.");
  }
  async queryElements(e3, t2) {
    await this.load(), await H(e3.spatialReference, this.spatialReference, null, t2);
    const s4 = G(e3.spatialReference, this.spatialReference) ? e3 : B(e3, this.spatialReference);
    if (!s4)
      return [];
    const r2 = s4.normalize(), o5 = [];
    for (const n5 of r2)
      this._index.forEachInBounds(o3(n5), ({ normalizedCoords: e4, element: t3 }) => {
        null != e4 && x(n5, e4) && o5.push(t3);
      });
    return o5.sort((e4, t3) => this._elementsIndexes.get(e4) - this._elementsIndexes.get(t3)), o5;
  }
  hasElement(e3) {
    return this.elements.includes(e3);
  }
  _updateIndexForElement(e3, t2) {
    const s4 = e3.normalizedBounds, r2 = this._index.has(e3), o5 = null != s4;
    this._index.delete(e3), o5 && this._index.set(e3, s4), this.notifyChange("fullExtent"), t2 || (r2 !== o5 ? this.emit("refresh") : this.emit("change", { element: e3.element }));
  }
};
e([y()], I.prototype, "elements", null), e([y({ readOnly: true })], I.prototype, "fullExtent", null), e([y()], I.prototype, "spatialReference", null), I = e([a("esri.layers.support.LocalMediaElementSource")], I);
var V2 = I;

// node_modules/@arcgis/core/layers/MediaLayer.js
function L(e3) {
  return "object" == typeof e3 && null != e3 && "type" in e3;
}
function b3(e3) {
  return L(e3) && "image" === e3.type;
}
var _ = class extends n4(t(u(j(S(b))))) {
  constructor(e3) {
    super(e3), this.effectiveSource = null, this.georeference = null, this.copyright = null, this.operationalLayerType = "MediaLayer", this.spatialReference = null, this.type = "media", this._debouncedSaveOperations = k(async (e4, r2, o5) => {
      const { save: t2, saveAs: s4 } = await import("./mediaLayerUtils-SUPLWP2A.js");
      switch (e4) {
        case A.SAVE:
          return t2(this, r2);
        case A.SAVE_AS:
          return s4(this, o5, r2);
      }
    }), this.source = new V2();
  }
  load(e3) {
    return this.addResolvingPromise(this._doLoad(e3)), Promise.resolve(this);
  }
  async _doLoad(e3) {
    await this.loadFromPortal({ supportedTypes: ["Media Layer"] }, e3);
    let t2 = this.source;
    if (!t2)
      throw new s("media-layer:source-missing", "Set 'MediaLayer.source' before loading the layer.");
    const s4 = this._getSourceOverride(t2, this.georeference);
    s4 && (this.setAtOrigin("source", s4, "web-map"), this.setAtOrigin("source", s4, "web-scene"), t2 = s4);
    const i = L(t2) ? new V2({ elements: new V([t2]) }) : t2;
    this._set("effectiveSource", i), this.spatialReference && (i.spatialReference = this.spatialReference), await i.load(e3), this.spatialReference = i.spatialReference;
  }
  destroy() {
    var _a, _b;
    (_a = this.effectiveSource) == null ? void 0 : _a.destroy(), this.effectiveSource !== this.source && ((_b = this.source) == null ? void 0 : _b.destroy());
  }
  readGeoreference(e3, r2) {
    return e3 && "itemId" in r2 && r2.itemId ? e3 : void 0;
  }
  get fullExtent() {
    return this.loaded ? this.effectiveSource.fullExtent : null;
  }
  set source(e3) {
    "loaded" !== this.loadStatus && "failed" !== this.loadStatus ? this._set("source", e3) : n.getLogger(this).error("#source", "source cannot be changed after the layer is loaded.");
  }
  castSource(e3) {
    return e3 ? Array.isArray(e3) ? new V2({ elements: new V(e3) }) : e3 instanceof V ? new V2({ elements: e3 }) : e3 : null;
  }
  readSource(e3, r2, o5) {
    if ("itemId" in r2 && r2.itemId)
      return;
    const t2 = this._createSource(r2);
    return t2 == null ? void 0 : t2.read(r2, o5), t2;
  }
  writeSource(e3, r2, t2, s4) {
    var _a;
    b3(e3) ? e3.write(r2, s4) : (s4 == null ? void 0 : s4.messages) && ((_a = s4 == null ? void 0 : s4.messages) == null ? void 0 : _a.push(new s("media-layer:unsupported-source", "source must be an 'ImageElement'")));
  }
  async save(e3) {
    return this._debouncedSaveOperations(A.SAVE, e3);
  }
  async saveAs(e3, r2) {
    return this._debouncedSaveOperations(A.SAVE_AS, r2, e3);
  }
  _createSource(e3) {
    if ("mediaType" in e3)
      switch (e3.mediaType) {
        case "image":
          return new b2();
        case "video":
          return new a2();
      }
    return null;
  }
  _getSourceOverride(e3, r2) {
    if (L(e3) && this.originIdOf("source") === e2.PORTAL_ITEM && r2 && (this.originIdOf("georeference") === e2.WEB_MAP || this.originIdOf("georeference") === e2.WEB_SCENE)) {
      const o5 = e3.toJSON(), t2 = this._createSource(o5);
      return t2.read({ ...o5 }, { origin: "portal-item" }), t2.read({ georeference: r2 }, { origin: "web-map" }), t2.read({ georeference: r2 }, { origin: "web-scene" }), t2;
    }
    return null;
  }
};
e([y({ readOnly: true })], _.prototype, "effectiveSource", void 0), e([y({ readOnly: true, json: { read: false, write: false, origins: { "web-document": { read: true } } } })], _.prototype, "georeference", void 0), e([o2("web-document", "georeference")], _.prototype, "readGeoreference", null), e([y({ type: String })], _.prototype, "copyright", void 0), e([y({ readOnly: true })], _.prototype, "fullExtent", null), e([y({ type: ["MediaLayer"] })], _.prototype, "operationalLayerType", void 0), e([y({ type: ["show", "hide"] })], _.prototype, "listMode", void 0), e([y({ nonNullable: true, json: { write: { enabled: true, allowNull: false, target: { url: { type: String }, mediaType: { type: ["image"] }, georeference: { type: X } }, overridePolicy(e3, r2, o5) {
  return { enabled: true, allowNull: false, ignoreOrigin: l(this, o5 == null ? void 0 : o5.origin) && b3(e3) && !!e3.georeference && e3.originIdOf("georeference") > e2.PORTAL_ITEM };
} } } })], _.prototype, "source", null), e([s3("source")], _.prototype, "castSource", null), e([o2("source", ["url"])], _.prototype, "readSource", null), e([r("source")], _.prototype, "writeSource", null), e([y()], _.prototype, "spatialReference", void 0), e([y({ readOnly: true })], _.prototype, "type", void 0), _ = e([a("esri.layers.MediaLayer")], _);
var E = _;
export {
  E as default
};
//# sourceMappingURL=MediaLayer-NTV44G6G.js.map
