import {
  s as s3
} from "./chunk-VS6AHHIY.js";
import {
  n
} from "./chunk-SAYWXQVM.js";
import {
  L,
  S,
  b,
  c2,
  e,
  m,
  o,
  o3 as o2,
  s as s2,
  u2 as u
} from "./chunk-JGDJR5EV.js";
import {
  l
} from "./chunk-QHK5ZYFW.js";
import {
  a2 as a,
  c,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/core/workers/connectionRegistry.js
var n2 = new FinalizationRegistry((n5) => {
  n5.close();
});
function e2(e4, i3) {
  n2.register(e4, i3, i3);
}
function i(e4) {
  n2.unregister(e4);
}

// node_modules/@arcgis/core/core/workers/utils.js
var r = "worker:port-closed";
var e3;
!function(t) {
  t[t.HANDSHAKE = 0] = "HANDSHAKE", t[t.OPEN = 1] = "OPEN", t[t.OPENED = 2] = "OPENED", t[t.RESPONSE = 3] = "RESPONSE", t[t.INVOKE = 4] = "INVOKE", t[t.ABORT = 5] = "ABORT", t[t.CLOSE = 6] = "CLOSE", t[t.OPEN_PORT = 7] = "OPEN_PORT", t[t.ON = 8] = "ON";
}(e3 || (e3 = {}));
var n3 = 0;
function s4() {
  return n3++;
}
function o3(t) {
  return t && "object" == typeof t && ("result" in t || "transferList" in t);
}
function i2(t) {
  return t ? "string" == typeof t ? JSON.stringify({ name: "message", message: t }) : t.toJSON ? JSON.stringify(t) : JSON.stringify({ name: t.name, message: t.message, details: t.details || { stack: t.stack } }) : null;
}
function a2(t, r4, n5, s5) {
  if (r4.type === e3.OPEN_PORT)
    return void t.postMessage(r4, [r4.port]);
  if (r4.type !== e3.INVOKE && r4.type !== e3.RESPONSE)
    return void t.postMessage(r4);
  let f2;
  if (o3(n5) ? (f2 = u2(n5.transferList), r4.data = n5.result) : (f2 = u2(s5), r4.data = n5), f2) {
    if (has("ff")) {
      for (const n6 of f2)
        if ("byteLength" in n6 && n6.byteLength > 267386880) {
          const n7 = "Worker call with large ArrayBuffer would crash Firefox";
          switch (r4.type) {
            case e3.INVOKE:
              throw n7;
            case e3.RESPONSE:
              return void a2(t, { type: e3.RESPONSE, jobId: r4.jobId, error: i2(n7) });
          }
        }
    }
    t.postMessage(r4, f2);
  } else
    t.postMessage(r4);
}
function f(t) {
  if (!t)
    return null;
  const r4 = t.data;
  return r4 ? "string" == typeof r4 ? JSON.parse(r4) : r4 : null;
}
function u2(t) {
  if (!(t == null ? void 0 : t.length))
    return null;
  if (has("esri-workers-arraybuffer-transfer"))
    return t;
  const r4 = t.filter((t2) => !c3(t2));
  return r4.length ? r4 : null;
}
function c3(t) {
  var _a;
  return t instanceof ArrayBuffer || "ArrayBuffer" === ((_a = t == null ? void 0 : t.constructor) == null ? void 0 : _a.name);
}
async function O(e4) {
  try {
    return await e4;
  } catch (n5) {
    const e5 = (n5 == null ? void 0 : n5.name) === r;
    if (!(b(n5) || e5))
      throw n5;
    return;
  }
}

// node_modules/@arcgis/core/core/workers/InvokeHandler.js
function n4(n5, e4, i3) {
  return new Proxy({}, { get: (o4, s5, l2) => (...o5) => {
    let l3, a3;
    const g = o5[o5.length - 1];
    r2(g) && (l3 = g.signal, a3 = g.transferList, o5.pop());
    const c5 = n5.apply(e4 ? `${e4}.${s5.toString()}` : s5.toString(), o5, { transferList: a3, signal: l3 });
    return (i3 == null ? void 0 : i3.ignoreConnectionErrors) ? O(c5) : c5;
  } });
}
function r2(t) {
  return "object" == typeof t && !Array.isArray(t) && null != t && ("signal" in t || "transferList" in t || 0 === Object.keys(t).length);
}

// node_modules/@arcgis/core/core/workers/registry.js
var r3 = { statsWorker: () => import("./statsWorker-IY5LHBDB.js"), geometryEngineWorker: () => import("./geometryEngineWorker-7CVAWE6P.js"), CSVSourceWorker: () => import("./CSVSourceWorker-BOZK4ODL.js"), EdgeProcessingWorker: () => import("./EdgeProcessingWorker-VARVFK75.js"), ElevationSamplerWorker: () => import("./ElevationSamplerWorker-3MTUUCVI.js"), FeatureServiceSnappingSourceWorker: () => import("./FeatureServiceSnappingSourceWorker-4HQESKBN.js"), GeoJSONSourceWorker: () => import("./GeoJSONSourceWorker-7X666MMP.js"), LercWorker: () => import("./LercWorker-ET272SKH.js"), MemorySourceWorker: () => import("./MemorySourceWorker-CY2FXHCN.js"), PBFDecoderWorker: () => import("./PBFDecoderWorker-T654QACH.js"), FeaturePipelineWorker: () => import("./FeaturePipelineWorker-FDAO2C2Q.js"), PointCloudWorker: () => import("./PointCloudWorker-E4OWEC37.js"), RasterWorker: () => import("./RasterWorker-44H623AL.js"), SceneLayerSnappingSourceWorker: () => import("./SceneLayerSnappingSourceWorker-SPI7POHV.js"), SceneLayerWorker: () => import("./SceneLayerWorker-RHET5MEZ.js"), WFSSourceWorker: () => import("./WFSSourceWorker-RIV4J365.js"), WorkerTileHandler: () => import("./WorkerTileHandler-3YKUF6VM.js"), Lyr3DWorker: () => import("./Lyr3DWorker-PEMKY6TJ.js") };

// node_modules/@arcgis/core/core/workers/RemoteClient.js
var { CLOSE: M, ABORT: k, INVOKE: j, RESPONSE: y, OPEN_PORT: I, ON: J } = e3;
var w = 2;
var O2 = class {
  constructor(e4) {
    this._invoke = e4, this._timer = null, this._cancelledJobIds = /* @__PURE__ */ new Set(), this._invokeMessages = [], this._timer = null, this._process = this._process.bind(this);
  }
  push(e4) {
    e4.type === e3.ABORT ? this._cancelledJobIds.add(e4.jobId) : (this._invokeMessages.push(e4), null === this._timer && (this._timer = setTimeout(this._process, 0)));
  }
  clear() {
    this._invokeMessages.length = 0, this._cancelledJobIds.clear(), this._timer = null;
  }
  _process() {
    this._timer = null;
    for (const e4 of this._invokeMessages)
      this._cancelledJobIds.has(e4.jobId) || this._invoke(e4);
    this._cancelledJobIds.clear(), this._invokeMessages.length = 0;
  }
};
var E = class _E {
  static connect(e4, s5) {
    const t = new MessageChannel();
    let o4;
    o4 = "function" == typeof e4 ? new e4() : "default" in e4 && "function" == typeof e4.default ? new e4.default() : e4;
    const n5 = new _E(t.port1, { channel: t, client: o4, schedule: s5 });
    return "object" == typeof o4 && "remoteClient" in o4 && (o4.remoteClient = n5), _E.clients.set(n5, o4), t.port2;
  }
  static loadWorker(e4) {
    const s5 = r3[e4];
    return s5 ? s5() : Promise.resolve(null);
  }
  constructor(e4, s5, t) {
    this._port = e4, this._jobQueue = t, this._outJobs = /* @__PURE__ */ new Map(), this._inJobs = /* @__PURE__ */ new Map(), this._invokeQueue = new O2((e5) => this._onInvokeMessage(e5)), this._client = s5.client, this._onMessage = this._onMessage.bind(this), this._channel = s5.channel, this._schedule = s5.schedule, this._port.addEventListener("message", this._onMessage), this._port.start();
  }
  close() {
    this._post({ type: M }), this._close();
  }
  isBusy() {
    return this._outJobs.size > 0;
  }
  invoke(e4, s5, t) {
    return this.apply(e4, [s5], t);
  }
  apply(e4, t, o4) {
    const a3 = o4 == null ? void 0 : o4.signal, h = o4 == null ? void 0 : o4.transferList;
    if (!this._port)
      return Promise.reject(new s(r, `Cannot call invoke('${e4}'), port is closed`, { methodName: e4, data: t }));
    const c5 = s4();
    return new Promise((s5, o5) => {
      if (c2(a3))
        return this._processWork(), void o5(u());
      const p = m(a3, () => {
        const e5 = this._outJobs.get(c5);
        e5 && (this._outJobs.delete(c5), this._processWork(), l(e5.abortHandle), this._post({ type: k, jobId: c5 }), o5(u()));
      }), _ = { resolve: s5, reject: o5, abortHandle: p, debugInfo: e4 };
      this._outJobs.set(c5, _), this._post({ type: j, jobId: c5, methodName: e4, abortable: null != a3 }, t, h);
    });
  }
  createInvokeProxy(e4, s5) {
    return n4(this, e4, s5);
  }
  on(e4, s5) {
    const t = new MessageChannel();
    function n5(e5) {
      s5(e5.data);
    }
    return this._port.postMessage({ type: e3.ON, eventType: e4, port: t.port2 }, [t.port2]), t.port1.addEventListener("message", n5), t.port1.start(), e(() => {
      t.port1.postMessage({ type: e3.CLOSE }), t.port1.close(), t.port1.removeEventListener("message", n5);
    });
  }
  jobAdded() {
    this._processWork();
  }
  openPort() {
    const e4 = new MessageChannel();
    return this._post({ type: I, port: e4.port2 }), e4.port1;
  }
  _processWork() {
    var _a;
    if (this._outJobs.size >= w)
      return;
    const e4 = (_a = this._jobQueue) == null ? void 0 : _a.pop();
    if (!e4)
      return;
    const { methodName: s5, data: t, invokeOptions: o4, resolver: n5 } = e4;
    this.apply(s5, t, o4).then((e5) => n5.resolve(e5)).catch((e5) => n5.reject(e5));
  }
  _close() {
    this._channel && (this._channel = void 0), this._port.removeEventListener("message", this._onMessage), this._port.close(), this._outJobs.forEach((e4) => {
      l(e4.abortHandle), e4.reject(u(`Worker closing, aborting job calling '${e4.debugInfo}'`));
    }), this._inJobs.clear(), this._outJobs.clear(), this._invokeQueue.clear(), this._port = null, this._client = null, this._schedule = null;
  }
  _onMessage(e4) {
    null != this._schedule ? this._schedule(() => this._processMessage(e4, true)) : this._processMessage(e4, false);
  }
  _processMessage(e4, s5) {
    const t = f(e4);
    if (t)
      switch (t.type) {
        case y:
          this._onResponseMessage(t);
          break;
        case j:
          s5 ? this._onInvokeMessage(t) : this._invokeQueue.push(t);
          break;
        case k:
          this._onAbortMessage(t);
          break;
        case M:
          this._onCloseMessage();
          break;
        case I:
          this._onOpenPortMessage(t);
          break;
        case J:
          this._onOnMessage(t);
      }
  }
  _onAbortMessage(e4) {
    const s5 = this._inJobs, t = e4.jobId, o4 = s5.get(t);
    this._invokeQueue.push(e4), o4 && (o4.controller && o4.controller.abort(), s5.delete(t));
  }
  _onCloseMessage() {
    const e4 = this._client;
    this._close(), e4 && "destroy" in e4 && _E.clients.get(this) === e4 && e4.destroy(), _E.clients.delete(this), (e4 == null ? void 0 : e4.remoteClient) && (e4.remoteClient = null);
  }
  _onInvokeMessage(e4) {
    const { methodName: s5, jobId: t, data: o4 = [], abortable: n5 } = e4, r4 = n5 ? new AbortController() : null, i3 = this._inJobs;
    let l2, c5 = this._client, p = c5[s5];
    try {
      if (!p && s5 && s5.includes(".")) {
        const e5 = s5.split(".");
        for (let s6 = 0; s6 < e5.length - 1; s6++)
          c5 = c5[e5[s6]], p = c5[e5[s6 + 1]];
      }
      if ("function" != typeof p)
        throw new TypeError(`${s5} is not a function`);
      o4.push({ client: this, signal: r4 ? r4.signal : null }), l2 = p.apply(c5, o4);
    } catch (_) {
      return void this._post({ type: y, jobId: t, error: i2(_) });
    }
    S(l2) ? (i3.set(t, { controller: r4, promise: l2 }), l2.then((e5) => {
      i3.has(t) && (i3.delete(t), this._post({ type: y, jobId: t }, e5));
    }, (e5) => {
      i3.has(t) && (i3.delete(t), b(e5) || this._post({ type: y, jobId: t, error: i2(e5 || { message: `Error encountered at method ${s5}` }) }));
    })) : this._post({ type: y, jobId: t }, l2);
  }
  _onOpenPortMessage(e4) {
    new _E(e4.port, { client: this._client });
  }
  _onOnMessage(e4) {
    const { port: s5 } = e4, o4 = this._client.on(e4.eventType, (e5) => {
      s5.postMessage(e5);
    }), n5 = o2(e4.port, "message", (e5) => {
      const t = f(e5);
      (t == null ? void 0 : t.type) === e3.CLOSE && (n5.remove(), o4.remove(), s5.close());
    });
  }
  _onResponseMessage(e4) {
    const { jobId: t, error: o4, data: r4 } = e4, i3 = this._outJobs;
    if (!i3.has(t))
      return;
    const l2 = i3.get(t);
    i3.delete(t), this._processWork(), l(l2.abortHandle), o4 ? l2.reject(s.fromJSON(JSON.parse(o4))) : l2.resolve(r4);
  }
  _post(e4, s5, t) {
    return a2(this._port, e4, s5, t);
  }
};
E.kernelInfo = { buildDate: a, fullVersion: n, revision: c }, E.clients = /* @__PURE__ */ new Map();

// node_modules/@arcgis/core/core/workers/Connection.js
var c4 = class {
  constructor() {
    this._inUseClients = new Array(), this._clients = new Array(), this._clientPromises = new Array(), this._ongoingJobsQueue = new s3();
  }
  destroy() {
    this.close();
  }
  get closed() {
    var _a;
    return !((_a = this._clients) == null ? void 0 : _a.length);
  }
  open(e4, s5) {
    return new Promise((n5, o4) => {
      let r4 = true;
      const l2 = (e5) => {
        s2(s5.signal), r4 && (r4 = false, e5());
      };
      this._clients.length = e4.length, this._clientPromises.length = e4.length, this._inUseClients.length = e4.length;
      for (let i3 = 0; i3 < e4.length; ++i3) {
        const r5 = e4[i3];
        S(r5) ? this._clientPromises[i3] = r5.then((e5) => (this._clients[i3] = new E(e5, s5, this._ongoingJobsQueue), l2(n5), this._clients[i3]), () => (l2(o4), null)) : (this._clients[i3] = new E(r5, s5, this._ongoingJobsQueue), this._clientPromises[i3] = Promise.resolve(this._clients[i3]), l2(n5));
      }
    });
  }
  broadcast(e4, t, s5) {
    const n5 = new Array(this._clientPromises.length);
    for (let i3 = 0; i3 < this._clientPromises.length; ++i3) {
      const o4 = this._clientPromises[i3];
      n5[i3] = o4.then((n6) => n6 == null ? void 0 : n6.invoke(e4, t, s5));
    }
    return n5;
  }
  close() {
    let e4;
    for (; e4 = this._ongoingJobsQueue.pop(); )
      e4.resolver.reject(u(`Worker closing, aborting job calling '${e4.methodName}'`));
    for (const t of this._clientPromises)
      t.then((e5) => e5 == null ? void 0 : e5.close());
    this._clients.length = 0, this._clientPromises.length = 0, this._inUseClients.length = 0, i(this);
  }
  invoke(e4, t, s5) {
    return this.apply(e4, [t], s5);
  }
  apply(e4, t, s5) {
    const i3 = L();
    this._ongoingJobsQueue.push({ methodName: e4, data: t, invokeOptions: s5, resolver: i3 });
    for (let n5 = 0; n5 < this._clientPromises.length; n5++) {
      const e5 = this._clients[n5];
      e5 ? e5.jobAdded() : this._clientPromises[n5].then((e6) => e6 == null ? void 0 : e6.jobAdded());
    }
    return i3.promise;
  }
  createInvokeProxy(e4) {
    return n4(this, e4);
  }
  on(t, s5) {
    return Promise.all(this._clientPromises).then(() => o(this._clients.map((e4) => e4.on(t, s5))));
  }
  openPorts() {
    return new Promise((e4) => {
      const t = new Array(this._clientPromises.length);
      let s5 = t.length;
      for (let n5 = 0; n5 < this._clientPromises.length; ++n5) {
        this._clientPromises[n5].then((i3) => {
          i3 && (t[n5] = i3.openPort()), 0 == --s5 && e4(t);
        });
      }
    });
  }
  get test() {
    return { numClients: this._clients.length };
  }
};

export {
  e2 as e,
  e3 as e2,
  s4 as s,
  i2 as i,
  a2 as a,
  f,
  E,
  c4 as c
};
//# sourceMappingURL=chunk-GGHKH3LP.js.map
