import {
  y as y3
} from "./chunk-4UEJR4VO.js";
import {
  n as n7
} from "./chunk-BUEJAM23.js";
import {
  c as c3
} from "./chunk-LQR76D5M.js";
import {
  p as p6
} from "./chunk-Q5NCQLSM.js";
import {
  p as p5
} from "./chunk-YH2IYJYF.js";
import {
  D as D2
} from "./chunk-DIT542IP.js";
import {
  a as a5
} from "./chunk-HFYOMP47.js";
import {
  i as i3
} from "./chunk-QMPD4WXY.js";
import {
  e as e3
} from "./chunk-OF4YIONV.js";
import {
  l
} from "./chunk-AHEDDTVZ.js";
import {
  c as c2
} from "./chunk-Z4ALW6LX.js";
import {
  p as p4
} from "./chunk-UVXSAP7V.js";
import {
  s as s3
} from "./chunk-IHQNQQJC.js";
import {
  i as i4
} from "./chunk-4IKPTZ53.js";
import {
  C as C2
} from "./chunk-DXMBDX2I.js";
import {
  m as m4,
  o as o3,
  u as u2
} from "./chunk-TUVEYM7U.js";
import {
  f as f5
} from "./chunk-7UUNSIMA.js";
import {
  d as d2
} from "./chunk-GMRQGGML.js";
import {
  p as p3
} from "./chunk-OHYLFFUW.js";
import {
  e as e2
} from "./chunk-XW3FDKYP.js";
import {
  i as i5
} from "./chunk-2QCWKZIQ.js";
import {
  A as A2,
  D,
  E,
  F,
  I as I3,
  M,
  O,
  P,
  Q,
  R,
  S as S4,
  T,
  b as b4,
  f as f4,
  g as g2,
  j as j4,
  m as m5,
  q,
  w as w2,
  x
} from "./chunk-2NPNEA6N.js";
import {
  b as b3
} from "./chunk-W5ALAOW2.js";
import {
  K
} from "./chunk-ERD6I7QP.js";
import {
  S as S3
} from "./chunk-QIT4M76C.js";
import {
  t as t3
} from "./chunk-EZL4LTMD.js";
import {
  d as d3
} from "./chunk-F3BQGS35.js";
import {
  g
} from "./chunk-OHE3HDFF.js";
import {
  f as f3
} from "./chunk-QYC3GV65.js";
import {
  P as P2
} from "./chunk-ETHGDNE6.js";
import {
  A
} from "./chunk-7EQJLP2H.js";
import {
  j as j2
} from "./chunk-4ZLXDMI5.js";
import {
  f as f2
} from "./chunk-EMYOYGGK.js";
import {
  n as n5
} from "./chunk-6PMFOUWZ.js";
import {
  t as t2
} from "./chunk-UUG4W2PI.js";
import {
  u
} from "./chunk-WW22JHXA.js";
import {
  S as S2
} from "./chunk-ZAM62XN5.js";
import {
  C,
  I as I2,
  b,
  c,
  m as m3,
  p as p2,
  y as y2
} from "./chunk-RKVEKQ5O.js";
import {
  a as a4
} from "./chunk-P7J4JFEH.js";
import {
  b as b2
} from "./chunk-G7FOE26O.js";
import {
  j2 as j3
} from "./chunk-ZIJHDTB7.js";
import {
  i
} from "./chunk-R4CJB3GP.js";
import {
  n as n6
} from "./chunk-6IED7TER.js";
import {
  g as g3,
  p as p7
} from "./chunk-X7VSXJWW.js";
import {
  n as n4
} from "./chunk-VEODBKUJ.js";
import {
  i as i2
} from "./chunk-PJNK3TLV.js";
import {
  t
} from "./chunk-DVI5RM3W.js";
import {
  h as h2,
  m as m2,
  p
} from "./chunk-VTH4DAHQ.js";
import {
  m
} from "./chunk-ONK5AE7R.js";
import {
  j
} from "./chunk-HV6S3GY2.js";
import {
  n as n3
} from "./chunk-Z2PDA67N.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  o as o2
} from "./chunk-YOPMY6TS.js";
import {
  r
} from "./chunk-VIN55KNF.js";
import {
  s as s2
} from "./chunk-IOB3DJMR.js";
import {
  I,
  U,
  V as V2
} from "./chunk-SAYWXQVM.js";
import {
  V,
  n as n2
} from "./chunk-PVUNFEWX.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3,
  d
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  a as a2,
  h,
  k
} from "./chunk-JGDJR5EV.js";
import {
  a,
  n2 as n,
  o,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/layers/graphics/sources/MemorySource.js
var _ = 0;
var T2 = class extends m.LoadableMixin(n3(V)) {
  constructor(e5) {
    super(e5), this._idToClientGraphic = null, this.type = "memory";
  }
  load(e5) {
    const t4 = null != e5 ? e5.signal : null;
    return this.addResolvingPromise(this._startWorker(t4)), Promise.resolve(this);
  }
  destroy() {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.close(), this._connection = null;
  }
  get _workerGeometryType() {
    var _a;
    const e5 = (_a = this.layer) == null ? void 0 : _a.geometryType;
    return e5 ? this._geometryTypeRequiresClientGraphicMapping(e5) ? "polygon" : e5 : null;
  }
  applyEdits(e5) {
    return this.load().then(() => this._applyEdits(e5));
  }
  openPorts() {
    return this.load().then(() => this._connection.openPorts());
  }
  async queryFeatures(e5, t4 = {}) {
    await this.load(t4);
    const r2 = await this._connection.invoke("queryFeatures", e5 ? e5.toJSON() : null, t4);
    t3(e5, this.layer.spatialReference, r2);
    const s4 = d3.fromJSON(r2);
    if (!this._requiresClientGraphicMapping())
      return s4;
    const i6 = this.layer.objectIdField;
    for (const o5 of s4.features) {
      const e6 = o5.attributes[i6], t5 = this._idToClientGraphic.get(e6);
      t5 && (o5.geometry = t5.geometry);
    }
    return s4.geometryType = this.layer.geometryType, s4;
  }
  async queryFeaturesJSON(e5, t4 = {}) {
    if (this._requiresClientGraphicMapping())
      throw new s("query-features-json:unsupported", "Cannot query in JSON format for client only geometry types (mesh and extent)");
    await this.load(t4);
    const r2 = await this._connection.invoke("queryFeatures", e5 ? e5.toJSON() : null, t4);
    return t3(e5, this.layer.spatialReference, r2), r2;
  }
  queryFeatureCount(e5, t4 = {}) {
    return this.load(t4).then(() => this._connection.invoke("queryFeatureCount", e5 ? e5.toJSON() : null, t4));
  }
  queryObjectIds(e5, t4 = {}) {
    return this.load(t4).then(() => this._connection.invoke("queryObjectIds", e5 ? e5.toJSON() : null, t4));
  }
  queryExtent(e5, t4 = {}) {
    return this.load(t4).then(() => this._connection.invoke("queryExtent", e5 ? e5.toJSON() : null, t4)).then((e6) => ({ count: e6.count, extent: w.fromJSON(e6.extent) }));
  }
  querySnapping(e5, t4 = {}) {
    return this.load(t4).then(() => this._connection.invoke("querySnapping", e5, t4));
  }
  async _applyEdits(e5) {
    if (!this._connection)
      throw new s("feature-layer-source:edit-failure", "Memory source not loaded");
    const t4 = this.layer.objectIdField;
    let r2 = null;
    const i6 = [], o5 = [];
    await Promise.all([this._prepareClientMapping(e5.addFeatures, null), this._prepareClientMapping(e5.updateFeatures, null)]);
    const n9 = (e6) => "objectId" in e6 && null != e6.objectId ? e6.objectId : "attributes" in e6 && null != e6.attributes[t4] ? e6.attributes[t4] : null;
    if (e5.addFeatures && (r2 = this._prepareAddFeatures(e5.addFeatures)), e5.deleteFeatures)
      for (const s4 of e5.deleteFeatures) {
        const e6 = n9(s4);
        null != e6 && i6.push(e6);
      }
    const a6 = e5.updateFeatures && this._idToClientGraphic ? /* @__PURE__ */ new Map() : null;
    if (e5.updateFeatures) {
      for (const s4 of e5.updateFeatures)
        if (o5.push(this._serializeFeature(s4)), a6) {
          const e6 = n9(s4);
          null != e6 && a6.set(e6, s4);
        }
    }
    i5(r2 ? r2.features : null, o5, this.layer.spatialReference);
    const { fullExtent: l2, featureEditResults: u3 } = await this._connection.invoke("applyEdits", { adds: r2 ? r2.features : [], updates: o5, deletes: i6 });
    return this.fullExtent = l2, r2 && r2.finish(u3.uidToObjectId), this._updateClientGraphicIds(a6, u3), this._createEditsResult(u3);
  }
  async _prepareClientMapping(e5, t4) {
    if ("mesh" !== this._layerOrSourceGeometryType || null == e5)
      return;
    const r2 = [];
    for (const { geometry: s4 } of e5)
      null == s4 || "mesh" !== s4.type || s4.hasExtent || s4.loaded || r2.push(s4.load({ signal: t4 }));
    r2.length && await Promise.all(r2);
  }
  _updateClientGraphicIds(e5, t4) {
    if (this._idToClientGraphic) {
      if (e5)
        for (const r2 of t4.updateResults) {
          if (!r2.success)
            continue;
          const t5 = e5.get(r2.objectId);
          null != t5 && this._addIdToClientGraphic(t5);
        }
      for (const e6 of t4.deleteResults)
        e6.success && this._idToClientGraphic.delete(e6.objectId);
    }
  }
  _createEditsResult(e5) {
    return { addFeatureResults: e5.addResults ? e5.addResults.map(this._createFeatureEditResult, this) : [], updateFeatureResults: e5.updateResults ? e5.updateResults.map(this._createFeatureEditResult, this) : [], deleteFeatureResults: e5.deleteResults ? e5.deleteResults.map(this._createFeatureEditResult, this) : [], addAttachmentResults: [], updateAttachmentResults: [], deleteAttachmentResults: [] };
  }
  _createFeatureEditResult(e5) {
    const t4 = true === e5.success ? null : e5.error || { code: void 0, description: void 0 };
    return { objectId: e5.objectId, globalId: e5.globalId, error: t4 ? new s("feature-layer-source:edit-failure", t4.description, { code: t4.code }) : null };
  }
  _prepareAddFeatures(e5) {
    const t4 = /* @__PURE__ */ new Map(), r2 = new Array(e5.length);
    let s4 = null;
    for (let o5 = 0; o5 < e5.length; o5++) {
      const i7 = e5[o5], n9 = this._serializeFeature(i7);
      s4 || null == i7.geometry || (s4 = i7.geometry.type), r2[o5] = n9, t4.set(`${n9.uid}`, i7);
    }
    const i6 = this;
    return { features: r2, inferredGeometryType: s4, finish(e6) {
      const r3 = i6.sourceJSON.objectIdField;
      for (const s5 in e6) {
        const o5 = e6[s5], n9 = t4.get(s5);
        n9 && (n9.attributes || (n9.attributes = {}), -1 === o5 ? delete n9.attributes[r3] : n9.attributes[r3] = o5, i6._addIdToClientGraphic(n9));
      }
    } };
  }
  _addIdToClientGraphic(e5) {
    var _a;
    if (!this._idToClientGraphic)
      return;
    const t4 = this.sourceJSON.objectIdField, r2 = (_a = e5.attributes) == null ? void 0 : _a[t4];
    null != r2 && this._idToClientGraphic.set(r2, e5);
  }
  get _layerOrSourceGeometryType() {
    var _a, _b;
    return ((_a = this.layer) == null ? void 0 : _a.geometryType) ?? ((_b = this.sourceJSON) == null ? void 0 : _b.geometryType);
  }
  _requiresClientGraphicMapping() {
    return this._geometryTypeRequiresClientGraphicMapping(this._layerOrSourceGeometryType);
  }
  _geometryRequiresClientGraphicMapping(e5) {
    return this._geometryTypeRequiresClientGraphicMapping(e5.type);
  }
  _geometryTypeRequiresClientGraphicMapping(e5) {
    return "mesh" === e5 || "multipatch" === e5 || "extent" === e5;
  }
  _serializeFeature(e5) {
    const { attributes: t4 } = e5, r2 = this._geometryForSerialization(e5), s4 = (_++).toString();
    return r2 ? { uid: s4, geometry: r2.toJSON(), attributes: t4 } : { uid: s4, attributes: t4 };
  }
  _geometryForSerialization(e5) {
    const { geometry: t4 } = e5;
    if (null == t4)
      return null;
    if (this._geometryRequiresClientGraphicMapping(t4)) {
      return t4.extent ? j.fromExtent(t4.extent) : null;
    }
    return t4;
  }
  async _startWorker(e5) {
    this._connection = await p5("MemorySourceWorker", { strategy: has("feature-layers-workers") ? "dedicated" : "local", signal: e5, registryTarget: this });
    const { fields: t4, spatialReference: r2, objectIdField: s4, hasM: i6, hasZ: n9, timeInfo: l2, dateFieldsTimeZone: u3 } = this.layer, p9 = "defaults" === this.layer.originOf("spatialReference");
    await this._prepareClientMapping(this.items, e5);
    const c4 = this._prepareAddFeatures(this.items);
    this.addHandles(this.on("before-changes", (e6) => {
      n.getLogger(this).error("Source modifications will not propagate after layer has been loaded. Please use .applyEdits() instead"), e6.preventDefault();
    }));
    const d4 = { features: c4.features, fields: t4 == null ? void 0 : t4.map((e6) => e6.toJSON()), geometryType: i2.toJSON(this._workerGeometryType), hasM: "mesh" !== this._layerOrSourceGeometryType && i6, hasZ: "mesh" === this._layerOrSourceGeometryType || n9, objectIdField: s4, spatialReference: p9 ? null : r2 && r2.toJSON(), timeInfo: (l2 == null ? void 0 : l2.toJSON()) ?? null, dateFieldsTimeZone: u3 }, h3 = await this._connection.invoke("load", d4, { signal: e5 });
    for (const a6 of h3.warnings)
      n.getLogger(this.layer).warn("#load()", `${a6.message} (title: '${this.layer.title || "no title"}', id: '${this.layer.id ?? "no id"}')`, { warning: a6 });
    h3.featureErrors.length && n.getLogger(this.layer).warn("#load()", `Encountered ${h3.featureErrors.length} validation errors while loading features. (title: '${this.layer.title || "no title"}', id: '${this.layer.id ?? "no id"}')`, { errors: h3.featureErrors });
    const y4 = h3.layerDefinition;
    this._geometryTypeRequiresClientGraphicMapping(c4.inferredGeometryType) && (y4.geometryType = i2.toJSON(c4.inferredGeometryType)), this.sourceJSON = y4, this._requiresClientGraphicMapping() && (this._idToClientGraphic = /* @__PURE__ */ new Map()), c4.finish(h3.assignedObjectIds);
  }
};
e([n2({ Type: f3, ensureType: d(f3) })], T2.prototype, "itemType", void 0), e([y()], T2.prototype, "type", void 0), e([y({ constructOnly: true })], T2.prototype, "layer", void 0), e([y({ readOnly: true })], T2.prototype, "_workerGeometryType", null), e([y()], T2.prototype, "sourceJSON", void 0), T2 = e([a3("esri.layers.graphics.sources.MemorySource")], T2);

// node_modules/@arcgis/core/layers/support/PublishingInfo.js
var e4 = class extends S {
  constructor() {
    super(...arguments), this.updating = false, this.status = "unknown";
  }
};
e([y()], e4.prototype, "updating", void 0), e([y()], e4.prototype, "status", void 0), e4 = e([a3("esri.layers.support.PublishingInfo")], e4);
var p8 = e4;

// node_modules/@arcgis/core/layers/mixins/PublishableLayer.js
var o4 = Symbol();
var n8 = (i6) => {
  var n9;
  let u3 = class extends i6 {
    constructor() {
      super(...arguments), this[n9] = true;
    }
    get publishingInfo() {
      if (this.destroyed)
        return null;
      const t4 = this._get("publishingInfo");
      if (t4)
        return t4;
      const s4 = new p8();
      return this._checkPublishingStatus(s4), s4;
    }
    _checkPublishingStatus(t4) {
      const s4 = 250, e5 = 125;
      let r2 = 0;
      const o5 = async (s5) => {
        let n10;
        t4.updating = true;
        try {
          n10 = await this.fetchPublishingStatus();
        } catch (u4) {
          n10 = "unavailable";
        }
        "published" !== n10 && "unavailable" !== n10 || ("publishing" === t4.status && this.refresh(), i7.remove()), t4.status = n10, t4.updating = false, i7.removed || (r2 = setTimeout(o5, s5, s5 + e5));
      }, i7 = { removed: false, remove() {
        this.removed = true, clearTimeout(r2);
      } };
      this.when().catch(() => i7.remove()), o5(s4), this.addHandles(i7);
    }
  };
  return n9 = o4, e([y({ readOnly: true, clonable: false })], u3.prototype, "publishingInfo", null), u3 = e([a3("esri.layers.mixins.PublishableLayer")], u3), u3;
};

// node_modules/@arcgis/core/layers/FeatureLayer.js
var Ue = "FeatureLayer";
function Qe(e5, r2) {
  return new s("layer:unsupported", `Layer (${e5.title}, ${e5.id}) of type '${e5.declaredClass}' ${r2}`, { layer: e5 });
}
function Ne(e5) {
  return e5 && e5 instanceof V;
}
var $e = s3();
function Ge(e5, r2, t4) {
  const i6 = !!(t4 == null ? void 0 : t4.writeLayerSchema);
  return { enabled: i6, ignoreOrigin: i6 };
}
var Je = class extends D2(c3(p4(n8(g(n5(c2(f5(t2(f2(l(u(j2(S2(e2(i3(i(b2))))))))))))))))) {
  constructor(...e5) {
    super(...e5), this.charts = null, this.copyright = null, this.displayField = null, this.dynamicDataSource = null, this.fields = null, this.fieldsIndex = null, this.formTemplate = null, this.fullExtent = null, this.geometryType = null, this.hasM = void 0, this.hasZ = void 0, this.infoFor3D = null, this.isTable = false, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.objectIdField = null, this.outFields = null, this.path = null, this.popupEnabled = true, this.popupTemplate = null, this.resourceInfo = null, this.screenSizePerspectiveEnabled = true, this.spatialReference = f.WGS84, this.subtypeCode = null, this.supportedSourceTypes = /* @__PURE__ */ new Set(["Feature Layer", "Oriented Imagery Layer", "Table", "Catalog Layer"]), this.templates = null, this.timeInfo = null, this.title = null, this.sublayerTitleMode = "item-title", this.type = "feature", this.typeIdField = null, this.types = null, this.visible = true, this._debouncedSaveOperations = k(async (e6, r2, t4) => {
      const { save: i6, saveAs: o5 } = await import("./featureLayerUtils-UQBIKW27.js");
      switch (e6) {
        case A.SAVE:
          return i6(this, r2);
        case A.SAVE_AS:
          return o5(this, t4, r2);
      }
    });
  }
  destroy() {
    var _a;
    (_a = this.source) == null ? void 0 : _a.destroy();
  }
  normalizeCtorArgs(e5, r2) {
    return "string" == typeof e5 ? { url: e5, ...r2 } : e5;
  }
  load(e5) {
    var _a;
    const r2 = null != e5 ? e5.signal : null;
    if (((_a = this.portalItem) == null ? void 0 : _a.loaded) && this.source)
      return this.addResolvingPromise(this.createGraphicsSource(r2).then((e6) => this.initLayerProperties(e6))), Promise.resolve(this);
    const t4 = this.loadFromPortal({ supportedTypes: ["Feature Service", "Feature Collection", "Scene Service"] }, e5).catch(a2).then(async () => {
      if (this.url && null == this.layerId && /FeatureServer|MapServer\/*$/i.test(this.url)) {
        const e6 = await this._fetchFirstValidLayerId(r2);
        null != e6 && (this.layerId = e6);
      }
      if (!this.url && !this._hasMemorySource())
        throw new s("feature-layer:missing-url-or-source", "Feature layer must be created with either a url or a source");
      return this.initLayerProperties(await this.createGraphicsSource(r2));
    }).then(() => Q(this, "load", e5));
    return this.addResolvingPromise(t4), Promise.resolve(this);
  }
  readCapabilities(e5, r2) {
    return r2 = r2.layerDefinition || r2, a5(r2, this.url);
  }
  get createQueryVersion() {
    return this.commitProperty("definitionExpression"), this.commitProperty("dynamicDataSource"), this.commitProperty("timeExtent"), this.commitProperty("timeOffset"), this.commitProperty("geometryType"), this.commitProperty("gdbVersion"), this.commitProperty("historicMoment"), this.commitProperty("returnZ"), this.commitProperty("capabilities"), this.commitProperty("returnM"), (this._get("createQueryVersion") ?? 0) + 1;
  }
  get editingEnabled() {
    var _a;
    return !(this.loaded && !((_a = this.capabilities) == null ? void 0 : _a.operations.supportsEditing)) && (this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this._hasMemorySource() || this.userHasEditingPrivileges);
  }
  set editingEnabled(e5) {
    this._overrideIfSome("editingEnabled", e5);
  }
  readEditingEnabled(e5, r2) {
    return this._readEditingEnabled(r2, false);
  }
  readEditingEnabledFromWebMap(e5, r2, t4) {
    return this._readEditingEnabled(r2, true, t4);
  }
  writeEditingEnabled(e5, r2) {
    this._writeEditingEnabled(e5, r2, false);
  }
  writeEditingEnabledToWebMap(e5, r2, t4, i6) {
    this._writeEditingEnabled(e5, r2, true, i6);
  }
  get effectiveEditingEnabled() {
    return T(this);
  }
  readIsTable(e5, r2) {
    return "Table" === (r2 = (r2 == null ? void 0 : r2.layerDefinition) ?? r2).type || !r2.geometryType;
  }
  writeIsTable(e5, r2, t4, i6) {
    (i6 == null ? void 0 : i6.writeLayerSchema) && o(t4, e5 ? "Table" : "Feature Layer", r2);
  }
  readGlobalIdField(e5, r2) {
    return R(r2.layerDefinition || r2);
  }
  readObjectIdField(e5, r2) {
    return M(r2.layerDefinition || r2);
  }
  get parsedUrl() {
    const e5 = I(this.url);
    return null != e5 && (null != this.dynamicDataSource ? e5.path = V2(e5.path, "dynamicLayer") : null != this.layerId && (e5.path = V2(e5.path, this.layerId.toString()))), e5;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  set renderer(e5) {
    p7(e5, this.fieldsIndex), this._set("renderer", e5);
  }
  readRenderer(e5, r2, i6) {
    var _a;
    r2 = r2.layerDefinition || r2;
    const o5 = (_a = r2.drawingInfo) == null ? void 0 : _a.renderer;
    if (o5) {
      const e6 = o3(o5, r2, i6) ?? void 0;
      return e6 || n.getLogger(this).error("Failed to create renderer", { rendererDefinition: r2.drawingInfo.renderer, layer: this, context: i6 }), e6;
    }
    return D(r2, i6);
  }
  set source(e5) {
    const r2 = this._get("source");
    r2 !== e5 && (Ne(r2) && this._resetMemorySource(r2), Ne(e5) && this._initMemorySource(e5), this._set("source", e5));
  }
  castSource(e5) {
    return e5 ? Array.isArray(e5) || e5 instanceof V ? new T2({ layer: this, items: e5 }) : e5 : null;
  }
  readSource(e5, r2) {
    const t4 = d3.fromJSON(r2.featureSet);
    return new T2({ layer: this, items: (t4 == null ? void 0 : t4.features) ?? [] });
  }
  readTemplates(e5, r2) {
    const t4 = r2.editFieldsInfo, i6 = t4 == null ? void 0 : t4.creatorField, o5 = t4 == null ? void 0 : t4.editorField;
    return e5 = e5 == null ? void 0 : e5.map((e6) => p6.fromJSON(e6)), this._fixTemplates(e5, i6), this._fixTemplates(e5, o5), e5;
  }
  readTitle(e5, r2) {
    var _a, _b, _c;
    const t4 = ((_a = r2.layerDefinition) == null ? void 0 : _a.name) ?? r2.name, i6 = r2.title || ((_b = r2.layerDefinition) == null ? void 0 : _b.title);
    if (t4) {
      const e6 = (_c = this.portalItem) == null ? void 0 : _c.title;
      if ("item-title" === this.sublayerTitleMode)
        return this.url ? h2(this.url, t4) : t4;
      let r3 = t4;
      if (!r3 && this.url) {
        const e7 = p(this.url);
        null != e7 && (r3 = e7.title);
      }
      if (!r3)
        return;
      return "item-title-and-service-name" === this.sublayerTitleMode && e6 && e6 !== r3 && (r3 = e6 + " - " + r3), m2(r3);
    }
    if ("item-title" === this.sublayerTitleMode && i6)
      return i6;
  }
  readTitleFromWebMap(e5, r2) {
    var _a;
    return r2.title || ((_a = r2.layerDefinition) == null ? void 0 : _a.name);
  }
  readTypeIdField(e5, r2) {
    let t4 = (r2 = r2.layerDefinition || r2).typeIdField;
    if (t4 && r2.fields) {
      t4 = t4.toLowerCase();
      const e6 = r2.fields.find((e7) => e7.name.toLowerCase() === t4);
      e6 && (t4 = e6.name);
    }
    return t4;
  }
  readTypes(e5, r2) {
    e5 = (r2 = r2.layerDefinition || r2).types;
    const t4 = r2.editFieldsInfo, i6 = t4 == null ? void 0 : t4.creatorField, o5 = t4 == null ? void 0 : t4.editorField;
    return e5 == null ? void 0 : e5.map((e6) => (e6 = n7.fromJSON(e6), this._fixTemplates(e6.templates, i6), this._fixTemplates(e6.templates, o5), e6));
  }
  readVisible(e5, r2) {
    var _a;
    return null != ((_a = r2.layerDefinition) == null ? void 0 : _a.defaultVisibility) ? !!r2.layerDefinition.defaultVisibility : null != r2.visibility ? !!r2.visibility : void 0;
  }
  async addAttachment(e5, r2) {
    return m5(this, e5, r2, Ue);
  }
  async updateAttachment(e5, r2, t4) {
    return w2(this, e5, r2, t4, Ue);
  }
  async applyEdits(e5, r2) {
    return b4(this, e5, r2);
  }
  async uploadAssets(e5, r2) {
    return g2(this, e5, r2);
  }
  on(e5, r2) {
    return super.on(e5, r2);
  }
  createPopupTemplate(e5) {
    return p3(this, e5);
  }
  async createGraphicsSource(e5) {
    if (this._hasMemorySource() && this.source)
      return this.source.load({ signal: e5 });
    const { default: r2 } = await h(import("./FeatureLayerSource-GYVCG4HY.js"), e5);
    return new r2({ layer: this, supportedSourceTypes: this.supportedSourceTypes }).load({ signal: e5 });
  }
  createQuery() {
    const e5 = x(this);
    e5.dynamicDataSource = this.dynamicDataSource;
    const r2 = null != this.subtypeCode ? `${this.subtypeField} = ${this.subtypeCode}` : null, t4 = n4(this.definitionExpression, r2);
    return e5.where = t4 || "1=1", e5;
  }
  async deleteAttachments(e5, r2) {
    return j4(this, e5, r2, Ue);
  }
  async fetchRecomputedExtents(e5) {
    return I3(this, e5, Ue);
  }
  getFeatureType(e5) {
    const { typeIdField: r2, types: t4 } = this;
    if (!r2 || !e5)
      return null;
    const i6 = e5.attributes ? e5.attributes[r2] : void 0;
    if (null == i6)
      return null;
    let o5 = null;
    return t4 == null ? void 0 : t4.some((e6) => {
      const { id: r3 } = e6;
      return null != r3 && (r3.toString() === i6.toString() && (o5 = e6), !!o5);
    }), o5;
  }
  getFieldDomain(e5, r2) {
    const t4 = r2 == null ? void 0 : r2.feature, i6 = this.getFeatureType(t4);
    if (i6) {
      const r3 = i6.domains && i6.domains[e5];
      if (r3 && "inherited" !== r3.type)
        return r3;
    }
    return this._getLayerDomain(e5);
  }
  getField(e5) {
    return this.fieldsIndex.get(e5);
  }
  async queryAttachments(e5, r2) {
    return q(this, e5, r2, Ue);
  }
  async queryFeatures(e5, r2) {
    const t4 = await this.load(), i6 = await t4.source.queryFeatures(b3.from(e5) ?? t4.createQuery(), r2);
    if (i6 == null ? void 0 : i6.features)
      for (const o5 of i6.features)
        o5.layer = o5.sourceLayer = t4;
    return i6;
  }
  async queryObjectIds(e5, r2) {
    return F(this, e5, r2, Ue);
  }
  async queryFeatureCount(e5, r2) {
    return A2(this, e5, r2, Ue);
  }
  async queryExtent(e5, r2) {
    return O(this, e5, r2, Ue);
  }
  async queryRelatedFeatures(e5, r2) {
    return P(this, e5, r2, Ue);
  }
  async queryRelatedFeaturesCount(e5, r2) {
    return E(this, e5, r2, Ue);
  }
  async queryTopFeatures(e5, r2) {
    var _a;
    const { source: t4, capabilities: i6 } = await this.load();
    if (!t4.queryTopFeatures || !((_a = i6 == null ? void 0 : i6.query) == null ? void 0 : _a.supportsTopFeaturesQuery))
      throw new s(Ue, "Layer source does not support queryTopFeatures capability");
    const o5 = await t4.queryTopFeatures(S3.from(e5), r2);
    if (o5 == null ? void 0 : o5.features)
      for (const s4 of o5.features)
        s4.layer = s4.sourceLayer = this;
    return o5;
  }
  async queryTopObjectIds(e5, r2) {
    const { source: t4, capabilities: i6 } = await this.load();
    if (!t4.queryTopObjectIds || !(i6 == null ? void 0 : i6.query.supportsTopFeaturesQuery))
      throw new s(Ue, "Layer source does not support queryTopObjectIds capability");
    return t4.queryTopObjectIds(S3.from(e5), r2);
  }
  async queryTopFeaturesExtent(e5, r2) {
    var _a;
    const { source: t4, capabilities: i6 } = await this.load();
    if (!t4.queryTopExtents || !((_a = i6 == null ? void 0 : i6.query) == null ? void 0 : _a.supportsTopFeaturesQuery))
      throw new s(Ue, "Layer source does not support queryTopExtents capability");
    return t4.queryTopExtents(S3.from(e5), r2);
  }
  async queryTopFeatureCount(e5, r2) {
    var _a;
    const { source: t4, capabilities: i6 } = await this.load();
    if (!t4.queryTopCount || !((_a = i6 == null ? void 0 : i6.query) == null ? void 0 : _a.supportsTopFeaturesQuery))
      throw new s(Ue, "Layer source does not support queryFeatureCount capability");
    return t4.queryTopCount(S3.from(e5), r2);
  }
  read(e5, r2) {
    const t4 = e5.featureCollection;
    if ((t4 || "Feature Collection" === e5.type) && (this.resourceInfo = e5), t4) {
      const e6 = t4.layers;
      e6 && 1 === e6.length && (super.read(e6[0], r2), null != t4.showLegend && super.read({ showLegend: t4.showLegend }, r2));
    }
    super.read(e5, r2), r2 && "service" === r2.origin && (this.revert(["objectIdField", "fields", "timeInfo", "dateFieldsTimeZone"], "service"), this.spatialReference || this.revert(["spatialReference"], "service"));
  }
  write(e5, r2) {
    r2 = { ...r2, origin: (r2 == null ? void 0 : r2.origin) ?? void 0, writeLayerSchema: (r2 == null ? void 0 : r2.writeLayerSchema) ?? this._hasMemorySource() };
    const { origin: t4, layerContainerType: i6, messages: o5 } = r2;
    if (this.dynamicDataSource)
      return o5 == null ? void 0 : o5.push(Qe(this, "using a dynamic data source cannot be written to web scenes, web maps and feature service items")), null;
    if (this.isTable) {
      if (("web-map" === t4 || "web-scene" === t4) && "tables" !== i6)
        return o5 == null ? void 0 : o5.push(Qe(this, `a table source can only be written to tables, not ${i6}`)), null;
      if (this._hasMemorySource())
        return o5 == null ? void 0 : o5.push(Qe(this, "using an in-memory table source cannot be written to web scenes and web maps")), null;
    } else if (this.loaded && ("web-map" === t4 || "web-scene" === t4) && "tables" === i6)
      return o5 == null ? void 0 : o5.push(Qe(this, "using a non-table source cannot be written to tables in web maps or web scenes")), null;
    return super.write(e5, r2);
  }
  clone() {
    if (this._hasMemorySource())
      throw new s(Ue, `FeatureLayer (title: ${this.title}, id: ${this.id}) created using in-memory source cannot be cloned`);
    return super.clone();
  }
  serviceSupportsSpatialReference(e5) {
    var _a;
    return !!this.loaded && ("memory" === ((_a = this.source) == null ? void 0 : _a.type) || e3(this, e5));
  }
  async save(e5) {
    return this._debouncedSaveOperations(A.SAVE, e5);
  }
  async saveAs(e5, r2) {
    return this._debouncedSaveOperations(A.SAVE_AS, r2, e5);
  }
  _readEditingEnabled(e5, r2, t4) {
    var _a;
    let i6 = (_a = e5.layerDefinition) == null ? void 0 : _a.capabilities;
    return i6 ? this._hasEditingCapability(i6) : (i6 = e5.capabilities, r2 && "web-map" === (t4 == null ? void 0 : t4.origin) && !this._hasMemorySource() && i6 ? this._hasEditingCapability(i6) : void 0);
  }
  _hasEditingCapability(e5) {
    return e5.toLowerCase().split(",").map((e6) => e6.trim()).includes("editing");
  }
  _writeEditingEnabled(e5, r2, t4, i6) {
    var _a, _b;
    if (!e5) {
      const e6 = ((_b = (_a = this.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsSync) ? "Query,Sync" : "Query";
      o("layerDefinition.capabilities", e6, r2), t4 && !(i6 == null ? void 0 : i6.writeLayerSchema) && (r2.capabilities = e6);
    }
  }
  _getLayerDomain(e5) {
    const r2 = this.fieldsIndex.get(e5);
    return r2 ? r2.domain : null;
  }
  _fetchFirstValidLayerId(e5) {
    return U(this.url, { query: { f: "json", ...this.customParameters, token: this.apiKey }, responseType: "json", signal: e5 }).then((e6) => {
      const r2 = e6.data;
      if (r2)
        return this.findFirstValidLayerId(r2);
    });
  }
  async initLayerProperties(e5) {
    var _a;
    return this._set("source", e5), e5.sourceJSON && (this.sourceJSON = e5.sourceJSON, this.read(e5.sourceJSON, { origin: "service", portalItem: this.portalItem, portal: (_a = this.portalItem) == null ? void 0 : _a.portal, url: this.parsedUrl })), this._verifySource(), this._verifyFields(), p7(this.renderer, this.fieldsIndex), g3(this.timeInfo, this.fieldsIndex), t(this, { origin: "service" });
  }
  async hasDataChanged() {
    return S4(this);
  }
  async fetchPublishingStatus() {
    const e5 = this.source;
    return (e5 == null ? void 0 : e5.fetchPublishingStatus) ? e5.fetchPublishingStatus() : "unavailable";
  }
  _verifyFields() {
    var _a, _b;
    const e5 = ((_a = this.parsedUrl) == null ? void 0 : _a.path) ?? "undefined";
    this.objectIdField || console.log("FeatureLayer: 'objectIdField' property is not defined (url: " + e5 + ")"), this.isTable || this._hasMemorySource() || -1 !== e5.search(/\/FeatureServer\//i) || ((_b = this.fields) == null ? void 0 : _b.some((e6) => "geometry" === e6.type)) || console.log("FeatureLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: " + e5 + ")");
  }
  _fixTemplates(e5, r2) {
    e5 && e5.forEach((e6) => {
      var _a;
      const t4 = (_a = e6.prototype) == null ? void 0 : _a.attributes;
      t4 && r2 && delete t4[r2];
    });
  }
  _verifySource() {
    if (this._hasMemorySource()) {
      if (this.url)
        throw new s("feature-layer:mixed-source-and-url", "FeatureLayer cannot be created with both an in-memory source and a url");
    } else if (!this.url)
      throw new s("feature-layer:source-or-url-required", "FeatureLayer requires either a url, a valid portal item or a source");
  }
  _initMemorySource(e5) {
    e5.forEach((e6) => {
      e6.layer = this, e6.sourceLayer = this;
    }), this.addHandles([e5.on("after-add", (e6) => {
      e6.item.layer = this, e6.item.sourceLayer = this;
    }), e5.on("after-remove", (e6) => {
      e6.item.layer = null, e6.item.sourceLayer = null;
    })], "fl-source");
  }
  _resetMemorySource(e5) {
    e5.forEach((e6) => {
      e6.layer = null, e6.sourceLayer = null;
    }), this.removeHandles("fl-source");
  }
  _hasMemorySource() {
    return !(this.url || !this.source);
  }
  findFirstValidLayerId(e5) {
    return Array.isArray(e5.layers) && e5.layers.length > 0 ? e5.layers[0].id : Array.isArray(e5.tables) && e5.tables.length > 0 ? e5.tables[0].id : void 0;
  }
};
e([o2("service", "capabilities")], Je.prototype, "readCapabilities", null), e([y({ json: { origins: { "web-scene": { write: false } }, write: true } })], Je.prototype, "charts", void 0), e([y({ readOnly: true })], Je.prototype, "createQueryVersion", null), e([y({ json: { read: { source: "layerDefinition.copyrightText" } } })], Je.prototype, "copyright", void 0), e([y({ json: { read: { source: "layerDefinition.displayField" } } })], Je.prototype, "displayField", void 0), e([y({ types: j3, readOnly: true })], Je.prototype, "defaultSymbol", void 0), e([y({ type: K })], Je.prototype, "dynamicDataSource", void 0), e([y({ type: Boolean })], Je.prototype, "editingEnabled", null), e([o2(["portal-item", "web-scene"], "editingEnabled", ["layerDefinition.capabilities"])], Je.prototype, "readEditingEnabled", null), e([o2("web-map", "editingEnabled", ["capabilities", "layerDefinition.capabilities"])], Je.prototype, "readEditingEnabledFromWebMap", null), e([r(["portal-item", "web-scene"], "editingEnabled", { "layerDefinition.capabilities": { type: String } })], Je.prototype, "writeEditingEnabled", null), e([r("web-map", "editingEnabled", { capabilities: { type: String }, "layerDefinition.capabilities": { type: String } })], Je.prototype, "writeEditingEnabledToWebMap", null), e([y({ readOnly: true })], Je.prototype, "effectiveEditingEnabled", null), e([y({ ...$e.fields, json: { read: { source: "layerDefinition.fields" }, origins: { service: { name: "fields" }, "web-map": { write: { target: "layerDefinition.fields", overridePolicy: Ge } } } } })], Je.prototype, "fields", void 0), e([y($e.fieldsIndex)], Je.prototype, "fieldsIndex", void 0), e([y({ type: y3, json: { name: "formInfo", write: true, origins: { "web-scene": { read: false, write: false } } } })], Je.prototype, "formTemplate", void 0), e([y({ json: { read: { source: "layerDefinition.extent" } } })], Je.prototype, "fullExtent", void 0), e([y({ json: { origins: { "web-map": { write: { target: "layerDefinition.geometryType", overridePolicy: Ge, writer(e5, r2, t4) {
  const i6 = e5 ? f4.toJSON(e5) : null;
  i6 && o(t4, i6, r2);
} } } }, read: { source: "layerDefinition.geometryType", reader: f4.read } } })], Je.prototype, "geometryType", void 0), e([y({ json: { read: { source: "layerDefinition.hasM" } } })], Je.prototype, "hasM", void 0), e([y({ json: { read: { source: "layerDefinition.hasZ" } } })], Je.prototype, "hasZ", void 0), e([y(I2)], Je.prototype, "id", void 0), e([y({ readOnly: true, json: { origins: { service: { read: true } }, read: false } })], Je.prototype, "infoFor3D", void 0), e([y({ json: { origins: { "web-map": { write: { target: "layerDefinition.type" } } } } })], Je.prototype, "isTable", void 0), e([o2("service", "isTable", ["type", "geometryType"]), o2("isTable", ["layerDefinition.type", "layerDefinition.geometryType"])], Je.prototype, "readIsTable", null), e([r("web-map", "isTable")], Je.prototype, "writeIsTable", null), e([y(m3)], Je.prototype, "labelsVisible", void 0), e([y({ type: [C2], json: { origins: { service: { name: "drawingInfo.labelingInfo", read: i4, write: false }, "web-scene": { name: "layerDefinition.drawingInfo.labelingInfo", read: i4, write: { enabled: true, layerContainerTypes: a4 } } }, name: "layerDefinition.drawingInfo.labelingInfo", read: i4, write: true } })], Je.prototype, "labelingInfo", void 0), e([y((() => {
  const e5 = a(b);
  return e5.json.origins["portal-item"] = { write: { target: "layerDefinition.drawingInfo.transparency", writer(e6, r2, t4) {
    o(t4, n6(e6), r2);
  } } }, e5;
})())], Je.prototype, "opacity", void 0), e([y(c)], Je.prototype, "legendEnabled", void 0), e([y({ type: ["show", "hide"], json: (() => {
  const e5 = a(C.json);
  return e5.origins["portal-item"] = { read: false, write: false }, e5;
})() })], Je.prototype, "listMode", void 0), e([o2("globalIdField", ["layerDefinition.globalIdField", "layerDefinition.fields"])], Je.prototype, "readGlobalIdField", null), e([y({ json: { origins: { "web-map": { write: { target: "layerDefinition.objectIdField", overridePolicy: Ge } } } } })], Je.prototype, "objectIdField", void 0), e([o2("objectIdField", ["layerDefinition.objectIdField", "layerDefinition.fields"])], Je.prototype, "readObjectIdField", null), e([y({ value: "ArcGISFeatureLayer", type: ["ArcGISFeatureLayer"] })], Je.prototype, "operationalLayerType", void 0), e([y($e.outFields)], Je.prototype, "outFields", void 0), e([y({ readOnly: true })], Je.prototype, "parsedUrl", null), e([y({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], Je.prototype, "path", void 0), e([y(y2)], Je.prototype, "popupEnabled", void 0), e([y({ type: P2, json: { name: "popupInfo", write: true } })], Je.prototype, "popupTemplate", void 0), e([y({ readOnly: true })], Je.prototype, "defaultPopupTemplate", null), e([y({ types: m4, json: { origins: { service: { write: { target: "drawingInfo.renderer", enabled: false } }, "web-scene": { types: u2, name: "layerDefinition.drawingInfo.renderer", write: { layerContainerTypes: a4, overridePolicy: (e5, r2, t4) => ({ ignoreOrigin: t4 == null ? void 0 : t4.writeLayerSchema }) } } }, write: { target: "layerDefinition.drawingInfo.renderer", overridePolicy: (e5, r2, t4) => ({ ignoreOrigin: t4 == null ? void 0 : t4.writeLayerSchema }) } } })], Je.prototype, "renderer", null), e([o2("service", "renderer", ["drawingInfo.renderer", "defaultSymbol"]), o2("renderer", ["layerDefinition.drawingInfo.renderer", "layerDefinition.defaultSymbol"])], Je.prototype, "readRenderer", null), e([y()], Je.prototype, "resourceInfo", void 0), e([y((() => {
  const e5 = a(p2);
  return e5.json.origins["portal-item"] = { read: false, write: false }, e5;
})())], Je.prototype, "screenSizePerspectiveEnabled", void 0), e([y({ clonable: false })], Je.prototype, "source", null), e([s2("source")], Je.prototype, "castSource", null), e([o2("portal-item", "source", ["featureSet"]), o2("web-map", "source", ["featureSet"])], Je.prototype, "readSource", null), e([y({ json: { read: { source: "layerDefinition.extent.spatialReference" } } })], Je.prototype, "spatialReference", void 0), e([y({ type: Number })], Je.prototype, "subtypeCode", void 0), e([y({ type: [p6] })], Je.prototype, "templates", void 0), e([o2("templates", ["editFieldsInfo", "creatorField", "editorField", "templates"])], Je.prototype, "readTemplates", null), e([y({ type: d2 })], Je.prototype, "timeInfo", void 0), e([y()], Je.prototype, "title", void 0), e([o2("service", "title", ["name"]), o2("portal-item", "title", ["layerDefinition.title", "layerDefinition.name", "title"])], Je.prototype, "readTitle", null), e([o2("web-map", "title", ["layerDefinition.name", "title"])], Je.prototype, "readTitleFromWebMap", null), e([y({ type: String })], Je.prototype, "sublayerTitleMode", void 0), e([y({ json: { read: false } })], Je.prototype, "type", void 0), e([y({ type: String })], Je.prototype, "typeIdField", void 0), e([o2("service", "typeIdField"), o2("typeIdField", ["layerDefinition.typeIdField"])], Je.prototype, "readTypeIdField", null), e([y({ type: [n7] })], Je.prototype, "types", void 0), e([o2("service", "types", ["types"]), o2("types", ["layerDefinition.types"])], Je.prototype, "readTypes", null), e([y({ type: Boolean, json: { origins: { "portal-item": { write: { target: "layerDefinition.defaultVisibility" } } } } })], Je.prototype, "visible", void 0), e([o2("portal-item", "visible", ["visibility", "layerDefinition.defaultVisibility"])], Je.prototype, "readVisible", null), Je = e([a3("esri.layers.FeatureLayer")], Je);
var We = Je;

export {
  We
};
//# sourceMappingURL=chunk-EWD7I5UU.js.map
