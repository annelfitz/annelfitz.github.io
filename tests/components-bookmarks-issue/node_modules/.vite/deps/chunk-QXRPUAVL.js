import {
  n as n4
} from "./chunk-M5UX4IRZ.js";
import {
  n as n3
} from "./chunk-KN52PCW4.js";
import {
  E as E3,
  L as L3,
  M,
  S as S4,
  c as c3,
  d as d3,
  f as f4,
  h as h5,
  m as m5,
  w as w2,
  y
} from "./chunk-HRDKP7QO.js";
import {
  o as o5
} from "./chunk-BHOYA5LV.js";
import {
  t as t8
} from "./chunk-6RR3WN7W.js";
import {
  A,
  B as B2,
  Bn,
  Bt,
  C as C2,
  C2 as C3,
  Ct,
  D as D2,
  Dt,
  E as E2,
  F as F2,
  F2 as F3,
  F3 as F4,
  G,
  G2,
  H,
  H2,
  H3,
  I as I2,
  I2 as I3,
  J,
  K as K3,
  Nt,
  O as O2,
  P,
  P2,
  P3,
  R,
  S,
  S2,
  S3,
  Sn,
  St,
  T,
  U as U2,
  Un,
  Wn,
  Xt,
  Y,
  Zt,
  _ as _3,
  a as a2,
  a2 as a3,
  b,
  bn,
  c as c2,
  d,
  d2,
  ee,
  f,
  f2,
  f3,
  g,
  g2,
  h as h2,
  h2 as h3,
  h3 as h4,
  i as i2,
  j,
  j2,
  k2,
  kn,
  l2 as l,
  ln,
  m as m3,
  m2 as m4,
  n2,
  nt,
  o as o2,
  o2 as o4,
  p,
  p2,
  q,
  q2,
  q3,
  q4,
  q5,
  r2,
  se,
  sn,
  t as t6,
  t2 as t7,
  te,
  tn,
  tt,
  u as u3,
  v,
  vn,
  w,
  x as x2,
  xt,
  yt,
  z,
  z2
} from "./chunk-4IJED6JM.js";
import {
  o as o3
} from "./chunk-LGIO6OCK.js";
import {
  t2 as t5
} from "./chunk-C5EJV3NW.js";
import {
  i as i3,
  s as s2,
  x
} from "./chunk-IJD65EMQ.js";
import {
  h
} from "./chunk-4YGBWYMD.js";
import {
  K2
} from "./chunk-ZPU7GNG4.js";
import {
  e2,
  m as m2
} from "./chunk-JTUYA5FE.js";
import {
  _ as _2
} from "./chunk-DCBZOZ54.js";
import {
  K,
  L as L2,
  a,
  ct,
  i,
  u as u2
} from "./chunk-AVR3LWTZ.js";
import {
  t as t4
} from "./chunk-FFG7BDAP.js";
import {
  B,
  C,
  D,
  E,
  F,
  I,
  L,
  O,
  U,
  _
} from "./chunk-WKVHVZW2.js";
import {
  t as t3
} from "./chunk-GKMVTGGM.js";
import {
  m
} from "./chunk-NCRCDVOW.js";
import {
  o,
  u
} from "./chunk-BOAEEYBE.js";
import {
  W2 as W
} from "./chunk-UWQ3OYA5.js";
import {
  e,
  t
} from "./chunk-2F6FFF5T.js";
import {
  r
} from "./chunk-QHK5ZYFW.js";
import {
  c2 as c,
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import {
  k,
  t as t2
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/Technique.js
var e3 = class {
  constructor(e5) {
    this.registryName = e5, this.postProcessingEnabled = false, this.overrideStencilRef = null, this.drawPhase = E3.MAP | E3.HITTEST | E3.HIGHLIGHT | E3.DEBUG, this.symbologyPlane = S4.FILL;
  }
  startup() {
  }
  shutdown(s6) {
  }
  postProcess(s6, t13) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/dotDensity/DotDensityPointShader.js
var z3 = class extends I3 {
};
e([f(0, C2)], z3.prototype, "pos", void 0);
var F5 = class extends F4 {
};
var R2 = class extends F3 {
};
e([g(j)], R2.prototype, "dotSize", void 0);
var b2 = class extends F3 {
};
e([g(S)], b2.prototype, "locations", void 0), e([g(j)], b2.prototype, "pixelRatio", void 0), e([g(j)], b2.prototype, "tileZoomFactor", void 0);
var P4 = 1e-6;
var C4 = class extends P {
  vertex(t13) {
    const o9 = new tt(1, 0, 0, 0, -1, 0, 0, 1, 1).multiply(new G2(t13.pos.xy.divide(a), 1)), i7 = se(this.draw.locations, o9.xy), s6 = Bn(this.instance.dotSize.divide(2), new j(1));
    let r6 = new j(0);
    r6 = r6.add(ee(i7.a, new j(P4)).multiply(2));
    let d8 = s6.add(this.instance.dotSize);
    const n11 = this.view.displayViewScreenMat3.multiply(new G2(t13.pos.add(0.5), 1)), a8 = new H2(n11.xy, r6, 1), l5 = this.instance.dotSize.divide(d8), h13 = new j(-1).divide(s6.divide(d8));
    return d8 = d8.multiply(this.draw.pixelRatio.multiply(this.draw.tileZoomFactor)), { glPosition: a8, glPointSize: d8, color: i7, ratio: l5, invEdgeRatio: h13 };
  }
  fragment(t13) {
    const o9 = kn(t13.glPointCoord.subtract(0.5)).multiply(2), e5 = te(new j(0), new j(1), t13.invEdgeRatio.multiply(o9.subtract(t13.ratio)).add(1)), i7 = new w();
    return i7.glFragColor = t13.color.multiply(e5), i7;
  }
};
e([g(R2)], C4.prototype, "instance", void 0), e([g(b2)], C4.prototype, "draw", void 0), e([g(d)], C4.prototype, "view", void 0), e([t(0, m3(z3))], C4.prototype, "vertex", null), e([t(0, m3(F5))], C4.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/dotDensity/DotDensityPolygonShader.js
var D3 = class extends S2 {
};
e([f(3, j)], D3.prototype, "inverseArea", void 0);
var V = class extends F3 {
};
e([g(U2.ofType(H2, 2))], V.prototype, "isActive", void 0), e([g(U2.ofType(H2, 8))], V.prototype, "colors", void 0), e([g(j)], V.prototype, "dotValue", void 0);
var F6 = class extends F3 {
};
e([g(S)], F6.prototype, "dotTexture0", void 0), e([g(S)], F6.prototype, "dotTexture1", void 0), e([g(j)], F6.prototype, "tileZoomFactor", void 0), e([g(j)], F6.prototype, "pixelRatio", void 0), e([g(j)], F6.prototype, "tileDotsOverArea", void 0);
var _4 = class extends P2 {
  _dotThreshold(t13, e5, o9) {
    return t13.divide(e5).divide(o9);
  }
  vertex(t13) {
    const e5 = new tt(2 / a, 0, 0, 0, -2 / a, 0, -1, 1, 1).multiply(new G2(t13.pos, 1)), s6 = this.clip(t13.id), i7 = new H2(e5.xy, s6, 1), r6 = this.storage.getVVData(t13.id).multiply(this.instance.isActive.get(0)).multiply(t13.inverseArea), l5 = this.storage.getDataDrivenData0(t13.id).multiply(this.instance.isActive.get(1)).multiply(t13.inverseArea), d8 = this.draw.tileZoomFactor.multiply(a).divide(this.draw.pixelRatio), a8 = this._dotThreshold(r6, this.instance.dotValue, this.draw.tileDotsOverArea), n11 = this._dotThreshold(l5, this.instance.dotValue, this.draw.tileDotsOverArea), u15 = t13.pos.add(0.5).divide(d8);
    return { glPosition: i7, color: new H2(0, 0, 0, 0), textureCoords: u15, thresholds0: a8, thresholds1: n11 };
  }
  fragment(t13) {
    const e5 = new w(), o9 = se(this.draw.dotTexture0, t13.textureCoords), s6 = se(this.draw.dotTexture1, t13.textureCoords), i7 = t13.thresholds0.subtract(o9), r6 = t13.thresholds1.subtract(s6);
    let l5;
    const a8 = nt.fromColumns(this.instance.colors[0], this.instance.colors[1], this.instance.colors[2], this.instance.colors[3]), n11 = nt.fromColumns(this.instance.colors[4], this.instance.colors[5], this.instance.colors[6], this.instance.colors[7]);
    if (this.blending) {
      const t14 = ee(new j(0), i7), e6 = ee(new j(0), r6), o10 = ln(t14, i7).add(ln(e6, r6)), s7 = ee(o10, new j(0)), d8 = new j(1).subtract(s7), p11 = o10.add(s7), h13 = i7.multiply(t14).divide(p11), c8 = r6.multiply(e6).divide(p11), u15 = a8.multiply(h13).add(n11.multiply(c8));
      l5 = d8.multiply(u15);
    } else {
      const t14 = Bn(q2(i7), q2(r6)), e6 = ee(t14, new j(0)), o10 = new j(1).subtract(e6), s7 = ee(t14, i7), d8 = ee(t14, r6), p11 = a8.multiply(s7).add(n11.multiply(d8));
      l5 = o10.multiply(p11);
    }
    return e5.glFragColor = l5, e5;
  }
  hittest(t13) {
    return q4(this.hittestRequest);
  }
};
e([K3], _4.prototype, "blending", void 0), e([g(V)], _4.prototype, "instance", void 0), e([g(F6)], _4.prototype, "draw", void 0), e([t(0, m3(D3))], _4.prototype, "vertex", null), e([t(0, m3(F4))], _4.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/meshing/definitions.js
var T2 = { [C.BYTE]: 1, [C.UNSIGNED_BYTE]: 1, [C.SHORT]: 2, [C.UNSIGNED_SHORT]: 2, [C.INT]: 4, [C.UNSIGNED_INT]: 4, [C.FLOAT]: 4 };

// node_modules/@arcgis/core/views/2d/engine/webgl/meshing/Mesh.js
var i4 = class {
  constructor(t13, i7) {
    this._boundPart = null;
    const a8 = [];
    for (const e5 of i7.vertex) {
      const s6 = h.createVertex(t13, F.STATIC_DRAW, e5);
      a8.push(s6);
    }
    const u15 = [];
    for (const e5 of i7.index || []) {
      const s6 = h.createIndex(t13, F.STATIC_DRAW, e5);
      u15.push(s6);
    }
    this.groups = [];
    for (const r6 of i7.groups) {
      let o9;
      if (null != r6.index) {
        if (!i7.index)
          throw new Error("No index data.");
        const { BYTES_PER_ELEMENT: t14 } = i7.index[r6.index];
        2 === t14 ? o9 = C.UNSIGNED_SHORT : 4 === t14 && (o9 = C.UNSIGNED_INT);
      }
      const d8 = null != r6.index ? u15[r6.index] : null, c8 = /* @__PURE__ */ new Map(), l5 = {}, p11 = {};
      for (const t14 of r6.attributes) {
        const { name: r7, count: o10, type: e5, offset: s6, normalized: i8, divisor: u16, stride: d9, vertex: f14, location: h13 } = t14, b8 = `vertex-buffer-${f14}`;
        let x7 = l5[b8];
        x7 || (x7 = l5[b8] = []);
        const m12 = new t4(r7, o10, e5, s6, d9, i8, u16);
        x7.push(m12), c8.set(r7, h13), p11[b8] = a8[f14];
      }
      const f13 = new o5(t13, c8, l5, p11, d8);
      this.groups.push({ ...r6, vertexArray: f13, locations: c8, layout: l5, indexing: o9 });
    }
    this.parts = i7.parts;
  }
  bind(t13, r6) {
    this._boundPart = r6;
    const { group: o9 } = this.parts[this._boundPart], { vertexArray: e5 } = this.groups[o9];
    t13.bindVAO(e5);
  }
  draw(r6) {
    if (null == this._boundPart)
      throw new Error("Mesh.bind() has not been called.");
    const { start: o9, count: e5 } = this.parts[this._boundPart], { group: s6 } = this.parts[this._boundPart], { indexing: n11, primitive: i7 } = this.groups[s6];
    n11 ? r6.drawElements(i7, e5, n11, o9 * T2[n11]) : r6.drawArrays(i7, o9, e5);
  }
  unbind(t13) {
    this._boundPart = null, t13.bindVAO(null);
  }
  destroy() {
    for (const { vertexArray: t13 } of this.groups)
      t13.dispose();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/meshing/SimpleMesh.js
var r3 = class _r extends i4 {
  static create(e5, o9) {
    const n11 = [];
    let { stride: s6, hash: l5 } = o9.layout;
    if (null == s6) {
      s6 = 0;
      for (const { count: e6, type: i7, offset: r6 } of o9.layout.attributes) {
        if (null != r6)
          throw new Error("Stride cannot be computed automatically when attribute offsets are supplied explicitly.");
        s6 += e6 * T2[i7];
      }
    }
    let u15 = 0, a8 = 0;
    for (const { count: i7, name: r6, offset: h13, type: m12, normalized: x7 } of o9.layout.attributes) {
      null != h13 && (a8 = h13);
      const e6 = { name: r6, location: u15, vertex: 0, count: i7, type: m12, offset: a8, stride: s6, divisor: 0, normalized: null != x7 && x7 };
      n11.push(e6), u15++, a8 += i7 * T2[m12];
    }
    const c8 = { attributes: n11, primitive: o9.primitive };
    null != o9.index && (c8.index = 0);
    let { count: d8 } = o9;
    if (null == d8 && (d8 = o9.index ? o9.index.length : o9.vertex.byteLength / s6, Math.floor(d8) !== d8))
      throw new Error(`The byte length of vertex data must be an exact multiple of the stride, which is ${s6}.`);
    const p11 = { start: 0, count: d8, group: 0, primitive: o9.primitive }, f13 = { vertex: [o9.vertex], parts: [p11], groups: [c8] };
    null != o9.index && (f13.index = [o9.index]), null == l5 && (l5 = t5(n11));
    return new _r(e5, f13, { hash: l5, attributes: n11, stride: s6 });
  }
  constructor(t13, e5, i7) {
    super(t13, e5), this.layout = i7;
  }
  bind(t13, e5 = 0) {
    super.bind(t13, e5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/dotDensity/DotDensityResources.js
var p3 = class {
  constructor() {
    this._dotTextureSize = 0, this._dotTextures = null, this._dotMesh = null;
  }
  destroy() {
    this._disposeTextures(), this._dotFBO && this._dotFBO.dispose(), this._dotMesh && this._dotMesh.destroy();
  }
  getFBO(t13) {
    if (null == this._dotFBO) {
      const s6 = a, o9 = a, h13 = new e2(s6, o9);
      h13.samplingMode = L.NEAREST, h13.wrapMode = D.CLAMP_TO_EDGE;
      const d8 = new s2(t13, new i3(B.DEPTH_STENCIL, s6, o9));
      this._dotFBO = new x(t13, h13, d8);
    }
    return this._dotFBO;
  }
  getDotDensityMesh(t13) {
    if (null == this._dotMesh) {
      const r6 = a, i7 = r6 * r6, n11 = 2, u15 = new Int16Array(i7 * n11);
      for (let t14 = 0; t14 < r6; t14++)
        for (let e5 = 0; e5 < r6; e5++)
          u15[n11 * (e5 + t14 * r6)] = e5, u15[n11 * (e5 + t14 * r6) + 1] = t14;
      const l5 = [{ count: 2, type: C.UNSIGNED_SHORT, name: "a_position", offset: 0 }], _6 = { hash: t5(l5), attributes: l5, stride: 4 };
      this._dotMesh = r3.create(t13, { primitive: E.POINTS, vertex: u15, count: i7, layout: _6 });
    }
    return this._dotMesh;
  }
  getDotDensityTextures(e5, s6, o9) {
    if (this._dotTextureSize === s6 && this._seed === o9 || (this._disposeTextures(), this._dotTextureSize = s6, this._seed = o9), null === this._dotTextures) {
      const r6 = new t2(o9);
      this._dotTextures = [this._allocDotDensityTexture(e5, s6, r6), this._allocDotDensityTexture(e5, s6, r6)];
    }
    return this._dotTextures;
  }
  _disposeTextures() {
    if (this._dotTextures) {
      for (let t13 = 0; t13 < this._dotTextures.length; t13++)
        this._dotTextures[t13].dispose();
      this._dotTextures = null;
    }
  }
  _allocDotDensityTexture(t13, e5, s6) {
    const o9 = new Float32Array(e5 * e5 * 4);
    for (let r6 = 0; r6 < o9.length; r6++)
      o9[r6] = s6.getFloat();
    const i7 = new e2();
    return i7.dataType = U.FLOAT, i7.samplingMode = L.NEAREST, i7.width = e5, i7.height = e5, new m2(t13, i7, o9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/dotDensity/DotDensityTechnique.js
var f5 = class extends e3 {
  constructor() {
    super(...arguments), this.shaders = { polygon: new _4(), point: new C4(), fill: new x2() }, this.meshWriter = a3.DotDensityMeshWriter, this._resources = /* @__PURE__ */ new Map();
  }
  render(e5, t13) {
    f4(e5) || m5(e5) ? this._renderPolygons(e5, t13) : this._renderDotDensity(e5, t13);
  }
  _renderPolygons(e5, t13) {
    const { context: i7, painter: o9 } = e5;
    o9.setShader({ shader: this.shaders.fill, uniforms: { ...h5(e5, t13.target), visualVariableColor: null, visualVariableOpacity: null }, defines: { ...y(e5) }, optionalAttributes: { zoomRange: false }, useComputeBuffer: m5(e5) }), o9.setPipelineState(M(e5)), o9.submitDraw(i7, t13);
  }
  _renderDotDensity(o9, r6) {
    const { context: d8, painter: u15, requiredLevel: c8 } = o9, h13 = r6.instance.getInput(), p11 = this._getOrCreateResourcesRecord(d8), m12 = p11.getDotDensityTextures(d8, a, h13.seed), f13 = 1 / 2 ** (c8 - r6.target.key.level), g6 = a, x7 = g6 * window.devicePixelRatio * g6 * window.devicePixelRatio, D4 = 1 / f13 * (1 / f13), b8 = h13.dotScale ? o9.state.scale / h13.dotScale : 1, y5 = h13.dotValue * b8 * D4;
    u15.setShader({ shader: this.shaders.polygon, uniforms: { ...h5(o9, r6.target), instance: { isActive: h13.isActive, colors: h13.colors, dotValue: Math.max(1, y5) }, draw: { dotTexture0: { unit: K, texture: m12[0] }, dotTexture1: { unit: L2, texture: m12[1] }, tileZoomFactor: f13, pixelRatio: window.devicePixelRatio, tileDotsOverArea: x7 / (a * window.devicePixelRatio * a * window.devicePixelRatio) } }, defines: { ...y(o9), blending: h13.blending }, optionalAttributes: {}, useComputeBuffer: false }), u15.setPipelineState(M(o9));
    const R4 = d8.getViewport();
    d8.setViewport(0, 0, a, a);
    const P5 = d8.getBoundFramebufferObject(), S7 = p11.getFBO(d8);
    d8.bindFramebuffer(S7), d8.setClearColor(0, 0, 0, 0), u15.setPipelineState({ color: { write: [true, true, true, true], blendMode: "composite" }, depth: false, stencil: false }), u15.updatePipelineState(d8), d8.clear(_.COLOR_BUFFER_BIT), u15.submitDraw(d8, r6), d8.bindFramebuffer(P5), d8.setViewport(R4.x, R4.y, R4.width, R4.height);
    const v5 = p11.getFBO(d8).colorTexture;
    u15.setShader({ shader: this.shaders.point, uniforms: { view: c3(o9, r6.target), instance: { dotSize: h13.dotSize }, draw: { locations: { unit: K, texture: v5 }, tileZoomFactor: 1, pixelRatio: window.devicePixelRatio } }, defines: { ...y(o9) }, optionalAttributes: {}, useComputeBuffer: false }), u15.setPipelineState({ color: { write: [true, true, true, true], blendMode: "composite" }, depth: false, stencil: false }), u15.submitDrawMesh(d8, p11.getDotDensityMesh(d8));
  }
  shutdown(e5) {
    var _a;
    super.shutdown(e5), (_a = this._resources.get(e5)) == null ? void 0 : _a.destroy(), this._resources.delete(e5);
  }
  _getOrCreateResourcesRecord(e5) {
    let t13 = this._resources.get(e5);
    return null == t13 && (t13 = new p3(), this._resources.set(e5, t13)), t13;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/ComplexFillTechnique.js
var h6 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.ComplexFillMeshWriter, this.shaders = { geometry: new E2() };
  }
  render(a8, n11) {
    const { context: m12, painter: h13 } = a8;
    h13.setShader({ shader: this.shaders.geometry, uniforms: { ...d3(a8, n11.target, n11.instance.getInput().geometry), ...h5(a8, n11.target), mosaicInfo: h13.textureManager.getMosaicInfo(m12, n11.textureKey), localTileOffset: w2(n11.target) }, defines: { ...y(a8) }, optionalAttributes: n11.instance.optionalAttributes, useComputeBuffer: m5(a8) }), h13.setPipelineState(M(a8)), h13.submitDraw(m12, n11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/line/utils.js
function n5(n11) {
  const t13 = 1 / n11;
  return { antialiasing: t13, blur: 0 + t13 };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/ComplexOutlineFillTechnique.js
var u4 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.ComplexOutlineFillMeshWriter, this.shaders = { geometry: new C3() };
  }
  render(n11, l5) {
    const { context: m12, painter: u15, pixelRatio: p11 } = n11;
    u15.setShader({ shader: this.shaders.geometry, uniforms: { ...d3(n11, l5.target, l5.instance.getInput().geometry), ...h5(n11, l5.target), antialiasingControls: n5(p11), mosaicInfo: u15.textureManager.getMosaicInfo(m12, l5.textureKey), localTileOffset: w2(l5.target) }, defines: { ...y(n11) }, optionalAttributes: l5.instance.optionalAttributes, useComputeBuffer: m5(n11) }), u15.setPipelineState(M(n11)), u15.submitDraw(m12, l5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/FillTechnique.js
var m6 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.FillMeshWriter, this.shaders = { geometry: new x2() };
  }
  render(o9, n11) {
    const { context: a8, painter: m12 } = o9;
    m12.setShader({ shader: this.shaders.geometry, uniforms: { ...d3(o9, n11.target, n11.instance.getInput().geometry), ...h5(o9, n11.target) }, defines: y(o9), optionalAttributes: n11.instance.optionalAttributes, useComputeBuffer: m5(o9) }), m12.setPipelineState(M(o9)), m12.submitDraw(a8, n11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/OutlineFillTechnique.js
var l2 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.OutlineFillMeshWriter, this.shaders = { geometry: new H3() };
  }
  render(o9, a8) {
    const { context: m12, painter: l5, pixelRatio: u15 } = o9;
    l5.setShader({ shader: this.shaders.geometry, uniforms: { ...d3(o9, a8.target, a8.instance.getInput().geometry), ...h5(o9, a8.target), antialiasingControls: n5(u15) }, defines: { ...y(o9) }, optionalAttributes: a8.instance.optionalAttributes, useComputeBuffer: m5(o9) }), l5.setPipelineState(M(o9)), l5.submitDraw(m12, a8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/PatternFillTechnique.js
var h7 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.PatternFillMeshWriter, this.shaders = { geometry: new z2() };
  }
  render(a8, n11) {
    const { context: m12, painter: h13 } = a8;
    h13.setShader({ shader: this.shaders.geometry, uniforms: { ...d3(a8, n11.target, n11.instance.getInput().geometry), ...h5(a8, n11.target), mosaicInfo: h13.textureManager.getMosaicInfo(m12, n11.textureKey), localTileOffset: w2(n11.target) }, defines: { ...y(a8) }, optionalAttributes: n11.instance.optionalAttributes, useComputeBuffer: m5(a8) }), h13.setPipelineState(M(a8)), h13.submitDraw(m12, n11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/PatternOutlineFillTechnique.js
var u5 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.PatternOutlineFillMeshWriter, this.shaders = { geometry: new S3() };
  }
  render(n11, l5) {
    const { context: m12, painter: u15, pixelRatio: h13 } = n11;
    u15.setShader({ shader: this.shaders.geometry, uniforms: { ...d3(n11, l5.target, l5.instance.getInput().geometry), ...h5(n11, l5.target), antialiasingControls: n5(h13), mosaicInfo: u15.textureManager.getMosaicInfo(m12, l5.textureKey), localTileOffset: w2(l5.target) }, defines: { ...y(n11) }, optionalAttributes: l5.instance.optionalAttributes, useComputeBuffer: m5(n11) }), u15.setPipelineState(M(n11)), u15.submitDraw(m12, l5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/heatmap/HeatmapResources.js
var m7 = () => n.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.heatmap.HeatmapResources");
var f6 = class {
  destroy() {
    this._accumulateFramebuffer = r(this._accumulateFramebuffer), this._resolveGradientTexture = r(this._resolveGradientTexture), this._prevGradientHash = null, this._qualityProfile = null;
  }
  get initialized() {
    return null != this._accumulateFramebuffer && null != this._resolveGradientTexture;
  }
  get accumulateFramebuffer() {
    return this._accumulateFramebuffer;
  }
  get resolveGradientTexture() {
    return this._resolveGradientTexture;
  }
  loadQualityProfile(e5) {
    if (null == this._qualityProfile) {
      const r6 = n4(e5, m7());
      this._qualityProfile = { ...r6, defines: { usesHalfFloatPrecision: r6.dataType !== U.FLOAT } };
    }
    return this._qualityProfile;
  }
  ensureAccumulateFBO(e5, r6, t13) {
    if (null == this._accumulateFramebuffer) {
      const { dataType: u15, samplingMode: o9, pixelFormat: m12, internalFormat: f13 } = this.loadQualityProfile(e5), h13 = new e2(r6, t13);
      h13.pixelFormat = m12, h13.internalFormat = f13, h13.dataType = u15, h13.samplingMode = o9, h13.wrapMode = D.CLAMP_TO_EDGE;
      const c8 = new i3(B.DEPTH_STENCIL, r6, t13);
      this._accumulateFramebuffer = new x(e5, h13, c8);
    } else {
      const { width: e6, height: a8 } = this._accumulateFramebuffer;
      e6 === r6 && a8 === t13 || this._accumulateFramebuffer.resize(r6, t13);
    }
    return this._accumulateFramebuffer;
  }
  ensureResolveGradientTexture(e5, r6, t13) {
    if (null == this._resolveGradientTexture) {
      const r7 = new e2();
      r7.wrapMode = D.CLAMP_TO_EDGE, this._resolveGradientTexture = new m2(e5, r7);
    } else
      this._prevGradientHash !== r6 && (this._resolveGradientTexture.resize(t13.length / 4, 1), this._resolveGradientTexture.setData(t13), this._prevGradientHash = r6);
    return this._resolveGradientTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/heatmapUtils.js
function n6(n11) {
  return n11 ? 0.25 : 1;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/HeatmapAccumulateShader.js
var v2 = class extends S2 {
};
e([f(5, C2)], v2.prototype, "offset", void 0);
var x3 = class extends F4 {
};
var g3 = class extends F3 {
};
e([g(j)], g3.prototype, "radius", void 0), e([g(j)], g3.prototype, "isFieldActive", void 0);
var F7 = class extends P2 {
  constructor() {
    super(...arguments), this.usesHalfFloatPrecision = false;
  }
  vertex(t13) {
    const { radius: e5, isFieldActive: s6 } = this.kernelControls, i7 = t13.offset, o9 = s6.multiply(this.storage.getVVData(t13.id).x).add(new j(1).subtract(s6)), l5 = this.view.displayViewScreenMat3.multiply(new G2(t13.pos, 1)).add(this.view.displayViewMat3.multiply(new G2(i7, 0)).multiply(e5)), r6 = this.clip(t13.id);
    return { glPosition: new H2(l5.xy, r6, 1), offset: i7, fieldValue: o9, color: new H2(0), ...this.maybeRunHittest(t13, {}, null) };
  }
  fragment(t13) {
    const { offset: e5, fieldValue: s6 } = t13, i7 = kn(e5), o9 = ee(i7, new j(1)), l5 = new j(1).subtract(i7.multiply(i7)), r6 = l5.multiply(l5), a8 = o9.multiply(r6).multiply(s6).multiply(new j(n6(this.usesHalfFloatPrecision)));
    return this.getFragmentOutput(new H2(a8), t13);
  }
  hittest(t13) {
    const { viewMat3: e5, tileMat3: s6 } = this.view, i7 = e5.multiply(s6).multiply(new G2(t13.pos, 1));
    return R(i7.xy, this.kernelControls.radius, this.hittestRequest.position);
  }
};
e([K3], F7.prototype, "usesHalfFloatPrecision", void 0), e([g(g3)], F7.prototype, "kernelControls", void 0), e([t(0, m3(v2))], F7.prototype, "vertex", null), e([t(0, m3(x3))], F7.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/HeatmapResolveShader.js
var x4 = class extends I3 {
};
e([f(0, C2)], x4.prototype, "pos", void 0);
var f7 = class extends v {
};
var h8 = class extends F3 {
};
e([g(S)], h8.prototype, "texture", void 0), e([g(C2)], h8.prototype, "minAndInvRange", void 0), e([g(j)], h8.prototype, "normalization", void 0);
var w3 = class extends F3 {
};
e([g(S)], w3.prototype, "texture", void 0);
var b3 = class extends P {
  constructor() {
    super(...arguments), this.usesHalfFloatPrecision = false;
  }
  vertex(t13) {
    return { glPosition: new H2(t13.pos.multiply(2).subtract(1), 1, 1), uv: t13.pos };
  }
  fragment(t13) {
    const { accumulatedDensity: e5, gradient: o9 } = this;
    let r6 = se(e5.texture, t13.uv).r.multiply(new j(n6(this.usesHalfFloatPrecision)));
    r6 = r6.multiply(e5.normalization), r6 = r6.subtract(e5.minAndInvRange.x).multiply(e5.minAndInvRange.y);
    const s6 = se(o9.texture, new C2(r6, 0.5)), n11 = new w();
    return n11.glFragColor = new H2(s6.rgb.multiply(s6.a), s6.a), n11;
  }
};
e([K3], b3.prototype, "usesHalfFloatPrecision", void 0), e([g(h8)], b3.prototype, "accumulatedDensity", void 0), e([g(w3)], b3.prototype, "gradient", void 0), e([t(0, m3(x4))], b3.prototype, "vertex", null), e([t(0, m3(f7))], b3.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/heatmap/HeatmapTechnique.js
var p4 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.HeatmapMeshWriter, this.shaders = { accumulate: new F7(), resolve: new b3() }, this.postProcessingEnabled = true, this._isBound = false, this._resources = /* @__PURE__ */ new Map(), this.overrideStencilRef = f8;
  }
  shutdown(e5) {
    var _a;
    super.shutdown(e5), (_a = this._resources.get(e5)) == null ? void 0 : _a.destroy(), this._resources.delete(e5), this._prevFBO = null, this._unbind();
  }
  render(i7, n11) {
    const { context: o9, painter: u15, state: a8 } = i7, d8 = n11.instance.getInput(), { isFieldActive: h13 } = d8, l5 = this._getOrCreateResourcesRecord(o9), c8 = l5.loadQualityProfile(o9);
    if (f4(i7))
      return;
    m5(i7) || this._bind(i7, l5, d8), u15.setShader({ shader: this.shaders.accumulate, uniforms: { ...h5(i7, n11.target), kernelControls: { radius: g4(d8, a8), isFieldActive: h13 ? 1 : 0 } }, defines: { ...y(i7), ...c8.defines }, optionalAttributes: n11.instance.optionalAttributes, useComputeBuffer: m5(i7) });
    const p11 = m5(i7) ? b4 : _5;
    u15.setPipelineState(p11), u15.submitDraw(o9, n11);
  }
  postProcess(r6, s6) {
    if (m5(r6) || f4(r6))
      return;
    const { context: i7, painter: n11 } = r6, o9 = this._resources.get(i7);
    if (null == this._prevFBO || null == this._prevViewport || !(o9 == null ? void 0 : o9.initialized))
      return;
    const { defines: u15 } = o9.loadQualityProfile(i7), { minDensity: a8, maxDensity: d8, radius: h13 } = s6.getInput(), l5 = 8, c8 = 9, p11 = o9.accumulateFramebuffer, m12 = o9.resolveGradientTexture;
    n11.setShader({ shader: this.shaders.resolve, uniforms: { accumulatedDensity: { texture: { unit: l5, texture: p11.colorTexture }, minAndInvRange: [a8, 1 / (d8 - a8)], normalization: 3 / (h13 * h13 * Math.PI) }, gradient: { texture: { unit: c8, texture: m12 } } }, defines: u15, optionalAttributes: {}, useComputeBuffer: false }), i7.bindFramebuffer(this._prevFBO), i7.setViewport(0, 0, this._prevViewport.width, this._prevViewport.height), i7.bindTexture(p11.colorTexture, l5), i7.bindTexture(m12, c8), n11.setPipelineState(w4), n11.submitDrawQuad(i7), this._unbind();
  }
  _getOrCreateResourcesRecord(e5) {
    let t13 = this._resources.get(e5);
    return null == t13 && (t13 = new f6(), this._resources.set(e5, t13)), t13;
  }
  _unbind() {
    this._prevFBO = null, this._prevViewport = null, this._isBound = false;
  }
  _bind(e5, t13, r6) {
    if (this._isBound)
      return;
    const { context: s6, state: i7, pixelRatio: n11 } = e5, o9 = s6.getBoundFramebufferObject(), u15 = s6.getViewport();
    this._prevFBO = o9, this._prevViewport = u15;
    const { gradient: a8, gradientHash: d8 } = r6;
    t13.ensureResolveGradientTexture(s6, d8, a8);
    const { width: h13, height: p11 } = u15, f13 = m8(g4(r6, i7), n11), _6 = h13 * f13, b8 = p11 * f13, w5 = t13.ensureAccumulateFBO(s6, _6, b8);
    s6.blitFramebuffer(o9, w5, 0, 0, o9.width, o9.height, 0, 0, w5.width, w5.height, _.STENCIL_BUFFER_BIT, L.NEAREST), s6.bindFramebuffer(w5), s6.setViewport(0, 0, w5.width, w5.height), s6.setColorMask(true, true, true, true), s6.setClearColor(0, 0, 0, 0), s6.clear(_.COLOR_BUFFER_BIT), this._isBound = true;
  }
};
function m8(e5, t13) {
  const r6 = t13 > 1.5 ? 0.25 : 0.5;
  return e5 < 1 / (2 * r6) ? 1 : r6;
}
function f8(e5) {
  return e5.key.level + 1;
}
var _5 = { color: { write: [true, true, true, true], blendMode: "additive" }, depth: false, stencil: { write: false, test: { ref: f8, compare: O.GEQUAL, mask: 255, op: { fail: I.KEEP, zFail: I.KEEP, zPass: I.REPLACE } } } };
var b4 = { ..._5, stencil: false };
var w4 = { color: { write: [true, true, true, true], blendMode: "composite" }, depth: false, stencil: false };
function g4(e5, t13) {
  const { referenceScale: r6, radius: s6 } = e5;
  return s6 * (0 !== r6 ? r6 / t13.scale : 1);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/VisualVariableRotation.js
var d4 = class extends F3 {
  getVVRotationMat4(t13) {
    return xt(h2(t13), nt.identity(), () => {
      const e5 = this._getNormalizedAngle(t13).multiply(t6), r6 = Wn(e5), o9 = tn(e5);
      return new nt(o9, r6, 0, 0, r6.multiply(new j(-1)), o9, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    });
  }
  getVVRotationMat3(t13) {
    return xt(h2(t13), tt.identity(), () => {
      const e5 = this._getNormalizedAngle(t13).multiply(t6), r6 = Wn(e5), o9 = tn(e5);
      return new tt(o9, r6, 0, r6.multiply(new j(-1)), o9, 0, 0, 0, 1);
    });
  }
  _getNormalizedAngle(t13) {
    const e5 = Bt(this.rotationType, new j(i2.Arithmatic));
    return xt(e5, new j(90).subtract(t13), t13);
  }
};
e([g(j)], d4.prototype, "rotationType", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/text/TextShader.js
var q6 = 360 / 254;
var G3 = class extends S2 {
};
e([f(3, H2)], G3.prototype, "color", void 0), e([f(4, C2)], G3.prototype, "offset", void 0), e([f(5, C2)], G3.prototype, "textureUV", void 0), e([f(6, j)], G3.prototype, "fontSize", void 0), e([f(7, j)], G3.prototype, "referenceSize", void 0), e([f(8, j)], G3.prototype, "haloFontSize", void 0), e([f(9, H2)], G3.prototype, "haloColor", void 0), e([f(10, C2)], G3.prototype, "zoomRange", void 0), e([f(11, j)], G3.prototype, "clipAngle", void 0), e([f(12, H2)], G3.prototype, "referenceSymbol", void 0);
var Z = class extends b {
};
e([f(13, C2)], Z.prototype, "offsetNextVertex1", void 0), e([f(14, C2)], Z.prototype, "offsetNextVertex2", void 0);
var J2 = class extends F4 {
};
var K4 = class extends P2 {
  constructor() {
    super(...arguments), this.computeAttributes = { offset: ["offsetNextVertex1", "offsetNextVertex2"] }, this.isHaloPass = false, this.isBackgroundPass = false, this.isLabel = false;
  }
  clipLabel(t13, e5, o9) {
    const s6 = e5.multiply(q6), a8 = Xt(this.view.rotation.subtract(s6)), r6 = Un(new j(360).subtract(a8), a8);
    let l5 = new j(0);
    const p11 = vn(this.view.currentZoom.multiply(ct)).divide(ct), n11 = t13.x, h13 = t13.y, v5 = new j(1).subtract(ee(n11, p11)).multiply(2), f13 = ee(new j(90), r6).multiply(2), V4 = new j(2).multiply(new j(1).subtract(ee(p11, h13)));
    return l5 = l5.add(o9.multiply(v5)), l5 = l5.add(o9.multiply(f13)), l5 = l5.add(V4), l5;
  }
  vertex(t13, e5) {
    const i7 = j2(t13.bitset, I2), s6 = new j(1).subtract(i7);
    let a8 = t13.fontSize, r6 = a8.divide(A);
    const l5 = this.isHaloPass ? t13.haloColor : this._getVertexColor(t13), p11 = this.isLabel ? l5.multiply(this.storage.getAnimationValue(t13.id)) : l5, n11 = this.view.displayViewScreenMat3.multiply(new G2(t13.pos, 1));
    let d8 = t13.offset, u15 = new j(1), y5 = tt.identity();
    if (this.isLabel) {
      if (!t13.referenceSymbol)
        throw new Error("InternalError: Optional attribute 'referenceSymbol' expected for labels");
      const e6 = t13.referenceSymbol, i8 = e6.xy, s7 = e6.z, a9 = this._unpackDirection(e6.w), r7 = t7(this, t13.id, s7).divide(2), l6 = a9.multiply(r7.add(u2));
      d8 = d8.add(i8).add(l6);
    } else {
      u15 = t7(this, t13.id, t13.referenceSize).divide(t13.referenceSize), a8 = a8.multiply(u15), r6 = r6.multiply(u15), d8 = d8.multiply(u15), y5 = n2(this, t13.id), d8 = y5.multiply(new G2(d8, 0)).xy;
    }
    const c8 = j2(t13.bitset, J), V4 = this._getViewRotationMatrix(c8).multiply(new G2(d8, 0));
    let b8 = this.isLabel ? this.clipLabel(t13.zoomRange, t13.clipAngle, c8) : this.clip(t13.id, t13.zoomRange);
    b8 = this.isBackgroundPass ? b8.add(s6.multiply(2)) : b8.add(i7.multiply(2));
    const w5 = new H2(n11.xy.add(V4.xy), b8, 1), x7 = t13.textureUV.divide(this.mosaicInfo.size);
    let g6 = new j(0);
    if (this.isHaloPass) {
      g6 = t13.haloFontSize.divide(r6).divide(G);
    }
    return { glPosition: w5, color: p11, size: r6, textureUV: x7, antialiasingWidth: new j(0.105 * A).divide(a8).divide(this.view.pixelRatio), haloDistanceOffset: g6, ...this.maybeRunHittest(t13, e5, { vvSizeAdjustment: u15, vvRotation: y5 }) };
  }
  _getViewRotationMatrix(t13) {
    const e5 = this.view.displayViewMat3, i7 = this.view.displayMat3, o9 = new j(1).subtract(t13);
    return e5.multiply(t13).add(i7.multiply(o9));
  }
  fragment(t13) {
    const e5 = new j(2 / 8), i7 = new j(1).subtract(e5), o9 = se(this.mosaicInfo.texture, t13.textureUV).a;
    let s6 = i7.subtract(t13.haloDistanceOffset);
    this.highlight && (s6 = s6.divide(2));
    const a8 = t13.antialiasingWidth, r6 = te(s6.subtract(a8), s6.add(a8), o9);
    return this.getFragmentOutput(t13.color.multiply(r6), t13);
  }
  hittest(t13, e5, { vvSizeAdjustment: i7, vvRotation: o9 }) {
    const s6 = o9.multiply(new G2(t13.offset.multiply(i7), 0)), a8 = o9.multiply(new G2(e5.offsetNextVertex1.multiply(i7), 0)), r6 = o9.multiply(new G2(e5.offsetNextVertex2.multiply(i7), 0)), { viewMat3: l5, tileMat3: p11 } = this.view, n11 = l5.multiply(p11).multiply(new G2(t13.pos, 1)), d8 = n11.add(p11.multiply(s6)).xy, u15 = n11.add(p11.multiply(a8)).xy, m12 = n11.add(p11.multiply(r6)).xy;
    return P3(this.hittestRequest.position, d8.xy, u15.xy, m12.xy);
  }
  _unpackDirection(t13) {
    const e5 = new O2(t13), i7 = Dt(e5, new O2(2)), o9 = Nt(e5, new O2(3));
    return new C2(new j(i7).subtract(1), new j(o9).subtract(1));
  }
  _getVertexColor(t13) {
    let e5 = t13.color;
    if (this.visualVariableColor) {
      const i7 = this.storage.getColorValue(t13.id);
      e5 = this.visualVariableColor.getColor(i7, t13.color, new Y(false));
    }
    if (this.visualVariableOpacity) {
      const i7 = this.storage.getOpacityValue(t13.id), o9 = this.visualVariableOpacity.getOpacity(i7);
      e5 = e5.multiply(o9);
    }
    return e5;
  }
};
e([_3(f2)], K4.prototype, "visualVariableColor", void 0), e([_3(h4)], K4.prototype, "visualVariableOpacity", void 0), e([_3(d4)], K4.prototype, "visualVariableRotation", void 0), e([_3(m4)], K4.prototype, "visualVariableSizeMinMaxValue", void 0), e([_3(p2)], K4.prototype, "visualVariableSizeScaleStops", void 0), e([_3(f3)], K4.prototype, "visualVariableSizeStops", void 0), e([_3(l)], K4.prototype, "visualVariableSizeUnitValue", void 0), e([g(p)], K4.prototype, "mosaicInfo", void 0), e([K3], K4.prototype, "isHaloPass", void 0), e([K3], K4.prototype, "isBackgroundPass", void 0), e([K3], K4.prototype, "isLabel", void 0), e([t(0, m3(G3)), t(1, m3(Z))], K4.prototype, "vertex", null), e([t(0, m3(J2))], K4.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/labels/LabelTechnique.js
var u6 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.LabelMeshWriter, this.shaders = { geometry: new K4() }, this.drawPhase = E3.LABEL | E3.LABEL_ALPHA, this.symbologyPlane = S4.TEXT;
  }
  render(e5, s6) {
    const { context: o9, painter: n11 } = e5, m12 = y(e5), u15 = { ...M(e5) }, h13 = { shader: this.shaders.geometry, uniforms: { ...d3(e5, s6.target, s6.instance.getInput().geometry), ...h5(e5, s6.target), mosaicInfo: n11.textureManager.getMosaicInfo(o9, s6.textureKey) }, defines: { ...m12, isHaloPass: false, isBackgroundPass: true, isLabel: true }, optionalAttributes: s6.instance.optionalAttributes, useComputeBuffer: false };
    n11.setShader(h13), n11.setPipelineState(u15), n11.submitDraw(o9, s6), n11.setShader({ ...h13, defines: { ...m12, isHaloPass: true, isBackgroundPass: false, isLabel: true } }), n11.setPipelineState(u15), n11.submitDraw(o9, s6), n11.setShader({ ...h13, defines: { ...m12, isHaloPass: false, isBackgroundPass: false, isLabel: true } }), n11.setPipelineState(u15), n11.submitDraw(o9, s6);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/line/LineTechnique.js
var p5 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.LineMeshWriter, this.shaders = { geometry: new B2() }, this.symbologyPlane = S4.LINE;
  }
  render(e5, n11) {
    const { context: m12, painter: h13, pixelRatio: p11 } = e5;
    h13.setShader({ shader: this.shaders.geometry, uniforms: { ...d3(e5, n11.target, n11.instance.getInput().geometry), ...h5(e5, n11.target), antialiasingControls: n5(p11) }, defines: { ...y(e5) }, optionalAttributes: n11.instance.optionalAttributes, useComputeBuffer: m5(e5) }), h13.setPipelineState(M(e5)), h13.submitDraw(m12, n11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/TexturedLineShader.js
var A3 = class extends q5 {
};
e([f(9, j)], A3.prototype, "accumulatedDistance", void 0), e([f(10, C2)], A3.prototype, "segmentDirection", void 0), e([f(11, H2)], A3.prototype, "tlbr", void 0);
var R3 = class extends B2 {
  _getLineWidthRatio(t13, e5) {
    const s6 = new j(o3), a8 = j2(t13.bitset, F2);
    return a8.multiply(Bn(e5, new j(0.25))).add(new j(1).subtract(a8)).divide(s6);
  }
  _getSDFAlpha(t13) {
    const { halfWidth: e5, normal: i7, tlbr: s6, patternSize: a8, accumulatedDistance: n11, lineWidthRatio: l5 } = t13, h13 = a8.x.multiply(new j(2)).multiply(l5), y5 = bn(n11.divide(h13)), w5 = new j(0.25).multiply(i7.y).add(new j(0.5)), f13 = Sn(s6.xy, s6.zw, new C2(y5, w5)), b8 = k2(se(this.mosaicInfo.texture, f13)).subtract(new j(0.5)).multiply(e5), x7 = Zt(new j(0.5).subtract(b8), new j(0), new j(1));
    return new H2(x7);
  }
  _getPatternColor(t13) {
    const { halfWidth: e5, normal: i7, color: s6, accumulatedDistance: a8, patternSize: n11, sampleAlphaOnly: l5, tlbr: p11 } = t13, w5 = n11.y.multiply(new j(2).multiply(e5).divide(n11.x)), f13 = bn(a8.divide(w5)), b8 = new j(0.5).multiply(i7.y).add(new j(0.5)), x7 = Sn(p11.xy, p11.zw, new C2(b8, f13));
    let g6 = se(this.mosaicInfo.texture, x7);
    return null != this.visualVariableColor && (g6 = xt(Ct(l5, new j(0.5)), new H2(s6.a), s6)), g6;
  }
  vertex(t13, e5) {
    const { segmentDirection: i7, tlbr: s6, bitset: a8 } = t13, n11 = T(this, t13), l5 = t13.accumulatedDistance.divide(this.view.displayZoomFactor).add(ln(i7, n11.scaledOffset)), r6 = new C2(s6.z.subtract(s6.x), s6.w.subtract(s6.y)), m12 = s6.divide(this.mosaicInfo.size.xyxy), c8 = j2(a8, H), p11 = j2(a8, q), u15 = xt(Ct(c8, new j(0.5)), this._getLineWidthRatio(t13, n11.scaledHalfWidth), new j(1));
    return { ...n11, tlbr: m12, patternSize: r6, accumulatedDistance: l5, isSDF: c8, sampleAlphaOnly: p11, lineWidthRatio: u15, ...this.maybeRunHittest(t13, e5, n11.halfWidth) };
  }
  fragment(t13) {
    const { color: e5, opacity: i7, isSDF: s6 } = t13, a8 = D2(t13, this.antialiasingControls.blur), n11 = xt(Ct(s6, new j(0.5)), this._getSDFAlpha(t13), this._getPatternColor(t13)), l5 = e5.multiply(i7).multiply(a8).multiply(n11);
    return this.getFragmentOutput(l5, t13);
  }
};
e([g(p)], R3.prototype, "mosaicInfo", void 0), e([t(0, m3(A3)), t(1, m3(q3))], R3.prototype, "vertex", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/line/TexturedLineTechnique.js
var h9 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.TexturedLineMeshWriter, this.shaders = { geometry: new R3() }, this.symbologyPlane = S4.LINE;
  }
  render(e5, n11) {
    const { context: m12, painter: u15, pixelRatio: h13 } = e5;
    u15.setShader({ shader: this.shaders.geometry, uniforms: { ...d3(e5, n11.target, n11.instance.getInput().geometry), ...h5(e5, n11.target), antialiasingControls: n5(h13), mosaicInfo: u15.textureManager.getMosaicInfo(m12, n11.textureKey) }, defines: { ...y(e5) }, optionalAttributes: n11.instance.optionalAttributes, useComputeBuffer: m5(e5) }), u15.setPipelineState(M(e5)), u15.submitDraw(m12, n11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/markers/MarkerShader.js
var Q = class extends S2 {
};
e([f(3, H2)], Q.prototype, "color", void 0), e([f(4, H2)], Q.prototype, "outlineColor", void 0), e([f(5, C2)], Q.prototype, "offset", void 0), e([f(6, C2)], Q.prototype, "textureUV", void 0), e([f(7, H2)], Q.prototype, "sizing", void 0), e([f(8, j)], Q.prototype, "placementAngle", void 0), e([f(9, j)], Q.prototype, "sizeRatio", void 0), e([f(10, C2)], Q.prototype, "zoomRange", void 0);
var W2 = class extends b {
};
e([f(12, C2)], W2.prototype, "offsetNextVertex1", void 0), e([f(13, C2)], W2.prototype, "offsetNextVertex2", void 0), e([f(14, C2)], W2.prototype, "textureUVNextVertex1", void 0), e([f(15, C2)], W2.prototype, "textureUVNextVertex2", void 0);
var X = class extends F4 {
};
function Y2(t13, e5, i7, o9) {
  return e5.multiply(t13.x).add(i7.multiply(t13.y)).add(o9.multiply(t13.z));
}
function Z2(t13) {
  return t13.multiply(t13).divide(128);
}
var $ = class extends P2 {
  constructor() {
    super(...arguments), this.computeAttributes = { offset: ["offsetNextVertex1", "offsetNextVertex2"], textureUV: ["textureUVNextVertex1", "textureUVNextVertex2"] };
  }
  vertex(t13, e5) {
    const i7 = Z2(t13.sizing.x), o9 = Z2(t13.sizing.y), s6 = Z2(t13.sizing.z), l5 = t13.placementAngle, r6 = j2(t13.bitset, o4.bitset.isSDF), y5 = j2(t13.bitset, o4.bitset.isMapAligned), h13 = j2(t13.bitset, o4.bitset.scaleSymbolsProportionally), c8 = z(t13.bitset, o4.bitset.colorLocked), x7 = u3(this, t13.id), V4 = r2(this, t13.id, t13.color, c8).multiply(x7), v5 = this.view.displayViewScreenMat3.multiply(new G2(t13.pos.xy, 1)), w5 = t7(this, t13.id, s6).divide(s6), f13 = i7.multiply(w5), b8 = t13.offset.xy.multiply(w5);
    let S7 = o9.multiply(h13.multiply(w5.subtract(1)).add(1));
    S7 = Un(S7, Bn(f13.subtract(0.99), new j(0)));
    const g6 = Bn(S7, new j(1)), C5 = Un(S7, new j(1)), M3 = tt.fromRotation(l5.multiply(c2)), _6 = n2(this, t13.id), U3 = this._getViewRotationMatrix(y5).multiply(_6).multiply(M3).multiply(new G2(b8.xy, 0)), R4 = this.clip(t13.id, t13.zoomRange), N = new H2(v5.xy.add(U3.xy), R4, 1), F9 = t13.textureUV.divide(this.mosaicInfo.size), D4 = t13.outlineColor.multiply(C5), k3 = j2(t13.bitset, o4.bitset.overrideOutlineColor), A4 = t13.sizeRatio.multiply(f13).multiply(0.5);
    return { glPosition: N, color: V4, textureUV: F9, outlineColor: D4, outlineSize: g6, distanceToPx: A4, isSDF: r6, overrideOutlineColor: k3, ...this.maybeRunHittest(t13, e5, { pos: t13.pos, size: f13, sizeCorrection: w5, isMapAligned: y5, outlineSize: g6, distanceToPx: A4, isSDF: r6 }) };
  }
  fragment(t13) {
    const e5 = this._getColor(t13.textureUV, t13);
    return this.getFragmentOutput(e5, t13);
  }
  hittest(t13, e5, i7) {
    return xt(St(i7.size, this.hittestRequest.smallSymbolSizeThreshold), this._hittestSmallMarker(t13, e5, i7), this._hittestMarker(t13, e5, i7));
  }
  _getViewRotationMatrix(t13) {
    const e5 = this.view.displayViewMat3, i7 = this.view.displayMat3, o9 = new j(1).subtract(t13);
    return e5.multiply(t13).add(i7.multiply(o9));
  }
  _getViewScreenMatrix(t13) {
    const e5 = this.view.viewMat3.multiply(this.view.tileMat3), i7 = this.view.tileMat3, o9 = new j(1).subtract(t13);
    return e5.multiply(t13).add(i7.multiply(o9));
  }
  _getColor(t13, e5) {
    return xt(Bt(e5.isSDF, new j(1)), this._getSDFColor(t13, e5), this._getSpriteColor(t13, e5));
  }
  _getSpriteColor(t13, e5) {
    return se(this.mosaicInfo.texture, t13).multiply(e5.color);
  }
  _getSDFColor(t13, e5) {
    const i7 = se(this.mosaicInfo.texture, t13), o9 = new j(0.5).subtract(k2(i7)).multiply(e5.distanceToPx).multiply(o2), s6 = Zt(new j(0.5).subtract(o9), new j(0), new j(1)), l5 = e5.color.multiply(s6);
    let r6 = e5.outlineSize;
    this.highlight && (r6 = Bn(r6, e5.overrideOutlineColor.multiply(4)));
    const a8 = r6.multiply(0.5), p11 = Xt(o9).subtract(a8), d8 = Zt(new j(0.5).subtract(p11), new j(0), new j(1)), m12 = Sn(e5.outlineColor, e5.color, e5.overrideOutlineColor).multiply(d8);
    return new j(1).subtract(m12.a).multiply(l5).add(m12);
  }
  _hittestSmallMarker(t13, e5, i7) {
    const { position: o9, distance: s6, smallSymbolDistance: l5 } = this.hittestRequest, r6 = s6.subtract(l5), { viewMat3: p11, tileMat3: u15 } = this.view, n11 = p11.multiply(u15).multiply(new G2(i7.pos, 1)).xy, d8 = i7.size.multiply(0.5);
    return sn(n11, o9).subtract(d8).add(r6);
  }
  _hittestMarker(t13, e5, i7) {
    const { pos: o9, size: s6, sizeCorrection: l5, isMapAligned: r6, outlineSize: p11, isSDF: u15, distanceToPx: d8 } = i7, y5 = new G2(t13.offset.multiply(l5), 0), h13 = new G2(e5.offsetNextVertex1.multiply(l5), 0), c8 = new G2(e5.offsetNextVertex2.multiply(l5), 0), { viewMat3: x7, tileMat3: V4 } = this.view, v5 = x7.multiply(V4).multiply(new G2(o9, 1)), w5 = this._getViewScreenMatrix(r6), f13 = v5.add(w5.multiply(y5)).xy, z6 = v5.add(w5.multiply(h13)).xy, C5 = v5.add(w5.multiply(c8)).xy, M3 = this.hittestRequest.position, _6 = this.hittestRequest.distance, j3 = h3(M3.add(new C2(yt(_6), yt(_6))), f13, z6, C5), U3 = h3(M3.add(new C2(0, yt(_6))), f13, z6, C5), D4 = h3(M3.add(new C2(_6, yt(_6))), f13, z6, C5), I4 = h3(M3.add(new C2(yt(_6), 0)), f13, z6, C5), O3 = h3(M3, f13, z6, C5), k3 = h3(M3.add(new C2(_6, 0)), f13, z6, C5), A4 = h3(M3.add(new C2(yt(_6), _6)), f13, z6, C5), P5 = h3(M3.add(new C2(0, _6)), f13, z6, C5), T4 = h3(M3.add(new C2(_6, _6)), f13, z6, C5), q7 = t13.textureUV.divide(this.mosaicInfo.size), G4 = e5.textureUVNextVertex1.divide(this.mosaicInfo.size), H4 = e5.textureUVNextVertex2.divide(this.mosaicInfo.size), L4 = { color: new H2(1), outlineColor: new H2(1), overrideOutlineColor: new j(1), outlineSize: p11, distanceToPx: d8, isSDF: u15 };
    let B3 = new j(0);
    return B3 = B3.add(g2(j3).multiply(this._getColor(Y2(j3, q7, G4, H4), L4).a)), B3 = B3.add(g2(U3).multiply(this._getColor(Y2(U3, q7, G4, H4), L4).a)), B3 = B3.add(g2(D4).multiply(this._getColor(Y2(D4, q7, G4, H4), L4).a)), B3 = B3.add(g2(I4).multiply(this._getColor(Y2(I4, q7, G4, H4), L4).a)), B3 = B3.add(g2(O3).multiply(this._getColor(Y2(O3, q7, G4, H4), L4).a)), B3 = B3.add(g2(k3).multiply(this._getColor(Y2(k3, q7, G4, H4), L4).a)), B3 = B3.add(g2(A4).multiply(this._getColor(Y2(A4, q7, G4, H4), L4).a)), B3 = B3.add(g2(P5).multiply(this._getColor(Y2(P5, q7, G4, H4), L4).a)), B3 = B3.add(g2(T4).multiply(this._getColor(Y2(T4, q7, G4, H4), L4).a)), ee(B3, new j(0.05)).multiply(q4(this.hittestRequest));
  }
};
e([_3(f2)], $.prototype, "visualVariableColor", void 0), e([_3(h4)], $.prototype, "visualVariableOpacity", void 0), e([_3(d4)], $.prototype, "visualVariableRotation", void 0), e([_3(m4)], $.prototype, "visualVariableSizeMinMaxValue", void 0), e([_3(p2)], $.prototype, "visualVariableSizeScaleStops", void 0), e([_3(f3)], $.prototype, "visualVariableSizeStops", void 0), e([_3(l)], $.prototype, "visualVariableSizeUnitValue", void 0), e([g(p)], $.prototype, "mosaicInfo", void 0), e([t(0, m3(Q)), t(1, m3(W2))], $.prototype, "vertex", null), e([t(0, m3(X))], $.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/markers/MarkerTechnique.js
var u7 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.MarkerMeshWriter, this.shaders = { geometry: new $() }, this.symbologyPlane = S4.MARKER;
  }
  render(e5, n11) {
    const { context: a8, painter: m12 } = e5;
    m12.setShader({ shader: this.shaders.geometry, uniforms: { ...d3(e5, n11.target, n11.instance.getInput().geometry), ...h5(e5, n11.target), mosaicInfo: m12.textureManager.getMosaicInfo(a8, n11.textureKey, true) }, defines: { ...y(e5) }, optionalAttributes: n11.instance.optionalAttributes, useComputeBuffer: m5(e5) }), m12.setPipelineState(M(e5)), m12.submitDraw(a8, n11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/GLSLShaderModule.js
var e4 = class {
  constructor() {
    this.computeAttributes = {};
  }
  get locationsMap() {
    const t13 = /* @__PURE__ */ new Map();
    for (const o9 in this.locations)
      t13.set(o9, this.locations[o9].index);
    return t13;
  }
  get optionPropertyKeys() {
    if (!this._optionPropertyKeys) {
      const t13 = new Set(Object.keys(this.options));
      this._optionPropertyKeys = t13;
    }
    return this._optionPropertyKeys;
  }
  get _transformFeedbackBindings() {
    return [];
  }
  get locationInfo() {
    if (!this._locationInfo) {
      const o9 = this.locationsMap, e5 = Array.from(o9.entries()).map(([t13, o10]) => `${t13}.${o10}`).join("."), n11 = c(e5);
      this._locationInfo = { hash: n11, locations: o9 };
    }
    return this._locationInfo;
  }
  get renamedLocationsMap() {
    const t13 = /* @__PURE__ */ new Map();
    for (const [o9, e5] of this.locationsMap.entries())
      t13.set("a_" + o9, e5);
    return t13;
  }
  getShaderKey(t13, o9, e5) {
    const n11 = Object.keys(e5).filter((t14) => e5[t14]).map((t14) => `${t14}_${e5[t14].toString()}`).join("."), r6 = Object.keys(o9).filter((t14) => this.optionPropertyKeys.has(t14)).join(".");
    return `${t13.hash}.${n11}.${r6}`;
  }
  getProgram(t13, e5, n11, r6) {
    let i7 = "", s6 = "";
    for (const o9 in n11)
      if (n11[o9]) {
        const t14 = "boolean" == typeof n11[o9] ? `#define ${o9}
` : `#define ${o9} ${n11[o9]}
`;
        i7 += t14, s6 += t14;
      }
    return i7 += this.vertexShader, s6 += this.fragmentShader, new a2(i7, s6, this.renamedLocationsMap, this.locationInfo, this._getUniformBindings(e5), this._transformFeedbackBindings);
  }
  _getUniformBindings(t13) {
    const o9 = [];
    for (const e5 in this.required) {
      const t14 = this.required[e5];
      o9.push({ uniformHydrated: null, shaderModulePath: e5, uniformName: e5, uniformType: t14.type, uniformArrayElementType: n7(t14), uniformArrayLength: r4(t14) });
    }
    for (const e5 in t13) {
      const i7 = this.options[e5];
      if (t13[e5])
        for (const t14 in i7) {
          const s6 = i7[t14];
          o9.push({ uniformHydrated: null, shaderModulePath: `${e5}.${t14}`, uniformName: t14, uniformType: s6.type, uniformArrayElementType: n7(s6), uniformArrayLength: r4(s6) });
        }
    }
    return o9;
  }
};
var n7 = (t13) => {
  var _a;
  return "array" === t13.type ? (_a = t13.elementType) == null ? void 0 : _a.type : void 0;
};
var r4 = (t13) => "array" === t13.type ? t13.size : void 0;

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/pieChart/PieChartShader.js
var p6 = { hittestDist: j, hittestPos: C2 };
var y2 = { filterFlags: S, animation: S, visualVariableData: S, dataDriven0: S, dataDriven1: S, dataDriven2: S, gpgpu: S, size: j };
var d5 = { displayViewScreenMat3: tt, displayViewMat3: tt, displayMat3: tt, viewMat3: tt, tileMat3: tt, displayZoomFactor: j, requiredZoomFactor: j, tileOffset: C2, currentScale: j, currentZoom: j, metersPerSRUnit: j };
var u8 = class extends e4 {
  constructor() {
    super(...arguments), this.vertexShader = n3("materials/pie/pie.vert"), this.fragmentShader = n3("materials/pie/pie.frag"), this.required = { ...y2, ...d5, outlineWidth: j, colors: U2, defaultColor: H2, othersColor: H2, outlineColor: H2, donutRatio: j, sectorThreshold: j }, this.options = { hittestUniforms: p6, visualVariableSizeMinMaxValue: { minMaxValueAndSize: H2 }, visualVariableSizeScaleStops: { sizes: { ...U2.ofType(j, 8), type: "array", elementType: j, size: 8 }, values: { ...U2.ofType(j, 8), type: "array", elementType: j, size: 8 } }, visualVariableSizeStops: { sizes: { ...U2.ofType(j, 8), type: "array", elementType: j, size: 8 }, values: { ...U2.ofType(j, 8), type: "array", elementType: j, size: 8 } }, visualVariableSizeUnitValue: { unitValueToPixelsRatio: j }, visualVariableOpacity: { opacities: { ...U2.ofType(j, 8), type: "array", elementType: j, size: 8 }, opacityValues: { ...U2.ofType(j, 8), type: "array", elementType: j, size: 8 } } }, this.locations = { pos: { index: 0, type: C2 }, id: { index: 1, type: G2 }, bitset: { index: 2, type: j }, offset: { index: 3, type: C2 }, texCoords: { index: 4, type: C2 }, size: { index: 5, type: C2 }, referenceSize: { index: 6, type: j }, zoomRange: { index: 7, type: C2 } }, this.defines = { VV_SIZE_MIN_MAX_VALUE: "boolean", VV_SIZE_SCALE_STOPS: "boolean", VV_SIZE_FIELD_STOPS: "boolean", VV_SIZE_UNIT_VALUE: "boolean", VV_OPACITY: "boolean", HITTEST: "boolean", numberOfFields: "number", highlight: "boolean", inside: "boolean", outside: "boolean" };
  }
  setNumberOfFields(e5) {
    this.required.colors = { ...U2.ofType(H2, e5), type: "array", elementType: H2, size: e5 };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/pieChart/PieChartTechnique.js
var u9 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.PieChartMeshWriter, this.shaders = { geometry: new u8() }, this.symbologyPlane = S4.MARKER;
  }
  render(e5, o9) {
    var _a, _b;
    const { context: h13, painter: m12 } = e5, { instance: u15, target: l5 } = o9, n11 = this.shaders.geometry, S7 = u15.getInput(), V4 = S7.numberOfFields, g6 = m5(e5), p11 = h5(e5, l5), f13 = y(e5);
    n11.setNumberOfFields(V4), m12.setShader({ shader: n11, uniforms: { ...d3(e5, o9.target, S7.geometry), ...p11.storage, ...p11.view, hittestUniforms: p11.hittestRequest ? { hittestDist: (_a = p11.hittestRequest) == null ? void 0 : _a.distance, hittestPos: (_b = p11.hittestRequest) == null ? void 0 : _b.position } : null }, defines: { VV_SIZE_MIN_MAX_VALUE: !!S7.geometry.visualVariableSizeMinMaxValue, VV_SIZE_SCALE_STOPS: !!S7.geometry.visualVariableSizeScaleStops, VV_SIZE_FIELD_STOPS: !!S7.geometry.visualVariableSizeStops, VV_SIZE_UNIT_VALUE: !!S7.geometry.visualVariableSizeUnitValue, VV_OPACITY: !!S7.geometry.visualVariableOpacity, HITTEST: g6, highlight: p11.highlight ? 1 : 0, ...f13, numberOfFields: V4 }, optionalAttributes: {}, useComputeBuffer: g6 }), m12.setPipelineState(M(e5)), m12.submitDraw(h13, o9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/text/TextTechnique.js
var u10 = class extends e3 {
  constructor() {
    super(...arguments), this.meshWriter = a3.TextMeshWriter, this.shaders = { geometry: new K4() }, this.symbologyPlane = S4.TEXT;
  }
  render(e5, o9) {
    const { context: n11, painter: m12 } = e5, u15 = y(e5), h13 = { shader: this.shaders.geometry, uniforms: { ...d3(e5, o9.target, o9.instance.getInput().geometry), ...h5(e5, o9.target), mosaicInfo: m12.textureManager.getMosaicInfo(n11, o9.textureKey) }, defines: { ...u15, isHaloPass: false, isBackgroundPass: true, isLabel: false }, optionalAttributes: o9.instance.optionalAttributes, useComputeBuffer: m5(e5) };
    m12.setShader(h13), m12.setPipelineState(M(e5)), m12.submitDraw(n11, o9), m12.setShader({ ...h13, defines: { ...u15, isHaloPass: true, isBackgroundPass: false, isLabel: false } }), m12.submitDraw(n11, o9), m12.setShader({ ...h13, defines: { ...u15, isHaloPass: false, isBackgroundPass: false, isLabel: false } }), m12.submitDraw(n11, o9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/TechniqueRegistry.js
var h10 = { fill: new m6("fill"), patternFill: new h7("patternFill"), complexFill: new h6("complexFill"), outlineFill: new l2("outlineFill"), patternOutlineFill: new u5("patternOutlineFill"), complexOutlineFill: new u4("complexOutlineFill"), marker: new u7("marker"), pieChart: new u9("pieChart"), line: new p5("line"), texturedLine: new h9("texturedLine"), text: new u10("text"), label: new u6("label"), heatmap: new p4("heatmap"), dotDensity: new f5("dotDensity") };
function F8() {
  for (const e5 in h10) {
    h10[e5].startup();
  }
}
function T3(e5) {
  for (const i7 in h10) {
    h10[i7].shutdown(e5);
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/schemaUtils.js
function n8(n11, t13) {
  const r6 = n11.slice(0, t13), e5 = t13 - r6.length;
  for (let o9 = 0; o9 < e5; o9++) {
    const n12 = r6[r6.length - 1];
    r6.push(n12);
  }
  return r6;
}
function t9(n11) {
  if (!n11)
    return [0, 0, 0, 0];
  const { r: t13, g: r6, b: e5, a: o9 } = n11;
  return [t13 * (o9 / 255), r6 * (o9 / 255), e5 * (o9 / 255), o9];
}

// node_modules/@arcgis/core/views/2d/layers/features/support/rendererUtils.js
var l3 = 8;
var s3 = l3 - 2;
var n9 = () => n.getLogger("esri.views.2d.layers.features.support.rendererUtils");
function u11(e5) {
  return e5.map((e6) => a4(e6) ? i5(e6.clone()) : e6);
}
function a4(e5) {
  return ("size" === e5.type || "color" === e5.type || "opacity" === e5.type) && null != e5.stops;
}
function i5(e5) {
  return e5.stops = b5(e5.type, e5.stops ?? []), e5;
}
function p7(e5, o9, r6) {
  return (1 - r6) * e5 + r6 * o9;
}
function c4(e5, o9) {
  const [t13, ...l5] = o9, n11 = l5.pop(), u15 = l5[0].value, a8 = l5[l5.length - 1].value, i7 = (a8 - u15) / s3, c8 = [];
  for (let s6 = u15; s6 < a8; s6 += i7) {
    let t14 = 0;
    for (; s6 >= l5[t14].value; )
      t14++;
    const n12 = l5[t14], u16 = o9[t14 - 1], a9 = s6 - u16.value, i8 = n12.value === u16.value ? 1 : a9 / (n12.value - u16.value);
    if ("color" === e5) {
      const e6 = l5[t14], r6 = o9[t14 - 1], n13 = e6.color.clone();
      n13.r = p7(r6.color.r, n13.r, i8), n13.g = p7(r6.color.g, n13.g, i8), n13.b = p7(r6.color.b, n13.b, i8), n13.a = p7(r6.color.a, n13.a, i8), c8.push({ value: s6, color: n13, label: e6.label });
    } else if ("size" === e5) {
      const e6 = l5[t14], n13 = o9[t14 - 1], u17 = o(e6.size), a10 = p7(o(n13.size), u17, i8);
      c8.push({ value: s6, size: a10, label: e6.label });
    } else {
      const e6 = l5[t14], r6 = p7(o9[t14 - 1].opacity, e6.opacity, i8);
      c8.push({ value: s6, opacity: r6, label: e6.label });
    }
  }
  return [t13, ...c8, n11];
}
function f9(e5) {
  const [o9, ...r6] = e5, t13 = r6.pop();
  for (; r6.length > s3; ) {
    let e6 = 0, o10 = 0;
    for (let t14 = 1; t14 < r6.length; t14++) {
      const l5 = r6[t14 - 1], s6 = r6[t14], n11 = Math.abs(s6.value - l5.value);
      n11 > o10 && (o10 = n11, e6 = t14);
    }
    r6.splice(e6, 1);
  }
  return [o9, ...r6, t13];
}
function b5(e5, o9) {
  return o9.length <= l3 ? o9 : (n9().warn(`Found ${o9.length} Visual Variable stops, but MapView only supports ${l3}. Displayed stops will be simplified.`), o9.length > 2 * l3 ? c4(e5, o9) : f9(o9));
}
function g5() {
  const { supportsColorBufferFloat: e5, supportsColorBufferFloatBlend: o9, supportsColorBufferHalfFloat: r6 } = t8();
  return e5 && o9 || r6;
}
function m9(o9) {
  if (!o9)
    return true;
  switch (o9.type) {
    case "dot-density":
      break;
    case "heatmap":
      if (!g5()) {
        const o10 = t8(), r6 = ["supportsColorBufferFloat", "supportsColorBufferFloatBlend", "supportsColorBufferHalfFloat"].filter((e5) => !o10[e5]).join(", ");
        return n9().errorOnce(new s("webgl-missing-extension", `Missing WebGL2 requirements for Heatmap: ${r6}`)), false;
      }
  }
  return true;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/VisualVariablesSchema.js
var u12 = 1.25;
var o6 = 128;
var c5 = 128;
function p8(e5) {
  var _a;
  if (!((_a = e5.stops) == null ? void 0 : _a.length))
    return null;
  const a8 = e5.stops.sort((e6, a9) => e6.value - a9.value), i7 = n8(a8, 8), l5 = i7.map(({ value: e6 }) => e6), t13 = i7.map(({ color: e6 }) => t9(e6));
  return { values: l5, colors: t13 };
}
function v3(e5) {
  var _a;
  if (!((_a = e5.stops) == null ? void 0 : _a.length))
    return null;
  const a8 = e5.stops.sort((e6, a9) => e6.value - a9.value), i7 = n8(a8, 8);
  return { opacityValues: i7.map(({ value: e6 }) => e6), opacities: i7.map(({ opacity: e6 }) => e6) };
}
function V2(e5) {
  return { rotationType: "geographic" === e5.rotationType ? i2.Geographic : i2.Arithmatic };
}
function f10(a8) {
  var _a;
  if (!((_a = a8.stops) == null ? void 0 : _a.length))
    return null;
  if (a8.stops.some((e5) => e5.useMaxValue || e5.useMinValue))
    return (i8, t14) => {
      const r6 = i8.statisticsByLevel.get(t14.key.level), n11 = a8.stops.map((i9) => {
        var _a2, _b;
        return { value: i9.useMaxValue ? ((_a2 = r6 == null ? void 0 : r6.get(a8.field)) == null ? void 0 : _a2.maxValue) ?? 0 : i9.useMinValue ? ((_b = r6 == null ? void 0 : r6.get(a8.field)) == null ? void 0 : _b.minValue) ?? 0 : i9.value, size: i9.size ? u(i9.size) : i };
      }).sort((e5, a9) => e5.value - a9.value), u15 = n8(n11, 8);
      return { values: u15.map(({ value: e5 }) => e5), sizes: u15.map(({ size: e5 }) => e5) };
    };
  const i7 = a8.stops.sort((e5, a9) => e5.value - a9.value), t13 = n8(i7, 8);
  return { values: t13.map(({ value: e5 }) => e5), sizes: t13.map(({ size: a9 }) => u(a9)) };
}
function S5(e5) {
  return (l5) => {
    const { state: t13 } = l5;
    return { unitValueToPixelsRatio: W(t13.spatialReference) / m[e5.valueUnit] / t13.resolution };
  };
}
function b6(e5, a8) {
  const i7 = a8.length;
  if (e5 < a8[0].value || 1 === i7)
    return a8[0].size;
  for (let l5 = 1; l5 < i7; l5++)
    if (e5 < a8[l5].value) {
      const i8 = (e5 - a8[l5 - 1].value) / (a8[l5].value - a8[l5 - 1].value);
      return a8[l5 - 1].size + i8 * (a8[l5].size - a8[l5 - 1].size);
    }
  return a8[i7 - 1].size;
}
function z4(a8) {
  const { minDataValue: i7, maxDataValue: l5, minSize: t13, maxSize: s6 } = a8;
  if ("object" == typeof t13 && "object" == typeof s6)
    return (a9, r6) => {
      const n11 = a9.state.scale, u15 = u(b6(n11, t13.stops)), o9 = u(b6(n11, s6.stops));
      return { minMaxValueAndSize: [i7, l5, u15, o9] };
    };
  if ("object" == typeof t13 || "object" == typeof s6)
    throw new Error("InternalError: Found a partial VisualVariableSizeMinMaxValue");
  return { minMaxValueAndSize: [i7, l5, u(t13), u(s6)] };
}
var x5 = { visualVariableColor: null, visualVariableOpacity: null, visualVariableRotation: null, visualVariableSizeStops: null, visualVariableSizeScaleStops: null, visualVariableSizeOutlineScaleStops: null, visualVariableSizeUnitValue: null, visualVariableSizeMinMaxValue: null };
function h11(e5, a8 = c5, i7 = u12) {
  if (e5.visualVariableSizeMinMaxValue)
    return e5.visualVariableSizeMinMaxValue instanceof Function ? o6 : Math.max(e5.visualVariableSizeMinMaxValue.minMaxValueAndSize[3] * i7, a8);
  if (e5.visualVariableSizeScaleStops) {
    if (e5.visualVariableSizeScaleStops instanceof Function)
      return o6;
    const l5 = e5.visualVariableSizeScaleStops.sizes;
    return Math.max(l5[l5.length - 1] * i7, a8);
  }
  if (e5.visualVariableSizeStops) {
    if (e5.visualVariableSizeStops instanceof Function)
      return o6;
    const l5 = e5.visualVariableSizeStops.sizes;
    return Math.max(l5[l5.length - 1] * i7, a8);
  }
  return e5.visualVariableSizeUnitValue ? 2 * o6 : 0;
}
function y3(e5) {
  const a8 = { ...x5 };
  if (!e5 || !("visualVariables" in e5) || !e5.visualVariables)
    return a8;
  for (const i7 of u11(e5.visualVariables))
    switch (i7.type) {
      case "color":
        a8.visualVariableColor = p8(i7);
        break;
      case "opacity":
        a8.visualVariableOpacity = v3(i7);
        break;
      case "rotation":
        a8.visualVariableRotation = V2(i7);
        break;
      case "size":
        switch (M2(i7)) {
          case "field-stops":
            a8.visualVariableSizeStops = f10(i7);
            break;
          case "scale-stops":
            "outline" === i7.target ? a8.visualVariableSizeOutlineScaleStops = f10(i7) : a8.visualVariableSizeScaleStops = f10(i7);
            break;
          case "min-max":
            a8.visualVariableSizeMinMaxValue = z4(i7);
            break;
          case "unit-value":
            a8.visualVariableSizeUnitValue = S5(i7);
        }
        break;
      default:
        console.error("Unable to handle VV type");
    }
  return a8;
}
function M2(e5) {
  if ("number" == typeof e5.minDataValue && "number" == typeof e5.maxDataValue && null != e5.minSize && null != e5.maxSize)
    return "min-max";
  if ("$view.scale" === (e5 == null ? void 0 : e5.valueExpression) && Array.isArray(e5.stops))
    return "scale-stops";
  if ((null != e5.field || "$view.scale" !== (e5 == null ? void 0 : e5.valueExpression)) && (Array.isArray(e5.stops) || "levels" in e5 && e5.levels))
    return "field-stops";
  if ((null != e5.field || "$view.scale" !== (e5 == null ? void 0 : e5.valueExpression)) && null != e5.valueUnit)
    return "unit-value";
  throw new Error("InternalError: Found unknown sizeVV type");
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/symbols/utils.js
function a5(a8) {
  return !!(a8.visualVariableSizeMinMaxValue || a8.visualVariableSizeScaleStops || a8.visualVariableSizeStops || a8.visualVariableSizeUnitValue || a8.visualVariableSizeOutlineScaleStops);
}
function i6(a8) {
  return !!a8.visualVariableRotation;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/symbols/ComplexSymbolSchema.js
function s4(e5) {
  return e5.minScale || e5.maxScale ? { minScale: e5.minScale ?? 0, maxScale: e5.maxScale ?? 0 } : null;
}
function t10(e5) {
  if (null == e5)
    return null;
  if (Array.isArray(e5)) {
    const [a8, i7, l5, o9] = e5;
    return [a8, i7, l5, 255 * o9];
  }
  return "string" == typeof e5 ? e5 : { ...e5, defaultValue: t10(e5 == null ? void 0 : e5.defaultValue) };
}
async function n10(a8, i7) {
  const { cimResourceManager: l5, cimAnalyzer: o9, scaleExpression: r6 } = i7.schemaOptions;
  await Promise.all(K2.fetchResources(a8.symbol, l5, []));
  const t13 = o9.analyzeSymbolReference(a8, false), n11 = { scaleInfo: s4(a8), scaleExpression: r6 }, u15 = [];
  for (const e5 of t13)
    switch (e5.type) {
      case "marker":
        u15.push(...c6(e5, i7, n11));
        break;
      case "fill":
        u15.push(...m10(e5, i7, n11));
        break;
      case "line":
        u15.push(...b7(e5, i7, n11));
        break;
      case "text":
        u15.push(...v4(e5, i7, n11));
    }
  return u15;
}
function c6(e5, a8, o9) {
  const { uniforms: r6, schemaOptions: s6 } = a8, { store: t13 } = s6, n11 = e5.isOutline ? { ...x5, visualVariableSizeScaleStops: r6.visualVariableSizeOutlineScaleStops } : { visualVariableColor: r6.visualVariableColor, visualVariableOpacity: r6.visualVariableOpacity, visualVariableSizeMinMaxValue: r6.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: r6.visualVariableSizeScaleStops, visualVariableSizeStops: r6.visualVariableSizeStops, visualVariableSizeUnitValue: r6.visualVariableSizeUnitValue, visualVariableRotation: r6.visualVariableRotation };
  return u13(t13.ensureInstance(h10.marker, { geometry: n11 }, { zoomRange: !!o9.scaleInfo }), e5, r6, o9);
}
function u13(e5, i7, l5, { scaleInfo: s6, scaleExpression: n11 }) {
  const c8 = a5(l5);
  return [e5.createMeshInfo({ params: { size: i7.size, scaleX: i7.scaleX, anchorX: i7.anchorPoint.x, anchorY: i7.anchorPoint.y, angle: i7.rotation, color: t10(i7.color) ?? [0, 0, 0, 0], colorLocked: i7.colorLocked, frameHeight: i7.frameHeight, widthRatio: i7.widthRatio, scaleInfo: s6, offsetX: i7.offsetX, offsetY: i7.offsetY, outlineColor: t10(i7.outlineColor) ?? [0, 0, 0, 0], outlineSize: i7.outlineWidth, referenceSize: i7.referenceSize || t3.CIMVectorMarker.size, rotateClockwise: i7.rotateClockwise, scaleFactor: n11 ?? 1, sizeRatio: i7.sizeRatio, alignment: i7.alignment, isAbsoluteAnchorPoint: i7.isAbsoluteAnchorPoint, scaleSymbolsProportionally: i7.scaleSymbolsProportionally, sprite: i7.spriteRasterizationParam, hasSizeVV: c8, placement: i7.markerPlacement, effects: i7.effects ? { type: "cim-effect-infos", effectInfos: i7.effects } : null, transforms: i7.transform, minPixelBuffer: h11(l5) } })];
}
function f11(e5, a8, l5) {
  const { uniforms: o9, schemaOptions: r6 } = a8, { store: s6 } = r6;
  return p9(s6.ensureInstance(h10.fill, { geometry: { visualVariableColor: e5.colorLocked ? null : o9.visualVariableColor, visualVariableOpacity: o9.visualVariableOpacity } }, { zoomRange: !!l5.scaleInfo }), e5, l5);
}
function p9(e5, a8, { scaleInfo: i7 }) {
  return [e5.createMeshInfo({ params: { color: t10(a8.color) ?? [0, 0, 0, 0], scaleInfo: i7, effects: a8.effects ? { type: "cim-effect-infos", effectInfos: a8.effects } : null } })];
}
function m10(e5, a8, l5) {
  if (!e5.spriteRasterizationParam)
    return f11(e5, a8, l5);
  const { uniforms: o9, schemaOptions: r6 } = a8, { store: s6 } = r6;
  return S6(s6.ensureInstance(h10.complexFill, { geometry: { visualVariableColor: e5.colorLocked ? null : o9.visualVariableColor, visualVariableOpacity: o9.visualVariableOpacity } }, { zoomRange: !!l5.scaleInfo }), e5, null != o9.visualVariableColor, l5);
}
function S6(e5, a8, i7, { scaleInfo: l5 }) {
  if (!a8.spriteRasterizationParam)
    throw new Error("InternalError: Sprite should always be defined");
  const o9 = !!a8.hasUnresolvedReplacementColor && (!i7 || a8.colorLocked), r6 = a8.sampleAlphaOnly && !o9, s6 = a8.spriteRasterizationParam;
  return [e5.createMeshInfo({ params: { color: t10(a8.color) ?? [0, 0, 0, 0], height: a8.height, aspectRatio: a8.scaleX, offsetX: a8.offsetX, offsetY: a8.offsetY, scaleX: 1, scaleY: 1, angle: a8.angle, applyRandomOffset: a8.applyRandomOffset, sampleAlphaOnly: r6, scaleProportionally: "CIMHatchFill" === s6.resource.type, sprite: s6, scaleInfo: l5, effects: a8.effects ? { type: "cim-effect-infos", effectInfos: a8.effects } : null } })];
}
function b7(e5, a8, o9) {
  const { uniforms: r6, schemaOptions: s6 } = a8, { store: t13 } = s6, n11 = e5.isOutline ? { ...x5, visualVariableSizeScaleStops: r6.visualVariableSizeOutlineScaleStops } : { visualVariableColor: e5.colorLocked ? null : r6.visualVariableColor, visualVariableOpacity: r6.visualVariableOpacity, visualVariableSizeMinMaxValue: r6.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: r6.visualVariableSizeScaleStops, visualVariableSizeStops: r6.visualVariableSizeStops, visualVariableSizeUnitValue: r6.visualVariableSizeUnitValue }, c8 = { geometry: n11 }, u15 = !!(n11.visualVariableSizeMinMaxValue || n11.visualVariableSizeScaleStops || n11.visualVariableSizeStops || n11.visualVariableSizeUnitValue);
  if (!e5.spriteRasterizationParam) {
    return h12(t13.ensureInstance(h10.line, c8, { zoomRange: !!o9.scaleInfo }), e5, u15, o9);
  }
  return z5(t13.ensureInstance(h10.texturedLine, c8, { zoomRange: !!o9.scaleInfo }), e5, u15, o9);
}
function V3(e5, a8, { scaleInfo: i7 }) {
  return { params: { color: t10(e5.color) ?? [0, 0, 0, 0], width: e5.width, referenceWidth: e5.referenceWidth, capType: e5.cap, joinType: e5.join, miterLimit: e5.miterLimit, scaleInfo: i7, hasSizeVV: a8, effects: e5.effects ? { type: "cim-effect-infos", effectInfos: e5.effects } : null } };
}
function h12(e5, a8, i7, l5) {
  if (a8.spriteRasterizationParam)
    throw new Error("InternalError: Sprite should not be defined");
  return [e5.createMeshInfo({ params: V3(a8, i7, l5).params })];
}
function z5(e5, a8, i7, l5) {
  const { spriteRasterizationParam: o9, scaleDash: r6, sampleAlphaOnly: s6 } = a8;
  if (!o9)
    throw new Error("InternalError: Sprite should be defined");
  return [e5.createMeshInfo({ params: { ...V3(a8, i7, l5).params, shouldScaleDash: r6 ?? false, shouldSampleAlphaOnly: s6, isSDF: "CIMPictureStroke" !== o9.resource.type, sprite: o9 } })];
}
function v4(e5, a8, l5) {
  const { uniforms: o9, schemaOptions: r6 } = a8, { store: s6 } = r6;
  return y4(s6.ensureInstance(h10.text, { geometry: { visualVariableColor: e5.colorLocked ? null : o9.visualVariableColor, visualVariableOpacity: o9.visualVariableOpacity, visualVariableRotation: o9.visualVariableRotation, visualVariableSizeMinMaxValue: o9.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: o9.visualVariableSizeScaleStops, visualVariableSizeStops: o9.visualVariableSizeStops, visualVariableSizeUnitValue: o9.visualVariableSizeUnitValue } }, { zoomRange: !!l5.scaleInfo, referenceSymbol: false, clipAngle: false }), e5, o9, l5);
}
function y4(e5, a8, i7, { scaleInfo: l5, scaleExpression: r6 }) {
  return [e5.createMeshInfo({ params: { boxBackgroundColor: t10(a8.backgroundColor), boxBorderLineColor: t10(a8.borderLineColor), boxBorderLineSize: a8.borderLineWidth ?? 0, color: t10(a8.color) ?? [0, 0, 0, 0], offsetX: a8.offsetX, offsetY: a8.offsetY, postAngle: a8.angle, fontSize: a8.size, referenceSize: a8.referenceSize, decoration: a8.decoration, haloColor: t10(a8.outlineColor) ?? [0, 0, 0, 0], haloFontSize: a8.outlineSize, lineWidth: a8.lineWidth || 512, lineHeightRatio: 1, horizontalAlignment: a8.horizontalAlignment ?? "center", verticalAlignment: a8.verticalAlignment ?? "baseline", useCIMAngleBehavior: false, glyphs: a8.textRasterizationParam, scaleInfo: l5, effects: a8.effects ? { type: "cim-effect-infos", effectInfos: a8.effects } : null, placement: a8.markerPlacement, transforms: a8.transform, scaleFactor: r6 ?? 1, minPixelBuffer: h11(i7), repeatLabel: null, repeatLabelDistance: null, allowOverrun: null, labelPosition: null, isLineLabel: false } })];
}

// node_modules/@arcgis/core/views/2d/layers/support/FeatureCommandQueue.js
function t11(e5) {
  return e5.some((e6) => e6.globalId);
}
function r5(e5) {
  return e5.filter((e6) => !e6.error).map((e6) => e6.objectId ?? e6.globalId).filter((e6) => null != e6);
}
function o7(e5, s6) {
  const t13 = new Set(e5);
  for (const r6 of s6.values())
    t13.add(r6);
  return t13;
}
function d6(e5, s6) {
  const t13 = new Set(e5);
  for (const r6 of s6.values())
    t13.delete(r6);
  return t13;
}
var a6 = class {
  constructor(t13) {
    this.updateTracking = new d2({ debugName: "FeatureCommandQueue" }), this._hasGlobalIds = false, this._queueProcessor = new _2({ concurrency: 1, process: t13.process });
  }
  destroy() {
    this.updateTracking.destroy(), this._queueProcessor.destroy(), this.clear();
  }
  clear() {
    this._queueProcessor.clear();
  }
  async push(e5) {
    return this.updateTracking.addPromise(this._doPush(e5));
  }
  async _doPush(e5) {
    const s6 = this._queueProcessor, t13 = s6.last(), r6 = [];
    switch (e5.type) {
      case "update":
        if ((t13 == null ? void 0 : t13.type) === e5.type)
          return;
        r6.push(s6.push(e5));
        break;
      case "edit": {
        const o9 = "processed-edit" === (t13 == null ? void 0 : t13.type) ? t13 : null;
        o9 && s6.popLast();
        const d8 = this._mergeEdits(o9, e5);
        for (const e6 of d8)
          e6 && r6.push(s6.push(e6));
        break;
      }
    }
    await Promise.all(r6);
  }
  _mergeEdits(e5, s6) {
    const { addedFeatures: a8, deletedFeatures: i7, updatedFeatures: u15 } = s6.edits;
    if (this._hasGlobalIds = this._hasGlobalIds || t11(a8) || t11(u15) || t11(i7), this._hasGlobalIds) {
      return [e5, { type: "processed-edit", edits: { addOrModified: [...a8, ...u15], removed: i7 } }];
    }
    const n11 = new Set(r5((e5 == null ? void 0 : e5.edits.addOrModified) ?? [])), c8 = new Set(r5((e5 == null ? void 0 : e5.edits.removed) ?? [])), p11 = /* @__PURE__ */ new Set([...r5(a8), ...r5(u15)]), l5 = new Set(r5(i7));
    return [{ type: "processed-edit", edits: { addOrModified: Array.from(o7(d6(n11, l5), p11)).map((e6) => ({ objectId: e6 })), removed: Array.from(o7(d6(c8, p11), l5)).map((e6) => ({ objectId: e6 })) } }];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/StorageSchema.js
function t12(e5, i7) {
  return { type: "simple", filters: i7, capabilities: { maxTextureSize: t8().maxTextureSize }, bindings: a7(e5) };
}
function s5(e5) {
  switch (e5) {
    case "opacity":
      return L3.OPACITY;
    case "color":
      return L3.COLOR;
    case "rotation":
      return L3.ROTATION;
    case "size":
      return L3.SIZE;
    default:
      return null;
  }
}
function a7(e5) {
  if (!e5)
    return [];
  switch (e5.type) {
    case "simple":
    case "class-breaks":
    case "unique-value":
    case "dictionary":
      return c7(e5);
    case "dot-density":
      return o8(e5);
    case "pie-chart":
      return l4(e5);
    case "heatmap":
      return u14(e5);
  }
}
function o8(e5) {
  const i7 = [];
  for (const n11 of e5.attributes)
    i7.push({ binding: i7.length, expression: n11.valueExpression, field: n11.field });
  return i7;
}
function l4(e5) {
  const i7 = c7(e5);
  let n11 = 4;
  for (const r6 of e5.attributes)
    i7.push({ binding: n11++, expression: r6.valueExpression, field: r6.field });
  return i7;
}
function u14({ valueExpression: e5, field: i7 }) {
  return e5 || i7 ? [{ binding: 0, expression: e5, field: i7 }] : [];
}
function c7(i7) {
  var _a;
  if (!("visualVariables" in i7) || !((_a = i7.visualVariables) == null ? void 0 : _a.length))
    return [];
  return u11(i7.visualVariables).map((e5) => x6(e5)).filter(k);
}
function p10(e5) {
  return "$view.scale" === e5.valueExpression ? null : { binding: s5(e5.type), field: e5.field, normalizationField: e5.normalizationField, expression: e5.valueExpression, valueRepresentation: e5.valueRepresentation };
}
function f12(e5) {
  return { binding: s5(e5.type), field: e5.field, normalizationField: e5.normalizationField, expression: e5.valueExpression };
}
function d7(e5) {
  return { binding: s5(e5.type), field: e5.field, normalizationField: e5.normalizationField, expression: e5.valueExpression };
}
function m11(e5) {
  return { binding: s5(e5.type), expression: e5.valueExpression, field: e5.field };
}
function x6(e5) {
  switch (e5.type) {
    case "size":
      return p10(e5);
    case "color":
      return f12(e5);
    case "opacity":
      return d7(e5);
    case "rotation":
      return m11(e5);
  }
}

export {
  h10 as h,
  F8 as F,
  T3 as T,
  t9 as t,
  m9 as m,
  x5 as x,
  h11 as h2,
  y3 as y,
  a5 as a,
  i6 as i,
  s4 as s,
  n10 as n,
  u13 as u,
  p9 as p,
  S6 as S,
  h12 as h3,
  z5 as z,
  y4 as y2,
  t12 as t2,
  c7 as c,
  a6 as a2
};
//# sourceMappingURL=chunk-QXRPUAVL.js.map
