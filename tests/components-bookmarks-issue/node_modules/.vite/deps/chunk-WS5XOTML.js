import {
  l as l15,
  p as p11
} from "./chunk-ID25T22U.js";
import {
  a as a13
} from "./chunk-5SYJEI74.js";
import {
  t as t22
} from "./chunk-OOISODT4.js";
import {
  i as i10
} from "./chunk-QFYJUFUK.js";
import {
  s as s17
} from "./chunk-V7IF2KNH.js";
import {
  v as v3
} from "./chunk-AZYURM7A.js";
import {
  n as n15
} from "./chunk-HBBLDSW6.js";
import {
  t as t24,
  te
} from "./chunk-YYI7TRI3.js";
import {
  n as n14
} from "./chunk-RQW2N53A.js";
import {
  Q as Q2
} from "./chunk-LMCIQOBX.js";
import {
  E as E9,
  R as R4,
  b as b7,
  c as c17,
  d as d8,
  f as f9,
  f2 as f10,
  g as g5,
  l as l14,
  m as m9,
  o as o15,
  p as p10,
  s as s16,
  u as u16
} from "./chunk-4VVENLLF.js";
import {
  B as B2,
  F as F6,
  I as I6,
  S as S7,
  U as U2,
  b as b8,
  k as k5
} from "./chunk-VUHMQQ6M.js";
import {
  _ as _8
} from "./chunk-PAH4PVZY.js";
import {
  b as b9
} from "./chunk-5T7MASZO.js";
import {
  it
} from "./chunk-5WKN6K5Z.js";
import {
  H as H3,
  O as O9
} from "./chunk-WCBHO6BH.js";
import {
  r as r18
} from "./chunk-V7NVRGBC.js";
import {
  r as r21
} from "./chunk-RFBA77K3.js";
import {
  G as G5,
  e as e28,
  i as i11
} from "./chunk-46T3D2EU.js";
import {
  m as m10
} from "./chunk-G3J4F5JD.js";
import {
  D as D5,
  n as n16
} from "./chunk-OFEQM7IB.js";
import {
  R as R5,
  a as a14
} from "./chunk-R3RV65RE.js";
import {
  M as M4
} from "./chunk-5XOEX7AO.js";
import {
  I as I5,
  f as f8,
  r as r19,
  t as t23
} from "./chunk-VIRGWB3Z.js";
import {
  E as E8,
  I as I4,
  m as m8
} from "./chunk-QCUK7T7Y.js";
import {
  At,
  G as G6,
  Ot,
  at,
  ft,
  ht,
  ot as ot3,
  rt,
  z as z2
} from "./chunk-SPYHZ6ZW.js";
import {
  e as e29
} from "./chunk-637XZX4A.js";
import {
  h as h11
} from "./chunk-MBLWM4C2.js";
import {
  r as r20
} from "./chunk-HHAESKQ6.js";
import {
  a2 as a12,
  e as e30,
  o as o16,
  u as u17
} from "./chunk-4MJOJUFR.js";
import {
  E as E7,
  Y as Y3,
  k as k4,
  s as s15
} from "./chunk-NT7TKMWH.js";
import {
  r as r16,
  t as t18,
  u as u15
} from "./chunk-BQGPMKNK.js";
import {
  r as r13
} from "./chunk-7KNPDPFB.js";
import {
  E as E6,
  O as O7,
  b as b6,
  k as k3,
  p as p6,
  p2 as p7,
  x as x5
} from "./chunk-M6P775BS.js";
import {
  e as e27,
  f as f7,
  i as i9,
  o as o13
} from "./chunk-J5F4VILS.js";
import {
  t as t21
} from "./chunk-KSBIR2KG.js";
import {
  N
} from "./chunk-XVQGALI7.js";
import {
  n as n13
} from "./chunk-XFQIXBHG.js";
import {
  A as A7,
  E as E5,
  S as S6,
  _ as _7,
  a as a11,
  c as c16,
  l as l13
} from "./chunk-7A5N7G2Z.js";
import {
  i as i8
} from "./chunk-FIHLU3LF.js";
import {
  p as p8
} from "./chunk-GL5TSVQL.js";
import {
  c as c13
} from "./chunk-OBABKQ6S.js";
import {
  r as r14,
  r2 as r15,
  t as t17
} from "./chunk-ZPC74XHC.js";
import {
  A as A8
} from "./chunk-IVGJRGD2.js";
import {
  t as t16
} from "./chunk-MTLWPXQD.js";
import {
  r as r17
} from "./chunk-JBF6CULO.js";
import {
  B,
  G as G4,
  O as O8,
  Q,
  W as W2,
  X,
  t as t20
} from "./chunk-JKOHBDRD.js";
import {
  c as c14,
  c2 as c15,
  e as e26,
  u2 as u14
} from "./chunk-3DFMDDMO.js";
import {
  t as t19
} from "./chunk-4BCSYJOQ.js";
import {
  O as O6
} from "./chunk-GMUCR2DJ.js";
import {
  S as S5,
  _ as _6,
  a as a10,
  h as h10,
  l as l12,
  o as o12
} from "./chunk-MEEG7XMI.js";
import {
  o as o11
} from "./chunk-LJULTBAY.js";
import {
  p as p9
} from "./chunk-54XXLVAD.js";
import {
  l as l11
} from "./chunk-KO7QNSNZ.js";
import {
  h as h9
} from "./chunk-4YGBWYMD.js";
import {
  K2
} from "./chunk-ZPU7GNG4.js";
import {
  c as c12,
  i as i7
} from "./chunk-7O3VD45U.js";
import {
  t as t15
} from "./chunk-GB4RVOXH.js";
import {
  e2 as e25,
  m as m7
} from "./chunk-JTUYA5FE.js";
import {
  E as E4,
  _ as _5
} from "./chunk-UNTQATE2.js";
import {
  Y as Y2
} from "./chunk-7MYYCSEB.js";
import {
  j as j9
} from "./chunk-ESK2YRQM.js";
import {
  e as e24,
  s as s14
} from "./chunk-3GY64OYE.js";
import {
  t as t13
} from "./chunk-QIEXJLRX.js";
import {
  o as o10,
  t as t14
} from "./chunk-UNTPHF5R.js";
import {
  H as H2
} from "./chunk-YJFPDMSR.js";
import {
  e as e23,
  t as t12
} from "./chunk-S243OWEZ.js";
import {
  C,
  I as I3,
  o as o9
} from "./chunk-QYDOVVH7.js";
import {
  F as F5
} from "./chunk-IWZSAF74.js";
import {
  ot as ot2
} from "./chunk-TLTAGTBA.js";
import {
  r as r12
} from "./chunk-HXYRQKMI.js";
import {
  D as D4,
  E as E3,
  F as F4,
  L as L3,
  O as O5,
  R as R3
} from "./chunk-WKVHVZW2.js";
import {
  A as A6,
  D as D3,
  O as O4,
  d as d6,
  g as g4,
  u as u11,
  w as w5
} from "./chunk-DH7BG2VH.js";
import {
  I as I2,
  l as l8
} from "./chunk-KSZESDGM.js";
import {
  r as r10
} from "./chunk-5P74D2TG.js";
import {
  e as e20
} from "./chunk-33LWZO2E.js";
import {
  i as i4
} from "./chunk-VIKID44H.js";
import {
  M as M2,
  b as b4,
  d as d5,
  v
} from "./chunk-3IDXRFXE.js";
import {
  m as m6,
  s as s13
} from "./chunk-RLZYC2LS.js";
import {
  h as h6
} from "./chunk-3RIV3ECV.js";
import {
  A as A5,
  f as f6,
  i as i5,
  l as l7,
  t as t10
} from "./chunk-WEER6QME.js";
import {
  c as c10,
  m as m5
} from "./chunk-IYU3Q2BA.js";
import {
  e as e21,
  s as s12,
  t as t11
} from "./chunk-TXLJQAAN.js";
import {
  G as G3,
  M as M3,
  R as R2,
  h as h8,
  j as j8
} from "./chunk-XJICXW6N.js";
import {
  a as a9,
  e as e19,
  t as t9
} from "./chunk-R4SGP2EA.js";
import {
  T as T2,
  b as b5,
  c as c11,
  d as d7,
  h as h7,
  i as i6,
  l as l10,
  u as u13,
  x as x4
} from "./chunk-IRL6OOVK.js";
import {
  P as P3,
  e as e22,
  j as j7,
  l as l9,
  o as o8,
  q as q5,
  r as r11,
  u as u12,
  v as v2
} from "./chunk-3AIILHI5.js";
import {
  g as g3
} from "./chunk-QJRGTKPN.js";
import {
  n as n12,
  r as r9
} from "./chunk-LA365FE7.js";
import {
  a as a8,
  c as c9
} from "./chunk-6K2UNRXT.js";
import {
  A as A3
} from "./chunk-WTKV7W5Z.js";
import {
  n as n8
} from "./chunk-D56W4LPT.js";
import {
  e as e13
} from "./chunk-BKOYOJBG.js";
import {
  e as e17,
  r as r8
} from "./chunk-CSSLIU64.js";
import {
  a as a7
} from "./chunk-CJNDQ2LH.js";
import {
  e as e18,
  i as i3,
  n as n10,
  o as o7,
  t as t7
} from "./chunk-CDBOQCLE.js";
import {
  l as l6
} from "./chunk-WZJNHZ6H.js";
import {
  Z,
  k as k2,
  w as w4
} from "./chunk-XMYPMIYH.js";
import {
  p as p5
} from "./chunk-FQLGRQKL.js";
import {
  f as f5,
  s as s8
} from "./chunk-BFOJPIF7.js";
import {
  n as n7
} from "./chunk-GKMVTGGM.js";
import {
  c as c8
} from "./chunk-LQBHIBXV.js";
import {
  s as s11,
  t as t8
} from "./chunk-42DUJ2CX.js";
import {
  A as A4,
  E as E2,
  F as F3,
  S as S4,
  U,
  V as V2,
  b as b3,
  d as d4,
  j as j6,
  q as q4
} from "./chunk-Z2F5OKVA.js";
import {
  g as g2,
  m as m4
} from "./chunk-UQA6M3KF.js";
import {
  e as e16
} from "./chunk-GLF3KRAL.js";
import {
  a as a6,
  e as e15,
  l as l5,
  n as n9,
  r as r7,
  s as s9,
  t as t6
} from "./chunk-ZLQTPFTL.js";
import {
  R
} from "./chunk-WIVZ7SMV.js";
import {
  j as j5,
  n as n11,
  s as s10,
  u as u10
} from "./chunk-HZSGATFT.js";
import {
  e as e12,
  o as o6,
  r as r6
} from "./chunk-N5GQOIDP.js";
import {
  e as e14
} from "./chunk-NFB6O77E.js";
import {
  _ as _4,
  n as n6,
  r as r5,
  s as s7,
  t as t5
} from "./chunk-AKEHDP75.js";
import {
  m as m3,
  s as s6
} from "./chunk-5MMGIT64.js";
import {
  M
} from "./chunk-LMO6NZJA.js";
import {
  n as n5
} from "./chunk-SCHTG6ZQ.js";
import {
  I,
  c as c5,
  e as e11,
  f as f4,
  h as h4,
  i as i2,
  n as n4,
  o as o4,
  p as p3,
  q as q3
} from "./chunk-HWHMO3CO.js";
import {
  h as h5,
  j as j4
} from "./chunk-TCRKKQAL.js";
import {
  c as c7,
  d as d3
} from "./chunk-JW7VBMHD.js";
import {
  d2,
  j as j3,
  l2 as l4,
  o as o5,
  p as p4
} from "./chunk-ZIJHDTB7.js";
import {
  c as c6,
  t as t4
} from "./chunk-JI3AZJ7K.js";
import {
  A as A2,
  D as D2,
  E,
  F,
  G as G2,
  O as O3,
  P as P2,
  S as S3,
  T,
  V,
  Y,
  a as a5,
  c as c4,
  f as f3,
  h as h3,
  i,
  l as l3,
  o as o3,
  w as w3,
  y as y2
} from "./chunk-326OSIM5.js";
import {
  o as o14
} from "./chunk-AG6JXA4M.js";
import {
  u as u9
} from "./chunk-WDPG5BMO.js";
import {
  e as e10,
  u as u8,
  x as x3
} from "./chunk-BOAEEYBE.js";
import {
  F as F2
} from "./chunk-2ICUS4HL.js";
import {
  H,
  n as n3
} from "./chunk-GBF2OQAY.js";
import {
  j as j2,
  u as u6
} from "./chunk-HV6S3GY2.js";
import {
  h as h2,
  p
} from "./chunk-IGR2BTWR.js";
import {
  D,
  f as f2,
  p as p2,
  u as u7,
  x as x2
} from "./chunk-C7NPPGFR.js";
import {
  b as b2,
  e as e9,
  f,
  h,
  m as m2
} from "./chunk-OCF7OAES.js";
import {
  J,
  K,
  O as O2,
  P,
  _ as _3,
  c as c3,
  e as e8,
  g,
  j,
  o as o2,
  q as q2,
  r as r4,
  s as s5,
  u as u5,
  x,
  z
} from "./chunk-JZBR4X6W.js";
import {
  _ as _2,
  e as e6,
  l as l2,
  n as n2,
  r as r3
} from "./chunk-OIJCMME5.js";
import {
  e as e7,
  u as u4
} from "./chunk-4KLYOMH2.js";
import {
  w as w2
} from "./chunk-IZKCZQUY.js";
import {
  G,
  L as L2,
  W2 as W,
  s3 as s4
} from "./chunk-UWQ3OYA5.js";
import {
  ot
} from "./chunk-SAYWXQVM.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import {
  _,
  a as a4,
  d
} from "./chunk-BVQWKK2V.js";
import {
  S as S2,
  e3 as e5,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3,
  e2 as e4
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  L,
  S,
  a as a2,
  b,
  c2,
  m,
  s as s3,
  u2,
  w
} from "./chunk-JGDJR5EV.js";
import {
  e as e3,
  l,
  r as r2,
  t as t3,
  u
} from "./chunk-QHK5ZYFW.js";
import {
  u as u3
} from "./chunk-L65HKN25.js";
import {
  a,
  c2 as c,
  n2 as n,
  s as s2
} from "./chunk-7RBRCL6S.js";
import {
  A2 as A,
  O,
  e as e2,
  has,
  k,
  q,
  r,
  s,
  t2 as t,
  t3 as t2
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/ElevationQuery.js
var l16 = class {
  constructor(e42, t32) {
    this.spatialReference = e42, this._view = t32;
  }
  getElevation(e42, t32, r39) {
    return this._view.elevationProvider.getElevation(e42, t32, 0, this.spatialReference, r39);
  }
  async queryElevation(e42, t32, r39, s32, i20) {
    return this._view.elevationProvider.queryElevation(e42, t32, 0, this.spatialReference, i20, r39, s32);
  }
};
var a15 = class {
  constructor(e42, t32, r39, s32) {
    this.spatialReference = t32, this._getElevationQueryProvider = r39, this._queries = new Array(), this._queryOptions = { ...s32, ignoreInvisibleLayers: true }, this._frameTask = e42.registerTask(I3.ELEVATION_QUERY, this);
  }
  destroy({ completeTasks: e42 } = { completeTasks: false }) {
    if (this._frameTask.remove(), this.running)
      if (e42)
        this.runTask(C);
      else
        for (const r39 of this._queries)
          r39.result.reject(u2());
  }
  queryElevation(i20, n28, o27, l31 = 0) {
    const a28 = L(), u32 = { x: i20, y: n28, minDemResolution: l31, result: a28, signal: o27 };
    return this._queries.push(u32), m(o27, () => {
      O(this._queries, u32), a28.reject(u2());
    }), a28.promise;
  }
  get running() {
    return this._queries.length > 0;
  }
  runTask(e42) {
    const r39 = this._queries;
    this._queries = [];
    const i20 = this._getElevationQueryProvider();
    if (!i20)
      return r39.forEach((e43) => e43.result.reject()), void e42.madeProgress();
    const n28 = r39.map((e43) => [e43.x, e43.y]), l31 = r39.reduce((e43, t32) => Math.min(e43, t32.minDemResolution), 1 / 0), a28 = new u6({ points: n28, spatialReference: this.spatialReference }), u32 = r39.length > 1 && r39.some((e43) => !!e43.signal) ? new AbortController() : null, c32 = null != u32 ? u32.signal : r39[0].signal;
    if (null != u32) {
      let e43 = 0;
      r39.forEach((i21) => m(i21.signal, () => {
        e43++, i21.result.reject(u2()), e43 === r39.length && u32.abort();
      }));
    }
    const h25 = { ...this._queryOptions, minDemResolution: l31, signal: c32 };
    i20.queryElevation(a28, h25).then((e43) => {
      r39.forEach((r40, s32) => {
        null != r40.signal && r40.signal.aborted ? r40.result.reject(u2()) : r40.result.resolve(e43.geometry.points[s32][2]);
      });
    }).catch((e43) => {
      r39.forEach((t32) => t32.result.reject(e43));
    }), e42.madeProgress();
  }
  get test() {
    const e42 = this;
    return { update: () => e42._queries.length > 0 && e42.runTask(C) };
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/enums.js
var L4;
var A9;
!function(L8) {
  L8[L8.USER = 1] = "USER", L8[L8.SCALE_RANGE = 2] = "SCALE_RANGE", L8[L8.FILTER = 4] = "FILTER", L8[L8.DECONFLICTION = 8] = "DECONFLICTION", L8[L8.ALL_GRAPHIC = 15] = "ALL_GRAPHIC", L8[L8.ALL_LABEL = 255] = "ALL_LABEL";
}(L4 || (L4 = {})), function(L8) {
  L8[L8.GRAPHIC = 1] = "GRAPHIC", L8[L8.LABEL = 16] = "LABEL";
}(A9 || (A9 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GeometryWithMapPositions.js
function e31(o27) {
  return null != o27.mapPositions;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/ElevationAligners.js
function u18(t32, e42, o27, n28, r39) {
  const a28 = t32.stageObject, s32 = a28.geometries;
  let i20 = 0;
  for (const l31 of s32) {
    if (!e31(l31))
      continue;
    const { update: t33, averageGeometrySampledElevation: s33 } = M5(l31, e42, o27, n28, r39);
    i20 += s33, t33 && a28.geometryVertexAttributeUpdated(l31, e16.POSITION);
  }
  return i20 / s32.length;
}
function p12(e42, n28, a28, i20, m22, f23) {
  const c32 = e42.stageObject, u32 = n28.centerPointInElevationSR;
  let p23 = 0;
  if (c32.usesVerticalDistanceToGround)
    i20(u32, E10), E9(c32, E10.verticalDistanceToGround), p23 = E10.sampledElevation;
  else {
    i20(u32, E10);
    "absolute-height" !== n28.mode && (p23 = E10.sampledElevation);
  }
  const b18 = n4(g6, f23 ?? c32.transformation), I15 = o2(v4, b18[12], b18[13], b18[14]);
  t19.TESTS_DISABLE_OPTIMIZATIONS ? (T3[0] = u32.x, T3[1] = u32.y, T3[2] = E10.z, R(u32.spatialReference, T3, b18, m22.spatialReference) && (f23 ? n4(f23, b18) : c32.transformation = b18)) : m22.setAltitudeOfTransformation(E10.z, b18);
  const S21 = d9 / m22.unitInMeters;
  return (Math.abs(b18[12] - I15[0]) >= S21 || Math.abs(b18[13] - I15[1]) >= S21 || Math.abs(b18[14] - I15[2]) >= S21) && (f23 ? n4(f23, b18) : c32.transformation = b18), p23;
}
var g6 = e12();
function b10(t32, e42, n28, a28, s32) {
  const i20 = t32.graphics3DSymbolLayer.lodRenderer;
  if (null == i20)
    return 0;
  const m22 = e42.centerPointInElevationSR;
  a28(m22, E10);
  const f23 = "absolute-height" !== e42.mode ? E10.sampledElevation : 0, c32 = i20.instanceData, u32 = t32.instanceIndex, p23 = h12;
  c32.getGlobalTransform(u32, p23);
  const g15 = o2(v4, p23[12], p23[13], p23[14]);
  t19.TESTS_DISABLE_OPTIMIZATIONS ? (T3[0] = m22.x, T3[1] = m22.y, T3[2] = E10.z, R(m22.spatialReference, T3, p23, s32.spatialReference) && c32.setGlobalTransform(u32, p23)) : s32.setAltitudeOfTransformation(E10.z, p23);
  const b18 = d9 / s32.unitInMeters;
  return (t19.TESTS_DISABLE_OPTIMIZATIONS || Math.abs(p23[12] - g15[0]) >= b18 || Math.abs(p23[13] - g15[1]) >= b18 || Math.abs(p23[14] - g15[2]) >= b18) && c32.setGlobalTransform(u32, p23), f23;
}
function I7(t32, e42, o27, n28, r39) {
  const a28 = t32.stageObject, s32 = a28.geometries;
  if (0 === s32.length)
    return 0;
  let i20 = 0, l31 = null, m22 = 0, u32 = false;
  for (const p23 of s32) {
    if (!e31(p23))
      continue;
    const t33 = p23.attributes.get(e16.POSITION);
    if (t33 !== l31) {
      const { update: a29, averageGeometrySampledElevation: s33 } = M5(p23, e42, o27, n28, r39);
      m22 = s33, l31 = t33, u32 = a29;
    }
    u32 && a28.geometryVertexAttributeUpdated(p23, e16.POSITION), i20 += m22;
  }
  return i20 / s32.length;
}
var d9 = 0.01;
var T3 = n2();
var S8 = n2();
var O10 = n2();
var h12 = e12();
var v4 = n2();
var E10 = new R4();
function M5(t32, e42, o27, n28, r39) {
  let s32 = false;
  const i20 = t32.transformation, f23 = e42.requiresSampledElevationInfo;
  S8[0] = i20[12], S8[1] = i20[13], S8[2] = i20[14], t32.invalidateBoundingInfo();
  const u32 = t32.getMutableAttribute(e16.POSITION), p23 = u32.data, g15 = u32.size, b18 = p23.length / g15, I15 = new r18(t32.mapPositions, o27);
  let h25 = 0, v13 = 0;
  for (let m22 = 0; m22 < b18; m22++) {
    if (O10[0] = p23[h25], O10[1] = p23[h25 + 1], O10[2] = p23[h25 + 2], n28(I15, E10), f23 && (v13 += E10.sampledElevation), t19.TESTS_DISABLE_OPTIMIZATIONS)
      p23[h25] = I15.array[I15.offset], p23[h25 + 1] = I15.array[I15.offset + 1], p23[h25 + 2] = E10.z, n3(p23, o27, h25, p23, r39.spatialReference, h25, 1), p23[h25] -= S8[0], p23[h25 + 1] -= S8[1], p23[h25 + 2] -= S8[2], s32 = true;
    else {
      T3[0] = p23[h25] + S8[0], T3[1] = p23[h25 + 1] + S8[1], T3[2] = p23[h25 + 2] + S8[2], r39.setAltitude(T3, E10.z), p23[h25] = T3[0] - S8[0], p23[h25 + 1] = T3[1] - S8[1], p23[h25 + 2] = T3[2] - S8[2];
      const t33 = d9 / r39.unitInMeters;
      (Math.abs(O10[0] - p23[h25]) >= t33 || Math.abs(O10[1] - p23[h25 + 1]) >= t33 || Math.abs(O10[2] - p23[h25 + 2]) >= t33) && (s32 = true);
    }
    h25 += g15, I15.offset += 3;
  }
  return v13 /= b18, { update: s32, averageGeometrySampledElevation: v13 };
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DGraphicCreationContext.js
var r22 = class {
  constructor(r39, s32, t32) {
    this.graphic = r39, this.renderingInfo = s32, this.layer = t32;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObject3DGraphicLayer.js
var j10 = class {
  constructor(e42, t32, i20) {
    this.baseMaterial = e42, this.edgeMaterials = t32, this.properties = i20;
  }
};
var p13 = class {
  get isElevationSource() {
    return !!this.stageObject.lastValidElevationBB;
  }
  constructor(e42, t32, i20, s32, a28, n28, r39, o27 = null) {
    this.graphics3DSymbolLayer = e42, this.stageObject = t32, this._uniqueGeometries = i20, this._uniqueMaterials = s32, this._sharedResource = a28, this.elevationAligner = n28, this.elevationContext = r39, this._edgeState = o27, this.type = "object3d", this._stageLayer = null, this._visible = false, this._addedToStage = false, this.alignedSampledElevation = 0, this.needsElevationUpdates = false, this.useObjectOriginAsAttachmentOrigin = false;
  }
  initialize(e42) {
    this._stageLayer = e42;
    const t32 = e42.stage;
    t32.addMany(this._uniqueMaterials), t32.addMany(this._uniqueGeometries), t32.add(this.stageObject);
  }
  destroy() {
    var _a, _b;
    if (!this._stageLayer)
      return;
    const e42 = this._stageLayer.stage;
    e42.removeMany(this._uniqueMaterials), e42.removeMany(this._uniqueGeometries), e42.remove(this.stageObject), this._addedToStage && (this._stageLayer.remove(this.stageObject), this._addedToStage = false), (_a = e42.renderer.edgeView) == null ? void 0 : _a.removeObject(this.stageObject), this.stageObject.dispose(), (_b = this._sharedResource) == null ? void 0 : _b.release(), this._visible = false, this._stageLayer = null;
  }
  layerOpacityChanged(e42, t32) {
    const { stageObject: i20, _edgeState: s32, _stageLayer: a28 } = this;
    if (null == s32)
      return;
    const n28 = v5(s32.baseMaterial);
    let r39 = false;
    for (const o27 of s32.edgeMaterials)
      o27.objectTransparency !== n28 && (o27.objectTransparency = n28, r39 = true);
    r39 && this.resetEdgeObject(t32), a28.stage.renderer.withEdgeView((t33) => {
      t33.updateAllComponentOpacities(i20, [e42]);
    });
  }
  slicePlaneEnabledChanged(e42, t32) {
    const { stageObject: i20, _edgeState: s32, _stageLayer: a28 } = this;
    null != s32 && a28.stage.renderer.withEdgeView((a29) => {
      a29.updateAllComponentMaterials(i20, s32.edgeMaterials, { hasSlicePlane: e42 }, !t32), s32.properties.hasSlicePlane = e42;
    });
  }
  setVisibility(e42) {
    const { _edgeState: t32, stageObject: i20, _stageLayer: s32 } = this;
    null != s32 && this.visible !== e42 && (this._visible = e42, i20.visible = e42, e42 && !this._addedToStage && (s32.add(i20), this._addedToStage = true), null != t32 && s32.stage.renderer.withEdgeView((s33) => {
      s33.hasObject(i20) ? s33.updateObjectVisibility(i20, e42) : e42 && this._addOrUpdateEdgeObject(t32, s33, false);
    }));
  }
  get visible() {
    return this._visible;
  }
  alignWithElevation(e42, t32, i20, s32) {
    if (null == this.elevationAligner)
      return;
    null != i20 && l14(this.elevationContext.featureExpressionInfoContext, i20);
    const a28 = (i21, s33) => c17(i21, e42, this.elevationContext, t32, s33);
    this.alignedSampledElevation = this.elevationAligner(this, this.elevationContext, e42.spatialReference, a28, t32), this.resetEdgeObject(s32);
  }
  alignWithAbsoluteElevation(e42, t32, i20) {
    const s32 = (t33, i21) => {
      i21.sampledElevation = e42, i21.verticalDistanceToGround = 0, i21.z = e42;
    };
    this.alignedSampledElevation = this.elevationAligner(this, this.elevationContext, null, s32, t32), this.resetEdgeObject(i20);
  }
  getCenterObjectSpace(t32 = n2()) {
    return r4(t32, Z(this.stageObject.boundingVolumeObjectSpace.bounds));
  }
  getBoundingBoxObjectSpace(e42 = i()) {
    const t32 = this.stageObject.boundingVolumeObjectSpace;
    return A2(e42, t32.min), G2(e42, t32.max), e42;
  }
  computeAttachmentOrigin(e42) {
    const s32 = this.stageObject.effectiveTransformation;
    if (this.useObjectOriginAsAttachmentOrigin)
      e42.render.origin[0] += s32[12], e42.render.origin[1] += s32[13], e42.render.origin[2] += s32[14], e42.render.num++;
    else
      for (const a28 of this.stageObject.geometries)
        a28.computeAttachmentOrigin(y3) && (O2(y3, y3, s32), u5(e42.render.origin, e42.render.origin, y3), e42.render.num++);
  }
  async getProjectedBoundingBox(e42, i20, s32, a28, n28) {
    const r39 = this.getBoundingBoxObjectSpace(n28), d20 = E11, h25 = w3(r39) ? 1 : d20.length;
    for (let o27 = 0; o27 < h25; o27++) {
      const e43 = d20[o27];
      _9[0] = r39[e43[0]], _9[1] = r39[e43[1]], _9[2] = r39[e43[2]], O2(_9, _9, this.stageObject.transformation), f11[3 * o27] = _9[0], f11[3 * o27 + 1] = _9[1], f11[3 * o27 + 2] = _9[2];
    }
    if (!e42(f11, 0, h25))
      return null;
    P2(r39);
    let u32 = null;
    this.calculateRelativeScreenBounds && (u32 = this.calculateRelativeScreenBounds());
    for (let t32 = 0; t32 < 3 * h25; t32 += 3) {
      for (let e43 = 0; e43 < 3; e43++)
        r39[e43] = Math.min(r39[e43], f11[t32 + e43]), r39[e43 + 3] = Math.max(r39[e43 + 3], f11[t32 + e43]);
      u32 && s32.push({ location: f11.slice(t32, t32 + 3), screenSpaceBoundingRect: u32 });
    }
    if ((i20 == null ? void 0 : i20.service) && "absolute-height" !== this.elevationContext.mode) {
      E(r39, y3);
      const e43 = "relative-to-scene" === this.elevationContext.mode ? "scene" : "ground";
      let t32 = 0;
      if (i20.useViewElevation)
        t32 = i20.service.getElevation(y3[0], y3[1], e43) ?? 0;
      else
        try {
          const s33 = k5(r39, i20.service.spatialReference, i20);
          t32 = await i20.service.queryElevation(y3[0], y3[1], a28, s33, e43) ?? 0;
        } catch (m22) {
        }
      Y(r39, 0, 0, -this.alignedSampledElevation + t32);
    }
    return r39;
  }
  addObjectState(e42, t32) {
    e42 === t11.Highlight && t32.addObject(this.stageObject, this.stageObject.highlight()), e42 === t11.MaskOccludee && t32.addObject(this.stageObject, this.stageObject.maskOccludee());
  }
  removeObjectState(e42) {
    e42.removeObject(this.stageObject);
  }
  resetEdgeObject(e42) {
    const { _edgeState: t32, stageObject: i20, _stageLayer: s32, _visible: a28 } = this;
    null != t32 && s32.stage.renderer.withEdgeView((s33) => {
      a28 ? this._addOrUpdateEdgeObject(t32, s33, e42) : s33.removeObject(i20);
    });
  }
  _addOrUpdateEdgeObject(e42, t32, i20) {
    const s32 = v5(e42.baseMaterial);
    for (const a28 of e42.edgeMaterials)
      a28.objectTransparency = s32;
    t32.addOrUpdateObject3D(this.stageObject, e42.edgeMaterials, e42.properties, !i20).then(() => {
      var _a;
      return (_a = this._stageLayer) == null ? void 0 : _a.sync();
    });
  }
};
function v5(e42) {
  return e42.isVisible() ? e42.parameters.transparent ? A3.TRANSPARENT : A3.OPAQUE : A3.INVISIBLE;
}
var f11 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
var _9 = n2();
var y3 = n2();
var E11 = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]];

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObjectMetadata.js
var t25 = class {
  constructor(t32, e42 = null) {
    this.labelText = e42, this.elevationOffset = t32 ?? 0;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DPathSymbolLayerConstants.js
var o17 = 3;
var t26 = 3;
var c18 = 10;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodResources.js
var s18 = class {
  constructor(e42, t32 = null) {
    this.geometry = e42, this.textures = t32;
  }
};
var r23 = class {
  constructor(e42, s32, r39) {
    this.components = e42, this.minScreenSpaceRadius = s32, this.pivotOffset = r39;
    const n28 = this.geometries;
    this.numVertices = n28.reduce((e43, s33) => e43 + s33.attributes.get(e16.POSITION).indices.length, 0);
  }
  get geometries() {
    return s(this.components.map((e42) => e42.geometry));
  }
};
var n17 = class {
  constructor(e42) {
    this.levels = e42, this.levels.sort((e43, t32) => e43.minScreenSpaceRadius === t32.minScreenSpaceRadius ? e43.numVertices - t32.numVertices : e43.minScreenSpaceRadius - t32.minScreenSpaceRadius);
  }
};
function c19(t32) {
  const s32 = [];
  return t32.levels.forEach((e42) => e42.components.forEach((e43) => s32.push(e43.geometry.material))), s(s32);
}
function o18(t32) {
  const s32 = new Array();
  return t32.levels.forEach((e42) => e42.components.forEach((e43) => {
    null != e43.textures && s32.push(...e43.textures);
  })), s(s32);
}
function i12(t32) {
  const s32 = new Array();
  return t32.levels.forEach((e42) => e42.components.forEach((e43) => s32.push(e43.geometry))), s(s32);
}

// node_modules/@arcgis/core/views/3d/layers/graphics/primitiveObjectSymbolUtils.js
function d10(e42) {
  switch (e42) {
    case "sphere":
    case "cube":
    case "diamond":
    case "cylinder":
    case "cone":
    case "inverted-cone":
    case "tetrahedron":
      return true;
  }
  return false;
}
function S9(d20, S21) {
  const m22 = (n28, s32, a28 = false) => new n17(n28.map((n29) => {
    const c32 = s32(n29.tesselation);
    return a28 && Ot(c32), new r23([new s18(c32)], n29.minScreenSpaceRadius);
  }));
  switch (d20) {
    case "sphere":
      return m22([{ tesselation: 0, minScreenSpaceRadius: 0 }, { tesselation: 1, minScreenSpaceRadius: 8 }, { tesselation: 2, minScreenSpaceRadius: 16 }, { tesselation: 3, minScreenSpaceRadius: 50 }, { tesselation: 4, minScreenSpaceRadius: 250 }], (e42) => rt(S21, 0.5, e42, true));
    case "cube":
      return m22([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => G6(S21, 1));
    case "cone":
      return m22(l17, (e42) => at(S21, 1, 0.5, e42, false), true);
    case "inverted-cone":
      return m22(l17, (e42) => at(S21, 1, 0.5, e42, true), true);
    case "cylinder":
      return m22(l17, (e42) => ft(S21, 1, 0.5, e42, [0, 0, 1], [0, 0, 0.5]));
    case "tetrahedron":
      return m22([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => ot3(S21, 1), true);
    case "diamond":
      return m22([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => z2(S21, 1), true);
    default:
      return;
  }
}
var l17 = [{ tesselation: 6, minScreenSpaceRadius: 0 }, { tesselation: 18, minScreenSpaceRadius: 7 }, { tesselation: 64, minScreenSpaceRadius: 65 }];

// node_modules/@arcgis/core/views/3d/layers/graphics/SymbolComplexity.js
var e32 = class {
  constructor(e42) {
    this.estimated = false, this.verticesPerFeature = e42.verticesPerFeature ?? 0, this.verticesPerCoordinate = e42.verticesPerCoordinate ?? 0, this.drawCallsPerFeature = e42.drawCallsPerFeature ?? 0, this.memory = e42.memory ?? new a16();
  }
};
var t27 = class extends e32 {
  constructor(e42) {
    super(e42), this.estimated = true;
  }
};
var s19 = class extends e32 {
  constructor(e42, t32) {
    super(t32), this.numComplexities = e42;
  }
};
var r24 = class extends t27 {
  constructor(e42, t32) {
    super(t32), this.numComplexities = e42;
  }
};
var a16 = class {
  constructor() {
    this.bytesPerFeature = 0, this.bytesPerFeatureLabel = 0, this.resourceBytes = 0, this.draped = { bytesPerFeature: 0, bytesPerFeatureLabel: 0 };
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/defaultSymbolComplexity.js
var P4 = new t27({});
function m11(e42) {
  if ("web-style" === e42.type)
    return P4;
  return F7(e42.symbolLayers.toArray().map((r39) => L5(e42, r39)));
}
function F7(e42) {
  let r39 = 0, t32 = 0, a28 = 0, s32 = false, u32 = 0;
  const o27 = new a16();
  for (const b18 of e42)
    null != b18 && (r39 += b18.verticesPerFeature, t32 += b18.verticesPerCoordinate, a28 += b18.drawCallsPerFeature, o27.bytesPerFeature += b18.memory.bytesPerFeature, o27.bytesPerFeatureLabel += b18.memory.bytesPerFeatureLabel, o27.resourceBytes += b18.memory.resourceBytes, o27.draped.bytesPerFeature += b18.memory.bytesPerFeature, o27.draped.bytesPerFeatureLabel += b18.memory.bytesPerFeatureLabel, s32 = s32 || b18.estimated, ++u32);
  return s32 ? new r24(u32, { verticesPerFeature: r39, verticesPerCoordinate: t32, drawCallsPerFeature: a28, memory: o27 }) : new s19(u32, { verticesPerFeature: r39, verticesPerCoordinate: t32, drawCallsPerFeature: a28, memory: o27 });
}
function d11(e42) {
  const r39 = F7(e42);
  return r39.numComplexities > 0 && (r39.verticesPerFeature /= r39.numComplexities, r39.verticesPerCoordinate /= r39.numComplexities, r39.drawCallsPerFeature /= r39.numComplexities, r39.memory.bytesPerFeature /= r39.numComplexities, r39.memory.bytesPerFeatureLabel /= r39.numComplexities, r39.memory.resourceBytes /= r39.numComplexities, r39.memory.draped.bytesPerFeature /= r39.numComplexities, r39.memory.draped.bytesPerFeatureLabel /= r39.numComplexities), r39;
}
var p14 = {};
function L5(u32, b18) {
  var _a, _b;
  const i20 = C2(u32, b18), c32 = c9(b18) ? 2 : 0;
  switch (b18.type) {
    case "extrude":
      return new e32({ verticesPerFeature: -12, verticesPerCoordinate: 12, drawCallsPerFeature: c32, memory: i20 });
    case "fill":
      if ("mesh-3d" === u32.type)
        return new e32({ drawCallsPerFeature: c32, memory: i20 });
      if (null != b18.outline && b18.outline.size > 0)
        return new e32({ verticesPerFeature: -12, verticesPerCoordinate: 9, memory: i20 });
    case "water":
      return new e32({ verticesPerFeature: -6, verticesPerCoordinate: 3, memory: i20 });
    case "line":
      return new e32({ verticesPerFeature: -6, verticesPerCoordinate: 6, memory: i20 });
    case "object":
      return ((_a = b18.resource) == null ? void 0 : _a.href) ? new t27({ verticesPerFeature: 100, memory: i20 }) : { ...f12(((_b = b18.resource) == null ? void 0 : _b.primitive) ?? d2), memory: i20 };
    case "path": {
      let r39 = 0, u33 = 0;
      switch (b18.profile) {
        case "circle":
          r39 = c18;
          break;
        case "quad":
          r39 = 4;
          break;
        default:
          return void n5(b18.profile);
      }
      switch (b18.join ?? "simple") {
        case "round":
          u33 = o17;
          break;
        case "miter":
        case "bevel":
          u33 = 1;
          break;
        default:
          return;
      }
      const o27 = 2 * r39, c33 = r39 * u33 * 2, n28 = c33 + o27;
      let l31 = -2 * c33 - o27;
      switch (b18.cap) {
        case "none":
          break;
        case "butt":
        case "square":
          l31 += 2 * (r39 - 1);
          break;
        case "round":
          l31 += 2 * (r39 * (t26 - 1) * 2 + r39);
          break;
        default:
          return;
      }
      return new e32({ verticesPerFeature: l31, verticesPerCoordinate: n28, memory: i20 });
    }
    case "text":
    case "icon":
      return new e32({ verticesPerFeature: 6, memory: i20 });
    default:
      return;
  }
}
function C2(r39, t32) {
  const a28 = "point-3d" === r39.type;
  switch (t32.type) {
    case "extrude":
      return t32.edges && t32.edges.size > 0 ? E12.EXTRUDE_EDGES : E12.EXTRUDE;
    case "fill":
      return null != t32.outline && t32.outline.size > 0 ? E12.FILL_OUTLINE : E12.FILL;
    case "water":
      return E12.FILL;
    case "line":
      return "round" === t32.join ? E12.LINE_ROUND : E12.LINE_MITER;
    case "path":
      switch (t32.join) {
        case "round":
          switch (t32.profile) {
            case "circle":
              return E12.PATH_ROUND_CIRCLE;
            case "quad":
              return E12.PATH_ROUND_QUAD;
            default:
              return void n5(t32.profile);
          }
        case "miter":
        case "bevel":
          switch (t32.profile) {
            case "circle":
              return E12.PATH_MITER_CIRCLE;
            case "quad":
              return E12.PATH_MITER_QUAD;
            default:
              return void n5(t32.profile);
          }
        default:
          return;
      }
    case "object":
      return a28 ? E12.OBJECT_POINT : E12.OBJECT_POLYGON;
    case "icon":
    case "text":
      return a28 ? E12.ICON_POINT : E12.ICON_POLYGON;
    default:
      return;
  }
}
function f12(e42) {
  const r39 = p14[e42];
  if (r39)
    return r39;
  const t32 = w6(S9(e42, new E7({})).levels);
  return p14[e42] = new e32({ verticesPerFeature: t32 }), p14[e42];
}
function w6(e42) {
  return e42.reduce((e43, r39, t32) => e43 + r39.numVertices * (1 / 10 ** t32), 0) / e42.reduce((e43, r39, t32) => e43 + 1 / 10 ** t32, 0);
}
var E12 = { ICON_POINT: { bytesPerFeature: 2379.8272296852992, bytesPerFeatureLabel: 852.246235, resourceBytes: 0, draped: { bytesPerFeature: 1868.2382921559424, bytesPerFeatureLabel: 839.205415 } }, ICON_POLYGON: { bytesPerFeature: 2957.8429876524656, bytesPerFeatureLabel: 862.5307816666666, resourceBytes: 0, draped: { bytesPerFeature: 2579.7767085451133, bytesPerFeatureLabel: 856.9298550000001 } }, OBJECT_POINT: { bytesPerFeature: 603.543820573039, bytesPerFeatureLabel: 717.4551849999999, resourceBytes: 0, draped: { bytesPerFeature: 603.543820573039, bytesPerFeatureLabel: 717.4551849999999 } }, OBJECT_POLYGON: { bytesPerFeature: 1111.1693389308373, bytesPerFeatureLabel: 707.4535949999998, resourceBytes: 0, draped: { bytesPerFeature: 1111.1693389308373, bytesPerFeatureLabel: 707.4535949999998 } }, LINE_MITER: { bytesPerFeature: 3081.208408220661, bytesPerFeatureLabel: 858.6749016666668, resourceBytes: 0, draped: { bytesPerFeature: 2682.57863388475, bytesPerFeatureLabel: 844.6118016666666 } }, LINE_ROUND: { bytesPerFeature: 3209.3236242927915, bytesPerFeatureLabel: 858.1810416666667, resourceBytes: 0, draped: { bytesPerFeature: 2687.6256038096126, bytesPerFeatureLabel: 849.578535 } }, PATH_MITER_CIRCLE: { bytesPerFeature: 38708.74276663992, bytesPerFeatureLabel: 858.70415, resourceBytes: 0, draped: { bytesPerFeature: 38708.74276663992, bytesPerFeatureLabel: 858.70415 } }, PATH_ROUND_CIRCLE: { bytesPerFeature: 42098.00590216518, bytesPerFeatureLabel: 868.3632500000001, resourceBytes: 0, draped: { bytesPerFeature: 42098.00590216518, bytesPerFeatureLabel: 868.3632500000001 } }, PATH_MITER_QUAD: { bytesPerFeature: 25037.823002405767, bytesPerFeatureLabel: 835.93355, resourceBytes: 0, draped: { bytesPerFeature: 25037.823002405767, bytesPerFeatureLabel: 835.93355 } }, PATH_ROUND_QUAD: { bytesPerFeature: 40320.254760224525, bytesPerFeatureLabel: 851.66955, resourceBytes: 0, draped: { bytesPerFeature: 40320.254760224525, bytesPerFeatureLabel: 851.66955 } }, FILL: { bytesPerFeature: 3147.43349219103, bytesPerFeatureLabel: 850.7598550000001, resourceBytes: 0, draped: { bytesPerFeature: 2673.7898488975106, bytesPerFeatureLabel: 846.6459950000002 } }, FILL_OUTLINE: { bytesPerFeature: 4565.099993465867, bytesPerFeatureLabel: 855.334515, resourceBytes: 0, draped: { bytesPerFeature: 3904.46969705314, bytesPerFeatureLabel: 844.7081016666667 } }, EXTRUDE: { bytesPerFeature: 7551.2282834569505, bytesPerFeatureLabel: 849.5513283333333, resourceBytes: 0, draped: { bytesPerFeature: 7551.2282834569505, bytesPerFeatureLabel: 849.5513283333333 } }, EXTRUDE_EDGES: { bytesPerFeature: 2959.8379634500698, bytesPerFeatureLabel: 602.0969283333335, resourceBytes: 0, draped: { bytesPerFeature: 2959.8379634500698, bytesPerFeatureLabel: 602.0969283333335 } } };

// node_modules/@arcgis/core/views/3d/layers/graphics/interfaces.js
var e33;
!function(e42) {
  e42[e42.RecreateSymbol = 0] = "RecreateSymbol", e42[e42.RecreateGraphics = 1] = "RecreateGraphics", e42[e42.FastUpdate = 2] = "FastUpdate";
}(e33 || (e33 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Loadable.js
var r25 = class {
  constructor(t32) {
    this.schedule = t32, this._abortController = null, this._loadStatus = l18.LOADING, this._loadError = null, this._loader = null, this.logger = null;
  }
  destroy() {
    this.abortLoad();
  }
  get loadStatus() {
    return this._loadStatus;
  }
  load(t32, r39) {
    return this._loadStatus === l18.LOADED ? (t32 && t32(), this._loader ?? Promise.resolve()) : this._loadStatus === l18.FAILED ? (r39 && r39(this._loadError), this._loader ?? Promise.resolve()) : (null == this._loader && (this._abortController = new AbortController(), this._loader = this.doLoad(this._abortController.signal).then(() => {
      this._abortController = null, this._loadStatus = l18.LOADED;
    }, (t33) => {
      throw this._loadError = t33, this._abortController = null, this._loadStatus = l18.FAILED, !b(t33) && this.logger && t33.message && this.logger.warn(t33.message), t33;
    })), this._loader.then(t32, r39).catch(() => {
    }), this._loader);
  }
  abortLoad() {
    null != this._abortController ? this._abortController = e3(this._abortController) : this._loadStatus === l18.LOADING && (this._loadStatus = l18.FAILED), this._loader = null;
  }
};
var l18;
!function(t32) {
  t32[t32.LOADING = 0] = "LOADING", t32[t32.LOADED = 1] = "LOADED", t32[t32.FAILED = 2] = "FAILED";
}(l18 || (l18 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolLayer.js
var u19 = () => n.getLogger("esri.views.3d.layers.graphics.Graphics3DSymbolLayer");
var h13 = class extends r25 {
  constructor(e42, t32, i20, r39) {
    super(i20.schedule), this.symbol = e42, this.symbolLayer = t32, this._context = i20, this.ignoreDrivers = false, this._drivenProperties = { color: false, opacity: false, opacityAlwaysOpaque: true, size: false }, this._materials = [], this.usedMemory = 0, this.logger = u19(), this._elevationOptions = { supportsOffsetAdjustment: false, supportsOnTheGround: true }, this.skipHighSymbolLodsChanged = true, this._renderPriority = r39.renderPriority, this._renderPriorityStep = r39.renderPriorityStep, this._elevationContext = new o15(), this.complexity = this.computeComplexity(), this.ignoreDrivers = r39.ignoreDrivers, this.ignoreDrivers || (this._drivenProperties = f13(this._context.renderer)), this._updateElevationContext();
  }
  getCachedSize() {
    return null;
  }
  get extentPadding() {
    return 0;
  }
  get materials() {
    return this._materials;
  }
  _drivenPropertiesChanged(e42) {
    if (this.ignoreDrivers)
      return false;
    const t32 = this._drivenProperties, i20 = f13(e42);
    return i20.color !== t32.color || i20.opacity !== t32.opacity || i20.opacityAlwaysOpaque !== t32.opacityAlwaysOpaque || i20.size !== t32.size;
  }
  get needsDrivenTransparentPass() {
    return this._drivenProperties.opacity && !this._drivenProperties.opacityAlwaysOpaque;
  }
  _logGeometryCreationWarnings(e42, t32, i20, r39) {
    const o27 = e42.projectionSuccess, n28 = "polygons" in e42 ? e42.polygons : null, s32 = `${r39} geometry failed to be created`;
    let a28 = null;
    o27 ? !this._logGeometryValidationWarnings(t32, i20, r39) && n28 && 0 === n28.length && "rings" === i20 && t32.length > 0 && t32[0].length > 2 && (a28 = `${s32} (filled rings should use clockwise winding - try reversing the order of vertices)`) : a28 = `${s32} (failed to project geometry to view spatial reference)`, a28 && u19().warnOncePerTick(a28);
  }
  _logGeometryValidationWarnings(e42, t32, i20) {
    const r39 = `${i20} geometry failed to be created`;
    return !e42.length || 1 === e42.length && !e42[0].length ? (u19().warnOncePerTick(`${r39} (no ${t32} were defined)`), true) : (!Array.isArray(e42) || !Array.isArray(e42[0])) && (u19().warnOncePerTick(`${r39} (${t32} should be defined as a 2D array)`), true);
  }
  _validateGeometry(e42, t32 = null, i20 = null) {
    if (null != t32 && !t32.includes(e42.type))
      return this.logger.warn("unsupported geometry type for " + i20 + ` symbol: ${e42.type}`), false;
    if ("point" === e42.type) {
      const t33 = e42;
      if (!isFinite(t33.x) || !isFinite(t33.y))
        return u19().warn("point coordinate is not a valid number, graphic skipped"), false;
    }
    return true;
  }
  _defaultElevationInfoNoZ() {
    return y4;
  }
  _defaultElevationInfoZ() {
    return g7;
  }
  _updateElevationContext() {
    null != this._elevationInfoOverride ? (this._elevationContext.setFromElevationInfo(this._elevationInfoOverride), this._elevationContext.updateFeatureExpressionInfoContext(null)) : this._context.layer.elevationInfo ? (this._elevationContext.setFromElevationInfo(this._context.layer.elevationInfo), this._elevationContext.updateFeatureExpressionInfoContext(this._context.featureExpressionInfoContext)) : this._elevationContext.reset();
  }
  getDefaultElevationInfo(e42) {
    return e42.hasZ ? this._defaultElevationInfoZ() : this._defaultElevationInfoNoZ();
  }
  getGeometryElevationMode(e42, t32 = this.getDefaultElevationInfo(e42)) {
    return this._elevationContext.mode || t32.mode;
  }
  setElevationInfoOverride(e42) {
    this._elevationInfoOverride = e42, this._updateElevationContext();
  }
  setGraphicElevationContext(e42, t32 = new o15()) {
    const i20 = e42.geometry, r39 = this.getDefaultElevationInfo(i20);
    t32.unit = null != this._elevationContext.unit ? this._elevationContext.unit : r39.unit, t32.mode = this.getGeometryElevationMode(i20, r39), t32.offsetMeters = this._elevationContext.meterUnitOffset ?? r39.offset ?? 0;
    const o27 = !this._elevationOptions.supportsOnTheGround && "on-the-ground" === t32.mode;
    o27 && (t32.mode = "relative-to-ground", t32.offsetMeters = 0);
    const n28 = o27 ? f10 : this._elevationContext.featureExpressionInfoContext;
    return t32.updateFeatureExpressionInfoContext(n28, e42, this._context.layer), t32;
  }
  prepareSymbolLayerPatch(e42) {
  }
  updateGeometry(e42, t32) {
    return false;
  }
  updateTransform(e42, t32, i20, r39) {
    return false;
  }
  onRemoveGraphic(e42) {
  }
  _getLayerOpacity() {
    if (this._context.graphicsCoreOwner && "fullOpacity" in this._context.graphicsCoreOwner)
      return this._context.graphicsCoreOwner.fullOpacity ?? 0;
    const e42 = this._context.layer.opacity;
    return e42 ?? 1;
  }
  _getCombinedOpacity(e42, t32 = m12) {
    let i20 = 1;
    return this.draped || (i20 *= this._getLayerOpacity()), this._drivenProperties.opacity || (null != e42 ? i20 *= e42.a : t32.hasIntrinsicColor || (i20 = 0)), i20;
  }
  _getCombinedOpacityAndColor(t32, r39 = m12) {
    const o27 = this._getCombinedOpacity(t32, r39);
    if (this._drivenProperties.color)
      return F6(null, o27);
    const n28 = null != t32 ? u9.toUnitRGB(t32) : _2;
    return F6(n28, o27);
  }
  _getVertexOpacityAndColor(e42, t32 = null) {
    const i20 = this._drivenProperties.color ? e42.color : null, r39 = this._drivenProperties.opacity ? e42.opacity : null, o27 = F6(i20, r39);
    return t32 && (o27[0] *= t32, o27[1] *= t32, o27[2] *= t32, o27[3] *= t32), o27;
  }
  isFastUpdatesEnabled() {
    return null != this._fastUpdates;
  }
  computeComplexity() {
    return L5(this.symbol, this.symbolLayer);
  }
  globalPropertyChanged(e42, t32, i20) {
    switch (e42) {
      case "opacity":
        return this.layerOpacityChanged(t32, i20), true;
      case "elevationInfo": {
        const e43 = this._elevationContext.mode;
        this._updateElevationContext();
        return this.layerElevationInfoChanged(t32, i20, e43) !== b7.RECREATE;
      }
      case "slicePlaneEnabled":
        return this.slicePlaneEnabledChanged(t32, i20);
      case "physicalBasedRenderingEnabled":
        return this.physicalBasedRenderingChanged();
      case "pixelRatio":
        return this.pixelRatioChanged;
      case "skipHighSymbolLods":
        return this.skipHighSymbolLodsChanged;
      default:
        return false;
    }
  }
  get pixelRatioChanged() {
    return true;
  }
  updateGraphics3DGraphicElevationInfo(e42, t32, i20) {
    let r39 = b7.UPDATE;
    return e42.forEach((e43) => {
      const o27 = t32(e43);
      if (null != o27) {
        const t33 = e43.graphic;
        this.setGraphicElevationContext(t33, o27.elevationContext), o27.needsElevationUpdates = i20(o27.elevationContext.mode);
      } else
        r39 = b7.RECREATE;
    }), r39;
  }
  applyRendererDiff(e42, t32) {
    return e33.RecreateSymbol;
  }
  getFastUpdateAttrValues(e42) {
    if (!this._fastUpdates)
      return null;
    const t32 = this._fastUpdates.visualVariables, i20 = t32.size ? X(t32.size.field, e42) : 0, o27 = t32.color ? X(t32.color.field, e42) : 0, n28 = t32.opacity ? X(t32.opacity.field, e42) : 0;
    return r5(i20, o27, n28, 0);
  }
  get draped() {
    return this._draped;
  }
  ensureDrapedStatus(e42) {
    return null == this._draped ? (this._draped = e42, true) : (e42 !== this.draped && u19().warnOnce("A symbol can only produce either draped or non-draped visualizations. Use two separate symbol instances for draped and non-draped graphics if necessary."), false);
  }
  test() {
    const e42 = () => {
      var _a, _b, _c, _d, _e3, _f, _g, _h2;
      return { size: ((_b = (_a = this._fastUpdates) == null ? void 0 : _a.visualVariables.size) == null ? void 0 : _b.field) ?? null, color: ((_d = (_c = this._fastUpdates) == null ? void 0 : _c.visualVariables.color) == null ? void 0 : _d.field) ?? null, opacity: ((_f = (_e3 = this._fastUpdates) == null ? void 0 : _e3.visualVariables.opacity) == null ? void 0 : _f.field) ?? null, rotation: ((_h2 = (_g = this._fastUpdates) == null ? void 0 : _g.visualVariables.rotation) == null ? void 0 : _h2.field) ?? null };
    };
    return { drivenProperties: this._drivenProperties, getVisVarFields: e42 };
  }
};
function f13(e42) {
  const t32 = { color: false, opacity: false, opacityAlwaysOpaque: true, size: false };
  return e42 && "visualVariables" in e42 && e42.visualVariables && e42.visualVariables.forEach((e43) => {
    switch (e43.type) {
      case "color":
        if (t32.color = true, e43.stops)
          for (let i20 = 0; i20 < e43.stops.length; i20++) {
            const r39 = e43.stops[i20].color;
            r39 && (t32.opacity = true, r39.a < 1 && (t32.opacityAlwaysOpaque = false));
          }
        break;
      case "opacity":
        t32.opacity = true, t32.opacityAlwaysOpaque = false;
        break;
      case "size":
        t32.size = true;
    }
  }), t32;
}
var y4 = { mode: "on-the-ground", offset: 0, unit: "meters" };
var g7 = { mode: "absolute-height", offset: 0, unit: "meters" };
var m12 = { hasIntrinsicColor: false };

// node_modules/@arcgis/core/views/3d/layers/graphics/pointUtils.js
function c20(e42, o27, n28, i20, s32) {
  const c32 = e42.clippingExtent;
  if (c8(o27, u20, e42.elevationProvider.spatialReference), null != c32 && !y2(c32, u20))
    return null;
  c8(o27, u20, e42.renderCoordsHelper.spatialReference), n28.localOrigin = e42.localOriginFactory.getOrigin(u20);
  const p23 = new O9({ geometries: [n28], castShadow: false, layerUid: e42.layer.uid, graphicUid: s32, usesVerticalDistanceToGround: true });
  return { object: p23, sampledElevation: p10(p23, o27, e42.elevationProvider, e42.renderCoordsHelper, i20) };
}
function p15(e42, t32, o27) {
  const n28 = e42.elevationContext, l31 = o27.spatialReference;
  c8(t32, u20, l31), n28.centerPointInElevationSR = e13(u20[0], u20[1], t32.hasZ ? u20[2] : 0, null != l31 ? l31 : null);
}
function m13(e42) {
  switch (e42.type) {
    case "point":
      return e42;
    case "polygon":
    case "extent":
      return b8(e42);
    case "polyline": {
      const r39 = e42.paths[0];
      if (!r39 || 0 === r39.length)
        return null;
      const t32 = p(r39, h2(r39) / 2);
      return e13(t32[0], t32[1], t32[2], e42.spatialReference);
    }
    case "mesh":
      return e42.origin;
  }
  return null;
}
var u20 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineCalloutTechnique.js
var h14 = class _h extends r14 {
  initializeConfiguration(i20, t32) {
    t32.spherical = i20.viewingMode === l6.Global;
  }
  initializeProgram(e42) {
    return new r15(e42.rctx, _h.shader.get().build(this.configuration), O6);
  }
  setPipelineState(e42) {
    const i20 = e42 ? O5.ALWAYS : O5.LESS;
    return this.configuration.depthHudEnabled ? S5({ depthTest: { func: i20 }, depthWrite: o12 }) : S5({ blending: l12(R3.ONE, R3.SRC_ALPHA, R3.ONE_MINUS_SRC_ALPHA, R3.ONE_MINUS_SRC_ALPHA), depthTest: { func: i20 }, colorWrite: _6 });
  }
  initializePipeline() {
    return this.setPipelineState(this.configuration.multipassEnabled);
  }
};
h14.shader = new t17(h11, () => import("./LineCallout.glsl-TLISSY3P.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineCalloutTechniqueConfiguration.js
var s20 = class extends t21 {
  constructor() {
    super(...arguments), this.screenCenterOffsetUnitsEnabled = false, this.spherical = false, this.occlusionTestEnabled = true, this.hasVerticalOffset = false, this.hasScreenSizePerspective = false, this.depthHudEnabled = false, this.depthHudAlignStartEnabled = false, this.hasSlicePlane = false, this.multipassEnabled = false;
  }
};
e([r17()], s20.prototype, "screenCenterOffsetUnitsEnabled", void 0), e([r17()], s20.prototype, "spherical", void 0), e([r17()], s20.prototype, "occlusionTestEnabled", void 0), e([r17()], s20.prototype, "hasVerticalOffset", void 0), e([r17()], s20.prototype, "hasScreenSizePerspective", void 0), e([r17()], s20.prototype, "depthHudEnabled", void 0), e([r17()], s20.prototype, "depthHudAlignStartEnabled", void 0), e([r17()], s20.prototype, "hasSlicePlane", void 0), e([r17()], s20.prototype, "multipassEnabled", void 0), e([r17({ constValue: true })], s20.prototype, "hasSliceInVertexProgram", void 0), e([r17({ constValue: false })], s20.prototype, "draped", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/LineCalloutMaterial.js
var d12 = class _d extends c15 {
  get uniqueMaterialIdentifier() {
    return this._uniqueMaterialIdentifier;
  }
  constructor(e42) {
    super(e42, new m14()), this.produces = /* @__PURE__ */ new Map([[A8.LINE_CALLOUTS, (e43) => e43 === o7.Color], [A8.LINE_CALLOUTS_HUD_DEPTH, (e43) => e43 === o7.Color]]), this._configuration = new s20(), this._uniqueMaterialIdentifier = _d.uniqueMaterialIdentifier(this.parameters);
  }
  passParameters() {
    return this.parameters;
  }
  getConfiguration(e42, t32) {
    const r39 = (t32 == null ? void 0 : t32.slot) !== A8.LINE_CALLOUTS;
    return this._configuration.occlusionTestEnabled = this.parameters.occlusionTest, this._configuration.hasVerticalOffset = null != this.parameters.verticalOffset, this._configuration.hasScreenSizePerspective = null != this.parameters.screenSizePerspective, this._configuration.depthHudEnabled = r39, this._configuration.depthHudAlignStartEnabled = !!this.parameters.depthHUDAlignStart, this._configuration.screenCenterOffsetUnitsEnabled = "screen" === this.parameters.centerOffsetUnits, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.multipassEnabled = t32.multipassEnabled, this._configuration;
  }
  intersect() {
  }
  createGLMaterial(e42) {
    return new p16(e42);
  }
  createBufferWriter() {
    return new S10();
  }
  validateParameters(e42) {
    const t32 = _d.uniqueMaterialIdentifier(e42);
    t32 !== this._uniqueMaterialIdentifier && (this._uniqueMaterialIdentifier = t32);
  }
  static uniqueMaterialIdentifier(e42) {
    return JSON.stringify({ horizontalScreenOffset: e42.horizontalScreenOffset ?? 0, centerOffsetUnits: e42.centerOffsetUnits || "world" });
  }
};
var p16 = class extends t16 {
  beginSlot(e42) {
    return this.ensureTechnique(h14, e42);
  }
};
var m14 = class extends u14 {
  constructor() {
    super(...arguments), this.horizontalScreenOffset = 0, this.color = [0, 0, 0, 1], this.size = 1, this.occlusionTest = false, this.shaderPolygonOffset = 1e-5, this.depthHUDAlignStart = false, this.centerOffsetUnits = "world", this.hasSlicePlane = false;
  }
};
var g8 = H2().vec3f(e16.POSITION).vec3f(e16.NORMAL).vec2f(e16.UV0).vec4f(e16.CENTEROFFSETANDDISTANCE);
var O11 = [t15(0, 0), t15(1, 0), t15(0, 1), t15(1, 0), t15(1, 1), t15(0, 1)];
var S10 = class {
  constructor() {
    this.vertexBufferLayout = g8;
  }
  elementCount(e42) {
    return 6 * e42.attributes.get(e16.POSITION).indices.length;
  }
  write(e42, t32, r39, i20, s32) {
    b6(r39.attributes.get(e16.POSITION), e42, i20.position, s32, 6), O7(r39.attributes.get(e16.NORMAL), t32, i20.normal, s32, 6), p7(r39.attributes.get(e16.CENTEROFFSETANDDISTANCE), i20.centerOffsetAndDistance, s32, 6);
    for (let n28 = 0; n28 < O11.length; ++n28)
      i20.uv0.setVec(s32 + n28, O11[n28]);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DLineCalloutSymbolLayer.js
var E13 = class _E extends h13 {
  constructor(e42, t32) {
    super(e42, null, t32, w7), this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: false }, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    this._materials[0] = new d12(this._materialParameters), this._context.stage.add(this._materials[0]);
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._materials[0]), this._materials.length = 0;
  }
  _perInstanceMaterialParameters(e42) {
    const t32 = this._materialParameters;
    return t32.horizontalScreenOffset = e42.horizontalScreenOffset ?? 0, t32.centerOffsetUnits = e42.centerOffsetUnits || "world", t32;
  }
  get _materialParameters() {
    var _a;
    const r39 = new m14(), i20 = this.symbol, n28 = i20.callout;
    if (r39.color = null != n28.color ? u9.toUnitRGBA(n28.color) : [0, 0, 0, 0], r39.color[3] *= this._getLayerOpacity(), r39.size = u8(n28.size || 0), i20.verticalOffset) {
      const { screenLength: e42, minWorldLength: n29, maxWorldLength: a29 } = i20.verticalOffset;
      r39.verticalOffset = { screenLength: u8(e42), minWorldLength: n29 || 0, maxWorldLength: null != a29 ? a29 : 1 / 0 };
    }
    r39.borderColor = null != ((_a = n28.border) == null ? void 0 : _a.color) ? u9.toUnitRGBA(n28.border.color) : null;
    const a28 = "object" === i20.symbolLayers.at(0).type, o27 = "label-3d" === i20.type;
    return r39.occlusionTest = !a28, r39.shaderPolygonOffset = a28 ? 0 : void 0, r39.depthHUDAlignStart = o27, r39.hasSlicePlane = this._context.slicePlaneEnabled, r39.screenSizePerspective = this._context.screenSizePerspectiveEnabled ? this._context.sharedResources.screenSizePerspectiveSettings : null, r39;
  }
  _defaultElevationInfoNoZ() {
    return U3;
  }
  createGraphics3DGraphic(e42) {
    const t32 = e42.renderingInfo, r39 = e42.graphic, i20 = this.setGraphicElevationContext(r39, new o15(), t32.elevationOffset || 0), a28 = t32.symbol, o27 = "on-the-ground" === this._elevationContext.mode && ("cim" === a28.type || !a28.symbolLayers.some((e43) => "object" === e43.type || "text" === e43.type));
    if ("label-3d" !== a28.type && o27)
      return null;
    if ("point-3d" === a28.type && a28.symbolLayers.every((e43) => "text" === e43.type && !l4(e43)))
      return null;
    const s32 = b8(r39.geometry);
    return null == s32 ? null : this._createAs3DShape(s32, i20, t32, r39.uid);
  }
  layerOpacityChanged() {
    var _a;
    (_a = this._materials[0]) == null ? void 0 : _a.setParameters(this._materialParameters);
  }
  layerElevationInfoChanged(e42, t32, r39) {
    const i20 = this._elevationContext.mode, n28 = m9(_E.elevationModeChangeTypes, r39, i20);
    return n28 !== b7.UPDATE || e42.forEach((e43) => {
      const r40 = t32(e43);
      null != r40 && this.updateGraphicElevationContext(e43.graphic, r40);
    }), n28;
  }
  slicePlaneEnabledChanged() {
    var _a;
    return (_a = this._materials[0]) == null ? void 0 : _a.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  setGraphicElevationContext(e42, t32, r39 = 0) {
    return super.setGraphicElevationContext(e42, t32), t32.addOffsetRenderUnits(r39), t32;
  }
  updateGraphicElevationContext(e42, t32) {
    this.setGraphicElevationContext(e42, t32.elevationContext, null != t32.metadata ? t32.metadata.elevationOffset : 0), t32.needsElevationUpdates = d8(t32.elevationContext.mode);
  }
  computeComplexity() {
    return new e32({ verticesPerFeature: 6 });
  }
  _getOrCreateMaterial(e42) {
    var _a;
    const t32 = this._perInstanceMaterialParameters(e42), r39 = d12.uniqueMaterialIdentifier(t32);
    if (r39 === ((_a = this._materials[0]) == null ? void 0 : _a.uniqueMaterialIdentifier))
      return { material: this._materials[0], isUnique: false };
    if (null != e42.materialCollection) {
      let i20 = e42.materialCollection.get(r39);
      return null == i20 && (i20 = new d12(t32), e42.materialCollection.add(r39, i20)), { material: i20, isUnique: false };
    }
    return { material: new d12(t32), isUnique: true };
  }
  _createAs3DShape(e42, t32, r39, i20) {
    const n28 = this._context.layer.uid, o27 = this._context.stage.renderView.getObjectAndLayerIdColor({ graphicUid: i20, layerUid: n28 }), s32 = this._getOrCreateMaterial(r39), c32 = new I2(s32.material, j11(r39), null, e20.Point, o27), m22 = c20(this._context, e42, c32, t32, i20);
    if (null == m22)
      return null;
    const p23 = new p13(this, m22.object, [c32], s32.isUnique ? [s32.material] : null, null, p12, t32);
    return p23.metadata = new t25(r39.elevationOffset), p23.alignedSampledElevation = m22.sampledElevation, p23.needsElevationUpdates = d8(t32.mode), p15(p23, e42, this._context.elevationProvider), p23;
  }
};
function j11(e42) {
  const { translation: t32, centerOffset: r39 } = e42, i20 = new t8(t32 ? [t32[0], t32[1], t32[2]] : [0, 0, 0], P5, 3, true), n28 = new t8(r39 ? [r39[0], r39[1], r39[2], r39[3]] : [0, 0, 0, 1], P5, 4, true);
  return [[e16.POSITION, i20], [e16.NORMAL, new t8([0, 0, 1], P5, 3, true)], [e16.CENTEROFFSETANDDISTANCE, n28]];
}
E13.elevationModeChangeTypes = { definedChanged: b7.UPDATE, staysOnTheGround: b7.UPDATE, onTheGroundChanged: b7.RECREATE };
var P5 = [0];
var U3 = { mode: "relative-to-ground", offset: 0 };
var w7 = { ignoreDrivers: true, renderPriority: 0, renderPriorityStep: 1 };
var G7 = class {
  constructor(e42, t32, n28 = n2(), a28 = n6(), o27 = 0, s32 = "world", l31 = 0, c32 = null) {
    this.renderer = e42, this.symbol = t32, this.translation = n28, this.centerOffset = a28, this.horizontalScreenOffset = o27, this.centerOffsetUnits = s32, this.elevationOffset = l31, this.materialCollection = c32;
  }
};
var S11 = class extends r22 {
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DCalloutSymbolLayerFactory.js
var t28 = () => n.getLogger("esri.views.3d.layers.graphics.Graphics3DCalloutSymbolLayerFactory");
function e34(o27, l31) {
  if (!o5(o27))
    return t28().error("Graphics3DCalloutSymbolLayerFactory#make", `symbol of type '${o27.type}' does not support callouts`), null;
  if (!o27.callout)
    return null;
  const e42 = a17[o27.callout.type];
  return e42 ? new e42(o27, l31) : (t28().error("Graphics3DCalloutSymbolLayerFactory#make", `unknown or unsupported callout type ${o27.callout.type}`), null);
}
var a17 = { line: E13 };

// node_modules/@arcgis/core/renderers/support/renderingInfoUtils.js
function o19(t32, e42) {
  if (!t32 || t32.symbol)
    return null;
  const o27 = e42 == null ? void 0 : e42.renderer;
  return t32 && null != o27 && o27.getObservationRenderer ? o27.getObservationRenderer(t32) : o27;
}
function r26(t32, e42) {
  if (null != t32.symbol)
    return t32.symbol;
  const r39 = o19(t32, e42);
  return null != r39 && "dot-density" !== r39.type ? r39.getSymbol(t32, e42) : null;
}
function i13(t32, i20) {
  const n28 = o19(t32, i20), l31 = r26(t32, i20);
  if (null == l31)
    return null;
  const a28 = { renderer: n28, symbol: l31 };
  if (null == n28 || !("visualVariables" in n28) || !n28.visualVariables)
    return a28;
  const s32 = M(n28, t32, i20) ?? [], u32 = ["proportional", "proportional", "proportional"];
  for (const { variable: e42, value: o27 } of s32)
    switch (e42.type) {
      case "color":
        a28.color = o27.toRgba();
        break;
      case "size":
        if ("outline" === e42.target)
          a28.outlineSize = o27;
        else {
          const t33 = e42.axis, r39 = e42.useSymbolValue ? "symbol-value" : o27;
          switch (t33) {
            case "width":
              u32[0] = r39;
              break;
            case "depth":
              u32[1] = r39;
              break;
            case "height":
              u32[2] = r39;
              break;
            case "width-and-depth":
              u32[0] = u32[1] = r39;
              break;
            default:
              u32[0] = u32[1] = u32[2] = r39;
          }
        }
        break;
      case "opacity":
        a28.opacity = o27;
        break;
      case "rotation":
        switch (e42.axis) {
          case "tilt":
            a28.tilt = o27;
            break;
          case "roll":
            a28.roll = o27;
            break;
          default:
            a28.heading = o27;
        }
    }
  return "proportional" === u32[0] && "proportional" === u32[1] && "proportional" === u32[2] || (a28.size = u32), a28;
}
async function n18(t32, e42) {
  if (null != t32.symbol)
    return t32.symbol;
  const r39 = o19(t32, e42);
  return null != r39 ? r39.getSymbolAsync(t32, e42) : null;
}
async function l19(r39, i20) {
  const l31 = o19(r39, i20), a28 = await n18(r39, i20);
  if (!a28)
    return null;
  const s32 = { renderer: l31, symbol: a28 };
  if (!l31 || !("visualVariables" in l31) || !l31.visualVariables)
    return s32;
  const u32 = M(l31, r39, i20) ?? [], c32 = ["proportional", "proportional", "proportional"];
  for (const { variable: e42, value: o27 } of u32)
    if ("color" === e42.type)
      s32.color = u9.toUnitRGBA(o27);
    else if ("size" === e42.type)
      if ("outline" === e42.target)
        s32.outlineSize = o27;
      else {
        const t32 = e42.axis, r40 = e42.useSymbolValue ? "symbol-value" : o27;
        "width" === t32 ? c32[0] = r40 : "depth" === t32 ? c32[1] = r40 : "height" === t32 ? c32[2] = r40 : c32[0] = c32[1] = "width-and-depth" === t32 ? r40 : c32[2] = r40;
      }
    else
      "opacity" === e42.type ? s32.opacity = o27 : "rotation" === e42.type && "tilt" === e42.axis ? s32.tilt = o27 : "rotation" === e42.type && "roll" === e42.axis ? s32.roll = o27 : "rotation" === e42.type && (s32.heading = o27);
  return (isFinite(c32[0]) || isFinite(c32[1]) || isFinite(c32[2])) && (s32.size = c32), s32;
}
function a18(t32, e42 = 0) {
  const o27 = t32[e42];
  return "number" == typeof o27 && isFinite(o27) ? o27 : null;
}
function s21(t32) {
  for (let e42 = 0; e42 < 3; e42++) {
    const o27 = t32[e42];
    if ("number" == typeof o27)
      return isFinite(o27) ? o27 : 0;
  }
  return 0;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/constants.js
var r27 = 1.2;
var t29 = _4;
var c21 = 4;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextHelperCanvas.js
function a19(a28, n28, c32) {
  return a28.canvas || (a28.canvas = document.createElement("canvas")), a28.canvas.width = n28, a28.canvas.height = c32, a28.canvas;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/FontMetrics.js
function e35(e42) {
  const { size: c32 } = e42.definition, a28 = e42.fontString(c32);
  let i20 = n19.get(a28);
  if (!i20) {
    const u32 = a19(o20, 0, 0).getContext("2d");
    e42.setFontProperties(u32, c32);
    const x12 = u32.measureText(r28);
    i20 = new s22(x12.actualBoundingBoxAscent, x12.actualBoundingBoxDescent), n19.set(a28, i20);
  }
  return i20;
}
var n19 = /* @__PURE__ */ new Map();
var s22 = class {
  get maxHeight() {
    return this.maxAscent + this.maxDescent;
  }
  constructor(t32, e42) {
    this.maxAscent = t32, this.maxDescent = e42;
  }
};
var o20 = { canvas: null };
var r28 = (() => {
  let t32 = "";
  for (let e42 = 32; e42 < 127; e42++)
    t32 += String.fromCharCode(e42);
  return t32;
})();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextRenderer.js
var s23 = 1;
var r29 = class {
  constructor(t32, e42, i20, n28) {
    this.text = t32, this._alignment = e42, this._parameters = i20, this._maxSize = n28, this._textWidths = [], this._lineWidths = [], this._renderPixelRatio = null, this._metricsCached = null, this.key = `TextRenderer-${this._parameters.key}-${this._alignment}--${t32}`, this._lines = t32.replaceAll(" ", "").split(/\r?\n/);
  }
  get displayWidth() {
    return Math.ceil(this._displayWidth + 2 * this._horizontalPadding);
  }
  get displayHeight() {
    let t32 = this._metrics.firstLineAscent;
    for (let e42 = 0; e42 < this._lines.length - 1; e42++)
      t32 += this._lineSpacing;
    return t32 += this._metrics.lastLineDescent, Math.ceil(t32 + 2 * this._haloSize + 2 * this._verticalPadding);
  }
  get renderedWidth() {
    return this._toRoundedRenderUnit(this.displayWidth);
  }
  get renderedHeight() {
    return this._toRoundedRenderUnit(this.displayHeight);
  }
  get firstRenderedBaselinePosition() {
    return this._toRenderUnit(this._firstLineYOffset + this._metrics.firstLineAscent);
  }
  get _firstLineYOffset() {
    return this._verticalPadding + this._haloSize;
  }
  get _metrics() {
    if (null == this._metricsCached) {
      const t32 = a19(a20, l20, l20).getContext("2d"), e42 = this._parameters.definition.pixelRatio, s32 = this._fontSize * e42;
      this._parameters.setFontProperties(t32, s32);
      let r39 = 2 * this._haloSize;
      const h25 = this._parameters.definition.font;
      "italic" !== h25.style && "oblique" !== h25.style && "bold" !== h25.weight && "bolder" !== h25.weight || (r39 += 0.3 * t32.measureText("A").width), this._textWidths.length = 0, this._lineWidths.length = 0;
      let o27 = 0, d20 = 0, _16 = 0, g15 = 0, m22 = 0;
      this._lines.forEach((i20, n28) => {
        const s33 = t32.measureText(i20), h26 = s33.width / e42, a28 = h26 + r39;
        this._textWidths.push(h26), this._lineWidths.push(a28), o27 = Math.max(o27, a28), g15 = Math.max(g15, s33.actualBoundingBoxAscent / e42), m22 = Math.max(m22, s33.actualBoundingBoxDescent / e42), 0 === n28 && (d20 = s33.actualBoundingBoxAscent / e42), n28 === this._lines.length - 1 && (_16 = s33.actualBoundingBoxDescent / e42);
      });
      const f23 = e35(this._parameters), u32 = Math.max(g15, f23.maxAscent), p23 = Math.max(m22, f23.maxDescent), x12 = d20, R11 = "underline" === this._parameters.definition.font.decoration ? p23 : _16, S21 = o27;
      this._metricsCached = new c22(x12, R11, u32, p23, S21);
    }
    return this._metricsCached;
  }
  get _lineSpacing() {
    return (this._midLineHeight + this._linePadding) * this._parameters.definition.lineSpacingFactor;
  }
  get _midLineHeight() {
    return this._metrics.midLineHeight;
  }
  get _linePadding() {
    return this._midLineHeight * d13;
  }
  get _midLineAscent() {
    return this._metrics.maxLineAscent;
  }
  get _renderedFontSize() {
    return this._toRenderUnit(this._fontSize);
  }
  get _fontSize() {
    return this._parameters.definition.size;
  }
  get _renderedHaloSize() {
    return this._toRenderUnit(this._haloSize);
  }
  get _haloSize() {
    return this._parameters.haloSize;
  }
  get _horizontalPadding() {
    return this._hasBackground ? this._parameters.definition.background.padding[0] : 0;
  }
  get _verticalPadding() {
    return Math.max(this._hasBackground ? this._parameters.definition.background.padding[1] : 0, s23);
  }
  get _hasBackground() {
    return !!this._parameters.backgroundStyle;
  }
  get renderPixelRatio() {
    if (null == this._renderPixelRatio) {
      const t32 = this._parameters.definition.pixelRatio;
      this._renderPixelRatio = Math.min(t32, Math.min(this._maxSize[0] / this.displayWidth, this._maxSize[1] / this.displayHeight));
    }
    return this._renderPixelRatio;
  }
  _getLineXOffset(t32) {
    switch (this._alignment) {
      case o21.Left:
        return this._horizontalPadding;
      case o21.Center:
        return (this.displayWidth - this._lineWidths[t32]) / 2;
      case o21.Right:
        return this.displayWidth - this._horizontalPadding - this._lineWidths[t32];
    }
  }
  render(t32, i20, n28) {
    t32.save();
    const s32 = i20 /= this.renderPixelRatio, r39 = n28 /= this.renderPixelRatio, h25 = this._haloSize, o27 = this._firstLineYOffset + this._metrics.firstLineAscent;
    i20 += h25, n28 += o27;
    const a28 = this._haloSize > 0;
    a28 && this._renderHalo(t32, s32, r39, h25, o27), this._parameters.setFontProperties(t32, this._renderedFontSize);
    for (let e42 = 0; e42 < this._lines.length; ++e42) {
      const s33 = this._lines[e42], r40 = this._getLineXOffset(e42);
      a28 && (t32.globalCompositeOperation = "destination-out", t32.fillStyle = "rgb(0, 0, 0)", this._fillText(t32, s33, i20 + r40, n28), this._renderLineDecoration(t32, i20 + r40, n28, this._textWidths[e42])), t32.globalCompositeOperation = "source-over", t32.fillStyle = this._parameters.textStyle, this._fillText(t32, s33, i20 + this._getLineXOffset(e42), n28), this._renderLineDecoration(t32, i20 + r40, n28, this._textWidths[e42]), n28 += this._lineSpacing;
    }
    if (t19.TEXT_SHOW_BASELINE) {
      t32.strokeStyle = _10, t32.setLineDash([2, 2]), t32.lineWidth = 1;
      let e42 = r39 + o27;
      for (let i21 = 0; i21 < this._lines.length; ++i21)
        this._drawLine(t32, [s32, e42], [s32 + this.displayWidth, e42]), e42 += this._lineSpacing;
    }
    if (t19.TEXT_SHOW_BORDER && (t32.strokeStyle = _10, t32.setLineDash([]), t32.lineWidth = 1, this._drawBox(t32, [s32, r39], [this.displayWidth, this.displayHeight])), this._hasBackground) {
      const e42 = this._parameters.definition.background.borderRadius * this.renderPixelRatio;
      this._roundedRect(t32, s32, r39, e42), t32.globalCompositeOperation = "destination-over", t32.fillStyle = this._parameters.backgroundStyle, t32.fill();
    }
    t32.restore();
  }
  _renderLineDecoration(t32, e42, i20, n28, s32 = false) {
    if ("none" === this._parameters.definition.font.decoration || 0 === n28)
      return;
    const r39 = 1, h25 = Math.max(this._parameters.definition.size / 16, r39);
    switch (this._parameters.definition.font.decoration) {
      case "underline":
        i20 += 2 * h25;
        break;
      case "line-through":
        i20 -= 0.33 * this._midLineAscent;
    }
    const o27 = s32 ? this._haloSize : 0;
    t32.strokeStyle = s32 ? this._parameters.haloStyle : this._parameters.textStyle, t32.lineWidth = this._toRenderUnit(h25 + 2 * o27), t32.beginPath(), t32.moveTo(this._toRenderUnit(e42 - o27), this._toRenderUnit(i20)), t32.lineTo(this._toRenderUnit(e42 + n28 + o27), this._toRenderUnit(i20)), t32.stroke();
  }
  _roundedRect(e42, i20, n28, s32) {
    i20 = this._toRenderUnit(i20), n28 = this._toRenderUnit(n28);
    const r39 = this.renderedWidth, h25 = this.renderedHeight;
    0 !== s32 ? (s32 = e9(s32, 0, Math.floor(h25 / 2)), e42.beginPath(), e42.moveTo(i20, n28 + s32), e42.arcTo(i20, n28, i20 + s32, n28, s32), e42.lineTo(i20 + r39 - s32, n28), e42.arcTo(i20 + r39, n28, i20 + r39, n28 + s32, s32), e42.lineTo(i20 + r39, n28 + h25 - s32), e42.arcTo(i20 + r39, n28 + h25, i20 + r39 - s32, n28 + h25, s32), e42.lineTo(i20 + s32, n28 + h25), e42.arcTo(i20, n28 + h25, i20, n28 + h25 - s32, s32), e42.closePath()) : e42.rect(i20, n28, r39, h25);
  }
  _renderHalo(t32, e42, i20, s32, r39) {
    const h25 = this.renderedWidth, o27 = this.renderedHeight, d20 = a19(a20, Math.max(h25, l20), Math.max(o27, l20)), _16 = d20.getContext("2d");
    _16.clearRect(0, 0, h25, o27), this._parameters.setFontProperties(_16, this._renderedFontSize), _16.fillStyle = this._parameters.haloStyle, _16.strokeStyle = this._parameters.haloStyle;
    const c32 = this._renderedHaloSize < 3;
    _16.lineJoin = c32 ? "miter" : "round", c32 ? this._renderHaloEmulated(_16, s32, r39) : this._renderHaloNative(_16, s32, r39);
    let g15 = r39;
    for (let n28 = 0; n28 < this._lines.length; ++n28) {
      const t33 = this._getLineXOffset(n28);
      this._renderLineDecoration(_16, s32 + t33, g15, this._textWidths[n28], true), g15 += this._lineSpacing;
    }
    t32.globalAlpha = this._parameters.definition.halo.color[3], t32.drawImage(d20, 0, 0, h25, o27, this._toRenderUnit(e42), this._toRenderUnit(i20), h25, o27), t32.globalAlpha = 1;
  }
  _renderHaloEmulated(t32, e42, i20) {
    for (let n28 = 0; n28 < this._lines.length; ++n28) {
      const s32 = this._lines[n28], r39 = this._getLineXOffset(n28);
      for (const [n29, o27] of h15)
        this._fillText(t32, s32, e42 + r39 + this._haloSize * n29, i20 + this._haloSize * o27);
      i20 += this._lineSpacing;
    }
  }
  _renderHaloNative(t32, e42, i20) {
    const n28 = 2 * this._haloSize;
    for (let s32 = 0; s32 < this._lines.length; ++s32) {
      const r39 = this._lines[s32], h25 = this._getLineXOffset(s32), o27 = 5, a28 = 0.1;
      for (let s33 = 0; s33 < o27; s33++) {
        const d20 = 1 - (o27 - 1) * a28 + s33 * a28;
        t32.lineWidth = this._toRenderUnit(d20 * n28), this._strokeText(t32, r39, e42 + h25, i20);
      }
      i20 += this._lineSpacing;
    }
  }
  get _displayWidth() {
    return this._metrics.displayWidth;
  }
  _toRenderUnit(t32) {
    return t32 * this.renderPixelRatio;
  }
  _toRoundedRenderUnit(t32) {
    return Math.round(t32 * this.renderPixelRatio);
  }
  _fillText(t32, e42, i20, n28) {
    t32.fillText(e42, this._toRenderUnit(i20), this._toRenderUnit(n28));
  }
  _strokeText(t32, e42, i20, n28) {
    t32.strokeText(e42, this._toRenderUnit(i20), this._toRenderUnit(n28));
  }
  _drawLine(t32, e42, i20) {
    t32.beginPath(), t32.moveTo(this._toRoundedRenderUnit(e42[0]) + 0.5, this._toRoundedRenderUnit(e42[1]) + 0.5), t32.lineTo(this._toRoundedRenderUnit(i20[0]) + 0.5, this._toRoundedRenderUnit(i20[1]) + 0.5), t32.stroke();
  }
  _drawBox(t32, e42, i20) {
    const n28 = this._toRenderUnit(e42[0]), s32 = this._toRenderUnit(e42[1]), r39 = this._toRenderUnit(i20[0]), h25 = this._toRenderUnit(i20[1]), o27 = Math.floor(n28) + 0.5, a28 = Math.ceil(n28 + r39) - 0.5, d20 = Math.floor(s32) + 0.5, l31 = Math.ceil(s32 + h25) - 0.5;
    t32.beginPath(), t32.moveTo(o27, d20), t32.lineTo(a28, d20), t32.lineTo(a28, l31), t32.lineTo(o27, l31), t32.lineTo(o27, d20), t32.stroke();
  }
};
var h15 = [];
{
  const t32 = 16;
  for (let e42 = 0; e42 < 360; e42 += 360 / t32)
    h15.push([Math.cos(Math.PI * e42 / 180), Math.sin(Math.PI * e42 / 180)]);
}
var o21;
!function(t32) {
  t32[t32.Left = 0] = "Left", t32[t32.Center = 1] = "Center", t32[t32.Right = 2] = "Right";
}(o21 || (o21 = {}));
var a20 = { canvas: null };
var d13 = 0.2;
var l20 = 512;
var _10 = "rgb(255, 0, 255, 0.5)";
var c22 = class {
  get firstLineHeight() {
    return this.firstLineAscent + this.maxLineDescent;
  }
  get midLineHeight() {
    return this.maxLineAscent + this.maxLineDescent;
  }
  get lastLineHeight() {
    return this.maxLineAscent + this.lastLineDescent;
  }
  constructor(t32, e42, i20, n28, s32) {
    this.firstLineAscent = t32, this.lastLineDescent = e42, this.maxLineAscent = i20, this.maxLineDescent = n28, this.displayWidth = s32;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/placementUtils.js
var i14 = Object.freeze({ left: 0, center: 0.5, right: 1 });
var s24 = Object.freeze({ "bottom-left": r7(0, 0), bottom: r7(0.5, 0), "bottom-right": r7(1, 0), left: r7(0, 0.5), center: r7(0.5, 0.5), right: r7(1, 0.5), "top-left": r7(0, 1), top: r7(0.5, 1), "top-right": r7(1, 1) });
function f14(t32) {
  switch (t32) {
    case "left":
      return o21.Left;
    case "right":
      return o21.Right;
    default:
      return o21.Center;
  }
}
function a21(t32) {
  switch (t32) {
    case "bottom-left":
    case "left":
    case "top-left":
      return "left";
    case "bottom":
    case "center":
    case "top":
      return "center";
    case "bottom-right":
    case "right":
    case "top-right":
      return "right";
  }
}
function l21(t32) {
  switch (t32) {
    case "bottom-left":
    case "bottom":
    case "bottom-right":
      return "bottom";
    case "left":
    case "center":
    case "right":
      return "center";
    case "top-left":
    case "top":
    case "top-right":
      return "top";
  }
}
function m15(t32, e42) {
  switch (e42) {
    case "bottom":
      return "left" === t32 ? "bottom-left" : "right" === t32 ? "bottom-right" : "bottom";
    case "center":
      return t32;
    case "top":
      return "left" === t32 ? "top-left" : "right" === t32 ? "top-right" : "top";
  }
}
function u21(t32) {
  return "middle" === t32 ? "center" : t32;
}
function h16(r39, c32) {
  switch (r39) {
    case "top":
      return o8(c32, 0, s23);
    case "bottom":
      return o8(c32, 0, -s23);
    default:
      return r11(c32, a6);
  }
}

// node_modules/@arcgis/core/views/3d/layers/graphics/LabelParameters.js
var i15 = class {
  constructor(i20, r39 = "center", c32 = false, a28 = n9(), o27 = r5(0, 0, 0, -1), l31 = "world", f23 = n2(), n28 = 0) {
    this.verticalOffset = i20, this.anchor = r39, this.hasLabelVerticalOffset = c32, this.screenOffset = a28, this.centerOffset = o27, this.centerOffsetUnits = l31, this.translation = f23, this.elevationOffset = n28;
  }
};
var r30 = class {
  constructor(e42, s32 = "center", i20 = "center", r39 = null, c32 = n9()) {
    this.placement = e42, this.horizontalPlacement = s32, this.verticalPlacement = i20, this.text = r39, this.displaySize = c32;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextRenderParameters.js
var s25 = class _s {
  constructor(o27) {
    this.definition = o27, this.key = JSON.stringify(o27), this.haloSize = Math.round(o27.halo.size), this.textStyle = a22(o27.color), this.haloStyle = l22(o27.halo.color), this.backgroundStyle = 0 !== o27.background.color[3] ? a22(o27.background.color) : null;
  }
  fontString(o27) {
    const t32 = this.definition.font, e42 = "sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji";
    return `${t32.style} ${t32.weight} ${o27}px ${t32.family}, ${e42}`;
  }
  setFontProperties(o27, t32) {
    o27.font = this.fontString(t32), o27.textAlign = "left", o27.textBaseline = "alphabetic";
  }
  static async fromSymbol(l31, a28) {
    var _a, _b, _c, _d, _e3;
    const f23 = (_a = l31 == null ? void 0 : l31.material) == null ? void 0 : _a.color, m22 = u9.toUnitRGBA(f23) ?? _4, g15 = null != l31.size ? u8(l31.size) : 12, u32 = l31.lineHeight, d20 = null != l31.background ? u9.toUnitRGBA(l31.background.color) : _4, h25 = { family: ((_b = l31.font) == null ? void 0 : _b.family) ?? "sans-serif", decoration: ((_c = l31.font) == null ? void 0 : _c.decoration) ?? "none", weight: ((_d = l31.font) == null ? void 0 : _d.weight) ?? "normal", style: ((_e3 = l31.font) == null ? void 0 : _e3.style) ?? "normal" }, y10 = l31.halo, b18 = null != (y10 == null ? void 0 : y10.color) && y10.size > 0 ? { size: u8(y10.size), color: u9.toUnitRGBA(y10.color) } : { size: 0, color: _4 }, p23 = new _s({ color: m22, size: g15, background: { color: d20, padding: null != l31.background ? [0.65 * g15, 0.5 * g15] : [0, 0], borderRadius: null != l31.background ? g15 * (6 / 16) : 0 }, lineSpacingFactor: u32, font: h25, halo: b18, pixelRatio: a28 });
    if (l31.font) {
      let o27 = false;
      const r39 = p23.fontString(g15);
      try {
        o27 = (await document.fonts.load(r39)).some((o28) => !i7(o28));
      } catch (S21) {
        n.getLogger("esri.views.3d.webgl-engine.lib.TextRenderParameters").warnOnce(`Failed to preload font '${r39}'. Some text symbology may be rendered using the default browser font.`);
      }
      if (!o27 && !c23.has(l31.font.family))
        try {
          await c12(l31.font);
        } catch (S21) {
        }
    }
    return p23;
  }
};
function l22(o27) {
  return `rgb(${o27.slice(0, 3).map((o28) => Math.floor(255 * o28)).toString()})`;
}
function a22(o27) {
  return `rgba(${o27.slice(0, 3).map((o28) => Math.floor(255 * o28)).toString()},${o27[3]})`;
}
var c23 = /* @__PURE__ */ new Set(["Arial", "Times New Roman", "Courier New", "serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextTextureAtlas.js
var b11 = 4096;
var j12 = class extends S2 {
  constructor(t32) {
    super(t32), this.type = e20.Texture, this.id = e5(), this.events = new o(), this._glTexture = null, this._atlas = new k6(256, 256), this._needsRepack = false, this._canRepack = true, this._elementsToRender = /* @__PURE__ */ new Map(), this._elements = /* @__PURE__ */ new Map(), this._stageObjects = /* @__PURE__ */ new Map(), this.updating = false;
  }
  initialize() {
    this._canvas = document.createElement("canvas"), this._canvas.setAttribute("id", "textAtlasCanvas"), this._canvas.setAttribute("style", "display:none"), this._ctx = this._canvas.getContext("2d"), this._stage = this.view._stage, this._stage.add(this), this._updateCanvasElementSize(this._atlas), this._reset();
  }
  unload() {
    this._glTexture = r2(this._glTexture), this.updating = false, this.events.emit("unloaded");
  }
  get glTexture() {
    return this._glTexture;
  }
  static get maxSize() {
    return S12 = n14.stableRendering ? A10 : 0, [b11 - A10 - S12, b11 - A10 - S12 - R6];
  }
  load(t32) {
    if (this._glTexture)
      return this._glTexture;
    const e42 = new e25();
    return e42.wrapMode = D4.CLAMP_TO_EDGE, e42.samplingMode = L3.LINEAR_MIPMAP_LINEAR, e42.hasMipmap = true, e42.preMultiplyAlpha = true, e42.maxAnisotropy = t32.parameters.maxMaxAnisotropy, this._glTexture = new m7(t32, e42, this._canvas), this._frameWorker = this.view.resourceController.scheduler.registerTask(I3.TEXT_TEXTURE_ATLAS, this), this.setDirty(), this._glTexture;
  }
  dispose() {
    this._elements.clear(), this._elementsToRender.clear(), this._frameWorker = l(this._frameWorker), this._glTexture && (this._stage.remove(this), this._glTexture = r2(this._glTexture)), this._canvas.width = 0, this._canvas.height = 0, this._canvas = null, this._ctx = null;
  }
  _updateCanvasElementSize(t32) {
    this._canvas.setAttribute("width", t32.width.toString()), this._canvas.setAttribute("height", t32.height.toString());
  }
  _resizeAtlas(t32, e42) {
    var _a, _b;
    const { width: s32, height: i20 } = this._atlas;
    s32 === t32 && i20 === e42 || (this._atlas.width = t32, this._atlas.height = e42, (_a = this._glTexture) == null ? void 0 : _a.resize(t32, e42), (_b = this._glTexture) == null ? void 0 : _b.updateData(0, 0, 0, s32, i20, this._canvas), this._updateCanvasElementSize(this._atlas), this._elements.forEach((t33) => {
      const e43 = this._stageObjects.get(t33.textRenderer.key);
      e43 == null ? void 0 : e43.forEach((e44) => y5(e44, t33));
    }), this._reset());
  }
  _reset() {
    this._elementsToRender.clear(), this._atlas.reset(), this._needsRepack = true, this.setDirty();
  }
  _addAtlasElement(t32, e42, s32, i20) {
    const r39 = this._atlas;
    if (r39.width < s32 || r39.height < i20)
      return false;
    let n28 = r39.cursors.get(i20);
    if (!n28) {
      if (r39.height < r39.nextY + i20)
        return false;
      n28 = [new E14(r39.nextY)], r39.cursors.set(i20, n28), r39.nextY += i20;
    }
    let h25 = n28.find((t33) => r39.width >= t33.x + s32);
    if (null == h25) {
      if (r39.height < r39.nextY + i20)
        return false;
      h25 = new E14(r39.nextY), r39.nextY += i20, n28.push(h25);
    }
    return t32.setNewPosition(h25), this._elements.set(e42, t32), this._elementsToRender.set(e42, t32), h25.x += s32, true;
  }
  _ensureStageObjects(t32) {
    const e42 = this._stageObjects.get(t32);
    if (e42)
      return e42;
    const s32 = /* @__PURE__ */ new Set();
    return this._stageObjects.set(t32, s32), s32;
  }
  _addStageObject(t32, e42) {
    this._ensureStageObjects(t32).add(e42);
  }
  _removeStageObject(t32, e42) {
    const s32 = this._stageObjects.get(t32);
    (s32 == null ? void 0 : s32.delete(e42)) && (e42.geometries[0].setAttributeData(e16.SIZE, [0, 0]), e42.geometryVertexAttributeUpdated(e42.geometries[0], e16.SIZE), this._elementsToRender.delete(t32));
  }
  _processAddition(t32) {
    const e42 = t32.textRenderer.key;
    if (this._needsRepack)
      return void this._elements.set(e42, t32);
    const s32 = this._atlas, i20 = t32.textRenderer.renderedWidth, r39 = t32.textRenderer.renderedHeight, n28 = i20 + A10, h25 = r39 + A10 + R6;
    if (!this._addAtlasElement(t32, e42, n28, h25)) {
      if (this._canRepack)
        this._reset();
      else if (s32.width < n28) {
        const t33 = Math.min(n13(Math.max(n28, 1.5 * s32.width)), b11);
        this._resizeAtlas(t33, s32.height);
      } else {
        const t33 = s32.nextY + h25, e43 = Math.min(n13(Math.max(t33, 1.5 * s32.height)), b11);
        if (e43 > s32.height)
          this._resizeAtlas(s32.width, e43);
        else if (s32.width < b11) {
          const t34 = Math.min(n13(1.5 * s32.width), b11);
          this._resizeAtlas(t34, s32.height);
        }
      }
      this._elements.set(e42, t32);
    }
  }
  _renderElement(t32) {
    const e42 = t32.commitNewPosition(), s32 = t32.textRenderer;
    this._ctx.clearRect(e42[0] - A10, e42[1] - A10, s32.renderedWidth + 2 * A10, s32.renderedHeight + 2 * A10), s32.render(this._ctx, e42[0], e42[1]);
    const i20 = this._stageObjects.get(s32.key);
    i20 == null ? void 0 : i20.forEach((e43) => y5(e43, t32));
  }
  get running() {
    return this.updating;
  }
  runTask(t32) {
    if (null == this._glTexture)
      return o9;
    for (; this._needsRepack && (this._canRepack || this._atlas.height < b11 && this._atlas.height < b11); ) {
      this._canRepack = this._needsRepack = false;
      const e42 = this._elements;
      this._elements = /* @__PURE__ */ new Map(), e42.forEach((t33) => this._processAddition(t33)), t32.madeProgress();
    }
    if (this._elementsToRender.size > 0) {
      for (const [e42, s32] of this._elementsToRender) {
        if (t32.done)
          break;
        this._renderElement(s32), this._elementsToRender.delete(e42), t32.madeProgress();
      }
      this._glTexture.setData(this._canvas);
    }
    this.updating = this._elementsToRender.size > 0;
  }
  addTextTexture(t32, e42) {
    const s32 = t32.key;
    this._addStageObject(s32, e42);
    let i20 = this._elements.get(s32);
    null == i20 && (i20 = new O12(this._atlas, t32), this._processAddition(i20), this.setDirty()), v6(e42, i20), y5(e42, i20);
  }
  removeTextTexture(t32, e42) {
    const s32 = t32.key;
    if (!this._elements.get(s32))
      return;
    this._removeStageObject(s32, e42);
    const i20 = this._stageObjects.get(s32);
    i20 && 0 !== i20.size || this._elements.delete(s32), 0 === (i20 == null ? void 0 : i20.size) && this._stageObjects.delete(s32), this._canRepack = true;
  }
  setDirty() {
    this._glTexture && (this.updating = true);
  }
  get test() {
    const { _elements: t32, _stageObjects: e42, _atlas: s32 } = this, i20 = this;
    return { elements: t32, stageObjects: e42, atlas: s32, resizeAtlas: (t33, e43) => i20._resizeAtlas(t33, e43), run: (t33) => i20.runTask(t33) };
  }
};
function v6(t32, e42) {
  t32.geometries[0].setAttributeData(e16.SIZE, [e42.textRenderer.displayWidth, e42.textRenderer.displayHeight]), t32.geometryVertexAttributeUpdated(t32.geometries[0], e16.SIZE);
}
function y5(t32, e42) {
  t32.geometries[0].setAttributeData(e16.UV0, e42.uv), t32.geometryVertexAttributeUpdated(t32.geometries[0], e16.UV0, true);
}
e([y({ constructOnly: true })], j12.prototype, "view", void 0), e([y({ type: Boolean })], j12.prototype, "updating", void 0), j12 = e([a3("esri.views.3d.webgl-engine.lib.TextTextureAtlas")], j12);
var A10 = 2;
var R6 = 2;
var O12 = class {
  constructor(t32, e42) {
    this._atlas = t32, this.textRenderer = e42, this._uv = n6(), this._newPosition = [0, 0];
  }
  get uv() {
    if (null == this._xOffset || null == this._yOffset)
      return _4;
    const { renderedWidth: t32, renderedHeight: e42 } = this.textRenderer;
    return s6(this._uv, this._xOffset / this._atlas.width, (this._yOffset + e42) / this._atlas.height, (this._xOffset + t32) / this._atlas.width, this._yOffset / this._atlas.height);
  }
  setNewPosition(t32) {
    this._newPosition[0] = t32.x, this._newPosition[1] = t32.y;
  }
  commitNewPosition() {
    return this._xOffset = this._newPosition[0], this._yOffset = this._newPosition[1], this._newPosition;
  }
  get xOffset() {
    return this._xOffset;
  }
  get yOffset() {
    return this._yOffset;
  }
};
var k6 = class {
  constructor(t32, e42) {
    this.width = t32, this.height = e42, this.cursors = /* @__PURE__ */ new Map(), this.nextY = 0;
  }
  reset() {
    this.cursors.clear(), this.nextY = S12;
  }
};
var E14 = class {
  constructor(t32) {
    this.y = t32, this.x = S12;
  }
};
var S12 = 0;

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolCreationContext.js
var e36 = class {
  constructor(e42, s32) {
    this.scheduler = e42, this.schedule = s32, this.sharedResources = null, this.streamDataRequester = null, this.elevationProvider = null, this.renderer = null, this.stage = null, this.clippingExtent = null, this.renderCoordsHelper = null, this.overlaySR = null, this.layer = null, this.drapeSourceRenderer = null, this.graphicsCoreOwner = null, this.localOriginFactory = null, this.featureExpressionInfoContext = null, this.screenSizePerspectiveEnabled = true, this.slicePlaneEnabled = false, this.physicalBasedRenderingEnabled = false, this.skipHighSymbolLods = false, this.isAsync = false;
  }
};
var s26 = class {
  constructor() {
    this.renderPriority = 0, this.renderPriorityStep = 1, this.ignoreDrivers = false;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DGraphic.js
var x6 = new e4(Array, (e42) => O3(e42, D2), null, 10, 5);
var v7 = u7();
var A11 = class {
  get labelLayers() {
    return this._labelLayers || q;
  }
  get extent() {
    return this._extent;
  }
  get isElevationSource() {
    return this.layers.some((e42) => e42 == null ? void 0 : e42.isElevationSource);
  }
  constructor(e42, t32, i20, r39, s32) {
    this.graphic = e42, this.graphics3DSymbol = t32, this.layers = i20, this._visibleFlags = L4.ALL_LABEL, this.deconflictionPriority = 0, ++t32.referenced, this._featureExpressionFeature = s32 ? s16(s32, e42, r39) : null;
  }
  initialize(e42) {
    this._layer = e42, this._forEachSymbolLayerGraphic((t32) => {
      t32.initialize(e42), t32.setVisibility(this.isVisible());
    });
  }
  destroy() {
    this._forEachSymbolLayerGraphic((e42) => e42.destroy()), this._calloutLayer = null, --this.graphics3DSymbol.referenced, this.graphics3DSymbol = null;
  }
  get destroyed() {
    return null == this.layers;
  }
  clearLabelGraphics() {
    this._forEachLabelGraphic((e42) => e42.destroy()), this._labelLayers = null;
  }
  addLabelGraphic(e42, t32) {
    this._labelLayers || (this._labelLayers = new Array()), this._labelLayers.push(e42), e42.initialize(t32), e42.setVisibility(this.isVisible(A9.LABEL));
  }
  setCalloutGraphic(e42) {
    this._calloutLayer = e42, this._layer && (e42.initialize(this._layer), e42.setVisibility(this.isVisible()));
  }
  get calloutLayer() {
    return this._calloutLayer;
  }
  get isDraped() {
    let e42 = false;
    return this._forEachSymbolLayerGraphic((t32) => {
      "draped" === t32.type && (e42 = true);
    }), e42;
  }
  isVisible(e42 = A9.GRAPHIC, t32) {
    const i20 = t32 ? this._visibleFlags | t32 | A9.LABEL * t32 : this._visibleFlags;
    return e42 === A9.GRAPHIC ? (i20 & L4.ALL_GRAPHIC) === L4.ALL_GRAPHIC : (i20 & L4.ALL_LABEL) === L4.ALL_LABEL;
  }
  setVisibilityFlag(e42, t32, i20) {
    const r39 = this.isVisible(e42);
    i20 ? this._visibleFlags |= e42 * t32 : this._visibleFlags &= ~(e42 * t32);
    const s32 = this.isVisible(e42);
    if (r39 === s32)
      return false;
    if (e42 === A9.LABEL)
      this._forEachLabelGraphic((e43) => e43.setVisibility(s32));
    else {
      this._forEachSymbolLayerGraphic((e44) => e44.setVisibility(s32));
      const e43 = this.isVisible(A9.LABEL);
      this._forEachLabelGraphic((t33) => t33.setVisibility(e43));
    }
    return true;
  }
  getVisibilityFlag(e42, t32) {
    return !!(this._visibleFlags & e42 * t32);
  }
  computeExtent(e42) {
    if (!this._extent) {
      const t32 = this.graphic.geometry;
      if (null == t32)
        return false;
      this._extent = u7(), F5(t32, this._extent);
      const i20 = t32.spatialReference;
      if (!G(i20, e42) && !i10(this._extent, i20, this._extent, e42))
        return this._extent = null, false;
    }
    return true;
  }
  getAsOptimizedGeometry(e42, t32) {
    return this._optimizedGeometry || (this._optimizedGeometry = this._convertGraphicToOptimizedGeometry(this.graphic, e42, t32)), this._optimizedGeometry;
  }
  _convertGraphicToOptimizedGeometry(e42, t32, i20) {
    let r39 = e42.geometry;
    return "mesh" !== r39.type && "extent" !== r39.type || (r39 = j2.fromExtent("mesh" === r39.type ? r39.extent : r39)), ot2(r39, t32, i20);
  }
  get usedMemory() {
    let e42 = t2(this.graphic.attributes);
    return this._forEachSymbolLayerGraphic((t32) => e42 += t32.graphics3DSymbolLayer.usedMemory), e42;
  }
  computeAttachmentOrigin() {
    const e42 = { render: { origin: n2(), num: 0 }, draped: { origin: n9(), num: 0 } };
    for (const t32 of this.layers)
      null != t32 && t32.computeAttachmentOrigin(e42);
    return e42.render.num > 1 && g(e42.render.origin, e42.render.origin, 1 / e42.render.num), e42.draped.num > 1 && l9(e42.draped.origin, e42.draped.origin, 1 / e42.draped.num), e42;
  }
  async getProjectedBoundingBox(e42, i20, r39, s32, a28) {
    return a28 || (a28 = { boundingBox: null, requiresDrapedElevation: false, screenSpaceObjects: [] }), a28.boundingBox ? P2(a28.boundingBox) : a28.boundingBox = P2(), a28.requiresDrapedElevation = false, await a4(this.layers, async (t32) => {
      if (null == t32)
        return;
      const o27 = "draped" === t32.type ? i20 : e42, l31 = x6.acquire(), n28 = await t32.getProjectedBoundingBox(o27, r39, a28.screenSpaceObjects, s32, l31);
      isFinite(n28[2]) && isFinite(n28[5]) || (a28.requiresDrapedElevation = true), n28 && o3(a28.boundingBox, l31), x6.release(l31);
    }), l3(a28.boundingBox) || x2(S3(a28.boundingBox, v7)) ? a28 : null;
  }
  needsElevationUpdates() {
    var _a;
    for (const e42 of this.layers)
      if (null != e42 && ("object3d" === e42.type || "lod-instance" === e42.type) && e42.needsElevationUpdates)
        return true;
    return ((_a = this._labelLayers) == null ? void 0 : _a.some((e42) => (e42 == null ? void 0 : e42.needsElevationUpdates) ?? false)) ?? false;
  }
  alignWithElevation(e42, t32, i20) {
    this._forEachRenderedGraphic((r39) => {
      "object3d" !== r39.type && "lod-instance" !== r39.type || r39.alignWithElevation(e42, t32, this._featureExpressionFeature, i20);
    });
  }
  alignWithAbsoluteElevation(e42, t32, i20) {
    this._forEachRenderedGraphic((r39) => {
      "object3d" === r39.type && r39.alignWithAbsoluteElevation(e42, t32, i20);
    });
  }
  addObjectStateSet(e42, t32) {
    this._forEachSymbolLayerGraphic((i20) => i20.addObjectState(e42, t32));
  }
  removeObjectState(e42) {
    this._forEachSymbolLayerGraphic((t32) => t32.removeObjectState(e42));
  }
  _forEachGraphicList(e42, t32) {
    e42 == null ? void 0 : e42.forEach((e43) => e43 && t32(e43));
  }
  _forEachSymbolLayerGraphic(e42) {
    this._forEachGraphicList(this.layers, e42), this._calloutLayer && e42(this._calloutLayer);
  }
  _forEachLabelGraphic(e42) {
    this._forEachGraphicList(this._labelLayers, e42);
  }
  _forEachRenderedGraphic(e42) {
    this._forEachSymbolLayerGraphic(e42), this._forEachLabelGraphic(e42);
  }
  get test() {
    const e42 = this;
    return { addLabelLayer: (t32) => {
      e42._labelLayers || (e42._labelLayers = new Array()), e42._labelLayers.push(t32);
    } };
  }
};

// node_modules/@arcgis/core/views/3d/support/renderInfoUtils/polygon.js
function p17(o27, n28, r39, p23) {
  const c32 = g4(o27.rings, !!o27.hasZ && "on-the-ground" !== p23.mode, u11.CCW_IS_HOLE, o27.spatialReference), h25 = t9(c32.position.length), a28 = u16(c32.position, o27.spatialReference, 0, h25, 0, c32.position, 0, c32.position.length / 3, n28, r39, p23), g15 = null != a28;
  return new f15(c32.position, h25, u22(c32.polygons, c32.position, h25), l23(c32.outlines, c32.position, h25), g15, a28);
}
function c24(t32, n28) {
  const e42 = g4(t32.rings, false, u11.CCW_IS_HOLE), p23 = n3(e42.position, t32.spatialReference, 0, e42.position, n28, 0, e42.position.length / 3);
  for (let o27 = 2; o27 < e42.position.length; o27 += 3)
    e42.position[o27] = te;
  return { position: e42.position, polygons: u22(e42.polygons, e42.position), outlines: l23(e42.outlines, e42.position), projectionSuccess: p23 };
}
function l23(o27, t32, s32 = null) {
  return o27.filter(({ count: o28 }) => o28 > 1).map(({ index: o28, count: i20 }) => {
    const e42 = 3 * o28, r39 = 3 * i20;
    return null != s32 ? new a23(o28, i20, a9(t32, e42, r39), a9(s32, e42, r39)) : new h17(o28, i20, a9(t32, e42, r39));
  });
}
function u22(o27, t32, s32 = null) {
  const i20 = new Array();
  for (const { index: e42, count: r39, holeIndices: p23, pathLengths: c32 } of o27) {
    if (r39 <= 1)
      continue;
    const o28 = 3 * e42, l31 = 3 * r39, u32 = p23.map((o29) => o29 - e42), h25 = null != s32 ? new g9(e42, r39, a9(t32, 3 * e42, 3 * r39), a9(s32, o28, l31), u32, c32) : new m16(e42, r39, a9(t32, 3 * e42, 3 * r39), u32, c32);
    i20.push(h25);
  }
  return i20;
}
var h17 = class {
  constructor(o27, t32, n28) {
    this.index = o27, this.count = t32, this.position = n28;
  }
};
var a23 = class extends h17 {
  constructor(o27, t32, n28, s32) {
    super(o27, t32, n28), this.mapPositions = s32;
  }
};
var g9 = class extends a23 {
  constructor(o27, t32, n28, s32, i20, e42) {
    super(o27, t32, n28, s32), this.holeIndices = i20, this.pathLengths = e42;
  }
};
var m16 = class extends h17 {
  constructor(o27, t32, n28, s32, i20) {
    super(o27, t32, n28), this.holeIndices = s32, this.pathLengths = i20;
  }
};
var f15 = class {
  constructor(o27, t32, n28, s32, i20, e42) {
    this.position = o27, this.mapPositions = t32, this.polygons = n28, this.outlines = s32, this.projectionSuccess = i20, this.sampledElevation = e42;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DExtrudeSymbolLayer.js
var tt = ["polygon", "extent"];
var et = class extends h13 {
  constructor(t32, e42, r39, s32) {
    super(t32, e42, r39, s32), this.ensureDrapedStatus(false);
  }
  async doLoad() {
    var _a, _b;
    if (!this._drivenProperties.size) {
      const e43 = I6(this._getSymbolSize());
      if (e43)
        throw new s2("graphics3dextrudesymbollayer:invalid-size", e43);
    }
    const e42 = (_b = (_a = this.symbolLayer) == null ? void 0 : _a.material) == null ? void 0 : _b.color, r39 = this._getCombinedOpacityAndColor(e42), s32 = e6(r39), o27 = r39[3], n28 = o27 < 1 || this.needsDrivenTransparentPass, i20 = { usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true, diffuse: s32, ambient: s32, opacity: o27, transparent: n28, cullFace: n28 ? e21.None : e21.Back, hasVertexColors: true, hasSlicePlane: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows, offsetTransparentBackfaces: true, normalType: a7.Compressed };
    this._materials[wt.Main] = new E7(i20), this._materials[wt.Bottom] = new E7({ ...i20, cullFace: e21.Back }), this._context.stage.addMany(this._materials);
  }
  destroy() {
    super.destroy(), this._context.stage.removeMany(this._materials), this._materials.length = 0;
  }
  createGraphics3DGraphic(t32) {
    const e42 = t32.graphic;
    if (!this._validateGeometry(e42.geometry, tt, this.symbolLayer.type))
      return null;
    const r39 = this._getVertexOpacityAndColor(t32.renderingInfo, 255), s32 = this.setGraphicElevationContext(e42);
    return this._createAs3DShape(e42, t32.renderingInfo, r39, s32, e42.uid);
  }
  layerOpacityChanged(t32, e42) {
    var _a, _b, _c, _d;
    const r39 = (_b = (_a = this.symbolLayer) == null ? void 0 : _a.material) == null ? void 0 : _b.color, s32 = this._getCombinedOpacity(r39), o27 = s32 < 1 || this.needsDrivenTransparentPass;
    (_c = this._materials[wt.Main]) == null ? void 0 : _c.setParameters({ opacity: s32, transparent: o27 }), (_d = this._materials[wt.Bottom]) == null ? void 0 : _d.setParameters({ opacity: s32, transparent: o27 });
    const n28 = this._getLayerOpacity();
    t32.forEach((t33) => {
      const r40 = e42(t33);
      null != r40 && r40.layerOpacityChanged(n28, this._context.isAsync);
    });
  }
  layerElevationInfoChanged(t32, e42) {
    return this.updateGraphics3DGraphicElevationInfo(t32, e42, g5);
  }
  slicePlaneEnabledChanged(t32, e42) {
    var _a, _b;
    return (_a = this._materials[wt.Main]) == null ? void 0 : _a.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), (_b = this._materials[wt.Bottom]) == null ? void 0 : _b.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), t32.forEach((t33) => {
      const r39 = e42(t33);
      null != r39 && r39.slicePlaneEnabledChanged(this._context.slicePlaneEnabled, this._context.isAsync);
    }), true;
  }
  physicalBasedRenderingChanged() {
    var _a, _b;
    const t32 = { usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true };
    return (_a = this._materials[wt.Main]) == null ? void 0 : _a.setParameters(t32), (_b = this._materials[wt.Bottom]) == null ? void 0 : _b.setParameters(t32), true;
  }
  _getExtrusionSize(t32) {
    let e42;
    return e42 = t32.size && this._drivenProperties.size ? a18(t32.size, 2) ?? 0 : this._getSymbolSize(), e42 /= this._context.renderCoordsHelper.unitInMeters, e42;
  }
  applyRendererDiff(t32, e42) {
    return this._drivenPropertiesChanged(e42) ? e33.RecreateSymbol : e33.RecreateGraphics;
  }
  async queryForSnapping(t32, s32, o27, n28) {
    const i20 = this._getExtrusionSize(o27) * this._context.renderCoordsHelper.unitInMeters / L2(s32), { objectId: a28, target: l31 } = t32, c32 = a(l31);
    switch (c32.z = (c32.z ?? 0) + i20, t32.type) {
      case "edge": {
        const { start: r39, end: s33 } = t32, o28 = a(r39), n29 = a(s33);
        return o28.z = (o28.z ?? 0) + i20, n29.z = (n29.z ?? 0) + i20, [e23(a28, c32, 1 / 0, o28, n29)];
      }
      case "vertex":
        return [t12(a28, c32, 1 / 0), e23(a28, l31, 1 / 0, l31, c32)];
      default:
        return [];
    }
  }
  _getSymbolSize() {
    return this.symbolLayer.size ?? 1;
  }
  _createAs3DShape(t32, e42, r39, a28, c32) {
    const m22 = A6(t32.geometry);
    if (null == m22)
      return null;
    if (0 === m22.rings.length || !m22.rings.some((t33) => t33.length > 0))
      return this._logGeometryValidationWarnings(m22.rings, "rings", "ExtrudeSymbol3DLayer"), null;
    const p23 = p17(m22, this._context.elevationProvider, this._context.renderCoordsHelper, a28);
    this._logGeometryCreationWarnings(p23, m22.rings, "rings", "ExtrudeSymbol3DLayer");
    const h25 = b8(m22);
    if (null == h25)
      return null;
    const g15 = new Array(), d20 = new Array(), u32 = i(), f23 = e12(), M11 = n2(), w13 = this._context.renderCoordsHelper.viewingMode === l6.Global;
    w13 || this._context.renderCoordsHelper.worldUpAtPosition(null, M11), R(m22.spatialReference, [h25.x, h25.y, 0], f23, this._context.renderCoordsHelper.spatialReference);
    const C6 = e12();
    h4(C6, f23);
    const I15 = e14();
    j5(I15, C6);
    const { polygons: L8, mapPositions: B6, position: D11 } = p23, T9 = /* @__PURE__ */ new Map(), N7 = this._materials[wt.Main];
    for (const o27 of L8) {
      const t33 = o27.count;
      if (this._context.clippingExtent && (P2(u32), c4(u32, o27.mapPositions), !V(u32, this._context.clippingExtent)))
        continue;
      const n28 = i4(o27.mapPositions, o27.holeIndices, 3);
      if (0 === n28.length)
        continue;
      const i20 = n28.length, a29 = 6 * t33, l31 = i5(a29 + i20), m23 = i5(i20), p24 = t9(3 * a29), h26 = t9(3 * a29), y10 = t9(3 * a29), b18 = t9(a29);
      st(D11, B6, n28, o27, p24, y10, h26, b18, l31, m23, this._getExtrusionSize(e42), M11, w13), r9(p24, p24, C6);
      const _16 = this._context.stage.renderView.getObjectAndLayerIdColor({ graphicUid: c32, layerUid: this._context.layer.uid }), I16 = new Ct(p24, y10, e24(h26), b18), v13 = rt2(N7, l31, l31.length - m23.length, I16, r39, _16), A16 = t33, L9 = t33, z7 = 2 * o27.count, R11 = new It(A16, L9, z7, i20 / 3);
      ft2(v13, R11, f23), T9.set(v13, R11), g15.push(v13, rt2(this._materials[wt.Bottom], m23, 0, I16, r39, _16)), d20.push(I16.heights);
    }
    if (0 === g15.length)
      return null;
    const V12 = new O9({ geometries: g15, layerUid: this._context.layer.uid, graphicUid: c32, isElevationSource: true });
    V12.transformation = f23;
    const k14 = a8(this.symbolLayer, { opacity: this._getLayerOpacity() }), H6 = null != k14 ? { baseMaterial: this._materials[wt.Main], edgeMaterials: [k14], properties: { mergeGeometries: true, hasSlicePlane: this._context.slicePlaneEnabled } } : null, W9 = new p13(this, V12, g15, null, null, (t33, e43, r40, s32, o27) => ut(t33, e43, r40, s32, o27, d20, T9), a28, H6);
    return W9.alignedSampledElevation = p23.sampledElevation, W9.needsElevationUpdates = g5(a28.mode), W9;
  }
};
function rt2(t32, e42, r39, s32, o27, n28) {
  const i20 = A5(e42.length), a28 = [[e16.POSITION, new t8(s32.positions, e42, 3, true)], [e16.NORMALCOMPRESSED, new t8(s32.normals, e42, 2, true)], [e16.COLOR, new t8(o27, i20, 4, true)]];
  return new I2(t32, a28, s32.elevation, e20.Mesh, n28, r39);
}
function st(t32, e42, r39, s32, o27, n28, i20, a28, l31, c32, m22, p23, h25) {
  {
    const g15 = r39.length / 3, d20 = 2 * s32.count;
    ot4(t32, e42, s32.index, s32.count, r39, 0, g15, o27, n28, i20, a28, l31, c32, d20, m22, p23, h25);
  }
  {
    let t33 = 0, e43 = 2 * s32.count, r40 = 0;
    const c33 = s32.pathLengths[0];
    at2(o27, n28, a28, i20, t33, c33, s32.count, e43, l31, r40, m22), e43 += 4 * c33, r40 += 2 * c33, t33 += c33;
    for (let p24 = 1; p24 < s32.pathLengths.length; ++p24) {
      const c34 = s32.pathLengths[p24];
      at2(o27, n28, a28, i20, t33, c34, s32.count, e43, l31, r40, m22), e43 += 4 * c34, r40 += 2 * c34, t33 += c34;
    }
  }
}
function ot4(t32, e42, r39, s32, o27, n28, i20, a28, l31, p23, h25, g15, d20, u32, f23, y10, b18) {
  r4(bt, y10);
  {
    const o28 = f23 > 0 ? 1 : -1;
    let n29 = 3 * r39, i21 = 0, c32 = 3 * i21, g16 = s32, d21 = 3 * g16;
    for (let r40 = 0; r40 < s32; ++r40) {
      const r41 = t32[n29], s33 = t32[n29 + 1], u33 = t32[n29 + 2];
      b18 && (bt[0] = r41, bt[1] = s33, bt[2] = u33, z(bt, bt)), a28[c32 + 0] = r41, a28[c32 + 1] = s33, a28[c32 + 2] = u33;
      const y11 = e42[n29 + 0], _16 = e42[n29 + 1], x12 = e42[n29 + 2];
      l31[c32 + 0] = y11, l31[c32 + 1] = _16, l31[c32 + 2] = x12, p23[c32 + 0] = -o28 * bt[0], p23[c32 + 1] = -o28 * bt[1], p23[c32 + 2] = -o28 * bt[2], h25[i21] = 0, a28[d21 + 0] = r41 + f23 * bt[0], a28[d21 + 1] = s33 + f23 * bt[1], a28[d21 + 2] = u33 + f23 * bt[2], l31[d21 + 0] = y11, l31[d21 + 1] = _16, l31[d21 + 2] = x12, h25[g16] = f23, c32 += 3, d21 += 3, n29 += 3, i21 += 1, g16 += 1;
    }
  }
  {
    let t33 = 3 * n28, e43 = 0, r40 = 3 * u32;
    const a29 = f23 < 0 ? St : xt, l32 = f23 < 0 ? xt : St;
    for (let n29 = 0; n29 < i20; ++n29)
      d20[e43] = o27[t33 + a29[0]], d20[e43 + 1] = o27[t33 + a29[1]], d20[e43 + 2] = o27[t33 + a29[2]], g15[r40] = o27[t33 + l32[0]] + s32, g15[r40 + 1] = o27[t33 + l32[1]] + s32, g15[r40 + 2] = o27[t33 + l32[2]] + s32, e43 += 3, r40 += 3, t33 += 3;
  }
}
function nt(t32, e42, r39, s32, o27, n28, i20) {
  s32[n28] = s32[i20], i20 *= 3, t32[n28 *= 3] = t32[i20], t32[n28 + 1] = t32[i20 + 1], t32[n28 + 2] = t32[i20 + 2], e42[n28] = e42[i20], e42[n28 + 1] = e42[i20 + 1], e42[n28 + 2] = e42[i20 + 2], r39[n28] = o27[0], r39[n28 + 1] = o27[1], r39[n28 + 2] = o27[2];
}
var it2 = n2();
function at2(t32, e42, r39, s32, o27, n28, i20, a28, l31, c32, m22) {
  let p23 = o27, h25 = o27 + 1, g15 = o27 + i20, d20 = o27 + i20 + 1, u32 = a28, f23 = a28 + 1, y10 = a28 + 2 * n28, b18 = a28 + 2 * n28 + 1;
  m22 < 0 && (p23 = o27 + i20 + 1, d20 = o27);
  let _16 = 3 * c32;
  for (let x12 = 0; x12 < n28; ++x12)
    x12 === n28 - 1 && (h25 = o27, m22 > 0 ? d20 = o27 + i20 : p23 = o27 + i20), gt(t32, p23, h25, g15, it2), nt(t32, e42, s32, r39, it2, u32, p23), nt(t32, e42, s32, r39, it2, f23, h25), nt(t32, e42, s32, r39, it2, y10, g15), nt(t32, e42, s32, r39, it2, b18, d20), l31[_16] = u32, l31[_16 + 1] = y10, l31[_16 + 2] = b18, l31[_16 + 3] = u32, l31[_16 + 4] = b18, l31[_16 + 5] = f23, _16 += 6, p23++, h25++, g15++, d20++, u32 += 2, f23 += 2, y10 += 2, b18 += 2;
}
var lt = n2();
var ct = n2();
var mt = n2();
var pt = n2();
var ht2 = n2();
function gt(t32, e42, r39, s32, o27) {
  e42 *= 3, r39 *= 3, s32 *= 3, o2(lt, t32[e42++], t32[e42++], t32[e42++]), o2(ct, t32[r39++], t32[r39++], t32[r39++]), o2(mt, t32[s32++], t32[s32++], t32[s32++]), e8(pt, ct, lt), e8(ht2, mt, lt), _3(o27, ht2, pt), z(o27, o27);
}
var dt = n2();
function ut(t32, e42, r39, s32, o27, n28, i20) {
  const c32 = t32.stageObject, m22 = c32.geometries, h25 = m22.length, g15 = "absolute-height" !== e42.mode;
  let u32 = 0;
  const f23 = c32.transformation, y10 = e11(e12(), f23);
  for (let a28 = 0; a28 < h25; a28 += 2) {
    const t33 = m22[a28];
    if (!e31(t33))
      continue;
    const e43 = t33.getMutableAttribute(e16.POSITION).data, l31 = n28[a28 / 2], h26 = new r18(t33.mapPositions), b18 = e43.length / 3;
    let _16 = false, x12 = 0;
    {
      let t34 = 0;
      for (let n29 = 0; n29 < b18; n29++) {
        dt[0] = e43[t34], dt[1] = e43[t34 + 1], dt[2] = e43[t34 + 2], s32(h26, _t), g15 && (x12 += _t.sampledElevation), t19.TESTS_DISABLE_OPTIMIZATIONS ? (o2(yt, h26.array[h26.offset], h26.array[h26.offset + 1], _t.z + l31[t34 / 3]), null != r39 && o27.toRenderCoords(yt, r39, yt), O2(yt, yt, y10)) : (o2(yt, e43[t34], e43[t34 + 1], e43[t34 + 2]), O2(yt, yt, f23), o27.setAltitude(yt, _t.z + l31[t34 / 3]), O2(yt, yt, y10)), e43[t34] = yt[0], e43[t34 + 1] = yt[1], e43[t34 + 2] = yt[2];
        const n30 = jt / o27.unitInMeters;
        (Math.abs(dt[0] - e43[t34]) >= n30 || Math.abs(dt[1] - e43[t34 + 1]) >= n30 || Math.abs(dt[2] - e43[t34 + 2]) >= n30) && (_16 = true), h26.offset += 3, t34 += 3;
      }
    }
    if (_16) {
      const e44 = i20.get(t33);
      e44 && ft2(t33, e44, f23), c32.geometryVertexAttributeUpdated(m22[a28], e16.NORMALCOMPRESSED), t33.invalidateBoundingInfo(), c32.geometryVertexAttributeUpdated(m22[a28], e16.POSITION), m22[a28 + 1].invalidateBoundingInfo(), c32.geometryVertexAttributeUpdated(m22[a28 + 1], e16.POSITION);
    }
    u32 += x12 / b18;
  }
  return u32 / h25;
}
function ft2(t32, e42, r39) {
  const s32 = t32.getMutableAttribute(e16.POSITION), o27 = t32.getMutableAttribute(e16.NORMALCOMPRESSED).data, { topVertexStart: n28, topVertexCount: i20, topFaceStart: a28, topFaceCount: l31 } = e42, c32 = s32.data, h25 = i20, f23 = t32.attributes.get(e16.POSITION).indices, y10 = a28 + l31, b18 = n28 + i20, _16 = t9(3 * h25);
  for (let m22 = 0; m22 < h25; ++m22) {
    const t33 = 3 * m22;
    _16[t33 + 0] = 0, _16[t33 + 1] = 0, _16[t33 + 2] = 0;
  }
  const x12 = Pt, S21 = Et, j19 = Mt, E21 = Ot2, M11 = bt;
  for (let P12 = a28; P12 < y10; ++P12) {
    const t33 = 3 * P12;
    for (let e43 = 0; e43 < 3; ++e43) {
      const s33 = f23[t33 + e43];
      E21[e43] = s33;
      const o28 = 3 * s33;
      o2(yt, c32[o28 + 0], c32[o28 + 1], c32[o28 + 2]), O2(x12[e43], yt, r39);
    }
    K(S21, x12[1], x12[0]), K(j19, x12[2], x12[0]), _3(M11, S21, j19), z(M11, M11);
    for (let e43 = 0; e43 < 3; ++e43) {
      const t34 = 3 * (E21[e43] - n28);
      _16[t34 + 0] += M11[0], _16[t34 + 1] += M11[1], _16[t34 + 2] += M11[2];
    }
  }
  for (let m22 = n28; m22 < b18; ++m22) {
    const t33 = 3 * (m22 - n28), e43 = _16[t33 + 0], r40 = _16[t33 + 1], s33 = _16[t33 + 2], i21 = Math.sqrt(e43 * e43 + r40 * r40 + s33 * s33);
    s14(o27, m22, e43 / i21, r40 / i21, s33 / i21);
  }
}
var yt = n2();
var bt = n2();
var _t = new R4();
var xt = [0, 2, 1];
var St = [0, 1, 2];
var jt = 0.01;
var Pt = [n2(), n2(), n2()];
var Et = n2();
var Mt = n2();
var Ot2 = [0, 0, 0];
var wt;
!function(t32) {
  t32[t32.Main = 0] = "Main", t32[t32.Bottom = 1] = "Bottom";
}(wt || (wt = {}));
var Ct = class {
  constructor(t32, e42, r39, s32) {
    this.positions = t32, this.elevation = e42, this.normals = r39, this.heights = s32;
  }
};
var It = class {
  constructor(t32, e42, r39, s32) {
    this.topVertexStart = t32, this.topVertexCount = e42, this.topFaceStart = r39, this.topFaceCount = s32;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DDrapedGraphicLayer.js
var l24 = class {
  constructor(e42, t32, r39, i20) {
    this.graphics3DSymbolLayer = e42, this.renderGeometries = t32, this.boundingBox = r39, this._drapeSourceRenderer = i20, this.type = "draped", this.stage = null, this._visible = false, this._addedToStage = false, this.isElevationSource = false;
  }
  initialize(e42) {
    this.stage = e42.stage;
  }
  setVisibility(e42) {
    if (null != this.stage && this._visible !== e42) {
      if (this._visible = e42, e42 && !this._addedToStage)
        return this._addedToStage = true, void this._drapeSourceRenderer.addGeometries(this.renderGeometries, E8.ADD);
      if (e42 || this._addedToStage) {
        for (const e43 of this.renderGeometries)
          e43.visible = this._visible;
        this._drapeSourceRenderer.modifyGeometries(this.renderGeometries, I4.VISIBILITY);
      }
    }
  }
  destroy() {
    this.stage && this._addedToStage && this._drapeSourceRenderer.removeGeometries(this.renderGeometries, E8.REMOVE), this._addedToStage = false, this._visible = false, this.stage = null;
  }
  getCenterObjectSpace(r39 = n2()) {
    return o2(r39, 0, 0, 0);
  }
  getBoundingBoxObjectSpace(e42 = i()) {
    return P2(e42);
  }
  addObjectState(e42, t32) {
    e42 === t11.Highlight && (this.renderGeometries.forEach((e43) => {
      const r39 = e43.geometry.addHighlight();
      t32.addRenderGeometry(e43, r39, this);
    }), this._addedToStage && this._drapeSourceRenderer.modifyGeometries(this.renderGeometries, I4.HIGHLIGHT));
  }
  removeObjectState(e42) {
    this.renderGeometries.forEach((t32) => {
      e42.removeRenderGeometry(t32);
    });
  }
  removeRenderGeometryObjectState(e42, t32) {
    e42.geometry.removeHighlight(t32), this._addedToStage && this._drapeSourceRenderer.modifyGeometries(this.renderGeometries, I4.HIGHLIGHT);
  }
  computeAttachmentOrigin(e42) {
    for (const t32 of this.renderGeometries)
      t32.geometry.computeAttachmentOrigin(f16) && (e42.draped.origin[0] += f16[0], e42.draped.origin[1] += f16[1], e42.draped.num++);
  }
  async getProjectedBoundingBox(e42, t32, r39, d20, n28) {
    P2(n28);
    for (let i20 = 0; i20 < this.renderGeometries.length; i20++) {
      const t33 = this.renderGeometries[i20];
      this._getRenderGeometryProjectedBoundingRect(t33, e42, u23, r39), f3(n28, u23);
    }
    if (t32) {
      let e43;
      E(n28, f16);
      const r40 = k5(n28, t32.service.spatialReference, t32);
      try {
        e43 = await t32.service.queryElevation(f16[0], f16[1], d20, r40, "ground");
      } catch (a28) {
      }
      null != e43 && (n28[2] = Math.min(n28[2], e43), n28[5] = Math.max(n28[5], e43));
    }
    return n28;
  }
  _getRenderGeometryProjectedBoundingRect(e42, t32, r39, i20) {
    if (this.boundingBox)
      O3(p18, this.boundingBox);
    else {
      const t33 = e42.boundingSphere, r40 = t33[3];
      p18[0] = t33[0] - r40, p18[1] = t33[1] - r40, p18[2] = t33[2] - r40, p18[3] = t33[0] + r40, p18[4] = t33[1] + r40, p18[5] = t33[2] + r40;
    }
    return t32(p18, 0, 2), this.calculateRelativeScreenBounds && i20.push({ location: E(p18), screenSpaceBoundingRect: this.calculateRelativeScreenBounds() }), S3(p18, r39);
  }
};
var u23 = u7();
var p18 = i();
var f16 = n2();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DIconSymbolLayer.js
var re = r3(0, 0, 1);
var ie = 16;
var se = 1.5;
var oe = o16;
var ae = [oe / 2, oe / 2, 1 - oe / 2, 1 - oe / 2];
var ne = [e30 * oe, e30 * oe];
var le = class _le extends h13 {
  getCachedSize() {
    return { size: this._getIconSize() };
  }
  constructor(e42, t32, r39, i20) {
    super(e42, t32, r39, i20), this._cimSymbolMaterials = /* @__PURE__ */ new Map(), this._cimSymbolTextures = /* @__PURE__ */ new Map(), this._cimMaterialParametersInfo = null, this._size = null, this._symbolTextureRatio = 1, this._outlineSize = 0, this._patchTask = null, this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: true };
  }
  async doLoad(e42) {
    this._validateOrThrow();
    const t32 = this._prepareMaterialParameters(), r39 = this._getPrimitive();
    if (null != r39)
      this._prepareResourcesPrimitive(t32, r39);
    else {
      const r40 = p9(this.symbolLayer), i20 = me(r40);
      null != i20 ? await this._prepareResourcesCIM(t32, JSON.parse(i20), e42) : await this._prepareResourcesHref(t32, r40, e42);
    }
  }
  _validateOrThrow() {
    if (this._drivenProperties.size)
      return;
    const e42 = I6(this._getIconSize());
    if (e42)
      throw new s2("graphics3diconsymbollayer:invalid-size", e42);
  }
  _getIconSize() {
    const e42 = this.symbolLayer, t32 = Math.round(null != e42.size ? u8(e42.size) : ie);
    return this._drivenProperties.size ? Math.max(t32, 64) : t32;
  }
  _generateTextureCIM(e42) {
    let t32 = this._cimData;
    if (t32 && t32.symbol || this.logger.error("Can't create texture, CIM data is undefined"), t32.primitiveOverrides) {
      t32 = a(t32);
      const r40 = t32.primitiveOverrides;
      f5.evaluateOverrides(r40, e42, this._arcadeInfo.geometryType, null, null), f5.applyOverrides(t32.symbol, r40);
    }
    const r39 = c(JSON.stringify(t32));
    let i20 = this._cimSymbolTextures.get(r39);
    if (i20)
      return i20;
    const o27 = this._context.sharedResources.cimSymbolRasterizer, a28 = this._context.renderer && "dictionary" === this._context.renderer.type ? this._context.renderer.fieldMap : null;
    a28 && f5.applyDictionaryTextOverrides(t32.symbol, e42, a28, null);
    const n28 = null != this._cimScaleFactorOrFunction ? n7(this._cimScaleFactorOrFunction, e42) : 1;
    1 !== n28 && t32.symbol && l11(t32.symbol, n28, true);
    const l31 = K2.getEnvelope(t32, null, o27.resourceManager);
    if (l31 && l31.width && l31.height) {
      const e43 = l31.x + l31.width / 2, r40 = l31.y + l31.height / 2, s32 = o27.rasterize({ type: "cim", data: t32 }, l31.width, l31.height, e43, r40, 1, "esriGeometryPoint"), a29 = new p4({ x: -l31.x / l31.width - 0.5, y: (l31.height + l31.y) / l31.height - 0.5 });
      this._cimMaterialParametersInfo.anchorPosition = ue("relative", a29), i20 = new N(s32, { width: (s32 == null ? void 0 : s32.width) ?? 1, height: (s32 == null ? void 0 : s32.height) ?? 1 });
    } else
      i20 = new N(new ImageData(1, 1), { width: 1, height: 1 });
    return this._cimSymbolTextures.set(r39, i20), this._context.stage.add(i20), i20;
  }
  _prepareMaterialParameters() {
    const e42 = { anchorPosition: ue(this.symbolLayer.anchor, this.symbolLayer.anchorPosition) }, t32 = this.symbol;
    if (ce(t32)) {
      const { screenLength: r39, minWorldLength: i20, maxWorldLength: s32 } = t32.verticalOffset;
      e42.verticalOffset = { screenLength: u8(r39), minWorldLength: i20 || 0, maxWorldLength: null != s32 ? s32 : 1 / 0 };
    }
    return this._context.screenSizePerspectiveEnabled && (e42.screenSizePerspective = this._context.sharedResources.screenSizePerspectiveSettings), e42.occlusionTest = true, e42.hasSlicePlane = this._context.slicePlaneEnabled, e42;
  }
  _prepareResourcesPrimitive(e42, t32) {
    const r39 = this._getOutlineSize();
    if (he(t32) && 0 === r39)
      throw new Error("Nothing to render");
    if (this._outlineSize = r39, e42.color = this._getFillColor(), e42.outlineColor = this._getOutlineColor(), e42.outlineSize = this._outlineSize, null != this._context.sharedResources.textures) {
      const r40 = this._context.sharedResources.textures.fromData(`${t32}-icon`, () => u17(t32));
      this._textureHandle = r40, e42.textureId = r40.texture.id;
    }
    e42.textureIsSignedDistanceField = true, e42.sampleSignedDistanceFieldTexelCenter = a12(t32), e42.distanceFieldBoundingBox = ae;
    const i20 = this._getIconSize();
    this._size = [i20, i20], this._symbolTextureRatio = 1 / oe, this._createMaterialAndAddToStage(e42, this._context.stage);
  }
  async _prepareResourcesHref(e42, r39, s32) {
    this._outlineSize = this._getOutlineSize(), e42.color = this._getFillColor(), e42.outlineColor = this._getOutlineColor(), e42.outlineSize = this._outlineSize, e42.textureIsSignedDistanceField = false;
    const o27 = this._getIconSize(), a28 = o27 * this._context.graphicsCoreOwner.view.state.rasterPixelRatio;
    if (null != this._context.sharedResources.textures) {
      const l31 = await _(this._context.sharedResources.textures.fromUrl(r39, a28, { signal: s32 }));
      if (false === l31.ok) {
        a2(l31.error);
        throw new s2("graphics3diconsymbollayer:request-failed", `Failed to load (Request for icon resource failed: ${r39})`);
      }
      this._textureHandle = l31.value;
      const c32 = l31.value.texture;
      this._size = de(c32, o27), e42.textureId = c32.id;
    }
    this._createMaterialAndAddToStage(e42, this._context.stage);
  }
  async _prepareResourcesCIM(e42, t32, r39) {
    if (this._cimData = t32, !this._context.sharedResources.cimSymbolRasterizer) {
      const e43 = (await import("./CIMSymbolRasterizer-QBPIG7Y2.js")).CIMSymbolRasterizer;
      s3(r39), this._context.sharedResources.cimSymbolRasterizer || (this._context.sharedResources.cimSymbolRasterizer = new e43(this._context.renderCoordsHelper.spatialReference));
    }
    const i20 = this._context.sharedResources.cimSymbolRasterizer, s32 = [], o27 = t32, a28 = o27 == null ? void 0 : o27.symbol;
    K2.fetchResources(a28, i20.resourceManager, s32, r39), K2.fetchFonts(a28, i20.resourceManager, s32);
    const n28 = this._context.layer.fields ? this._context.layer.fields.map((e43) => e43.toJSON()) : [], c32 = this._context.renderCoordsHelper.spatialReference;
    if (this._arcadeInfo = { spatialReference: c32, fields: n28, geometryType: "esriGeometryPoint" }, (o27 == null ? void 0 : o27.primitiveOverrides) && s32.push(f5.createRenderExpressions(o27.primitiveOverrides, this._arcadeInfo)), s32.length > 0 && (await Promise.all(s32), s3(r39)), this._context.renderer && "dictionary" === this._context.renderer.type && this._context.renderer.scaleExpression) {
      const e43 = this._context.renderer;
      if (e43.scaleExpression) {
        const t33 = e43.scaleExpression, r40 = await o14(t33, this._context.layer.spatialReference, n28);
        this._cimScaleFactorOrFunction = (e44, t34, i21) => {
          const s33 = s8(r40, e44, { $view: i21 }, "esriGeometryPoint", t34);
          return null !== s33 ? s33 : 1;
        };
      }
    }
    s3(r39), this._cimMaterialParametersInfo = e42, this._cimMaterialParametersInfo.color = this._getFillColor(), this._cimMaterialParametersInfo.outlineColor = [0, 0, 0, 0], this._cimMaterialParametersInfo.outlineSize = 0, this._cimMaterialParametersInfo.textureIsSignedDistanceField = false;
  }
  _getPrimitive() {
    return this.symbolLayer.resource && this.symbolLayer.resource.href ? null : this.symbolLayer.resource && this.symbolLayer.resource.primitive || j3;
  }
  _getOutlineSize() {
    var _a;
    let e42 = 0;
    const t32 = this.symbolLayer;
    if (null != ((_a = t32.outline) == null ? void 0 : _a.size))
      return Math.max(u8(t32.outline.size), 0);
    return e42 = he(this._getPrimitive()) ? se : 0, Math.max(e42, 0);
  }
  _getOutlineColor() {
    var _a;
    const t32 = this._getLayerOpacity(), r39 = this.symbolLayer, i20 = (_a = r39 == null ? void 0 : r39.outline) == null ? void 0 : _a.color;
    if (null != i20) {
      const r40 = u9.toUnitRGB(i20), s32 = i20.a * t32;
      return [r40[0], r40[1], r40[2], s32];
    }
    return [0, 0, 0, 0];
  }
  _getFillColor() {
    var _a, _b;
    if (he(this._getPrimitive()))
      return t29;
    const e42 = null == this._getPrimitive(), t32 = (_b = (_a = this.symbolLayer) == null ? void 0 : _a.material) == null ? void 0 : _b.color;
    return this._getCombinedOpacityAndColor(t32, { hasIntrinsicColor: e42 });
  }
  _createMaterialAndAddToStage(e42, t32) {
    if (this._cimData) {
      this._fastUpdates = null;
      let r39 = e42.textureId ? this._cimSymbolMaterials.get(e42.textureId) : null;
      return r39 || (r39 = new Q2(e42), this._cimSymbolMaterials.set(e42.textureId ?? 0, r39), t32.add(r39)), r39;
    }
    return this._fastUpdates = O8(this._context.renderer, this._fastVisualVariableConvertOptions()), this._fastUpdates && (e42 = { ...e42, ...this._fastUpdates.materialParameters }), this._materials[0] = new Q2(e42), t32.add(this._materials[0]), this._materials[0];
  }
  _setDrapingDependentMaterialParameters() {
    this.draped && (this._forEachMaterial((e42) => {
      e42.setParameters({ verticalOffset: null, screenSizePerspective: null, occlusionTest: false, hasSlicePlane: false, shaderPolygonOffset: 0, draped: this.draped });
    }), this.layerOpacityChanged());
  }
  destroy() {
    super.destroy(), this._patchTask = e3(this._patchTask), this._forEachMaterial((e42) => this._context.stage.remove(e42)), this._materials.length = 0, this._cimSymbolMaterials.clear(), this._cimSymbolTextures.forEach((e42) => this._context.stage.remove(e42)), this._cimSymbolTextures.clear(), this._textureHandle = t3(this._textureHandle);
  }
  _getScaleFactor(e42, t32) {
    if (this._drivenProperties.size && e42.size) {
      for (let t33 = 0; t33 < 3; t33++) {
        const r39 = e42.size[t33];
        r39 && "symbol-value" !== r39 && "proportional" !== r39 && (e42.size[t33] = u8(r39));
      }
      if ("symbol-value" === e42.size[0])
        return 1;
      if (isFinite(+e42.size[0]))
        return +e42.size[0] / t32;
      if (isFinite(+e42.size[2]))
        return +e42.size[2] / t32;
    }
    return 1;
  }
  createGraphics3DGraphic(e42) {
    var _a;
    const t32 = e42.graphic;
    if (!this._validateGeometry(t32.geometry))
      return null;
    let r39, i20 = [0, 0];
    if (this._cimData) {
      if (!this._cimData.symbol)
        return null;
      const e43 = this._generateTextureCIM(t32), s33 = { textureId: e43.id, ...this._cimMaterialParametersInfo };
      r39 = this._createMaterialAndAddToStage(s33, this._context.stage);
      const o28 = window.devicePixelRatio || 1;
      i20 = [e43.parameters.width / o28, e43.parameters.height / o28];
    } else
      i20 = this._size, r39 = this._materials[0];
    const s32 = m13(t32.geometry);
    if (null == s32)
      return this.logger.warn(`unsupported geometry type for icon symbol: ${t32.geometry.type}`), null;
    const o27 = e42.renderingInfo, a28 = this._getVertexOpacityAndColor(o27);
    let n28 = 1;
    if (!((_a = this._fastUpdates) == null ? void 0 : _a.visualVariables.size)) {
      const e43 = i20[0] > i20[1] ? i20[0] : i20[1];
      n28 = this._getScaleFactor(o27, e43);
    }
    n28 *= this._symbolTextureRatio;
    const l31 = r7(i20[0] * n28, i20[1] * n28), c32 = this.setGraphicElevationContext(t32);
    return this.ensureDrapedStatus("on-the-ground" === c32.mode) && this._setDrapingDependentMaterialParameters(), this.draped ? this._createAsOverlay(t32, s32, r39, a28, l31, e42.layer.uid) : this._createAs3DShape(t32, s32, r39, a28, l31, c32, t32.uid);
  }
  layerOpacityChanged() {
    const e42 = this._getFillColor(), t32 = this._getOutlineColor();
    this._forEachMaterial((r39) => {
      r39.setParameters({ color: e42 }), r39.setParameters({ outlineColor: t32 });
    });
  }
  layerElevationInfoChanged(e42, t32, r39) {
    const i20 = this._elevationContext.mode, s32 = m9(_le.elevationModeChangeTypes, r39, i20);
    if (s32 !== b7.UPDATE)
      return s32;
    const o27 = d8(i20) || "absolute-height" === i20;
    return this.updateGraphics3DGraphicElevationInfo(e42, t32, () => o27);
  }
  slicePlaneEnabledChanged() {
    return this.draped || this._forEachMaterial((e42) => {
      e42.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  get pixelRatioChanged() {
    return null != this._getPrimitive();
  }
  applyRendererDiff(e42, t32) {
    var _a;
    for (const r39 in e42.diff) {
      if ("visualVariables" !== r39)
        return e33.RecreateSymbol;
      if (!G4(this._fastUpdates, t32, this._fastVisualVariableConvertOptions()))
        return e33.RecreateSymbol;
      (_a = this._materials[0]) == null ? void 0 : _a.setParameters(this._fastUpdates.materialParameters);
    }
    return e33.FastUpdate;
  }
  prepareSymbolLayerPatch(e42) {
    var _a;
    if ((_a = this._patchTask) == null ? void 0 : _a.abort(), "partial" !== e42.diff.type)
      return;
    const t32 = e42.diff.diff;
    this._preparePatchResource(e42, t32);
  }
  _preparePatchResource(e42, s32) {
    var _a;
    if (!s32.resource || "partial" !== s32.resource.type)
      return;
    const c32 = s32.resource.diff;
    if ("complete" !== ((_a = c32 == null ? void 0 : c32.href) == null ? void 0 : _a.type))
      return;
    const h25 = c32.href.newValue, { textures: m22 } = this._context.sharedResources;
    if (null == h25 || null == m22 || null != me(h25))
      return;
    const u32 = this._getIconSize(), d20 = u32 * this._context.graphicsCoreOwner.view.state.pixelRatio;
    e42.symbolLayerStatePatches.push(() => {
      this._patchTask = e3(this._patchTask), this._patchTask = d((e43) => this._context.schedule(async (e44, r39) => {
        const s33 = await _(m22.fromUrl(h25, d20, { signal: r39 }));
        s3(r39);
        const o27 = !s33.ok;
        if (o27 && a2(s33.error), this._textureHandle = t3(this._textureHandle), this._patchTask = null, o27) {
          this._forEachMaterial((e46) => {
            e46.visible = false, e46.setParameters({ textureId: null });
          });
          const e45 = `Failed to load (Request for icon resource failed: ${h25})`;
          return void this.logger.error(new s2("graphics3diconsymbollayer:request-failed", e45));
        }
        this._textureHandle = s33.value;
        const c33 = s33.value.texture;
        this._size = de(c33, u32), this._forEachMaterial((e45) => {
          e45.setParameters({ textureId: c33.id }), e45.visible = true;
        });
      }, e43));
    }), delete c32.href;
  }
  _defaultElevationInfoNoZ() {
    return pe;
  }
  _createAs3DShape(e42, t32, r39, i20, s32, o27, a28) {
    const n28 = this.getFastUpdateAttrValues(e42), l31 = this._context.layer.uid, c32 = this._context.stage.renderView.getObjectAndLayerIdColor({ graphicUid: a28, layerUid: l31 }), h25 = ht(r39, re, null, i20, s32, _e, null, n28, c32), m22 = c20(this._context, t32, h25, o27, a28);
    if (null == m22)
      return null;
    const u32 = new p13(this, m22.object, [h25], null, null, p12, o27);
    return u32.alignedSampledElevation = m22.sampledElevation, u32.needsElevationUpdates = d8(o27.mode) || "absolute-height" === o27.mode, u32.getScreenSize = this._createScreenSizeGetter(s32, n28), u32.calculateRelativeScreenBounds = (e43) => r39.calculateRelativeScreenBounds(u32.getScreenSize(), 1, e43), p15(u32, t32, this._context.elevationProvider), u32;
  }
  _createAsOverlay(e42, t32, r39, i20, s32, o27) {
    r39.renderPriority = this._renderPriority;
    const a28 = n2();
    c8(t32, a28, this._context.overlaySR), a28[2] = te;
    const n28 = this._context.clippingExtent;
    if (null != n28 && !y2(n28, a28))
      return null;
    const l31 = this.getFastUpdateAttrValues(e42), c32 = this._context.stage.renderView.getObjectAndLayerIdColor({ graphicUid: e42.uid, layerUid: this._context.layer.uid }), h25 = ht(r39, re, a28, i20, s32, null, null, l31, c32), m22 = new m8(h25, { layerUid: o27, graphicUid: e42.uid }), u32 = new l24(this, [m22], null, this._context.drapeSourceRenderer);
    return u32.getScreenSize = this._createScreenSizeGetter(s32, l31), u32.calculateRelativeScreenBounds = (e43) => r39.calculateRelativeScreenBounds(u32.getScreenSize(), 1, e43), u32;
  }
  _createScreenSizeGetter(e42, t32) {
    const r39 = this._outlineSize + 2;
    if (this._fastUpdates && t32) {
      const i21 = e42[0] / this._symbolTextureRatio, s33 = e42[1] / this._symbolTextureRatio;
      return (e43 = n9()) => {
        const [o27, a28] = W2(fe, this._fastUpdates.materialParameters, t32);
        return e43[0] = o27 * i21 + r39, e43[1] = a28 * s33 + r39, e43;
      };
    }
    const i20 = e42[0] / this._symbolTextureRatio + r39, s32 = e42[1] / this._symbolTextureRatio + r39;
    return (e43 = n9()) => (e43[0] = i20, e43[1] = s32, e43);
  }
  _fastVisualVariableConvertOptions() {
    const e42 = Math.max(this._size[0], this._size[1]), t32 = r3(e42, e42, e42), r39 = e10(1), i20 = e42 * r39, s32 = r3(i20, i20, i20);
    return new B({ size: true, color: true, rotation: true, opacity: false }, t32, s32, r39);
  }
  _forEachMaterial(e42) {
    this._materials.forEach(e42), this._cimSymbolMaterials.forEach(e42);
  }
  test() {
    return { ...super.test(), material: this._materials[0] };
  }
};
function ce(e42) {
  return e42 && "point-3d" === e42.type && e42.hasVisibleVerticalOffset();
}
function he(e42) {
  return null != e42 && ("cross" === e42 || "x" === e42);
}
function me(e42) {
  const t32 = ot(e42);
  return "application/json" === (t32 == null ? void 0 : t32.mediaType) ? t32.data : void 0;
}
function ue(e42, t32) {
  return "relative" === e42 ? r7((t32.x || 0) + 0.5, 0.5 - (t32.y || 0)) : e42 in s24 ? s24[e42] : s24.center;
}
function de({ parameters: e42 }, t32) {
  const r39 = (e42.width ?? 1) / (e42.height ?? 1);
  return r39 > 1 ? [t32, Math.round(t32 / r39)] : [Math.round(t32 * r39), t32];
}
le.PRIMITIVE_SIZE = ne, le.elevationModeChangeTypes = { definedChanged: b7.UPDATE, staysOnTheGround: b7.NONE, onTheGroundChanged: b7.RECREATE };
var pe = { mode: "relative-to-ground", offset: 0 };
var _e = r5(0, 0, 0, 1);
var fe = n2();

// node_modules/@arcgis/core/views/3d/layers/graphics/lineUtils.js
function n20(n28) {
  switch (n28) {
    case "butt":
      return r20.BUTT;
    case "square":
      return r20.SQUARE;
    case "round":
      return r20.ROUND;
    default:
      return null;
  }
}
function r31(e42) {
  return "diamond" === e42 ? "kite" : e42;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DLineSymbolLayer.js
var W3 = ["polyline", "polygon", "extent"];
var G8 = new B({ size: true, color: true, rotation: false, opacity: true });
var O13 = class _O extends h13 {
  constructor(e42, t32, r39, i20) {
    super(e42, t32, r39, i20);
  }
  async doLoad() {
    if (this._fastUpdates = O8(this._context.renderer, G8), !this._drivenProperties.size) {
      if ((null != this.symbolLayer.size ? this.symbolLayer.size : e10(1)) < 0)
        throw new s2("graphics3dlinesymbollayer:invalid-size", "Symbol sizes may not be negative values");
    }
  }
  _getMaterialParameters(e42, t32 = false) {
    var _a, _b;
    const r39 = this._getCombinedOpacityAndColor(t32 && this._markerColor || this._materialColor);
    this._patternHidesLine && !t32 && (r39[3] = 0);
    const i20 = { width: this._computeMaterialWidth((_a = this.symbolLayer) == null ? void 0 : _a.size), color: r39, hasPolygonOffset: true, join: this.symbolLayer.join || "miter", cap: n20(this.symbolLayer.cap || "butt"), hasSlicePlane: this._context.slicePlaneEnabled, isClosed: e42, stipplePattern: n15(this.symbolLayer.pattern) };
    return ((_b = this._fastUpdates) == null ? void 0 : _b.visualVariables) ? { ...i20, ...this._fastUpdates.materialParameters } : i20;
  }
  get _materialColor() {
    var _a;
    return (_a = this.symbolLayer.material) == null ? void 0 : _a.color;
  }
  get _markerColor() {
    var _a;
    return (_a = this.symbolLayer.marker) == null ? void 0 : _a.color;
  }
  get _lineMaterial() {
    return null == this._materials[F8.Line] && (this._materials[F8.Line] = new H3(this._getMaterialParameters(false)), this._context.stage.add(this._materials[F8.Line])), this._materials[F8.Line];
  }
  get _ringMaterial() {
    return null == this._materials[F8.Ring] && (this._materials[F8.Ring] = new H3(this._getMaterialParameters(true)), this._context.stage.add(this._materials[F8.Ring])), this._materials[F8.Ring];
  }
  get _wireframeLineMaterial() {
    return null == this._materials[F8.LineWireframe] && (this._materials[F8.LineWireframe] = new H3({ ...this._getMaterialParameters(false), wireframe: true }), this._context.stage.add(this._materials[F8.LineWireframe])), this._materials[F8.LineWireframe];
  }
  get _wireframeRingMaterial() {
    return null == this._materials[F8.RingWireframe] && (this._materials[F8.RingWireframe] = new H3({ ...this._getMaterialParameters(true), wireframe: true }), this._context.stage.add(this._materials[F8.RingWireframe])), this._materials[F8.RingWireframe];
  }
  get _markerMaterial() {
    return null == this._materials[F8.Marker] && null != this.symbolLayer.marker && (this._materials[F8.Marker] = new v3({ ...this._getMaterialParameters(false, true), placement: this.symbolLayer.marker.placement, markerPrimitive: r31(this.symbolLayer.marker.style) }), this._context.stage.add(this._materials[F8.Marker])), this._materials[F8.Marker];
  }
  destroy() {
    super.destroy(), this._forEachMaterial((e42) => this._context.stage.remove(e42)), this._materials.length = 0;
  }
  _getDrivenSize(e42) {
    return this._drivenProperties.size && e42.size ? u8(s21(e42.size)) : 1;
  }
  _getDrivenColor(e42) {
    const t32 = r5(1, 1, 1, 1);
    return this._drivenProperties.color && e42.color && (t32[0] = e42.color[0], t32[1] = e42.color[1], t32[2] = e42.color[2], e42.color.length > 0 && (t32[3] = e42.color[3])), this._drivenProperties.opacity && e42.opacity && (t32[3] = e42.opacity), t32;
  }
  createGraphics3DGraphic(e42) {
    const t32 = e42.graphic;
    if (!this._validateGeometry(t32.geometry, W3, this.symbolLayer.type))
      return null;
    const r39 = this.setGraphicElevationContext(t32);
    return this.ensureDrapedStatus("on-the-ground" === r39.mode), this.draped ? this._createAsOverlay(e42, this._context.layer.uid) : this._createAs3DShape(e42, r39, t32.uid);
  }
  applyRendererDiff(e42, t32) {
    for (const r39 in e42.diff) {
      if ("visualVariables" !== r39)
        return e33.RecreateSymbol;
      {
        const e43 = this._fastUpdates;
        if (!G4(e43, t32, G8))
          return e33.RecreateSymbol;
        this._forEachMaterial((t33) => t33 == null ? void 0 : t33.setParameters(e43.materialParameters));
      }
    }
    return e33.FastUpdate;
  }
  prepareSymbolLayerPatch(e42) {
    var _a, _b;
    if ("partial" !== e42.diff.type)
      return;
    const t32 = e42.diff.diff, r39 = {};
    "complete" === ((_a = t32.size) == null ? void 0 : _a.type) && (r39.width = this._computeMaterialWidth(t32.size.newValue), delete t32.size), "complete" === ((_b = t32.cap) == null ? void 0 : _b.type) && (r39.cap = n20(t32.cap.newValue ?? "butt"), delete t32.cap);
    const i20 = this._prepareMarkerPatch(e42, t32);
    this._prepareMaterialPatch(e42, t32, i20), e42.symbolLayerStatePatches.push(() => this._forEachMaterial((e43) => e43 == null ? void 0 : e43.setParameters(r39)));
  }
  layerOpacityChanged() {
    this._forEachMaterial((e42, t32) => this._updateMaterialLayerOpacity(e42, t32 === F8.Marker));
  }
  _forEachMaterial(e42) {
    this._materials.forEach(e42);
  }
  _updateMaterialLayerOpacity(e42, t32 = false) {
    var _a, _b;
    if (null == e42)
      return;
    const r39 = e42.parameters.color, a28 = (_b = (_a = this.symbolLayer) == null ? void 0 : _a.material) == null ? void 0 : _b.color, s32 = this._patternHidesLine && !t32 ? 0 : this._getCombinedOpacity(a28), n28 = r5(r39[0], r39[1], r39[2], s32);
    e42.setParameters({ color: n28 });
  }
  layerElevationInfoChanged(e42, t32, r39) {
    const i20 = this._elevationContext.mode, a28 = m9(_O.elevationModeChangeTypes, r39, i20);
    if (a28 !== b7.UPDATE)
      return a28;
    const s32 = d8(i20);
    return this.updateGraphics3DGraphicElevationInfo(e42, t32, () => s32);
  }
  slicePlaneEnabledChanged() {
    const e42 = { hasSlicePlane: this._context.slicePlaneEnabled };
    return this._forEachMaterial((t32) => t32 == null ? void 0 : t32.setParameters(e42)), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  _createAs3DShape(e42, t32, r39) {
    const i20 = V3(e42.graphic.geometry), a28 = "polygon" === i20.type ? i20.rings : i20.paths, m22 = new Array(), h25 = i(), c32 = p11(i20, this._context.elevationProvider, this._context.renderCoordsHelper, t32), d20 = "polygon" === i20.type ? "rings" : "paths";
    this._logGeometryCreationWarnings(c32, a28, d20, "LineSymbol3DLayer");
    for (let s32 = 0; s32 < c32.lines.length; s32++) {
      const t33 = c32.lines[s32], a29 = t33.position, p23 = t33.mapPositions;
      if (null != this._context.clippingExtent && (P2(h25), c4(h25, p23), !V(h25, this._context.clippingExtent)))
        continue;
      const d21 = this._createGeometry("polygon" === i20.type ? this._ringMaterial : this._lineMaterial, e42, a29, p23, i20.type, T4.ELEVATED, r39);
      m22.push(d21), t19.LINE_WIREFRAMES && m22.push(d21.instantiate({ material: "polygon" === i20.type ? this._wireframeRingMaterial : this._wireframeLineMaterial })), null != this._markerMaterial && m22.push(d21.instantiate({ material: this._markerMaterial }));
    }
    if (0 === m22.length)
      return null;
    const u32 = new O9({ geometries: m22, castShadow: false, layerUid: this._context.layer.uid, graphicUid: r39 }), g15 = new p13(this, u32, m22, null, null, I7, t32);
    return g15.alignedSampledElevation = c32.sampledElevation, g15.needsElevationUpdates = d8(t32.mode), g15;
  }
  _createGeometry(e42, t32, r39, i20, a28, s32, n28) {
    var _a, _b, _c;
    const o27 = s32 === T4.DRAPED ? { spatialReference: this._context.overlaySR, renderCoordsHelper: this._context.renderCoordsHelper } : null, l31 = "polygon" === a28, m22 = (_a = this._fastUpdates) == null ? void 0 : _a.visualVariables.color, h25 = (_b = this._fastUpdates) == null ? void 0 : _b.visualVariables.size, p23 = (_c = this._fastUpdates) == null ? void 0 : _c.visualVariables.opacity, c32 = this._context.stage.renderView.getObjectAndLayerIdColor({ graphicUid: n28, layerUid: this._context.layer.uid }), d20 = { position: r39, size: h25 ? null : this._getDrivenSize(t32.renderingInfo), color: m22 ? null : this._getDrivenColor(t32.renderingInfo), sizeFeature: h25 ? X(h25.field, t32.graphic) : null, colorFeature: m22 ? X(m22.field, t32.graphic) : null, opacityFeature: p23 ? X(p23.field, t32.graphic) : null };
    return b9(e42, { overlayInfo: o27, removeDuplicateStartEnd: l31, mapPositions: i20, attributeData: d20 }, c32);
  }
  _createAsOverlay(e42, t32) {
    const r39 = e42.graphic, i20 = V3(r39.geometry), a28 = "polygon" === i20.type ? i20.rings : i20.paths, h25 = "polygon" === i20.type ? this._ringMaterial : this._lineMaterial;
    h25.renderPriority = this._renderPriority;
    const p23 = t19.LINE_WIREFRAMES ? "polygon" === i20.type ? this._wireframeRingMaterial : this._wireframeLineMaterial : null, c32 = this._markerMaterial;
    null != p23 && (p23.renderPriority = this._renderPriority - 1e-3), null != c32 && (c32.renderPriority = this._renderPriority - 2e-3);
    const d20 = new Array(), y10 = i(), _16 = P2(), g15 = l15(i20, this._context.overlaySR), f23 = "polygon" === i20.type ? "rings" : "paths";
    this._logGeometryCreationWarnings(g15, a28, f23, "LineSymbol3DLayer");
    for (const s32 of g15.lines) {
      if (P2(y10), c4(y10, s32.position), !V(y10, this._context.clippingExtent))
        continue;
      o3(_16, y10);
      const a29 = (a30) => {
        const n28 = this._createGeometry(a30, e42, s32.position, void 0, i20.type, T4.DRAPED, r39.uid), o27 = new m8(n28, { layerUid: t32, graphicUid: r39.uid });
        d20.push(o27);
      };
      if (null != c32) {
        a29(c32);
        const e43 = this.symbolLayer.marker.placement;
        "begin" !== e43 && "begin-end" !== e43 || c4(y10, s32.position, 0, 1), "end" !== e43 && "begin-end" !== e43 || c4(y10, s32.position, s32.position.length - 3, 1);
      }
      a29(h25), t19.LINE_WIREFRAMES && a29(p23);
    }
    return new l24(this, d20, _16, this._context.drapeSourceRenderer);
  }
  get _patternHidesLine() {
    const e42 = this.symbolLayer.pattern;
    return null != e42 && "style" === e42.type && "none" === e42.style;
  }
  _computeMaterialWidth(e42) {
    var _a;
    return e42 = e42 ?? e10(1), this._drivenProperties.size ? ((_a = this._fastUpdates) == null ? void 0 : _a.visualVariables.size) ? u8(1) : 1 : u8(e42);
  }
  _prepareMaterialPatch(e42, t32, r39) {
    var _a, _b;
    const i20 = t32.material;
    if (null == i20)
      return void (r39.changed && r39.useMaterialColor && I8(this._getCombinedOpacityAndColor(this._materialColor), this._materials[F8.Marker], e42));
    if ("collection" === i20.type)
      return;
    const s32 = "complete" === i20.type ? (_a = i20.newValue) == null ? void 0 : _a.color : "complete" === ((_b = i20.diff.color) == null ? void 0 : _b.type) ? i20.diff.color.newValue : null, n28 = this._getCombinedOpacityAndColor(s32);
    r39.useMaterialColor && I8(t5(n28), this._materials[F8.Marker], e42), this._patternHidesLine && (n28[3] = 0), I8(n28, this._materials[F8.Line], e42), delete t32.material;
  }
  _prepareMarkerPatch(e42, t32) {
    var _a;
    const r39 = t32.marker, i20 = this._markerMaterial;
    if (null == r39 || "partial" !== r39.type || null == r39.diff || null != r39.diff.placement || null != r39.diff.style && "complete" !== r39.diff.style.type || null != r39.diff.color && "complete" !== r39.diff.color.type || null == i20)
      return { changed: false, useMaterialColor: null == this._markerColor };
    const a28 = r39.diff.color, s32 = null != a28, n28 = s32 ? a28.newValue : null, o27 = null == n28 && null == this._markerColor;
    n28 && I8(this._getCombinedOpacityAndColor(n28), i20, e42);
    const l31 = (_a = r39.diff.style) == null ? void 0 : _a.newValue;
    return l31 && e42.symbolLayerStatePatches.push(() => i20.setParameters({ markerPrimitive: r31(l31) })), delete t32.marker, { changed: s32, useMaterialColor: o27 };
  }
};
function V3(e42) {
  switch (e42.type) {
    case "extent":
      if (e42 instanceof w2)
        return j2.fromExtent(e42);
      break;
    case "polygon":
    case "polyline":
      return e42;
  }
  return null;
}
function I8(e42, t32, r39) {
  null != t32 && r39.symbolLayerStatePatches.push(() => t32.setParameters({ color: e42 }));
}
var T4;
var F8;
O13.elevationModeChangeTypes = { definedChanged: b7.RECREATE, staysOnTheGround: b7.NONE, onTheGroundChanged: b7.RECREATE }, function(e42) {
  e42[e42.DRAPED = 0] = "DRAPED", e42[e42.ELEVATED = 1] = "ELEVATED";
}(T4 || (T4 = {})), function(e42) {
  e42[e42.Line = 0] = "Line", e42[e42.Ring = 1] = "Ring", e42[e42.LineWireframe = 2] = "LineWireframe", e42[e42.RingWireframe = 3] = "RingWireframe", e42[e42.Marker = 4] = "Marker";
}(F8 || (F8 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DMeshObject3DGraphicLayer.js
var g10 = class extends p13 {
  constructor() {
    super(...arguments), this._originalGeometries = [], this._fastTransformUpdatesEnabled = false;
  }
  get fastTransformUpdatesEnabled() {
    return this._fastTransformUpdatesEnabled;
  }
  enableFastTransformUpdates(e42, a28) {
    if (this._fastTransformUpdatesEnabled)
      return;
    this._fastTransformUpdatesEnabled = true;
    const { stageObject: r39 } = this, s32 = r39.geometries.slice();
    r39.removeAllGeometries();
    const o27 = I(h18, r39.transformation), i20 = a28.getOrigin(o27);
    for (const t32 of s32) {
      const a29 = e42(t32.material), s33 = t32.instantiate({ material: a29 });
      s33.localOrigin = i20, r39.addGeometry(s33);
    }
    this._originalGeometries = s32;
  }
  disableFastTransformUpdates(t32) {
    if (!this._fastTransformUpdatesEnabled)
      return;
    this._fastTransformUpdatesEnabled = false;
    const { stageObject: e42 } = this, a28 = e42.geometries.map((e43) => t32(e43.material));
    e42.removeAllGeometries();
    for (let r39 = 0; r39 < this._originalGeometries.length; r39++) {
      const t33 = this._originalGeometries[r39], s32 = a28[r39];
      s32.setParameters({ modelTransformation: null }), s32 === t33.material ? e42.addGeometry(t33) : e42.addGeometry(t33.instantiate({ material: s32 }));
    }
    this._originalGeometries.length = 0;
  }
  updateFastLocalOrigin(e42, a28, r39) {
    if (!this._fastTransformUpdatesEnabled)
      return;
    const { stageObject: s32 } = this;
    if (0 === s32.geometries.length)
      return;
    const i20 = s32.geometries[0].localOrigin, n28 = I(h18, e42), m22 = r39.getOrigin(n28);
    if (m22 === i20)
      return;
    const f23 = (a28 == null ? void 0 : a28.localMatrix) ?? o6;
    s32.shaderTransformation = null, s32.transformation = e42, s32.geometries.forEach((t32) => {
      t32.transformation = f23, t32.localOrigin = m22;
    });
  }
  updateTransform(t32, r39, s32) {
    const { stageObject: i20 } = this, n28 = (r39 == null ? void 0 : r39.localMatrix) ?? o6;
    if (!this._fastTransformUpdatesEnabled)
      return i20.shaderTransformation = null, i20.transformation = t32, i20.geometries.forEach((t33) => t33.transformation = n28), void this._updateEdgeTransform(s32);
    const m22 = i20.transformation, f23 = i20.geometries[0].transformation, l31 = t32, c32 = n28, d20 = c5(p19, m22, f23), g15 = c5(T5, l31, c32), h25 = c5(b12, g15, h4(b12, f23));
    i20.shaderTransformation = h25, this._setFastMaterialTransformation({ matA: d20, matB: g15 }), this._updateEdgeTransform(s32);
  }
  alignWithElevation(t32, a28, s32, o27) {
    if (!this._fastTransformUpdatesEnabled)
      return void super.alignWithElevation(t32, a28, s32, o27);
    null != s32 && l14(this.elevationContext.featureExpressionInfoContext, s32);
    const i20 = (e42, r39) => c17(e42, t32, this.elevationContext, a28, r39), { stageObject: n28 } = this;
    if (!n28.geometries[0].material.parameters.modelTransformation)
      return;
    const m22 = n28.transformation, d20 = n28.geometries[0].transformation, g15 = c5(p19, m22, d20), h25 = n28.effectiveTransformation, b18 = n4(u24, h25);
    this.alignedSampledElevation = p12(this, this.elevationContext, t32.spatialReference, i20, a28, b18), n28.shaderTransformation = b18;
    const E21 = n28.geometries[0].transformation, _16 = c5(T5, b18, E21);
    this._setFastMaterialTransformation({ matA: g15, matB: _16 }), this._updateEdgeTransform(o27);
  }
  _setFastMaterialTransformation({ matA: t32, matB: r39 }) {
    const { stageObject: o27 } = this;
    if (0 === o27.geometries.length)
      return;
    const i20 = o27.geometries[0].localOrigin, m22 = q3(j13, g(h18, i20.vec3, -1)), f23 = c5(E15, m22, t32), l31 = c5(_11, m22, r39), c32 = h4(E15, f23), d20 = c5(_11, l31, c32);
    for (const e42 of o27.geometries)
      e42.material.setParameters({ modelTransformation: d20 });
  }
  _updateEdgeTransform(t32) {
    const { stageObject: e42, _stageLayer: a28 } = this;
    a28.stage.renderer.withEdgeView((a29) => {
      a29.fastUpdateObject3DEdgesTransform(e42) || this.resetEdgeObject(t32);
    });
  }
};
var h18 = n2();
var p19 = e12();
var T5 = e12();
var u24 = e12();
var b12 = e12();
var E15 = e12();
var _11 = e12();
var j13 = e12();

// node_modules/@arcgis/core/views/3d/layers/graphics/MeshFastUpdateProcessor.js
var r32 = class {
  constructor() {
    this._fastTransformOriginalMaterials = /* @__PURE__ */ new Map(), this._fastTransformClonedMaterials = /* @__PURE__ */ new Map(), this._graphicReferenceCount = 0;
  }
  enable(r39, t32, e42) {
    r39.enableFastTransformUpdates((r40) => {
      if (this._graphicReferenceCount <= 1) {
        if (this._fastTransformOriginalMaterials.has(r40))
          return r40;
        const a28 = t32.byMaterial(r40);
        return this._fastTransformOriginalMaterials.set(r40, a28), t32.delete(r40), r40;
      }
      const s32 = new E7(r40.parameters);
      return e42.stage.add(s32), this._fastTransformClonedMaterials.set(s32, r40), s32;
    }, e42.localOriginFactory);
  }
  disable(a28, r39, t32) {
    const e42 = /* @__PURE__ */ new Set(), s32 = /* @__PURE__ */ new Set();
    a28.disableFastTransformUpdates((a29) => {
      if (!this._fastTransformClonedMaterials.has(a29)) {
        const t33 = a29, i21 = this._fastTransformOriginalMaterials.get(t33);
        return r39.has(i21.uid) ? (e42.add(t33), r39.byUid(i21.uid).material) : (s32.add(t33), i21.material);
      }
      const i20 = a29, n28 = this._fastTransformClonedMaterials.get(i20);
      return this._fastTransformClonedMaterials.delete(i20), t32.stage.remove(i20), n28;
    });
    for (const i20 of e42)
      this._fastTransformOriginalMaterials.delete(i20), t32.stage.remove(i20);
    for (const i20 of s32) {
      const a29 = this._fastTransformOriginalMaterials.get(i20);
      this._fastTransformOriginalMaterials.delete(i20), r39.set(a29.uid, a29);
    }
  }
  onAddGraphic() {
    this._graphicReferenceCount++;
  }
  onRemoveGraphic(a28, r39, t32) {
    this._graphicReferenceCount--, this.disable(a28, r39, t32);
  }
  forEachMaterialInfo(a28) {
    this._fastTransformOriginalMaterials.forEach(a28);
  }
  forEachClonedMaterial(a28) {
    this._fastTransformClonedMaterials.forEach(a28);
  }
  destroy(a28) {
    a28.removeMany(Array.from(this._fastTransformClonedMaterials.keys())), a28.removeMany(Array.from(this._fastTransformOriginalMaterials.values(), ({ material: a29 }) => a29)), this._fastTransformClonedMaterials.clear(), this._fastTransformOriginalMaterials.clear();
  }
};
var t30 = class {
  constructor() {
    this._byUid = /* @__PURE__ */ new Map(), this._byMaterial = /* @__PURE__ */ new Map();
  }
  get materials() {
    return Array.from(this._byUid.values(), (a28) => a28.material);
  }
  byUid(a28) {
    return this._byUid.get(a28);
  }
  byMaterial(a28) {
    return this._byMaterial.get(a28);
  }
  set(a28, r39) {
    this._byUid.set(a28, r39), this._byMaterial.set(r39.material, r39);
  }
  delete(a28) {
    var _a;
    const r39 = (_a = this._byMaterial.get(a28)) == null ? void 0 : _a.uid;
    r39 && (this._byUid.delete(r39), this._byMaterial.delete(a28));
  }
  has(a28) {
    return this._byUid.has(a28);
  }
  forEachMaterialInfo(a28) {
    this._byUid.forEach(a28);
  }
  clear() {
    this._byUid.clear(), this._byMaterial.clear();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/NativeLineTechnique.js
var S13 = class _S extends r14 {
  initializeProgram(e42) {
    return new r15(e42.rctx, _S.shader.get().build(this.configuration), O6);
  }
  initializePipeline() {
    const t32 = this.configuration, r39 = l12(R3.SRC_ALPHA, R3.ONE, R3.ONE_MINUS_SRC_ALPHA, R3.ONE_MINUS_SRC_ALPHA), i20 = (e42, r40 = null, i21 = null) => S5({ blending: r40, depthTest: i9, depthWrite: i21, colorWrite: _6, stencilWrite: t32.hasOccludees ? e27 : null, stencilTest: t32.hasOccludees ? e42 ? o13 : f7 : null });
    return t32.output === o7.Color ? (this._occludeePipelineState = i20(true, t32.transparent ? r39 : null, o12), i20(false, t32.transparent ? r39 : null, o12)) : i20(false);
  }
  get primitiveType() {
    return E3.LINES;
  }
  getPipeline(e42) {
    return e42 ? this._occludeePipelineState : super.getPipeline();
  }
};
S13.shader = new t17(m10, () => import("./NativeLine.glsl-VAEVZ2XC.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/NativeLineTechniqueConfiguration.js
var s27 = class extends t21 {
  constructor() {
    super(...arguments), this.output = o7.Color, this.hasSlicePlane = false, this.hasVertexColors = false, this.transparent = false, this.hasOccludees = false;
  }
};
e([r17({ count: o7.COUNT })], s27.prototype, "output", void 0), e([r17()], s27.prototype, "hasSlicePlane", void 0), e([r17()], s27.prototype, "hasVertexColors", void 0), e([r17()], s27.prototype, "transparent", void 0), e([r17()], s27.prototype, "hasOccludees", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/NativeLineMaterial.js
var V4 = class extends c15 {
  constructor(e42) {
    super(e42, new U4()), this._configuration = new s27(), this.produces = /* @__PURE__ */ new Map([[A8.OPAQUE_MATERIAL, (e43) => e43 === o7.Color || e43 === o7.Highlight || e43 === o7.ObjectAndLayerIdColor]]);
  }
  getConfiguration(e42) {
    return this._configuration.output = e42, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasVertexColors = this.parameters.hasVertexColors, this._configuration.transparent = this.parameters.color[3] < 1 || this.parameters.width < 1, this._configuration.hasOccludees = this.parameters.hasOccludees, this._configuration;
  }
  intersect(t32, r39, f23, h25, d20, S21) {
    if (!f23.options.selectionMode || !t32.visible)
      return;
    if (!m6(r39))
      return void n.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial").error("intersection assumes a translation-only matrix");
    const L8 = t32.attributes.get(e16.POSITION).data, x12 = f23.camera, y10 = Z2;
    r11(y10, f23.point);
    const N7 = 2;
    o2(z3[0], y10[0] - N7, y10[1] + N7, 0), o2(z3[1], y10[0] + N7, y10[1] + N7, 0), o2(z3[2], y10[0] + N7, y10[1] - N7, 0), o2(z3[3], y10[0] - N7, y10[1] - N7, 0);
    for (let e42 = 0; e42 < 4; e42++)
      if (!x12.unprojectFromRenderScreen(z3[e42], J2[e42]))
        return;
    b3(x12.eye, J2[0], J2[1], K3), b3(x12.eye, J2[1], J2[2], Y4), b3(x12.eye, J2[2], J2[3], $), b3(x12.eye, J2[3], J2[0], ee);
    let R11 = Number.MAX_VALUE, T9 = 0;
    for (let e42 = 0; e42 < L8.length - 5; e42 += 3) {
      if (q6[0] = L8[e42] + r39[12], q6[1] = L8[e42 + 1] + r39[13], q6[2] = L8[e42 + 2] + r39[14], B3[0] = L8[e42 + 3] + r39[12], B3[1] = L8[e42 + 4] + r39[13], B3[2] = L8[e42 + 5] + r39[14], V2(K3, q6) < 0 && V2(K3, B3) < 0 || V2(Y4, q6) < 0 && V2(Y4, B3) < 0 || V2($, q6) < 0 && V2($, B3) < 0 || V2(ee, q6) < 0 && V2(ee, B3) < 0)
        continue;
      if (x12.projectToRenderScreen(q6, X2), x12.projectToRenderScreen(B3, k7), X2[2] < 0 && k7[2] > 0) {
        e8(D6, q6, B3);
        const e43 = x12.frustum, t34 = -V2(e43[j9.NEAR], q6) / P(D6, F3(e43[j9.NEAR]));
        g(D6, D6, t34), u5(q6, q6, D6), x12.projectToRenderScreen(q6, X2);
      } else if (X2[2] > 0 && k7[2] < 0) {
        e8(D6, B3, q6);
        const e43 = x12.frustum, t34 = -V2(e43[j9.NEAR], B3) / P(D6, F3(e43[j9.NEAR]));
        g(D6, D6, t34), u5(B3, B3, D6), x12.projectToRenderScreen(B3, k7);
      } else if (X2[2] < 0 && k7[2] < 0)
        continue;
      X2[2] = 0, k7[2] = 0;
      const t33 = M2(b4(X2, k7, H4), y10);
      t33 < R11 && (R11 = t33, r4(G9, q6), r4(F9, B3), T9 = e42 / 3);
    }
    const v13 = f23.rayBegin, w13 = f23.rayEnd;
    if (R11 < N7 * N7) {
      let e42 = Number.MAX_VALUE;
      if (d5(b4(G9, F9, H4), b4(v13, w13, Q3), W4)) {
        e8(W4, W4, v13);
        const t33 = s5(W4);
        g(W4, W4, 1 / t33), e42 = t33 / x(v13, w13);
      }
      S21(e42, W4, T9, false);
    }
  }
  intersectDraped(e42, r39, s32, o27, i20, a28) {
    if (!s32.options.selectionMode)
      return;
    const n28 = e42.attributes.get(e16.POSITION).data, c32 = e42.attributes.get(e16.SIZE), l31 = c32 ? c32.data[0] : 0, m22 = o27[0], u32 = o27[1], f23 = ((l31 + 1) / 2 + 4) * e42.screenToWorldRatio;
    let h25 = Number.MAX_VALUE, p23 = 0;
    for (let d20 = 0; d20 < n28.length - 5; d20 += 3) {
      const e43 = n28[d20], r40 = n28[d20 + 1], s33 = m22 - e43, o28 = u32 - r40, i21 = n28[d20 + 3] - e43, a29 = n28[d20 + 4] - r40, c33 = e9((i21 * s33 + a29 * o28) / (i21 * i21 + a29 * a29), 0, 1), l32 = i21 * c33 - s33, f24 = a29 * c33 - o28, g15 = l32 * l32 + f24 * f24;
      g15 < h25 && (h25 = g15, p23 = d20 / 3);
    }
    h25 < f23 * f23 && i20(a28.dist, a28.normal, p23, false);
  }
  createGLMaterial(e42) {
    return new I9(e42);
  }
  createBufferWriter() {
    const e42 = this.parameters.hasVertexColors ? r19 : t23;
    return new r13(e42);
  }
};
var I9 = class extends t16 {
  _updateOccludeeState(e42) {
    e42.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e42.hasOccludees });
  }
  beginSlot(e42) {
    return this._output === o7.Color && this._updateOccludeeState(e42), this.ensureTechnique(S13, e42);
  }
};
var U4 = class extends u14 {
  constructor() {
    super(...arguments), this.color = s7, this.hasVertexColors = false, this.hasSlicePlane = false, this.width = 1, this.hasOccludees = false;
  }
};
var q6 = n2();
var B3 = n2();
var D6 = n2();
var W4 = n2();
var X2 = x3();
var k7 = x3();
var G9 = n2();
var F9 = n2();
var H4 = v();
var Q3 = v();
var Z2 = n2();
var z3 = [x3(), x3(), x3(), x3()];
var J2 = [n2(), n2(), n2(), n2()];
var K3 = E2();
var Y4 = E2();
var $ = E2();
var ee = E2();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DMeshFillSymbolLayer.js
var je = ["mesh"];
var Ce = class extends h13 {
  constructor(e42, t32, r39, o27) {
    super(e42, t32, r39, o27), this._materialInfoCache = new t30(), this._fastUpdateProcessor = new r32(), this._textures = /* @__PURE__ */ new Map(), this.ensureDrapedStatus(false);
  }
  async doLoad() {
    t19.DRAW_MESH_GEOMETRY_NORMALS && (this._debugVertexNormalMaterial = new V4({ color: [1, 0, 1, 1] }), this._debugFaceNormalMaterial = new V4({ color: [0, 1, 1, 1] }));
  }
  destroy() {
    super.destroy(), this._textures.forEach((e42) => e42.unload()), this._context.stage.removeMany(this._materialInfoCache.materials), this._context.stage.removeMany(Array.from(this._textures.values())), this._materialInfoCache.clear(), this._textures.clear(), this._fastUpdateProcessor.destroy(this._context.stage);
  }
  get materials() {
    return this._materialInfoCache.materials;
  }
  createGraphics3DGraphic(e42) {
    const t32 = e42.graphic;
    if (!this._validateGeometry(t32.geometry, je, "fill on mesh-3d"))
      return null;
    const r39 = this.setGraphicElevationContext(t32), o27 = e42.renderingInfo;
    return this._createAs3DShape(t32, o27, r39, t32.uid);
  }
  onRemoveGraphic(e42) {
    this._fastUpdateProcessor.onRemoveGraphic(e42, this._materialInfoCache, this._context);
  }
  layerOpacityChanged(e42, t32) {
    const r39 = this._getLayerOpacity();
    this._updateMaterialParameters((e43) => {
      e43.material.setParameters({ layerOpacity: r39 });
      const t33 = e43.material.parameters;
      this._setMaterialTransparentParameter(t33, e43), e43.material.setParameters({ transparent: t33.transparent });
    }), e42.forEach((e43) => {
      var _a;
      return (_a = t32(e43)) == null ? void 0 : _a.layerOpacityChanged(r39, this._context.isAsync);
    });
  }
  layerElevationInfoChanged(e42, t32) {
    return this.updateGraphics3DGraphicElevationInfo(e42, t32, g5);
  }
  slicePlaneEnabledChanged(e42, t32) {
    return this._updateMaterialParameters(({ material: e43 }) => {
      e43.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    }), e42.forEach((e43) => {
      var _a;
      return (_a = t32(e43)) == null ? void 0 : _a.slicePlaneEnabledChanged(this._context.slicePlaneEnabled, this._context.isAsync);
    }), true;
  }
  physicalBasedRenderingChanged() {
    const e42 = this._usePBR();
    return this._updateMaterialParameters(({ material: t32 }) => t32.setParameters({ usePBR: e42 })), true;
  }
  updateTransform(e42, t32, r39, o27) {
    const n28 = e42.fastTransformUpdatesEnabled;
    switch (o27) {
      case a13.EnableFastUpdates:
        if (n28)
          return true;
        break;
      case a13.DisableFastUpdates:
        if (!n28)
          return true;
        break;
      default:
        if (!n28)
          return false;
    }
    const a28 = this._context.renderCoordsHelper.spatialReference, s32 = Xe, { origin: i20, transform: l31 } = r39;
    if (!R(t32, o2(ze, i20.x, i20.y, i20.z ?? 0), s32, a28))
      return false;
    switch (o27) {
      case a13.EnableFastUpdates:
        this._fastUpdateProcessor.enable(e42, this._materialInfoCache, this._context);
        break;
      case a13.DisableFastUpdates:
        this._fastUpdateProcessor.disable(e42, this._materialInfoCache, this._context);
        break;
      case a13.UpdateFastLocalOrigin:
        e42.updateFastLocalOrigin(s32, l31, this._context.localOriginFactory);
    }
    const { elevationContext: c32 } = e42;
    c32.centerPointInElevationSR = this._getCenterPointInElevationSR(s32);
    const { elevationProvider: u32, renderCoordsHelper: m22 } = this._context, f23 = (e43, t33) => c17(e43, u32, c32, m22, t33);
    return e42.alignedSampledElevation = p12(e42, c32, u32.spatialReference, f23, m22, s32), e42.updateTransform(s32, l31, this._context.isAsync), true;
  }
  _requiresSymbolVertexColors() {
    return this._drivenProperties.color || this._drivenProperties.opacity;
  }
  _materialPropertiesDefault(e42, t32) {
    const r39 = this._requiresSymbolVertexColors(), o27 = !!e42.vertexAttributes.color, n28 = !!e42.vertexAttributes.tangent;
    return { hasSymbolVertexColors: r39, hasVertexColors: o27, hasVertexTangents: n28, uid: `vc:${o27},vt:${n28},vct${t32},svc:${r39}` };
  }
  _materialProperties(e42, t32, r39) {
    const o27 = this._materialPropertiesDefault(e42, r39);
    if (!t32.material)
      return o27;
    const { color: n28, colorTexture: a28, colorTextureTransform: s32, normalTexture: i20, normalTextureTransform: l31, doubleSided: c32, alphaCutoff: u32, alphaMode: m22 } = t32.material, f23 = Ge(n28), p23 = Ge(a28), h25 = Ve(s32), d20 = Ge(i20), g15 = Ve(l31);
    if (o27.color = n28, o27.colorTexture = a28, o27.normalTexture = i20, o27.uid = `${o27.uid},cmuid:${f23},ctmuid:${p23},cttuid:${h25},ntmuid:${d20},nttuid:${g15},ds:${c32},ac:${u32},am:${m22}`, t32.material instanceof m5) {
      const { metallic: e43, roughness: r40, metallicRoughnessTexture: n29, metallicRoughnessTextureTransform: a29, emissiveColor: i21, emissiveTexture: c33, emissiveTextureTransform: u33, occlusionTexture: m23, occlusionTextureTransform: f24 } = t32.material, p24 = Ge(n29), h26 = Ve(a29), d21 = Ge(i21), g16 = Ge(c33), x12 = Ve(u33), _16 = Ge(m23), T9 = Ve(f24);
      o27.metallic = e43, o27.roughness = r40, o27.metallicRoughnessTexture = n29, o27.emissiveColor = i21, o27.emissiveTexture = c33, o27.occlusionTexture = m23, o27.colorTextureTransform = Be(s32), o27.normalTextureTransform = Be(l31), o27.emissiveTextureTransform = Be(u33), o27.occlusionTextureTransform = Be(f24), o27.metallicRoughnessTextureTransform = Be(a29), o27.uid = `${o27.uid},mrm:${e43},mrr:${r40},mrt:${p24},mrtt:${h26},emuid:${d21},etmuid:${g16},ett:${x12},otmuid:${_16},ott:${T9}`;
    }
    return o27;
  }
  _getInternalTextureId(e42) {
    const t32 = this._getInternalTexture(e42, s12.Opaque);
    return t32 == null ? void 0 : t32.id;
  }
  _getInternalTexture(e42, t32) {
    const r39 = Le(e42);
    if (!r39)
      return null;
    const o27 = `${e42.contentHash}/${t32}`;
    let n28 = this._textures.get(o27);
    if (!n28) {
      let a28 = null;
      const s32 = this._context.stage.renderView.renderingContext.parameters.maxMaxAnisotropy, i20 = { wrap: Ue(e42.wrap), noUnpackFlip: true, maxAnisotropy: s32, mipmap: s32 > 1 };
      r12(r39) ? (a28 = r39.data, i20.preMultiplyAlpha = false, i20.encoding = r39.encoding) : (a28 = r39, i20.preMultiplyAlpha = t32 !== s12.Opaque, i20.downsampleUncompressed = this._context.graphicsCoreOwner.view.qualitySettings.graphics3D.uncompressedTextureDownsamplingEnabled), n28 = new N(a28, i20), this._textures.set(o27, n28), n28.load(this._context.stage.renderView.renderingContext), this._context.stage.add(n28);
    }
    return n28;
  }
  _setInternalMaterialParameters(t32, r39) {
    var _a, _b;
    if (null != t32.color && $e(t32.color, r39), null != t32.colorTexture) {
      const e42 = this._getInternalTexture(t32.colorTexture, r39.textureAlphaMode);
      e42 ? (r39.textureId = e42.id, r39.textureAlphaPremultiplied = !!e42.parameters.preMultiplyAlpha) : r39.textureId = void 0;
    }
    t32.normalTexture && (r39.normalTextureId = this._getInternalTextureId(t32.normalTexture)), t32.emissiveColor && (r39.emissiveFactor = u9.toUnitRGB(t32.emissiveColor)), t32.emissiveTexture && (r39.emissiveTextureId = this._getInternalTextureId(t32.emissiveTexture)), t32.occlusionTexture && (r39.occlusionTextureId = this._getInternalTextureId(t32.occlusionTexture)), t32.metallicRoughnessTexture && (r39.metallicRoughnessTextureId = this._getInternalTextureId(t32.metallicRoughnessTexture)), r39.colorTextureTransformMatrix = s15(t32.colorTextureTransform), r39.normalTextureTransformMatrix = s15(t32.normalTextureTransform);
    const o27 = null != ((_a = t32.normalTextureTransform) == null ? void 0 : _a.scale) ? (_b = t32.normalTextureTransform) == null ? void 0 : _b.scale : l5;
    r39.scale = [o27[0], o27[1]], r39.occlusionTextureTransformMatrix = s15(t32.occlusionTextureTransform), r39.emissiveTextureTransformMatrix = s15(t32.emissiveTextureTransform), r39.metallicRoughnessTextureTransformMatrix = s15(t32.metallicRoughnessTextureTransform);
  }
  _setExternalMaterialParameters(t32) {
    var _a, _b;
    const r39 = this._drivenProperties.color;
    let o27 = ((_a = this.symbolLayer.material) == null ? void 0 : _a.colorMixMode) ?? null;
    if (r39)
      t32.externalColor = s7;
    else {
      const r40 = ((_b = this.symbolLayer.material) == null ? void 0 : _b.color) ?? null;
      r40 ? t32.externalColor = u9.toUnitRGBA(r40) : (o27 = null, t32.externalColor = s7);
    }
    o27 && (t32.colorMixMode = o27), t32.castShadows = !!this.symbolLayer.castShadows;
  }
  _getOrCreateMaterial(t32, r39) {
    var _a, _b, _c;
    const o27 = (_a = r39.material) == null ? void 0 : _a.color, n28 = (_b = r39.material) == null ? void 0 : _b.colorTexture, a28 = (_c = r39.material) == null ? void 0 : _c.alphaMode, s32 = "blend" === a28, i20 = !("opaque" === a28) && (De(t32) || null != o27 && o27.a < 1 || (n28 == null ? void 0 : n28.transparent) || s32), l31 = this._materialProperties(t32, r39, i20), c32 = this._materialInfoCache.byUid(l31.uid);
    if (c32)
      return c32.material;
    const u32 = { uid: l31.uid, material: null, isComponentTransparent: i20, alphaMode: r39.material ? r39.material.alphaMode : "opaque" }, m22 = u15({ normalTexture: l31.normalTexture, metallicRoughnessTexture: l31.metallicRoughnessTexture, metallicFactor: l31.metallic, roughnessFactor: l31.roughness, emissiveTexture: l31.emissiveTexture, emissiveFactor: u9.toUnitRGB(l31.emissiveColor), occlusionTexture: l31.occlusionTexture }), f23 = { usePBR: this._usePBR(), isSchematic: m22, hasVertexColors: l31.hasVertexColors, hasSymbolColors: l31.hasSymbolVertexColors, hasVertexTangents: l31.hasVertexTangents, ambient: l2, diffuse: _2, opacity: 1, doubleSided: true, doubleSidedType: "winding-order", cullFace: e21.None, layerOpacity: this._getLayerOpacity(), hasSlicePlane: this._context.slicePlaneEnabled, initTextureTransparent: true };
    f23.mrrFactors = m22 ? [...t18] : [l31.metallic, l31.roughness, r16[2]], r39.material && (f23.doubleSided = r39.material.doubleSided, f23.cullFace = r39.material.doubleSided ? e21.None : e21.Back, f23.textureAlphaCutoff = r39.material.alphaCutoff), this._setExternalMaterialParameters(f23), this._setMaterialTransparentParameter(f23, u32), this._setInternalMaterialParameters(l31, f23);
    const p23 = new E7(f23);
    return u32.material = p23, this._materialInfoCache.set(l31.uid, u32), this._context.stage.add(p23), p23;
  }
  _usePBR() {
    return this._context.physicalBasedRenderingEnabled;
  }
  _setMaterialTransparentParameter(e42, t32) {
    e42.transparent = this.needsDrivenTransparentPass || t32.isComponentTransparent || e42.layerOpacity < 1 || e42.opacity < 1 || e42.externalColor && e42.externalColor[3] < 1, "auto" === t32.alphaMode ? e42.textureAlphaMode = e42.transparent ? s12.MaskBlend : s12.Opaque : e42.textureAlphaMode = "opaque" === t32.alphaMode ? s12.Opaque : "mask" === t32.alphaMode ? s12.Mask : s12.Blend;
  }
  _addDebugNormals(e42, t32) {
    const r39 = t32.length, o27 = e42.spatialReference.isGeographic ? 20015077 / 180 : 1, n28 = 0.1 * Math.max(e42.extent.width * o27, e42.extent.height * o27, e42.extent.zmax - e42.extent.zmin), a28 = [], s32 = [], i20 = [], l31 = [];
    for (let f23 = 0; f23 < r39; f23++) {
      const e43 = t32[f23], r40 = e43.attributes.get(e16.POSITION), o28 = e43.attributes.get(e16.NORMAL), c33 = r40.data, u33 = r40.indices, m23 = o28.data, p23 = o28.indices;
      for (let t33 = 0; t33 < u33.length; t33++) {
        const e44 = 3 * u33[t33], r41 = 3 * p23[t33];
        for (let t34 = 0; t34 < 3; t34++)
          a28.push(c33[e44 + t34]);
        for (let t34 = 0; t34 < 3; t34++)
          a28.push(c33[e44 + t34] + m23[r41 + t34] * n28);
        if (s32.push(s32.length), s32.push(s32.length), t33 % 3 == 0) {
          Se(c33, u33, t33, Je), Ie(c33, u33, t33, ze, Ye, We), u5(ze, ze, Ye), u5(ze, ze, We), g(ze, ze, 1 / 3);
          for (let e45 = 0; e45 < 3; e45++)
            i20.push(ze[e45]);
          for (let e45 = 0; e45 < 3; e45++)
            i20.push(ze[e45] + Je[e45] * n28);
          l31.push(l31.length), l31.push(l31.length);
        }
      }
    }
    const c32 = t32[0].transformation, u32 = new I2(this._debugVertexNormalMaterial, [[e16.POSITION, new t8(a28, s32, 3, true)]], null, e20.Line);
    t32.push(u32), u32.transformation = c32;
    const m22 = new I2(this._debugFaceNormalMaterial, [[e16.POSITION, new t8(i20, l31, 3, true)]], null, e20.Line);
    m22.transformation = c32, t32.push(m22);
  }
  _createAs3DShape(e42, t32, r39, o27) {
    const n28 = e42.geometry;
    if ("mesh" !== n28.type)
      return null;
    const a28 = this._createGeometryInfo(n28, t32, o27);
    if (null == a28)
      return null;
    const { geometries: s32, objectTransformation: i20 } = a28;
    t19.DRAW_MESH_GEOMETRY_NORMALS && this._addDebugNormals(n28, s32);
    const l31 = new O9({ geometries: s32, layerUid: this._context.layer.uid, graphicUid: o27, isElevationSource: true });
    l31.transformation = i20;
    const c32 = a8(this.symbolLayer, { opacity: this._getLayerOpacity() }), u32 = c32 ? new j10(s32[0].material, [c32], { mergeGeometries: true, hasSlicePlane: this._context.slicePlaneEnabled }) : null, m22 = new g10(this, l31, s32, null, null, p12, r39, u32);
    this._fastUpdateProcessor.onAddGraphic(), m22.needsElevationUpdates = g5(r39.mode), m22.useObjectOriginAsAttachmentOrigin = true, r39.centerPointInElevationSR = this._getCenterPointInElevationSR(l31.transformation);
    const { elevationProvider: f23, renderCoordsHelper: p23 } = this._context, h25 = (e43, t33) => c17(e43, f23, r39, p23, t33);
    return m22.alignedSampledElevation = p12(m22, r39, f23.spatialReference, h25, p23), m22;
  }
  _getCenterPointInElevationSR(e42) {
    const t32 = e13(0, 0, 0, null != this._context.elevationProvider.spatialReference ? this._context.elevationProvider.spatialReference : null);
    return t22([e42[12], e42[13], e42[14]], this._context.renderCoordsHelper.spatialReference, t32), t32;
  }
  _createPositionBuffer(e42, t32) {
    let r39 = e42.vertexAttributes.position;
    const o27 = t32.reprojection === tt2.RENDER ? t32.transformBeforeProject : null;
    if (o27 && (r39 = r9(new Float64Array(r39.length), r39, o27)), t32.reprojection === tt2.NONE)
      return t32.needsBufferCopy ? new Float64Array(r39) : r39;
    const n28 = o27 ? r39 : new Float64Array(r39.length);
    return n3(r39, e42.spatialReference, 0, n28, this._context.renderCoordsHelper.spatialReference, 0, r39.length / 3), n28;
  }
  _createNormalBuffer(e42, t32, r39) {
    let o27 = e42.vertexAttributes.normal;
    if (null == o27)
      return null;
    const n28 = r39.reprojection === tt2.RENDER ? r39.transformBeforeProject : null;
    n28 && (o27 = M3(o27, new Float32Array(o27.length), n28));
    if ("local" === this._context.graphicsCoreOwner.view.viewingMode || r39.reprojection === tt2.NONE)
      return r39.needsBufferCopy && e42.vertexAttributes.normal === o27 ? new Float32Array(o27) : o27;
    const a28 = e42.vertexAttributes.position, s32 = n28 ? o27 : new Float32Array(o27.length);
    return j8(o27, a28, t32, e42.spatialReference, s32);
  }
  _createTangentBuffer(e42, t32, r39) {
    let o27 = e42.vertexAttributes.tangent;
    if (null == o27)
      return null;
    const n28 = r39.reprojection === tt2.RENDER ? r39.transformBeforeProject : null;
    n28 && (o27 = R2(o27, new Float32Array(o27.length), n28));
    if ("local" === this._context.graphicsCoreOwner.view.viewingMode || r39.reprojection === tt2.NONE)
      return r39.needsBufferCopy && e42.vertexAttributes.normal === o27 ? new Float32Array(o27) : o27;
    const a28 = e42.vertexAttributes.position, s32 = n28 ? o27 : new Float32Array(o27.length);
    return h8(o27, a28, t32, e42.spatialReference, s32);
  }
  _createSymbolColorBuffer(e42) {
    var _a, _b;
    if (this._requiresSymbolVertexColors()) {
      const t32 = this._getVertexOpacityAndColor(e42), r39 = e17((_b = (_a = this.symbolLayer) == null ? void 0 : _a.material) == null ? void 0 : _b.colorMixMode), o27 = new Uint8Array(4);
      return r8(t32, r39, o27), o27;
    }
    return null;
  }
  _createBuffers(e42, t32) {
    const r39 = e42.vertexAttributes && e42.vertexAttributes.position;
    if (!r39)
      return this.logger.warn("Mesh geometry must contain position vertex attributes"), null;
    const o27 = e42.vertexAttributes.normal, n28 = e42.vertexAttributes.uv, a28 = e42.vertexAttributes.tangent;
    if (o27 && o27.length !== r39.length)
      return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"), null;
    if (a28 && a28.length / 4 != r39.length / 3)
      return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"), null;
    if (n28 && n28.length / 2 != r39.length / 3)
      return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"), null;
    const s32 = this._computeReprojectionInfo(e42), i20 = this._createPositionBuffer(e42, s32), l31 = He(e42), u32 = this._createSymbolColorBuffer(t32), m22 = this._createNormalBuffer(e42, i20, s32), f23 = this._createTangentBuffer(e42, i20, s32);
    return { positionBuffer: i20, normalBuffer: m22, tangentBuffer: f23, uvBuffer: n28, colorBuffer: l31, symbolColorBuffer: u32, objectTransformation: s32.reprojection === tt2.NONE && s32.objectTransformation ? s32.objectTransformation : this._transformOriginLocal(e42, i20, m22, f23), geometryTransformation: s32.reprojection === tt2.NONE && s32.geometryTransformation ? s32.geometryTransformation : e12() };
  }
  _computeReprojectionInfo(e42) {
    var _a;
    const { vertexSpace: t32 } = e42, r39 = "georeferenced" === t32.type ? G(this._context.renderCoordsHelper.spatialReference, e42.spatialReference) ? tt2.NONE : tt2.RENDER : tt2.NONE;
    if (g3(t32)) {
      const o27 = t32.origin, n28 = e12(), i20 = ((_a = e42.transform) == null ? void 0 : _a.localMatrix) ?? o6;
      if (r39 === tt2.NONE) {
        R(e42.spatialReference, o27, n28, this._context.renderCoordsHelper.spatialReference);
        return { reprojection: r39, objectTransformation: n28, geometryTransformation: r6(i20), needsBufferCopy: false };
      }
      const l31 = q3(e12(), o27);
      return c5(l31, l31, i20), { reprojection: r39, transformBeforeProject: l31, needsBufferCopy: true };
    }
    return { reprojection: r39, needsBufferCopy: true };
  }
  _transformOriginLocal(e42, t32, n28, a28) {
    const s32 = this._context.renderCoordsHelper.spatialReference, l31 = e42.anchor;
    qe[0] = l31.x, qe[1] = l31.y, qe[2] = l31.z ?? 0;
    const u32 = e12();
    return R(e42.spatialReference, qe, u32, s32), h4(Ke, u32), r9(t32, t32, Ke), (n28 || a28) && (n11(Qe, u32), u10(Qe, Qe), n28 && n12(n28, n28, Qe), a28 && n12(a28, a28, Qe, 4)), u32;
  }
  _validateFaces(e42, t32) {
    const r39 = e42.vertexAttributes.position.length / 3, o27 = t32.faces;
    if (o27) {
      let e43 = -1;
      for (let t33 = 0; t33 < o27.length; t33++) {
        const r40 = o27[t33];
        r40 > e43 && (e43 = r40);
      }
      if (r39 <= e43)
        return this.logger.warn(`Vertex index ${e43} is out of bounds of the mesh position buffer`), false;
    } else if (r39 % 3 != 0)
      return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"), false;
    return true;
  }
  _isOutsideClippingArea(e42) {
    var _a;
    if (!this._context.clippingExtent)
      return false;
    const t32 = (_a = e42.vertexAttributes) == null ? void 0 : _a.position;
    if (!t32)
      return false;
    const r39 = this._context.elevationProvider.spatialReference, o27 = G3({ positions: t32, transform: e42.transform, vertexSpace: e42.vertexSpace, inSpatialReference: e42.spatialReference, outSpatialReference: r39 ?? e42.spatialReference, localMode: this._context.stage.viewingMode === l6.Local }), n28 = o27.length / 3;
    return P2(Ze), c4(Ze, o27, 0, n28), !V(Ze, this._context.clippingExtent);
  }
  _createGeometryInfo(e42, t32, r39) {
    if (!F2(e42.spatialReference, this._context.renderCoordsHelper.spatialReference))
      return this.logger.warn("Geometry spatial reference is not compatible with the view"), null;
    if (!this._validateVertexSpace(e42))
      return null;
    if (this._isOutsideClippingArea(e42))
      return null;
    const o27 = this._createBuffers(e42, t32);
    if (null == o27)
      return null;
    const { positionBuffer: n28, uvBuffer: a28, colorBuffer: s32, symbolColorBuffer: i20, normalBuffer: c32, tangentBuffer: u32, objectTransformation: m22, geometryTransformation: f23 } = o27, p23 = Ne(e42), h25 = new Array();
    let d20 = false;
    const g15 = I(ze, m22), x12 = this._context.localOriginFactory.getOrigin(g15);
    for (const l31 of p23) {
      if (!this._validateFaces(e42, l31))
        return null;
      const t33 = Me(e42, l31);
      if (0 === t33.length)
        continue;
      const o28 = Pe(n28, c32, l31, t33);
      o28.didFlipNormals && (d20 = true);
      const m23 = [[e16.POSITION, new t8(n28, t33, 3, true)], [e16.NORMAL, new t8(o28.normals, o28.indices, 3, true)]];
      s32 && m23.push([e16.COLOR, new t8(s32, t33, 4, true)]), i20 && m23.push([e16.SYMBOLCOLOR, new t8(i20, A5(t33.length), 4, true)]), a28 && m23.push([e16.UV0, new t8(a28, t33, 2, true)]), u32 && m23.push([e16.TANGENT, new t8(u32, t33, 4, true)]);
      const p24 = this._context.stage.renderView.getObjectAndLayerIdColor({ graphicUid: r39, layerUid: this._context.layer.uid }), g16 = this._getOrCreateMaterial(e42, l31), _16 = new I2(g16, m23, null, e20.Mesh, p24);
      _16.transformation = f23, _16.localOrigin = x12, h25.push(_16);
    }
    return d20 && this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals."), { geometries: h25, objectTransformation: m22 };
  }
  _updateMaterialParameters(e42) {
    this._materialInfoCache.forEachMaterialInfo(e42), this._fastUpdateProcessor.forEachMaterialInfo(e42), this._fastUpdateProcessor.forEachClonedMaterial((e43, t32) => {
      t32.setParameters(e43.parameters);
    });
  }
  _validateVertexSpace(e42) {
    const { _context: { graphicsCoreOwner: { view: { state: { viewingMode: t32 } } } } } = this, { vertexSpace: r39 } = e42;
    return t32 !== l6.Local || "local" !== r39.type || (this.logger.warn("Displaying a mesh with a local vertex space in a view in local viewing mode is not supported."), false);
  }
  test() {
    return { ...super.test(), materials: this._materialInfoCache.materials };
  }
};
var Re = class {
  constructor(e42, t32, r39) {
    this.normals = e42, this.indices = t32, this.didFlipNormals = r39;
  }
};
function Me(e42, t32) {
  return t32.faces ?? l7(e42.vertexAttributes.position.length / 3);
}
function Pe(e42, t32, r39, o27) {
  switch (r39.shading || "flat") {
    default:
    case "source":
      return Ee(e42, t32, r39, o27);
    case "flat":
      return Ae(e42, o27);
    case "smooth":
      return Oe(e42, o27);
  }
}
function Ae(e42, t32) {
  const r39 = t14(t32.length), o27 = new Array(3 * t32.length);
  for (let n28 = 0; n28 < t32.length; n28 += 3) {
    const a28 = Se(e42, t32, n28, Je);
    for (let e43 = 0; e43 < 3; e43++)
      r39[n28 + e43] = a28[e43], o27[n28 + e43] = n28 / 3;
  }
  return new Re(r39, o27, false);
}
function Ee(e42, t32, r39, o27) {
  if (null == t32)
    return Ae(e42, o27);
  let n28 = false;
  if (!r39.trustSourceNormals)
    for (let a28 = 0; a28 < o27.length; a28 += 3) {
      Se(e42, o27, a28, Je);
      for (let e43 = 0; e43 < 3; e43++) {
        const r40 = 3 * o27[a28 + e43];
        ze[0] = t32[r40], ze[1] = t32[r40 + 1], ze[2] = t32[r40 + 2], P(Je, ze) < 0 && (t32[r40] = -t32[r40], t32[r40 + 1] = -t32[r40 + 1], t32[r40 + 2] = -t32[r40 + 2], n28 = true);
      }
    }
  return new Re(t32, o27, n28);
}
function Oe(e42, t32) {
  const r39 = {};
  for (let a28 = 0; a28 < t32.length; a28 += 3) {
    const o28 = Se(e42, t32, a28, Je);
    for (let e43 = 0; e43 < 3; e43++) {
      const n29 = t32[a28 + e43];
      let s32 = r39[n29];
      s32 || (s32 = { normal: n2(), count: 0 }, r39[n29] = s32), u5(s32.normal, s32.normal, o28), s32.count++;
    }
  }
  const o27 = t14(3 * t32.length), n28 = new Array(3 * t32.length);
  for (let a28 = 0; a28 < t32.length; a28++) {
    const e43 = r39[t32[a28]];
    1 !== e43.count && (z(e43.normal, e43.normal), e43.count = 1);
    for (let t33 = 0; t33 < 3; t33++)
      o27[3 * a28 + t33] = e43.normal[t33];
    n28[a28] = a28;
  }
  return new Re(o27, n28, false);
}
function Ie(e42, t32, r39, o27, n28, a28) {
  const s32 = 3 * t32[r39], i20 = 3 * t32[r39 + 1], l31 = 3 * t32[r39 + 2];
  o27[0] = e42[s32], o27[1] = e42[s32 + 1], o27[2] = e42[s32 + 2], n28[0] = e42[i20], n28[1] = e42[i20 + 1], n28[2] = e42[i20 + 2], a28[0] = e42[l31], a28[1] = e42[l31 + 1], a28[2] = e42[l31 + 2];
}
function Se(e42, t32, r39, o27) {
  return Ie(e42, t32, r39, ze, Ye, We), e8(Ye, Ye, ze), e8(We, We, ze), _3(ze, Ye, We), z(o27, ze), o27;
}
function Ne(e42) {
  return e42.components ?? et2;
}
function Be(e42) {
  if (!e42)
    return null;
  const { scale: r39, offset: o27, rotation: n28 } = e42;
  return { scale: r39, offset: o27, rotation: h(n28) };
}
function Ue(e42 = "repeat") {
  if ("string" == typeof e42) {
    const t32 = Fe(e42);
    return { s: t32, t: t32 };
  }
  return { s: Fe(e42.horizontal), t: Fe(e42.vertical) };
}
function Fe(e42) {
  switch (e42) {
    case "clamp":
      return D4.CLAMP_TO_EDGE;
    case "mirror":
      return D4.MIRRORED_REPEAT;
    default:
      return D4.REPEAT;
  }
}
function De(e42) {
  const t32 = e42.vertexAttributes.color;
  if (null == t32)
    return false;
  for (let r39 = 3; r39 < t32.length; r39 += 4)
    if (255 !== t32[r39])
      return true;
  return false;
}
function $e(t32, r39) {
  r39.diffuse = u9.toUnitRGB(t32), r39.opacity = t32.a;
}
function Le(e42) {
  return e42.data ?? e42.url;
}
function Ge(t32) {
  return null == t32 ? "-" : t32 instanceof u9 ? t32.toHex() : t32.contentHash;
}
function Ve(e42) {
  const { offset: t32, scale: r39, rotation: o27 } = e42 ?? ke;
  return `${t32[0]},${t32[1]},${o27},${r39[0]},${r39[1]}`;
}
function He(e42) {
  return e42.vertexAttributes.color;
}
var ke = new c10();
var qe = n2();
var ze = n2();
var Ye = n2();
var We = n2();
var Je = n2();
var Ke = e12();
var Qe = e14();
var Xe = e12();
var Ze = i();
var et2 = [new h6()];
var tt2;
!function(e42) {
  e42[e42.NONE = 0] = "NONE", e42[e42.RENDER = 1] = "RENDER";
}(tt2 || (tt2 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DLodInstanceGraphicLayer.js
var p20 = class {
  constructor(e42, t32, i20, n28) {
    this.graphics3DSymbolLayer = e42, this.instanceIndex = t32, this.elevationAligner = i20, this.elevationContext = n28, this.type = "lod-instance", this._highlights = /* @__PURE__ */ new Set(), this.alignedSampledElevation = 0, this.isElevationSource = false, this.needsElevationUpdates = false;
  }
  initialize() {
  }
  setVisibility(e42) {
    const t32 = this._lodRenderer.instanceData;
    e42 !== t32.getVisible(this.instanceIndex) && t32.setVisible(this.instanceIndex, e42);
  }
  destroy() {
    null != this.instanceIndex && (this._lodRenderer.instanceData.removeInstance(this.instanceIndex), this.graphics3DSymbolLayer.notifyDestroyGraphicLayer(this));
  }
  alignWithElevation(e42, t32, i20) {
    if (this.elevationAligner) {
      l14(this.elevationContext.featureExpressionInfoContext, i20);
      const n28 = (i21, n29) => c17(i21, e42, this.elevationContext, t32, n29), s32 = this.elevationAligner(this, this.elevationContext, e42.spatialReference, n28, t32);
      null != s32 && (this.alignedSampledElevation = s32);
    }
  }
  getCenterObjectSpace(e42 = n2()) {
    return this._lodRenderer.instanceData.getCombinedLocalTransform(this.instanceIndex, I10), O2(e42, this._lodRenderer.baseBoundingSphere.center, I10);
  }
  getBoundingBoxObjectSpace(e42 = i()) {
    this._lodRenderer.instanceData.getCombinedLocalTransform(this.instanceIndex, I10);
    const n28 = this._lodRenderer.baseBoundingBox;
    P2(e42);
    for (let s32 = 0; s32 < 8; ++s32)
      o2(x7, 1 & s32 ? n28[3] : n28[0], 2 & s32 ? n28[4] : n28[1], 4 & s32 ? n28[5] : n28[2]), O2(x7, x7, I10), h3(e42, x7);
    return e42;
  }
  computeAttachmentOrigin(e42) {
    this._lodRenderer.instanceData.getGlobalTransform(this.instanceIndex, I10), e42.render.origin[0] += I10[12], e42.render.origin[1] += I10[13], e42.render.origin[2] += I10[14], e42.render.num++;
  }
  async getProjectedBoundingBox(e42, i20, n28, a28, r39) {
    const c32 = this.getBoundingBoxObjectSpace(r39), d20 = b13, m22 = w3(c32) ? 1 : d20.length;
    this._lodRenderer.instanceData.getGlobalTransform(this.instanceIndex, I10);
    for (let s32 = 0; s32 < m22; s32++) {
      const e43 = d20[s32];
      x7[0] = c32[e43[0]], x7[1] = c32[e43[1]], x7[2] = c32[e43[2]], O2(x7, x7, I10), u25[3 * s32] = x7[0], u25[3 * s32 + 1] = x7[1], u25[3 * s32 + 2] = x7[2];
    }
    if (!e42(u25, 0, m22))
      return null;
    P2(c32);
    let f23 = null;
    this.calculateRelativeScreenBounds && (f23 = this.calculateRelativeScreenBounds());
    for (let t32 = 0; t32 < 3 * m22; t32 += 3) {
      for (let e43 = 0; e43 < 3; e43++)
        c32[e43] = Math.min(c32[e43], u25[t32 + e43]), c32[e43 + 3] = Math.max(c32[e43 + 3], u25[t32 + e43]);
      f23 && n28.push({ location: u25.slice(t32, t32 + 3), screenSpaceBoundingRect: f23 });
    }
    if (i20 && (E(c32, v8), "absolute-height" !== this.elevationContext.mode)) {
      let e43;
      const t32 = k5(c32, i20.service.spatialReference, i20);
      try {
        e43 = await i20.service.queryElevation(v8[0], v8[1], a28, t32, "ground");
      } catch (p23) {
      }
      null != e43 && Y(c32, 0, 0, -this.alignedSampledElevation + e43);
    }
    return c32;
  }
  addObjectState(e42, t32) {
    if (e42 === t11.Highlight) {
      const i20 = new r10(e42);
      this._addHighlightId(i20), t32.addExternal((e43) => {
        this._removeHighlightId(e43);
      }, i20);
    }
  }
  removeObjectState(e42) {
    this._highlights.forEach((t32) => e42.remove(t32));
  }
  _addHighlightId(e42) {
    this._highlights.add(e42), this._lodRenderer.instanceData.setHighlight(this.instanceIndex, true);
  }
  _removeHighlightId(e42) {
    this._highlights.delete(e42), this._lodRenderer.instanceData.setHighlight(this.instanceIndex, this._highlights.size > 0);
  }
  get _lodRenderer() {
    return this.graphics3DSymbolLayer.lodRenderer;
  }
};
var u25 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
var x7 = n2();
var v8 = n2();
var b13 = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]];
var I10 = e12();

// node_modules/@arcgis/core/views/3d/layers/graphics/lodResourceUtils.js
function n21(e42, n28) {
  const r39 = e42.stageResources.geometries.map((t32) => new s18(t32, e42.stageResources.textures)), u32 = null == e42.lodThreshold || 0 === e42.lodThreshold && n28 > 0 ? s28(r39) : e42.lodThreshold;
  return new r23(r39, u32, e42.pivotOffset);
}
function r33(o27) {
  return new n17(o27.map((e42, o28) => n21(e42, o28)));
}
function s28(e42) {
  const o27 = e42.reduce((e43, { geometry: o28 }) => e43 + o28.indexCount / 3, 0);
  return Math.sqrt(o27 * u26 / Math.PI);
}
var u26 = 20;

// node_modules/@arcgis/core/views/3d/layers/graphics/webStyleUtils.js
async function r34(r39) {
  var _a;
  if (null === r39 || null == r39.styleName && null == r39.styleUrl)
    return null;
  const o27 = r39.name;
  if (null == o27)
    throw new s2("symbolstyleutils:style-symbol-reference-name-missing", "Missing name in style symbol reference");
  const u32 = { portal: r39.portal }, i20 = await c7(r39, u32).catch(() => null);
  if (null === i20)
    return null;
  const m22 = j4(o27, i20.data);
  if (m22 && !((_a = m22.formatInfos) == null ? void 0 : _a.some((l31) => "gltf_basisu" === l31.type)))
    return null;
  const a28 = await h5(i20, o27, u32, "webRef", (l31, t32) => d3(l31, t32, ["gltf_basisu", "gltf"])).catch(() => null);
  if (null === a28 || "point-3d" !== a28.type)
    return null;
  const y10 = a28.symbolLayers.items[0];
  return "object" === y10.type ? y10.resource : null;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/BackedBufferObject.js
var r35 = class {
  constructor(r39, i20, s32) {
    this._elementSize = i20, this._buffer = h9.createVertex(r39, F4.STATIC_DRAW), this.resize(s32);
  }
  destroy() {
    this._buffer.dispose();
  }
  get elementSize() {
    return this._elementSize;
  }
  get capacity() {
    return this._capacity;
  }
  get array() {
    return this._array;
  }
  get buffer() {
    return this._buffer;
  }
  get usedMemory() {
    return this._array.byteLength + this._buffer.usedMemory;
  }
  copyRange(e42, t32, r39, i20 = 0) {
    const s32 = new Uint8Array(this.array, e42 * this.elementSize, (t32 - e42) * this.elementSize);
    new Uint8Array(r39.array, i20 * this.elementSize).set(s32);
  }
  transferAll() {
    this._buffer.setData(this._array);
  }
  transferRange(e42, t32) {
    const r39 = e42 * this._elementSize, i20 = t32 * this._elementSize;
    this._buffer.setSubData(new Uint8Array(this._array), r39, r39, i20);
  }
  resize(e42) {
    const t32 = e42 * this._elementSize, r39 = new ArrayBuffer(t32);
    this._array && (e42 >= this._capacity ? new Uint8Array(r39).set(new Uint8Array(this._array)) : new Uint8Array(r39).set(new Uint8Array(this._array).subarray(0, e42 * this._elementSize))), this._array = r39, this._buffer.setSize(t32), this._capacity = e42;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/RenderInstanceData.js
var c25 = class {
  constructor(t32) {
    this.modelOriginHi = t32.getField(e16.INSTANCEMODELORIGINHI, i6), this.modelOriginLo = t32.getField(e16.INSTANCEMODELORIGINLO, i6), this.model = t32.getField(e16.INSTANCEMODEL, l10), this.modelNormal = t32.getField(e16.INSTANCEMODELNORMAL, l10), this.featureAttribute = t32.getField(e16.INSTANCEFEATUREATTRIBUTE, c11), this.color = t32.getField(e16.INSTANCECOLOR, x4), this.objectAndLayerIdColor = t32.getField(e16.INSTANCEOBJECTANDLAYERIDCOLOR, x4);
  }
};
var f17 = class {
  constructor(t32, i20) {
    this._rctx = t32, this._instanceBufferLayout = i20, this._headIndex = 0, this._tailIndex = 0, this._firstIndex = null, this._captureFirstIndex = true, this._updating = false, this._prevHeadIndex = 0, this._resized = false, this._capacity = 1;
  }
  destroy() {
    this._buffer && this._buffer.destroy();
  }
  get buffer() {
    return this._buffer.buffer;
  }
  get view() {
    return this._view;
  }
  get capacity() {
    return this._capacity;
  }
  get size() {
    const t32 = this._headIndex, i20 = this._tailIndex;
    return t32 >= i20 ? t32 - i20 : t32 + this._capacity - i20;
  }
  get isEmpty() {
    return this._headIndex === this._tailIndex;
  }
  get isFull() {
    return this._tailIndex === (this._headIndex + 1) % this._capacity;
  }
  get headIndex() {
    return this._headIndex;
  }
  get tailIndex() {
    return this._tailIndex;
  }
  get firstIndex() {
    return this._firstIndex;
  }
  get usedMemory() {
    var _a;
    return ((_a = this._buffer) == null ? void 0 : _a.usedMemory) ?? 0;
  }
  reset() {
    this._headIndex = 0, this._tailIndex = 0, this._firstIndex = null;
  }
  startUpdateCycle() {
    this._captureFirstIndex = true;
  }
  beginUpdate() {
    s13(!this._updating, "already updating"), this._updating = true, this._prevHeadIndex = this._headIndex;
  }
  endUpdate() {
    s13(this._updating, "not updating"), this.size < r * this.capacity && this._shrink(), this._resized ? (this._buffer.transferAll(), this._resized = false) : this._transferRange(this._prevHeadIndex, this._headIndex), this._updating = false;
  }
  allocateHead() {
    s13(this._updating, "not updating"), this.isFull && this._grow();
    const t32 = this.headIndex;
    return this._captureFirstIndex && (this._firstIndex = t32, this._captureFirstIndex = false), this._incrementHead(), s13(this._headIndex !== this._tailIndex, "invalid pointers"), t32;
  }
  freeTail() {
    s13(this._updating, "not updating"), s13(this.size > 0, "invalid size");
    const t32 = this._tailIndex === this._firstIndex;
    this._incrementTail(), t32 && (this._firstIndex = this._tailIndex);
  }
  _grow() {
    const t32 = Math.max(u27, Math.floor(this._capacity * t));
    this._resize(t32);
  }
  _shrink() {
    const t32 = Math.max(u27, Math.floor(this._capacity * e2));
    this._resize(t32);
  }
  _resize(t32) {
    if (s13(this._updating, "not updating"), t32 === this._capacity)
      return;
    const i20 = new r35(this._rctx, this._instanceBufferLayout.stride, t32);
    if (this._buffer) {
      this._firstIndex && (this._firstIndex = (this._firstIndex + this._capacity - this._tailIndex) % this._capacity);
      const t33 = this.size, e42 = this._compactInstances(i20);
      s13(e42 === t33, "invalid compaction"), this._buffer.destroy(), this._tailIndex = 0, this._headIndex = e42, this._prevHeadIndex = 0;
    }
    this._resized = true, this._capacity = t32, this._buffer = i20, this._view = new c25(this._instanceBufferLayout.createView(this._buffer.array));
  }
  _compactInstances(t32) {
    const i20 = this._headIndex, e42 = this._tailIndex;
    return e42 < i20 ? (this._buffer.copyRange(e42, i20, t32), i20 - e42) : e42 > i20 ? (this._buffer.copyRange(e42, this._capacity, t32), i20 > 0 && this._buffer.copyRange(0, i20, t32, this._capacity - e42), i20 + (this._capacity - e42)) : 0;
  }
  _incrementHead(t32 = 1) {
    this._headIndex = (this._headIndex + t32) % this._capacity;
  }
  _incrementTail(t32 = 1) {
    this._tailIndex = (this._tailIndex + t32) % this._capacity;
  }
  _transferRange(t32, i20) {
    t32 < i20 ? this._buffer.transferRange(t32, i20) : t32 > i20 && (i20 > 0 && this._buffer.transferRange(0, i20), this._buffer.transferRange(t32, this._capacity));
  }
};
var u27 = 64;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/InstanceData.js
var M6;
function C3(t32) {
  let e42 = H2().mat4f64(e16.LOCALTRANSFORM).mat4f64(e16.GLOBALTRANSFORM).vec4f64(e16.BOUNDINGSPHERE).vec3f64(e16.MODELORIGIN).mat3f(e16.INSTANCEMODEL).mat3f(e16.INSTANCEMODELNORMAL).vec2f(e16.MODELSCALEFACTORS);
  return t32.includes(e16.FEATUREATTRIBUTE) && (e42 = e42.vec4f(e16.FEATUREATTRIBUTE)), t32.includes(e16.COLOR) && (e42 = e42.vec4u8(e16.COLOR)), t32.includes(e16.OBJECTANDLAYERIDCOLOR) && (e42 = e42.vec4u8(e16.OBJECTANDLAYERIDCOLOR)), e42 = e42.u8(e16.STATE).u8(e16.LODLEVEL), e42;
}
!function(t32) {
  t32[t32.ALLOCATED = 1] = "ALLOCATED", t32[t32.DEFAULT_ACTIVE = 2] = "DEFAULT_ACTIVE", t32[t32.VISIBLE = 4] = "VISIBLE", t32[t32.HIGHLIGHT = 8] = "HIGHLIGHT", t32[t32.HIGHLIGHT_ACTIVE = 16] = "HIGHLIGHT_ACTIVE", t32[t32.REMOVE = 32] = "REMOVE", t32[t32.TRANSFORM_CHANGED = 64] = "TRANSFORM_CHANGED", t32[t32.ACTIVE = 18] = "ACTIVE";
}(M6 || (M6 = {}));
var R7 = class {
  constructor(t32) {
    this.localTransform = t32.getField(e16.LOCALTRANSFORM, b5), this.globalTransform = t32.getField(e16.GLOBALTRANSFORM, b5), this.modelOrigin = t32.getField(e16.MODELORIGIN, T2), this.model = t32.getField(e16.INSTANCEMODEL, l10), this.modelNormal = t32.getField(e16.INSTANCEMODELNORMAL, l10), this.modelScaleFactors = t32.getField(e16.MODELSCALEFACTORS, u13), this.boundingSphere = t32.getField(e16.BOUNDINGSPHERE, h7), this.featureAttribute = t32.getField(e16.FEATUREATTRIBUTE, c11), this.color = t32.getField(e16.COLOR, x4), this.objectAndLayerIdColor = t32.getField(e16.OBJECTANDLAYERIDCOLOR, x4), this.state = t32.getField(e16.STATE, d7), this.lodLevel = t32.getField(e16.LODLEVEL, d7);
  }
};
var b14 = class extends S2 {
  constructor(t32, e42) {
    super(t32), this.events = new o(), this._capacity = 0, this._size = 0, this._next = 0, this._layout = C3(e42), this._capacity = u27, this._buffer = this._layout.createBuffer(this._capacity), this._view = new R7(this._buffer);
  }
  get capacity() {
    return this._capacity;
  }
  get size() {
    return this._size;
  }
  get view() {
    return this._view;
  }
  addInstance() {
    this._size + 1 > this._capacity && this._grow();
    const t32 = this._findSlot();
    return this._view.state.set(t32, M6.ALLOCATED), this._size++, this.events.emit("instances-changed"), t32;
  }
  removeInstance(t32) {
    const e42 = this._view.state;
    s13(t32 >= 0 && t32 < this._capacity && !!(e42.get(t32) & M6.ALLOCATED), "invalid instance handle"), this._getStateFlag(t32, M6.ACTIVE) ? this._setStateFlags(t32, M6.REMOVE) : this.freeInstance(t32), this.events.emit("instances-changed");
  }
  freeInstance(t32) {
    const e42 = this._view.state;
    s13(t32 >= 0 && t32 < this._capacity && !!(e42.get(t32) & M6.ALLOCATED), "invalid instance handle"), e42.set(t32, 0), this._size--;
  }
  setLocalTransform(t32, e42, s32 = true) {
    this._view.localTransform.setMat(t32, e42), s32 && this.updateModelTransform(t32);
  }
  getLocalTransform(t32, e42) {
    this._view.localTransform.getMat(t32, e42);
  }
  setGlobalTransform(t32, e42, s32 = true) {
    this._view.globalTransform.setMat(t32, e42), s32 && this.updateModelTransform(t32);
  }
  getGlobalTransform(t32, e42) {
    this._view.globalTransform.getMat(t32, e42);
  }
  updateModelTransform(t32) {
    const e42 = this._view, s32 = y6, i20 = D7;
    e42.localTransform.getMat(t32, N2), e42.globalTransform.getMat(t32, V5);
    const a28 = c5(V5, V5, N2);
    o2(s32, a28[12], a28[13], a28[14]), e42.modelOrigin.setVec(t32, s32), n11(i20, a28), e42.model.setMat(t32, i20);
    const r39 = g2(y6, a28);
    r39.sort(), e42.modelScaleFactors.set(t32, 0, r39[1]), e42.modelScaleFactors.set(t32, 1, r39[2]), s10(i20, i20), u10(i20, i20), e42.modelNormal.setMat(t32, i20), this._setStateFlags(t32, M6.TRANSFORM_CHANGED), this.events.emit("instance-transform-changed", { index: t32 });
  }
  getModelTransform(t32, e42) {
    const s32 = this._view;
    s32.model.getMat(t32, D7), s32.modelOrigin.getVec(t32, y6), e42[0] = D7[0], e42[1] = D7[1], e42[2] = D7[2], e42[3] = 0, e42[4] = D7[3], e42[5] = D7[4], e42[6] = D7[5], e42[7] = 0, e42[8] = D7[6], e42[9] = D7[7], e42[10] = D7[8], e42[11] = 0, e42[12] = y6[0], e42[13] = y6[1], e42[14] = y6[2], e42[15] = 1;
  }
  applyShaderTransformation(t32, e42) {
    null != this.shaderTransformation && this.shaderTransformation.applyTransform(this, t32, e42);
  }
  getCombinedModelTransform(t32, e42) {
    return this.getModelTransform(t32, e42), null != this.shaderTransformation && this.shaderTransformation.applyTransform(this, t32, e42), e42;
  }
  getCombinedLocalTransform(t32, e42) {
    this._view.localTransform.getMat(t32, e42), null != this.shaderTransformation && this.shaderTransformation.applyTransform(this, t32, e42);
  }
  getCombinedMaxScaleFactor(t32) {
    let e42 = this._view.modelScaleFactors.get(t32, 1);
    return null != this.shaderTransformation && (this.shaderTransformation.scaleFactor(y6, this, t32), e42 *= Math.max(y6[0], y6[1], y6[2])), e42;
  }
  getCombinedMedianScaleFactor(t32) {
    let e42 = this._view.modelScaleFactors.get(t32, 0);
    return null != this.shaderTransformation && (this.shaderTransformation.scaleFactor(y6, this, t32), e42 *= w8(y6[0], y6[1], y6[2])), e42;
  }
  getModel(t32, e42) {
    this._view.model.getMat(t32, e42);
  }
  setFeatureAttribute(t32, e42) {
    this._view.featureAttribute.setVec(t32, e42);
  }
  getFeatureAttribute(t32, e42) {
    this._view.featureAttribute.getVec(t32, e42);
  }
  setColor(t32, e42) {
    this._view.color.setVec(t32, e42);
  }
  setObjectAndLayerIdColor(t32, e42) {
    this._view.objectAndLayerIdColor.setVec(t32, e42);
  }
  setVisible(t32, e42) {
    e42 !== this.getVisible(t32) && (this._setStateFlag(t32, M6.VISIBLE, e42), this.events.emit("instance-visibility-changed", { index: t32 }));
  }
  getVisible(t32) {
    return this._getStateFlag(t32, M6.VISIBLE);
  }
  setHighlight(t32, e42) {
    e42 !== this.getHighlight(t32) && (this._setStateFlag(t32, M6.HIGHLIGHT, e42), this.events.emit("instance-highlight-changed"));
  }
  getHighlight(t32) {
    return this._getStateFlag(t32, M6.HIGHLIGHT);
  }
  getState(t32) {
    return this._view.state.get(t32);
  }
  getLodLevel(t32) {
    return this._view.lodLevel.get(t32);
  }
  countFlags(t32) {
    let e42 = 0;
    for (let s32 = 0; s32 < this._capacity; ++s32) {
      this.getState(s32) & t32 && ++e42;
    }
    return e42;
  }
  _setStateFlags(t32, e42) {
    const s32 = this._view.state;
    e42 = s32.get(t32) | e42, s32.set(t32, e42);
  }
  _clearStateFlags(t32, e42) {
    const s32 = this._view.state;
    e42 = s32.get(t32) & ~e42, s32.set(t32, e42);
  }
  _setStateFlag(t32, e42, s32) {
    s32 ? this._setStateFlags(t32, e42) : this._clearStateFlags(t32, e42);
  }
  _getStateFlag(t32, e42) {
    return !!(this._view.state.get(t32) & e42);
  }
  _grow() {
    this._capacity = Math.max(u27, Math.floor(this._capacity * t)), this._buffer = this._layout.createBuffer(this._capacity).copyFrom(this._buffer), this._view = new R7(this._buffer);
  }
  _findSlot() {
    const t32 = this._view.state;
    let e42 = this._next;
    for (; t32.get(e42) & M6.ALLOCATED; )
      e42 = e42 + 1 === this._capacity ? 0 : e42 + 1;
    return this._next = e42 + 1 === this._capacity ? 0 : e42 + 1, e42;
  }
};
function w8(t32, e42, s32) {
  return Math.max(Math.min(t32, e42), Math.min(Math.max(t32, e42), s32));
}
e([y({ constructOnly: true })], b14.prototype, "shaderTransformation", void 0), e([y()], b14.prototype, "_size", void 0), e([y({ readOnly: true })], b14.prototype, "size", null), b14 = e([a3("esri.views.3d.webgl-engine.lib.lodRendering.InstanceData")], b14);
var y6 = n2();
var D7 = e14();
var N2 = e12();
var V5 = e12();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/InstanceOctree.js
var n22 = class extends Y2 {
  constructor(e42, r39) {
    super((t32) => k2(this._instanceData.view.boundingSphere.getVec(t32, this._tmpSphere)), { maximumDepth: 25 }), this._instanceData = e42, this._boundingSphere = r39, this._tmpSphere = w4(), this._tmpMat4 = e12();
  }
  addInstance(t32) {
    const s32 = this._instanceData.view.boundingSphere, i20 = this._instanceData.getCombinedModelTransform(t32, this._tmpMat4);
    O2(Z(this._tmpSphere), this._boundingSphere.center, i20), this._tmpSphere[3] = this._boundingSphere.radius * m4(i20), s32.setVec(t32, this._tmpSphere), this.add([t32]);
  }
  removeInstance(t32) {
    this.remove([t32]);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LevelSelector.js
var e37 = class {
  constructor(e42, i20) {
    this._worldSpaceRadius = e42, this._minScreenSpaceRadii = i20;
  }
  selectLevel(e42, i20, t32) {
    const c32 = t32.computeScreenPixelSizeAt(e42), r39 = this._worldSpaceRadius * i20 / c32;
    let s32 = 0;
    for (let a28 = 1; a28 < this._minScreenSpaceRadii.length; ++a28)
      r39 >= this._minScreenSpaceRadii[a28] && (s32 = a28);
    return s32;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodComponentData.js
var u28 = class {
  constructor(s32, o27) {
    const i20 = s32.renderContext.rctx, n28 = o27.geometry;
    this._materialRepository = s32.materialRepository, n28.material.setParameters({ instancedDoublePrecision: true });
    const u32 = n28.material.createBufferWriter(), f23 = u32.vertexBufferLayout, d20 = u32.elementCount(n28), p23 = f23.createBuffer(d20);
    u32.write(null, null, n28, p23, 0), this.geometry = n28, this.material = n28.material, this.glMaterials = new t24(n28.material, this._materialRepository), this.vertexBufferLayout = f23, this.vbo = h9.createVertex(i20, F4.STATIC_DRAW, p23.buffer), this.vao = new r21(i20, O6, { geometry: t13(f23) }, { geometry: this.vbo }), this.vertexCount = d20;
  }
  destroy() {
    this.glMaterials.dispose(), this.vbo.dispose(), this.vao.dispose();
  }
  get boundingInfo() {
    return this.geometry.boundingInfo;
  }
  get triangleCount() {
    return this.vertexCount / 3;
  }
  intersect(r39, t32, e42, a28, m22, l31, u32, f23) {
    const d20 = this.geometry.id;
    this.material.intersect(this.geometry, r39.transform.transform, r39, e42, a28, (e43, a29, p23, c32, y10) => {
      if (e43 >= 0) {
        if (null != t32 && !t32(r39.rayBegin, r39.rayEnd, e43))
          return;
        const c33 = new s17(l31.layerUid, l31.graphicUid(m22), d20, p23, u32, f23);
        if ((null == r39.results.min.drapedLayerOrder || y10 >= r39.results.min.drapedLayerOrder) && (null == r39.results.min.dist || e43 < r39.results.min.dist) && r39.results.min.set(i11.LOD, c33, e43, a29, r39.transform.transform, y10), r39.options.store !== e28.MIN && (null == r39.results.max.drapedLayerOrder || y10 >= r39.results.max.drapedLayerOrder) && (null == r39.results.max.dist || e43 > r39.results.max.dist) && r39.results.max.set(i11.LOD, c33, e43, a29, r39.transform.transform, y10), r39.options.store === e28.ALL) {
          const t33 = G5(r39.results.min.ray);
          t33.set(i11.LOD, c33, e43, a29, r39.transform.transform, y10), r39.results.all.push(t33);
        }
      }
    });
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodLevel.js
var a24 = class _a {
  static async create(e42, r39, i20) {
    const s32 = await Promise.allSettled(r39.components.map((o27) => e42.controller.schedule(() => new u28(e42, o27), i20))), c32 = s32.map((o27) => "fulfilled" === o27.status ? o27.value : null).filter(k);
    if (c2(i20) || c32.length !== s32.length) {
      c32.forEach((o27) => o27.destroy()), s3(i20);
      for (const o27 of s32)
        if ("rejected" === o27.status)
          throw o27.reason;
    }
    return new _a(r39.minScreenSpaceRadius, c32);
  }
  constructor(o27, n28) {
    this.minScreenSpaceRadius = o27, this.components = n28;
  }
  destroy() {
    this.components.forEach((o27) => o27.destroy());
  }
  intersect(o27, n28, t32, e42, r39, i20, s32) {
    this.components.forEach((c32) => c32.intersect(o27, n28, t32, e42, r39, i20, this.boundingSphere, s32));
  }
  get boundingBox() {
    if (null == this._boundingBox) {
      const o27 = P2();
      this.components.forEach((n28) => {
        null != n28.boundingInfo && (h3(o27, n28.boundingInfo.bbMin), h3(o27, n28.boundingInfo.bbMax));
      }), this._boundingBox = o27;
    }
    return this._boundingBox;
  }
  get boundingSphere() {
    if (null == this._boundingSphere) {
      const o27 = this.boundingBox, n28 = n2();
      E(o27, n28), this._boundingSphere = { center: n28, radius: 0.5 * T(o27) };
    }
    return this._boundingSphere;
  }
  get triangleCount() {
    return this.components.reduce((o27, n28) => o27 + n28.triangleCount, 0);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodRenderer.js
var V6 = (e42) => {
  const t32 = e42.baseBoundingSphere.radius, r39 = e42.levels.map((e43) => e43.minScreenSpaceRadius);
  return new e37(t32, r39);
};
var B4 = class extends p8 {
  constructor(e42, t32) {
    super(e42), this.type = i11.LOD, this.isGround = false, this._levels = [], this._defaultRenderInstanceData = [new Array()], this._highlightRenderInstanceData = [new Array()], this._allRenderInstanceData = [this._defaultRenderInstanceData[0], this._highlightRenderInstanceData[0]], this._instanceIndex = 0, this._cycleStartIndex = 0, this._slicePlane = false, this._camera = new it(), this._updateCyclesWithStaticCamera = -1, this._needFullCycle = false, this.produces = /* @__PURE__ */ new Map([[A8.OPAQUE_MATERIAL, (e43) => this._produces(e43)], [A8.TRANSPARENT_MATERIAL, (e43) => !!this._hasTransparentLevels() && this._produces(e43)]]), this._instanceData = new b14({ shaderTransformation: e42.shaderTransformation }, e42.optionalFields), this.addHandles(t32.registerTask(I3.LOD_RENDERER, this));
  }
  initialize() {
    this._instanceBufferLayout = q7(this.optionalFields), this._glInstanceBufferLayout = t13(this._instanceBufferLayout, 1), this.addHandles([this._instanceData.events.on("instances-changed", () => this._requestUpdateCycle()), this._instanceData.events.on("instance-transform-changed", ({ index: e42 }) => {
      this._requestUpdateCycle(), this.metadata.notifyGraphicGeometryChanged(e42);
    }), this._instanceData.events.on("instance-visibility-changed", ({ index: e42 }) => {
      this._requestUpdateCycle(true), this.metadata.notifyGraphicVisibilityChanged(e42);
    }), this._instanceData.events.on("instance-highlight-changed", () => this._requestUpdateCycle(true))]);
  }
  get _enableLevelSelection() {
    return this.symbol.levels.length > 1;
  }
  get levels() {
    return this._levels;
  }
  get baseBoundingBox() {
    return this._levels[this._levels.length - 1].boundingBox;
  }
  get baseBoundingSphere() {
    return this._levels[this._levels.length - 1].boundingSphere;
  }
  get baseMaterial() {
    return this._levels[this._levels.length - 1].components[0].material;
  }
  get slicePlaneEnabled() {
    return this._slicePlane;
  }
  set slicePlaneEnabled(e42) {
    this._slicePlane = e42;
  }
  get layerUid() {
    return this.metadata.layerUid;
  }
  get instanceData() {
    return this._instanceData;
  }
  get usedMemory() {
    return this._allRenderInstanceData.reduce((e42, t32) => t32.reduce((e43, t33) => e43 + t33.usedMemory, e42), 0);
  }
  get renderStats() {
    const e42 = this._instanceData.size, t32 = [];
    return this._levels.forEach((e43, r39) => {
      const a28 = this._allRenderInstanceData[0][r39].size + this._allRenderInstanceData[1][r39].size, s32 = e43.triangleCount;
      t32.push({ renderedInstances: a28, renderedTriangles: a28 * s32, trianglesPerInstance: s32 });
    }), { totalInstances: e42, renderedInstances: t32.reduce((e43, t33) => e43 + t33.renderedInstances, 0), renderedTriangles: t32.reduce((e43, t33) => e43 + t33.renderedTriangles, 0), levels: t32 };
  }
  async initializeRenderContext(e42, r39) {
    this._context = e42;
    const n28 = e42.renderContext.rctx, i20 = await Promise.allSettled(this.symbol.levels.map((t32) => (this._defaultRenderInstanceData[0].push(new f17(n28, this._instanceBufferLayout)), this._highlightRenderInstanceData[0].push(new f17(n28, this._instanceBufferLayout)), a24.create(e42, t32, r39)))), o27 = i20.map((e43) => "fulfilled" === e43.status ? e43.value : null).filter(k);
    if (c2(r39) || o27.length !== i20.length) {
      o27.forEach((e43) => e43.destroy()), s3(r39);
      for (const e43 of i20)
        if ("rejected" === e43.status)
          throw e43.reason;
    }
    this._levels = o27, this._levelSelector = V6(this);
  }
  uninitializeRenderContext() {
    this._invalidateOctree(), this._levels.forEach((e42) => e42.destroy()), this._defaultRenderInstanceData[0].forEach((e42) => e42.destroy()), this._highlightRenderInstanceData[0].forEach((e42) => e42.destroy());
  }
  _hasTransparentLevels() {
    return this._levels.some((e42) => e42.components.some((e43) => {
      const t32 = e43.material.produces.get(A8.TRANSPARENT_MATERIAL);
      return t32 && t32(o7.Color);
    }));
  }
  hasHighlights() {
    return this._highlightRenderInstanceData[0].some((e42) => e42.size > 0);
  }
  _produces(e42) {
    return e42 !== o7.Highlight && e42 !== o7.ShadowHighlight || this.hasHighlights();
  }
  prepareRender(e42) {
    if (!t19.LOD_INSTANCE_RENDERER_DISABLE_UPDATES) {
      if (this._enableLevelSelection) {
        const t32 = e42.bindParameters.contentCamera.equals(this._camera);
        this._camera.copyFrom(e42.bindParameters.contentCamera), t32 || this._requestUpdateCycle();
      }
      this._needFullCycle && (this.runTask(C), this._needFullCycle = false);
    }
  }
  prepareTechniques(e42) {
    if (!this.baseMaterial.isVisible() || !this.baseMaterial.isVisibleForOutput(e42.output))
      return null;
    const t32 = this._getInstanceDatas(e42.output);
    if (!t32)
      return null;
    const r39 = new Array();
    return t32.forEach((t33) => this.levels.forEach((a28, s32) => {
      a28.components.forEach((a29) => r39.push(this._beginComponent(e42, t33[s32], a29)));
    })), r39;
  }
  renderNode(e42, t32) {
    const r39 = this._getInstanceDatas(e42.output);
    if (!r39 || null == t32)
      return;
    let a28 = 0;
    e42.rctx.bindVAO(), r39.forEach((r40) => this.levels.forEach((s32, n28) => {
      s32.components.forEach((s33) => this._renderComponent(e42, t32[a28++], r40[n28], s33, n28));
    }));
  }
  _getInstanceDatas(e42) {
    const t32 = e42 !== o7.Highlight && e42 !== o7.ShadowHighlight, r39 = e42 !== o7.ShadowExcludeHighlight;
    return t32 && r39 ? this._allRenderInstanceData : t32 ? this._defaultRenderInstanceData : r39 ? this._highlightRenderInstanceData : null;
  }
  intersect(e42, t32, r39, a28) {
    if (!this.baseMaterial.isVisible() || null == this._octree)
      return;
    const s32 = n2();
    e8(s32, a28, r39);
    const n28 = (s33) => {
      this._instanceData.getCombinedModelTransform(s33, W5), e42.transform.set(W5), O2(K4, r39, e42.transform.inverse), O2(Y5, a28, e42.transform.inverse);
      const n29 = this._instanceData.getState(s33), i20 = this._instanceData.getLodLevel(s33), o27 = this._levels.length;
      s13(!!(n29 & M6.ACTIVE), "invalid instance state"), s13(i20 >= 0 && i20 < o27, "invaid lod level"), this._levels[i20].intersect(e42, t32, K4, Y5, s33, this.metadata, o27);
    };
    this.baseMaterial.parameters.verticalOffset ? this._octree.forEach(n28) : this._octree.forEachAlongRay(r39, s32, n28);
  }
  notifyShaderTransformationChanged() {
    this._invalidateOctree(), this._requestUpdateCycle();
  }
  get _octree() {
    var _a;
    if (null == this._octreeCached) {
      const e42 = this._instanceData, t32 = (_a = e42.view) == null ? void 0 : _a.state;
      if (!t32)
        return null;
      this._octreeCached = new n22(e42, this.baseBoundingSphere);
      for (let r39 = 0; r39 < e42.capacity; ++r39)
        t32.get(r39) & M6.ACTIVE && this._octreeCached.addInstance(r39);
    }
    return this._octreeCached;
  }
  _invalidateOctree() {
    this._octreeCached = u(this._octreeCached);
  }
  queryDepthRange(e42) {
    if (null == this._octree)
      return { near: 1 / 0, far: -1 / 0 };
    const t32 = e42.viewForward, r39 = this._octree.findClosest(t32, Y2.DepthOrder.FRONT_TO_BACK, e42.frustum), a28 = this._octree.findClosest(t32, Y2.DepthOrder.BACK_TO_FRONT, e42.frustum);
    if (null == r39 || null == a28)
      return { near: 1 / 0, far: -1 / 0 };
    const s32 = e42.eye, n28 = this._instanceData.view;
    n28.boundingSphere.getVec(r39, k8), e8(k8, k8, s32);
    const i20 = P(k8, t32) - k8[3];
    n28.boundingSphere.getVec(a28, k8), e8(k8, k8, s32);
    const o27 = P(k8, t32) + k8[3];
    return { near: Math.max(e42.near, i20), far: Math.min(e42.far, o27) };
  }
  _requestUpdateCycle(e42 = false) {
    this._updateCyclesWithStaticCamera = -1, this._cycleStartIndex = this._instanceIndex, e42 && (this._needFullCycle = true, this._context.requestRender());
  }
  _startUpdateCycle() {
    this._updateCyclesWithStaticCamera++, this._allRenderInstanceData.forEach((e42) => e42.forEach((e43) => e43.startUpdateCycle()));
  }
  get running() {
    return this._instanceData.size > 0 && this._updateCyclesWithStaticCamera < 1;
  }
  runTask(e42) {
    const { _enableLevelSelection: t32, _camera: r39, _levelSelector: a28 } = this;
    this._allRenderInstanceData.forEach((e43) => e43.forEach((e44) => e44.beginUpdate()));
    const s32 = this._instanceData, n28 = s32.view;
    let i20 = s32.size;
    const o27 = s32.capacity;
    let l31 = this._instanceIndex;
    const c32 = Math.ceil(o27 / 500);
    for (let h25 = 0; h25 < i20 && !e42.done; ++h25) {
      l31 === this._cycleStartIndex && this._startUpdateCycle();
      const h26 = n28.state.get(l31);
      let d20 = 0;
      if (!(h26 & M6.ALLOCATED)) {
        l31 = l31 + 1 === o27 ? 0 : l31 + 1, i20++;
        continue;
      }
      const u32 = n28.lodLevel.get(l31);
      if (h26 & M6.DEFAULT_ACTIVE && this._defaultRenderInstanceData[0][u32].freeTail(), h26 & M6.HIGHLIGHT_ACTIVE && this._highlightRenderInstanceData[0][u32].freeTail(), h26 & M6.REMOVE)
        s32.freeInstance(l31);
      else if (h26 & M6.VISIBLE) {
        let e43 = 0;
        t32 && (n28.modelOrigin.getVec(l31, z4), e43 = a28.selectLevel(z4, s32.getCombinedMedianScaleFactor(l31), r39)), d20 = h26 & ~(M6.ACTIVE | M6.TRANSFORM_CHANGED), e43 >= 0 && (h26 & M6.HIGHLIGHT ? (P6(this._highlightRenderInstanceData[0][e43], n28, l31), d20 |= M6.HIGHLIGHT_ACTIVE) : (P6(this._defaultRenderInstanceData[0][e43], n28, l31), d20 |= M6.DEFAULT_ACTIVE)), n28.state.set(l31, d20), n28.lodLevel.set(l31, e43);
      } else
        d20 = h26 & ~(M6.ACTIVE | M6.TRANSFORM_CHANGED), n28.state.set(l31, d20);
      if (null != this._octreeCached) {
        const e43 = !!(h26 & M6.ACTIVE), t33 = !!(d20 & M6.ACTIVE);
        !e43 && t33 ? this._octreeCached.addInstance(l31) : e43 && !t33 ? this._octreeCached.removeInstance(l31) : e43 && t33 && h26 & M6.TRANSFORM_CHANGED && (this._octreeCached.removeInstance(l31), this._octreeCached.addInstance(l31));
      }
      l31 = l31 + 1 === o27 ? 0 : l31 + 1, l31 % c32 == 0 && e42.madeProgress();
    }
    this._instanceIndex = l31, this._allRenderInstanceData.forEach((e43) => e43.forEach((e44) => e44.endUpdate())), this._context.requestRender();
  }
  _beginComponent(e42, t32, r39) {
    if (0 === t32.size)
      return null;
    const a28 = r39.glMaterials.load(e42.rctx, e42.bindParameters.slot, e42.output);
    return null != a28 ? a28.beginSlot(e42.bindParameters) : null;
  }
  _renderComponent(e42, t32, r39, a28, s32) {
    if (!t32)
      return;
    const { bindParameters: n28, rctx: i20 } = e42;
    i20.runAppleAmdDriverHelper();
    const o27 = i20.bindTechnique(t32, n28, a28.material.parameters, Q4);
    i20.bindVAO(a28.vao), t32.ensureAttributeLocations(a28.vao), t19.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL && e42.output === o7.Color && (o27.setUniform4fv("externalColor", J3[Math.min(s32, J3.length - 1)]), o27.setUniform1i("colorMixMode", c14.replace));
    const l31 = r39.capacity, c32 = r39.headIndex, h25 = r39.tailIndex, d20 = r39.firstIndex, u32 = this._glInstanceBufferLayout, m22 = (e43, s33) => {
      E4(i20, O6, r39.buffer, u32, e43), i20.drawArraysInstanced(t32.primitiveType, 0, a28.vertexCount, s33 - e43), _5(i20, O6, r39.buffer, u32);
    };
    a28.material.parameters.transparent && null != d20 ? c32 > h25 ? (s13(d20 >= h25 && d20 <= c32, "invalid firstIndex"), m22(d20, c32), m22(h25, d20)) : c32 < h25 && (d20 <= c32 ? (s13(d20 >= 0 && d20 <= c32, "invalid firstIndex"), m22(d20, c32), m22(h25, l31), m22(0, d20)) : (s13(d20 >= h25 && d20 <= l31, "invalid firstIndex"), m22(d20, l31), m22(0, c32), m22(h25, d20))) : c32 > h25 ? m22(h25, c32) : c32 < h25 && (m22(0, c32), m22(h25, l31)), i20.bindVAO(null);
  }
};
function P6(e42, t32, r39) {
  const a28 = e42.allocateHead();
  G10(t32, r39, e42.view, a28);
}
function G10(e42, t32, r39, a28) {
  l8(e42.modelOrigin, t32, r39.modelOriginHi, r39.modelOriginLo, a28), r39.model.copyFrom(a28, e42.model, t32), r39.modelNormal.copyFrom(a28, e42.modelNormal, t32), e42.color && r39.color && r39.color.copyFrom(a28, e42.color, t32), e42.objectAndLayerIdColor && r39.objectAndLayerIdColor && r39.objectAndLayerIdColor.copyFrom(a28, e42.objectAndLayerIdColor, t32), e42.featureAttribute && r39.featureAttribute && r39.featureAttribute.copyFrom(a28, e42.featureAttribute, t32);
}
function q7(e42) {
  let t32 = H2().vec3f(e16.INSTANCEMODELORIGINHI).vec3f(e16.INSTANCEMODELORIGINLO).mat3f(e16.INSTANCEMODEL).mat3f(e16.INSTANCEMODELNORMAL);
  return null != e42 && e42.includes("featureAttribute") && (t32 = t32.vec4f(e16.INSTANCEFEATUREATTRIBUTE)), null != e42 && e42.includes("color") && (t32 = t32.vec4u8(e16.INSTANCECOLOR)), null != e42 && e42.includes("objectAndLayerIdColor") && (t32 = t32.vec4u8(e16.INSTANCEOBJECTANDLAYERIDCOLOR)), t32;
}
e([y({ constructOnly: true })], B4.prototype, "symbol", void 0), e([y({ constructOnly: true })], B4.prototype, "optionalFields", void 0), e([y({ constructOnly: true })], B4.prototype, "metadata", void 0), e([y({ constructOnly: true })], B4.prototype, "shaderTransformation", void 0), e([y()], B4.prototype, "_instanceData", void 0), e([y()], B4.prototype, "_cycleStartIndex", void 0), e([y({ readOnly: true })], B4.prototype, "_enableLevelSelection", null), e([y()], B4.prototype, "_updateCyclesWithStaticCamera", void 0), e([y({ readOnly: true })], B4.prototype, "running", null), B4 = e([a3("esri.views.3d.webgl-engine.lib.lodRendering.LodRenderer")], B4);
var z4 = n2();
var k8 = n6();
var W5 = e12();
var K4 = n2();
var Y5 = n2();
var J3 = [r5(1, 0, 1, 1), r5(0, 0, 1, 1), r5(0, 1, 0, 1), r5(1, 1, 0, 1), r5(1, 0, 0, 1)];
var Q4 = new k4();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObjectSymbolLayer.js
var me2 = class {
  constructor(e42, t32, s32, r39, i20, a28, o27, n28, l31, c32, h25, d20) {
    this.lodResources = e42, this.lodRenderer = t32, this.stageResources = s32, this.originalMaterialParameters = r39, this.resourceSize = i20, this.isEsriSymbolResource = a28, this.isWosr = o27, this.resourceBoundingBox = n28, this.symbolSize = l31, this.extentPadding = c32, this.physicalBasedRenderingEnabled = h25, this.pivotOffset = d20;
  }
};
var pe2 = class extends h13 {
  getCachedSize() {
    const [e42, t32, s32] = null != this._resources ? this._resources.symbolSize : [1, 1, 1];
    return { width: e42, depth: t32, height: s32 };
  }
  constructor(e42, t32, s32, r39) {
    super(e42, t32, s32, r39), this._resources = null, this._optionalFields = new Array(), this._instanceIndexToGraphicUid = /* @__PURE__ */ new Map(), this._hasLoadedPBRTextures = false, this._disposeResourceHandles = new Array(), this.skipHighSymbolLodsChanged = false, this.ensureDrapedStatus(false), this._hasLoadedPBRTextures = s32.physicalBasedRenderingEnabled;
  }
  async doLoad(e42) {
    if (!this._drivenProperties.size) {
      if (I6(this.symbolLayer))
        throw new Error();
    }
    if (this._isPrimitive) {
      const t32 = this.symbolLayer.resource, s32 = t32 && d10(t32.primitive) ? t32.primitive : d2;
      this._resources = await this._createResourcesForPrimitive(s32, e42);
    } else {
      const t32 = await r34(this.symbol.styleOrigin), s32 = (t32 == null ? void 0 : t32.href) ?? this.symbolLayer.resource.href;
      this._resources = await this._createResourcesForUrl(s32, e42);
    }
    this.layerOpacityChanged(), this.slicePlaneEnabledChanged(), this.physicalBasedRenderingChanged(), this.complexity = this.computeComplexity();
  }
  get extentPadding() {
    return null != this._resources ? this._resources.extentPadding : 0;
  }
  get _isPrimitive() {
    var _a;
    return !((_a = this.symbolLayer.resource) == null ? void 0 : _a.href);
  }
  get lodRenderer() {
    var _a;
    return (_a = this._resources) == null ? void 0 : _a.lodRenderer;
  }
  get materials() {
    var _a;
    return ((_a = this._resources) == null ? void 0 : _a.stageResources.materials) ?? [];
  }
  _setMaterialTransparencyParameters(e42, t32 = ((_b) => (_b = ((_a) => (_a = this.symbolLayer) == null ? void 0 : _a.material)()) == null ? void 0 : _b.color)()) {
    const s32 = this._getCombinedOpacity(t32), r39 = s32 < 1 || this.needsDrivenTransparentPass;
    return e42.transparent = r39, e42.opacity = s32, e42.cullFace = r39 ? e21.None : e21.Back, e42;
  }
  async _createResourcesForPrimitive(t32, r39) {
    const i20 = this.symbolLayer, a28 = i(c6(t32)), o27 = e6(F(a28)), n28 = e6(t4(o27, i20)), l31 = s5(n28), h25 = false, d20 = false, m22 = { usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true, mrrFactors: [...t18], ambient: _2, diffuse: _2, hasSlicePlane: this._context.slicePlaneEnabled, hasSliceHighlight: false, castShadows: this.symbolLayer.castShadows, offsetTransparentBackfaces: !this.symbolLayer.isPrimitive }, p23 = !!m22.usePBR;
    this._setMaterialTransparencyParameters(m22);
    const u32 = this.symbol;
    if ("point-3d" === u32.type && u32.verticalOffset) {
      const { screenLength: e42, minWorldLength: t33, maxWorldLength: r40 } = u32.verticalOffset;
      m22.verticalOffset = { screenLength: u8(e42), minWorldLength: t33 || 0, maxWorldLength: null != r40 ? r40 : 1 / 0 }, m22.castShadows = false;
    }
    if (this._context.screenSizePerspectiveEnabled && (m22.screenSizePerspective = this._context.sharedResources.screenSizePerspectiveSettings), this._drivenProperties.color)
      m22.externalColor = s7;
    else {
      const t33 = null != i20.material ? i20.material.color : null, s32 = null != t33 ? u9.toUnitRGBA(t33) : s7;
      m22.externalColor = s32;
    }
    this._fastUpdates = O8(this._context.renderer, this._fastVisualVariableConvertOptions(a28, n28, o27, null)), m22.isInstanced = true, this._fastUpdates ? (Object.assign(m22, this._fastUpdates.materialParameters), this._optionalFields.push(e16.FEATUREATTRIBUTE)) : this._hasPerInstanceColor() && (m22.hasInstancedColor = true, this._optionalFields.push(e16.COLOR)), has("enable-feature:objectAndLayerId-rendering") && this._optionalFields.push(e16.OBJECTANDLAYERIDCOLOR);
    const _16 = new E7(m22), g15 = S9(t32, _16);
    if (!g15)
      throw new Error(`Unknown object symbol primitive: ${t32}`);
    const b18 = c19(g15).map((e42) => ({ opacity: 1, transparent: e42.parameters.transparent })), R11 = await this._createStageResources(g15, p23, r39), x12 = await this._createLodRenderer(g15, r39);
    return new me2(g15, x12, R11, b18, o27, h25, d20, a28, n28, l31, p23, null);
  }
  async _createResourcesForUrl(e42, t32) {
    var _a, _b;
    const r39 = { materialParameters: { isInstanced: true, hasSlicePlane: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows }, streamDataRequester: this._context.streamDataRequester, cache: this._context.sharedResources.objectResourceCache };
    this._fastUpdates = O8(this._context.renderer, this._fastVisualVariableConvertOptions(null, null, null, null)), this._fastUpdates ? (Object.assign(r39.materialParameters, this._fastUpdates.materialParameters), this._optionalFields.push(e16.FEATUREATTRIBUTE)) : this._hasPerInstanceColor() && (r39.materialParameters.hasInstancedColor = true, this._optionalFields.push(e16.COLOR)), has("enable-feature:objectAndLayerId-rendering") && this._optionalFields.push(e16.OBJECTANDLAYERIDCOLOR);
    const i20 = this.symbol;
    if ("point-3d" === i20.type && i20.verticalOffset) {
      const { screenLength: e43, minWorldLength: t33, maxWorldLength: a29 } = i20.verticalOffset;
      r39.materialParameters.verticalOffset = { screenLength: u8(e43), minWorldLength: t33 || 0, maxWorldLength: null != a29 ? a29 : 1 / 0 }, r39.materialParameters.castShadows = false;
    }
    const a28 = this._context.physicalBasedRenderingEnabled;
    r39.signal = t32, r39.usePBR = a28, r39.skipHighLods = this._context.skipHighSymbolLods;
    const o27 = await Y3(e42, r39), n28 = o27.isEsriSymbolResource, l31 = o27.isWosr, h25 = r33(o27.lods), d20 = this._context, m22 = this.symbolLayer.material, p23 = this._getExternalColorParameters(m22), u32 = (_b = (_a = this.symbolLayer) == null ? void 0 : _a.material) == null ? void 0 : _b.color, f23 = this._getCombinedOpacity(u32, { hasIntrinsicColor: true }), _16 = this.needsDrivenTransparentPass, g15 = c19(h25), b18 = c19(h25).map((e43) => ({ opacity: e43.parameters.opacity || 1, transparent: e43.parameters.transparent }));
    g15.forEach((e43) => {
      const t33 = e43.parameters;
      e43.setParameters(p23);
      const s32 = t33.opacity * f23, r40 = s32 < 1 || _16 || t33.transparent;
      e43.setParameters({ opacity: s32, transparent: r40 }), d20.screenSizePerspectiveEnabled && e43.setParameters({ screenSizePerspective: d20.sharedResources.screenSizePerspectiveSettings });
    });
    const P12 = o27.referenceBoundingBox, R11 = e6(F(P12)), x12 = e6(h25.levels[0].pivotOffset), v13 = e6(t4(R11, this.symbolLayer)), L8 = s5(v13), S21 = this._fastUpdates;
    G4(S21, this._context.renderer, this._fastVisualVariableConvertOptions(P12, v13, R11, x12)) && g15.forEach((e43) => e43.setParameters(S21.materialParameters));
    const j19 = await this._createStageResources(h25, a28, t32), w13 = await this._createLodRenderer(h25, t32);
    return new me2(h25, w13, j19, b18, R11, n28, l31, P12, v13, L8, a28, x12);
  }
  _addDisposeResource(e42) {
    this._disposeResourceHandles.push(e42);
  }
  async _createStageResources(e42, s32, r39) {
    const i20 = this._context.stage, a28 = c19(e42);
    s32 !== this._context.physicalBasedRenderingEnabled && this.physicalBasedRenderingChanged(), i20.addMany(a28), this._addDisposeResource(() => i20.removeMany(a28));
    const o27 = o18(e42);
    i20.addMany(o27), this._addDisposeResource(() => {
      o27.forEach((e43) => e43.unload()), i20.removeMany(o27);
    }), await Promise.all(o27.map((e43) => this._context.stage.schedule(() => e43.load(i20.renderView.renderingContext), r39))), s3(r39);
    const n28 = i12(e42);
    return i20.addMany(n28), this._addDisposeResource(() => i20.removeMany(n28)), { materials: a28, textures: o27, geometries: n28 };
  }
  async _createLodRenderer(e42, t32) {
    const s32 = this._context.stage, r39 = { layerUid: this._context.layer.uid, graphicUid: (e43) => this._instanceIndexToGraphicUid.get(e43), notifyGraphicGeometryChanged: (e43) => this._context.notifyGraphicGeometryChanged(this._instanceIndexToGraphicUid.get(e43)), notifyGraphicVisibilityChanged: (e43) => this._context.notifyGraphicVisibilityChanged(this._instanceIndexToGraphicUid.get(e43)) }, i20 = this._fastUpdates, a28 = i20 ? { applyTransform: (e43, t33, s33) => {
      e43.getFeatureAttribute(t33, be), n4(s33, Q(i20.materialParameters, be, s33));
    }, scaleFactor: (e43, t33, s33) => {
      t33.getFeatureAttribute(s33, be), W2(e43, i20.materialParameters, be);
    } } : null, o27 = new B4({ symbol: e42, optionalFields: this._optionalFields, metadata: r39, shaderTransformation: a28 }, this._context.scheduler);
    return o27.slicePlaneEnabled = this._context.slicePlaneEnabled, this._addDisposeResource(() => {
      s32.removeRenderPlugin(o27), o27.destroy();
    }), await s32.addRenderPlugin(o27, t32), o27;
  }
  _getExternalColorParameters(t32) {
    const s32 = {};
    return this._drivenProperties.color ? s32.externalColor = s7 : null != (t32 == null ? void 0 : t32.color) ? s32.externalColor = u9.toUnitRGBA(t32.color) : (s32.externalColor = s7, s32.colorMixMode = "ignore"), s32;
  }
  destroy() {
    super.destroy(), this._cleanupResources();
  }
  _cleanupResources() {
    this._disposeResourceHandles.forEach((e42) => e42()), this._disposeResourceHandles.length = 0, this._resources = null;
  }
  createGraphics3DGraphic(e42) {
    const t32 = e42.graphic;
    if (!this._validateGeometry(t32.geometry))
      return null;
    const s32 = m13(t32.geometry);
    if (null == s32)
      return this.logger.warn(`unsupported geometry type for icon symbol: ${t32.geometry.type}`), null;
    const r39 = this.setGraphicElevationContext(t32), i20 = e42.renderingInfo;
    return this._createAs3DShape(t32, s32, i20, r39, t32.uid, e42.layer.uid);
  }
  notifyDestroyGraphicLayer(e42) {
    this._instanceIndexToGraphicUid.delete(e42.instanceIndex);
  }
  graphicLayerToGraphicId() {
    return 0;
  }
  layerOpacityChanged() {
    var _a, _b;
    if (null == this._resources)
      return;
    const e42 = this._drivenProperties.opacity, t32 = !this._isPrimitive, s32 = this._resources.stageResources.materials, r39 = this._resources.originalMaterialParameters;
    for (let i20 = 0; i20 < s32.length; i20++) {
      const a28 = s32[i20], o27 = (_b = (_a = this.symbolLayer) == null ? void 0 : _a.material) == null ? void 0 : _b.color, n28 = r39[i20], l31 = this._getCombinedOpacity(o27, { hasIntrinsicColor: t32 }) * n28.opacity, c32 = l31 < 1 || e42 || n28.transparent;
      a28.setParameters({ opacity: l31, transparent: c32 }), this._isPrimitive && a28.setParameters({ cullFace: c32 ? e21.None : e21.Back });
    }
  }
  layerElevationInfoChanged(e42, t32) {
    return this.updateGraphics3DGraphicElevationInfo(e42, t32, g5);
  }
  slicePlaneEnabledChanged() {
    if (null == this._resources)
      return true;
    this._resources.lodRenderer.slicePlaneEnabled = this._context.slicePlaneEnabled;
    for (const e42 of this._resources.stageResources.materials)
      e42.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    return true;
  }
  physicalBasedRenderingChanged() {
    if (null == this._resources)
      return true;
    const { stageResources: e42, isWosr: t32 } = this._resources;
    for (const s32 of e42.materials)
      this._isPrimitive ? s32.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }) : t32 || s32.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: false });
    return false !== this._hasLoadedPBRTextures || true !== this._context.physicalBasedRenderingEnabled || (this._hasLoadedPBRTextures = true, false);
  }
  applyRendererDiff(e42, t32) {
    if (null == this._resources)
      return e33.RecreateSymbol;
    const { stageResources: { materials: s32 }, lodRenderer: r39, resourceBoundingBox: i20, symbolSize: a28, resourceSize: o27, pivotOffset: n28 } = this._resources;
    for (const l31 in e42.diff) {
      if ("visualVariables" !== l31)
        return e33.RecreateSymbol;
      if (!G4(this._fastUpdates, t32, this._fastVisualVariableConvertOptions(i20, a28, o27, n28)))
        return e33.RecreateSymbol;
      for (const e43 of s32)
        e43.setParameters(this._fastUpdates.materialParameters);
      r39.notifyShaderTransformationChanged();
    }
    return e33.FastUpdate;
  }
  computeComplexity() {
    if (null == this._resources)
      return super.computeComplexity();
    const e42 = this._resources.lodResources, t32 = w6(e42.levels), s32 = (e43) => Array.from(e43.attributes.values()).reduce((e44, t33) => e44 + A(t33.data, t33.indices), 0), i20 = i12(e42).reduce((e43, t33) => e43 + s32(t33), 0), a28 = o18(e42).reduce((e43, t33) => e43 + t33.memoryEstimate, 0) + i20, o27 = { ...C2(this.symbol, this.symbolLayer), resourceBytes: a28 };
    return new e32({ verticesPerFeature: t32, memory: o27 });
  }
  _hasLodRenderer() {
    return null != this._resources;
  }
  _createAs3DShape(e42, t32, s32, r39, i20, a28) {
    if (!this._hasLodRenderer() || null == this._resources)
      return null;
    const o27 = this.getFastUpdateAttrValues(e42), n28 = this._context.clippingExtent;
    if (c8(t32, fe2, this._context.elevationProvider.spatialReference), null != n28 && !y2(n28, fe2))
      return null;
    const l31 = ye(r39), c32 = this._computeGlobalTransform(t32, r39, ge, Pe2), h25 = this._computeLocalTransform(this._resources, this.symbolLayer, s32, _e2), d20 = this._resources.lodRenderer.instanceData, m22 = d20.addInstance();
    this._instanceIndexToGraphicUid.set(m22, i20), d20.setLocalTransform(m22, h25, false), d20.setGlobalTransform(m22, c32), o27 && d20.setFeatureAttribute(m22, o27), null == this._fastUpdates && this._hasPerInstanceColor() && d20.setColor(m22, F6(s32.color, s32.opacity, 255)), null != this._context.stage.renderView.objectAndLayerIdRenderHelper && d20.setObjectAndLayerIdColor(m22, this._context.stage.renderView.objectAndLayerIdRenderHelper.getObjectAndLayerIdColor({ graphicUid: i20, layerUid: a28 }));
    const p23 = new p20(this, m22, b10, r39);
    return l31 && (p23.alignedSampledElevation = Pe2.sampledElevation), p23.needsElevationUpdates = g5(r39.mode), p15(p23, t32, this._context.elevationProvider), p23;
  }
  _computeGlobalTransform(e42, t32, s32, r39) {
    return c17(e42, this._context.elevationProvider, t32, this._context.renderCoordsHelper, r39), fe2[0] = e42.x, fe2[1] = e42.y, fe2[2] = r39.z, R(e42.spatialReference, fe2, s32, this._context.renderCoordsHelper.spatialReference), s32;
  }
  _computeLocalTransform(e42, t32, s32, r39) {
    return o4(r39), this._applyObjectRotation(s32, false, r39), this._applyObjectRotation(t32, true, r39), this._applyObjectScale(e42, s32, r39), this._applyAnchor(e42, t32, r39), r39;
  }
  _applyObjectScale(e42, t32, s32) {
    var _a;
    if ((_a = this._fastUpdates) == null ? void 0 : _a.requiresShaderTransformation)
      return;
    const r39 = this._drivenProperties.size && t32.size ? t32.size : e42.symbolSize, i20 = B2(r39, e42.symbolSize, e42.resourceSize, this._context.renderCoordsHelper.unitInMeters);
    1 === i20[0] && 1 === i20[1] && 1 === i20[2] || f4(s32, s32, i20);
  }
  prepareSymbolLayerPatch(e42) {
    if ("partial" !== e42.diff.type)
      return;
    const t32 = e42.diff.diff;
    this._preparePatchTransform(e42, t32), this._preparePatchColor(e42, t32);
  }
  updateGeometry(e42, t32) {
    if (null == this._resources)
      return true;
    const s32 = t32 && m13(t32);
    if (null == s32)
      return false;
    const r39 = this.getGeometryElevationMode(t32);
    return e42.elevationContext.mode === r39 && (this._computeGlobalTransform(s32, e42.elevationContext, ge, Pe2), ye(e42.elevationContext) && (e42.alignedSampledElevation = Pe2.sampledElevation), this._resources.lodRenderer.instanceData.setGlobalTransform(e42.instanceIndex, ge, true), p15(e42, s32, this._context.elevationProvider), true);
  }
  _preparePatchTransform(e42, t32) {
    if (!(t32.heading || t32.tilt || t32.roll || t32.width || t32.height || t32.depth || t32.anchor || t32.anchorPosition))
      return;
    if (null == this._resources)
      return;
    const s32 = (e43, t33, s33) => (null != e43 && "complete" === e43.type ? e43.newValue : t33) ?? s33, r39 = s32(t32.heading, this.symbolLayer.heading, 0), i20 = s32(t32.tilt, this.symbolLayer.tilt, 0), a28 = s32(t32.roll, this.symbolLayer.roll, 0), o27 = s32(t32.width, this.symbolLayer.width, void 0), n28 = s32(t32.height, this.symbolLayer.height, void 0), l31 = s32(t32.depth, this.symbolLayer.depth, void 0), c32 = s32(t32.anchor, this.symbolLayer.anchor, void 0), h25 = s32(t32.anchorPosition, this.symbolLayer.anchorPosition, void 0);
    delete t32.heading, delete t32.tilt, delete t32.roll, delete t32.width, delete t32.height, delete t32.depth, delete t32.anchor, delete t32.anchorPosition;
    const d20 = { heading: r39, tilt: i20, roll: a28, anchor: c32, anchorPosition: h25 }, m22 = this._resources;
    this.loadStatus === l18.LOADED && e42.symbolLayerStatePatches.push(() => {
      m22.symbolSize = e6(t4(m22.resourceSize, { width: o27, height: n28, depth: l31, isPrimitive: this.symbolLayer.isPrimitive }));
    }), e42.graphics3DGraphicPatches.push((e43, t33) => {
      const s33 = this._computeLocalTransform(m22, d20, t33, _e2), r40 = e43.instanceIndex;
      m22.lodRenderer.instanceData.setLocalTransform(r40, s33, true);
    });
  }
  _preparePatchColor(t32, s32) {
    if (!s32.material || "partial" !== s32.material.type)
      return;
    const r39 = s32.material.diff;
    if (!r39.color || "complete" !== r39.color.type || null == r39.color.newValue || null == r39.color.oldValue)
      return;
    const i20 = r39.color.newValue, a28 = null != i20 ? u9.toUnitRGBA(i20) : s7;
    delete r39.color;
    const o27 = this._resources;
    null != o27 && t32.graphics3DGraphicPatches.push((e42) => {
      let t33;
      this._hasPerInstanceColor() ? (o27.lodRenderer.instanceData.setColor(e42.instanceIndex, a28), t33 = this._setMaterialTransparencyParameters({}, i20)) : t33 = this._setMaterialTransparencyParameters({ externalColor: a28 }, i20);
      for (const s33 of o27.stageResources.materials)
        s33.setParameters(t33);
    });
  }
  _applyObjectRotation(e42, t32, s32) {
    var _a;
    if (!((_a = this._fastUpdates) == null ? void 0 : _a.requiresShaderTransformation) || !t32)
      return U2(e42.heading, e42.tilt, e42.roll, s32);
  }
  _applyAnchor(e42, t32, s32) {
    var _a;
    if ((_a = this._fastUpdates) == null ? void 0 : _a.requiresShaderTransformation)
      return;
    const r39 = ue2(e42.resourceBoundingBox, e42.pivotOffset, t32);
    r39 && i2(s32, s32, r39);
  }
  _hasPerInstanceColor() {
    return this._drivenProperties.color || this._drivenProperties.opacity;
  }
  _fastVisualVariableConvertOptions(e42, t32, s32, r39) {
    const i20 = null != e42 ? e6(F(e42)) : _2, a28 = null != e42 ? ue2(e42, r39, this.symbolLayer) : l2, o27 = this._context.renderCoordsHelper.unitInMeters, n28 = B2(null != t32 ? t32 : void 0, t32, s32, o27), l31 = r3(this.symbolLayer.tilt || 0, this.symbolLayer.roll || 0, this.symbolLayer.heading || 0);
    return new B({ size: true, color: true, rotation: true, opacity: false }, i20, t32 ?? _2, o27, a28, n28, l31);
  }
};
function ue2(e42, t32, s32) {
  const r39 = n2();
  switch (s32.anchor) {
    case "center":
      r4(r39, E(e42)), j(r39, r39);
      break;
    case "top": {
      const t33 = E(e42);
      o2(r39, -t33[0], -t33[1], -e42[5]);
      break;
    }
    case "bottom": {
      const t33 = E(e42);
      o2(r39, -t33[0], -t33[1], -e42[2]);
      break;
    }
    case "relative": {
      const t33 = E(e42), i20 = F(e42), a28 = s32.anchorPosition, o27 = a28 ? r3(a28.x, a28.y, a28.z) : l2;
      c3(r39, i20, o27), u5(r39, r39, t33), j(r39, r39);
      break;
    }
    default:
      null != t32 ? j(r39, t32) : r4(r39, l2);
  }
  return r39;
}
function ye(e42) {
  return "absolute-height" !== e42.mode;
}
var fe2 = n2();
var _e2 = e12();
var ge = e12();
var be = n6();
var Pe2 = new R4();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Path.js
var r36 = class {
  constructor(t32, i20, s32, o27) {
    this.vertices = t32, this.positionsES = i20, this.offset = o27;
    const r39 = t32.length, n28 = Math.floor(r39 / 2), g15 = this.offset + 3 * n28, v13 = s32[g15], f23 = s32[g15 + 1], c32 = s32[g15 + 2];
    this.origin = r3(v13, f23, c32), this.positions = t14(3 * r39);
    const l31 = this.offset + 3 * r39;
    for (let e42 = this.offset; e42 < l31; e42 += 3)
      this.positions[e42] = s32[e42] - v13, this.positions[e42 + 1] = s32[e42 + 1] - f23, this.positions[e42 + 2] = s32[e42 + 2] - c32;
    this.updatePathVertexInformation();
  }
  get usedMemory() {
    return A(this.positions);
  }
  updatePathVertexInformation() {
    const t32 = this.vertices.length, e42 = this.vertices[0];
    let h25 = this.offset;
    const r39 = this.positions;
    e42.vRight[0] = r39[h25 + 3] - r39[h25], e42.vRight[1] = r39[h25 + 4] - r39[h25 + 1], e42.vRight[2] = r39[h25 + 5] - r39[h25 + 2], h25 += 3;
    let n28 = s5(e42.vRight);
    e42.vMinSiblingLength = n28, z(e42.vRight, e42.vRight);
    let g15 = e42;
    for (let v13 = 1; v13 < t32; ++v13) {
      const e43 = this.vertices[v13];
      if (e43.vLeft = g15.vRight, v13 < t32 - 1) {
        e43.vRight[0] = r39[h25 + 3] - r39[h25], e43.vRight[1] = r39[h25 + 4] - r39[h25 + 1], e43.vRight[2] = r39[h25 + 5] - r39[h25 + 2];
        const t33 = s5(e43.vRight);
        e43.vMinSiblingLength = Math.min(n28, t33), n28 = t33, z(e43.vRight, e43.vRight);
      } else
        r4(e43.vRight, e43.vLeft), e43.vMinSiblingLength = n28;
      g15 = e43, h25 += 3;
    }
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/PathBuilder.js
var h19 = class {
  constructor(t32, r39, h25, o27, p23, n28 = {}) {
    this.path = t32, this.profile = r39, this.extruder = h25, this.startCap = o27, this.endCap = p23, this.options = n28, this._extrusionVertexCount = 0;
    const l31 = this.path.vertices.length - 2;
    this.numExtrusionProfiles = h25.numProfilesPerJoin() * l31 + 2, this.numVerticesTotal = r39.vertices.length * this.numExtrusionProfiles, this.startCap.vertexBufferStart = this.numVerticesTotal;
    const a28 = this.startCap.numVertices;
    this.numVerticesTotal += a28, this.endCap.vertexBufferStart = this.numVerticesTotal;
    const u32 = this.endCap.numVertices;
    this.numVerticesTotal += u32, this.pathVertexData = f6(1 * this.numVerticesTotal), this.profileRightAxes = t14(4 * this.numVerticesTotal), this.profileUpAxes = t14(4 * this.numVerticesTotal), this.profileVertexAndNormals = t14(4 * this.numVerticesTotal), this.positions = o10(t32.positions, t32.offset, 3 * t32.vertices.length), this._rebuildGeometry(), this.buildTopology();
  }
  get usedMemory() {
    return A(this.pathVertexData, this.profileRightAxes, this.profileUpAxes, this.profileVertexAndNormals) + this.path.usedMemory + this.profile.usedMemory;
  }
  emitVertex(t32, e42, i20, s32, r39) {
    const h25 = 4 * this._extrusionVertexCount;
    if (this.profileRightAxes[h25] = e42.right[0], this.profileRightAxes[h25 + 1] = e42.right[1], this.profileRightAxes[h25 + 2] = e42.right[2], this.profileUpAxes[h25] = e42.up[0], this.profileUpAxes[h25 + 1] = e42.up[1], this.profileUpAxes[h25 + 2] = e42.up[2], this.profileVertexAndNormals[h25] = i20[0], this.profileVertexAndNormals[h25 + 1] = i20[1], this.profileVertexAndNormals[h25 + 2] = s32[0], this.profileVertexAndNormals[h25 + 3] = s32[1], this.pathVertexData[this._extrusionVertexCount] = t32, r39) {
      const e43 = this.path.vertices[t32], i21 = e43.maxStretchDistance;
      this.profileRightAxes[h25 + 3] = e43.rotationRight[0] * i21, this.profileUpAxes[h25 + 3] = e43.rotationRight[1] * i21;
    } else
      this.profileRightAxes[h25 + 3] = 0, this.profileUpAxes[h25 + 3] = 0;
    ++this._extrusionVertexCount;
  }
  emitCapVertex(t32, e42, i20, s32, r39, h25) {
    const o27 = 4 * this._extrusionVertexCount;
    this.profileRightAxes[o27] = e42.right[0], this.profileRightAxes[o27 + 1] = e42.right[1], this.profileRightAxes[o27 + 2] = e42.right[2], this.profileRightAxes[o27 + 3] = r39, this.profileUpAxes[o27] = e42.up[0], this.profileUpAxes[o27 + 1] = e42.up[1], this.profileUpAxes[o27 + 2] = e42.up[2], this.profileUpAxes[o27 + 3] = h25, this.profileVertexAndNormals[o27] = i20[0], this.profileVertexAndNormals[o27 + 1] = i20[1], this.profileVertexAndNormals[o27 + 2] = s32[0], this.profileVertexAndNormals[o27 + 3] = s32[1], this.pathVertexData[this._extrusionVertexCount] = t32, ++this._extrusionVertexCount;
  }
  _rebuildGeometry() {
    this._extrusionVertexCount = 0;
    const { positions: t32, offset: e42, vertices: s32 } = this.path;
    this.positions = o10(t32, e42, 3 * s32.length);
    let r39 = 0;
    const h25 = (t33, e43, i20, s33, h26) => this.emitCapVertex(r39, t33, e43, i20, s33, h26), o27 = (t33, e43, i20, s33) => this.emitVertex(r39, t33, e43, i20, s33);
    for (this.startCap.rebuildConnectingProfileGeometry(s32[r39], this.profile, h25), r39 = 1; r39 < s32.length - 1; ++r39)
      this.extruder.extrude(s32[r39], this.profile, o27);
    this.endCap.rebuildConnectingProfileGeometry(s32[r39], this.profile, h25), r39 = 0, this.startCap.rebuildCapGeometry(s32[r39], h25), r39 = s32.length - 1, this.endCap.rebuildCapGeometry(s32[r39], h25);
  }
  buildTopology() {
    const t32 = this.profile.vertices.length, e42 = this.profile.numSegments, i20 = this.numExtrusionProfiles - 1;
    let s32 = 3 * (2 * (e42 * i20));
    this.startCap.indexBufferStart = s32, this.startCap.firstProfileVertexIndex = 0, s32 += this.startCap.numIndices, this.endCap.indexBufferStart = s32, this.endCap.firstProfileVertexIndex = t32 * (this.numExtrusionProfiles - 1);
    const h25 = new Array(), o27 = new Array(), p23 = new Array(), n28 = (t33, e43, i21) => {
      h25.push(t33), h25.push(e43), h25.push(i21), o27.push(t33), o27.push(e43), o27.push(i21), p23.push(this.pathVertexData[t33]), p23.push(this.pathVertexData[e43]), p23.push(this.pathVertexData[i21]);
    };
    for (let r39 = 0; r39 < e42; ++r39) {
      const e43 = this.profile.indices[2 * r39], s33 = this.profile.indices[2 * r39 + 1];
      for (let r40 = 0; r40 < i20; ++r40) {
        const i21 = r40 * t32 + e43, h26 = (r40 + 1) * t32 + s33, o28 = r40 * t32 + s33;
        n28(i21, (r40 + 1) * t32 + e43, h26), n28(i21, h26, o28);
      }
    }
    this.startCap.buildTopology(this.path.vertices[0], n28), this.endCap.buildTopology(this.path.vertices[this.path.vertices.length - 1], n28), this.vertexIndices = t10(h25), this.normalIndices = t10(o27), this.pathVertexIndices = t10(p23);
  }
  onPathChanged() {
    this._rebuildGeometry();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/PathCapBuilder.js
var o22 = class {
  rebuildConnectingProfileGeometry(e42, t32, s32) {
    for (let i20 = 0; i20 < t32.vertices.length; ++i20)
      s32(e42.frame, t32.vertices[i20], t32.normals[i20], 0, 0);
  }
};
var l25 = class extends o22 {
  constructor() {
    super(), this.numVertices = 0, this.numIndices = 0;
  }
  rebuildCapGeometry() {
  }
  buildTopology() {
  }
};
var f18 = class extends o22 {
  constructor(e42, t32 = 0, s32 = false) {
    super(), this.profile = e42, this.profilePlaneOffset = t32, this.flip = s32;
  }
  get numVertices() {
    return this.profile.vertices.length;
  }
  get numIndices() {
    return 3 * this.profile.numSegments;
  }
  rebuildConnectingProfileGeometry(e42, t32, s32) {
    const i20 = this.profilePlaneOffset;
    for (let r39 = 0; r39 < t32.vertices.length; ++r39)
      s32(e42.frame, t32.vertices[r39], t32.normals[r39], i20, 0);
  }
  rebuildCapGeometry(t32, s32) {
    const i20 = this.profile, r39 = this.flip ? 1 : -1, n28 = this.profilePlaneOffset, o27 = m17;
    o8(o27, 0, 0);
    for (let e42 = 0; e42 < i20.vertices.length; ++e42)
      s32(t32.frame, i20.vertices[e42], o27, n28, r39);
  }
  buildTopology(e42, t32) {
    const s32 = this.profile, i20 = this.vertexBufferStart + s32.indices[0];
    for (let r39 = 1; r39 < s32.numSegments; ++r39) {
      const e43 = s32.indices[2 * r39], n28 = s32.indices[2 * r39 + 1], o27 = this.vertexBufferStart + e43, l31 = this.vertexBufferStart + n28;
      this.flip ? t32(l31, o27, i20) : t32(i20, o27, l31);
    }
  }
};
var h20 = class extends o22 {
  constructor(e42) {
    super(), this.flip = false, this.sign = 0, this.breakNormals = false, this.numSegments = 3, this.profile = e42.profile, this.flip = e42.flip, this.sign = this.flip ? 1 : -1, this.breakNormals = e42.breakNormals, this.numSegments = e42.subdivisions;
  }
  get numVertices() {
    let e42 = this.profile.vertices.length * (this.numSegments - 1) + this.profile.poles.length;
    return this.breakNormals && (e42 += this.profile.vertices.length), e42;
  }
  get numIndices() {
    let e42 = 0;
    const t32 = this.profile;
    e42 += 2 * t32.numSegments * (this.numSegments - 1);
    for (let s32 = 0; s32 < t32.numSegments; ++s32) {
      const i20 = t32.indices[2 * s32], r39 = t32.indices[2 * s32 + 1];
      t32.poleIndices[i20] === t32.poleIndices[r39] ? e42 += 1 : e42 += 2;
    }
    return 3 * e42;
  }
  rebuildCapGeometry(n28, o27) {
    const l31 = this.profile, f23 = n28.frame, h25 = 0.5 * this.sign, p23 = c26, a28 = m17;
    o8(a28, 0, 0);
    for (const e42 of l31.poles)
      e42.normal ? o27(f23, e42.position, e42.normal, h25, 0) : o27(f23, e42.position, a28, h25, this.sign);
    if (this.breakNormals)
      for (let e42 = 0; e42 < l31.vertices.length; ++e42)
        o27(f23, l31.vertices[e42], l31.normals[e42], 0, 0);
    for (let e42 = 0; e42 < this.numSegments - 1; ++e42) {
      const n29 = (1 - (e42 + 1) / this.numSegments) * Math.PI * 0.5, c32 = Math.sin(n29), m22 = Math.cos(n29);
      for (let e43 = 0; e43 < l31.vertices.length; ++e43) {
        const n30 = l31.poles[l31.poleIndices[e43]];
        e22(p23, l31.vertices[e43], n30.position), l9(p23, p23, c32), n30.normal ? (u12(p23, p23, n30.position), o27(f23, p23, n30.normal, h25 * m22, 0)) : (v2(a28, p23), l9(a28, a28, c32), u12(p23, p23, n30.position), o27(f23, p23, a28, h25 * m22, this.sign * m22));
      }
    }
  }
  buildTopology(e42, t32) {
    const s32 = this.profile, i20 = this.breakNormals ? this.vertexBufferStart + s32.poles.length : this.firstProfileVertexIndex, r39 = this.breakNormals ? this.vertexBufferStart + s32.poles.length + s32.vertices.length : this.vertexBufferStart + s32.poles.length;
    for (let n28 = 0; n28 < s32.numSegments; ++n28) {
      const e43 = s32.indices[2 * n28], o27 = s32.indices[2 * n28 + 1], l31 = this.vertexBufferStart + s32.poleIndices[e43], f23 = this.vertexBufferStart + s32.poleIndices[o27];
      let h25 = i20 + e43, c32 = i20 + o27;
      for (let i21 = 0; i21 < this.numSegments - 1; ++i21) {
        const n29 = r39 + i21 * s32.vertices.length + e43, l32 = r39 + i21 * s32.vertices.length + o27;
        this.flip ? (t32(n29, c32, h25), t32(c32, n29, l32)) : (t32(h25, c32, n29), t32(l32, n29, c32)), h25 = n29, c32 = l32;
      }
      this.flip ? (t32(l31, c32, h25), l31 !== f23 && t32(l31, f23, c32)) : (t32(h25, c32, l31), l31 !== f23 && t32(c32, f23, l31));
    }
  }
};
var c26 = n9();
var m17 = n9();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/PathExtruder.js
var c27 = class {
  numProfilesPerJoin() {
    return 1;
  }
  extrude(t32, e42, r39) {
    for (let s32 = 0; s32 < e42.vertices.length; ++s32)
      r39(t32.frame, e42.vertices[s32], e42.normals[s32], false);
  }
};
var a25 = class {
  constructor(t32, e42) {
    this.cutoffAngle = t32, this.numBendSubdivisions = e42;
  }
  numProfilesPerJoin() {
    return this.numBendSubdivisions + 1;
  }
  extrude(e42, s32, i20) {
    const o27 = h21, { rotationAngle: n28, rotationRight: c32, frame: a28 } = e42;
    if (Math.abs(n28) >= this.cutoffAngle) {
      const l31 = e42.rotationFrameUp;
      for (let h25 = 0; h25 < this.numBendSubdivisions + 1; ++h25) {
        p3(u29, 0.5 * -n28 + h25 * n28 / this.numBendSubdivisions, l31), m18(o27, a28, u29);
        for (let t32 = 0; t32 < s32.vertices.length; ++t32) {
          if (j7(s32.vertices[t32], c32) * n28 >= 0)
            i20(o27, s32.vertices[t32], s32.normals[t32], false);
          else {
            i20(a28, e42.applyMiterStretch(f19, s32.vertices[t32]), s32.normals[t32], true);
          }
        }
      }
    } else
      for (let t32 = 0; t32 < this.numBendSubdivisions + 1; ++t32)
        for (let o28 = 0; o28 < s32.vertices.length; ++o28) {
          const t33 = j7(s32.vertices[o28], c32) * n28 >= 0;
          i20(a28, e42.applyMiterStretch(f19, s32.vertices[o28]), s32.normals[o28], !t33);
        }
  }
};
var l26 = class {
  constructor() {
    this.up = n2(), this.right = n2();
  }
};
function m18(t32, e42, r39) {
  O2(t32.up, e42.up, r39), O2(t32.right, e42.right, r39);
}
var f19 = n9();
var u29 = e12();
var h21 = new l26();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/PathGeometry.js
var e38 = class extends I2 {
  constructor(r39, e42, o27, n28, s32, i20) {
    super(r39, e42, null, e20.Mesh, i20), this.path = o27, this.geometrySR = n28, this.stencilWidth = s32;
  }
};
var o23;
function n23(t32) {
  return "path" in t32;
}
!function(t32) {
  t32[t32.World = 0] = "World", t32[t32.Path = 1] = "Path";
}(o23 || (o23 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/PathGeometryData.js
var d14 = class {
  constructor(t32) {
    this.builder = t32;
  }
  onPathChanged(t32) {
    this.builder.onPathChanged();
  }
};
var f20 = class extends d14 {
  constructor(t32) {
    super(t32), this.vertexAttributeColor = r5(255, 255, 255, 255), this.size = new Array(), this.vertexAttributePosition = t14(3 * this.builder.numVerticesTotal), this.vertexAttributeNormal = new Int16Array(2 * this.builder.numVerticesTotal);
  }
  bakeVertexColors(t32) {
    this.vertexAttributeColor[0] = 255 * t32[0], this.vertexAttributeColor[1] = 255 * t32[1], this.vertexAttributeColor[2] = 255 * t32[2], this.vertexAttributeColor[3] = 255 * (t32.length > 3 ? t32[3] : 1);
  }
  bake(a28) {
    this.size = a28;
    const { numVerticesTotal: l31, pathVertexData: c32, path: u32, positions: b18, profileRightAxes: v13, profileUpAxes: m22, profileVertexAndNormals: x12 } = this.builder;
    for (let A16 = 0; A16 < l31; ++A16) {
      let l32 = c32[A16];
      const d20 = 0 === l32 || l32 === u32.vertices.length - 1;
      l32 *= 3;
      const f23 = V7;
      let g15 = 0, D11 = 0;
      const N7 = 4 * A16, j19 = o2(R8, v13[N7], v13[N7 + 1], v13[N7 + 2]), E21 = o2(w9, m22[N7], m22[N7 + 1], m22[N7 + 2]), y10 = o8(P7, x12[N7] * a28[0], x12[N7 + 1] * a28[1]);
      if (d20)
        _3(f23, E21, j19), g15 = v13[N7 + 3] * a28[0], D11 = m22[N7 + 3];
      else {
        const a29 = I11, h25 = C4;
        o8(a29, v13[N7 + 3], m22[N7 + 3]);
        const l33 = q5(a29);
        v2(a29, a29);
        const c33 = j7(y10, a29);
        if (Math.abs(c33) > l33) {
          o8(h25, -a29[1], a29[0]);
          const e42 = j7(y10, h25);
          l9(a29, a29, l33 * Math.sign(c33)), l9(h25, h25, e42), u12(y10, a29, h25);
        }
        o2(f23, 0, 0, 0);
      }
      const T9 = o2(O14, j19[0] * y10[0] + E21[0] * y10[1], j19[1] * y10[0] + E21[1] * y10[1], j19[2] * y10[0] + E21[2] * y10[1]), L8 = 3 * A16;
      this.vertexAttributePosition[L8] = b18[l32] + T9[0] + f23[0] * g15, this.vertexAttributePosition[L8 + 1] = b18[l32 + 1] + T9[1] + f23[1] * g15, this.vertexAttributePosition[L8 + 2] = b18[l32 + 2] + T9[2] + f23[2] * g15;
      const M11 = o8(P7, x12[N7 + 2], x12[N7 + 3]);
      s14(this.vertexAttributeNormal, A16, j19[0] * M11[0] + E21[0] * M11[1] + f23[0] * D11, j19[1] * M11[0] + E21[1] * M11[1] + f23[1] * D11, j19[2] * M11[0] + E21[2] * M11[1] + f23[2] * D11);
    }
  }
  createGeometryData() {
    const t32 = this.builder.vertexIndices.length, { normalIndices: e42, vertexIndices: r39 } = this.builder;
    return [[e16.POSITION, new t8(this.vertexAttributePosition, r39, 3, true)], [e16.NORMALCOMPRESSED, new t8(this.vertexAttributeNormal, e42, 2, true)], [e16.COLOR, new t8(this.vertexAttributeColor, A5(t32), 4)]];
  }
  onPathChanged(t32) {
    super.onPathChanged(t32), this.bake(this.size);
  }
  intersect(t32, e42, r39, i20) {
    const s32 = this.builder.vertexIndices, o27 = new s11(this.vertexAttributePosition, 3), a28 = s32.length / 3;
    x5(t32, e42, 0, a28, s32, o27, void 0, r39, (t33, e43, r40) => {
      i20(t33, r40, e43, false);
    });
  }
};
var g11 = class extends d14 {
  constructor(t32, e42, r39, i20) {
    super(t32), this.sizeAttributeValue = e42, this.colorAttributeValue = r39, this.opacityAttributeValue = i20, this.vvData = null, this.baked = new f20(t32), this.vvData = t14(4 * this.builder.path.vertices.length);
    for (let s32 = 0; s32 < this.builder.path.vertices.length; ++s32) {
      this.vvData[4 * s32] = e42, this.vvData[4 * s32 + 1] = r39, this.vvData[4 * s32 + 2] = i20;
      const t33 = 0 === s32 || s32 === this.builder.path.vertices.length - 1;
      this.vvData[4 * s32 + 3] = t33 ? 1 : 0;
    }
  }
  createGeometryData() {
    const { positions: t32, profileRightAxes: e42, profileUpAxes: r39, profileVertexAndNormals: i20, pathVertexIndices: s32, vertexIndices: o27 } = this.builder;
    return [[e16.POSITION, new t8(t32, s32, 3, true)], [e16.PROFILERIGHT, new t8(e42, o27, 4, true)], [e16.PROFILEUP, new t8(r39, o27, 4, true)], [e16.PROFILEVERTEXANDNORMAL, new t8(i20, o27, 4, true)], [e16.FEATUREVALUE, new t8(this.vvData, s32, 4, true)]];
  }
  onPathChanged(t32) {
    super.onPathChanged(t32);
    const e42 = t32.getMutableAttribute(e16.POSITION);
    e42 && (e42.data = this.builder.positions);
  }
};
var P7 = n9();
var I11 = n9();
var C4 = n9();
var O14 = n2();
var V7 = n2();
var R8 = n2();
var w9 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/pathGeometryUtils.js
function l27(l31, v13) {
  let h25 = null;
  const u32 = l31.vertices.length, j19 = 0.99619469809, R11 = n2(), y10 = n2(), b18 = n2(), x12 = n2(), L8 = n2(), k14 = n2(), q11 = E2();
  let G12 = l31.vertices[0];
  r4(y10, v13), o2(R11, 0, 1, 0), At(G12.vRight, y10, R11, R11, b18, y10, j19), r4(G12.frame.up, y10), r4(G12.frame.right, b18);
  const M11 = l31.positions;
  let U9 = l31.offset;
  h25 = G12;
  for (let m22 = 1; m22 < u32; ++m22) {
    G12 = l31.vertices[m22], u5(L8, G12.vLeft, G12.vRight);
    let a28 = s5(L8);
    a28 > 0 ? (a28 = 1 / Math.sqrt(a28), L8[0] = L8[0] * a28, L8[1] = L8[1] * a28, L8[2] = L8[2] * a28) : (L8[0] = G12.vRight[0], L8[1] = G12.vRight[1], L8[2] = G12.vRight[2]), k14[0] = M11[U9] + h25.frame.up[0], k14[1] = M11[U9 + 1] + h25.frame.up[1], k14[2] = M11[U9 + 2] + h25.frame.up[2], U9 += 3;
    const v14 = o2(n24, M11[U9], M11[U9 + 1], M11[U9 + 2]);
    j6(v14, L8, q11);
    S4(q11, p5(k14, G12.vLeft), x12) ? (x12[0] -= M11[U9], x12[1] -= M11[U9 + 1], x12[2] -= M11[U9 + 2], z(y10, x12), _3(b18, L8, y10), z(b18, b18)) : At(L8, h25.frame.up, h25.frame.right, R11, b18, y10, j19), r4(G12.frame.up, y10), r4(G12.frame.right, b18), h25 = G12;
  }
}
var n24 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/PathProfile.js
var o24 = class {
  constructor() {
    this.vertices = new Array(), this.normals = new Array(), this.indices = new Array(), this.poles = new Array(), this.poleIndices = new Array();
  }
  addVertex(t32, e42) {
    return this.vertices.push(t6(t32)), this.normals.push(t6(e42)), this.vertices.length - 1;
  }
  addPole(t32, e42 = null) {
    return this.poles.push({ position: t6(t32), normal: e42 ? t6(e42) : null }), this.poles.length - 1;
  }
  addSegment(t32, e42 = null) {
    this.indices.push(t32.v0), this.indices.push(t32.v1), e42 && (this.poleIndices.push(e42.v0), this.poleIndices.push(e42.v1));
  }
  get numSegments() {
    return this.indices.length / 2;
  }
  translate(t32, e42) {
    for (const s32 of this.vertices)
      s32[0] += t32, s32[1] += e42;
    for (const s32 of this.poles)
      s32.position[0] += t32, s32.position[1] += e42;
  }
  get usedMemory() {
    return this.vertices.length * A(this.vertices[0]) * 2 + A(this.indices);
  }
};
var n25 = { top: [0, -0.5], bottom: [0, 0.5] };
function i16(t32) {
  const s32 = 0.5, i20 = c18, d20 = new o24(), a28 = { v0: 0, v1: 0 };
  d20.addPole(r7(0, 0));
  for (let r39 = 0; r39 < i20; ++r39) {
    const t33 = 2 * r39 * Math.PI / i20, o27 = Math.cos(t33), n28 = Math.sin(t33), a29 = r7(o27 * s32, n28 * s32), c33 = r7(o27, n28);
    d20.addVertex(a29, c33);
  }
  for (let e42 = 0; e42 < i20 - 1; ++e42) {
    const t33 = { v0: e42, v1: e42 + 1 };
    d20.addSegment(t33, a28);
  }
  const c32 = { v0: i20 - 1, v1: 0 };
  if (d20.addSegment(c32, a28), "center" !== t32) {
    const e42 = n25[t32];
    d20.translate(e42[0], e42[1]);
  }
  return d20;
}
var d15 = { center: i16("center"), top: i16("top"), bottom: i16("bottom") };
var a26 = { center: c28("center"), top: c28("top"), bottom: c28("bottom") };
function c28(t32) {
  const s32 = 1, r39 = 1, i20 = new o24(), d20 = r7(0.5 * -s32, 0.5 * -r39), a28 = r7(0.5 * s32, 0.5 * -r39), c32 = r7(0.5 * s32, 0.5 * r39), h25 = r7(0.5 * -s32, 0.5 * r39), l31 = r7(0, -1), v13 = r7(1, 0), p23 = r7(0, 1), m22 = r7(-1, 0);
  if (i20.addPole(r7(0, 0.5 * r39), p23), i20.addPole(r7(0, 0.5 * r39)), i20.addPole(r7(0, 0.5 * -r39)), i20.addPole(r7(0, 0.5 * -r39), l31), i20.addVertex(d20, l31), i20.addVertex(a28, l31), i20.addSegment({ v0: 0, v1: 1 }, { v0: 3, v1: 3 }), i20.addVertex(a28, v13), i20.addVertex(c32, v13), i20.addSegment({ v0: 2, v1: 3 }, { v0: 2, v1: 1 }), i20.addVertex(c32, p23), i20.addVertex(h25, p23), i20.addSegment({ v0: 4, v1: 5 }, { v0: 0, v1: 0 }), i20.addVertex(h25, m22), i20.addVertex(d20, m22), i20.addSegment({ v0: 6, v1: 7 }, { v0: 1, v1: 2 }), "center" !== t32) {
    const e42 = n25[t32];
    i20.translate(e42[0], e42[1]);
  }
  return i20;
}

// node_modules/@arcgis/core/core/libs/gl-matrix-2/math/mat2.js
function n26(t32, n28) {
  return t32[0] = n28[0], t32[1] = n28[1], t32[2] = n28[2], t32[3] = n28[3], t32;
}
function r37(t32) {
  return t32[0] = 1, t32[1] = 0, t32[2] = 0, t32[3] = 1, t32;
}
function a27(t32, n28, r39, a28, u32) {
  return t32[0] = n28, t32[1] = r39, t32[2] = a28, t32[3] = u32, t32;
}
function u30(t32, n28) {
  if (t32 === n28) {
    const r39 = n28[1];
    t32[1] = n28[2], t32[2] = r39;
  } else
    t32[0] = n28[0], t32[1] = n28[2], t32[2] = n28[1], t32[3] = n28[3];
  return t32;
}
function o25(t32, n28) {
  const r39 = n28[0], a28 = n28[1], u32 = n28[2], o27 = n28[3];
  let e42 = r39 * o27 - u32 * a28;
  return e42 ? (e42 = 1 / e42, t32[0] = o27 * e42, t32[1] = -a28 * e42, t32[2] = -u32 * e42, t32[3] = r39 * e42, t32) : null;
}
function e39(t32, n28) {
  const r39 = n28[0];
  return t32[0] = n28[3], t32[1] = -n28[1], t32[2] = -n28[2], t32[3] = r39, t32;
}
function c29(t32) {
  return t32[0] * t32[3] - t32[2] * t32[1];
}
function s29(t32, n28, r39) {
  const a28 = n28[0], u32 = n28[1], o27 = n28[2], e42 = n28[3], c32 = r39[0], s32 = r39[1], i20 = r39[2], f23 = r39[3];
  return t32[0] = a28 * c32 + o27 * s32, t32[1] = u32 * c32 + e42 * s32, t32[2] = a28 * i20 + o27 * f23, t32[3] = u32 * i20 + e42 * f23, t32;
}
function i17(t32, n28, r39) {
  const a28 = n28[0], u32 = n28[1], o27 = n28[2], e42 = n28[3], c32 = Math.sin(r39), s32 = Math.cos(r39);
  return t32[0] = a28 * s32 + o27 * c32, t32[1] = u32 * s32 + e42 * c32, t32[2] = a28 * -c32 + o27 * s32, t32[3] = u32 * -c32 + e42 * s32, t32;
}
function f21(t32, n28, r39) {
  const a28 = n28[0], u32 = n28[1], o27 = n28[2], e42 = n28[3], c32 = r39[0], s32 = r39[1];
  return t32[0] = a28 * c32, t32[1] = u32 * c32, t32[2] = o27 * s32, t32[3] = e42 * s32, t32;
}
function l28(t32, n28) {
  const r39 = Math.sin(n28), a28 = Math.cos(n28);
  return t32[0] = a28, t32[1] = r39, t32[2] = -r39, t32[3] = a28, t32;
}
function M7(t32, n28) {
  return t32[0] = n28[0], t32[1] = 0, t32[2] = 0, t32[3] = n28[1], t32;
}
function h22(t32) {
  return "mat2(" + t32[0] + ", " + t32[1] + ", " + t32[2] + ", " + t32[3] + ")";
}
function b15(t32) {
  return Math.sqrt(t32[0] ** 2 + t32[1] ** 2 + t32[2] ** 2 + t32[3] ** 2);
}
function m19(t32, n28, r39, a28) {
  return t32[2] = a28[2] / a28[0], r39[0] = a28[0], r39[1] = a28[1], r39[3] = a28[3] - t32[2] * r39[1], [t32, n28, r39];
}
function d16(t32, n28, r39) {
  return t32[0] = n28[0] + r39[0], t32[1] = n28[1] + r39[1], t32[2] = n28[2] + r39[2], t32[3] = n28[3] + r39[3], t32;
}
function p21(t32, n28, r39) {
  return t32[0] = n28[0] - r39[0], t32[1] = n28[1] - r39[1], t32[2] = n28[2] - r39[2], t32[3] = n28[3] - r39[3], t32;
}
function y7(t32, n28) {
  return t32[0] === n28[0] && t32[1] === n28[1] && t32[2] === n28[2] && t32[3] === n28[3];
}
function x8(n28, r39) {
  const a28 = n28[0], u32 = n28[1], o27 = n28[2], e42 = n28[3], c32 = r39[0], s32 = r39[1], i20 = r39[2], f23 = r39[3], l31 = e7();
  return Math.abs(a28 - c32) <= l31 * Math.max(1, Math.abs(a28), Math.abs(c32)) && Math.abs(u32 - s32) <= l31 * Math.max(1, Math.abs(u32), Math.abs(s32)) && Math.abs(o27 - i20) <= l31 * Math.max(1, Math.abs(o27), Math.abs(i20)) && Math.abs(e42 - f23) <= l31 * Math.max(1, Math.abs(e42), Math.abs(f23));
}
function S14(t32, n28, r39) {
  return t32[0] = n28[0] * r39, t32[1] = n28[1] * r39, t32[2] = n28[2] * r39, t32[3] = n28[3] * r39, t32;
}
function j14(t32, n28, r39, a28) {
  return t32[0] = n28[0] + r39[0] * a28, t32[1] = n28[1] + r39[1] * a28, t32[2] = n28[2] + r39[2] * a28, t32[3] = n28[3] + r39[3] * a28, t32;
}
var _12 = s29;
var g12 = p21;
var q8 = Object.freeze(Object.defineProperty({ __proto__: null, LDU: m19, add: d16, adjoint: e39, copy: n26, determinant: c29, equals: x8, exactEquals: y7, frob: b15, fromRotation: l28, fromScaling: M7, identity: r37, invert: o25, mul: _12, multiply: s29, multiplyScalar: S14, multiplyScalarAndAdd: j14, rotate: i17, scale: f21, set: a27, str: h22, sub: g12, subtract: p21, transpose: u30 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/mat2f64.js
function e40() {
  return [1, 0, 0, 1];
}
function r38(e42) {
  return [e42[0], e42[1], e42[2], e42[3]];
}
function t31(e42, r39, t32, n28) {
  return [e42, r39, t32, n28];
}
function n27(e42, r39) {
  return new Float64Array(e42, r39, 4);
}
var o26 = Object.freeze(Object.defineProperty({ __proto__: null, clone: r38, create: e40, createView: n27, fromValues: t31 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/PathVertex.js
var R9 = class {
  constructor() {
    this.vLeft = n2(), this.vRight = n2(), this.vMinSiblingLength = 0, this.frame = new l26();
  }
  setFrameFromUpVector(t32) {
    r4(this.frame.up, t32), u5(k9, this.vLeft, this.vRight), z(k9, k9), g(I12, this.frame.up, P(k9, this.frame.up)), e8(D8, k9, I12), z(D8, D8), _3(this.frame.right, D8, this.frame.up);
  }
  get foldingAngle() {
    return Math.PI - this.rotationAngle;
  }
};
var x9 = class extends R9 {
  get rotationFrameUp() {
    return this.frame.up;
  }
  get rotationRight() {
    return s9;
  }
  get rotationAngle() {
    g(w10, this.frame.up, P(this.frame.up, this.vLeft)), e8(w10, this.vLeft, w10), j(w10, w10), z(w10, w10), g(y8, this.frame.up, P(this.frame.up, this.vRight)), e8(y8, this.vRight, y8), z(y8, y8), _3(U5, this.rotationFrameUp, this.vLeft);
    return Math.sign(P(U5, this.vRight)) * (Math.PI - m2(P(w10, y8)));
  }
  get maxStretchDistance() {
    return Math.abs(this.vMinSiblingLength / Math.cos(0.5 * this.foldingAngle));
  }
  applyMiterStretch(t32, r39) {
    const s32 = this.rotationAngle;
    if (Math.abs(s32) <= 0)
      return r39;
    const a28 = b2(Math.cos(0.5 * s32));
    return o8(t32, (a28 - 1 + 1) * r39[0], r39[1]);
  }
};
var L6 = class extends R9 {
  get rotationFrameUp() {
    const t32 = Math.sign(P(this.frame.right, this.vRight));
    return _3(d17, this.vRight, this.vLeft), g(d17, d17, t32), z(d17, d17);
  }
  get rotationRight() {
    const t32 = this.rotationFrameUp, i20 = P(t32, this.frame.up), r39 = P(t32, this.frame.right);
    return g(S15, this.frame.up, -r39), g(P8, this.frame.right, i20), u5(S15, S15, P8), z(S15, S15), j15(F10, this.frame, S15), F10;
  }
  get rotationAngle() {
    const i20 = Math.sign(P(this.frame.right, this.vRight));
    return j(U5, this.vLeft), -i20 * (Math.PI - m2(P(U5, this.vRight)));
  }
  get maxStretchDistance() {
    return Math.abs(this.vMinSiblingLength * b2(Math.cos(0.5 * this.foldingAngle)));
  }
  applyMiterStretch(t32, s32) {
    const e42 = this.rotationAngle;
    if (0 === Math.abs(e42))
      return s32;
    const h25 = b2(Math.cos(0.5 * e42)), o27 = this.rotationRight, n28 = a27(E16, 1 + (h25 - 1) * o27[0] * o27[0], (h25 - 1) * o27[0] * o27[1], (h25 - 1) * o27[0] * o27[1], 1 + (h25 - 1) * o27[1] * o27[1]);
    return P3(t32, s32, n28);
  }
};
function j15(t32, i20, r39) {
  o8(t32, P(r39, i20.right), P(r39, i20.up));
}
function A12(t32) {
  switch (t32) {
    case o23.World:
      return new x9();
    case o23.Path:
      return new L6();
  }
}
var d17 = n2();
var F10 = n9();
var S15 = n2();
var P8 = n2();
var U5 = n2();
var w10 = n2();
var y8 = n2();
var I12 = n2();
var k9 = n2();
var D8 = n2();
var E16 = e40();

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/PathTechnique.js
var E17 = /* @__PURE__ */ new Map([[e16.POSITION, 0], [e16.PROFILERIGHT, 1], [e16.PROFILEUP, 2], [e16.PROFILEVERTEXANDNORMAL, 3], [e16.FEATUREVALUE, 4]]);
var N3 = class extends n16 {
  constructor() {
    super(...arguments), this.ambient = r3(0.2, 0.2, 0.2), this.diffuse = r3(0.8, 0.8, 0.8), this.specular = r3(0, 0, 0), this.opacity = 1, this.origin = n2(), this.modelTransformation = null;
  }
};
var C5 = class _C extends r14 {
  initializeConfiguration(e42, o27) {
    o27.spherical = e42.viewingMode === l6.Global, o27.doublePrecisionRequiresObfuscation = e42.rctx.driverTest.doublePrecisionRequiresObfuscation.result;
  }
  initializeProgram(e42) {
    return new r15(e42.rctx, _C.shader.get().build(this.configuration), E17);
  }
  initializePipeline() {
    const e42 = this.configuration.transparencyPassType, o27 = this.configuration, t32 = e42 === o11.NONE, i20 = e42 === o11.FrontFace;
    return S5({ blending: o27.output !== o7.Color && o27.output !== o7.Alpha || !o27.transparent ? null : t32 ? c16 : A7(e42), culling: o27.hasSlicePlane && !o27.transparent && o27.doubleSidedMode !== i8.None ? a10 : null, depthTest: { func: l13(e42) }, depthWrite: t32 || i20 ? o12 : null, colorWrite: _6, stencilWrite: o27.hasOccludees ? e27 : null, stencilTest: o27.hasOccludees ? f7 : null, polygonOffset: t32 || i20 ? null : _7 });
  }
};
C5.shader = new t17(D5, () => import("./Path.glsl-U7WL5XJD.js"));
var V8 = class extends t21 {
  constructor() {
    super(...arguments), this.output = o7.Color, this.doubleSidedMode = i8.None, this.transparencyPassType = o11.NONE, this.spherical = false, this.receiveShadows = false, this.receiveAmbientOcclusion = false, this.vvSize = false, this.vvColor = false, this.vvOpacity = false, this.hasSlicePlane = false, this.transparent = false, this.hasOccludees = false, this.multipassEnabled = false, this.cullAboveGround = false, this.doublePrecisionRequiresObfuscation = false;
  }
};
e([r17({ count: o7.COUNT })], V8.prototype, "output", void 0), e([r17({ count: i8.COUNT })], V8.prototype, "doubleSidedMode", void 0), e([r17({ count: o11.COUNT })], V8.prototype, "transparencyPassType", void 0), e([r17()], V8.prototype, "spherical", void 0), e([r17()], V8.prototype, "receiveShadows", void 0), e([r17()], V8.prototype, "receiveAmbientOcclusion", void 0), e([r17()], V8.prototype, "vvSize", void 0), e([r17()], V8.prototype, "vvColor", void 0), e([r17()], V8.prototype, "vvOpacity", void 0), e([r17()], V8.prototype, "hasSlicePlane", void 0), e([r17()], V8.prototype, "transparent", void 0), e([r17()], V8.prototype, "hasOccludees", void 0), e([r17()], V8.prototype, "multipassEnabled", void 0), e([r17()], V8.prototype, "cullAboveGround", void 0), e([r17()], V8.prototype, "doublePrecisionRequiresObfuscation", void 0), e([r17({ constValue: false })], V8.prototype, "occlusionPass", void 0), e([r17({ constValue: c13.Disabled })], V8.prototype, "pbrMode", void 0), e([r17({ constValue: true })], V8.prototype, "hasVvInstancing", void 0), e([r17({ constValue: false })], V8.prototype, "useCustomDTRExponentForWater", void 0), e([r17({ constValue: false })], V8.prototype, "useFillLights", void 0), e([r17({ constValue: false })], V8.prototype, "hasColorTexture", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/PathMaterial.js
var g13 = class _g extends c15 {
  constructor(e42) {
    super(e42, new O15()), this.supportsEdges = true, this.produces = /* @__PURE__ */ new Map([[A8.OPAQUE_MATERIAL, (e43) => (this.parameters.castShadows && t7(e43) || n10(e43)) && !this.parameters.transparent], [A8.TRANSPARENT_MATERIAL, (e43) => (this.parameters.castShadows && t7(e43) || n10(e43)) && this.parameters.transparent]]), this._vertexAttributeLocations = E17, this._configuration = new V8(), this._vertexBufferLayout = _g.getVertexBufferLayout();
  }
  getConfiguration(e42, t32) {
    return this._configuration.output = e42, this._configuration.vvSize = !!this.parameters.vvSize, this._configuration.vvColor = !!this.parameters.vvColor, this._configuration.vvOpacity = !!this.parameters.vvOpacity, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.transparent = this.parameters.transparent, this._configuration.hasOccludees = this.parameters.hasOccludees, e42 !== o7.Color && e42 !== o7.Alpha || (this._configuration.doubleSidedMode = this.parameters.doubleSided && "normal" === this.parameters.doubleSidedType ? i8.View : this.parameters.doubleSided && "winding-order" === this.parameters.doubleSidedType ? i8.WindingOrder : i8.None, this._configuration.receiveShadows = this.parameters.receiveShadows, this._configuration.receiveAmbientOcclusion = null != t32.ssao), this._configuration.transparencyPassType = t32.transparencyPassType, this._configuration.multipassEnabled = t32.multipassEnabled, this._configuration.cullAboveGround = t32.multipassTerrain.cullAboveGround, this._configuration;
  }
  isVisibleForOutput(e42) {
    return e42 !== o7.Shadow && e42 !== o7.ShadowExcludeHighlight && e42 !== o7.ShadowHighlight || this.parameters.castShadows;
  }
  isVisible() {
    return super.isVisible() && this.parameters.opacity > 0;
  }
  intersect(r39, i20, s32, a28, o27, n28) {
    const h25 = r39;
    if (!n23(h25))
      return;
    const l31 = h25.path, p23 = [this.parameters.size[0], this.parameters.size[1]];
    if (this.parameters.vvSize) {
      const { offset: t32, factor: r40, minSize: i21, maxSize: s33 } = this.parameters.vvSize, a29 = l31.sizeAttributeValue;
      p23[0] *= e9(t32[0] + a29 * r40[0], i21[0], s33[0]), p23[1] *= e9(t32[2] + a29 * r40[2], i21[2], s33[2]);
    }
    const m22 = new p6(false, s32.options.normalRequired), f23 = Math.max(p23[0], p23[1]), b18 = r39.boundingInfo;
    if (null == b18)
      return void w11(l31, p23, a28, o27, m22, n28);
    const S21 = a5(b18.bbMin[0] - f23, b18.bbMin[1] - f23, b18.bbMin[2] - f23, b18.bbMax[0] + f23, b18.bbMax[1] + f23, b18.bbMax[2] + f23), v13 = [o27[0] - a28[0], o27[1] - a28[1], o27[2] - a28[2]], g15 = Math.sqrt(v13[0] * v13[0] + v13[1] * v13[1] + v13[2] * v13[2]), _16 = [g15 / v13[0], g15 / v13[1], g15 / v13[2]];
    k3(S21, a28, _16, s32.tolerance) && w11(l31, p23, a28, o27, m22, n28);
  }
  createBufferWriter() {
    return new r13(this._vertexBufferLayout);
  }
  createGLMaterial(e42) {
    return new _13(e42);
  }
  static getVertexBufferLayout() {
    return H2().vec3f(e16.POSITION).vec4f(e16.PROFILERIGHT).vec4f(e16.PROFILEUP).vec4f(e16.PROFILEVERTEXANDNORMAL).vec4f(e16.FEATUREVALUE);
  }
};
var _13 = class extends t16 {
  _updateOccludeeState(e42) {
    e42.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e42.hasOccludees });
  }
  _updateShadowState(e42) {
    null != this.technique && e42.shadowMap.enabled === this.technique.configuration.receiveShadows || this._material.setParameters({ receiveShadows: e42.shadowMap.enabled });
  }
  beginSlot(e42) {
    return this._output !== o7.Color && this._output !== o7.Alpha || (this._updateShadowState(e42), this._updateOccludeeState(e42)), this.ensureTechnique(C5, e42);
  }
};
function w11(e42, t32, r39, i20, s32, a28) {
  e42.baked.size && e42.baked.size[0] === t32[0] && e42.baked.size[1] === t32[1] || e42.baked.bake(t32), e42.baked.intersect(r39, i20, s32, a28);
}
var O15 = class extends N3 {
  constructor() {
    super(...arguments), this.doubleSided = false, this.doubleSidedType = "normal", this.receiveShadows = false, this.castShadows = true, this.hasSlicePlane = false, this.transparent = false, this.hasOccludees = false;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DPathSymbolLayer.js
var ee2 = ["polyline"];
var te2 = class extends h13 {
  constructor(e42, t32, i20, r39) {
    super(e42, t32, i20, r39), this._intrinsicSize = r7(1, 1), this._upVectorAlignment = o23.Path, this._stencilWidth = 0.1, this.usedMemory = 0, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    var _a, _b, _c, _d, _e3;
    const t32 = null != this.symbolLayer.width ? this.symbolLayer.width : this.symbolLayer.height, i20 = null != this.symbolLayer.height ? this.symbolLayer.height : t32;
    this._vvConvertOptions = new B({ size: true, color: true, rotation: false, opacity: true }, [1, 1, 1], [t32, 1, i20], this._context.renderCoordsHelper.unitInMeters), this._fastUpdates = ((_b = (_a = this._context.renderer) == null ? void 0 : _a.visualVariables) == null ? void 0 : _b.length) > 0 ? O8(this._context.renderer, this._vvConvertOptions) : null;
    const r39 = this.symbolLayer.anchor || "center";
    this._upVectorAlignment = "heading" === this.symbolLayer.profileRotation ? o23.World : o23.Path;
    const o27 = this.symbolLayer.profile || "circle";
    switch (o27) {
      default:
      case "circle":
        this._profile = d15[r39];
        break;
      case "quad":
        this._profile = a26[r39];
    }
    switch (this.symbolLayer.join) {
      case "round":
        this._extruder = new a25(0, o17);
        break;
      case "bevel":
        this._extruder = new a25(0, 1);
        break;
      case "miter":
        this._extruder = new a25(0.8 * Math.PI, 1);
        break;
      default:
        this._extruder = new c27();
    }
    const l31 = this.symbolLayer.cap || "butt";
    switch (l31) {
      case "none":
        this._startCap = new l25(), this._endCap = new l25();
        break;
      case "butt":
      default:
        this._startCap = new f18(this._profile, 0), this._endCap = new f18(this._profile, 0, true);
        break;
      case "square":
        this._startCap = new f18(this._profile, -0.5), this._endCap = new f18(this._profile, 0.5, true);
        break;
      case "round": {
        const e42 = "quad" === o27;
        this._startCap = new h20({ profile: this._profile, flip: false, breakNormals: e42, subdivisions: t26 }), this._endCap = new h20({ profile: this._profile, flip: true, breakNormals: e42, subdivisions: t26 });
        break;
      }
    }
    const c32 = (_d = (_c = this.symbolLayer) == null ? void 0 : _c.material) == null ? void 0 : _d.color, p23 = this._getCombinedOpacityAndColor(c32), m22 = e6(p23), f23 = p23[3], d20 = f23 < 1 || this.needsDrivenTransparentPass, u32 = { diffuse: m22, ambient: m22, opacity: f23, transparent: d20, hasVertexColors: false, hasSlicePlane: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows, cullFace: d20 || "none" === l31 ? e21.None : e21.Back, offsetTransparentBackfaces: true };
    if (!this._drivenProperties.size && (o8(this._intrinsicSize, t32, i20), !S7(this._intrinsicSize[0]) || !S7(this._intrinsicSize[1])))
      throw new s2("graphics3dpathsymbollayer:invalid-size", "Symbol sizes may not be negative values");
    if (((_e3 = this._fastUpdates) == null ? void 0 : _e3.visualVariables.size) || l9(this._intrinsicSize, this._intrinsicSize, 1 / this._context.renderCoordsHelper.unitInMeters), this._fastUpdates) {
      const e42 = { ...u32, ...this._fastUpdates.materialParameters, size: e15(this._intrinsicSize) };
      this._materials[0] = new g13(e42);
    } else
      u32.hasVertexColors = this._drivenProperties.color || this._drivenProperties.opacity, u32.normalType = a7.Compressed, this._materials[0] = new E7(u32);
    this._materials[0].setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), this._context.stage.add(this._materials[0]);
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._materials[0]), this._materials[0] = null, this._materials.length = 0;
  }
  createGraphics3DGraphic(e42) {
    const t32 = e42.graphic;
    if (!this._validateGeometry(t32.geometry, ee2, this.symbolLayer.type))
      return null;
    const i20 = this.setGraphicElevationContext(t32), r39 = e42.renderingInfo;
    return this._createAs3DShape(t32, r39, i20, t32.uid);
  }
  layerOpacityChanged() {
    var _a, _b, _c;
    const e42 = (_b = (_a = this.symbolLayer) == null ? void 0 : _a.material) == null ? void 0 : _b.color, t32 = this._getCombinedOpacity(e42), i20 = t32 < 1 || this.needsDrivenTransparentPass;
    (_c = this._materials[0]) == null ? void 0 : _c.setParameters({ opacity: t32, transparent: i20 });
  }
  layerElevationInfoChanged(e42, t32) {
    return this.updateGraphics3DGraphicElevationInfo(e42, t32, g5);
  }
  slicePlaneEnabledChanged() {
    var _a;
    return (_a = this._materials[0]) == null ? void 0 : _a.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    var _a;
    return (_a = this._materials[0]) == null ? void 0 : _a.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), true;
  }
  applyRendererDiff(e42, t32) {
    var _a;
    for (const i20 in e42.diff) {
      if ("visualVariables" !== i20)
        return e33.RecreateSymbol;
      if (!G4(this._fastUpdates, t32, this._vvConvertOptions))
        return e33.RecreateSymbol;
      (_a = this._materials[0]) == null ? void 0 : _a.setParameters(this._fastUpdates.materialParameters);
    }
    return e33.FastUpdate;
  }
  _getVertexData(e42) {
    let t32 = 0;
    const i20 = e42.paths, r39 = [], s32 = e42.spatialReference, a28 = this._context.elevationProvider.spatialReference, o27 = this._context.renderCoordsHelper.spatialReference;
    for (const c32 of i20)
      t32 += c32.length;
    const n28 = t9(3 * t32);
    let l31, h25 = 0;
    for (const c32 of i20) {
      r39.push({ offset: h25, numVertices: c32.length });
      for (const t33 of c32)
        n28[h25++] = t33[0], n28[h25++] = t33[1], n28[h25++] = e42.hasZ ? t33[2] : 0;
    }
    return null == a28 || s32.equals(a28) || n3(n28, s32, 0, n28, a28, 0, t32) ? (null == a28 || a28.equals(o27) ? l31 = e19(n28) : (l31 = t9(3 * t32), n3(n28, a28, 0, l31, o27, 0, t32)), { pathVertexDataInfos: r39, vertexDataES: n28, vertexDataRS: l31 }) : null;
  }
  _createAs3DShape(e42, s32, a28, o27) {
    var _a, _b, _c;
    this.usedMemory = 0;
    const n28 = e42.geometry, h25 = this._getVertexData(n28);
    if (null == h25)
      return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"), null;
    if (0 === h25.pathVertexDataInfos.length)
      return 0 !== n28.paths.length && n28.paths.some((e43) => e43.length > 0) || this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)"), null;
    const c32 = new Array(), p23 = n28.spatialReference, b18 = i(), y10 = this._context.renderCoordsHelper, v13 = new r18(h25.vertexDataES);
    for (const m22 of h25.pathVertexDataInfos) {
      const n29 = m22.numVertices;
      if (n29 < 2)
        continue;
      const g15 = m22.offset;
      if (null != this._context.clippingExtent && (P2(b18), c4(b18, h25.vertexDataES, g15, n29), !V(b18, this._context.clippingExtent)))
        continue;
      const w13 = new Array(), x13 = g15 + 3 * n29;
      for (let e43 = g15; e43 < x13; e43 += 3) {
        v13.offset = e43;
        const t32 = f9(v13, this._context.elevationProvider, a28, y10);
        o2(oe2, h25.vertexDataRS[e43], h25.vertexDataRS[e43 + 1], h25.vertexDataRS[e43 + 2]), y10.setAltitude(oe2, t32), h25.vertexDataRS[e43] = oe2[0], h25.vertexDataRS[e43 + 1] = oe2[1], h25.vertexDataRS[e43 + 2] = oe2[2], w13.push(A12(this._upVectorAlignment));
      }
      const P13 = new r36(w13, h25.vertexDataES, h25.vertexDataRS, g15);
      ie2(P13, this._upVectorAlignment, this._context.renderCoordsHelper);
      const j19 = new h19(P13, this._profile, this._extruder, this._startCap, this._endCap);
      let S21 = null;
      if (this._fastUpdates) {
        const t32 = this._fastUpdates.visualVariables, i20 = X((_a = t32.size) == null ? void 0 : _a.field, e42) ?? 0, r39 = X((_b = t32.color) == null ? void 0 : _b.field, e42) ?? 0, s33 = X((_c = t32.opacity) == null ? void 0 : _c.field, e42) ?? 0;
        S21 = new g11(j19, i20, r39, s33);
      } else {
        const e43 = [this._intrinsicSize[0], this._intrinsicSize[1]];
        if (this._drivenProperties.size) {
          const t33 = s32.size;
          e43[0] *= re2(t33[0], "symbol-value" === t33[2] ? this.symbolLayer.height || 0 : t33[2], this.symbolLayer.width || 0), e43[1] *= re2(t33[2], "symbol-value" === t33[0] ? this.symbolLayer.width || 0 : t33[0], this.symbolLayer.height || 0);
        }
        let t32;
        this._drivenProperties.color && (t32 = s32.color), this._drivenProperties.opacity && null != s32.opacity && (t32 = t32 ? [t32[0], t32[1], t32[2], s32.opacity] : [1, 1, 1, s32.opacity]);
        const i20 = new f20(j19);
        i20.bake(e43), t32 && i20.bakeVertexColors(t32), S21 = i20;
      }
      const D11 = S21.createGeometryData(), C6 = this._context.stage.renderView.getObjectAndLayerIdColor({ graphicUid: o27, layerUid: this._context.layer.uid }), L8 = new e38(this._materials[0], D11, S21, p23, this._stencilWidth, C6);
      L8.transformation = i2(e12(), o6, j19.path.origin), c32.push(L8), this.usedMemory += j19.usedMemory;
    }
    if (0 === c32.length)
      return null;
    const x12 = new O9({ geometries: c32, layerUid: this._context.layer.uid, graphicUid: o27 }), P12 = new p13(this, x12, c32, null, null, (e43, t32, i20, r39, s33) => ae2(e43, t32, r39, s33, this._upVectorAlignment), a28);
    return P12.alignedSampledElevation = 0, P12.needsElevationUpdates = g5(a28.mode), P12;
  }
};
function ie2(e42, t32, i20) {
  const { origin: r39, positions: s32 } = e42;
  let a28 = e42.offset;
  switch (t32) {
    default:
    case o23.World:
      for (const t33 of e42.vertices)
        oe2[0] = s32[a28++] + r39[0], oe2[1] = s32[a28++] + r39[1], oe2[2] = s32[a28++] + r39[2], i20.worldUpAtPosition(oe2, oe2), t33.setFrameFromUpVector(oe2);
      break;
    case o23.Path:
      oe2[0] = s32[a28] + r39[0], oe2[1] = s32[a28 + 1] + r39[1], oe2[2] = s32[a28 + 2] + r39[2], i20.worldUpAtPosition(oe2, oe2), l27(e42, oe2);
  }
}
function re2(e42, t32, i20) {
  switch (e42) {
    case "symbol-value":
      return i20;
    case "proportional":
      return t32;
    default:
      return e42;
  }
}
function se2(e42, t32, i20, r39) {
  let s32 = 0;
  const { origin: a28, vertices: o27, positions: n28, positionsES: h25 } = e42, c32 = e42.offset + 3 * o27.length;
  for (let p23 = e42.offset; p23 < c32; p23 += 3)
    o2(oe2, h25[p23], h25[p23 + 1], h25[p23 + 2]), i20(oe2, ne2), s32 += ne2.sampledElevation, oe2[0] = n28[p23] + a28[0], oe2[1] = n28[p23 + 1] + a28[1], oe2[2] = n28[p23 + 2] + a28[2], r39.setAltitude(oe2, ne2.z), n28[p23] = oe2[0] - a28[0], n28[p23 + 1] = oe2[1] - a28[1], n28[p23 + 2] = oe2[2] - a28[2];
  return e42.updatePathVertexInformation(), s32 / o27.length;
}
function ae2(e42, t32, i20, r39, s32) {
  const a28 = e42.stageObject, o27 = a28.geometries;
  let n28 = 0;
  for (const l31 of o27) {
    if (!n23(l31))
      continue;
    const e43 = l31.path, o28 = e43.builder.path;
    n28 += se2(o28, t32, i20, r39), s32 !== o23.World && ie2(o28, s32, r39), e43.onPathChanged(l31), l31.invalidateBoundingInfo(), a28.geometryVertexAttributeUpdated(l31, e16.POSITION);
  }
  return n28 / o27.length;
}
var oe2 = n2();
var ne2 = new R4();

// node_modules/@arcgis/core/views/3d/layers/support/uvUtils.js
function T6(t32, r39, e42, s32, i20 = 1) {
  if (e42.isGeographic && s32 === l6.Global) {
    const t33 = t9(r39.length), o27 = r39.length, s33 = s4(e42);
    for (let e43 = 0; e43 < o27; e43 += 3)
      H(r39, e43, t33, e43, s33);
    r39 = t33;
  }
  o8(y9, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
  for (let o27 = 0; o27 < r39.length; o27 += 3)
    y9[0] = Math.min(y9[0], r39[o27]), y9[1] = Math.min(y9[1], r39[o27 + 1]);
  const a28 = y9[0] % i20, m22 = y9[1] % i20, n28 = y9[0] - a28, c32 = y9[1] - m22;
  for (let o27 = 0; o27 < r39.length; o27 += 3) {
    const e43 = o27 / 3 * 4;
    t32[e43] = (r39[o27] - n28) / i20, t32[e43 + 1] = (r39[o27 + 1] - c32) / i20, t32[e43 + 2] = n28 / i20, t32[e43 + 3] = c32 / i20;
  }
}
function M8(t32, r39, n28, c32, l31 = 1) {
  o2(F11, 1, 0, 0), o2(Y6, 0, 1, 0), o2(_14, 0, 0, 1), D9(x10, n28), d4(V9, n28) && O16(V9, F11, Y6, _14, c32, x10), o8(y9, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), o8(P9, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
  for (let o27 = 0; o27 < n28.length; o27 += 3) {
    o2(E18, n28[o27], n28[o27 + 1], n28[o27 + 2]);
    const t33 = P(F11, E18), r40 = P(Y6, E18);
    y9[0] = Math.min(y9[0], t33), y9[1] = Math.min(y9[1], r40), P9[0] = Math.max(P9[0], t33), P9[1] = Math.max(P9[1], r40);
  }
  const f23 = P(_14, x10);
  q9(v9, y9[0], y9[1], f23, F11, Y6, _14), q9(A13, P9[0], y9[1], f23, F11, Y6, _14), q9(G11, y9[0], P9[1], f23, F11, Y6, _14), e8(A13, A13, v9), g(A13, A13, 0.5), e8(G11, G11, v9), g(G11, G11, 0.5), u5(v9, v9, A13), u5(v9, v9, G11);
  const I15 = y9[0] % l31, h25 = y9[1] % l31, p23 = y9[0] - I15, N7 = y9[1] - h25;
  for (let o27 = 0; o27 < n28.length; o27 += 3) {
    o2(E18, n28[o27], n28[o27 + 1], n28[o27 + 2]);
    const i20 = o27 / 3, a28 = 4 * i20;
    t32[a28] = (P(F11, E18) - p23) / l31, t32[a28 + 1] = (P(Y6, E18) - N7) / l31, t32[a28 + 2] = p23 / l31, t32[a28 + 3] = N7 / l31;
    const m22 = 9 * i20;
    for (let t33 = 0; t33 < 3; t33++)
      r39[m22 + t33] = v9[t33], r39[m22 + t33 + 3] = A13[t33], r39[m22 + t33 + 6] = G11[t33];
  }
}
var x10 = n2();
var E18 = n2();
var V9 = E2();
var F11 = n2();
var Y6 = n2();
var _14 = n2();
var y9 = n9();
var P9 = n9();
var v9 = n2();
var A13 = n2();
var G11 = n2();
function O16(t32, o27, r39, i20, m22, I15) {
  null != m22 ? (m22.basisMatrixAtPosition(I15, S16), o2(d18, S16[0], S16[1], S16[2]), o2(k10, S16[4], S16[5], S16[6]), o2(w12, S16[8], S16[9], S16[10])) : (o2(d18, 1, 0, 0), o2(k10, 0, 1, 0), o2(w12, 0, 0, 1));
  const h25 = F3(t32);
  P(h25, w12) < 0 && g(h25, h25, -1), r4(i20, h25);
  const p23 = P(h25, k10), N7 = P(h25, d18);
  Math.abs(p23) > Math.abs(N7) ? (q2(o27, d18, h25, -N7), z(o27, o27), _3(r39, o27, h25), z(r39, r39), g(r39, r39, -1)) : (q2(r39, k10, h25, -p23), z(r39, r39), _3(o27, r39, h25), z(o27, o27));
}
var S16 = e12();
var d18 = n2();
var k10 = n2();
var w12 = n2();
function D9(t32, o27) {
  o2(U6, 0, 0, 0);
  for (let r39 = 0; r39 < o27.length - 3; r39 += 3)
    U6[0] += o27[r39], U6[1] += o27[r39 + 1], U6[2] += o27[r39 + 2];
  g(t32, U6, 1 / (o27.length / 3 - 1));
}
var U6 = n2();
function q9(t32, o27, r39, s32, i20, a28, m22) {
  o2(t32, o27 * i20[0] + r39 * a28[0] + s32 * m22[0], o27 * i20[1] + r39 * a28[1] + s32 * m22[1], o27 * i20[2] + r39 * a28[2] + s32 * m22[2]);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/PatternTechnique.js
var S17 = class _S extends r14 {
  initializeProgram(e42) {
    return new r15(e42.rctx, _S.shader.get().build(this.configuration), has("enable-feature:objectAndLayerId-rendering") ? N4 : E19);
  }
  _setPipelineState(e42, o27) {
    const r39 = this.configuration, i20 = e42 === o11.NONE, s32 = e42 === o11.FrontFace;
    return S5({ blending: r39.output === o7.Color || r39.output === o7.Alpha ? i20 ? c16 : A7(e42) : null, culling: h10(r39.cullFace), depthTest: r39.draped ? null : { func: l13(e42) }, depthWrite: r39.draped ? null : i20 ? o12 : E5(e42), colorWrite: _6, stencilWrite: r39.hasOccludees ? e27 : null, stencilTest: r39.hasOccludees ? o27 ? o13 : f7 : null, polygonOffset: i20 || s32 ? r39.polygonOffset ? j16 : null : a11(r39.enableOffset) });
  }
  initializePipeline() {
    return this._occludeePipelineState = this._setPipelineState(this.configuration.transparencyPassType, true), this._setPipelineState(this.configuration.transparencyPassType, false);
  }
  getPipeline(e42) {
    return e42 ? this._occludeePipelineState : super.getPipeline();
  }
};
S17.shader = new t17(R5, () => import("./Pattern.glsl-EE3YAXAL.js"));
var j16 = { factor: 1, units: 1 };
var A14 = class extends t21 {
  constructor() {
    super(...arguments), this.output = o7.Color, this.cullFace = e21.None, this.transparencyPassType = o11.NONE, this.hasSlicePlane = false, this.hasVertexColors = false, this.polygonOffset = false, this.hasOccludees = false, this.enableOffset = true, this.multipassEnabled = false, this.cullAboveGround = false, this.vvColor = false, this.objectAndLayerIdColorInstanced = false;
  }
};
e([r17({ count: o7.COUNT })], A14.prototype, "output", void 0), e([r17({ count: e21.COUNT })], A14.prototype, "cullFace", void 0), e([r17({ count: a14.COUNT })], A14.prototype, "style", void 0), e([r17({ count: o11.COUNT })], A14.prototype, "transparencyPassType", void 0), e([r17()], A14.prototype, "hasSlicePlane", void 0), e([r17()], A14.prototype, "hasVertexColors", void 0), e([r17()], A14.prototype, "polygonOffset", void 0), e([r17()], A14.prototype, "hasOccludees", void 0), e([r17()], A14.prototype, "patternSpacing", void 0), e([r17()], A14.prototype, "lineWidth", void 0), e([r17()], A14.prototype, "enableOffset", void 0), e([r17()], A14.prototype, "draped", void 0), e([r17()], A14.prototype, "multipassEnabled", void 0), e([r17()], A14.prototype, "cullAboveGround", void 0), e([r17()], A14.prototype, "vvColor", void 0), e([r17({ constValue: true })], A14.prototype, "writeDepth", void 0), e([r17({ constValue: false })], A14.prototype, "occlusionPass", void 0), e([r17({ constValue: false })], A14.prototype, "hasVvInstancing", void 0), e([r17({ constValue: false })], A14.prototype, "vvSize", void 0), e([r17({ constValue: false })], A14.prototype, "vvOpacity", void 0);
var E19 = /* @__PURE__ */ new Map([[e16.POSITION, 0], [e16.COLOR, 3], [e16.UVMAPSPACE, 4], [e16.COLORFEATUREATTRIBUTE, 5], [e16.BOUNDINGRECT, 6]]);
var N4 = /* @__PURE__ */ new Map([[e16.POSITION, 0], [e16.COLOR, 3], [e16.UVMAPSPACE, 4], [e16.COLORFEATUREATTRIBUTE, 5], [e16.BOUNDINGRECT, 6], [e16.OBJECTANDLAYERIDCOLOR, 9]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/PatternMaterial.js
var P10 = class extends e29 {
  constructor(e42) {
    super(e42, new j17()), this.supportsEdges = true, this.produces = /* @__PURE__ */ new Map([[A8.OPAQUE_MATERIAL, (e43) => e18(e43)], [A8.TRANSPARENT_MATERIAL, (e43) => i3(e43)], [A8.TRANSPARENT_NO_SSAO_DEPTH, (e43) => e43 === o7.LinearDepth && this.parameters.writeLinearDepth], [A8.DRAPED_MATERIAL, (e43) => this.parameters.draped && e43 === o7.Color || e18(e43)]]), this._vertexAttributeLocations = has("enable-feature:objectAndLayerId-rendering") ? N4 : E19, this._configuration = new A14();
  }
  getConfiguration(e42, t32) {
    return this._configuration.output = e42, this._configuration.cullFace = this.parameters.cullFace, this._configuration.hasVertexColors = this.parameters.hasVertexColors && !this.parameters.vvColor, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.polygonOffset = this.parameters.polygonOffset, this._configuration.style = this.parameters.style, this._configuration.patternSpacing = this.parameters.patternSpacing, this._configuration.lineWidth = this.parameters.lineWidth, this._configuration.draped = this.parameters.draped, this._configuration.transparencyPassType = t32.transparencyPassType, this._configuration.enableOffset = t32.camera.relativeElevation < S6, this._configuration.multipassEnabled = t32.multipassEnabled, this._configuration.cullAboveGround = t32.multipassTerrain.cullAboveGround, this._configuration.vvColor = !!this.parameters.vvColor, this._configuration;
  }
  createGLMaterial(e42) {
    return new v10(e42);
  }
  createBufferWriter() {
    const e42 = H2().vec3f(e16.POSITION).vec4f(e16.UVMAPSPACE);
    return this.parameters.draped || e42.mat3f(e16.BOUNDINGRECT), this.parameters.vvColor ? e42.f32(e16.COLORFEATUREATTRIBUTE) : e42.vec4u8(e16.COLOR), has("enable-feature:objectAndLayerId-rendering") && e42.vec4u8(e16.OBJECTANDLAYERIDCOLOR), new E20(e42);
  }
};
var v10 = class extends t16 {
  _updateParameters(e42) {
    return this.ensureTechnique(S17, e42);
  }
  _updateOccludeeState(e42) {
    e42.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e42.hasOccludees });
  }
  beginSlot(e42) {
    return this._output !== o7.Color && this._output !== o7.Alpha || this._updateOccludeeState(e42), this._updateParameters(e42);
  }
};
var E20 = class extends r13 {
  write(e42, s32, i20, a28, o27) {
    E6(i20, this.vertexBufferLayout, e42, s32, a28, o27);
    for (const n28 of this.vertexBufferLayout.fields.keys()) {
      const s33 = i20.attributes.get(n28), c32 = s33 == null ? void 0 : s33.indices;
      if (s33 && c32)
        switch (n28) {
          case e16.UVMAPSPACE: {
            s13(4 === s33.size);
            const e43 = a28.getField(n28, c11);
            e43 && p7(s33, e43, o27);
            break;
          }
          case e16.BOUNDINGRECT: {
            s13(9 === s33.size);
            const r39 = a28.getField(n28, l10);
            r39 && S18(s33, e42, r39, o27);
            break;
          }
        }
    }
  }
};
function S18(e42, t32, r39, s32) {
  const { data: i20, indices: a28 } = e42, o27 = t32, n28 = r39.typedBuffer, c32 = r39.typedBufferStride, l31 = a28.length;
  s32 *= c32;
  for (let u32 = 0; u32 < l31; ++u32) {
    const e43 = 9 * a28[u32], t33 = i20[e43], r40 = i20[e43 + 1], l32 = i20[e43 + 2];
    n28[s32] = o27[0] * t33 + o27[4] * r40 + o27[8] * l32 + o27[12], n28[s32 + 1] = o27[1] * t33 + o27[5] * r40 + o27[9] * l32 + o27[13], n28[s32 + 2] = o27[2] * t33 + o27[6] * r40 + o27[10] * l32 + o27[14];
    for (let a29 = 3; a29 < 9; ++a29)
      n28[s32 + a29] = i20[e43 + a29];
    s32 += c32;
  }
}
var j17 = class extends t20 {
  constructor() {
    super(...arguments), this.color = r5(1, 1, 1, 1), this.writeLinearDepth = false, this.hasVertexColors = false, this.polygonOffset = false, this.hasSlicePlane = false, this.cullFace = e21.None, this.hasOccludees = false, this.style = a14.Cross, this.patternSpacing = 10, this.lineWidth = 1, this.draped = true;
  }
};

// node_modules/@arcgis/core/views/3d/layers/support/patternUtils.js
function s30(e42, r39) {
  const a28 = (e42 == null ? void 0 : e42.pattern) ?? null;
  return null == a28 ? new _8(r39) : "none" === a28.style || "solid" === a28.style ? ("none" === a28.style && (r39.color = r5(0, 0, 0, 0), r39.forceTransparentMode = true), new _8(r39)) : (r39.style = l29(a28.style), new P10(r39));
}
function l29(t32) {
  switch (t32) {
    case "horizontal":
      return a14.Horizontal;
    case "vertical":
      return a14.Vertical;
    case "cross":
      return a14.Cross;
    case "forward-diagonal":
      return a14.ForwardDiagonal;
    case "backward-diagonal":
      return a14.BackwardDiagonal;
    case "diagonal-cross":
      return a14.DiagonalCross;
    default:
      return;
  }
}
function c30(t32) {
  return t32.material instanceof P10 && !t32.material.parameters.draped;
}
function u31(t32, e42) {
  if (c30(t32)) {
    const n28 = t32.attributes.get(e16.POSITION).data, o27 = t32.getMutableAttribute(e16.UVMAPSPACE).data, i20 = t32.getMutableAttribute(e16.BOUNDINGRECT).data;
    M8(o27, i20, n28, e42);
  }
}
function m20(t32, r39, a28, n28, o27) {
  const i20 = u18(t32, r39, a28, n28, o27), s32 = t32.stageObject.geometries;
  for (const e42 of s32)
    u31(e42, o27);
  return i20;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DPolygonFillSymbolLayer.js
var z5 = ["polyline", "polygon", "extent"];
var H5 = new B({ size: false, color: true, rotation: false, opacity: false });
var N5 = class _N extends h13 {
  constructor(e42, t32, i20, r39) {
    super(e42, t32, i20, r39), this._needsUV = false;
  }
  async doLoad() {
    this._fastUpdates = O8(this._context.renderer, H5);
  }
  _createMaterials() {
    var _a, _b, _c;
    if (this._materials.length > 0)
      return;
    const e42 = (_b = (_a = this.symbolLayer) == null ? void 0 : _a.material) == null ? void 0 : _b.color, i20 = this._getCombinedOpacityAndColor(e42);
    this._materials[J4.Fill] = s30(this.symbolLayer, { color: i20, forceTransparentMode: this.needsDrivenTransparentPass, polygonOffset: false, hasVertexColors: true, writeLinearDepth: true, draped: this.draped, hasSlicePlane: this._context.slicePlaneEnabled, ...(_c = this._fastUpdates) == null ? void 0 : _c.materialParameters }), this._needsUV = this._materials[J4.Fill] instanceof P10;
    const r39 = this.symbolLayer.outline;
    if (K5(r39)) {
      const e43 = n15(r39.pattern);
      this._materials[J4.Outline] = new H3({ width: u8(r39.size), color: this._getOutlineColor(), hasPolygonOffset: true, hasSlicePlane: this._context.slicePlaneEnabled, isClosed: true, stipplePattern: e43, cap: n20(r39.patternCap || "butt") });
    }
    this._context.stage.addMany(this._materials);
  }
  destroy() {
    super.destroy(), this._context.stage.removeMany(this._materials), this._materials.length = 0;
  }
  createGraphics3DGraphic(e42) {
    const t32 = e42.graphic;
    if (!this._validateGeometry(t32.geometry, z5, this.symbolLayer.type))
      return null;
    const i20 = this._getVertexOpacityAndColor(e42.renderingInfo, 255), r39 = this.setGraphicElevationContext(t32);
    return this.ensureDrapedStatus("on-the-ground" === r39.mode), this._createMaterials(), this.draped ? this._createAsOverlay(t32, i20) : this._createAs3DShape(t32, i20, r39);
  }
  applyRendererDiff(e42, t32) {
    var _a;
    for (const i20 in e42.diff) {
      if ("visualVariables" !== i20)
        return e33.RecreateSymbol;
      if (!G4(this._fastUpdates, t32, H5))
        return e33.RecreateSymbol;
      (_a = this._materials[J4.Fill]) == null ? void 0 : _a.setParameters(this._fastUpdates.materialParameters);
    }
    return e33.FastUpdate;
  }
  layerOpacityChanged() {
    var _a, _b;
    if (null != this._materials[J4.Fill]) {
      const e42 = this._materials[J4.Fill].parameters.color, t32 = (_b = (_a = this.symbolLayer) == null ? void 0 : _a.material) == null ? void 0 : _b.color, i20 = this._getCombinedOpacity(t32);
      this._materials[J4.Fill].setParameters({ color: [e42[0], e42[1], e42[2], i20], forceTransparentMode: this.needsDrivenTransparentPass });
    }
    if (null != this._materials[J4.Outline]) {
      const e42 = this._materials[J4.Outline].parameters.color;
      this._materials[J4.Outline].setParameters({ color: [e42[0], e42[1], e42[2], this._getOutlineOpacity()] });
    }
  }
  layerElevationInfoChanged(e42, t32, i20) {
    const r39 = this._elevationContext.mode, o27 = m9(_N.elevationModeChangeTypes, i20, r39);
    if (o27 !== b7.UPDATE)
      return o27;
    const s32 = d8(r39);
    return this.updateGraphics3DGraphicElevationInfo(e42, t32, () => s32);
  }
  slicePlaneEnabledChanged() {
    var _a;
    if ((_a = this._materials[J4.Fill]) == null ? void 0 : _a.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), this._materials[J4.Outline]) {
      const e42 = { hasSlicePlane: this._context.slicePlaneEnabled };
      this._materials[J4.Outline].setParameters(e42);
    }
    return true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  _createAs3DShape(e42, t32, i20) {
    var _a;
    const r39 = A6(e42.geometry);
    if (!r39)
      return null;
    const o27 = p17(r39, this._context.elevationProvider, this._context.renderCoordsHelper, i20), s32 = new k11(o27, t32, this._context.layer.uid, e42.uid), n28 = s32.renderData.position.length / 3;
    if (this._needsUV && (s32.uvMapSpace = t14(4 * n28, true), s32.boundingRect = t9(9 * n28, true), M8(s32.uvMapSpace, s32.boundingRect, s32.renderData.position, this._context.renderCoordsHelper)), s32.objectAndLayerIdColor = (_a = this._context.stage.renderView) == null ? void 0 : _a.getObjectAndLayerIdColor(s32), this._createAs3DShapeFill(e42, s32), this._materials[J4.Outline] && this._createAs3DShapeOutline(s32), this._logGeometryCreationWarnings(s32.renderData, r39.rings, "rings", "FillSymbol3DLayer"), 0 === s32.outGeometries.length)
      return null;
    const a28 = new O9({ geometries: s32.outGeometries, castShadow: false, layerUid: this._context.layer.uid, graphicUid: e42.uid }), c32 = new p13(this, a28, s32.outGeometries, null, null, m20, i20);
    return c32.alignedSampledElevation = s32.renderData.sampledElevation, c32.needsElevationUpdates = d8(i20.mode), c32;
  }
  _createAs3DShapeFill(e42, t32) {
    var _a;
    const i20 = t32.renderData.polygons;
    for (const { position: r39, mapPositions: a28, holeIndices: l31, index: p23, count: u32 } of i20) {
      if (null != this._context.clippingExtent && (P2(W6), c4(W6, a28), !V(W6, this._context.clippingExtent)))
        continue;
      const i21 = w5(a28, l31, this._context.elevationProvider.spatialReference);
      if (0 === i21.length)
        continue;
      const d20 = (_a = this._fastUpdates) == null ? void 0 : _a.visualVariables.color, m22 = d6({ material: this._materials[J4.Fill], indices: i21, mapPositions: a28, attributeData: { position: r39, color: d20 ? null : t32.color, colorFeature: d20 ? X(d20.field, e42) : null, uvMapSpace: this._needsUV ? o10(t32.uvMapSpace, 4 * p23, 4 * u32) : null, boundingRect: this._needsUV ? a9(t32.boundingRect, 9 * p23, 9 * u32) : null, objectAndLayerIdColor: t32.objectAndLayerIdColor } });
      t32.outGeometries.push(m22);
    }
  }
  _createAs3DShapeOutline(e42) {
    if (null == this._materials[J4.Outline])
      return;
    const t32 = e42.renderData.outlines;
    for (const { mapPositions: i20, position: r39 } of t32) {
      if (null != this._context.clippingExtent && (P2(W6), c4(W6, i20), !V(W6, this._context.clippingExtent)))
        continue;
      const t33 = b9(this._materials[J4.Outline], { overlayInfo: null, removeDuplicateStartEnd: true, mapPositions: i20, attributeData: { position: r39 } }, e42.objectAndLayerIdColor);
      e42.outGeometries.push(t33);
    }
  }
  _createAsOverlay(e42, t32) {
    var _a;
    const i20 = A6(e42.geometry);
    if (null == i20)
      return null;
    this._materials[J4.Fill].renderPriority = this._renderPriority + this._renderPriorityStep / 2, null != this._materials[J4.Outline] && (this._materials[J4.Outline].renderPriority = this._renderPriority);
    const r39 = c24(i20, this._context.overlaySR), s32 = new q10(r39, t32, this._context.layer.uid, e42.uid), n28 = s32.renderData.position.length / 3;
    return this._needsUV && (s32.uvMapSpace = t14(4 * n28, true), T6(s32.uvMapSpace, s32.renderData.position, this._context.overlaySR, this._context.graphicsCoreOwner.view.state.viewingMode)), s32.outBoundingBox = P2(), s32.objectAndLayerIdColor = (_a = this._context.stage.renderView) == null ? void 0 : _a.getObjectAndLayerIdColor(s32), this._createAsOverlayFill(e42, s32), this._materials[J4.Outline] && this._createAsOverlayOutline(s32), this._logGeometryCreationWarnings(s32.renderData, i20.rings, "rings", "FillSymbol3DLayer"), 0 === s32.outGeometries.length ? null : new l24(this, s32.outGeometries, s32.outBoundingBox, this._context.drapeSourceRenderer);
  }
  _createAsOverlayFill(e42, t32) {
    var _a;
    const r39 = t32.renderData.polygons;
    for (const { position: l31, holeIndices: c32, index: p23, count: u32 } of r39) {
      const r40 = P2(W6);
      if (c4(r40, l31), !V(r40, this._context.clippingExtent))
        continue;
      const d20 = i4(l31, c32, 3);
      if (0 === d20.length)
        continue;
      o3(t32.outBoundingBox, r40);
      const m22 = (_a = this._fastUpdates) == null ? void 0 : _a.visualVariables.color, y10 = d6({ material: this._materials[J4.Fill], indices: d20, attributeData: { position: l31, color: m22 ? null : t32.color, colorFeature: m22 ? X(m22.field, e42) : null, uvMapSpace: this._needsUV ? o10(t32.uvMapSpace, 4 * p23, 4 * u32) : null, objectAndLayerIdColor: t32.objectAndLayerIdColor } });
      t32.outGeometries.push(new m8(y10, t32));
    }
  }
  _createAsOverlayOutline(e42) {
    if (null == this._materials[J4.Outline])
      return;
    const t32 = e42.renderData.outlines;
    for (let i20 = 0; i20 < t32.length; ++i20) {
      const { position: r39 } = t32[i20];
      if (P2(W6), c4(W6, r39), !V(W6, this._context.clippingExtent))
        continue;
      o3(e42.outBoundingBox, W6);
      const l31 = b9(this._materials[J4.Outline], { overlayInfo: { spatialReference: this._context.overlaySR, renderCoordsHelper: this._context.renderCoordsHelper }, removeDuplicateStartEnd: true, attributeData: { position: r39 } }, e42.objectAndLayerIdColor);
      e42.outGeometries.push(new m8(l31, e42));
    }
  }
  _getOutlineOpacity() {
    var _a, _b;
    const e42 = (_b = (_a = this.symbolLayer) == null ? void 0 : _a.outline) == null ? void 0 : _b.color;
    return (this.draped ? 1 : this._getLayerOpacity()) * (null != e42 ? e42.a : 0);
  }
  _getOutlineColor() {
    var _a, _b;
    const t32 = (_b = (_a = this.symbolLayer) == null ? void 0 : _a.outline) == null ? void 0 : _b.color, i20 = this._getOutlineOpacity();
    return F6(null != t32 ? u9.toUnitRGB(t32) : null, i20);
  }
  test() {
    return { ...super.test(), createAsOverlay: (e42, t32) => this._createAsOverlay(e42, t32), createAs3DShape: (e42, t32, i20) => this._createAs3DShape(e42, t32, i20) };
  }
};
N5.elevationModeChangeTypes = { definedChanged: b7.RECREATE, staysOnTheGround: b7.NONE, onTheGroundChanged: b7.RECREATE };
var W6 = i();
var k11 = class extends O4 {
  constructor(e42, t32, i20, r39) {
    super(e42, i20, r39), this.color = t32;
  }
};
var q10 = class extends O4 {
  constructor(e42, t32, i20, r39) {
    super(e42, i20, r39), this.color = t32;
  }
};
var J4;
function K5(e42) {
  return null != (e42 == null ? void 0 : e42.size) && e42.size > 0 && null != e42.color && (null == e42.pattern || "style" !== e42.pattern.type || "none" !== e42.pattern.style);
}
!function(e42) {
  e42[e42.Fill = 0] = "Fill", e42[e42.Outline = 1] = "Outline";
}(J4 || (J4 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextTextureFactory.js
var i18 = class {
  constructor(e42, n28, s32) {
    this._renderer = new r29(e42, n28, s32, j12.maxSize);
  }
  get key() {
    return this._renderer.key;
  }
  get baselineAnchorY() {
    return 1 - this._renderer.firstRenderedBaselinePosition / this._renderer.renderedHeight;
  }
  get displayWidth() {
    return this._renderer.displayWidth;
  }
  get displayHeight() {
    return this._renderer.displayHeight;
  }
  create() {
    const r39 = a19(d19, this._renderer.renderedWidth, this._renderer.renderedHeight), t32 = r39.getContext("2d");
    return t32.save(), this._renderer.render(t32, 0, 0), t32.restore(), new N(r39, { wrap: { s: D4.CLAMP_TO_EDGE, t: D4.CLAMP_TO_EDGE }, noUnpackFlip: false, mipmap: true, preMultiplyAlpha: true });
  }
};
var d19 = { canvas: null };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DTextSymbolLayer.js
var R10 = r3(0, 0, 1);
var D10 = class extends h13 {
  constructor(e42, t32, r39, n28) {
    super(e42, t32, r39, n28), this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: false }, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    if (!this._drivenProperties.size) {
      const t32 = I6(this.symbolLayer.size);
      if (t32)
        throw new s2("graphics3dtextsymbollayer:invalid-size", t32);
    }
    await this._createTextRenderParameters();
  }
  async _createTextRenderParameters() {
    const e42 = this._context.graphicsCoreOwner.view.state.rasterPixelRatio;
    this._textRenderParameters = await s25.fromSymbol(this.symbolLayer, e42);
  }
  destroy() {
    super.destroy();
  }
  createGraphics3DGraphic(e42) {
    const t32 = e42.graphic, r39 = m13(t32.geometry);
    if (null == r39)
      return this.logger.warn(`unsupported geometry type for text symbol: ${t32.geometry.type}`), null;
    const n28 = this.symbolLayer.text;
    if (null == n28 || "" === n28)
      return null;
    const s32 = o5(this.symbol) && this.symbol.hasVisibleVerticalOffset() ? this.symbol.verticalOffset : null;
    if (null != s32 && !l4(this.symbolLayer))
      return this.logger.errorOncePerTick(`Callouts and vertical offset on text symbols are currently only supported with 'center' horizontal alignment (not with '${this.symbolLayer.horizontalAlignment}' alignment)`), null;
    const { verticalAlignment: i20 } = this.symbolLayer, o27 = new i15(s32);
    h16(i20, o27.screenOffset);
    const c32 = new r30(o27, this.symbolLayer.horizontalAlignment, u21(i20));
    return this._createAs3DShape(t32, r39, n28, c32);
  }
  createLabel(e42, t32, r39, n28, s32) {
    const i20 = e42.graphic, o27 = m13(i20.geometry);
    if (null == o27)
      return this.logger.warn(`unsupported geometry type for label: ${i20.geometry.type}`), null;
    const l31 = t32.text;
    return !l31 || /^\s+$/.test(l31) ? null : this._createAs3DShape(i20, o27, l31, t32, r39, n28, s32);
  }
  setGraphicElevationContext(e42, t32, r39 = 0) {
    return super.setGraphicElevationContext(e42, t32), t32.addOffsetRenderUnits(r39), t32;
  }
  layerOpacityChanged() {
    return this.logger.warn("layer opacity change not yet implemented in Graphics3DTextSymbolLayer"), false;
  }
  layerElevationInfoChanged(e42, t32) {
    return A15(e42, t32, (e43, t33) => {
      this.updateGraphicElevationContext(t33, e43);
    }), b7.UPDATE;
  }
  slicePlaneEnabledChanged(e42, t32) {
    return A15(e42, t32, (e43) => {
      for (const t33 of e43.stageObject.geometries)
        t33.material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  get pixelRatioChanged() {
    return false;
  }
  updateGraphicElevationContext(e42, t32) {
    const r39 = t32.elevationContext;
    this.setGraphicElevationContext(e42, r39, null != t32.metadata ? t32.metadata.elevationOffset : 0), t32.needsElevationUpdates = d8(r39.mode) || "absolute-height" === r39.mode;
  }
  _defaultElevationInfoNoZ() {
    return W7;
  }
  _createAs3DShape(e42, o27, l31, a28, m22 = null, d20 = null, g15 = () => a28.placement.elevationOffset) {
    var _a;
    const y10 = this.setGraphicElevationContext(e42, new o15(), a28.placement.elevationOffset), x12 = "polyline" === ((_a = e42.geometry) == null ? void 0 : _a.type), v13 = e42.uid;
    let b18 = null, O17 = null;
    if (null == d20) {
      const e43 = f14(a28.horizontalPlacement);
      b18 = new i18(l31, e43, this._textRenderParameters);
      let r39 = null;
      if (null != this._context.sharedResources.textures) {
        O17 = this._context.sharedResources.textures.fromData(b18.key, () => b18.create()), O17.texture.events.on("unloaded", () => r39 == null ? void 0 : r39.release());
        const e44 = this._context.stage.renderView.textureRepository.acquire(O17.texture.id);
        if (null == e44 || S(e44))
          return O17.release(), null;
        r39 = e44;
      }
    }
    const j19 = T7(b18, a28), w13 = { occlusionTest: true, screenOffset: a28.placement.screenOffset, anchorPosition: j19, polygonOffset: true, color: [1, 1, 1, 1], centerOffsetUnits: a28.placement.centerOffsetUnits, drawInSecondSlot: true };
    if (d20 ? w13.textureId = d20.id : O17 && (w13.textureId = O17.texture.id), null != a28.placement.verticalOffset) {
      const { screenLength: e43, minWorldLength: t32, maxWorldLength: n28 } = a28.placement.verticalOffset;
      w13.verticalOffset = { screenLength: u8(e43), minWorldLength: t32 || 0, maxWorldLength: null != n28 ? n28 : 1 / 0 };
    }
    if (this._context.screenSizePerspectiveEnabled) {
      const { screenSizePerspectiveSettings: e43, screenSizePerspectiveSettingsLabels: t32 } = this._context.sharedResources, r39 = e35(this._textRenderParameters);
      w13.screenSizePerspective = t32.overrideFontHeight(r39.maxHeight), w13.screenSizePerspectiveAlignment = e43;
    }
    x12 && (w13.shaderPolygonOffset = 1e-4), w13.hasSlicePlane = this._context.slicePlaneEnabled;
    const S21 = (e43, t32) => {
      const r39 = JSON.stringify(t32);
      let n28 = e43.get(r39);
      return null == n28 && (n28 = new Q2(t32), e43.add(r39, n28)), n28;
    }, C6 = m22 ? S21(m22, w13) : new Q2(w13), D11 = a28.placement.translation, A16 = b18 ? r7(b18.displayWidth, b18.displayHeight) : a6, W9 = a28.placement.centerOffset, H6 = R10, I15 = n9(), V12 = ht(C6, H6, D11, null, A16, W9, I15, null), $2 = c20(this._context, o27, V12, y10, v13);
    if (null == $2)
      return null;
    const F14 = (t32, r39, n28, s32, i20, o28) => {
      const l32 = g15() || a28.placement.elevationOffset, m23 = this.setGraphicElevationContext(e42, r39, l32);
      return p12(t32, m23, n28, s32, i20, o28);
    }, M11 = new p13(this, $2.object, [V12], null == m22 ? [C6] : null, O17, F14, y10);
    M11.alignedSampledElevation = $2.sampledElevation, M11.needsElevationUpdates = d8(y10.mode) || "absolute-height" === y10.mode, M11.getScreenSize = (e43 = n9()) => (e43[0] = b18 ? b18.displayWidth : a28.displaySize[0], e43[1] = b18 ? b18.displayHeight : a28.displaySize[1], e43);
    const k14 = new t25(a28.placement.elevationOffset, l31);
    return M11.metadata = k14, p15(M11, o27, this._context.elevationProvider), M11;
  }
};
function A15(e42, t32, r39) {
  e42 && e42.forEach((e43) => {
    const n28 = t32(e43);
    null != n28 && r39(n28, e43.graphic);
  });
}
function T7(e42, t32) {
  if ("baseline" === t32.verticalPlacement) {
    const r40 = i14[t32.horizontalPlacement], s32 = null != e42 ? e42.baselineAnchorY : 0;
    return r7(r40, s32);
  }
  const r39 = m15(t32.horizontalPlacement, t32.verticalPlacement);
  return s24[r39];
}
var W7 = { mode: "relative-to-ground", offset: 0 };

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/WaterTechnique.js
var S19 = class _S extends r14 {
  initializeConfiguration(e42, o27) {
    o27.spherical = e42.viewingMode === l6.Global, o27.doublePrecisionRequiresObfuscation = e42.rctx.driverTest.doublePrecisionRequiresObfuscation.result;
  }
  initializeProgram(e42) {
    return new r15(e42.rctx, _S.shader.get().build(this.configuration), O6);
  }
  _setPipelineState(e42) {
    const t32 = this.configuration, r39 = e42 === o11.NONE, i20 = e42 === o11.FrontFace;
    return S5({ blending: t32.output !== o7.Normal && t32.output !== o7.Highlight && t32.output !== o7.ObjectAndLayerIdColor && t32.transparent ? r39 ? c16 : A7(e42) : null, depthTest: t32.draped ? null : { func: l13(e42) }, depthWrite: t32.draped ? null : r39 ? t32.writeDepth ? o12 : null : E5(e42), colorWrite: _6, polygonOffset: r39 || i20 ? null : a11(t32.enableOffset) });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
};
S19.shader = new t17(M4, () => import("./WaterSurface.glsl-B7H4RE4S.js"));
var T8 = class extends t21 {
  constructor() {
    super(...arguments), this.output = o7.Color, this.transparencyPassType = o11.NONE, this.spherical = false, this.receiveShadows = false, this.hasSlicePlane = false, this.transparent = false, this.enableOffset = true, this.writeDepth = false, this.hasScreenSpaceReflections = false, this.doublePrecisionRequiresObfuscation = false, this.hasCloudsReflections = false, this.objectAndLayerIdColorInstanced = false, this.draped = false, this.multipassEnabled = false, this.cullAboveGround = false;
  }
};
e([r17({ count: o7.COUNT })], T8.prototype, "output", void 0), e([r17({ count: o11.COUNT })], T8.prototype, "transparencyPassType", void 0), e([r17()], T8.prototype, "spherical", void 0), e([r17()], T8.prototype, "receiveShadows", void 0), e([r17()], T8.prototype, "hasSlicePlane", void 0), e([r17()], T8.prototype, "transparent", void 0), e([r17()], T8.prototype, "enableOffset", void 0), e([r17()], T8.prototype, "writeDepth", void 0), e([r17()], T8.prototype, "hasScreenSpaceReflections", void 0), e([r17()], T8.prototype, "doublePrecisionRequiresObfuscation", void 0), e([r17()], T8.prototype, "hasCloudsReflections", void 0), e([r17()], T8.prototype, "objectAndLayerIdColorInstanced", void 0), e([r17()], T8.prototype, "draped", void 0), e([r17()], T8.prototype, "multipassEnabled", void 0), e([r17()], T8.prototype, "cullAboveGround", void 0), e([r17({ constValue: false })], T8.prototype, "occlusionPass", void 0), e([r17({ constValue: c13.Water })], T8.prototype, "pbrMode", void 0), e([r17({ constValue: true })], T8.prototype, "useCustomDTRExponentForWater", void 0), e([r17({ constValue: true })], T8.prototype, "highStepCount", void 0), e([r17({ constValue: false })], T8.prototype, "useFillLights", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/WaterGLMaterial.js
var s31 = class extends t16 {
  _updateShadowState(e42) {
    e42.shadowMap.enabled !== this._material.parameters.receiveShadows && this._material.setParameters({ receiveShadows: e42.shadowMap.enabled });
  }
  _updateSSRState(e42) {
    const t32 = null != e42.ssr.lastFrameColor;
    t32 !== this._material.parameters.hasScreenSpaceReflections && this._material.setParameters({ hasScreenSpaceReflections: t32 });
  }
  _updateCloudsReflectionState(e42) {
    const t32 = null != e42.cloudsFade.data;
    t32 !== this._material.parameters.hasCloudsReflections && this._material.setParameters({ hasCloudsReflections: t32 });
  }
  ensureResources(e42) {
    return this._techniqueRepository.constructionContext.waterTextureRepository.ensureResources(e42);
  }
  beginSlot(t32) {
    return this._output === o7.Color && (this._updateShadowState(t32), this._updateSSRState(t32), this._updateCloudsReflectionState(t32)), this._material.setParameters(this._techniqueRepository.constructionContext.waterTextureRepository.passParameters), this.ensureTechnique(S19, t32);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/WaterMaterial.js
var _15 = class extends e29 {
  constructor(e42) {
    super(e42, new S20()), this._configuration = new T8(), this._animation = new e26(), this.produces = /* @__PURE__ */ new Map([[A8.OPAQUE_MATERIAL, (e43) => i3(e43) && !this.parameters.transparent || e18(e43)], [A8.TRANSPARENT_MATERIAL, (e43) => i3(e43) && this.parameters.transparent || e18(e43)], [A8.DRAPED_MATERIAL, (e43) => this.parameters.draped && e43 === o7.Color || e18(e43)], [A8.DRAPED_WATER, (e43) => e43 === o7.Normal]]);
  }
  getConfiguration(e42, t32) {
    return this._configuration.output = e42, this._configuration.writeDepth = true, this._configuration.receiveShadows = this.parameters.receiveShadows, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.transparent = this.parameters.transparent, this._configuration.hasScreenSpaceReflections = this.parameters.hasScreenSpaceReflections, this._configuration.hasCloudsReflections = this.parameters.hasCloudsReflections, this._configuration.draped = this.parameters.draped, this._configuration.transparencyPassType = t32.transparencyPassType, this._configuration.enableOffset = t32.camera.relativeElevation < S6, this._configuration.multipassEnabled = t32.multipassEnabled, this._configuration.cullAboveGround = t32.multipassTerrain.cullAboveGround, this._configuration;
  }
  update(t32) {
    const r39 = Math.min(t32.camera.relativeElevation, t32.camera.distance);
    this._animation.enabled = Math.sqrt(this.parameters.waveTextureRepeat / this.parameters.waveStrength) * r39 < b16;
    const a28 = this._animation.advance(t32);
    return this.setParameters({ timeElapsed: u3(this._animation.time) * this.parameters.animationSpeed }, false), this._animation.enabled && a28;
  }
  createGLMaterial(e42) {
    return new s31(e42);
  }
  createBufferWriter() {
    return new r13(has("enable-feature:objectAndLayerId-rendering") ? I5 : f8);
  }
  get test() {
    return { animationEnabled: this._animation.enabled };
  }
};
var S20 = class extends u14 {
  constructor() {
    super(...arguments), this.waveStrength = 0.06, this.waveTextureRepeat = 32, this.waveDirection = r7(1, 0), this.waveVelocity = 0.05, this.flowStrength = 0.015, this.flowOffset = -0.5, this.animationSpeed = 0.35, this.timeElapsed = 0, this.color = r5(0, 0, 0, 0), this.transparent = true, this.hasSlicePlane = false, this.draped = false, this.receiveShadows = true, this.hasScreenSpaceReflections = false, this.hasCloudsReflections = false, this.origin = n2(), this.modelTransformation = null;
  }
};
var b16 = 35e3;

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/waterMaterialUtils.js
var e41 = { "calm-small": { waveStrength: 5e-3, perturbationStrength: 0.02, textureRepeat: 12, waveVelocity: 0.01 }, "rippled-small": { waveStrength: 0.02, perturbationStrength: 0.09, textureRepeat: 32, waveVelocity: 0.07 }, "slight-small": { waveStrength: 0.05, perturbationStrength: 0.07, textureRepeat: 28, waveVelocity: 0.1 }, "moderate-small": { waveStrength: 0.075, perturbationStrength: 0.07, textureRepeat: 24, waveVelocity: 0.1 }, "calm-medium": { waveStrength: 3125e-6, perturbationStrength: 0.01, textureRepeat: 8, waveVelocity: 0.02 }, "rippled-medium": { waveStrength: 0.035, perturbationStrength: 0.015, textureRepeat: 12, waveVelocity: 0.07 }, "slight-medium": { waveStrength: 0.06, perturbationStrength: 0.015, textureRepeat: 8, waveVelocity: 0.12 }, "moderate-medium": { waveStrength: 0.09, perturbationStrength: 0.03, textureRepeat: 4, waveVelocity: 0.12 }, "calm-large": { waveStrength: 0.01, perturbationStrength: 0, textureRepeat: 4, waveVelocity: 0.05 }, "rippled-large": { waveStrength: 0.025, perturbationStrength: 0.01, textureRepeat: 8, waveVelocity: 0.11 }, "slight-large": { waveStrength: 0.06, perturbationStrength: 0.02, textureRepeat: 3, waveVelocity: 0.13 }, "moderate-large": { waveStrength: 0.14, perturbationStrength: 0.03, textureRepeat: 2, waveVelocity: 0.15 } };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DWaterSymbolLayer.js
var I13 = ["polyline", "polygon", "extent"];
var B5 = class _B extends h13 {
  constructor(e42, t32, r39, o27) {
    super(e42, t32, r39, o27);
  }
  async doLoad() {
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._materials[0]), this._materials.length = 0;
  }
  createGraphics3DGraphic(e42) {
    const t32 = e42.graphic;
    if (!this._validateGeometry(t32.geometry, I13, this.symbolLayer.type))
      return null;
    const r39 = this.setGraphicElevationContext(t32);
    return this.ensureDrapedStatus("on-the-ground" === r39.mode), this.ensureMaterial(), this.draped ? this._createAsOverlay(t32) : this._createAs3DShape(t32, r39, t32.uid);
  }
  ensureMaterial() {
    if (this._materials[0])
      return;
    const t32 = new S20(), r39 = this.symbolLayer.color;
    null != r39 && (t32.color = u9.toUnitRGBA(r39));
    const o27 = this._getCombinedOpacity(r39, { hasIntrinsicColor: true });
    t32.color = [t32.color[0], t32.color[1], t32.color[2], o27], t32.transparent = o27 < 1 || this.needsDrivenTransparentPass, t32.waveDirection = null != this.symbolLayer.waveDirection ? _B.headingVectorFromAngle(this.symbolLayer.waveDirection) : r7(0, 0);
    const n28 = this.symbolLayer.waveStrength + "-" + this.symbolLayer.waterbodySize, s32 = e41[n28];
    t32.waveStrength = s32.waveStrength, t32.waveTextureRepeat = s32.textureRepeat, t32.waveVelocity = s32.waveVelocity, t32.flowStrength = s32.perturbationStrength, t32.hasSlicePlane = this._context.slicePlaneEnabled, t32.draped = this.draped, this._materials[0] = new _15(t32), this._context.stage.add(this._materials[0]);
  }
  layerOpacityChanged() {
    if (null == this._materials[0])
      return;
    const e42 = this._materials[0].parameters.color, t32 = this._getCombinedOpacity(this.symbolLayer.color, { hasIntrinsicColor: true }), r39 = t32 < 1 || this.needsDrivenTransparentPass;
    this._materials[0].setParameters({ color: [e42[0], e42[1], e42[2], t32], transparent: r39 });
  }
  layerElevationInfoChanged(e42, t32, r39) {
    const o27 = this._elevationContext.mode, i20 = m9(_B.elevationModeChangeTypes, r39, o27);
    if (i20 !== b7.UPDATE)
      return i20;
    const n28 = d8(o27);
    return this.updateGraphics3DGraphicElevationInfo(e42, t32, () => n28);
  }
  slicePlaneEnabledChanged() {
    var _a;
    return (_a = this._materials[0]) == null ? void 0 : _a.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  _createAs3DShape(e42, t32, r39) {
    var _a;
    const o27 = A6(e42.geometry);
    if (null == o27)
      return null;
    const i20 = p17(o27, this._context.elevationProvider, this._context.renderCoordsHelper, t32), n28 = i20.position.length / 3, s32 = t9(2 * n28);
    U7(s32, i20.mapPositions, n28, this._context.elevationProvider.spatialReference);
    const a28 = new k12(i20, s32, this._context.layer.uid, e42.uid);
    if (a28.objectAndLayerIdColor = (_a = this._context.stage.renderView) == null ? void 0 : _a.getObjectAndLayerIdColor(a28), this._create3DShapeGeometries(a28), this._logGeometryCreationWarnings(a28.renderData, o27.rings, "rings", "WaterSymbol3DLayer"), 0 === a28.outGeometries.length)
      return null;
    const l31 = new O9({ geometries: a28.outGeometries, castShadow: false, layerUid: this._context.layer.uid, graphicUid: r39 }), c32 = new p13(this, l31, a28.outGeometries, null, null, u18, t32);
    return c32.alignedSampledElevation = a28.renderData.sampledElevation, c32.needsElevationUpdates = d8(t32.mode), c32;
  }
  _create3DShapeGeometries(e42) {
    const t32 = e42.renderData.polygons, o27 = e42.uvCoords;
    for (const { count: i20, index: n28, position: s32, mapPositions: a28, holeIndices: l31 } of t32) {
      if (null != this._context.clippingExtent && (P2(V10), c4(V10, a28), !V(V10, this._context.clippingExtent)))
        continue;
      const t33 = i4(a28, l31, 3);
      if (0 === t33.length)
        continue;
      const p23 = a9(o27, 2 * n28, 2 * i20), u32 = D3({ material: this._materials[0], indices: t33, mapPositions: a28, attributeData: { position: s32, uv0: p23 } }, e42.objectAndLayerIdColor);
      e42.outGeometries.push(u32);
    }
  }
  _createAsOverlay(e42) {
    var _a;
    const t32 = A6(e42.geometry);
    if (null == t32)
      return null;
    this._materials[0].renderPriority = this._renderPriority;
    const r39 = c24(t32, this._context.overlaySR), o27 = r39.position.length / 3, i20 = t9(2 * o27);
    U7(i20, r39.position, o27, this._context.overlaySR);
    const n28 = new F12(r39, i20, this._context.layer.uid, e42.uid);
    return n28.objectAndLayerIdColor = (_a = this._context.stage.renderView) == null ? void 0 : _a.getObjectAndLayerIdColor(n28), n28.outBoundingBox = P2(), this._createAsOverlayWater(n28), this._logGeometryCreationWarnings(n28.renderData, t32.rings, "rings", "WaterSymbol3DLayer"), 0 === n28.outGeometries.length ? null : new l24(this, n28.outGeometries, n28.outBoundingBox, this._context.drapeSourceRenderer);
  }
  _createAsOverlayWater(e42) {
    const t32 = e42.uvCoords, o27 = e42.renderData.polygons;
    for (const { position: i20, holeIndices: n28, index: s32, count: a28 } of o27) {
      if (P2(V10), c4(V10, i20), !V(V10, this._context.clippingExtent))
        continue;
      o3(e42.outBoundingBox, V10);
      const o28 = i4(i20, n28, 3);
      if (0 === o28.length)
        continue;
      const l31 = a9(t32, 2 * s32, 2 * a28), u32 = D3({ material: this._materials[0], indices: o28, attributeData: { position: i20, uv0: l31 } }, e42.objectAndLayerIdColor);
      e42.outGeometries.push(new m8(u32, e42));
    }
  }
  static headingVectorFromAngle(e42) {
    const t32 = n9(), r39 = u4(e42);
    return t32[0] = Math.sin(r39), t32[1] = Math.cos(r39), t32;
  }
  test() {
    return { ...super.test(), create3DShape: (e42) => this._createAs3DShape(e42.graphic, e42.elevationContext, e42.graphicUid), ensureMaterial: () => this.ensureMaterial() };
  }
};
function U7(e42, r39, i20, n28) {
  const a28 = W(n28);
  D(W8);
  for (let t32 = 0; t32 < i20; t32++)
    o8(z6, r39[3 * t32], r39[3 * t32 + 1]), f2(W8, z6);
  m3(W8, W8, a28);
  const l31 = W8[0] % B5.unitSizeOfTexture, c32 = W8[1] % B5.unitSizeOfTexture;
  M9[0] = W8[0] - l31, M9[1] = W8[1] - c32;
  for (let t32 = 0; t32 < i20; t32++)
    e42[2 * t32] = (r39[3 * t32] * a28 - M9[0]) / B5.unitSizeOfTexture, e42[2 * t32 + 1] = (r39[3 * t32 + 1] * a28 - M9[1]) / B5.unitSizeOfTexture;
}
B5.unitSizeOfTexture = 100, B5.elevationModeChangeTypes = { definedChanged: b7.RECREATE, staysOnTheGround: b7.NONE, onTheGroundChanged: b7.RECREATE };
var M9 = n9();
var W8 = u7();
var z6 = n9();
var V10 = i();
var k12 = class extends O4 {
  constructor(e42, t32, r39, o27) {
    super(e42, r39, o27), this.uvCoords = t32;
  }
};
var F12 = class extends O4 {
  constructor(e42, t32, r39, o27) {
    super(e42, r39, o27), this.uvCoords = t32;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolLayerFactory.js
function c31(o27, e42, t32, i20) {
  var _a;
  const m22 = ((_a = h23[o27.type]) == null ? void 0 : _a[e42.type]) || l30[e42.type];
  return m22 ? new m22(o27, e42, t32, i20) : (n.getLogger("esri.views.3d.layers.graphics.Graphics3DSymbolLayerFactory").error("GraphicsLayerFactory#make", `unknown symbol type ${e42.type}`), null);
}
var l30 = { icon: le, object: pe2, line: O13, path: te2, fill: N5, extrude: et, text: D10, water: B5 };
var h23 = { "mesh-3d": { fill: Ce } };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbol.js
var m21 = class extends r25 {
  set symbol(e42) {
    this._symbol = e42, e42.symbolLayers.forEach((t32, r39) => {
      const s32 = this.symbolLayers[r39];
      null != s32 && (s32.symbol = e42, s32.symbolLayer = t32);
    });
  }
  get symbol() {
    return this._symbol;
  }
  constructor(e42, t32, r39) {
    super(t32.schedule), this._symbol = e42, this._context = t32, this._backgroundLayers = r39, this._destroyed = false, this.symbolLayers = new Array(), this.referenced = 0, this._extentPadding = 0;
  }
  async doLoad(e42) {
    let o27 = this._symbol.symbolLayers;
    this._extentPadding = 0, this._backgroundLayers && (o27 = this._backgroundLayers.concat(o27));
    const a28 = o27.length;
    for (; this.symbolLayers.length < o27.length; )
      this.symbolLayers.push(null);
    this.symbolLayers.length = o27.length;
    const l31 = [];
    for (let t32 = 0; t32 < a28; t32++) {
      const s32 = o27.at(t32);
      if (false === s32.enabled)
        continue;
      p22.renderPriority = 1 - (1 + t32) / a28, p22.renderPriorityStep = 1 / a28, p22.ignoreDrivers = s32.ignoreDrivers;
      const n28 = c31(this.symbol, s32, this._context, p22), y10 = w(e42, () => {
        this.symbolLayers[t32] = null, n28.destroy();
      });
      y10 && l31.push(y10), this.symbolLayers[t32] = n28;
    }
    if (await a4(this.symbolLayers, async (e43, t32) => {
      if (null != e43)
        try {
          await e43.load(), this._extentPadding += Math.max(this._extentPadding, e43.extentPadding);
        } catch {
          this.symbolLayers[t32] = null;
        }
    }), l31.forEach((e43) => e43.remove()), s3(e42), this.symbolLayers.length && !this.symbolLayers.some((e43) => !!e43))
      throw new Error();
  }
  getSymbolLayerSize(e42) {
    const t32 = this.symbolLayers[e42];
    return null != t32 ? t32.getCachedSize() : null;
  }
  get extentPadding() {
    return this._extentPadding;
  }
  get symbologySnappingSupported() {
    return this.symbolLayers.some((e42) => e42 == null ? void 0 : e42.queryForSnapping);
  }
  createGraphics3DGraphic(e42, t32) {
    var _a, _b;
    const r39 = e42.graphic, s32 = this.symbolLayers.map((t33) => (t33 == null ? void 0 : t33.createGraphics3DGraphic(e42)) ?? null), o27 = this._context.arcade || ((_b = (_a = this._context.featureExpressionInfoContext) == null ? void 0 : _a.arcade) == null ? void 0 : _b.modules) || null;
    return new A11(r39, t32 || this, s32, e42.layer, o27);
  }
  get complexity() {
    return F7(this.symbolLayers.map((e42) => null != e42 ? e42.complexity : null));
  }
  globalPropertyChanged(e42, t32) {
    const r39 = this.symbolLayers.length;
    for (let s32 = 0; s32 < r39; s32++) {
      const r40 = this.symbolLayers[s32], o27 = (e43) => {
        const t33 = e43.layers[s32];
        return t33 instanceof p13 ? t33 : null;
      };
      if (null != r40 && !r40.globalPropertyChanged(e42, t32, o27))
        return false;
    }
    return true;
  }
  applyRendererDiff(e42, t32) {
    return this.loadStatus !== l18.LOADED ? e33.RecreateSymbol : this.symbolLayers.reduce((r39, s32) => r39 !== e33.RecreateSymbol && null != s32 ? Math.min(r39, s32.applyRendererDiff(e42, t32)) : r39, e33.FastUpdate);
  }
  prepareSymbolPatch(e42) {
    if (this.loadStatus === l18.FAILED)
      return;
    if ("partial" !== e42.diff.type)
      return;
    const t32 = e42.diff.diff;
    if (!t32.symbolLayers || "partial" !== t32.symbolLayers.type)
      return;
    const r39 = t32.symbolLayers.diff;
    this.symbolLayers.forEach((t33, s32) => {
      if (null == t33)
        return;
      const o27 = r39[s32];
      if (o27) {
        const r40 = { diff: o27, graphics3DGraphicPatches: [], symbolLayerStatePatches: [] };
        t33.prepareSymbolLayerPatch(r40), e42.symbolStatePatches.push(...r40.symbolLayerStatePatches), r40.graphics3DGraphicPatches.length && e42.graphics3DGraphicPatches.push((e43, t34) => {
          const o28 = e43.layers[s32];
          null != o28 && r40.graphics3DGraphicPatches.forEach((e44) => e44(o28, t34));
        });
      }
    });
  }
  updateGeometry(e42, t32) {
    return this._updateGeometryOrTransform(e42, (e43, r39) => e43.updateGeometry(r39, t32));
  }
  updateTransform(e42, t32, r39, s32) {
    return this._updateGeometryOrTransform(e42, (e43, o27) => e43.updateTransform(o27, t32, r39, s32));
  }
  _updateGeometryOrTransform(e42, t32) {
    for (let r39 = 0; r39 < this.symbolLayers.length; r39++) {
      const s32 = this.symbolLayers[r39];
      if (null == s32)
        continue;
      const o27 = e42.layers[r39];
      if (!o27 || !t32(s32, o27))
        return false;
    }
    return true;
  }
  onRemoveGraphic(e42) {
    for (let t32 = 0; t32 < this.symbolLayers.length; t32++) {
      const r39 = this.symbolLayers[t32];
      if (null == r39)
        continue;
      const s32 = e42.layers[t32];
      null != s32 && r39.onRemoveGraphic(s32);
    }
  }
  getFastUpdateStatus() {
    let e42 = 0, t32 = 0, r39 = 0;
    return this.symbolLayers.forEach((s32) => {
      null != s32 && (s32.loadStatus === l18.LOADING ? e42++ : s32.isFastUpdatesEnabled() ? r39++ : t32++);
    }), { loading: e42, slow: t32, fast: r39 };
  }
  async queryForSnapping(t32, r39, o27, a28) {
    const l31 = this.symbolLayers.filter(k).filter((e42) => null != e42.queryForSnapping).map((e42) => e42.queryForSnapping(t32, r39, o27, a28)), n28 = await Promise.all(l31);
    return s3(a28), n28.flat();
  }
  destroy() {
    if (this.destroyed)
      console.error("Graphics3DSymbol.destroy called when already destroyed!");
    else {
      super.destroy();
      for (const e42 of this.symbolLayers)
        null != e42 && e42.destroy();
      this.symbolLayers.length = 0, this._destroyed = true;
    }
  }
  get destroyed() {
    return this._destroyed;
  }
};
var p22 = new s26();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DWebStyleSymbol.js
var i19 = class extends r25 {
  constructor(t32, r39, s32) {
    super(r39), this.symbol = t32, this._convert = s32, this.symbologySnappingSupported = false, this.graphics3DSymbol = null, this.referenced = 0;
  }
  getSymbolLayerSize(t32) {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.getSymbolLayerSize(t32) : null;
  }
  get symbolLayers() {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.symbolLayers : [];
  }
  get extentPadding() {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.extentPadding : 0;
  }
  async doLoad(t32) {
    const r39 = await this.symbol.fetchSymbol({ signal: t32 });
    r39.id = this.symbol.id, this.graphics3DSymbol = this._convert(r39), null != this.graphics3DSymbol && await this.graphics3DSymbol.load();
  }
  createGraphics3DGraphic(t32) {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.createGraphics3DGraphic(t32, this) : null;
  }
  get complexity() {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.complexity : P4;
  }
  globalPropertyChanged(t32, r39) {
    return null != this.graphics3DSymbol && this.graphics3DSymbol.globalPropertyChanged(t32, r39);
  }
  applyRendererDiff(t32, s32) {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.applyRendererDiff(t32, s32) : e33.RecreateSymbol;
  }
  prepareSymbolPatch(t32) {
    null != this.graphics3DSymbol && this.graphics3DSymbol.prepareSymbolPatch(t32);
  }
  updateGeometry(t32, r39) {
    return null != this.graphics3DSymbol && this.graphics3DSymbol.updateGeometry(t32, r39);
  }
  updateTransform(t32, r39, s32, i20) {
    var _a;
    return ((_a = this.graphics3DSymbol) == null ? void 0 : _a.updateTransform(t32, r39, s32, i20)) ?? false;
  }
  onRemoveGraphic() {
  }
  getFastUpdateStatus() {
    return null != this.graphics3DSymbol ? this.graphics3DSymbol.getFastUpdateStatus() : { loading: 1, fast: 0, slow: 0 };
  }
  destroy() {
    null != this.graphics3DSymbol && this.graphics3DSymbol.destroy(), this.graphics3DSymbol = void 0, super.destroy();
  }
  get destroyed() {
    return void 0 === this.graphics3DSymbol;
  }
};

// node_modules/@arcgis/core/views/3d/support/intersectionUtils.js
function g14(r39, n28, t32, i20) {
  return x11(r39, n28, t32, h24(i20, n28, t32, true));
}
function j18(r39, c32, o27, u32) {
  const f23 = P(o27, e8(r39, u32, c32));
  return u5(r39, c32, g(r39, o27, f23));
}
var b17 = { dir: n2(), len: 0, clip: n9() };
function h24(r39, n28, i20, f23) {
  const l31 = b17;
  return r39 ? (i20 && f23 && (l31.len = x(n28, i20)), r4(l31.dir, r39)) : f23 ? (l31.len = x(n28, i20), e8(l31.dir, i20, n28), g(l31.dir, l31.dir, 1 / l31.len)) : (e8(l31.dir, i20, n28), z(l31.dir, l31.dir)), l31;
}
function v11(r39, t32, i20) {
  const e42 = P(F3(r39), i20.dir), c32 = -V2(r39, t32);
  if (c32 < 0 && e42 >= 0)
    return false;
  if (e42 > -1e-6 && e42 < 1e-6)
    return c32 > 0;
  if ((c32 < 0 || e42 < 0) && !(c32 < 0 && e42 < 0))
    return true;
  const o27 = c32 / e42;
  return e42 > 0 ? o27 < i20.clip[1] && (i20.clip[1] = o27) : o27 > i20.clip[0] && (i20.clip[0] = o27), i20.clip[0] <= i20.clip[1];
}
function x11(r39, n28, t32, i20) {
  i20.clip[0] = 0, i20.clip[1] = t32 ? i20.len : Number.MAX_VALUE;
  for (let e42 = 0; e42 < r39.length; e42++)
    if (!v11(r39[e42], n28, i20))
      return false;
  return true;
}

// node_modules/@arcgis/core/views/3d/support/FrustumExtentIntersection.js
var M10 = 0.5 * Math.PI;
var F13 = M10 / Math.PI * 180;
var N6 = class {
  constructor(t32) {
    this._renderCoordsHelper = t32.renderCoordsHelper, this._extent = new Array(4), this._planes = new Array(6), this._maxSpan = 0, this._center = { origin: n2(), direction: n2() };
    for (let e42 = 0; e42 < 4; e42++)
      this._extent[e42] = { origin: n2(), direction: n2(), cap: { next: null, direction: n2() } }, this._planes[e42] = E2();
    this._planes[j9.NEAR] = E2(), this._planes[j9.FAR] = E2(), this._planesWithoutFar = this._planes.slice(0, 5);
  }
  update(t32, e42, i20, r39 = true) {
    const a28 = this._extent;
    this._toRenderBoundingExtent(t32, e42, i20), u5(this._center.origin, a28[0].origin, a28[2].origin), g(this._center.origin, this._center.origin, 0.5), this._renderCoordsHelper.worldUpAtPosition(this._center.origin, this._center.direction), r39 || g(this._center.direction, this._center.direction, -1);
    for (let n28 = 0; n28 < 4; n28++) {
      const t33 = a28[n28];
      this._renderCoordsHelper.worldUpAtPosition(t33.origin, t33.direction);
      const e43 = a28[3 === n28 ? 0 : n28 + 1];
      t33.cap.next = e43.origin, J(t33.cap.direction, t33.origin, e43.origin), U(t33.direction, t33.cap.direction, t33.origin, this._planes[n28]), r39 || g(t33.direction, t33.direction, -1);
    }
    U(a28[0].cap.direction, a28[1].cap.direction, a28[0].origin, this._planes[j9.NEAR]), r39 ? q4(this._planes[j9.NEAR], this._planes[j9.FAR]) : (A4(this._planes[j9.FAR], this._planes[j9.NEAR]), q4(this._planes[j9.NEAR], this._planes[j9.NEAR])), this._maxSpan = Math.max(Math.abs(t32[0] - t32[2]), Math.abs(t32[1] - t32[3])), this._maxSpanSpatialReference = e42, this._minGlobalAltitude = 0.9 * s4(this._maxSpanSpatialReference).radius;
  }
  isVisibleInFrustum(t32, e42, i20 = false) {
    if (null == t32)
      return false;
    if (this._renderCoordsHelper.viewingMode === l6.Global) {
      const i21 = this._maxSpanSpatialReference.isGeographic ? F13 : M10 * e42;
      if (this._maxSpan > i21)
        return true;
      if (null != t32.altitude && t32.altitude >= this._minGlobalAltitude)
        return this._isVisibleInFrustumGlobal(t32);
    }
    if (0 === this._maxSpan) {
      const e43 = this._extent[0];
      return !(i20 || !t32.intersectsRay(p5(e43.origin, e43.direction)));
    }
    for (let n28 = 0; n28 < this._extent.length; n28++) {
      const e43 = this._extent[n28];
      if (!i20 && t32.intersectsRay(p5(e43.origin, e43.direction)))
        return true;
      if (t32.intersectsLineSegment(b4(e43.origin, e43.cap.next, P11), e43.cap.direction))
        return true;
    }
    const r39 = i20 ? this._planes : this._planesWithoutFar;
    for (let n28 = 0; n28 < t32.lines.length; n28++) {
      const e43 = t32.lines[n28];
      if (g14(r39, e43.origin, e43.endpoint, e43.direction))
        return true;
    }
    return false;
  }
  _toRenderBoundingExtentGlobal(t32, r39, n28) {
    const o27 = 5;
    p2(t32, V11), V11[2] = n28, R(r39, V11, v12, this._renderCoordsHelper.spatialReference), h4(I14, v12), P2(k13);
    for (const { x0: i20, x1: s32, y0: c32, y1: l31 } of U8)
      for (let p23 = 0; p23 < o27; p23++) {
        const h25 = p23 / (o27 - 1);
        V11[0] = f(t32[i20], t32[s32], h25), V11[1] = f(t32[c32], t32[l31], h25), V11[2] = n28, n8(V11, r39, V11, this._renderCoordsHelper.spatialReference), O2(V11, V11, I14), h3(k13, V11);
      }
    o2(this._extent[0].origin, k13[0], k13[1], k13[2]), o2(this._extent[1].origin, k13[3], k13[1], k13[2]), o2(this._extent[2].origin, k13[3], k13[4], k13[2]), o2(this._extent[3].origin, k13[0], k13[4], k13[2]);
    for (let e42 = 0; e42 < 4; ++e42)
      O2(this._extent[e42].origin, this._extent[e42].origin, v12);
  }
  _toRenderBoundingExtentLocal(t32, e42, i20) {
    i10(t32, e42, L7, this._renderCoordsHelper.spatialReference), o2(this._extent[0].origin, L7[0], L7[1], i20), o2(this._extent[1].origin, L7[2], L7[1], i20), o2(this._extent[2].origin, L7[2], L7[3], i20), o2(this._extent[3].origin, L7[0], L7[3], i20);
  }
  _toRenderBoundingExtent(e42, i20, r39) {
    switch (this._renderCoordsHelper.viewingMode) {
      case l6.Global:
        this._toRenderBoundingExtentGlobal(e42, i20, r39);
        break;
      case l6.Local:
        this._toRenderBoundingExtentLocal(e42, i20, r39);
        break;
      default:
        n5(this._renderCoordsHelper.viewingMode);
    }
  }
  _isVisibleInFrustumGlobal(t32) {
    if (V2(t32.planes[j9.NEAR], this._center.origin) < 0 && P(this._center.direction, t32.direction) < 0)
      return true;
    for (let e42 = 0; e42 < 4; e42++) {
      const i20 = this._extent[e42];
      if (V2(t32.planes[j9.NEAR], i20.origin) < 0 && P(i20.direction, t32.direction) < 0)
        return true;
    }
    return false;
  }
};
var U8 = [{ x0: 0, y0: 1, x1: 2, y1: 1 }, { x0: 0, y0: 3, x1: 2, y1: 3 }, { x0: 0, y0: 1, x1: 0, y1: 3 }, { x0: 2, y0: 1, x1: 2, y1: 3 }];
var V11 = n2();
var v12 = e12();
var I14 = e12();
var k13 = i();
var L7 = u7();
var P11 = v();

export {
  m11 as m,
  d11 as d,
  l16 as l,
  a15 as a,
  L4 as L,
  A9 as A,
  r22 as r,
  e36 as e,
  e33 as e2,
  l18 as l2,
  G7 as G,
  S11 as S,
  e34 as e3,
  i13 as i,
  l19 as l3,
  r27 as r2,
  c21 as c,
  s23 as s,
  r29 as r3,
  f14 as f,
  a21 as a2,
  l21 as l4,
  i15 as i2,
  r30 as r4,
  s25 as s2,
  j12 as j,
  m21 as m2,
  i19 as i3,
  j18 as j2,
  N6 as N
};
//# sourceMappingURL=chunk-WS5XOTML.js.map
