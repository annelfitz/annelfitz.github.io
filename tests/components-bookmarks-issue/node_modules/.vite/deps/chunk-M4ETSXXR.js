import {
  c as c2
} from "./chunk-VGQTAP4F.js";
import {
  p as p4
} from "./chunk-CTJKH5VV.js";
import {
  f as f3
} from "./chunk-FKMPOIQR.js";
import {
  e as e6
} from "./chunk-CTY3WTET.js";
import {
  A as A3,
  B,
  R as R2,
  j
} from "./chunk-7IFMSG3H.js";
import {
  D,
  p as p3
} from "./chunk-6SB3EFZU.js";
import {
  E2,
  P as P2,
  a as a5,
  p as p2
} from "./chunk-LEFES6LS.js";
import {
  t
} from "./chunk-UANQJYHL.js";
import {
  Et,
  It,
  Le,
  N,
  Tt,
  Zt,
  ge,
  gt,
  xt
} from "./chunk-TO6UIATU.js";
import {
  d as d4,
  l as l2,
  y as y2
} from "./chunk-WCBCYPOZ.js";
import {
  A as A2
} from "./chunk-3FTSPLRV.js";
import {
  x as x2
} from "./chunk-6GQQIJM7.js";
import {
  e as e5,
  r as r2
} from "./chunk-YGP7UFWC.js";
import {
  a as a4,
  f as f2,
  o as o3
} from "./chunk-PMQ5HDZI.js";
import {
  u as u4
} from "./chunk-YK3UMVCY.js";
import {
  h as h2
} from "./chunk-I4SHZ6P5.js";
import {
  a as a3,
  i as i2
} from "./chunk-FMS3CZY7.js";
import {
  g as g2,
  h,
  p,
  u as u3
} from "./chunk-SA77Z3WI.js";
import {
  n as n3
} from "./chunk-D56W4LPT.js";
import {
  e as e3
} from "./chunk-BKOYOJBG.js";
import {
  l
} from "./chunk-WZJNHZ6H.js";
import {
  d as d3
} from "./chunk-VEYMN5N3.js";
import {
  L,
  R
} from "./chunk-QCMUK3QA.js";
import {
  e as e4
} from "./chunk-KNMQQRV7.js";
import {
  c,
  i
} from "./chunk-BOAEEYBE.js";
import {
  n as n2
} from "./chunk-ZPYA32PH.js";
import {
  E,
  P,
  _,
  e as e2,
  g,
  r,
  u as u2,
  z
} from "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  Z,
  ee
} from "./chunk-UWQ3OYA5.js";
import {
  A,
  d as d2
} from "./chunk-Z4Y53NDM.js";
import {
  o as o2
} from "./chunk-TXBMNSNF.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a2
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  d
} from "./chunk-JGDJR5EV.js";
import {
  o,
  u
} from "./chunk-QHK5ZYFW.js";
import {
  a
} from "./chunk-7RBRCL6S.js";
import {
  k
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/draw/DrawingMode.js
var c3 = ["freehand", "hybrid", "click"];
var e7 = "click";

// node_modules/@arcgis/core/views/draw/DrawManipulator.js
var t2 = class {
  constructor({ consumesClicks: t3, grabbableForEvent: s }) {
    this.events = new o2(), this.interactive = true, this.selectable = false, this.cursor = null, this.grabbable = true, this.consumesClicks = t3, this.grabbableForEvent = s;
  }
  destroy() {
  }
  intersectionDistance(e8, t3) {
    return 0;
  }
  attach() {
  }
  detach() {
  }
  onElevationChange() {
  }
  onViewChange() {
  }
};

// node_modules/@arcgis/core/views/interactive/sketch/constraintUtils.js
function Z2(e8, n4, t3, r3, o4, i3) {
  let l4 = "geodesic", u6 = A2(t3);
  const s = d4(e8, n4, r3);
  return s[2] = 0, u6 && n3(s, t3, s, u6) || (l4 = "euclidean", u6 = t3), { mode: l4, view: n4, elevationInfo: r3, hasZ: o4, directionMode: i3, spatialReference: e8.spatialReference, measurementSR: u6, origin: s };
}
function A4(n4, t3, r3) {
  if (null == t3 || null == n4)
    return;
  const i3 = Z(r3.measurementSR);
  if (null == i3)
    return;
  const l4 = W(n4, r3);
  if (null == l4)
    return;
  const u6 = f2(t3, i3);
  return new xt(l2(l4), u6);
}
function B2(e8, n4, r3, o4) {
  if (null == r3 || null == e8)
    return;
  const i3 = W(e8, o4);
  if (null == i3)
    return;
  const l4 = B(r3), u6 = 10, c5 = (e9) => {
    if (null == e9)
      return;
    const n5 = n(), r4 = o3(e9, "degrees", "geographic");
    return A3(n5, i3, o4.measurementSR, u6, r4, o4.mode) ? new Et(i3, n5) : void 0;
  }, a6 = () => {
    if (null != n4 && null != e8)
      return B(R2(n4, e8));
  };
  switch (o4.directionMode) {
    case j.Absolute:
      return c5(l4);
    case j.Relative: {
      const e9 = a6();
      if (null == e9)
        return;
      return c5(e9 + l4);
    }
    case j.RelativeBilateral: {
      const e9 = a6();
      if (null == e9)
        return;
      return ge([c5(e9 + l4), c5(e9 - l4)]);
    }
  }
}
function P3(e8, n4) {
  const t3 = D2(e8, n4);
  return null != t3 ? new Tt(t3) : void 0;
}
function T(e8, n4, t3) {
  const { context: r3, longitude: o4, latitude: i3, direction: l4, distance: u6, elevation: s } = t3;
  if (null != o4 || null != i3 || null != u6 || null != s || null != l4) {
    if (null != o4 || null != i3) {
      const e9 = B(o4), n5 = B(i3), t4 = E3(s, r3);
      return new Zt(e9, n5, t4);
    }
    return V(e8, n4, t3);
  }
}
function V(n4, t3, { context: r3, direction: o4, distance: i3, elevation: l4 }) {
  if (null == t3)
    return P3(l4, r3);
  const { view: u6, elevationInfo: s, measurementSR: a6 } = r3, f4 = d4(t3, u6, s);
  if (!a6 || !n3(f4, t3.spatialReference, H, a6))
    return;
  const m = [H[0], H[1]], d5 = null != i3 ? f2(i3, "meters") : void 0, v2 = B(o4), g4 = E3(l4, r3), w2 = (e8) => {
    const n5 = new It(m, a6, d5, g4, e8);
    return null == d5 || null == e8 || null == g4 && r3.hasZ ? n5 : new gt(n5.closestTo(f4));
  };
  if (null == v2)
    return w2(void 0);
  const x3 = () => {
    if (null != n4 && null != t3)
      return B(R2(n4, t3));
  };
  switch (r3.directionMode) {
    case j.Absolute:
      return w2(v2);
    case j.Relative: {
      const e8 = x3();
      if (null == e8)
        return;
      return w2(e8 + v2);
    }
    case j.RelativeBilateral: {
      const e8 = x3();
      if (null == e8)
        return;
      return ge([w2(e8 + v2), w2(e8 - v2)]);
    }
  }
}
function k2(e8) {
  return "geodesic" === e8.context.mode ? T(null, null, e8) : z2(e8);
}
function q(e8, n4, t3) {
  const { context: r3, x: o4, y: i3, distance: l4, direction: u6, elevation: s } = t3;
  return "geodesic" === r3.mode ? T(n4, e8, t3) : null != o4 || null != i3 ? z2(t3) : G([A4(e8, l4, r3), B2(e8, n4, u6, r3), P3(s, r3)]);
}
function z2({ x: e8, y: n4, elevation: t3, context: r3 }) {
  J.x = (e8 == null ? void 0 : e8.value) ?? 0, J.y = (n4 == null ? void 0 : n4.value) ?? 0, J.spatialReference = r3.spatialReference;
  const o4 = W(J, r3);
  return new Zt(null != e8 && null != o4 ? o4[0] : void 0, null != n4 && null != o4 ? o4[1] : void 0, E3(t3, r3));
}
function G(e8) {
  let n4;
  for (const t3 of e8)
    t3 && (n4 = (n4 == null ? void 0 : n4.intersect(t3)) ?? t3);
  return n4;
}
function W(e8, n4) {
  const { view: t3, elevationInfo: r3, measurementSR: o4, origin: l4, mode: u6 } = n4, s = d4(e8, t3, r3);
  if (n3(s, e8.spatialReference, s, o4))
    return "geodesic" !== u6 && e2(s, s, l4), s;
}
function C(e8, n4, t3) {
  const { view: r3, measurementSR: o4, spatialReference: i3, origin: s, mode: a6 } = t3, f4 = H;
  if ("geodesic" === a6 ? r(f4, e8) : u2(f4, e8, s), n3(f4, o4, f4, i3))
    return y2(f4, r3, n4, t3);
}
function D2(e8, n4) {
  var _a;
  return ((_a = F(e8, n4)) == null ? void 0 : _a.value) ?? void 0;
}
function E3(n4, t3) {
  const r3 = F(n4, t3);
  return null != r3 ? f2(r3, "meters") : void 0;
}
function F(t3, { view: o4, origin: i3, elevationInfo: l4, hasZ: u6, measurementSR: s }) {
  if (null == t3 || !u6)
    return;
  const c5 = ee(s);
  if (null == c5)
    return;
  const [a6, f4] = i3, d5 = f2(t3, c5), p5 = "3d" === (o4 == null ? void 0 : o4.type) ? p(o4, a6, f4, d5, s, l4) : d5;
  return null != p5 ? a4(p5, c5) : void 0;
}
var H = n();
var J = e3(0, 0, 0, f.WGS84);

// node_modules/@arcgis/core/views/draw/DrawOperation.js
var Z3 = "crosshair";
var A5 = "progress";
var L2 = class extends o2.EventedMixin(S) {
  constructor(t3) {
    super(t3), this._createOperationCompleted = false, this._hideDefaultCursor = false, this._pointerDownStates = /* @__PURE__ */ new Set(), this._stagedScreenPoint = null, this._stagedPointerType = null, this._stagedPointerId = null, this._updatingHandles = new h2(), this.constraintsEnabled = false, this.constraints = void 0, this._getPointConstraint = t(k2), this._getPolylineOrPolygonConstraint = t(q), this.constraintZ = null, this.defaultZ = null, this.isDraped = true, this.labelOptions = new c2(), this.cursor = null, this.loading = false, this.snapToSceneEnabled = null, this.firstVertex = null, this.lastVertex = null, this.secondToLastVertex = null, null == t3.elevationInfo && (this.elevationInfo = u3(!!t3.hasZ));
  }
  initialize() {
    const { geometryType: t3, view: e8 } = this, i3 = e8.spatialReference, n4 = "viewingMode" in e8.state ? e8.state.viewingMode : l.Local, o4 = "segment" === t3 || "multipoint" === t3 ? "polyline" : t3;
    this.coordinateHelper = P2(this.hasZ, this.hasM, i3), this._editGeometryOperations = new E2(new p2(o4, this.coordinateHelper), n4), this._snappingOperation = new p4({ view: e8 }), this.addHandles([d2(() => ({ stagedPoint: this._snappingOperation.stagedPoint, constraint: this._constraint }), ({ stagedPoint: t4, constraint: e9 }, i4) => {
      const { snappingOptions: n5 } = this;
      n5 && (n5.forceDisabled = null != e9 && Le(e9));
      if (null != i4 && t4 === i4.stagedPoint && e9 !== i4.constraint)
        return this._onKeyboardBasedChange();
      this._processCursor(t4 ?? this._screenToMap(this._stagedScreenPoint));
    }, { equals: (t4, e9) => t4.stagedPoint === e9.stagedPoint && o(t4.constraint, e9.constraint) }), d2(() => this.view.viewpoint, (t4, e9) => {
      t4 && e9 && d3(t4, e9) && this._onKeyboardBasedChange();
    })]), this._activeComponent = new a5(i3, n4), this._editGeometryOperations.data.components.push(this._activeComponent);
    const s = this.segmentLabels;
    null != s && (s.context = { view: e8, editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, labelOptions: this.labelOptions }, this.addHandles(d2(() => this.labelOptions.enabled, (t4) => {
      s.visible = t4;
    }, A))), this.addHandles(this._editGeometryOperations.on(["vertex-add", "vertex-update", "vertex-remove"], (t4) => {
      var _a, _b, _c, _d;
      const e9 = t4.vertices.map((t5) => ({ componentIndex: 0, vertexIndex: t5.index, coordinates: this.coordinateHelper.vectorToArray(t5.pos) })), i4 = e9.map((t5) => t5.coordinates), n5 = this.coordinateHelper.vectorToDehydratedPoint((_a = this._activeComponent.getFirstVertex()) == null ? void 0 : _a.pos) ?? null;
      a3(n5, this.firstVertex) || (this.firstVertex = n5);
      const o5 = this.coordinateHelper.vectorToDehydratedPoint((_b = this._activeComponent.getLastVertex()) == null ? void 0 : _b.pos) ?? null;
      a3(o5, this.lastVertex) || (this.lastVertex = o5);
      const r3 = this.coordinateHelper.vectorToDehydratedPoint((_d = (_c = this._activeComponent.edges.at(-1)) == null ? void 0 : _c.leftVertex) == null ? void 0 : _d.pos) ?? null;
      switch (a3(r3, this.secondToLastVertex) || (this.secondToLastVertex = r3), this._processCursor(this.cursorVertex), t4.type) {
        case "vertex-add":
          this.emit(t4.type, { ...t4, added: i4, vertices: e9 });
          break;
        case "vertex-update":
          this.emit(t4.type, { ...t4, updated: i4, vertices: e9 });
          break;
        case "vertex-remove":
          this.emit(t4.type, { ...t4, removed: i4, vertices: e9 });
      }
    }));
    const l4 = this._manipulator = new t2({ consumesClicks: false, grabbableForEvent: (t4) => "click" !== this.drawingMode || "touch" === t4.pointerType && this._snappingEnabled && 1 === this._pointerDownStates.size });
    this.manipulators.add(l4), l4.grabbable = "point" !== t3, this.addHandles([this._createManipulatorDragPipeline(l4), l4.events.on("immediate-click", (t4) => this._onImmediateClick(t4)), l4.events.on("immediate-double-click", (t4) => this._onImmediateDoubleClick(t4)), d2(() => ({ effectiveCursor: this.effectiveCursor }), ({ effectiveCursor: t4 }) => {
      l4.cursor = t4;
    }, A)]), N(this, () => {
      const t4 = this.view.inputManager.latestPointerType ?? "mouse", e9 = this._getSnappingContext(t4);
      if (null != this.snappingManager) {
        const t5 = this._snappingOperation.snapAgainNearPreviousMapPoint(this.snappingManager, e9);
        this._updatingHandles.addPromise(d(t5));
      }
    });
  }
  destroy() {
    u(this.segmentLabels), u(this._snappingOperation), this._editGeometryOperations = u(this._editGeometryOperations), this._updatingHandles.destroy();
  }
  get _snappingEnabled() {
    return null != this.snappingManager && this.snappingManager.options.effectiveEnabled;
  }
  get _requiresScenePoint() {
    const t3 = this._updateAndGetEffectiveDrawSurface();
    return "3d" === this.view.type && this.drawSurface !== t3;
  }
  get canRedo() {
    return this._editGeometryOperations.canRedo;
  }
  get canUndo() {
    return this._editGeometryOperations.canUndo;
  }
  get committedVertices() {
    return this._activeComponent.vertices.map((t3) => this.coordinateHelper.vectorToArray(t3.pos));
  }
  get _constraint() {
    const { constraints: t3, constraintsEnabled: e8 } = this;
    if (t3 && e8)
      switch (this.geometryType) {
        case "point":
          return this._getPointConstraint(t3);
        case "polygon":
        case "polyline":
          return this._getPolylineOrPolygonConstraint(this.lastVertex, this.secondToLastVertex, t3);
      }
  }
  set drawingMode(t3) {
    this._set("drawingMode", t3 ?? e7);
  }
  get effectiveCursor() {
    return this.loading ? A5 : this._hideDefaultCursor ? null : this.cursor || Z3;
  }
  get interactive() {
    return this._manipulator.interactive;
  }
  set interactive(t3) {
    this._manipulator.interactive = t3;
  }
  get isCompleted() {
    return this._createOperationCompleted;
  }
  get numCommittedVertices() {
    return this._activeComponent.vertices.length;
  }
  get snappingOptions() {
    return null != this.snappingManager ? this.snappingManager.options : null;
  }
  get cursorVertex() {
    return this._get("cursorVertex");
  }
  get visualizationCursorVertex() {
    return "mouse" === this._stagedPointerType ? this.cursorVertex : null;
  }
  get committableVertex() {
    const { cursorVertex: t3, lastVertex: e8, firstVertex: i3, geometryType: n4 } = this;
    return "polygon" === n4 && i2(t3, i3) || i2(t3, e8) ? null : t3;
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get geometryIncludingUncommittedVertices() {
    const { committedVertices: t3, committableVertex: e8, coordinateHelper: i3 } = this, n4 = t3.slice();
    return null != e8 && n4.push(i3.pointToArray(e8)), n4;
  }
  cancel() {
    this.complete({ aborted: true });
  }
  commitStagedVertex() {
    this._snappingOperation.abort();
    const { committableVertex: t3 } = this;
    null != t3 && this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(t3));
  }
  complete(t3) {
    var _a;
    const e8 = (t3 == null ? void 0 : t3.aborted) || false;
    this._snappingOperation.abort(), (_a = this.snappingManager) == null ? void 0 : _a.doneSnapping();
    const { geometryType: i3, numCommittedVertices: n4 } = this, o4 = "multipoint" === i3 && 0 === n4 || "polyline" === i3 && n4 < 2 || "polygon" === i3 && n4 < 3;
    "segment" !== i3 && "point" !== i3 || this.commitStagedVertex(), this._createOperationCompleted = !o4, (this.isCompleted || e8) && (this._stagedScreenPoint = null, this._stagedPointerId = null, this._stagedPointerType = null, this._processCursor(null), this.emit("complete", { vertices: this.committedVertices.map((t4, e9) => ({ componentIndex: 0, vertexIndex: e9, coordinates: t4 })), aborted: e8, type: "complete" }));
  }
  onInputEvent(t3) {
    switch (t3.type) {
      case "pointer-down":
        this._pointerDownStates.add(t3.pointerId);
        break;
      case "pointer-up":
        this._pointerDownStates.delete(t3.pointerId);
    }
    switch (t3.type) {
      case "pointer-move":
        return this._onPointerMove(t3);
      case "hold":
        return this._onHold(t3);
    }
  }
  redo() {
    this._editGeometryOperations.redo();
  }
  undo() {
    null != this.snappingManager && this.snappingManager.doneSnapping(), this._editGeometryOperations.undo();
  }
  _processCursor(t3) {
    var _a, _b;
    const e8 = a(this.cursorVertex), i3 = a(t3), o4 = i3 && (((_a = this._updateAndGetEffectiveDrawSurface()) == null ? void 0 : _a.constrainZ(i3)) ?? i3), r3 = this._snapToClosingVertex(o4), s = this._applyConstraints(r3);
    i2(e8, s) || (this._set("cursorVertex", s), (_b = this.segmentLabels) == null ? void 0 : _b.set("stagedVertex", null != s ? this.coordinateHelper.pointToVector(s) : null), null == s || "mouse" !== this._stagedPointerType ? this.emit("cursor-remove") : this.emit("cursor-update", { updated: null, vertices: [{ componentIndex: 0, vertexIndex: this._activeComponent.vertices.length, coordinates: this.coordinateHelper.pointToArray(s) }], operation: "apply", type: "vertex-update" }));
  }
  _snapToClosingVertex(t3) {
    if (null == t3 || "polygon" !== this.geometryType || this.numCommittedVertices <= 2)
      return t3;
    const e8 = this._mapToScreen(t3);
    if (!e8)
      return t3;
    const i3 = this._activeComponent;
    return this._vertexWithinPointerDistance(i3.vertices[0].pos, e8) ? this.firstVertex : this._vertexWithinPointerDistance(i3.vertices.at(-1).pos, e8) ? this.lastVertex : t3;
  }
  _createManipulatorDragPipeline(t3) {
    switch (this.drawingMode) {
      case "click":
        return this._createManipulatorDragPipelineClick(t3);
      case "freehand":
        return this._createManipulatorDragPipelineFreehand(t3);
      case "hybrid":
        return this._createManipulatorDragPipelineHybrid(t3);
    }
  }
  _createManipulatorDragPipelineClick(t3) {
    return p3(t3, (t4, e8, i3, n4) => {
      const o4 = "touch" === n4 && this._snappingEnabled;
      if (this.isCompleted || !o4)
        return;
      const { snappingStep: r3, cancelSnapping: s } = f3({ predicate: () => o4, snappingManager: this.snappingManager, snappingContext: new e6({ editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, feature: this.graphic, pointer: n4, visualizer: this.snappingVisualizer, drawConstraints: this.constraints }), updatingHandles: this._updatingHandles, useZ: !this._requiresScenePoint });
      i3 = i3.next((t5) => (o4 && null != this.snappingManager && this.snappingManager.doneSnapping(), t5)).next(s), e8.next(this._screenToMapDragEventStep()).next((t5) => ("start" === t5.action && (this._processCursor(t5.mapStart), ("segment" === this.geometryType || o4 && !this.numCommittedVertices) && this.commitStagedVertex()), t5)).next(D(this.view, this.elevationInfo)).next(...r3).next((t5) => (o4 && (this._processCursor(t5.mapEnd), "end" === t5.action && this.commitStagedVertex()), t5)).next((t5) => ("end" === t5.action && ("mouse" !== this._stagedPointerType && this._snappingOperation.abort(), "segment" !== this.geometryType && "point" !== this.geometryType || this.complete()), t5));
    });
  }
  _createManipulatorDragPipelineFreehand(t3) {
    return p3(t3, (t4, e8) => {
      this.isCompleted || e8.next(this._screenToMapDragEventStep()).next((t5) => ("start" === t5.action && (this._snappingOperation.abort(), null == this.committableVertex && this._processCursor(t5.mapStart), "segment" === this.geometryType && this.commitStagedVertex()), t5)).next((t5) => {
        switch (t5.action) {
          case "start":
          case "update":
            this._processCursor(t5.mapEnd), "polygon" !== this.geometryType && "polyline" !== this.geometryType || this.commitStagedVertex();
            break;
          case "end":
            this.complete();
        }
        return t5;
      });
    });
  }
  _createManipulatorDragPipelineHybrid(t3) {
    return p3(t3, (t4, e8) => {
      this.isCompleted || e8.next(this._screenToMapDragEventStep()).next((t5) => ("start" === t5.action && (this._snappingOperation.abort(), this._processCursor(t5.mapStart), this.commitStagedVertex()), t5)).next((t5) => {
        switch (t5.action) {
          case "start":
          case "update":
            this._processCursor(t5.mapEnd), "polygon" !== this.geometryType && "polyline" !== this.geometryType || this.commitStagedVertex();
            break;
          case "end":
            "mouse" !== this._stagedPointerType && this._snappingOperation.abort(), "segment" !== this.geometryType && "point" !== this.geometryType || this.complete();
        }
        return t5;
      });
    });
  }
  get _drawAtFixedElevation() {
    const { constraintsEnabled: t3, constraintZ: e8, geometryType: i3, numCommittedVertices: n4 } = this;
    return t3 ? null != e8 || "segment" === i3 && n4 > 0 : ("segment" === i3 || "polygon" === i3) && n4 > 0;
  }
  _updateAndGetEffectiveDrawSurface() {
    var _a;
    const { constraintsEnabled: t3, coordinateHelper: e8, drawSurface: i3, elevationDrawSurface: n4, snapToSceneEnabled: o4 } = this;
    if (null == n4)
      return i3;
    if (!this.hasZ)
      return n4.defaultZ = null, n4;
    const r3 = (_a = this.elevationInfo) == null ? void 0 : _a.mode;
    let s = this.defaultZ, a6 = t3 || "absolute-height" === r3;
    if (null != o4 && (a6 = o4), "on-the-ground" === r3 && (a6 = false), this._drawAtFixedElevation) {
      s = (t3 ? this.constraintZ : null) ?? e8.getZ(this._activeComponent.vertices[0].pos), a6 = false;
    }
    return a6 ? i3 : (n4.defaultZ = s, n4);
  }
  _mapToScreen(t3) {
    var _a;
    return (_a = this._updateAndGetEffectiveDrawSurface()) == null ? void 0 : _a.mapToScreen(t3);
  }
  _onHold(t3) {
    this._snappingOperation.abort(), "click" === this.drawingMode && "touch" === t3.pointerType && this._snappingEnabled && this._processCursor(t3.mapPoint), t3.stopPropagation();
  }
  _onImmediateClick(t3) {
    if (!("mouse" === t3.pointerType && 2 === t3.button || this._manipulator.dragging))
      try {
        const { drawingMode: e8, geometryType: i3 } = this;
        this._stagedPointerType = t3.pointerType, this._stagedScreenPoint = t3.screenPoint;
        const n4 = this._screenToMap(t3.screenPoint);
        if (null == n4)
          return;
        if (null == n4 || "freehand" === e8 && "point" !== i3)
          return;
        if (this._snappingEnabled && null != this.cursorVertex || this._processCursor(n4), null == this.committableVertex)
          return void this.complete();
        this.commitStagedVertex(), "mouse" !== t3.pointerType && this._processCursor(null), ("freehand" === e8 || "point" === i3 || "segment" === i3 && 2 === this.numCommittedVertices || "segment" === i3 && "hybrid" === e8 && 1 === this.numCommittedVertices) && this.complete();
      } finally {
        t3.stopPropagation();
      }
  }
  _onImmediateDoubleClick(t3) {
    this._manipulator.dragging || "point" === this.geometryType || (this.complete(), t3.stopPropagation());
  }
  _onPointerMove(t3) {
    const e8 = c(t3.x, t3.y);
    this._stagedScreenPoint = e8, this._stagedPointerType = t3.pointerType, this._stagedPointerId = t3.pointerId;
    const i3 = this._snappingOperation, n4 = this._manipulator;
    this._pointerDownStates.has(t3.pointerId) || n4.grabbing || !n4.interactive ? i3.abort() : (t3.stopPropagation(), this._processCursorMovementRelativeToSurface(e8, t3.pointerType));
  }
  _onKeyboardBasedChange() {
    const t3 = this._manipulator;
    "mouse" === this._stagedPointerType && this._stagedScreenPoint && null != this._stagedPointerId && !this._pointerDownStates.has(this._stagedPointerId) && !t3.grabbing && t3.interactive ? this._processCursorMovementRelativeToSurface(this._stagedScreenPoint, this._stagedPointerType) : this._snappingOperation.abort();
  }
  _processCursorMovementRelativeToSurface(t3, e8) {
    var _a;
    const i3 = this._snappingOperation, n4 = this._screenToMap(t3), o4 = this._requiresScenePoint ? (_a = this.drawSurface) == null ? void 0 : _a.screenToMap(t3) : null;
    if (null == n4)
      return this._hideDefaultCursor = true, this._processCursor(null), void i3.abort();
    this._hideDefaultCursor = false;
    const r3 = this.snappingManager;
    if (null == r3)
      return this._processCursor(n4), void i3.abort();
    const s = this._getSnappingContext(e8);
    this._updatingHandles.addPromise(d(i3.snap({ point: n4, scenePoint: o4 }, r3, s)));
  }
  _applyConstraints(t3) {
    const { _constraint: e8, constraints: i3 } = this;
    if (!t3 || !i3 || !e8)
      return t3;
    const { context: n4 } = i3, o4 = W(t3, n4), r3 = o4 ? e8.closestTo(o4) : void 0;
    if (!r3)
      return t3;
    const s = C(r3, t3, n4);
    return null != s && "absolute-height" !== n4.elevationInfo.mode && null != this.constraintZ && this.hasZ && (s.z = this.constraintZ), s;
  }
  _screenToMap(t3) {
    var _a;
    return t3 ? (_a = this._updateAndGetEffectiveDrawSurface()) == null ? void 0 : _a.screenToMap(t3) : null;
  }
  _screenToMapDragEventStep() {
    let t3 = null;
    return (e8) => {
      if ("start" === e8.action && (t3 = this._screenToMap(e8.screenStart)), null == t3)
        return null;
      const i3 = this._screenToMap(e8.screenEnd);
      return null != i3 ? { ...e8, mapStart: t3, mapEnd: i3 } : null;
    };
  }
  _vertexWithinPointerDistance(t3, e8) {
    const i3 = 25, n4 = this._mapToScreen(this.coordinateHelper.vectorToDehydratedPoint(t3));
    return null != n4 && z3(n4, e8, i3);
  }
  _getSnappingContext(t3) {
    var _a;
    const e8 = this._drawAtFixedElevation ? (_a = this.elevationDrawSurface) == null ? void 0 : _a.defaultZ : null;
    return new e6({ editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, pointer: t3, feature: this.graphic, visualizer: this.snappingVisualizer, selfSnappingZ: null != e8 ? { value: e8, elevationInfo: this.elevationInfo } : null, drawConstraints: this.constraints });
  }
};
function z3(t3, e8, i3) {
  const n4 = t3.x - e8.x, o4 = t3.y - e8.y;
  return n4 * n4 + o4 * o4 <= i3;
}
e([y()], L2.prototype, "_hideDefaultCursor", void 0), e([y()], L2.prototype, "_snappingOperation", void 0), e([y()], L2.prototype, "_snappingEnabled", null), e([y({ constructOnly: true })], L2.prototype, "graphic", void 0), e([y()], L2.prototype, "constraintsEnabled", void 0), e([y()], L2.prototype, "constraints", void 0), e([y()], L2.prototype, "_constraint", null), e([y()], L2.prototype, "constraintZ", void 0), e([y()], L2.prototype, "defaultZ", void 0), e([y()], L2.prototype, "isDraped", void 0), e([y({ value: e7 })], L2.prototype, "drawingMode", null), e([y({ constructOnly: true })], L2.prototype, "elevationDrawSurface", void 0), e([y({ constructOnly: true })], L2.prototype, "elevationInfo", void 0), e([y({ constructOnly: true, type: c2 })], L2.prototype, "labelOptions", void 0), e([y({ constructOnly: true })], L2.prototype, "geometryType", void 0), e([y({ constructOnly: true })], L2.prototype, "hasM", void 0), e([y({ constructOnly: true })], L2.prototype, "hasZ", void 0), e([y()], L2.prototype, "cursor", void 0), e([y()], L2.prototype, "effectiveCursor", null), e([y()], L2.prototype, "loading", void 0), e([y({ constructOnly: true })], L2.prototype, "manipulators", void 0), e([y({ constructOnly: true })], L2.prototype, "drawSurface", void 0), e([y({ constructOnly: true })], L2.prototype, "segmentLabels", void 0), e([y({ constructOnly: true })], L2.prototype, "snappingManager", void 0), e([y({ constructOnly: true })], L2.prototype, "snappingVisualizer", void 0), e([y()], L2.prototype, "snapToSceneEnabled", void 0), e([y({ readOnly: true })], L2.prototype, "cursorVertex", null), e([y({ readOnly: true })], L2.prototype, "visualizationCursorVertex", null), e([y()], L2.prototype, "committableVertex", null), e([y()], L2.prototype, "firstVertex", void 0), e([y()], L2.prototype, "lastVertex", void 0), e([y()], L2.prototype, "secondToLastVertex", void 0), e([y()], L2.prototype, "updating", null), e([y({ constructOnly: true })], L2.prototype, "view", void 0), L2 = e([a2("esri.views.draw.DrawOperation")], L2);

// node_modules/@arcgis/core/views/draw/drawSurfaces.js
var c4 = class {
  constructor(e8, t3, r3, s = null) {
    this._elevationInfo = e8, this.defaultZ = t3, this._view = r3, this._excludeGraphics = s;
  }
  screenToMap(t3) {
    const { defaultZ: r3, _view: s } = this, n4 = s.sceneIntersectionHelper.intersectElevationFromScreen(i(t3.x, t3.y), this._elevationInfo, r3 ?? 0, this._excludeGraphics);
    return null == r3 && null != n4 && (n4.z = void 0), n4;
  }
  mapToScreen(e8) {
    const t3 = e3(e8.x, e8.y, h(this._view, e8, this._elevationInfo), e8.spatialReference);
    return this._view.toScreen(t3);
  }
  constrainZ(e8) {
    const { defaultZ: t3 } = this;
    return null != t3 && e8.z !== t3 && ((e8 = x2(e8)).z = t3), e8;
  }
};
var l3 = class {
  constructor(e8, t3, r3 = []) {
    this.view = e8, this.elevationInfo = t3, this.exclude = r3;
  }
  screenToMap(e8) {
    const t3 = this.view.toMap(e8, { exclude: this.exclude, excludeHud: true });
    return null != t3 && (t3.z = g2(t3, this.view, this.elevationInfo)), t3;
  }
  mapToScreen(e8) {
    let t3 = e8;
    return null != this.elevationInfo && (t3 = e3(e8.x, e8.y, h(this.view, e8, this.elevationInfo), e8.spatialReference)), this.view.toScreen(t3);
  }
  constrainZ(e8) {
    return e8;
  }
};
var h3 = class {
  constructor(e8, t3 = false, r3 = 0) {
    this.view = e8, this.hasZ = t3, this.defaultZ = r3, this.mapToScreen = (t4) => e8.toScreen(t4), this.screenToMap = t3 ? (t4) => {
      const s = e8.toMap(t4);
      return s.z = r3, s;
    } : (t4) => e8.toMap(t4);
  }
  constrainZ(e8) {
    const { defaultZ: t3 } = this;
    return this.hasZ && e8.z !== t3 && ((e8 = x2(e8)).z = t3), e8;
  }
};
var u5 = class _u {
  screenToMap(e8) {
    const { x: t3, y: r3 } = e8;
    return new x({ x: t3, y: r3, spatialReference: _u.spatialReference });
  }
  mapToScreen(e8) {
    return c(e8.x, e8.y);
  }
  constrainZ(e8) {
    return e8;
  }
};
u5.spatialReference = new f();

// node_modules/@arcgis/core/views/draw/support/surfaceCoordinateSystems.js
function g3(t3, r3, e8 = null) {
  return null != e8 ? [t3, r3, e8] : [t3, r3];
}
function w(t3, r3, e8 = null) {
  return null != e8 ? { x: t3, y: r3, z: e8 } : { x: t3, y: r3 };
}
var R3 = class {
  constructor(t3) {
    this.spatialReference = t3;
  }
  mapToLocalMultiple(r3) {
    return r3.map((t3) => this.mapToLocal(t3)).filter(k);
  }
  get doUnnormalization() {
    return false;
  }
};
var W2 = class extends R3 {
  constructor(t3, a6, o4 = null) {
    super(a6), this._defaultZ = o4, this.transform = e5(), this.transformInv = e5(), this.transform = r2(t3), u4(this.transformInv, this.transform);
  }
  makeMapPoint(t3, r3) {
    return g3(t3, r3, this._defaultZ);
  }
  mapToLocal(t3) {
    return w(this.transform[0] * t3[0] + this.transform[2] * t3[1] + this.transform[4], this.transform[1] * t3[0] + this.transform[3] * t3[1] + this.transform[5]);
  }
  localToMap(t3) {
    return g3(this.transformInv[0] * t3.x + this.transformInv[2] * t3.y + this.transformInv[4], this.transformInv[1] * t3.x + this.transformInv[3] * t3.y + this.transformInv[5], this._defaultZ);
  }
};
var v = class extends R3 {
  constructor(t3, r3) {
    super(t3.spatialReference), this.view = t3, this.defaultZ = null, this.pWS = n(), this.tangentFrameUpWS = n(), this.tangentFrameRightWS = n(), this.tangentFrameForwardWS = n(), this.localFrameRightWS = n(), this.localFrameUpWS = n(), this.worldToLocalTransform = e4(), this.localToWorldTransform = e4(), this.scale = 1, this.scale = t3.resolution, this.referenceMapPoint = r3, this.defaultZ = r3.hasZ ? r3.z : null;
    const e8 = t3.state.camera.viewRight;
    this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint, this.pWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, n2.X, this.tangentFrameRightWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, n2.Y, this.tangentFrameUpWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, n2.Z, this.tangentFrameForwardWS);
    const s = n();
    g(s, this.tangentFrameForwardWS, P(e8, this.tangentFrameForwardWS)), e2(this.localFrameRightWS, e8, s), z(this.localFrameRightWS, this.localFrameRightWS), _(this.localFrameUpWS, this.tangentFrameForwardWS, this.localFrameRightWS), R(this.worldToLocalTransform, this.localFrameRightWS, this.tangentFrameRightWS), L(this.localToWorldTransform, this.worldToLocalTransform);
  }
  get doUnnormalization() {
    return "global" === this.view.viewingMode;
  }
  makeMapPoint(t3, r3) {
    return g3(t3, r3, this.defaultZ);
  }
  mapToLocal(t3) {
    const r3 = n();
    this.view.renderCoordsHelper.toRenderCoords(new x({ x: t3[0], y: t3[1], spatialReference: this.spatialReference }), r3), E(r3, r3, this.worldToLocalTransform);
    const e8 = this.view.renderCoordsHelper.fromRenderCoords(r3, new x({ spatialReference: this.view.spatialReference }));
    return null != e8 ? w(e8.x / this.scale, e8.y / this.scale) : null;
  }
  localToMap(t3) {
    const r3 = n();
    this.view.renderCoordsHelper.toRenderCoords(new x({ x: t3.x * this.scale, y: t3.y * this.scale, spatialReference: this.spatialReference }), r3), E(r3, r3, this.localToWorldTransform);
    const e8 = this.view.renderCoordsHelper.fromRenderCoords(r3, new x({ spatialReference: this.view.spatialReference }));
    return null != e8 ? g3(e8.x, e8.y, this.defaultZ) : null;
  }
};
function F2(t3, r3) {
  if ("2d" === t3.type)
    return new W2(t3.state.transform, t3.spatialReference, r3.length > 2 ? r3[2] : null);
  if ("3d" === t3.type) {
    const e8 = r3.length > 2 ? new x({ x: r3[0], y: r3[1], z: r3[2], spatialReference: t3.spatialReference }) : new x({ x: r3[0], y: r3[1], spatialReference: t3.spatialReference });
    return new v(t3, e8);
  }
  return null;
}

export {
  w,
  W2 as W,
  F2 as F,
  Z2 as Z,
  c3 as c,
  e7 as e,
  L2 as L,
  c4 as c2,
  l3 as l,
  h3 as h,
  u5 as u
};
//# sourceMappingURL=chunk-M4ETSXXR.js.map
