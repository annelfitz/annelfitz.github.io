import {
  c,
  i as i2,
  o
} from "./chunk-T7GGEMBH.js";
import {
  i
} from "./chunk-CTO5W2RR.js";
import {
  r as r2
} from "./chunk-MCZ4QOSQ.js";
import {
  e as e4,
  t as t2
} from "./chunk-7FQYGAVT.js";
import {
  l,
  n as n2,
  r
} from "./chunk-QRQWG4D3.js";
import {
  h
} from "./chunk-KTQIY334.js";
import {
  e as e2
} from "./chunk-IQFWVTUJ.js";
import {
  e2 as e3,
  m
} from "./chunk-JTUYA5FE.js";
import {
  t
} from "./chunk-JCP47SOM.js";
import {
  n
} from "./chunk-252ISA6Z.js";
import {
  D,
  G
} from "./chunk-WKVHVZW2.js";
import {
  p
} from "./chunk-YH2IYJYF.js";
import {
  j
} from "./chunk-2SYXH2R7.js";
import {
  Et,
  U
} from "./chunk-SAYWXQVM.js";
import {
  a,
  b,
  f2 as f,
  v
} from "./chunk-JGDJR5EV.js";
import {
  e
} from "./chunk-QHK5ZYFW.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RectangleBinPack.js
var e5 = class {
  constructor(e7, t6) {
    this._width = 0, this._height = 0, this._free = [], this._width = e7, this._height = t6, this._free.push(new t(0, 0, e7, t6));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(e7, t6) {
    if (e7 > this._width || t6 > this._height)
      return new t();
    let i6 = null, s2 = -1;
    for (let h3 = 0; h3 < this._free.length; ++h3) {
      const w = this._free[h3];
      e7 <= w.width && t6 <= w.height && (null === i6 || w.y <= i6.y && w.x <= i6.x) && (i6 = w, s2 = h3);
    }
    return null === i6 ? new t() : (this._free.splice(s2, 1), i6.width < i6.height ? (i6.width > e7 && this._free.push(new t(i6.x + e7, i6.y, i6.width - e7, t6)), i6.height > t6 && this._free.push(new t(i6.x, i6.y + t6, i6.width, i6.height - t6))) : (i6.width > e7 && this._free.push(new t(i6.x + e7, i6.y, i6.width - e7, i6.height)), i6.height > t6 && this._free.push(new t(i6.x, i6.y + t6, e7, i6.height - t6))), new t(i6.x, i6.y, e7, t6));
  }
  release(h3) {
    for (let e7 = 0; e7 < this._free.length; ++e7) {
      const t6 = this._free[e7];
      if (t6.y === h3.y && t6.height === h3.height && t6.x + t6.width === h3.x)
        t6.width += h3.width;
      else if (t6.x === h3.x && t6.width === h3.width && t6.y + t6.height === h3.y)
        t6.height += h3.height;
      else if (h3.y === t6.y && h3.height === t6.height && h3.x + h3.width === t6.x)
        t6.x = h3.x, t6.width += h3.width;
      else {
        if (h3.x !== t6.x || h3.width !== t6.width || h3.y + h3.height !== t6.y)
          continue;
        t6.y = h3.y, t6.height += h3.height;
      }
      this._free.splice(e7, 1), this.release(h3);
    }
    this._free.push(h3);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphMosaic.js
var n3 = class {
  constructor(e7, s2, i6) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphIndex = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = e7, this.height = s2, this._glyphSource = i6, this._binPack = new e5(e7 - 4, s2 - 4), this._glyphData.push(new Uint8Array(e7 * s2)), this._dirties.push(true), this._textures.push(void 0);
  }
  getGlyphItems(s2, i6) {
    const h3 = [], r5 = this._glyphSource, n6 = /* @__PURE__ */ new Set(), o4 = 1 / 256;
    for (const t6 of i6) {
      const e7 = Math.floor(t6 * o4);
      n6.add(e7);
    }
    const a3 = [];
    return n6.forEach((t6) => {
      const e7 = s2 + t6;
      if (this._rangePromises.has(e7))
        a3.push(this._rangePromises.get(e7));
      else {
        const i7 = r5.getRange(s2, t6).then(() => {
          this._rangePromises.delete(e7);
        }, () => {
          this._rangePromises.delete(e7);
        });
        this._rangePromises.set(e7, i7), a3.push(i7);
      }
    }), Promise.all(a3).then(() => {
      let n7 = this._glyphIndex[s2];
      n7 || (n7 = {}, this._glyphIndex[s2] = n7);
      for (const o5 of i6) {
        const i7 = n7[o5];
        if (i7) {
          h3[o5] = { sdf: true, rect: i7.rect, metrics: i7.metrics, page: i7.page, code: o5 };
          continue;
        }
        const a4 = r5.getGlyph(s2, o5);
        if (!(a4 == null ? void 0 : a4.metrics))
          continue;
        const l3 = a4.metrics;
        let c2;
        if (0 === l3.width)
          c2 = new t(0, 0, 0, 0);
        else {
          const e7 = 3, s3 = l3.width + 2 * e7, i8 = l3.height + 2 * e7;
          let h4 = s3 % 4 ? 4 - s3 % 4 : 4, r6 = i8 % 4 ? 4 - i8 % 4 : 4;
          1 === h4 && (h4 = 5), 1 === r6 && (r6 = 5), c2 = this._binPack.allocate(s3 + h4, i8 + r6), c2.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(void 0), this._binPack = new e5(this.width - 4, this.height - 4), c2 = this._binPack.allocate(s3 + h4, i8 + r6));
          const n8 = this._glyphData[this._currentPage], o6 = a4.bitmap;
          let g, _;
          if (o6)
            for (let t6 = 0; t6 < i8; t6++) {
              g = s3 * t6, _ = this.width * (c2.y + t6 + 1) + c2.x;
              for (let t7 = 0; t7 < s3; t7++)
                n8[_ + t7 + 1] = o6.at(g + t7);
            }
        }
        n7[o5] = { rect: c2, metrics: l3, tileIDs: null, page: this._currentPage }, h3[o5] = { sdf: true, rect: c2, metrics: l3, page: this._currentPage, code: o5 }, this._dirties[this._currentPage] = true;
      }
      return h3;
    });
  }
  removeGlyphs(t6) {
    for (const e7 in this._glyphIndex) {
      const s2 = this._glyphIndex[e7];
      if (!s2)
        continue;
      let i6;
      for (const e8 in s2)
        if (i6 = s2[e8], i6.tileIDs.delete(t6), 0 === i6.tileIDs.size) {
          const t7 = this._glyphData[i6.page], h3 = i6.rect;
          let r5, n6;
          for (let e9 = 0; e9 < h3.height; e9++)
            for (r5 = this.width * (h3.y + e9) + h3.x, n6 = 0; n6 < h3.width; n6++)
              t7[r5 + n6] = 0;
          delete s2[e8], this._dirties[i6.page] = true;
        }
    }
  }
  bind(t6, e7, n6, o4 = 0) {
    if (!this._textures[n6]) {
      const e8 = new e3();
      e8.pixelFormat = G.ALPHA, e8.wrapMode = D.CLAMP_TO_EDGE, e8.width = this.width, e8.height = this.height, this._textures[n6] = new m(t6, e8, new Uint8Array(this.width * this.height));
    }
    const a3 = this._textures[n6];
    a3.setSamplingMode(e7), this._dirties[n6] && a3.setData(this._glyphData[n6]), t6.bindTexture(a3, o4), this._dirties[n6] = false;
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._glyphData.length = 0, this._binPack = null;
    for (const t6 of this._textures)
      t6 && t6.dispose();
    this._textures.length = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphSource.js
var s = class {
  constructor(t6) {
    if (this._metrics = [], !t6)
      return void (this._allBitmaps = null);
    const e7 = /* @__PURE__ */ new Map();
    let s2 = 0;
    for (; t6.next(); )
      switch (t6.tag()) {
        case 1: {
          const a4 = t6.getMessage();
          for (; a4.next(); )
            switch (a4.tag()) {
              case 3: {
                const t7 = a4.getMessage();
                let r6, n6, i6, c2, o4, g, h3;
                for (; t7.next(); )
                  switch (t7.tag()) {
                    case 1:
                      r6 = t7.getUInt32();
                      break;
                    case 2:
                      n6 = t7.getBytes();
                      break;
                    case 3:
                      i6 = t7.getUInt32();
                      break;
                    case 4:
                      c2 = t7.getUInt32();
                      break;
                    case 5:
                      o4 = t7.getSInt32();
                      break;
                    case 6:
                      g = t7.getSInt32();
                      break;
                    case 7:
                      h3 = t7.getUInt32();
                      break;
                    default:
                      t7.skip();
                  }
                if (t7.release(), r6) {
                  const t8 = (n6 == null ? void 0 : n6.length) ?? 0;
                  this._metrics[r6] = { width: i6, height: c2, left: o4, top: g, advance: h3, startOffset: s2, length: t8 }, e7.set(r6, n6), s2 += t8;
                }
                break;
              }
              default:
                a4.skip();
            }
          a4.release();
          break;
        }
        default:
          t6.skip();
      }
    const a3 = new Uint8Array(s2), r5 = this._metrics;
    for (const [n6, i6] of e7) {
      const { startOffset: t7, length: e8 } = r5[n6];
      if (i6)
        for (let s3 = 0; s3 < e8; ++s3)
          a3[t7 + s3] = i6[s3];
    }
    this._allBitmaps = a3;
  }
  getMetrics(t6) {
    return this._metrics[t6];
  }
  getBitmap(t6) {
    if (!this._allBitmaps)
      return;
    const e7 = this._metrics[t6];
    if (void 0 === e7)
      return;
    const { startOffset: s2, length: a3 } = e7;
    return 0 !== a3 ? new n4(this._allBitmaps, s2, a3) : void 0;
  }
};
var a2 = class {
  constructor() {
    this._ranges = [];
  }
  get ranges() {
    return this._ranges;
  }
  getRange(t6) {
    return this._ranges[t6];
  }
  addRange(t6, e7) {
    this._ranges[t6] = e7;
  }
};
var r3 = class {
  constructor(t6) {
    this._glyphInfo = {}, this._baseURL = t6;
  }
  getRange(a3, r5) {
    const n6 = this._getFontStack(a3);
    if (n6.getRange(r5))
      return Promise.resolve();
    const i6 = 256 * r5, c2 = i6 + 255;
    if (this._baseURL) {
      const o4 = this._baseURL.replace("{fontstack}", a3).replace("{range}", i6 + "-" + c2);
      return U(o4, { responseType: "array-buffer" }).then((t6) => {
        n6.addRange(r5, new s(new n(new Uint8Array(t6.data), new DataView(t6.data))));
      }).catch(() => {
        n6.addRange(r5, new s());
      });
    }
    return n6.addRange(r5, new s()), Promise.resolve();
  }
  getGlyph(t6, e7) {
    const s2 = this._getFontStack(t6);
    if (!s2)
      return;
    const a3 = Math.floor(e7 / 256), r5 = s2.getRange(a3);
    return r5 ? { metrics: r5.getMetrics(e7), bitmap: r5.getBitmap(e7) } : void 0;
  }
  _getFontStack(t6) {
    let e7 = this._glyphInfo[t6];
    return e7 || (e7 = this._glyphInfo[t6] = new a2()), e7;
  }
};
var n4 = class {
  constructor(t6, e7, s2) {
    this._array = t6, this._start = e7, this.length = s2;
  }
  at(t6) {
    return 0 <= t6 && t6 < this.length ? this._array[this._start + t6] : void 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SpriteMosaic.js
var r4 = "dasharray-";
var o2 = class _o {
  constructor(t6, e7, s2 = 0) {
    this._size = [], this._mosaicsData = [], this._textures = [], this._dirties = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = {}, this.pixelRatio = 1, (t6 <= 0 || e7 <= 0) && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t6, this._pageHeight = e7, s2 > 0 && (this._maxItemSize = s2), this._binPack = new e5(t6 - 4, e7 - 4);
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._binPack = null, this._mosaicsData.length = 0, this._mosaicRects = {};
    for (const t6 of this._textures)
      t6 && t6.dispose();
    this._textures.length = 0;
  }
  getWidth(t6) {
    return t6 >= this._size.length ? -1 : this._size[t6][0];
  }
  getHeight(t6) {
    return t6 >= this._size.length ? -1 : this._size[t6][1];
  }
  getPageSize(t6) {
    return t6 >= this._size.length ? null : this._size[t6];
  }
  setSpriteSource(t6) {
    if (this.dispose(), this.pixelRatio = t6.devicePixelRatio, 0 === this._mosaicsData.length) {
      this._binPack = new e5(this._pageWidth - 4, this._pageHeight - 4);
      const t7 = Math.floor(this._pageWidth), e7 = Math.floor(this._pageHeight), s2 = new Uint32Array(t7 * e7);
      this._mosaicsData[0] = s2, this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0);
    }
    this._sprites = t6;
  }
  getSpriteItem(t6, i6 = false) {
    let e7, s2, h3 = this._mosaicRects[t6];
    if (h3)
      return h3;
    if (!this._sprites || "loaded" !== this._sprites.loadStatus)
      return null;
    if (t6 && t6.startsWith(r4) ? ([e7, s2] = this._rasterizeDash(t6), i6 = true) : e7 = this._sprites.getSpriteInfo(t6), !(e7 == null ? void 0 : e7.width) || !e7.height || e7.width < 0 || e7.height < 0)
      return null;
    const a3 = e7.width, o4 = e7.height, [n6, _, g] = this._allocateImage(a3, o4);
    return n6.width <= 0 ? null : (this._copy(n6, e7, _, g, i6, s2), h3 = { type: "sprite", rect: n6, width: a3, height: o4, sdf: e7.sdf, simplePattern: false, rasterizationScale: e7.pixelRatio, page: _ }, this._mosaicRects[t6] = h3, h3);
  }
  getSpriteItems(t6) {
    const i6 = {};
    for (const e7 of t6)
      i6[e7.name] = this.getSpriteItem(e7.name, e7.repeat);
    return i6;
  }
  getMosaicItemPosition(t6, i6) {
    const e7 = this.getSpriteItem(t6, i6), s2 = e7 && e7.rect;
    if (!s2)
      return null;
    s2.width = e7.width, s2.height = e7.height;
    const h3 = e7.width, a3 = e7.height, r5 = 2;
    return { tl: [s2.x + r5, s2.y + r5], br: [s2.x + r5 + h3, s2.y + r5 + a3], page: e7.page };
  }
  bind(t6, i6, e7 = 0, r5 = 0) {
    if (e7 >= this._size.length || e7 >= this._mosaicsData.length)
      return;
    if (!this._textures[e7]) {
      const i7 = new e3();
      i7.wrapMode = D.CLAMP_TO_EDGE, i7.width = this._size[e7][0], i7.height = this._size[e7][1], this._textures[e7] = new m(t6, i7, new Uint8Array(this._mosaicsData[e7].buffer));
    }
    const o4 = this._textures[e7];
    o4.setSamplingMode(i6), this._dirties[e7] && o4.setData(new Uint8Array(this._mosaicsData[e7].buffer)), t6.bindTexture(o4, r5), this._dirties[e7] = false;
  }
  static _copyBits(t6, i6, e7, s2, h3, a3, r5, o4, n6, _, g) {
    let c2 = s2 * i6 + e7, l3 = o4 * a3 + r5;
    if (g) {
      l3 -= a3;
      for (let r6 = -1; r6 <= _; r6++, c2 = ((r6 + _) % _ + s2) * i6 + e7, l3 += a3)
        for (let i7 = -1; i7 <= n6; i7++)
          h3[l3 + i7] = t6[c2 + (i7 + n6) % n6];
    } else
      for (let p3 = 0; p3 < _; p3++) {
        for (let i7 = 0; i7 < n6; i7++)
          h3[l3 + i7] = t6[c2 + i7];
        c2 += i6, l3 += a3;
      }
  }
  _copy(t6, i6, e7, s2, h3, a3) {
    if (!this._sprites || "loaded" !== this._sprites.loadStatus || e7 >= this._mosaicsData.length)
      return;
    const r5 = new Uint32Array(a3 ? a3.buffer : this._sprites.image.buffer), n6 = this._mosaicsData[e7];
    n6 && r5 || console.error("Source or target images are uninitialized!");
    const _ = 2, g = a3 ? i6.width : this._sprites.width;
    _o._copyBits(r5, g, i6.x, i6.y, n6, s2[0], t6.x + _, t6.y + _, i6.width, i6.height, h3), this._dirties[e7] = true;
  }
  _allocateImage(t6, s2) {
    t6 += 2, s2 += 2;
    const h3 = Math.max(t6, s2);
    if (this._maxItemSize && this._maxItemSize < h3) {
      const i6 = new t(0, 0, t6, s2);
      return this._mosaicsData.push(new Uint32Array(t6 * s2)), this._dirties.push(true), this._size.push([t6, s2]), this._textures.push(void 0), [i6, this._mosaicsData.length - 1, [t6, s2]];
    }
    let a3 = t6 % 4 ? 4 - t6 % 4 : 4, r5 = s2 % 4 ? 4 - s2 % 4 : 4;
    1 === a3 && (a3 = 5), 1 === r5 && (r5 = 5);
    const o4 = this._binPack.allocate(t6 + a3, s2 + r5);
    return o4.width <= 0 ? (this._dirties[this._currentPage] || (this._mosaicsData[this._currentPage] = null), this._currentPage = this._mosaicsData.length, this._mosaicsData.push(new Uint32Array(this._pageWidth * this._pageHeight)), this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0), this._binPack = new e5(this._pageWidth - 4, this._pageHeight - 4), this._allocateImage(t6, s2)) : [o4, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _rasterizeDash(i6) {
    const e7 = /\[(.*?)\]/, s2 = i6.match(e7);
    if (!s2)
      return null;
    const h3 = s2[1].split(",").map(Number), a3 = i6.slice(i6.lastIndexOf("-") + 1), [r5, o4, n6] = i(h3, a3);
    return [{ x: 0, y: 0, width: o4, height: n6, sdf: true, pixelRatio: 1 }, new Uint8Array(r5.buffer)];
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler.js
var h2 = class {
  constructor(t6, e7, s2, r5) {
    this._layer = t6, this._styleRepository = e7, this.devicePixelRatio = s2, this._sourceDataMaxLOD = r5, this._spriteMosaic = null, this._glyphMosaic = null, this._connection = null, this._spriteSourceAbortController = null, this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  destroy() {
    var _a, _b, _c;
    (_a = this._connection) == null ? void 0 : _a.close(), this._connection = null, this._styleRepository = null, this._layer = null, (_b = this._spriteMosaic) == null ? void 0 : _b.destroy(), this._spriteMosaic = null, this._glyphMosaic = null, this._spriteSourceAbortController = e(this._spriteSourceAbortController), this._spriteSourcePromise = null, this._inputSignalEventListener && ((_c = this._startOptionsInputSignal) == null ? void 0 : _c.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  get spriteMosaic() {
    return this._spriteSourcePromise.then(() => this._spriteMosaic);
  }
  get glyphMosaic() {
    return this._glyphMosaic;
  }
  async start(t6) {
    this._requestSprite(t6);
    const s2 = this._layer.currentStyleInfo.glyphsUrl, r5 = new r3(s2 ? Et(s2, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    this._glyphMosaic = new n3(1024, 1024, r5), this._broadcastPromise = p("WorkerTileHandler", { client: this, schedule: t6.schedule, signal: t6.signal }).then((s3) => {
      var _a;
      if (this._layer && ((_a = this._connection) == null ? void 0 : _a.close(), this._connection = s3, this._layer && !this._connection.closed)) {
        const r6 = s3.broadcast("setStyle", { style: this._layer.currentStyleInfo.style, sourceDataMaxLOD: this._sourceDataMaxLOD }, t6);
        Promise.all(r6).catch((t7) => f(t7));
      }
    });
  }
  _requestSprite(t6) {
    var _a, _b;
    (_a = this._spriteSourceAbortController) == null ? void 0 : _a.abort();
    const e7 = new AbortController();
    this._spriteSourceAbortController = e7;
    const r5 = t6 == null ? void 0 : t6.signal;
    this._inputSignalEventListener && ((_b = this._startOptionsInputSignal) == null ? void 0 : _b.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, r5 && (this._inputSignalEventListener = p2(e7), r5.addEventListener("abort", this._inputSignalEventListener, { once: true }));
    const { signal: i6 } = e7, o4 = { ...t6, signal: i6 };
    this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, o4), this._spriteSourcePromise.then((t7) => {
      a(i6), this._spriteMosaic = new o2(1024, 1024, 250), this._spriteMosaic.setSpriteSource(t7);
    });
  }
  async updateStyle(t6) {
    return await this._broadcastPromise, this._broadcastPromise = Promise.all(this._connection.broadcast("updateStyle", t6)), this._broadcastPromise;
  }
  setSpriteSource(t6) {
    const e7 = new o2(1024, 1024, 250);
    return e7.setSpriteSource(t6), this._spriteMosaic = e7, this._spriteSourcePromise = Promise.resolve(t6), this._spriteSourceAbortController = null, e7;
  }
  async setStyle(t6, e7, s2) {
    await this._broadcastPromise, this._styleRepository = t6, this._sourceDataMaxLOD = s2, this._requestSprite();
    const r5 = new r3(this._layer.currentStyleInfo.glyphsUrl ? Et(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    return this._glyphMosaic = new n3(1024, 1024, r5), this._broadcastPromise = Promise.all(this._connection.broadcast("setStyle", { style: e7, sourceDataMaxLOD: this._sourceDataMaxLOD })), this._broadcastPromise;
  }
  async fetchTileData(t6, e7) {
    const s2 = await this._getRefKeys(t6, e7);
    return this._getSourcesData(Object.keys(this._layer.sourceNameToSource), s2, e7);
  }
  async fetchTilePBFs(t6) {
    const e7 = Object.keys(this._layer.sourceNameToSource), s2 = {}, r5 = await this._getRefKeys(t6, s2), i6 = [], o4 = [];
    for (let n6 = 0; n6 < r5.length; n6++)
      if (null == r5[n6].value || null == e7[n6])
        o4.push(null);
      else {
        const t7 = r5[n6].value, a3 = this._getTilePayload(t7, e7[n6], s2);
        a3.then((e8) => {
          i6.push({ ...e8, key: t7 });
        }), o4.push(a3);
      }
    return Promise.all(o4).then(() => i6);
  }
  async parseTileData(t6, e7) {
    const s2 = t6 && t6.data;
    if (!s2)
      return null;
    const { sourceName2DataAndRefKey: r5, transferList: i6 } = s2;
    return 0 === Object.keys(r5).length ? null : this._broadcastPromise.then(() => this._connection.invoke("createTileAndParse", { key: t6.key.id, sourceName2DataAndRefKey: r5, styleLayerUIDs: t6.styleLayerUIDs }, { ...e7, transferList: i6 }));
  }
  async getSprites(t6) {
    return await this._spriteSourcePromise, this._spriteMosaic.getSpriteItems(t6);
  }
  getGlyphs(t6) {
    return this._glyphMosaic.getGlyphItems(t6.font, t6.codePoints);
  }
  async _getTilePayload(t6, e7, s2) {
    const i6 = e2.pool.acquire(t6.id), o4 = this._layer.sourceNameToSource[e7], { level: n6, row: a3, col: l3 } = i6;
    e2.pool.release(i6);
    try {
      return { protobuff: await o4.requestTile(n6, a3, l3, s2), sourceName: e7 };
    } catch (c2) {
      if (b(c2))
        throw c2;
      return { protobuff: null, sourceName: e7 };
    }
  }
  async _getRefKeys(t6, e7) {
    const s2 = this._layer.sourceNameToSource, r5 = new Array();
    for (const i6 in s2) {
      const o4 = s2[i6].getRefKey(t6, e7);
      r5.push(o4);
    }
    return v(r5);
  }
  _getSourcesData(t6, e7, s2) {
    const r5 = [];
    for (let i6 = 0; i6 < e7.length; i6++)
      if (null == e7[i6].value || null == t6[i6])
        r5.push(null);
      else {
        const o4 = e7[i6].value, n6 = this._getTilePayload(o4, t6[i6], s2);
        r5.push(n6);
      }
    return v(r5).then((t7) => {
      const s3 = {}, r6 = [];
      for (let i6 = 0; i6 < t7.length; i6++) {
        const o4 = t7[i6].value;
        if (o4 && (o4.protobuff && o4.protobuff.byteLength > 0)) {
          const t8 = e7[i6].value.id;
          s3[o4.sourceName] = { refKey: t8, protobuff: o4.protobuff }, r6.push(o4.protobuff);
        }
      }
      return { sourceName2DataAndRefKey: s3, transferList: r6 };
    });
  }
};
function p2(t6) {
  return () => t6.abort();
}

// node_modules/@arcgis/core/views/2d/tiling/TileInfoViewPOT.js
var t3 = class extends h {
  constructor() {
    super(...arguments), this._fullCacheLodInfos = null, this._levelByScale = {};
  }
  getTileParentId(e7) {
    const l3 = e2.pool.acquire(e7), t6 = 0 === l3.level ? null : e2.getId(l3.level - 1, l3.row >> 1, l3.col >> 1, l3.world);
    return e2.pool.release(l3), t6;
  }
  getTileCoverage(e7, l3, s2 = true, t6) {
    const o4 = super.getTileCoverage(e7, l3, s2, t6);
    if (!o4)
      return o4;
    const i6 = 1 << o4.lodInfo.level;
    return o4.spans = o4.spans.filter((e8) => e8.row >= 0 && e8.row < i6), o4;
  }
  scaleToLevel(e7) {
    if (this._fullCacheLodInfos || this._initializeFullCacheLODs(this._lodInfos), this._levelByScale[e7])
      return this._levelByScale[e7];
    {
      const l3 = this._fullCacheLodInfos;
      if (e7 > l3[0].scale)
        return l3[0].level;
      let s2, t6;
      for (let o4 = 0; o4 < l3.length - 1; o4++)
        if (t6 = l3[o4 + 1], e7 > t6.scale)
          return s2 = l3[o4], s2.level + (s2.scale - e7) / (s2.scale - t6.scale);
      return l3[l3.length - 1].level;
    }
  }
  _initializeFullCacheLODs(l3) {
    let s2;
    if (0 === l3[0].level)
      s2 = l3.map((e7) => ({ level: e7.level, resolution: e7.resolution, scale: e7.scale }));
    else {
      const l4 = this.tileInfo.size[0], t6 = this.tileInfo.spatialReference;
      s2 = j.create({ size: l4, spatialReference: t6 }).lods.map((e7) => ({ level: e7.level, resolution: e7.resolution, scale: e7.scale }));
    }
    for (let e7 = 0; e7 < s2.length; e7++)
      this._levelByScale[s2[e7].scale] = s2[e7].level;
    this._fullCacheLodInfos = s2;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobs.js
function i3(e7, t6, n6, o4, i6, l3) {
  const { iconRotationAlignment: a3, textRotationAlignment: c2, iconTranslate: h3, iconTranslateAnchor: u, textTranslate: d, textTranslateAnchor: y } = o4;
  let x = 0;
  for (const g of e7.colliders) {
    const [e8, o5] = 0 === g.partIndex ? h3 : d, m2 = 0 === g.partIndex ? u : y, f2 = g.minLod <= l3 && l3 <= g.maxLod;
    x += f2 ? 0 : 1, g.enabled = f2, g.xScreen = g.xTile * i6[0] + g.yTile * i6[3] + i6[6], g.yScreen = g.xTile * i6[1] + g.yTile * i6[4] + i6[7], m2 === r.MAP ? (g.xScreen += n6 * e8 - t6 * o5, g.yScreen += t6 * e8 + n6 * o5) : (g.xScreen += e8, g.yScreen += o5), l.VIEWPORT === (0 === g.partIndex ? a3 : c2) ? (g.dxScreen = g.dxPixels, g.dyScreen = g.dyPixels) : (g.dxScreen = n6 * (g.dxPixels + g.width / 2) - t6 * (g.dyPixels + g.height / 2) - g.width / 2, g.dyScreen = t6 * (g.dxPixels + g.width / 2) + n6 * (g.dyPixels + g.height / 2) - g.height / 2);
  }
  e7.colliders.length > 0 && x === e7.colliders.length && (e7.unique.show = false);
}
var l2 = class {
  constructor(o4, r5, s2, i6, l3, a3) {
    this._symbols = o4, this._styleRepository = i6, this._zoom = l3, this._currentLayerCursor = 0, this._currentSymbolCursor = 0, this._styleProps = /* @__PURE__ */ new Map(), this._allNeededMatrices = /* @__PURE__ */ new Map(), this._gridIndex = new i2(r5, s2, t2), this._si = Math.sin(Math.PI * a3 / 180), this._co = Math.cos(Math.PI * a3 / 180);
    for (const t6 of o4)
      for (const n6 of t6.symbols)
        this._allNeededMatrices.has(n6.tile) || this._allNeededMatrices.set(n6.tile, r2(n6.tile.transforms.tileUnitsToPixels));
  }
  work(e7) {
    const t6 = this._gridIndex;
    function n6(e8) {
      const n7 = e8.xScreen + e8.dxScreen, o5 = e8.yScreen + e8.dyScreen, r5 = n7 + e8.width, s2 = o5 + e8.height, [i6, l3, a3, c2] = t6.getCellSpan(n7, o5, r5, s2);
      for (let h3 = l3; h3 <= c2; h3++)
        for (let e9 = i6; e9 <= a3; e9++) {
          const i7 = t6.cells[h3][e9];
          for (const e10 of i7) {
            const t7 = e10.xScreen + e10.dxScreen, i8 = e10.yScreen + e10.dyScreen, l4 = t7 + e10.width, a4 = i8 + e10.height;
            if (!(r5 < t7 || n7 > l4 || s2 < i8 || o5 > a4))
              return true;
          }
        }
      return false;
    }
    const o4 = performance.now();
    for (; this._currentLayerCursor < this._symbols.length; this._currentLayerCursor++, this._currentSymbolCursor = 0) {
      const t7 = this._symbols[this._currentLayerCursor], r5 = this._getProperties(t7.styleLayerUID);
      for (; this._currentSymbolCursor < t7.symbols.length; this._currentSymbolCursor++) {
        if (this._currentSymbolCursor % 100 == 99 && performance.now() - o4 > e7)
          return false;
        const s2 = t7.symbols[this._currentSymbolCursor];
        if (!s2.unique.show)
          continue;
        i3(s2, this._si, this._co, r5, this._allNeededMatrices.get(s2.tile), this._zoom);
        const l3 = s2.unique;
        if (!l3.show)
          continue;
        const { iconAllowOverlap: a3, iconIgnorePlacement: c2, textAllowOverlap: h3, textIgnorePlacement: u } = r5;
        for (const e8 of s2.colliders) {
          if (!e8.enabled)
            continue;
          const t8 = l3.parts[e8.partIndex];
          if (!t8.show)
            continue;
          !(e8.partIndex ? h3 : a3) && n6(e8) && (e8.hard ? l3.show = false : t8.show = false);
        }
        if (l3.show)
          for (const e8 of s2.colliders) {
            if (!e8.enabled)
              continue;
            if (e8.partIndex ? u : c2)
              continue;
            if (!l3.parts[e8.partIndex].show)
              continue;
            const t8 = e8.xScreen + e8.dxScreen, n7 = e8.yScreen + e8.dyScreen, o5 = t8 + e8.width, r6 = n7 + e8.height, [s3, i6, a4, h4] = this._gridIndex.getCellSpan(t8, n7, o5, r6);
            for (let l4 = i6; l4 <= h4; l4++)
              for (let t9 = s3; t9 <= a4; t9++) {
                this._gridIndex.cells[l4][t9].push(e8);
              }
          }
      }
    }
    return true;
  }
  _getProperties(e7) {
    const t6 = this._styleProps.get(e7);
    if (t6)
      return t6;
    const n6 = this._zoom, s2 = this._styleRepository.getStyleLayerByUID(e7), i6 = s2.getLayoutValue("symbol-placement", n6) !== n2.POINT;
    let l3 = s2.getLayoutValue("icon-rotation-alignment", n6);
    l3 === l.AUTO && (l3 = i6 ? l.MAP : l.VIEWPORT);
    let a3 = s2.getLayoutValue("text-rotation-alignment", n6);
    a3 === l.AUTO && (a3 = i6 ? l.MAP : l.VIEWPORT);
    const c2 = s2.getPaintValue("icon-translate", n6), h3 = s2.getPaintValue("icon-translate-anchor", n6), u = s2.getPaintValue("text-translate", n6), d = s2.getPaintValue("text-translate-anchor", n6), y = { iconAllowOverlap: s2.getLayoutValue("icon-allow-overlap", n6), iconIgnorePlacement: s2.getLayoutValue("icon-ignore-placement", n6), textAllowOverlap: s2.getLayoutValue("text-allow-overlap", n6), textIgnorePlacement: s2.getLayoutValue("text-ignore-placement", n6), iconRotationAlignment: l3, textRotationAlignment: a3, iconTranslateAnchor: h3, iconTranslate: c2, textTranslateAnchor: d, textTranslate: u };
    return this._styleProps.set(e7, y), y;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolDeclutterer.js
function t4(o4, t6) {
  if (o4.priority - t6.priority)
    return o4.priority - t6.priority;
  const e7 = o4.tile.key, i6 = t6.tile.key;
  return e7.world - i6.world ? e7.world - i6.world : e7.level - i6.level ? e7.level - i6.level : e7.row - i6.row ? e7.row - i6.row : e7.col - i6.col ? e7.col - i6.col : o4.xTile - t6.xTile ? o4.xTile - t6.xTile : o4.yTile - t6.yTile;
}
var e6 = class {
  get running() {
    return this._running;
  }
  constructor(o4, t6, e7, i6, s2, n6) {
    this._visibleTiles = o4, this._symbolRepository = t6, this._createCollisionJob = e7, this._assignTileSymbolsOpacity = i6, this._symbolLayerSorter = s2, this._isLayerVisible = n6, this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  setScreenSize(o4, t6) {
    this._screenWidth === o4 && this._screenHeight === t6 || this.restart(), this._screenWidth = o4, this._screenHeight = t6;
  }
  restart() {
    this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  continue(o4) {
    if (this._selectionJob || (this._selectionJob = this._createSelectionJob()), !this._selectionJobCompleted) {
      const t6 = performance.now();
      if (!this._selectionJob.work(o4))
        return false;
      if (this._selectionJobCompleted = true, 0 === (o4 = Math.max(0, o4 - (performance.now() - t6))))
        return false;
    }
    if (this._collisionJob || (this._collisionJob = this._createCollisionJob(this._selectionJob.sortedSymbols, this._screenWidth, this._screenHeight)), !this._collisionJobCompleted) {
      const t6 = performance.now();
      if (!this._collisionJob.work(o4))
        return false;
      if (this._collisionJobCompleted = true, 0 === (o4 = Math.max(0, o4 - (performance.now() - t6))))
        return false;
    }
    if (this._opacityJob || (this._opacityJob = this._createOpacityJob()), !this._opacityJobCompleted) {
      const t6 = performance.now();
      if (!this._opacityJob.work(o4))
        return false;
      if (this._opacityJobCompleted = true, 0 === (o4 = Math.max(0, o4 - (performance.now() - t6))))
        return false;
    }
    return this._running = false, true;
  }
  _createSelectionJob() {
    const o4 = this._symbolRepository.uniqueSymbols;
    for (let t6 = 0; t6 < o4.length; t6++) {
      const e8 = o4[t6];
      for (let o5 = 0; o5 < e8.uniqueSymbols.length; o5++) {
        const t7 = e8.uniqueSymbols[o5];
        for (const o6 of t7.tileSymbols)
          o6.selectedForRendering = false;
      }
    }
    const e7 = [];
    let i6 = 0, s2 = 0;
    const n6 = this._isLayerVisible;
    function r5(r6) {
      let l4;
      const c2 = performance.now();
      for (; s2 < o4.length; s2++, i6 = 0) {
        const t6 = o4[s2], h3 = t6.styleLayerUID;
        if (!n6(h3)) {
          e7[s2] || (e7[s2] = { styleLayerUID: h3, symbols: [] });
          continue;
        }
        e7[s2] = e7[s2] || { styleLayerUID: h3, symbols: [] };
        const a3 = e7[s2];
        for (; i6 < t6.uniqueSymbols.length; i6++) {
          if (l4 = t6.uniqueSymbols[i6], i6 % 100 == 99 && performance.now() - c2 > r6)
            return false;
          let o5 = null, e8 = false, s3 = false;
          for (const t7 of l4.tileSymbols)
            if (!s3 || !e8) {
              const i7 = t7.tile;
              (!o5 || i7.isCoverage || i7.neededForCoverage && !e8) && (o5 = t7, (i7.neededForCoverage || i7.isCoverage) && (s3 = true), i7.isCoverage && (e8 = true));
            }
          if (o5.selectedForRendering = true, s3) {
            a3.symbols.push(o5), l4.show = true;
            for (const o6 of l4.parts)
              o6.show = true;
          } else
            l4.show = false;
        }
      }
      for (const o5 of e7)
        o5.symbols.sort(t4);
      return true;
    }
    const l3 = this._symbolLayerSorter;
    return { work: r5, get sortedSymbols() {
      return e7.sort(l3);
    } };
  }
  _createOpacityJob() {
    const o4 = this._assignTileSymbolsOpacity, t6 = this._visibleTiles;
    let e7 = 0;
    function s2(t7, e8) {
      const n6 = t7.symbols;
      for (const [o5, s3] of n6)
        i4(s3, e8);
      o4(t7, e8);
      for (const o5 of t7.childrenTiles)
        s2(o5, e8);
    }
    return { work(o5) {
      const i6 = performance.now();
      for (; e7 < t6.length; e7++) {
        if (performance.now() - i6 > o5)
          return false;
        const n6 = t6[e7];
        if (null != n6.parentTile)
          continue;
        s2(n6, performance.now());
      }
      return true;
    } };
  }
};
function i4(t6, e7) {
  for (const i6 of t6) {
    const t7 = i6.unique;
    for (const i7 of t7.parts) {
      const s2 = i7.targetOpacity > 0.5 ? 1 : -1;
      i7.startOpacity += s2 * ((e7 - i7.startTime) / e4), i7.startOpacity = Math.min(Math.max(i7.startOpacity, 0), 1), i7.startTime = e7, i7.targetOpacity = t7.show && i7.show ? 1 : 0;
    }
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolRepository.js
var o3 = 32;
var t5 = 8;
var i5 = 64;
var n5 = class {
  constructor(e7, s2, l3) {
    this.tileCoordRange = e7, this._visibleTiles = s2, this._createUnique = l3, this._tiles = /* @__PURE__ */ new Map(), this._uniqueSymbolsReferences = /* @__PURE__ */ new Map();
  }
  get uniqueSymbols() {
    return null == this._uniqueSymbolLayerArray && (this._uniqueSymbolLayerArray = this._createUniqueSymbolLayerArray()), this._uniqueSymbolLayerArray;
  }
  get uniqueSymbolsReferences() {
    return this._uniqueSymbolsReferences;
  }
  add(s2, l3) {
    this._uniqueSymbolLayerArray = null;
    let n6 = this._tiles.get(s2.id);
    n6 || (n6 = { symbols: /* @__PURE__ */ new Map() }, this._tiles.set(s2.id, n6));
    const r5 = /* @__PURE__ */ new Map();
    if (l3)
      for (const e7 of l3)
        n6.symbols.has(e7) && (r5.set(e7, n6.symbols.get(e7)), n6.symbols.delete(e7));
    else
      for (const [e7, o4] of s2.layerData)
        n6.symbols.has(e7) && (r5.set(e7, n6.symbols.get(e7)), n6.symbols.delete(e7));
    this._removeSymbols(r5);
    const y = s2.symbols, a3 = /* @__PURE__ */ new Map();
    for (const [f2, u] of y) {
      let s3 = u.length;
      if (s3 >= o3) {
        let l4 = this.tileCoordRange;
        do {
          l4 /= 2, s3 /= 4;
        } while (s3 > t5 && l4 > i5);
        const o4 = new i2(this.tileCoordRange, this.tileCoordRange, l4);
        a3.set(f2, { flat: u, index: o4 }), n6.symbols.set(f2, { flat: u, index: o4 });
        for (const e7 of u)
          o4.getCell(e7.xTile, e7.yTile).push(e7);
      } else
        a3.set(f2, { flat: u }), n6.symbols.set(f2, { flat: u });
    }
    this._addSymbols(s2.key, y);
  }
  deleteStyleLayers(e7) {
    this._uniqueSymbolLayerArray = null;
    for (const [s2, l3] of this._tiles) {
      const o4 = /* @__PURE__ */ new Map();
      for (const s3 of e7)
        l3.symbols.has(s3) && (o4.set(s3, l3.symbols.get(s3)), l3.symbols.delete(s3));
      this._removeSymbols(o4), 0 === l3.symbols.size && this._tiles.delete(s2);
    }
  }
  removeTile(e7) {
    this._uniqueSymbolLayerArray = null;
    const s2 = this._tiles.get(e7.id);
    if (!s2)
      return;
    const l3 = /* @__PURE__ */ new Map();
    for (const [o4, t6] of e7.symbols)
      s2.symbols.has(o4) && (l3.set(o4, s2.symbols.get(o4)), s2.symbols.delete(o4));
    this._removeSymbols(l3), 0 === s2.symbols.size && this._tiles.delete(e7.id);
  }
  querySymbols(e7, l3, o4, t6) {
    const i6 = [], n6 = this.uniqueSymbols;
    for (const r5 of n6) {
      const t7 = r5.styleLayerUID, n7 = r5.uniqueSymbols;
      for (const r6 of n7) {
        const n8 = r6.tileSymbols.find((e8) => e8.selectedForRendering);
        n8 && c(n8, e7, l3 * (window.devicePixelRatio || 1), o4) && i6.push({ vtlSymbol: n8, styleLayerUID: t7, tileKey: n8.tile.key });
      }
    }
    return i6;
  }
  _removeSymbols(e7) {
    for (const [s2, { flat: l3 }] of e7)
      for (const e8 of l3) {
        const l4 = e8.unique, o4 = l4.tileSymbols, t6 = o4.length - 1;
        for (let s3 = 0; s3 < t6; s3++)
          if (o4[s3] === e8) {
            o4[s3] = o4[t6];
            break;
          }
        if (o4.length = t6, 0 === t6) {
          const e9 = this._uniqueSymbolsReferences.get(s2);
          e9.delete(l4), 0 === e9.size && this._uniqueSymbolsReferences.delete(s2);
        }
        e8.unique = null;
      }
  }
  _addSymbols(e7, s2) {
    if (0 === s2.size)
      return;
    const l3 = this._visibleTiles;
    for (const o4 of l3)
      o4.parentTile || o4.key.world !== e7.world || o4.key.level === e7.level && !o4.key.equals(e7) || this._matchSymbols(o4, e7, s2);
    for (const [o4, t6] of s2)
      for (const e8 of t6)
        if (null == e8.unique) {
          const s3 = this._createUnique();
          e8.unique = s3, s3.tileSymbols.push(e8);
          let l4 = this._uniqueSymbolsReferences.get(o4);
          l4 || (l4 = /* @__PURE__ */ new Set(), this._uniqueSymbolsReferences.set(o4, l4)), l4.add(s3);
        }
  }
  _matchSymbols(e7, s2, o4) {
    if (e7.key.level > s2.level) {
      const l3 = e7.key.level - s2.level;
      if (e7.key.row >> l3 !== s2.row || e7.key.col >> l3 !== s2.col)
        return;
    }
    if (s2.level > e7.key.level) {
      const l3 = s2.level - e7.key.level;
      if (s2.row >> l3 !== e7.key.row || s2.col >> l3 !== e7.key.col)
        return;
    }
    if (s2.equals(e7.key)) {
      for (const l3 of e7.childrenTiles)
        this._matchSymbols(l3, s2, o4);
      return;
    }
    const t6 = /* @__PURE__ */ new Map();
    for (const [i6, n6] of o4) {
      const o5 = [];
      for (const t7 of n6) {
        const i7 = o(this.tileCoordRange, t7.xTile, s2.level, s2.col, e7.key.level, e7.key.col), n7 = o(this.tileCoordRange, t7.yTile, s2.level, s2.row, e7.key.level, e7.key.row);
        i7 >= 0 && i7 < this.tileCoordRange && n7 >= 0 && n7 < this.tileCoordRange && o5.push({ symbol: t7, xTransformed: i7, yTransformed: n7 });
      }
      const r5 = [], y = e7.key.level < s2.level ? 1 : 1 << e7.key.level - s2.level, a3 = this._tiles.get(e7.id).symbols.get(i6);
      if (a3) {
        const e8 = a3.flat;
        for (const s3 of o5) {
          let l3, o6 = false;
          const t7 = s3.xTransformed, i7 = s3.yTransformed;
          l3 = null != a3.index ? a3.index.getCell(t7, i7) : e8;
          const n7 = s3.symbol, f2 = n7.hash;
          for (const e9 of l3)
            if (f2 === e9.hash && Math.abs(t7 - e9.xTile) <= y && Math.abs(i7 - e9.yTile) <= y) {
              const s4 = e9.unique;
              n7.unique = s4, s4.tileSymbols.push(n7), o6 = true;
              break;
            }
          o6 || r5.push(n7);
        }
      }
      r5.length > 0 && t6.set(i6, r5);
    }
    for (const l3 of e7.childrenTiles)
      this._matchSymbols(l3, s2, t6);
  }
  _createUniqueSymbolLayerArray() {
    const e7 = this._uniqueSymbolsReferences, s2 = new Array(e7.size);
    let l3, o4 = 0;
    for (const [t6, i6] of e7) {
      const e8 = new Array(i6.size);
      l3 = 0;
      for (const s3 of i6)
        e8[l3++] = s3;
      s2[o4] = { styleLayerUID: t6, uniqueSymbols: e8 }, o4++;
    }
    return s2;
  }
};

export {
  h2 as h,
  l2 as l,
  e6 as e,
  n5 as n,
  t3 as t
};
//# sourceMappingURL=chunk-HQRXH4OY.js.map
