import {
  n as n2,
  t,
  u as u2
} from "./chunk-FU2UQ2HG.js";
import {
  u
} from "./chunk-NGAYW4TW.js";
import {
  r
} from "./chunk-U34ZXOJT.js";
import {
  I2 as I,
  J,
  M,
  x
} from "./chunk-X7VSXJWW.js";
import {
  B,
  F,
  b as b2,
  k as k3
} from "./chunk-2ICUS4HL.js";
import {
  P,
  d,
  w
} from "./chunk-Z4Y53NDM.js";
import {
  b
} from "./chunk-BVQWKK2V.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  a as a2,
  f2 as f,
  k as k2
} from "./chunk-JGDJR5EV.js";
import {
  e as e2
} from "./chunk-QHK5ZYFW.js";
import {
  a,
  n2 as n
} from "./chunk-7RBRCL6S.js";
import {
  k
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/featureEditing.js
var o = { setAttribute() {
}, rollback() {
}, commit() {
} };
var r2;
function i(e3, n3) {
  const i3 = n3.attributes[e3.objectIdField];
  if (null == i3)
    return o;
  const s2 = e3.sessions.get(i3);
  if (s2)
    return s2;
  const l2 = a(n3.attributes), u4 = /* @__PURE__ */ new Set(), a7 = e3.i3sOverrides.createInteractiveEditSession(i3), d3 = /* @__PURE__ */ new Map(), f4 = (e4, t2) => {
    const n4 = d3.get(e4);
    if (null == n4) {
      const n5 = t2.indexOf(i3);
      return d3.set(e4, n5), n5;
    }
    return n4;
  };
  let c3 = r2.EDITING;
  const g2 = { setAttribute(t2, o2) {
    if (c3 !== r2.EDITING)
      return;
    const i4 = e3.fieldsIndex.get(t2);
    if (!i4)
      return;
    const s3 = e3.attributeStorageInfo.findIndex((e4) => e4.name === i4.name);
    if (s3 < 0)
      return;
    if (!(t2 in l2))
      throw new Error(`Attribute "${t2}" is not an attribute of the edited feature.`);
    a7.setAttribute(s3, o2);
    const d4 = e3.attributeStorageInfo[s3];
    let g3 = false;
    u4.add(t2), e3.forEachNode((t3, r3) => {
      const i5 = f4(t3, r3);
      if (-1 === i5)
        return;
      const s4 = e3.getAttributeData(t3.index);
      if (s4) {
        const r4 = s4[d4.name];
        r4 && (r4[i5] = o2, e3.setAttributeData(t3.index, s4, n3), g3 = true);
      }
    }), g3 && e3.clearMemCache();
  }, rollback() {
    if (c3 === r2.EDITING) {
      for (const e4 of u4)
        this.setAttribute(e4, l2[e4]);
      a7.remove(), c3 = r2.ROLLED_BACK, e3.sessions.delete(i3);
    }
  }, commit() {
    c3 === r2.EDITING && (a7.remove(), c3 = r2.COMMITTED, e3.sessions.delete(i3));
  } };
  return e3.sessions.set(i3, g2), g2;
}
function s(e3, t2, n3) {
  const { gidToFeatureInfo: o2, oidToFeatureInfo: r3, fieldsIndex: i3, objectIdField: s2, globalIdField: l2, featureOrIdentifierList: u4 } = n3;
  if (!n3.featuresResolved && null != u4) {
    for (const e4 of u4) {
      const t3 = { feature: null, oid: -1, gid: null };
      if ("attributes" in e4) {
        t3.feature = e4;
        const n4 = e4.attributes;
        if (null != n4)
          for (const e5 in n4) {
            if (-1 !== t3.oid && null != t3.gid)
              break;
            const o3 = i3.normalizeFieldName(e5);
            o3 === s2 && (t3.oid = n4[e5] ?? -1), o3 === l2 && (t3.gid = n4[e5]);
          }
      } else
        t3.oid = e4.objectId ?? -1, t3.gid = e4.globalId;
      null != t3.gid && o2.set(t3.gid, t3), -1 !== t3.oid && r3.set(t3.oid, t3);
    }
    n3.featuresResolved = true;
  }
  return (-1 !== e3 ? r3.get(e3) : null) ?? (null != t2 ? o2.get(t2) : null);
}
function l(e3, t2, n3, o2, r3 = null, i3 = true) {
  const l2 = [], u4 = { gidToFeatureInfo: /* @__PURE__ */ new Map(), oidToFeatureInfo: /* @__PURE__ */ new Map(), featuresResolved: null == n3, fieldsIndex: e3.fieldsIndex, objectIdField: e3.objectIdField, globalIdField: e3.globalIdField, featureOrIdentifierList: n3 };
  for (const a7 of t2) {
    if (null != a7.error)
      continue;
    const e4 = a7.objectId ?? -1, t3 = a7.globalId, n4 = (-1 === e4 || i3 ? s(e4, t3, u4) : null) ?? { feature: null, oid: e4, gid: t3 }, d3 = { oid: -1 === e4 ? n4.oid : e4, gid: t3 ?? n4.gid, feature: n4.feature, result: a7 };
    if (l2.push(d3), -1 === d3.oid && null != d3.gid && null != r3 && (d3.oid = r3.get(d3.gid) ?? -1), -1 === d3.oid && null != d3.gid) {
      let e5 = o2.get(d3.gid);
      null == e5 && (e5 = [], o2.set(d3.gid, e5)), e5.push(d3);
    }
  }
  return l2;
}
async function u3(e3, t2) {
  var _a, _b, _c;
  const n3 = /* @__PURE__ */ new Map(), o2 = l(e3, t2.addedFeatures, (_a = t2.edits) == null ? void 0 : _a.addFeatures, n3), r3 = l(e3, t2.updatedFeatures, (_b = t2.edits) == null ? void 0 : _b.updateFeatures, n3), i3 = l(e3, t2.deletedFeatures, (_c = t2.edits) == null ? void 0 : _c.deleteFeatures, n3, t2.globalIdToObjectId, false);
  return n3.size > 0 && await a4(e3, n3), { adds: o2.filter((e4) => -1 !== e4.oid), updates: r3.filter((e4) => -1 !== e4.oid), deletes: i3.filter((e4) => -1 !== e4.oid) };
}
async function a4(t2, o2) {
  const r3 = t2.i3sOverrides.layer.associatedLayer;
  if (null == (r3 == null ? void 0 : r3.globalIdField))
    return;
  const i3 = r3.createQuery(), { objectIdField: s2, globalIdField: l2 } = r3;
  i3.where = Array.from(o2.keys()).map((e3) => `${l2}='${e3}'`).join(" OR "), i3.returnGeometry = false, i3.outFields = [s2, l2], i3.cacheHint = false;
  const u4 = await b(r(r3, i3));
  if (!u4.ok)
    return;
  const a7 = u4.value.features;
  for (const e3 of a7) {
    const t3 = e3.attributes[l2], n3 = e3.attributes[s2];
    if (null == t3 || null == n3 || -1 === n3)
      continue;
    const r4 = o2.get(t3);
    if (null != r4)
      for (const e4 of r4)
        e4.oid = n3;
  }
}
function d2(e3, t2) {
  var _a, _b;
  const n3 = /* @__PURE__ */ new Map(), o2 = t2.adds, r3 = t2.updates, i3 = t2.deletes;
  if (o2.length > 0)
    for (const s2 of o2) {
      const e4 = s2.oid, t3 = s2.feature;
      "mesh" === ((_a = t3 == null ? void 0 : t3.geometry) == null ? void 0 : _a.type) && n3.set(e4, t3.geometry);
    }
  if (r3.length > 0)
    for (const s2 of r3) {
      const e4 = s2.oid, t3 = s2.feature;
      "mesh" === ((_b = t3 == null ? void 0 : t3.geometry) == null ? void 0 : _b.type) && n3.set(e4, t3.geometry);
    }
  if (i3.length > 0)
    for (const s2 of i3)
      n3.set(s2.oid, null);
  for (const [s2, l2] of n3)
    e3.i3sOverrides.updateGeometry(s2, l2);
}
function f2(e3, t2) {
  var _a;
  const n3 = g(e3, t2), o2 = c(e3, t2);
  if (0 === n3.size && 0 === o2.size)
    return;
  const r3 = /* @__PURE__ */ new Map();
  for (let c3 = 0; c3 < e3.attributeStorageInfo.length; c3++)
    r3.set(e3.attributeStorageInfo[c3].name, c3);
  let i3 = false;
  n3.forEach((t3, n4) => {
    const o3 = e3.getAttributeData(n4);
    let s3 = false;
    t3.forEach((t4, n5) => {
      const l3 = null != o3 ? o3[n5] : null, u5 = r3.get(n5);
      for (const { featureIndex: o4, value: r4, featureId: a8 } of t4)
        l3 && (l3[o4] = r4, s3 = true, i3 = true), e3.i3sOverrides.updateAttributeValue(a8, u5, r4);
    }), s3 && e3.setAttributeData(n4, o3, null);
  }), i3 && e3.clearMemCache();
  const { fieldsIndex: s2, i3sOverrides: l2, objectIdField: u4, globalIdField: a7 } = e3, d3 = (_a = l2.layer.associatedLayer) == null ? void 0 : _a.infoFor3D, f4 = new Set(d3 ? [...Object.values(d3.assetMapFieldRoles), ...Object.values(d3.transformFieldRoles)] : []);
  for (const [c3, g2] of o2) {
    l2.featureAdded(c3);
    const { attributes: e4 } = g2;
    for (const t3 in e4) {
      if (t3 !== u4 && t3 !== a7 && f4.has(t3))
        continue;
      const n4 = s2.normalizeFieldName(t3), o3 = null != n4 ? r3.get(n4) : null;
      if (null == o3)
        continue;
      const i4 = e4[t3];
      l2.updateAttributeValue(c3, o3, i4);
    }
  }
}
function c(e3, t2) {
  var _a;
  const n3 = /* @__PURE__ */ new Map(), o2 = t2.adds;
  if (!o2 || 0 === o2.length || null == e3.globalIdField)
    return n3;
  for (const r3 of o2) {
    const e4 = r3.oid, t3 = r3.feature;
    "mesh" === ((_a = t3 == null ? void 0 : t3.geometry) == null ? void 0 : _a.type) && n3.set(e4, t3);
  }
  return n3;
}
function g(e3, t2) {
  const n3 = t2.updates;
  if (!n3 || 0 === n3.length)
    return new p();
  const o2 = new p(), r3 = /* @__PURE__ */ new Map();
  for (let i3 = 0; i3 < e3.attributeStorageInfo.length; i3++)
    r3.set(e3.attributeStorageInfo[i3].name, i3);
  return e3.forEachNode((t3, r4) => {
    for (const i3 of n3) {
      if (null == i3.feature)
        continue;
      const n4 = i3.feature, s2 = i3.oid, l2 = r4.indexOf(s2);
      for (const r5 in n4.attributes) {
        const i4 = e3.fieldsIndex.normalizeFieldName(r5), u4 = I2(o2, t3.index, i4), a7 = n4.attributes[r5];
        u4.push({ featureIndex: l2, featureId: s2, value: a7 });
      }
    }
  }), o2;
}
function I2(e3, t2, n3) {
  const o2 = b3(e3, t2), r3 = null != n3 && o2.get(n3);
  if (r3)
    return r3;
  const i3 = new Array();
  return o2.set(n3, i3), i3;
}
function b3(e3, t2) {
  const n3 = e3.get(t2);
  if (n3)
    return n3;
  const o2 = new m();
  return e3.set(t2, o2), o2;
}
!function(e3) {
  e3[e3.EDITING = 0] = "EDITING", e3[e3.ROLLED_BACK = 1] = "ROLLED_BACK", e3[e3.COMMITTED = 2] = "COMMITTED";
}(r2 || (r2 = {}));
var m = Map;
var p = Map;

// node_modules/@arcgis/core/views/3d/layers/support/fieldProperties.js
function i2() {
  return { requiredFields: { type: [String], readOnly: true }, availableFields: { type: [String], readOnly: true, get: function() {
    const { layer: i3, layer: { fieldsIndex: t2 }, requiredFields: l2 } = this;
    return i3.outFields ? I(t2, [...x(t2, i3.outFields), ...l2]) : I(t2, l2);
  } } };
}

// node_modules/@arcgis/core/core/AsyncUpdate.js
var c2 = (s2) => {
  let c3 = class extends s2 {
    constructor() {
      super(...arguments), this._numUpdating = 0;
    }
    get updating() {
      return this._numUpdating > 0;
    }
    autoUpdateAsync(t2, s3) {
      const i3 = k2(async (s4) => {
        ++this._numUpdating;
        try {
          const r3 = await s4;
          this.destroyed || this._set(t2, r3);
        } catch (o2) {
          n.getLogger(this).warn(`Async update of "${String(t2)}" failed. Async update functions should not throw exceptions.`);
        }
        --this._numUpdating;
      });
      return d(s3, i3, P);
    }
  };
  return e([y({ readOnly: true })], c3.prototype, "updating", null), e([y()], c3.prototype, "_numUpdating", void 0), c3 = e([a3("esri.core.AsyncUpdate")], c3), c3;
};
var a5 = class extends c2(S) {
};
a5 = e([a3("esri.core.AsyncUpdate")], a5);

// node_modules/@arcgis/core/views/3d/layers/support/SceneLayerViewRequiredFields.js
var a6 = class extends c2(S) {
  get layer() {
    return this.layerView.layer;
  }
  get requiredFields() {
    const { layerView: { layer: { fieldsIndex: e3 }, definitionExpressionFields: r3 }, rendererFields: s2, labelingFields: t2, viewFilterFields: i3 } = this;
    return I(e3, [...r3 ?? [], ...s2 ?? [], ...t2 ?? [], ...i3 ?? []]);
  }
  constructor(e3) {
    super(e3);
  }
  initialize() {
    this.addHandles([this.autoUpdateAsync("rendererFields", async () => {
      const { fieldsIndex: e3, renderer: r3 } = this.layer;
      return r3 ? this._getFieldsAsync((s2) => r3.collectRequiredFields(s2, e3)) : null;
    }), this.autoUpdateAsync("labelingFields", async () => {
      const { layer: e3 } = this;
      return e3.labelsVisible ? this._getFieldsAsync((r3) => J(r3, e3)) : null;
    }), this.autoUpdateAsync("viewFilterFields", () => {
      const { layer: e3, mergedFilter: r3 } = this.layerView;
      return this._getFieldsAsync((s2) => M(s2, e3, r3));
    })]);
  }
  async _getFieldsAsync(e3) {
    const r3 = /* @__PURE__ */ new Set();
    try {
      return await e3(r3), Array.from(r3).sort();
    } catch (s2) {
      return n.getLogger(this).error(s2), null;
    }
  }
};
e([y()], a6.prototype, "layerView", void 0), e([y()], a6.prototype, "layer", null), e([y()], a6.prototype, "requiredFields", null), e([y()], a6.prototype, "rendererFields", void 0), e([y()], a6.prototype, "labelingFields", void 0), e([y()], a6.prototype, "viewFilterFields", void 0), a6 = e([a3("esri.views.3d.layers.support.SceneLayerViewRequiredFields")], a6);

// node_modules/@arcgis/core/views/layers/SceneLayerView.js
var f3 = class extends u {
  constructor() {
    super(...arguments), this.layer = null, this.filter = null, this._geometryEngine = null, this._projectionEngineLoaded = false, this._abortController = new AbortController();
  }
  get availableFields() {
    return [];
  }
  get maximumNumberOfFeatures() {
    return 0;
  }
  set maximumNumberOfFeatures(e3) {
    throw new Error("Not implemented");
  }
  get maximumNumberOfFeaturesExceeded() {
    return false;
  }
  get layerFilter() {
    return t(this._layerFilter);
  }
  get _layerFilter() {
    var _a;
    const e3 = (_a = this.layer) == null ? void 0 : _a.filter;
    if (null == e3 || e3.geometries.length < 1)
      return null;
    const o2 = this._geometryEngine;
    if (null == o2 || !this._projectionEngineLoaded && this._filterNeedsProjectionEngine)
      return n2;
    const i3 = e3.geometries.at(0).spatialReference, l2 = e3.geometries.toArray().map((e4) => {
      try {
        e4 = o2.simplify(e4);
      } catch (t2) {
        return n.getLogger(this).warnOncePerTick("Failed to simplify scene filter mask polygon. Polygon will be ignored."), null;
      }
      if (null == e4)
        return null;
      if (e4.spatialReference.equals(i3))
        return e4;
      try {
        return B(e4, i3);
      } catch (t2) {
        return n.getLogger(this).warnOncePerTick("Failed to project scene filter mask polygon. Polygon will be ignored."), null;
      }
    }).filter(k).sort((e4, t2) => e4.extent.xmin - t2.extent.xmin), s2 = /* @__PURE__ */ new Set(), a7 = new Array(), m2 = new Array();
    for (let t2 of l2) {
      const e4 = t2.extent.xmin;
      if (a7.length = 0, s2.forEach((r3) => {
        if (e4 >= r3.extent.xmax)
          return m2.push(r3), void s2.delete(r3);
        t2.extent.ymin <= r3.extent.ymax && t2.extent.ymax >= r3.extent.ymin && o2.intersects(t2, r3) && a7.push(r3);
      }), a7.length > 0) {
        a7.push(t2);
        try {
          t2 = o2.union(a7);
        } catch (p2) {
          n.getLogger(this).warnOncePerTick("Failed to unify filter mask polygons. Polygon will be ignored.");
          continue;
        }
        a7.pop(), a7.forEach((e5) => s2.delete(e5));
      }
      s2.add(t2);
    }
    return s2.forEach((e4) => m2.push(e4)), m2.length > 0 ? { spatialRelationship: e3.spatialRelationship, geometries: m2 } : null;
  }
  get _filterNeedsProjectionEngine() {
    const e3 = this.layer.filter;
    if (null == e3 || e3.geometries.length <= 1)
      return false;
    const t2 = e3.geometries.at(0).spatialReference;
    return e3.geometries.some(({ spatialReference: e4 }) => !e4.equals(t2) && !F(e4, t2));
  }
  get layerFilterUpdating() {
    return u2(this._layerFilter);
  }
  initialize() {
    const { signal: e3 } = this._abortController;
    w(() => {
      var _a, _b, _c;
      return this.destroyed || !this._geometryEngine && ((_c = (_b = (_a = this.layer) == null ? void 0 : _a.filter) == null ? void 0 : _b.geometries) == null ? void 0 : _c.length);
    }, e3).then(async () => {
      a2(e3), this._geometryEngine = await import("./geometryEngine-SEKGYY2X.js");
    }).catch(f), this._projectionEngineLoaded = b2(), w(() => this.destroyed || !this._projectionEngineLoaded && this._filterNeedsProjectionEngine, e3).then(async () => {
      a2(e3), await k3(), this._projectionEngineLoaded = true;
    }).catch(f);
  }
  destroy() {
    this._abortController = e2(this._abortController);
  }
  highlight(e3) {
    throw new Error("Not implemented");
  }
  queryFeatures(e3, t2) {
    throw new Error("Not implemented");
  }
  queryObjectIds(e3, t2) {
    throw new Error("Not implemented");
  }
  queryFeatureCount(e3, t2) {
    throw new Error("Not implemented");
  }
  createQuery() {
    throw new Error("Not implemented");
  }
  queryExtent(e3, t2) {
    throw new Error("Not implemented");
  }
};
e([y()], f3.prototype, "layer", void 0), e([y()], f3.prototype, "availableFields", null), e([y()], f3.prototype, "maximumNumberOfFeatures", null), e([y({ readOnly: true })], f3.prototype, "maximumNumberOfFeaturesExceeded", null), e([y()], f3.prototype, "filter", void 0), e([y({ readOnly: true })], f3.prototype, "layerFilter", null), e([y({ readOnly: true })], f3.prototype, "_layerFilter", null), e([y()], f3.prototype, "_geometryEngine", void 0), e([y()], f3.prototype, "_projectionEngineLoaded", void 0), e([y()], f3.prototype, "_filterNeedsProjectionEngine", null), e([y()], f3.prototype, "layerFilterUpdating", null), f3 = e([a3("esri.views.layers.SceneLayerView")], f3);
var w2 = f3;

export {
  i,
  u3 as u,
  d2 as d,
  f2 as f,
  i2,
  a6 as a,
  w2 as w
};
//# sourceMappingURL=chunk-NUJDDQFT.js.map
