import {
  i
} from "./chunk-TNR6E67I.js";
import {
  e2 as e,
  m
} from "./chunk-JTUYA5FE.js";
import {
  s as s2
} from "./chunk-UNTQATE2.js";
import {
  t
} from "./chunk-FFG7BDAP.js";
import {
  C,
  U
} from "./chunk-WKVHVZW2.js";
import {
  c2 as c,
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/DisplayRecord.js
var t2 = class _t {
  constructor(t4, e5, s4, r4, i2, h2, n6) {
    this.instanceId = t4, this.textureKey = e5, this.indexStart = s4, this.indexCount = r4, this.vertexStart = i2, this.vertexCount = h2, this.overlaps = n6;
  }
  updateBaseOffsets(t4) {
    this.vertexStart += t4.vertexFrom, this.indexStart += t4.indexFrom;
  }
  clone() {
    return new _t(this.instanceId, this.textureKey, this.indexStart, this.indexCount, this.vertexStart, this.vertexCount, this.overlaps);
  }
  static write(t4, e5, s4, r4, i2, h2, n6, a) {
    t4.push(e5), t4.push(s4), t4.push(r4), t4.push(i2), t4.push(h2), t4.push(n6), t4.push(a);
  }
  serialize(t4) {
    return t4.push(this.instanceId), t4.push(this.textureKey), t4.push(this.indexStart), t4.push(this.indexCount), t4.push(this.vertexStart), t4.push(this.vertexCount), t4.push(this.overlaps), t4;
  }
  static deserialize(e5) {
    const s4 = e5.readInt32(), r4 = e5.readInt32(), i2 = e5.readInt32(), h2 = e5.readInt32(), n6 = e5.readInt32(), a = e5.readInt32(), u2 = e5.readInt32();
    return new _t(s4, r4, i2, h2, n6, a, u2);
  }
};
t2.byteSizeHint = 7 * Uint32Array.BYTES_PER_ELEMENT;

// node_modules/@arcgis/core/views/2d/engine/webgl/util/serializationUtils.js
function e2(e5, n6) {
  if (null !== n6) {
    e5.push(n6.length);
    for (const r4 of n6)
      r4.serialize(e5);
    return e5;
  }
  e5.push(0);
}
function n2(e5, n6, r4) {
  const t4 = e5.readInt32(), o2 = new Array(t4);
  for (let i2 = 0; i2 < o2.length; i2++)
    o2[i2] = n6.deserialize(e5, r4);
  return o2;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/DisplayEntity.js
var s3 = class _s {
  constructor(t4, r4) {
    this.id = t4, this.sortKey = r4, this.records = [];
  }
  serialize(t4) {
    return t4.push(this.id), t4.writeF32(this.sortKey), e2(t4, this.records), t4;
  }
  static deserialize(r4) {
    const e5 = r4.readInt32(), o2 = r4.readF32(), a = new _s(e5, o2);
    return a.records = n2(r4, t2) ?? [], a;
  }
};
s3.byteSizeHint = 2 * Uint32Array.BYTES_PER_ELEMENT + t2.byteSizeHint;

// node_modules/@arcgis/core/views/2d/engine/webgl/number.js
var n3 = new Float32Array(1);
var r = new Uint32Array(n3.buffer);
function w(n6, r4) {
  return 65535 & n6 | r4 << 16;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/utils.js
function t3(t4) {
  const o2 = t4.map(({ name: e5, count: t5, type: o3 }) => `${e5}.${t5}.${o3}`).join(",");
  return c(o2);
}
function o(e5, t4, r4, i2, n6, a, c3) {
  if (e5.primitiveName === t4) {
    for (const o2 in e5)
      if (o2 === r4) {
        let t5 = i2 == null ? void 0 : i2.readWithDefault(n6, a, e5[o2] && c3);
        return "text" === e5.type && (t5 = t5.toString()), void (e5[o2] = t5);
      }
  }
  if ("type" in e5 && null != e5.type)
    switch (e5.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        if (e5.symbolLayers)
          for (const l of e5.symbolLayers)
            o(l, t4, r4, i2, n6, a, c3);
        break;
      case "CIMHatchFill":
        e5.lineSymbol && o(e5.lineSymbol, t4, r4, i2, n6, a, c3);
        break;
      case "CIMSolidStroke":
      case "CIMSolidFill":
      case "CIMVectorMarker":
        if ("CIMVectorMarker" === e5.type && e5.markerGraphics)
          for (const l of e5.markerGraphics)
            o(l, t4, r4, i2, n6, a, c3), o(l.symbol, t4, r4, i2, n6, a, c3);
    }
}
function r2(e5) {
  const t4 = e5.width;
  return null != e5.effects ? 256 : Math.max(1.25 * t4, 8);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/Utils.js
var u = () => n.getLogger("esri.views.2d.engine.webgl.Utils");
function c2(t4) {
  switch (t4) {
    case U.UNSIGNED_BYTE:
      return 1;
    case U.UNSIGNED_SHORT_4_4_4_4:
      return 2;
    case U.FLOAT:
      return 4;
    default:
      return void u().error(new s("webgl-utils", `Unable to handle type ${t4}`));
  }
}
function d(t4) {
  switch (t4) {
    case U.UNSIGNED_BYTE:
      return Uint8Array;
    case U.UNSIGNED_SHORT_4_4_4_4:
      return Uint16Array;
    case U.FLOAT:
      return Float32Array;
    default:
      return void u().error(new s("webgl-utils", `Unable to handle type ${t4}`));
  }
}
function f(e5) {
  var _a;
  const t4 = {};
  for (const r4 in e5) {
    const n6 = e5[r4];
    let o2 = 0;
    t4[r4] = n6.map((e6) => {
      const t5 = new t(e6.name, e6.count, e6.type, o2, 0, e6.normalized || false);
      return o2 += e6.count * s2(e6.type), t5;
    }), (_a = t4[r4]) == null ? void 0 : _a.forEach((e6) => e6.stride = o2);
  }
  return t4;
}
var g = (e5) => {
  const t4 = /* @__PURE__ */ new Map();
  for (const r4 in e5)
    for (const n6 of e5[r4])
      t4.set(n6.name, n6.location);
  return t4;
};
var h = (e5) => {
  const t4 = {};
  for (const r4 in e5) {
    const n6 = e5[r4];
    t4[r4] = (n6 == null ? void 0 : n6.length) ? n6[0].stride : 0;
  }
  return t4;
};
var w2 = /* @__PURE__ */ new Map();
var b = (e5, t4) => {
  if (!w2.has(e5)) {
    const r4 = f(t4), n6 = { strides: h(r4), bufferLayouts: r4, attributes: g(t4) };
    w2.set(e5, n6);
  }
  return w2.get(e5);
};
var y = (e5) => e5.includes("data:image/svg+xml");
function j(e5) {
  const t4 = [];
  for (let r4 = 0; r4 < e5.length; r4++)
    t4.push(e5.charCodeAt(r4));
  return t4;
}
function T(e5, t4, r4) {
  const n6 = new e(t4.width, t4.height);
  return n6.dataType = t4.dataType, t4.depth && (n6.depth = t4.depth), t4.flipped && (n6.flipped = t4.flipped), t4.hasMipmap && (n6.hasMipmap = t4.hasMipmap), n6.internalFormat = t4.internalFormat, t4.isImmutable && (n6.isImmutable = t4.isImmutable), t4.isOpaque && (n6.isOpaque = t4.isOpaque), t4.maxAnisotropy && (n6.maxAnisotropy = t4.maxAnisotropy), n6.pixelFormat = t4.pixelFormat, t4.preMultiplyAlpha && (n6.preMultiplyAlpha = t4.preMultiplyAlpha), t4.samplingMode && (n6.samplingMode = t4.samplingMode), t4.target && (n6.target = t4.target), n6.uniform = t4.uniform, t4.unpackAlignment && (n6.unpackAlignment = t4.unpackAlignment), t4.wrapMode && (n6.wrapMode = t4.wrapMode), new m(e5, n6, r4);
}
function M(e5) {
  return "url" in e5 && "urlHash" in e5 ? { ...e5, url: "" } : e5;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/LabelMetric.js
var r3 = class _r {
  constructor(e5, i2, t4, r4, s4, n6, o2, a, h2 = []) {
    this.entityTexel = e5, this.anchorX = i2, this.anchorY = t4, this.directionX = r4, this.directionY = s4, this.maxScale = n6, this.minScale = o2, this.referenceBounds = a, this.bounds = h2;
  }
  serialize(e5) {
    e5.push(this.entityTexel), e5.writeF32(this.anchorX), e5.writeF32(this.anchorY), e5.writeF32(this.directionX), e5.writeF32(this.directionY), e5.writeF32(this.maxScale), e5.writeF32(this.minScale), null === this.referenceBounds ? (e5.writeF32(0), e5.writeF32(0), e5.writeF32(0)) : (e5.writeF32(this.referenceBounds.size), e5.writeF32(this.referenceBounds.offsetX), e5.writeF32(this.referenceBounds.offsetY)), e2(e5, this.bounds);
  }
  static deserialize(i2) {
    const s4 = i2.readInt32(), n6 = i2.readF32(), o2 = i2.readF32(), a = i2.readF32(), h2 = i2.readF32(), d2 = i2.readF32(), c3 = i2.readF32(), F = i2.readF32(), f2 = i2.readF32(), l = i2.readF32(), u2 = n2(i2, i) ?? [];
    return new _r(s4, n6, o2, a, h2, d2, c3, { size: F, offsetX: f2, offsetY: l }, u2);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/dataViewUtils.js
function e4(e5, n6, o2, s4) {
  const f2 = o2.packPrecisionFactor ?? 1;
  switch (o2.type) {
    case C.BYTE:
      if (1 === o2.count)
        e5.setInt8(s4 + o2.offset, n6 * f2);
      else
        for (let t4 = 0; t4 < o2.count; t4++) {
          const r4 = t4 * Int8Array.BYTES_PER_ELEMENT;
          e5.setInt8(s4 + o2.offset + r4, n6[t4] * f2);
        }
      break;
    case C.UNSIGNED_BYTE:
      if (1 === o2.count)
        e5.setUint8(s4 + o2.offset, n6 * f2);
      else
        for (let t4 = 0; t4 < o2.count; t4++) {
          const r4 = t4 * Uint8Array.BYTES_PER_ELEMENT;
          e5.setUint8(s4 + o2.offset + r4, n6[t4] * f2);
        }
      break;
    case C.SHORT:
      if (1 === o2.count)
        e5.setInt16(s4 + o2.offset, n6 * f2, true);
      else
        for (let t4 = 0; t4 < o2.count; t4++) {
          const r4 = t4 * Int16Array.BYTES_PER_ELEMENT;
          e5.setInt16(s4 + o2.offset + r4, n6[t4] * f2, true);
        }
      break;
    case C.UNSIGNED_SHORT:
      if (1 === o2.count)
        e5.setUint16(s4 + o2.offset, n6 * f2, true);
      else
        for (let t4 = 0; t4 < o2.count; t4++) {
          const r4 = t4 * Uint16Array.BYTES_PER_ELEMENT;
          e5.setUint16(s4 + o2.offset + r4, n6[t4] * f2, true);
        }
      break;
    case C.INT:
      if (1 === o2.count)
        e5.setInt32(s4 + o2.offset, n6 * f2, true);
      else
        for (let t4 = 0; t4 < o2.count; t4++) {
          const r4 = t4 * Int32Array.BYTES_PER_ELEMENT;
          e5.setInt32(s4 + o2.offset + r4, n6[t4] * f2, true);
        }
      break;
    case C.UNSIGNED_INT:
      if (1 === o2.count)
        e5.setUint32(s4 + o2.offset, n6 * f2, true);
      else
        for (let t4 = 0; t4 < o2.count; t4++) {
          const r4 = t4 * Uint32Array.BYTES_PER_ELEMENT;
          e5.setUint32(s4 + o2.offset + r4, n6[t4] * f2, true);
        }
      break;
    case C.FLOAT:
      if (1 === o2.count)
        e5.setFloat32(s4 + o2.offset, n6 * f2, true);
      else
        for (let t4 = 0; t4 < o2.count; t4++) {
          const r4 = t4 * Float32Array.BYTES_PER_ELEMENT;
          e5.setFloat32(s4 + o2.offset + r4, n6[t4] * f2, true);
        }
  }
}
function n5(e5, n6, o2) {
  switch (n6.type) {
    case C.BYTE: {
      if (1 === n6.count)
        return e5.getInt8(o2 + n6.offset);
      const t4 = [];
      for (let s4 = 0; s4 < n6.count; s4++) {
        const f2 = s4 * Int8Array.BYTES_PER_ELEMENT;
        t4.push(e5.getInt8(o2 + n6.offset + f2));
      }
      return t4;
    }
    case C.UNSIGNED_BYTE: {
      if (1 === n6.count)
        return e5.getUint8(o2 + n6.offset);
      const t4 = [];
      for (let s4 = 0; s4 < n6.count; s4++) {
        const f2 = s4 * Uint8Array.BYTES_PER_ELEMENT;
        t4.push(e5.getUint8(o2 + n6.offset + f2));
      }
      return t4;
    }
    case C.SHORT: {
      if (1 === n6.count)
        return e5.getInt16(o2 + n6.offset, true);
      const t4 = [];
      for (let s4 = 0; s4 < n6.count; s4++) {
        const f2 = s4 * Int16Array.BYTES_PER_ELEMENT;
        t4.push(e5.getInt16(o2 + n6.offset + f2, true));
      }
      return t4;
    }
    case C.UNSIGNED_SHORT: {
      if (1 === n6.count)
        return e5.getUint16(o2 + n6.offset, true);
      const t4 = [];
      for (let s4 = 0; s4 < n6.count; s4++) {
        const f2 = s4 * Uint16Array.BYTES_PER_ELEMENT;
        t4.push(e5.getUint16(o2 + n6.offset + f2, true));
      }
      return t4;
    }
    case C.INT: {
      if (1 === n6.count)
        return e5.getInt32(o2 + n6.offset, true);
      const t4 = [];
      for (let s4 = 0; s4 < n6.count; s4++) {
        const f2 = s4 * Int32Array.BYTES_PER_ELEMENT;
        t4.push(e5.getInt32(o2 + n6.offset + f2, true));
      }
      return t4;
    }
    case C.UNSIGNED_INT: {
      if (1 === n6.count)
        return e5.getUint32(o2 + n6.offset, true);
      const t4 = [];
      for (let s4 = 0; s4 < n6.count; s4++) {
        const f2 = s4 * Uint32Array.BYTES_PER_ELEMENT;
        t4.push(e5.getUint32(o2 + n6.offset + f2, true));
      }
      return t4;
    }
    case C.FLOAT: {
      if (1 === n6.count)
        return e5.getFloat32(o2 + n6.offset, true);
      const t4 = [];
      for (let s4 = 0; s4 < n6.count; s4++) {
        const f2 = s4 * Float32Array.BYTES_PER_ELEMENT;
        t4.push(e5.getFloat32(o2 + n6.offset + f2, true));
      }
      return t4;
    }
  }
}

export {
  t2 as t,
  n2 as n,
  s3 as s,
  t3 as t2,
  o,
  r2 as r,
  w,
  e4 as e,
  n5 as n2,
  c2 as c,
  d,
  b,
  y,
  j,
  T,
  M,
  r3 as r2
};
//# sourceMappingURL=chunk-C5EJV3NW.js.map
