import {
  $,
  I,
  P,
  c,
  d,
  j,
  l as l2,
  v,
  w,
  y
} from "./chunk-EZNF6O3O.js";
import "./chunk-DORNK7ZC.js";
import {
  i as i3
} from "./chunk-OWKPWQPA.js";
import "./chunk-CQFVWMFK.js";
import "./chunk-VQWLJR3W.js";
import "./chunk-RDPH36VD.js";
import {
  a,
  f,
  i as i2,
  l,
  u
} from "./chunk-LBXFRGMS.js";
import {
  i,
  t
} from "./chunk-4WS4UHOQ.js";
import "./chunk-LT6KUDSQ.js";
import {
  p
} from "./chunk-VTH4DAHQ.js";
import {
  a as a2
} from "./chunk-GWC53NTZ.js";
import {
  L
} from "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import "./chunk-D25BO7X7.js";
import "./chunk-NDIXNREV.js";
import "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  s
} from "./chunk-7RBRCL6S.js";
import {
  g,
  h,
  k
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/layers/save/featureLayerUtils.js
var P2 = "Feature Service";
var E = "feature-layer-utils";
var $2 = `${E}-save`;
var x = `${E}-save-as`;
var N = `${E}-saveall`;
var g2 = `${E}-saveall-as`;
function O(e) {
  return { isValid: L(e) && ("feature" !== e.type || !e.dynamicDataSource), errorMessage: "Feature layer should be a layer or table in a map or feature service" };
}
function U(e) {
  const r = [], a3 = [];
  for (const { layer: t2, layerJSON: o } of e)
    t2.isTable ? a3.push(o) : r.push(o);
  return { layers: r, tables: a3 };
}
function j2(e) {
  return U([e]);
}
async function J(e, r) {
  return /\/\d+\/?$/.test(e.url) ? j2(r[0]) : M(r, e);
}
async function M(e, r) {
  if (e.reverse(), !r)
    return U(e);
  const a3 = await R(r, e);
  for (const t2 of e)
    k2(t2.layer, t2.layerJSON, a3);
  return K(a3, e), a3;
}
async function R(e, r) {
  let a3 = await e.fetchData("json");
  if (D(a3))
    return a3;
  a3 || (a3 = {}), F(a3);
  const { layer: { url: t2, customParameters: o, apiKey: n } } = r[0];
  return await z(a3, { url: t2 ?? "", customParameters: o, apiKey: n }, r.map((e2) => e2.layer.layerId)), a3;
}
function D(e) {
  return !!(e && Array.isArray(e.layers) && Array.isArray(e.tables));
}
function F(e) {
  e.layers || (e.layers = []), e.tables || (e.tables = []);
}
function K(e, r) {
  const a3 = [], t2 = [];
  for (const { layer: o } of r) {
    const { isTable: e2, layerId: r2 } = o;
    e2 ? t2.push(r2) : a3.push(r2);
  }
  Y(e.layers, a3), Y(e.tables, t2);
}
function Y(r, a3) {
  if (r.length < 2)
    return;
  const t2 = [];
  for (const { id: e } of r)
    t2.push(e);
  h(t2.sort(_), a3.slice().sort(_)) && r.sort((e, r2) => {
    const t3 = a3.indexOf(e.id), o = a3.indexOf(r2.id);
    return t3 < o ? -1 : t3 > o ? 1 : 0;
  });
}
function _(e, r) {
  return e < r ? -1 : e > r ? 1 : 0;
}
async function z(e, r, a3) {
  const { url: t2, customParameters: o, apiKey: n } = r, { serviceJSON: s2, layersJSON: i4 } = await t(t2, { customParameters: o, apiKey: n }), l3 = G(e.layers, s2.layers, a3), c2 = G(e.tables, s2.tables, a3);
  e.layers = l3.itemResources, e.tables = c2.itemResources;
  const u2 = [...l3.added, ...c2.added], p2 = i4 ? [...i4.layers, ...i4.tables] : [];
  await B(e, u2, t2, p2);
}
function G(e, a3, t2) {
  const o = g(e, a3, (e2, r) => e2.id === r.id);
  e = e.filter((e2) => !o.removed.some((r) => r.id === e2.id));
  const n = o.added;
  return n.forEach(({ id: r }) => {
    e.push({ id: r });
  }), { itemResources: e, added: n.filter(({ id: e2 }) => !t2.includes(e2)) };
}
async function B(e, r, a3, t2) {
  const o = await V(r), n = r.map(({ id: e2, type: r2 }) => new (o.get(r2))({ url: a3, layerId: e2, sourceJSON: t2.find(({ id: r3 }) => r3 === e2) }));
  await Promise.allSettled(n.map((e2) => e2.load())), n.forEach((r2) => {
    const { layerId: a4, loaded: t3, defaultPopupTemplate: o2 } = r2;
    if (!t3 || null == o2)
      return;
    const n2 = { id: a4, popupInfo: o2.toJSON() };
    "ArcGISFeatureLayer" !== r2.operationalLayerType && (n2.layerType = r2.operationalLayerType), k2(r2, n2, e);
  });
}
async function V(e) {
  const r = [];
  e.forEach(({ type: e2 }) => {
    const a4 = i(e2), t3 = a2[a4];
    r.push(t3());
  });
  const a3 = await Promise.all(r), t2 = /* @__PURE__ */ new Map();
  return e.forEach(({ type: e2 }, r2) => {
    t2.set(e2, a3[r2]);
  }), t2;
}
function k2(e, r, a3) {
  e.isTable ? q(a3.tables, r) : q(a3.layers, r);
}
function q(e, r) {
  const a3 = e.findIndex(({ id: e2 }) => e2 === r.id);
  -1 === a3 ? e.push(r) : e[a3] = r;
}
function C(e, r) {
  if (!e.length)
    throw new s(`${r}:missing-parameters`, "'layers' array should contain at least one feature layer");
}
function H(e, r) {
  const a3 = e.map((e2) => e2.portalItem.id);
  if (new Set(a3).size > 1)
    throw new s(`${r}:invalid-parameters`, "All layers in the 'layers' array should be loaded from the same portal item");
}
function Q(e, r) {
  const a3 = e.map((e2) => e2.layerId);
  if (new Set(a3).size !== a3.length)
    throw new s(`${r}:invalid-parameters`, "'layers' array should contain only one instance each of layer or table in a feature service");
}
async function W(e) {
  C(e, N), await Promise.all(e.map((e2) => e2.load()));
  for (const r of e)
    l2(r, N, O), d({ layer: r, itemType: P2, errorNamePrefix: N });
  H(e, N), Q(e, N);
}
async function X(e, r) {
  const { url: a3, layerId: t2, title: o, fullExtent: n, isTable: s2 } = e, i4 = p(a3);
  r.url = "FeatureServer" === (i4 == null ? void 0 : i4.serverType) ? a3 : `${a3}/${t2}`, r.title || (r.title = o), r.extent = null, s2 || null == n || (r.extent = await l(n)), a(r, f.METADATA), a(r, f.MULTI_LAYER), i2(r, f.SINGLE_LAYER), s2 && i2(r, f.TABLE);
}
function Z(e, r) {
  for (const s2 of e) {
    const a4 = s2.parsedUrl.path, o2 = p(a4), n2 = o2 == null ? void 0 : o2.url.path;
    if (!n2)
      throw new s(`${r}:invalid-parameters`, c(s2, `has unsupported url pattern: ${a4}`), { layer: s2 });
    const i4 = o2 == null ? void 0 : o2.serverType;
    if ("FeatureServer" !== i4 && "MapServer" !== i4)
      throw new s(`${r}:invalid-parameters`, c(s2, `has unsupported server type: ${i4}`), { layer: s2 });
    if ("MapServer" === i4 && e.length > 1)
      throw new s(`${r}:invalid-parameters`, "Only one layer or table in a map service can be saved");
  }
  const a3 = p(e[0].parsedUrl.path), o = a3 == null ? void 0 : a3.url.path, n = e.every((e2) => {
    const r2 = p(e2.parsedUrl.path);
    return (r2 == null ? void 0 : r2.url.path) === o;
  });
  if (!n)
    throw new s(`${r}:invalid-parameters`, "'layers' array should only contain layers or tables that belong to the same feature service");
}
async function ee(e) {
  C(e, g2), await Promise.all(e.map((e2) => e2.load()));
  for (const r of e)
    l2(r, g2, O);
  Z(e, g2), Q(e, g2);
}
async function re(e, r) {
  let t2 = 0, o = 0;
  for (const { isTable: a3 } of r)
    a3 ? o++ : t2++;
  const n = r[0].parsedUrl.path, s2 = p(n);
  if (e.url = "FeatureServer" === (s2 == null ? void 0 : s2.serverType) ? s2.url.path : n, e.title || (e.title = s2.title), e.extent = null, t2 > 0) {
    const t3 = r.map((e2) => e2.fullExtent).filter(k).reduce((e2, r2) => e2.clone().union(r2));
    t3 && (e.extent = await l(t3));
  }
  a(e, f.METADATA), u(e, f.MULTI_LAYER, r.length > 1), u(e, f.SINGLE_LAYER, 1 === r.length), u(e, f.TABLE, o > 0 && 0 === t2), v(e);
}
async function ae(e, r) {
  return $({ layer: e, itemType: P2, validateLayer: O, createItemData: (e2, r2) => J(r2, [e2]), errorNamePrefix: $2 }, r);
}
async function te(e, r) {
  await W(e);
  const a3 = e[0].portalItem, t2 = w(a3), n = await Promise.all(e.map((e2) => I(e2, t2, r))), c2 = await J(a3, e.map((e2, r2) => ({ layer: e2, layerJSON: n[r2] })));
  return v(a3), await a3.update({ data: c2 }), await Promise.all(e.slice(1).map((e2) => e2.portalItem.reload())), i3(t2), a3.clone();
}
async function oe(e, r, a3) {
  return j({ layer: e, itemType: P2, validateLayer: O, createItemData: (e2, r2) => Promise.resolve(j2(e2)), errorNamePrefix: x, newItem: r, setItemProperties: X }, a3);
}
async function ne(e, r, a3) {
  await ee(e);
  const t2 = y({ itemType: P2, errorNamePrefix: g2, newItem: r }), n = w(t2), l3 = await Promise.all(e.map((e2) => I(e2, n, a3))), c2 = await M(e.map((e2, r2) => ({ layer: e2, layerJSON: l3[r2] })));
  await re(t2, e), await P(t2, c2, a3);
  for (const o of e)
    o.portalItem = t2.clone();
  return i3(n), t2;
}
export {
  ae as save,
  te as saveAll,
  ne as saveAllAs,
  oe as saveAs
};
//# sourceMappingURL=featureLayerUtils-UQBIKW27.js.map
