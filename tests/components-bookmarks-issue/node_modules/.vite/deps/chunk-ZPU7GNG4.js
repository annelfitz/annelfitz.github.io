import {
  i as i4
} from "./chunk-TNR6E67I.js";
import {
  t as t4
} from "./chunk-7O3VD45U.js";
import {
  a as a5,
  n as n3
} from "./chunk-QREUCRQ4.js";
import {
  M,
  e as e5,
  i as i3,
  s as s3
} from "./chunk-YK3UMVCY.js";
import {
  n as n4
} from "./chunk-GB4RVOXH.js";
import {
  C as C3
} from "./chunk-MTQHYT7Y.js";
import {
  t as t5
} from "./chunk-JCP47SOM.js";
import {
  e as e4,
  i as i2,
  r
} from "./chunk-CXCB57TE.js";
import {
  A as A2,
  B as B2,
  C as C2,
  K,
  O,
  P as P2,
  R,
  U as U2,
  X,
  Y,
  Z,
  a as a4,
  ie,
  k as k2,
  l as l3,
  m as m3,
  ne,
  o as o2,
  oe,
  u as u5,
  w as w2,
  y
} from "./chunk-IWO6JXL2.js";
import {
  U,
  g as g2,
  lt
} from "./chunk-AVR3LWTZ.js";
import {
  e as e2
} from "./chunk-M4RFJU4F.js";
import {
  S as S2,
  o
} from "./chunk-3AIILHI5.js";
import {
  u as u4
} from "./chunk-RO3CTAP7.js";
import {
  A,
  B,
  C,
  F,
  I,
  L,
  N,
  P,
  S,
  T,
  d,
  g,
  j,
  k,
  t as t3,
  w,
  x
} from "./chunk-GKMVTGGM.js";
import {
  m2,
  s as s2
} from "./chunk-A5Q7MMP6.js";
import {
  f as f6,
  l as l2,
  m,
  s,
  u as u2
} from "./chunk-J7AMTUNG.js";
import {
  e as e3,
  u as u3
} from "./chunk-BOAEEYBE.js";
import {
  a as a3,
  c,
  f as f3,
  f2 as f5,
  i,
  l,
  n as n2,
  t as t2
} from "./chunk-HV6S3GY2.js";
import {
  f as f2
} from "./chunk-IGR2BTWR.js";
import {
  a as a2,
  f as f4,
  u
} from "./chunk-C7NPPGFR.js";
import {
  G
} from "./chunk-IZKCZQUY.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  e2 as e
} from "./chunk-I2RC5KWA.js";
import {
  a,
  n2 as n
} from "./chunk-7RBRCL6S.js";
import {
  has,
  t
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/symbols/cim/effects/EffectAddControlPoints.js
var e6 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(e14, s12, n18, i15, o8) {
    return new t6(e14, s12, n18);
  }
};
e6.instance = null;
var t6 = class {
  constructor(e14, t15, s12) {
    this._inputGeometries = e14, this._angleTolerance = void 0 !== t15.angleTolerance ? t15.angleTolerance : 120, this._maxCosAngle = Math.cos((1 - Math.abs(this._angleTolerance) / 180) * Math.PI);
  }
  next() {
    let e14 = this._inputGeometries.next();
    for (; e14; ) {
      if ("esriGeometryPolygon" === e14.geometryType)
        this._isClosed = true;
      else if ("esriGeometryPolyline" === e14.geometryType)
        this._isClosed = false;
      else {
        if ("esriGeometryEnvelope" !== e14.geometryType) {
          e14 = this._inputGeometries.next();
          continue;
        }
        if (this._maxCosAngle)
          return e14;
        this._isClosed = true;
      }
      for (; e14.nextPath(); )
        this._processPath(e14);
      return e14.reset(), e14;
    }
    return null;
  }
  _processPath(e14) {
    if (e14.nextPoint()) {
      const t15 = e14.x, s12 = e14.y;
      let n18 = t15, i15 = s12, o8 = e14.pathSize, l12 = 0, r17 = 0, a12 = 0, h7 = 0, c5 = 0, _5 = 0;
      this._isClosed && ++o8;
      for (let u11 = 1; e14.nextPoint() || u11 < o8; ++u11) {
        let x4, m7;
        this._isClosed && u11 === o8 - 1 ? (x4 = t15, m7 = s12) : (x4 = e14.x, m7 = e14.y);
        const y5 = x4 - n18, g4 = m7 - i15, C5 = Math.sqrt(y5 * y5 + g4 * g4);
        if (u11 > 1 && C5 > 0 && a12 > 0) {
          (l12 * y5 + r17 * g4) / C5 / a12 <= this._maxCosAngle && e14.setControlPointAt(u11 - 1);
        }
        1 === u11 && (h7 = y5, c5 = g4, _5 = C5), C5 > 0 && (n18 = x4, i15 = m7, l12 = y5, r17 = g4, a12 = C5);
      }
      if (this._isClosed && a12 > 0 && _5 > 0) {
        (l12 * h7 + r17 * c5) / _5 / a12 <= this._maxCosAngle && e14.setControlPointAt(0);
      }
    }
  }
};

// node_modules/@arcgis/core/geometry/GeometryCursor.js
var a6 = class {
  static fromOptimized(t15, e14, s12 = false, i15 = false, h7 = 1) {
    return new p().initialize(t15, e14, s12, i15, h7);
  }
  static fromJSON(t15, e14 = false, s12 = false) {
    const [i15, h7] = u6(t15);
    return new d2().initialize(i15, h7, e14, s12, 1);
  }
  static fromOptimizedCIM(t15, e14, s12 = false, i15 = false, h7 = 1) {
    return new m4().initialize(t15, e14, s12, i15, h7);
  }
  static fromJSONCIM(t15, e14 = false, s12 = false, i15 = 1) {
    const [h7, r17] = u6(t15);
    return new y2().initialize(h7, r17, e14, s12, i15);
  }
  static fromFeatureSetReader(t15) {
    const e14 = t15.readGeometryForDisplay(), s12 = t15.geometryType;
    return e14 && s12 ? this.fromOptimized(e14, s12) : null;
  }
  static fromFeatureSetReaderCIM(t15) {
    const e14 = t15.readGeometryForDisplay(), s12 = t15.geometryType;
    return e14 && s12 ? this.fromOptimizedCIM(e14, s12) : null;
  }
  static createEmptyOptimized(t15, e14 = false, s12 = false, i15 = 1) {
    return new p().initialize(new e2(), t15, e14, s12, i15);
  }
  static createEmptyJSON(t15, e14 = false, s12 = false) {
    return new d2().initialize([], t15, e14, s12, 1);
  }
  static createEmptyOptimizedCIM(t15, e14 = false, s12 = false, i15 = 1) {
    return new m4().initialize(new e2(), t15, e14, s12, i15);
  }
  static createEmptyJSONCIM(t15, e14 = false, s12 = false, i15 = 1) {
    return new y2().initialize([], t15, e14, s12, i15);
  }
  asJSON() {
    const t15 = t2(this);
    return "esriGeometryEnvelope" === this.geometryType ? { xmin: t15[0][0][0], ymin: t15[0][0][1], xmax: t15[0][2][0], ymax: t15[0][2][1] } : "esriGeometryMultipoint" === this.geometryType ? { points: t15.flat() } : "esriGeometryPoint" === this.geometryType ? { x: t15[0][0][0], y: t15[0][0][1] } : "esriGeometryPolygon" === this.geometryType ? { rings: t15 } : { paths: t15 };
  }
  getCurrentRingArea() {
    if (this.pathSize < 3)
      return 0;
    let t15, e14, s12 = 0;
    if (this.seekPathStart(), !this.nextPoint())
      return 0;
    t15 = this.x, e14 = this.y;
    const i15 = t15, h7 = e14;
    for (; this.nextPoint(); )
      s12 += (t15 - this.x) * (e14 + this.y), t15 = this.x, e14 = this.y;
    return s12 += (t15 - i15) * (e14 + h7), -0.5 * s12;
  }
  invertY() {
    this.yFactor *= -1;
  }
};
var p = class _p extends a6 {
  constructor() {
    super(...arguments), this._end = -1;
  }
  initialize(t15, e14, s12, i15, h7) {
    return this.hasZ = s12, this.hasM = i15, this.geometryType = e14, this._stride = 2 + Number(s12) + Number(i15), this._geometry = t15, this._pathIndex = -1, this._pathOffset = 0, this._pointOffset = -this._stride, this._end = -1, this.yFactor = h7, this;
  }
  reset() {
    this.initialize(this._geometry, this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  seekPath(t15) {
    if (t15 >= 0 && t15 < this.totalSize) {
      if (this._pathIndex < t15)
        for (; this._pathIndex < t15 && this.nextPath(); )
          ;
      else if (this._pathIndex > t15)
        for (; this._pathIndex > t15 && this.prevPath(); )
          ;
      return true;
    }
    return false;
  }
  seekPathStart() {
    this._pointOffset = this._pathOffset - this._stride;
  }
  seekPathEnd() {
    this._pointOffset = this._end;
  }
  seekInPath(t15) {
    const e14 = this._pathOffset + t15 * this._stride;
    return e14 >= 0 && e14 < this._end && (this._pointOffset = e14, true);
  }
  nextPoint() {
    return (this._pointOffset += this._stride) < this._end;
  }
  prevPoint() {
    return (this._pointOffset -= this._stride) >= this._pathOffset;
  }
  nextPath() {
    return !(this.pathIndex >= this.totalSize - 1) && (this._pathIndex >= 0 && (this._pathOffset += this._stride * this.pathSize), this._pathIndex++, this._pointOffset = this._pathOffset - this._stride, this._end = this._pointOffset + this._stride + this._stride * this.pathSize, true);
  }
  prevPath() {
    return !(this.pathIndex <= 0) && (this._pathIndex--, this._end = this._pathOffset, this._pathOffset -= this._stride * this.pathSize, this._pointOffset = this._pathOffset - this._stride, true);
  }
  pathLength() {
    const t15 = this._end, e14 = this._stride, s12 = this._geometry.coords;
    let i15 = 0;
    for (let h7 = this._pathOffset + e14; h7 < t15; h7 += e14) {
      const t16 = s12[h7 - e14], r17 = s12[h7 - e14 + 1], n18 = s12[h7] - t16, o8 = s12[h7 + 1] - r17;
      i15 += Math.sqrt(n18 * n18 + o8 * o8);
    }
    return i15;
  }
  startPath() {
    this._geometry.lengths.push(0);
  }
  pushPath(t15) {
    this.startPath(), this.pushPoints(t15);
  }
  pushPoint(t15) {
    for (let e14 = 0; e14 < this._stride; ++e14)
      this._geometry.coords.push(t15[e14]);
    this._geometry.lengths[this.totalSize - 1]++;
  }
  pushXY(t15, e14) {
    this._geometry.coords.push(t15, e14), this._geometry.lengths[this.totalSize - 1]++;
  }
  pushPoints(t15) {
    for (const e14 of t15)
      for (let t16 = 0; t16 < this._stride; ++t16)
        this._geometry.coords.push(e14[t16]);
    this._geometry.lengths[this.totalSize - 1] += t15.length;
  }
  pushCursor(t15) {
    const e14 = t15.asOptimized();
    this._geometry.coords.push(...e14.coords), this._geometry.lengths.push(...e14.lengths);
  }
  asOptimized() {
    const t15 = this._geometry.clone();
    if (1 !== this.yFactor)
      for (let e14 = 1; e14 < t15.coords.length; e14 += this._stride)
        t15.coords[e14] *= this.yFactor;
    return "esriGeometryPoint" === this.geometryType && (t15.lengths.length = 0), t15;
  }
  isClosed() {
    const t15 = this._geometry.coords, e14 = this._pathOffset, s12 = this._end - this._stride;
    for (let i15 = 0; i15 < this._stride; i15++)
      if (t15[e14 + i15] !== t15[s12 + i15])
        return false;
    return true;
  }
  clone() {
    return new _p().initialize(this._geometry.clone(), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  get totalPoints() {
    return this._geometry.isPoint ? 1 : this._geometry.lengths.reduce((t15, e14) => t15 + e14);
  }
  get pathSize() {
    const { lengths: t15 } = this._geometry;
    return this._pathIndex < 0 || this._pathIndex > t15.length - 1 ? 0 : this._geometry.isPoint ? 1 : t15[this._pathIndex];
  }
  get totalSize() {
    return this._geometry.lengths.length;
  }
  get x() {
    return this._geometry.coords[this._pointOffset];
  }
  set x(t15) {
    this._geometry.coords[this._pointOffset] = t15;
  }
  get y() {
    return this.yFactor * this._geometry.coords[this._pointOffset + 1];
  }
  set y(t15) {
    this._geometry.coords[this._pointOffset + 1] = this.yFactor * t15;
  }
  get z() {
    return this._geometry.coords[this._pointOffset + 2];
  }
  set z(t15) {
    this._geometry.coords[this._pointOffset + 2] = t15;
  }
  get m() {
    const t15 = this.hasZ ? 3 : 2;
    return this._geometry.coords[this._pointOffset + t15];
  }
  set m(t15) {
    this._geometry.coords[this._pointOffset + 3] = t15;
  }
  get pathIndex() {
    return this._pathIndex;
  }
  get _coordIndex() {
    return this._pointOffset / this._stride;
  }
};
function _(t15) {
  const e14 = [t15.x, t15.y];
  return t15.z && e14.push(t15.z), t15.m && e14.push(t15.m), e14;
}
function u6(t15) {
  return f6(t15) ? [t15.rings, "esriGeometryPolygon"] : s(t15) ? [t15.paths, "esriGeometryPolyline"] : l2(t15) ? [[t15.points], "esriGeometryMultipoint"] : m(t15) ? [[[[t15.xmin, t15.ymin], [t15.xmin, t15.ymax], [t15.xmax, t15.ymax], [t15.xmax, t15.ymin], [t15.xmin, t15.ymin]]], "esriGeometryEnvelope"] : u2(t15) ? [[[_(t15)]], "esriGeometryPoint"] : [[], "esriGeometryPolyline"];
}
var d2 = class _d extends a6 {
  initialize(t15, e14, s12, i15, h7) {
    return this._paths = t15, this.geometryType = e14, this.hasZ = s12, this.hasM = i15, this._pathIndex = this._pointIndex = -1, this.yFactor = h7, this._mIndex = this.hasZ ? 3 : 2, this;
  }
  reset() {
    this._pathIndex = this._pointIndex = -1;
  }
  seekPath(t15) {
    return this._pathIndex = t15, this._pointIndex = -1, t15 >= 0 && t15 < this.totalSize && (this._currentPath = this._paths[t15], true);
  }
  seekPathStart() {
    this._pointIndex = -1;
  }
  seekPathEnd() {
    this._pointIndex = this._currentPath.length;
  }
  seekInPath(t15) {
    return t15 >= 0 && t15 < this._currentPath.length && (this._pointIndex = t15, this._currentPoint = this._currentPath[this._pointIndex], true);
  }
  nextPoint() {
    return this._currentPoint = this._currentPath[++this._pointIndex], this._pointIndex < this._currentPath.length;
  }
  prevPoint() {
    return this._currentPoint = this._currentPath[--this._pointIndex], this._pointIndex >= 0;
  }
  nextPath() {
    return this._pointIndex = -1, this._currentPath = this._paths[++this._pathIndex], this._pathIndex < this.totalSize;
  }
  prevPath() {
    return this.pathIndex > 0 && (this._pointIndex = -1, this._pathIndex--, this._currentPath = this._paths[this._pathIndex], true);
  }
  pathLength() {
    const t15 = this._currentPath.length, e14 = this._currentPath;
    let s12 = 0;
    for (let i15 = 1; i15 < t15; i15++) {
      const t16 = e14[i15 - 1], h7 = e14[i15], r17 = t16[0], n18 = t16[1], o8 = h7[0] - r17, a12 = h7[1] - n18;
      s12 += Math.sqrt(o8 * o8 + a12 * a12);
    }
    return s12;
  }
  startPath() {
    this._paths.push([]);
  }
  pushPath(t15) {
    this._paths.push(t15);
  }
  pushPoint(t15) {
    this._paths[this.totalSize - 1].push(t15);
  }
  pushXY(t15, e14) {
    this._paths[this.totalSize - 1].push([t15, e14]);
  }
  pushPoints(t15) {
    this._paths[this.totalSize - 1].push(...t15);
  }
  pushCursor(t15) {
    const s12 = t2(t15);
    for (const e14 of s12)
      this.pushPath(e14);
  }
  asOptimized() {
    const t15 = new e2();
    if ("esriGeometryPoint" === this.geometryType)
      t15.coords.push(...this._paths[0][0]), t15.lengths.length = 0;
    else
      for (const e14 of this._paths) {
        for (const s12 of e14)
          t15.coords.push(s12[0]), t15.coords.push(s12[1] * this.yFactor), this.hasZ && t15.coords.push(s12[2]), this.hasM && t15.coords.push(s12[this._mIndex]);
        t15.lengths.push(e14.length);
      }
    return t15;
  }
  isClosed() {
    const t15 = this._currentPath[0], e14 = this._currentPath[this._currentPath.length - 1];
    for (let s12 = 0; s12 < t15.length; s12++)
      if (t15[s12] !== e14[s12])
        return false;
    return true;
  }
  clone() {
    return new _d().initialize(a(this._paths), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  get totalPoints() {
    return this._paths.map((t15) => t15.length).reduce((t15, e14) => t15 + e14);
  }
  get pathSize() {
    return this._pathIndex < 0 || this._pathIndex > this.totalSize - 1 ? -1 : this._paths[this._pathIndex].length;
  }
  get totalSize() {
    return this._paths.length;
  }
  get x() {
    return this._currentPoint[0];
  }
  set x(t15) {
    this._currentPoint[0] = t15;
  }
  get y() {
    return this.yFactor * this._currentPoint[1];
  }
  set y(t15) {
    this._currentPoint[1] = this.yFactor * t15;
  }
  get z() {
    return this._currentPoint[2];
  }
  set z(t15) {
    this._currentPoint[2] = t15;
  }
  get m() {
    return this._currentPoint[this._mIndex];
  }
  set m(t15) {
    this._currentPoint[this._mIndex] = t15;
  }
  get pathIndex() {
    return this._pathIndex;
  }
};
var c2 = 4;
var l4 = 1;
var m4 = class _m extends p {
  initialize(t15, e14, s12, i15, h7) {
    return super.initialize(t15, e14, s12, i15, h7), this._controlPoints || (this._controlPoints = this._controlPoints = new Array(this.totalSize).fill(void 0).map((t16) => /* @__PURE__ */ new Set())), this;
  }
  startPath() {
    super.startPath(), this._controlPoints.push(/* @__PURE__ */ new Set());
  }
  clone() {
    const t15 = new _m().initialize(this._geometry.clone(), this.geometryType, this.hasZ, this.hasM, this.yFactor);
    return t15._controlPoints = this._controlPoints, t15;
  }
  setControlPoint() {
    this._controlPoints[this.pathIndex].add(this._coordIndex);
  }
  getControlPoint() {
    return this._controlPoints[this.pathIndex].has(this._coordIndex);
  }
  setControlPointAt(t15) {
    this._controlPoints[this.pathIndex].add(t15);
  }
  getControlPointAt(t15) {
    return this._controlPoints[this.pathIndex].has(t15);
  }
};
var y2 = class _y extends d2 {
  initialize(t15, e14, s12, i15, h7) {
    return super.initialize(t15, e14, s12, i15, h7);
  }
  clone() {
    return new _y().initialize(a(this._paths), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  setControlPoint() {
    this._paths[this.pathIndex][this._pointIndex][c2] = l4;
  }
  getControlPoint() {
    return this._paths[this.pathIndex][this._pointIndex][c2] === l4;
  }
  setControlPointAt(t15) {
    this._paths[this.pathIndex][t15][c2] = l4;
  }
  getControlPointAt(t15) {
    return this._paths[this.pathIndex][t15][c2] === l4;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMPlacements.js
var t7 = class {
  constructor() {
    this.setIdentity();
  }
  getAngle() {
    return (null == this.rz || 0 === this.rz && 1 !== this.rzCos && 0 !== this.rzSin) && (this.rz = Math.atan2(this.rzSin, this.rzCos)), this.rz;
  }
  setIdentity() {
    this.tx = 0, this.ty = 0, this.tz = 0, this.s = 1, this.rx = 0, this.ry = 0, this.rz = 0, this.rzCos = 1, this.rzSin = 0;
  }
  setTranslate(t15, s12) {
    this.tx = t15, this.ty = s12;
  }
  setTranslateZ(t15) {
    this.tz = t15;
  }
  setRotateCS(t15, s12) {
    this.rz = void 0, this.rzCos = t15, this.rzSin = s12;
  }
  setRotate(t15) {
    this.rz = t15, this.rzCos = void 0, this.rzSin = void 0;
  }
  setRotateY(t15) {
    this.ry = t15;
  }
  setScale(t15) {
    this.s = t15;
  }
  setMeasure(t15) {
    this.m = t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMCursor.js
function r2(t15, e14) {
  t15[4] = e14;
}
var s4 = class {
  constructor(e14, r17 = true, s12 = true, i15 = 0) {
    this.isClosed = false, this.geometryCursor = null, this.geometryCursor = !r17 && "esriGeometryPolygon" === e14.geometryType || !s12 && "esriGeometryPolyline" === e14.geometryType ? null : e14, this.geomUnitsPerPoint = i15, this.iteratePath = false, this.internalPlacement = new t7();
  }
  next() {
    if (!this.geometryCursor)
      return null;
    for (; this.iteratePath || this.geometryCursor.pathIndex < this.geometryCursor.totalSize - 1; ) {
      this.iteratePath || this.geometryCursor.nextPath();
      const t15 = this.processPath(this.geometryCursor);
      if (t15)
        return t15;
    }
    return this.geometryCursor = null, null;
  }
};
var i5 = class {
  constructor(t15, e14, r17, s12 = 0) {
    this.isClosed = false, this.inputGeometries = t15, this.acceptPolygon = e14, this.acceptPolyline = r17, this.geomUnitsPerPoint = s12, this.iteratePath = false, this.multiPathCursor = null;
  }
  next() {
    for (; ; ) {
      if (!this.multiPathCursor) {
        let t15 = this.inputGeometries.next();
        for (; t15 && (this.isClosed = this.acceptPolygon && "esriGeometryPolygon" === t15.geometryType || "esriGeometryEnvelope" === t15.geometryType, this.multiPathCursor = t15, !this.multiPathCursor); )
          t15 = this.inputGeometries.next();
        if (!this.multiPathCursor)
          return null;
      }
      for (; this.iteratePath || this.multiPathCursor.nextPath(); ) {
        this.multiPathCursor.seekPathStart();
        const t15 = this.processPath(this.multiPathCursor);
        if (t15)
          return t15;
      }
      this.multiPathCursor = null;
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/CurveHelper.js
var n5 = 0.03;
var s5 = class {
  constructor(t15 = 0, e14 = false) {
  }
  isEmpty(t15) {
    if (!t15.nextPoint())
      return true;
    let e14, n18, s12, r17;
    for (e14 = t15.x, n18 = t15.y; t15.nextPoint(); e14 = n18, n18 = r17)
      if (s12 = t15.x, r17 = t15.y, s12 !== e14 || r17 !== n18)
        return t15.seekPathStart(), false;
    return t15.seekPathStart(), true;
  }
  normalize(t15) {
    const e14 = Math.sqrt(t15[0] * t15[0] + t15[1] * t15[1]);
    0 !== e14 && (t15[0] /= e14, t15[1] /= e14);
  }
  getLength(t15, e14, n18, s12) {
    const r17 = n18 - t15, o8 = s12 - e14;
    return Math.sqrt(r17 * r17 + o8 * o8);
  }
  getSegLength(t15) {
    const [[e14, n18], [s12, r17]] = t15;
    return this.getLength(e14, n18, s12, r17);
  }
  getCoord2D(t15, e14, n18, s12, r17) {
    return [t15 + (n18 - t15) * r17, e14 + (s12 - e14) * r17];
  }
  getSegCoord2D(t15, e14) {
    const [[n18, s12], [r17, o8]] = t15;
    return this.getCoord2D(n18, s12, r17, o8, e14);
  }
  getAngle(t15, e14, n18, s12, r17) {
    const o8 = n18 - t15, i15 = s12 - e14;
    return Math.atan2(i15, o8);
  }
  getAngleCS(t15, e14, n18, s12, r17) {
    const o8 = n18 - t15, i15 = s12 - e14, u11 = Math.sqrt(o8 * o8 + i15 * i15);
    return u11 > 0 ? [o8 / u11, i15 / u11] : [1, 0];
  }
  getSegAngleCS(t15, e14) {
    const [[n18, s12], [r17, o8]] = t15;
    return this.getAngleCS(n18, s12, r17, o8, e14);
  }
  cut(t15, e14, n18, s12, r17, o8) {
    return [r17 <= 0 ? [t15, e14] : this.getCoord2D(t15, e14, n18, s12, r17), o8 >= 1 ? [n18, s12] : this.getCoord2D(t15, e14, n18, s12, o8)];
  }
  getSubCurve(e14, n18, s12) {
    const r17 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    return this.appendSubCurve(r17, e14, n18, s12) ? r17 : null;
  }
  appendSubCurve(t15, e14, n18, s12) {
    t15.startPath(), e14.seekPathStart();
    let r17 = 0, o8 = true;
    if (!e14.nextPoint())
      return false;
    let i15 = e14.x, u11 = e14.y;
    for (; e14.nextPoint(); ) {
      const h7 = this.getLength(i15, u11, e14.x, e14.y);
      if (0 !== h7) {
        if (o8) {
          if (r17 + h7 > n18) {
            const l12 = (n18 - r17) / h7;
            let a12 = 1, c5 = false;
            r17 + h7 >= s12 && (a12 = (s12 - r17) / h7, c5 = true);
            const f9 = this.cut(i15, u11, e14.x, e14.y, l12, a12);
            if (f9 && t15.pushPoints(f9), c5)
              break;
            o8 = false;
          }
        } else {
          if (r17 + h7 > s12) {
            const n19 = this.cut(i15, u11, e14.x, e14.y, 0, (s12 - r17) / h7);
            n19 && t15.pushPoint(n19[1]);
            break;
          }
          t15.pushXY(e14.x, e14.y);
        }
        r17 += h7, i15 = e14.x, u11 = e14.y;
      } else
        i15 = e14.x, u11 = e14.y;
    }
    return true;
  }
  getCIMPointAlong(t15, e14) {
    if (!t15.nextPoint())
      return null;
    let n18, s12, r17, o8, i15 = 0;
    for (n18 = t15.x, s12 = t15.y; t15.nextPoint(); n18 = r17, s12 = o8) {
      r17 = t15.x, o8 = t15.y;
      const u11 = this.getLength(n18, s12, r17, o8);
      if (0 !== u11) {
        if (i15 + u11 > e14) {
          const t16 = (e14 - i15) / u11;
          return this.getCoord2D(n18, s12, r17, o8, t16);
        }
        i15 += u11;
      }
    }
    return null;
  }
  offset(t15, n18, s12, r17, o8) {
    if (!t15 || t15.length < 2)
      return null;
    let i15 = 0, u11 = t15[i15++], h7 = i15;
    for (; i15 < t15.length; ) {
      const e14 = t15[i15];
      e14[0] === u11[0] && e14[1] === u11[1] || (i15 !== h7 && (t15[h7] = t15[i15]), u11 = t15[h7++]), i15++;
    }
    const l12 = t15[0][0] === t15[h7 - 1][0] && t15[0][1] === t15[h7 - 1][1];
    if (l12 && --h7, h7 < (l12 ? 3 : 2))
      return null;
    const a12 = [];
    u11 = l12 ? t15[h7 - 1] : null;
    let c5 = t15[0];
    for (let f9 = 0; f9 < h7; f9++) {
      const o9 = f9 === h7 - 1 ? l12 ? t15[0] : null : t15[f9 + 1];
      if (u11)
        if (o9) {
          const t16 = [o9[0] - c5[0], o9[1] - c5[1]];
          this.normalize(t16);
          const i16 = [c5[0] - u11[0], c5[1] - u11[1]];
          this.normalize(i16);
          const h8 = i16[0] * t16[1] - i16[1] * t16[0], l13 = i16[0] * t16[0] + i16[1] * t16[1];
          if (0 === h8 && 1 === l13) {
            c5 = o9;
            continue;
          }
          if (h8 >= 0 == n18 <= 0) {
            if (l13 < 1) {
              const e14 = [t16[0] - i16[0], t16[1] - i16[1]];
              this.normalize(e14);
              const s13 = Math.sqrt((1 + l13) / 2);
              if (s13 > 1 / r17) {
                const t17 = -Math.abs(n18) / s13;
                a12.push([c5[0] - e14[0] * t17, c5[1] - e14[1] * t17]);
              }
            }
          } else
            switch (s12) {
              case O.Mitered: {
                const e14 = Math.sqrt((1 + l13) / 2);
                if (e14 > 0 && 1 / e14 < r17) {
                  const s13 = [t16[0] - i16[0], t16[1] - i16[1]];
                  this.normalize(s13);
                  const r18 = Math.abs(n18) / e14;
                  a12.push([c5[0] - s13[0] * r18, c5[1] - s13[1] * r18]);
                  break;
                }
              }
              case O.Bevelled:
                a12.push([c5[0] + i16[1] * n18, c5[1] - i16[0] * n18]), a12.push([c5[0] + t16[1] * n18, c5[1] - t16[0] * n18]);
                break;
              case O.Rounded:
                if (l13 < 1) {
                  a12.push([c5[0] + i16[1] * n18, c5[1] - i16[0] * n18]);
                  const e14 = Math.floor(2.5 * (1 - l13));
                  if (e14 > 0) {
                    const s13 = 1 / e14;
                    let r18 = s13;
                    for (let o10 = 1; o10 < e14; o10++, r18 += s13) {
                      const e15 = [i16[1] * (1 - r18) + t16[1] * r18, -i16[0] * (1 - r18) - t16[0] * r18];
                      this.normalize(e15), a12.push([c5[0] + e15[0] * n18, c5[1] + e15[1] * n18]);
                    }
                  }
                  a12.push([c5[0] + t16[1] * n18, c5[1] - t16[0] * n18]);
                }
                break;
              case O.Square:
              default:
                if (h8 < 0)
                  a12.push([c5[0] + (i16[1] + i16[0]) * n18, c5[1] + (i16[1] - i16[0]) * n18]), a12.push([c5[0] + (t16[1] - t16[0]) * n18, c5[1] - (t16[0] + t16[1]) * n18]);
                else {
                  const e14 = Math.sqrt((1 + Math.abs(l13)) / 2), s13 = [t16[0] - i16[0], t16[1] - i16[1]];
                  this.normalize(s13);
                  const r18 = n18 / e14;
                  a12.push([c5[0] - s13[0] * r18, c5[1] - s13[1] * r18]);
                }
            }
        } else {
          const t16 = [c5[0] - u11[0], c5[1] - u11[1]];
          this.normalize(t16), a12.push([c5[0] + t16[1] * n18, c5[1] - t16[0] * n18]);
        }
      else {
        const t16 = [o9[0] - c5[0], o9[1] - c5[1]];
        this.normalize(t16), a12.push([c5[0] + t16[1] * n18, c5[1] - t16[0] * n18]);
      }
      u11 = c5, c5 = o9;
    }
    return a12.length < (l12 ? 3 : 2) ? null : (l12 && a12.push([a12[0][0], a12[0][1]]), a12);
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectArrow.js
var c3 = 1.7320508075688772;
var u7 = 5;
var h = P2.OpenEnded;
var p2 = class _p {
  static local() {
    return null === _p.instance && (_p.instance = new _p()), _p.instance;
  }
  execute(t15, e14, r17, n18, o8) {
    return new P3(t15, e14, r17);
  }
};
p2.instance = null;
var P3 = class extends i5 {
  constructor(t15, e14, r17) {
    super(t15, false, true), this._curveHelper = new s5(), this._width = (void 0 !== e14.width ? e14.width : u7) * r17, this._arrowType = void 0 !== e14.geometricEffectArrowType ? e14.geometricEffectArrowType : void 0 !== e14.arrowType ? e14.arrowType : h, this._offsetFlattenError = n5 * r17;
  }
  processPath(e14) {
    const r17 = a6.createEmptyOptimizedCIM(e14.geometryType);
    switch (this._arrowType) {
      case P2.OpenEnded:
      default:
        this._constructSimpleArrow(r17, e14, true);
        break;
      case P2.Block:
        this._constructSimpleArrow(r17, e14, false);
        break;
      case P2.Crossed:
        this._constructCrossedArrow(r17, e14);
    }
    return r17;
  }
  _constructSimpleArrow(t15, r17, n18) {
    const o8 = r17.pathLength();
    let s12 = this._width;
    o8 < 2 * s12 && (s12 = o8 / 2);
    const i15 = this._curveHelper.getSubCurve(r17, 0, o8 - s12);
    if (!i15 || !i15.nextPath())
      return;
    i15.seekPathStart();
    const c5 = s12 / 2;
    if (this._curveHelper.isEmpty(i15))
      return;
    const u11 = n2(i15), h7 = this._constructOffset(u11, -c5);
    if (!h7)
      return;
    const p5 = this._constructOffset(u11, c5);
    if (!p5)
      return;
    const P5 = this._constructArrowBasePoint(h7, -c5 / 2);
    if (!P5)
      return;
    const l12 = this._constructArrowBasePoint(p5, c5 / 2);
    if (!l12)
      return;
    r17.seekInPath(r17.pathSize - 1);
    const f9 = [r17.x, r17.y];
    t15.pushPath(p5), t15.nextPath(), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(l12), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(f9), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(P5), t15.nextPoint(), t15.setControlPoint(), t15.pushPoints(h7.reverse()), t15.setControlPoint(), n18 || (t15.setControlPointAt(0), t15.setControlPointAt(t15.pathSize - 1), t15.pushPoint(p5[0])), t15.reset();
  }
  _constructCrossedArrow(t15, r17) {
    const n18 = r17.pathLength();
    let o8 = this._width;
    n18 < o8 * (1 + c3 + 1) && (o8 = n18 / (1 + c3 + 1)), r17.seekPathStart();
    const s12 = this._curveHelper.getSubCurve(r17, 0, n18 - o8 * (1 + c3));
    if (!s12)
      return;
    s12.nextPath();
    const i15 = o8 / 2;
    if (this._curveHelper.isEmpty(s12))
      return;
    const u11 = n2(s12), h7 = this._constructOffset(u11, i15);
    if (!h7)
      return;
    const p5 = this._constructOffset(u11, -i15);
    if (!p5)
      return;
    const P5 = this._curveHelper.getSubCurve(r17, 0, n18 - o8);
    if (!P5)
      return;
    if (P5.nextPath(), this._curveHelper.isEmpty(P5))
      return;
    const l12 = n2(P5), f9 = this._constructOffset(l12, i15);
    if (!f9)
      return;
    const a12 = this._constructOffset(l12, -i15);
    if (!a12)
      return;
    const _5 = f9[f9.length - 1], m7 = this._constructArrowBasePoint(f9, i15 / 2);
    if (!m7)
      return;
    const C5 = a12[a12.length - 1], w5 = this._constructArrowBasePoint(a12, -i15 / 2);
    if (!w5)
      return;
    r17.seekInPath(r17.pathSize - 1);
    const x4 = [r17.x, r17.y];
    t15.pushPath(h7), t15.nextPath(), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(C5), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(w5), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(x4), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(m7), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(_5), t15.nextPoint(), t15.setControlPoint(), t15.pushPoints(p5.reverse()), t15.nextPoint(), t15.setControlPoint(), t15.reset();
  }
  _constructOffset(t15, e14) {
    return this._curveHelper.offset(t15, e14, O.Rounded, 4, this._offsetFlattenError);
  }
  _constructArrowBasePoint(t15, e14) {
    if (!t15 || t15.length < 2)
      return null;
    const r17 = t15[t15.length - 2], n18 = t15[t15.length - 1], o8 = [n18[0] - r17[0], n18[1] - r17[1]];
    return this._curveHelper.normalize(o8), [n18[0] + o8[1] * e14, n18[1] - o8[0] * e14];
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMEffects.js
var r3 = 512;
var n6;
var s6 = class {
  constructor(t15) {
    this._geometry = t15;
  }
  next() {
    const t15 = this._geometry;
    return this._geometry = null, t15;
  }
};
function i6(s12, i15) {
  n6 || (n6 = new e4(0, 0, 0, 1));
  const y5 = "esriGeometryPolygon" === s12.geometryType, m7 = y5 ? i2.Polygon : i2.LineString, l12 = y5 ? 3 : 2;
  let c5, p5;
  for (n6.reset(m7), n6.setPixelMargin(i15 + 1), n6.setExtent(r3); s12.nextPath(); )
    if (!(s12.pathSize < l12)) {
      for (s12.nextPoint(), c5 = s12.x, p5 = -s12.y, n6.moveTo(c5, p5); s12.nextPoint(); )
        c5 = s12.x, p5 = -s12.y, n6.lineTo(c5, p5);
      y5 && n6.close();
    }
  const f9 = n6.result(false);
  if (f9) {
    const e14 = a6.createEmptyOptimizedCIM(s12.geometryType);
    for (const t15 of f9) {
      e14.startPath();
      for (const o8 of t15)
        e14.pushXY(o8.x, -o8.y);
    }
    return e14.reset(), e14;
  }
  return null;
}

// node_modules/@arcgis/core/symbols/cim/effects/EffectBuffer.js
var m5 = class _m {
  static local() {
    return null === _m.instance && (_m.instance = new _m()), _m.instance;
  }
  execute(e14, t15, i15, s12, r17, n18) {
    return new l5(e14, t15, i15, s12, r17, n18);
  }
};
m5.instance = null;
var l5 = class {
  constructor(e14, t15, i15, n18, o8, m7) {
    this._inputGeometries = e14, this._tileKey = n18, this._geometryEngine = o8, this._curveHelper = new s5(), this._size = (void 0 !== t15.size ? t15.size : 1) * i15, this._maxInflateSize = m7 * i15, this._offsetFlattenError = n5 * i15;
  }
  next() {
    let s12;
    for (; s12 = this._inputGeometries.next(); ) {
      if (0 === this._size)
        return s12;
      if ("esriGeometryEnvelope" === s12.geometryType) {
        if (this._size > 0) {
          const i15 = a6.createEmptyOptimizedCIM(s12.geometryType), r18 = t2(s12)[0], o8 = this._curveHelper.offset(r18, this._size, O.Rounded, 4, this._offsetFlattenError);
          if (o8)
            return i15.pushPath(o8), i15;
        } else if (this._size < 0) {
          const t15 = s12.asJSON();
          if (Math.min(t15.xmax - t15.xmin, t15.ymax - t15.ymin) + 2 * this._size > 0)
            return a6.fromJSONCIM({ xmin: t15.xmin - this._size, xmax: t15.xmax + this._size, ymin: t15.ymin - this._size, ymax: t15.ymax + this._size });
        }
      }
      const r17 = this._geometryEngine;
      if (null == r17)
        return null;
      const m7 = this._tileKey ? i6(s12, this._maxInflateSize) : s12;
      if (!m7)
        continue;
      const l12 = r17.buffer(f.WebMercator, m7.asJSON(), this._size, 1);
      return l12 ? a6.fromJSONCIM(l12) : null;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectControlMeasureLine.js
var e7 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(s12, t15, i15, h7, e14) {
    return new r4(s12, t15, i15);
  }
};
e7.instance = null;
var r4 = class {
  constructor(s12, t15, i15) {
    this._defaultPointSize = 20, this._inputGeometries = s12, this._geomUnitsPerPoint = i15, this._rule = t15.rule ?? R.FullGeometry, this._defaultSize = this._defaultPointSize * i15;
  }
  next() {
    let i15;
    for (; i15 = this._inputGeometries.next(); ) {
      const h7 = this._processGeom(t2(i15));
      if (h7 && h7.length)
        return a6.fromJSONCIM({ paths: h7 });
    }
    return null;
  }
  _clone(s12) {
    return [s12[0], s12[1]];
  }
  _mid(s12, t15) {
    return [(s12[0] + t15[0]) / 2, (s12[1] + t15[1]) / 2];
  }
  _mix(s12, t15, i15, h7) {
    return [s12[0] * t15 + i15[0] * h7, s12[1] * t15 + i15[1] * h7];
  }
  _add(s12, t15) {
    return [s12[0] + t15[0], s12[1] + t15[1]];
  }
  _add2(s12, t15, i15) {
    return [s12[0] + t15, s12[1] + i15];
  }
  _sub(s12, t15) {
    return [s12[0] - t15[0], s12[1] - t15[1]];
  }
  _dist(s12, t15) {
    return Math.sqrt((s12[0] - t15[0]) * (s12[0] - t15[0]) + (s12[1] - t15[1]) * (s12[1] - t15[1]));
  }
  _norm(s12) {
    return Math.sqrt(s12[0] * s12[0] + s12[1] * s12[1]);
  }
  _normalize(s12, t15 = 1) {
    const i15 = t15 / this._norm(s12);
    s12[0] *= i15, s12[1] *= i15;
  }
  _leftPerpendicular(s12) {
    const t15 = -s12[1], i15 = s12[0];
    s12[0] = t15, s12[1] = i15;
  }
  _leftPerp(s12) {
    return [-s12[1], s12[0]];
  }
  _rightPerpendicular(s12) {
    const t15 = s12[1], i15 = -s12[0];
    s12[0] = t15, s12[1] = i15;
  }
  _rightPerp(s12) {
    return [s12[1], -s12[0]];
  }
  _dotProduct(s12, t15) {
    return s12[0] * t15[0] + s12[1] * t15[1];
  }
  _crossProduct(s12, t15) {
    return s12[0] * t15[1] - s12[1] * t15[0];
  }
  _rotateDirect(s12, t15, i15) {
    const h7 = s12[0] * t15 - s12[1] * i15, e14 = s12[0] * i15 + s12[1] * t15;
    s12[0] = h7, s12[1] = e14;
  }
  _makeCtrlPt(s12) {
    const t15 = [s12[0], s12[1]];
    return r2(t15, 1), t15;
  }
  _addAngledTicks(s12, t15, i15, h7) {
    const e14 = this._sub(i15, t15);
    this._normalize(e14);
    const r17 = this._crossProduct(e14, this._sub(h7, t15));
    let _5;
    _5 = r17 > 0 ? this._rightPerp(e14) : this._leftPerp(e14);
    const c5 = Math.abs(r17) / 2, u11 = [];
    u11.push([t15[0] + (_5[0] - e14[0]) * c5, t15[1] + (_5[1] - e14[1]) * c5]), u11.push(t15), u11.push(i15), u11.push([i15[0] + (_5[0] + e14[0]) * c5, i15[1] + (_5[1] + e14[1]) * c5]), s12.push(u11);
  }
  _addBezier2(s12, t15, i15, h7, e14) {
    if (0 == e14--)
      return void s12.push(h7);
    const r17 = this._mid(t15, i15), _5 = this._mid(i15, h7), c5 = this._mid(r17, _5);
    this._addBezier2(s12, t15, r17, c5, e14), this._addBezier2(s12, c5, _5, h7, e14);
  }
  _addBezier3(s12, t15, i15, h7, e14, r17) {
    if (0 == r17--)
      return void s12.push(e14);
    const _5 = this._mid(t15, i15), c5 = this._mid(i15, h7), u11 = this._mid(h7, e14), o8 = this._mid(_5, c5), n18 = this._mid(c5, u11), a12 = this._mid(o8, n18);
    this._addBezier3(s12, t15, _5, o8, a12, r17), this._addBezier3(s12, a12, n18, u11, e14, r17);
  }
  _add90DegArc(s12, t15, i15, h7, e14) {
    const r17 = e14 ?? this._crossProduct(this._sub(i15, t15), this._sub(h7, t15)) > 0, _5 = this._mid(t15, i15), c5 = this._sub(_5, t15);
    r17 ? this._leftPerpendicular(c5) : this._rightPerpendicular(c5), _5[0] += c5[0], _5[1] += c5[1], this._addBezier3(s12, t15, this._mix(t15, 0.33333, _5, 0.66667), this._mix(i15, 0.33333, _5, 0.66667), i15, 4);
  }
  _addArrow(s12, t15, i15) {
    const h7 = t15[0], e14 = t15[1], r17 = t15[t15.length - 1], _5 = this._sub(h7, e14);
    this._normalize(_5);
    const c5 = this._crossProduct(_5, this._sub(r17, e14)), u11 = 0.5 * c5, o8 = this._leftPerp(_5), n18 = [r17[0] - o8[0] * c5, r17[1] - o8[1] * c5], a12 = t15.length - 1, p5 = [];
    p5.push(i15 ? [-o8[0], -o8[1]] : o8);
    let l12 = [-_5[0], -_5[1]];
    for (let d4 = 1; d4 < a12 - 1; d4++) {
      const s13 = this._sub(t15[d4 + 1], t15[d4]);
      this._normalize(s13);
      const i16 = this._dotProduct(s13, l12), h8 = this._crossProduct(s13, l12), e15 = Math.sqrt((1 + i16) / 2), r18 = this._sub(s13, l12);
      this._normalize(r18), r18[0] /= e15, r18[1] /= e15, p5.push(h8 < 0 ? [-r18[0], -r18[1]] : r18), l12 = s13;
    }
    p5.push(this._rightPerp(l12));
    for (let d4 = p5.length - 1; d4 > 0; d4--)
      s12.push([t15[d4][0] + p5[d4][0] * u11, t15[d4][1] + p5[d4][1] * u11]);
    s12.push([n18[0] + p5[0][0] * u11, n18[1] + p5[0][1] * u11]), s12.push([n18[0] + p5[0][0] * c5, n18[1] + p5[0][1] * c5]), s12.push(h7), s12.push([n18[0] - p5[0][0] * c5, n18[1] - p5[0][1] * c5]), s12.push([n18[0] - p5[0][0] * u11, n18[1] - p5[0][1] * u11]);
    for (let d4 = 1; d4 < p5.length; d4++)
      s12.push([t15[d4][0] - p5[d4][0] * u11, t15[d4][1] - p5[d4][1] * u11]);
  }
  _cp2(s12, t15, i15) {
    return s12.length >= 2 ? s12[1] : this._add2(s12[0], t15 * this._defaultSize, i15 * this._defaultSize);
  }
  _cp3(s12, t15, i15, h7) {
    if (s12.length >= 3)
      return s12[2];
    const e14 = this._mix(s12[0], 1 - i15, t15, i15), r17 = this._sub(t15, s12[0]);
    return this._normalize(r17), this._rightPerpendicular(r17), [e14[0] + r17[0] * h7 * this._defaultSize, e14[1] + r17[1] * h7 * this._defaultSize];
  }
  _arrowPath(s12) {
    if (s12.length > 2)
      return s12;
    const t15 = s12[0], i15 = this._cp2(s12, -4, 0), h7 = this._sub(t15, i15);
    this._normalize(h7);
    const e14 = this._rightPerp(h7);
    return [t15, i15, [t15[0] + (e14[0] - h7[0]) * this._defaultSize, t15[1] + (e14[1] - h7[1]) * this._defaultSize]];
  }
  _arrowLastSeg(s12) {
    const t15 = s12[0], i15 = this._cp2(s12, -4, 0);
    let h7;
    if (s12.length >= 3)
      h7 = s12[s12.length - 1];
    else {
      const s13 = this._sub(t15, i15);
      this._normalize(s13);
      const e14 = this._rightPerp(s13);
      h7 = [t15[0] + (e14[0] - s13[0]) * this._defaultSize, t15[1] + (e14[1] - s13[1]) * this._defaultSize];
    }
    return [i15, h7];
  }
  _processGeom(s12) {
    if (!s12)
      return null;
    const t15 = [];
    for (const e14 of s12) {
      if (!e14 || 0 === e14.length)
        continue;
      const s13 = e14.length;
      let r17 = e14[0];
      switch (this._rule) {
        case R.PerpendicularFromFirstSegment: {
          const s14 = this._cp2(e14, 0, -1), i15 = this._cp3(e14, s14, 0.5, 4), h7 = [];
          h7.push(i15), h7.push(this._mid(r17, s14)), t15.push(h7);
          break;
        }
        case R.ReversedFirstSegment: {
          const s14 = this._cp2(e14, 0, -1);
          t15.push([s14, r17]);
          break;
        }
        case R.PerpendicularToSecondSegment: {
          const s14 = this._cp2(e14, -4, 1), i15 = this._cp3(e14, s14, 0.882353, -1.94), h7 = [];
          h7.push(this._mid(s14, i15)), h7.push(r17), t15.push(h7);
          break;
        }
        case R.SecondSegmentWithTicks: {
          const s14 = this._cp2(e14, -4, 1), i15 = this._cp3(e14, s14, 0.882353, -1.94), h7 = this._sub(i15, s14);
          let _5;
          _5 = this._crossProduct(h7, this._sub(r17, s14)) > 0 ? this._rightPerp(_5) : this._leftPerp(h7);
          const c5 = [];
          c5.push([s14[0] + (_5[0] - h7[0]) / 3, s14[1] + (_5[1] - h7[1]) / 3]), c5.push(s14), c5.push(i15), c5.push([i15[0] + (_5[0] + h7[0]) / 3, i15[1] + (_5[1] + h7[1]) / 3]), t15.push(c5);
          break;
        }
        case R.DoublePerpendicular: {
          const s14 = this._cp2(e14, 0, -1), i15 = this._cp3(e14, s14, 0.5, 3), h7 = this._mid(r17, s14), _5 = this._sub(h7, i15);
          this._normalize(_5);
          const c5 = this._crossProduct(_5, this._sub(r17, i15));
          this._leftPerpendicular(_5);
          const u11 = [];
          u11.push(r17), u11.push([i15[0] + _5[0] * c5, i15[1] + _5[1] * c5]), t15.push(u11);
          const o8 = [];
          o8.push([i15[0] - _5[0] * c5, i15[1] - _5[1] * c5]), o8.push(s14), t15.push(o8);
          break;
        }
        case R.OppositeToFirstSegment: {
          const s14 = this._cp2(e14, 0, -1), i15 = this._cp3(e14, s14, 0.5, 3), h7 = this._mid(r17, s14), _5 = this._sub(h7, i15);
          this._normalize(_5);
          const c5 = this._crossProduct(_5, this._sub(r17, i15));
          this._leftPerpendicular(_5);
          const u11 = [];
          u11.push([i15[0] + _5[0] * c5, i15[1] + _5[1] * c5]), u11.push([i15[0] - _5[0] * c5, i15[1] - _5[1] * c5]), t15.push(u11);
          break;
        }
        case R.TriplePerpendicular: {
          const s14 = this._cp2(e14, 0, -1), i15 = this._cp3(e14, s14, 0.5, 4), h7 = this._mid(r17, s14), _5 = this._sub(h7, i15);
          this._normalize(_5);
          const c5 = this._crossProduct(_5, this._sub(r17, i15));
          this._leftPerpendicular(_5);
          const u11 = [];
          u11.push([i15[0] + _5[0] * c5 * 0.8, i15[1] + _5[1] * c5 * 0.8]), u11.push([h7[0] + 0.8 * (r17[0] - h7[0]), h7[1] + 0.8 * (r17[1] - h7[1])]), t15.push(u11), t15.push([i15, h7]);
          const o8 = [];
          o8.push([i15[0] - _5[0] * c5 * 0.8, i15[1] - _5[1] * c5 * 0.8]), o8.push([h7[0] + 0.8 * (s14[0] - h7[0]), h7[1] + 0.8 * (s14[1] - h7[1])]), t15.push(o8);
          break;
        }
        case R.HalfCircleFirstSegment: {
          const s14 = this._cp2(e14, 0, -1), i15 = this._cp3(e14, s14, 0.5, 4), h7 = this._mid(r17, s14);
          let _5 = this._sub(s14, r17);
          const c5 = Math.cos(Math.PI / 18), u11 = Math.sin(Math.PI / 18), o8 = Math.sqrt((1 + c5) / 2), n18 = Math.sqrt((1 - c5) / 2), a12 = [];
          let p5;
          this._crossProduct(_5, this._sub(i15, r17)) > 0 ? (a12.push(r17), _5 = this._sub(r17, h7), p5 = s14) : (a12.push(s14), _5 = this._sub(s14, h7), p5 = r17), this._rotateDirect(_5, o8, n18), _5[0] /= o8, _5[1] /= o8;
          for (let t16 = 1; t16 <= 18; t16++)
            a12.push(this._add(h7, _5)), this._rotateDirect(_5, c5, u11);
          a12.push(p5), t15.push(a12);
          break;
        }
        case R.HalfCircleSecondSegment: {
          const s14 = this._cp2(e14, 0, -1), i15 = this._cp3(e14, s14, 1, -1);
          let h7 = this._sub(r17, s14);
          this._normalize(h7);
          const _5 = this._crossProduct(h7, this._sub(i15, s14)) / 2;
          this._leftPerpendicular(h7);
          const c5 = [s14[0] + h7[0] * _5, s14[1] + h7[1] * _5];
          h7 = this._sub(s14, c5);
          const u11 = Math.cos(Math.PI / 18);
          let o8 = Math.sin(Math.PI / 18);
          _5 > 0 && (o8 = -o8);
          const n18 = [s14];
          for (let t16 = 1; t16 <= 18; t16++)
            this._rotateDirect(h7, u11, o8), n18.push(this._add(c5, h7));
          t15.push(n18);
          break;
        }
        case R.HalfCircleExtended: {
          const i15 = this._cp2(e14, 0, -2), h7 = this._cp3(e14, i15, 1, -1);
          let _5;
          if (s13 >= 4)
            _5 = e14[3];
          else {
            const s14 = this._sub(r17, i15);
            _5 = this._add(h7, s14);
          }
          const c5 = this._dist(i15, h7) / 2 / 0.75, u11 = this._sub(i15, r17);
          this._normalize(u11, c5);
          const o8 = this._sub(h7, _5);
          this._normalize(o8, c5);
          const n18 = [_5, h7];
          t15.push(n18);
          const a12 = [this._clone(h7)];
          this._addBezier3(a12, h7, this._add(h7, o8), this._add(i15, u11), i15, 4), a12.push(r17), t15.push(a12);
          break;
        }
        case R.OpenCircle: {
          const s14 = this._cp2(e14, -2, 0), i15 = this._sub(s14, r17), h7 = Math.cos(Math.PI / 18), _5 = -Math.sin(Math.PI / 18), c5 = [s14];
          for (let t16 = 1; t16 <= 33; t16++)
            this._rotateDirect(i15, h7, _5), c5.push(this._add(r17, i15));
          t15.push(c5);
          break;
        }
        case R.CoverageEdgesWithTicks: {
          const i15 = this._cp2(e14, 0, -1);
          let h7, _5;
          if (s13 >= 3)
            h7 = e14[2];
          else {
            const s14 = this._sub(i15, r17), t16 = this._leftPerp(s14);
            h7 = [r17[0] + t16[0] - 0.25 * s14[0], r17[1] + t16[1] - 0.25 * s14[1]];
          }
          if (s13 >= 4)
            _5 = e14[3];
          else {
            const s14 = this._mid(r17, i15), t16 = this._sub(r17, i15);
            this._normalize(t16), this._leftPerpendicular(t16);
            const e15 = this._crossProduct(t16, this._sub(h7, s14));
            this._rightPerpendicular(t16), _5 = [h7[0] + t16[0] * e15 * 2, h7[1] + t16[1] * e15 * 2];
          }
          const c5 = this._sub(i15, r17);
          let u11, o8;
          u11 = this._crossProduct(c5, this._sub(h7, r17)) > 0 ? this._rightPerp(c5) : this._leftPerp(c5), o8 = [], o8.push(h7), o8.push(r17), o8.push([r17[0] + (u11[0] - c5[0]) / 3, r17[1] + (u11[1] - c5[1]) / 3]), t15.push(o8), u11 = this._crossProduct(c5, this._sub(_5, i15)) > 0 ? this._rightPerp(u11) : this._leftPerp(c5), o8 = [], o8.push([i15[0] + (u11[0] + c5[0]) / 3, i15[1] + (u11[1] + c5[1]) / 3]), o8.push(i15), o8.push(_5), t15.push(o8);
          break;
        }
        case R.GapExtentWithDoubleTicks: {
          const i15 = this._cp2(e14, 0, 2), h7 = this._cp3(e14, i15, 0, 1);
          let _5;
          if (s13 >= 4)
            _5 = e14[3];
          else {
            const s14 = this._sub(i15, r17);
            _5 = this._add(h7, s14);
          }
          this._addAngledTicks(t15, r17, i15, this._mid(h7, _5)), this._addAngledTicks(t15, h7, _5, this._mid(r17, i15));
          break;
        }
        case R.GapExtentMidline: {
          const i15 = this._cp2(e14, 2, 0), h7 = this._cp3(e14, i15, 0, 1);
          let _5;
          if (s13 >= 4)
            _5 = e14[3];
          else {
            const s14 = this._sub(i15, r17);
            _5 = this._add(h7, s14);
          }
          const c5 = [];
          c5.push(this._mid(r17, h7)), c5.push(this._mid(i15, _5)), t15.push(c5);
          break;
        }
        case R.Chevron: {
          const i15 = this._cp2(e14, -1, -1);
          let h7;
          if (s13 >= 3)
            h7 = e14[2];
          else {
            const s14 = this._sub(i15, r17);
            this._leftPerpendicular(s14), h7 = this._add(r17, s14);
          }
          t15.push([i15, this._makeCtrlPt(r17), h7]);
          break;
        }
        case R.PerpendicularWithArc: {
          const s14 = this._cp2(e14, 0, -2), i15 = this._cp3(e14, s14, 0.5, -1);
          let h7 = this._sub(s14, r17);
          const _5 = this._norm(h7);
          h7[0] /= _5, h7[1] /= _5;
          const c5 = this._crossProduct(h7, this._sub(i15, r17));
          let u11 = this._dotProduct(h7, this._sub(i15, r17));
          u11 < 0.05 * _5 ? u11 = 0.05 * _5 : u11 > 0.95 * _5 && (u11 = 0.95 * _5);
          const o8 = [r17[0] + h7[0] * u11, r17[1] + h7[1] * u11];
          this._leftPerpendicular(h7);
          let n18 = [];
          n18.push([o8[0] - h7[0] * c5, o8[1] - h7[1] * c5]), n18.push([o8[0] + h7[0] * c5, o8[1] + h7[1] * c5]), t15.push(n18);
          const a12 = [s14[0] + h7[0] * c5, s14[1] + h7[1] * c5];
          h7 = this._sub(s14, a12);
          const p5 = Math.cos(Math.PI / 18);
          let l12 = Math.sin(Math.PI / 18);
          c5 < 0 && (l12 = -l12), n18 = [r17, s14];
          for (let t16 = 1; t16 <= 9; t16++)
            this._rotateDirect(h7, p5, l12), n18.push(this._add(a12, h7));
          t15.push(n18);
          break;
        }
        case R.ClosedHalfCircle: {
          const s14 = this._cp2(e14, 2, 0), i15 = this._mid(r17, s14), h7 = this._sub(s14, i15), _5 = Math.cos(Math.PI / 18), c5 = Math.sin(Math.PI / 18), u11 = [r17, s14];
          for (let t16 = 1; t16 <= 18; t16++)
            this._rotateDirect(h7, _5, c5), u11.push(this._add(i15, h7));
          t15.push(u11);
          break;
        }
        case R.TripleParallelExtended: {
          const s14 = this._cp2(e14, 0, -2), h7 = this._cp3(e14, s14, 1, -2), _5 = this._mid(r17, s14), c5 = this._sub(h7, s14);
          this._normalize(c5);
          const u11 = Math.abs(this._crossProduct(c5, this._sub(_5, s14))) / 2, o8 = this._dist(s14, h7), n18 = [s14, r17];
          n18.push([r17[0] + c5[0] * o8 * 0.5, r17[1] + c5[1] * o8 * 0.5]), t15.push(n18);
          const a12 = [];
          a12.push([_5[0] - c5[0] * u11, _5[1] - c5[1] * u11]), a12.push([_5[0] + c5[0] * o8 * 0.375, _5[1] + c5[1] * o8 * 0.375]), r2(a12[a12.length - 1], 1), a12.push([_5[0] + c5[0] * o8 * 0.75, _5[1] + c5[1] * o8 * 0.75]), t15.push(a12);
          const p5 = [s14, h7];
          t15.push(p5);
          break;
        }
        case R.ParallelWithTicks: {
          const s14 = this._cp2(e14, 3, 0), i15 = this._cp3(e14, s14, 0.5, -1), h7 = this._sub(i15, s14);
          this._normalize(h7);
          const _5 = this._crossProduct(h7, this._sub(i15, r17));
          this._leftPerpendicular(h7), this._addAngledTicks(t15, r17, s14, i15), this._addAngledTicks(t15, this._mix(r17, 1, h7, _5), this._mix(s14, 1, h7, _5), this._mid(r17, s14));
          break;
        }
        case R.Parallel: {
          const s14 = this._cp2(e14, 3, 0), i15 = this._cp3(e14, s14, 0.5, -1), h7 = this._sub(s14, r17);
          this._normalize(h7);
          const _5 = this._leftPerp(h7), c5 = this._crossProduct(h7, this._sub(i15, r17));
          let u11 = [r17, s14];
          t15.push(u11), u11 = [], u11.push([r17[0] + _5[0] * c5, r17[1] + _5[1] * c5]), u11.push([s14[0] + _5[0] * c5, s14[1] + _5[1] * c5]), t15.push(u11);
          break;
        }
        case R.PerpendicularToFirstSegment: {
          const s14 = this._cp2(e14, 3, 0), i15 = this._cp3(e14, s14, 0.5, -1), h7 = this._mid(r17, s14), _5 = this._sub(s14, r17);
          this._normalize(_5);
          const c5 = this._crossProduct(_5, this._sub(i15, r17));
          this._leftPerpendicular(_5);
          const u11 = [];
          u11.push([h7[0] - _5[0] * c5 * 0.25, h7[1] - _5[1] * c5 * 0.25]), u11.push([h7[0] + _5[0] * c5 * 1.25, h7[1] + _5[1] * c5 * 1.25]), t15.push(u11);
          break;
        }
        case R.ParallelOffset: {
          const s14 = this._cp2(e14, 3, 0), i15 = this._cp3(e14, s14, 0.5, -1), h7 = this._sub(s14, r17);
          this._normalize(h7);
          const _5 = this._crossProduct(h7, this._sub(i15, r17));
          this._leftPerpendicular(h7);
          const c5 = [];
          c5.push([r17[0] - h7[0] * _5, r17[1] - h7[1] * _5]), c5.push([s14[0] - h7[0] * _5, s14[1] - h7[1] * _5]), t15.push(c5);
          const u11 = [];
          u11.push([r17[0] + h7[0] * _5, r17[1] + h7[1] * _5]), u11.push([s14[0] + h7[0] * _5, s14[1] + h7[1] * _5]), t15.push(u11);
          break;
        }
        case R.OffsetOpposite: {
          const s14 = this._cp2(e14, 3, 0), i15 = this._cp3(e14, s14, 0.5, -1), h7 = this._sub(s14, r17);
          this._normalize(h7);
          const _5 = this._crossProduct(h7, this._sub(i15, r17));
          this._leftPerpendicular(h7);
          const c5 = [];
          c5.push([r17[0] - h7[0] * _5, r17[1] - h7[1] * _5]), c5.push([s14[0] - h7[0] * _5, s14[1] - h7[1] * _5]), t15.push(c5);
          break;
        }
        case R.OffsetSame: {
          const s14 = this._cp2(e14, 3, 0), i15 = this._cp3(e14, s14, 0.5, -1), h7 = this._sub(s14, r17);
          this._normalize(h7);
          const _5 = this._crossProduct(h7, this._sub(i15, r17));
          this._leftPerpendicular(h7);
          const c5 = [];
          c5.push([r17[0] + h7[0] * _5, r17[1] + h7[1] * _5]), c5.push([s14[0] + h7[0] * _5, s14[1] + h7[1] * _5]), t15.push(c5);
          break;
        }
        case R.CircleWithArc: {
          let h7 = this._cp2(e14, 3, 0);
          const _5 = this._cp3(e14, h7, 0.5, -1);
          let c5, u11;
          if (s13 >= 4)
            c5 = e14[3], u11 = this._crossProduct(this._sub(c5, h7), this._sub(_5, h7)) > 0;
          else {
            c5 = h7, u11 = this._crossProduct(this._sub(c5, r17), this._sub(_5, r17)) > 0;
            const s14 = 24 * this._geomUnitsPerPoint, t16 = this._sub(c5, r17);
            this._normalize(t16, s14);
            const i15 = Math.sqrt(2) / 2;
            this._rotateDirect(t16, i15, u11 ? i15 : -i15), h7 = this._add(r17, t16);
          }
          const o8 = this._sub(h7, r17), n18 = Math.cos(Math.PI / 18), a12 = Math.sin(Math.PI / 18), p5 = [h7];
          for (let s14 = 1; s14 <= 36; s14++)
            this._rotateDirect(o8, n18, a12), p5.push(this._add(r17, o8));
          this._add90DegArc(p5, h7, c5, _5, u11), r2(p5[p5.length - 8], 1), t15.push(p5);
          break;
        }
        case R.DoubleJog: {
          let i15, h7, _5 = this._cp2(e14, -3, 1);
          if (i15 = s13 >= 3 ? e14[2] : this._add(r17, this._sub(r17, _5)), s13 >= 4)
            h7 = e14[3];
          else {
            const s14 = r17;
            r17 = _5, h7 = i15;
            const t16 = this._dist(r17, s14), e15 = this._dist(h7, s14);
            let c6 = 30 * this._geomUnitsPerPoint;
            0.5 * t16 < c6 && (c6 = 0.5 * t16), 0.5 * e15 < c6 && (c6 = 0.5 * e15), _5 = this._mix(r17, c6 / t16, s14, (t16 - c6) / t16), i15 = this._mix(h7, c6 / e15, s14, (e15 - c6) / e15);
          }
          const c5 = this._mid(r17, _5), u11 = this._mid(h7, i15), o8 = this._dist(r17, _5), n18 = this._dist(i15, h7);
          let a12 = Math.min(o8, n18) / 8;
          a12 = Math.min(a12, 24 * this._geomUnitsPerPoint);
          const p5 = Math.cos(Math.PI / 4);
          let l12 = this._sub(r17, _5);
          this._normalize(l12, a12), this._crossProduct(l12, this._sub(h7, _5)) > 0 ? this._rotateDirect(l12, p5, -p5) : this._rotateDirect(l12, p5, p5);
          let d4 = [];
          d4.push(_5), d4.push(this._add(c5, l12)), d4.push(this._sub(c5, l12)), d4.push(r17), t15.push(d4), l12 = this._sub(h7, i15), this._normalize(l12, a12), this._crossProduct(l12, this._sub(r17, i15)) < 0 ? this._rotateDirect(l12, p5, p5) : this._rotateDirect(l12, p5, -p5), d4 = [], d4.push(i15), d4.push(this._add(u11, l12)), d4.push(this._sub(u11, l12)), d4.push(h7), t15.push(d4);
          break;
        }
        case R.PerpendicularOffset: {
          const s14 = this._cp2(e14, -4, 1), i15 = this._cp3(e14, s14, 0.882353, -1.94), h7 = this._sub(i15, s14);
          this._crossProduct(h7, this._sub(r17, s14)) > 0 ? this._rightPerpendicular(h7) : this._leftPerpendicular(h7);
          const _5 = [h7[0] / 8, h7[1] / 8], c5 = this._sub(this._mid(s14, i15), _5);
          t15.push([c5, r17]);
          break;
        }
        case R.LineExcludingLastSegment: {
          const s14 = this._arrowPath(e14), i15 = [];
          let h7 = s14.length - 2;
          for (; h7--; )
            i15.push(s14[h7]);
          t15.push(i15);
          break;
        }
        case R.MultivertexArrow: {
          const s14 = this._arrowPath(e14), i15 = [];
          this._addArrow(i15, s14, false), t15.push(i15);
          break;
        }
        case R.CrossedArrow: {
          const s14 = this._arrowPath(e14), i15 = [];
          this._addArrow(i15, s14, true), t15.push(i15);
          break;
        }
        case R.ChevronArrow: {
          const [s14, i15] = this._arrowLastSeg(e14), h7 = 10 * this._geomUnitsPerPoint, _5 = this._sub(r17, s14);
          this._normalize(_5);
          const c5 = this._crossProduct(_5, this._sub(i15, s14)), u11 = this._leftPerp(_5), o8 = [i15[0] - u11[0] * c5 * 2, i15[1] - u11[1] * c5 * 2], n18 = [];
          n18.push([i15[0] + _5[0] * h7, i15[1] + _5[1] * h7]), n18.push(r17), n18.push([o8[0] + _5[0] * h7, o8[1] + _5[1] * h7]), t15.push(n18);
          break;
        }
        case R.ChevronArrowOffset: {
          const [s14, i15] = this._arrowLastSeg(e14), h7 = this._sub(r17, s14);
          this._normalize(h7);
          const _5 = this._crossProduct(h7, this._sub(i15, s14));
          this._leftPerpendicular(h7);
          const c5 = [i15[0] - h7[0] * _5, i15[1] - h7[1] * _5], u11 = [];
          u11.push([c5[0] + h7[0] * _5 * 0.5, c5[1] + h7[1] * _5 * 0.5]), u11.push(this._mid(c5, r17)), u11.push([c5[0] - h7[0] * _5 * 0.5, c5[1] - h7[1] * _5 * 0.5]), t15.push(u11);
          break;
        }
        case R.PartialFirstSegment: {
          const [s14, i15] = this._arrowLastSeg(e14), h7 = this._sub(r17, s14);
          this._normalize(h7);
          const _5 = this._crossProduct(h7, this._sub(i15, s14));
          this._leftPerpendicular(h7);
          const c5 = [i15[0] - h7[0] * _5, i15[1] - h7[1] * _5];
          t15.push([s14, c5]);
          break;
        }
        case R.Arch: {
          const s14 = this._cp2(e14, 0, -1), i15 = this._cp3(e14, s14, 0.5, 1), h7 = this._sub(r17, s14), _5 = this._mix(i15, 1, h7, 0.55), c5 = this._mix(i15, 1, h7, -0.55), u11 = [r17];
          this._addBezier2(u11, r17, _5, i15, 4), this._addBezier2(u11, i15, c5, s14, 4), t15.push(u11);
          break;
        }
        case R.CurvedParallelTicks: {
          const s14 = this._cp2(e14, -4, 1), i15 = this._cp3(e14, s14, 0.882353, -1.94), h7 = this._sub(i15, s14);
          this._crossProduct(h7, this._sub(r17, s14)) > 0 ? this._rightPerpendicular(h7) : this._leftPerpendicular(h7);
          const _5 = [h7[0] / 8, h7[1] / 8], c5 = this._sub(this._mid(s14, i15), _5), u11 = this._sub(this._mix(s14, 0.75, i15, 0.25), _5), o8 = this._sub(this._mix(s14, 0.25, i15, 0.75), _5), n18 = [s14];
          this._addBezier2(n18, s14, u11, c5, 3), this._addBezier2(n18, c5, o8, i15, 3), t15.push(n18);
          for (let e15 = 0; e15 < 8; e15++) {
            const s15 = n18[2 * e15 + 1], i16 = [this._clone(s15)];
            i16.push(this._add(s15, [h7[0] / 4, h7[1] / 4])), t15.push(i16);
          }
          break;
        }
        case R.Arc90Degrees: {
          const s14 = this._cp2(e14, 0, -1), i15 = this._cp3(e14, s14, 0.5, 1), h7 = [s14];
          this._add90DegArc(h7, s14, r17, i15), t15.push(h7);
          break;
        }
        case R.FullGeometry:
        default:
          t15.push(e14);
      }
    }
    return t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectCut.js
var r5 = class _r {
  static local() {
    return null === _r.instance && (_r.instance = new _r()), _r.instance;
  }
  execute(e14, t15, i15, r17, n18) {
    return new u8(e14, t15, i15);
  }
};
r5.instance = null;
var u8 = class extends i5 {
  constructor(e14, t15, r17) {
    super(e14, true, true), this._curveHelper = new s5(), this._beginCut = (void 0 !== t15.beginCut ? t15.beginCut : 1) * r17, this._endCut = (void 0 !== t15.endCut ? t15.endCut : 1) * r17, this._middleCut = (void 0 !== t15.middleCut ? t15.middleCut : 0) * r17, this._invert = void 0 !== t15.invert && t15.invert, this._beginCut < 0 && (this._beginCut = 0), this._endCut < 0 && (this._endCut = 0), this._middleCut < 0 && (this._middleCut = 0);
  }
  processPath(t15) {
    const { _beginCut: i15, _endCut: r17, _middleCut: u11 } = this, n18 = t15.pathLength(), s12 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    if (this._invert) {
      if (0 !== i15 || 0 !== r17 || 0 !== u11)
        if (i15 + r17 + u11 >= n18)
          for (s12.startPath(); t15.nextPoint(); )
            s12.pushXY(t15.x, t15.y);
        else
          this._curveHelper.appendSubCurve(s12, t15, 0, i15), this._curveHelper.appendSubCurve(s12, t15, 0.5 * (n18 - u11), 0.5 * (n18 + u11)), this._curveHelper.appendSubCurve(s12, t15, n18 - r17, r17);
    } else if (0 === i15 && 0 === r17 && 0 === u11)
      for (s12.startPath(); t15.nextPoint(); )
        s12.pushXY(t15.x, t15.y);
    else
      i15 + r17 + u11 < n18 && (0 === u11 ? this._curveHelper.appendSubCurve(s12, t15, i15, n18 - r17) : (this._curveHelper.appendSubCurve(s12, t15, i15, 0.5 * (n18 - u11)), this._curveHelper.appendSubCurve(s12, t15, 0.5 * (n18 + u11), n18 - r17)));
    return 0 === s12.totalSize ? null : s12;
  }
};

// node_modules/@arcgis/core/symbols/cim/GeometryWalker.js
var n7 = 1e-7;
var i7 = class {
  constructor() {
    this._values = [], this.extPtGap = 0, this.ctrlPtGap = 0, this._length = 0, this._currentValue = 0;
  }
  isEmpty() {
    return 0 === this._values.length;
  }
  size() {
    return this._values.length;
  }
  init(t15, e14, s12 = true) {
    if (this._setEmpty(), !t15 || 0 === t15.length)
      return false;
    for (let i15 = 0; i15 < t15.length; i15++) {
      let e15 = Math.abs(t15[i15]);
      s12 && e15 < n7 && (e15 = n7), this._values.push(e15), this._length += e15;
    }
    return e14 && 1 & t15.length && (this._length *= 2), 0 !== this._length && (this.ctrlPtGap = this.extPtGap = 0, this._currentValue = -1, true);
  }
  scale(t15) {
    const e14 = this._values ? this._values.length : 0;
    for (let s12 = 0; s12 < e14; ++s12)
      this._values[s12] *= t15;
    this._length *= t15, this.extPtGap *= t15, this.ctrlPtGap *= t15;
  }
  addValue(t15) {
    this._length += t15, this._values.push(t15);
  }
  firstValue() {
    return this._values[0];
  }
  lastValue() {
    return this._values[this._values.length - 1];
  }
  nextValue() {
    return this._currentValue++, this._currentValue === this._values.length && (this._currentValue = 0), this._values[this._currentValue];
  }
  reset() {
    this._currentValue = -1;
  }
  length() {
    return this._length;
  }
  _setEmpty() {
    this.extPtGap = this.ctrlPtGap = this._length = 0, this._currentValue = -1, this._values.length = 0;
  }
};
var h2 = class {
  constructor() {
    this.pt = null, this.ca = 0, this.sa = 0;
  }
};
var r6;
!function(t15) {
  t15[t15.FAIL = 0] = "FAIL", t15[t15.END = 1] = "END", t15[t15.CONTINUE = 2] = "CONTINUE";
}(r6 || (r6 = {}));
var a7 = class {
  constructor() {
    this.reset();
  }
  reset() {
    this.segment = null, this.segmentLength = 0, this.abscissa = 0, this.isPathEnd = false, this.isPartEnd = false;
  }
  isValid() {
    return null !== this.segment;
  }
  copyTo(t15) {
    t15.segment = this.segment, t15.segmentLength = this.segmentLength, t15.abscissa = this.abscissa, t15.isPathEnd = this.isPathEnd, t15.isPartEnd = this.isPartEnd;
  }
};
var o3 = class extends s5 {
  constructor(t15 = 0, e14 = false) {
    super(t15, e14), this._tolerance = n5, this._currentPosition = new a7();
  }
  updateTolerance(t15) {
    this._tolerance = n5 * t15;
  }
  init(t15, e14, s12 = true) {
    return s12 ? (this._patternLength = e14.length(), this._partExtPtGap = e14.extPtGap, this._partCtrlPtGap = e14.ctrlPtGap) : (this._patternLength = 0, this._partExtPtGap = 0, this._partCtrlPtGap = 0), this._currentPosition.reset(), this._partSegCount = 0, this._pathCursor = t15, this._seg = -1, this._setPosAtNextPart();
  }
  curPositionIsValid() {
    return this._currentPosition.isValid();
  }
  nextPosition(t15, e14 = r6.FAIL) {
    const s12 = new a7();
    return !!this._nextPosition(t15, s12, null, e14) && (s12.copyTo(this._currentPosition), true);
  }
  curPointAndAngle(t15) {
    t15.pt = this._getPoint(this._currentPosition);
    const [e14, s12] = this._getAngleCS(this._currentPosition);
    t15.ca = e14, t15.sa = s12;
  }
  nextPointAndAngle(t15, e14, s12 = r6.FAIL) {
    const n18 = new a7();
    if (!this._nextPosition(t15, n18, null, s12))
      return false;
    n18.copyTo(this._currentPosition), e14.pt = this._getPoint(n18);
    const [i15, h7] = this._getAngleCS(n18);
    return e14.ca = i15, e14.sa = h7, true;
  }
  nextCurve(e14) {
    if (0 === e14)
      return null;
    const s12 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    s12.startPath(), s12.nextPath();
    const n18 = new a7();
    return this._nextPosition(e14, n18, s12, r6.END) ? (n18.copyTo(this._currentPosition), s12) : null;
  }
  isPathEnd() {
    return this._currentPosition.isPathEnd;
  }
  getPathEnd() {
    return this._currentPosition.segment[1];
  }
  getPt(t15) {
    return this._pathCursor.seekInPath(t15), [this._pathCursor.x, this._pathCursor.y];
  }
  getSeg(t15) {
    return [this.getPt(t15), this.getPt(t15 + 1)];
  }
  _nextPosition(t15, e14, s12, n18) {
    if (this._currentPosition.isPathEnd)
      return false;
    let i15 = this._currentPosition.abscissa;
    for (this._currentPosition.segmentLength > 0 && (i15 /= this._currentPosition.segmentLength), this._currentPosition.copyTo(e14); e14.abscissa + t15 * this._partLengthRatio > e14.segmentLength + this._tolerance; ) {
      if (s12) {
        if (0 === s12.pathSize)
          if (0 === i15) {
            const t17 = e14.segment[0];
            s12.pushXY(t17[0], t17[1]);
          } else
            s12.pushPoint(this.getSegCoord2D(e14.segment, i15));
        const t16 = e14.segment[1];
        s12.pushXY(t16[0], t16[1]);
      }
      if (i15 = 0, t15 -= (e14.segmentLength - e14.abscissa) / this._partLengthRatio, this._partSegCount)
        e14.segment = this._nextSegment(), e14.segmentLength = this.getSegLength(e14.segment), e14.abscissa = 0, this._partSegCount--;
      else {
        if (!this._setPosAtNextPart())
          return n18 !== r6.FAIL && (e14.segmentLength = this.getSegLength(e14.segment), e14.isPartEnd = true, n18 === r6.END ? (e14.abscissa = e14.segmentLength, e14.isPathEnd = true) : e14.abscissa = e14.segmentLength + t15, true);
        this._currentPosition.copyTo(e14);
      }
    }
    if (e14.abscissa += t15 * this._partLengthRatio, s12) {
      0 === s12.pathSize && (0 === i15 ? s12.pushPoint(e14.segment[0]) : s12.pushPoint(this.getSegCoord2D(e14.segment, i15)));
      const t16 = e14.abscissa / e14.segmentLength;
      1 === t16 ? s12.pushPoint(e14.segment[1]) : s12.pushPoint(this.getSegCoord2D(e14.segment, t16));
    }
    return this._partSegCount || Math.abs(e14.abscissa - e14.segmentLength) < this._tolerance && (e14.isPathEnd = this._partIsLast, e14.isPartEnd = true), true;
  }
  _getPoint(t15) {
    const e14 = t15.segmentLength <= 0 ? 0 : t15.abscissa / t15.segmentLength;
    return this.getSegCoord2D(this._currentPosition.segment, e14);
  }
  _getAngleCS(t15) {
    const e14 = t15.segmentLength <= 0 ? 0 : t15.abscissa / t15.segmentLength;
    return this.getSegAngleCS(this._currentPosition.segment, e14);
  }
  _setPosAtNextPart() {
    for (; this._partSegCount; )
      this._hasNextSegment() && this._nextSegment(), this._partSegCount--;
    if (!this._hasNextSegment())
      return false;
    for (this._partLength = 0, this._partIsLast = true, this._partSegCount = 0; this._hasNextSegment(); )
      if (this._partLength += this.getSegLength(this._nextSegment()), this._partSegCount++, this._pathCursor.getControlPointAt(this._getEndPointIndex())) {
        this._partIsLast = !this._hasNextSegment();
        break;
      }
    let t15 = this._partSegCount;
    for (; t15; )
      this._previousSegment(), --t15;
    this._currentPosition.segment = this._nextSegment(), this._currentPosition.segmentLength = this.getSegLength(this._currentPosition.segment), this._currentPosition.abscissa = 0, this._currentPosition.isPathEnd = this._currentPosition.isPartEnd = false, --this._partSegCount;
    const e14 = this._getStartPointIndex();
    this._ctrlPtBegin = this._pathCursor.getControlPointAt(e14);
    let s12 = e14 + this._partSegCount + 1;
    if (s12 >= this._pathCursor.pathSize && (s12 = 0), this._ctrlPtEnd = this._pathCursor.getControlPointAt(s12), this._patternLength > 0) {
      const t16 = this._ctrlPtBegin ? this._partCtrlPtGap : this._partExtPtGap, e15 = this._ctrlPtEnd ? this._partCtrlPtGap : this._partExtPtGap;
      let s13 = Math.round((this._partLength - (t16 + e15)) / this._patternLength);
      s13 <= 0 && (s13 = t16 + e15 > 0 ? 0 : 1), this._partLengthRatio = this._partLength / (t16 + e15 + s13 * this._patternLength), this._partLengthRatio < 0.01 && (this._partLengthRatio = 1);
    } else
      this._partLengthRatio = 1;
    return true;
  }
  _hasNextSegment() {
    return this._seg < this._pathCursor.pathSize - 2;
  }
  _previousSegment() {
    return this.getSeg(--this._seg);
  }
  _nextSegment() {
    return this.getSeg(++this._seg);
  }
  _getStartPointIndex() {
    return this._seg;
  }
  _getEndPointIndex() {
    return this._seg + 1;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDashes.js
var h3 = class _h {
  static local() {
    return null === _h.instance && (_h.instance = new _h()), _h.instance;
  }
  execute(t15, e14, s12, i15, r17) {
    return new l6(t15, e14, s12);
  }
};
h3.instance = null;
var l6 = class extends i5 {
  constructor(t15, e14, s12) {
    super(t15, true, true), this._firstCurve = null, this._walker = new o3(), this._walker.updateTolerance(s12), this._endings = e14.lineDashEnding, this._customDashPos = -(e14.offsetAlongLine ?? 0) * s12, this._offsetAtEnd = (e14.customEndingOffset ?? 0) * s12, this._pattern = new i7(), this._pattern.init(j(e14).dashTemplate, true), this._pattern.scale(s12);
  }
  processPath(s12) {
    if (0 === this._pattern.length()) {
      this.iteratePath = false;
      const i15 = n2(s12);
      return a6.fromJSONCIM({ paths: [i15] });
    }
    if (!this.iteratePath) {
      let r18 = true;
      switch (this._endings) {
        case k2.HalfPattern:
        case k2.HalfGap:
        default:
          this._pattern.extPtGap = 0;
          break;
        case k2.FullPattern:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.firstValue());
          break;
        case k2.FullGap:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.lastValue());
          break;
        case k2.NoConstraint:
          this.isClosed || (r18 = false);
          break;
        case k2.Custom:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._offsetAtEnd);
      }
      const a13 = s12.pathLength();
      if (this._pattern.isEmpty() || a13 < 0.1 * this._pattern.length()) {
        const i15 = n2(s12);
        return a6.fromJSONCIM({ paths: [i15] });
      }
      if (!this._walker.init(s12, this._pattern, r18)) {
        const i15 = n2(s12);
        return a6.fromJSONCIM({ paths: [i15] });
      }
    }
    let r17;
    if (this.iteratePath)
      r17 = this._pattern.nextValue();
    else {
      let t15;
      switch (this._endings) {
        case k2.HalfPattern:
        default:
          t15 = 0.5 * this._pattern.firstValue();
          break;
        case k2.HalfGap:
          t15 = 0.5 * -this._pattern.lastValue();
          break;
        case k2.FullGap:
          t15 = -this._pattern.lastValue();
          break;
        case k2.FullPattern:
          t15 = 0;
          break;
        case k2.NoConstraint:
        case k2.Custom:
          t15 = -this._customDashPos;
      }
      let e14 = t15 / this._pattern.length();
      e14 -= Math.floor(e14), t15 = e14 * this._pattern.length(), this._pattern.reset(), r17 = this._pattern.nextValue();
      let s13 = false;
      for (; t15 >= r17; )
        t15 -= r17, r17 = this._pattern.nextValue(), s13 = !s13;
      r17 -= t15, s13 ? (this._walker.nextPosition(r17), r17 = this._pattern.nextValue()) : this.isClosed && (this._firstCurve = this._walker.nextCurve(r17), r17 = this._pattern.nextValue(), this._walker.nextPosition(r17), r17 = this._pattern.nextValue());
    }
    let a12 = this._walker.nextCurve(r17);
    if (a12)
      if (this._walker.isPathEnd()) {
        if (this.iteratePath = false, this._firstCurve) {
          for (this._firstCurve.nextPath(); this._firstCurve.nextPoint(); )
            a12.pushXY(this._firstCurve.x, this._firstCurve.y);
          this._firstCurve = null;
        }
      } else
        r17 = this._pattern.nextValue(), !this._walker.nextPosition(r17) || this._walker.isPathEnd() ? (this.iteratePath = false, this._firstCurve && (a12.pushCursor(this._firstCurve), this._firstCurve = null)) : this.iteratePath = true;
    else
      this.iteratePath = false, a12 = this._firstCurve, this._firstCurve = null;
    return a12 == null ? void 0 : a12.reset(), a12;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDonut.js
var s7 = class _s {
  static local() {
    return null === _s.instance && (_s.instance = new _s()), _s.instance;
  }
  execute(t15, i15, e14, n18, s12, o8) {
    return new r7(t15, i15, e14, n18, s12, o8);
  }
};
s7.instance = null;
var r7 = class {
  constructor(t15, i15, n18, s12, r17, o8) {
    switch (this._inputGeometries = t15, this._tileKey = s12, this._geometryEngine = r17, this._maxInflateSize = o8 * n18, this._width = (void 0 !== i15.width ? i15.width : 2) * n18, i15.method) {
      case B2.Mitered:
      case B2.Bevelled:
      case B2.Rounded:
      case B2.TrueBuffer:
      case B2.Square:
    }
    this._option = i15.option;
  }
  next() {
    let e14;
    for (; e14 = this._inputGeometries.next(); ) {
      if ("esriGeometryEnvelope" === e14.geometryType && this._width > 0) {
        const i15 = e14.asJSON();
        return Math.min(i15.xmax - i15.xmin, i15.ymax - i15.ymin) - 2 * this._width < 0 ? e14 : a6.fromJSONCIM({ paths: [[[i15.xmin + this._width, i15.ymin + this._width], [i15.xmax - this._width, i15.ymin + this._width], [i15.xmax - this._width, i15.ymax - this._width], [i15.xmin + this._width, i15.ymax - this._width], [i15.xmin + this._width, i15.ymin + this._width]], [[i15.xmin, i15.ymin], [i15.xmin, i15.ymax], [i15.xmax, i15.ymax], [i15.xmax, i15.ymin], [i15.xmin, i15.ymin]]] });
      }
      if ("esriGeometryPolygon" === e14.geometryType) {
        if (0 === this._width)
          return e14.clone();
        const t15 = this._geometryEngine;
        if (null == t15)
          return null;
        const s12 = this._tileKey ? i6(e14, this._maxInflateSize) : e14.clone();
        if (!s12)
          continue;
        const r17 = t15.buffer(f.WebMercator, s12.asJSON(), -this._width, 1);
        if (r17) {
          for (const i15 of r17.rings)
            if (i15) {
              s12.startPath();
              for (const t16 of i15.reverse())
                s12.pushXY(t16[0], s12.yFactor * t16[1]);
            }
        }
        return s12;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectJog.js
var e8 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(t15, i15, s12, e14, o8) {
    return new n8(t15, i15, s12);
  }
};
e8.instance = null;
var n8 = class extends i5 {
  constructor(t15, i15, e14) {
    super(t15, false, true), this._curveHelper = new s5(), this._length = (void 0 !== i15.length ? i15.length : 20) * e14, this._angle = void 0 !== i15.angle ? i15.angle : 225, this._position = void 0 !== i15.position ? i15.position : 50, this._length < 0 && (this._length = -this._length), this._position < 20 && (this._position = 20), this._position > 80 && (this._position = 80), this._mirror = false;
  }
  processPath(i15) {
    const s12 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    if (this._curveHelper.isEmpty(i15))
      return null;
    i15.seekInPath(0);
    const e14 = i15.x, n18 = i15.y;
    i15.seekInPath(i15.pathSize - 1);
    const o8 = i15.x, r17 = i15.y, h7 = [o8 - e14, r17 - n18];
    this._curveHelper.normalize(h7);
    const l12 = e14 + (o8 - e14) * this._position / 100, _5 = n18 + (r17 - n18) * this._position / 100, a12 = Math.cos((90 - this._angle) / 180 * Math.PI);
    let p5 = Math.sin((90 - this._angle) / 180 * Math.PI);
    this._mirror && (p5 = -p5), this._mirror = !this._mirror;
    const c5 = [l12 - this._length / 2 * a12, _5 - this._length / 2 * p5], m7 = [l12 + this._length / 2 * a12, _5 + this._length / 2 * p5];
    return s12.pushPath([[e14, n18], c5, m7, [o8, r17]]), s12;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectMove.js
var t8 = class _t {
  static local() {
    return null === _t.instance && (_t.instance = new _t()), _t.instance;
  }
  execute(t15, s12, n18, o8, i15) {
    return new e9(t15, s12, n18);
  }
};
t8.instance = null;
var e9 = class {
  constructor(t15, e14, s12) {
    this._inputGeometries = t15, this._offsetX = void 0 !== e14.offsetX ? e14.offsetX * s12 : 0, this._offsetY = void 0 !== e14.offsetY ? e14.offsetY * s12 : 0;
  }
  next() {
    let t15 = this._inputGeometries.next();
    for (; t15; ) {
      if (t15.totalSize > 0)
        return this._move(t15.clone(), this._offsetX, this._offsetY);
      t15 = this._inputGeometries.next();
    }
    return null;
  }
  _move(t15, e14, s12) {
    for (; t15.nextPath(); )
      for (; t15.nextPoint(); )
        t15.x = t15.x + e14, t15.y = t15.y + s12;
    return t15.reset(), t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectOffset.js
var f7 = 10;
var h4 = class _h {
  static local() {
    return null === _h.instance && (_h.instance = new _h()), _h.instance;
  }
  execute(t15, e14, s12, o8, r17, i15) {
    return new l7(t15, e14, s12, o8, r17, i15);
  }
};
h4.instance = null;
var l7 = class {
  constructor(t15, e14, s12, o8, n18, m7) {
    this._inputGeometries = t15, this._tileKey = o8, this._geometryEngine = n18, this._curveHelper = new s5(), this._offset = (e14.offset ?? 1) * s12, this._method = e14.method, this._maxInflateSize = Math.max(Math.abs(m7 * s12), f7), this._option = e14.option, this._offsetFlattenError = n5 * s12;
  }
  next() {
    let r17;
    for (; r17 = this._inputGeometries.next(); ) {
      if (0 === this._offset)
        return r17.clone();
      if ("esriGeometryEnvelope" === r17.geometryType) {
        if (this._method === O.Rounded && this._offset > 0) {
          const s12 = n2(r17), o9 = this._curveHelper.offset(s12, -this._offset, this._method, 4, this._offsetFlattenError);
          if (o9) {
            const e14 = a6.createEmptyOptimizedCIM(r17.geometryType);
            return e14.pushPath(o9), e14;
          }
          return null;
        }
        const o8 = r17.asJSON();
        if (m(o8) && Math.min(o8.xmax - o8.xmin, o8.ymax - o8.ymin) + 2 * this._offset > 0)
          return a6.fromJSONCIM({ xmin: o8.xmin - this._offset, xmax: o8.xmax + this._offset, ymin: o8.ymin - this._offset, ymax: o8.ymax + this._offset });
      }
      const i15 = this._geometryEngine;
      if (null == i15)
        continue;
      const f9 = this._tileKey ? i6(r17, this._maxInflateSize) : r17.clone();
      if (!f9)
        continue;
      const h7 = i15.offset(f.WebMercator, f9.asJSON(), -this._offset, 1, this._method, 4, this._offsetFlattenError);
      return h7 ? a6.fromJSONCIM(h7) : null;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectReverse.js
var e10 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(e14, n18, r17, s12, i15) {
    return new t9(e14, n18, r17);
  }
};
e10.instance = null;
var t9 = class {
  constructor(e14, t15, n18) {
    this._inputGeometries = e14, this._reverse = void 0 === t15.reverse || t15.reverse;
  }
  next() {
    let e14 = this._inputGeometries.next();
    for (; e14; ) {
      if (!this._reverse)
        return e14;
      if ("esriGeometryPolyline" === e14.geometryType)
        return n9(e14.clone());
      e14 = this._inputGeometries.next();
    }
    return null;
  }
};
function n9(e14) {
  for (; e14.nextPath(); )
    for (let t15 = 0; t15 < e14.pathSize / 2; t15++) {
      e14.seekInPath(t15);
      const n18 = e14.x, r17 = e14.y;
      e14.seekInPath(e14.pathSize - t15 - 1);
      const s12 = e14.x, i15 = e14.y;
      e14.x = n18, e14.y = r17, e14.seekInPath(t15), e14.x = s12, e14.y = i15;
    }
  return e14.reset(), e14;
}

// node_modules/@arcgis/core/symbols/cim/effects/EffectRotate.js
var e11 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(t15, e14, r17, s12, o8) {
    return new n10(t15, e14, r17);
  }
};
e11.instance = null;
var n10 = class {
  constructor(t15, e14, n18) {
    this._inputGeometries = t15, this._rotateAngle = void 0 !== e14.angle ? e14.angle * Math.PI / 180 : 0;
  }
  next() {
    let e14 = this._inputGeometries.next();
    for (; e14; ) {
      if (0 === this._rotateAngle || "esriGeometryPoint" === e14.geometryType)
        return e14;
      if (e14.totalSize > 0) {
        const n18 = c(e14), r17 = (n18[2] + n18[0]) / 2, s12 = (n18[3] + n18[1]) / 2;
        return e14.reset(), this._rotate(e14.clone(), r17, s12);
      }
      e14 = this._inputGeometries.next();
    }
    return null;
  }
  _rotate(t15, e14, n18) {
    const r17 = Math.cos(this._rotateAngle), s12 = Math.sin(this._rotateAngle);
    for (; t15.nextPath(); )
      for (; t15.nextPoint(); ) {
        const o8 = t15.x - e14, i15 = t15.y - n18;
        t15.x = e14 + o8 * r17 - i15 * s12, t15.y = n18 + o8 * s12 + i15 * r17;
      }
    return t15.reset(), t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectScale.js
var e12 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(t15, e14, o8, s12, n18) {
    return new r8(t15, e14, o8);
  }
};
e12.instance = null;
var r8 = class {
  constructor(t15, e14, r17) {
    this._inputGeometries = t15, this._xFactor = void 0 !== e14.XScaleFactor ? e14.XScaleFactor : 1.15, this._yFactor = void 0 !== e14.YScaleFactor ? e14.YScaleFactor : 1.15;
  }
  next() {
    const e14 = this._inputGeometries.next();
    if (e14) {
      if (1 === this._xFactor && 1 === this._yFactor)
        return e14;
      if ("esriGeometryPoint" === e14.geometryType)
        return e14;
      if (e14.totalSize > 0) {
        const r17 = c(e14), o8 = (r17[2] + r17[0]) / 2, s12 = (r17[3] + r17[1]) / 2;
        return e14.reset(), this._scaleCursor(e14.clone(), o8, s12);
      }
    }
    return null;
  }
  _scaleCursor(t15, e14, r17) {
    for (; t15.nextPath(); )
      for (; t15.nextPoint(); )
        t15.x = e14 + (t15.x - e14) * this._xFactor, t15.y = r17 + (t15.y - r17) * this._yFactor;
    return t15.reset(), t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectWave.js
var n11 = class _n {
  static local() {
    return null === _n.instance && (_n.instance = new _n()), _n.instance;
  }
  execute(t15, e14, i15, s12, h7) {
    return new r9(t15, e14, i15);
  }
};
n11.instance = null;
var r9 = class {
  constructor(t15, e14, h7) {
    this._inputGeometries = t15, this._height = (void 0 !== e14.amplitude ? e14.amplitude : 2) * h7, this._period = (void 0 !== e14.period ? e14.period : 3) * h7, this._style = e14.waveform, this._height <= 0 && (this._height = Math.abs(this._height)), this._period <= 0 && (this._period = Math.abs(this._period)), this._pattern = new i7(), this._pattern.addValue(this._period), this._pattern.addValue(this._period), this._walker = new o3(), this._walker.updateTolerance(h7);
  }
  next() {
    let t15 = this._inputGeometries.next();
    for (; t15; ) {
      if (0 === this._height || 0 === this._period)
        return t15;
      const e14 = this._processGeom(t15);
      if (e14)
        return e14;
      t15 = this._inputGeometries.next();
    }
    return null;
  }
  _processGeom(i15) {
    const s12 = a6.createEmptyOptimizedCIM(i15.geometryType);
    for (; i15.nextPath(); ) {
      s12.startPath();
      const t15 = i15.pathLength();
      if (this._walker.init(i15, this._pattern))
        switch (this._style) {
          case A2.Sinus:
          default:
            this._constructCurve(s12, t15, false);
            break;
          case A2.Square:
            this._constructSquare(s12, t15);
            break;
          case A2.Triangle:
            this._constructTriangle(s12, t15);
            break;
          case A2.Random:
            this._constructCurve(s12, t15, true);
        }
      else
        for (; i15.nextPoint(); )
          s12.pushXY(i15.x, i15.y);
    }
    return s12;
  }
  _constructCurve(t15, e14, i15) {
    let s12 = Math.round(e14 / this._period);
    0 === s12 && (s12 = 1);
    const n18 = s12 * 16 + 1, r17 = e14 / s12, a12 = this._period / 16, o8 = 1 / n18, p5 = 2 * Math.PI * e14 / r17, _5 = 2 * Math.PI * Math.random(), u11 = 2 * Math.PI * Math.random(), l12 = 2 * Math.PI * Math.random(), c5 = 0.75 - Math.random() / 2, d4 = 0.75 - Math.random() / 2, g4 = new h2();
    this._walker.curPointAndAngle(g4), t15.pushPoint(g4.pt);
    let w5 = 0;
    for (; ; ) {
      if (!this._walker.nextPointAndAngle(a12, g4)) {
        t15.pushPoint(this._walker.getPathEnd());
        break;
      }
      {
        const e15 = w5;
        let s13;
        if (w5 += o8, i15) {
          const t16 = this._height / 2 * (1 + 0.3 * Math.sin(c5 * p5 * e15 + _5));
          s13 = t16 * Math.sin(p5 * e15 + u11), s13 += t16 * Math.sin(d4 * p5 * e15 + l12), s13 /= 2;
        } else
          s13 = 0.5 * this._height * Math.sin(0.5 * p5 * e15);
        t15.pushXY(g4.pt[0] - s13 * g4.sa, g4.pt[1] + s13 * g4.ca);
      }
    }
  }
  _constructSquare(t15, e14) {
    Math.round(e14 / this._period);
    let i15 = true;
    for (; ; ) {
      let e15 = false;
      if (this._walker.curPositionIsValid()) {
        const s12 = new h2();
        this._walker.curPointAndAngle(s12);
        const n18 = new h2();
        if (this._walker.nextPointAndAngle(this._period, n18)) {
          const r17 = new h2();
          this._walker.nextPointAndAngle(this._period, r17) && (i15 ? (t15.pushPoint(s12.pt), i15 = false) : t15.pushPoint(s12.pt), t15.pushXY(s12.pt[0] - this._height / 2 * s12.sa, s12.pt[1] + this._height / 2 * s12.ca), t15.pushXY(n18.pt[0] - this._height / 2 * n18.sa, n18.pt[1] + this._height / 2 * n18.ca), t15.pushXY(n18.pt[0] + this._height / 2 * n18.sa, n18.pt[1] - this._height / 2 * n18.ca), t15.pushXY(r17.pt[0] + this._height / 2 * r17.sa, r17.pt[1] - this._height / 2 * r17.ca), e15 = true);
        }
      }
      if (!e15) {
        t15.pushPoint(this._walker.getPathEnd());
        break;
      }
    }
  }
  _constructTriangle(t15, e14) {
    Math.round(e14 / this._period);
    let i15 = true;
    for (; ; ) {
      let e15 = false;
      if (this._walker.curPositionIsValid()) {
        const s12 = new h2();
        this._walker.curPointAndAngle(s12);
        const n18 = new h2();
        if (this._walker.nextPointAndAngle(this._period / 2, n18)) {
          const r17 = new h2();
          this._walker.nextPointAndAngle(this._period, r17) && (this._walker.nextPosition(this._period / 2) && (i15 ? (t15.pushPoint(s12.pt), i15 = false) : t15.pushPoint(s12.pt), t15.pushXY(n18.pt[0] - this._height / 2 * n18.sa, n18.pt[1] + this._height / 2 * n18.ca), t15.pushXY(r17.pt[0] + this._height / 2 * r17.sa, r17.pt[1] - this._height / 2 * r17.ca)), e15 = true);
        }
      }
      if (!e15) {
        t15.pushPoint(this._walker.getPathEnd());
        break;
      }
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAlongLineSameSize.js
var a8 = class _a {
  static local() {
    return null === _a.instance && (_a.instance = new _a()), _a.instance;
  }
  execute(t15, e14, s12, i15, n18) {
    return new r10(t15, e14, s12);
  }
};
a8.instance = null;
var r10 = class extends s4 {
  constructor(t15, e14, n18) {
    super(t15), this._geometryWalker = new o3(), this._geometryWalker.updateTolerance(n18), this._angleToLine = e14.angleToLine ?? true, this._offset = (e14.offset ? e14.offset : 0) * n18, this._originalEndings = e14.endings, this._offsetAtEnd = (e14.customEndingOffset ? e14.customEndingOffset : 0) * n18, this._position = -(e14.offsetAlongLine ? e14.offsetAlongLine : 0) * n18, this._pattern = new i7(), this._pattern.init(e14.placementTemplate, false), this._pattern.scale(n18), this._endings = this._originalEndings;
  }
  processPath(t15) {
    if (this._pattern.isEmpty())
      return null;
    let s12;
    if (this.iteratePath)
      s12 = this._pattern.nextValue();
    else {
      this._originalEndings === X.WithFullGap && this.isClosed ? this._endings = X.WithMarkers : this._endings = this._originalEndings, this._pattern.extPtGap = 0;
      let i16, n18 = true;
      switch (this._endings) {
        case X.NoConstraint:
          i16 = -this._position, i16 = this._adjustPosition(i16), n18 = false;
          break;
        case X.WithHalfGap:
        default:
          i16 = -this._pattern.lastValue() / 2;
          break;
        case X.WithFullGap:
          i16 = -this._pattern.lastValue(), this._pattern.extPtGap = this._pattern.lastValue();
          break;
        case X.WithMarkers:
          i16 = 0;
          break;
        case X.Custom:
          i16 = -this._position, i16 = this._adjustPosition(i16), this._pattern.extPtGap = 0.5 * this._offsetAtEnd;
      }
      if (!this._geometryWalker.init(t15, this._pattern, n18))
        return null;
      this._pattern.reset();
      let a12 = 0;
      for (; i16 > a12; )
        i16 -= a12, a12 = this._pattern.nextValue();
      a12 -= i16, s12 = a12, this.iteratePath = true;
    }
    const i15 = new h2();
    return this._geometryWalker.nextPointAndAngle(s12, i15) ? this._endings === X.WithFullGap && this._geometryWalker.isPathEnd() ? (this.iteratePath = false, null) : this._endings === X.WithMarkers && this._geometryWalker.isPathEnd() && (this.iteratePath = false, this.isClosed) ? null : (this.internalPlacement.setTranslate(i15.pt[0] - this._offset * i15.sa, i15.pt[1] + this._offset * i15.ca), this._angleToLine && this.internalPlacement.setRotateCS(i15.ca, i15.sa), this.internalPlacement) : (this.iteratePath = false, null);
  }
  _adjustPosition(t15) {
    let e14 = t15 / this._pattern.length();
    return e14 -= Math.floor(e14), e14 * this._pattern.length();
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtExtremities.js
var i8 = class _i {
  static local() {
    return null === _i.instance && (_i.instance = new _i()), _i.instance;
  }
  execute(e14, t15, s12, i15, r17) {
    return new n12(e14, t15, s12);
  }
};
i8.instance = null;
var n12 = class extends s4 {
  constructor(e14, s12, i15) {
    super(e14, false, true), this._curveHelper = new s5(), this._angleToLine = void 0 === s12.angleToLine || s12.angleToLine, this._offset = void 0 !== s12.offset ? s12.offset * i15 : 0, this._type = s12.extremityPlacement, this._position = void 0 !== s12.offsetAlongLine ? s12.offsetAlongLine * i15 : 0, this._beginProcessed = false;
  }
  processPath(e14) {
    let t15;
    switch (this._type) {
      case o2.Both:
      default:
        this._beginProcessed ? (t15 = this._atExtremities(e14, this._position, false), this._beginProcessed = false, this.iteratePath = false) : (t15 = this._atExtremities(e14, this._position, true), this._beginProcessed = true, this.iteratePath = true);
        break;
      case o2.JustBegin:
        t15 = this._atExtremities(e14, this._position, true);
        break;
      case o2.JustEnd:
        t15 = this._atExtremities(e14, this._position, false);
      case o2.None:
    }
    return t15;
  }
  _atExtremities(e14, t15, s12) {
    if (s12 || e14.seekPathEnd(), s12 ? e14.nextPoint() : e14.prevPoint()) {
      let i15 = 0, [n18, r17] = [0, 0], [o8, a12] = [e14.x, e14.y];
      for (; s12 ? e14.nextPoint() : e14.prevPoint(); ) {
        n18 = o8, r17 = a12, o8 = e14.x, a12 = e14.y;
        const s13 = this._curveHelper.getLength(n18, r17, o8, a12);
        if (i15 + s13 > t15) {
          const e15 = (t15 - i15) / s13, [h7, l12] = this._curveHelper.getAngleCS(n18, r17, o8, a12, e15), c5 = this._curveHelper.getCoord2D(n18, r17, o8, a12, e15);
          return this.internalPlacement.setTranslate(c5[0] - this._offset * l12, c5[1] + this._offset * h7), this._angleToLine && this.internalPlacement.setRotateCS(-h7, -l12), this.internalPlacement;
        }
        i15 += s13;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtRatioPositions.js
var a9 = class _a {
  static local() {
    return null === _a.instance && (_a.instance = new _a()), _a.instance;
  }
  execute(t15, i15, s12, e14, n18) {
    return new r11(t15, i15, s12);
  }
};
a9.instance = null;
var r11 = class extends s4 {
  constructor(t15, e14, n18) {
    super(t15), this._walker = new o3(), this._walker.updateTolerance(n18), this._angleToLine = void 0 === e14.angleToLine || e14.angleToLine, this._offset = void 0 !== e14.offset ? e14.offset * n18 : 0, this._beginGap = void 0 !== e14.beginPosition ? e14.beginPosition * n18 : 0, this._endGap = void 0 !== e14.endPosition ? e14.endPosition * n18 : 0, this._flipFirst = void 0 === e14.flipFirst || e14.flipFirst, this._pattern = new i7(), this._pattern.init(e14.positionArray, false, false), this._subPathLen = 0, this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0;
  }
  processPath(t15) {
    if (this._pattern.isEmpty())
      return null;
    let i15;
    if (this.iteratePath) {
      const t16 = this._pattern.nextValue() * this._subPathLen, s13 = this._beginGap + t16;
      i15 = s13 - this._prevPos, this._prevPos = s13;
    } else {
      if (this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0, this._subPathLen = t15.pathLength() - this._beginGap - this._endGap, this._subPathLen < 0)
        return this.iteratePath = false, null;
      if (!this._walker.init(t15, this._pattern, false))
        return null;
      this._pattern.reset();
      const s13 = this._pattern.nextValue() * this._subPathLen, e14 = this._beginGap + s13;
      i15 = e14 - this._prevPos, this._prevPos = e14, this.iteratePath = true;
    }
    const s12 = new h2();
    if (!this._walker.nextPointAndAngle(i15, s12, r6.END))
      return this.iteratePath = false, null;
    this.internalPlacement.setTranslate(s12.pt[0] - this._offset * s12.sa, s12.pt[1] + this._offset * s12.ca);
    const a12 = this._isFirst && this._flipFirst;
    let r17, h7;
    return this._angleToLine ? (r17 = s12.ca, h7 = s12.sa) : (r17 = 1, h7 = 0), a12 && (r17 = -r17, h7 = -h7), this.internalPlacement.setRotateCS(r17, h7), this._isFirst = false, this._posCount--, 0 === this._posCount && (this.iteratePath = false), this.internalPlacement;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementInsidePolygon.js
var e13 = 512;
var h5 = 10;
var n13 = 24;
var _2 = 1e-6;
var r12 = class _r {
  static local() {
    return null === _r.instance && (_r.instance = new _r()), _r.instance;
  }
  execute(t15, s12, i15, e14, h7) {
    return new a10(t15, s12, i15, e14, h7);
  }
};
r12.instance = null;
var a10 = class _a {
  constructor(h7, n18, _5, r17, a12) {
    if (this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, this._currentX = 0, this._currentY = 0, this._accelerationMap = null, this._testInsidePolygon = false, this._verticalSubdivision = true, this._stepX = Math.abs(n18.stepX ?? 16) * _5, this._stepY = Math.abs(n18.stepY ?? 16) * _5, this._stepX = Math.round(128 * this._stepX) / 128, this._stepY = Math.round(128 * this._stepY) / 128, 0 !== this._stepX && 0 !== this._stepY) {
      if (this._gridType = n18.gridType ?? Y.Fixed, this._gridType === Y.Random) {
        const s12 = n18.seed ?? 13, i15 = 1;
        this._randomLCG = new t(s12 * i15), this._randomness = (n18.randomness ?? 100) / 100, this._gridAngle = 0, this._shiftOddRows = false, this._cosAngle = 1, this._sinAngle = 0, this._offsetX = 0, this._offsetY = 0, this._buildRandomValues();
      } else {
        if (this._randomness = 0, this._gridAngle = n18.gridAngle ?? 0, this._shiftOddRows = n18.shiftOddRows ?? false, this._offsetX = (n18.offsetX ?? 0) * _5, this._offsetY = (n18.offsetY ?? 0) * _5, this._cosAngle = Math.cos(this._gridAngle / 180 * Math.PI), this._sinAngle = -Math.sin(this._gridAngle / 180 * Math.PI), this._stepX)
          if (this._offsetX < 0)
            for (; this._offsetX < -0.5 * this._stepX; )
              this._offsetX += this._stepX;
          else
            for (; this._offsetX >= 0.5 * this._stepX; )
              this._offsetX -= this._stepX;
        if (this._stepY)
          if (this._offsetY < 0)
            for (; this._offsetY < -0.5 * this._stepY; )
              this._offsetY += this._stepY;
          else
            for (; this._offsetY >= 0.5 * this._stepY; )
              this._offsetY -= this._stepY;
      }
      if (this._graphicOriginX = 0, this._graphicOriginY = 0, null != r17) {
        const [t15, s12, i15, h8] = r17.split("/"), n19 = parseFloat(t15), _6 = parseFloat(s12), a13 = parseFloat(i15), o8 = parseFloat(h8);
        this._graphicOriginX = -(o8 * 2 ** n19 + a13) * e13, this._graphicOriginY = _6 * e13, this._testInsidePolygon = true;
      }
      this._internalPlacement = new t7(), this._calculateMinMax(h7), this._geometryCursor = h7;
    }
  }
  next() {
    return this._geometryCursor ? this._nextInside() : null;
  }
  _buildRandomValues() {
    if (!_a._randValues) {
      _a._randValues = [];
      for (let t15 = 0; t15 < n13; t15++)
        for (let s12 = 0; s12 < n13; s12++)
          _a._randValues.push(this._randomLCG.getFloat()), _a._randValues.push(this._randomLCG.getFloat());
    }
  }
  _calculateMinMax(t15) {
    let s12, i15, h7, n18, _5, r17, a12, o8, l12, f9, c5, u11, p5, M4;
    this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, a12 = o8 = p5 = c5 = Number.MAX_VALUE, l12 = f9 = M4 = u11 = -Number.MAX_VALUE;
    const g4 = 1 !== this._cosAngle;
    for (t15.reset(); t15.nextPath(); )
      for (; t15.nextPoint(); )
        r17 = t15.x, _5 = t15.y, s12 = r17 - this._graphicOriginX - this._offsetX, i15 = _5 - this._graphicOriginY - this._offsetY, g4 ? (h7 = this._cosAngle * s12 - this._sinAngle * i15, n18 = this._sinAngle * s12 + this._cosAngle * i15) : (h7 = s12, n18 = i15), a12 = Math.min(a12, h7), l12 = Math.max(l12, h7), o8 = Math.min(o8, n18), f9 = Math.max(f9, n18), c5 = Math.min(c5, _5), u11 = Math.max(u11, _5), p5 = Math.min(p5, r17), M4 = Math.max(M4, r17);
    c5 = c5 !== Number.MAX_VALUE ? c5 : -e13 - this._stepY, u11 = u11 !== -Number.MAX_VALUE ? u11 : this._stepY, p5 = p5 !== Number.MAX_VALUE ? p5 : -this._stepX, M4 = M4 !== -Number.MAX_VALUE ? M4 : e13 + this._stepX;
    const d4 = u11 - c5, X3 = M4 - p5;
    if (this._verticalSubdivision = d4 >= X3, this._polygonMin = this._verticalSubdivision ? c5 : p5, this._testInsidePolygon) {
      let t16 = 0 - this._graphicOriginX - this._offsetX - this._stepX, s13 = e13 - this._graphicOriginX - this._offsetX + this._stepX, i16 = -e13 - this._graphicOriginY - this._offsetY - this._stepY, h8 = 0 - this._graphicOriginY - this._offsetY + this._stepY;
      if (g4) {
        const e14 = [[t16, i16], [t16, h8], [s13, i16], [s13, h8]];
        t16 = i16 = Number.MAX_VALUE, s13 = h8 = -Number.MAX_VALUE;
        for (const n19 of e14) {
          const e15 = this._cosAngle * n19[0] - this._sinAngle * n19[1], _6 = this._sinAngle * n19[0] + this._cosAngle * n19[1];
          t16 = Math.min(t16, e15), s13 = Math.max(s13, e15), i16 = Math.min(i16, _6), h8 = Math.max(h8, _6);
        }
      }
      a12 = a12 !== Number.MAX_VALUE ? Math.max(a12, t16) : t16, o8 = o8 !== Number.MAX_VALUE ? Math.max(o8, i16) : i16, l12 = l12 !== -Number.MAX_VALUE ? Math.min(l12, s13) : s13, f9 = f9 !== -Number.MAX_VALUE ? Math.min(f9, h8) : h8;
    }
    this._xMin = Math.round(a12 / this._stepX), this._xMax = Math.round(l12 / this._stepX), this._yMin = Math.round(o8 / this._stepY), this._yMax = Math.round(f9 / this._stepY), this._currentX = this._xMax + 1, this._currentY = this._yMin - 1, this._buildAccelerationMap(t15, p5, M4, c5, u11);
  }
  _buildAccelerationMap(t15, s12, i15, n18, _5) {
    t15.reset();
    const r17 = /* @__PURE__ */ new Map(), a12 = this._verticalSubdivision, o8 = a12 ? _5 - n18 : i15 - s12;
    let f9 = Math.ceil(o8 / h5);
    if (f9 <= 1)
      return;
    const c5 = Math.floor(o8 / f9);
    let u11, p5, M4, g4, d4, X3, m7, x4, A5, Y4, y5;
    for (f9++, this._delta = c5, a12 ? (A5 = -e13 - 2 * this._stepY, Y4 = 2 * this._stepY, y5 = n18) : (A5 = -2 * this._stepX, Y4 = e13 + 2 * this._stepX, y5 = s12); t15.nextPath(); )
      if (!(t15.pathSize < 2) && t15.nextPoint())
        for (u11 = t15.x, p5 = t15.y; t15.nextPoint(); u11 = M4, p5 = g4) {
          if (M4 = t15.x, g4 = t15.y, a12) {
            if (p5 === g4 || p5 < A5 && g4 < A5 || p5 > Y4 && g4 > Y4)
              continue;
            d4 = Math.min(p5, g4), X3 = Math.max(p5, g4);
          } else {
            if (u11 === M4 || u11 < A5 && M4 < A5 || u11 > Y4 && M4 > Y4)
              continue;
            d4 = Math.min(u11, M4), X3 = Math.max(u11, M4);
          }
          for (; d4 < X3; )
            m7 = Math.floor((d4 - y5) / c5), l8(m7, u11, p5, M4, g4, r17), d4 += c5;
          x4 = Math.floor((X3 - y5) / c5), x4 > m7 && l8(x4, u11, p5, M4, g4, r17);
        }
    this._accelerationMap = r17;
  }
  _nextInside() {
    for (; ; ) {
      if (this._currentX > this._xMax) {
        if (this._currentY++, this._currentY > this._yMax)
          return null;
        this._currentX = this._xMin, this._shiftOddRows && this._currentY % 2 && this._currentX--;
      }
      let t15 = this._currentX * this._stepX + this._offsetX;
      this._shiftOddRows && this._currentY % 2 && (t15 += 0.5 * this._stepX);
      const s12 = this._currentY * this._stepY + this._offsetY;
      let e14, h7;
      if (this._currentX++, this._gridType === Y.Random) {
        const i15 = (this._currentX % n13 + n13) % n13, _5 = (this._currentY % n13 + n13) % n13;
        e14 = this._graphicOriginX + t15 + this._stepX * this._randomness * (0.5 - _a._randValues[_5 * n13 + i15]) * 2 / 3, h7 = this._graphicOriginY + s12 + this._stepY * this._randomness * (0.5 - _a._randValues[_5 * n13 + i15 + 1]) * 2 / 3;
      } else
        e14 = this._graphicOriginX + this._cosAngle * t15 + this._sinAngle * s12, h7 = this._graphicOriginY - this._sinAngle * t15 + this._cosAngle * s12;
      if (!this._testInsidePolygon || this._isInsidePolygon(e14, h7, this._geometryCursor))
        return this._internalPlacement.setTranslate(e14, h7), this._internalPlacement;
    }
  }
  _isInsidePolygon(t15, s12, i15) {
    if (null == this._accelerationMap)
      return o4(t15, s12, i15);
    t15 += _2, s12 += _2;
    const e14 = this._verticalSubdivision, h7 = e14 ? s12 : t15, n18 = Math.floor((h7 - this._polygonMin) / this._delta), r17 = this._accelerationMap.get(n18);
    if (!r17)
      return false;
    let a12, l12, f9, c5 = 0;
    for (const _5 of r17) {
      if (a12 = _5[0], l12 = _5[1], e14) {
        if (a12[1] > s12 == l12[1] > s12)
          continue;
        f9 = (l12[0] - a12[0]) * (s12 - a12[1]) - (l12[1] - a12[1]) * (t15 - a12[0]);
      } else {
        if (a12[0] > t15 == l12[0] > t15)
          continue;
        f9 = (l12[1] - a12[1]) * (t15 - a12[0]) - (l12[0] - a12[0]) * (s12 - a12[1]);
      }
      f9 > 0 ? c5++ : c5--;
    }
    return 0 !== c5;
  }
};
function o4(t15, s12, i15) {
  let e14, h7, n18, r17, a12 = 0;
  for (t15 += _2, s12 += _2, i15.reset(); i15.nextPath(); )
    if (i15.nextPoint())
      for (e14 = i15.x, h7 = i15.y; i15.nextPoint(); e14 = n18, h7 = r17) {
        if (n18 = i15.x, r17 = i15.y, h7 > s12 == r17 > s12)
          continue;
        (n18 - e14) * (s12 - h7) - (r17 - h7) * (t15 - e14) > 0 ? a12++ : a12--;
      }
  return 0 !== a12;
}
function l8(t15, s12, i15, e14, h7, n18) {
  let _5 = n18.get(t15);
  _5 || (_5 = [], n18.set(t15, _5)), _5.push([[s12, i15], [e14, h7]]);
}

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnLine.js
var i9 = 1e-3;
var s8 = class _s {
  static local() {
    return null === _s.instance && (_s.instance = new _s()), _s.instance;
  }
  execute(e14, t15, n18, i15, s12) {
    return new r13(e14, t15, n18);
  }
};
s8.instance = null;
var r13 = class extends s4 {
  constructor(e14, n18, s12) {
    super(e14), this._curveHelper = new s5(), this._angleToLine = void 0 === n18.angleToLine || n18.angleToLine, this._offset = void 0 !== n18.offset ? n18.offset * s12 : 0, this._relativeTo = n18.relativeTo, this._position = void 0 !== n18.startPointOffset ? n18.startPointOffset * s12 : 0, this._epsilon = i9 * s12;
  }
  processPath(e14) {
    const t15 = this._position;
    if (this._relativeTo === Z.SegmentMidpoint) {
      if (this.iteratePath || (this.iteratePath = true), e14.nextPoint()) {
        let [t16, n18] = [e14.x, e14.y], [i16, s12] = [0, 0];
        for (; e14.nextPoint(); ) {
          i16 = e14.x, s12 = e14.y;
          const r17 = this._curveHelper.getLength(t16, n18, i16, s12);
          if (r17 < this._epsilon) {
            t16 = i16, n18 = s12;
            continue;
          }
          const o8 = 0.5 + this._position / r17, [a12, l12] = this._curveHelper.getAngleCS(t16, n18, i16, s12, o8), h7 = this._curveHelper.getCoord2D(t16, n18, i16, s12, o8);
          return this.internalPlacement.setTranslate(h7[0] - this._offset * l12, h7[1] + this._offset * a12), this._angleToLine && this.internalPlacement.setRotateCS(a12, l12), this.internalPlacement;
        }
      }
      return this.iteratePath = false, null;
    }
    const i15 = this._relativeTo === Z.LineEnd;
    return this.onLine(e14, t15, i15);
  }
  onLine(e14, t15, i15) {
    let s12, r17 = false;
    switch (this._relativeTo) {
      case Z.LineMiddle:
      default:
        e14.seekPathStart(), s12 = e14.pathLength() / 2 + t15;
        break;
      case Z.LineBeginning:
        s12 = t15;
        break;
      case Z.LineEnd:
        s12 = t15, r17 = true;
    }
    i15 ? e14.seekPathEnd() : e14.seekPathStart();
    let o8 = 0;
    if (i15 ? e14.prevPoint() : e14.nextPoint()) {
      let [t16, n18] = [e14.x, e14.y], [a12, l12] = [0, 0];
      for (; i15 ? e14.prevPoint() : e14.nextPoint(); ) {
        a12 = e14.x, l12 = e14.y;
        const i16 = this._curveHelper.getLength(t16, n18, a12, l12);
        if (o8 + i16 > s12) {
          const e15 = (s12 - o8) / i16, [h7, c5] = this._curveHelper.getAngleCS(t16, n18, a12, l12, e15), f9 = this._curveHelper.getCoord2D(t16, n18, a12, l12, e15), u11 = r17 ? -this._offset : this._offset;
          return this.internalPlacement.setTranslate(f9[0] - u11 * c5, f9[1] + u11 * h7), this._angleToLine && (r17 ? this.internalPlacement.setRotateCS(-h7, -c5) : this.internalPlacement.setRotateCS(h7, c5)), this.internalPlacement;
        }
        t16 = a12, n18 = l12, o8 += i16;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnVertices.js
var s9 = 1e-15;
var i10 = class _i {
  static local() {
    return null === _i.instance && (_i.instance = new _i()), _i.instance;
  }
  execute(t15, e14, s12, i15, o8) {
    return new n14(t15, e14, s12);
  }
};
i10.instance = null;
var n14 = class extends s4 {
  constructor(t15, s12, i15) {
    super(t15), this._curveHelper = new s5(), this._angleToLine = void 0 === s12.angleToLine || s12.angleToLine, this._offset = void 0 !== s12.offset ? s12.offset * i15 : 0, this._endPoints = void 0 === s12.placeOnEndPoints || s12.placeOnEndPoints, this._controlPoints = void 0 === s12.placeOnControlPoints || s12.placeOnControlPoints, this._regularVertices = void 0 === s12.placeOnRegularVertices || s12.placeOnRegularVertices, this._tags = [], this._tagIterator = 0;
  }
  processPath(t15) {
    if (this.iteratePath || (this._preparePath(t15), this.iteratePath = true), this._tagIterator >= this._tags.length)
      return this._tags.length = 0, this._tagIterator = 0, this.iteratePath = false, null;
    const e14 = this._tags[this._tagIterator];
    this._angleToLine && this.internalPlacement.setRotate(e14[2]);
    let s12 = e14[0], i15 = e14[1];
    if (0 !== this._offset) {
      const t16 = Math.cos(e14[2]), n18 = Math.sin(e14[2]);
      s12 -= this._offset * n18, i15 += this._offset * t16;
    }
    return this.internalPlacement.setTranslate(s12, i15), this._tagIterator++, this.internalPlacement;
  }
  _preparePath(t15) {
    this._tags.length = 0, this._tagIterator = 0, t15.seekPathStart();
    const e14 = t15.isClosed();
    let s12 = 0, i15 = false, n18 = 0, r17 = 0;
    if (t15.seekPathStart(), t15.nextPoint()) {
      let a12 = t15.x, h7 = t15.y, l12 = t15.getControlPoint(), _5 = true, c5 = t15.nextPoint();
      for (; c5; ) {
        const g4 = t15.x, P5 = t15.y, u11 = t15.getControlPoint();
        (this._angleToLine || 0 !== this._offset) && (n18 = this._curveHelper.getAngle(a12, h7, g4, P5, 0)), _5 ? (_5 = false, e14 ? (s12 = n18, i15 = l12) : (this._endPoints || this._controlPoints && l12) && this._tags.push([a12, h7, n18])) : l12 ? this._controlPoints && this._tags.push([a12, h7, o5(r17, n18)]) : this._regularVertices && this._tags.push([a12, h7, o5(r17, n18)]), (this._angleToLine || 0 !== this._offset) && (r17 = this._curveHelper.getAngle(a12, h7, g4, P5, 1)), c5 = t15.nextPoint(), c5 || (e14 ? u11 || i15 ? this._controlPoints && this._tags.push([g4, P5, o5(r17, s12)]) : this._regularVertices && this._tags.push([g4, P5, o5(r17, s12)]) : (this._endPoints || this._controlPoints && u11) && this._tags.push([g4, P5, r17])), a12 = g4, h7 = P5, l12 = u11;
      }
    }
    this._tagIterator = 0;
  }
};
function o5(t15, e14) {
  const i15 = Math.PI;
  for (; Math.abs(e14 - t15) > i15 + 2 * s9; )
    e14 - t15 > i15 ? e14 -= 2 * i15 : e14 += 2 * i15;
  return (t15 + e14) / 2;
}

// node_modules/@arcgis/core/geometry/support/labelPoint.js
var N2 = 100 * 222045e-21;
function l10(t15) {
  if (0 === t15.totalSize)
    return null;
  const a12 = c(t15);
  if (!a12)
    return null;
  const o8 = 4 * (Math.abs(a12[0]) + Math.abs(a12[2]) + Math.abs(a12[1]) + Math.abs(a12[3]) + 1) * N2;
  let s12 = 0, c5 = 0;
  t15.reset();
  for (let e14 = 0; t15.nextPath(); e14++) {
    const n18 = t15.getCurrentRingArea();
    n18 > c5 && (c5 = n18, s12 = e14);
  }
  if (t15.seekPath(s12), 0 === t15.pathSize)
    return null;
  t15.seekPathStart();
  const l12 = f5(t15);
  if (Math.abs(c5) <= 2 * o8 * o8)
    return [(l12[0] + l12[2]) / 2, (l12[1] + l12[3]) / 2];
  t15.seekPathStart();
  const x4 = i(t15, u());
  if (null === x4)
    return null;
  if (t15.totalPoints < 4)
    return x4;
  const m7 = [[NaN, NaN], [NaN, NaN], [NaN, NaN], [NaN, NaN]], d4 = [NaN, NaN, NaN, NaN], P5 = [NaN, NaN, NaN, NaN];
  let y5 = false, M4 = f8(x4, t15, true);
  0 === M4.distance && (y5 = true, m7[0][0] = x4[0], m7[0][1] = x4[1], M4 = f8(x4, t15, false)), d4[0] = M4.distance, P5[0] = 0;
  const b3 = [NaN, NaN];
  let S3 = false, k3 = 0.25, z2 = -1, g4 = NaN;
  do {
    if (g4 = NaN, m7[1] = h6(t15, w3(l12[0], l12[2], k3), o8, a12), isNaN(m7[1][0]) || isNaN(m7[1][1]) || (M4 = f8(m7[1], t15, false), g4 = M4.distance), !isNaN(g4) && g4 > o8 && u9(m7[1], t15))
      S3 = true, d4[1] = g4, P5[1] = p3(m7[1], x4);
    else if (!isNaN(g4) && g4 > z2 && (z2 = g4, b3[0] = m7[1][0], b3[1] = m7[1][1]), k3 -= 0.01, k3 < 0.1) {
      if (!(z2 >= 0))
        break;
      S3 = true, d4[1] = z2, m7[1][0] = b3[0], m7[1][1] = b3[1], P5[1] = p3(m7[1], x4);
    }
  } while (!S3);
  S3 = false, k3 = 0.5, z2 = -1;
  let q3 = 0.01, j3 = 1;
  do {
    if (g4 = NaN, m7[2] = h6(t15, w3(l12[0], l12[2], k3), o8, a12), isNaN(m7[2][0]) || isNaN(m7[2][1]) || (M4 = f8(m7[2], t15, false), g4 = M4.distance), !isNaN(g4) && g4 > o8 && u9(m7[2], t15))
      S3 = true, d4[2] = g4, P5[2] = p3(m7[2], x4);
    else if (!isNaN(g4) && g4 > z2)
      z2 = g4, b3[0] = m7[2][0], b3[1] = m7[2][1];
    else if (g4 > z2 && (z2 = g4, b3[0] = m7[2][0], b3[1] = m7[2][1]), k3 = 0.5 + q3 * j3, q3 += 0.01, j3 *= -1, k3 < 0.3 || k3 > 0.7) {
      if (!(z2 >= 0))
        break;
      S3 = true, d4[2] = z2, m7[2][0] = b3[0], m7[2][1] = b3[1], P5[2] = p3(m7[2], x4);
    }
  } while (!S3);
  S3 = false, k3 = 0.75, z2 = -1;
  do {
    if (g4 = NaN, m7[3] = h6(t15, w3(l12[0], l12[2], k3), o8, a12), isNaN(m7[3][0]) || isNaN(m7[3][1]) || (M4 = f8(m7[3], t15, false), g4 = M4.distance), !isNaN(g4) && g4 > o8 && u9(m7[3], t15))
      S3 = true, d4[3] = g4, P5[3] = p3(m7[3], x4);
    else if (g4 > z2 && (z2 = g4, b3[0] = m7[3][0], b3[1] = m7[3][1]), k3 += 0.01, k3 > 0.9) {
      if (!(z2 >= 0))
        break;
      S3 = true, d4[3] = z2, m7[3][0] = b3[0], m7[3][1] = b3[1], P5[3] = p3(m7[3], x4);
    }
  } while (!S3);
  const T3 = [0, 1, 2, 3], D = y5 ? 0 : 1;
  let R3;
  for (let e14 = D; e14 < 4; e14++)
    for (let t16 = D; t16 < 3; t16++) {
      const e15 = P5[t16], n18 = P5[t16 + 1];
      C4(e15, n18) > 0 && (R3 = T3[t16], T3[t16] = T3[t16 + 1], T3[t16 + 1] = R3, P5[t16] = n18, P5[t16 + 1] = e15);
    }
  let B4 = D, Q3 = 0, U4 = 0;
  for (let e14 = D; e14 < 4; e14++) {
    switch (e14) {
      case 0:
        U4 = 2 * d4[T3[e14]];
        break;
      case 1:
        U4 = 1.66666666 * d4[T3[e14]];
        break;
      case 2:
        U4 = 1.33333333 * d4[T3[e14]];
        break;
      case 3:
        U4 = d4[T3[e14]];
    }
    U4 > Q3 && (Q3 = U4, B4 = T3[e14]);
  }
  return m7[B4];
}
function u9(t15, e14) {
  let n18, i15, r17, a12, o8 = 0;
  for (e14.reset(); e14.nextPath() && e14.nextPoint(); )
    for (n18 = e14.x, i15 = e14.y; e14.nextPoint(); n18 = r17, i15 = a12) {
      if (r17 = e14.x, a12 = e14.y, i15 > t15[1] == a12 > t15[1])
        continue;
      (r17 - n18) * (t15[1] - i15) - (a12 - i15) * (t15[0] - n18) > 0 ? o8++ : o8--;
    }
  return 0 !== o8;
}
function f8(t15, e14, n18) {
  if (n18 && u9(t15, e14))
    return { coord: t15, distance: 0 };
  let i15 = 1 / 0, r17 = 0, a12 = 0, s12 = [0, 0], c5 = [0, 0];
  const N5 = [0, 0];
  for (e14.reset(); e14.nextPath() && e14.nextPoint(); )
    if (!(e14.pathSize < 2))
      for (s12[0] = e14.x, s12[1] = e14.y; e14.nextPoint(); s12 = c5) {
        c5 = [e14.x, e14.y], f2(N5, t15, s12, c5);
        const n19 = p3(t15, N5);
        n19 < i15 && (i15 = n19, r17 = N5[0], a12 = N5[1]);
      }
  return { coord: [r17, a12], distance: Math.sqrt(i15) };
}
function h6(t15, n18, i15, r17) {
  const a12 = [n18, 0];
  let o8 = 1 / 0, s12 = 1 / 0, N5 = false, l12 = false;
  const u11 = [[n18, r17[1] - 1], [n18, r17[3] + 1]], f9 = [0, 0], h7 = [0, 0], m7 = [0, 0], d4 = [[0, 0], [0, 0]], P5 = u();
  for (t15.reset(); t15.nextPath() && t15.nextPoint(); )
    if (!(t15.pathSize < 2))
      for (d4[0][0] = t15.x, d4[0][1] = t15.y; t15.nextPoint(); d4[0][0] = d4[1][0], d4[0][1] = d4[1][1]) {
        if (d4[1][0] = t15.x, d4[1][1] = t15.y, null === x2(P5, d4))
          continue;
        if (h7[0] = u11[0][0], h7[1] = u11[0][1], m7[0] = u11[1][0], m7[1] = u11[1][1], 0 === M2(P5, h7, m7))
          continue;
        if (!G(u11[0], u11[1], d4[0], d4[1], f9))
          continue;
        const e14 = f9[1];
        o8 > s12 ? e14 < o8 && (o8 = e14, N5 = true) : e14 < s12 && (s12 = e14, l12 = true);
      }
  return N5 && l12 ? a12[1] = (o8 + s12) / 2 : a12[0] = a12[1] = NaN, a12;
}
function x2(t15, n18) {
  if (n18.length < 2)
    return null;
  t15 || (t15 = u());
  const [i15, r17] = n18[0], [a12, o8] = n18[1];
  return t15[0] = Math.min(i15, a12), t15[1] = Math.min(r17, o8), t15[2] = Math.max(i15, a12), t15[3] = Math.max(r17, o8), t15;
}
var m6 = 1;
var d3 = 4;
var P4 = 3;
var y3 = 12;
function M2(t15, e14, n18) {
  let i15 = b(e14, t15), r17 = b(n18, t15);
  const a12 = t15[0], o8 = t15[1], s12 = t15[2], c5 = t15[3];
  if (i15 & r17)
    return 0;
  if (!(i15 | r17))
    return 4;
  const N5 = (i15 ? 1 : 0) | (r17 ? 2 : 0);
  do {
    const N6 = n18[0] - e14[0], l12 = n18[1] - e14[1];
    if (N6 > l12)
      i15 & P4 ? (i15 & m6 ? (e14[1] += l12 * (a12 - e14[0]) / N6, e14[0] = a12) : (e14[1] += l12 * (s12 - e14[0]) / N6, e14[0] = s12), i15 = b(e14, t15)) : r17 & P4 ? (r17 & m6 ? (n18[1] += l12 * (a12 - n18[0]) / N6, n18[0] = a12) : (n18[1] += l12 * (s12 - n18[0]) / N6, n18[0] = s12), r17 = b(n18, t15)) : i15 ? (i15 & d3 ? (e14[0] += N6 * (o8 - e14[1]) / l12, e14[1] = o8) : (e14[0] += N6 * (c5 - e14[1]) / l12, e14[1] = c5), i15 = b(e14, t15)) : (r17 & d3 ? (n18[0] += N6 * (o8 - n18[1]) / l12, n18[1] = o8) : (n18[0] += N6 * (c5 - n18[1]) / l12, n18[1] = c5), r17 = b(n18, t15));
    else if (i15 & y3 ? (i15 & d3 ? (e14[0] += N6 * (o8 - e14[1]) / l12, e14[1] = o8) : (e14[0] += N6 * (c5 - e14[1]) / l12, e14[1] = c5), i15 = b(e14, t15)) : r17 & y3 ? (r17 & d3 ? (n18[0] += N6 * (o8 - n18[1]) / l12, n18[1] = o8) : (n18[0] += N6 * (c5 - n18[1]) / l12, n18[1] = c5), r17 = b(n18, t15)) : i15 ? (i15 & m6 ? (e14[1] += l12 * (a12 - e14[0]) / N6, e14[0] = a12) : (e14[1] += l12 * (s12 - e14[0]) / N6, e14[0] = s12), i15 = b(e14, t15)) : (r17 & m6 ? (n18[1] += l12 * (a12 - n18[0]) / N6, n18[0] = a12) : (n18[1] += l12 * (s12 - n18[0]) / N6, n18[0] = s12), r17 = b(n18, t15)), i15 & r17)
      return 0;
  } while (i15 | r17);
  return N5;
}
function b(t15, e14) {
  return (t15[0] < e14[0] ? 1 : 0) | (t15[0] > e14[2] ? 1 : 0) << 1 | (t15[1] < e14[1] ? 1 : 0) << 2 | (t15[1] > e14[3] ? 1 : 0) << 3;
}
function w3(t15, e14, n18) {
  return t15 + (e14 - t15) * n18;
}
function p3(t15, e14) {
  return (t15[0] - e14[0]) * (t15[0] - e14[0]) + (t15[1] - e14[1]) * (t15[1] - e14[1]);
}
function C4(t15, e14) {
  if (t15 < e14)
    return -1;
  if (t15 > e14)
    return 1;
  if (t15 === e14)
    return 0;
  const n18 = isNaN(t15), i15 = isNaN(e14);
  return n18 < i15 ? -1 : n18 > i15 ? 1 : 0;
}

// node_modules/@arcgis/core/symbols/cim/placements/PlacementPolygonCenter.js
var r14 = class _r {
  static local() {
    return null === _r.instance && (_r.instance = new _r()), _r.instance;
  }
  execute(t15, e14, s12, n18, o8) {
    return new i11(t15, e14, s12);
  }
};
r14.instance = null;
var i11 = class {
  constructor(t15, e14, s12) {
    this._geometryCursor = t15, this._offsetX = void 0 !== e14.offsetX ? e14.offsetX * s12 : 0, this._offsetY = void 0 !== e14.offsetY ? e14.offsetY * s12 : 0, this._method = void 0 !== e14.method ? e14.method : K.OnPolygon, this._internalPlacement = new t7();
  }
  next() {
    const t15 = this._geometryCursor;
    return this._geometryCursor = null, t15 ? this._polygonCenter(t15) : null;
  }
  _polygonCenter(n18) {
    let r17 = false;
    switch (this._method) {
      case K.CenterOfMass:
        {
          const t15 = f3(n18);
          t15 && (this._internalPlacement.setTranslate(t15[0] + this._offsetX, t15[1] + this._offsetY), r17 = true);
        }
        break;
      case K.BoundingBoxCenter:
        {
          const e14 = c(n18);
          e14 && (this._internalPlacement.setTranslate((e14[2] + e14[0]) / 2 + this._offsetX, (e14[3] + e14[1]) / 2 + this._offsetY), r17 = true);
        }
        break;
      case K.OnPolygon:
      default: {
        const t15 = l10(n18);
        null !== t15 && (this._internalPlacement.setTranslate(t15[0] + this._offsetX, t15[1] + this._offsetY), r17 = true);
      }
    }
    return r17 ? this._internalPlacement : null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/alignmentUtils.js
var t11 = () => n.getLogger("esri.views.2d.engine.webgl.alignmentUtils");
var r15;
var n15;
function a11(e14) {
  if (!e14)
    return r15.Center;
  switch (e14) {
    case "Left":
    case "left":
      return r15.Left;
    case "Right":
    case "right":
      return r15.Right;
    case "Justify":
      return t11().warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."), r15.Center;
    case "Center":
    case "center":
      return r15.Center;
  }
}
function c4(e14) {
  if (!e14)
    return n15.Center;
  switch (e14) {
    case "Top":
    case "top":
      return n15.Top;
    case "Center":
    case "middle":
      return n15.Center;
    case "Baseline":
    case "baseline":
      return n15.Baseline;
    case "Bottom":
    case "bottom":
      return n15.Bottom;
  }
}
function o6(e14) {
  switch (e14) {
    case "above-left":
    case "esriServerPointLabelPlacementAboveLeft":
      return ["right", "bottom"];
    case "above-center":
    case "above-along":
    case "esriServerPointLabelPlacementAboveCenter":
    case "esriServerLinePlacementAboveAlong":
      return ["center", "bottom"];
    case "above-right":
    case "esriServerPointLabelPlacementAboveRight":
      return ["left", "bottom"];
    case "center-left":
    case "esriServerPointLabelPlacementCenterLeft":
      return ["right", "middle"];
    case "center-center":
    case "center-along":
    case "esriServerPointLabelPlacementCenterCenter":
    case "esriServerLinePlacementCenterAlong":
    case "always-horizontal":
    case "esriServerPolygonPlacementAlwaysHorizontal":
      return ["center", "middle"];
    case "center-right":
    case "esriServerPointLabelPlacementCenterRight":
      return ["left", "middle"];
    case "below-left":
    case "esriServerPointLabelPlacementBelowLeft":
      return ["right", "top"];
    case "below-center":
    case "below-along":
    case "esriServerPointLabelPlacementBelowCenter":
    case "esriServerLinePlacementBelowAlong":
      return ["center", "top"];
    case "below-right":
    case "esriServerPointLabelPlacementBelowRight":
      return ["left", "top"];
    default:
      return console.debug(`Found invalid placement type ${e14}`), ["center", "middle"];
  }
}
function s10(e14) {
  switch (e14) {
    case r15.Right:
    case "right":
      return -1;
    case r15.Center:
    case "center":
      return 0;
    case r15.Left:
    case "left":
      return 1;
    default:
      return console.debug(`Found invalid horizontal alignment ${e14}`), 0;
  }
}
function i12(e14) {
  switch (e14) {
    case n15.Top:
    case "top":
      return 1;
    case n15.Center:
    case "middle":
      return 0;
    case n15.Bottom:
    case n15.Baseline:
    case "baseline":
    case "bottom":
      return -1;
    default:
      return console.debug(`Found invalid vertical alignment ${e14}`), 0;
  }
}
!function(e14) {
  e14[e14.Left = -1] = "Left", e14[e14.Center = 0] = "Center", e14[e14.Right = 1] = "Right";
}(r15 || (r15 = {})), function(e14) {
  e14[e14.Top = 1] = "Top", e14[e14.Center = 0] = "Center", e14[e14.Bottom = -1] = "Bottom", e14[e14.Baseline = 2] = "Baseline";
}(n15 || (n15 = {}));

// node_modules/@arcgis/core/symbols/cim/CIMImageColorSubstitutionHelper.js
var t12 = class {
  applyColorSubstituition(t15, a12) {
    if (!a12)
      return t15;
    this._rasterizationCanvas || (this._rasterizationCanvas = document.createElement("canvas"));
    const { width: e14, height: n18 } = t15, o8 = this._rasterizationCanvas, r17 = o8.getContext("2d", { willReadFrequently: true });
    t15 !== o8 && (o8.width = e14, o8.height = n18, r17.drawImage(t15, 0, 0, e14, n18));
    const i15 = r17.getImageData(0, 0, e14, n18).data;
    if (a12) {
      for (const l12 of a12)
        if (l12 && l12.oldColor && 4 === l12.oldColor.length && l12.newColor && 4 === l12.newColor.length) {
          const [t16, a13, e15, n19] = l12.oldColor, [o9, r18, s13, h7] = l12.newColor;
          if (t16 === o9 && a13 === r18 && e15 === s13 && n19 === h7)
            continue;
          for (let l13 = 0; l13 < i15.length; l13 += 4)
            t16 === i15[l13] && a13 === i15[l13 + 1] && e15 === i15[l13 + 2] && n19 === i15[l13 + 3] && (i15[l13] = o9, i15[l13 + 1] = r18, i15[l13 + 2] = s13, i15[l13 + 3] = h7);
        }
    }
    const s12 = new ImageData(i15, e14, n18);
    return r17.putImageData(s12, 0, 0), o8;
  }
  tintImageData(t15, a12) {
    if (!a12 || a12.length < 4)
      return t15;
    this._rasterizationCanvas || (this._rasterizationCanvas = document.createElement("canvas"));
    const { width: e14, height: n18 } = t15, o8 = this._rasterizationCanvas, r17 = o8.getContext("2d", { willReadFrequently: true });
    t15 !== o8 && (o8.width = e14, o8.height = n18, r17.drawImage(t15, 0, 0, e14, n18));
    const i15 = r17.getImageData(0, 0, e14, n18), s12 = new Uint8Array(i15.data), l12 = [a12[0] / 255, a12[1] / 255, a12[2] / 255, a12[3] / 255];
    for (let g4 = 0; g4 < s12.length; g4 += 4)
      s12[g4] *= l12[0], s12[g4 + 1] *= l12[1], s12[g4 + 2] *= l12[2], s12[g4 + 3] *= l12[3];
    const h7 = new ImageData(new Uint8ClampedArray(s12.buffer), e14, n18);
    return r17.putImageData(h7, 0, 0), o8;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMOperators.js
function A3(p5) {
  if (!p5)
    return null;
  switch (p5.type) {
    case "CIMGeometricEffectAddControlPoints":
      return e6.local();
    case "CIMGeometricEffectArrow":
      return p2.local();
    case "CIMGeometricEffectBuffer":
      return m5.local();
    case "CIMGeometricEffectControlMeasureLine":
      return e7.local();
    case "CIMGeometricEffectCut":
      return r5.local();
    case "CIMGeometricEffectDashes":
      return h3.local();
    case "CIMGeometricEffectDonut":
      return s7.local();
    case "CIMGeometricEffectJog":
      return e8.local();
    case "CIMGeometricEffectMove":
      return t8.local();
    case "CIMGeometricEffectOffset":
      return h4.local();
    case "CIMGeometricEffectReverse":
      return e10.local();
    case "CIMGeometricEffectRotate":
      return e11.local();
    case "CIMGeometricEffectScale":
      return e12.local();
    case "CIMGeometricEffectWave":
      return n11.local();
  }
  return null;
}
function g3(e14) {
  if (!e14)
    return null;
  switch (e14.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
      return a8.local();
    case "CIMMarkerPlacementAtExtremities":
      return i8.local();
    case "CIMMarkerPlacementAtRatioPositions":
      return a9.local();
    case "CIMMarkerPlacementInsidePolygon":
      return r12.local();
    case "CIMMarkerPlacementOnLine":
      return s8.local();
    case "CIMMarkerPlacementOnVertices":
      return i10.local();
    case "CIMMarkerPlacementPolygonCenter":
      return r14.local();
  }
  return null;
}

// node_modules/@arcgis/core/symbols/cim/imageUtils.js
function t13(t15) {
  const e14 = t15.getFrame(0);
  if (e14 instanceof HTMLImageElement || e14 instanceof HTMLCanvasElement)
    return e14;
  const n18 = document.createElement("canvas");
  n18.width = t15.width, n18.height = t15.height;
  const a12 = n18.getContext("2d");
  return e14 instanceof ImageData ? a12.putImageData(e14, 0, 0) : a12.drawImage(e14, 0, 0), n18;
}

// node_modules/@arcgis/core/symbols/cim/Rect.js
var t14 = class _t {
  constructor(t15 = 0, h7 = 0, i15 = 0, s12 = 0) {
    this.x = t15, this.y = h7, this.width = i15, this.height = s12;
  }
  static fromExtent(h7) {
    return new _t(h7.xmin, -h7.ymax, h7.xmax - h7.xmin, h7.ymax - h7.ymin);
  }
  get isEmpty() {
    return this.width <= 0 || this.height <= 0;
  }
  union(t15) {
    this.x = Math.min(this.x, t15.x), this.y = Math.min(this.y, t15.y), this.width = Math.max(this.width, t15.width), this.height = Math.max(this.height, t15.height);
  }
};

// node_modules/@arcgis/core/symbols/cim/TextRasterizer.js
function i13(t15) {
  return `rgb(${t15.slice(0, 3).toString()})`;
}
function s11(t15) {
  return `rgba(${t15.slice(0, 3).toString()},${t15[3]})`;
}
var n16 = class {
  constructor(t15) {
    t15 && (this._textRasterizationCanvas = t15);
  }
  rasterizeText(n18, h7) {
    var _a, _b;
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const a12 = this._textRasterizationCanvas, l12 = a12.getContext("2d", { willReadFrequently: true });
    r16(l12, h7), this._parameters = h7, this._textLines = n18.split(/\r?\n/), this._lineHeight = this._computeLineHeight();
    const { decoration: d4, weight: c5 } = h7.font;
    this._lineThroughWidthOffset = d4 && "line-through" === d4 ? 0.1 * this._lineHeight : 0;
    const g4 = null != h7.backgroundColor || null != h7.borderLine, _5 = g4 ? s2 : 0, f9 = this._computeTextWidth(l12, h7) + 2 * _5, u11 = this._lineHeight * this._textLines.length + 2 * _5;
    if (a12.width = f9 + 2 * this._lineThroughWidthOffset, a12.height = u11, 0 === a12.width || 0 === a12.height)
      return a12.width = a12.height = 1, { size: [0, 0], image: new Uint32Array(0), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0, canvas: a12 };
    this._renderedLineHeight = Math.round(this._lineHeight * h7.pixelRatio), this._renderedHaloSize = u3(h7.halo.size) * h7.pixelRatio, this._renderedWidth = f9 * h7.pixelRatio, this._renderedHeight = u11 * h7.pixelRatio, this._lineThroughWidthOffset *= h7.pixelRatio;
    const x4 = h7.color ?? [0, 0, 0, 0], p5 = h7.halo && h7.halo.color ? h7.halo.color : [0, 0, 0, 0];
    this._fillStyle = s11(x4), this._haloStyle = i13(p5);
    const m7 = this._renderedLineHeight, b3 = this._renderedHaloSize;
    l12.save(), l12.clearRect(0, 0, a12.width, a12.height), r16(l12, h7);
    const w5 = _5 * h7.pixelRatio, z2 = o7(l12.textAlign, this._renderedWidth - 2 * w5) + b3 + w5, y5 = b3 + w5, R3 = b3 > 0;
    let v2 = this._lineThroughWidthOffset, H2 = 0;
    if (g4) {
      l12.save();
      const e14 = h7.backgroundColor ?? [0, 0, 0, 0], i15 = ((_a = h7.borderLine) == null ? void 0 : _a.color) ?? [0, 0, 0, 0], n19 = 2 * u3(((_b = h7.borderLine) == null ? void 0 : _b.size) ?? 0);
      l12.fillStyle = s11(e14), l12.strokeStyle = s11(i15), l12.lineWidth = n19, l12.fillRect(0, 0, a12.width, a12.height), l12.strokeRect(0, 0, a12.width, a12.height), l12.restore();
    }
    R3 && this._renderHalo(l12, z2, y5, v2, H2, h7), H2 += y5, v2 += z2;
    for (const t15 of this._textLines)
      R3 ? (l12.globalCompositeOperation = "destination-out", l12.fillStyle = "rgb(0, 0, 0)", l12.fillText(t15, v2, H2), l12.globalCompositeOperation = "source-over", l12.fillStyle = this._fillStyle, l12.fillText(t15, v2, H2)) : (l12.fillStyle = this._fillStyle, l12.fillText(t15, v2, H2)), d4 && "none" !== d4 && this._renderDecoration(l12, v2, H2, d4, c5), H2 += m7;
    l12.restore();
    const S3 = this._renderedWidth + 2 * this._lineThroughWidthOffset, C5 = this._renderedHeight, T3 = l12.getImageData(0, 0, S3, C5), W3 = new Uint8Array(T3.data);
    if (h7.premultiplyColors) {
      let t15;
      for (let e14 = 0; e14 < W3.length; e14 += 4)
        t15 = W3[e14 + 3] / 255, W3[e14] = W3[e14] * t15, W3[e14 + 1] = W3[e14 + 1] * t15, W3[e14 + 2] = W3[e14 + 2] * t15;
    }
    let k3, L3;
    switch (h7.horizontalAlignment) {
      case "left":
        k3 = -0.5;
        break;
      case "right":
        k3 = 0.5;
        break;
      default:
        k3 = 0;
    }
    switch (h7.verticalAlignment) {
      case "bottom":
        L3 = -0.5;
        break;
      case "top":
        L3 = 0.5;
        break;
      case "baseline":
        L3 = -1 / 6;
        break;
      default:
        L3 = 0;
    }
    return { size: [S3, C5], image: new Uint32Array(W3.buffer), sdf: false, simplePattern: false, anchorX: k3, anchorY: L3, canvas: a12 };
  }
  _renderHalo(t15, e14, i15, s12, n18, o8) {
    const h7 = this._renderedWidth, a12 = this._renderedHeight;
    this._haloRasterizationCanvas || (this._haloRasterizationCanvas = document.createElement("canvas")), this._haloRasterizationCanvas.width = h7, this._haloRasterizationCanvas.height = a12;
    const l12 = this._haloRasterizationCanvas, d4 = l12.getContext("2d");
    d4.clearRect(0, 0, h7, a12), r16(d4, o8);
    const { decoration: c5, weight: g4 } = o8.font;
    d4.fillStyle = this._haloStyle, d4.strokeStyle = this._haloStyle, d4.lineJoin = "round", this._renderHaloNative(d4, e14, i15, c5, g4), t15.globalAlpha = this._parameters.halo.color[3], t15.drawImage(l12, 0, 0, h7, a12, s12, n18, h7, a12), t15.globalAlpha = 1;
  }
  _renderHaloNative(t15, e14, i15, s12, n18) {
    const r17 = this._renderedLineHeight, o8 = this._renderedHaloSize;
    for (const h7 of this._textLines) {
      const a12 = 2 * o8, l12 = 5, d4 = 0.1;
      for (let r18 = 0; r18 < l12; r18++) {
        const o9 = (1 - (l12 - 1) * d4 + r18 * d4) * a12;
        t15.lineWidth = o9, t15.strokeText(h7, e14, i15), s12 && "none" !== s12 && this._renderDecoration(t15, e14, i15, s12, n18, o9);
      }
      i15 += r17;
    }
  }
  computeTextSize(t15, e14) {
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const i15 = this._textRasterizationCanvas, s12 = i15.getContext("2d");
    r16(s12, e14), this._parameters = e14, this._textLines = t15.split(/\r?\n/), this._lineHeight = this._computeLineHeight();
    const n18 = this._computeTextWidth(s12, e14), o8 = this._lineHeight * this._textLines.length;
    return i15.width = n18, i15.height = o8, [n18 * e14.pixelRatio, o8 * e14.pixelRatio];
  }
  _computeTextWidth(e14, i15) {
    let s12 = 0;
    for (const t15 of this._textLines)
      s12 = Math.max(s12, e14.measureText(t15).width);
    const n18 = i15.font;
    return ("italic" === n18.style || "oblique" === n18.style || "string" == typeof n18.weight && ("bold" === n18.weight || "bolder" === n18.weight) || "number" == typeof n18.weight && n18.weight > 600) && (s12 += 0.3 * e14.measureText("w").width), s12 += 2 * u3(this._parameters.halo.size), Math.round(s12);
  }
  _computeLineHeight() {
    let e14 = 1.275 * this._parameters.size;
    const i15 = this._parameters.font.decoration;
    return i15 && "underline" === i15 && (e14 *= 1.3), Math.round(e14 + 2 * u3(this._parameters.halo.size));
  }
  _renderDecoration(t15, e14, i15, s12, n18, r17) {
    const o8 = 0.9 * this._lineHeight, h7 = "bold" === n18 ? 0.06 : "bolder" === n18 ? 0.09 : 0.04;
    switch (t15.textAlign) {
      case "center":
        e14 -= this._renderedWidth / 2;
        break;
      case "right":
        e14 -= this._renderedWidth;
    }
    const a12 = t15.textBaseline;
    if ("underline" === s12)
      switch (a12) {
        case "top":
          i15 += o8;
          break;
        case "middle":
          i15 += o8 / 2;
      }
    else if ("line-through" === s12)
      switch (a12) {
        case "top":
          i15 += o8 / 1.5;
          break;
        case "middle":
          i15 += o8 / 3;
      }
    const l12 = r17 ? 1.5 * r17 : Math.ceil(o8 * h7);
    t15.save(), t15.beginPath(), t15.strokeStyle = t15.fillStyle, t15.lineWidth = l12, t15.moveTo(e14 - this._lineThroughWidthOffset, i15), t15.lineTo(e14 + this._renderedWidth + 2 * this._lineThroughWidthOffset, i15), t15.stroke(), t15.restore();
  }
};
function r16(e14, i15) {
  const s12 = Math.max(i15.size, 0.5), n18 = i15.font, r17 = `${n18.style} ${n18.weight} ${u3(s12 * i15.pixelRatio).toFixed(1)}px ${n18.family}, sans-serif`;
  let o8;
  switch (e14.font = r17, e14.textBaseline = "top", i15.horizontalAlignment) {
    case "left":
    default:
      o8 = "left";
      break;
    case "right":
      o8 = "right";
      break;
    case "center":
      o8 = "center";
  }
  e14.textAlign = o8;
}
function o7(t15, e14) {
  return "center" === t15 ? 0.5 * e14 : "right" === t15 ? e14 : 0;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/shapingUtils.js
var _3 = 22;
var l11 = 4;
var u10 = _3 + l11;
var x3 = _3 - 6;
var p4 = 3;
var b2 = Math.PI / 180;
var y4 = 8;
var w4 = 1.5;
var M3 = class {
  constructor(t15, s12, i15, e14) {
    this._rotationT = n3(), this._xBounds = 0, this._yBounds = 0, this.minZoom = 0, this.maxZoom = 255, this._bounds = null;
    const h7 = i15.rect, n18 = new Float32Array(8);
    t15 *= e14, s12 *= e14;
    const r17 = i15.code ? h7.width * e14 : i15.metrics.width, a12 = i15.code ? h7.height * e14 : i15.metrics.height;
    this.width = r17, this.height = a12, n18[0] = t15, n18[1] = s12, n18[2] = t15 + r17, n18[3] = s12, n18[4] = t15, n18[5] = s12 + a12, n18[6] = t15 + r17, n18[7] = s12 + a12, this._data = n18, this._setTextureCoords(h7), this._scale = e14, this._mosaic = i15, this.x = t15, this.y = s12, this.maxOffset = Math.max(t15 + r17, s12 + a12);
  }
  get mosaic() {
    return this._mosaic;
  }
  set angle(s12) {
    this._angle = s12, M(this._rotationT, -s12), this._setOffsets();
  }
  get angle() {
    return this._angle;
  }
  get xTopLeft() {
    return this._data[0];
  }
  get yTopLeft() {
    return this._data[1];
  }
  get xBottomRight() {
    return this._data[6];
  }
  get yBottomRight() {
    return this._data[7];
  }
  get texcoords() {
    return this._texcoords;
  }
  get textureBinding() {
    return this._mosaic.textureBinding;
  }
  get offsets() {
    return this._offsets || this._setOffsets(), this._offsets;
  }
  get char() {
    return String.fromCharCode(this._mosaic.code);
  }
  get code() {
    return this._mosaic.code;
  }
  get bounds() {
    if (!this._bounds) {
      const { height: t15, width: i15 } = this._mosaic.metrics, e14 = i15 * this._scale, n18 = Math.abs(t15) * this._scale, r17 = new Float32Array(8);
      r17[0] = this.x, r17[1] = this.y, r17[2] = this.x + e14, r17[3] = this.y, r17[4] = this.x, r17[5] = this.y + n18, r17[6] = this.x + e14, r17[7] = this.y + n18;
      const a12 = e5(n3(), this._rotationT, this._transform);
      a5(r17, r17, a12);
      let f9 = 1 / 0, c5 = 1 / 0, m7 = 0, d4 = 0;
      for (let s12 = 0; s12 < 4; s12++) {
        const t16 = r17[2 * s12], i16 = r17[2 * s12 + 1];
        f9 = Math.min(f9, t16), c5 = Math.min(c5, i16), m7 = Math.max(m7, t16), d4 = Math.max(d4, i16);
      }
      const _5 = m7 - f9, l12 = d4 - c5, u11 = f9 + _5 / 2, x4 = c5 + l12 / 2;
      this._bounds = new i4(u11, x4, _5, l12);
    }
    return this._bounds;
  }
  setTransform(t15) {
    this._transform = t15, this._offsets = null;
  }
  _setOffsets() {
    this._offsets || (this._offsets = { topLeft: [0, 0], topRight: [0, 0], bottomLeft: [0, 0], bottomRight: [0, 0] });
    const t15 = e5(n3(), this._rotationT, this._transform);
    this._offsets.topLeft[0] = this._data[0], this._offsets.topLeft[1] = this._data[1], this._offsets.topRight[0] = this._data[2], this._offsets.topRight[1] = this._data[3], this._offsets.bottomLeft[0] = this._data[4], this._offsets.bottomLeft[1] = this._data[5], this._offsets.bottomRight[0] = this._data[6], this._offsets.bottomRight[1] = this._data[7], S2(this._offsets.topLeft, this._offsets.topLeft, t15), S2(this._offsets.topRight, this._offsets.topRight, t15), S2(this._offsets.bottomLeft, this._offsets.bottomLeft, t15), S2(this._offsets.bottomRight, this._offsets.bottomRight, t15);
  }
  _setTextureCoords({ x: t15, y: s12, width: i15, height: e14 }) {
    this._texcoords = { topLeft: [t15, s12], topRight: [t15 + i15, s12], bottomLeft: [t15, s12 + e14], bottomRight: [t15 + i15, s12 + e14] };
  }
};
var L2 = (t15, s12) => ({ code: 0, page: 0, sdf: true, rect: new t5(0, 0, 11, 8), textureBinding: s12, metrics: { advance: 0, height: 4, width: t15, left: 0, top: 0 } });
function R2(t15, s12) {
  return t15.forEach((t16) => S2(t16, t16, s12)), { topLeft: t15[0], topRight: t15[1], bottomLeft: t15[2], bottomRight: t15[3] };
}
var B3 = class {
  constructor(t15, s12, i15) {
    this._rotation = 0, this._decorate(t15, s12, i15), this.glyphs = t15, this.bounds = this._createBounds(t15), this.isMultiline = s12.length > 1, this._hasRotation = 0 !== i15.angle, this._transform = this._createGlyphTransform(this.bounds, i15), this._borderLineSizePx = i15.borderLineSizePx, (i15.borderLineSizePx || i15.hasBackground) && ([this.bounds, this.textBox] = this.shapeBackground(this._transform));
    for (const e14 of t15)
      e14.setTransform(this._transform);
  }
  setRotation(i15) {
    if (0 === i15 && 0 === this._rotation)
      return;
    this._rotation = i15;
    const e14 = this._transform, h7 = M(n3(), i15);
    e5(e14, h7, e14);
    for (const t15 of this.glyphs)
      t15.setTransform(this._transform);
  }
  _decorate(t15, s12, i15) {
    if (!i15.decoration || "none" === i15.decoration || !t15.length)
      return;
    const e14 = i15.scale, o8 = "underline" === i15.decoration ? u10 : x3, h7 = t15[0].textureBinding;
    for (const n18 of s12) {
      const s13 = n18.startX * e14, i16 = n18.startY * e14, r17 = (n18.width + n18.glyphWidthEnd) * e14;
      t15.push(new M3(s13, i16 + o8 * e14, L2(r17, h7), 1));
    }
  }
  shapeBackground(t15) {
    const s12 = this._borderLineSizePx || 0, i15 = (w4 + s12) / 2, e14 = this._borderLineSizePx ? i15 : 0, { xmin: o8, ymin: h7, xmax: n18, ymax: r17, x: a12, y: f9, width: c5, height: m7 } = this.bounds, d4 = [o8 - y4, h7 - y4], _5 = [n18 + y4, h7 - y4], l12 = [o8 - y4, r17 + y4], u11 = [n18 + y4, r17 + y4], x4 = R2([[d4[0] - i15, d4[1] - i15], [_5[0] + i15, _5[1] - i15], [d4[0] + e14, d4[1] + e14], [_5[0] - e14, _5[1] + e14]], t15), p5 = R2([[l12[0] + e14, l12[1] - e14], [u11[0] - e14, u11[1] - e14], [l12[0] - i15, l12[1] + i15], [u11[0] + i15, u11[1] + i15]], t15), b3 = R2([[d4[0] - i15, d4[1] - i15], [d4[0] + e14, d4[1] + e14], [l12[0] - i15, l12[1] + i15], [l12[0] + e14, l12[1] - e14]], t15), M4 = R2([[_5[0] - e14, _5[1] + e14], [_5[0] + i15, _5[1] - i15], [u11[0] - e14, u11[1] - e14], [u11[0] + i15, u11[1] + i15]], t15), L3 = { main: R2([d4, _5, l12, u11], t15), top: x4, bot: p5, left: b3, right: M4 };
    return [new i4(a12, f9, c5 + 2 * i15, m7 + 2 * i15), L3];
  }
  get boundsT() {
    const t15 = this.bounds, s12 = o(n4(), t15.x, t15.y);
    if (S2(s12, s12, this._transform), this._hasRotation) {
      const i15 = Math.max(t15.width, t15.height);
      return new i4(s12[0], s12[1], i15, i15);
    }
    return new i4(s12[0], s12[1], t15.width, t15.height);
  }
  _createBounds(t15) {
    let s12 = 1 / 0, i15 = 1 / 0, e14 = 0, o8 = 0;
    for (const r17 of t15)
      s12 = Math.min(s12, r17.xTopLeft), i15 = Math.min(i15, r17.yTopLeft), e14 = Math.max(e14, r17.xBottomRight), o8 = Math.max(o8, r17.yBottomRight);
    const h7 = e14 - s12, n18 = o8 - i15;
    return new i4(s12 + h7 / 2, i15 + n18 / 2, h7, n18);
  }
  _createGlyphTransform(t15, s12) {
    const h7 = b2 * s12.angle, n18 = n3(), f9 = n4();
    return i3(n18, n18, o(f9, s12.xOffset, -s12.yOffset)), s12.useCIMAngleBehavior ? s3(n18, n18, h7) : (i3(n18, n18, o(f9, t15.x, t15.y)), s3(n18, n18, h7), i3(n18, n18, o(f9, -t15.x, -t15.y))), n18;
  }
};
var T2 = class {
  constructor(t15, s12, i15, e14, o8, h7) {
    this.glyphWidthEnd = 0, this.startX = 0, this.startY = 0, this.start = Math.max(0, Math.min(s12, i15)), this.end = Math.max(0, Math.max(s12, i15)), this.end < t15.length && (this.glyphWidthEnd = t15[this.end].metrics.width), this.width = e14, this.yMin = o8, this.yMax = h7;
  }
};
var v = (t15) => 10 === t15;
var j2 = (t15) => 32 === t15;
function A4(t15, s12, i15) {
  const e14 = new Array(), o8 = 1 / i15.scale, h7 = i15.maxLineWidth * o8, n18 = s12 ? t15.length - 1 : 0, r17 = s12 ? -1 : t15.length, a12 = s12 ? -1 : 1;
  let f9 = n18, c5 = 0, m7 = 0, d4 = f9, g4 = d4, _5 = 0, l12 = 1 / 0, u11 = 0;
  for (; f9 !== r17; ) {
    const { code: s13, metrics: i16 } = t15[f9], o9 = Math.abs(i16.top);
    if (v(s13) || j2(s13) || (l12 = Math.min(l12, o9), u11 = Math.max(u11, o9 + i16.height)), v(s13))
      f9 !== n18 && (e14.push(new T2(t15, d4, f9 - a12, c5, l12, u11)), l12 = 1 / 0, u11 = 0), c5 = 0, d4 = f9 + a12, g4 = f9 + a12, m7 = 0;
    else if (j2(s13))
      g4 = f9 + a12, m7 = 0, _5 = i16.advance, c5 += i16.advance;
    else if (c5 > h7) {
      if (g4 !== d4) {
        const s14 = g4 - 2 * a12;
        c5 -= _5, e14.push(new T2(t15, d4, s14, c5 - m7, l12, u11)), l12 = 1 / 0, u11 = 0, d4 = g4, c5 = m7;
      } else
        e14.push(new T2(t15, d4, f9 - a12, c5, l12, u11)), l12 = 1 / 0, u11 = 0, d4 = f9, g4 = f9, c5 = 0;
      c5 += i16.advance, m7 += i16.advance;
    } else
      c5 += i16.advance, m7 += i16.advance;
    f9 += a12;
  }
  const x4 = new T2(t15, d4, f9 - a12, c5, l12, u11);
  return x4.start >= 0 && x4.end < t15.length && e14.push(x4), e14;
}
function z(t15, s12) {
  let i15 = 0;
  for (let h7 = 0; h7 < t15.length; h7++) {
    const { width: s13 } = t15[h7];
    i15 = Math.max(s13, i15);
  }
  const e14 = "underline" === s12.decoration ? l11 : 0, o8 = t15[0].yMin;
  return { x: 0, y: o8, height: t15[t15.length - 1].yMax + s12.lineHeight * (t15.length - 1) + e14 - o8, width: i15 };
}
function O2(t15, s12) {
  const i15 = s12.scale, e14 = new Array(), { glyphs: o8, isRightToLeft: h7 } = t15, n18 = A4(o8, h7, s12), r17 = z(n18, s12), a12 = a11(s12.horizontalAlignment), d4 = c4(s12.verticalAlignment), g4 = d4 === n15.Baseline ? 1 : 0, l12 = g4 ? 0 : d4 - 1, u11 = (1 - g4) * -r17.y + l12 * (r17.height / 2) + (g4 ? 1 : 0) * -_3;
  for (let f9 = 0; f9 < n18.length; f9++) {
    const { start: t16, end: h8, width: r18 } = n18[f9];
    let c5 = -1 * (a12 + 1) * (r18 / 2) - p4;
    const m7 = f9 * s12.lineHeight + u11 - p4;
    n18[f9].startX = c5, n18[f9].startY = m7;
    for (let s13 = t16; s13 <= h8; s13++) {
      const t17 = o8[s13];
      if (v(t17.code))
        continue;
      const h9 = new M3(c5 + t17.metrics.left, m7 - t17.metrics.top, t17, i15);
      c5 += t17.metrics.advance, e14.push(h9);
    }
  }
  return new B3(e14, n18, s12);
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolDrawHelper.js
var N3 = Math.PI / 180;
var J = 0.5;
var O3 = () => n.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");
var V = class _V {
  constructor(t15) {
    this._t = t15;
  }
  static createIdentity() {
    return new _V([1, 0, 0, 0, 1, 0]);
  }
  clone() {
    const t15 = this._t;
    return new _V(t15.slice());
  }
  transform(t15) {
    const e14 = this._t;
    return [e14[0] * t15[0] + e14[1] * t15[1] + e14[2], e14[3] * t15[0] + e14[4] * t15[1] + e14[5]];
  }
  static createScale(t15, e14) {
    return new _V([t15, 0, 0, 0, e14, 0]);
  }
  scale(t15, e14) {
    const r17 = this._t;
    return r17[0] *= t15, r17[1] *= t15, r17[2] *= t15, r17[3] *= e14, r17[4] *= e14, r17[5] *= e14, this;
  }
  scaleRatio() {
    return Math.sqrt(this._t[0] * this._t[0] + this._t[1] * this._t[1]);
  }
  static createTranslate(t15, e14) {
    return new _V([0, 0, t15, 0, 0, e14]);
  }
  translate(t15, e14) {
    const r17 = this._t;
    return r17[2] += t15, r17[5] += e14, this;
  }
  static createRotate(t15) {
    const e14 = Math.cos(t15), r17 = Math.sin(t15);
    return new _V([e14, -r17, 0, r17, e14, 0]);
  }
  rotate(t15) {
    return _V.multiply(this, _V.createRotate(t15), this);
  }
  angle() {
    const t15 = this._t[0], e14 = this._t[3], r17 = Math.sqrt(t15 * t15 + e14 * e14);
    return [t15 / r17, e14 / r17];
  }
  static multiply(t15, e14, r17) {
    const s12 = t15._t, i15 = e14._t, o8 = s12[0] * i15[0] + s12[3] * i15[1], n18 = s12[1] * i15[0] + s12[4] * i15[1], a12 = s12[2] * i15[0] + s12[5] * i15[1] + i15[2], l12 = s12[0] * i15[3] + s12[3] * i15[4], h7 = s12[1] * i15[3] + s12[4] * i15[4], c5 = s12[2] * i15[3] + s12[5] * i15[4] + i15[5], m7 = r17._t;
    return m7[0] = o8, m7[1] = n18, m7[2] = a12, m7[3] = l12, m7[4] = h7, m7[5] = c5, r17;
  }
  invert() {
    const t15 = this._t;
    let e14 = t15[0] * t15[4] - t15[1] * t15[3];
    if (0 === e14)
      return new _V([0, 0, 0, 0, 0, 0]);
    e14 = 1 / e14;
    const r17 = (t15[1] * t15[5] - t15[2] * t15[4]) * e14, s12 = (t15[2] * t15[3] - t15[0] * t15[5]) * e14, i15 = t15[4] * e14, o8 = -t15[1] * e14, n18 = -t15[3] * e14, a12 = t15[0] * e14;
    return new _V([i15, o8, r17, n18, a12, s12]);
  }
};
var q = class {
  constructor(t15, e14) {
    this._resourceManager = t15, this._transfos = [], this._sizeTransfos = [], this._geomUnitsPerPoint = 1, this._placementPool = new e(t7, void 0, void 0, 100), this._earlyReturn = false, this._mapRotation = 0, this._transfos.push(e14 || V.createIdentity()), this._sizeTransfos.push(e14 ? e14.scaleRatio() : 1);
  }
  setTransform(t15, e14) {
    this._transfos = [t15 || V.createIdentity()], this._sizeTransfos = [e14 || (t15 ? t15.scaleRatio() : 1)];
  }
  setGeomUnitsPerPoint(t15) {
    this._geomUnitsPerPoint = t15;
  }
  transformPt(t15) {
    return this._transfos[this._transfos.length - 1].transform(t15);
  }
  transformSize(t15) {
    return t15 * this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  reverseTransformPt(t15) {
    return this._transfos[this._transfos.length - 1].invert().transform(t15);
  }
  reverseTransformSize(t15) {
    return t15 / this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  reverseTransformScalar(t15) {
    return t15 / this._transfos[this._transfos.length - 1].scaleRatio();
  }
  getTransformAngle() {
    return this._transfos[this._transfos.length - 1].angle();
  }
  geomUnitsPerPoint() {
    return this.isEmbedded() ? 1 : this._geomUnitsPerPoint;
  }
  prevGeomUnitsPerPoint() {
    return this._transfos.length > 2 ? 1 : this._geomUnitsPerPoint;
  }
  isEmbedded() {
    return this._transfos.length > 1;
  }
  back() {
    return this._transfos[this._transfos.length - 1];
  }
  push(t15, e14) {
    const r17 = e14 ? t15.scaleRatio() : 1;
    V.multiply(t15, this.back(), t15), this._transfos.push(t15), this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length - 1] * r17);
  }
  pop() {
    this._transfos.splice(-1, 1), this._sizeTransfos.splice(-1, 1);
  }
  drawSymbol(t15, e14, r17) {
    if (t15)
      switch (t15.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          this.drawMultiLayerSymbol(t15, e14);
          break;
        case "CIMTextSymbol":
          this.drawTextSymbol(t15, e14, r17);
      }
  }
  drawMultiLayerSymbol(t15, e14) {
    if (!t15 || !e14)
      return;
    const r17 = t15.symbolLayers;
    if (!r17)
      return;
    const s12 = t15.effects;
    if (s12 && s12.length > 0) {
      const t16 = this.executeEffects(s12, e14);
      if (t16) {
        let e15 = t16.next();
        for (; e15; )
          this.drawSymbolLayers(r17, e15.asJSON()), e15 = t16.next();
      }
    } else
      this.drawSymbolLayers(r17, e14);
  }
  executeEffects(t15, e14) {
    const r17 = this._resourceManager.geometryEngine;
    let s12 = new s6(a6.fromJSONCIM(e14));
    for (const i15 of t15) {
      const t16 = A3(i15);
      t16 && (s12 = t16.execute(s12, i15, this.geomUnitsPerPoint(), null, r17));
    }
    return s12;
  }
  drawSymbolLayers(t15, e14) {
    let r17 = t15.length;
    for (; r17--; ) {
      const s12 = t15[r17];
      if (!s12 || false === s12.enable)
        continue;
      const i15 = s12.effects;
      if (i15 && i15.length > 0) {
        const t16 = this.executeEffects(i15, e14);
        if (t16) {
          let e15 = null;
          for (; (e15 = t16.next()) && (this.drawSymbolLayer(s12, e15.asJSON()), !this._earlyReturn); )
            ;
        }
      } else
        this.drawSymbolLayer(s12, e14);
      if (this._earlyReturn)
        return;
    }
  }
  drawSymbolLayer(t15, e14) {
    switch (t15.type) {
      case "CIMSolidFill":
        this.drawSolidFill(e14, t15.color);
        break;
      case "CIMHatchFill":
        this.drawHatchFill(e14, t15);
        break;
      case "CIMPictureFill":
        this.drawPictureFill(e14, t15);
        break;
      case "CIMGradientFill":
        this.drawGradientFill(e14, t15);
        break;
      case "CIMSolidStroke":
        this.drawSolidStroke(e14, t15.color, t15.width, t15.capStyle, t15.joinStyle, t15.miterLimit);
        break;
      case "CIMPictureStroke":
        this.drawPictureStroke(e14, t15);
        break;
      case "CIMGradientStroke":
        this.drawGradientStroke(e14, t15);
        break;
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
      case "CIMVectorMarker":
        this.drawMarkerLayer(t15, e14);
    }
  }
  drawHatchFill(t15, e14) {
    const r17 = Q(e14, t15, this.geomUnitsPerPoint());
    r17 && (this.pushClipPath(t15), this.drawMultiLayerSymbol(e14.lineSymbol, r17), this.popClipPath());
  }
  drawPictureFill(t15, e14) {
  }
  drawGradientFill(t15, e14) {
  }
  drawPictureStroke(t15, e14) {
  }
  drawGradientStroke(t15, e14) {
  }
  drawMarkerLayer(t15, e14) {
    const r17 = t15.markerPlacement;
    if (r17) {
      const s12 = g3(r17);
      if (s12) {
        const i15 = "CIMMarkerPlacementInsidePolygon" === r17.type || "CIMMarkerPlacementPolygonCenter" === r17.type && r17.clipAtBoundary;
        i15 && this.pushClipPath(e14);
        const o8 = s12.execute(a6.fromJSONCIM(e14), r17, this.geomUnitsPerPoint(), null, this._resourceManager.geometryEngine);
        if (o8) {
          let e15 = null;
          for (; (e15 = o8.next()) && (this.drawMarker(t15, e15), !this._earlyReturn); )
            ;
        }
        i15 && this.popClipPath();
      }
    } else {
      const r18 = this._placementPool.acquire();
      if (u2(e14))
        r18.tx = e14.x, r18.ty = e14.y, this.drawMarker(t15, r18);
      else if (f6(e14)) {
        const s12 = l(e14);
        s12 && ([r18.tx, r18.ty] = s12, this.drawMarker(t15, r18));
      } else
        for (const s12 of e14.points)
          if (r18.tx = s12[0], r18.ty = s12[1], this.drawMarker(t15, r18), this._earlyReturn)
            break;
      this._placementPool.release(r18);
    }
  }
  drawMarker(t15, e14) {
    switch (t15.type) {
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
        this.drawPictureMarker(t15, e14);
        break;
      case "CIMVectorMarker":
        this.drawVectorMarker(t15, e14);
    }
  }
  drawPictureMarker(t15, e14) {
    if (!t15)
      return;
    const r17 = this._resourceManager.getResource(t15.url), s12 = I(t15.size, t3.CIMPictureMarker.size);
    if (null == r17 || s12 <= 0)
      return;
    const i15 = r17.width, o8 = r17.height;
    if (!i15 || !o8)
      return;
    const n18 = i15 / o8, a12 = I(t15.scaleX, 1), l12 = V.createIdentity(), h7 = t15.anchorPoint;
    if (h7) {
      let e15 = h7.x, r18 = h7.y;
      "Absolute" !== t15.anchorPointUnits && (e15 *= s12 * n18 * a12, r18 *= s12), l12.translate(-e15, -r18);
    }
    let c5 = I(t15.rotation);
    t15.rotateClockwise && (c5 = -c5), this._mapRotation && (c5 += this._mapRotation), c5 && l12.rotate(c5 * N3);
    let m7 = I(t15.offsetX), f9 = I(t15.offsetY);
    if (m7 || f9) {
      if (this._mapRotation) {
        const t16 = N3 * this._mapRotation, e15 = Math.cos(t16), r18 = Math.sin(t16), s13 = m7 * r18 + f9 * e15;
        m7 = m7 * e15 - f9 * r18, f9 = s13;
      }
      l12.translate(m7, f9);
    }
    const u11 = this.geomUnitsPerPoint();
    1 !== u11 && l12.scale(u11, u11);
    const d4 = e14.getAngle();
    d4 && l12.rotate(d4), l12.translate(e14.tx, e14.ty), this.push(l12, false), this.drawImage(t15, s12), this.pop();
  }
  drawVectorMarker(t15, e14) {
    if (!t15)
      return;
    const r17 = t15.markerGraphics;
    if (!r17)
      return;
    const s12 = I(t15.size, t3.CIMVectorMarker.size), i15 = t15.frame, o8 = i15 ? i15.ymax - i15.ymin : 0, n18 = s12 && o8 ? s12 / o8 : 1, a12 = V.createIdentity();
    i15 && a12.translate(0.5 * -(i15.xmax + i15.xmin), 0.5 * -(i15.ymax + i15.ymin));
    const l12 = t15.anchorPoint;
    if (l12) {
      let e15 = l12.x, r18 = l12.y;
      "Absolute" !== t15.anchorPointUnits ? i15 && (e15 *= i15.xmax - i15.xmin, r18 *= i15.ymax - i15.ymin) : (e15 /= n18, r18 /= n18), a12.translate(-e15, -r18);
    }
    1 !== n18 && a12.scale(n18, n18);
    let h7 = I(t15.rotation);
    t15.rotateClockwise && (h7 = -h7), this._mapRotation && (h7 += this._mapRotation), h7 && a12.rotate(h7 * N3);
    let c5 = I(t15.offsetX), m7 = I(t15.offsetY);
    if (c5 || m7) {
      if (this._mapRotation) {
        const t16 = N3 * this._mapRotation, e15 = Math.cos(t16), r18 = Math.sin(t16), s13 = c5 * r18 + m7 * e15;
        c5 = c5 * e15 - m7 * r18, m7 = s13;
      }
      a12.translate(c5, m7);
    }
    const f9 = this.geomUnitsPerPoint();
    1 !== f9 && a12.scale(f9, f9);
    const u11 = e14.getAngle();
    u11 && a12.rotate(u11), a12.translate(e14.tx, e14.ty), this.push(a12, t15.scaleSymbolsProportionally);
    for (const d4 of r17) {
      (d4 == null ? void 0 : d4.symbol) && d4.geometry || O3().error("Invalid marker graphic", d4);
      let t16 = d4.textString;
      if ("number" == typeof t16 && (t16 = t16.toString()), this.drawSymbol(d4.symbol, d4.geometry, t16), this._earlyReturn)
        break;
    }
    this.pop();
  }
  drawTextSymbol(t15, e14, r17) {
    if (!t15)
      return;
    if (!u2(e14))
      return;
    if (I(t15.height, t3.CIMTextSymbol.height) <= 0)
      return;
    const s12 = V.createIdentity();
    let i15 = I(t15.angle);
    i15 = -i15, i15 && s12.rotate(i15 * N3);
    const o8 = I(t15.offsetX), n18 = I(t15.offsetY);
    (o8 || n18) && s12.translate(o8, n18);
    const a12 = this.geomUnitsPerPoint();
    1 !== a12 && s12.scale(a12, a12), s12.translate(e14.x, e14.y), this.push(s12, false), this.drawText(t15, r17), this.pop();
  }
};
var Y2 = class extends q {
  constructor(t15, e14) {
    super(t15, e14), this.reset();
  }
  reset() {
    this._xmin = this._ymin = 1 / 0, this._xmax = this._ymax = -1 / 0, this._clipCount = 0;
  }
  envelope() {
    return new t14(this._xmin, this._ymin, this._xmax - this._xmin, this._ymax - this._ymin);
  }
  bounds() {
    return a2(this._xmin, this._ymin, this._xmax, this._ymax);
  }
  drawSolidFill(t15) {
    if (t15 && !(this._clipCount > 0))
      if (f6(t15))
        this._processPath(t15.rings, 0);
      else if (s(t15))
        this._processPath(t15.paths, 0);
      else if (m(t15)) {
        const e14 = et(t15);
        e14 && this._processPath(e14.rings, 0);
      } else
        console.error("drawSolidFill Unexpected geometry type!");
  }
  drawSolidStroke(t15, e14, r17) {
    if (!t15 || this._clipCount > 0 || null == r17 || r17 <= 0)
      return;
    const s12 = Math.max(0.5 * this.transformSize(I(r17, t3.CIMSolidStroke.width)), 0.5 * J);
    if (f6(t15))
      this._processPath(t15.rings, s12);
    else if (s(t15))
      this._processPath(t15.paths, s12);
    else if (m(t15)) {
      const e15 = et(t15);
      e15 && this._processPath(e15.rings, s12);
    } else
      console.error("drawSolidStroke unexpected geometry type!");
  }
  drawMarkerLayer(t15, e14) {
    f6(e14) && t15.markerPlacement && ("CIMMarkerPlacementInsidePolygon" === t15.markerPlacement.type || "CIMMarkerPlacementPolygonCenter" === t15.markerPlacement.type && t15.markerPlacement.clipAtBoundary) ? this._processPath(e14.rings, 0) : super.drawMarkerLayer(t15, e14);
  }
  drawHatchFill(t15, e14) {
    this.drawSolidFill(t15);
  }
  drawPictureFill(t15, e14) {
    this.drawSolidFill(t15);
  }
  drawGradientFill(t15, e14) {
    this.drawSolidFill(t15);
  }
  drawPictureStroke(t15, e14) {
    this.drawSolidStroke(t15, null, e14.width);
  }
  drawGradientStroke(t15, e14) {
    this.drawSolidStroke(t15, null, e14.width);
  }
  pushClipPath(t15) {
    this.drawSolidFill(t15), this._clipCount++;
  }
  popClipPath() {
    this._clipCount--;
  }
  drawImage(t15, e14) {
    const { url: r17 } = t15, s12 = I(t15.scaleX, 1);
    let i15 = s12 * e14, o8 = e14;
    const n18 = this._resourceManager.getResource(r17);
    if (null != n18) {
      const t16 = n18.height / n18.width;
      i15 = s12 * (e14 ? t16 > 1 ? e14 : e14 / t16 : n18.width), o8 = e14 ? t16 > 1 ? e14 * t16 : e14 : n18.height;
    }
    this._merge(this.transformPt([-i15 / 2, -o8 / 2]), 0), this._merge(this.transformPt([-i15 / 2, o8 / 2]), 0), this._merge(this.transformPt([i15 / 2, -o8 / 2]), 0), this._merge(this.transformPt([i15 / 2, o8 / 2]), 0);
  }
  drawText(t15, e14) {
    if (!e14 || 0 === e14.length)
      return;
    this._textRasterizer || (this._textRasterizer = new n16());
    const r17 = st(t15);
    let [s12, o8] = this._textRasterizer.computeTextSize(e14, r17);
    s12 = e3(s12), o8 = e3(o8);
    let n18 = 0;
    switch (t15.horizontalAlignment) {
      case "Left":
        n18 = s12 / 2;
        break;
      case "Right":
        n18 = -s12 / 2;
    }
    let a12 = 0;
    switch (t15.verticalAlignment) {
      case "Bottom":
        a12 = o8 / 2;
        break;
      case "Top":
        a12 = -o8 / 2;
        break;
      case "Baseline":
        a12 = o8 / 6;
    }
    this._merge(this.transformPt([-s12 / 2 + n18, -o8 / 2 + a12]), 0), this._merge(this.transformPt([-s12 / 2 + n18, o8 / 2 + a12]), 0), this._merge(this.transformPt([s12 / 2 + n18, -o8 / 2 + a12]), 0), this._merge(this.transformPt([s12 / 2 + n18, o8 / 2 + a12]), 0);
  }
  _processPath(t15, e14) {
    if (t15)
      for (const r17 of t15) {
        const t16 = r17 ? r17.length : 0;
        if (t16 > 1) {
          this._merge(this.transformPt(r17[0]), e14);
          for (let s12 = 1; s12 < t16; s12++)
            this._merge(this.transformPt(r17[s12]), e14);
        }
      }
  }
  _merge(t15, e14) {
    t15[0] - e14 < this._xmin && (this._xmin = t15[0] - e14), t15[0] + e14 > this._xmax && (this._xmax = t15[0] + e14), t15[1] - e14 < this._ymin && (this._ymin = t15[1] - e14), t15[1] + e14 > this._ymax && (this._ymax = t15[1] + e14);
  }
};
var W = class extends q {
  constructor() {
    super(...arguments), this._searchPoint = [0, 0], this._searchDistPoint = 0, this._textInfo = null;
  }
  hitTest(t15, e14, r17, s12, n18, a12) {
    var _a;
    const l12 = a12 * u3(1);
    this.setTransform(), this.setGeomUnitsPerPoint(l12), this._searchPoint = [(t15[0] + t15[2]) / 2, (t15[1] + t15[3]) / 2], this._searchDistPoint = (t15[2] - t15[0]) / 2 / l12, this._textInfo = s12;
    const h7 = e14 && ("CIMPointSymbol" === e14.type && "Map" !== e14.angleAlignment || "CIMTextSymbol" === e14.type);
    if (this._mapRotation = h7 ? n18 : 0, !has("esri-mobile")) {
      const t16 = e3(has("hittest-2d-small-symbol-tolerance") * window.devicePixelRatio), r18 = e3(has("hittest-2d-small-symbol-tolerance-threshold"));
      !(("CIMLineSymbol" === (e14 == null ? void 0 : e14.type) || "CIMPolygonSymbol" === (e14 == null ? void 0 : e14.type)) && ((_a = e14.symbolLayers) == null ? void 0 : _a.some(C))) && "CIMMeshSymbol" !== (e14 == null ? void 0 : e14.type) && (B(e14) ?? 0) < r18 && (this._searchDistPoint = t16);
    }
    return this._earlyReturn = false, this.drawSymbol(e14, r17), this._earlyReturn;
  }
  drawSolidFill(t15, e14) {
    this._hitTestFill(t15);
  }
  drawHatchFill(t15, e14) {
    this._hitTestFill(t15);
  }
  drawPictureFill(t15, e14) {
    this._hitTestFill(t15);
  }
  drawGradientFill(t15, e14) {
    this._hitTestFill(t15);
  }
  drawSolidStroke(t15, e14, r17, s12, i15, o8) {
    this._hitTestStroke(t15, r17);
  }
  drawPictureStroke(t15, e14) {
    this._hitTestStroke(t15, e14.width);
  }
  drawGradientStroke(t15, e14) {
    this._hitTestStroke(t15, e14.width);
  }
  drawMarkerLayer(t15, e14) {
    t15.markerPlacement && ("CIMMarkerPlacementInsidePolygon" === t15.markerPlacement.type || "CIMMarkerPlacementPolygonCenter" === t15.markerPlacement.type && t15.markerPlacement.clipAtBoundary) ? this._hitTestFill(e14) : super.drawMarkerLayer(t15, e14);
  }
  pushClipPath(t15) {
  }
  popClipPath() {
  }
  drawImage(t15, e14) {
    const { url: r17 } = t15, s12 = I(t15.scaleX, 1), i15 = this._resourceManager.getResource(r17);
    if (null == i15 || 0 === i15.height || 0 === e14)
      return;
    const o8 = e14 * this.geomUnitsPerPoint(), n18 = o8 * s12 * (i15.width / i15.height), a12 = this.reverseTransformPt(this._searchPoint), l12 = this._searchDistPoint;
    Math.abs(a12[0]) < n18 / 2 + l12 && Math.abs(a12[1]) < o8 / 2 + l12 && (this._earlyReturn = true);
  }
  drawText(t15, e14) {
    var _a;
    const r17 = this._textInfo;
    if (!r17)
      return;
    const s12 = r17.get(t15);
    if (!s12)
      return;
    if (!s12.glyphMosaicItems.glyphs.length)
      return;
    const i15 = I(t15.height, t3.CIMTextSymbol.height), { lineGapType: o8, lineGap: n18 } = t15, a12 = o8 ? rt(o8, I(n18), i15) : 0, l12 = "CIMBackgroundCallout" === ((_a = t15.callout) == null ? void 0 : _a.type), h7 = O2(s12.glyphMosaicItems, { scale: i15 / U, angle: 0, xOffset: 0, yOffset: 0, horizontalAlignment: t15.horizontalAlignment, verticalAlignment: t15.verticalAlignment, maxLineWidth: 512, lineHeight: g2 * Math.max(0.25, Math.min(a12 || 1, 4)), decoration: t15.font.decoration || "none", useCIMAngleBehavior: true, hasBackground: l12 }), c5 = this.reverseTransformPt(this._searchPoint), m7 = c5[0], f9 = c5[1];
    for (const u11 of h7.glyphs)
      if (m7 > u11.xTopLeft && m7 < u11.xBottomRight && f9 > -u11.yBottomRight && f9 < -u11.yTopLeft) {
        this._earlyReturn = true;
        break;
      }
  }
  _hitTestFill(t15) {
    let e14 = null;
    if (m(t15)) {
      const r18 = t15;
      e14 = [[[r18.xmin, r18.ymin], [r18.xmin, r18.ymax], [r18.xmax, r18.ymax], [r18.xmax, r18.ymin], [r18.xmin, r18.ymin]]];
    } else if (f6(t15))
      e14 = t15.rings;
    else {
      if (!s(t15))
        return;
      e14 = t15.paths;
    }
    const r17 = this.reverseTransformPt(this._searchPoint);
    if (Z2(r17, e14) && (this._earlyReturn = true), !this._earlyReturn) {
      $(r17, e14, this.reverseTransformScalar(this._searchDistPoint) * this.prevGeomUnitsPerPoint()) && (this._earlyReturn = true);
    }
  }
  _hitTestStroke(t15, e14) {
    let r17 = null;
    if (m(t15)) {
      const e15 = t15;
      r17 = [[[e15.xmin, e15.ymin], [e15.xmin, e15.ymax], [e15.xmax, e15.ymax], [e15.xmax, e15.ymin], [e15.xmin, e15.ymin]]];
    } else if (f6(t15))
      r17 = t15.rings;
    else {
      if (!s(t15))
        return;
      r17 = t15.paths;
    }
    $(this.reverseTransformPt(this._searchPoint), r17, I(e14, t3.CIMSolidStroke.width) * this.geomUnitsPerPoint() / 2 + this.reverseTransformScalar(this._searchDistPoint) * this.prevGeomUnitsPerPoint()) && (this._earlyReturn = true);
  }
};
var K2 = class extends q {
  constructor(t15, e14, r17, s12) {
    super(e14, r17), this._applyAdditionalRenderProps = s12, this._colorSubstitutionHelper = new t12(), this._ctx = t15;
  }
  drawSolidFill(t15, e14) {
    if (!t15)
      return;
    if (f6(t15))
      this._buildPath(t15.rings, true);
    else if (s(t15))
      this._buildPath(t15.paths, true);
    else if (m(t15))
      this._buildPath(et(t15).rings, true);
    else {
      if (!l2(t15))
        return;
      console.log("CanvasDrawHelper.drawSolidFill - No implementation!");
    }
    const r17 = this._ctx;
    r17.fillStyle = "string" == typeof e14 ? e14 : "rgba(" + Math.round(e14[0]) + "," + Math.round(e14[1]) + "," + Math.round(e14[2]) + "," + (e14[3] ?? 255) / 255 + ")", r17.fill("evenodd");
  }
  drawSolidStroke(t15, e14, r17, s12, i15, o8) {
    if (!t15 || !e14 || 0 === r17)
      return;
    if (f6(t15))
      this._buildPath(t15.rings, true);
    else if (s(t15))
      this._buildPath(t15.paths, false);
    else {
      if (!m(t15))
        return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");
      this._buildPath(et(t15).rings, true);
    }
    const n18 = this._ctx;
    n18.strokeStyle = "string" == typeof e14 ? e14 : "rgba(" + Math.round(e14[0]) + "," + Math.round(e14[1]) + "," + Math.round(e14[2]) + "," + (e14[3] ?? 255) / 255 + ")", n18.lineWidth = Math.max(this.transformSize(r17), J), this._setCapStyle(s12), this._setJoinStyle(i15), n18.miterLimit = o8, n18.stroke();
  }
  pushClipPath(t15) {
    if (this._ctx.save(), f6(t15))
      this._buildPath(t15.rings, true);
    else if (s(t15))
      this._buildPath(t15.paths, true);
    else {
      if (!m(t15))
        return;
      this._buildPath(et(t15).rings, true);
    }
    this._ctx.clip("evenodd");
  }
  popClipPath() {
    this._ctx.restore();
  }
  drawImage(t15, e14) {
    const { colorSubstitutions: r17, url: s12, tintColor: i15 } = t15, o8 = I(t15.scaleX, 1), n18 = this._resourceManager.getResource(s12);
    if (null == n18)
      return;
    let a12 = e14 * (n18.width / n18.height), l12 = e14;
    e14 || (a12 = n18.width, l12 = n18.height);
    const h7 = N(s12) || "src" in n18 && N(n18.src);
    let c5 = "getFrame" in n18 ? t13(n18) : n18;
    r17 && (c5 = this._colorSubstitutionHelper.applyColorSubstituition(c5, r17)), this._applyAdditionalRenderProps && !h7 && i15 && (c5 = this._colorSubstitutionHelper.tintImageData(c5, i15));
    const m7 = this.transformPt([0, 0]), [f9, u11] = this.getTransformAngle(), d4 = this.transformSize(1), p5 = this._ctx;
    p5.save(), p5.setTransform({ m11: o8 * d4 * f9, m12: o8 * d4 * u11, m21: -d4 * u11, m22: d4 * f9, m41: m7[0], m42: m7[1] }), p5.drawImage(c5, -a12 / 2, -l12 / 2, a12, l12), p5.restore();
  }
  drawText(t15, e14) {
    if (!e14 || 0 === e14.length)
      return;
    this._textRasterizer || (this._textRasterizer = new n16());
    const r17 = st(t15);
    r17.size *= this.transformSize(e3(1));
    const s12 = this._textRasterizer.rasterizeText(e14, r17);
    if (!s12)
      return;
    const { size: o8, anchorX: n18, anchorY: a12, canvas: l12 } = s12, h7 = o8[0] * (n18 + 0.5), c5 = o8[1] * (a12 - 0.5), m7 = this._ctx, f9 = this.transformPt([0, 0]), [u11, d4] = this.getTransformAngle(), p5 = 1;
    m7.save(), m7.setTransform({ m11: p5 * u11, m12: p5 * d4, m21: -p5 * d4, m22: p5 * u11, m41: f9[0] - p5 * h7, m42: f9[1] + p5 * c5 }), m7.drawImage(l12, 0, 0), m7.restore();
  }
  drawPictureFill(t15, e14) {
    if (!t15)
      return;
    let { colorSubstitutions: r17, height: s12, offsetX: i15, offsetY: o8, rotation: n18, scaleX: a12, tintColor: l12, url: h7 } = e14;
    const c5 = this._resourceManager.getResource(h7);
    if (null == c5)
      return;
    if (f6(t15))
      this._buildPath(t15.rings, true);
    else if (s(t15))
      this._buildPath(t15.paths, true);
    else if (m(t15))
      this._buildPath(et(t15).rings, true);
    else {
      if (!l2(t15))
        return;
      console.log("CanvasDrawHelper.drawPictureFill - No implementation!");
    }
    const m7 = this._ctx, _5 = N(h7) || "src" in c5 && N(c5.src);
    let y5, g4 = "getFrame" in c5 ? t13(c5) : c5;
    if (r17 && (g4 = this._colorSubstitutionHelper.applyColorSubstituition(g4, r17)), this._applyAdditionalRenderProps) {
      _5 || l12 && (g4 = this._colorSubstitutionHelper.tintImageData(g4, l12)), y5 = m7.createPattern(g4, "repeat");
      const t16 = this.transformSize(1);
      n18 || (n18 = 0), i15 ? i15 *= t16 : i15 = 0, o8 ? o8 *= t16 : o8 = 0, s12 && (s12 *= t16);
      const e15 = s12 ? s12 / c5.height : 1, r18 = a12 && s12 ? a12 * s12 / c5.width : 1;
      if (0 !== n18 || 1 !== e15 || 1 !== r18 || 0 !== i15 || 0 !== o8) {
        const t17 = new DOMMatrix();
        t17.rotateSelf(0, 0, -n18).translateSelf(i15, o8).scaleSelf(r18, e15, 1), y5.setTransform(t17);
      }
    } else
      y5 = m7.createPattern(g4, "repeat");
    m7.save(), m7.fillStyle = y5, m7.fill("evenodd"), m7.restore();
  }
  drawPictureStroke(t15, r17) {
    if (!t15)
      return;
    let { colorSubstitutions: s12, capStyle: i15, joinStyle: n18, miterLimit: a12, tintColor: l12, url: h7, width: c5 } = r17;
    const m7 = this._resourceManager.getResource(h7);
    if (null == m7)
      return;
    let _5;
    if (f6(t15))
      _5 = t15.rings;
    else if (s(t15))
      _5 = t15.paths;
    else {
      if (!m(t15))
        return l2(t15) ? void console.log("CanvasDrawHelper.drawPictureStroke - No implementation!") : void 0;
      _5 = et(t15).rings;
    }
    c5 || (c5 = m7.width);
    const y5 = N(h7) || "src" in m7 && N(m7.src);
    let g4 = "getFrame" in m7 ? t13(m7) : m7;
    s12 && (g4 = this._colorSubstitutionHelper.applyColorSubstituition(g4, s12)), this._applyAdditionalRenderProps && (y5 || l12 && (g4 = this._colorSubstitutionHelper.tintImageData(g4, l12)));
    const P5 = Math.max(this.transformSize(u3(c5)), 0.5), x4 = P5 / g4.width, w5 = this._ctx, S3 = w5.createPattern(g4, "repeat-y");
    let M4, k3;
    w5.save(), this._setCapStyle(i15), this._setJoinStyle(n18), void 0 !== a12 && (w5.miterLimit = a12), w5.lineWidth = P5;
    for (let o8 of _5)
      if (o8 = a(o8), ot(o8), o8 && !(o8.length <= 1)) {
        M4 = this.transformPt(o8[0]);
        for (let t16 = 1; t16 < o8.length; t16++) {
          k3 = this.transformPt(o8[t16]);
          const e14 = tt(M4, k3), r18 = new DOMMatrix();
          r18.translateSelf(0, M4[1] - P5 / 2).scaleSelf(x4, x4, 1).rotateSelf(0, 0, 90 - e14), S3.setTransform(r18), w5.strokeStyle = S3, w5.beginPath(), w5.moveTo(M4[0], M4[1]), w5.lineTo(k3[0], k3[1]), w5.stroke(), M4 = k3;
        }
      }
    w5.restore();
  }
  _buildPath(t15, e14) {
    const r17 = this._ctx;
    if (r17.beginPath(), t15)
      for (const s12 of t15) {
        const t16 = s12 ? s12.length : 0;
        if (t16 > 1) {
          let i15 = this.transformPt(s12[0]);
          r17.moveTo(i15[0], i15[1]);
          for (let e15 = 1; e15 < t16; e15++)
            i15 = this.transformPt(s12[e15]), r17.lineTo(i15[0], i15[1]);
          e14 && r17.closePath();
        }
      }
  }
  _setCapStyle(t15) {
    switch (t15) {
      case U2.Butt:
        this._ctx.lineCap = "butt";
        break;
      case U2.Round:
        this._ctx.lineCap = "round";
        break;
      case U2.Square:
        this._ctx.lineCap = "square";
    }
  }
  _setJoinStyle(t15) {
    switch (t15) {
      case w2.Bevel:
        this._ctx.lineJoin = "bevel";
        break;
      case w2.Round:
        this._ctx.lineJoin = "round";
        break;
      case w2.Miter:
        this._ctx.lineJoin = "miter";
    }
  }
};
function Q(t15, e14, r17) {
  let s12 = I(t15.separation, t3.CIMHatchFill.separation) * r17, i15 = I(t15.rotation);
  if (0 === s12)
    return null;
  s12 < 0 && (s12 = -s12);
  let o8 = 0;
  const n18 = 0.5 * s12;
  for (; o8 > n18; )
    o8 -= s12;
  for (; o8 < -n18; )
    o8 += s12;
  const a12 = u();
  a3(a12, e14), a12[0] -= n18, a12[1] -= n18, a12[2] += n18, a12[3] += n18;
  const c5 = [[a12[0], a12[1]], [a12[0], a12[3]], [a12[2], a12[3]], [a12[2], a12[1]]];
  for (; i15 > 180; )
    i15 -= 180;
  for (; i15 < 0; )
    i15 += 180;
  const m7 = Math.cos(i15 * N3), f9 = Math.sin(i15 * N3), u11 = -s12 * f9, d4 = s12 * m7;
  let p5, _5, y5, g4;
  o8 = I(t15.offsetX) * r17 * f9 - I(t15.offsetY) * r17 * m7, p5 = y5 = Number.MAX_VALUE, _5 = g4 = -Number.MAX_VALUE;
  for (const l12 of c5) {
    const t16 = l12[0], e15 = l12[1], r18 = m7 * t16 + f9 * e15, s13 = -f9 * t16 + m7 * e15;
    p5 = Math.min(p5, r18), y5 = Math.min(y5, s13), _5 = Math.max(_5, r18), g4 = Math.max(g4, s13);
  }
  y5 = Math.floor(y5 / s12) * s12;
  let P5 = m7 * p5 - f9 * y5 - u11 * o8 / s12, x4 = f9 * p5 + m7 * y5 - d4 * o8 / s12, S3 = m7 * _5 - f9 * y5 - u11 * o8 / s12, M4 = f9 * _5 + m7 * y5 - d4 * o8 / s12;
  const b3 = 1 + Math.round((g4 - y5) / s12), k3 = [];
  for (let l12 = 0; l12 < b3; l12++)
    P5 += u11, x4 += d4, S3 += u11, M4 += d4, k3.push([[P5, x4], [S3, M4]]);
  return { paths: k3 };
}
function Z2(t15, e14) {
  let r17 = 0;
  for (const s12 of e14) {
    const e15 = s12.length;
    for (let i15 = 1; i15 < e15; i15++) {
      const e16 = s12[i15 - 1], o8 = s12[i15];
      if (e16[1] > t15[1] == o8[1] > t15[1])
        continue;
      (o8[0] - e16[0]) * (t15[1] - e16[1]) - (o8[1] - e16[1]) * (t15[0] - e16[0]) > 0 ? r17++ : r17--;
    }
  }
  return 0 !== r17;
}
function $(t15, e14, r17) {
  for (const s12 of e14) {
    const e15 = s12.length;
    for (let i15 = 1; i15 < e15; i15++) {
      const e16 = s12[i15 - 1], o8 = s12[i15];
      let n18 = (o8[0] - e16[0]) * (o8[0] - e16[0]) + (o8[1] - e16[1]) * (o8[1] - e16[1]);
      if (0 === n18)
        continue;
      n18 = Math.sqrt(n18);
      const a12 = ((o8[0] - e16[0]) * (t15[1] - e16[1]) - (o8[1] - e16[1]) * (t15[0] - e16[0])) / n18;
      if (Math.abs(a12) < r17) {
        const s13 = ((o8[0] - e16[0]) * (t15[0] - e16[0]) + (o8[1] - e16[1]) * (t15[1] - e16[1])) / n18;
        if (s13 > -r17 && s13 < n18 + r17)
          return true;
      }
    }
  }
  return false;
}
function tt(t15, e14) {
  const r17 = e14[0] - t15[0], s12 = e14[1] - t15[1];
  return 180 / Math.PI * Math.atan2(s12, r17);
}
var et = (t15) => t15 ? { spatialReference: t15.spatialReference, rings: [[[t15.xmin, t15.ymin], [t15.xmin, t15.ymax], [t15.xmax, t15.ymax], [t15.xmax, t15.ymin], [t15.xmin, t15.ymin]]] } : null;
var rt = (t15, e14, r17) => {
  switch (t15) {
    case "ExtraLeading":
      return 1 + e14 / r17;
    case "Multiple":
      return e14;
    case "Exact":
      return e14 / r17;
  }
};
function st(e14, r17 = 1) {
  var _a;
  const s12 = w(e14), i15 = P(e14.fontStyleName), o8 = e14.fontFamilyName ?? t4, { weight: n18, style: a12 } = i15, l12 = r17 * (e14.height || 5), h7 = A(e14.horizontalAlignment), c5 = F(e14.verticalAlignment), m7 = L(e14), f9 = L(e14.haloSymbol), u11 = null != f9 ? r17 * (e14.haloSize ?? 0) : 0, d4 = "CIMBackgroundCallout" === ((_a = e14.callout) == null ? void 0 : _a.type) ? e14.callout.backgroundSymbol : null, p5 = L(d4), _5 = x(d4), y5 = T(d4);
  return { color: m7, size: l12, horizontalAlignment: h7, verticalAlignment: c5, font: { family: o8, style: S(a12), weight: g(n18), decoration: s12 }, halo: { size: u11 || 0, color: f9, style: a12 }, backgroundColor: p5, borderLine: null != _5 && null != y5 ? { size: _5, color: y5 } : null, pixelRatio: 1, premultiplyColors: true };
}
var it = 1e-4;
function ot(t15) {
  let e14, r17, s12, i15, o8, n18 = t15[0], a12 = 1;
  for (; a12 < t15.length; )
    e14 = t15[a12][0] - n18[0], r17 = t15[a12][1] - n18[1], i15 = 0 !== e14 ? r17 / e14 : Math.PI / 2, void 0 !== s12 && i15 - s12 <= it ? (t15.splice(a12 - 1, 1), n18 = o8) : (o8 = n18, n18 = t15[a12], a12++), s12 = i15;
}

// node_modules/@arcgis/core/core/BidiText.js
var n17 = new C3();
function i14(r17) {
  if (null == r17)
    return ["", false];
  if (!n17.hasBidiChar(r17))
    return [r17, false];
  let i15;
  return i15 = "rtl" === n17.checkContextual(r17) ? "IDNNN" : "ICNNN", [n17.bidiTransform(r17, i15, "VLYSN"), true];
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolHelper.js
var X2 = Math.PI;
var V2 = X2 / 2;
var N4 = Math.PI / 180;
var Y3 = 96 / 72;
var _4 = 4;
var H = () => n.getLogger("esri.symbols.cim.CIMSymbolHelper");
function U3(e14) {
  let t15;
  switch (e14.type) {
    case "cim":
      return e14.data;
    case "web-style":
      return e14;
    case "simple-marker": {
      const r17 = K3.fromSimpleMarker(e14);
      if (!r17)
        throw new Error("InternalError: Cannot convert symbol to CIM");
      t15 = r17;
      break;
    }
    case "picture-marker":
      t15 = K3.fromPictureMarker(e14);
      break;
    case "simple-line":
      t15 = K3.fromSimpleLineSymbol(e14);
      break;
    case "simple-fill":
      t15 = K3.fromSimpleFillSymbol(e14);
      break;
    case "picture-fill":
      t15 = K3.fromPictureFillSymbol(e14);
      break;
    case "text":
      t15 = K3.fromTextSymbol(e14);
  }
  return { type: "CIMSymbolReference", symbol: t15 };
}
function O4(e14, t15, r17) {
  switch (t15.type) {
    case "CIMSymbolReference":
      return O4(e14, t15.symbol, r17);
    case "CIMPointSymbol":
      null == r17 && (r17 = { x: 0, y: 0 }), e14.drawSymbol(t15, r17);
      break;
    case "CIMLineSymbol":
      null == r17 && (r17 = { paths: [[[0, 0], [10, 0]]] }), e14.drawSymbol(t15, r17);
      break;
    case "CIMPolygonSymbol":
      null == r17 && (r17 = { rings: [[[0, 0], [0, 10], [10, 10], [10, 0], [0, 0]]] }), e14.drawSymbol(t15, r17);
      break;
    case "CIMTextSymbol": {
      const r18 = { x: 0, y: 0 };
      e14.drawSymbol(t15, r18);
      break;
    }
    case "CIMVectorMarker": {
      const r18 = new t7();
      e14.drawMarker(t15, r18);
      break;
    }
  }
  return e14.envelope();
}
function q2(e14) {
  if (!e14)
    return 0;
  switch (e14.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
    case "CIMMarkerPlacementAlongLineRandomSize":
    case "CIMMarkerPlacementAtExtremities":
    case "CIMMarkerPlacementAtMeasuredUnits":
    case "CIMMarkerPlacementAtRatioPositions":
    case "CIMMarkerPlacementOnLine":
    case "CIMMarkerPlacementOnVertices":
      return Math.abs(e14.offset);
    default:
      return 0;
  }
}
function W2(e14) {
  if (!e14)
    return 0;
  switch (e14.type) {
    case "CIMGeometricEffectArrow":
      return Math.abs(0.5 * e14.width);
    case "CIMGeometricEffectBuffer":
      return Math.abs(e14.size);
    case "CIMGeometricEffectExtension":
    case "CIMGeometricEffectRadial":
      return Math.abs(e14.length);
    case "CIMGeometricEffectJog":
      return Math.abs(0.5 * e14.length);
    case "CIMGeometricEffectMove":
      return Math.max(Math.abs(I(e14.offsetX)), Math.abs(I(e14.offsetY)));
    case "CIMGeometricEffectOffset":
    case "CIMGeometricEffectOffsetTangent":
      return Math.abs(e14.offset);
    case "CIMGeometricEffectRegularPolygon":
      return Math.abs(e14.radius);
    case "CIMGeometricEffectRotate":
    case "CIMGeometricEffectScale":
    default:
      return 0;
    case "CIMGeometricEffectTaperedPolygon":
      return 0.5 * Math.max(Math.abs(e14.fromWidth), Math.abs(e14.toWidth));
    case "CIMGeometricEffectWave":
      return Math.abs(e14.amplitude);
    case "CIMGeometricEffectDonut":
      return Math.abs(e14.width);
  }
}
function $2(e14) {
  if (!e14)
    return 0;
  let t15 = 0;
  for (const r17 of e14)
    t15 += W2(r17);
  return t15;
}
var J2 = class {
  static getSymbolInflateSize(e14, t15, r17, o8, a12) {
    return e14 || (e14 = [0, 0, 0, 0]), t15 ? this._getInflateSize(e14, t15, r17, o8, a12) : e14;
  }
  static safeSize(e14) {
    const t15 = Math.max(Math.abs(e14[0]), Math.abs(e14[2])), r17 = Math.max(Math.abs(e14[1]), Math.abs(e14[3]));
    return Math.sqrt(t15 * t15 + r17 * r17);
  }
  static _vectorMarkerBounds(e14, t15, r17, o8) {
    let a12 = true;
    const i15 = u();
    if (t15 == null ? void 0 : t15.markerGraphics)
      for (const s12 of t15.markerGraphics) {
        const t16 = [0, 0, 0, 0];
        s12.geometry && (a3(i15, s12.geometry), t16[0] = 0, t16[1] = 0, t16[2] = 0, t16[3] = 0, this.getSymbolInflateSize(t16, s12.symbol, r17, 0, o8), i15[0] += t16[0], i15[1] += t16[1], i15[2] += t16[2], i15[3] += t16[3], a12 ? (e14[0] = i15[0], e14[1] = i15[1], e14[2] = i15[2], e14[3] = i15[3], a12 = false) : (e14[0] = Math.min(e14[0], i15[0]), e14[1] = Math.min(e14[1], i15[1]), e14[2] = Math.max(e14[2], i15[2]), e14[3] = Math.max(e14[3], i15[3])));
      }
    return e14;
  }
  static _getInflateSize(e14, t15, r17, o8, a12) {
    if (le(t15)) {
      const s12 = this._getLayersInflateSize(e14, t15.symbolLayers, r17, o8, a12), i15 = $2(t15.effects);
      return i15 > 0 && (s12[0] -= i15, s12[1] -= i15, s12[2] += i15, s12[3] += i15), s12;
    }
    return this._getTextInflatedSize(e14, t15, a12);
  }
  static _getLayersInflateSize(e14, t15, r17, o8, a12) {
    let n18 = true;
    if (!t15)
      return e14;
    for (const l12 of t15) {
      if (!l12)
        continue;
      let t16 = [0, 0, 0, 0];
      switch (l12.type) {
        case "CIMSolidFill":
        case "CIMPictureFill":
        case "CIMHatchFill":
        case "CIMGradientFill":
          break;
        case "CIMSolidStroke":
        case "CIMPictureStroke":
        case "CIMGradientStroke": {
          const e15 = l12;
          let r18 = e15.width;
          null != r18 && (e15.capStyle === U2.Square || e15.joinStyle === w2.Miter ? r18 /= 1.4142135623730951 : r18 /= 2, t16[0] = -r18, t16[1] = -r18, t16[2] = r18, t16[3] = r18);
          break;
        }
        case "CIMCharacterMarker":
        case "CIMVectorMarker":
        case "CIMPictureMarker": {
          const e15 = l12;
          if ("CIMVectorMarker" === l12.type) {
            const e16 = l12;
            if (t16 = this._vectorMarkerBounds(t16, e16, r17, a12), e16.frame) {
              const r18 = (e16.frame.xmin + e16.frame.xmax) / 2, o9 = (e16.frame.ymin + e16.frame.ymax) / 2;
              if (t16[0] -= r18, t16[1] -= o9, t16[2] -= r18, t16[3] -= o9, null != e16.size) {
                const r19 = e16.size / (e16.frame.ymax - e16.frame.ymin);
                t16[0] *= r19, t16[1] *= r19, t16[2] *= r19, t16[3] *= r19;
              }
            }
          } else if ("CIMPictureMarker" === l12.type) {
            const o9 = l12, a13 = r17.getResource(o9.url);
            let s12 = 1;
            if (null != a13 && a13.height && (s12 = a13.width / a13.height), null != e15.size) {
              const r18 = e15.size / 2, a14 = e15.size * s12 * o9.scaleX / 2;
              t16 = [-a14, -r18, a14, r18];
            }
          } else if (null != e15.size) {
            const r18 = e15.size / 2;
            t16 = [-r18, -r18, r18, r18];
          }
          if (e15.anchorPoint) {
            let r18, o9;
            "Absolute" === e15.anchorPointUnits ? (r18 = e15.anchorPoint.x, o9 = e15.anchorPoint.y) : (r18 = e15.anchorPoint.x * (t16[2] - t16[0]), o9 = e15.anchorPoint.y * (t16[3] - t16[1])), t16[0] -= r18, t16[1] -= o9, t16[2] -= r18, t16[3] -= o9;
          }
          let n19 = I(e15.rotation);
          if (e15.rotateClockwise && (n19 = -n19), o8 && (n19 -= o8), n19) {
            const e16 = N4 * n19, r18 = Math.cos(e16), o9 = Math.sin(e16), a13 = u([r, r, -r, -r]);
            f4(a13, [t16[0] * r18 - t16[1] * o9, t16[0] * o9 + t16[1] * r18]), f4(a13, [t16[0] * r18 - t16[3] * o9, t16[0] * o9 + t16[3] * r18]), f4(a13, [t16[2] * r18 - t16[1] * o9, t16[2] * o9 + t16[1] * r18]), f4(a13, [t16[2] * r18 - t16[3] * o9, t16[2] * o9 + t16[3] * r18]), t16 = a13;
          }
          let c6 = I(e15.offsetX), m7 = I(e15.offsetY);
          if (o8) {
            const e16 = N4 * o8, t17 = Math.cos(e16), r18 = Math.sin(e16), a13 = c6 * r18 + m7 * t17;
            c6 = c6 * t17 - m7 * r18, m7 = a13;
          }
          t16[0] += c6, t16[1] += m7, t16[2] += c6, t16[3] += m7;
          const f9 = q2(e15.markerPlacement);
          f9 > 0 && (t16[0] -= f9, t16[1] -= f9, t16[2] += f9, t16[3] += f9);
          break;
        }
      }
      const c5 = $2(l12.effects);
      c5 > 0 && (t16[0] -= c5, t16[1] -= c5, t16[2] += c5, t16[3] += c5), n18 ? (e14[0] = t16[0], e14[1] = t16[1], e14[2] = t16[2], e14[3] = t16[3], n18 = false) : (e14[0] = Math.min(e14[0], t16[0]), e14[1] = Math.min(e14[1], t16[1]), e14[2] = Math.max(e14[2], t16[2]), e14[3] = Math.max(e14[3], t16[3]));
    }
    return e14;
  }
  static _getTextInflatedSize(e14, t15, r17) {
    var _a;
    const o8 = t15.height ?? t3.CIMTextSymbol.height;
    if (e14[0] = -o8 / 2, e14[1] = -o8 / 2, e14[2] = o8 / 2, e14[3] = o8 / 2, !r17)
      return e14;
    const a12 = r17.get(t15);
    if (!a12)
      return e14;
    if (!a12.glyphMosaicItems.glyphs.length)
      return e14;
    const { lineGapType: s12, lineGap: i15 } = t15, n18 = s12 ? rt(s12, i15 ?? 0, o8) : 0, l12 = "CIMBackgroundCallout" === ((_a = t15.callout) == null ? void 0 : _a.type), c5 = O2(a12.glyphMosaicItems, { scale: o8 / U, angle: I(t15.angle), xOffset: I(t15.offsetX), yOffset: I(t15.offsetY), horizontalAlignment: t15.horizontalAlignment, verticalAlignment: t15.verticalAlignment, maxLineWidth: 512, lineHeight: g2 * Math.max(0.25, Math.min(n18 || 1, 4)), decoration: t15.font.decoration || "none", useCIMAngleBehavior: true, hasBackground: l12 }).boundsT;
    return e14[0] = c5.x - c5.halfWidth, e14[1] = -c5.y - c5.halfHeight, e14[2] = c5.x + c5.halfWidth, e14[3] = -c5.y + c5.halfHeight, e14;
  }
};
var K3 = class _K {
  static getEnvelope(e14, t15, r17) {
    if (!e14)
      return null;
    const o8 = new Y2(r17);
    if (Array.isArray(e14)) {
      let r18;
      for (const a12 of e14)
        r18 ? r18.union(O4(o8, a12, t15)) : r18 = O4(o8, a12, t15);
      return r18;
    }
    return O4(o8, e14, t15);
  }
  static getTextureAnchor(e14, t15) {
    const r17 = this.getEnvelope(e14, null, t15);
    if (!r17)
      return [0, 0, 0];
    const o8 = (r17.x + 0.5 * r17.width) * Y3, a12 = (r17.y + 0.5 * r17.height) * Y3, s12 = r17.width * Y3 + 2, i15 = r17.height * Y3 + 2;
    return [-o8 / s12, -a12 / i15, i15];
  }
  static rasterize(e14, t15, r17, o8, a12 = true) {
    const s12 = r17 || this.getEnvelope(t15, null, o8);
    if (!s12)
      return [null, 0, 0, 0, 0];
    const i15 = (s12.x + 0.5 * s12.width) * Y3, n18 = (s12.y + 0.5 * s12.height) * Y3;
    e14.width = s12.width * Y3, e14.height = s12.height * Y3, r17 || (e14.width += 2, e14.height += 2);
    const l12 = e14.getContext("2d", { willReadFrequently: true }), m7 = V.createScale(Y3, -Y3);
    m7.translate(0.5 * e14.width - i15, 0.5 * e14.height + n18);
    const h7 = new K2(l12, o8, m7);
    switch (t15.type) {
      case "CIMPointSymbol": {
        const e15 = { type: "point", x: 0, y: 0 };
        h7.drawSymbol(t15, e15);
        break;
      }
      case "CIMVectorMarker": {
        const e15 = new t7();
        h7.drawMarker(t15, e15);
        break;
      }
    }
    const u11 = l12.getImageData(0, 0, e14.width, e14.height), p5 = new Uint8Array(u11.data);
    if (a12) {
      let e15;
      for (let t16 = 0; t16 < p5.length; t16 += 4)
        e15 = p5[t16 + 3] / 255, p5[t16] = p5[t16] * e15, p5[t16 + 1] = p5[t16 + 1] * e15, p5[t16 + 2] = p5[t16 + 2] * e15;
    }
    return [p5, e14.width, e14.height, -i15 / e14.width, -n18 / e14.height];
  }
  static fromTextSymbol(e14) {
    const { text: t15 } = e14;
    return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, anchorPointUnits: "Relative", dominantSizeAxis3D: "Y", size: 10, billboardMode3D: "FaceNearPlane", frame: { xmin: -5, ymin: -5, xmax: 5, ymax: 5 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { x: 0, y: 0 }, symbol: _K.createCIMTextSymbolfromTextSymbol(e14), textString: t15 }], scaleSymbolsProportionally: true, respectFrame: true }], scaleX: 1, angleAlignment: "Display" };
  }
  static fromPictureFillSymbol(e14) {
    const { height: t15, outline: r17, width: o8, xoffset: a12, xscale: s12, yoffset: i15, yscale: n18 } = e14, l12 = [], c5 = { type: "CIMPolygonSymbol", symbolLayers: l12 };
    if (r17) {
      const e15 = ye(r17);
      e15 && l12.push(e15);
    }
    let m7 = e14.url;
    "esriPFS" === e14.type && e14.imageData && (m7 = e14.imageData);
    const f9 = "angle" in e14 ? e14.angle ?? 0 : 0, y5 = (o8 ?? 0) * (s12 || 1), h7 = (t15 ?? 0) * (n18 || 1);
    return l12.push({ type: "CIMPictureFill", invertBackfaceTexture: false, scaleX: 1, textureFilter: ie.Picture, tintColor: null, url: m7, height: h7, width: y5, offsetX: I(a12), offsetY: I(i15), rotation: I(-f9), colorSubstitutions: null }), c5;
  }
  static fromSimpleFillSymbol(e14) {
    const { color: r17, style: o8, outline: s12 } = e14, i15 = [], n18 = { type: "CIMPolygonSymbol", symbolLayers: i15 };
    if (s12) {
      const e15 = ye(s12);
      e15 && i15.push(e15);
    }
    if (o8 && "solid" !== o8 && "none" !== o8 && "esriSFSSolid" !== o8 && "esriSFSNull" !== o8) {
      const e15 = { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", color: oe2(r17), capStyle: U2.Butt, joinStyle: w2.Miter, width: 0.75 }] };
      let s13 = 0;
      const n19 = e3(me(o8) ? 8 : 10);
      switch (o8) {
        case "vertical":
        case "esriSFSVertical":
          s13 = 90;
          break;
        case "forward-diagonal":
        case "esriSFSForwardDiagonal":
        case "diagonal-cross":
        case "esriSFSDiagonalCross":
          s13 = -45;
          break;
        case "backward-diagonal":
        case "esriSFSBackwardDiagonal":
          s13 = 45;
          break;
        case "cross":
        case "esriSFSCross":
          s13 = 0;
      }
      i15.push({ type: "CIMHatchFill", lineSymbol: e15, offsetX: 0, offsetY: 0, rotation: s13, separation: n19 }), "cross" === o8 || "esriSFSCross" === o8 ? i15.push({ type: "CIMHatchFill", lineSymbol: a(e15), offsetX: 0, offsetY: 0, rotation: 90, separation: n19 }) : "diagonal-cross" !== o8 && "esriSFSDiagonalCross" !== o8 || i15.push({ type: "CIMHatchFill", lineSymbol: a(e15), offsetX: 0, offsetY: 0, rotation: 45, separation: n19 });
    } else
      !o8 || "solid" !== o8 && "esriSFSSolid" !== o8 || i15.push({ type: "CIMSolidFill", enable: true, color: oe2(r17) });
    return n18;
  }
  static fromSimpleLineSymbol(e14) {
    const { cap: t15, color: r17, join: o8, marker: a12, miterLimit: s12, style: i15, width: n18 } = e14;
    let l12 = null;
    "solid" !== i15 && "none" !== i15 && "esriSLSSolid" !== i15 && "esriSLSNull" !== i15 && (l12 = [{ type: "CIMGeometricEffectDashes", dashTemplate: ne2(i15, t15), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]);
    const c5 = [];
    if (a12) {
      let e15;
      switch (a12.placement) {
        case "begin-end":
          e15 = o2.Both;
          break;
        case "begin":
          e15 = o2.JustBegin;
          break;
        case "end":
          e15 = o2.JustEnd;
          break;
        default:
          e15 = o2.None;
      }
      const t16 = _K.fromSimpleMarker(a12, n18, r17).symbolLayers[0];
      t16.markerPlacement = { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: e15, offsetAlongLine: 0 }, c5.push(t16);
    }
    return c5.push({ type: "CIMSolidStroke", color: "none" !== i15 && "esriSLSNull" !== i15 ? oe2(r17) : [0, 0, 0, 0], capStyle: Z3(t15), joinStyle: ee(o8), miterLimit: s12, width: n18, effects: l12 }), { type: "CIMLineSymbol", symbolLayers: c5 };
  }
  static fromPictureMarker(e14) {
    const { angle: t15, height: r17, width: o8, xoffset: a12, yoffset: s12 } = e14;
    let i15 = e14.url;
    return "esriPMS" === e14.type && e14.imageData && (i15 = e14.imageData), { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMPictureMarker", invertBackfaceTexture: false, scaleX: 1, textureFilter: ie.Picture, tintColor: null, url: i15, size: r17, width: o8, offsetX: I(a12), offsetY: I(s12), rotation: I(-t15) }] };
  }
  static createCIMTextSymbolfromTextSymbol(t15) {
    const { angle: r17, color: o8, font: a12, haloColor: s12, haloSize: i15, horizontalAlignment: n18, kerning: l12, text: c5, verticalAlignment: m7, xoffset: f9, yoffset: y5, backgroundColor: h7, borderLineColor: u11, borderLineSize: p5 } = t15;
    let M4, S3, d4, L3, z2, D;
    a12 && (M4 = a12.family, S3 = a12.style, d4 = a12.weight, L3 = a12.size, z2 = a12.decoration);
    let E = false;
    if (c5) {
      E = i14(c5)[1];
    }
    return (h7 || p5) && (D = { type: "CIMBackgroundCallout", margin: null, backgroundSymbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", color: oe2(h7) }, { type: "CIMSolidStroke", color: oe2(u11), width: p5 }] }, accentBarSymbol: null, gap: null, leaderLineSymbol: null, lineStyle: null }), { type: "CIMTextSymbol", angle: r17, blockProgression: C2.BTT, depth3D: 1, extrapolateBaselines: true, fontEffects: l3.Normal, fontEncoding: a4.Unicode, fontFamilyName: M4 || "Arial", fontStyleName: ae(S3, d4), fontType: u5.Unspecified, haloSize: i15, height: L3, hinting: y.Default, horizontalAlignment: te(n18 ?? "center"), kerning: l12, letterWidth: 100, ligatures: true, lineGapType: "Multiple", offsetX: I(f9), offsetY: I(y5), strikethrough: "line-through" === z2, underline: "underline" === z2, symbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: oe2(o8) }] }, haloSymbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: oe2(s12) }] }, shadowColor: [0, 0, 0, 255], shadowOffsetX: 1, shadowOffsetY: 1, textCase: "Normal", textDirection: E ? ne.RTL : ne.LTR, verticalAlignment: re(m7 ?? "baseline"), verticalGlyphOrientation: oe.Right, wordSpacing: 100, billboardMode3D: m3.FaceNearPlane, callout: D };
  }
  static createPictureMarkerRasterizationParam(e14) {
    var _a, _b;
    const { angle: t15, height: r17, width: o8, xoffset: a12, yoffset: s12 } = e14, i15 = e14.url ?? ((_a = e14.source) == null ? void 0 : _a.url) ?? ((_b = e14.source) == null ? void 0 : _b.imageData);
    return i15 ? { type: "sprite-rasterization-param", overrides: [], resource: { type: "CIMPictureMarker", invertBackfaceTexture: false, scaleX: 1, textureFilter: ie.Picture, tintColor: null, url: i15, size: r17, width: o8, offsetX: I(a12), offsetY: I(s12), rotation: I(-t15) } } : null;
  }
  static createPictureFillRasterizationParam(e14) {
    const { width: t15, height: r17, xoffset: o8, yoffset: a12, url: s12 } = e14;
    return s12 ? { type: "sprite-rasterization-param", overrides: [], resource: { type: "CIMPictureFill", scaleX: 1, textureFilter: ie.Picture, tintColor: null, url: s12, width: t15, height: r17, offsetX: I(o8), offsetY: I(a12), rotation: 0 } } : null;
  }
  static fromSimpleMarker(e14, t15, r17) {
    const { style: o8 } = e14, a12 = e14.color ?? r17;
    if ("path" === o8 || "esriSMSPath" === o8) {
      const t16 = [];
      if ("outline" in e14 && e14.outline) {
        const r19 = e14.outline;
        t16.push({ type: "CIMSolidStroke", enable: true, width: r19.width, color: oe2(r19.color), path: e14.path });
      }
      t16.push({ type: "CIMSolidFill", enable: true, color: oe2(a12), path: e14.path });
      const [r18, o9] = ce("square");
      return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: -I(e14.angle), size: I(e14.size || 6), offsetX: I(e14.xoffset), offsetY: I(e14.yoffset), scaleSymbolsProportionally: false, frame: r18, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: o9, symbol: { type: "CIMPolygonSymbol", symbolLayers: t16 } }] }] };
    }
    const s12 = [];
    let i15, n18, l12 = e14.size;
    if ("outline" in e14 && e14.outline && "none" !== e14.outline.style && "esriSLSNull" !== e14.outline.style) {
      const t16 = e14.outline, r18 = "solid" !== t16.style && "esriSLSSolid" !== t16.style;
      [i15, n18] = r18 ? ce(o8, e14.size) : ce(o8);
      const a13 = t16.width ?? u4.width;
      if (r18) {
        const t17 = a13 / e14.size, r19 = (i15.xmax - i15.xmin) * t17 / 2, o9 = (i15.ymax - i15.ymin) * t17 / 2;
        i15.xmin -= r19, i15.xmax += r19, i15.ymin -= o9, i15.ymax += o9, l12 && (l12 += a13);
      }
      const c6 = "cross" !== e14.style && "x" !== e14.style || "dot" === (e14 == null ? void 0 : e14.outline.style) || "short-dot" === (e14 == null ? void 0 : e14.outline.style) ? k2.HalfGap : k2.FullPattern, m7 = r18 ? [{ type: "CIMGeometricEffectAddControlPoints" }, { type: "CIMGeometricEffectDashes", dashTemplate: ne2(t16.style, null).map((e15) => t16.width && t16.width > 0 ? e15 * t16.width : e15), lineDashEnding: c6, controlPointEnding: k2.FullPattern }] : void 0;
      s12.push({ type: "CIMSolidStroke", capStyle: r18 ? U2.Round : U2.Butt, enable: true, width: a13, color: oe2(t16.color), effects: m7 });
    } else
      !t15 || "line-marker" !== e14.type || "cross" !== e14.style && "x" !== e14.style ? [i15, n18] = ce(o8) : ([i15, n18] = ce(o8), s12.push({ type: "CIMSolidStroke", enable: true, width: t15, color: oe2(a12) }));
    s12.push({ type: "CIMSolidFill", enable: true, color: oe2(a12) });
    const c5 = { type: "CIMPolygonSymbol", symbolLayers: s12 };
    return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: I(-e14.angle), size: I(l12 || 6 * t15), offsetX: I(e14.xoffset), offsetY: I(e14.yoffset), scaleSymbolsProportionally: false, frame: i15, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: n18, symbol: c5 }] }] };
  }
  static fromCIMHatchFill(e14, r17) {
    var _a;
    const o8 = r17 * (e14.separation ?? t3.CIMHatchFill.separation), a12 = o8 / 2, s12 = a(e14.lineSymbol);
    (_a = s12.symbolLayers) == null ? void 0 : _a.forEach((e15) => {
      var _a2;
      switch (e15.type) {
        case "CIMSolidStroke":
          null != e15.width && (e15.width *= r17), (_a2 = e15.effects) == null ? void 0 : _a2.forEach((e16) => {
            if ("CIMGeometricEffectDashes" === e16.type) {
              const t15 = e16.dashTemplate;
              e16.dashTemplate = t15.map((e17) => e17 * r17);
            }
          });
          break;
        case "CIMVectorMarker": {
          null != e15.size && (e15.size *= r17);
          const t15 = e15.markerPlacement;
          null != t15 && "placementTemplate" in t15 && (t15.placementTemplate = t15.placementTemplate.map((e16) => e16 * r17));
          break;
        }
      }
    });
    let i15 = this._getLineSymbolPeriod(s12) || _4;
    for (; i15 < _4; )
      i15 *= 2;
    const n18 = i15 / 2;
    return { type: "CIMVectorMarker", frame: { xmin: -n18, xmax: n18, ymin: -a12, ymax: a12 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { paths: [[[-n18, 0], [n18, 0]]] }, symbol: s12 }], size: o8 };
  }
  static fetchResources(e14, t15, r17, o8 = null) {
    return e14 && t15 ? (Q2(e14, (e15) => {
      fe(e15, t15, r17), "url" in e15 && e15.url && r17.push(t15.fetchResource(e15.url, { signal: o8 }));
    }), r17) : r17;
  }
  static fetchFonts(e14, t15, r17) {
    if (e14 && t15) {
      if ("symbolLayers" in e14 && e14.symbolLayers) {
        for (const o8 of e14.symbolLayers)
          if ("CIMVectorMarker" === o8.type && o8.markerGraphics)
            for (const e15 of o8.markerGraphics)
              (e15 == null ? void 0 : e15.symbol) && _K.fetchFonts(e15.symbol, t15, r17);
      } else if ("CIMTextSymbol" === e14.type) {
        const { fontFamilyName: o8, fontStyleName: a12 } = e14;
        if (!o8 || "calcitewebcoreicons" === o8.toLowerCase())
          return;
        const { style: s12, weight: i15 } = P(a12), n18 = w(e14), c5 = new m2({ family: o8, style: s12, weight: i15, decoration: n18 });
        r17.push(t15.loadFont(c5).catch(() => {
          H().error(`Unsupported font ${o8} in CIM symbol`);
        }));
      }
    }
  }
  static _getLineSymbolPeriod(e14) {
    if (e14) {
      const t15 = this._getEffectsRepeat(e14.effects);
      if (t15)
        return t15;
      if (e14.symbolLayers) {
        for (const r17 of e14.symbolLayers)
          if (r17) {
            const e15 = this._getEffectsRepeat(r17.effects);
            if (e15)
              return e15;
            switch (r17.type) {
              case "CIMCharacterMarker":
              case "CIMPictureMarker":
              case "CIMVectorMarker":
              case "CIMObjectMarker3D":
              case "CIMglTFMarker3D": {
                const e16 = this._getPlacementRepeat(r17.markerPlacement);
                if (e16)
                  return e16;
              }
            }
          }
      }
    }
    return 0;
  }
  static _getEffectsRepeat(e14) {
    if (e14) {
      for (const t15 of e14)
        if (t15)
          switch (t15.type) {
            case "CIMGeometricEffectDashes": {
              const e15 = t15.dashTemplate;
              if (e15 && e15.length) {
                let t16 = 0;
                for (const r17 of e15)
                  t16 += r17;
                return 1 & e15.length && (t16 *= 2), t16;
              }
              break;
            }
            case "CIMGeometricEffectWave":
              return t15.period;
            default:
              H().error(`unsupported geometric effect type ${t15.type}`);
          }
    }
    return 0;
  }
  static _getPlacementRepeat(e14) {
    if (e14)
      switch (e14.type) {
        case "CIMMarkerPlacementAlongLineSameSize":
        case "CIMMarkerPlacementAlongLineRandomSize":
        case "CIMMarkerPlacementAlongLineVariableSize": {
          const t15 = e14.placementTemplate;
          if (t15 && t15.length) {
            let e15 = 0;
            for (const r17 of t15)
              e15 += +r17;
            return 1 & t15.length && (e15 *= 2), e15;
          }
          break;
        }
      }
    return 0;
  }
  static fromCIMInsidePolygon(e14) {
    const t15 = e14.markerPlacement, r17 = { ...e14 };
    r17.markerPlacement = null, r17.anchorPoint = null;
    const s12 = Math.abs(t15.stepX), i15 = Math.abs(t15.stepY), n18 = (t15.randomness ?? 100) / 100;
    let l12, c5, m7, f9;
    if ("Random" === t15.gridType) {
      const e15 = e3(lt), r18 = Math.max(Math.floor(e15 / s12), 1), y5 = Math.max(Math.floor(e15 / i15), 1);
      l12 = r18 * s12 / 2, c5 = y5 * i15 / 2, m7 = 2 * c5;
      const h7 = new t(t15.seed), u11 = n18 * s12 / 1.5, p5 = n18 * i15 / 1.5;
      f9 = [];
      for (let t16 = 0; t16 < r18; t16++)
        for (let e16 = 0; e16 < y5; e16++) {
          const r19 = t16 * s12 - l12 + u11 * (0.5 - h7.getFloat()), o8 = e16 * i15 - c5 + p5 * (0.5 - h7.getFloat());
          f9.push({ x: r19, y: o8 }), 0 === t16 && f9.push({ x: r19 + 2 * l12, y: o8 }), 0 === e16 && f9.push({ x: r19, y: o8 + 2 * c5 });
        }
    } else
      true === t15.shiftOddRows ? (l12 = s12 / 2, c5 = i15, m7 = 2 * i15, f9 = [{ x: -l12, y: 0 }, { x: l12, y: 0 }, { x: 0, y: c5 }, { x: 0, y: -c5 }]) : (l12 = s12 / 2, c5 = i15 / 2, m7 = i15, f9 = [{ x: -s12, y: 0 }, { x: 0, y: -i15 }, { x: -s12, y: -i15 }, { x: 0, y: 0 }, { x: s12, y: 0 }, { x: 0, y: i15 }, { x: s12, y: i15 }, { x: -s12, y: i15 }, { x: s12, y: -i15 }]);
    return { type: "CIMVectorMarker", frame: { xmin: -l12, xmax: l12, ymin: -c5, ymax: c5 }, markerGraphics: f9.map((e15) => ({ type: "CIMMarkerGraphic", geometry: e15, symbol: { type: "CIMPointSymbol", symbolLayers: [r17] } })), size: m7 };
  }
};
function Q2(e14, t15) {
  if (e14)
    switch (e14.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol": {
        const r17 = e14.symbolLayers;
        if (!r17)
          return;
        for (const e15 of r17)
          if (t15(e15), "CIMVectorMarker" === e15.type) {
            const r18 = e15.markerGraphics;
            if (!r18)
              continue;
            for (const e16 of r18)
              if (e16) {
                const r19 = e16.symbol;
                r19 && Q2(r19, t15);
              }
          }
        break;
      }
    }
}
var Z3 = (e14) => {
  if (!e14)
    return U2.Butt;
  switch (e14) {
    case "butt":
      return U2.Butt;
    case "square":
      return U2.Square;
    case "round":
      return U2.Round;
  }
};
var ee = (e14) => {
  if (!e14)
    return w2.Miter;
  switch (e14) {
    case "miter":
      return w2.Miter;
    case "round":
      return w2.Round;
    case "bevel":
      return w2.Bevel;
  }
};
var te = (e14) => {
  if (null == e14)
    return "Center";
  switch (e14) {
    case "left":
      return "Left";
    case "right":
      return "Right";
    case "center":
      return "Center";
  }
};
var re = (e14) => {
  if (null == e14)
    return "Center";
  switch (e14) {
    case "baseline":
      return "Baseline";
    case "top":
      return "Top";
    case "middle":
      return "Center";
    case "bottom":
      return "Bottom";
  }
};
var oe2 = (e14) => {
  if (!e14)
    return [0, 0, 0, 0];
  const { r: t15, g: r17, b: o8, a: a12 } = e14;
  return [t15, r17, o8, 255 * a12];
};
var ae = (e14, t15) => {
  const r17 = se(t15), o8 = ie2(e14);
  return r17 && o8 ? `${r17}-${o8}` : `${r17}${o8}`;
};
var se = (e14) => {
  if (!e14)
    return "";
  switch (e14.toLowerCase()) {
    case "bold":
    case "bolder":
      return "bold";
  }
  return "";
};
var ie2 = (e14) => {
  if (!e14)
    return "";
  switch (e14.toLowerCase()) {
    case "italic":
    case "oblique":
      return "italic";
  }
  return "";
};
var ne2 = (e14, t15) => {
  const r17 = has("safari") ? 1e-3 : 0, o8 = "butt" === t15;
  switch (e14) {
    case "dash":
    case "esriSLSDash":
      return o8 ? [4, 3] : [3, 4];
    case "dash-dot":
    case "esriSLSDashDot":
      return o8 ? [4, 3, 1, 3] : [3, 4, r17, 4];
    case "dot":
    case "esriSLSDot":
      return o8 ? [1, 3] : [r17, 4];
    case "long-dash":
    case "esriSLSLongDash":
      return o8 ? [8, 3] : [7, 4];
    case "long-dash-dot":
    case "esriSLSLongDashDot":
      return o8 ? [8, 3, 1, 3] : [7, 4, r17, 4];
    case "long-dash-dot-dot":
    case "esriSLSDashDotDot":
      return o8 ? [8, 3, 1, 3, 1, 3] : [7, 4, r17, 4, r17, 4];
    case "short-dash":
    case "esriSLSShortDash":
      return o8 ? [4, 1] : [3, 2];
    case "short-dash-dot":
    case "esriSLSShortDashDot":
      return o8 ? [4, 1, 1, 1] : [3, 2, r17, 2];
    case "short-dash-dot-dot":
    case "esriSLSShortDashDotDot":
      return o8 ? [4, 1, 1, 1, 1, 1] : [3, 2, r17, 2, r17, 2];
    case "short-dot":
    case "esriSLSShortDot":
      return o8 ? [1, 1] : [r17, 2];
    case "solid":
    case "esriSLSSolid":
    case "none":
      return H().error("Unexpected: style does not require rasterization"), [0, 0];
    default:
      return H().error(`Tried to rasterize SLS, but found an unexpected style: ${e14}!`), [0, 0];
  }
};
function le(e14) {
  return void 0 !== e14.symbolLayers;
}
var ce = (e14, t15 = 100) => {
  const r17 = t15 / 2;
  let o8, a12;
  const s12 = e14;
  if ("circle" === s12 || "esriSMSCircle" === s12) {
    const e15 = 0.25;
    let t16 = Math.acos(1 - e15 / r17), s13 = Math.ceil(X2 / t16 / 4);
    0 === s13 && (s13 = 1), t16 = V2 / s13, s13 *= 4;
    const i15 = [];
    i15.push([r17, 0]);
    for (let o9 = 1; o9 < s13; o9++)
      i15.push([r17 * Math.cos(o9 * t16), -r17 * Math.sin(o9 * t16)]);
    i15.push([r17, 0]), o8 = { rings: [i15] }, a12 = { xmin: -r17, ymin: -r17, xmax: r17, ymax: r17 };
  } else if ("cross" === s12 || "esriSMSCross" === s12) {
    const e15 = 0;
    o8 = { paths: [[[e15, r17], [e15, -r17]], [[r17, e15], [-r17, e15]]] }, a12 = { xmin: -r17, ymin: -r17, xmax: r17, ymax: r17 };
  } else if ("diamond" === s12 || "esriSMSDiamond" === s12)
    o8 = { rings: [[[-r17, 0], [0, r17], [r17, 0], [0, -r17], [-r17, 0]]] }, a12 = { xmin: -r17, ymin: -r17, xmax: r17, ymax: r17 };
  else if ("square" === s12 || "esriSMSSquare" === s12)
    o8 = { rings: [[[-r17, -r17], [-r17, r17], [r17, r17], [r17, -r17], [-r17, -r17]]] }, a12 = { xmin: -r17, ymin: -r17, xmax: r17, ymax: r17 };
  else if ("x" === s12 || "esriSMSX" === s12)
    o8 = { paths: [[[r17, r17], [-r17, -r17]], [[r17, -r17], [-r17, r17]]] }, a12 = { xmin: -r17, ymin: -r17, xmax: r17, ymax: r17 };
  else if ("triangle" === s12 || "esriSMSTriangle" === s12) {
    const e15 = t15 * 0.5773502691896257, r18 = -e15, s13 = 2 / 3 * t15, i15 = s13 - t15;
    o8 = { rings: [[[r18, i15], [0, s13], [e15, i15], [r18, i15]]] }, a12 = { xmin: r18, ymin: i15, xmax: e15, ymax: s13 };
  } else
    "arrow" === s12 && (o8 = { rings: [[[-50, 50], [50, 0], [-50, -50], [-33, -20], [-33, 20], [-50, 50]]] }, a12 = { xmin: -r17, ymin: -r17, xmax: r17, ymax: r17 });
  return [a12, o8];
};
var me = (e14) => "vertical" === e14 || "horizontal" === e14 || "cross" === e14 || "esriSFSCross" === e14 || "esriSFSVertical" === e14 || "esriSFSHorizontal" === e14;
function fe(e14, t15, r17) {
  if (!e14.effects || null != t15.geometryEngine)
    return;
  if (t15.geometryEnginePromise)
    return void r17.push(t15.geometryEnginePromise);
  d(e14.effects) && (t15.geometryEnginePromise = k(), r17.push(t15.geometryEnginePromise), t15.geometryEnginePromise.then((e15) => t15.geometryEngine = e15));
}
function ye(e14) {
  if (!e14)
    return null;
  let t15 = null;
  const { cap: r17, color: o8, join: a12, miterLimit: s12, style: i15, width: n18 } = e14;
  return "solid" !== i15 && "none" !== i15 && "esriSLSSolid" !== i15 && "esriSLSNull" !== i15 && (t15 = [{ type: "CIMGeometricEffectDashes", dashTemplate: ne2(i15, r17), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]), { type: "CIMSolidStroke", color: "esriSLSNull" !== i15 && "none" !== i15 ? oe2(o8) : [0, 0, 0, 0], capStyle: Z3(r17), joinStyle: ee(a12), miterLimit: s12, width: n18, effects: t15 };
}

export {
  a6 as a,
  s6 as s,
  l10 as l,
  A3 as A,
  g3 as g,
  i14 as i,
  t14 as t,
  a11 as a2,
  c4 as c,
  o6 as o,
  s10 as s2,
  i12 as i2,
  O2 as O,
  V,
  W,
  K2 as K,
  U3 as U,
  $2 as $,
  J2 as J,
  K3 as K2,
  Z3 as Z,
  ne2 as ne
};
//# sourceMappingURL=chunk-ZPU7GNG4.js.map
