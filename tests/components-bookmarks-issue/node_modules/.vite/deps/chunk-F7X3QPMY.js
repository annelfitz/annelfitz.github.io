import {
  j,
  p as p2
} from "./chunk-2SYXH2R7.js";
import {
  u
} from "./chunk-C7NPPGFR.js";
import {
  F,
  h,
  y
} from "./chunk-OCF7OAES.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  f as f2,
  p,
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  A,
  W2 as W
} from "./chunk-UWQ3OYA5.js";
import {
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/views/3d/terrain/TilingScheme.js
var g = 12;
var f3 = class _f {
  constructor(e) {
    const i = _f.checkUnsupported(e);
    if (null != i)
      throw i;
    const t = e;
    this.spatialReference = t.spatialReference, this._isWebMercator = this.spatialReference.isWebMercator, this._isGCS = A(this.spatialReference), this.origin = [t.origin.x, t.origin.y], this.pixelSize = t.size[0], this.dpi = t.dpi;
    const s2 = t.lods.reduce((e2, i2, t2) => (i2.level < e2.min && (e2.min = i2.level, e2.minIndex = t2), e2.max = Math.max(e2.max, i2.level), e2), { min: 1 / 0, minIndex: 0, max: -1 / 0 }), r = t.lods[s2.minIndex], n = 2 ** r.level;
    let l = r.resolution * n, o = r.scale * n;
    this.levels = new Array(s2.max + 1);
    for (let a = 0; a < this.levels.length; a++)
      this.levels[a] = { resolution: l, scale: o, tileSize: [l * t.size[0], l * t.size[1]] }, l /= 2, o /= 2;
  }
  clone() {
    return new _f(this.toTileInfo());
  }
  toTileInfo() {
    return new j({ dpi: this.dpi, origin: new x({ x: this.origin[0], y: this.origin[1], spatialReference: this.spatialReference }), size: [this.pixelSize, this.pixelSize], spatialReference: this.spatialReference, lods: this.levels.map((e, i) => new p2({ level: i, scale: e.scale, resolution: e.resolution })) });
  }
  getExtent(e, i, t, s2) {
    const r = this.levels[e], n = r.tileSize[0], l = r.tileSize[1];
    s2[0] = this.origin[0] + t * n, s2[2] = this.origin[0] + (t + 1) * n, s2[3] = this.origin[1] - i * l, s2[1] = this.origin[1] - (i + 1) * l;
  }
  convertExtentToRadians(e, t) {
    this._isWebMercator ? (t[0] = p(e[0]), t[1] = f2(e[1]), t[2] = p(e[2]), t[3] = f2(e[3])) : this._isGCS && (t[0] = h(e[0]), t[1] = h(e[1]), t[2] = h(e[2]), t[3] = h(e[3]));
  }
  getExtentGeometry(e, i, t, s2 = new w()) {
    return this.getExtent(e, i, t, v), s2.spatialReference = this.spatialReference, s2.xmin = v[0], s2.ymin = v[1], s2.xmax = v[2], s2.ymax = v[3], s2.zmin = void 0, s2.zmax = void 0, s2;
  }
  ensureMaxLod(e) {
    if (null == e)
      return false;
    let i = false;
    for (; this.levels.length <= e; ) {
      const { resolution: e2, scale: t } = this.levels[this.levels.length - 1], s2 = e2 / 2 * this.pixelSize;
      this.levels.push({ resolution: e2 / 2, scale: t / 2, tileSize: [s2, s2] }), i = true;
    }
    return i;
  }
  capMaxLod(e) {
    this.levels.length > e + 1 && (this.levels.length = e + 1);
  }
  getMaxLod() {
    return this.levels.length - 1;
  }
  scaleAtLevel(e) {
    return this.levels[0].scale / 2 ** e;
  }
  levelAtScale(e) {
    const i = this.levels[0].scale;
    return e >= i ? 0 : Math.log(i / e) * Math.LOG2E;
  }
  resolutionAtLevel(e) {
    return this.levels[0].resolution / 2 ** e;
  }
  compatibleWith(e, i = 1 / 0) {
    if (_f.checkUnsupported(e))
      return false;
    const s2 = new _f(e);
    if (!s2.spatialReference.equals(this.spatialReference))
      return false;
    if (s2.pixelSize !== this.pixelSize)
      return false;
    const r = Math.min(this.levels.length - 1, s2.levels.length - 1, i), n = this.levels[r].resolution;
    let l = 0.5 * n;
    if (!F(s2.origin[0], this.origin[0], l) || !F(s2.origin[1], this.origin[1], l))
      return false;
    return l = 0.5 * n / 2 ** r / this.pixelSize * g, F(n, s2.levels[r].resolution, l);
  }
  rootTilesInExtent(e, i = null, t = 1 / 0) {
    const s2 = new Array(), r = this.levels[0].tileSize;
    if (null == e || 0 === r[0] || 0 === r[1])
      return s2;
    _f.computeRowColExtent(e, r, this.origin, v);
    let n = v[1], l = v[3], o = v[0], a = v[2];
    const h2 = a - o, c = l - n;
    if (h2 * c > t) {
      const e2 = Math.floor(Math.sqrt(t));
      c > e2 && (n = n + Math.floor(0.5 * c) - Math.floor(0.5 * e2), l = n + e2), h2 > e2 && (o = o + Math.floor(0.5 * h2) - Math.floor(0.5 * e2), a = o + e2);
    }
    for (let m = n; m < l; m++)
      for (let e2 = o; e2 < a; e2++)
        s2.push([0, m, e2]);
    return null != i && (i[0] = this.origin[0] + o * r[0], i[1] = this.origin[1] - l * r[1], i[2] = this.origin[0] + a * r[0], i[3] = this.origin[1] - n * r[1]), s2;
  }
  static computeRowColExtent(e, i, t, s2) {
    const r = 1e-3 * (e[2] - e[0] + (e[3] - e[1]));
    s2[0] = Math.max(0, Math.floor((e[0] + r - t[0]) / i[0])), s2[2] = Math.max(0, Math.ceil((e[2] - r - t[0]) / i[0])), s2[1] = Math.max(0, Math.floor((t[1] - e[3] + r) / i[1])), s2[3] = Math.max(0, Math.ceil((t[1] - e[1] - r) / i[1]));
  }
  static isPowerOfTwo(e) {
    const i = e.lods, t = i[0].resolution * 2 ** i[0].level;
    return !i.some((e2) => !y(e2.resolution, t / 2 ** e2.level));
  }
  static hasGapInLevels(e) {
    const i = e.lods.map((e2) => e2.level);
    i.sort((e2, i2) => e2 - i2);
    for (let t = 1; t < i.length; t++)
      if (i[t] !== i[0] + t)
        return true;
    return false;
  }
  static tileSizeSupported(e) {
    const i = e.size[1];
    return i === e.size[0] && !(i & i - 1) && i >= 128 && i <= 512;
  }
  static hasOriginPerLODs(e) {
    const i = e.origin;
    return e.lods.some((e2) => null != e2.origin && (e2.origin[0] !== i.x || e2.origin[1] !== i.y));
  }
  static getMissingTileInfoError() {
    return new s("tilingscheme:tile-info-missing", "Tiling scheme must have tiling information");
  }
  static checkUnsupported(i) {
    return null == i ? x2() : i.lods.length < 1 ? new s("tilingscheme:generic", "Tiling scheme must have at least one level") : _f.isPowerOfTwo(i) ? _f.hasGapInLevels(i) ? new s("tilingscheme:gaps", "Tiling scheme levels must not have gaps between min and max level") : _f.tileSizeSupported(i) ? _f.hasOriginPerLODs(i) ? new s("tilingscheme:multiple-origin", "Tiling scheme levels must not have their own origin") : null : new s("tilingscheme:tile-size", "Tiles must be square and size must be one of [128, 256, 512]") : new s("tilingscheme:power-of-two", "Tiling scheme must be power of two");
  }
  static fromExtent(e, i) {
    const t = e[2] - e[0], s2 = e[3] - e[1], n = W(i), l = 1.2 * Math.max(t, s2), o = 256, a = l / o, h2 = a * n * (96 / 0.0254), c = new _f(new j({ size: [o, o], origin: new x({ x: e[0] - 0.5 * (l - t), y: e[3] + 0.5 * (l - s2) }), lods: [new p2({ level: 0, resolution: a, scale: h2 })], spatialReference: i }));
    return c.ensureMaxLod(20), c;
  }
  static makeWebMercatorAuxiliarySphere(e) {
    const i = new _f(_f.WebMercatorAuxiliarySphereTileInfo);
    return i.ensureMaxLod(e), i;
  }
  static makeGCSWithTileSize(e, i = 256, t = 16) {
    const s2 = 256 / i, r = new _f(new j({ size: [i, i], origin: new x({ x: -180, y: 90, spatialReference: e }), spatialReference: e, lods: [new p2({ level: 0, resolution: 0.703125 * s2, scale: 295497598570834e-6 * s2 })] }));
    return r.ensureMaxLod(t), r;
  }
  get test() {
    return { isWebMercator: this._isWebMercator, isGCS: this._isGCS };
  }
};
function x2() {
  return new s("tilingscheme:tile-info-missing", "Tiling scheme must have tiling information");
}
f3.WebMercatorAuxiliarySphereTileInfo = new j({ size: [256, 256], origin: new x({ x: -20037508342787e-6, y: 20037508342787e-6, spatialReference: f.WebMercator }), spatialReference: f.WebMercator, lods: [new p2({ level: 0, resolution: 156543.03392800014, scale: 591657527591555e-6 })] }), f3.WebMercatorAuxiliarySphere = f3.makeWebMercatorAuxiliarySphere(19);
var v = u();

export {
  f3 as f,
  x2 as x
};
//# sourceMappingURL=chunk-F7X3QPMY.js.map
