import {
  c
} from "./chunk-QD3CP3I4.js";
import {
  e as e2,
  n as n2
} from "./chunk-E5PVY3UF.js";
import {
  m
} from "./chunk-PGOAFABD.js";
import "./chunk-63NZBHDP.js";
import {
  $
} from "./chunk-BNDDKY53.js";
import "./chunk-BECEVYQR.js";
import "./chunk-S243OWEZ.js";
import "./chunk-QYDOVVH7.js";
import "./chunk-YSXT2SWC.js";
import {
  x
} from "./chunk-DGRFM5OL.js";
import "./chunk-AOAT6HYL.js";
import "./chunk-YH3SFFF7.js";
import "./chunk-JBU54P54.js";
import "./chunk-UQEUYEWU.js";
import "./chunk-5LIYYE75.js";
import {
  i as i2,
  o
} from "./chunk-ZECONJNT.js";
import "./chunk-UWZ4CRJK.js";
import "./chunk-TLTAGTBA.js";
import "./chunk-2QPP5AGU.js";
import {
  t
} from "./chunk-2C26DRKK.js";
import {
  e
} from "./chunk-M4RFJU4F.js";
import "./chunk-WVKWBQ7C.js";
import "./chunk-RK2U53CD.js";
import "./chunk-YPY24RRU.js";
import "./chunk-O7RKI2QW.js";
import "./chunk-BMB27ANS.js";
import "./chunk-3FOBZIUS.js";
import {
  t as t2
} from "./chunk-JKLFCJPR.js";
import {
  Z
} from "./chunk-QNG4TY7L.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import "./chunk-Y546C2O5.js";
import "./chunk-IYKBAIQE.js";
import "./chunk-BDRVHR2K.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import "./chunk-I2X6UR6L.js";
import "./chunk-HV2SFSJW.js";
import "./chunk-SBARCIDP.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-326OSIM5.js";
import "./chunk-HTKSTTSR.js";
import {
  H,
  K,
  d2
} from "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import {
  U as U2
} from "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import {
  i
} from "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-PWPXYWXV.js";
import "./chunk-545NO6M2.js";
import "./chunk-5LSHHVQ5.js";
import "./chunk-IZKCZQUY.js";
import {
  M
} from "./chunk-M5ZB5S5C.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  G,
  g2 as g,
  w
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import {
  I,
  U,
  bt
} from "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import {
  d
} from "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import "./chunk-NDIXNREV.js";
import "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  b
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/layers/graphics/sources/csv/csv.js
var r = /^\s*"([\S\s]*)"\s*$/;
var l = /""/g;
var o2 = "\n";
var s2 = [",", " ", ";", "|", "	"];
function* u(e3, t3, n3) {
  let i3 = 0;
  for (; i3 <= e3.length; ) {
    const r2 = e3.indexOf(t3, i3), l2 = e3.substring(i3, r2 > -1 ? r2 : void 0);
    i3 += l2.length + t3.length, n3 && !l2.trim() || (yield l2);
  }
}
function c2(e3) {
  const t3 = e3.includes("\r\n") ? "\r\n" : o2;
  return u(e3, t3, true);
}
function d3(e3, t3) {
  return u(e3, t3, false);
}
function f2(e3, t3, n3) {
  e3 = e3.trim(), t3 = t3 == null ? void 0 : t3.trim();
  const i3 = [], r2 = Array.from(/* @__PURE__ */ new Set([n3 == null ? void 0 : n3.delimiter, ...s2])).filter((e4) => null != e4);
  for (const o3 of r2) {
    const n4 = m2(e3, o3).length, r3 = m2(t3, o3).length ?? n4;
    n4 > 1 && i3.push({ weight: Math.min(n4, r3), delimiter: o3 });
  }
  const l2 = i3.sort(({ weight: e4 }, { weight: t4 }) => t4 - e4).map(({ delimiter: e4 }) => e4);
  for (const o3 of l2) {
    const t4 = h(g2(e3, o3).names, n3 == null ? void 0 : n3.longitudeField, n3 == null ? void 0 : n3.latitudeField);
    if (t4.longitudeFieldName && t4.latitudeFieldName)
      return { delimiter: o3, locationInfo: t4 };
  }
  return { delimiter: l2[0], locationInfo: null };
}
function* a(e3, t3, n3, i3 = () => /* @__PURE__ */ Object.create(null)) {
  const s3 = c2(e3);
  s3.next();
  let u2 = "", f3 = "", a2 = 0, g3 = i3(), m3 = 0;
  e:
    for (const c3 of s3) {
      const e4 = d3(c3, n3);
      for (const o3 of e4)
        if (u2 += f3 + o3, f3 = "", a2 += p(o3), a2 % 2 == 0) {
          if (a2 > 0) {
            const e5 = r.exec(u2);
            if (!e5) {
              g3 = i3(), m3 = 0, u2 = "", a2 = 0;
              continue e;
            }
            g3[t3[m3]] = e5[1].replaceAll(l, '"'), m3++;
          } else
            g3[t3[m3]] = u2, m3++;
          u2 = "", a2 = 0;
        } else
          f3 = n3;
      0 === a2 ? (yield g3, g3 = i3(), m3 = 0) : f3 = o2;
    }
}
function g2(e3, t3) {
  const i3 = m2(e3, t3).filter((e4) => null != e4), r2 = i3.map((e4) => d2(e4));
  for (let n3 = r2.length - 1; n3 >= 0; n3--)
    r2[n3] || (r2.splice(n3, 1), i3.splice(n3, 1));
  return { names: r2, aliases: i3 };
}
function m2(e3, t3) {
  if (!(e3 == null ? void 0 : e3.length))
    return [];
  const n3 = [];
  let i3 = "", o3 = "", s3 = 0;
  const u2 = d3(e3, t3);
  for (const c3 of u2)
    if (i3 += o3 + c3, o3 = "", s3 += p(c3), s3 % 2 == 0) {
      if (s3 > 0) {
        const e4 = r.exec(i3);
        e4 && n3.push(e4[1].replaceAll(l, '"'));
      } else
        n3.push(i3);
      i3 = "", s3 = 0;
    } else
      o3 = t3;
  return n3;
}
function p(e3) {
  let t3 = 0, n3 = 0;
  for (n3 = e3.indexOf('"', n3); n3 >= 0; )
    t3++, n3 = e3.indexOf('"', n3 + 1);
  return t3;
}
function h(e3, t3, i3) {
  var _a, _b;
  t3 = (_a = d2(t3)) == null ? void 0 : _a.toLowerCase(), i3 = (_b = d2(i3)) == null ? void 0 : _b.toLowerCase();
  const r2 = e3.map((e4) => e4.toLowerCase()), l2 = t3 ? e3[r2.indexOf(t3)] : null, o3 = i3 ? e3[r2.indexOf(i3)] : null;
  return { longitudeFieldName: l2 || e3[r2.indexOf(F.find((e4) => r2.includes(e4)))], latitudeFieldName: o3 || e3[r2.indexOf(y.find((e4) => r2.includes(e4)))] };
}
function b2(e3, t3, n3, r2, l2) {
  const o3 = [], s3 = a(e3, n3, t3), u2 = [];
  for (const i3 of s3) {
    if (10 === u2.length)
      break;
    u2.push(i3);
  }
  for (let c3 = 0; c3 < n3.length; c3++) {
    const e4 = n3[c3], t4 = r2[c3];
    if (e4 === l2.longitudeFieldName || e4 === l2.latitudeFieldName)
      o3.push({ name: e4, type: "esriFieldTypeDouble", alias: t4 });
    else {
      let n4;
      switch (N(u2.map((t5) => t5[e4]))) {
        case "integer":
          n4 = "esriFieldTypeInteger";
          break;
        case "double":
          n4 = "esriFieldTypeDouble";
          break;
        case "date":
          n4 = "esriFieldTypeDate";
          break;
        default:
          n4 = "esriFieldTypeString";
      }
      o3.push({ name: e4, type: n4, alias: t4, length: K(n4) });
    }
  }
  return o3;
}
function N(t3) {
  if (!t3.length)
    return "string";
  const n3 = /[^+\-.,0-9]/;
  return t3.map((t4) => {
    if ("" !== t4) {
      if (!n3.test(t4)) {
        let e3 = x2(t4);
        if (!isNaN(e3))
          return /[.,]/.test(t4) || !Number.isInteger(e3) || e3 > 214783647 || e3 < -214783648 ? "double" : "integer";
        if (t4.includes("E")) {
          if (e3 = Number(t4), !Number.isNaN(e3))
            return "double";
          if (t4.includes(",") && (t4 = t4.replace(",", "."), e3 = Number(t4), !Number.isNaN(e3)))
            return "double";
        }
      }
      return e2(t4) ? "date" : "string";
    }
  }).reduce((e3, t4) => void 0 === e3 ? t4 : void 0 === t4 ? e3 : e3 === t4 ? t4 : "string" === e3 || "string" === t4 ? "string" : "double" === e3 || "double" === t4 ? "double" : void 0);
}
var x2 = function() {
  const e3 = c(), n3 = new RegExp("^" + e3.regexp + "$"), i3 = new RegExp("[" + e3.group + "\\s\\xa0]", "g"), r2 = e3.factor;
  return (t3) => {
    const l2 = n3.exec(t3);
    if (e3.factor = r2, !l2)
      return NaN;
    let o3 = l2[1];
    if (!l2[1]) {
      if (!l2[2])
        return NaN;
      o3 = l2[2], e3.factor *= -1;
    }
    return o3 = o3.replace(i3, "").replace(e3.decimal, "."), +o3 * e3.factor;
  };
}();
var y = ["lat", "latitude", "latitude83", "latdecdeg", "lat_dd", "y", "ycenter", "point_y"];
var F = ["lon", "lng", "long", "longitude", "longitude83", "longdecdeg", "long_dd", "x", "xcenter", "point_x"];

// node_modules/@arcgis/core/layers/graphics/sources/support/CSVSourceWorker.js
var O = o("esriGeometryPoint");
var v = ["csv"];
var D = [0, 0];
var k = class {
  constructor(e3, t3) {
    this.x = e3, this.y = t3;
  }
};
var P = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e3) => {
      const t3 = await this._fetch(e3);
      return this._createFeatures(t3);
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = null;
  }
  async load(e3, t3 = {}) {
    var _a;
    this._loadOptions = e3;
    const [i3] = await Promise.all([this._fetch(t3.signal), this._checkProjection((_a = e3 == null ? void 0 : e3.parsingOptions) == null ? void 0 : _a.spatialReference)]), n3 = R(i3, e3);
    this._locationInfo = n3.locationInfo, this._delimiter = n3.delimiter, this._queryEngine = this._createQueryEngine(n3);
    const r2 = await this._createFeatures(i3);
    this._queryEngine.featureStore.addMany(r2);
    const { fullExtent: s3, timeExtent: o3 } = await this._queryEngine.fetchRecomputedExtents();
    if (n3.layerDefinition.extent = s3, o3) {
      const { start: e4, end: t4 } = o3;
      n3.layerDefinition.timeInfo.timeExtent = [e4, t4];
    }
    return n3;
  }
  async applyEdits() {
    throw new s("csv-layer:editing-not-supported", "applyEdits() is not supported on CSVLayer");
  }
  async queryFeatures(e3 = {}, t3 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e3, t3.signal);
  }
  async queryFeatureCount(e3 = {}, t3 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e3, t3.signal);
  }
  async queryObjectIds(e3 = {}, t3 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e3, t3.signal);
  }
  async queryExtent(e3 = {}, t3 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e3, t3.signal);
  }
  async querySnapping(e3, t3 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e3, t3.signal);
  }
  async refresh(e3) {
    var _a;
    this._loadOptions.customParameters = e3, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d(this._snapshotFeatures), this._snapshotTask.promise.then((e4) => {
      this._queryEngine.featureStore.clear(), e4 && this._queryEngine.featureStore.addMany(e4);
    }, (e4) => {
      this._queryEngine.featureStore.clear(), b(e4) || n.getLogger("esri.layers.CSVLayer").error(new s("csv-layer:refresh", "An error occurred during refresh", { error: e4 }));
    }), await this._waitSnapshotComplete();
    const { fullExtent: i3, timeExtent: o3 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: i3, timeExtent: o3 };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t3) {
    const { url: i3, customParameters: r2 } = this._loadOptions;
    if (!i3)
      throw new s("csv-layer:invalid-source", "url not defined");
    const s3 = I(i3);
    return (await U(s3.path, { query: { ...s3.query, ...r2 }, responseType: "text", signal: t3 })).data;
  }
  _createQueryEngine(e3) {
    const { objectIdField: t3, fields: i3, extent: n3, timeInfo: r2 } = e3.layerDefinition, s3 = new m({ geometryType: "esriGeometryPoint", hasM: false, hasZ: false });
    return new $({ fieldsIndex: Z.fromLayerJSON({ fields: i3, dateFieldsTimeReference: { timeZoneIANA: i } }), geometryType: "esriGeometryPoint", hasM: false, hasZ: false, timeInfo: r2, objectIdField: t3, spatialReference: n3.spatialReference || { wkid: 4326 }, cacheSpatialQueries: true, featureStore: s3 });
  }
  async _createFeatures(e3) {
    const { latitudeFieldName: t3, longitudeFieldName: n3 } = this._locationInfo, { objectIdField: r2, fieldsIndex: s3, spatialReference: o3 } = this._queryEngine;
    let a2 = [];
    const u2 = [], h2 = s3.fields.filter((e4) => e4.name !== r2).map((e4) => e4.name);
    let g3 = 0;
    const I2 = {};
    for (const i3 of s3.fields)
      if ("esriFieldTypeOID" !== i3.type && "esriFieldTypeGlobalID" !== i3.type) {
        const e4 = H(i3);
        void 0 !== e4 && (I2[i3.name] = e4);
      }
    const w2 = a(e3, h2, this._delimiter, i2(I2, r2));
    for (const l2 of w2) {
      const e4 = this._parseCoordinateValue(l2[t3]), o4 = this._parseCoordinateValue(l2[n3]);
      if (null != o4 && null != e4 && !isNaN(e4) && !isNaN(o4)) {
        l2[t3] = e4, l2[n3] = o4;
        for (const e5 in l2)
          if (e5 !== t3 && e5 !== n3) {
            if (s3.isDateField(e5))
              l2[e5] = n2(l2[e5]);
            else if (s3.isNumericField(e5)) {
              const t4 = x2(l2[e5]);
              isNaN(t4) ? l2[e5] = null : l2[e5] = t4;
            }
          }
        l2[r2] = g3, g3++, a2.push(new k(o4, e4)), u2.push(l2);
      }
    }
    if (!G({ wkid: 4326 }, o3))
      if (w(o3))
        for (const i3 of a2)
          [i3.x, i3.y] = M(i3.x, i3.y, D);
      else
        a2 = U2(t2, a2, f.WGS84, o3, null, null);
    const E = [];
    for (let i3 = 0; i3 < a2.length; i3++) {
      const { x: e4, y: t4 } = a2[i3], n4 = u2[i3];
      n4[r2] = i3 + 1, E.push(new t(new e([], [e4, t4]), n4, null, n4[r2]));
    }
    return E;
  }
  _parseCoordinateValue(e3) {
    if (null == e3 || "" === e3)
      return null;
    let t3 = x2(e3);
    return (isNaN(t3) || Math.abs(t3) > 181) && (t3 = parseFloat(e3)), t3;
  }
  async _checkProjection(e3) {
    try {
      await x(g, e3);
    } catch {
      throw new s("csv-layer:projection-not-supported", "Projection not supported");
    }
  }
};
function R(e3, t3) {
  var _a, _b, _c;
  const i3 = t3.parsingOptions || {}, r2 = { delimiter: i3.delimiter, layerDefinition: null, locationInfo: { latitudeFieldName: i3.latitudeField, longitudeFieldName: i3.longitudeField } }, s3 = r2.layerDefinition = { name: bt(t3.url, v) || "csv", dateFieldsTimeReference: { timeZoneIANA: i }, drawingInfo: O, geometryType: "esriGeometryPoint", objectIdField: null, fields: [], timeInfo: i3.timeInfo, extent: { xmin: Number.POSITIVE_INFINITY, ymin: Number.POSITIVE_INFINITY, xmax: Number.NEGATIVE_INFINITY, ymax: Number.NEGATIVE_INFINITY, spatialReference: i3.spatialReference || { wkid: 4326 } } }, o3 = c2(e3), l2 = (_a = o3.next().value) == null ? void 0 : _a.trim(), m3 = (_b = o3.next().value) == null ? void 0 : _b.trim();
  if (!l2)
    throw new s("csv-layer:empty-csv", "CSV is empty", { csv: e3 });
  const { delimiter: c3, locationInfo: d4 } = f2(l2, m3, i3);
  if (!c3)
    throw new s("csv-layer:invalid-delimiter", "Unable to detect the delimiter from CSV", { firstLine: l2, secondLine: m3, parsingOptions: i3 });
  if (!d4)
    throw new s("csv-layer:location-fields-not-found", "Unable to identify latitude and longitude fields from the CSV file", { firstLine: l2, secondLine: m3, parsingOptions: i3 });
  r2.locationInfo = d4, r2.delimiter = c3;
  const { names: u2, aliases: p2 } = g2(l2, c3), f3 = b2(e3, r2.delimiter, u2, p2, r2.locationInfo);
  if ((_c = i3.fields) == null ? void 0 : _c.length) {
    const e4 = new Z(i3.fields);
    for (const t4 of f3) {
      const i4 = e4.get(t4.name);
      i4 && Object.assign(t4, i4);
    }
  }
  if (!f3.some((e4) => "esriFieldTypeOID" === e4.type && (s3.objectIdField = e4.name, true))) {
    const e4 = { name: "__OBJECTID", alias: "__OBJECTID", type: "esriFieldTypeOID", editable: false, nullable: false };
    s3.objectIdField = e4.name, f3.unshift(e4);
  }
  s3.fields = f3;
  const y2 = new Z(s3.fields);
  if (r2.locationInfo && (r2.locationInfo.latitudeFieldName = y2.get(r2.locationInfo.latitudeFieldName).name, r2.locationInfo.longitudeFieldName = y2.get(r2.locationInfo.longitudeFieldName).name), s3.timeInfo) {
    const e4 = s3.timeInfo;
    if (e4.startTimeField) {
      const t4 = y2.get(e4.startTimeField);
      t4 ? (e4.startTimeField = t4.name, t4.type = "esriFieldTypeDate") : e4.startTimeField = null;
    }
    if (e4.endTimeField) {
      const t4 = y2.get(e4.endTimeField);
      t4 ? (e4.endTimeField = t4.name, t4.type = "esriFieldTypeDate") : e4.endTimeField = null;
    }
    if (e4.trackIdField) {
      const t4 = y2.get(e4.trackIdField);
      e4.trackIdField = t4 ? t4.name : null;
    }
    e4.startTimeField || e4.endTimeField || (s3.timeInfo = null);
  }
  return r2;
}
export {
  P as default
};
//# sourceMappingURL=CSVSourceWorker-BOZK4ODL.js.map
