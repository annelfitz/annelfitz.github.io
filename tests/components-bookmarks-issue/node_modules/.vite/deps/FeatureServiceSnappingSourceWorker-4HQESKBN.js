import {
  i,
  n as n2,
  r
} from "./chunk-A2COVLMU.js";
import {
  E as E2
} from "./chunk-ECTYMEUP.js";
import {
  h as h3
} from "./chunk-I4SHZ6P5.js";
import {
  m
} from "./chunk-PGOAFABD.js";
import {
  o as o4
} from "./chunk-63NZBHDP.js";
import {
  $
} from "./chunk-BNDDKY53.js";
import "./chunk-BECEVYQR.js";
import "./chunk-S243OWEZ.js";
import "./chunk-QYDOVVH7.js";
import "./chunk-YSXT2SWC.js";
import "./chunk-DGRFM5OL.js";
import "./chunk-AOAT6HYL.js";
import "./chunk-YH3SFFF7.js";
import "./chunk-JBU54P54.js";
import "./chunk-UQEUYEWU.js";
import "./chunk-5LIYYE75.js";
import {
  S as S2,
  c as c3,
  f as f3,
  x
} from "./chunk-F2EHRKUX.js";
import "./chunk-UWZ4CRJK.js";
import {
  a as a3
} from "./chunk-2636VFVY.js";
import "./chunk-252ISA6Z.js";
import {
  ct,
  gt,
  it
} from "./chunk-TLTAGTBA.js";
import "./chunk-2QPP5AGU.js";
import "./chunk-2C26DRKK.js";
import "./chunk-M4RFJU4F.js";
import "./chunk-WVKWBQ7C.js";
import "./chunk-RK2U53CD.js";
import "./chunk-YPY24RRU.js";
import "./chunk-O7RKI2QW.js";
import "./chunk-BMB27ANS.js";
import "./chunk-3FOBZIUS.js";
import "./chunk-ONKWNPIN.js";
import "./chunk-JKLFCJPR.js";
import "./chunk-QNG4TY7L.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import {
  b as b2
} from "./chunk-W5ALAOW2.js";
import "./chunk-FHDHOWK5.js";
import "./chunk-IYKBAIQE.js";
import "./chunk-BDRVHR2K.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-ERD6I7QP.js";
import "./chunk-EZL4LTMD.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import "./chunk-I2X6UR6L.js";
import "./chunk-HV2SFSJW.js";
import "./chunk-SBARCIDP.js";
import {
  j
} from "./chunk-2SYXH2R7.js";
import {
  t as t3
} from "./chunk-7JNXJYRU.js";
import {
  h as h2
} from "./chunk-USOPZ2Q6.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import {
  y as y2
} from "./chunk-J7AMTUNG.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import {
  w as w3
} from "./chunk-VTH4DAHQ.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import {
  E,
  c as c2,
  l,
  o as o3,
  u as u2
} from "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-PWPXYWXV.js";
import "./chunk-545NO6M2.js";
import "./chunk-5LSHHVQ5.js";
import {
  w as w2
} from "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import {
  f as f2
} from "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  C,
  d as d2,
  p,
  w
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import {
  o as o2
} from "./chunk-TXBMNSNF.js";
import {
  b,
  d
} from "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  S,
  e2 as e3,
  f,
  o4 as o,
  t4 as t2,
  u3 as u,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a2
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  L,
  a,
  e as e2,
  s
} from "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";
import {
  c2 as c,
  h,
  t3 as t
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/core/AsyncSequence.js
var r2 = class extends S {
  constructor() {
    super(...arguments), this.updating = false, this._pending = [];
  }
  push(s2, t5) {
    this._pending.push({ promise: s2, callback: t5 }), 1 === this._pending.length && this._process();
  }
  _process() {
    if (!this._pending.length)
      return void (this.updating = false);
    this.updating = true;
    const s2 = this._pending[0];
    s2.promise.then((t5) => s2.callback(t5)).catch(() => {
    }).then(() => {
      this._pending.shift(), this._process();
    });
  }
};
e([y()], r2.prototype, "updating", void 0), r2 = e([a2("esri.core.AsyncSequence")], r2);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/PendingFeatureTile.js
var r3 = class {
  constructor(t5, e4) {
    this.data = t5, this.resolution = e4, this.state = { type: i2.CREATED }, this.alive = true;
  }
  process(t5) {
    switch (this.state.type) {
      case i2.CREATED:
        return this.state = this._gotoFetchCount(this.state, t5), this.state.task.promise.then(t5.resume, t5.resume);
      case i2.FETCH_COUNT:
        break;
      case i2.FETCHED_COUNT:
        return this.state = this._gotoFetchFeatures(this.state, t5), this.state.task.promise.then(t5.resume, t5.resume);
      case i2.FETCH_FEATURES:
        break;
      case i2.FETCHED_FEATURES:
        this.state = this._goToDone(this.state, t5);
      case i2.DONE:
    }
    return null;
  }
  get debugInfo() {
    return { data: this.data, featureCount: this._featureCount, state: this._stateToString };
  }
  get _featureCount() {
    switch (this.state.type) {
      case i2.CREATED:
      case i2.FETCH_COUNT:
        return 0;
      case i2.FETCHED_COUNT:
        return this.state.featureCount;
      case i2.FETCH_FEATURES:
        return this.state.previous.featureCount;
      case i2.FETCHED_FEATURES:
        return this.state.features.length;
      case i2.DONE:
        return this.state.previous.features.length;
    }
  }
  get _stateToString() {
    switch (this.state.type) {
      case i2.CREATED:
        return "created";
      case i2.FETCH_COUNT:
        return "fetch-count";
      case i2.FETCHED_COUNT:
        return "fetched-count";
      case i2.FETCH_FEATURES:
        return "fetch-features";
      case i2.FETCHED_FEATURES:
        return "fetched-features";
      case i2.DONE:
        return "done";
    }
  }
  _gotoFetchCount(s2, a4) {
    return { type: i2.FETCH_COUNT, previous: s2, task: d(async (t5) => {
      const s3 = await b(a4.fetchCount(this, t5));
      this.state.type === i2.FETCH_COUNT && (this.state = u3(this.state, s3.ok ? s3.value : 1 / 0));
    }) };
  }
  _gotoFetchFeatures(s2, a4) {
    return { type: i2.FETCH_FEATURES, previous: s2, task: d(async (t5) => {
      const E4 = await b(a4.fetchFeatures(this, s2.featureCount, t5));
      this.state.type === i2.FETCH_FEATURES && (this.state = T(this.state, E4.ok ? E4.value : []));
    }) };
  }
  _goToDone(t5, e4) {
    return e4.finish(this, t5.features), { type: i2.DONE, previous: t5 };
  }
  reset() {
    const t5 = this.state;
    switch (this.state = { type: i2.CREATED }, t5.type) {
      case i2.CREATED:
      case i2.FETCHED_COUNT:
      case i2.FETCHED_FEATURES:
      case i2.DONE:
        break;
      case i2.FETCH_COUNT:
      case i2.FETCH_FEATURES:
        t5.task.abort();
    }
  }
  intersects(t5) {
    return null == t5 || !this.data.extent || (o3(t5, n3), E(this.data.extent, n3));
  }
};
function u3(t5, e4) {
  return { type: i2.FETCHED_COUNT, featureCount: e4, previous: t5 };
}
function T(t5, e4) {
  return { type: i2.FETCHED_FEATURES, previous: t5, features: e4 };
}
var i2;
!function(t5) {
  t5[t5.CREATED = 0] = "CREATED", t5[t5.FETCH_COUNT = 1] = "FETCH_COUNT", t5[t5.FETCHED_COUNT = 2] = "FETCHED_COUNT", t5[t5.FETCH_FEATURES = 3] = "FETCH_FEATURES", t5[t5.FETCHED_FEATURES = 4] = "FETCHED_FEATURES", t5[t5.DONE = 5] = "DONE";
}(i2 || (i2 = {}));
var n3 = u2();

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiledFetcher.js
var x2 = class extends S {
  get _minimumVerticesPerFeature() {
    var _a;
    switch ((_a = this.store) == null ? void 0 : _a.featureStore.geometryType) {
      case "esriGeometryPoint":
      case "esriGeometryMultipoint":
        return 1;
      case "esriGeometryPolygon":
        return 4;
      case "esriGeometryPolyline":
        return 2;
    }
  }
  get _mandatoryOutFields() {
    const e4 = /* @__PURE__ */ new Set();
    return this.objectIdField && e4.add(this.objectIdField), this.globalIdField && e4.add(this.globalIdField), e4;
  }
  set outFields(e4) {
    const t5 = this._get("outFields"), i3 = t2(e4, this._mandatoryOutFields);
    f(i3, t5) || (this._set("outFields", i3), e3(i3, t5) || this.refresh());
  }
  get outFields() {
    return this._get("outFields") ?? this._mandatoryOutFields;
  }
  set filter(e4) {
    const t5 = this._get("filter"), i3 = this._filterProperties(e4);
    JSON.stringify(t5) !== JSON.stringify(i3) && this._set("filter", i3);
  }
  set customParameters(e4) {
    const t5 = this._get("customParameters");
    JSON.stringify(t5) !== JSON.stringify(e4) && this._set("customParameters", e4);
  }
  get _configuration() {
    return { filter: this.filter, customParameters: this.customParameters, tileInfo: this.tileInfo, tileSize: this.tileSize };
  }
  set tileInfo(e4) {
    const t5 = this._get("tileInfo");
    t5 !== e4 && (null != e4 && null != t5 && JSON.stringify(e4) === JSON.stringify(t5) || (this._set("tileInfo", e4), this.store.tileInfo = e4));
  }
  set tileSize(e4) {
    this._get("tileSize") !== e4 && this._set("tileSize", e4);
  }
  get updating() {
    return this.updatingExcludingEdits || this._pendingEdits.updating;
  }
  get updatingExcludingEdits() {
    return this._updatingHandles.updating;
  }
  get hasZ() {
    return this.store.featureStore.hasZ;
  }
  constructor(e4) {
    super(e4), this.suspended = true, this.tilesOfInterest = [], this.availability = 0, this._pendingTiles = /* @__PURE__ */ new Map(), this._updatingHandles = new h3(), this._pendingEdits = new r2(), this._pendingEditsAbortController = new AbortController();
  }
  initialize() {
    this._initializeFetchExtent(), this._updatingHandles.add(() => this._configuration, () => this.refresh()), this._updatingHandles.add(() => this.tilesOfInterest, (e4, t5) => {
      h(e4, t5, ({ id: e5 }, { id: t6 }) => e5 === t6) || this._process();
    }, C), this.addHandles(p(() => !this.suspended, () => this._process()));
  }
  destroy() {
    this._pendingTiles.forEach((e4) => this._deletePendingTile(e4)), this._pendingTiles.clear(), this.store.destroy(), this.tilesOfInterest.length = 0, this._pendingEditsAbortController.abort(), this._pendingEditsAbortController = null, this._updatingHandles.destroy();
  }
  refresh() {
    this.store.refresh(), this._pendingTiles.forEach((e4) => this._deletePendingTile(e4)), this._process();
  }
  applyEdits(e4) {
    this._pendingEdits.push(e4, async (e5) => {
      if (0 === e5.addedFeatures.length && 0 === e5.updatedFeatures.length && 0 === e5.deletedFeatures.length)
        return;
      for (const [, i3] of this._pendingTiles)
        i3.reset();
      const t5 = { ...e5, deletedFeatures: e5.deletedFeatures.map(({ objectId: e6, globalId: t6 }) => e6 && -1 !== e6 ? e6 : this._lookupObjectIdByGlobalId(t6)) };
      await this._updatingHandles.addPromise(this.store.processEdits(t5, (e6, t6) => this._queryFeaturesById(e6, t6), this._pendingEditsAbortController.signal)), this._processPendingTiles();
    });
  }
  _initializeFetchExtent() {
    if (!this.capabilities.query.supportsExtent || !w3(this.url))
      return;
    const e4 = d(async (e5) => {
      var _a;
      try {
        const t5 = await x(this.url, new b2({ where: "1=1", outSpatialReference: this.spatialReference, cacheHint: this.capabilities.query.supportsCacheHint ?? void 0 }), { query: this._configuration.customParameters, signal: e5 });
        this.store.extent = w2.fromJSON((_a = t5.data) == null ? void 0 : _a.extent);
      } catch (t5) {
        a(t5), n.getLogger(this).warn("Failed to fetch data extent", t5);
      }
    });
    this._updatingHandles.addPromise(e4.promise.then(() => this._process())), this.addHandles(e2(() => e4.abort()));
  }
  get debugInfo() {
    return { numberOfFeatures: this.store.featureStore.numFeatures, tilesOfInterest: this.tilesOfInterest, pendingTiles: Array.from(this._pendingTiles.values()).map((e4) => e4.debugInfo), storedTiles: this.store.debugInfo };
  }
  _process() {
    this._markTilesNotAlive(), this._createPendingTiles(), this._deletePendingTiles(), this._processPendingTiles();
  }
  _markTilesNotAlive() {
    for (const [, e4] of this._pendingTiles)
      e4.alive = false;
  }
  _createPendingTiles() {
    if (this.suspended)
      return;
    const e4 = this._collectMissingTilesInfo();
    if (this._setAvailability(null == e4 ? 1 : e4.coveredArea / e4.fullArea), null != e4)
      for (const { data: t5, resolution: i3 } of e4.missingTiles) {
        const e5 = this._pendingTiles.get(t5.id);
        e5 ? (e5.resolution = i3, e5.alive = true) : this._createPendingTile(t5, i3);
      }
  }
  _collectMissingTilesInfo() {
    let e4 = null;
    for (let t5 = this.tilesOfInterest.length - 1; t5 >= 0; t5--) {
      const i3 = this.tilesOfInterest[t5], s2 = this.store.process(i3, (e5, t6) => this._verifyTileComplexity(e5, t6), this.outFields);
      null == e4 ? e4 = s2 : e4.prepend(s2);
    }
    return e4;
  }
  _deletePendingTiles() {
    for (const [, e4] of this._pendingTiles)
      e4.alive || this._deletePendingTile(e4);
  }
  _processPendingTiles() {
    const e4 = { fetchCount: (e5, t5) => this._fetchCount(e5, t5), fetchFeatures: (e5, t5, i3) => this._fetchFeatures(e5, t5, i3), finish: (e5, t5) => this._finishPendingTile(e5, t5), resume: () => this._processPendingTiles() };
    if (this._ensureFetchAllCounts(e4))
      for (const [, t5] of this._pendingTiles)
        this._verifyTileComplexity(this.store.getFeatureCount(t5.data), t5.resolution) && this._updatingHandles.addPromise(t5.process(e4));
  }
  _verifyTileComplexity(e4, t5) {
    return this._verifyVertexComplexity(e4) && this._verifyFeatureDensity(e4, t5);
  }
  _verifyVertexComplexity(e4) {
    return e4 * this._minimumVerticesPerFeature < q;
  }
  _verifyFeatureDensity(e4, t5) {
    if (null == this.tileInfo)
      return false;
    const i3 = this.tileSize * t5;
    return e4 * (A / (i3 * i3)) < H;
  }
  _ensureFetchAllCounts(e4) {
    let t5 = true;
    for (const [, i3] of this._pendingTiles)
      i3.state.type < i2.FETCHED_COUNT && this._updatingHandles.addPromise(i3.process(e4)), i3.state.type <= i2.FETCH_COUNT && (t5 = false);
    return t5;
  }
  _finishPendingTile(e4, t5) {
    this.store.add(e4.data, t5), this._deletePendingTile(e4), this._updateAvailability();
  }
  _updateAvailability() {
    const e4 = this._collectMissingTilesInfo();
    this._setAvailability(null == e4 ? 1 : e4.coveredArea / e4.fullArea);
  }
  _setAvailability(e4) {
    this._set("availability", e4);
  }
  _createPendingTile(e4, t5) {
    const i3 = new r3(e4, t5);
    return this._pendingTiles.set(e4.id, i3), i3;
  }
  _deletePendingTile(e4) {
    e4.reset(), this._pendingTiles.delete(e4.data.id);
  }
  async _fetchCount(e4, t5) {
    return this.store.fetchCount(e4.data, this.url, this._createCountQuery(e4), { query: this.customParameters, timeout: w4, signal: t5 });
  }
  async _fetchFeatures(e4, t5, i3) {
    let s2 = 0;
    const r4 = [];
    let o5 = 0, n4 = t5;
    for (; ; ) {
      const l2 = this._createFeaturesQuery(e4), a4 = this._setPagingParameters(l2, s2, n4), { features: u4, exceededTransferLimit: d3 } = await this._queryFeatures(l2, i3);
      a4 && (s2 += l2.num), o5 += u4.length;
      for (const e5 of u4)
        r4.push(e5);
      if (n4 = t5 - o5, !a4 || !d3 || n4 <= 0)
        return r4;
    }
  }
  _filterProperties(e4) {
    return null == e4 ? { where: "1=1", gdbVersion: void 0, timeExtent: void 0 } : { where: e4.where || "1=1", timeExtent: e4.timeExtent, gdbVersion: e4.gdbVersion };
  }
  _lookupObjectIdByGlobalId(e4) {
    const t5 = this.globalIdField, i3 = this.objectIdField;
    if (null == t5)
      throw new Error("Expected globalIdField to be defined");
    let s2 = null;
    if (this.store.featureStore.forEach((r4) => {
      e4 === r4.attributes[t5] && (s2 = r4.objectId ?? r4.attributes[i3]);
    }), null == s2)
      throw new Error(`Expected to find a feature with globalId ${e4}`);
    return s2;
  }
  _queryFeaturesById(e4, t5) {
    const i3 = this._createFeaturesQuery();
    return i3.objectIds = e4, this._queryFeatures(i3, t5);
  }
  _queryFeatures(e4, t5) {
    return this.capabilities.query.supportsFormatPBF ? this._queryFeaturesPBF(e4, t5) : this._queryFeaturesJSON(e4, t5);
  }
  async _queryFeaturesPBF(e4, t5) {
    const { sourceSpatialReference: i3 } = this, { data: s2 } = await f3(this.url, e4, new a3({ sourceSpatialReference: i3 }), { query: this._configuration.customParameters, timeout: w4, signal: t5 });
    return it(s2);
  }
  async _queryFeaturesJSON(e4, t5) {
    const { sourceSpatialReference: i3 } = this, { data: s2 } = await c3(this.url, e4, i3, { query: this._configuration.customParameters, timeout: w4, signal: t5 });
    return ct(s2, this.objectIdField);
  }
  _createCountQuery(e4) {
    const t5 = this._createBaseQuery(e4);
    return this.capabilities.query.supportsCacheHint && (t5.cacheHint = true), t5;
  }
  _createFeaturesQuery(e4 = null) {
    var _a;
    const t5 = this._createBaseQuery(e4), i3 = null != (e4 == null ? void 0 : e4.data) ? this.store.getAttributesForTile((_a = e4 == null ? void 0 : e4.data) == null ? void 0 : _a.id) : null, s2 = t2(u(this.outFields, i3 ?? /* @__PURE__ */ new Set()), this._mandatoryOutFields);
    return t5.outFields = Array.from(s2), t5.returnGeometry = true, null != e4 && (this.capabilities.query.supportsResultType ? t5.resultType = "tile" : this.capabilities.query.supportsCacheHint && (t5.cacheHint = true)), t5;
  }
  _createBaseQuery(e4) {
    const t5 = new b2({ returnZ: this.hasZ, returnM: false, geometry: null != this.tileInfo && null != e4 ? c2(e4.data.extent, this.tileInfo.spatialReference) : void 0 }), i3 = this._configuration.filter;
    return null != i3 && (t5.where = i3.where, t5.gdbVersion = i3.gdbVersion, t5.timeExtent = i3.timeExtent), t5.outSpatialReference = this.spatialReference, t5;
  }
  _setPagingParameters(e4, t5, i3) {
    if (!this.capabilities.query.supportsPagination)
      return false;
    const { supportsMaxRecordCountFactor: s2, supportsCacheHint: r4, tileMaxRecordCount: o5, maxRecordCount: n4, supportsResultType: l2 } = this.capabilities.query, a4 = s2 ? b2.MAX_MAX_RECORD_COUNT_FACTOR : 1, u4 = a4 * ((l2 || r4) && o5 ? o5 : n4 || j2);
    return e4.start = t5, s2 ? (e4.maxRecordCountFactor = Math.min(a4, Math.ceil(i3 / u4)), e4.num = Math.min(i3, e4.maxRecordCountFactor * u4)) : e4.num = Math.min(i3, u4), true;
  }
};
e([y({ constructOnly: true })], x2.prototype, "url", void 0), e([y({ constructOnly: true })], x2.prototype, "objectIdField", void 0), e([y({ constructOnly: true })], x2.prototype, "globalIdField", void 0), e([y({ constructOnly: true })], x2.prototype, "capabilities", void 0), e([y({ constructOnly: true })], x2.prototype, "sourceSpatialReference", void 0), e([y({ constructOnly: true })], x2.prototype, "spatialReference", void 0), e([y({ constructOnly: true })], x2.prototype, "store", void 0), e([y({ readOnly: true })], x2.prototype, "_minimumVerticesPerFeature", null), e([y()], x2.prototype, "_mandatoryOutFields", null), e([y()], x2.prototype, "outFields", null), e([y()], x2.prototype, "suspended", void 0), e([y()], x2.prototype, "filter", null), e([y()], x2.prototype, "customParameters", null), e([y({ readOnly: true })], x2.prototype, "_configuration", null), e([y()], x2.prototype, "tileInfo", null), e([y()], x2.prototype, "tileSize", null), e([y()], x2.prototype, "tilesOfInterest", void 0), e([y({ readOnly: true })], x2.prototype, "updating", null), e([y({ readOnly: true })], x2.prototype, "updatingExcludingEdits", null), e([y({ readOnly: true })], x2.prototype, "availability", void 0), e([y()], x2.prototype, "hasZ", null), x2 = e([a2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiledFetcher")], x2);
var j2 = 2e3;
var w4 = 6e5;
var q = 1e6;
var A = 25;
var H = 1;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileCache.js
var t4 = class {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._byteSize = 0;
  }
  set(t5, e4) {
    this.delete(t5), this._store.set(t5, e4), this._byteSize += e4.byteSize;
  }
  delete(t5) {
    const e4 = this._store.get(t5);
    return !!this._store.delete(t5) && (null != e4 && (this._byteSize -= e4.byteSize), true);
  }
  get(t5) {
    return this._used(t5), this._store.get(t5);
  }
  has(t5) {
    return this._used(t5), this._store.has(t5);
  }
  clear() {
    this._store.clear();
  }
  applyByteSizeLimit(t5, e4) {
    for (const [s2, r4] of this._store) {
      if (this._byteSize <= t5)
        break;
      this.delete(s2), e4(r4);
    }
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
  _used(t5) {
    const e4 = this._store.get(t5);
    e4 && (this._store.delete(t5), this._store.set(t5, e4));
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileStore.js
var v = class extends S {
  constructor(e4) {
    super(e4), this.tileInfo = null, this.extent = null, this.maximumByteSize = 10 * E2.MEGABYTES, this._tileBounds = new o4(), this._tiles = new t4(), this._refCounts = /* @__PURE__ */ new Map(), this._tileFeatureCounts = /* @__PURE__ */ new Map(), this._tmpBoundingRect = u2();
  }
  add(e4, t5) {
    var _a;
    for (const r4 of t5)
      this._referenceFeature(r4.objectId);
    const s2 = this.featureStore.upsertMany(t5), i3 = s2.map((e5) => new Set(Object.keys(e5.attributes))).reduce((e5, t6) => o(e5, t6), new Set(Object.keys(((_a = s2[0]) == null ? void 0 : _a.attributes) ?? [])));
    this._addTileStorage(e4, new Set(s2.map((e5) => e5.objectId)), S3(s2), i3), this._tiles.applyByteSizeLimit(this.maximumByteSize, (e5) => this._removeTileStorage(e5));
  }
  getAttributesForTile(e4) {
    var _a;
    return e4 ? (_a = this._tiles.get(e4)) == null ? void 0 : _a.attributeKeys : null;
  }
  destroy() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  clear() {
    this.featureStore.clear(), this._tileBounds.clear(), this._tiles.clear(), this._refCounts.clear();
  }
  refresh() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  processEdits(e4, t5, s2) {
    return this._processEditsDelete(e4.deletedFeatures.concat(e4.updatedFeatures)), this._processEditsRefetch(e4.addedFeatures.concat(e4.updatedFeatures), t5, s2);
  }
  _addTileStorage(e4, t5, s2, i3) {
    const r4 = e4.id;
    this._tiles.set(r4, new w5(e4, t5, s2, i3)), this._tileBounds.set(r4, e4.extent), this._tileFeatureCounts.set(r4, t5.size);
  }
  _remove({ id: e4 }) {
    const t5 = this._tiles.get(e4);
    t5 && this._removeTileStorage(t5);
  }
  _removeTileStorage(e4) {
    const t5 = [];
    for (const i3 of e4.objectIds)
      this._unreferenceFeature(i3) === x3.REMOVED && t5.push(i3);
    this.featureStore.removeManyById(t5);
    const s2 = e4.data.id;
    this._tiles.delete(s2), this._tileBounds.delete(s2);
  }
  _processEditsDelete(e4) {
    this.featureStore.removeManyById(e4);
    for (const [, t5] of this._tiles) {
      for (const s2 of e4)
        t5.objectIds.delete(s2);
      this._tileFeatureCounts.set(t5.data.id, t5.objectIds.size);
    }
    for (const t5 of e4)
      this._refCounts.delete(t5);
  }
  async _processEditsRefetch(e4, t5, s2) {
    const i3 = (await t5(e4, s2)).features, { hasZ: r4, hasM: o5 } = this.featureStore;
    for (const n4 of i3) {
      const e5 = gt(this._tmpBoundingRect, n4.geometry, r4, o5);
      null != e5 && this._tileBounds.forEachInBounds(e5, (e6) => {
        const t6 = this._tiles.get(e6);
        this.featureStore.add(n4);
        const s3 = n4.objectId;
        t6.objectIds.has(s3) || (t6.objectIds.add(s3), this._referenceFeature(s3), this._tileFeatureCounts.set(t6.data.id, t6.objectIds.size));
      });
    }
  }
  process(e4, t5 = () => true, s2) {
    if (null == this.tileInfo || !e4.extent || null != this.extent && !E(o3(this.extent, this._tmpBoundingRect), e4.extent))
      return new j3(e4);
    const i3 = this.getAttributesForTile(e4.id);
    if (e3(s2, i3))
      return new j3(e4);
    const r4 = this._createTileTree(e4, this.tileInfo);
    return this._simplify(r4, t5, null, 0, 1), this._collectMissingTiles(e4, r4, this.tileInfo, s2);
  }
  get debugInfo() {
    return Array.from(this._tiles.values()).map(({ data: e4 }) => ({ data: e4, featureCount: this._tileFeatureCounts.get(e4.id) || 0 }));
  }
  getFeatureCount(e4) {
    return this._tileFeatureCounts.get(e4.id) ?? 0;
  }
  async fetchCount(e4, t5, s2, i3) {
    const r4 = this._tileFeatureCounts.get(e4.id);
    if (null != r4)
      return r4;
    const o5 = await S2(t5, s2, i3);
    return this._tileFeatureCounts.set(e4.id, o5.data.count), o5.data.count;
  }
  _createTileTree(e4, t5) {
    const s2 = new F(e4.level, e4.row, e4.col);
    return t5.updateTileInfo(s2, j.ExtrapolateOptions.POWER_OF_TWO), this._tileBounds.forEachInBounds(e4.extent, (i3) => {
      var _a;
      const r4 = (_a = this._tiles.get(i3)) == null ? void 0 : _a.data;
      r4 && C2(e4, r4) && this._populateChildren(s2, r4, t5, this._tileFeatureCounts.get(r4.id) || 0);
    }), s2;
  }
  _populateChildren(e4, t5, s2, i3) {
    const r4 = t5.level - e4.level - 1;
    if (r4 < 0)
      return void (e4.isLeaf = true);
    const o5 = t5.row >> r4, n4 = t5.col >> r4, l2 = e4.row << 1, u4 = n4 - (e4.col << 1) + (o5 - l2 << 1), c4 = e4.children[u4];
    if (null != c4)
      this._populateChildren(c4, t5, s2, i3);
    else {
      const r5 = new F(e4.level + 1, o5, n4);
      s2.updateTileInfo(r5, j.ExtrapolateOptions.POWER_OF_TWO), e4.children[u4] = r5, this._populateChildren(r5, t5, s2, i3);
    }
  }
  _simplify(e4, t5, s2, i3, r4) {
    const o5 = r4 * r4;
    if (e4.isLeaf)
      return t5(this.getFeatureCount(e4), r4) ? 0 : (this._remove(e4), null != s2 && (s2.children[i3] = null), o5);
    const n4 = r4 / 2, l2 = n4 * n4;
    let u4 = 0;
    for (let c4 = 0; c4 < e4.children.length; c4++) {
      const s3 = e4.children[c4];
      u4 += null != s3 ? this._simplify(s3, t5, e4, c4, n4) : l2;
    }
    return 0 === u4 ? this._mergeChildren(e4) : 1 - u4 / o5 < I && (this._purge(e4), null != s2 && (s2.children[i3] = null), u4 = o5), u4;
  }
  _mergeChildren(e4) {
    const t5 = /* @__PURE__ */ new Set();
    let s2, i3 = 0;
    this._forEachLeaf(e4, (e5) => {
      const r4 = this._tiles.get(e5.id);
      if (r4) {
        s2 = s2 ? o(s2, r4.attributeKeys) : new Set(r4.attributeKeys), i3 += r4.byteSize;
        for (const e6 of r4.objectIds)
          t5.has(e6) || (t5.add(e6), this._referenceFeature(e6));
        this._remove(e5);
      }
    }), this._addTileStorage(e4, t5, i3, s2 ?? /* @__PURE__ */ new Set()), e4.isLeaf = true, e4.children[0] = e4.children[1] = e4.children[2] = e4.children[3] = null, this._tileFeatureCounts.set(e4.id, t5.size);
  }
  _forEachLeaf(e4, t5) {
    for (const s2 of e4.children)
      null != s2 && (s2.isLeaf ? t5(s2) : this._forEachLeaf(s2, t5));
  }
  _purge(e4) {
    if (null != e4)
      if (e4.isLeaf)
        this._remove(e4);
      else
        for (let t5 = 0; t5 < e4.children.length; t5++) {
          const s2 = e4.children[t5];
          this._purge(s2), e4.children[t5] = null;
        }
  }
  _collectMissingTiles(e4, t5, s2, i3) {
    const r4 = new b3(s2, e4, this.extent);
    return this._collectMissingTilesRecurse(t5, r4, 1, i3), r4.info;
  }
  _collectMissingTilesRecurse(e4, t5, s2, i3) {
    const r4 = this.getAttributesForTile(e4.id), o5 = r4 && !e3(i3, r4);
    if (o5 && t5.addMissing(e4.level, e4.row, e4.col, s2), e4.isLeaf)
      return;
    if (!e4.hasChildren)
      return void (o5 || t5.addMissing(e4.level, e4.row, e4.col, s2));
    const l2 = s2 / 2;
    for (let n4 = 0; n4 < e4.children.length; n4++) {
      const s3 = e4.children[n4];
      null == s3 ? t5.addMissing(e4.level + 1, (e4.row << 1) + ((2 & n4) >> 1), (e4.col << 1) + (1 & n4), l2) : this._collectMissingTilesRecurse(s3, t5, l2, i3);
    }
  }
  _referenceFeature(e4) {
    const t5 = (this._refCounts.get(e4) || 0) + 1;
    return this._refCounts.set(e4, t5), 1 === t5 ? x3.ADDED : x3.UNCHANGED;
  }
  _unreferenceFeature(e4) {
    const t5 = (this._refCounts.get(e4) || 0) - 1;
    return 0 === t5 ? (this._refCounts.delete(e4), x3.REMOVED) : (t5 > 0 && this._refCounts.set(e4, t5), x3.UNCHANGED);
  }
  get test() {
    return { tiles: Array.from(this._tiles.values()).map((e4) => `${e4.data.id}:[${Array.from(e4.objectIds)}]`), featureReferences: Array.from(this._refCounts.keys()).map((e4) => `${e4}:${this._refCounts.get(e4)}`) };
  }
};
function C2(e4, t5) {
  if (!e4 || !t5)
    return false;
  if (e4.level === t5.level)
    return e4.row === t5.row && e4.col === t5.col;
  const s2 = e4.level < t5.level, i3 = s2 ? e4 : t5, r4 = s2 ? t5 : e4, o5 = 1 << r4.level - i3.level;
  return Math.floor(r4.row / o5) === i3.row && Math.floor(r4.col / o5) === i3.col;
}
function S3(e4) {
  return e4.reduce((e5, t5) => e5 + E3(t5), 0);
}
function E3(e4) {
  return 32 + T2(e4.geometry) + t(e4.attributes);
}
function T2(e4) {
  if (null == e4)
    return 0;
  const t5 = c(e4.lengths, 4);
  return 32 + c(e4.coords, 8) + t5;
}
e([y({ constructOnly: true })], v.prototype, "featureStore", void 0), e([y()], v.prototype, "tileInfo", void 0), e([y()], v.prototype, "extent", void 0), e([y()], v.prototype, "maximumByteSize", void 0), v = e([a2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTileStore")], v);
var w5 = class {
  constructor(e4, t5, s2, i3) {
    this.data = e4, this.objectIds = t5, this.byteSize = s2, this.attributeKeys = i3;
  }
};
var F = class {
  constructor(e4, t5, s2) {
    this.level = e4, this.row = t5, this.col = s2, this.isLeaf = false, this.extent = null, this.children = [null, null, null, null];
  }
  get hasChildren() {
    return !this.isLeaf && (null != this.children[0] || null != this.children[1] || null != this.children[2] || null != this.children[3]);
  }
};
var j3 = class {
  constructor(e4, t5 = []) {
    this.missingTiles = t5, this.fullArea = 0, this.coveredArea = 0, this.fullArea = l(e4.extent), this.coveredArea = this.fullArea;
  }
  prepend(e4) {
    this.missingTiles = e4.missingTiles.concat(this.missingTiles), this.coveredArea += e4.coveredArea, this.fullArea += e4.fullArea;
  }
};
var b3 = class {
  constructor(e4, t5, s2) {
    this._tileInfo = e4, this._extent = null, this.info = new j3(t5), null != s2 && (this._extent = o3(s2));
  }
  addMissing(e4, t5, s2, i3) {
    const r4 = new t3(null, e4, t5, s2);
    this._tileInfo.updateTileInfo(r4, j.ExtrapolateOptions.POWER_OF_TWO), null == r4.extent || null != this._extent && !E(this._extent, r4.extent) || (this.info.missingTiles.push({ data: r4, resolution: i3 }), this.info.coveredArea -= l(r4.extent));
  }
};
var I = 0.18751;
var x3;
!function(e4) {
  e4[e4.ADDED = 0] = "ADDED", e4[e4.REMOVED = 1] = "REMOVED", e4[e4.UNCHANGED = 2] = "UNCHANGED";
}(x3 || (x3 = {}));

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker.js
var w6 = class extends o2.EventedAccessor {
  constructor() {
    super(...arguments), this._isInitializing = true, this.remoteClient = null, this._whenSetup = L(), this._elevationAligner = i(), this._elevationFilter = r(), this._symbologyCandidatesFetcher = n2(), this._updatingHandles = new h3(), this._editsUpdatingHandles = new h3(), this._pendingApplyEdits = /* @__PURE__ */ new Map(), this._alignPointsInFeatures = async (e4, t5) => {
      const i3 = { query: e4 }, r4 = await this.remoteClient.invoke("alignElevation", i3, { signal: t5 });
      return s(t5), r4;
    }, this._getSymbologyCandidates = async (e4, t5) => {
      const i3 = { candidates: e4, spatialReference: this._spatialReference.toJSON() }, r4 = await this.remoteClient.invoke("getSymbologyCandidates", i3, { signal: t5 });
      return s(t5), r4;
    };
  }
  get updating() {
    return this.updatingExcludingEdits || this._editsUpdatingHandles.updating || this._featureFetcher.updating;
  }
  get updatingExcludingEdits() {
    return this._featureFetcher.updatingExcludingEdits || this._isInitializing || this._updatingHandles.updating;
  }
  destroy() {
    var _a, _b, _c;
    (_a = this._featureFetcher) == null ? void 0 : _a.destroy(), (_b = this._queryEngine) == null ? void 0 : _b.destroy(), (_c = this._featureStore) == null ? void 0 : _c.clear();
  }
  async setup(e4) {
    if (this.destroyed)
      return { result: {} };
    const { geometryType: t5, objectIdField: i3, timeInfo: s2, fieldsIndex: n4 } = e4.serviceInfo, { hasZ: o5 } = e4, l2 = f2.fromJSON(e4.spatialReference);
    this._spatialReference = l2, this._featureStore = new m({ ...e4.serviceInfo, hasZ: o5, hasM: false }), this._queryEngine = new $({ spatialReference: e4.spatialReference, featureStore: this._featureStore, geometryType: t5, fieldsIndex: n4, hasZ: o5, hasM: false, objectIdField: i3, timeInfo: s2 }), this._featureFetcher = new x2({ store: new v({ featureStore: this._featureStore }), url: e4.serviceInfo.url, objectIdField: e4.serviceInfo.objectIdField, globalIdField: e4.serviceInfo.globalIdField, capabilities: e4.serviceInfo.capabilities, spatialReference: l2, sourceSpatialReference: f2.fromJSON(e4.serviceInfo.spatialReference), customParameters: e4.configuration.customParameters });
    const d3 = "3d" === e4.configuration.viewType;
    return this._elevationAligner = i(d3, { elevationInfo: null != e4.elevationInfo ? h2.fromJSON(e4.elevationInfo) : null, alignPointsInFeatures: this._alignPointsInFeatures }), this._elevationFilter = r(d3), this.addHandles([d2(() => this._featureFetcher.availability, (e5) => this.emit("notify-availability", { availability: e5 }), C), d2(() => this.updating, () => this._notifyUpdating())]), this._whenSetup.resolve(), this._isInitializing = false, this.configure(e4.configuration);
  }
  async configure(e4) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), this._updateFeatureFetcherConfiguration(e4), j4;
  }
  async setSuspended(e4, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t5), this._featureFetcher.suspended = e4, j4;
  }
  async updateOutFields(e4, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t5), this._featureFetcher.outFields = new Set(e4 ?? []), j4;
  }
  async fetchCandidates(e4, t5) {
    await this._whenSetup.promise, s(t5);
    const i3 = b4(e4), r4 = t5 == null ? void 0 : t5.signal, n4 = await this._queryEngine.executeQueryForSnapping(i3, r4);
    s(r4);
    const a4 = await this._elevationAligner.alignCandidates(n4.candidates, f2.fromJSON(e4.point.spatialReference) ?? f2.WGS84, r4);
    s(r4);
    const o5 = await this._symbologyCandidatesFetcher.fetch(a4, r4);
    s(r4);
    const l2 = 0 === o5.length ? a4 : a4.concat(o5);
    return { result: { candidates: this._elevationFilter.filter(i3, l2) } };
  }
  async updateTiles(e4, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t5), this._featureFetcher.tileSize = e4.tileSize, this._featureFetcher.tilesOfInterest = e4.tiles, this._featureFetcher.tileInfo = null != e4.tileInfo ? j.fromJSON(e4.tileInfo) : null, j4;
  }
  async refresh(e4, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t5), this._featureFetcher.refresh(), j4;
  }
  async whenNotUpdating(e4, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t5), await w(() => !this.updatingExcludingEdits, t5), s(t5), j4;
  }
  async getDebugInfo(e4, t5) {
    return s(t5), { result: this._featureFetcher.debugInfo };
  }
  async beginApplyEdits(e4, t5) {
    this._updatingHandles.addPromise(this._whenSetup.promise), s(t5);
    const r4 = L();
    return this._pendingApplyEdits.set(e4.id, r4), this._featureFetcher.applyEdits(r4.promise), this._editsUpdatingHandles.addPromise(r4.promise), j4;
  }
  async endApplyEdits(e4, t5) {
    const i3 = this._pendingApplyEdits.get(e4.id);
    return i3 && i3.resolve(e4.edits), s(t5), j4;
  }
  async notifyElevationSourceChange(e4, t5) {
    return this._elevationAligner.notifyElevationSourceChange(), j4;
  }
  async notifySymbologyChange(e4, t5) {
    return this._symbologyCandidatesFetcher.notifySymbologyChange(), j4;
  }
  async setSymbologySnappingSupported(e4) {
    return this._symbologyCandidatesFetcher = n2(e4, this._getSymbologyCandidates), j4;
  }
  _updateFeatureFetcherConfiguration(e4) {
    this._featureFetcher.filter = null != e4.filter ? b2.fromJSON(e4.filter) : null, this._featureFetcher.customParameters = e4.customParameters;
  }
  _notifyUpdating() {
    this.emit("notify-updating", { updating: this.updating });
  }
};
e([y({ readOnly: true })], w6.prototype, "updating", null), e([y({ readOnly: true })], w6.prototype, "updatingExcludingEdits", null), e([y()], w6.prototype, "_isInitializing", void 0), w6 = e([a2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorker")], w6);
var I2 = w6;
function b4(e4) {
  if (!e4.filter)
    return { ...e4, query: { where: "1=1" } };
  const { distance: t5, units: i3, spatialRel: s2, where: r4, timeExtent: n4, objectIds: a4 } = e4.filter, o5 = { geometry: e4.filter.geometry ? y2(e4.filter.geometry) : void 0, distance: t5, units: i3, spatialRel: s2, timeExtent: n4, objectIds: a4, where: r4 ?? "1=1" };
  return { ...e4, query: o5 };
}
var j4 = { result: {} };
export {
  I2 as default
};
//# sourceMappingURL=FeatureServiceSnappingSourceWorker-4HQESKBN.js.map
