import {
  F,
  s
} from "./chunk-O7RKI2QW.js";
import {
  r as r2
} from "./chunk-LSM34QAB.js";
import {
  K,
  _,
  x
} from "./chunk-SAYWXQVM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  d
} from "./chunk-I2RC5KWA.js";
import {
  f,
  u
} from "./chunk-QHK5ZYFW.js";
import {
  n2 as n,
  r
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/support/basemapUtils.js
var p = () => n.getLogger("esri.support.basemapUtils");
function y() {
  return {};
}
function m(e) {
  for (const r3 in e) {
    const t = e[r3];
    u(t), delete e[r3];
  }
}
function b(t, n2) {
  let a;
  if ("string" == typeof t) {
    const i = t in s, l = !i && t.includes("/");
    if (!i && !l) {
      const e = Object.entries(s).filter(([e2, t2]) => r.apiKey && !t2.classic || !r.apiKey && (t2.classic || t2.is3d)).map(([e2]) => `"${e2}"`).sort().join(", ");
      return p().warn(`Unable to find basemap definition for: ${t}. Try one of these: ${e}`), null;
    }
    n2 && (a = n2[t]), a || (a = i ? F.fromId(t) : new F({ style: { id: t } }), n2 && (n2[t] = a));
  } else
    a = d(F, t);
  return (a == null ? void 0 : a.destroyed) && (p().warn("The provided basemap is already destroyed", { basemap: a }), a = null), a;
}
function d2(e) {
  var _a;
  return "Web Scene" === ((_a = e.portalItem) == null ? void 0 : _a.type) || e.referenceLayers.some((e2) => "scene" === e2.type);
}
function L(e) {
  var _a, _b;
  return !!((_b = (_a = e == null ? void 0 : e.portalItem) == null ? void 0 : _a.tags) == null ? void 0 : _b.some((e2) => "beta" === e2.toLowerCase()));
}
function S(e, r3) {
  var _a, _b, _c, _d;
  return ((_b = (_a = e.basemap) == null ? void 0 : _a.referenceLayers) == null ? void 0 : _b.some((e2) => e2.uid === r3)) || ((_d = (_c = e.basemap) == null ? void 0 : _c.baseLayers) == null ? void 0 : _d.some((e2) => e2.uid === r3));
}
function v(e, r3 = null) {
  const t = b(e);
  if (!t)
    return null;
  const n2 = t.clone();
  return r3 && (n2.baseLayers = T(n2.baseLayers, r3.baseLayers), n2.referenceLayers = T(n2.referenceLayers, r3.referenceLayers)), n2;
}
var g;
function h(e) {
  if (g)
    return g(e);
  let r3 = null;
  const t = M(e), n2 = !(t == null ? void 0 : t.baseLayers.length);
  for (const a in s) {
    const e2 = K2(t, $(s[a]), { mustMatchReferences: n2 });
    if ("equal" === e2) {
      r3 = a;
      break;
    }
    "base-layers-equal" === e2 && (r3 = a);
  }
  return r3;
}
function R(e, r3) {
  var _a, _b;
  if (e === r3)
    return true;
  if (null != ((_a = e == null ? void 0 : e.portalItem) == null ? void 0 : _a.id) && e.portalItem.id === ((_b = r3 == null ? void 0 : r3.portalItem) == null ? void 0 : _b.id))
    return true;
  return "equal" === K2(M(e), M(r3), { mustMatchReferences: true });
}
function T(e, r3) {
  const n2 = new V();
  return e.forEach((e2) => {
    const t = r3.find((r4) => "scene" !== r4.type && D(A(e2), A(r4))) || e2;
    n2.includes(t) ? n2.push(e2) : n2.push(t);
  }), n2;
}
function w(e) {
  return !!(e == null ? void 0 : e.baseLayers.concat(e.referenceLayers).some(j));
}
function j(e) {
  if (x2(e.url))
    return true;
  if ("vector-tile" === e.type)
    for (const r3 in e.sourceNameToSource) {
      const t = e.sourceNameToSource[r3];
      if (x2(t == null ? void 0 : t.sourceUrl))
        return true;
    }
  return false;
}
function U(e, r3) {
  var _a;
  if (null == r3 || null == e)
    return { spatialReference: null, updating: false };
  if ("not-loaded" === r3.loadStatus)
    return r3.load(), { spatialReference: null, updating: true };
  if (r3.spatialReference)
    return { spatialReference: r3.spatialReference, updating: false };
  if (0 === r3.baseLayers.length)
    return { spatialReference: null, updating: false };
  const t = r3.baseLayers.at(0);
  switch (t.loadStatus) {
    case "not-loaded":
      t.load();
    case "loading":
      return { spatialReference: null, updating: true };
    case "failed":
      return { spatialReference: null, updating: false };
  }
  const n2 = (("supportedSpatialReferences" in t ? t.supportedSpatialReferences : null) || ["tileInfo" in t ? (_a = t.tileInfo) == null ? void 0 : _a.spatialReference : t.spatialReference]).filter(Boolean), a = e.spatialReference;
  return a ? { spatialReference: n2.find((e2) => a.equals(e2)) ?? n2[0] ?? null, updating: false } : { spatialReference: n2[0], updating: false };
}
var q = /^(basemaps|ibasemaps).*-api\.arcgis\.com$/i;
function x2(e) {
  if (!e)
    return false;
  const r3 = new x(_(e));
  return !!r3.authority && q.test(r3.authority);
}
function M(e) {
  return e ? !e.loaded && e.resourceInfo ? $(e.resourceInfo.data) : { baseLayers: k(e.baseLayers), referenceLayers: k(e.referenceLayers) } : null;
}
function k(e) {
  return (V.isCollection(e) ? e.toArray() : e).map(A);
}
function A(e) {
  var _a, _b;
  return { type: e.type, effect: "effect" in e ? e.effect : void 0, url: E("urlTemplate" in e && e.urlTemplate || e.url || "styleUrl" in e && e.styleUrl || ""), minScale: "minScale" in e && null != e.minScale ? e.minScale : 0, maxScale: "maxScale" in e && null != e.maxScale ? e.maxScale : 0, opacity: null != e.opacity ? e.opacity : 1, visible: null == e.visible || !!e.visible, sublayers: "map-image" !== e.type && "wms" !== e.type || null == e.sublayers ? void 0 : (_a = e.sublayers) == null ? void 0 : _a.map((e2) => ({ id: e2.id, visible: e2.visible })), activeLayerId: "wmts" === e.type ? (_b = e.activeLayer) == null ? void 0 : _b.id : void 0 };
}
function C(e) {
  return e.isReference || "ArcGISSceneServiceLayer" === e.layerType;
}
function $(e) {
  return e ? { baseLayers: G((e.baseMapLayers ?? []).filter((e2) => !C(e2))), referenceLayers: G((e.baseMapLayers ?? []).filter((e2) => C(e2))) } : null;
}
function G(e) {
  return e.map((e2) => B(e2));
}
function B(e) {
  let r3;
  switch (e.layerType) {
    case "VectorTileLayer":
      r3 = "vector-tile";
      break;
    case "ArcGISTiledMapServiceLayer":
      r3 = "tile";
      break;
    case "ArcGISSceneServiceLayer":
      r3 = "scene";
      break;
    default:
      r3 = "unknown";
  }
  return { type: r3, effect: e.effect, url: E(e.templateUrl || e.urlTemplate || e.styleUrl || e.url), minScale: e.minScale ?? 0, maxScale: e.maxScale ?? 0, opacity: e.opacity ?? 1, visible: null == e.visibility || !!e.visibility, sublayers: void 0, activeLayerId: void 0 };
}
function K2(e, r3, t) {
  if (null != e != (null != r3))
    return "not-equal";
  if (!e || !r3)
    return "equal";
  if (!N(e.baseLayers, r3.baseLayers))
    return "not-equal";
  return N(e.referenceLayers, r3.referenceLayers) ? "equal" : t.mustMatchReferences ? "not-equal" : "base-layers-equal";
}
function N(e, r3) {
  if (e.length !== r3.length)
    return false;
  for (let t = 0; t < e.length; t++)
    if (!D(e[t], r3[t]))
      return false;
  return true;
}
function D(e, r3) {
  if (e.type !== r3.type || e.url !== r3.url || e.minScale !== r3.minScale || e.maxScale !== r3.maxScale || e.visible !== r3.visible || e.opacity !== r3.opacity)
    return false;
  if (!r2(e.effect, r3.effect))
    return false;
  if (null != e.activeLayerId || null != r3.activeLayerId)
    return e.activeLayerId === r3.activeLayerId;
  if (null != e.sublayers || null != r3.sublayers) {
    if (null == e.sublayers || null == r3.sublayers || e.sublayers.length !== r3.sublayers.length)
      return false;
    for (let t = 0; t < e.sublayers.length; t++) {
      const n2 = e.sublayers.at(t), a = r3.sublayers.at(t);
      if ((n2 == null ? void 0 : n2.id) !== (a == null ? void 0 : a.id) || (n2 == null ? void 0 : n2.visible) !== (a == null ? void 0 : a.visible))
        return false;
    }
  }
  return true;
}
function E(e) {
  return e ? K(e).replace(/^\s*https?:/i, "").toLowerCase() : "";
}
function O(e) {
  if (!e)
    return null;
  const { thumbnailUrl: r3 } = e;
  if (r3)
    return r3;
  const t = h(e);
  return t ? s[t].thumbnailUrl : f(e.baseLayers, V2);
}
function V2(e) {
  var _a;
  return "portalItem" in e ? (_a = e.portalItem) == null ? void 0 : _a.thumbnailUrl : void 0;
}

export {
  y,
  m,
  b,
  d2 as d,
  L,
  S,
  v,
  R,
  w,
  j,
  U,
  O
};
//# sourceMappingURL=chunk-YPY24RRU.js.map
