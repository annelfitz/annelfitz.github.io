import {
  R,
  a,
  c,
  d2 as d,
  o
} from "./chunk-4VVENLLF.js";
import {
  l
} from "./chunk-SA77Z3WI.js";
import {
  e
} from "./chunk-BKOYOJBG.js";
import {
  i
} from "./chunk-LQBHIBXV.js";
import {
  i as i2
} from "./chunk-AG6JXA4M.js";
import {
  n
} from "./chunk-OIJCMME5.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  s
} from "./chunk-JGDJR5EV.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/elevationAlignPointsInFeatures.js
async function m(m2, l2, d2, j, u) {
  const { elevationProvider: v, renderCoordsHelper: g } = m2, { elevationInfo: y } = l2, { pointsInFeatures: I, spatialReference: x } = j, h = f.fromJSON(x), w = d(y, true), R2 = await a(w, h, u);
  s(u);
  const S = [], b = /* @__PURE__ */ new Set(), z = /* @__PURE__ */ new Set(), E = new o(), P = e(0, 0, 0, f.WGS84), U = new R(), C = n();
  P.spatialReference = h;
  const F = m2.elevationProvider.spatialReference ?? m2.spatialReference;
  for (const { objectId: e2, points: o2 } of I) {
    const r2 = d2(e2);
    if (null == r2) {
      for (const e3 of o2)
        S.push(e3.z ?? 0);
      b.add(e2);
      continue;
    }
    r2.isDraped && z.add(e2);
    const s2 = r2.graphic.geometry;
    E.setFromElevationInfo(l(s2, y)), E.updateFeatureExpressionInfoContext(R2, r2.graphic, l2);
    for (const { x: e3, y: i3, z: a2 } of o2)
      P.x = e3, P.y = i3, P.z = a2 ?? 0, await i(P, C, F, 0, { signal: u }), c(C, v, E, g, U), S.push(U.z);
  }
  return { elevations: S, drapedObjectIds: z, failedObjectIds: b };
}

// node_modules/@arcgis/core/views/3d/layers/graphics/queryForSymbologySnapping.js
async function r(r2, a2, s2) {
  if (null == r2 || 0 === a2.candidates.length)
    return t;
  const i3 = r2.graphics3DGraphicsByObjectID ?? r2.graphics3DGraphics, c2 = [], o2 = [], { renderer: d2 } = r2, p = null != d2 && "arcadeRequired" in d2 && d2.arcadeRequired ? i2() : null, l2 = async (n2, { graphic: e2, graphics3DSymbol: t2 }) => {
    const a3 = await p, i4 = await r2.getRenderingInfoAsync(e2, d2, a3, { signal: s2 });
    return null == i4 ? [] : t2.queryForSnapping(n2, g, i4, s2);
  }, { candidates: u, spatialReference: g } = a2;
  for (let n2 = 0; n2 < u.length; ++n2) {
    const e2 = u[n2], { objectId: r3 } = e2, t2 = "number" == typeof r3 ? i3 == null ? void 0 : i3.get(r3) : void 0;
    if (null == t2)
      continue;
    const { graphics3DSymbol: a3 } = t2;
    a3.symbologySnappingSupported && (c2.push(l2(e2, t2)), o2.push(n2));
  }
  if (0 === c2.length)
    return t;
  const h = await Promise.all(c2);
  s(s2);
  const f2 = [], m2 = [];
  for (let n2 = 0; n2 < h.length; ++n2) {
    const e2 = h[n2], r3 = o2[n2];
    for (const n3 of e2)
      f2.push(n3), m2.push(r3);
  }
  return { candidates: f2, sourceCandidateIndices: m2 };
}
var t = { candidates: [], sourceCandidateIndices: [] };

export {
  m,
  r
};
//# sourceMappingURL=chunk-5N67JZXF.js.map
