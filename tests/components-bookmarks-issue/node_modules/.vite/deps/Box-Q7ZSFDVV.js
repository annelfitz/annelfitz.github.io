import {
  h as h3
} from "./chunk-LX4MCBVU.js";
import {
  U
} from "./chunk-WGW5NIFJ.js";
import {
  h as h2
} from "./chunk-DSYR24NA.js";
import {
  e as e3
} from "./chunk-5HWGOVOV.js";
import {
  a as a3,
  i as i2,
  m as m3,
  s
} from "./chunk-PGQVBXGK.js";
import "./chunk-CGJEHQM2.js";
import {
  i,
  o as o2,
  p as p2
} from "./chunk-X6YRTSHB.js";
import {
  r
} from "./chunk-PHGMJ5KG.js";
import {
  u as u4
} from "./chunk-EIFRMATR.js";
import "./chunk-AVQM6UNY.js";
import {
  l
} from "./chunk-ZIKY3AX6.js";
import "./chunk-VGQTAP4F.js";
import {
  m as m2
} from "./chunk-BOU46AXG.js";
import "./chunk-7IFMSG3H.js";
import "./chunk-NIRB3OB6.js";
import "./chunk-JASPUPTW.js";
import "./chunk-HWBFFWYY.js";
import "./chunk-B473F3N3.js";
import "./chunk-UANQJYHL.js";
import "./chunk-3FTSPLRV.js";
import "./chunk-OMRW2J7M.js";
import "./chunk-PTIWH4S7.js";
import "./chunk-67GTVIII.js";
import "./chunk-BEXFYHUM.js";
import "./chunk-K3DEHPDR.js";
import "./chunk-I6RS7YIS.js";
import "./chunk-7KPPNEIJ.js";
import "./chunk-KDAM4HTO.js";
import "./chunk-G4YIJOSP.js";
import {
  h
} from "./chunk-PMQ5HDZI.js";
import "./chunk-NAWP2ZCR.js";
import "./chunk-M5DWZKDJ.js";
import "./chunk-LO5UMUY4.js";
import "./chunk-YKIGDW5O.js";
import "./chunk-QD3CP3I4.js";
import "./chunk-ECTYMEUP.js";
import "./chunk-JBU54P54.js";
import "./chunk-RK2U53CD.js";
import "./chunk-YPY24RRU.js";
import "./chunk-O7RKI2QW.js";
import "./chunk-3AIILHI5.js";
import "./chunk-SA77Z3WI.js";
import "./chunk-D56W4LPT.js";
import "./chunk-BKOYOJBG.js";
import "./chunk-VS6AHHIY.js";
import "./chunk-RO3CTAP7.js";
import "./chunk-Y546C2O5.js";
import "./chunk-LQBHIBXV.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-O76UVYOO.js";
import {
  f
} from "./chunk-QYC3GV65.js";
import "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import "./chunk-HV2SFSJW.js";
import "./chunk-SBARCIDP.js";
import "./chunk-6PMFOUWZ.js";
import "./chunk-3KPZ3BQR.js";
import "./chunk-5JYVZQZR.js";
import "./chunk-UUG4W2PI.js";
import "./chunk-G7FOE26O.js";
import "./chunk-USOPZ2Q6.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import {
  S
} from "./chunk-G5EVVNIJ.js";
import {
  y as y2
} from "./chunk-HU5IGOTI.js";
import {
  d as d2
} from "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-WMUEII2O.js";
import "./chunk-6QNF7OHN.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import {
  j,
  m2 as m,
  u as u2,
  x as x2
} from "./chunk-HV6S3GY2.js";
import {
  a as a2,
  e as e2
} from "./chunk-IGR2BTWR.js";
import {
  u as u3
} from "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-CXNX736Z.js";
import "./chunk-RGCWZ2KZ.js";
import "./chunk-5VMSFOCB.js";
import "./chunk-LGQXPGTM.js";
import "./chunk-2SDMYJDE.js";
import "./chunk-TPLOIZC7.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  A,
  P,
  d,
  p
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import {
  u
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-MDRC3XUT.js";
import "./chunk-NCF6OYL5.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/geometry/support/rotate.js
function o3(n, e4, t, s2) {
  const i3 = [];
  for (const o4 of n) {
    const n2 = o4.slice(0);
    i3.push(n2);
    const r3 = e4 * (o4[0] - s2.x) - t * (o4[1] - s2.y) + s2.x, a4 = t * (o4[0] - s2.x) + e4 * (o4[1] - s2.y) + s2.y;
    n2[0] = r3, n2[1] = a4;
  }
  return i3;
}
function r2(r3, a4, c) {
  const { hasM: m4, hasZ: x3, spatialReference: f2 } = r3, p3 = a4 * Math.PI / 180, l2 = Math.cos(p3), h4 = Math.sin(p3);
  if ("xmin" in r3 && (c = c ?? r3.center, r3 = new j({ spatialReference: f2, rings: [[[r3.xmin, r3.ymin], [r3.xmin, r3.ymax], [r3.xmax, r3.ymax], [r3.xmax, r3.ymin], [r3.xmin, r3.ymin]]] })), "paths" in r3) {
    c = c ?? r3.extent.center;
    const n = [];
    for (const e4 of r3.paths)
      n.push(o3(e4, l2, h4, c));
    return new m({ hasM: m4, hasZ: x3, spatialReference: f2, paths: n });
  }
  if ("rings" in r3) {
    c = c ?? r3.extent.center;
    const t = [];
    for (const e4 of r3.rings) {
      const s2 = a2(e4), i3 = o3(e4, l2, h4, c);
      a2(i3) !== s2 && i3.reverse(), t.push(i3);
    }
    return new j({ hasM: m4, hasZ: x3, spatialReference: f2, rings: t });
  }
  if ("x" in r3) {
    c = c ?? r3;
    const n = new x({ x: l2 * (r3.x - c.x) - h4 * (r3.y - c.y) + c.x, y: h4 * (r3.x - c.x) + l2 * (r3.y - c.y) + c.y, spatialReference: f2 });
    return null != r3.z && (n.z = r3.z), null != r3.m && (n.m = r3.m), n;
  }
  return "points" in r3 ? (c = c ?? r3.extent.center, new u2({ hasM: m4, hasZ: x3, points: o3(r3.points, l2, h4, c), spatialReference: f2 })) : null;
}

// node_modules/@arcgis/core/views/draw/support/Box.js
var z = class {
  constructor(t, e4, i3, s2) {
    this.graphics = t, this.mover = e4, this.dx = i3, this.dy = s2, this.type = "move-start";
  }
};
var B = class {
  constructor(t, e4, i3, s2) {
    this.graphics = t, this.mover = e4, this.dx = i3, this.dy = s2, this.type = "move";
  }
};
var Y = class {
  constructor(t, e4, i3, s2) {
    this.graphics = t, this.mover = e4, this.dx = i3, this.dy = s2, this.type = "move-stop";
  }
};
var N = class {
  constructor(t, e4, i3) {
    this.graphics = t, this.mover = e4, this.angle = i3, this.type = "rotate-start";
  }
};
var U2 = class {
  constructor(t, e4, i3) {
    this.graphics = t, this.mover = e4, this.angle = i3, this.type = "rotate";
  }
};
var A2 = class {
  constructor(t, e4, i3) {
    this.graphics = t, this.mover = e4, this.angle = i3, this.type = "rotate-stop";
  }
};
var P2 = class {
  constructor(t, e4, i3, s2) {
    this.graphics = t, this.mover = e4, this.xScale = i3, this.yScale = s2, this.type = "scale-start";
  }
};
var X = class {
  constructor(t, e4, i3, s2) {
    this.graphics = t, this.mover = e4, this.xScale = i3, this.yScale = s2, this.type = "scale";
  }
};
var F = class {
  constructor(t, e4, i3, s2) {
    this.graphics = t, this.mover = e4, this.xScale = i3, this.yScale = s2, this.type = "scale-stop";
  }
};
var D = h3.transformGraphics;
var V = { centerIndicator: new y2({ style: "cross", size: D.center.size, color: D.center.color }), fill: { default: new S({ color: D.fill.color, outline: { color: D.fill.outlineColor, join: "round", width: 1 } }), active: new S({ color: D.fill.stagedColor, outline: { color: D.fill.outlineColor, join: "round", style: "dash", width: 1 } }) }, handles: { default: new y2({ style: "square", size: D.vertex.size, color: D.vertex.color, outline: { color: D.vertex.outlineColor, width: 1 } }), hover: new y2({ style: "square", size: D.vertex.hoverSize, color: D.vertex.hoverColor, outline: { color: D.vertex.hoverOutlineColor, width: 1 } }) }, rotator: { default: new y2({ style: "circle", size: D.vertex.size, color: D.vertex.color, outline: { color: D.vertex.outlineColor, width: 1 } }), hover: new y2({ style: "circle", size: D.vertex.hoverSize, color: D.vertex.hoverColor, outline: { color: D.vertex.hoverOutlineColor, width: 1 } }) }, rotatorLine: new d2({ color: D.line.color, width: 1 }) };
var q = class extends o.EventedAccessor {
  constructor(t) {
    super(t), this._activeHandleGraphic = null, this._graphicAttributes = { esriSketchTool: "box" }, this._mover = null, this._centerGraphic = null, this._backgroundGraphic = null, this._vertexGraphics = [], this._rotateHandleGraphic = null, this._rotateGraphicOffset = 20, this._angleOfRotation = 0, this._rotateLineGraphic = null, this._startInfo = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this.tooltip = null, this.type = "box", this.callbacks = { onMoveStart() {
    }, onMove() {
    }, onMoveStop() {
    }, onScaleStart() {
    }, onScale() {
    }, onScaleStop() {
    }, onRotateStart() {
    }, onRotate() {
    }, onRotateStop() {
    }, onGraphicClick() {
    } }, this.enableMovement = true, this.enableRotation = true, this.enableScaling = true, this.graphics = [], this.highlightsEnabled = true, this.layer = null, this.preserveAspectRatio = false, this.showCenterGraphic = true, this.symbols = V, this.sketchOptions = new l(), this.view = null, this._getBounds = (() => {
      const t2 = u3();
      return (e4, i3) => {
        e4[0] = Number.POSITIVE_INFINITY, e4[1] = Number.POSITIVE_INFINITY, e4[2] = Number.NEGATIVE_INFINITY, e4[3] = Number.NEGATIVE_INFINITY;
        for (const s2 of i3) {
          if (!s2)
            continue;
          let i4, o4, r3, a4;
          if ("point" === s2.type)
            i4 = r3 = s2.x, o4 = a4 = s2.y;
          else if ("multipoint" === s2.type) {
            const e5 = e2(s2);
            [i4, o4, r3, a4] = x2(t2, [e5]);
          } else if ("extent" === s2.type)
            [i4, o4, r3, a4] = [s2.xmin, s2.ymin, s2.xmax, s2.ymax];
          else {
            const e5 = e2(s2);
            [i4, o4, r3, a4] = x2(t2, e5);
          }
          e4[0] = Math.min(i4, e4[0]), e4[1] = Math.min(o4, e4[1]), e4[2] = Math.max(r3, e4[2]), e4[3] = Math.max(a4, e4[3]);
        }
        return e4;
      };
    })();
  }
  initialize() {
    const t = this.view;
    this._highlightHelper = new h2({ view: t }), this.tooltip = new u4({ view: t }), this._setup(), this.addHandles([p(() => t == null ? void 0 : t.ready, () => {
      const { layer: t2, view: e4 } = this;
      e3(e4, t2);
    }, { once: true, initial: true }), d(() => this.preserveAspectRatio, () => {
      this._activeHandleGraphic && (this._scaleGraphic(this._activeHandleGraphic), this._updateGraphics(), this._updateTooltip(this._activeHandleGraphic));
    }), d(() => t == null ? void 0 : t.scale, () => {
      this._updateRotateGraphic(), this._updateRotateLineGraphic();
    }), d(() => this.graphics, () => this.refresh()), d(() => this.layer, (t2, e4) => {
      e4 && this._resetGraphics(e4), this.refresh();
    }), d(() => this.highlightsEnabled, () => {
      var _a;
      (_a = this._highlightHelper) == null ? void 0 : _a.removeAll(), this._setUpHighlights();
    }), d(() => this.sketchOptions.tooltips.effectiveEnabled, (t2) => {
      this.tooltip = t2 ? new u4({ view: this.view }) : u(this.tooltip);
    }, A), d(() => this.view.effectiveTheme.accentColor, () => this._updateSymbolsForTheme(), P), this.on("move-start", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onMoveStart) == null ? void 0 : _b.call(_a, t2);
    }), this.on("move", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onMove) == null ? void 0 : _b.call(_a, t2);
    }), this.on("move-stop", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onMoveStop) == null ? void 0 : _b.call(_a, t2);
    }), this.on("rotate-start", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onRotateStart) == null ? void 0 : _b.call(_a, t2);
    }), this.on("rotate", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onRotate) == null ? void 0 : _b.call(_a, t2);
    }), this.on("rotate-stop", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onRotateStop) == null ? void 0 : _b.call(_a, t2);
    }), this.on("scale-start", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onScaleStart) == null ? void 0 : _b.call(_a, t2);
    }), this.on("scale", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onScale) == null ? void 0 : _b.call(_a, t2);
    }), this.on("scale-stop", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onScaleStop) == null ? void 0 : _b.call(_a, t2);
    })]);
  }
  destroy() {
    this._reset(), this.tooltip = u(this.tooltip);
  }
  get state() {
    var _a;
    const t = ((_a = this.view) == null ? void 0 : _a.ready) ?? false, e4 = this.graphics.length && this.layer;
    return t && e4 ? "active" : t ? "ready" : "disabled";
  }
  isUIGraphic(t) {
    return this._vertexGraphics.includes(t) || t === this._backgroundGraphic || t === this._centerGraphic || t === this._rotateHandleGraphic || t === this._rotateLineGraphic;
  }
  move(t, e4) {
    if (this._mover && this.graphics.length) {
      for (const i3 of this.graphics) {
        const s2 = i3.geometry, o4 = i2(s2, t, e4, this.view);
        i3.geometry = o4;
      }
      this.refresh(), this.emit("move-stop", new Y(this.graphics, null, t, e4));
    }
  }
  scale(t, e4) {
    if (this._mover && this.graphics.length) {
      for (const i3 of this.graphics) {
        const s2 = i3.geometry, o4 = s(s2, t, e4);
        i3.geometry = o4;
      }
      this.refresh(), this.emit("scale-stop", new F(this.graphics, null, t, e4));
    }
  }
  rotate(t, e4) {
    if (this._mover && this.graphics.length) {
      if (!e4) {
        const t2 = this._vertexGraphics[1].geometry.x, i3 = this._vertexGraphics[3].geometry.y;
        e4 = new x(t2, i3, this.view.spatialReference);
      }
      for (const i3 of this.graphics) {
        const s2 = i3.geometry, o4 = r2(s2, t, e4);
        i3.geometry = o4;
      }
      this.refresh(), this.emit("rotate-stop", new A2(this.graphics, null, t));
    }
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphics = [];
  }
  _setup() {
    "active" === this.state && (this._setUpHighlights(), this._setupGraphics(), this._setupMover(), this._updateGraphics());
  }
  _reset() {
    var _a;
    (_a = this._highlightHelper) == null ? void 0 : _a.removeAll(), this._resetGraphicStateVars(), this._resetGraphics(), this._updateTooltip(), this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetGraphicStateVars() {
    this._startInfo = null, this._activeHandleGraphic = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this._angleOfRotation = 0;
  }
  _resetGraphics(t) {
    (t = t || this.layer) && (t.removeMany(this._vertexGraphics), t.remove(this._backgroundGraphic), t.remove(this._centerGraphic), t.remove(this._rotateHandleGraphic), t.remove(this._rotateLineGraphic)), this._vertexGraphics.forEach((t2) => !t2.destroyed && t2.destroy()), !this._backgroundGraphic.destroyed && this._backgroundGraphic.destroy(), !this._centerGraphic.destroyed && this._centerGraphic.destroy(), !this._rotateHandleGraphic.destroyed && this._rotateHandleGraphic.destroy(), !this._rotateLineGraphic.destroyed && this._rotateLineGraphic.destroy(), this._vertexGraphics = [], this._backgroundGraphic = null, this._centerGraphic = null, this._rotateHandleGraphic = null, this._rotateLineGraphic = null;
  }
  _setupMover() {
    let t = [];
    this.enableScaling && (t = t.concat(this._vertexGraphics)), this.enableMovement && (t = t.concat(this.graphics, this._backgroundGraphic)), this.enableRotation && t.push(this._rotateHandleGraphic), this.showCenterGraphic && t.push(this._centerGraphic), this._mover = new U({ enableMoveAllGraphics: false, highlightsEnabled: false, indicatorsEnabled: false, view: this.view, graphics: t, callbacks: { onGraphicClick: (t2) => this._onGraphicClickCallback(t2), onGraphicMoveStart: (t2) => this._onGraphicMoveStartCallback(t2), onGraphicMove: (t2) => this._onGraphicMoveCallback(t2), onGraphicMoveStop: (t2) => this._onGraphicMoveStopCallback(t2), onGraphicPointerOver: (t2) => this._onGraphicPointerOverCallback(t2), onGraphicPointerOut: (t2) => this._onGraphicPointerOutCallback(t2) } });
  }
  _getStartInfo(t) {
    const [e4, i3, s2, o4] = this._getBoxBounds(u3()), r3 = Math.abs(s2 - e4), a4 = Math.abs(o4 - i3), h4 = (s2 + e4) / 2, c = (o4 + i3) / 2, { x: n, y: l2 } = t.geometry;
    return { width: r3, height: a4, centerX: h4, centerY: c, startX: n, startY: l2, graphicInfos: this._getGraphicInfos(), box: this._backgroundGraphic.geometry, rotate: this._rotateHandleGraphic.geometry };
  }
  _getGraphicInfos() {
    return this.graphics.map((t) => this._getGraphicInfo(t));
  }
  _getGraphicInfo(t) {
    const e4 = t.geometry, [i3, s2, o4, r3] = this._getBounds(u3(), [e4]);
    return { width: Math.abs(o4 - i3), height: Math.abs(r3 - s2), centerX: (o4 + i3) / 2, centerY: (r3 + s2) / 2, geometry: e4 };
  }
  _onGraphicClickCallback(t) {
    t.viewEvent.stopPropagation(), this.emit("graphic-click", t), this.callbacks.onGraphicClick && this.callbacks.onGraphicClick(t);
  }
  _onGraphicMoveStartCallback(t) {
    const { _angleOfRotation: e4, _xScale: i3, _yScale: s2, _backgroundGraphic: o4, _vertexGraphics: r3, _rotateHandleGraphic: a4, symbols: h4 } = this, c = t.graphic;
    this._resetGraphicStateVars(), this._hideGraphicsBeforeUpdate(), o4.symbol = h4.fill.active, this._startInfo = this._getStartInfo(c), this._updateTooltip(c, t.viewEvent), c === a4 ? (this.view.cursor = "grabbing", this.emit("rotate-start", new N(this.graphics, c, e4))) : r3.includes(c) ? (this._activeHandleGraphic = c, this.emit("scale-start", new P2(this.graphics, c, i3, s2))) : this.emit("move-start", new z(this.graphics, c, t.dx, t.dy));
  }
  _onGraphicMoveCallback(t) {
    const e4 = t.graphic;
    if (this._startInfo)
      if (this._vertexGraphics.includes(e4))
        this._scaleGraphic(e4), this._updateTooltip(e4, t.viewEvent), this.emit("scale", new X(this.graphics, e4, this._xScale, this._yScale));
      else if (e4 === this._rotateHandleGraphic)
        this._rotateGraphic(e4), this._updateTooltip(e4, t.viewEvent), this.emit("rotate", new U2(this.graphics, e4, this._angleOfRotation));
      else {
        const { dx: i3, dy: s2 } = t;
        this._totalDx += i3, this._totalDy += s2, this._moveGraphic(e4, i3, s2), this._updateTooltip(e4, t.viewEvent), this.emit("move", new B(this.graphics, e4, i3, s2));
      }
  }
  _onGraphicMoveStopCallback(t) {
    const e4 = t.graphic;
    if (!this._startInfo)
      return void this.refresh();
    const { _angleOfRotation: i3, _totalDx: s2, _totalDy: o4, _xScale: r3, _yScale: a4, _vertexGraphics: h4, _rotateHandleGraphic: c } = this;
    this.refresh(), e4 === c ? (this.view.cursor = "pointer", this.emit("rotate-stop", new A2(this.graphics, e4, i3))) : h4.includes(e4) ? this.emit("scale-stop", new F(this.graphics, e4, r3, a4)) : this.emit("move-stop", new Y(this.graphics, e4, s2, o4));
  }
  _onGraphicPointerOverCallback(t) {
    const { _backgroundGraphic: e4, _vertexGraphics: i3, graphics: s2, _rotateHandleGraphic: o4, symbols: r3, view: a4 } = this, h4 = t.graphic;
    if (this._hoveredGraphic = h4, h4 === o4)
      return o4.symbol = r3.rotator.hover, a4.cursor = "pointer", void this._updateTooltip(h4);
    if (s2.includes(h4) || h4 === e4)
      return void (a4.cursor = "move");
    if (!i3.includes(h4))
      return void (a4.cursor = "pointer");
    this._updateTooltip(h4), t.graphic.symbol = r3.handles.hover;
    const c = a4.rotation;
    let n, l2 = t.index;
    switch (l2 < 8 && (c >= 0 && c < 45 ? l2 %= 8 : l2 = c >= 45 && c < 90 ? (l2 + 1) % 8 : c >= 90 && c < 135 ? (l2 + 2) % 8 : c >= 135 && c < 180 ? (l2 + 3) % 8 : c >= 180 && c < 225 ? (l2 + 4) % 8 : c >= 225 && c < 270 ? (l2 + 5) % 8 : c >= 270 && c < 315 ? (l2 + 6) % 8 : (l2 + 7) % 8), l2) {
      case 0:
      case 4:
        n = "nwse-resize";
        break;
      case 1:
      case 5:
        n = "ns-resize";
        break;
      case 2:
      case 6:
        n = "nesw-resize";
        break;
      case 3:
      case 7:
        n = "ew-resize";
        break;
      default:
        n = "pointer";
    }
    a4.cursor = n;
  }
  _onGraphicPointerOutCallback(t) {
    const { _vertexGraphics: e4, _rotateHandleGraphic: i3, symbols: s2, view: o4 } = this;
    this._hoveredGraphic = null, t.graphic === i3 ? i3.symbol = s2.rotator.default : e4.includes(t.graphic) && (t.graphic.symbol = s2.handles.default), o4.cursor = "default", this._updateTooltip();
  }
  _scaleGraphic(t) {
    const { _startInfo: e4, _vertexGraphics: i3, preserveAspectRatio: s2, view: o4 } = this, { centerX: r3, centerY: a4, graphicInfos: h4, height: c, startX: n, startY: l2, width: p3 } = e4, { resolution: _, transform: d3 } = o4.state, m4 = i3.indexOf(t);
    1 !== m4 && 5 !== m4 || this._updateX(t, r3), 3 !== m4 && 7 !== m4 || this._updateY(t, a4);
    const { x: u5, y: g } = t.geometry, v = d3[0] * u5 + d3[2] * g + d3[4], G = d3[1] * u5 + d3[3] * g + d3[5], w = (h4 == null ? void 0 : h4.map((t2) => t2.geometry)) ?? [], x3 = w.every((t2) => "point" === t2.type);
    if ((0 === p3 || 0 === c) && x3) {
      const t2 = J((u5 - n) / _), i4 = J((l2 - g) / _);
      for (let e5 = 0; e5 < w.length; e5++)
        this.graphics[e5].geometry = i2(w[e5], t2, i4, o4, true);
      return this._centerGraphic.geometry = new x(u5, g, o4.spatialReference), void (this._backgroundGraphic.geometry = i2(e4.box, t2, i4, o4, true));
    }
    if (s2) {
      const t2 = J(d3[0] * r3 + d3[2] * a4 + d3[4], 2), e5 = J(d3[1] * r3 + d3[3] * a4 + d3[5], 2), i4 = J(d3[0] * n + d3[2] * l2 + d3[4], 2), s3 = J(d3[1] * n + d3[3] * l2 + d3[5], 2);
      let o5 = a3(t2, e5, i4, s3, v, G);
      0 !== o5 && Math.abs(o5) !== 1 / 0 || (o5 = 1), this._xScale = this._yScale = o5;
      for (const h5 of w) {
        const t3 = w.indexOf(h5);
        this.graphics[t3].geometry = s(h5, this._xScale, this._yScale, [r3, a4]);
      }
      this._updateBackgroundGraphic();
    } else {
      let t2 = u5 - n, i4 = l2 - g;
      if (1 === m4 || 5 === m4 ? t2 = 0 : 3 !== m4 && 7 !== m4 || (i4 = 0), 0 === t2 && 0 === i4)
        return;
      const s3 = r3 + t2 / 2, h5 = a4 + i4 / 2;
      let d4 = (p3 + (n > r3 ? t2 : -1 * t2)) / p3, v2 = (c + (l2 < a4 ? i4 : -1 * i4)) / c;
      1 !== m4 && 5 !== m4 && 0 !== d4 && Math.abs(d4) !== 1 / 0 || (d4 = 1), 3 !== m4 && 7 !== m4 && 0 !== v2 && Math.abs(v2) !== 1 / 0 || (v2 = 1), this._xScale = d4, this._yScale = v2;
      const G2 = (s3 - r3) / _, b = (h5 - a4) / _, x4 = s(e4.box, this._xScale, this._yScale);
      this._backgroundGraphic.geometry = i2(x4, G2, b, o4, true);
      const { centerX: S2, centerY: k } = this._getGraphicInfo(this._backgroundGraphic), R = (S2 - r3) / _, M = -1 * (k - a4) / _;
      for (const e5 of w) {
        const t3 = w.indexOf(e5), i5 = s(e5, this._xScale, this._yScale, [r3, a4]);
        this.graphics[t3].geometry = i2(i5, R, M, o4, true);
      }
      this._centerGraphic.geometry = new x(S2, k, o4.spatialReference);
    }
  }
  _rotateGraphic(t) {
    var _a;
    const { centerX: e4, centerY: i3, startX: s2, startY: o4, box: r3, rotate: a4 } = this._startInfo, h4 = this.view.spatialReference, c = new x(s2, o4, h4), n = new x(e4, i3, h4), l2 = t.geometry;
    this._angleOfRotation = m3(c, l2, n);
    const p3 = ((_a = this._startInfo.graphicInfos) == null ? void 0 : _a.map((t2) => t2.geometry)) ?? [];
    for (const _ of p3) {
      const t2 = p3.indexOf(_), e5 = r2(_, this._angleOfRotation, n);
      this.graphics[t2].geometry = e5;
    }
    this._backgroundGraphic.geometry = r2(r3, this._angleOfRotation, n), this._rotateHandleGraphic.geometry = r2(a4, this._angleOfRotation, n);
  }
  _moveGraphic(t, e4, i3) {
    if (this.graphics.includes(t)) {
      const s2 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = i2(s2, e4, i3, this.view);
      for (const o4 of this.graphics)
        o4 !== t && (o4.geometry = i2(o4.geometry, e4, i3, this.view));
    } else if (t === this._centerGraphic) {
      const t2 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = i2(t2, e4, i3, this.view);
    }
    if (t === this._backgroundGraphic || t === this._centerGraphic)
      for (const s2 of this.graphics)
        s2.geometry = i2(s2.geometry, e4, i3, this.view);
  }
  _setUpHighlights() {
    var _a;
    this.highlightsEnabled && this.graphics.length && ((_a = this._highlightHelper) == null ? void 0 : _a.add(this.graphics));
  }
  _setupGraphics() {
    const { _graphicAttributes: t, symbols: i3 } = this;
    this._centerGraphic = new f(null, i3.centerIndicator, t), this.showCenterGraphic && this.layer.add(this._centerGraphic), this._backgroundGraphic = new f(null, i3.fill.default, t), this.layer.add(this._backgroundGraphic), this._rotateLineGraphic = new f(null, i3.rotatorLine, t), this._rotateHandleGraphic = new f(null, i3.rotator.default, t), this.enableRotation && !this._hasExtentGraphic() && this.layer.addMany([this._rotateLineGraphic, this._rotateHandleGraphic]);
    for (let s2 = 0; s2 < 8; s2++)
      this._vertexGraphics.push(new f(null, i3.handles.default, t));
    this.enableScaling && this.layer.addMany(this._vertexGraphics);
  }
  _updateSymbolsForTheme() {
    var _a, _b;
    const t = this.view.effectiveTheme.accentColor;
    this.symbols = { ...this.symbols, fill: { active: (_a = this.symbols.fill.active) == null ? void 0 : _a.clone().set("outline.color", t), default: (_b = this.symbols.fill.default) == null ? void 0 : _b.clone().set("outline.color", t) }, handles: { ...this.symbols.handles, default: this.symbols.handles.default.clone().set("outline.color", t) }, rotator: { ...this.symbols.rotator, default: this.symbols.rotator.default.clone().set("outline.color", t) }, rotatorLine: this.symbols.rotatorLine.clone().set("color", t) };
    for (const e4 of this._vertexGraphics)
      e4.symbol = e4 === this._hoveredGraphic ? this.symbols.handles.hover : this.symbols.handles.default;
    this._backgroundGraphic.symbol = this.symbols.fill.default, this._rotateHandleGraphic.symbol = this._rotateHandleGraphic === this._hoveredGraphic ? this.symbols.rotator.hover : this.symbols.rotator.default, this._rotateLineGraphic.symbol = this.symbols.rotatorLine;
  }
  _updateGraphics() {
    this._updateBackgroundGraphic(), this._updateHandleGraphics(), this._updateCenterGraphic(), this._updateRotateGraphic(), this._updateRotateLineGraphic();
  }
  _hideGraphicsBeforeUpdate() {
    this._centerGraphic.visible = false, this._rotateHandleGraphic.visible = false, this._rotateLineGraphic.visible = false, this._vertexGraphics.forEach((t) => t.visible = false);
  }
  _updateHandleGraphics() {
    const t = this._getCoordinates(true);
    this._vertexGraphics.forEach((e4, i3) => {
      const [s2, o4] = t[i3];
      this._updateXY(e4, s2, o4);
    });
  }
  _updateBackgroundGraphic() {
    const t = this._getCoordinates();
    this._backgroundGraphic.geometry = new j({ rings: t, spatialReference: this.view.spatialReference });
  }
  _updateCenterGraphic() {
    const [t, e4, i3, s2] = this._getBoxBounds(u3()), o4 = (i3 + t) / 2, r3 = (s2 + e4) / 2;
    this._centerGraphic.geometry = new x(o4, r3, this.view.spatialReference);
  }
  _updateRotateGraphic() {
    if (!this._vertexGraphics.length)
      return;
    const { x: t, y: e4 } = this._vertexGraphics[1].geometry, i3 = e4 + this.view.state.resolution * this._rotateGraphicOffset;
    this._rotateHandleGraphic.geometry = new x(t, i3, this.view.spatialReference);
  }
  _updateRotateLineGraphic() {
    var _a;
    if (!this._vertexGraphics.length || !((_a = this._rotateHandleGraphic) == null ? void 0 : _a.geometry))
      return;
    const t = this._vertexGraphics[1].geometry, e4 = this._rotateHandleGraphic.geometry;
    this._rotateLineGraphic.geometry = new m({ paths: [[t.x, t.y], [e4.x, e4.y]], spatialReference: this.view.spatialReference });
  }
  _updateXY(t, e4, i3) {
    t.geometry = new x(e4, i3, this.view.spatialReference);
  }
  _updateX(t, e4) {
    const i3 = t.geometry.y;
    t.geometry = new x(e4, i3, this.view.spatialReference);
  }
  _updateY(t, e4) {
    const i3 = t.geometry.x;
    t.geometry = new x(i3, e4, this.view.spatialReference);
  }
  _hasExtentGraphic() {
    return this.graphics.some((t) => null != (t == null ? void 0 : t.geometry) && "extent" === t.geometry.type);
  }
  _getBoxBounds(t) {
    const e4 = this.graphics.map((t2) => t2.geometry);
    return this._getBounds(t, e4);
  }
  _getCoordinates(t) {
    const [e4, i3, s2, o4] = this._getBoxBounds(u3());
    if (t) {
      const t2 = (e4 + s2) / 2, r3 = (o4 + i3) / 2;
      return [[e4, o4], [t2, o4], [s2, o4], [s2, r3], [s2, i3], [t2, i3], [e4, i3], [e4, r3]];
    }
    return [[e4, o4], [s2, o4], [s2, i3], [e4, i3]];
  }
  _updateTooltip(t, e4) {
    if (null == this.tooltip)
      return;
    if (!t)
      return void this.tooltip.clear();
    const { _backgroundGraphic: i3, graphics: s2, _vertexGraphics: o4, _rotateHandleGraphic: r3 } = this;
    t === r3 ? this._updateRotateTooltip() : o4.includes(t) ? this._updateScaleTooltip() : (s2.includes(t) || t === i3) && this._updateMoveTooltip(e4);
  }
  _updateRotateTooltip() {
    null != this.tooltip && (this.tooltip.info = new i({ sketchOptions: this.sketchOptions, angle: -this._angleOfRotation }));
  }
  _updateScaleTooltip() {
    const { tooltip: t, _xScale: e4, _yScale: i3, sketchOptions: s2, view: o4 } = this;
    if (null == t)
      return;
    const r3 = this._getCoordinates(), a4 = o2({ topLeft: r3[0], topRight: r3[1], bottomRight: r3[2], bottomLeft: r3[3], spatialReference: o4.spatialReference });
    if (null == a4)
      return;
    const { xSize: h4, ySize: c } = a4, n = Math.abs(e4), l2 = Math.abs(i3);
    t.info = new p2({ sketchOptions: s2, xScale: n, yScale: l2, xSize: h4, ySize: c });
  }
  _updateMoveTooltip(t) {
    const { tooltip: e4, sketchOptions: i3, view: s2 } = this;
    if (null == e4)
      return;
    const r3 = new r({ sketchOptions: i3 });
    if (t) {
      const { x: e5, y: i4 } = t.origin, a4 = s2.toMap(t), h4 = s2.toMap({ x: e5, y: i4 }), c = m2(h4, a4);
      r3.distance = null != c ? c : h;
    }
    e4.info = r3;
  }
};
function J(t, e4 = 2) {
  return Number.parseFloat(t.toFixed(e4));
}
e([y()], q.prototype, "tooltip", void 0), e([y({ readOnly: true })], q.prototype, "type", void 0), e([y()], q.prototype, "callbacks", void 0), e([y()], q.prototype, "enableMovement", void 0), e([y()], q.prototype, "enableRotation", void 0), e([y()], q.prototype, "enableScaling", void 0), e([y()], q.prototype, "graphics", void 0), e([y()], q.prototype, "highlightsEnabled", void 0), e([y()], q.prototype, "layer", void 0), e([y()], q.prototype, "preserveAspectRatio", void 0), e([y()], q.prototype, "showCenterGraphic", void 0), e([y({ readOnly: true })], q.prototype, "state", null), e([y()], q.prototype, "symbols", void 0), e([y({ type: l })], q.prototype, "sketchOptions", void 0), e([y({ constructOnly: true })], q.prototype, "view", void 0), q = e([a("esri.views.draw.support.Box")], q);
var K = q;
export {
  K as default
};
//# sourceMappingURL=Box-Q7ZSFDVV.js.map
