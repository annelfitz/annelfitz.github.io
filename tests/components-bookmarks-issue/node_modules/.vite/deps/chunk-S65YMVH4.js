import {
  i,
  l,
  p,
  r as r2,
  u as u2,
  w
} from "./chunk-DTQH7ECI.js";
import {
  m,
  y2
} from "./chunk-54XXLVAD.js";
import {
  I
} from "./chunk-KO7QNSNZ.js";
import {
  x
} from "./chunk-ZIJHDTB7.js";
import {
  y
} from "./chunk-HU5IGOTI.js";
import {
  d
} from "./chunk-C24MEKSO.js";
import {
  u
} from "./chunk-WDPG5BMO.js";
import {
  r
} from "./chunk-CXNX736Z.js";
import {
  a
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/smartMapping/renderers/support/referenceSizeUtils.js
var a3;
function l2(e) {
  switch (e) {
    case "circle":
      return { rings: [[[8.5, 0.2], [7.06, 0.33], [5.66, 0.7], [4.35, 1.31], [3.16, 2.14], [2.14, 3.16], [1.31, 4.35], [0.7, 5.66], [0.33, 7.06], [0.2, 8.5], [0.33, 9.94], [0.7, 11.34], [1.31, 12.65], [2.14, 13.84], [3.16, 14.86], [4.35, 15.69], [5.66, 16.3], [7.06, 16.67], [8.5, 16.8], [9.94, 16.67], [11.34, 16.3], [12.65, 15.69], [13.84, 14.86], [14.86, 13.84], [15.69, 12.65], [16.3, 11.34], [16.67, 9.94], [16.8, 8.5], [16.67, 7.06], [16.3, 5.66], [15.69, 4.35], [14.86, 3.16], [13.84, 2.14], [12.65, 1.31], [11.34, 0.7], [9.94, 0.33], [8.5, 0.2]]] };
    case "square":
      return { rings: [[[0.5, 0.5], [0.5, 16.5], [16.5, 16.5], [16.5, 0.5], [0.5, 0.5]]] };
    case "diamond":
      return { rings: [[[8.5, 0.5], [0.2, 8.5], [8.5, 16.5], [16.5, 8.5], [8.5, 0.5]]] };
    case "hexagon-pointy":
      return { rings: [[[15.86, 12.75], [15.86, 4.25], [8.5, 0], [1.14, 4.25], [1.14, 12.75], [8.5, 17], [15.86, 12.75]]] };
    case "hexagon-flat":
      return { rings: [[[12.75, 15.86], [17, 8.5], [12.75, 1.14], [4.25, 1.14], [0, 8.5], [4.25, 15.86], [12.75, 15.86]]] };
  }
}
function c(e) {
  var _a;
  return "CIMVectorMarker" === (e == null ? void 0 : e.type) ? (_a = e.markerGraphics) == null ? void 0 : _a[0] : void 0;
}
function y3(e) {
  var _a, _b;
  return "CIMPolygonSymbol" === ((_a = e == null ? void 0 : e.symbol) == null ? void 0 : _a.type) ? (_b = e.symbol.symbolLayers) == null ? void 0 : _b[0] : void 0;
}
function p2(e, r3) {
  "CIMVectorMarker" === (e == null ? void 0 : e.type) && null != r3 && (e.size = r3);
}
function f(e, r3) {
  const n = c(e);
  n && null != r3 && (n.geometry = l2(r3));
}
function v(e, r3) {
  const n = y3(c(e));
  n && null != r3 && (n.color = r3.toArray());
}
function S(e, r3, n) {
  const i2 = y3(c(e));
  i2 && null != r3 && n && (i2.colorLocked = r3, i2.primitiveName = r3 ? "grayRing" : "symbolFill");
}
function b(e, n) {
  var _a;
  const { outerRingSize: i2, innerDotSize: t, type: o, color: l3, colorLocked: m2, primitiveOverrides: s2 } = n, u3 = "CIMPolygonSymbol" === ((_a = e.data.symbol) == null ? void 0 : _a.type) ? e.data.symbol.symbolLayers : null;
  if (2 === (u3 == null ? void 0 : u3.length))
    for (const r3 of u3) {
      const e2 = r3.primitiveName === a3.OuterRing;
      p2(r3, e2 ? i2 : t), f(r3, o), v(r3, l3), S(r3, m2, e2);
    }
  return null != i2 && null != t && (e.data.primitiveOverrides = null), void 0 !== s2 && (e.data.primitiveOverrides = a(s2)), e;
}
!function(e) {
  e.OuterRing = "outerRing", e.InnerDot = "innerDot";
}(a3 || (a3 = {}));

// node_modules/@arcgis/core/widgets/Legend/support/sizeRampUtils.js
var b2 = 30;
var h = 12;
var d3 = 24;
var w2 = [255, 255, 255];
var S2 = [200, 200, 200];
var g = [128, 128, 128];
var v2 = 20;
var z = 5;
function j(e) {
  return "esri.symbols.SimpleMarkerSymbol" === e.declaredClass;
}
function k(e) {
  return "esri.symbols.PictureMarkerSymbol" === e.declaredClass;
}
function V(e) {
  return "esri.symbols.SimpleLineSymbol" === e.declaredClass;
}
function x2(e) {
  return "esri.symbols.TextSymbol" === e.declaredClass;
}
function I2(e, l3) {
  const t = e.length - 1;
  return e.map((e2, n) => r2(e2, n, t, l3));
}
async function L(e, l3, n, o, i2, s2, c2) {
  const m2 = l3.legendOptions, p3 = m2 == null ? void 0 : m2.customValues, f2 = c2 || await D(e, n), y4 = l3.stops, b3 = !!f2, h2 = !!p3, w3 = null != l3.minSize && null != l3.maxSize, S3 = y4 && y4.length > 1, g2 = !!l3.target;
  if (!b3 || !h2 && !(w3 || S3 && !g2))
    return;
  const v3 = y2(f2);
  let z2 = false, j2 = null, k2 = null;
  j2 = v3 && !S3 ? u2([l3.minDataValue, l3.maxDataValue]) : p3 ?? await T(l3, f2, o, i2 == null ? void 0 : i2.type);
  const V2 = e == null ? void 0 : e.authoringInfo, x3 = "univariate-color-size" === (V2 == null ? void 0 : V2.type), L2 = x3 && "above-and-below" === (V2 == null ? void 0 : V2.univariateTheme), q2 = !!w(e);
  if (!j2 && S3 && (j2 = y4.map((e2) => e2.value), z2 = y4.some((e2) => !!e2.label), "flow" === e.type && (j2 = u2(j2)), z2 && (k2 = y4.map((e2) => e2.label))), v3 && null != j2 && (j2 == null ? void 0 : j2.length) > 2 && !L2 && (j2 = [j2[0], j2[j2.length - 1]]), !j2)
    return null;
  x3 && 5 !== (j2 == null ? void 0 : j2.length) && (j2 = P({ minSize: j2[0], maxSize: j2[j2.length - 1] }));
  const B2 = v3 ? U(e, j2) : null, E2 = m(f2), R2 = z2 ? null : I2(j2, s2);
  return (await Promise.all(j2.map(async (t, s3) => {
    const r3 = v3 ? B2[s3] : await H(l3, f2, t, o, i2 == null ? void 0 : i2.type);
    return { value: t, symbol: !q2 || "class-breaks" !== e.type && "unique-value" !== e.type ? O(L2 && "class-breaks" === e.type ? C(e, s3) : f2, r3) : M(e, r3, l3.maxSize, n) ?? f2, label: z2 ? k2[s3] : R2[s3], size: q2 ? d3 : r3, outlineSize: E2 };
  }))).reverse();
}
function U(e, l3) {
  const t = e == null ? void 0 : e.authoringInfo, n = "univariate-color-size" === (t == null ? void 0 : t.type);
  let o = [h, b2];
  if (n) {
    const e2 = l3[0], t2 = l3[l3.length - 1], n2 = h, i2 = b2;
    o = l3.map((l4) => n2 + (l4 - e2) / (t2 - e2) * (i2 - n2));
  }
  return n && "below" === (t == null ? void 0 : t.univariateTheme) && o.reverse(), o;
}
function M(l3, t, n, o) {
  var _a, _b, _c, _d, _e, _f;
  const s2 = "class-breaks" === l3.type, r3 = s2 ? (_c = (_b = (_a = l3.classBreakInfos) == null ? void 0 : _a[0]) == null ? void 0 : _b.symbol) == null ? void 0 : _c.clone() : (_f = (_e = (_d = l3.uniqueValueInfos) == null ? void 0 : _d[0]) == null ? void 0 : _e.symbol) == null ? void 0 : _f.clone();
  return r3 && "type" in r3 && "cim" === r3.type ? (b(r3, { color: o ?? (s2 ? null : new u(S2)), innerDotSize: t * (d3 / n) || 1, outerRingSize: d3 }), r3) : null;
}
function C(e, l3) {
  const t = e.classBreakInfos, n = t.length, o = n < 2 || !(l3 >= 2) ? t[0].symbol.clone() : t[n - 1].symbol.clone();
  return e.visualVariables.some((e2) => "color" === e2.type) && (o.type.includes("3d") ? B(o) : E(o)), o;
}
async function D(e, l3) {
  var _a, _b;
  if ("flow" === e.type)
    return p(e, l3);
  if ("pie-chart" === e.type)
    return new y({ color: null, outline: ((_a = e.outline) == null ? void 0 : _a.width) ? e.outline : new d() });
  let t = null, n = null;
  if ("simple" === e.type)
    t = e.symbol;
  else if ("class-breaks" === e.type) {
    const l4 = e.classBreakInfos;
    t = l4 && l4[0] && l4[0].symbol, n = l4.length > 1;
  } else if ("unique-value" === e.type) {
    const l4 = e.uniqueValueInfos;
    t = (_b = l4 == null ? void 0 : l4[0]) == null ? void 0 : _b.symbol, n = null != l4 && l4.length > 1;
  }
  return !t || q(t) ? null : (t = t.clone(), (l3 || n) && (t.type.includes("3d") ? B(t) : E(t)), t);
}
function q(e) {
  if (e) {
    if (x(e)) {
      return !!e.symbolLayers && e.symbolLayers.some((e2) => e2 && "fill" === e2.type);
    }
    return e.type.includes("fill");
  }
  return false;
}
function B(e) {
  "line-3d" === e.type ? e.symbolLayers.forEach((e2) => {
    e2.material = { color: g };
  }) : e.symbolLayers.forEach((e2) => {
    var _a;
    "icon" !== e2.type || ((_a = e2.resource) == null ? void 0 : _a.href) ? e2.material = { color: S2 } : (e2.material = { color: w2 }, e2.outline = { color: g, size: 1.5 });
  });
}
function E(l3) {
  var _a, _b;
  const t = r();
  if ("cim" === l3.type)
    I(l3, new u(S2));
  else if (l3.type.includes("line"))
    l3.color = g;
  else if (l3.color = t ? g : w2, "simple-marker" === l3.type)
    if (l3.outline) {
      const e = (_b = (_a = l3.outline) == null ? void 0 : _a.color) == null ? void 0 : _b.toHex();
      "#ffffff" === e && (l3.outline.color = g);
    } else
      l3.outline = { color: g, width: 1.5 };
}
async function T(e, l3, n, o) {
  const i2 = (await import("./visualVariableUtils-OMMRO36I.js")).getSizeRangeAtScale(e, n, o), s2 = i2 && P(i2);
  if (!i2 || !s2)
    return;
  let r3 = s2.map((l4) => R(l4, e, i2));
  r3 = u2(r3);
  for (let t = 1; t < r3.length - 1; t++) {
    const i3 = await A(e, l3, r3[t], r3[t - 1], n, o);
    i3 && (r3[t] = i3[0], s2[t] = i3[1]);
  }
  return r3;
}
function P(e) {
  const l3 = e.minSize, t = e.maxSize, n = z, o = (t - l3) / (n - 1), i2 = [];
  for (let s2 = 0; s2 < n; s2++)
    i2.push(l3 + o * s2);
  return i2;
}
function R(e, l3, t) {
  const n = t.minSize, o = t.maxSize, i2 = l3.minDataValue, s2 = l3.maxDataValue;
  let r3;
  if (e <= n)
    r3 = i2;
  else if (e >= o)
    r3 = s2;
  else {
    r3 = (e - n) / (o - n) * (s2 - i2) + i2;
  }
  return r3;
}
async function A(e, l3, i2, s2, r3, a4) {
  const u3 = await H(e, l3, i2, r3, a4), c2 = await H(e, l3, s2, r3, a4), m2 = i(i2), p3 = m2.fractional, f2 = v2;
  let y4 = m2.integer, b3 = null, h2 = null;
  i2 > 0 && i2 < 1 && (b3 = 10 ** p3, y4 = i(i2 *= b3).integer);
  for (let n = y4 - 1; n >= 0; n--) {
    const s3 = 10 ** n;
    let m3 = Math.floor(i2 / s3) * s3, p4 = Math.ceil(i2 / s3) * s3;
    null != b3 && (m3 /= b3, p4 /= b3);
    let y5 = (m3 + p4) / 2;
    [, y5] = u2([m3, y5, p4], { indexes: [1] });
    const d4 = await H(e, l3, m3, r3, a4), w3 = await H(e, l3, p4, r3, a4), S3 = await H(e, l3, y5, r3, a4), g2 = l(u3, d4, c2, null), v3 = l(u3, w3, c2, null), z2 = l(u3, S3, c2, null);
    let j2 = g2.previous <= f2, k2 = v3.previous <= f2;
    if (j2 && k2 && (g2.previous <= v3.previous ? (j2 = true, k2 = false) : (k2 = true, j2 = false)), j2 ? h2 = [m3, d4] : k2 ? h2 = [p4, w3] : z2.previous <= f2 && (h2 = [y5, S3]), h2)
      break;
  }
  return h2;
}
async function H(e, l3, t, n, o) {
  const { getSize: i2 } = await import("./visualVariableUtils-OMMRO36I.js");
  return i2(e, t, { scale: n, view: o, shape: "simple-marker" === l3.type ? l3.style : null });
}
function O(e, t) {
  const n = e.clone();
  if (x(n))
    y2(n) || n.symbolLayers.forEach((e2) => {
      "fill" !== e2.type && (e2.size = t);
    });
  else if (j(n))
    n.size = t;
  else if (k(n)) {
    const e2 = n.width, l3 = n.height;
    n.height = t, n.width = t * (e2 / l3);
  } else
    V(n) ? n.width = t : x2(n) && n.font && (n.font.size = t);
  return n;
}

export {
  b,
  b2,
  h,
  L,
  M
};
//# sourceMappingURL=chunk-S65YMVH4.js.map
