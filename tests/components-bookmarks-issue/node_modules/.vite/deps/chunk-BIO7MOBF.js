import {
  j
} from "./chunk-B5IJN7OM.js";
import {
  e as e2,
  t as t2
} from "./chunk-BMTOVJNA.js";
import {
  t
} from "./chunk-CMLG62TA.js";
import {
  w
} from "./chunk-Z4Y53NDM.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/views/3d/layers/TiledLayerView3D.js
var c = (c2) => {
  let p = class extends c2 {
    get imageFormatIsOpaque() {
      return false;
    }
    get fullExtent() {
      return this.layer.fullExtent;
    }
    get isOpaque() {
      return this.fullOpacity >= 1 && this.imageFormatIsOpaque;
    }
    get dataScaleRange() {
      const e3 = this.tileInfo.lods;
      let t3 = e3[0].scale, i = e3[e3.length - 1].scale;
      if ("tilemapCache" in this.layer && this.layer.tilemapCache) {
        const { effectiveMinLOD: e4, effectiveMaxLOD: a2 } = this.layer.tilemapCache;
        t3 = this.tileInfo.lodAt(e4).scale, i = this.tileInfo.lodAt(a2).scale;
      }
      return { minScale: t3, maxScale: i };
    }
    get dataLevelRange() {
      const { minScale: e3, maxScale: t3 } = this.dataScaleRange;
      return this.levelRangeFromScaleRange(e3, t3);
    }
    get displayLevelRange() {
      const e3 = this.layer.minScale || this.dataScaleRange.minScale, t3 = this.layer.maxScale || this.dataScaleRange.maxScale, i = this.levelRangeFromScaleRange(e3, t3);
      return this.layer.maxScale && i.maxLevel++, i;
    }
    get performanceInfo() {
      return new t(this.view.basemapTerrain.getUsedMemoryForLayerView(this));
    }
    getTileUrl(e3, t3, i) {
      return this.layer.getTileUrl(e3, t3, i);
    }
    _addTilingSchemeMatchPromise() {
      if (null == this.fullExtent)
        return this.addResolvingPromise(Promise.reject(new s("tilingscheme:extent-not-defined", "This layer doesn't define a fullExtent.")));
      const e3 = this._getTileInfoSupportError(this.tileInfo, this.fullExtent);
      if (e3)
        return this.addResolvingPromise(Promise.reject(e3));
      const a2 = w(() => {
        var _a, _b;
        return (_b = (_a = this.view) == null ? void 0 : _a.basemapTerrain) == null ? void 0 : _b.tilingSchemeLocked;
      }).then(() => {
        var _a;
        const e4 = this.view.basemapTerrain.tilingScheme, t3 = "tilemapCache" in this.layer ? (_a = this.layer.tilemapCache) == null ? void 0 : _a.effectiveMaxLOD : void 0, i = this._getTileInfoCompatibilityError(this.tileInfo, e4, t3);
        if (i)
          throw i;
      });
      this.addResolvingPromise(a2);
    }
    _getTileInfoSupportError(e3, i) {
      var _a;
      const a2 = j(e3, i, this.view.spatialReference, this.view.state.viewingMode, "tilemapCache" in this.layer ? (_a = this.layer.tilemapCache) == null ? void 0 : _a.effectiveMaxLOD : void 0);
      if (a2) {
        const e4 = { layer: this.layer, error: a2 };
        let i2;
        switch (a2.name) {
          case "tilingscheme:spatial-reference-mismatch":
          case "tilingscheme:global-unsupported-spatial-reference":
          case "tilingscheme:local-unsupported-spatial-reference":
            i2 = new s("layerview:spatial-reference-incompatible", "The spatial reference of this layer does not meet the requirements of the view", e4);
            break;
          default:
            i2 = new s("layerview:tiling-scheme-unsupported", "The tiling scheme of this layer is not supported by SceneView", e4);
        }
        return i2;
      }
      return null;
    }
    _getTileInfoCompatibilityError(e3, i, a2) {
      return null != e3 && i.compatibleWith(e3, a2) ? null : new s("layerview:tiling-scheme-incompatible", "The tiling scheme of this layer is incompatible with the tiling scheme of the surface");
    }
    levelRangeFromScaleRange(e3, t3) {
      const i = { minLevel: 0, maxLevel: 1 / 0 }, a2 = this.view && this.view.basemapTerrain && this.view.basemapTerrain.tilingScheme;
      if (!a2)
        return i;
      const r = a2.levels[0], l = (e4) => {
        const t4 = Math.log(r.scale / e4) / Math.LN2;
        return 0.5 - Math.abs(0.5 - t4 % 1) < 1e-9 ? Math.round(t4) : Math.ceil(t4);
      };
      return null != e3 && e3 > 0 && (i.minLevel = Math.max(0, l(e3))), null != t3 && t3 > 0 && (i.maxLevel = Math.max(0, l(t3))), i;
    }
    isUpdating() {
      return !!(this.view && this.view.basemapTerrain && this.view.basemapTerrain.updating);
    }
  };
  return e([y({ readOnly: true })], p.prototype, "imageFormatIsOpaque", null), e([y({ readOnly: true })], p.prototype, "updating", void 0), e([y(t2)], p.prototype, "updatingProgress", void 0), e([y(e2)], p.prototype, "updatingProgressValue", void 0), e([y()], p.prototype, "fullExtent", null), e([y({ readOnly: true })], p.prototype, "isOpaque", null), e([y()], p.prototype, "dataScaleRange", null), e([y({ readOnly: true })], p.prototype, "dataLevelRange", null), e([y({ readOnly: true })], p.prototype, "displayLevelRange", null), e([y()], p.prototype, "layer", void 0), p = e([a("esri.views.3d.layers.TiledLayerView3D")], p), p;
};

export {
  c
};
//# sourceMappingURL=chunk-BIO7MOBF.js.map
