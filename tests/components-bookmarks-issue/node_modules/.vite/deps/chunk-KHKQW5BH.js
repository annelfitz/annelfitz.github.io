import {
  e as e5
} from "./chunk-4SMSAJZT.js";
import {
  j
} from "./chunk-X5WDIDKE.js";
import {
  i as i5
} from "./chunk-SWNHB34O.js";
import {
  t as t5
} from "./chunk-7Z3DFF4C.js";
import {
  m as m3
} from "./chunk-UXMZQA2H.js";
import {
  u as u4
} from "./chunk-NGAYW4TW.js";
import {
  l
} from "./chunk-VQKDRN55.js";
import {
  i as i4,
  r as r2
} from "./chunk-SGCIDT4C.js";
import {
  a as a4,
  a2 as a5,
  c as c4,
  h as h3,
  h2 as h4,
  i as i3,
  m as m2,
  n as n4,
  t as t3,
  t2 as t4,
  x,
  y as y2
} from "./chunk-QXRPUAVL.js";
import {
  b as b3
} from "./chunk-KN52PCW4.js";
import {
  E,
  N,
  R,
  a as a3
} from "./chunk-HRDKP7QO.js";
import {
  h as h2
} from "./chunk-4UOHLZKX.js";
import {
  t as t2
} from "./chunk-6RR3WN7W.js";
import {
  o as o3
} from "./chunk-O64IB52L.js";
import {
  r
} from "./chunk-4IJED6JM.js";
import {
  t
} from "./chunk-XXIDOBRO.js";
import {
  K2 as K,
  Z,
  ne,
  o as o5
} from "./chunk-ZPU7GNG4.js";
import {
  e as e4
} from "./chunk-IQFWVTUJ.js";
import {
  s as s3
} from "./chunk-5IT6RVBX.js";
import {
  i as i2,
  o as o4
} from "./chunk-IWO6JXL2.js";
import {
  P as P2
} from "./chunk-AVR3LWTZ.js";
import {
  h
} from "./chunk-I4SHZ6P5.js";
import {
  p
} from "./chunk-YH2IYJYF.js";
import {
  c as c2
} from "./chunk-H4O73SDK.js";
import {
  d as d3
} from "./chunk-DRC4XSYG.js";
import {
  c as c3
} from "./chunk-4IKPTZ53.js";
import {
  d as d2
} from "./chunk-VEYMN5N3.js";
import {
  b as b2
} from "./chunk-W5ALAOW2.js";
import {
  f as f4
} from "./chunk-IYKBAIQE.js";
import {
  d as d4
} from "./chunk-F3BQGS35.js";
import {
  i
} from "./chunk-A5QTLE4Y.js";
import {
  n as n3
} from "./chunk-SCHTG6ZQ.js";
import {
  f as f3
} from "./chunk-QYC3GV65.js";
import {
  m
} from "./chunk-NCRCDVOW.js";
import {
  T2 as T
} from "./chunk-X7VSXJWW.js";
import {
  n as n2
} from "./chunk-VEODBKUJ.js";
import {
  S as S2
} from "./chunk-G5EVVNIJ.js";
import {
  u as u3
} from "./chunk-BOAEEYBE.js";
import {
  w as w2
} from "./chunk-VTH4DAHQ.js";
import {
  O
} from "./chunk-HLDUDRTD.js";
import {
  u as u2
} from "./chunk-C7NPPGFR.js";
import {
  F,
  e as e3
} from "./chunk-OCF7OAES.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  f as f2
} from "./chunk-MBGZKT2Z.js";
import {
  o as o2
} from "./chunk-YOPMY6TS.js";
import {
  P,
  d
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a2
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  L,
  b,
  e as e2,
  f2 as f,
  s as s2
} from "./chunk-JGDJR5EV.js";
import {
  u
} from "./chunk-QHK5ZYFW.js";
import {
  a,
  c2 as c,
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import {
  has,
  k
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/AggregateGraphic.js
var p2 = class extends f3 {
  constructor() {
    super(...arguments), this.isAggregate = true;
  }
  getEffectivePopupTemplate(e8 = false) {
    var _a;
    if (this.popupTemplate)
      return this.popupTemplate;
    const t11 = (_a = this.sourceLayer) == null ? void 0 : _a.featureReduction;
    return t11 && "popupTemplate" in t11 && t11.popupEnabled ? t11.popupTemplate : null;
  }
  getObjectId() {
    return this.attributes.aggregateId;
  }
};
e([y({ type: Boolean })], p2.prototype, "isAggregate", void 0), p2 = e([a2("esri.AggregateGraphic")], p2);
var s4 = p2;

// node_modules/@arcgis/core/layers/effects/FeatureEffectView.js
var c5 = class extends S {
  constructor(e8) {
    super(e8), this._filter = null, this.duration = has("mapview-transitions-duration"), this._excludedEffectView = new h2(e8), this._includedEffectView = new h2(e8);
  }
  get excludedEffects() {
    return this._excludedEffectView.effects;
  }
  set featureEffect(e8) {
    this._get("featureEffect") !== e8 && this._transitionTo(e8);
  }
  get filter() {
    var _a;
    return this._filter || ((_a = this.featureEffect) == null ? void 0 : _a.filter) || null;
  }
  get hasEffects() {
    return this._excludedEffectView.hasEffects || this._includedEffectView.hasEffects;
  }
  get includedEffects() {
    return this._includedEffectView.effects;
  }
  set scale(e8) {
    this._set("scale", e8), this._excludedEffectView.scale = e8, this._includedEffectView.scale = e8;
  }
  get transitioning() {
    return this._excludedEffectView.transitioning || this._includedEffectView.transitioning;
  }
  transitionStep(e8, t11) {
    this._set("scale", t11), this.transitioning ? (this._includedEffectView.transitionStep(e8, t11), this._excludedEffectView.transitionStep(e8, t11), this.transitioning || (this._filter = null)) : (this._excludedEffectView.scale = t11, this._includedEffectView.scale = t11);
  }
  endTransitions() {
    this._includedEffectView.endTransitions(), this._excludedEffectView.endTransitions(), this._filter = null;
  }
  _transitionTo(e8) {
    const t11 = this._get("featureEffect"), i9 = e8, s8 = i9 == null ? void 0 : i9.includedEffect, f7 = i9 == null ? void 0 : i9.excludedEffect, c12 = this._includedEffectView.canTransitionTo(s8) && this._excludedEffectView.canTransitionTo(f7);
    this._includedEffectView.effect = s8, this._excludedEffectView.effect = f7, this._set("featureEffect", i9), this._filter = (i9 == null ? void 0 : i9.filter) || (t11 == null ? void 0 : t11.filter) || null, c12 || this.endTransitions();
  }
};
e([y()], c5.prototype, "_filter", void 0), e([y()], c5.prototype, "_excludedEffectView", void 0), e([y()], c5.prototype, "_includedEffectView", void 0), e([y()], c5.prototype, "duration", void 0), e([y()], c5.prototype, "excludedEffects", null), e([y()], c5.prototype, "featureEffect", null), e([y()], c5.prototype, "filter", null), e([y()], c5.prototype, "hasEffects", null), e([y()], c5.prototype, "includedEffects", null), e([y({ value: 0 })], c5.prototype, "scale", null), e([y()], c5.prototype, "transitioning", null), c5 = e([a2("esri.layers.effects.FeatureEffectView")], c5);
var r3 = c5;

// node_modules/@arcgis/core/rest/support/AggregateFeatureSet.js
var c6 = class extends d4 {
  constructor() {
    super(...arguments), this.features = [];
  }
  readFeatures(e8, t11) {
    var _a;
    const o14 = f2.fromJSON(t11.spatialReference), s8 = [];
    for (let a8 = 0; a8 < e8.length; a8++) {
      const t12 = e8[a8], p6 = s4.fromJSON(t12), c12 = (_a = t12.geometry) == null ? void 0 : _a.spatialReference;
      null == p6.geometry || c12 || (p6.geometry.spatialReference = o14);
      const m7 = t12.aggregateGeometries, i9 = p6.aggregateGeometries;
      if (m7 && null != i9)
        for (const e9 in i9) {
          const r8 = i9[e9], t13 = m7[e9], s9 = t13 == null ? void 0 : t13.spatialReference;
          null == r8 || s9 || (r8.spatialReference = o14);
        }
      s8.push(p6);
    }
    return s8;
  }
};
e([y({ type: [s4], json: { write: true } })], c6.prototype, "features", void 0), e([o2("features")], c6.prototype, "readFeatures", null), c6 = e([a2("esri.rest.support.AggregateFeatureSet")], c6);
var m4 = c6;

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/InstanceStore.js
var s5 = class {
  constructor() {
    this._instanceById = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._instanceById.clear();
  }
  get size() {
    return this._instanceById.size;
  }
  updateStart() {
    this._instanceByIdNext = /* @__PURE__ */ new Map();
  }
  updateEnd() {
    if (!this._instanceByIdNext)
      throw new Error("InternalError: Found updateEnd call without corresponding updateStart");
    for (const t11 of this._instanceById.keys())
      this._instanceByIdNext.has(t11) || this._instanceById.delete(t11);
    for (const [t11, e8] of this._instanceByIdNext.entries()) {
      const n10 = this._instanceById.get(t11);
      n10 ? n10.setInput(e8.getInput()) : this._instanceById.set(t11, e8);
    }
    this._instanceByIdNext = null;
  }
  values() {
    return this._instanceById.values();
  }
  ensureInstance(s8, i9, r8) {
    let a8 = `${s8.registryName}`;
    for (const t11 in i9) {
      const e8 = i9[t11];
      if ("object" == typeof e8 && "geometry" === t11)
        for (const n10 in e8)
          a8 += `.${t11}.${n10}.${null != e8[n10]}`;
      else
        a8 += `.${t11}.${null != i9[t11]}`;
    }
    if (null != r8)
      for (const t11 in r8)
        r8[t11] && (a8 += `-${t11}`);
    const c12 = c(a8);
    if (this._instanceByIdNext) {
      const t11 = new i4(r(c12), s8, s8.meshWriter.name, i9, r8);
      return this._instanceByIdNext.set(c12, t11), t11;
    }
    if (!this._instanceById.has(c12)) {
      const t11 = new i4(r(c12), s8, s8.meshWriter.name, i9, r8);
      this._instanceById.set(c12, t11);
    }
    return this._instanceById.get(c12);
  }
  getInstance(t11) {
    return this._instanceById.get(t11);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/RenderState.js
var n5 = class {
  constructor(e8, t11, i9) {
    this.getStage = e8, this.version = t11, this._tileInfoView = i9, this._tiles = /* @__PURE__ */ new Map(), this._pendingUpdates = [], this._locked = false;
  }
  destroy() {
  }
  tiles() {
    return this._tiles.values();
  }
  size() {
    return this._tiles.size;
  }
  setTiles(e8) {
    this._tiles.clear();
    for (const t11 of e8)
      this._tiles.set(t11.key.id, t11);
  }
  lockUploads() {
    this._locked = true;
  }
  unlockUploads() {
    this._locked = false;
    for (const e8 of this._pendingUpdates)
      this.updateTile(e8);
    this._pendingUpdates = [];
  }
  updateTile(e8) {
    var _a;
    if (this._locked)
      return void this._pendingUpdates.push(e8);
    if (has("esri-2d-update-debug")) {
      const t12 = ((_a = e8.debugInfo) == null ? void 0 : _a.chunkId) ?? "<EnsureEnd>";
      console.debug(`Version[${e8.version}] Tile[${e8.id}] Chunk[${t12}] RenderState.updateTile [${e8.type}]`, e8);
    }
    const t11 = this._ensureTile(e8.id);
    if ("update" === e8.type) {
      const [i10, ...s9] = e8.modify;
      t11.onMessage({ type: "update", modify: i10, remove: e8.remove, end: e8.end, attributeEpoch: e8.attributeEpoch });
      for (const t12 of s9) {
        const i11 = this._tiles.get(t12.tileId);
        i11 && i11.onMessage({ type: "update", modify: t12, remove: e8.remove, end: false, isPixelBuffer: true, attributeEpoch: null });
      }
      return;
    }
    if (null == e8.append)
      return void t11.onMessage({ type: "append", clear: e8.clear, debugInfo: e8.debugInfo, end: e8.end, attributeEpoch: e8.attributeEpoch });
    const [i9, ...s8] = e8.append;
    t11.onMessage({ type: "append", clear: e8.clear, append: i9, debugInfo: e8.debugInfo, end: e8.end, attributeEpoch: e8.attributeEpoch });
    for (const o14 of s8) {
      const e9 = this._tiles.get(o14.tileId);
      e9 && e9.onMessage({ type: "update", modify: o14, remove: [], sort: false, end: false, isPixelBuffer: true, attributeEpoch: null });
    }
  }
  removeTile(e8) {
    const t11 = this._tiles.get(e8);
    has("esri-2d-update-debug") && console.debug(`Tile[${e8}] RenderState.removeTile`), t11 == null ? void 0 : t11.destroy(), this._tiles.delete(e8);
  }
  isTileDone(e8) {
    const t11 = this._tiles.get(e8.id);
    return !!t11 && t11.isReady;
  }
  _ensureTile(e8) {
    if (!this._tiles.has(e8)) {
      const t11 = this._createTile(e8);
      this._copyPixelBufferedEntitiesInto(t11), this._tiles.set(e8, t11);
    }
    return this._tiles.get(e8);
  }
  _createTile(r8) {
    has("esri-2d-update-debug") && console.debug(`Version[${this.version}] Tile[${r8}] RenderState.createTile`);
    const n10 = new e4(r8), l7 = this._tileInfoView.getTileBounds(u2(), n10), d11 = this._tileInfoView.getTileResolution(n10.level), a8 = new b3(n10, d11, l7[0], l7[3], true);
    if (a8.stage = this.getStage(), !a8.stage) {
      const i9 = new s("featurelayerview:webgl", "Cannot create tile with empty stage");
      n.getLogger("esri.views.2d.layers.features.RenderState").error(i9);
    }
    return a8;
  }
  _copyPixelBufferedEntitiesInto(e8) {
    let t11 = 7;
    for (let i9 = -1; i9 <= 1; i9++)
      for (let s8 = -1; s8 <= 1; s8++) {
        if (0 === i9 && 0 === s8)
          continue;
        const o14 = this._tileInfoView.tileInfo.isWrappable, n10 = o3(e8.key, s8, i9, o14).id, l7 = this._tiles.get(n10);
        if (null != l7) {
          const o15 = 1 << t11;
          e8.copyPixelBufferedEntitesFrom(l7, o15, s8, i9);
        }
        t11--;
      }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureContainer.js
var l2 = class {
  constructor(e8, s8) {
    this.id = e8, this.version = s8, this._resolver = L(), this._done = false;
  }
  get done() {
    return this._done;
  }
  get promise() {
    return this._resolver.promise;
  }
  end() {
    this._resolver.resolve(), this._done = true;
  }
  destroy() {
    this._resolver.reject();
  }
};
var u5 = class extends r2 {
  constructor(e8) {
    super(e8.view.featuresTilingScheme), this.updatingHandles = new h(), this._hitTestsRequests = [], this._store = new s5(), this._visibleTiles = /* @__PURE__ */ new Set(), this._subscriptions = /* @__PURE__ */ new Map(), this._updateStatisticsRequests = [], this._lockStatisticUpdates = false, this._layerView = e8;
  }
  renderChildren(e8) {
    var _a;
    if (this.attributeView.update(), this._renderState) {
      const e9 = Array.from(this._renderState.tiles()).filter((e10) => e10.needsUpload);
      if (e9.length) {
        e9[Math.floor(Math.random() * e9.length)].upload(), e9.length >= 2 && this.requestRender();
      }
      for (const t11 of this._renderState.tiles())
        t11.tryReady(this.attributeView.currentEpoch) && ((_a = this._subscriptions.get(t11.key.id)) == null ? void 0 : _a.end(), this._layerView.requestUpdate(), this.hasLabels && this._layerView.view.labelManager.requestUpdate(), this.requestRender());
    }
    for (const t11 of this.children)
      t11.setTransform(e8.state);
    if (this.hasAnimation) {
      e8.painter.effects.integrate.draw(e8, e8.attributeView);
    }
    switch (super.renderChildren(e8), e8.drawPhase) {
      case E.MAP:
        return this._renderMapPhase(e8);
      case E.HIGHLIGHT:
        return this._renderHighlightPhase(e8);
      case E.LABEL:
        return this._renderLabelPhase(e8);
    }
  }
  subscriptions() {
    return this._subscriptions.values();
  }
  get _instanceStore() {
    return this._store;
  }
  get instanceStore() {
    return this._store;
  }
  get layerView() {
    return this._layerView;
  }
  get hasLabels() {
    return this._layerView.labelingCollisionInfos.length > 0;
  }
  get hasHighlight() {
    return this._layerView.hasHighlight();
  }
  get _layer() {
    return this._layerView.layer;
  }
  _getExclusivePostprocessingInstance({ drawPhase: e8 }) {
    if (null == this._instanceStore)
      return null;
    let t11 = 0, s8 = null;
    for (const i9 of this._instanceStore.values())
      i9.techniqueRef.drawPhase & e8 && (t11++, i9.techniqueRef.postProcessingEnabled && (s8 = i9));
    return t11 > 1 ? null : s8;
  }
  _getOverrideStencilRef({ drawPhase: e8 }) {
    if (null == this._instanceStore)
      return null;
    let t11 = null;
    for (const s8 of this._instanceStore.values()) {
      if (!(s8.techniqueRef.drawPhase & e8))
        continue;
      const { overrideStencilRef: i9 } = s8.techniqueRef;
      if (null == t11)
        t11 = i9;
      else if (t11 !== i9) {
        t11 = null;
        break;
      }
    }
    return t11;
  }
  get children() {
    return this._renderState ? Array.from(this._renderState.tiles()).filter((e8) => this._visibleTiles.has(e8.key.id)) : [];
  }
  updateAttributeView(e8) {
    this.requestRender(), this.attributeView.requestUpdate(e8), this.hasLabels && this._layerView.view.labelManager.requestUpdate();
  }
  updateSubscriptions(e8) {
    for (const { tileId: t11, version: s8 } of e8.subscribe)
      if (this._subscriptions.has(t11))
        this._subscriptions.get(t11).version = s8;
      else {
        const e9 = new l2(t11, s8);
        this._subscriptions.set(t11, e9), this.updatingHandles.addPromise(e9.promise);
      }
    for (const t11 of e8.unsubscribe) {
      const e9 = this._subscriptions.get(t11);
      e9 == null ? void 0 : e9.destroy(), this._subscriptions.delete(t11), this.removeTile(t11);
    }
  }
  isDone(e8) {
    return !!this._renderState && this._renderState.isTileDone(e8);
  }
  async updateRenderState(e8) {
    has("esri-2d-update-debug") && console.debug(`Version[${e8}] FeatureContainer.updateRenderState`), this._renderStateNext = new n5(() => this._stage, e8, this._tileInfoView);
  }
  getDisplayStatistics(e8, t11) {
    const s8 = this._statisticsByLevel.get(e8);
    return s8 ? s8.get(t11) : null;
  }
  updateStatistics(e8, t11) {
    if (this._lockStatisticUpdates)
      return void this._updateStatisticsRequests.push({ level: e8, statistics: t11 });
    let s8 = this._statisticsByLevel.get(e8);
    s8 || (s8 = /* @__PURE__ */ new Map(), this._statisticsByLevel.set(e8, s8));
    for (const i9 of t11)
      s8.set(i9.fieldName, { minValue: i9.minValue, maxValue: i9.maxValue });
  }
  editStart() {
    var _a;
    (_a = this._renderState) == null ? void 0 : _a.lockUploads(), this.attributeView.lockTextureUploads(), this._lockStatisticUpdates = true;
  }
  editEnd() {
    var _a;
    (_a = this._renderState) == null ? void 0 : _a.unlockUploads(), this.attributeView.unlockTextureUploads(), this._lockStatisticUpdates = false;
    for (const e8 of this._updateStatisticsRequests)
      this.updateStatistics(e8.level, e8.statistics);
    this._updateStatisticsRequests = [], this.requestRender();
  }
  swapRenderState() {
    var _a;
    if (this._renderStateNext && (has("esri-2d-update-debug") && console.debug(`Version[${this._renderStateNext.version}] FeatureContainer.update.swapRenderState`), (_a = this._renderState) == null ? void 0 : _a.destroy(), this._renderState = this._renderStateNext, this._renderStateNext = null), this._renderState)
      for (const e8 of this._renderState.tiles())
        e8.upload();
    this.requestRender();
  }
  setVisibleTiles(e8) {
    this._visibleTiles = e8;
  }
  async onMessage(t11, s8) {
    if (s2(s8), !this._subscriptions.has(t11.id))
      return;
    const i9 = this._subscriptions.get(t11.id);
    if (i9.version !== t11.subscriptionVesrion) {
      if (has("esri-2d-update-debug")) {
        const e8 = `${t11.subscriptionVesrion} != ${i9.version}`;
        console.debug(`Version[${e8}] Tile[${t11.id}] FeatureContainer - Dropping message, outdated version]`, t11);
      }
      return;
    }
    const r8 = this._renderStateNext ?? this._renderState;
    if (!r8)
      throw new Error("InternalError: No renderState defined");
    r8.version !== t11.version && console.error(`InternalError: Version mismatch. [renderState: ${r8.version}, message: ${t11.version}]`), r8.updateTile(t11), this.requestRender(), this._layerView.view.labelManager.requestUpdate(), this._layerView.requestUpdate();
  }
  removeTile(e8) {
    (this._renderState || this._renderStateNext) && (this._renderState && this._renderState.removeTile(e8), this._renderStateNext && this._renderStateNext.removeTile(e8));
  }
  hitTest(e8) {
    let s8 = this._hitTestsRequests.find(({ x: t11, y: s9 }) => t11 === e8.x && s9 === e8.y);
    const i9 = L();
    return s8 ? s8.resolvers.push(i9) : (s8 = { x: e8.x, y: e8.y, resolvers: [i9] }, this._hitTestsRequests.push(s8)), this.requestRender(), i9.promise;
  }
  getSortKeys(e8) {
    const t11 = new Set(e8), s8 = /* @__PURE__ */ new Map();
    for (const i9 of this.children)
      if (i9.getSortKeys(t11).forEach((e9, t12) => s8.set(t12, e9)), s8.size === t11.size)
        break;
    return s8;
  }
  get hasAnimation() {
    return this.hasLabels;
  }
  updateTransitionProperties(e8, t11) {
    super.updateTransitionProperties(e8, t11), this._layerView.featureEffectView.transitionStep(e8, t11), this._layerView.featureEffectView.transitioning && this.requestRender();
  }
  doRender(e8) {
    const { minScale: t11, maxScale: s8 } = this._layer.effectiveScaleRange, i9 = e8.state.scale;
    i9 <= (t11 || 1 / 0) && i9 >= s8 && super.doRender(e8);
  }
  afterRender(e8) {
    super.afterRender(e8), this._hitTestsRequests.length && this.requestRender();
  }
  setStencilReference(e8) {
    const t11 = this._getOverrideStencilRef(e8);
    if (null == t11)
      super.setStencilReference(e8);
    else
      for (const s8 of this.children)
        s8.stencilRef = t11(s8);
  }
  _renderMapPhase(e8) {
    this._layerView.featureEffectView.hasEffects ? (this._renderOutsideEffect(e8), this._renderInsideEffect(e8)) : this._renderFeatures(e8, R.All), this._hitTestsRequests.length > 0 && this._renderHittest(e8);
  }
  _renderHighlightPhase(e8) {
    this.hasHighlight && a3(e8, false, (e9) => {
      this._renderFeatures(e9, R.Highlight);
    });
  }
  _renderLabelPhase(e8) {
    this._renderFeatures(e8, R.All);
  }
  _renderInsideEffect(e8) {
    const t11 = e8.painter.effects.insideEffect;
    t11.bind(e8), this._renderFeatures(e8, R.InsideEffect), t11.draw(e8, this._layerView.featureEffectView.includedEffects), t11.unbind();
  }
  _renderOutsideEffect(e8) {
    const t11 = e8.painter.effects.outsideEffect;
    t11.bind(e8), this._renderFeatures(e8, R.OutsideEffect), t11.draw(e8, this._layerView.featureEffectView.excludedEffects), t11.unbind();
  }
  _renderHittest(e8) {
    const { context: t11 } = e8, s8 = e8.painter.effects.hittest, i9 = t11.getBoundFramebufferObject(), r8 = t11.getViewport(), a8 = e8.passOptions;
    s8.bind(e8), e8.passOptions = s8.createOptions(e8, this._hitTestsRequests), this._renderFeatures(e8, R.All), s8.draw(e8), s8.unbind(), t11.bindFramebuffer(i9), t11.restoreViewport(r8), e8.passOptions = a8;
  }
  _renderFeatures(e8, t11) {
    for (const i9 of this.children) {
      if (!i9.visible)
        continue;
      const s9 = has("featurelayer-force-marker-text-draw-order") ? N.STRICT_MARKERS_AND_TEXT : N.BATCHING, r8 = i9.getDisplayList(e8.drawPhase, this._instanceStore, s9);
      e8.selection = t11, r8 == null ? void 0 : r8.render(e8);
    }
    const s8 = this._getExclusivePostprocessingInstance(e8);
    null != s8 && s8.techniqueRef.postProcess(e8, s8);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorkerProxy.js
async function t6(t11) {
  const o14 = await p("FeaturePipelineWorker", { client: t11, strategy: "dedicated" });
  return new n6(o14);
}
var n6 = class {
  constructor(e8) {
    this._connection = e8, this.pipeline = this._connection.createInvokeProxy(), this.features = this._connection.createInvokeProxy("features"), this.aggregates = this._connection.createInvokeProxy("aggregates"), this.streamMessenger = this._connection.createInvokeProxy("streamMessenger");
  }
  destroy() {
    this._connection.destroy();
  }
  get closed() {
    return this._connection.closed;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureSourceEventLog.js
var o6 = class extends S {
  constructor() {
    super(...arguments), this.events = new o(), this._updatingStrategy = true, this._tileToEvent = new s3(), this._fetchStatus = { outstanding: 0, done: 0 };
  }
  get hasAllFeatures() {
    var _a;
    return this._hasAllData() && (((_a = this._strategyInfo) == null ? void 0 : _a.willQueryAllFeatures) ?? false);
  }
  get hasAllFeaturesInView() {
    return this._hasAllData();
  }
  get hasFullGeometries() {
    var _a;
    return this._hasAllData() && (((_a = this._strategyInfo) == null ? void 0 : _a.willQueryFullResolutionGeometry) ?? false);
  }
  onEvent(t11) {
    switch (t11.type) {
      case "subscribe":
      case "unsubscribe":
      case "loaded":
      case "error":
        this._handleTileEvent(t11);
        break;
      case "updateStrategyStart":
        this._updatingStrategy = true, this._fetchStatus = { done: 0, outstanding: 0 }, this._strategyInfo = t11.about;
        break;
      case "updateStrategyEnd":
        this._updatingStrategy = false;
        break;
      case "updateFieldsStart":
        this._fetchStatus = { done: 0, outstanding: 0 };
        break;
      case "updateFieldsEnd":
        break;
      case "updateFieldsError":
        this.events.emit("error", t11);
        break;
      case "fetchStart":
        this._fetchStatus.outstanding += 1, this.events.emit("status", this._fetchStatus);
        break;
      case "fetchEnd":
        this._fetchStatus.done += 1, this.events.emit("status", this._fetchStatus), t11.done && (this._fetchStatus = { done: 0, outstanding: 0 });
    }
  }
  _hasAllData() {
    return !this._updatingStrategy && this._hasAllTileData();
  }
  _hasAllTileData() {
    for (const t11 of this._tileToEvent.values()) {
      if ("loaded" !== t11[t11.length - 1].type)
        return false;
    }
    return true;
  }
  _handleTileEvent(t11) {
    switch (t11.type) {
      case "subscribe":
        this._tileToEvent.set(t11.tile, [t11]);
        break;
      case "unsubscribe":
        this._tileToEvent.delete(t11.tile);
        break;
      case "loaded": {
        const e8 = this._tileToEvent.get(t11.tile);
        if (!e8)
          return;
        e8.push(t11), this._tileToEvent.set(t11.tile, e8);
        break;
      }
      case "error": {
        const e8 = this._tileToEvent.get(t11.tile);
        if (!e8)
          return;
        e8.push(t11), this._tileToEvent.set(t11.tile, e8), this.events.emit("error", t11);
        break;
      }
    }
  }
};
e([y({ readOnly: true })], o6.prototype, "hasAllFeatures", null), e([y({ readOnly: true })], o6.prototype, "hasAllFeaturesInView", null), e([y({ readOnly: true })], o6.prototype, "hasFullGeometries", null), e([y()], o6.prototype, "_updatingStrategy", void 0), e([y()], o6.prototype, "_strategyInfo", void 0), e([y()], o6.prototype, "_tileToEvent", void 0), o6 = e([a2("esri.views.2d.layers.features.FeatureSourceEventLog")], o6);

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/geometryUtils.js
function e6(e8) {
  switch (e8.geometryType) {
    case "point":
      return "esriGeometryPoint";
    case "polyline":
      return "esriGeometryPolyline";
    case "polygon":
    case "multipatch":
      return "esriGeometryPolygon";
    case "multipoint":
      return "esriGeometryMultipoint";
    default:
      return null;
  }
}

// node_modules/@arcgis/core/views/2d/layers/support/visualVariableSimpleUtils.js
var r4 = Math.PI;
function i6(e8, t11) {
  switch (t11.transformationType) {
    case i.Additive:
      return s6(e8, t11);
    case i.Constant:
      return o7(t11, e8);
    case i.ClampedLinear:
      return u6(e8, t11);
    case i.Proportional:
      return l3(e8, t11);
    case i.Stops:
      return c7(e8, t11);
    case i.RealWorldSize:
      return m5(e8, t11);
    case i.Identity:
      return e8;
    case i.Unknown:
      return null;
  }
}
function a6(e8, t11) {
  return "number" == typeof e8 ? e8 : i6(t11, e8);
}
function s6(e8, t11) {
  return e8 + (a6(t11.minSize, e8) || t11.minDataValue);
}
function o7(e8, t11) {
  const n10 = e8.stops;
  let r8 = (n10 == null ? void 0 : n10.length) && n10[0].size;
  return null == r8 && (r8 = e8.minSize), a6(r8, t11);
}
function u6(e8, t11) {
  const n10 = t11.minDataValue, r8 = t11.maxDataValue, i9 = (e8 - n10) / (r8 - n10), s8 = a6(t11.minSize, e8), o14 = a6(t11.maxSize, e8);
  return e8 <= n10 ? s8 : e8 >= r8 ? o14 : s8 + i9 * (o14 - s8);
}
function l3(t11, n10) {
  const r8 = t11 / n10.minDataValue, i9 = a6(n10.minSize, t11), s8 = a6(n10.maxSize, t11);
  let o14 = null;
  return o14 = r8 * i9, e3(o14, i9, s8);
}
function c7(e8, t11) {
  const [n10, r8, i9] = p3(e8, t11.cache.ipData);
  if (n10 === r8)
    return a6(t11.stops[n10].size, e8);
  {
    const s8 = a6(t11.stops[n10].size, e8);
    return s8 + (a6(t11.stops[r8].size, e8) - s8) * i9;
  }
}
function m5(n10, i9) {
  const s8 = m[i9.valueUnit], o14 = a6(i9.minSize, n10), u13 = a6(i9.maxSize, n10), { valueRepresentation: l7 } = i9;
  let c12 = null;
  return c12 = "area" === l7 ? 2 * Math.sqrt(n10 / r4) / s8 : "radius" === l7 || "distance" === l7 ? 2 * n10 / s8 : n10 / s8, e3(c12, o14, u13);
}
function p3(e8, t11) {
  if (!t11)
    return;
  let n10 = 0, r8 = t11.length - 1;
  return t11.some((t12, i9) => e8 < t12 ? (r8 = i9, true) : (n10 = i9, false)), [n10, r8, (e8 - t11[n10]) / (t11[r8] - t11[n10])];
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/labelingUtils.js
function l4(n10) {
  var _a;
  return (n10.labelsVisible && ((_a = n10.labelingInfo) == null ? void 0 : _a.every((n11) => "none" !== n11.deconflictionStrategy))) ?? false;
}
function r5(n10, i9) {
  var _a;
  const l7 = e5(n10, i9);
  if ((l7 == null ? void 0 : l7.labelsVisible) && ((_a = l7.labelingInfo) == null ? void 0 : _a.length))
    return l7.labelingInfo.every((n11) => "none" !== n11.deconflictionStrategy);
}
function t7(e8) {
  return (l7) => u3(i6(l7, e8));
}
function o8(n10) {
  const e8 = null != n10 && "visualVariables" in n10 && n10.visualVariables;
  if (!e8)
    return null;
  for (const i9 of e8)
    if ("size" === i9.type)
      return t7(i9);
  return null;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/SourceSchema.js
function t8(t11, i9, o14, n10, r8) {
  var _a, _b;
  const s8 = null != i9.subtypeCode ? `${i9.subtypeField} = ${i9.subtypeCode}` : null, a8 = n2(i9.definitionExpression, s8), l7 = i9.customParameters ?? {};
  return r8 && (l7.token = r8), { type: "feature", mutable: { sourceRefreshVersion: n10, availableFields: o14.availableFields, dataFilter: { queryScaleRanges: i9.queryScaleRanges ?? [], definitionExpression: a8, gdbVersion: i9.gdbVersion, historicMoment: (_a = i9.historicMoment) == null ? void 0 : _a.getTime(), outSpatialReference: o14.outSpatialReference.toJSON(), timeExtent: (_b = i9.timeExtent) == null ? void 0 : _b.toJSON(), customParameters: l7 } }, service: t11, tileInfoJSON: o14.tileInfoJSON };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/color.js
function u7(n10, r8, t11 = 0) {
  if (null == r8)
    return n10[t11] = 0, n10[t11 + 1] = 0, n10[t11 + 2] = 0, void (n10[t11 + 3] = 0);
  const { r: o14, g: u13, b: i9, a: c12 } = r8;
  n10[t11] = o14 * c12 / 255, n10[t11 + 1] = u13 * c12 / 255, n10[t11 + 2] = i9 * c12 / 255, n10[t11 + 3] = c12;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/symbols/SymbolSchema.js
async function z(e8, a8) {
  if (!e8)
    return [];
  switch (e8.type) {
    case "simple-fill":
      return E2(e8, a8);
    case "picture-fill":
      return P3(e8, a8);
    case "simple-marker":
      return C(e8, a8);
    case "picture-marker":
      return I(e8, a8);
    case "simple-line":
      return U(e8, a8, false);
    case "text":
      return A(e8, a8);
    case "label":
      return w3(e8, a8);
    case "cim":
      return n4(e8.data, a8);
    case "web-style": {
      const l7 = await e8.fetchCIMSymbol();
      return n4(l7.data, a8);
    }
    default:
      throw new Error(`symbol not supported ${e8.type}`);
  }
}
async function d5(e8, a8) {
  const { schemaOptions: l7 } = a8, { store: i9 } = l7, r8 = new Array(P2), t11 = new Array(P2 / 4);
  for (let p6 = 0; p6 < P2; p6++) {
    const a9 = p6 < e8.attributes.length ? e8.attributes[p6].color : null;
    r8[p6] = [0, 0, 0, 0], u7(r8[p6], a9);
  }
  for (let u13 = 0; u13 < P2 / 4; u13++)
    t11[u13] = [0, 0, 0, 0], t11[u13][0] = 4 * u13 < e8.attributes.length ? 1 : 0, t11[u13][1] = 4 * u13 + 1 < e8.attributes.length ? 1 : 0, t11[u13][2] = 4 * u13 + 2 < e8.attributes.length ? 1 : 0, t11[u13][3] = 4 * u13 + 3 < e8.attributes.length ? 1 : 0;
  const o14 = { isActive: t11, colors: r8, dotValue: e8.dotValue, dotScale: e8.referenceScale, blending: e8.dotBlendingEnabled, dotSize: e8.dotSize, seed: e8.seed }, s8 = i9.ensureInstance(h3.dotDensity, o14, {}).createMeshInfo({ params: { effects: null } }), n10 = [];
  if (e8.backgroundColor) {
    const l8 = new S2({ color: e8.backgroundColor, outline: null }), i10 = await z(l8, a8);
    n10.push(...i10);
  }
  if (n10.push(s8), e8.outline) {
    const l8 = U(e8.outline, a8, true);
    n10.push(...l8);
  }
  return n10;
}
async function g(l7, i9) {
  const { store: r8 } = i9, { radius: t11, minDensity: o14, maxDensity: s8, referenceScale: n10, field: u13, valueExpression: c12, colorStops: f7 } = l7, m7 = f4(f7);
  return [r8.ensureInstance(h3.heatmap, { radius: u3(t11), minDensity: o14, maxDensity: s8, referenceScale: n10, isFieldActive: !(!u13 && !c12), gradient: m7, gradientHash: m7.join(",") }, {}).createMeshInfo({ params: { effects: null } })];
}
function x3(a8, l7) {
  var _a, _b, _c, _d;
  const { store: i9 } = l7, r8 = ((_a = a8.outline) == null ? void 0 : _a.width) || 0, t11 = y2(a8), o14 = i9.ensureInstance(h3.pieChart, { geometry: { outlineWidth: Math.round(u3(r8)), defaultColor: t3(a8.defaultColor), outlineColor: t3((_b = a8.outline) == null ? void 0 : _b.color), othersColor: t3((_c = a8.othersCategory) == null ? void 0 : _c.color), donutRatio: a8.holePercentage, sectorThreshold: ((_d = a8.othersCategory) == null ? void 0 : _d.threshold) || 0, colors: a8.attributes.map((e8) => t3(e8.color)), visualVariableOpacity: t11.visualVariableOpacity, visualVariableSizeMinMaxValue: t11.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: t11.visualVariableSizeScaleStops, visualVariableSizeStops: t11.visualVariableSizeStops, visualVariableSizeUnitValue: t11.visualVariableSizeUnitValue, hittestUniforms: null }, numberOfFields: a8.attributes.length }, {}).createMeshInfo({ params: { size: a8.size, outlineWidth: r8, effects: null, scaleInfo: null, minPixelBuffer: h4(t11) } });
  return [...a8.backgroundFillSymbol ? E2(a8.backgroundFillSymbol, { schemaOptions: l7, path: "", uniforms: x }) : [], o14];
}
function M(e8) {
  if ("path" === e8.style) {
    if (null == e8.path)
      throw new Error("Symbol with a style of type path must define a path");
    return { type: "sprite-rasterization-param", overrides: [], resource: { type: "path", path: e8.path, asFill: true } };
  }
  const a8 = K.fromSimpleMarker(e8);
  if ("outline" in e8 && e8.outline && "none" !== e8.outline.style) {
    if ("solid" !== e8.outline.style) {
      if (!a8 || !a8.symbolLayers)
        throw new Error("Error handling marker! ");
      return { type: "sprite-rasterization-param", resource: a8.symbolLayers[0], overrides: [] };
    }
  }
  return { type: "sprite-rasterization-param", resource: l(a8), overrides: [] };
}
async function C(e8, a8) {
  var _a, _b, _c, _d, _e;
  const { uniforms: i9, schemaOptions: r8 } = a8, { store: o14 } = r8;
  if ("path" === e8.style || e8.outline && "solid" !== e8.outline.style && "none" !== e8.outline.style) {
    const r9 = K.fromSimpleMarker(e8);
    if (!r9 || !r9.symbolLayers)
      throw new Error("Error handling marker! ");
    if (i9.visualVariableRotation && (r9.angleAlignment = "Map"), "path" !== e8.style) {
      const e9 = r9.symbolLayers[0];
      if (a4(a8.uniforms)) {
        const l7 = h4(a8.uniforms, 0, 1);
        if (l7 > e9.size) {
          const a9 = l7 / e9.size;
          e9.size = l7;
          const i10 = (_a = e9.markerGraphics) == null ? void 0 : _a[0].symbol;
          (i10.symbolLayers && i10.symbolLayers[0]).width *= a9;
        }
      }
    }
    return n4({ type: "CIMSymbolReference", symbol: r9 }, a8);
  }
  const s8 = o14.ensureInstance(h3.marker, { geometry: { visualVariableColor: i9.visualVariableColor, visualVariableOpacity: i9.visualVariableOpacity, visualVariableSizeMinMaxValue: i9.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: i9.visualVariableSizeScaleStops, visualVariableSizeStops: i9.visualVariableSizeStops, visualVariableSizeUnitValue: i9.visualVariableSizeUnitValue, visualVariableRotation: i9.visualVariableRotation } }, { zoomRange: false }), n10 = M(e8);
  let u13 = ((_b = e8.color) == null ? void 0 : _b.toArray()) ?? [0, 0, 0, 0];
  "CIMVectorMarker" === n10.resource.type && (u13 = [255, 255, 255, 255]);
  const c12 = "triangle" === e8.style ? 124 / 116 : 1, f7 = e8.size, m7 = f7 * c12, S3 = null != i9.visualVariableColor && ("cross" === e8.style || "x" === e8.style);
  return [s8.createMeshInfo({ params: { type: "simple", color: u13, height: f7, width: m7, offsetX: e8.xoffset, offsetY: e8.yoffset, angle: e8.angle, alignment: i3(i9) ? i2.MAP : i2.SCREEN, outlineColor: ((_d = (_c = e8.outline) == null ? void 0 : _c.color) == null ? void 0 : _d.toArray()) ?? [0, 0, 0, 0], outlineSize: ((_e = e8.outline) == null ? void 0 : _e.width) ?? 1, referenceSize: f7, sprite: n10, overrideOutlineColor: S3, hasSizeVV: a4(i9), placement: null, effects: null, transforms: null, scaleInfo: null, minPixelBuffer: h4(i9) } })];
}
function I(e8, a8) {
  const { uniforms: i9, schemaOptions: r8 } = a8, { store: o14 } = r8, s8 = o14.ensureInstance(h3.marker, { geometry: { visualVariableColor: i9.visualVariableColor, visualVariableOpacity: i9.visualVariableOpacity, visualVariableSizeMinMaxValue: i9.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: i9.visualVariableSizeScaleStops, visualVariableSizeStops: i9.visualVariableSizeStops, visualVariableSizeUnitValue: i9.visualVariableSizeUnitValue, visualVariableRotation: i9.visualVariableRotation } }, { zoomRange: false }), n10 = K.createPictureMarkerRasterizationParam(e8);
  if (!n10)
    return [];
  return [s8.createMeshInfo({ params: { type: "picture", color: [255, 255, 255, 255], height: e8.height, width: e8.width, offsetX: e8.xoffset, offsetY: e8.yoffset, angle: e8.angle, alignment: i3(i9) ? i2.MAP : i2.SCREEN, outlineColor: null, outlineSize: 0, referenceSize: e8.height, sprite: n10, overrideOutlineColor: false, hasSizeVV: a4(i9), placement: null, effects: null, transforms: null, scaleInfo: null, minPixelBuffer: h4(i9) } })];
}
function O2(e8, a8, l7) {
  var _a, _b;
  const { uniforms: i9, schemaOptions: r8 } = l7, { store: s8 } = r8, n10 = s8.ensureInstance(h3.marker, { geometry: { visualVariableColor: i9.visualVariableColor, visualVariableOpacity: i9.visualVariableOpacity, visualVariableSizeMinMaxValue: i9.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: i9.visualVariableSizeScaleStops, visualVariableSizeStops: i9.visualVariableSizeStops, visualVariableSizeUnitValue: i9.visualVariableSizeUnitValue, visualVariableRotation: i9.visualVariableRotation } }, { zoomRange: false }), u13 = M(e8), c12 = 6, f7 = c12 * a8.width, m7 = f7, S3 = ((_a = e8.color) == null ? void 0 : _a.toArray()) ?? ((_b = a8.color) == null ? void 0 : _b.toArray()) ?? [0, 0, 0, 0], V2 = "cross" === e8.style || "x" === e8.style;
  let h6;
  switch (e8.placement) {
    case "begin-end":
      h6 = o4.Both;
      break;
    case "begin":
      h6 = o4.JustBegin;
      break;
    case "end":
      h6 = o4.JustEnd;
      break;
    default:
      h6 = o4.None;
  }
  const z3 = { type: "cim-marker-placement-info", placement: { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: h6, offsetAlongLine: 0 }, overrides: [] };
  return [n10.createMeshInfo({ params: { type: "simple", color: S3, height: m7, width: f7, offsetX: 0, offsetY: 0, angle: 0, alignment: i3(i9) ? i2.MAP : i2.SCREEN, outlineColor: S3, outlineSize: V2 ? a8.width : 0, referenceSize: m7 / c12, sprite: u13, overrideOutlineColor: V2 && null != i9.visualVariableColor, hasSizeVV: a4(i9), placement: z3, transforms: null, effects: null, scaleInfo: null, minPixelBuffer: h4(i9) } })];
}
function A(e8, a8) {
  var _a, _b, _c, _d;
  const { uniforms: i9, schemaOptions: r8 } = a8, { store: t11 } = r8;
  return [t11.ensureInstance(h3.text, { geometry: { visualVariableColor: i9.visualVariableColor, visualVariableOpacity: i9.visualVariableOpacity, visualVariableRotation: i9.visualVariableRotation, visualVariableSizeMinMaxValue: i9.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: i9.visualVariableSizeScaleStops, visualVariableSizeStops: i9.visualVariableSizeStops, visualVariableSizeUnitValue: i9.visualVariableSizeUnitValue } }, { zoomRange: false, clipAngle: false, referenceSymbol: false }).createMeshInfo({ params: { boxBackgroundColor: (_a = e8.backgroundColor) == null ? void 0 : _a.toArray(), boxBorderLineColor: (_b = e8.borderLineColor) == null ? void 0 : _b.toArray(), boxBorderLineSize: e8.borderLineSize ?? 0, color: ((_c = e8.color) == null ? void 0 : _c.toArray()) ?? [0, 0, 0, 0], offsetX: e8.xoffset, offsetY: e8.yoffset, postAngle: e8.angle, fontSize: e8.font.size, decoration: e8.font.decoration, haloColor: ((_d = e8.haloColor) == null ? void 0 : _d.toArray()) ?? [0, 0, 0, 0], haloFontSize: e8.haloSize ?? 0, lineWidth: e8.lineWidth, lineHeightRatio: e8.lineHeight, horizontalAlignment: e8.horizontalAlignment, verticalAlignment: e8.verticalAlignment, useCIMAngleBehavior: false, glyphs: { type: "text-rasterization-param", resource: { type: "text", font: e8.font.toJSON(), textString: e8.text, symbol: K.createCIMTextSymbolfromTextSymbol(e8) }, overrides: [] }, referenceSize: null, effects: null, placement: null, scaleInfo: null, transforms: null, scaleFactor: 1, minPixelBuffer: h4(i9), repeatLabel: null, repeatLabelDistance: null, allowOverrun: null, labelPosition: null, isLineLabel: false } })];
}
function w3(a8, i9) {
  var _a, _b, _c, _d, _e, _f;
  const { schemaOptions: r8, uniforms: t11 } = i9, { store: o14 } = r8, s8 = a8.symbol, { allowOverrun: u13, repeatLabel: c12, repeatLabelDistance: f7 } = a8, m7 = { maxScale: a8.maxScale ?? 0, minScale: a8.minScale ?? 0 }, S3 = o14.ensureInstance(h3.label, { geometry: { visualVariableColor: null, visualVariableOpacity: null, visualVariableRotation: t11.visualVariableRotation, visualVariableSizeMinMaxValue: t11.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: t11.visualVariableSizeScaleStops, visualVariableSizeStops: t11.visualVariableSizeStops, visualVariableSizeUnitValue: t11.visualVariableSizeUnitValue } }, { zoomRange: true, clipAngle: true, referenceSymbol: true }), V2 = a8.labelPlacement, [y4, v] = o5(V2);
  return [S3.createMeshInfo({ params: { boxBackgroundColor: (_a = s8.backgroundColor) == null ? void 0 : _a.toArray(), boxBorderLineColor: (_b = s8.borderLineColor) == null ? void 0 : _b.toArray(), boxBorderLineSize: s8.borderLineSize ?? 0, color: ((_c = s8.color) == null ? void 0 : _c.toArray()) ?? [0, 0, 0, 0], offsetX: s8.xoffset, offsetY: s8.yoffset, postAngle: s8.angle, fontSize: s8.font.size, decoration: s8.font.decoration, haloColor: ((_d = s8.haloColor) == null ? void 0 : _d.toArray()) ?? [0, 0, 0, 0], haloFontSize: s8.haloSize ?? 0, lineWidth: s8.lineWidth, lineHeightRatio: s8.lineHeight, horizontalAlignment: y4, verticalAlignment: v, repeatLabel: c12, repeatLabelDistance: u3(f7), allowOverrun: u13, labelPosition: a8.labelPosition, scaleInfo: m7, minPixelBuffer: h4(t11), useCIMAngleBehavior: false, glyphs: { type: "text-rasterization-param", resource: { type: "text", font: s8.font.toJSON(), textString: s8.text, symbol: K.createCIMTextSymbolfromTextSymbol(s8), primitiveName: "label-override" }, useLegacyLabelEvaluationRules: null == ((_e = a8.labelExpressionInfo) == null ? void 0 : _e.expression), overrides: [{ type: "CIMPrimitiveOverride", valueExpressionInfo: { type: "CIMExpressionInfo", expression: ((_f = a8.labelExpressionInfo) == null ? void 0 : _f.expression) ?? a8.labelExpression, returnType: "String" }, primitiveName: "label-override", propertyName: "textString", defaultValue: "" }] }, referenceSize: null, effects: null, placement: null, transforms: null, scaleFactor: 1, isLineLabel: false } })];
}
function R2(e8, a8) {
  var _a;
  const l7 = e8.width;
  return { outlineColor: ((_a = e8.color) == null ? void 0 : _a.toArray()) || [0, 0, 0, 1], width: l7, referenceWidth: l7, capType: e8.cap ?? "round", joinType: e8.join ?? "round", miterLimit: e8.miterLimit, hasSizeVV: a8 };
}
function L2(e8, a8) {
  var _a, _b, _c;
  const { uniforms: l7, schemaOptions: i9 } = a8, { store: r8 } = i9, t11 = ((_a = e8.color) == null ? void 0 : _a.toArray()) ?? [0, 0, 0, 0], o14 = { type: "sprite-rasterization-param", resource: { type: "fill-style", style: e8.style }, overrides: [] };
  if ("solid" === ((_b = e8.outline) == null ? void 0 : _b.style)) {
    return [r8.ensureInstance(h3.patternOutlineFill, { geometry: { visualVariableColor: l7.visualVariableColor, visualVariableOpacity: l7.visualVariableOpacity, visualVariableSizeScaleStops: l7.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null } }, { zoomRange: false }).createMeshInfo({ params: { color: t11, ...R2(e8.outline, !!l7.visualVariableSizeOutlineScaleStops), sprite: o14, scaleInfo: null, effects: null } })];
  }
  const s8 = [], n10 = r8.ensureInstance(h3.patternFill, { geometry: { visualVariableColor: l7.visualVariableColor, visualVariableOpacity: l7.visualVariableOpacity } }, { zoomRange: false }).createMeshInfo({ params: { color: ((_c = e8.color) == null ? void 0 : _c.toArray()) ?? [0, 0, 0, 0], sprite: o14, scaleInfo: null, effects: null } });
  return s8.push(n10), e8.outline && s8.push(...U(e8.outline, a8, true)), s8;
}
function k2(e8, a8) {
  var _a, _b;
  const { uniforms: l7, schemaOptions: i9 } = a8, { store: r8 } = i9, t11 = ((_a = e8.color) == null ? void 0 : _a.toArray()) ?? [0, 0, 0, 0];
  if ("none" !== e8.style && "solid" === ((_b = e8.outline) == null ? void 0 : _b.style)) {
    return [r8.ensureInstance(h3.outlineFill, { geometry: { visualVariableColor: l7.visualVariableColor, visualVariableOpacity: l7.visualVariableOpacity, visualVariableSizeScaleStops: l7.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null } }, { zoomRange: false }).createMeshInfo({ params: { color: t11, ...R2(e8.outline, !!l7.visualVariableSizeOutlineScaleStops), scaleInfo: null, effects: null } })];
  }
  const o14 = [];
  if ("none" !== e8.style) {
    const e9 = r8.ensureInstance(h3.fill, { geometry: { visualVariableColor: l7.visualVariableColor, visualVariableOpacity: l7.visualVariableOpacity } }, { zoomRange: false }).createMeshInfo({ params: { color: t11, scaleInfo: null, effects: null } });
    o14.push(e9);
  }
  return e8.outline && o14.push(...U(e8.outline, a8, true)), o14;
}
function E2(e8, a8) {
  const { style: l7 } = e8;
  return l7 && "none" !== l7 && "solid" !== l7 ? L2(e8, a8) : k2(e8, a8);
}
function P3(e8, a8) {
  const { outline: i9 } = e8, { uniforms: r8, schemaOptions: t11 } = a8, { store: o14 } = t11, s8 = [], n10 = K.createPictureFillRasterizationParam(e8);
  if (!n10)
    return [];
  const { width: u13, height: c12, xoffset: f7, yoffset: m7, xscale: b4, yscale: S3 } = e8, V2 = { color: [255, 255, 255, 255], sprite: n10, height: c12, aspectRatio: u13 / c12, offsetX: f7, offsetY: m7, scaleX: b4, scaleY: S3, angle: 0, applyRandomOffset: false, sampleAlphaOnly: false, scaleProportionally: false, effects: null, scaleInfo: null };
  if ("solid" === (i9 == null ? void 0 : i9.style)) {
    return [o14.ensureInstance(h3.complexOutlineFill, { geometry: { visualVariableColor: r8.visualVariableColor, visualVariableOpacity: r8.visualVariableOpacity, visualVariableSizeScaleStops: r8.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null } }, { zoomRange: false }).createMeshInfo({ params: { ...V2, ...R2(i9, !!r8.visualVariableSizeOutlineScaleStops) } })];
  }
  const y4 = o14.ensureInstance(h3.complexFill, { geometry: { visualVariableColor: r8.visualVariableColor, visualVariableOpacity: r8.visualVariableOpacity } }, { zoomRange: false });
  return s8.push(y4.createMeshInfo({ params: V2 })), i9 && s8.push(...U(i9, a8, true)), s8;
}
function U(e8, a8, l7) {
  const { color: t11, style: o14, width: s8, cap: n10, join: u13 } = e8, { schemaOptions: c12 } = a8, { store: f7 } = c12, m7 = [], b4 = l7 ? { ...x, visualVariableSizeScaleStops: a8.uniforms.visualVariableSizeOutlineScaleStops } : a8.uniforms, V2 = { geometry: { visualVariableColor: b4.visualVariableColor, visualVariableOpacity: b4.visualVariableOpacity, visualVariableSizeMinMaxValue: b4.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: b4.visualVariableSizeScaleStops, visualVariableSizeStops: b4.visualVariableSizeStops, visualVariableSizeUnitValue: b4.visualVariableSizeUnitValue } }, v = { color: (t11 == null ? void 0 : t11.toArray()) ?? [0, 0, 0, 0], width: s8, referenceWidth: s8, capType: n10, joinType: u13, miterLimit: e8.miterLimit, hasSizeVV: a4(b4), effects: null, scaleInfo: null };
  if (null == o14 || "solid" === o14) {
    const e9 = f7.ensureInstance(h3.line, V2, { zoomRange: false }).createMeshInfo({ params: v });
    m7.push(e9);
  } else if ("none" !== o14) {
    const e9 = f7.ensureInstance(h3.texturedLine, V2, { zoomRange: false }).createMeshInfo({ params: { ...v, shouldScaleDash: true, shouldSampleAlphaOnly: false, isSDF: true, sprite: { type: "sprite-rasterization-param", resource: { type: "dash", dashTemplate: ne(o14, n10), capStyle: Z(n10) }, overrides: [] } } });
    m7.push(e9);
  }
  return null != e8.marker && m7.push(...O2(e8.marker, e8, a8)), m7;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/LabelMatcherSchema.js
async function l5(a8, l7, r8) {
  const n10 = l7.labelsVisible && l7.labelingInfo || [], i9 = e6(l7), m7 = c3(n10, i9);
  return { type: "label", classes: await Promise.all(m7.map((e8, s8) => o9(a8, e8, s8, r8))) };
}
async function o9(e8, s8, l7, o14) {
  var _a;
  const r8 = await z(s8, { path: `${l7}`, schemaOptions: e8, uniforms: o14 });
  return { maxScale: s8.maxScale, minScale: s8.minScale, expression: ((_a = s8.labelExpressionInfo) == null ? void 0 : _a.expression) ?? s8.labelExpression, where: s8.where, meshes: r8 };
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/MatcherSchema.js
async function r6(e8, a8) {
  if (!a8)
    return { type: "simple", meshes: [] };
  switch (a8.type) {
    case "simple":
      return o10(e8, a8);
    case "dot-density":
      return u8(e8, a8);
    case "class-breaks":
      return m6(e8, a8);
    case "unique-value":
      return c8(e8, a8);
    case "dictionary":
      return p4(a8);
    case "heatmap":
      return f5(e8, a8);
    case "pie-chart":
      return y3(e8, a8);
  }
}
async function o10(a8, l7) {
  const n10 = l7.getSymbols(), s8 = n10.length ? n10[0] : null, r8 = y2(l7), t11 = "renderer.symbol";
  return { type: "simple", meshes: await z(s8, { schemaOptions: a8, uniforms: r8, path: t11 }) };
}
async function u8(a8, i9) {
  const n10 = y2(i9), s8 = "renderer.symbol";
  return { type: "dot-density", meshes: await d5(i9, { schemaOptions: a8, uniforms: n10, path: s8 }) };
}
async function m6(l7, n10) {
  const s8 = y2(n10), r8 = n10.backgroundFillSymbol, t11 = n10.normalizationType, o14 = "log" === t11 ? "esriNormalizeByLog" : "percent-of-total" === t11 ? "esriNormalizeByPercentOfTotal" : "field" === t11 ? "esriNormalizeByField" : null, u13 = n10.classBreakInfos.map(async (e8) => ({ meshes: await z(e8.symbol, { path: `renderer-stop-${e8.minValue}-${e8.maxValue}`, schemaOptions: l7, uniforms: s8 }), min: e8.minValue, max: e8.maxValue })), m7 = (await Promise.all(u13)).sort((e8, a8) => e8.min - a8.min), c12 = await z(r8, { schemaOptions: l7, path: "renderer.backgroundFill", uniforms: { ...x, visualVariableSizeOutlineScaleStops: s8.visualVariableSizeOutlineScaleStops } }), p6 = await z(n10.defaultSymbol, { schemaOptions: l7, path: "renderer.defaultSymbol", uniforms: s8 });
  return { type: "interval", field: n10.field, expression: n10.valueExpression, backgroundFill: c12, defaultSymbol: p6, intervals: m7, normalizationField: n10.normalizationField, normalizationTotal: n10.normalizationTotal, normalizationType: o14, isMaxInclusive: n10.isMaxInclusive };
}
async function c8(l7, n10) {
  const s8 = [], r8 = y2(n10), t11 = await z(n10.backgroundFillSymbol, { schemaOptions: l7, path: "renderer.backgroundFill", uniforms: { ...x, visualVariableSizeOutlineScaleStops: r8.visualVariableSizeOutlineScaleStops } }), o14 = await z(n10.defaultSymbol, { schemaOptions: l7, path: "renderer.defaultSymbol", uniforms: r8 });
  for (const e8 of n10.uniqueValueInfos ?? []) {
    const a8 = await z(e8.symbol, { path: `renderer-unique-value-${e8.value}`, schemaOptions: l7, uniforms: r8 });
    s8.push({ value: "" + e8.value, symbol: a8 });
  }
  return { type: "map", field: n10.field, expression: n10.valueExpression, field2: n10.field2, field3: n10.field3, fieldDelimiter: n10.fieldDelimiter, backgroundFill: t11, defaultSymbol: o14, map: s8 };
}
function p4(a8) {
  const i9 = y2(a8), l7 = a8.scaleExpression, n10 = null != l7 && "1" !== l7 ? { valueExpressionInfo: { type: "CIMExpressionInfo", expression: a8.scaleExpression, returnType: "Numeric" }, defaultValue: 1 } : void 0;
  return { type: "dictionary", fieldMap: a8.fieldMap, scaleExpression: n10, visualVariableUniforms: i9 };
}
async function f5(e8, a8) {
  return { type: "heatmap", meshes: await g(a8, e8) };
}
async function y3(e8, a8) {
  return { type: "pie-chart", meshes: x3(a8, e8) };
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/SimpleProcessorSchema.js
async function l6(e8, r8) {
  const i9 = r8.renderer, l7 = y2(i9);
  return { symbology: await r6(e8, i9), labels: await l5(e8, r8, l7) };
}
async function a7(e8, r8, t11, s8) {
  const n10 = t11.featureReduction;
  if (n10)
    switch (n10.type) {
      case "binning":
        return u9(n10, e8, r8, t11, s8);
      case "cluster":
        return f6(n10, e8, r8, t11, s8);
    }
  const a8 = d6(t11.orderBy, t11.renderer, t11.objectIdField);
  return { storage: t4(t11.renderer, r8.filters), mesh: { displayRefreshVersion: s8, strategy: { type: "feature" }, factory: await l6(e8, t11), sortKey: a8, timeZone: r8.timeZone } };
}
function o11(e8, r8) {
  return e8.fields.map((e9) => ({ ...e9.toJSON(), type: c9(e9, r8) }));
}
function c9(e8, r8) {
  const { onStatisticExpression: t11, onStatisticField: s8, statisticType: i9 } = e8;
  switch (i9) {
    case "min":
    case "max":
    case "avg":
    case "avg_angle":
    case "sum":
    case "count":
      return "esriFieldTypeDouble";
    case "mode": {
      if (t11) {
        const { returnType: e10 } = t11;
        return e10 ? "string" === e10 ? "esriFieldTypeString" : "esriFieldTypeDouble" : "esriFieldTypeString";
      }
      const e9 = r8.find((e10) => e10.name === s8);
      return e9 ? e9.type : "esriFieldTypeString";
    }
  }
}
async function u9(e8, r8, l7, a8, c12) {
  const u13 = o11(e8, a8.fields), f7 = e8.renderer, d11 = await r6(r8, f7), y4 = t4(f7, [null, null]), p6 = y2(f7), m7 = await l5(r8, { geometryType: "polygon", labelingInfo: e8.labelingInfo, labelsVisible: e8.labelsVisible }, p6);
  return { storage: y4, mesh: { displayRefreshVersion: c12, strategy: { type: "binning", fields: u13, fixedBinLevel: e8.fixedBinLevel, featureFilter: l7.filters[0] }, factory: { labels: m7, symbology: d11 }, sortKey: null, timeZone: l7.timeZone } };
}
async function f6(r8, l7, a8, c12, u13) {
  const f7 = o11(r8, c12.fields), d11 = { type: "cluster", feature: await r6(l7, r8.effectiveFeatureRenderer), cluster: await r6(l7, r8.effectiveClusterRenderer) }, y4 = y2(r8.effectiveFeatureRenderer), p6 = { type: "cluster", feature: await l5(l7, c12, y4), cluster: await l5(l7, { geometryType: "point", labelingInfo: r8.labelingInfo, labelsVisible: r8.labelsVisible }, y4) };
  return { storage: t4(r8.effectiveFeatureRenderer, [null, null]), mesh: { displayRefreshVersion: u13, strategy: { type: "cluster", fields: f7, featureFilter: a8.filters[0], clusterRadius: u3(r8.clusterRadius / 2) }, factory: { labels: p6, symbology: d11 }, sortKey: null, timeZone: a8.timeZone } };
}
function d6(e8, t11, s8) {
  const i9 = null != t11 && "unique-value" === t11.type && t11.orderByClassesEnabled;
  if ("default" !== e8 || i9 || (e8 = [new c2({ field: s8, order: "descending" })]), "default" !== e8 && e8.length) {
    e8.length;
    const r8 = e8[0], t12 = "ascending" === r8.order ? "asc" : "desc";
    return r8.field ? { field: r8.field, order: t12 } : r8.valueExpression ? { expression: r8.valueExpression, order: t12 } : null;
  }
  if (i9) {
    return { byRenderer: true, order: "asc" };
  }
  return null;
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/CatalogFootprintLayerAdapter.js
var d7 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const r8 = this.layer, t11 = l4(r8);
    return [{ vvEvaluators: { 0: o8(r8.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(s8) {
    var _a, _b;
    const o14 = this.layer, a8 = o14.parent, l7 = O(a8), { capabilities: n10, editingInfo: d11, objectIdField: p6, globalIdField: c12, datesInUnknownTimezone: m7, orderBy: y4, subtypeField: f7, parsedUrl: u13 } = a8, b4 = a8.fieldsIndex.toJSON(), g2 = e6(o14), h6 = (_a = a8.timeInfo) == null ? void 0 : _a.toJSON(), I2 = o14.spatialReference.toJSON(), S3 = a(u13);
    let j2 = p6;
    if (y4 == null ? void 0 : y4.length) {
      const e8 = !y4[0].valueExpression && y4[0].field;
      e8 && (j2 = e8);
    }
    return { type: "feature-service", source: S3, isSourceHosted: w2(S3.path), orderByFields: j2, metadata: { timeReferenceUnknownClient: m7, subtypeField: f7, globalIdField: c12, fieldsIndex: b4, geometryType: g2, objectIdField: p6, timeInfo: h6, spatialReference: I2, subtypes: null, typeIdField: null, types: null }, queryMetadata: { capabilities: n10, effectiveCapabilities: l7, lastEditDate: (_b = d11 == null ? void 0 : d11.lastEditDate) == null ? void 0 : _b.getTime(), snapshotInfo: null } };
  }
  createSourceSchema(e8, r8, t11) {
    const { definitionExpression: i9, customParameters: s8, timeExtent: o14, apiKey: l7 } = this.layer.parent;
    return t8(e8, { definitionExpression: i9, customParameters: s8, timeExtent: o14 }, r8, t11, l7);
  }
  createProcessorSchema(e8, r8, t11) {
    const { parent: { fields: i9, geometryType: s8, orderBy: o14, objectIdField: a8 }, renderer: n10, labelingInfo: d11, labelsVisible: p6 } = this.layer, c12 = { featureReduction: null, fields: i9.map((e9) => e9.toJSON()), geometryType: s8, labelingInfo: d11, labelsVisible: p6, objectIdField: a8, orderBy: o14 ?? "default", renderer: n10 == null ? void 0 : n10.clone() };
    return a7(e8, r8, c12, t11);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  getUpdateHashProperties(e8) {
    const r8 = this.layer, { parent: t11, parent: { definitionExpression: i9, apiKey: s8 }, renderer: o14 } = r8, a8 = this.layer.labelsVisible ? this.layer.labelingInfo : null;
    return { apiKey: s8, customParameters: JSON.stringify(t11.customParameters), definitionExpression: i9, labelingInfo: a8, orderBy: JSON.stringify(t11.orderBy), renderer: o14 };
  }
  setGraphicOrigin(e8) {
    e8.origin = { type: "catalog", layer: this.layer };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/featureServiceUtils.js
function t9(t11, e8) {
  const n10 = t11.extent, o14 = e8 == null ? void 0 : e8.clone().intersection(n10), i9 = null != o14 ? o14.width * o14.height : 0, r8 = e8 ? e8.width * e8.height : 0, h6 = 0 === r8 ? 0 : i9 / r8, s8 = has("featurelayer-snapshot-point-coverage");
  return !isNaN(h6) && h6 >= s8;
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/floorFilterUtils.js
function o12(e8, l7) {
  return null != e8.floorInfo && (e8.floorInfo.viewAllLevelIds.length > 0 || l7.floors.length > 0);
}
function r7(e8, o14, r8) {
  const t11 = n7(e8, o14 == null ? void 0 : o14.where, r8);
  return t11 ? (o14 ?? (o14 = new d3()), o14.where = t11, o14) : o14;
}
function n7(l7, o14, r8) {
  var _a;
  if (null == l7.floorInfo || !((_a = r8.floors) == null ? void 0 : _a.length))
    return o14;
  let n10 = r8.floors;
  const { floorField: t11, viewAllLevelIds: f7 } = l7.floorInfo;
  f7.length && (n10 = f7);
  const s8 = n10.filter((e8) => "" !== e8).map((e8) => "'" + e8 + "'");
  if (s8.push("''"), o14 == null ? void 0 : o14.includes(t11)) {
    let e8 = new RegExp("AND \\(" + t11 + ".*NULL\\)", "g");
    o14 = o14.replace(e8, ""), e8 = new RegExp("\\(" + t11 + ".*NULL\\)", "g"), o14 = (o14 = o14.replace(e8, "")).replaceAll(/\s+/g, " ").trim();
  }
  let i9 = "(" + t11 + " IN ({ids}) OR " + t11 + " IS NULL)";
  return i9 = i9.replace("{ids}", s8.join(", ")), n2(o14, i9);
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/FeatureLayerAdapter.js
var u10 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const t11 = this.layer, r8 = r5(t11, e8) ?? l4(t11);
    return [{ vvEvaluators: { 0: o8(t11.renderer) }, deconflictionEnabled: r8 }];
  }
  async createServiceOptions(s8) {
    var _a, _b, _c, _d;
    const o14 = this.layer, a8 = O(o14), { capabilities: n10, editingInfo: d11, objectIdField: p6, typeIdField: y4, globalIdField: m7, datesInUnknownTimezone: c12, orderBy: u13, subtypeField: f7, refreshInterval: h6 } = o14, b4 = o14.fieldsIndex.toJSON(), g2 = b4.fields, S3 = e6(o14), I2 = (_a = o14.timeInfo) == null ? void 0 : _a.toJSON(), j2 = o14.spatialReference.toJSON(), F2 = (_b = o14.types) == null ? void 0 : _b.map((e8) => e8.toJSON()), x4 = a(this.layer.parsedUrl);
    this.layer.dynamicDataSource && (x4.query = { layer: JSON.stringify({ source: this.layer.dynamicDataSource }) });
    let E3 = this.layer.objectIdField;
    if (u13 == null ? void 0 : u13.length) {
      const e8 = !u13[0].valueExpression && u13[0].field;
      e8 && (E3 = e8);
    }
    const U2 = !(null != (d11 == null ? void 0 : d11.lastEditDate)) && h6 > 0, v = has("featurelayer-snapshot-enabled") && "point" === o14.geometryType && (n10 == null ? void 0 : n10.query.supportsPagination) && !(n10 == null ? void 0 : n10.operations.supportsEditing) && !U2, O3 = v && t9(s8, o14.fullExtent);
    return { type: "feature-service", source: x4, isSourceHosted: w2(x4.path), orderByFields: E3, metadata: { typeIdField: y4 ?? void 0, types: F2, timeReferenceUnknownClient: c12, subtypeField: f7, globalIdField: m7, fields: g2, fieldsIndex: b4, geometryType: S3, objectIdField: p6, timeInfo: I2, spatialReference: j2, subtypes: (_c = this.layer.subtypes) == null ? void 0 : _c.map((e8) => e8.toJSON()) }, queryMetadata: { capabilities: n10, effectiveCapabilities: a8, lastEditDate: (_d = d11 == null ? void 0 : d11.lastEditDate) == null ? void 0 : _d.getTime(), snapshotInfo: { supportsSnapshotMinThreshold: v, supportsSnapshotMaxThreshold: O3, snapshotCountThresholds: { min: has("featurelayer-snapshot-point-min-threshold"), max: has("featurelayer-snapshot-point-max-threshold") } } } };
  }
  createSourceSchema(e8, t11, r8) {
    const { definitionExpression: s8, customParameters: i9, gdbVersion: o14, historicMoment: a8, subtypeCode: l7, subtypeField: n10, timeExtent: d11, apiKey: p6 } = this.layer;
    return t8(e8, { definitionExpression: s8, customParameters: i9, gdbVersion: o14, historicMoment: a8, subtypeCode: l7, subtypeField: n10, timeExtent: d11 }, t11, r8, p6);
  }
  createProcessorSchema(e8, t11, r8) {
    const { fields: i9, renderer: o14, geometryType: a8, labelingInfo: l7, labelsVisible: n10, orderBy: d11, objectIdField: p6 } = this.layer, y4 = { fields: i9.map((e9) => e9.toJSON()), renderer: o14 == null ? void 0 : o14.clone(), featureReduction: e5(this.layer, t11), geometryType: a8, labelingInfo: l7, labelsVisible: n10, objectIdField: p6, orderBy: d11 ?? "default" };
    return a7(e8, t11, y4, r8);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  hasFilters(e8) {
    return o12(this.layer, e8);
  }
  addFilters(e8, t11) {
    return r7(this.layer, e8, t11);
  }
  getUpdateHashProperties(e8) {
    var _a, _b;
    const t11 = this.layer, { definitionExpression: r8, renderer: i9, gdbVersion: a8, apiKey: l7, subtypeCode: n10 } = t11, d11 = this.layer.labelsVisible ? this.layer.labelingInfo : null, p6 = ((_a = t11.historicMoment) == null ? void 0 : _a.getTime()) ?? void 0, y4 = JSON.stringify(t11.customParameters), m7 = (_b = e5(t11, e8)) == null ? void 0 : _b.toJSON(), c12 = JSON.stringify(t11.orderBy);
    return { apiKey: l7, customParameters: y4, definitionExpression: r8, featureReduction: m7, floors: o12(this.layer, e8) ? e8.floors : null, gdbVersion: a8, historicMoment: p6, labelingInfo: d11, orderBy: c12, renderer: i9, subtypeCode: n10 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/InMemoryLayerAdapter.js
function d8(r8) {
  if (!("openPorts" in r8))
    throw new s("source-not-supported");
}
var p5 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const r8 = this.layer, t11 = r5(r8, e8) ?? l4(r8);
    return [{ vvEvaluators: { 0: o8(r8.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(e8) {
    var _a;
    const t11 = this.layer, o14 = O(t11), { capabilities: s8, objectIdField: l7 } = t11, n10 = t11.fieldsIndex.toJSON(), a8 = e6(t11), c12 = (_a = t11.timeInfo) == null ? void 0 : _a.toJSON(), p6 = t11.spatialReference.toJSON();
    d8(t11.source);
    return { type: "memory", source: await t11.source.openPorts(), orderByFields: l7, metadata: { fieldsIndex: n10, geometryType: a8, objectIdField: l7, timeInfo: c12, spatialReference: p6, subtypes: null, subtypeField: null, globalIdField: null, typeIdField: null, types: null, timeReferenceUnknownClient: null }, queryMetadata: { capabilities: s8, effectiveCapabilities: o14, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e8, r8, t11) {
    const { definitionExpression: i9, timeExtent: o14 } = this.layer;
    return t8(e8, { definitionExpression: i9, timeExtent: o14, customParameters: null }, r8, t11, null);
  }
  createProcessorSchema(e8, r8, i9) {
    const { fields: o14, renderer: s8, geometryType: l7, labelingInfo: n10, labelsVisible: c12, orderBy: d11, objectIdField: p6 } = this.layer, u13 = { fields: o14.map((e9) => e9.toJSON()), renderer: s8 == null ? void 0 : s8.clone(), featureReduction: e5(this.layer, r8), geometryType: l7, labelingInfo: n10, labelsVisible: c12, objectIdField: p6, orderBy: d11 ?? "default" };
    return a7(e8, r8, u13, i9);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  getUpdateHashProperties(e8) {
    var _a;
    const r8 = this.layer, { definitionExpression: i9, renderer: o14 } = r8, s8 = this.layer.labelsVisible ? this.layer.labelingInfo : null, l7 = (_a = e5(r8, e8)) == null ? void 0 : _a.toJSON();
    return { orderBy: JSON.stringify(r8.orderBy), definitionExpression: i9, renderer: o14, labelingInfo: s8, featureReduction: l7 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/KnowledgeGraphSublayerAdapter.js
var c10 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const r8 = this.layer, t11 = r5(r8, e8) ?? l4(r8);
    return [{ vvEvaluators: { 0: o8(r8.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(r8) {
    const i9 = this.layer, l7 = O(i9), { capabilities: s8, objectIdField: o14 } = i9, n10 = i9.fieldsIndex.toJSON(), a8 = e6(i9), c12 = i9.spatialReference.toJSON();
    return { type: "memory", source: await i9.source.openPorts(), orderByFields: o14, metadata: { fieldsIndex: n10, geometryType: a8, objectIdField: o14, spatialReference: c12, globalIdField: null, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, typeIdField: null, types: null }, queryMetadata: { capabilities: s8, effectiveCapabilities: l7, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e8, r8, t11) {
    const { definitionExpression: i9 } = this.layer;
    return t8(e8, { definitionExpression: i9, customParameters: null }, r8, t11, null);
  }
  createProcessorSchema(e8, t11, i9) {
    const { fields: l7, renderer: s8, geometryType: o14, labelingInfo: a8, labelsVisible: c12, objectIdField: d11 } = this.layer, p6 = { fields: l7.map((e9) => e9.toJSON()), renderer: s8 == null ? void 0 : s8.clone(), featureReduction: e5(this.layer, t11), geometryType: o14, labelingInfo: a8, labelsVisible: c12, objectIdField: d11, orderBy: "default" };
    return a7(e8, t11, p6, i9);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  getUpdateHashProperties(e8) {
    var _a;
    const t11 = this.layer, { definitionExpression: i9, renderer: l7 } = t11, s8 = this.layer.labelsVisible ? this.layer.labelingInfo : null, o14 = (_a = e5(t11, e8)) == null ? void 0 : _a.toJSON();
    return { definitionExpression: i9, renderer: l7, labelingInfo: s8, featureReduction: o14 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/OGCFeatureLayerAdapter.js
var d9 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const r8 = this.layer, t11 = r5(r8, e8) ?? l4(r8);
    return [{ vvEvaluators: { 0: o8(r8.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(t11) {
    var _a;
    const i9 = this.layer, l7 = O(i9), { capabilities: s8, objectIdField: a8 } = i9, n10 = i9.fieldsIndex.toJSON(), c12 = e6(i9), d11 = (_a = i9.timeInfo) == null ? void 0 : _a.toJSON(), m7 = i9.spatialReference.toJSON(), u13 = i9.source.getSource(), p6 = this.layer.objectIdField, y4 = a(s8);
    return y4.query.maxRecordCount = u13.maxRecordCount, { type: "ogc", source: u13, orderByFields: p6, metadata: { fieldsIndex: n10, geometryType: c12, objectIdField: a8, timeInfo: d11, spatialReference: m7, globalIdField: null, subtypeField: null, subtypes: null, timeReferenceUnknownClient: null, typeIdField: null, types: null }, queryMetadata: { capabilities: y4, effectiveCapabilities: l7, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e8, r8, t11) {
    const { customParameters: o14, timeExtent: i9, apiKey: l7 } = this.layer;
    return t8(e8, { customParameters: o14, timeExtent: i9 }, r8, t11, l7);
  }
  createProcessorSchema(e8, r8, o14) {
    const { fields: i9, renderer: l7, geometryType: s8, labelingInfo: a8, labelsVisible: c12, orderBy: d11, objectIdField: m7 } = this.layer, u13 = { fields: i9.map((e9) => e9.toJSON()), renderer: l7 == null ? void 0 : l7.clone(), featureReduction: e5(this.layer, r8), geometryType: s8, labelingInfo: a8, labelsVisible: c12, objectIdField: m7, orderBy: d11 ?? "default" };
    return a7(e8, r8, u13, o14);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  getUpdateHashProperties(e8) {
    var _a;
    const r8 = this.layer, { renderer: o14, apiKey: i9 } = r8, l7 = this.layer.labelsVisible ? this.layer.labelingInfo : null, s8 = JSON.stringify(r8.customParameters), a8 = (_a = e5(r8, e8)) == null ? void 0 : _a.toJSON();
    return { apiKey: i9, customParameters: s8, featureReduction: a8, labelingInfo: l7, orderBy: JSON.stringify(r8.orderBy), renderer: o14 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/OrientedImageryLayerAdapter.js
var u11 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const r8 = this.layer, t11 = r5(r8, e8) ?? l4(r8);
    return [{ vvEvaluators: { 0: o8(r8.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(s8) {
    var _a;
    const i9 = this.layer, l7 = O(i9), { capabilities: n10, objectIdField: p6, globalIdField: d11, orderBy: c12, refreshInterval: f7 } = i9, m7 = i9.fieldsIndex.toJSON(), u13 = m7.fields, y4 = e6(i9), h6 = (_a = i9.timeInfo) == null ? void 0 : _a.toJSON(), b4 = i9.spatialReference.toJSON(), g2 = a(this.layer.parsedUrl);
    let S3 = this.layer.objectIdField;
    if (c12 == null ? void 0 : c12.length) {
      const e8 = !c12[0].valueExpression && c12[0].field;
      e8 && (S3 = e8);
    }
    const I2 = f7 > 0, j2 = has("featurelayer-snapshot-enabled") && "point" === i9.geometryType && (n10 == null ? void 0 : n10.query.supportsPagination) && !(n10 == null ? void 0 : n10.operations.supportsEditing) && !I2, x4 = j2 && t9(s8, i9.fullExtent);
    return { type: "feature-service", source: g2, isSourceHosted: w2(g2.path), orderByFields: S3, metadata: { globalIdField: d11, fields: u13, fieldsIndex: m7, geometryType: y4, objectIdField: p6, timeInfo: h6, spatialReference: b4, timeReferenceUnknownClient: false, subtypeField: null, subtypes: null, typeIdField: null, types: null }, queryMetadata: { capabilities: n10, effectiveCapabilities: l7, lastEditDate: null, snapshotInfo: { supportsSnapshotMinThreshold: j2, supportsSnapshotMaxThreshold: x4, snapshotCountThresholds: { min: has("featurelayer-snapshot-point-min-threshold"), max: has("featurelayer-snapshot-point-max-threshold") } } } };
  }
  createSourceSchema(e8, r8, t11) {
    const { definitionExpression: s8, customParameters: o14, timeExtent: i9 } = this.layer;
    return t8(e8, { definitionExpression: s8, customParameters: o14, timeExtent: i9 }, r8, t11, null);
  }
  createProcessorSchema(e8, r8, t11) {
    const { fields: o14, renderer: i9, geometryType: l7, labelingInfo: a8, labelsVisible: n10, orderBy: p6, objectIdField: d11 } = this.layer, c12 = { fields: o14.map((e9) => e9.toJSON()), renderer: i9 == null ? void 0 : i9.clone(), featureReduction: e5(this.layer, r8), geometryType: l7, labelingInfo: a8, labelsVisible: n10, objectIdField: d11, orderBy: p6 ?? "default" };
    return a7(e8, r8, c12, t11);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  hasFilters(e8) {
    return o12(this.layer, e8);
  }
  addFilters(e8, r8) {
    return r7(this.layer, e8, r8);
  }
  getUpdateHashProperties(e8) {
    var _a;
    const r8 = this.layer, { definitionExpression: t11, renderer: o14 } = r8, l7 = this.layer.labelsVisible ? this.layer.labelingInfo : null, a8 = JSON.stringify(r8.customParameters), n10 = (_a = e5(r8, e8)) == null ? void 0 : _a.toJSON();
    return { orderBy: JSON.stringify(r8.orderBy), definitionExpression: t11, renderer: o14, labelingInfo: l7, featureReduction: n10, customParameters: a8, floors: o12(this.layer, e8) ? e8.floors : null };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/StreamLayerAdapter.js
var s7 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const t11 = this.layer, o14 = r5(t11, e8) ?? l4(t11);
    return [{ vvEvaluators: { 0: o8(t11.renderer) }, deconflictionEnabled: o14 }];
  }
  async createServiceOptions(e8) {
    var _a;
    const r8 = this.layer, { objectIdField: i9 } = r8, n10 = e6(r8), o14 = ((_a = r8.timeInfo) == null ? void 0 : _a.toJSON()) || null, l7 = r8.spatialReference ? r8.spatialReference.toJSON() : null;
    return { source: this.layer.parsedUrl, metadata: { fieldsIndex: this.layer.fieldsIndex.toJSON(), geometryType: n10, objectIdField: i9, timeInfo: o14, timeReferenceUnknownClient: null, spatialReference: l7, subtypeField: null, subtypes: null, globalIdField: null, typeIdField: null, types: null } };
  }
  createSourceSchema(e8, t11, r8) {
    const { definitionExpression: i9, geometryDefinition: n10, customParameters: o14 } = this.layer;
    return { type: "stream", service: e8, tileInfoJSON: t11.tileInfoJSON, mutable: { sourceRefreshVersion: r8, availableFields: t11.availableFields, dataFilter: { geometryDefinition: n10 == null ? void 0 : n10.toJSON(), definitionExpression: i9, outSpatialReference: t11.outSpatialReference.toJSON(), customParameters: o14 ?? null, maxReconnectionAttempts: this.layer.maxReconnectionAttempts, maxReconnectionInterval: this.layer.maxReconnectionInterval, purgeOptions: this.layer.purgeOptions.toJSON() } } };
  }
  createProcessorSchema(t11, r8, i9) {
    const { fields: n10, renderer: l7, geometryType: s8, labelingInfo: a8, labelsVisible: c12, objectIdField: d11 } = this.layer, m7 = { fields: n10.map((e8) => e8.toJSON()), renderer: l7 == null ? void 0 : l7.clone(), featureReduction: e5(this.layer, r8), geometryType: s8, labelingInfo: a8, labelsVisible: c12, objectIdField: d11, orderBy: "default" };
    return a7(t11, r8, m7, i9);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  getUpdateHashProperties(t11) {
    var _a;
    const r8 = this.layer, { definitionExpression: i9, renderer: n10 } = r8, o14 = this.layer.labelsVisible ? this.layer.labelingInfo : null, l7 = JSON.stringify(r8.customParameters), s8 = (_a = e5(r8, t11)) == null ? void 0 : _a.toJSON();
    return { definitionExpression: i9, renderer: n10, labelingInfo: o14, featureReduction: s8, customParameters: l7, streamFilter: `${JSON.stringify(r8.geometryDefinition)}${r8.definitionExpression}` };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/SubtypeProcessorSchema.js
async function i7(e8, { subtypeField: t11, sublayers: s8 }) {
  const a8 = await Promise.all(s8.map(({ renderer: t12 }) => r6(e8, t12)));
  return { type: "subtype", subtypeField: t11, renderers: s8.reduce((e9, { subtypeCode: r8 }, t12) => ({ ...e9, [r8]: a8[t12] }), {}) };
}
function o13(e8, r8) {
  const s8 = t2();
  return { type: "subtype", filters: e8.filters, capabilities: { maxTextureSize: s8.maxTextureSize }, subtypeField: r8.subtypeField, target: "feature", bindings: r8.sublayers.reduce((e9, { renderer: r9, subtypeCode: s9 }) => ({ ...e9, [s9]: c4(r9) }), {}) };
}
async function u12(r8, { subtypeField: t11, sublayers: a8 }) {
  const i9 = await Promise.all(a8.map((t12) => {
    const a9 = y2(t12.renderer), i10 = { ...t12, geometryType: t12.geometryType ?? null };
    return l5(r8, i10, a9);
  }));
  return { type: "subtype", subtypeField: t11, renderers: a8.reduce((e8, { subtypeCode: r9 }, t12) => ({ ...e8, [r9]: i9[t12] }), {}) };
}
async function n8(e8, r8, t11, s8) {
  return { storage: o13(r8, t11), mesh: { displayRefreshVersion: s8, strategy: { type: "feature" }, factory: { symbology: await i7(e8, t11), labels: await u12(e8, t11) }, sortKey: null, timeZone: r8.timeZone } };
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/SubtypeGroupLayerAdapter.js
var c11 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    return [{ vvEvaluators: {}, deconflictionEnabled: this.layer.sublayers.every((e9) => l4(e9)) }];
  }
  async createServiceOptions(t11) {
    var _a, _b, _c2;
    const r8 = this.layer, i9 = O(r8), { capabilities: l7, datesInUnknownTimezone: n10, editingInfo: y4, globalIdField: m7, objectIdField: u13, refreshInterval: c12, subtypeField: d11 } = r8, h6 = r8.fieldsIndex.toJSON(), f7 = e6(r8), b4 = (_a = r8.timeInfo) == null ? void 0 : _a.toJSON(), g2 = r8.spatialReference.toJSON(), S3 = a(this.layer.parsedUrl), x4 = u13, F2 = !(null != (y4 == null ? void 0 : y4.lastEditDate)) && c12 > 0, I2 = has("featurelayer-snapshot-enabled") && "point" === r8.geometryType && (l7 == null ? void 0 : l7.query.supportsPagination) && !(l7 == null ? void 0 : l7.operations.supportsEditing) && !F2, j2 = I2 && t9(t11, r8.fullExtent);
    return { type: "feature-service", source: S3, isSourceHosted: w2(S3.path), orderByFields: x4, metadata: { timeReferenceUnknownClient: n10, subtypeField: d11, globalIdField: m7, fieldsIndex: h6, geometryType: f7, objectIdField: u13, timeInfo: b4, spatialReference: g2, subtypes: (_b = this.layer.subtypes) == null ? void 0 : _b.map((e8) => e8.toJSON()), typeIdField: null, types: null }, queryMetadata: { capabilities: l7, effectiveCapabilities: i9, lastEditDate: (_c2 = y4 == null ? void 0 : y4.lastEditDate) == null ? void 0 : _c2.getTime(), snapshotInfo: { supportsSnapshotMinThreshold: I2, supportsSnapshotMaxThreshold: j2, snapshotCountThresholds: { min: has("featurelayer-snapshot-point-min-threshold"), max: has("featurelayer-snapshot-point-max-threshold") } } } };
  }
  createSourceSchema(e8, t11, r8) {
    const { definitionExpression: s8, customParameters: i9, gdbVersion: a8, historicMoment: o14, subtypeField: l7, timeExtent: n10, apiKey: p6 } = this.layer, y4 = { queryScaleRanges: this.layer.sublayers.items.map((e9) => ({ subtypeCode: e9.subtypeCode, minScale: e9.minScale, maxScale: e9.maxScale })), definitionExpression: s8, customParameters: i9, gdbVersion: a8, historicMoment: o14, subtypeField: l7, timeExtent: n10 };
    return t8(e8, y4, t11, r8, p6);
  }
  createProcessorSchema(e8, t11, r8) {
    const s8 = { subtypeField: this.layer.subtypeField, sublayers: Array.from(this.layer.sublayers, (e9) => ({ featureReduction: null, geometryType: this.layer.geometryType, labelingInfo: e9.labelingInfo, labelsVisible: e9.labelsVisible, renderer: e9.renderer, subtypeCode: e9.subtypeCode, orderBy: null })) };
    return n8(e8, t11, s8, r8);
  }
  hasFilters(e8) {
    return o12(this.layer, e8) || d10(this.layer, e8);
  }
  addFilters(e8, t11) {
    e8 = r7(this.layer, e8, t11);
    const s8 = this.layer.sublayers.filter((e9) => !h5(e9, t11)).map((e9) => e9.subtypeCode);
    if (!s8.length)
      return e8;
    e8 ?? (e8 = new d3());
    const a8 = `NOT ${this.layer.subtypeField} IN (${s8.join(",")})`;
    return e8.where = n2(e8.where, a8), e8;
  }
  get hasRequiredSupport() {
    return true;
  }
  getUpdateHashProperties(e8) {
    var _a;
    const t11 = this.layer, { definitionExpression: r8, gdbVersion: s8, apiKey: i9 } = t11, a8 = ((_a = t11.historicMoment) == null ? void 0 : _a.getTime()) ?? void 0, o14 = JSON.stringify(t11.customParameters), n10 = o12(this.layer, e8) ? e8.floors : null;
    return { gdbVersion: s8, definitionExpression: r8, historicMoment: a8, customParameters: o14, apiKey: i9, sublayerHash: "sublayers" in this.layer && this.layer.sublayers.items.reduce((e9, t12) => e9 + `${t12.visible ? 1 : 0}.${JSON.stringify(t12.renderer)}.${t12.labelsVisible}
.${JSON.stringify(t12.labelingInfo)}`, ""), floors: n10 };
  }
  setGraphicOrigin(e8) {
    const t11 = this.layer.fieldsIndex.get(this.layer.subtypeField), r8 = e8.attributes[t11.name], s8 = this.layer.sublayers.find((e9) => e9.subtypeCode === r8);
    e8.layer = e8.sourceLayer = s8;
  }
};
function d10(e8, t11) {
  return e8.sublayers.some((e9) => !h5(e9, t11));
}
function h5(e8, r8) {
  return e8.visible && (0 === e8.minScale || F(r8.scale, e8.minScale) || r8.scale < e8.minScale) && (0 === e8.maxScale || F(r8.scale, e8.maxScale) || r8.scale > e8.maxScale);
}

// node_modules/@arcgis/core/views/2d/layers/support/handleNoEngineError.js
async function n9(n10, r8) {
  try {
    return await n10;
  } catch (t11) {
    if ("no-queryEngine" !== t11.name)
      throw t11;
    return r8;
  }
}

// node_modules/@arcgis/core/views/2d/tiling/FeatureTileSubscriptionManager.js
function e7(s8, e8) {
  const i9 = /* @__PURE__ */ new Set();
  for (const t11 of s8 instanceof Set ? s8.values() : s8.keys())
    e8.has(t11) || i9.add(t11);
  return i9;
}
var i8 = class {
  constructor(s8) {
    this.version = s8;
  }
};
var t10 = class {
  constructor(s8) {
    this._subscriptions = /* @__PURE__ */ new Map(), this._visible = /* @__PURE__ */ new Set(), this._paused = /* @__PURE__ */ new Set(), this._version = 0, this._config = s8;
  }
  destroy() {
  }
  get _coverageSet() {
    const s8 = this._coverage ? Array.from(this._coverage.keys()).map((s9) => s9.id) : [];
    return new Set(s8);
  }
  suspend() {
    this._suspendedOverage = this._coverage, this._coverage = null, this._updateSubscriptions();
  }
  resume() {
    null == this._coverage && (this._coverage = this._suspendedOverage, this._suspendedOverage = null, this._updateSubscriptions());
  }
  update(s8) {
    return this._version = this._version + 1 % Number.MAX_SAFE_INTEGER, this._updateCoverage(s8), this._updateSubscriptions(), new Set(this._visible);
  }
  _updateCoverage(s8) {
    this._coverage = this._config.tileInfoView.getTileCoverage(s8.state, 0, true, "closest");
  }
  _updateSubscriptions() {
    const s8 = this._coverageSet, t11 = this._updateVisibility(), o14 = e7(t11, s8), n10 = e7(this._subscriptions, t11), r8 = e7(s8, this._subscriptions), a8 = e7(n10, s8), u13 = e7(o14, a8), c12 = e7(u13, this._paused);
    this._visible = t11;
    for (const e8 of r8.values())
      this._subscriptions.set(e8, new i8(this._version));
    for (const e8 of c12.values())
      this._paused.add(e8);
    for (const e8 of a8.values())
      this._subscriptions.delete(e8), this._paused.delete(e8);
    (r8.size || a8.size || c12.size) && this._sendUpdateSubscriptions(r8, a8, c12);
  }
  _sendUpdateSubscriptions(s8, e8, i9) {
    const t11 = Array.from(s8.values()).map((s9) => ({ tileId: s9, version: this._subscriptions.get(s9).version }));
    this._config.updateSubscriptions({ subscribe: t11, unsubscribe: Array.from(e8.values()), pause: Array.from(i9.values()), tileInfoJSON: this._config.tileInfoView.tileInfo.toJSON() });
  }
  _updateVisibility() {
    const s8 = /* @__PURE__ */ new Set();
    if (!this._coverage)
      return s8;
    for (const e8 of this._coverage.keys()) {
      if (this._config.isDone(e8)) {
        s8.add(e8.id);
        continue;
      }
      if (this._addVisibleParent(s8, e8))
        continue;
      this._addVisibleChildren(s8, e8) || s8.add(e8.id);
    }
    return s8;
  }
  _addVisibleParent(e8, i9) {
    let t11 = false;
    for (const o14 of this._visible.values()) {
      new e4(o14).containsChild(i9) && (e8.add(o14), t11 = true);
    }
    return t11;
  }
  _addVisibleChildren(e8, i9) {
    let t11 = false;
    for (const o14 of this._visible.values()) {
      const n10 = new e4(o14);
      i9.containsChild(n10) && (e8.add(o14), t11 = true);
    }
    return t11;
  }
};

// node_modules/@arcgis/core/views/2d/layers/FeatureLayerView2D.js
function P4(e8, t11) {
  const r8 = /* @__PURE__ */ new Set();
  return e8 && e8.forEach((e9) => r8.add(e9)), t11 && t11.forEach((e9) => r8.add(e9)), r8.has("*") ? ["*"] : Array.from(r8);
}
var z2 = 4294967294;
var B = class extends j(i5(m3(u4))) {
  constructor() {
    super(...arguments), this._commandsQueue = new a5({ process: (e8) => {
      switch (e8.type) {
        case "processed-edit":
          return this._doEdit(e8);
        case "update":
          return this._doUpdate();
      }
    } }), this._visibilityOverrides = /* @__PURE__ */ new Set(), this._highlightCounter = new t5(), this._lastAvailableFields = [], this.eventLog = new o6(), this._sourceRefreshVersion = 1, this._displayRefreshVersion = 1, this._pipelineUpdating = false, this._fields = null, this.featureEffectView = new r3();
  }
  destroy() {
    var _a;
    (_a = this._worker) == null ? void 0 : _a.destroy(), this._commandsQueue.destroy();
  }
  initialize() {
    this.addResolvingPromise(this._initProxy()), this.featureEffectView.featureEffect = this.featureEffect, this.featureEffectView.endTransitions();
  }
  async _initProxy() {
    var _a;
    const e8 = this.layer;
    if ("isTable" in e8 && e8.isTable)
      throw new s("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: e8 });
    if ("mesh" === e8.geometryType)
      throw new s("featurelayerview:geometry-type-not-supported", `Geometry type of ${e8.geometryType} is not supported`, { layer: e8 });
    if (("feature" === e8.type || "subtype-group" === e8.type) && false === ((_a = O(e8)) == null ? void 0 : _a.operations.supportsQuery))
      throw new s("featurelayerview:query-not-supported", "layer view requires a layer with query capability", { layer: e8 });
    this._worker && this._worker.destroy();
    const t11 = this._createClientOptions();
    this._worker = await t6(t11);
  }
  get hasAllFeatures() {
    return this.layer.visible && this.eventLog.hasAllFeatures;
  }
  get hasAllFeaturesInView() {
    return this.layer.visible && this.eventLog.hasAllFeaturesInView;
  }
  get hasFullGeometries() {
    return this.layer.visible && this.eventLog.hasFullGeometries;
  }
  get labelingCollisionInfos() {
    const e8 = this.layerAdapter.getLabelingDeconflictionInfo(this.view), t11 = this.layer.geometryType, r8 = !this.suspended;
    return e8.map(({ vvEvaluators: e9, deconflictionEnabled: s8 }) => ({ container: this.featureContainer, vvEvaluators: e9, deconflictionEnabled: s8, geometryType: t11, visible: r8 }));
  }
  get layerAdapter() {
    switch (this.layer.type) {
      case "feature":
        return "memory" === this.layer.source.type ? new p5(this.layer) : new u10(this.layer);
      case "geojson":
      case "csv":
      case "wfs":
        return new p5(this.layer);
      case "subtype-group":
        return new c11(this.layer);
      case "ogc-feature":
        return new d9(this.layer);
      case "stream":
        return new s7(this.layer);
      case "oriented-imagery":
        return new u11(this.layer);
      case "knowledge-graph-sublayer":
        return new c10(this.layer);
      case "catalog-footprint":
        return new d7(this.layer);
      default:
        n3(this.layer);
    }
    return null;
  }
  get updateHash() {
    if (!this.layerAdapter)
      return null;
    const { availableFields: e8, _displayRefreshVersion: t11, timeExtent: r8, clips: s8, filter: i9, featureEffect: a8, _sourceRefreshVersion: o14, view: { timeZone: n10 } } = this, u13 = JSON.stringify(s8), l7 = a8 == null ? void 0 : a8.toJSON(), h6 = i9 == null ? void 0 : i9.toJSON();
    return JSON.stringify({ availableFields: e8, clipsHash: u13, displayRefreshVersion: t11, effectHash: l7, filterHash: h6, sourceRefreshVersion: o14, timeExtent: r8, timeZone: n10, ...this.layerAdapter.getUpdateHashProperties(this.view) });
  }
  getDisplayStatistics(e8, t11) {
    var _a;
    return (_a = this.featureContainer) == null ? void 0 : _a.getDisplayStatistics(e8, t11);
  }
  async queryHeatmapStatistics(e8) {
    return this._worker.pipeline.queryHeatmapStatistics(e8);
  }
  highlight(e8, t11 = "highlight") {
    let a8;
    e8 instanceof f3 ? a8 = [e8.getObjectId()] : "number" == typeof e8 || "string" == typeof e8 ? a8 = [e8] : V.isCollection(e8) && e8.length > 0 ? a8 = e8.map((e9) => e9 == null ? void 0 : e9.getObjectId()).toArray() : Array.isArray(e8) && e8.length > 0 && (a8 = "number" == typeof e8[0] || "string" == typeof e8[0] ? e8 : e8.map((e9) => e9 == null ? void 0 : e9.getObjectId()));
    const o14 = a8 == null ? void 0 : a8.filter(k);
    return (o14 == null ? void 0 : o14.length) ? (this._addHighlights(o14, t11), e2(() => this._removeHighlights(o14, t11))) : e2();
  }
  getHighlightIds() {
    return Array.from(this._highlightCounter.ids());
  }
  hasHighlight() {
    return !this._highlightCounter.empty;
  }
  async hitTest(e8, s8) {
    const i9 = await this.featureContainer.hitTest(s8);
    if (0 === i9.length)
      return null;
    const { features: a8, aggregates: o14 } = await this._worker.pipeline.getDisplayFeatures(i9), n10 = this.featureContainer.getSortKeys(i9), u13 = ({ displayId: e9 }, { displayId: t11 }) => n10.has(e9) && n10.has(t11) ? n10.get(e9) - n10.get(t11) : e9 - t11;
    return a8.sort(u13).reverse(), o14.sort(u13).reverse(), [...o14.map((r8) => this._createGraphicHit(e8, s4.fromJSON(r8))), ...a8.map((t11) => this._createGraphicHit(e8, f3.fromJSON(t11)))];
  }
  queryStatistics() {
    return n9(this._worker.pipeline.queryStatistics(), { featureCount: 0, ringCount: 0, vertexCount: 0 });
  }
  querySummaryStatistics(e8, t11, r8) {
    const s8 = { ...t11, scale: this.view.scale }, i9 = this._worker.features.executeQueryForSummaryStatistics(this._cleanUpQuery(e8), s8, r8);
    return n9(i9, {});
  }
  async queryAggregateSummaryStatistics(e8, t11, r8) {
    const s8 = { ...t11, scale: this.view.scale }, i9 = this._worker.aggregates.executeQueryForSummaryStatistics(this._cleanUpAggregateQuery(e8), s8, r8);
    return n9(i9, {});
  }
  async queryUniqueValues(e8, t11, r8) {
    const s8 = { ...t11, scale: this.view.scale }, i9 = this._worker.features.executeQueryForUniqueValues(this._cleanUpQuery(e8), s8, r8);
    return n9(i9, { uniqueValueInfos: [] });
  }
  async queryAggregateUniqueValues(e8, t11, r8) {
    const s8 = { ...t11, scale: this.view.scale }, i9 = this._worker.aggregates.executeQueryForUniqueValues(this._cleanUpAggregateQuery(e8), s8, r8);
    return n9(i9, { uniqueValueInfos: [] });
  }
  async queryClassBreaks(e8, t11, r8) {
    const s8 = { ...t11, scale: this.view.scale }, i9 = this._worker.features.executeQueryForClassBreaks(this._cleanUpQuery(e8), s8, r8);
    return n9(i9, { classBreakInfos: [] });
  }
  async queryAggregateClassBreaks(e8, t11, r8) {
    const s8 = { ...t11, scale: this.view.scale }, i9 = this._worker.aggregates.executeQueryForClassBreaks(this._cleanUpAggregateQuery(e8), s8, r8);
    return n9(i9, { classBreakInfos: [] });
  }
  async queryHistogram(e8, t11, r8) {
    const s8 = { ...t11, scale: this.view.scale }, i9 = this._worker.features.executeQueryForHistogram(this._cleanUpQuery(e8), s8, r8);
    return n9(i9, { bins: [], maxValue: null, minValue: null, normalizationTotal: null });
  }
  async queryAggregateHistogram(e8, t11, r8) {
    const s8 = { ...t11, scale: this.view.scale }, i9 = this._worker.aggregates.executeQueryForHistogram(this._cleanUpAggregateQuery(e8), s8, r8);
    return n9(i9, { bins: [], maxValue: null, minValue: null, normalizationTotal: null });
  }
  queryFeatures(e8, t11) {
    return this.queryFeaturesJSON(e8, t11).then((e9) => {
      const t12 = d4.fromJSON(e9);
      return t12.features.forEach((e10) => this._setLayersForFeature(e10)), t12;
    });
  }
  async queryVisibleFeatures(e8, t11) {
    const r8 = this._worker.pipeline.queryVisibleFeatures(this._cleanUpQuery(e8), t11), s8 = await n9(r8, { features: [] }), i9 = d4.fromJSON(s8);
    return i9.features.forEach((e9) => this._setLayersForFeature(e9)), i9;
  }
  async queryAggregates(e8, t11) {
    const r8 = this._worker.aggregates.executeQuery(this._cleanUpAggregateQuery(e8), t11), s8 = await n9(r8, { features: [] }), i9 = m4.fromJSON(s8);
    return i9.features.forEach((e9) => this._setLayersForFeature(e9)), i9;
  }
  queryAggregateIds(e8, t11) {
    const r8 = this._worker.aggregates.executeQueryForIds(this._cleanUpAggregateQuery(e8), t11);
    return n9(r8, []);
  }
  queryAggregateCount(e8, t11) {
    const r8 = this._worker.aggregates.executeQueryForCount(this._cleanUpAggregateQuery(e8), t11);
    return n9(r8, 0);
  }
  queryAggregateJSON(e8, t11) {
    const r8 = this._worker.aggregates.executeQuery(this._cleanUpAggregateQuery(e8), t11);
    return n9(r8, { features: [] });
  }
  async queryFeaturesJSON(e8, t11) {
    const r8 = this._worker.features.executeQuery(this._cleanUpQuery(e8), t11);
    return n9(r8, { features: [] });
  }
  queryObjectIds(e8, t11) {
    const r8 = this._worker.features.executeQueryForIds(this._cleanUpQuery(e8), t11);
    return n9(r8, []);
  }
  queryFeatureCount(e8, t11) {
    const r8 = this._worker.features.executeQueryForCount(this._cleanUpQuery(e8), t11);
    return n9(r8, 0);
  }
  async queryExtent(e8, t11) {
    const r8 = this._worker.features.executeQueryForExtent(this._cleanUpQuery(e8), t11), s8 = await n9(r8, { count: 0, extent: null });
    return { count: s8.count, extent: w.fromJSON(s8.extent) };
  }
  async getSampleFeatures(e8) {
    return this._worker.pipeline.getSampleFeatures(e8);
  }
  setVisibility(e8, t11) {
    t11 ? this._visibilityOverrides.delete(e8) : this._visibilityOverrides.add(e8), this._update();
  }
  update(e8) {
    if (!this._subscriptionManager)
      return;
    const t11 = this._subscriptionManager.update(e8);
    this.featureContainer.setVisibleTiles(t11);
  }
  attach() {
    has("esri-2d-update-debug") && console.debug("FeatureLayerView2D.attach"), this.featureContainer = new u5(this), this.container.addChild(this.featureContainer), this.view.timeline.record(`${this.layer.title} (FeatureLayer) Attach`), this._subscriptionManager = new t10({ tileInfoView: this.view.featuresTilingScheme, updateSubscriptions: (e8) => {
      this.featureContainer.updateSubscriptions(e8), this._updatingHandles.addPromise(this._worker.pipeline.updateSubscriptions(e8));
    }, isDone: (e8) => this.featureContainer.isDone(e8) }), this.requestUpdate(), this.addAttachHandles([d(() => this.updateHash, () => this._update(), P), d(() => this.updateSuspended, (e8) => {
      e8 || this._subscriptionManager.resume();
    })]), "stream" !== this.layer.type && "catalog-footprint" !== this.layer.type && this.addAttachHandles(this.layer.on("edits", (e8) => this._edit(e8)));
  }
  detach() {
    has("esri-2d-update-debug") && console.debug("FeatureLayerView2D.detach"), this._fields = null, this.featureContainer.destroy(), this._commandsQueue.clear(), this.container.removeAllChildren(), this._subscriptionManager = u(this._subscriptionManager), this._worker.pipeline.onDetach();
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  isUpdating() {
    const e8 = "renderer" in this.layer && null != this.layer.renderer, t11 = this._commandsQueue.updateTracking.updating, r8 = null != this._updatingRequiredFieldsPromise, s8 = this.featureContainer.updatingHandles.updating, i9 = this.updateRequested || e8 && (t11 || r8) || s8 || this._pipelineUpdating || this.dataUpdating;
    if (has("esri-2d-log-updating")) {
      console.log(`Updating FLV2D (${this.layer.id}): ${i9}
  -> updateRequested ${this.updateRequested}
  -> hasRenderer ${e8}
  -> updatingRequiredFields ${r8}
  -> hasPendingCommand ${t11}
  -> dataUpdating ${this.dataUpdating}
  -> processing ${this._pipelineUpdating}
  -> updatingContainer ${s8}
`);
      for (const e9 of this.featureContainer.subscriptions())
        console.log(`    -> Tile[${e9.id}] Done: ${e9.done}`);
    }
    return i9;
  }
  _createClientOptions() {
    const e8 = this;
    return { get container() {
      return e8.featureContainer;
    }, setUpdating: (e9) => {
      this._set("_pipelineUpdating", e9.pipeline), this._set("dataUpdating", e9.data);
    }, emitEvent: (e9) => {
      this.emit(e9.name, e9.event);
    }, get eventLog() {
      return e8.eventLog;
    }, fetch: (t11) => Promise.all(t11.map((t12) => e8.view.stage.painter.textureManager.rasterizeItem(t12))), fetchDictionary: (e9) => Promise.all(e9.map((e10) => this._fetchDictionaryRequest(e10))) };
  }
  async _fetchDictionaryRequest(e8) {
    try {
      if ("subtype-group" === this.layer.type)
        throw new Error("InternalError: SubtypeGroupLayer does not support dictionary renderer");
      const t11 = this.layer.renderer;
      if (!t11 || "dictionary" !== t11.type)
        throw new Error("InternalError: Expected layer to have a DictionaryRenderer");
      const r8 = this._lastSchema.processor.mesh.factory.symbology;
      if ("dictionary" !== r8.type)
        throw new Error("InternalError: Expected schema to be of type 'dictionary'");
      const s8 = { cimAnalyzer: this.view.stage.cimAnalyzer, cimResourceManager: this.view.stage.painter.textureManager.resourceManager, store: this.featureContainer.instanceStore, scaleExpression: r8.scaleExpression };
      this._fields || (this._fields = this.layer.fields.map((e9) => e9.toJSON()));
      const i9 = r8.visualVariableUniforms, a8 = await t11.getSymbolAsync(e8.feature, { fields: this._fields });
      if (!a8 || !a8.data)
        return { type: "dictionary-response", meshes: [] };
      return { type: "dictionary-response", meshes: await n4(a8.data, { uniforms: i9, path: "renderer", schemaOptions: s8 }) };
    } catch (t11) {
      return { type: "dictionary-response", meshes: [] };
    }
  }
  _cleanUpQuery(e8) {
    const t11 = b2.from(e8) || this.createQuery();
    return t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference), t11.toJSON();
  }
  _cleanUpAggregateQuery(e8) {
    const t11 = b2.from(e8) || this.createAggregateQuery();
    t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference);
    const r8 = t11.objectIds ?? [];
    for (const s8 of t11.aggregateIds ?? [])
      r8.push(s8);
    return t11.objectIds = r8, t11.aggregateIds = [], t11.toJSON();
  }
  async _update() {
    return this._commandsQueue.push({ type: "update" });
  }
  async _edit(e8) {
    if (this.updateSuspended)
      return void this._subscriptionManager.suspend();
    return this._validateEdit(e8) ? this._commandsQueue.push({ type: "edit", edits: e8 }).catch(f) : void 0;
  }
  async doRefresh(e8) {
    this.attached && (this.updateSuspended && e8 || (e8 ? this.incrementSourceRefreshVersion() : this.incrementDisplayRefreshVersion()));
  }
  incrementSourceRefreshVersion() {
    this._sourceRefreshVersion = (this._sourceRefreshVersion + 1) % z2 + 1;
  }
  incrementDisplayRefreshVersion() {
    this._displayRefreshVersion = (this._displayRefreshVersion + 1) % z2 + 1;
  }
  _validateEdit(e8) {
    const t11 = "globalIdField" in this.layer && this.layer.globalIdField, r8 = e8.deletedFeatures.some((e9) => -1 === e9.objectId || !e9.objectId), s8 = t11 && this.availableFields.includes(t11);
    return r8 && !s8 ? (n.getLogger(this).error(new s("mapview-apply-edits", `Editing the specified service requires the layer's globalIdField, ${t11} to be included the layer's outFields for updates to be reflected on the map`)), null) : e8;
  }
  async _doUpdate() {
    var _a, _b, _c, _d;
    "featureReduction" in this.layer && this.layer.featureReduction && this.layer.featureReduction !== this._lastFeatureReduction && (this.layer.featureReduction = (_a = this.layer.featureReduction) == null ? void 0 : _a.clone(), this._lastFeatureReduction = this.layer.featureReduction);
    try {
      if (await this._updateRequiredFields(), this.destroyed || !((_b = this.layerAdapter) == null ? void 0 : _b.hasRequiredSupport) || !this._subscriptionManager)
        return;
      const e8 = this.featureContainer.instanceStore;
      this.featureContainer.attributeView.lockTextureUploads(), e8.updateStart();
      const t11 = this.featureEffect, r8 = { store: e8, cimAnalyzer: this.view.stage.cimAnalyzer, cimResourceManager: this.view.stage.painter.textureManager.resourceManager, scaleExpression: void 0 }, s8 = await this.layerAdapter.createServiceOptions(this.view), i9 = this._createViewSchemaConfig(), a8 = { source: this.layerAdapter.createSourceSchema(s8, i9, this._sourceRefreshVersion), processor: await this.layerAdapter.createProcessorSchema(r8, i9, this._displayRefreshVersion) }, o14 = !!d2((_c = this._lastSchema) == null ? void 0 : _c.source.mutable, a8.source.mutable) || !!d2((_d = this._lastSchema) == null ? void 0 : _d.processor, a8.processor);
      if (!o14)
        return this.featureContainer.requestRender(), this.featureContainer.attributeView.unlockTextureUploads(), e8.updateEnd(), void (this.featureEffectView.featureEffect = t11);
      this._lastSchema = a8, this._fields = null;
      const n10 = Math.round(performance.now());
      has("esri-2d-update-debug") && console.debug(`Id[${this.layer.uid}] Version[${n10}] FeatureLayerView2D._doUpdate`, { changes: o14 });
      let u13 = [];
      Array.isArray(s8.source) && (u13 = s8.source), await this._worker.pipeline.updateSchema(a8, n10, { transferList: u13 }), e8.updateEnd(), this.featureEffectView.featureEffect = t11, this.featureEffectView.endTransitions(), this.featureContainer.attributeView.unlockTextureUploads(), this.featureContainer.swapRenderState(), this.featureContainer.requestRender(), has("esri-2d-update-debug") && console.debug(`Version[${n10}] FeatureLayerView2D.updateEnd`), this.requestUpdate();
    } catch (e8) {
      has("esri-2d-update-debug") && console.error("Encountered an error during update", e8);
    }
  }
  async _doEdit(e8) {
    try {
      this.featureContainer.editStart(), await this._worker.pipeline.onEdits(e8), this.featureContainer.editEnd();
    } catch (t11) {
      b(t11), 0;
    }
  }
  get hasFilter() {
    var _a, _b;
    const e8 = ((_b = (_a = this.layerAdapter).hasFilters) == null ? void 0 : _b.call(_a, this.view)) ?? false;
    return null != this.filter || null != this.timeExtent || this._visibilityOverrides.size > 0 || e8;
  }
  _getEffectiveAvailableFields(e8) {
    const t11 = P4(this._lastAvailableFields, e8);
    return this._lastAvailableFields = t11, T(this.layer.fieldsIndex, t11);
  }
  _createViewSchemaConfig() {
    var _a, _b;
    const e8 = [Z2(this.view, this.layerAdapter, this.timeExtent, this._visibilityOverrides, this.filter), ((_b = (_a = this.featureEffect) == null ? void 0 : _a.filter) == null ? void 0 : _b.toJSON()) ?? null];
    return { availableFields: this._getEffectiveAvailableFields(this.availableFields), filters: e8, outSpatialReference: this.view.spatialReference, tileInfoJSON: this.view.featuresTilingScheme.tileInfo.toJSON(), scale: this.view.scale, timeZone: this.view.timeZone };
  }
  _addHighlights(e8, t11) {
    this._highlightCounter.addReason(e8, t11), this._updateHighlights();
  }
  _removeHighlights(e8, t11) {
    this._highlightCounter.deleteReason(e8, t11), this._updateHighlights();
  }
  _updateHighlights() {
    const e8 = [];
    for (const r8 of this._highlightCounter.ids()) {
      const t12 = this._highlightCounter.getHighestReason(r8), s8 = t(t12);
      e8.push({ objectId: r8, highlightFlags: s8 });
    }
    const t11 = this._worker.pipeline.updateHighlight({ highlights: e8 }).catch((e9) => {
      b(e9) || n.getLogger(this).error(e9);
    });
    this._updatingHandles.addPromise(t11);
  }
  _setLayersForFeature(e8) {
    e8.layer = e8.sourceLayer = this.layer, this.layerAdapter.setGraphicOrigin && this.layerAdapter.setGraphicOrigin(e8);
  }
  _createGraphicHit(e8, t11) {
    return this._setLayersForFeature(t11), null != t11.geometry && (t11.geometry.spatialReference = this.view.spatialReference), { type: "graphic", graphic: t11, layer: this.layer, mapPoint: e8 };
  }
};
function Z2(e8, t11, r8, s8, i9) {
  var _a;
  i9 && (i9 = i9.clone());
  const a8 = null != i9 ? i9.timeExtent : null, o14 = null != r8 && null != a8 ? r8.intersection(a8) : r8 || a8;
  o14 && (i9 ?? (i9 = new d3()), i9.timeExtent = o14), i9 = ((_a = t11.addFilters) == null ? void 0 : _a.call(t11, i9, e8)) ?? i9;
  let n10 = (i9 == null ? void 0 : i9.toJSON()) ?? null;
  return s8.size && (n10 ?? (n10 = new d3().toJSON()), n10.hiddenIds = Array.from(s8)), n10;
}
e([y()], B.prototype, "_worker", void 0), e([y()], B.prototype, "_commandsQueue", void 0), e([y()], B.prototype, "_sourceRefreshVersion", void 0), e([y()], B.prototype, "_displayRefreshVersion", void 0), e([y({ readOnly: true })], B.prototype, "_pipelineUpdating", void 0), e([y({ readOnly: true })], B.prototype, "hasAllFeatures", null), e([y({ readOnly: true })], B.prototype, "hasAllFeaturesInView", null), e([y({ readOnly: true })], B.prototype, "hasFullGeometries", null), e([y()], B.prototype, "featureEffectView", void 0), e([y()], B.prototype, "labelingCollisionInfos", null), e([y()], B.prototype, "layerAdapter", null), e([y()], B.prototype, "updateHash", null), e([y()], B.prototype, "updating", void 0), B = e([a2("esri.views.2d.layers.FeatureLayerView2D")], B);
var K2 = B;

export {
  n9 as n,
  K2 as K
};
//# sourceMappingURL=chunk-KHKQW5BH.js.map
