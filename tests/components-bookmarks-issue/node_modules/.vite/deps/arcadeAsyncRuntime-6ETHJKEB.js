import {
  A,
  C,
  M,
  Y,
  f as f2,
  o,
  p2 as p,
  q,
  s as s2
} from "./chunk-TEKM2ZUW.js";
import "./chunk-SI6AVZBW.js";
import "./chunk-TXFZLIFM.js";
import {
  xn
} from "./chunk-4R3SH4E2.js";
import "./chunk-ICMKKNJO.js";
import "./chunk-OPQLV3CH.js";
import "./chunk-66SBVETX.js";
import "./chunk-6P4ZZRYH.js";
import "./chunk-ZJQ6M76T.js";
import {
  D
} from "./chunk-MVNKR6NA.js";
import {
  N
} from "./chunk-PMK5VFGV.js";
import {
  B,
  E2 as E,
  G2 as G,
  H,
  J2 as J,
  O2 as O,
  Q,
  R,
  U,
  Ze,
  _,
  _e,
  a,
  ae,
  ce,
  e,
  fe,
  ge,
  me,
  n as n2,
  r,
  r2,
  s,
  s2 as s3,
  u,
  w,
  x,
  z
} from "./chunk-YGY4RCQM.js";
import "./chunk-GEMKWQ3Q.js";
import "./chunk-J7CIAQLK.js";
import "./chunk-QD3CP3I4.js";
import "./chunk-TLTAGTBA.js";
import "./chunk-2QPP5AGU.js";
import "./chunk-2C26DRKK.js";
import "./chunk-M4RFJU4F.js";
import "./chunk-YH2IYJYF.js";
import "./chunk-GGHKH3LP.js";
import "./chunk-VS6AHHIY.js";
import "./chunk-QNG4TY7L.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-326OSIM5.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-TPLOIZC7.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-545NO6M2.js";
import "./chunk-5LSHHVQ5.js";
import "./chunk-IZKCZQUY.js";
import {
  n
} from "./chunk-M5ZB5S5C.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import "./chunk-D25BO7X7.js";
import "./chunk-NDIXNREV.js";
import "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/arcade/arcadeAsyncRuntime.js
var q2 = 100;
async function T(e2, t) {
  const n3 = [];
  for (let r3 = 0; r3 < t.arguments.length; r3++)
    n3.push(await H2(e2, t.arguments[r3]));
  return n3;
}
async function W(e2, t, n3) {
  if (true === t.preparsed)
    return n3(e2, null, t.arguments);
  return n3(e2, t, await T(e2, t));
}
var V = class extends r2 {
  constructor(e2, t) {
    super(), this.definition = null, this.context = null, this.definition = e2, this.context = t;
  }
  createFunction(e2) {
    return (...t) => {
      const n3 = { spatialReference: this.context.spatialReference, console: this.context.console, lrucache: this.context.lrucache, timeZone: this.context.timeZone ?? null, exports: this.context.exports, libraryResolver: this.context.libraryResolver, interceptor: this.context.interceptor, localScope: {}, depthCounter: { depth: e2.depthCounter + 1 }, globalScope: this.context.globalScope };
      if (n3.depthCounter.depth > 64)
        throw new a(e2, r.MaximumCallDepth, null);
      return Be(this.definition, n3, t, null);
    };
  }
  call(e2, t) {
    return z2(e2, t, (n3, a2, i) => {
      const l = { spatialReference: e2.spatialReference, services: e2.services, console: e2.console, libraryResolver: e2.libraryResolver, exports: e2.exports, lrucache: e2.lrucache, timeZone: e2.timeZone ?? null, interceptor: e2.interceptor, localScope: {}, abortSignal: e2.abortSignal, globalScope: e2.globalScope, depthCounter: { depth: e2.depthCounter.depth + 1 } };
      if (l.depthCounter.depth > 64)
        throw new a(e2, r.MaximumCallDepth, t);
      return Be(this.definition, l, i, t);
    });
  }
  marshalledCall(e2, t, n3, r3) {
    return r3(e2, t, async (o2, a2, i) => {
      const l = { spatialReference: e2.spatialReference, globalScope: n3.globalScope, depthCounter: { depth: e2.depthCounter.depth + 1 }, libraryResolver: e2.libraryResolver, exports: e2.exports, console: e2.console, abortSignal: e2.abortSignal, lrucache: e2.lrucache, timeZone: e2.timeZone ?? null, interceptor: e2.interceptor, localScope: {} };
      return i = i.map((t2) => !_(t2) || t2 instanceof s3 ? t2 : n2(t2, e2, r3)), n2(await Be(this.definition, l, i, t), n3, r3);
    });
  }
};
var _2 = class extends s {
  constructor(e2) {
    super(e2);
  }
  async global(e2) {
    const t = this.executingContext.globalScope[e2.toLowerCase()];
    if (t.valueset || (t.value = await H2(this.executingContext, t.node), t.valueset = true), _(t.value) && !(t.value instanceof s3)) {
      const e3 = new s3();
      e3.fn = t.value, e3.parameterEvaluator = z2, e3.context = this.executingContext, t.value = e3;
    }
    return t.value;
  }
  setGlobal(e2, t) {
    if (_(t))
      throw new a(null, r.AssignModuleFunction, null);
    this.executingContext.globalScope[e2.toLowerCase()] = { value: t, valueset: true, node: null };
  }
  hasGlobal(e2) {
    return void 0 === this.executingContext.exports[e2] && (e2 = e2.toLowerCase()), void 0 !== this.executingContext.exports[e2];
  }
  async loadModule(e2) {
    let n3 = e2.spatialReference;
    null == n3 && (n3 = new f({ wkid: 102100 })), this.moduleScope = De({}, e2.customfunctions, e2.timeZone), this.executingContext = { spatialReference: n3, services: e2.services, libraryResolver: new s2(e2.libraryResolver._moduleSingletons, this.source.syntax.loadedModules), exports: {}, abortSignal: void 0 === e2.abortSignal || null === e2.abortSignal ? { aborted: false } : e2.abortSignal, globalScope: this.moduleScope, console: e2.console ?? Ge, lrucache: e2.lrucache, timeZone: e2.timeZone ?? null, interceptor: e2.interceptor, localScope: null, depthCounter: { depth: 1 } }, await H2(this.executingContext, this.source.syntax);
  }
};
async function z2(e2, t, n3) {
  if (true === t.preparsed)
    return n3(e2, null, t.arguments);
  return n3(e2, t, await T(e2, t));
}
async function H2(e2, t, n3) {
  if (t.breakpoint && true !== n3) {
    const n4 = t.breakpoint();
    return await n4, H2(e2, t, true);
  }
  try {
    switch (t == null ? void 0 : t.type) {
      case "VariableDeclarator":
        return await Se(e2, t);
      case "ImportDeclaration":
        return await ye(e2, t);
      case "ExportNamedDeclaration":
        return await ve(e2, t);
      case "VariableDeclaration":
        return await be(e2, t, 0);
      case "BlockStatement":
      case "Program":
        return await de(e2, t);
      case "FunctionDeclaration":
        return await ge2(e2, t);
      case "ReturnStatement":
        return await me2(e2, t);
      case "IfStatement":
        return await we(e2, t);
      case "ExpressionStatement":
        return await pe(e2, t);
      case "UpdateExpression":
        return await ue(e2, t);
      case "AssignmentExpression":
        return await fe2(e2, t);
      case "ForStatement":
        return await te(e2, t);
      case "WhileStatement":
        return await Q2(e2, t);
      case "ForInStatement":
        return await se(e2, t);
      case "BreakStatement":
        return R;
      case "EmptyStatement":
        return O;
      case "ContinueStatement":
        return J;
      case "TemplateElement":
        return await je(e2, t);
      case "TemplateLiteral":
        return await Le(e2, t);
      case "Identifier":
        return await Re(e2, t);
      case "MemberExpression":
        return await xe(e2, t);
      case "Literal":
        return t.value;
      case "CallExpression":
        return await Me(e2, t);
      case "UnaryExpression":
        return await Fe(e2, t);
      case "BinaryExpression":
        return await Ce(e2, t);
      case "LogicalExpression":
        return await Ae(e2, t);
      case "ArrayExpression":
        return await Ie(e2, t);
      case "ObjectExpression":
        return await Y2(e2, t);
      case "Property":
        return await J2(e2, t);
      default:
        throw new a(e2, r.Unrecognized, t);
    }
  } catch (i) {
    throw u(e2, t, i);
  }
}
async function Y2(e2, t) {
  const a2 = [];
  for (let n3 = 0; n3 < t.properties.length; n3++)
    a2[n3] = await H2(e2, t.properties[n3]);
  const i = {}, l = /* @__PURE__ */ new Map();
  for (let n3 = 0; n3 < a2.length; n3++) {
    const s5 = a2[n3];
    if (_(s5.value))
      throw new a(e2, r.NoFunctionInDictionary, t);
    if (false === G(s5.key))
      throw new a(e2, r.KeyMustBeString, t);
    let u2 = s5.key.toString();
    const c = u2.toLowerCase();
    l.has(c) ? u2 = l.get(c) : l.set(c, u2), s5.value === O ? i[u2] = null : i[u2] = s5.value;
  }
  const s4 = new N(i);
  return s4.immutable = false, s4;
}
async function J2(e2, t) {
  const n3 = await H2(e2, t.value);
  if ("Identifier" === t.key.type)
    return { key: t.key.name, value: n3 };
  return { key: await H2(e2, t.key), value: n3 };
}
async function Q2(e2, t) {
  const n3 = { testResult: true, lastAction: O };
  if (n3.testResult = await H2(e2, t.test), false === n3.testResult)
    return O;
  if (true !== n3.testResult)
    throw new a(e2, r.BooleanConditionRequired, t);
  for (; true === n3.testResult && (n3.lastAction = await H2(e2, t.body), n3.lastAction !== R) && !(n3.lastAction instanceof x); )
    if (n3.testResult = await H2(e2, t.test), true !== n3.testResult && false !== n3.testResult)
      throw new a(e2, r.BooleanConditionRequired, t);
  return n3.lastAction instanceof x ? n3.lastAction : O;
}
async function X(e2, t, n3) {
  const r3 = await H2(e2, t.body);
  return n3.lastAction = r3, n3.lastAction === R || n3.lastAction instanceof x ? (n3.testResult = false, n3) : null !== t.update ? (await H2(e2, t.update), n3) : n3;
}
async function $(e2, t, n3) {
  var _a;
  if (null !== t.test) {
    const a2 = await H2(e2, t.test);
    if (true === ((_a = e2.abortSignal) == null ? void 0 : _a.aborted))
      throw new a(e2, r.Cancelled, t);
    if (n3.testResult = a2, false === n3.testResult)
      return n3;
    if (true !== n3.testResult)
      throw new a(e2, r.BooleanConditionRequired, t);
    return X(e2, t, n3);
  }
  return X(e2, t, n3);
}
function ee(e2, t, n3, r3, o2, a2) {
  try {
    $(e2, t, n3).then(() => {
      try {
        true === n3.testResult ? ++a2 > q2 ? (a2 = 0, setTimeout(() => {
          ee(e2, t, n3, r3, o2, a2);
        }, 0)) : ee(e2, t, n3, r3, o2, a2) : n3.lastAction instanceof x ? r3(n3.lastAction) : r3(O);
      } catch (i) {
        o2(i);
      }
    }, (e3) => {
      o2(e3);
    });
  } catch (i) {
    o2(i);
  }
}
function te(e2, t) {
  try {
    return null !== t.init ? H2(e2, t.init).then(() => new Promise((n3, r3) => {
      ee(e2, t, { testResult: true, lastAction: O }, (e3) => {
        n3(e3);
      }, (e3) => {
        r3(e3);
      }, 0);
    })) : new Promise((n3, r3) => {
      ee(e2, t, { testResult: true, lastAction: O }, (e3) => {
        n3(e3);
      }, (e3) => {
        r3(e3);
      }, 0);
    });
  } catch (n3) {
    return Promise.reject(n3);
  }
}
function ne(e2, t, n3, r3, o2, a2, i, l, s4, u2) {
  try {
    if (r3 <= a2)
      return void l(O);
    o2.value = "k" === i ? n3[a2] : a2, H2(e2, t.body).then((c) => {
      try {
        c instanceof x ? l(c) : c === R ? l(O) : ++u2 > q2 ? (u2 = 0, setTimeout(() => {
          ne(e2, t, n3, r3, o2, a2 + 1, i, l, s4, u2);
        }, 0)) : ne(e2, t, n3, r3, o2, a2 + 1, i, l, s4, u2);
      } catch (f3) {
        s4(f3);
      }
    }, (e3) => {
      s4(e3);
    });
  } catch (c) {
    s4(c);
  }
}
function re(e2, t, n3, r3, o2, a2, i, l, s4) {
  try {
    if (n3.length() <= o2)
      return void i(O);
    r3.value = "k" === a2 ? n3.get(o2) : o2, H2(e2, t.body).then((u2) => {
      u2 instanceof x ? i(u2) : u2 === R ? i(O) : ++s4 > q2 ? (s4 = 0, setTimeout(() => {
        re(e2, t, n3, r3, o2 + 1, a2, i, l, s4);
      }, 0)) : re(e2, t, n3, r3, o2 + 1, a2, i, l, s4);
    }, (e3) => {
      l(e3);
    });
  } catch (u2) {
    l(u2);
  }
}
function oe(e2, t, n3, r3, o2, a2) {
  try {
    if (void 0 === a2 && (a2 = "i"), 0 === n3.length)
      return void r3.resolve(O);
    ne(e2, t, n3, n3.length, o2, 0, a2, (e3) => {
      r3.resolve(e3);
    }, (e3) => {
      r3.reject(e3);
    }, 0);
  } catch (i) {
    r3.reject(i);
  }
}
function ae2(e2, t, n3, r3, o2, a2) {
  try {
    if (void 0 === a2 && (a2 = "i"), 0 === n3.length)
      return void r3.resolve(O);
    re(e2, t, n3, o2, 0, a2, (e3) => {
      r3.resolve(e3);
    }, (e3) => {
      r3.reject(e3);
    }, 0);
  } catch (i) {
    r3.reject(i);
  }
}
function ie(e2, t, n3, r3, o2) {
  try {
    oe(e2, t, n3.keys(), r3, o2, "k");
  } catch (a2) {
    r3.reject(a2);
  }
}
function le(e2, t, n3, r3, o2, a2, l, s4) {
  try {
    e2.next().then((u2) => {
      try {
        if (null === u2)
          a2(O);
        else {
          const c = D.createFromGraphicLikeObject(u2.geometry, u2.attributes, r3, t.timeZone);
          c._underlyingGraphic = u2, o2.value = c;
          H2(t, n3.body).then((i) => {
            try {
              i === R ? a2(O) : i instanceof x ? a2(i) : ++s4 > q2 ? (s4 = 0, setTimeout(() => {
                le(e2, t, n3, r3, o2, a2, l, s4);
              }, 0)) : le(e2, t, n3, r3, o2, a2, l, s4);
            } catch (u3) {
              l(u3);
            }
          }, (e3) => {
            l(e3);
          });
        }
      } catch (c) {
        l(c);
      }
    }, (e3) => {
      l(e3);
    });
  } catch (u2) {
    l(u2);
  }
}
async function se(e2, t) {
  return new Promise((a2, i) => {
    H2(e2, t.right).then((l) => {
      try {
        let s4 = null;
        s4 = "VariableDeclaration" === t.left.type ? H2(e2, t.left) : Promise.resolve(), s4.then(() => {
          try {
            let s5 = "";
            if ("VariableDeclaration" === t.left.type) {
              const e3 = t.left.declarations[0].id;
              "Identifier" === e3.type && (s5 = e3.name);
            } else
              "Identifier" === t.left.type && (s5 = t.left.name);
            if (!s5)
              throw new a(e2, r.InvalidIdentifier, t);
            s5 = s5.toLowerCase();
            let u2 = null;
            if (null != e2.localScope && void 0 !== e2.localScope[s5] && (u2 = e2.localScope[s5]), null === u2 && void 0 !== e2.globalScope[s5] && (u2 = e2.globalScope[s5]), null === u2)
              return void i(new a(e2, r.InvalidIdentifier, t));
            U(l) || G(l) ? oe(e2, t, l, { reject: i, resolve: a2 }, u2) : Q(l) ? ae2(e2, t, l, { reject: i, resolve: a2 }, u2) : l instanceof N || H(l) ? ie(e2, t, l, { reject: i, resolve: a2 }, u2) : B(l) ? le(l.iterator(e2.abortSignal), e2, t, l, u2, (e3) => {
              a2(e3);
            }, (e3) => {
              i(e3);
            }, 0) : oe(e2, t, [], { reject: i, resolve: a2 }, u2);
          } catch (s5) {
            i(s5);
          }
        }, i);
      } catch (s4) {
        i(s4);
      }
    }, i);
  });
}
async function ue(e2, t) {
  const a2 = t.argument;
  if ("MemberExpression" === a2.type) {
    const i2 = { t: null }, l2 = await H2(e2, a2.object);
    let s4 = null;
    i2.t = l2, true === a2.computed ? s4 = await H2(e2, a2.property) : "Identifier" === a2.property.type && (s4 = a2.property.name);
    const u2 = i2.t;
    let c;
    if (U(u2)) {
      if (!E(s4))
        throw new a(e2, r.ArrayAccessorMustBeNumber, t);
      if (s4 < 0 && (s4 = u2.length + s4), s4 < 0 || s4 >= u2.length)
        throw new a(e2, r.OutOfBounds, t);
      c = ge(u2[s4]), u2[s4] = "++" === t.operator ? c + 1 : c - 1;
    } else if (u2 instanceof N) {
      if (false === G(s4))
        throw new a(e2, r.KeyAccessorMustBeString, t);
      if (true !== u2.hasField(s4))
        throw new a(e2, r.FieldNotFound, t, { key: s4 });
      c = ge(u2.field(s4)), u2.setField(s4, "++" === t.operator ? c + 1 : c - 1);
    } else if (u2 instanceof _2) {
      if (false === G(s4))
        throw new a(e2, r.ModuleAccessorMustBeString, t);
      if (true !== u2.hasGlobal(s4))
        throw new a(e2, r.ModuleExportNotFound, t);
      c = ge(await u2.global(s4)), u2.setGlobal(s4, "++" === t.operator ? c + 1 : c - 1);
    } else {
      if (!H(u2))
        throw Q(u2) ? new a(e2, r.Immutable, t) : new a(e2, r.InvalidParameter, t);
      if (false === G(s4))
        throw new a(e2, r.KeyAccessorMustBeString, t);
      if (true !== u2.hasField(s4))
        throw new a(e2, r.FieldNotFound, t, { key: s4 });
      c = ge(u2.field(s4)), u2.setField(s4, "++" === t.operator ? c + 1 : c - 1);
    }
    return false === t.prefix ? c : "++" === t.operator ? c + 1 : c - 1;
  }
  const i = "Identifier" === t.argument.type ? t.argument.name.toLowerCase() : "";
  if (!i)
    throw new a(e2, r.InvalidIdentifier, t);
  let l;
  if (null != e2.localScope && void 0 !== e2.localScope[i])
    return l = ge(e2.localScope[i].value), e2.localScope[i] = { value: "++" === t.operator ? l + 1 : l - 1, valueset: true, node: t }, false === t.prefix ? l : "++" === t.operator ? l + 1 : l - 1;
  if (void 0 !== e2.globalScope[i])
    return l = ge(e2.globalScope[i].value), e2.globalScope[i] = { value: "++" === t.operator ? l + 1 : l - 1, valueset: true, node: t }, false === t.prefix ? l : "++" === t.operator ? l + 1 : l - 1;
  throw new a(e2, r.InvalidIdentifier, t);
}
function ce2(e2, t, n3, a2, i) {
  switch (t) {
    case "=":
      return e2 === O ? null : e2;
    case "/=":
      return ge(n3) / ge(e2);
    case "*=":
      return ge(n3) * ge(e2);
    case "-=":
      return ge(n3) - ge(e2);
    case "+=":
      return G(n3) || G(e2) ? me(n3) + me(e2) : ge(n3) + ge(e2);
    case "%=":
      return ge(n3) % ge(e2);
    default:
      throw new a(i, r.UnsupportedOperator, a2);
  }
}
async function fe2(e2, t) {
  const a2 = t.left;
  if ("MemberExpression" === a2.type) {
    const i2 = await H2(e2, a2.object);
    let l = null;
    if (true === a2.computed)
      l = await H2(e2, a2.property);
    else {
      if ("Identifier" !== a2.property.type)
        throw new a(e2, r.InvalidIdentifier, t);
      l = a2.property.name;
    }
    const s4 = await H2(e2, t.right);
    if (U(i2)) {
      if (!E(l))
        throw new a(e2, r.ArrayAccessorMustBeNumber, t);
      if (l < 0 && (l = i2.length + l), l < 0 || l > i2.length)
        throw new a(e2, r.OutOfBounds, t);
      if (l === i2.length) {
        if ("=" !== t.operator)
          throw new a(e2, r.OutOfBounds, t);
        i2[l] = ce2(s4, t.operator, i2[l], t, e2);
      } else
        i2[l] = ce2(s4, t.operator, i2[l], t, e2);
    } else if (i2 instanceof N) {
      if (false === G(l))
        throw new a(e2, r.KeyAccessorMustBeString, t);
      if (true === i2.hasField(l))
        i2.setField(l, ce2(s4, t.operator, i2.field(l), t, e2));
      else {
        if ("=" !== t.operator)
          throw new a(e2, r.FieldNotFound, t, { key: l });
        i2.setField(l, ce2(s4, t.operator, null, t, e2));
      }
    } else if (i2 instanceof _2) {
      if (false === G(l))
        throw new a(e2, r.KeyAccessorMustBeString, t);
      if (true !== i2.hasGlobal(l))
        throw new a(e2, r.ModuleExportNotFound, t);
      i2.setGlobal(l, ce2(s4, t.operator, await i2.global(l), t, e2));
    } else {
      if (!H(i2))
        throw Q(i2) ? new a(e2, r.Immutable, t) : new a(e2, r.InvalidParameter, t);
      if (false === G(l))
        throw new a(e2, r.KeyAccessorMustBeString, t);
      if (true === i2.hasField(l))
        i2.setField(l, ce2(s4, t.operator, i2.field(l), t, e2));
      else {
        if ("=" !== t.operator)
          throw new a(e2, r.FieldNotFound, t, { key: l });
        i2.setField(l, ce2(s4, t.operator, null, t, e2));
      }
    }
    return O;
  }
  const i = a2.name.toLowerCase();
  if (null != e2.localScope && void 0 !== e2.localScope[i]) {
    const n3 = await H2(e2, t.right);
    return e2.localScope[i] = { value: ce2(n3, t.operator, e2.localScope[i].value, t, e2), valueset: true, node: t.right }, O;
  }
  if (void 0 !== e2.globalScope[i]) {
    const n3 = await H2(e2, t.right);
    return e2.globalScope[i] = { value: ce2(n3, t.operator, e2.globalScope[i].value, t, e2), valueset: true, node: t.right }, O;
  }
  throw new a(e2, r.InvalidIdentifier, t);
}
async function pe(e2, t) {
  if ("AssignmentExpression" === t.expression.type)
    return H2(e2, t.expression);
  if ("CallExpression" === t.expression.type) {
    const n4 = await H2(e2, t.expression);
    return n4 === O ? O : new w(n4);
  }
  const n3 = await H2(e2, t.expression);
  return n3 === O ? O : new w(n3);
}
async function we(e2, t) {
  const n3 = await H2(e2, t.test);
  if (true === n3)
    return H2(e2, t.consequent);
  if (false === n3)
    return null !== t.alternate ? H2(e2, t.alternate) : O;
  throw new a(e2, r.BooleanConditionRequired, t);
}
async function de(e2, t) {
  return he(e2, t, 0);
}
async function he(e2, t, n3) {
  if (n3 >= t.body.length)
    return O;
  const r3 = await H2(e2, t.body[n3]);
  return r3 instanceof x || r3 === R || r3 === J || n3 === t.body.length - 1 ? r3 : he(e2, t, n3 + 1);
}
async function me2(e2, t) {
  if (null === t.argument)
    return new x(O);
  const n3 = await H2(e2, t.argument);
  return new x(n3);
}
async function ge2(e2, t) {
  const n3 = t.id.name.toLowerCase();
  return e2.globalScope[n3] = { valueset: true, node: null, value: new V(t, e2) }, O;
}
async function ye(e2, t) {
  var _a, _b;
  const n3 = t.specifiers[0].local.name.toLowerCase(), r3 = e2.libraryResolver.loadLibrary(n3);
  let o2 = null;
  return ((_a = e2.libraryResolver._moduleSingletons) == null ? void 0 : _a.has(r3.uri)) ? o2 = e2.libraryResolver._moduleSingletons.get(r3.uri) : (o2 = new _2(r3), await o2.loadModule(e2), (_b = e2.libraryResolver._moduleSingletons) == null ? void 0 : _b.set(r3.uri, o2)), e2.globalScope[n3] = { value: o2, valueset: true, node: t }, O;
}
async function ve(e2, t) {
  if (await H2(e2, t.declaration), "FunctionDeclaration" === t.declaration.type)
    e2.exports[t.declaration.id.name.toLowerCase()] = "function";
  else if ("VariableDeclaration" === t.declaration.type)
    for (const n3 of t.declaration.declarations)
      e2.exports[n3.id.name.toLowerCase()] = "variable";
  return O;
}
async function be(e2, t, n3) {
  return n3 >= t.declarations.length ? O : (await H2(e2, t.declarations[n3]), n3 === t.declarations.length - 1 || await be(e2, t, n3 + 1), O);
}
async function Se(e2, t) {
  let n3 = null;
  if (n3 = null === t.init ? null : await H2(e2, t.init), null !== e2.localScope) {
    if (n3 === O && (n3 = null), "Identifier" !== t.id.type)
      throw new a(e2, r.InvalidIdentifier, t);
    const a3 = t.id.name.toLowerCase();
    return null != e2.localScope && (e2.localScope[a3] = { value: n3, valueset: true, node: t.init }), O;
  }
  if ("Identifier" !== t.id.type)
    throw new a(e2, r.InvalidIdentifier, t);
  const a2 = t.id.name.toLowerCase();
  return n3 === O && (n3 = null), e2.globalScope[a2] = { value: n3, valueset: true, node: t.init }, O;
}
async function xe(e2, t) {
  const a2 = await H2(e2, t.object);
  if (null === a2)
    throw new a(e2, r.MemberOfNull, t);
  if (false === t.computed) {
    if ("Identifier" === t.property.type) {
      if (a2 instanceof N || H(a2))
        return a2.field(t.property.name);
      if (a2 instanceof n)
        return q(a2, t.property.name, e2, t);
      if (a2 instanceof _2) {
        if (!a2.hasGlobal(t.property.name))
          throw new a(e2, r.InvalidIdentifier, t);
        return a2.global(t.property.name);
      }
      throw new a(e2, r.InvalidMemberAccessKey, t);
    }
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  let i = await H2(e2, t.property);
  if (a2 instanceof N || H(a2)) {
    if (G(i))
      return a2.field(i);
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  if (a2 instanceof _2) {
    if (G(i))
      return a2.global(i);
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  if (a2 instanceof n) {
    if (G(i))
      return q(a2, i, e2, t);
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  if (U(a2)) {
    if (E(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a2.length + i), i >= a2.length || i < 0)
        throw new a(e2, r.OutOfBounds, t);
      return a2[i];
    }
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  if (Q(a2)) {
    if (E(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a2.length() + i), i >= a2.length() || i < 0)
        throw new a(e2, r.OutOfBounds, t);
      return a2.get(i);
    }
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  if (G(a2)) {
    if (E(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a2.length + i), i >= a2.length || i < 0)
        throw new a(e2, r.OutOfBounds, t);
      return a2[i];
    }
    throw new a(e2, r.InvalidMemberAccessKey, t);
  }
  throw new a(e2, r.InvalidMemberAccessKey, t);
}
async function Fe(e2, t) {
  const n3 = await H2(e2, t.argument);
  if (z(n3)) {
    if ("!" === t.operator)
      return !n3;
    if ("-" === t.operator)
      return -1 * ge(n3);
    if ("+" === t.operator)
      return 1 * ge(n3);
    if ("~" === t.operator)
      return ~ge(n3);
    throw new a(e2, r.UnsupportedUnaryOperator, t);
  }
  if ("-" === t.operator)
    return -1 * ge(n3);
  if ("+" === t.operator)
    return 1 * ge(n3);
  if ("~" === t.operator)
    return ~ge(n3);
  throw new a(e2, r.UnsupportedUnaryOperator, t);
}
async function Ie(e2, t) {
  const n3 = [];
  for (let r3 = 0; r3 < t.elements.length; r3++)
    n3.push(await H2(e2, t.elements[r3]));
  for (let a2 = 0; a2 < n3.length; a2++) {
    if (_(n3[a2]))
      throw new a(e2, r.NoFunctionInArray, t);
    n3[a2] === O && (n3[a2] = null);
  }
  return n3;
}
async function Ce(e2, t) {
  const n3 = [];
  n3[0] = await H2(e2, t.left), n3[1] = await H2(e2, t.right);
  const a2 = n3[0], i = n3[1];
  switch (t.operator) {
    case "|":
    case "<<":
    case ">>":
    case ">>>":
    case "^":
    case "&":
      return _e(ge(a2), ge(i), t.operator);
    case "==":
      return ce(a2, i);
    case "!=":
      return !ce(a2, i);
    case "<":
    case ">":
    case "<=":
    case ">=":
      return fe(a2, i, t.operator);
    case "+":
      return G(a2) || G(i) ? me(a2) + me(i) : ge(a2) + ge(i);
    case "-":
      return ge(a2) - ge(i);
    case "*":
      return ge(a2) * ge(i);
    case "/":
      return ge(a2) / ge(i);
    case "%":
      return ge(a2) % ge(i);
    default:
      throw new a(e2, r.UnsupportedOperator, t);
  }
}
async function Ae(e2, t) {
  const n3 = await H2(e2, t.left);
  let a2 = null;
  if (!z(n3))
    throw new a(e2, r.LogicalExpressionOnlyBoolean, t);
  switch (t.operator) {
    case "||":
      if (true === n3)
        return n3;
      if (a2 = await H2(e2, t.right), z(a2))
        return a2;
      throw new a(e2, r.LogicExpressionOrAnd, t);
    case "&&":
      if (false === n3)
        return n3;
      if (a2 = await H2(e2, t.right), z(a2))
        return a2;
      throw new a(e2, r.LogicExpressionOrAnd, t);
    default:
      throw new a(e2, r.LogicExpressionOrAnd, t);
  }
}
async function Re(e2, t) {
  const n3 = t.name.toLowerCase();
  if (null != e2.localScope && void 0 !== e2.localScope[n3]) {
    const t2 = e2.localScope[n3];
    if (true === t2.valueset)
      return t2.value;
    if (null !== t2.d)
      return t2.d;
    t2.d = H2(e2, t2.node);
    const r3 = await t2.d;
    return t2.value = r3, t2.valueset = true, r3;
  }
  if (void 0 !== e2.globalScope[n3]) {
    const t2 = e2.globalScope[n3];
    if (true === t2.valueset)
      return t2.value;
    if (null !== t2.d)
      return t2.d;
    t2.d = H2(e2, t2.node);
    const r3 = await t2.d;
    return t2.value = r3, t2.valueset = true, r3;
  }
  throw new a(e2, r.InvalidIdentifier, t);
}
async function Me(e2, t) {
  if ("MemberExpression" === t.callee.type) {
    const n3 = await H2(e2, t.callee.object);
    if (!(n3 instanceof _2))
      throw new a(e2, r.FunctionNotFound, t);
    const a2 = false === t.callee.computed ? t.callee.property.name : await H2(e2, t.callee.property);
    if (!n3.hasGlobal(a2))
      throw new a(e2, r.FunctionNotFound, t);
    const i = await n3.global(a2);
    if (!_(i))
      throw new a(e2, r.CallNonFunction, t);
    return i.call(e2, t);
  }
  if ("Identifier" !== t.callee.type)
    throw new a(e2, r.FunctionNotFound, t);
  if (null != e2.localScope && void 0 !== e2.localScope[t.callee.name.toLowerCase()]) {
    const n3 = e2.localScope[t.callee.name.toLowerCase()];
    if (_(n3.value))
      return n3.value.call(e2, t);
    throw new a(e2, r.CallNonFunction, t);
  }
  if (void 0 !== e2.globalScope[t.callee.name.toLowerCase()]) {
    const n3 = e2.globalScope[t.callee.name.toLowerCase()];
    if (_(n3.value))
      return n3.value.call(e2, t);
    throw new a(e2, r.CallNonFunction, t);
  }
  throw new a(e2, r.FunctionNotFound, t);
}
async function je(e2, t) {
  return t.value ? t.value.cooked : "";
}
function ke(e2, t, n3) {
  if (_(e2))
    throw new a(t, r.NoFunctionInTemplateLiteral, n3);
  return e2;
}
async function Le(e2, t) {
  const n3 = [];
  for (let a2 = 0; a2 < t.expressions.length; a2++) {
    const r4 = await H2(e2, t.expressions[a2]);
    n3[a2] = me(r4);
  }
  let r3 = "", o2 = 0;
  for (const a2 of t.quasis)
    if (r3 += a2.value ? a2.value.cooked : "", false === a2.tail) {
      r3 += n3[o2] ? ke(n3[o2], e2, t) : "", o2++;
    }
  return r3;
}
var Ee = {};
async function Ne(e2, t, n3, r3) {
  const o2 = await H2(e2, t.arguments[n3]);
  if (ce(o2, r3))
    return H2(e2, t.arguments[n3 + 1]);
  const a2 = t.arguments.length - n3;
  return 1 === a2 ? H2(e2, t.arguments[n3]) : 2 === a2 ? null : 3 === a2 ? H2(e2, t.arguments[n3 + 2]) : Ne(e2, t, n3 + 2, r3);
}
async function Oe(e2, t, n3, a2) {
  if (true === a2)
    return H2(e2, t.arguments[n3 + 1]);
  if (3 === t.arguments.length - n3)
    return H2(e2, t.arguments[n3 + 2]);
  const i = await H2(e2, t.arguments[n3 + 2]);
  if (false === z(i))
    throw new a(e2, r.ModuleExportNotFound, t.arguments[n3 + 2]);
  return Oe(e2, t, n3 + 2, i);
}
async function Be(e2, t, n3, a2) {
  const i = e2.body;
  if (n3.length !== e2.params.length)
    throw new a(t, r.WrongNumberOfParameters, null);
  for (let r3 = 0; r3 < n3.length; r3++) {
    const o2 = e2.params[r3];
    "Identifier" === o2.type && null != t.localScope && (t.localScope[o2.name.toLowerCase()] = { d: null, value: n3[r3], valueset: true, node: null });
  }
  const l = await H2(t, i);
  if (l instanceof x)
    return l.value;
  if (l === R)
    throw new a(t, r.UnexpectedToken, a2);
  if (l === J)
    throw new a(t, r.UnexpectedToken, a2);
  return l instanceof w ? l.value : l;
}
C(Ee, W), Y(Ee, W), M(Ee, W), A(Ee, W), f2(Ee, W), xn({ functions: Ee, compiled: false, signatures: null, evaluateIdentifier: null, mode: "async", standardFunction: W, standardFunctionAsync: z2 }), Ee.iif = async function(e2, t) {
  ae(null === t.arguments ? [] : t.arguments, 3, 3, e2, t);
  const n3 = await H2(e2, t.arguments[0]);
  if (false === z(n3))
    throw new a(e2, r.BooleanConditionRequired, t);
  return H2(e2, n3 ? t.arguments[1] : t.arguments[2]);
}, Ee.defaultvalue = async function(e2, t) {
  ae(null === t.arguments ? [] : t.arguments, 2, 3, e2, t);
  const a2 = await H2(e2, t.arguments[0]);
  if (3 === t.arguments.length) {
    const i = await H2(e2, t.arguments[1]);
    let l = [];
    if (Q(i))
      l = i.toArray();
    else {
      if (!U(i))
        throw new a(e2, r.InvalidParameter, t);
      l = i;
    }
    let s4 = a2;
    if (null === s4)
      return H2(e2, t.arguments[2]);
    for (const r3 of l)
      if (H(s4)) {
        if (false === G(r3))
          return H2(e2, t.arguments[2]);
        if (!s4.hasField(r3))
          return H2(e2, t.arguments[2]);
        s4 = s4.field(r3);
      } else if (s4 instanceof N) {
        if (false === G(r3))
          return H2(e2, t.arguments[2]);
        if (!s4.hasField(r3))
          return H2(e2, t.arguments[2]);
        s4 = s4.field(r3);
      } else if (s4 instanceof n) {
        if (false === G(r3))
          return H2(e2, t.arguments[2]);
        if (s4 = q(s4, r3, null, null, 2), null === s4)
          return H2(e2, t.arguments[2]);
        if ("notfound" === (s4 == null ? void 0 : s4.keystate))
          return H2(e2, t.arguments[2]);
      } else if (U(s4)) {
        if (false === E(r3))
          return H2(e2, t.arguments[2]);
        if (s4 = s4[r3], null == s4)
          return H2(e2, t.arguments[2]);
      } else {
        if (!Q(s4))
          return H2(e2, t.arguments[2]);
        if (false === E(r3))
          return H2(e2, t.arguments[2]);
        if (s4 = s4.get(r3), null == s4)
          return H2(e2, t.arguments[2]);
      }
    return s4;
  }
  return null == a2 || "" === a2 ? H2(e2, t.arguments[1]) : a2;
}, Ee.decode = async function(e2, t) {
  if (t.arguments.length < 2)
    throw new a(e2, r.WrongNumberOfParameters, t);
  if (2 === t.arguments.length)
    return H2(e2, t.arguments[1]);
  if ((t.arguments.length - 1) % 2 == 0)
    throw new a(e2, r.WrongNumberOfParameters, t);
  return Ne(e2, t, 1, await H2(e2, t.arguments[0]));
}, Ee.when = async function(e2, t) {
  if (t.arguments.length < 3)
    throw new a(e2, r.WrongNumberOfParameters, t);
  if (t.arguments.length % 2 == 0)
    throw new a(e2, r.WrongNumberOfParameters, t);
  const n3 = await H2(e2, t.arguments[0]);
  if (false === z(n3))
    throw new a(e2, r.BooleanConditionRequired, t.arguments[0]);
  return Oe(e2, t, 0, n3);
};
var Pe = { fixSpatialReference: Ze, parseArguments: T, standardFunction: W, standardFunctionAsync: z2, evaluateIdentifier: Re };
for (const Te in Ee)
  Ee[Te] = { value: new e(Ee[Te]), valueset: true, node: null };
var Ke = function() {
};
function De(e2, t, r3) {
  const o2 = new Ke();
  null == e2 && (e2 = {}), null == t && (t = {});
  const a2 = new N({ newline: "\n", tab: "	", singlequote: "'", doublequote: '"', forwardslash: "/", backwardslash: "\\" });
  a2.immutable = false, o2.textformatting = { value: a2, valueset: true, node: null };
  for (const n3 in t)
    o2[n3] = { value: new e(t[n3]), native: true, valueset: true, node: null };
  for (const n3 in e2)
    e2[n3] && "esri.Graphic" === e2[n3].declaredClass ? o2[n3] = { value: D.createFromGraphic(e2[n3], r3), valueset: true, node: null } : o2[n3] = { value: e2[n3], valueset: true, node: null };
  return o2;
}
function Ge(e2) {
  console.log(e2);
}
Ke.prototype = Ee, Ke.prototype.infinity = { value: Number.POSITIVE_INFINITY, valueset: true, node: null }, Ke.prototype.pi = { value: Math.PI, valueset: true, node: null };
var Ze2 = Pe;
function Ue(e2) {
  const t = { mode: "async", compiled: false, functions: {}, signatures: [], standardFunction: W, standardFunctionAsync: z2, evaluateIdentifier: Re };
  for (let n3 = 0; n3 < e2.length; n3++)
    e2[n3].registerFunctions(t);
  for (const n3 in t.functions)
    Ee[n3] = { value: new e(t.functions[n3]), valueset: true, node: null }, Ke.prototype[n3] = Ee[n3];
  for (let n3 = 0; n3 < t.signatures.length; n3++)
    o(t.signatures[n3], "async");
}
async function qe(e2, n3) {
  let a2 = n3.spatialReference;
  null == a2 && (a2 = new f({ wkid: 102100 }));
  let i = null;
  e2.usesModules && (i = new s2(/* @__PURE__ */ new Map(), e2.loadedModules));
  const l = De(n3.vars, n3.customfunctions, n3.timeZone), s4 = { spatialReference: a2, services: n3.services, exports: {}, libraryResolver: i, abortSignal: void 0 === n3.abortSignal || null === n3.abortSignal ? { aborted: false } : n3.abortSignal, globalScope: l, console: n3.console ?? Ge, timeZone: n3.timeZone ?? null, lrucache: n3.lrucache, interceptor: n3.interceptor, localScope: null, depthCounter: { depth: 1 } };
  let u2 = await H2(s4, e2);
  if (u2 instanceof x && (u2 = u2.value), u2 instanceof w && (u2 = u2.value), u2 === O && (u2 = null), u2 === R)
    throw new a(s4, r.IllegalResult, null);
  if (u2 === J)
    throw new a(s4, r.IllegalResult, null);
  if (_(u2))
    throw new a(s4, r.IllegalResult, null);
  return u2;
}
Ue([p]);
export {
  qe as executeScript,
  Ue as extend,
  Ze2 as functionHelper
};
//# sourceMappingURL=arcadeAsyncRuntime-6ETHJKEB.js.map
