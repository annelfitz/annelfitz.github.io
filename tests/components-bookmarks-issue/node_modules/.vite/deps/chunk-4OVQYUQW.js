import {
  r
} from "./chunk-BYRUCUF7.js";
import {
  y
} from "./chunk-R4SGP2EA.js";
import {
  a,
  i
} from "./chunk-VIH3KDZO.js";
import {
  n as n2,
  s
} from "./chunk-LA365FE7.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  n
} from "./chunk-BPRXWDBO.js";

// node_modules/@arcgis/core/libs/i3s/enums.js
var n3;
var e;
!function(n5) {
  n5[n5.None = 0] = "None", n5[n5.Int16 = 1] = "Int16", n5[n5.Int32 = 2] = "Int32";
}(n3 || (n3 = {})), function(n5) {
  n5[n5.Replace = 0] = "Replace", n5[n5.Outside = 1] = "Outside", n5[n5.Inside = 2] = "Inside", n5[n5.Finished = 3] = "Finished";
}(e || (e = {}));

// node_modules/@arcgis/core/libs/i3s/I3SModule.js
function e2() {
  return n4 || (n4 = new Promise((t) => import("./i3s-EWQB3TFL.js").then((t2) => t2.i).then(({ default: e3 }) => {
    const n5 = e3({ locateFile: i2, onRuntimeInitialized: () => t(n5) });
    delete n5.then;
  })).catch((t) => {
    throw t;
  })), n4;
}
function i2(e3) {
  return n(`esri/libs/i3s/${e3}`);
}
var n4;

// node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function c(e3) {
  g = await _();
  const t = [e3.geometryBuffer];
  return { result: E(g, e3, t), transferList: t };
}
async function l(e3) {
  var _a;
  g = await _();
  const t = [e3.geometryBuffer], { geometryBuffer: r2 } = e3, o = r2.byteLength, n5 = g._malloc(o), s2 = new Uint8Array(g.HEAPU8.buffer, n5, o);
  s2.set(new Uint8Array(r2));
  const i3 = g.dracoDecompressPointCloudData(n5, s2.byteLength);
  if (g._free(n5), i3.error.length > 0)
    throw new Error(`i3s.wasm: ${i3.error}`);
  const a2 = ((_a = i3.featureIds) == null ? void 0 : _a.length) > 0 ? i3.featureIds.slice() : null, f2 = i3.positions.slice();
  return a2 && t.push(a2.buffer), t.push(f2.buffer), { result: { positions: f2, featureIds: a2 }, transferList: t };
}
async function u(e3) {
  await _(), L(e3);
  const t = { buffer: e3.buffer };
  return { result: t, transferList: [t.buffer] };
}
async function m(e3) {
  await _(), w(e3);
}
async function y2(e3) {
  g = await _(), g.setLegacySchema(e3.context, e3.jsonSchema);
}
async function p(n5) {
  const { localMatrix: s2, origin: i3, positions: a2, vertexSpace: f2, localMode: c2 } = n5, l2 = f.fromJSON(n5.inSpatialReference), u2 = f.fromJSON(n5.outSpatialReference);
  let m2;
  if ("georeferenced" === f2.type && null == f2.origin) {
    const [{ projectBuffer: e3 }, { initializeProjection: t }] = await Promise.all([import("./projectBuffer-V4VDYKLO.js"), import("./projection-VU5SJPUL.js")]);
    await t(l2, u2), m2 = new Float64Array(a2.length), e3(a2, l2, 0, m2, u2, 0, m2.length / 3);
  } else {
    const e3 = "georeferenced" === f2.type ? i.fromJSON(f2) : a.fromJSON(f2), { project: n6 } = await import("./georeference-ZJXK7SAL.js");
    m2 = y(n6({ positions: a2, transform: s2 ? { localMatrix: s2 } : void 0, vertexSpace: e3, inSpatialReference: l2, outSpatialReference: u2, localMode: c2 }));
  }
  const y3 = m2.length, [p2, d2, b2] = i3;
  for (let e3 = 0; e3 < y3; e3 += 3)
    m2[e3] -= p2, m2[e3 + 1] -= d2, m2[e3 + 2] -= b2;
  return { result: { projected: m2, original: a2 }, transferList: [m2.buffer, a2.buffer] };
}
async function d({ normalMatrix: e3, normals: t }) {
  const r2 = new Float32Array(t.length);
  return n2(r2, t, e3), s(r2, r2), { result: { transformed: r2, original: t }, transferList: [r2.buffer, t.buffer] };
}
function b(e3) {
  I(e3);
}
var h;
var g;
function w(e3) {
  if (!g)
    return;
  const t = e3.modifications, r2 = g._malloc(8 * t.length), o = new Float64Array(g.HEAPU8.buffer, r2, t.length);
  for (let n5 = 0; n5 < t.length; ++n5)
    o[n5] = t[n5];
  g.setModifications(e3.context, r2, t.length, e3.isGeodetic), g._free(r2);
}
function E(e3, t, r2) {
  const { context: o, localOrigin: n5, globalTrafo: s2, mbs: a2, obbData: f2, elevationOffset: c2, geometryBuffer: l2, geometryDescriptor: u2, indexToVertexProjector: m2, vertexToRenderProjector: y3 } = t, p2 = e3._malloc(l2.byteLength), d2 = 33, b2 = e3._malloc(d2 * Float64Array.BYTES_PER_ELEMENT), h2 = new Uint8Array(e3.HEAPU8.buffer, p2, l2.byteLength);
  h2.set(new Uint8Array(l2));
  const g2 = new Float64Array(e3.HEAPU8.buffer, b2, d2);
  S(g2, n5);
  let w2 = g2.byteOffset + 3 * g2.BYTES_PER_ELEMENT, E2 = new Float64Array(g2.buffer, w2);
  S(E2, s2), w2 += 16 * g2.BYTES_PER_ELEMENT, E2 = new Float64Array(g2.buffer, w2), S(E2, a2), w2 += 4 * g2.BYTES_PER_ELEMENT, f2 && (E2 = new Float64Array(g2.buffer, w2), S(E2, f2));
  const A2 = u2, L2 = { isDraco: false, isLegacy: false, color: t.layouts.some((e4) => e4.some((e5) => "color" === e5.name)), normal: t.needNormals && t.layouts.some((e4) => e4.some((e5) => "normalCompressed" === e5.name)), uv0: t.layouts.some((e4) => e4.some((e5) => "uv0" === e5.name)), uvRegion: t.layouts.some((e4) => e4.some((e5) => "uvRegion" === e5.name)), featureIndex: A2.featureIndex }, I2 = e3.process(o, !!t.obbData, p2, h2.byteLength, A2, L2, b2, c2, m2, y3, t.normalReferenceFrame);
  if (e3._free(b2), e3._free(p2), I2.error.length > 0)
    throw new Error(`i3s.wasm: ${I2.error}`);
  if (I2.discarded)
    return null;
  const j2 = I2.componentOffsets.length > 0 ? I2.componentOffsets.slice() : null, _2 = I2.featureIds.length > 0 ? I2.featureIds.slice() : null, x2 = I2.anchorIds.length > 0 ? Array.from(I2.anchorIds) : null, M = I2.anchors.length > 0 ? Array.from(I2.anchors) : null, P = I2.interleavedVertedData.slice().buffer, U = I2.indicesType === n3.Int16 ? new Uint16Array(I2.indices.buffer, I2.indices.byteOffset, I2.indices.byteLength / 2).slice() : new Uint32Array(I2.indices.buffer, I2.indices.byteOffset, I2.indices.byteLength / 4).slice(), O = I2.positions.slice(), T = I2.positionIndicesType === n3.Int16 ? new Uint16Array(I2.positionIndices.buffer, I2.positionIndices.byteOffset, I2.positionIndices.byteLength / 2).slice() : new Uint32Array(I2.positionIndices.buffer, I2.positionIndices.byteOffset, I2.positionIndices.byteLength / 4).slice(), R = { layout: t.layouts[0], interleavedVertexData: P, indices: U, hasColors: I2.hasColors, hasModifications: I2.hasModifications, positionData: { data: O, indices: T } };
  return _2 && r2.push(_2.buffer), j2 && r2.push(j2.buffer), r2.push(P), r2.push(U.buffer), r2.push(O.buffer), r2.push(T.buffer), { componentOffsets: j2, featureIds: _2, anchorIds: x2, anchors: M, transformedGeometry: R, obb: I2.obb };
}
function A(e3) {
  return 0 === e3 ? r.Unmodified : 1 === e3 ? r.PotentiallyModified : 2 === e3 ? r.Culled : r.Unknown;
}
function L(e3) {
  if (!g)
    return;
  const { context: t, buffer: r2 } = e3, o = g._malloc(r2.byteLength), n5 = r2.byteLength / Float64Array.BYTES_PER_ELEMENT, s2 = new Float64Array(g.HEAPU8.buffer, o, n5), i3 = new Float64Array(r2);
  s2.set(i3), g.filterOBBs(t, o, n5), i3.set(s2), g._free(o);
}
function I(e3) {
  g && 0 === g.destroy(e3) && (g = null);
}
function S(e3, t) {
  for (let r2 = 0; r2 < t.length; ++r2)
    e3[r2] = t[r2];
}
async function j() {
  g || await _();
}
function _() {
  return g ? Promise.resolve(g) : (h || (h = e2().then((e3) => (g = e3, h = null, g))), h);
}
var x = { transform: (e3, t) => g && E(g, e3, t), destroy: I };

export {
  e,
  c,
  l,
  u,
  m,
  y2 as y,
  p,
  d,
  b,
  w,
  A,
  L,
  j,
  x
};
//# sourceMappingURL=chunk-4OVQYUQW.js.map
