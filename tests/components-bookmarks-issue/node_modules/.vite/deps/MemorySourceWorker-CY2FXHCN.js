import {
  n,
  t
} from "./chunk-IBOAF5ZH.js";
import {
  d,
  f,
  j as j2,
  p as p2,
  y
} from "./chunk-C6M5UQQR.js";
import "./chunk-E5PVY3UF.js";
import {
  m
} from "./chunk-PGOAFABD.js";
import "./chunk-63NZBHDP.js";
import {
  $
} from "./chunk-BNDDKY53.js";
import "./chunk-BECEVYQR.js";
import "./chunk-S243OWEZ.js";
import "./chunk-QYDOVVH7.js";
import "./chunk-YSXT2SWC.js";
import {
  j,
  x
} from "./chunk-DGRFM5OL.js";
import "./chunk-AOAT6HYL.js";
import "./chunk-YH3SFFF7.js";
import "./chunk-JBU54P54.js";
import "./chunk-UQEUYEWU.js";
import "./chunk-5LIYYE75.js";
import {
  a,
  i as i3,
  o
} from "./chunk-ZECONJNT.js";
import "./chunk-UWZ4CRJK.js";
import {
  et,
  nt,
  tt
} from "./chunk-TLTAGTBA.js";
import "./chunk-2QPP5AGU.js";
import "./chunk-2C26DRKK.js";
import "./chunk-M4RFJU4F.js";
import "./chunk-WVKWBQ7C.js";
import "./chunk-RK2U53CD.js";
import "./chunk-YPY24RRU.js";
import "./chunk-O7RKI2QW.js";
import "./chunk-BMB27ANS.js";
import "./chunk-3FOBZIUS.js";
import "./chunk-JKLFCJPR.js";
import {
  Z
} from "./chunk-QNG4TY7L.js";
import "./chunk-RW5QMWE6.js";
import "./chunk-LGMX4E7L.js";
import "./chunk-Y546C2O5.js";
import "./chunk-IYKBAIQE.js";
import "./chunk-BDRVHR2K.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import {
  i as i2
} from "./chunk-6NLHKXEW.js";
import "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import "./chunk-I2X6UR6L.js";
import "./chunk-HV2SFSJW.js";
import "./chunk-SBARCIDP.js";
import "./chunk-LSM34QAB.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-326OSIM5.js";
import "./chunk-HTKSTTSR.js";
import {
  H,
  K
} from "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import {
  p,
  u
} from "./chunk-J7AMTUNG.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-HLDUDRTD.js";
import "./chunk-SLQA5YBV.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import {
  i
} from "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-PWPXYWXV.js";
import "./chunk-545NO6M2.js";
import "./chunk-5LSHHVQ5.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import {
  g2 as g
} from "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-BIAXSBMP.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import "./chunk-NDIXNREV.js";
import "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  s
} from "./chunk-7RBRCL6S.js";
import "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/layers/graphics/sources/support/MemorySourceWorker.js
var R = g;
var q = { xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: g };
var D = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsQueryWithDistance: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsQueryWithResultType: false, supportsSqlExpression: true, supportsDisjointSpatialRel: true } };
function O(e) {
  return u(e) ? null != e.z : !!e.hasZ;
}
function w(e) {
  return u(e) ? null != e.m : !!e.hasM;
}
var S = class {
  constructor() {
    this._queryEngine = null, this._nextObjectId = null;
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = this._createDefaultAttributes = null;
  }
  async load(t2) {
    const i4 = [], { features: s2 } = t2, n2 = this._inferLayerProperties(s2, t2.fields), r = t2.fields || [], a2 = null != t2.hasM ? t2.hasM : !!n2.hasM, p3 = null != t2.hasZ ? t2.hasZ : !!n2.hasZ, h = !t2.spatialReference && !n2.spatialReference, g2 = h ? R : t2.spatialReference || n2.spatialReference, I = h ? q : null, F = t2.geometryType || n2.geometryType, b = !F;
    let O2 = t2.objectIdField || n2.objectIdField, w2 = t2.timeInfo;
    const S2 = new Z(r);
    if (!b && (h && i4.push({ name: "feature-layer:spatial-reference-not-found", message: "Spatial reference not provided or found in features. Defaults to WGS84" }), !F))
      throw new s("feature-layer:missing-property", "geometryType not set and couldn't be inferred from the provided features");
    if (!O2)
      throw new s("feature-layer:missing-property", "objectIdField not set and couldn't be found in the provided fields");
    if (n2.objectIdField && O2 !== n2.objectIdField && (i4.push({ name: "feature-layer:duplicated-oid-field", message: `Provided objectIdField "${O2}" doesn't match the field name "${n2.objectIdField}", found in the provided fields` }), O2 = n2.objectIdField), O2 && !n2.objectIdField) {
      const e = S2.get(O2);
      e ? (O2 = e.name, e.type = "esriFieldTypeOID", e.editable = false, e.nullable = false) : r.unshift({ alias: O2, name: O2, type: "esriFieldTypeOID", editable: false, nullable: false });
    }
    for (const o2 of r) {
      if (null == o2.name && (o2.name = o2.alias), null == o2.alias && (o2.alias = o2.name), !o2.name)
        throw new s("feature-layer:invalid-field-name", "field name is missing", { field: o2 });
      if (o2.name === O2 && (o2.type = "esriFieldTypeOID"), !i2.jsonValues.includes(o2.type))
        throw new s("feature-layer:invalid-field-type", `invalid type for field "${o2.name}"`, { field: o2 });
      null == o2.length && (o2.length = K(o2));
    }
    const v = {};
    for (const e of r)
      if ("esriFieldTypeOID" !== e.type && "esriFieldTypeGlobalID" !== e.type) {
        const t3 = H(e);
        void 0 !== t3 && (v[e.name] = t3);
      }
    if (w2) {
      if (w2.startTimeField) {
        const e = S2.get(w2.startTimeField);
        e ? (w2.startTimeField = e.name, e.type = "esriFieldTypeDate") : w2.startTimeField = null;
      }
      if (w2.endTimeField) {
        const e = S2.get(w2.endTimeField);
        e ? (w2.endTimeField = e.name, e.type = "esriFieldTypeDate") : w2.endTimeField = null;
      }
      if (w2.trackIdField) {
        const e = S2.get(w2.trackIdField);
        e ? w2.trackIdField = e.name : (w2.trackIdField = null, i4.push({ name: "feature-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: w2 } }));
      }
      w2.startTimeField || w2.endTimeField || (i4.push({ name: "feature-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing or invalid", details: { timeInfo: w2 } }), w2 = null);
    }
    const Q = S2.dateFields.length ? { timeZoneIANA: t2.dateFieldsTimeZone ?? i } : null;
    this._createDefaultAttributes = i3(v, O2);
    const M = { warnings: i4, featureErrors: [], layerDefinition: { ...D, drawingInfo: o(F), templates: a(v), extent: I, geometryType: F, objectIdField: O2, fields: r, hasZ: p3, hasM: a2, timeInfo: w2, dateFieldsTimeReference: Q }, assignedObjectIds: {} };
    if (this._queryEngine = new $({ fieldsIndex: Z.fromLayerJSON({ fields: r, timeInfo: w2, dateFieldsTimeReference: Q }), geometryType: F, hasM: a2, hasZ: p3, objectIdField: O2, spatialReference: g2, featureStore: new m({ geometryType: F, hasM: a2, hasZ: p3 }), timeInfo: w2, cacheSpatialQueries: true }), !(s2 == null ? void 0 : s2.length))
      return this._nextObjectId = t, M;
    const Z2 = n(O2, s2);
    return this._nextObjectId = Z2 + 1, await x(s2, g2), this._loadInitialFeatures(M, s2);
  }
  async applyEdits(e) {
    const { spatialReference: t2, geometryType: i4 } = this._queryEngine;
    return await Promise.all([j2(t2, i4), x(e.adds, t2), x(e.updates, t2)]), this._applyEdits(e);
  }
  queryFeatures(e, t2 = {}) {
    return this._queryEngine.executeQuery(e, t2.signal);
  }
  queryFeatureCount(e, t2 = {}) {
    return this._queryEngine.executeQueryForCount(e, t2.signal);
  }
  queryObjectIds(e, t2 = {}) {
    return this._queryEngine.executeQueryForIds(e, t2.signal);
  }
  queryExtent(e, t2 = {}) {
    return this._queryEngine.executeQueryForExtent(e, t2.signal);
  }
  querySnapping(e, t2 = {}) {
    return this._queryEngine.executeQueryForSnapping(e, t2.signal);
  }
  _inferLayerProperties(e, i4) {
    let s2, n2, r = null, a2 = null, o2 = null;
    for (const l of e) {
      const e2 = l.geometry;
      if (null != e2 && (r || (r = p(e2)), a2 || (a2 = e2.spatialReference), null == s2 && (s2 = O(e2)), null == n2 && (n2 = w(e2)), r && a2 && null != s2 && null != n2))
        break;
    }
    if (i4 && i4.length) {
      let e2 = null;
      i4.some((t2) => {
        const i5 = "esriFieldTypeOID" === t2.type, s3 = !t2.type && t2.name && "objectid" === t2.name.toLowerCase();
        return e2 = t2, i5 || s3;
      }) && (o2 = e2.name);
    }
    return { geometryType: r, spatialReference: a2, objectIdField: o2, hasM: n2, hasZ: s2 };
  }
  async _loadInitialFeatures(e, i4) {
    const { geometryType: s2, hasM: r, hasZ: a2, objectIdField: o2, spatialReference: l, featureStore: u2, fieldsIndex: d2 } = this._queryEngine, f2 = [];
    for (const n2 of i4) {
      if (null != n2.uid && (e.assignedObjectIds[n2.uid] = -1), n2.geometry && s2 !== p(n2.geometry)) {
        e.featureErrors.push(f("Incorrect geometry type."));
        continue;
      }
      const i5 = this._createDefaultAttributes(), r2 = p2(d2, i5, n2.attributes, true);
      r2 ? e.featureErrors.push(r2) : (this._assignObjectId(i5, n2.attributes, true), n2.attributes = i5, null != n2.uid && (e.assignedObjectIds[n2.uid] = n2.attributes[o2]), null != n2.geometry && (n2.geometry = j(n2.geometry, n2.geometry.spatialReference, l)), f2.push(n2));
    }
    u2.addMany(et([], f2, s2, a2, r, o2));
    const { fullExtent: c, timeExtent: m2 } = await this._queryEngine.fetchRecomputedExtents();
    if (e.layerDefinition.extent = c, m2) {
      const { start: t2, end: i5 } = m2;
      e.layerDefinition.timeInfo.timeExtent = [t2, i5];
    }
    return e;
  }
  async _applyEdits(e) {
    const { adds: t2, updates: i4, deletes: s2 } = e, n2 = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if ((t2 == null ? void 0 : t2.length) && this._applyAddEdits(n2, t2), (i4 == null ? void 0 : i4.length) && this._applyUpdateEdits(n2, i4), s2 == null ? void 0 : s2.length) {
      for (const e2 of s2)
        n2.deleteResults.push(d(e2));
      this._queryEngine.featureStore.removeManyById(s2);
    }
    const { fullExtent: r, timeExtent: a2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: r, timeExtent: a2, featureEditResults: n2 };
  }
  _applyAddEdits(e, i4) {
    const { addResults: s2 } = e, { geometryType: r, hasM: a2, hasZ: o2, objectIdField: l, spatialReference: u2, featureStore: d2, fieldsIndex: f2 } = this._queryEngine, c = [];
    for (const n2 of i4) {
      if (n2.geometry && r !== p(n2.geometry)) {
        s2.push(f("Incorrect geometry type."));
        continue;
      }
      const i5 = this._createDefaultAttributes(), a3 = p2(f2, i5, n2.attributes);
      if (a3)
        s2.push(a3);
      else {
        if (this._assignObjectId(i5, n2.attributes), n2.attributes = i5, null != n2.uid) {
          const t2 = n2.attributes[l];
          e.uidToObjectId[n2.uid] = t2;
        }
        if (null != n2.geometry) {
          const e2 = n2.geometry.spatialReference ?? u2;
          n2.geometry = j(y(n2.geometry, e2), e2, u2);
        }
        c.push(n2), s2.push(d(n2.attributes[l]));
      }
    }
    d2.addMany(et([], c, r, o2, a2, l));
  }
  _applyUpdateEdits({ updateResults: e }, i4) {
    const { geometryType: s2, hasM: n2, hasZ: o2, objectIdField: l, spatialReference: u2, featureStore: d2, fieldsIndex: f2 } = this._queryEngine;
    for (const c of i4) {
      const { attributes: i5, geometry: m2 } = c, y2 = i5 == null ? void 0 : i5[l];
      if (null == y2) {
        e.push(f(`Identifier field ${l} missing`));
        continue;
      }
      if (!d2.has(y2)) {
        e.push(f(`Feature with object id ${y2} missing`));
        continue;
      }
      const h = nt(d2.getFeature(y2), s2, o2, n2);
      if (null != m2) {
        if (s2 !== p(m2)) {
          e.push(f("Incorrect geometry type."));
          continue;
        }
        const i6 = m2.spatialReference ?? u2;
        h.geometry = j(y(m2, i6), i6, u2);
      }
      if (i5) {
        const t2 = p2(f2, h.attributes, i5);
        if (t2) {
          e.push(t2);
          continue;
        }
      }
      d2.add(tt(h, s2, o2, n2, l)), e.push(d(y2));
    }
  }
  _assignObjectId(e, t2, i4 = false) {
    const s2 = this._queryEngine.objectIdField;
    i4 && t2 && isFinite(t2[s2]) ? e[s2] = t2[s2] : e[s2] = this._nextObjectId++;
  }
};
export {
  S as default
};
//# sourceMappingURL=MemorySourceWorker-CY2FXHCN.js.map
