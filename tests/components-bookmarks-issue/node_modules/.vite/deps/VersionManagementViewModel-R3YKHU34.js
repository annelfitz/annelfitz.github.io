import {
  t as t2
} from "./chunk-ICMKKNJO.js";
import {
  h as h3
} from "./chunk-I4SHZ6P5.js";
import {
  I,
  b,
  g,
  h as h2,
  m as m2,
  p as p2
} from "./chunk-QJHIIUXI.js";
import {
  n as n3,
  r as r2
} from "./chunk-TOKUWZQG.js";
import {
  i as i3
} from "./chunk-2QCWKZIQ.js";
import {
  D,
  M,
  V
} from "./chunk-KMK4SMGY.js";
import "./chunk-YUUTEPX2.js";
import "./chunk-G7YFDDME.js";
import "./chunk-PCKG3UTS.js";
import "./chunk-3VMVD66K.js";
import {
  c,
  c2,
  h,
  i as i2,
  l,
  n as n2,
  o as o2,
  s as s4,
  t
} from "./chunk-OHE3HDFF.js";
import "./chunk-QYC3GV65.js";
import "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import {
  f as f2,
  i,
  s as s3
} from "./chunk-I2X6UR6L.js";
import {
  s as s2
} from "./chunk-QX66UTIR.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import {
  p
} from "./chunk-VTH4DAHQ.js";
import "./chunk-HLDUDRTD.js";
import {
  Q
} from "./chunk-UMXV3EBO.js";
import {
  m
} from "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-TPLOIZC7.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import {
  o
} from "./chunk-YOPMY6TS.js";
import {
  r
} from "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import {
  U,
  qt,
  x
} from "./chunk-SAYWXQVM.js";
import {
  u2 as u
} from "./chunk-SBL4URUW.js";
import {
  P,
  d
} from "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a2
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import "./chunk-JGDJR5EV.js";
import "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  a,
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";
import {
  k
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/rest/featureService/FeatureService.js
function I2(e2) {
  return { data: M2(e2), sync: x2(e2), operations: D2(e2.capabilities, e2), query: N(e2), editing: U2(e2) };
}
function M2(e2) {
  return { isDataVersioned: n3(e2, "hasVersionedData", false) };
}
function D2(e2, t5) {
  const s6 = e2 ? e2.toLowerCase().split(",").map((e3) => e3.trim()) : [], r3 = s6.includes("query"), i4 = s6.includes("editing") && !t5.datesInUnknownTimezone;
  let a3 = i4 && s6.includes("create"), o3 = i4 && s6.includes("delete"), n4 = i4 && s6.includes("update");
  return i4 && !(a3 || o3 || n4) && (a3 = o3 = n4 = true), { supportsAdd: a3, supportsDelete: o3, supportsEditing: i4, supportsChangeTracking: s6.includes("changetracking"), supportsQuery: r3, supportsQueryDataElements: n3(t5, "supportsQueryDataElements", false), supportsQueryDomains: n3(t5, "supportsQueryDomains", false), supportsQueryContingentValues: n3(t5, "supportsQueryContingentValues", false), supportsSync: s6.includes("sync"), supportsUpdate: n4 };
}
function N(e2) {
  return { maxRecordCountFactor: r2(e2, "maxRecordCountFactor", void 0), maxRecordCount: r2(e2, "maxRecordCount", void 0) };
}
function U2(e2) {
  const t5 = e2 == null ? void 0 : e2.advancedEditingCapabilities;
  return { supportsGlobalId: n3(e2, "supportsApplyEditsWithGlobalIds", false), supportsReturnServiceEditsInSourceSpatialReference: n3(t5, "supportsReturnServiceEditsInSourceSR", false), supportsSplit: n3(t5, "supportsSplit", false), supportsAsyncApplyEdits: n3(t5, "supportsAsyncApplyEdits", false) };
}
function x2(e2) {
  const t5 = e2 == null ? void 0 : e2.syncCapabilities, s6 = t5 == null ? void 0 : t5.supportedSyncDataOptions;
  return { supportsAsync: n3(t5, "supportsAsync", false), supportedSyncDataOptions: { annotations: !(1 & ~s6), dimensions: !(2 & ~s6), contingentValues: !(4 & ~s6), attributeRules: !(8 & ~s6), utilityNetworkSystem: !(16 & ~s6), annotationFullModel: !(32 & ~s6), include3DObjects: !(64 & ~s6), utilityNetworkMissingLayers: !(128 & ~s6), preserveTrueCurves: !(256 & ~s6) } };
}
var J = class extends u(s2(m)) {
  constructor(e2) {
    super(e2), this.url = null, this.sourceJSON = null, this.userTypeExtensions = [], this.layerInfos = [], this.tableInfos = [], this.capabilities = null;
  }
  read(e2, t5) {
    this.sourceJSON = e2, super.read(e2, t5);
  }
  get utilityNetworkUrl() {
    for (const e2 of this.sourceJSON.layers)
      if ("Utility Network Layer" === e2.type)
        return `${this.url}/${e2.id}`;
    return null;
  }
  get versionManagementServiceUrl() {
    return this.sourceJSON.hasBranchVersionedData ? this.url.replace(/\/FeatureServer/i, "/VersionManagementServer") : null;
  }
  readCapabilities(e2, t5) {
    return I2(t5);
  }
  load(e2) {
    return this.addResolvingPromise(this._fetchService(this.url, e2)), Promise.resolve(this);
  }
  async applyEdits(e2, t5) {
    let s6 = null;
    try {
      const { results: r3, edits: i4, editedFeatures: a3 } = await this._internalApplyEdits(e2, t5), n4 = (e3) => e3.filter((e4) => !e4.error).map(a);
      let u2 = 0;
      return r3.map((e3) => {
        s6 = h(this.url, e3.id, t5 == null ? void 0 : t5.gdbVersion, true);
        const r4 = { edits: i4[u2], addedFeatures: n4(e3.addFeatureResults), updatedFeatures: n4(e3.updateFeatureResults), deletedFeatures: n4(e3.deleteFeatureResults), addedAttachments: n4(e3.addAttachmentResults), updatedAttachments: n4(e3.updateAttachmentResults), deletedAttachments: n4(e3.deleteAttachmentResults), exceededTransferLimit: false, historicMoment: e3.editMoment ? new Date(e3.editMoment) : null };
        u2 += 1, a3.length > 0 && (r4.editedFeatures = a3), s6.resolve(r4), s6 = null;
      }), r3;
    } catch (r3) {
      throw s6 && s6.reject(r3), r3;
    }
  }
  async _internalApplyEdits(e2, r3) {
    const i4 = (r3 == null ? void 0 : r3.globalIdUsed) ?? false, a3 = f.fromJSON(this.sourceJSON.spatialReference), { edits: o3, options: n4 } = await this._processApplyEditsParams(e2, r3), u2 = await Promise.all(o3.map(async (e3) => {
      var _a, _b;
      const t5 = ((_a = e3.addFeatures) == null ? void 0 : _a.map((e4) => p2({ spatialReference: a3 }, e4, null))) ?? [], r4 = (await Promise.all(t5)).filter(k), o4 = ((_b = e3.updateFeatures) == null ? void 0 : _b.map((e4) => p2({ spatialReference: a3 }, e4, null))) ?? [], n5 = (await Promise.all(o4)).filter(k), u3 = g(e3.identifierFields, e3.deleteFeatures, i4);
      i3(r4, n5, a3);
      const d3 = await m2(e3.identifierFields, e3);
      return { id: e3.id, adds: r4, updates: n5, deletes: u3, attachments: d3 };
    })), d2 = { gdbVersion: n4 == null ? void 0 : n4.gdbVersion, rollbackOnFailure: true, useGlobalIds: i4, returnEditMoment: true, honorSequenceOfEdits: n4 == null ? void 0 : n4.honorSequenceOfEdits, usePreviousEditMoment: n4 == null ? void 0 : n4.usePreviousEditMoment, returnServiceEditsInSourceSR: n4 == null ? void 0 : n4.returnServiceEditsInSourceSR, returnServiceEditsOption: "originalAndCurrentFeatures", async: false };
    await i2(this.url, r3 == null ? void 0 : r3.gdbVersion, true);
    const l3 = c(this.url, (r3 == null ? void 0 : r3.gdbVersion) || null);
    d2.edits = JSON.stringify(u2);
    const h4 = f2(this.url), S3 = i(h4.query, { query: s3({ ...d2, f: "json" }), method: "post" });
    let v2;
    l3 && (S3.authMode = "immediate", S3.query.sessionId = t);
    try {
      v2 = await U(this.url + "/applyEdits", S3);
    } catch (g2) {
      if (!h2(g2))
        throw g2;
      S3.authMode = "immediate", v2 = await U(this.url + "/applyEdits", S3);
    }
    return { ...q(v2), edits: o3 };
  }
  async _processApplyEditsParams(e2, t5) {
    const s6 = { ...t5 };
    return { edits: await Promise.all(e2.map(async (e3) => {
      const s7 = this.capabilities, i4 = e3 && (e3.addFeatures || e3.updateFeatures || e3.deleteFeatures), a3 = e3 && (e3.addAttachments || e3.updateAttachments || e3.deleteAttachments);
      if (M(e3, s7, t5, !!i4, !!a3, "feature-service"), !s7.data.isDataVersioned && (t5 == null ? void 0 : t5.gdbVersion))
        throw new s("feature-service:invalid-parameter", "'gdbVersion' is applicable only if the layer supports versioned data. See: 'capabilities.data.isVersioned'");
      const o3 = V(e3, s7, "feature-service");
      return { ...await D(o3), id: e3.id, identifierFields: e3.identifierFields };
    })), options: s6 };
  }
  async _fetchService(e2, s6) {
    if (this.sourceJSON)
      return void this.read(this.sourceJSON, { origin: "service", url: f2(e2) });
    const r3 = await U(e2, { responseType: "json", query: { f: "json" }, ...s6 });
    this.read(r3.data);
  }
};
function q(e2) {
  const t5 = e2.data, s6 = [];
  return { results: t5.map((e3) => {
    const t6 = { addResults: e3.addResults ?? [], updateResults: e3.updateResults ?? [], deleteResults: e3.deleteResults ?? [], attachments: e3.attachments, editMoment: e3.editMoment }, r3 = b(t6), i4 = e3.editedFeatures, a3 = (i4 == null ? void 0 : i4.spatialReference) ? new f({ wkid: i4 == null ? void 0 : i4.spatialReference.wkid, wkt: i4 == null ? void 0 : i4.spatialReference.wkt, latestWkid: i4 == null ? void 0 : i4.spatialReference.latestWkid, latestVcsWkid: i4 == null ? void 0 : i4.spatialReference.latestVcsWkid, vcsWkid: i4 == null ? void 0 : i4.spatialReference.vcsWkid }) : null, o3 = i4 ? I(i4, a3) : null;
    return o3 && s6.push({ layerId: e3.id, editedFeatures: o3 }), { id: e3.id, editedFeatures: o3, ...r3 };
  }), editedFeatures: s6 };
}
e([y()], J.prototype, "url", void 0), e([y()], J.prototype, "sourceJSON", void 0), e([y({ readOnly: true })], J.prototype, "utilityNetworkUrl", null), e([y({ readOnly: true })], J.prototype, "versionManagementServiceUrl", null), e([y()], J.prototype, "userTypeExtensions", void 0), e([y({ json: { read: { source: "layers" } } })], J.prototype, "layerInfos", void 0), e([y({ json: { read: { source: "tables" } } })], J.prototype, "tableInfos", void 0), e([y({ readOnly: true, json: { read: { source: ["hasVersionedData", "capabilities", "supportsQueryDataElements", "supportsQueryDomains", "supportsQueryContingentValues", "maxRecordCountFactor", "maxRecordCount", "advancedEditingCapabilities", "supportsApplyEditsWithGlobalIds", "syncCapabilities", "datesInUnknownTimezone"] } } })], J.prototype, "capabilities", void 0), e([o("service", "capabilities")], J.prototype, "readCapabilities", null), J = e([a2("esri.rest.featureService.FeatureService")], J);
var P2 = J;

// node_modules/@arcgis/core/rest/featureService/utils.js
var t3 = (s6, o3) => {
  for (const u2 of s6)
    if ("feature" === u2.type || "subtype-group" === u2.type) {
      if (!u2.url)
        continue;
      const t5 = p(u2.url).url.path, s7 = o3.get(t5);
      if (s7)
        s7.layers.push(u2);
      else {
        const e2 = new P2({ url: t5 }), s8 = [u2];
        o3.set(t5, { featureService: e2, layers: s8 });
      }
    } else
      "group" === u2.type && t3(u2.layers, o3);
};
function s5(e2) {
  const r3 = /* @__PURE__ */ new Map();
  return t3(e2, r3), r3;
}

// node_modules/@arcgis/core/versionManagement/support/EditMomentStack.js
var t4 = class {
  constructor(t5) {
    this.moments = [], this.forwardMoments = [], this.moments.push(t5);
  }
  push(t5) {
    return this.forwardMoments.length, this.moments.push(t5);
  }
  pop() {
    if (!(this.forwardMoments.length > 0))
      return this.moments.pop();
  }
  undo() {
    if (!this.canUndo())
      return;
    const t5 = this.moments.pop();
    return this.forwardMoments.push(t5), t5;
  }
  peek() {
    return this.moments.at(-1);
  }
  canUndo() {
    return this.moments.length > 1;
  }
  canRedo() {
    return this.hasForwardEdits();
  }
  redo() {
    if (!this.canRedo())
      return;
    const t5 = this.forwardMoments.pop();
    return this.moments.push(t5), t5;
  }
  size() {
    return this.moments.length + this.forwardMoments.length;
  }
  hasForwardEdits() {
    return this.forwardMoments.length > 0;
  }
  clearForwardEdits() {
    this.forwardMoments = [];
  }
};

// node_modules/@arcgis/core/versionManagement/VersionManagementService.js
var y2 = class extends u(m) {
  constructor(e2) {
    super(e2), this.url = null, this.sourceJSON = null, this.name = null, this.defaultVersionIdentifier = null, this.capabilities = null, this._applyEditsHandler = (e3) => {
      const { serviceUrl: t5, gdbVersion: r3, result: i4 } = e3;
      t5 === this._featureServiceUrl && i4.then((e4) => {
        const t6 = e4.historicMoment;
        t6 && this._addMomentToVersionItem(r3, t6);
      });
    };
  }
  initialize() {
    this.url = qt(this.url), this._featureServiceUrl = this.url.replace(/\/VersionManagementServer/i, "/FeatureServer"), o2.has(this.url) || o2.set(this.url, /* @__PURE__ */ new Map());
    const e2 = (s4.get(this.url) ?? 0) + 1;
    s4.set(this.url, e2), this.when().then(() => this.addHandles(l(this._applyEditsHandler)), () => {
    });
  }
  destroy() {
    const e2 = (s4.get(this.url) ?? 1) - 1;
    s4.set(this.url, e2), 0 === e2 && o2.delete(this.url), n2.delete(this._featureServiceUrl);
  }
  read(e2, t5) {
    this.sourceJSON = e2, super.read(e2, t5);
  }
  readDefaultVersionIdentifier(e2, t5) {
    return { name: t5.defaultVersionName, guid: t5.defaultVersionGuid };
  }
  writeDefaultVersionIdentifier(e2, t5) {
    t5.defaultVersionName = e2.name, t5.defaultVersionGuid = e2.guid;
  }
  load(e2) {
    return this.addResolvingPromise(this._fetchService(this.url, e2)), Promise.resolve(this);
  }
  async createVersion(e2) {
    const [{ createVersion: t5 }, { default: r3 }] = await Promise.all([import("./createVersion-AWDK6UNX.js"), import("./CreateVersionParameters-NLGBPO2H.js")]), i4 = r3.from(e2);
    return t5(this.url, i4);
  }
  async deleteVersion(e2) {
    var _a;
    const [{ deleteVersion: t5 }, { default: r3 }] = await Promise.all([import("./deleteVersion-ABZIDGQL.js"), import("./DeleteVersionParameters-JOQBULSI.js")]);
    let i4;
    e2.guid && ((_a = o2.get(this.url)) == null ? void 0 : _a.has(e2.guid)) && (i4 = t ?? void 0);
    const s6 = new r3({ versionName: e2.name, sessionId: i4 });
    return t5(this.url, s6);
  }
  async getVersionInfoExtended(e2) {
    const { getVersion: t5 } = await import("./getVersion-DM3GTM6N.js");
    return t5(this.url, e2.guid);
  }
  async getVersionInfos(e2 = {}) {
    const [{ getVersionInfos: t5 }, { default: r3 }] = await Promise.all([import("./getVersionInfos-N437XCRI.js"), import("./GetVersionInfosParameters-ZZBEELRQ.js")]), i4 = r3.from(e2);
    return t5(this.url, i4);
  }
  async reconcile(e2, t5 = {}) {
    const [{ reconcile: r3 }, { default: i4 }] = await Promise.all([import("./reconcile-TUZM6A66.js"), import("./ReconcileParameters-I6MOHHPX.js")]), s6 = i4.from(t5);
    return s6.sessionId = t, r3(this.url, e2.guid, s6);
  }
  async post(e2) {
    const [{ post: t5 }, { default: r3 }] = await Promise.all([import("./post-YPBRUGLX.js"), import("./PostParameters-PKN7VXRW.js")]), i4 = r3.from({ sessionId: t });
    return t5(this.url, e2.guid, i4);
  }
  async alterVersion(e2, t5) {
    const [{ alterVersion: r3 }, { default: i4 }] = await Promise.all([import("./alterVersion-BDMJGXLK.js"), import("./AlterVersionParameters-6A2DWIWH.js")]), s6 = i4.from(t5);
    return r3(this.url, e2.guid, s6);
  }
  async startReading(e2) {
    const { startReading: t5 } = await import("./startReading-QNHDXREX.js"), r3 = await t5(this.url, e2.guid, t);
    if (r3) {
      const t6 = await this.getVersionInfoExtended(e2), r4 = new Date(t6.modifiedDate), i4 = { name: t6.versionIdentifier.name, moment: r4, lockType: "read" };
      this._addOrUpdateItem(e2.guid, i4), c2(this._featureServiceUrl, null, e2.name, r4);
    }
    return r3;
  }
  async stopReading(e2) {
    var _a;
    const { stopReading: t5 } = await import("./stopReading-NWLDGSTE.js"), r3 = await t5(this.url, e2.guid, t);
    return r3 && ((_a = o2.get(this.url)) == null ? void 0 : _a.delete(e2.guid), c2(this._featureServiceUrl, null, e2.name, null)), r3;
  }
  async startEditing(e2) {
    const { startEditing: t5 } = await import("./startEditing-KZVYCCDS.js"), r3 = await t5(this.url, e2.guid, t);
    if (r3) {
      const t6 = await this.getVersionInfoExtended(e2), r4 = new Date(t6.modifiedDate), i4 = new t4(r4), s6 = { name: e2.name, moment: r4, lockType: "edit", stack: i4 };
      this._addOrUpdateItem(e2.guid, s6), c2(this._featureServiceUrl, null, e2.name, r4);
    }
    return r3;
  }
  async stopEditing(e2, t5) {
    var _a, _b;
    if (t5) {
      const t6 = (_a = o2.get(this.url)) == null ? void 0 : _a.get(e2.guid);
      if ((_b = t6 == null ? void 0 : t6.stack) == null ? void 0 : _b.canRedo()) {
        const [{ deleteForwardEdits: r4 }, { default: i5 }] = await Promise.all([import("./deleteForwardEdits-KTYPUSX2.js"), import("./DeleteForwardEditsParameters-WC4SV7O4.js")]);
        if (!await r4(this.url, e2.guid, new i5({ sessionId: t, moment: t6.moment })))
          return false;
      }
    }
    const { stopEditing: r3 } = await import("./stopEditing-GEK3LXUS.js"), i4 = await r3(this.url, e2.guid, t, t5);
    if (i4) {
      const t6 = await this.getVersionInfoExtended(e2), r4 = new Date(t6.modifiedDate);
      this._addOrUpdateItem(e2.guid, { name: e2.name, moment: r4, lockType: "read", editMomentStack: void 0 }), c2(this._featureServiceUrl, null, e2.name, r4);
    }
    return i4;
  }
  getLockType(e2) {
    var _a, _b;
    const t5 = (_b = (_a = o2.get(this.url)) == null ? void 0 : _a.get(e2.guid)) == null ? void 0 : _b.lockType;
    return t5 ?? "none";
  }
  changeVersionInternal(e2, t5, r3) {
    let i4 = null, s6 = null, n4 = null, o3 = null;
    const a3 = (e3) => !e3 || e3 === this.defaultVersionIdentifier.name, l3 = (e3) => {
      var _a, _b;
      const t6 = (_b = (_a = o2) == null ? void 0 : _a.get(this.url)) == null ? void 0 : _b.get(e3.guid);
      n4 = e3.name, o3 = (t6 == null ? void 0 : t6.moment) ?? null;
    }, u2 = (e3, t6) => !e3 && !t6 || !(!e3 || !t6) && e3.toISOString() === t6.toISOString();
    if ("name" in t5) {
      if ("none" !== this.getLockType(t5))
        return false;
      i4 = t5.name, s6 = null, "name" in r3 ? l3(r3) : (n4 = this.defaultVersionIdentifier.name, o3 = r3);
    } else
      i4 = this.defaultVersionIdentifier.name, s6 = t5, "name" in r3 ? l3(r3) : (n4 = this.defaultVersionIdentifier.name, o3 = r3);
    return (a3(i4) && a3(e2.gdbVersion) && u2(e2.historicMoment, s6) || i4 === e2.gdbVersion && u2(e2.historicMoment, s6)) && (e2.gdbVersion = n4, e2.historicMoment = o3), true;
  }
  async changeVersion(e2, t5, i4) {
    if ("name" in i4 && !await this.getVersionInfoExtended(i4))
      throw new s("version-management-service:invalid-version", "version does not exist");
    if ("networkServiceUrl" in e2) {
      if (this._featureServiceUrl.toLowerCase() === e2.featureServiceUrl.toLowerCase())
        return this.changeVersionInternal(e2, t5, i4);
    } else {
      let r3;
      "layers" in e2 ? (r3 = e2.allTables.concat(e2.allLayers), e2.utilityNetworks && e2.utilityNetworks.forEach((e3) => {
        this._featureServiceUrl.toLowerCase() === e3.featureServiceUrl.toLowerCase() && this.changeVersionInternal(e3, t5, i4);
      })) : r3 = e2;
      for (const e3 of r3)
        if ("feature" === e3.type || "subtype-group" === e3.type) {
          const r4 = /^(.*\/FeatureServer)\/\d+$/, s6 = e3.url.replace(r4, "$1");
          if (this._featureServiceUrl.toLowerCase() === s6.toLowerCase() && !this.changeVersionInternal(e3, t5, i4))
            return false;
        } else if ("group" === e3.type) {
          const r4 = e3.allTables.concat(e3.allLayers);
          for (const e4 of r4)
            if ("feature" === e4.type || "subtype-group" === e4.type) {
              const r5 = /^(.*\/FeatureServer)\/\d+$/, s6 = e4.url.replace(r5, "$1");
              if (this._featureServiceUrl.toLowerCase() === s6.toLowerCase() && !this.changeVersionInternal(e4, t5, i4))
                return false;
            }
        }
    }
    return true;
  }
  async getVersionIdentifierFromName(e2) {
    var _a;
    try {
      const t5 = await this.getVersionInfos({ includeHidden: true });
      return ((_a = t5.find((t6) => t6.versionIdentifier.name === e2)) == null ? void 0 : _a.versionIdentifier) || null;
    } catch {
      return null;
    }
  }
  async getVersionIdentifierFromGuid(e2) {
    const { getVersion: t5 } = await import("./getVersion-DM3GTM6N.js");
    try {
      return (await t5(this.url, e2)).versionIdentifier;
    } catch {
      return null;
    }
  }
  canUndo(e2) {
    var _a, _b;
    const t5 = (_a = o2.get(this.url)) == null ? void 0 : _a.get(e2.guid);
    return !!((_b = t5 == null ? void 0 : t5.stack) == null ? void 0 : _b.canUndo());
  }
  canRedo(e2) {
    var _a, _b;
    const t5 = (_a = o2.get(this.url)) == null ? void 0 : _a.get(e2.guid);
    return !!((_b = t5 == null ? void 0 : t5.stack) == null ? void 0 : _b.canRedo());
  }
  undo(e2) {
    var _a, _b, _c;
    const t5 = (_a = o2.get(this.url)) == null ? void 0 : _a.get(e2.guid), r3 = ((_b = t5 == null ? void 0 : t5.stack) == null ? void 0 : _b.undo()) || void 0;
    if (t5 && r3) {
      const r4 = t5.stack.peek();
      c2(this._featureServiceUrl, null, e2.name, r4), (_c = o2.get(this.url)) == null ? void 0 : _c.set(e2.guid, { ...t5, moment: r4 });
    }
  }
  redo(e2) {
    var _a, _b, _c;
    const t5 = (_a = o2.get(this.url)) == null ? void 0 : _a.get(e2.guid), r3 = ((_b = t5 == null ? void 0 : t5.stack) == null ? void 0 : _b.redo()) || void 0;
    t5 && r3 && (c2(this._featureServiceUrl, null, e2.name, r3), (_c = o2.get(this.url)) == null ? void 0 : _c.set(e2.guid, { ...t5, moment: r3 }));
  }
  _addMomentToVersionItem(e2, t5) {
    const r3 = o2.get(this.url);
    if (r3)
      for (const [i4, s6] of r3) {
        s6.name === e2 && this._addToStack(i4, t5);
      }
  }
  _addToStack(e2, t5) {
    const r3 = o2.get(this.url), i4 = r3 == null ? void 0 : r3.get(e2);
    return !!(i4 == null ? void 0 : i4.stack) && (w(i4.stack.peek(), t5) && i4.stack.push(t5), r3.set(e2, { ...i4, moment: t5 }), true);
  }
  _addOrUpdateItem(e2, t5) {
    const r3 = o2.get(this.url), i4 = r3 == null ? void 0 : r3.get(e2);
    return i4 ? (r3.set(e2, { ...i4, ...t5 }), true) : !(!t5.name || !t5.lockType) && (r3 == null ? void 0 : r3.set(e2, { ...t5, lockType: t5.lockType }), true);
  }
  async _fetchService(e2, r3) {
    if (this.sourceJSON) {
      this.read(this.sourceJSON, { origin: "service", url: f2(e2) });
      const t5 = new x(this.url).host;
      return void n2.set(t5, this.defaultVersionIdentifier.name);
    }
    const i4 = await U(e2, { responseType: "json", query: { f: "json" }, ...r3 });
    this.read(i4.data);
  }
};
function w(e2, t5) {
  if (e2) {
    return e2.getTime() < t5.getTime();
  }
  return true;
}
e([y()], y2.prototype, "url", void 0), e([y()], y2.prototype, "sourceJSON", void 0), e([y({ type: String, json: { write: true } })], y2.prototype, "name", void 0), e([y({ json: { write: { target: { defaultVersionName: { type: String }, defaultVersionGuid: { type: String } } }, read: { source: ["defaultVersionName", "defaultVersionGuid"] } } })], y2.prototype, "defaultVersionIdentifier", void 0), e([o("defaultVersionIdentifier", ["defaultVersionName", "defaultVersionGuid"])], y2.prototype, "readDefaultVersionIdentifier", null), e([r("defaultVersionIdentifier", { defaultVersionName: { type: String }, defaultVersionGuid: { type: String } })], y2.prototype, "writeDefaultVersionIdentifier", null), e([y({ json: { write: true } })], y2.prototype, "capabilities", void 0), y2 = e([a2("esri.versionManagement.VersionManagementService")], y2);
var S2 = y2;

// node_modules/@arcgis/core/widgets/VersionManagement/VersionManagementViewModel.js
var l2 = class extends S {
  constructor(e2) {
    super(e2), this._initialValidationsFinished = false, this._portalLookup = /* @__PURE__ */ new Map(), this._updatingHandles = new h3(), this._validConstructProperties = true, this.advancedEditingUserTypeExtensionLookup = /* @__PURE__ */ new Map(), this.executionError = void 0, this.featureServiceLookup = /* @__PURE__ */ new Map(), this.loadError = void 0, this.serverVersionLookup = /* @__PURE__ */ new Map(), this.serviceNameLookup = /* @__PURE__ */ new Map(), this.userLookup = /* @__PURE__ */ new Map(), this.versionIdentifierLookup = /* @__PURE__ */ new Map(), this.versionInfoLookup = /* @__PURE__ */ new Map(), this.versionManagementServiceLookup = /* @__PURE__ */ new Map();
  }
  initialize() {
    this.addHandles([d(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.map.layers.toArray();
    }, async () => {
      await this._onLayersChange();
    }, P)]);
  }
  destroy() {
    this._updatingHandles.destroy();
  }
  get state() {
    return this.loadError || !this._validConstructProperties ? "disabled" : this.executionError ? "failed" : this._updatingHandles.updating ? "executing" : this._initialValidationsFinished ? "ready" : "loading";
  }
  set view(e2) {
    this._get("view") !== e2 && this._set("view", e2);
  }
  async alterVersion(e2) {
    "disabled" !== this.state ? await this._updatingHandles.addPromise((async () => {
      this._setExecutionError();
      const r3 = this.versionManagementServiceLookup.get(e2.featureServerUrl);
      if (!r3)
        return void this._logNoVersionManagementServiceFoundError();
      if (!this.serverVersionLookup.has(e2.featureServerUrl) || this.serverVersionLookup.get(e2.featureServerUrl) <= 11.1)
        return void this._logError("execution-error", "no-valid-enterprise-version");
      if (!this.advancedEditingUserTypeExtensionLookup.get(e2.featureServerUrl))
        return void this._logError("execution-error", "no-advanced-editing-user-type-extension");
      const { featureServerUrl: o3, versionIdentifier: i4, ...t5 } = e2;
      await r3.alterVersion(i4, t5).catch(async (e3) => {
        await this.getVersionInfos(o3, true), this._logExecutionError(e3);
      });
    })()) : this._logError("load-error", this.loadError);
  }
  async changeVersion(e2, r3, o3) {
    "disabled" !== this.state ? await this._updatingHandles.addPromise((async () => {
      var _a;
      this._setExecutionError();
      const i4 = this.versionManagementServiceLookup.get(e2);
      if (!i4)
        return void this._logNoVersionManagementServiceFoundError();
      const t5 = this.versionIdentifierLookup.get(e2) ?? { name: i4.defaultVersionIdentifier.name, guid: i4.defaultVersionIdentifier.guid }, s6 = { name: r3, guid: o3 };
      await i4.changeVersion((_a = this.view) == null ? void 0 : _a.map, t5, s6).catch((e3) => {
        this._logExecutionError(e3);
      }) && this.versionIdentifierLookup.set(e2, s6);
    })()) : this._logError("load-error", this.loadError);
  }
  async createVersion(e2) {
    "disabled" !== this.state ? await this._updatingHandles.addPromise((async () => {
      var _a, _b;
      this._setExecutionError();
      const r3 = e2.featureServerUrl, o3 = this.versionManagementServiceLookup.get(r3);
      if (!o3)
        return void this._logNoVersionManagementServiceFoundError();
      const i4 = this.advancedEditingUserTypeExtensionLookup.get(e2.featureServerUrl), t5 = this.userLookup.get(r3).toUpperCase(), s6 = this._isEmptyString(e2.ownerName) ? t5 : (_a = e2.ownerName) == null ? void 0 : _a.trim().toUpperCase();
      if (s6 !== t5) {
        if (this.serverVersionLookup.get(r3) <= 11.1)
          return void this._logError("execution-error", "versioning-api-error");
        if (!i4)
          return void this._logError("execution-error", "no-advanced-editing-user-type-extension");
      }
      if ("SDE" === (s6 == null ? void 0 : s6.toUpperCase()) && "DEFAULT" === e2.versionName.toUpperCase() || ((_b = this.versionInfoLookup.get(r3)) == null ? void 0 : _b.find((r4) => r4.versionIdentifier.name.toUpperCase() === (s6 + "." + e2.versionName).toUpperCase() || r4.versionIdentifier.name.toUpperCase() === (t5 + "." + e2.versionName).toUpperCase())))
        return void this._logError("execution-error", "no-valid-version-name");
      const n4 = await o3.createVersion({ versionName: e2.versionName, access: s6 !== t5 ? "public" : e2.access, description: e2.description }).catch((e3) => {
        this._logExecutionError(e3);
      });
      if (!this.executionError && s6 !== t5) {
        const { guid: o4, name: i5 } = n4.versionIdentifier, a3 = { featureServerUrl: r3, versionIdentifier: { guid: o4, name: i5 }, access: e2.access, ownerName: s6 };
        await this.alterVersion(a3), this.executionError && this.deleteVersion(r3, t5 + "." + e2.versionName, n4.versionIdentifier.guid);
      }
      await this.getVersionInfos(r3, true);
    })()) : this._logError("load-error", this.loadError);
  }
  async deleteVersion(e2, r3, o3) {
    "disabled" !== this.state ? await this._updatingHandles.addPromise((async () => {
      this._setExecutionError();
      const i4 = this.versionManagementServiceLookup.get(e2);
      if (!i4)
        return void this._logNoVersionManagementServiceFoundError();
      if (this.serverVersionLookup.get(e2) <= 11.1)
        return void this._logError("execution-error", "versioning-api-error");
      if (!this.advancedEditingUserTypeExtensionLookup.get(e2))
        return void this._logError("execution-error", "no-advanced-editing-user-type-extension");
      const t5 = { name: r3, guid: o3 };
      await i4.deleteVersion(t5).catch((e3) => {
        this._logExecutionError(e3);
      }) && await this.getVersionInfos(e2, true).catch((e3) => {
        this._logExecutionError(e3);
      });
    })()) : this._logError("load-error", this.loadError);
  }
  async getVersionInfos(e2, r3) {
    if ("disabled" !== this.state)
      return await this._updatingHandles.addPromise((async () => {
        var _a, _b;
        this._setExecutionError();
        const o3 = (_a = this.featureServiceLookup.get(e2)) == null ? void 0 : _a.featureService;
        if (!o3)
          return void this._logError("execution-error", "no-feature-service-found");
        if (!o3.loaded) {
          await o3.load().catch((e3) => {
            this._logExecutionError(e3);
          });
          const r4 = o3.url;
          this.serverVersionLookup.set(r4, ((_b = o3.sourceJSON) == null ? void 0 : _b.currentVersion) ?? 0), this.serverVersionLookup.get(r4) <= 11.1 && this.advancedEditingUserTypeExtensionLookup.set(r4, false);
          const i5 = this.userLookup.get(e2);
          this._portalLookup.get(e2) && i5 ? this.advancedEditingUserTypeExtensionLookup.set(r4, await t2(this._portalLookup.get(e2), i5, "advediting")) : this.advancedEditingUserTypeExtensionLookup.set(r4, false);
        }
        o3.versionManagementServiceUrl && this.versionManagementServiceLookup.set(o3.url, new S2({ url: o3.versionManagementServiceUrl }));
        const i4 = this.versionManagementServiceLookup.get(e2);
        if (i4) {
          if (i4.loaded || await i4.load().catch((e3) => {
            this._logExecutionError(e3);
          }), !this.versionInfoLookup.get(e2) || r3) {
            const r4 = await i4.getVersionInfos().catch((e3) => {
              this._logExecutionError(e3);
            });
            this.versionInfoLookup.set(e2, r4);
          }
        } else
          this._logNoVersionManagementServiceFoundError();
      })()), this.versionInfoLookup.get(e2);
    this._logError("load-error", this.loadError);
  }
  _isEmptyString(e2) {
    return !e2 || 0 === e2.trim().length;
  }
  _logError(e2, r3) {
    switch (e2) {
      case "load-error":
        this._setLoadError(r3), n.getLogger(this).error(new s(e2, r3));
        break;
      case "execution-error":
        this._setExecutionError(r3), n.getLogger(this).error(new s(e2, r3));
    }
  }
  _logExecutionError(e2) {
    this._logError("execution-error", e2.message);
  }
  _logNoVersionManagementServiceFoundError() {
    this._logError("execution-error", "no-version-management-service-found");
  }
  async _onLayersChange() {
    var _a;
    if (this._initialValidationsFinished = false, this._setLoadError(), this._validConstructProperties = true, !this.view)
      return this._logError("load-error", "no-view-property"), void (this._validConstructProperties = false);
    if (this.featureServiceLookup = s5(this.view.map.layers), !this.featureServiceLookup.size)
      return this._logError("load-error", "no-feature-services"), void (this._validConstructProperties = false);
    for (const e2 of this.featureServiceLookup.keys())
      if (!this.serviceNameLookup.has(e2)) {
        this.serviceNameLookup.set(e2, e2.split("/").at(-2));
        const r3 = new Q({ authMode: "immediate", url: new URL(e2).origin + "/portal" });
        await r3.load(), this._portalLookup.set(e2, r3);
        const o3 = (_a = r3 == null ? void 0 : r3.user) == null ? void 0 : _a.username;
        o3 && this.userLookup.set(e2, o3);
      }
    this._initialValidationsFinished = true;
  }
  _setExecutionError(e2) {
    this._set("executionError", e2);
  }
  _setLoadError(e2) {
    this._set("loadError", e2);
  }
};
e([y()], l2.prototype, "_initialValidationsFinished", void 0), e([y({ readOnly: true })], l2.prototype, "advancedEditingUserTypeExtensionLookup", void 0), e([y({ readOnly: true })], l2.prototype, "executionError", void 0), e([y()], l2.prototype, "featureServiceLookup", void 0), e([y({ readOnly: true })], l2.prototype, "loadError", void 0), e([y({ readOnly: true })], l2.prototype, "serverVersionLookup", void 0), e([y()], l2.prototype, "serviceNameLookup", void 0), e([y({ readOnly: true })], l2.prototype, "state", null), e([y({ readOnly: true })], l2.prototype, "userLookup", void 0), e([y({ readOnly: true })], l2.prototype, "versionIdentifierLookup", void 0), e([y()], l2.prototype, "versionInfoLookup", void 0), e([y()], l2.prototype, "versionManagementServiceLookup", void 0), e([y()], l2.prototype, "view", null), l2 = e([a2("esri.widgets.VersionManagement.VersionManagementViewModel")], l2);
var v = l2;
export {
  v as default
};
//# sourceMappingURL=VersionManagementViewModel-R3YKHU34.js.map
