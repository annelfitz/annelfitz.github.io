import {
  g as g2
} from "./chunk-WOKVMRAD.js";
import {
  k,
  x as x3
} from "./chunk-6GQQIJM7.js";
import {
  it
} from "./chunk-5WKN6K5Z.js";
import {
  O as O2,
  a as a2
} from "./chunk-WCBHO6BH.js";
import {
  a
} from "./chunk-V7NVRGBC.js";
import {
  C
} from "./chunk-PMFQ2A2V.js";
import {
  t,
  u as u3
} from "./chunk-L3GUCBXG.js";
import {
  B,
  M,
  b,
  v as v2
} from "./chunk-3IDXRFXE.js";
import {
  b as b2
} from "./chunk-3AIILHI5.js";
import {
  v
} from "./chunk-SA77Z3WI.js";
import {
  d as d2
} from "./chunk-FQLGRQKL.js";
import {
  E,
  S as S2,
  c as c2,
  j
} from "./chunk-Z2F5OKVA.js";
import {
  n as n4
} from "./chunk-WIVZ7SMV.js";
import {
  n as n5
} from "./chunk-HZSGATFT.js";
import {
  e as e3
} from "./chunk-N5GQOIDP.js";
import {
  e as e4
} from "./chunk-NFB6O77E.js";
import {
  n as n3
} from "./chunk-SCHTG6ZQ.js";
import {
  c,
  n as n2,
  o as o3,
  r as r2
} from "./chunk-HWHMO3CO.js";
import {
  d,
  i,
  x as x2,
  y as y2
} from "./chunk-BOAEEYBE.js";
import {
  F as F2,
  J
} from "./chunk-2ICUS4HL.js";
import {
  y
} from "./chunk-GBF2OQAY.js";
import {
  F
} from "./chunk-C7NPPGFR.js";
import {
  h
} from "./chunk-OCF7OAES.js";
import {
  O,
  S,
  e as e2,
  g,
  o as o2,
  p,
  r,
  u as u2
} from "./chunk-JZBR4X6W.js";
import {
  l,
  n
} from "./chunk-OIJCMME5.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  s3 as s
} from "./chunk-UWQ3OYA5.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import {
  e
} from "./chunk-JGDJR5EV.js";
import {
  u
} from "./chunk-QHK5ZYFW.js";

// node_modules/@arcgis/core/views/3d/interactive/Manipulator3D.js
var ee = class {
  constructor(e6) {
    var _a;
    this.metadata = void 0, this._camera = new it(), this._elevation = { offset: 0, override: null }, this.collisionType = { type: "point" }, this.collisionPriority = 0, this._renderObjects = new Array(), this.autoScaleRenderObjects = true, this._available = true, this._noDisplayCount = 0, this._radius = 10, this._worldSized = false, this.focusMultiplier = 2, this.touchMultiplier = 2.5, this.worldOriented = false, this._modelTransform = e3(), this._worldFrame = null, this._renderLocation = n(), this._renderLocationDirty = true, this._location = new x({ x: 0, y: 0, z: 0 }), this._elevationAlignedLocation = new x(), this._elevationAlignedLocationDirty = true, this.interactive = true, this.selectable = false, this.grabbable = true, this.consumesClicks = true, this.cursor = null, this.grabCursor = null, this._grabbing = false, this.dragging = false, this._hovering = false, this._selected = false, this._state = u3.None, this._focused = false, this.events = new o.EventEmitter(), this._screenLocation = { screenPointArray: i(), renderScreenPointArray: x2(), pixelSize: 0 }, this._screenLocationDirty = true, this._engineResourcesAddedToStage = false, this._attached = false, this._location.spatialReference = e6.view.spatialReference, Object.assign(this, e6);
    const i2 = (_a = this.view.state) == null ? void 0 : _a.camera;
    i2 && this._camera.copyFrom(i2);
  }
  destroy() {
    this._applyObjectTransform = pe, this._removeResourcesFromStage(), this._engineResources = null, this.view = null, this._camera = null;
  }
  get _stage() {
    var _a;
    return (_a = this.view) == null ? void 0 : _a._stage;
  }
  get elevationInfo() {
    return this._elevationInfo;
  }
  set elevationInfo(e6) {
    this._elevationInfo = e6, this._elevationAlignedLocationDirty = true, this._renderLocationDirty = true, this._updateEngineObject();
  }
  get renderObjects() {
    return this._renderObjects;
  }
  set renderObjects(e6) {
    this._removeResourcesFromStage(), this._engineResources = null, this._renderObjects = e6.slice(), this._updateEngineObject();
  }
  set available(e6) {
    e6 !== this._available && (this._available = e6, this._updateEngineObject());
  }
  get available() {
    return this._available;
  }
  disableDisplay() {
    return this._noDisplayCount++, 1 === this._noDisplayCount && this._updateEngineObject(), e(() => {
      this._noDisplayCount--, 0 === this._noDisplayCount && this._updateEngineObject();
    });
  }
  set radius(e6) {
    e6 !== this._radius && (this._radius = e6, this._updateEngineObject());
  }
  get radius() {
    return this._radius;
  }
  set worldSized(e6) {
    e6 !== this._worldSized && (this._worldSized = e6, this._updateEngineObject());
  }
  get worldSized() {
    return this._worldSized;
  }
  get modelTransform() {
    return this._modelTransform;
  }
  set modelTransform(e6) {
    te(e6) && (this._screenLocationDirty = true), n2(this._modelTransform, e6), this._updateEngineObject();
  }
  get renderLocation() {
    return this._renderLocationDirty && (this._renderLocationDirty = false, this.view.renderCoordsHelper.toRenderCoords(this.elevationAlignedLocation, this._renderLocation), this.worldOriented ? (this._worldFrame || (this._worldFrame = e3()), ie(this.view, this._renderLocation, this._worldFrame)) : this._worldFrame && (this._worldFrame = null)), this._renderLocation;
  }
  set renderLocation(e6) {
    this.view.renderCoordsHelper.fromRenderCoords(e6, this._location), this.elevationAlignedLocation = this._location;
  }
  get location() {
    return this._location;
  }
  set location(e6) {
    x3(e6, this._location), this._notifyLocationChanged();
  }
  _notifyLocationChanged() {
    this._renderLocationDirty = true, this._screenLocationDirty = true, this._elevationAlignedLocationDirty = true, this._updateEngineObject(), this.events.emit("location-update", { location: this._location });
  }
  get elevationAlignedLocation() {
    return this._elevationAlignedLocationDirty ? (this._evaluateElevationAlignment(), this._updateElevationAlignedLocation(), this._elevationAlignedLocation) : this._elevationAlignedLocation;
  }
  set elevationAlignedLocation(e6) {
    x3(e6, this._location), this._evaluateElevationAlignment(), this._location.z -= this._elevation.offset, this._updateElevationAlignedLocation(), this._updateEngineObject(), this.events.emit("location-update", { location: this._location });
  }
  _updateElevationAlignedLocation() {
    const e6 = null != this._elevation.override ? this._elevation.override : this.location.z || 0;
    this._elevationAlignedLocation.x = this.location.x, this._elevationAlignedLocation.y = this.location.y, this._elevationAlignedLocation.z = e6 + this._elevation.offset, this._elevationAlignedLocation.spatialReference = k(this.location.spatialReference), this._renderLocationDirty = true, this._screenLocationDirty = true, this._elevationAlignedLocationDirty = false;
  }
  grabbableForEvent() {
    return true;
  }
  get grabbing() {
    return this._grabbing;
  }
  set grabbing(e6) {
    e6 !== this._grabbing && (this._grabbing = e6, this._setFocused(this._hovering || this._grabbing), this._updateEngineObject());
  }
  get hovering() {
    return this._hovering;
  }
  set hovering(e6) {
    e6 !== this._hovering && (this._hovering = e6, this._setFocused(this._hovering || this._grabbing), this._updateEngineObject());
  }
  get selected() {
    return this._selected;
  }
  set selected(e6) {
    e6 !== this._selected && (this._selected = e6, this._updateEngineObject(), this.events.emit("select-changed", { action: e6 ? "select" : "deselect" }));
  }
  get state() {
    return this._state;
  }
  set state(e6) {
    e6 !== this._state && (this._state = e6, this._updateEngineObject());
  }
  updateStateEnabled(e6, t2) {
    t2 ? this.state |= e6 : this.state &= ~e6;
  }
  _setFocused(e6) {
    e6 !== this._focused && (this._focused = e6, this.events.emit("focus-changed", { action: true === e6 ? "focus" : "unfocus" }));
  }
  get focused() {
    return this._focused;
  }
  get screenLocation() {
    return this._ensureScreenLocation(), this._screenLocation;
  }
  _ensureScreenLocation() {
    if (!this._screenLocationDirty)
      return;
    this._screenLocation.pixelSize = this._camera.computeScreenPixelSizeAt(this.renderLocation), this._screenLocationDirty = false;
    let e6;
    if (te(this._modelTransform)) {
      const t2 = this._calculateModelTransformOffset(me);
      e6 = u2(t2, t2, this.renderLocation);
    } else
      e6 = this.renderLocation;
    this._camera.projectToRenderScreen(e6, this._screenLocation.renderScreenPointArray), this._camera.renderToScreen(this._screenLocation.renderScreenPointArray, this._screenLocation.screenPointArray);
  }
  get applyObjectTransform() {
    return this._applyObjectTransform;
  }
  set applyObjectTransform(e6) {
    this._applyObjectTransform = e6, this._screenLocationDirty = true, this._updateEngineObject();
  }
  get attached() {
    return this._attached;
  }
  intersectionDistance(t2, i2) {
    if (!this.available)
      return null;
    const s2 = d(t2, se), o4 = this._getCollisionRadius(i2), r3 = -1 * this.collisionPriority;
    switch (this.collisionType.type) {
      case "point":
        if (b2(this.screenLocation.screenPointArray, s2) < o4 * o4)
          return this.screenLocation.renderScreenPointArray[2] + r3;
        break;
      case "line": {
        const e6 = this.collisionType.paths, t3 = this._getWorldToScreenObjectScale(), i3 = this._calculateObjectTransform(t3, ce), n6 = o4 * this.screenLocation.pixelSize, a3 = g2(this._camera, s2, re);
        if (null == a3)
          return null;
        for (const s3 of e6) {
          if (0 === s3.length)
            continue;
          const e7 = O(he, s3[0], i3);
          for (let t4 = 1; t4 < s3.length; t4++) {
            const o5 = O(de, s3[t4], i3), l2 = B(b(e7, o5, oe), a3);
            if (null != l2 && l2 < n6 * n6) {
              const t5 = u2(c2.get(), e7, o5);
              g(t5, t5, 0.5);
              const i4 = y2(c2.get());
              return this._camera.projectToRenderScreen(t5, i4), i4[2] + r3;
            }
            r(e7, o5);
          }
        }
        break;
      }
      case "disc": {
        const e6 = this.collisionType.direction, t3 = this.collisionType.offset ?? l, i3 = this._getWorldToScreenObjectScale(), n6 = this._calculateObjectTransform(i3, ce), a3 = o4 * this.screenLocation.pixelSize, c3 = g2(this._camera, s2, re);
        if (null == c3)
          return null;
        const h2 = n5(ne, n6), d3 = S(ue, e6, h2), _ = O(ge, t3, n6);
        j(_, d3, le);
        const u4 = _e;
        if (S2(le, c3, u4) && p(u4, _) < a3 * a3)
          return this.screenLocation.renderScreenPointArray[2] + r3;
        break;
      }
      case "ribbon": {
        const { paths: e6, direction: t3 } = this.collisionType, i3 = this._getWorldToScreenObjectScale(), n6 = this._calculateObjectTransform(i3, ce), a3 = o4 * this._camera.computeScreenPixelSizeAt(this.renderLocation), h2 = g2(this._camera, s2, re);
        if (null == h2)
          return null;
        const d3 = n5(ne, n6), _ = S(ue, t3, d3), u4 = this._calculateModelTransformPosition(ge);
        j(u4, _, le);
        const g3 = _e;
        if (!S2(le, h2, g3))
          break;
        for (const s3 of e6) {
          if (0 === s3.length)
            continue;
          const e7 = O(he, s3[0], n6);
          for (let t4 = 1; t4 < s3.length; t4++) {
            const i4 = O(de, s3[t4], n6), o5 = M(b(e7, i4, oe), g3);
            if (null != o5 && o5 < a3 * a3) {
              const t5 = u2(c2.get(), e7, i4);
              g(t5, t5, 0.5);
              const s4 = y2(c2.get());
              return this._camera.projectToRenderScreen(t5, s4), s4[2] + r3;
            }
            r(e7, i4);
          }
        }
        break;
      }
      default:
        n3(this.collisionType);
    }
    return null;
  }
  attach(e6 = { manipulator3D: {} }) {
    const t2 = this._stage;
    if (!t2)
      return;
    const i2 = e6.manipulator3D;
    null == i2.engineLayerId ? (this._engineLayer = new a2(t2, { pickable: false, updatePolicy: C.SYNC }), i2.engineLayerId = this._engineLayer.id) : (t2 == null ? void 0 : t2.getObject) && (this._engineLayer = t2.getObject(i2.engineLayerId)), i2.engineLayerReferences = (i2.engineLayerReferences || 0) + 1, this._materialIdReferences = i2.materialIdReferences, null == this._materialIdReferences && (this._materialIdReferences = /* @__PURE__ */ new Map(), i2.materialIdReferences = this._materialIdReferences), this._camera.copyFrom(this.view.state.camera), this._attached = true, this._updateEngineObject(), F2(this._location.spatialReference, this.view.spatialReference) || (this.location = new x({ x: 0, y: 0, z: 0, spatialReference: this.view.spatialReference }));
  }
  detach(e6 = { manipulator3D: {} }) {
    const t2 = e6.manipulator3D;
    t2.engineLayerReferences--;
    const i2 = 0 === t2.engineLayerReferences;
    this._removeResourcesFromStage(), i2 && (t2.engineLayerId = null, u(this._engineLayer)), this._engineResources = null, this._engineLayer = null, this._materialIdReferences = null, this._attached = false;
  }
  onViewChange() {
    this._camera.copyFrom(this.view.state.camera), this._screenLocationDirty = true, this._updateEngineObject();
  }
  onElevationChange(e6) {
    J(this.location, fe, e6.spatialReference) && F(e6.extent, fe) && this._notifyLocationChanged();
  }
  _evaluateElevationAlignment() {
    if (null == this.elevationInfo)
      return;
    let e6 = null, t2 = 0;
    const i2 = v(this.elevationInfo, this.location.spatialReference ?? this.view.elevationProvider.spatialReference);
    switch (this.elevationInfo.mode) {
      case "on-the-ground":
        e6 = a(this.view.elevationProvider, this.location, "ground") ?? 0;
        break;
      case "relative-to-ground":
        t2 = (a(this.view.elevationProvider, this.location, "ground") ?? 0) + i2;
        break;
      case "relative-to-scene":
        t2 = (a(this.view.elevationProvider, this.location, "scene") ?? 0) + i2;
        break;
      case "absolute-height":
        t2 = i2;
    }
    return t2 !== this._elevation.offset || e6 !== this._elevation.override ? (this._elevation.offset = t2, void (this._elevation.override = e6)) : void 0;
  }
  _updateEngineObject() {
    if (!this._attached)
      return;
    if (!this.available)
      return void this._removeResourcesFromStage();
    const e6 = this._getWorldToScreenObjectScale(), t2 = ce;
    if (true === this.autoScaleRenderObjects) {
      const i3 = this._getFocusedSize(this._radius, this.focused) * e6;
      this._calculateObjectTransform(i3, t2);
    } else
      this._calculateObjectTransform(e6, t2);
    const { objectsByState: i2 } = this._ensureEngineResources(), s2 = (this.focused ? t.Focused : t.Unfocused) | (this.selected ? t.Selected : t.Unselected), o4 = this._noDisplayCount > 0;
    for (const { stateMask: r3, objects: n6 } of i2) {
      if (o4) {
        for (const e8 of n6)
          e8.visible = false;
        continue;
      }
      const e7 = (r3 & t.All) !== t.None, i3 = (r3 & u3.All) !== u3.None, a3 = !e7 || (s2 & r3) == (r3 & t.All), c3 = !i3 || (this.state & r3) == (r3 & u3.All);
      if (a3 && c3)
        for (const s3 of n6)
          s3.visible = true, s3.transformation = t2;
      else
        for (const t3 of n6)
          t3.visible = false;
    }
  }
  _ensureEngineResources() {
    if (null == this._engineResources) {
      const e6 = this._engineLayer, t2 = [], i2 = /* @__PURE__ */ new Set();
      this.renderObjects.forEach(({ geometry: { material: e7 } }) => {
        i2.has(e7) || (t2.push(e7), i2.add(e7));
      });
      const s2 = /* @__PURE__ */ new Map();
      this._renderObjects.forEach((e7) => {
        const t3 = new O2({ castShadow: false, geometries: [e7.geometry] }), i3 = s2.get(e7.stateMask) || [];
        i3.push(t3), s2.set(e7.stateMask, i3);
      });
      const o4 = [];
      s2.forEach((e7, t3) => o4.push({ stateMask: t3, objects: e7 })), this._engineResources = { objectsByState: o4, layer: e6, materials: t2 };
    }
    return this._addResourcesToStage(), this._engineResources;
  }
  _addResourcesToStage() {
    const e6 = this._stage;
    if (this._engineResourcesAddedToStage || null == this._engineResources || !e6)
      return;
    const { objectsByState: t2, layer: i2, materials: s2 } = this._engineResources;
    s2.forEach((t3) => {
      const i3 = this._materialIdReferences, s3 = i3.get(t3.id) || 0;
      0 === s3 && e6.add(t3), i3.set(t3.id, s3 + 1);
    }), t2.forEach(({ objects: t3 }) => {
      i2.addMany(t3), e6.addMany(t3);
    }), this._engineResourcesAddedToStage = true;
  }
  _removeResourcesFromStage() {
    const e6 = this._stage;
    if (!this._engineResourcesAddedToStage || null == this._engineResources || !e6)
      return;
    const { objectsByState: t2, layer: i2, materials: s2 } = this._engineResources;
    t2.forEach(({ objects: t3 }) => {
      i2.removeMany(t3), e6.removeMany(t3);
    }), s2.forEach((t3) => {
      const i3 = this._materialIdReferences, s3 = i3.get(t3.id);
      1 === s3 ? (e6.remove(t3), i3.delete(t3.id)) : i3.set(t3.id, s3 - 1);
    }), this._engineResourcesAddedToStage = false;
  }
  _getCollisionRadius(e6) {
    return this._getFocusedSize(this.radius, true) * ("touch" === e6 ? this.touchMultiplier : 1);
  }
  _getFocusedSize(e6, t2) {
    return e6 * (t2 ? this.focusMultiplier : 1);
  }
  _getWorldToScreenObjectScale() {
    return this._worldSized ? 1 : this.screenLocation.pixelSize;
  }
  _calculateModelTransformPosition(e6) {
    const t2 = this._getWorldToScreenObjectScale(), i2 = this._calculateObjectTransform(t2, ae);
    return o2(e6, i2[12], i2[13], i2[14]);
  }
  _calculateModelTransformOffset(e6) {
    const t2 = this._calculateModelTransformPosition(e6);
    return e2(e6, t2, this.renderLocation);
  }
  _calculateObjectTransform(e6, t2) {
    return r2(t2, e6, 0, 0, 0, 0, e6, 0, 0, 0, 0, e6, 0, 0, 0, 0, 1), this._worldFrame && c(t2, t2, this._worldFrame), c(t2, t2, this._modelTransform), t2[12] += this.renderLocation[0], t2[13] += this.renderLocation[1], t2[14] += this.renderLocation[2], t2[15] = 1, null != this._applyObjectTransform && this._applyObjectTransform(t2), t2;
  }
  get test() {
    let e6 = false;
    if (null != this._engineResources)
      for (const t2 of this._engineResources.objectsByState) {
        for (const i2 of t2.objects)
          if (i2.visible) {
            e6 = true;
            break;
          }
        if (e6)
          break;
      }
    return { areAnyResourcesVisible: e6 };
  }
};
function te(e6) {
  return 0 !== e6[12] || 0 !== e6[13] || 0 !== e6[14];
}
function ie(e6, t2, i2) {
  switch (e6.viewingMode) {
    case "local":
      return o3(i2), true;
    case "global": {
      const o4 = s(e6.renderCoordsHelper.spatialReference);
      return y(t2, 0, he, 0, o4.radius), n4(h(he[0]), h(he[1]), i2), true;
    }
  }
}
var se = i();
var oe = v2();
var re = d2();
var ne = e4();
var ae = e3();
var ce = e3();
var le = E();
var he = n();
var de = n();
var _e = n();
var ue = n();
var ge = n();
var me = n();
var fe = new x({ x: 0, y: 0, z: 0, spatialReference: null });
var pe = () => {
};

// node_modules/@arcgis/core/views/3d/interactive/RenderObject.js
var e5 = class {
  constructor(e6, s2 = t.None) {
    this.geometry = e6, this.stateMask = s2;
  }
};

export {
  ee,
  e5 as e
};
//# sourceMappingURL=chunk-6FMD7BOV.js.map
