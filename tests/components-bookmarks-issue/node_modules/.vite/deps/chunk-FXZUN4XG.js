import {
  a as a2
} from "./chunk-3W2U3CD4.js";
import {
  R,
  b
} from "./chunk-5T7MASZO.js";
import {
  H
} from "./chunk-WCBHO6BH.js";
import {
  a
} from "./chunk-V7NVRGBC.js";
import {
  h
} from "./chunk-3DFMDDMO.js";
import {
  e
} from "./chunk-N5GQOIDP.js";
import {
  r,
  t
} from "./chunk-AKEHDP75.js";
import {
  q
} from "./chunk-HWHMO3CO.js";
import {
  C
} from "./chunk-2ICUS4HL.js";
import {
  O,
  o
} from "./chunk-JZBR4X6W.js";
import {
  l,
  n
} from "./chunk-OIJCMME5.js";

// node_modules/@arcgis/core/views/3d/analysis/support/projectionUtils.js
function r2(r3, t3, i, n2 = false) {
  const l2 = C(r3, t3);
  return null == l2 ? null : (l2.hasZ && !n2 || null == i || (l2.z = a(i, l2) ?? 0), l2);
}
function t2(o2, e2, r3) {
  r3.warnOnce(`Failed to project analysis geometry (id: '${o2.id}'), projection from spatial reference (wkid: '${e2.wkid}') to view spatial reference is not supported. Projection may be possible after calling projection.load().`);
}

// node_modules/@arcgis/core/views/3d/interactive/visualElements/LineVisualElement.js
var f = class extends a2 {
  constructor(e2, t3) {
    super(e2), this._hasExternalMaterial = false, this._hasExternalMaterial = null != t3, this._material = null != t3 ? t3 : new H({ width: 1, color: r(1, 0, 1, 1), stippleOffColor: null, stipplePattern: null, stipplePreferContinuous: true, isClosed: false, falloff: 0, innerColor: null, innerWidth: 1, hasPolygonOffset: false, renderOccluded: h.OccludeAndTransparent, isDecoration: !!e2.isDecoration, writeDepth: true }), this.applyProperties(e2);
  }
  setGeometryFromRenderSpacePoint(e2, t3 = 1e3) {
    this.geometry = [[[e2[0] - t3, e2[1], e2[2]], [e2[0] + t3, e2[1], e2[2]]], [[e2[0], e2[1] - t3, e2[2]], [e2[0], e2[1] + t3, e2[2]]], [[e2[0], e2[1], e2[2] - t3], [e2[0], e2[1], e2[2] + t3]]];
  }
  setGeometryFromExtent(e2) {
    const t3 = this.view.spatialReference, s = n(), o2 = n(), a3 = 100, n2 = [];
    o(s, e2[0], e2[1], a3), this.view.renderCoordsHelper.toRenderCoords(s, t3, o2), n2.push([o2[0], o2[1], o2[2]]), o(s, e2[2], e2[1], a3), this.view.renderCoordsHelper.toRenderCoords(s, t3, o2), n2.push([o2[0], o2[1], o2[2]]), o(s, e2[2], e2[3], a3), this.view.renderCoordsHelper.toRenderCoords(s, t3, o2), n2.push([o2[0], o2[1], o2[2]]), o(s, e2[0], e2[3], a3), this.view.renderCoordsHelper.toRenderCoords(s, t3, o2), n2.push([o2[0], o2[1], o2[2]]), o(s, e2[0], e2[1], a3), this.view.renderCoordsHelper.toRenderCoords(s, t3, o2), n2.push([o2[0], o2[1], o2[2]]), o(s, e2[0], e2[1], a3), this.view.renderCoordsHelper.toRenderCoords(s, t3, o2), n2.push([o2[0], o2[1], o2[2]]), this.geometry = [n2];
  }
  setGeometryFromFrustum(e2) {
    const t3 = [];
    e2.lines.forEach((e3) => {
      t3.push([e3.origin[0], e3.origin[1], e3.origin[2]]), t3.push([e3.endpoint[0], e3.endpoint[1], e3.endpoint[2]]);
    }), this.geometry = [t3];
  }
  setGeometryFromBoundedPlane(e2) {
    const t3 = [], r3 = e2.origin, s = e2.basis1, o2 = e2.basis2, a3 = 0.5, n2 = n(), l2 = n(), m = n(), p = n();
    n2[0] = r3[0] - s[0] * a3 - o2[0] * a3, n2[1] = r3[1] - s[1] * a3 - o2[1] * a3, n2[2] = r3[2] - s[2] * a3 - o2[2] * a3, l2[0] = r3[0] - s[0] * a3 + o2[0] * a3, l2[1] = r3[1] - s[1] * a3 + o2[1] * a3, l2[2] = r3[2] - s[2] * a3 + o2[2] * a3, m[0] = r3[0] + s[0] * a3 + o2[0] * a3, m[1] = r3[1] + s[1] * a3 + o2[1] * a3, m[2] = r3[2] + s[2] * a3 + o2[2] * a3, p[0] = r3[0] + s[0] * a3 - o2[0] * a3, p[1] = r3[1] + s[1] * a3 - o2[1] * a3, p[2] = r3[2] + s[2] * a3 - o2[2] * a3, t3.push([n2[0], n2[1], n2[2]]), t3.push([l2[0], l2[1], l2[2]]), t3.push([m[0], m[1], m[2]]), t3.push([p[0], p[1], p[2]]), t3.push([n2[0], n2[1], n2[2]]), this.geometry = [t3];
  }
  setGeometryFromSegment(t3) {
    const r3 = t3.endRenderSpace;
    this.transform = q(u, r3);
    const { points: s } = t3.createRenderGeometry(r3, this.view.renderCoordsHelper);
    this.geometry = [s];
  }
  setGeometryFromSegments(t3, r3 = l) {
    this.transform = q(u, r3), this.geometry = t3.map((e2) => e2.createRenderGeometry(r3, this.view.renderCoordsHelper).points);
  }
  getTransformedGeometry() {
    return null == this._geometry ? null : this._geometry.map((e2) => e2.map((e3) => O(n(), e3, this.transform)));
  }
  get renderOccluded() {
    return this._material.parameters.renderOccluded;
  }
  set renderOccluded(e2) {
    this._material.setParameters({ renderOccluded: e2 });
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e2) {
    this._geometry = e2, this.recreateGeometry();
  }
  get width() {
    return this._material.parameters.width;
  }
  set width(e2) {
    this._material.setParameters({ width: e2 });
  }
  get color() {
    return this._material.parameters.color;
  }
  set color(e2) {
    const t3 = 1 === e2[3];
    this._material.setParameters({ color: t(e2), writeDepth: t3 });
  }
  get innerWidth() {
    return this._material.parameters.innerWidth;
  }
  set innerWidth(e2) {
    this._material.setParameters({ innerWidth: e2 });
  }
  get innerColor() {
    return this._material.parameters.innerColor;
  }
  set innerColor(e2) {
    this._material.setParameters({ innerColor: null != e2 ? t(e2) : null });
  }
  get stipplePattern() {
    return this._material.parameters.stipplePattern;
  }
  set stipplePattern(e2) {
    null != this._material && this._material.setParameters({ stipplePattern: e2 });
  }
  get stippleOffColor() {
    return this._material.parameters.stippleOffColor;
  }
  set stippleOffColor(e2) {
    this._material.setParameters({ stippleOffColor: null != e2 ? t(e2) : null });
  }
  get stipplePreferContinuous() {
    return this._material.parameters.stipplePreferContinuous;
  }
  set stipplePreferContinuous(e2) {
    this._material.setParameters({ stipplePreferContinuous: e2 });
  }
  get falloff() {
    return this._material.parameters.falloff;
  }
  set falloff(e2) {
    this._material.setParameters({ falloff: e2 });
  }
  get polygonOffset() {
    return this._material.parameters.hasPolygonOffset;
  }
  set polygonOffset(e2) {
    this._material.setParameters({ hasPolygonOffset: e2 });
  }
  createExternalResources() {
  }
  destroyExternalResources() {
  }
  createGeometries(e2) {
    for (const t3 of R(this.geometry)) {
      const r3 = b(this._material, t3);
      e2.addGeometry(r3);
    }
  }
  forEachExternalMaterial(e2) {
    this._hasExternalMaterial || e2(this._material);
  }
};
var u = e();

export {
  f,
  r2 as r,
  t2 as t
};
//# sourceMappingURL=chunk-FXZUN4XG.js.map
