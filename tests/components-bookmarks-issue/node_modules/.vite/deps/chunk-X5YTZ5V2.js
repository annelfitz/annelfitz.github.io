import {
  w as w2
} from "./chunk-M4ETSXXR.js";
import {
  b
} from "./chunk-3FTSPLRV.js";
import {
  f as f2,
  w
} from "./chunk-LO5UMUY4.js";
import {
  j as j2,
  m2 as m,
  u
} from "./chunk-HV6S3GY2.js";
import {
  M,
  a as a3,
  x as x2
} from "./chunk-IGR2BTWR.js";
import {
  A
} from "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";
import {
  R,
  d,
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import {
  f
} from "./chunk-MBGZKT2Z.js";
import {
  $,
  G3 as G,
  N,
  W2 as W,
  j,
  r2 as r,
  re,
  s3 as s
} from "./chunk-UWQ3OYA5.js";
import {
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a2
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  a
} from "./chunk-7RBRCL6S.js";
import {
  h,
  k
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/geometry/Circle.js
var f3;
var g = f3 = class extends j2 {
  constructor(...e2) {
    super(...e2), this.center = null, this.geodesic = false, this.numberOfPoints = 60, this.radius = 1e3, this.radiusUnit = "meters";
  }
  normalizeCtorArgs(e2, r2) {
    let t;
    if (e2 == null ? void 0 : e2.center)
      t = e2;
    else {
      if (e2 == null ? void 0 : e2.rings)
        return super.normalizeCtorArgs(e2, r2);
      t = { center: e2 };
    }
    return { ...super.normalizeCtorArgs(), ...t, ...r2 };
  }
  initialize() {
    const e2 = this.center, o = this.numberOfPoints;
    if (this.hasZ = (e2 == null ? void 0 : e2.hasZ) ?? false, 0 !== this.rings.length || !e2)
      return;
    const c = j(this.radius, this.radiusUnit, "meters"), a4 = e2.spatialReference;
    let p, l = "geographic";
    if (a4.isWebMercator ? l = "webMercator" : (null != (a4.wkid && r[a4.wkid]) || (a4.wkt2 || a4.wkt) && re(a4.wkt2 || a4.wkt)) && (l = "projected"), this.geodesic) {
      let r2;
      switch (l) {
        case "webMercator":
          r2 = R(e2);
          break;
        case "projected":
          console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");
          break;
        case "geographic":
          r2 = e2;
      }
      p = this._createGeodesicCircle(r2, c, o), "webMercator" === l && (p = d(p));
    } else {
      let r2;
      "webMercator" === l || "projected" === l ? r2 = c / $(e2.spatialReference) : "geographic" === l && (r2 = G(c, "meters", s(e2.spatialReference).radius)), p = this._createPlanarCircle(e2, r2, o);
    }
    this.spatialReference = p.spatialReference, this.addRing(p.rings[0]);
  }
  clone() {
    const { center: e2, numberOfPoints: r2, radius: t, radiusUnit: s2, geodesic: i } = this;
    return new f3({ center: e2 == null ? void 0 : e2.clone(), numberOfPoints: r2, radius: t, radiusUnit: s2, geodesic: i });
  }
  _createGeodesicCircle(e2, r2, t) {
    let s2 = 0;
    const i = [];
    for (; s2 < 360; ) {
      const o = [0, 0], c = [e2.x, e2.y];
      b(o, c, s2, r2, f.WGS84), this.hasZ && o.push(e2.z), i.push(o), s2 += 360 / t;
    }
    return i.push(i[0]), new j2(i);
  }
  _createPlanarCircle(e2, r2, t) {
    const s2 = [], i = 2 * Math.PI / t;
    for (let o = 0; o < t; ++o) {
      const t2 = i * o, c = [e2.x + Math.cos(-t2) * r2, e2.y + Math.sin(-t2) * r2];
      this.hasZ && c.push(e2.z), s2.push(c);
    }
    return s2.push(s2[0]), new j2({ spatialReference: e2.spatialReference, rings: [s2] });
  }
};
e([y({ type: x })], g.prototype, "center", void 0), e([y()], g.prototype, "geodesic", void 0), e([y()], g.prototype, "numberOfPoints", void 0), e([y()], g.prototype, "radius", void 0), e([y()], g.prototype, "radiusUnit", void 0), g = f3 = e([a2("esri.geometry.Circle")], g);
var b2 = g;

// node_modules/@arcgis/core/views/draw/support/createUtils.js
function g2(t, e2) {
  const o = new x({ x: t[0], y: t[1], spatialReference: e2 });
  return t.length > 2 && (o.z = t[2]), o;
}
function d2(t, e2) {
  return new u({ points: t, spatialReference: e2 });
}
function R2(t, e2, o) {
  const n2 = new m({ paths: t, spatialReference: e2 });
  return o && x2(n2), n2;
}
function j3(e2, n2, r2, a4 = true) {
  const l = a(e2);
  l.forEach((e3) => {
    const o = e3[0], n3 = e3[e3.length - 1];
    h(o, n3) && 1 !== e3.length || e3.push(e3[0]);
  });
  let i = new j2({ rings: l, spatialReference: n2 });
  return i.rings.forEach((t) => {
    a3(t) || t.reverse();
  }), r2 && x2(i), a4 && i.isSelfIntersecting && N(n2) && (i = w(i)), i;
}
function T(t, o, n2) {
  const r2 = o.mapToLocalMultiple(t), a4 = [], l = { x: r2[0].x, y: r2[0].y }, s2 = { x: r2[1].x, y: r2[1].y }, i = Math.round(s2.x - l.x), c = Math.round(s2.y - l.y), y2 = Math.max(Math.abs(i), Math.abs(c));
  if (n2) {
    const t2 = { x: l.x + y2, y: l.y + y2 }, e2 = { x: l.x - y2, y: l.y - y2 };
    a4.push(w2(t2.x, e2.y), w2(e2.x, e2.y), w2(e2.x, t2.y), w2(t2.x, t2.y));
  } else {
    const t2 = { x: i > 0 ? l.x + y2 : l.x - y2, y: c > 0 ? l.y + y2 : l.y - y2 };
    a4.push(w2(l.x, l.y), w2(t2.x, l.y), w2(t2.x, t2.y), w2(l.x, t2.y));
  }
  return U(j3([a4.map((t2) => o.localToMap(t2)).filter(k)], o.spatialReference, o.doUnnormalization, true), a4, o);
}
function b3(t, o, n2) {
  let r2 = o.mapToLocalMultiple(t);
  if (1 === r2.length) {
    const t2 = 48, e2 = r2[0];
    r2 = [w2(e2.x - t2, e2.y + t2), w2(e2.x + t2, e2.y - t2), w2(e2.x + t2, e2.y - t2), w2(e2.x - t2, e2.y + t2)];
  }
  const a4 = [], l = { x: r2[0].x, y: r2[0].y }, s2 = { x: r2[1].x, y: r2[1].y };
  if (n2) {
    const t2 = Math.round(s2.x - l.x), e2 = Math.round(s2.y - l.y);
    a4.push(w2(l.x - t2, l.y - e2), w2(s2.x, l.y - e2), w2(s2.x, s2.y), w2(l.x - t2, s2.y));
  } else
    a4.push(w2(l.x, l.y), w2(s2.x, l.y), w2(s2.x, s2.y), w2(l.x, s2.y));
  return U(j3([a4.map((t2) => o.localToMap(t2)).filter(k)], o.spatialReference, o.doUnnormalization, true), a4, o);
}
function U(t, e2, o) {
  const n2 = P(e2[3], e2[2], o), r2 = P(e2[1], e2[2], o), a4 = P(e2[0], e2[1], o), l = P(e2[0], e2[3], o);
  return { geometry: t, midpoints: null != n2 && null != r2 && null != a4 && null != l ? { top: n2, right: r2, bottom: a4, left: l } : null };
}
function P(t, e2, o) {
  w3[0] = t.x, w3[1] = t.y, w3[2] = 0, I[0] = e2.x, I[1] = e2.y, I[2] = 0, A(w3, w3, I, 0.5), z.x = w3[0], z.y = I[1], z.z = I[2];
  const n2 = o.localToMap(z);
  return null != n2 ? g2(n2, o.spatialReference) : null;
}
var z = w2(0, 0, 0);
var w3 = n();
var I = n();
function L(t, e2, o, r2) {
  const a4 = e2.mapToLocalMultiple(t);
  let s2 = null, c = null;
  if (o)
    s2 = a4[0], c = a4[1];
  else {
    const t2 = a4[0], e3 = a4[1], o2 = Math.round(e3.x - t2.x), n2 = Math.round(e3.y - t2.y), r3 = Math.max(Math.abs(o2), Math.abs(n2));
    s2 = w2(o2 > 0 ? t2.x + r3 / 2 : t2.x - r3 / 2, n2 > 0 ? t2.y + r3 / 2 : t2.y - r3 / 2), c = w2(Math.abs(o2) > Math.abs(n2) ? s2.x - r3 / 2 : s2.x, Math.abs(o2) > Math.abs(n2) ? s2.y : s2.y - r3 / 2);
  }
  const y2 = e2.localToMap(s2), f4 = e2.localToMap(c);
  if (null == y2 || null == f4)
    return null;
  e2.doUnnormalization && M([[y2, f4]], e2.spatialReference);
  const x3 = g2(y2, e2.spatialReference), h2 = g2(f4, e2.spatialReference), M2 = W(e2.spatialReference);
  let d3 = 0;
  if (N(e2.spatialReference))
    d3 = M2 * f2(x3, h2, null);
  else {
    const t2 = s2.x - c.x, e3 = s2.y - c.y;
    d3 = M2 * Math.sqrt(t2 * t2 + e3 * e3) * (r2 || 1);
  }
  const R3 = new b2({ center: x3, radius: d3, radiusUnit: "meters", spatialReference: e2.spatialReference });
  return { geometry: j3(R3.rings, R3.spatialReference, false), center: x3, edge: h2 };
}
function v(t, o, n2) {
  const r2 = o.mapToLocalMultiple(t), a4 = r2[0], l = r2[1], s2 = Math.round(l.x - a4.x), i = Math.round(l.y - a4.y), c = w2(n2 ? a4.x : a4.x + s2 / 2, n2 ? a4.y : a4.y + i / 2), y2 = n2 ? s2 : s2 / 2, p = n2 ? i : i / 2, u2 = 60, f4 = [], x3 = 2 * Math.PI / u2;
  function h2(t2) {
    const e2 = Math.cos(t2), o2 = Math.sin(t2);
    return w2(y2 * e2 + c.x, p * o2 + c.y);
  }
  for (let e2 = 0; e2 < u2; e2++)
    f4.push(h2(e2 * x3));
  f4.push(f4[0]);
  const { spatialReference: M2, doUnnormalization: d3 } = o, R3 = j3([f4.map((t2) => o.localToMap(t2)).filter(k)], M2, d3, false), T2 = o.localToMap(h2(Math.PI / 2)), b4 = o.localToMap(h2(0)), U2 = o.localToMap(h2(-Math.PI / 2)), P2 = o.localToMap(h2(Math.PI));
  return { geometry: R3, midpoints: null != T2 && null != b4 && null != U2 && null != P2 ? { top: g2(T2, M2), right: g2(b4, M2), bottom: g2(U2, M2), left: g2(P2, M2) } : null };
}

export {
  d2 as d,
  R2 as R,
  j3 as j,
  T,
  b3 as b,
  L,
  v
};
//# sourceMappingURL=chunk-X5YTZ5V2.js.map
