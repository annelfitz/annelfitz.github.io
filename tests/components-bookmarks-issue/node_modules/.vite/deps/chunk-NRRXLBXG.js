import {
  t
} from "./chunk-ZURX6ZW7.js";
import {
  e as e3
} from "./chunk-QR7J3YDY.js";
import {
  s
} from "./chunk-GO2OGJDG.js";
import {
  e as e2
} from "./chunk-VYSGSKHB.js";
import {
  o as o2
} from "./chunk-IDPLBNJX.js";
import {
  n,
  o
} from "./chunk-P4MNTMCZ.js";
import {
  e
} from "./chunk-GLF3KRAL.js";
import {
  a
} from "./chunk-ZLQTPFTL.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/terrain/TileComposite.glsl.js
var a2 = class extends n {
  constructor() {
    super(...arguments), this.scale = 1, this.offset = a;
  }
};
function d(e5) {
  e5.attributes.add(e.POSITION, "vec2"), e5.attributes.add(e.UV0, "vec2"), e5.vertex.uniforms.add(new o2("scale", (e6) => e6.scale)), e5.vertex.uniforms.add(new e3("offset", (e6) => e6.offset)), e5.varyings.add("uv", "vec2"), e5.varyings.add("vuv", "vec2"), e5.vertex.code.add(o`void main(void) {
gl_Position = vec4(position, 0.0, 1.0);
uv = uv0 * scale + offset;
vuv = uv0;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/BlendOptions.js
var t2;
!function(t3) {
  t3[t3.Normal = 0] = "Normal", t3[t3.Average = 1] = "Average", t3[t3.Lighten = 2] = "Lighten", t3[t3.Lighter = 3] = "Lighter", t3[t3.Plus = 4] = "Plus", t3[t3.Screen = 5] = "Screen", t3[t3.ColorDodge = 6] = "ColorDodge", t3[t3.Darken = 7] = "Darken", t3[t3.Multiply = 8] = "Multiply", t3[t3.ColorBurn = 9] = "ColorBurn", t3[t3.Overlay = 10] = "Overlay", t3[t3.SoftLight = 11] = "SoftLight", t3[t3.HardLight = 12] = "HardLight", t3[t3.VividLight = 13] = "VividLight", t3[t3.Hue = 14] = "Hue", t3[t3.Saturation = 15] = "Saturation", t3[t3.Luminosity = 16] = "Luminosity", t3[t3.Color = 17] = "Color", t3[t3.DestinationOver = 18] = "DestinationOver", t3[t3.DestinationAtop = 19] = "DestinationAtop", t3[t3.DestinationIn = 20] = "DestinationIn", t3[t3.DestinationOut = 21] = "DestinationOut", t3[t3.SourceAtop = 22] = "SourceAtop", t3[t3.SourceIn = 23] = "SourceIn", t3[t3.SourceOut = 24] = "SourceOut", t3[t3.Xor = 25] = "Xor", t3[t3.Difference = 26] = "Difference", t3[t3.Exclusion = 27] = "Exclusion", t3[t3.Minus = 28] = "Minus", t3[t3.Invert = 29] = "Invert", t3[t3.Reflect = 30] = "Reflect", t3[t3.COUNT = 31] = "COUNT";
}(t2 || (t2 = {}));
var e4 = { normal: t2.Normal, average: t2.Average, lighten: t2.Lighten, lighter: t2.Lighter, screen: t2.Screen, plus: t2.Plus, "color-dodge": t2.ColorDodge, darken: t2.Darken, multiply: t2.Multiply, "color-burn": t2.ColorBurn, overlay: t2.Overlay, "soft-light": t2.SoftLight, "hard-light": t2.HardLight, "vivid-light": t2.VividLight, hue: t2.Hue, saturation: t2.Saturation, luminosity: t2.Luminosity, color: t2.Color, difference: t2.Difference, exclusion: t2.Exclusion, minus: t2.Minus, invert: t2.Invert, reflect: t2.Reflect, "destination-over": t2.DestinationOver, "destination-atop": t2.DestinationAtop, "destination-in": t2.DestinationIn, "destination-out": t2.DestinationOut, "source-atop": t2.SourceAtop, "source-in": t2.SourceIn, "source-out": t2.SourceOut, xor: t2.Xor };
function o3(e5) {
  return e5 === t2.DestinationOver || e5 === t2.DestinationAtop || e5 === t2.DestinationIn || e5 === t2.DestinationOut || e5 === t2.SourceAtop || e5 === t2.SourceIn || e5 === t2.SourceOut || e5 === t2.Xor;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/BlendModes.glsl.js
function l(l3, b) {
  const e5 = b.blendMode;
  e5 !== t2.Normal && (e5 === t2.Reflect && l3.code.add(o`float reflectBlend(in float cb, in float cl) {
return (cl == 1.0) ? cl : min(cb * cb / (1.0 - cl), 1.0);
}`), e5 !== t2.ColorDodge && e5 !== t2.VividLight || l3.code.add(o`float colorDodge(in float cb, in float cl) {
return (cb == 0.0) ? 0.0 : (cl == 1.0) ? 1.0 : min(1.0, cb / (1.0 - cl));
}`), e5 !== t2.ColorBurn && e5 !== t2.VividLight || l3.code.add(o`float colorBurn(in float cb, in float cl) {
return (cb == 1.0) ? 1.0 : (cl == 0.0) ? 0.0 : 1.0 - min(1.0, (1.0 - cb) / cl);
}`), e5 === t2.Overlay && l3.code.add(o`float overlay(in float cb, in float cl) {
return (1.0 - step(0.5, cl)) * (1.0 - 2.0 * (1.0 - cl ) * (1.0 - cb)) + step(0.5, cl) * (2.0 * cl * cb);
}`), e5 === t2.HardLight && l3.code.add(o`float hardLight(in float cb, in float cl) {
return (1.0 - step(0.5, cl)) * (2.0 * cl * cb) + step(0.5, cl) * (1.0 - 2.0 * (1.0 - cl) * (1.0 - cb));
}`), e5 === t2.SoftLight && l3.code.add(o`float softLight(in float cb, in float cl) {
if (cl <= 0.5) {
return cb - (1.0 - 2.0 * cl) * cb * (1.0 - cb);
}
if (cb <= 0.25) {
return cb + (2.0 * cl - 1.0) * cb * ((16.0 * cb - 12.0) * cb + 3.0);
}
return cb + (2.0 * cl - 1.0) * (sqrt(cb) - cb);
}`), e5 === t2.VividLight && l3.code.add(o`float vividLight(in float cb, in float cl) {
return (1.0 - step(0.5, cl)) * colorBurn(cb, 2.0 * cl) + step(0.5, cl) * colorDodge(cb, (2.0 * (cl - 0.5)));
}`), e5 !== t2.Hue && e5 !== t2.Saturation && e5 !== t2.Color && e5 !== t2.Luminosity || (l3.code.add(o`float minv3(in vec3 c) {
return min(min(c.r, c.g), c.b);
}
float maxv3(in vec3 c) {
return max(max(c.r, c.g), c.b);
}
float lumv3(in vec3 c) {
return dot(c, vec3(0.3, 0.59, 0.11));
}
vec3 clipColor(vec3 color) {
float lum = lumv3(color);
float mincol = minv3(color);
float maxcol = maxv3(color);
if (mincol < 0.0) {
color = lum + ((color - lum) * lum) / (lum - mincol);
}
if (maxcol > 1.0) {
color = lum + ((color - lum) * (1.0 - lum)) / (maxcol - lum);
}
return color;
}
vec3 setLum(vec3 cbase, vec3 clum) {
return clipColor(cbase + vec3(lumv3(clum) - lumv3(cbase)));
}`), e5 !== t2.Hue && e5 !== t2.Saturation || l3.code.add(o`float satv3(vec3 c) {
return maxv3(c) - minv3(c);
}
vec3 setLumSat(vec3 cbase, vec3 csat, vec3 clum)
{
float minbase = minv3(cbase);
float sbase = satv3(cbase);
float ssat = satv3(csat);
return setLum(sbase > 0.0 ? (cbase - minbase) * ssat / sbase : vec3(0.0), clum);
}`)), l3.code.add(o`
    vec4 applyBlendMode(vec3 cl, float ol, vec3 cb, float ob) {
      ${e5 === t2.Multiply ? o`return vec4(cl * ol * cb * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.Average ? o`return vec4((cb + cl) * 0.5 * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.Lighten ? o`return vec4(max(cb, cl) * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.Darken ? o`return vec4(min(cl, cb) * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.Lighter ? o`return vec4(cl * ol + cb * ob, ol + ob);` : e5 === t2.Plus ? o`return clamp(vec4(cl.rgb + cb.rgb, ol + ob), 0.0, 1.0);` : e5 === t2.Minus ? o`return vec4(clamp(vec3(cb.rgb - cl.rgb), 0.0, 1.0), ob * ol);` : e5 === t2.Screen ? o`return vec4((cl + cb - cl * cb) * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.Difference ? o`return vec4(abs(cb - cl) * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.Invert ? o`return vec4((1.0 - cb) * ol * ob + cb * ob * (1.0 - ol), ob);` : e5 === t2.DestinationOver ? o`return vec4(cl * ol * (1.0 - ob) + cb * ob, ol + ob - ol * ob);` : e5 === t2.DestinationAtop ? o`return vec4(cl * ol * (1.0 - ob) + cb * ob * ol, ol);` : e5 === t2.DestinationOut ? o`return vec4(cb * ob * (1.0 - ol), ob * (1.0 - ol));` : e5 === t2.SourceAtop ? o`return vec4(cl * ol * ob + cb * ob * (1.0 - ol), ob);` : e5 === t2.SourceOut ? o`return vec4(cl * ol * (1.0 - ob), ol * (1.0 - ob));` : e5 === t2.Xor ? o`return vec4(cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), ol * (1.0 - ob) + ob * (1.0 - ol));` : e5 === t2.DestinationIn ? o`return vec4(cb * ob * ol, ol * ob);` : e5 === t2.SourceIn ? o`return vec4(cl * ol * ob, ol * ob);` : e5 === t2.Hue ? o`
          vec3 f = setLumSat(cl, cb, cb);
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.Saturation ? o`
          vec3 f = setLumSat(cb, cl, cb);
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.Color ? o`
          vec3 f = setLum(cl, cb);
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.Luminosity ? o`
          vec3 f = setLum(cb, cl);
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.Exclusion ? o`
          vec3 f = cl + cb - 2.0 * cl * cb;
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.Reflect ? o`
          vec3 f = vec3(reflectBlend(cb.r, cl.r), reflectBlend(cb.g, cl.g), reflectBlend(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.ColorDodge ? o`
          vec3 f = vec3(colorDodge(cb.r, cl.r), colorDodge(cb.g, cl.g), colorDodge(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.ColorBurn ? o`
          vec3 f = vec3(colorBurn(cb.r, cl.r), colorBurn(cb.g, cl.g), colorBurn(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.Overlay ? o`
          vec3 f = vec3(overlay(cb.r, cl.r), overlay(cb.g, cl.g), overlay(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.SoftLight ? o`
          vec3 f = vec3(softLight(cb.r, cl.r), softLight(cb.g, cl.g), softLight(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.HardLight ? o`
          vec3 f = vec3(hardLight(cb.r, cl.r), hardLight(cb.g, cl.g), hardLight(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e5 === t2.VividLight ? o`
          vec3 f = vec3(vividLight(cb.r, cl.r), vividLight(cb.g, cl.g), vividLight(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : o``}
    }
  `));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/terrain/TileBackground.glsl.js
var u;
var n2;
var d2;
!function(o4) {
  o4[o4.Composite = 0] = "Composite", o4[o4.ColorComposite = 1] = "ColorComposite", o4[o4.GridComposite = 2] = "GridComposite", o4[o4.GroupBackgroundComposite = 3] = "GroupBackgroundComposite", o4[o4.COUNT = 4] = "COUNT";
}(u || (u = {})), function(o4) {
  o4[o4.NotRequired = 0] = "NotRequired", o4[o4.Required = 1] = "Required", o4[o4.COUNT = 2] = "COUNT";
}(n2 || (n2 = {})), function(o4) {
  o4[o4.Off = 0] = "Off", o4[o4.On = 1] = "On", o4[o4.COUNT = 2] = "COUNT";
}(d2 || (d2 = {}));
function m(o4, i) {
  const p = i.output === u.GridComposite, m2 = i.output === u.ColorComposite, f = i.output === u.GroupBackgroundComposite, C = i.output === u.Composite;
  p && o4.fragment.include(t), m2 && o4.fragment.uniforms.add(new e2("backgroundColor", (o5) => o5.backgroundColor));
  const g = i.baseOpacityMode === n2.Required;
  g && o4.fragment.uniforms.add(new o2("baseOpacity", (o5) => o5.baseOpacity)), C && o4.fragment.uniforms.add(new s("fboColor", (o5) => o5.fboTexture));
  const b = i.blendMode !== t2.Normal, y = i.premultipliedSource === d2.On;
  o4.fragment.include(l, i), o4.fragment.code.add(o`
    vec4 getBackground(vec2 uv) {
      return ${g ? o`baseOpacity *` : ""} ${f ? o`vec4(0.0, 0.0, 0.0, 0.0)` : m2 ? o`vec4(backgroundColor, 1.0)` : p ? o`vec4(gridColor(uv), 1.0)` : o`texelFetch(fboColor, ivec2(gl_FragCoord.xy), 0)`};
    }

    vec4 blendLayers(vec4 bgColor, vec4 colorLayer, float opacity) {
      ${b ? o`
          vec3 cl = colorLayer.a == 0.0 ? colorLayer.rgb : colorLayer.rgb / colorLayer.a;
          vec3 cb = bgColor.a == 0.0 ? bgColor.rgb : bgColor.rgb / bgColor.a;
          return applyBlendMode(clamp(cl, vec3(0.0), vec3(1.0)), colorLayer.a * opacity, cb, bgColor.a);` : o`
          float composeAlpha = colorLayer.a * opacity;
          return ${!y && (C && !g || f) ? o`colorLayer * opacity;` : o`bgColor * (1.0 - composeAlpha) + colorLayer * opacity;`}`}
    }`);
}

export {
  a2 as a,
  d,
  t2 as t,
  e4 as e,
  o3 as o,
  u,
  n2 as n,
  d2,
  m
};
//# sourceMappingURL=chunk-NRRXLBXG.js.map
