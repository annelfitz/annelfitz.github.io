import {
  r as r3
} from "./chunk-2KONNOEN.js";
import {
  V as V2,
  m,
  w
} from "./chunk-OZCCH2YL.js";
import {
  a as a5,
  v as v2
} from "./chunk-HJ7EOT7R.js";
import {
  o as o4
} from "./chunk-23GKO7D7.js";
import {
  s
} from "./chunk-45P2R3BJ.js";
import {
  x as x3
} from "./chunk-E22EEEDE.js";
import {
  c
} from "./chunk-KDHW2KXU.js";
import {
  e as e8,
  ee
} from "./chunk-6FMD7BOV.js";
import {
  f as f2
} from "./chunk-TKMRXVLK.js";
import {
  p as p3
} from "./chunk-6SB3EFZU.js";
import {
  g as g2
} from "./chunk-WOKVMRAD.js";
import {
  f as f3,
  t as t5
} from "./chunk-FXZUN4XG.js";
import "./chunk-3W2U3CD4.js";
import "./chunk-3ENNELTC.js";
import "./chunk-LEFES6LS.js";
import {
  a as a4,
  p as p2
} from "./chunk-ARNGZTAW.js";
import "./chunk-AEAYH74I.js";
import "./chunk-ZKV5BWYX.js";
import "./chunk-E6JAHJ2A.js";
import "./chunk-SVNPPUZN.js";
import "./chunk-UXQH3C5A.js";
import {
  i
} from "./chunk-QFYJUFUK.js";
import "./chunk-V7IF2KNH.js";
import "./chunk-LMCIQOBX.js";
import "./chunk-4VVENLLF.js";
import "./chunk-VUHMQQ6M.js";
import "./chunk-6GQQIJM7.js";
import "./chunk-PAH4PVZY.js";
import "./chunk-5T7MASZO.js";
import "./chunk-5WKN6K5Z.js";
import "./chunk-WCBHO6BH.js";
import "./chunk-V7NVRGBC.js";
import "./chunk-KCZGCTYM.js";
import {
  n as n4
} from "./chunk-3YZBQBZ5.js";
import "./chunk-RFBA77K3.js";
import {
  T,
  e as e7,
  i as i2
} from "./chunk-46T3D2EU.js";
import "./chunk-RYF27IO3.js";
import "./chunk-2GT6KC2O.js";
import {
  st
} from "./chunk-SPYHZ6ZW.js";
import "./chunk-637XZX4A.js";
import "./chunk-PMFQ2A2V.js";
import "./chunk-HHAESKQ6.js";
import "./chunk-6LT23NJG.js";
import "./chunk-4FXZDEEP.js";
import "./chunk-KYKKN5I4.js";
import "./chunk-4MJOJUFR.js";
import "./chunk-XKMZJHKM.js";
import {
  t as t4
} from "./chunk-DRUZYZGP.js";
import {
  n as n3
} from "./chunk-PTIWH4S7.js";
import {
  u as u5
} from "./chunk-L3GUCBXG.js";
import "./chunk-K3DEHPDR.js";
import "./chunk-I6RS7YIS.js";
import "./chunk-BHOYA5LV.js";
import {
  f,
  t as t3,
  u as u4
} from "./chunk-NN47JW6M.js";
import "./chunk-VXM3PR7E.js";
import "./chunk-VE57JPH4.js";
import "./chunk-KWLN46JY.js";
import "./chunk-7KNPDPFB.js";
import "./chunk-M6P775BS.js";
import "./chunk-J5F4VILS.js";
import "./chunk-KSBIR2KG.js";
import "./chunk-XVQGALI7.js";
import "./chunk-XFQIXBHG.js";
import "./chunk-MVSN2HAN.js";
import "./chunk-7A5N7G2Z.js";
import "./chunk-GL5TSVQL.js";
import "./chunk-FD7NY4JS.js";
import "./chunk-ZPC74XHC.js";
import "./chunk-IVGJRGD2.js";
import "./chunk-JA2AO4PC.js";
import "./chunk-MTLWPXQD.js";
import "./chunk-ZEMG7GKC.js";
import "./chunk-ECIXBYOQ.js";
import "./chunk-XIWETS2Q.js";
import "./chunk-FOCTPJDR.js";
import "./chunk-2DATALUO.js";
import "./chunk-QFKFOAJ6.js";
import "./chunk-LOPMLCHC.js";
import "./chunk-JIR2YP6A.js";
import "./chunk-LANUNBDP.js";
import "./chunk-JBF6CULO.js";
import "./chunk-DRCNNCTI.js";
import "./chunk-MKOOEINB.js";
import "./chunk-JKOHBDRD.js";
import "./chunk-MDSRD3WV.js";
import {
  h as h5
} from "./chunk-3DFMDDMO.js";
import "./chunk-4BCSYJOQ.js";
import "./chunk-GMUCR2DJ.js";
import "./chunk-HBRJJENW.js";
import "./chunk-VHY5K2VE.js";
import "./chunk-6ENXMQPD.js";
import "./chunk-FV43HSGW.js";
import "./chunk-ZR7OV2EH.js";
import "./chunk-U76EZJUZ.js";
import "./chunk-MEEG7XMI.js";
import "./chunk-LJULTBAY.js";
import "./chunk-7QHIE4SQ.js";
import "./chunk-6MGK5WBT.js";
import "./chunk-HSOVRETF.js";
import "./chunk-CPZW2LMK.js";
import "./chunk-QR7J3YDY.js";
import "./chunk-GO2OGJDG.js";
import "./chunk-UYMREM3D.js";
import "./chunk-4YGBWYMD.js";
import "./chunk-JTUYA5FE.js";
import "./chunk-UNTQATE2.js";
import "./chunk-5YY6NZNY.js";
import "./chunk-YUWVLORR.js";
import "./chunk-7MYYCSEB.js";
import "./chunk-ESK2YRQM.js";
import "./chunk-QIEXJLRX.js";
import "./chunk-UNTPHF5R.js";
import "./chunk-YJFPDMSR.js";
import "./chunk-FFG7BDAP.js";
import {
  h as h4
} from "./chunk-I4SHZ6P5.js";
import {
  F as F3,
  I
} from "./chunk-QYDOVVH7.js";
import "./chunk-YSXT2SWC.js";
import "./chunk-YH3SFFF7.js";
import "./chunk-JBU54P54.js";
import {
  I as I2
} from "./chunk-IWZSAF74.js";
import "./chunk-FMS3CZY7.js";
import "./chunk-H7T5AB2S.js";
import "./chunk-WKVHVZW2.js";
import "./chunk-KSZESDGM.js";
import "./chunk-CHJMCUAV.js";
import "./chunk-5P74D2TG.js";
import "./chunk-33LWZO2E.js";
import "./chunk-YT66FIGM.js";
import {
  b as b2,
  v
} from "./chunk-3IDXRFXE.js";
import "./chunk-RLZYC2LS.js";
import "./chunk-WEER6QME.js";
import "./chunk-TXLJQAAN.js";
import "./chunk-R4SGP2EA.js";
import "./chunk-IRL6OOVK.js";
import "./chunk-3AIILHI5.js";
import "./chunk-QJRGTKPN.js";
import "./chunk-VIH3KDZO.js";
import "./chunk-LA365FE7.js";
import {
  a as a3,
  b,
  h as h3
} from "./chunk-SA77Z3WI.js";
import "./chunk-D56W4LPT.js";
import "./chunk-BKOYOJBG.js";
import "./chunk-7JR6S3WL.js";
import "./chunk-B4E4X2TN.js";
import "./chunk-HS6YI5DU.js";
import "./chunk-CDBOQCLE.js";
import "./chunk-RSRUEM5U.js";
import "./chunk-HFJMEXIX.js";
import "./chunk-VYSGSKHB.js";
import "./chunk-UAFQMHYI.js";
import "./chunk-IDPLBNJX.js";
import "./chunk-ZHAZR5C3.js";
import "./chunk-P4MNTMCZ.js";
import "./chunk-FLBJ53KN.js";
import "./chunk-BSPKLAHD.js";
import "./chunk-VS6AHHIY.js";
import "./chunk-GPWQGIYV.js";
import "./chunk-WZJNHZ6H.js";
import "./chunk-XMYPMIYH.js";
import {
  d as d5,
  j as j2,
  k,
  l
} from "./chunk-FQLGRQKL.js";
import {
  F as F2,
  G
} from "./chunk-XGTCDM4C.js";
import "./chunk-BDRVHR2K.js";
import "./chunk-LQBHIBXV.js";
import "./chunk-42DUJ2CX.js";
import "./chunk-B35SNV2V.js";
import {
  t as t2
} from "./chunk-Z2F5OKVA.js";
import "./chunk-UQA6M3KF.js";
import "./chunk-GLF3KRAL.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-WIVZ7SMV.js";
import "./chunk-O76UVYOO.js";
import "./chunk-QCMUK3QA.js";
import "./chunk-HZSGATFT.js";
import "./chunk-KNMQQRV7.js";
import {
  e as e6
} from "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-SCHTG6ZQ.js";
import "./chunk-QYC3GV65.js";
import "./chunk-ETHGDNE6.js";
import "./chunk-X2GCSX3A.js";
import "./chunk-CQFVWMFK.js";
import {
  h as h2
} from "./chunk-USOPZ2Q6.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-QX66UTIR.js";
import "./chunk-ZIJHDTB7.js";
import "./chunk-ZU6I4R6T.js";
import "./chunk-JI3AZJ7K.js";
import "./chunk-A5Q7MMP6.js";
import "./chunk-326OSIM5.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-HTKSTTSR.js";
import "./chunk-6IED7TER.js";
import "./chunk-X7VSXJWW.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-AG6JXA4M.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-G5EVVNIJ.js";
import "./chunk-HU5IGOTI.js";
import "./chunk-C24MEKSO.js";
import {
  u as u3
} from "./chunk-WDPG5BMO.js";
import "./chunk-TGXFDJCS.js";
import {
  d as d4
} from "./chunk-BOAEEYBE.js";
import "./chunk-VBUVOOM6.js";
import "./chunk-UMXV3EBO.js";
import "./chunk-ONK5AE7R.js";
import "./chunk-CZSTCON2.js";
import {
  W
} from "./chunk-2ICUS4HL.js";
import "./chunk-ZXJ6I4RF.js";
import "./chunk-GBF2OQAY.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import {
  D,
  F,
  j
} from "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import {
  H,
  K,
  U,
  e as e5,
  g,
  p,
  r as r2,
  u as u2,
  x as x2,
  z
} from "./chunk-JZBR4X6W.js";
import {
  e as e4,
  n as n2,
  t
} from "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-TPLOIZC7.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-Z2PDA67N.js";
import "./chunk-IZKCZQUY.js";
import {
  x2 as x
} from "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import {
  A,
  P,
  d as d3
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  o as o3
} from "./chunk-TXBMNSNF.js";
import {
  d as d2
} from "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  S,
  r2 as r,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a2
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  d,
  e as e3,
  o as o2
} from "./chunk-JGDJR5EV.js";
import {
  e as e2,
  o,
  u
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import {
  a,
  n2 as n
} from "./chunk-7RBRCL6S.js";
import {
  h
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/3d/analysis/LineOfSightAnalysisResult.js
var s2 = class extends S {
  constructor(o5) {
    super(o5), this.target = null, this.intersectedGraphic = null, this.intersectedLocation = null, this.elevationAlignedTargetLocation = null, this.visible = void 0;
  }
};
e([y()], s2.prototype, "target", void 0), e([y()], s2.prototype, "intersectedGraphic", void 0), e([y()], s2.prototype, "intersectedLocation", void 0), e([y()], s2.prototype, "elevationAlignedTargetLocation", void 0), e([y({ type: Boolean })], s2.prototype, "visible", void 0), s2 = e([a2("esri.views.3d.analysis.LineOfSightAnalysisResult")], s2);

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightComputation.js
var i3 = class extends S {
  constructor(t6) {
    super(t6), this.elevationAlignedTargetLocation = null, this.inputPoints = { isValid: false, observer: n2(), observerSurfaceNormal: null, observerFeatureId: null, target: n2(), targetSurfaceNormal: null, targetFeatureId: null, observerAdjusted: n2(), targetAdjusted: n2() }, this.computationResult = { start: n2(), end: n2(), intersection: n2(), isValid: false, isTargetVisible: false }, this.result = null;
  }
  notifyResultChanged() {
    this.notifyChange("computationResult");
  }
  notifyInputPointsChanged() {
    this.notifyChange("inputPoints");
  }
};
e([y()], i3.prototype, "target", void 0), e([y()], i3.prototype, "elevationAlignedTargetLocation", void 0), e([y()], i3.prototype, "inputPoints", void 0), e([y()], i3.prototype, "computationResult", void 0), e([y()], i3.prototype, "result", void 0), i3 = e([a2("esri.views.3d.analysis.LineOfSight.LineOfSightComputation")], i3);

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightIntersectionResult.js
var m2;
var y2 = m2 = class extends S {
  constructor(r5) {
    super(r5);
  }
  clone() {
    return new m2({ type: this.type, id: a(this.id), mapPoint: a(this.mapPoint), renderPoint: t(this.renderPoint), normal: a(this.normal), ray: a(this.ray), graphic: this.graphic });
  }
  equals(r5) {
    return this.type === r5.type && this.id === r5.id && o(this.mapPoint, r5.mapPoint) && H(this.renderPoint, r5.renderPoint) && h(this.normal, r5.normal) && j2(this.ray, r5.ray) && this.graphic === r5.graphic;
  }
};
e([y()], y2.prototype, "type", void 0), e([y({ constructOnly: true })], y2.prototype, "id", void 0), e([y({ constructOnly: true })], y2.prototype, "mapPoint", void 0), e([y({ constructOnly: true })], y2.prototype, "renderPoint", void 0), e([y({ constructOnly: true })], y2.prototype, "normal", void 0), e([y({ constructOnly: true })], y2.prototype, "graphic", void 0), e([y({ constructOnly: true })], y2.prototype, "ray", void 0), y2 = m2 = e([a2("esri.views.3d.analysis.LineOfSight.LineOfSightIntersectionResult")], y2);

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightRayIntersector.js
var C = class extends S {
  constructor(e11) {
    super(e11), this._terrainIntersectionOptionsLayerUids = /* @__PURE__ */ new Set(["terrain"]);
  }
  initialize() {
    this.intersector = T(this.view.state.viewingMode), this.intersector.options.hud = false, this.intersector.options.store = e7.MIN;
  }
  getScreenPointIntersection(e11) {
    const r5 = d4(e11, t2.get()), i5 = g2(this.view.state.camera, r5, T2);
    return this._getRayIntersection(i5);
  }
  _getRayIntersection(e11, r5) {
    if (null == e11 || null == this.view.sceneIntersectionHelper)
      return null;
    const { intersector: t6 } = this;
    t6.options.store = e7.MIN, this.view.sceneIntersectionHelper.intersectToolIntersectorRay(e11, t6, r5);
    const i5 = t6.results.min, o5 = n2();
    if (!i5.getIntersectionPoint(o5))
      return null;
    if (null != (r5 == null ? void 0 : r5.maxDistance) && p(o5, e11.origin) > r5.maxDistance ** 2)
      return null;
    const n5 = this.view.renderCoordsHelper.fromRenderCoords(o5, new x({ spatialReference: this.view.spatialReference })), a6 = t(i5.normal);
    if (a4(i5))
      return new y2({ type: i2.OBJECT, id: `${i5.target.layerUid}/${i5.target.nodeIndex}/${i5.target.componentIndex}`, mapPoint: n5, renderPoint: o5, normal: a6, ray: k(e11), graphic: null });
    if (p2(i5))
      return new y2({ type: i2.OBJECT, id: `${i5.target.layerUid}/${i5.target.graphicUid}`, mapPoint: n5, renderPoint: o5, normal: a6, ray: k(e11), graphic: null });
    if (n4(i5))
      return new y2({ type: i2.TERRAIN, id: i5.target.lij.slice(), mapPoint: n5, renderPoint: o5, normal: a6, ray: k(e11), graphic: null });
    const c3 = m(i5, this.view);
    if (null != c3) {
      const r6 = c3.layer, t7 = c3.sourceLayer;
      let i6;
      if (t7)
        if ("scene" === t7.type)
          i6 = I2(c3, t7.objectIdField);
        else
          i6 = c3.uid;
      else
        i6 = c3.uid;
      return new y2({ type: i2.OBJECT, id: `${r6 == null ? void 0 : r6.uid}/${i6}`, mapPoint: n5, renderPoint: o5, normal: a6, ray: k(e11), graphic: c3 });
    }
    return null;
  }
  updateFromGroundIntersection(e11, r5, t6) {
    const i5 = L, o5 = O, s4 = S2, m4 = $;
    r2(o5, e11), this.view.renderCoordsHelper.worldUpAtPosition(o5, s4), z(s4, s4);
    const u8 = this.view.basemapTerrain.visibleElevationBounds, d9 = (r5 >= 0 ? 1 : -1) * ((u8 ? Math.abs(u8.max - u8.min) : 100) + Math.abs(r5));
    g(m4, s4, d9), u2(i5, o5, m4), l(i5, o5, T2);
    const f5 = this._getRayIntersection(T2, { include: this._terrainIntersectionOptionsLayerUids, maxDistance: d9 });
    if (null != f5) {
      const e12 = $;
      return g(e12, s4, r5), u2(t6, f5.renderPoint, e12), t(f5.normal);
    }
    return r2(t6, e11), null;
  }
};
e([y()], C.prototype, "view", void 0), e([y()], C.prototype, "intersector", void 0), C = e([a2("esri.views.3d.analysis.LineOfSight.LineOfSightRayIntersector")], C);
var L = n2();
var O = n2();
var S2 = n2();
var $ = n2();
var T2 = d5();

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightController.js
var U2 = class extends o3.EventedMixin(S) {
  constructor(e11) {
    super(e11), this.updateOnCameraChange = true, this._observerGroundOffsetRenderSpace = 0, this._effectiveObserverElevationMode = "absolute-height", this._observerFeatureId = null, this._updatingHandles = new h4(), this._frameTask = F3, this._computationHandles = new r(), this._externalObserverUpdate = true;
  }
  initialize() {
    var _a;
    const e11 = (_a = this.view.resourceController) == null ? void 0 : _a.scheduler;
    this._frameTask = e11 ? e11.registerTask(I.LINE_OF_SIGHT_TOOL) : F3, this._intersector = new C({ view: this.view }), this.addHandles([this._connectObserver(), this._connectComputations(), this._connectTargets()]);
  }
  destroy() {
    this._computationHandles.destroy(), this._computations.removeAll(), this._updatingHandles.destroy();
  }
  get updating() {
    return this._frameTask.updating || this._updatingHandles.updating;
  }
  get priority() {
    return this._frameTask.priority;
  }
  set priority(e11) {
    this._frameTask.priority = e11;
  }
  get _computations() {
    return this.analysisViewData.computations;
  }
  get _elevationAlignedObserverPositionRenderSpace() {
    return this.analysisViewData.observerEngineLocation;
  }
  set _elevationAlignedObserverPositionRenderSpace(e11) {
    this.analysisViewData.observerEngineLocation = e11;
  }
  get _screenPixelSize() {
    return this.view.state.camera.computeScreenPixelSizeAt(this._elevationAlignedObserverPositionRenderSpace);
  }
  _computeResult(e11) {
    const t6 = e11.computation, { inputPoints: n5, computationResult: o5 } = t6, { observerAdjusted: i5, targetAdjusted: r5 } = n5, { start: s4, end: a6 } = o5;
    r2(s4, i5), r2(a6, r5);
    this._canCompute(t6) ? this._computeIntersection(e11) : B(e11), t6.notifyResultChanged(), this.emit("result-changed", { target: e11.computation.target, result: t6.result });
  }
  _updateAdjustedPointsFromFeatures(e11) {
    const n5 = this.view, { sceneIntersectionHelper: o5 } = n5, { inputPoints: i5 } = e11, { observerAdjusted: r5, observerFeatureId: s4, targetFeatureId: a6, targetAdjusted: l3 } = i5;
    if (null == s4 && null == a6)
      return;
    const u8 = x2(r5, l3), c3 = this._intersector.intersector, d9 = l(i5.observer, i5.target, Q);
    c3.options.store = e7.ALL, o5.intersectToolIntersectorRay(d9, c3);
    let p4 = null, g3 = null, h7 = null, v3 = null;
    for (const m4 of c3.results.all) {
      const e12 = m(m4, this.view);
      if (null == e12 || null == m4.distanceInRenderSpace)
        continue;
      const o6 = t3(e12);
      null != o6 && (null != s4 && o6 === s4 && (null == p4 && (p4 = Z(m4, n5, u8)), m4.distanceInRenderSpace < p4 && (h7 = m4)), null != a6 && o6 === a6 && (null == g3 && (g3 = Z(m4, n5, u8)), null == v3 && m4.distanceInRenderSpace < u8 && u8 - m4.distanceInRenderSpace < g3 && (v3 = m4)));
    }
    null != h7 && h7.getIntersectionPoint(r5) && (i5.observerSurfaceNormal = h7.getTransformedNormal(n2())), null != v3 && v3.getIntersectionPoint(l3) && (i5.targetSurfaceNormal = v3.getTransformedNormal(n2()));
  }
  _adjustStartEndPositions(e11) {
    const t6 = this._screenPixelSize, n5 = this.view, { inputPoints: o5 } = e11, { observer: i5, observerSurfaceNormal: r5, target: s4, targetSurfaceNormal: a6, observerAdjusted: l3, targetAdjusted: u8 } = o5, c3 = K2;
    r2(l3, i5), r2(u8, s4), this._updateAdjustedPointsFromFeatures(e11), null != r5 ? r2(c3, r5) : e5(c3, u8, l3);
    const d9 = t6;
    z(c3, c3), g(c3, c3, Math.min(d9, 1)), u2(l3, l3, c3), null != a6 ? r2(c3, a6) : e5(c3, l3, u8);
    const p4 = n5.state.camera.computeScreenPixelSizeAt(u8);
    z(c3, c3), g(c3, c3, Math.min(p4, 1)), u2(u8, u8, c3);
  }
  _computeIntersection({ computation: e11, interpolationInfo: t6 }) {
    const { view: n5 } = this, { sceneIntersectionHelper: o5, renderCoordsHelper: i5 } = n5;
    if (null == o5)
      return;
    const r5 = this._intersector.intersector, { computationResult: s4, inputPoints: a6 } = e11, { observer: l3, target: u8 } = a6, { start: c3, end: d9 } = s4, p4 = l(c3, d9, Q);
    r5.options.store = e7.MIN, o5.intersectToolIntersectorRay(p4, r5);
    const g3 = r5.results.min, m4 = s4.intersection, v3 = K2;
    let f5 = true;
    if (null != g3 && g3.getIntersectionPoint(m4)) {
      r2(t6.originalIntersection, m4), r2(t6.originalObserver, c3), r2(t6.originalTarget, d9), i5.fromRenderCoords(m4, v3, n5.spatialReference);
      const e12 = 1 - U(d9, u8) / U(c3, u8);
      f5 = U(l3, m4) >= e12 * U(l3, u8);
    }
    const _2 = new x(v3, n5.spatialReference);
    {
      const { result: t7, target: o6 } = e11;
      null != t7 ? (t7.target = o6, t7.intersectedGraphic = f5 ? null : m(g3, n5), t7.intersectedLocation = f5 ? null : _2, t7.visible = f5) : e11.result = new s2({ target: o6, elevationAlignedTargetLocation: e11.elevationAlignedTargetLocation, intersectedGraphic: f5 ? null : m(g3, n5), intersectedLocation: f5 ? null : _2, visible: f5 });
    }
    s4.isValid = a6.isValid = true, s4.isTargetVisible = f5;
  }
  _canCompute(e11) {
    const t6 = this.analysisViewData.elevationAlignedObserver, n5 = this.view.frustum;
    if (null == t6 || null == e11.elevationAlignedTargetLocation || null == n5)
      return false;
    const { observerAdjusted: o5, targetAdjusted: i5 } = e11.inputPoints, r5 = n5.intersectsPoint(o5), s4 = n5.intersectsPoint(i5);
    return r5 && s4;
  }
  _onObserverPositionChange(e11, n5, o5, i5, r5) {
    if (this._externalObserverUpdate = r5, null == e11)
      return this.analysisViewData.elevationAlignedObserver = null, void (this._observerFeatureId = null);
    if (null == n5)
      return t5(this.analysis, e11.spatialReference, n.getLogger(this)), void (this.analysisViewData.elevationAlignedObserver = null);
    const s4 = q(n5, o5), { absoluteZ: a6, elevation: u8 } = b(n5.x, n5.y, n5.z, this.view.spatialReference, this.view, s4), c3 = n5.clone();
    c3.z = a6, this._effectiveObserverElevationMode = s4.mode, this.analysisViewData.elevationAlignedObserver = c3;
    const d9 = n2();
    this.view.renderCoordsHelper.toRenderCoords(c3, d9), this._elevationAlignedObserverPositionRenderSpace = d9, this._observerGroundOffsetRenderSpace = a6 - u8, this._observerFeatureId = t3(i5), this.priority = I.LINE_OF_SIGHT_TOOL_INTERACTIVE;
  }
  _onObserverRenderSpacePositionChangeForComputation(e11, t6, n5, o5, i5) {
    const { inputPoints: r5 } = e11;
    switch (r2(r5.observer, t6), r5.observerFeatureId = i5, r5.observerSurfaceNormal = null, o5) {
      case "on-the-ground":
      case "relative-to-ground": {
        const e12 = this._intersector.updateFromGroundIntersection(r5.observer, n5, r5.observer);
        null == r5.observerFeatureId && (r5.observerSurfaceNormal = e12);
      }
    }
    this._adjustStartEndPositions(e11), e11.notifyInputPointsChanged(), this.priority = I.LINE_OF_SIGHT_TOOL_INTERACTIVE;
  }
  _onTargetPositionChange(e11, n5, o5, i5, r5, s4 = true) {
    const a6 = e11.inputPoints;
    if (s4 && (a6.isValid = false), null == o5)
      return null != n5 && t5(this.analysis, n5.spatialReference, n.getLogger(this)), e11.elevationAlignedTargetLocation = null, void e11.notifyInputPointsChanged();
    const u8 = q(o5, i5), { absoluteZ: c3, elevation: d9 } = b(o5.x, o5.y, o5.z, this.view.spatialReference, this.view, u8), p4 = o5.clone();
    switch (p4.z = c3, e11.elevationAlignedTargetLocation = p4, this.view.renderCoordsHelper.toRenderCoords(e11.elevationAlignedTargetLocation, a6.target), a6.targetFeatureId = t3(r5), a6.targetSurfaceNormal = null, u8.mode) {
      case "on-the-ground":
      case "relative-to-ground": {
        const e12 = this._intersector.updateFromGroundIntersection(a6.target, c3 - d9, a6.target);
        null == a6.targetFeatureId && (a6.targetSurfaceNormal = e12);
      }
    }
    this._adjustStartEndPositions(e11), e11.notifyInputPointsChanged(), this.priority = I.LINE_OF_SIGHT_TOOL_INTERACTIVE;
  }
  _connectComputationToTarget(e11) {
    return o2([this._updatingHandles.add(() => ({ computation: e11, targetPosition: e11.target.position, targetElevationInfo: e11.target.elevationInfo, targetFeatureInfo: e11.target.feature, projectedTargetPosition: W(e11.target.position, this.view.spatialReference) }), ({ computation: e12, targetPosition: t6, targetElevationInfo: n5, targetFeatureInfo: o5, projectedTargetPosition: i5 }) => {
      null == i5.pending ? this._onTargetPositionChange(e12, t6, i5.geometry, n5, o5) : this._updatingHandles.addPromise(i5.pending);
    }, P)]);
  }
  _connectComputationToObserver(e11) {
    return this._updatingHandles.add(() => ({ computation: e11, observer: this.analysisViewData.elevationAlignedObserver }), ({ computation: e12 }) => {
      this._externalObserverUpdate && (e12.inputPoints.isValid = false, e12.notifyInputPointsChanged());
    }, P);
  }
  _connectComputationToRenderSpaceObserver(e11) {
    return this._updatingHandles.add(() => ({ computation: e11, observer: this._elevationAlignedObserverPositionRenderSpace, observerGroundOffset: this._observerGroundOffsetRenderSpace, observerElevationMode: this._effectiveObserverElevationMode, observerFeatureId: this._observerFeatureId }), ({ computation: e12, observer: t6, observerGroundOffset: n5, observerElevationMode: o5, observerFeatureId: i5 }) => {
      this._onObserverRenderSpacePositionChangeForComputation(e12, t6, n5, o5, i5);
    }, P);
  }
  _connectComputationToCamera(e11) {
    return this._updatingHandles.add(() => ({ camera: this.view.state.camera, isDirty: this._isCameraDirty }), ({ isDirty: t6 }) => {
      !this.updateOnCameraChange || e11.inputPoints.isValid && !t6 || e11.notifyInputPointsChanged();
    });
  }
  _connectComputationToSlicePlane(e11) {
    return this._updatingHandles.add(() => this.view.slicePlane, () => {
      e11.inputPoints.isValid = false, e11.notifyInputPointsChanged();
    });
  }
  _connectComputationToElevation(e11) {
    const t6 = (n5, o5) => {
      const i5 = this.analysis.observer, r5 = e11.target;
      let s4 = null, a6 = null, l3 = null, u8 = null, c3 = null, d9 = null;
      if (null != (i5 == null ? void 0 : i5.position)) {
        const e12 = W(i5.position, this.view.spatialReference);
        if (null != e12.pending)
          return this._updatingHandles.addPromise(e12.pending), void e12.pending.finally(() => t6(n5, o5));
        s4 = e12.geometry, a6 = i5.elevationInfo, l3 = i5.feature;
      }
      if (null != r5.position) {
        const e12 = W(r5.position, this.view.spatialReference);
        if (null != e12.pending)
          return this._updatingHandles.addPromise(e12.pending), void e12.pending.finally(() => t6(n5, o5));
        u8 = e12.geometry, c3 = r5.elevationInfo, d9 = r5.feature;
      }
      null == s4 && null == u8 || (i(n5, o5, W2, this.view.spatialReference), null != s4 && F(W2, s4) && this._onObserverPositionChange(null != i5 ? i5.position : null, s4, a6, l3, false), null != u8 && F(W2, u8) && this._onTargetPositionChange(e11, r5.position, u8, c3, d9, false), null != s4 && null != u8 && j(W2, s4, u8) && e11.notifyInputPointsChanged());
    };
    return this.view.elevationProvider.on("elevation-change", ({ extent: e12, spatialReference: n5 }) => t6(e12, n5));
  }
  _connectComputationToTask(e11) {
    let t6 = null;
    const n5 = { computation: e11, interpolationInfo: { originalIntersection: n2(), originalObserver: n2(), originalTarget: n2() } };
    return o2([this._updatingHandles.add(() => e11.inputPoints, () => {
      t6 = e2(t6), t6 = d2(async (e12) => {
        await d(this._frameTask.schedule(() => this._computeResult(n5), e12));
      });
    }, { initial: true, equals: () => false }), e3(() => t6 = e2(t6))]);
  }
  _connectComputation(e11) {
    const t6 = this._computationHandles;
    t6.has(e11) || t6.add([this._connectComputationToTarget(e11), this._connectComputationToObserver(e11), this._connectComputationToRenderSpaceObserver(e11), this._connectComputationToCamera(e11), this._connectComputationToSlicePlane(e11), this._connectComputationToElevation(e11), this._connectComputationToTask(e11)], e11);
  }
  _disconnectComputation(e11) {
    this._computationHandles.remove(e11);
  }
  _onComputationCollectionChange({ added: e11, removed: t6 }) {
    for (const n5 of t6)
      this._disconnectComputation(n5);
    for (const n5 of e11)
      this._connectComputation(n5);
  }
  _onTargetCollectionChange({ added: e11, removed: t6 }) {
    for (const n5 of t6)
      this._removeTarget(n5);
    for (const n5 of e11)
      this._addTarget(n5);
  }
  _onCursorTargetChange(e11, t6) {
    null != t6 && this._removeTarget(t6), null != e11 && this._addTarget(e11);
  }
  _addTarget(e11) {
    this._computations.some((t6) => t6.target === e11) || this._computations.add(new i3({ target: e11 }));
  }
  _removeTarget(e11) {
    const t6 = this._computations.findIndex((t7) => t7.target === e11);
    this._computations.removeAt(t6);
  }
  _connectObserver() {
    return o2([this._updatingHandles.add(() => ({ observerPosition: null != this.analysis.observer ? this.analysis.observer.position : null, projectedObserverPosition: W(null != this.analysis.observer ? this.analysis.observer.position : null, this.view.spatialReference), observerElevationInfo: null != this.analysis.observer ? this.analysis.observer.elevationInfo : null, observerFeatureInfo: null != this.analysis.observer ? this.analysis.observer.feature : null }), ({ observerPosition: e11, projectedObserverPosition: t6, observerElevationInfo: n5, observerFeatureInfo: o5 }) => {
      null == t6.pending ? this._onObserverPositionChange(e11, t6.geometry, n5, o5, true) : this._updatingHandles.addPromise(t6.pending);
    }, P)]);
  }
  _connectComputations() {
    return this._updatingHandles.addOnCollectionChange(() => this._computations, (e11) => this._onComputationCollectionChange(e11), { initial: true, final: true });
  }
  _connectTargets() {
    return o2([this._updatingHandles.addOnCollectionChange(() => this.analysis.targets, (e11) => this._onTargetCollectionChange(e11), { initial: true, final: true }), this._updatingHandles.add(() => this.analysisViewData.cursorTarget, (e11, t6) => {
      this._onCursorTargetChange(e11, t6);
    })]);
  }
  get _isCameraDirty() {
    const e11 = this.analysisViewData.elevationAlignedObserver, { view: t6 } = this, { renderCoordsHelper: n5 } = t6;
    if (null == e11 || null == n5)
      return false;
    const o5 = K2;
    n5.toRenderCoords(e11, o5);
    const i5 = t6.state.camera.computeScreenPixelSizeAt(o5);
    return Math.abs((i5 - this._screenPixelSize) / this._screenPixelSize) > J;
  }
};
function Z(e11, t6, n5) {
  if (w(e11)) {
    const o5 = V2(e11, t6);
    if (null != o5)
      return Math.min(o5 * X, n5);
  }
  return 1e-5 * n5;
}
function q(e11, t6) {
  return e11.hasZ ? t6 ?? { mode: "absolute-height", offset: 0 } : { mode: "on-the-ground", offset: 0 };
}
function B({ computation: e11, interpolationInfo: t6 }) {
  const { computationResult: n5, inputPoints: o5 } = e11, { start: i5, end: r5, intersection: s4 } = n5, { originalIntersection: a6, originalObserver: l3, originalTarget: u8 } = t6;
  if (r2(s4, a6), o5.isValid) {
    const e12 = K2, t7 = U(l3, a6) / U(l3, u8);
    K(e12, i5, l3), g(e12, e12, 1 - t7), u2(s4, s4, e12), K(e12, r5, u8), g(e12, e12, t7), u2(s4, s4, e12), n5.isValid = true;
  } else
    e11.result = null, n5.isValid = false, n5.isTargetVisible = false;
}
e([y({ constructOnly: true })], U2.prototype, "analysis", void 0), e([y({ constructOnly: true })], U2.prototype, "analysisViewData", void 0), e([y({ constructOnly: true })], U2.prototype, "view", void 0), e([y()], U2.prototype, "updating", null), e([y()], U2.prototype, "priority", null), e([y()], U2.prototype, "updateOnCameraChange", void 0), e([y()], U2.prototype, "_computations", null), e([y()], U2.prototype, "_elevationAlignedObserverPositionRenderSpace", null), e([y()], U2.prototype, "_observerGroundOffsetRenderSpace", void 0), e([y()], U2.prototype, "_effectiveObserverElevationMode", void 0), e([y()], U2.prototype, "_observerFeatureId", void 0), e([y()], U2.prototype, "_screenPixelSize", null), e([y({ readOnly: true })], U2.prototype, "_updatingHandles", void 0), e([y()], U2.prototype, "_frameTask", void 0), e([y()], U2.prototype, "_isCameraDirty", null), U2 = e([a2("esri.views.3d.analysis.LineOfSight.LineOfSightController")], U2);
var J = 0.1;
var K2 = n2();
var Q = d5();
var W2 = D();
var X = 0.05;

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightConfiguration.js
var e9 = class {
  constructor() {
    this.glowWidth = 8, this.innerWidth = 0.75;
  }
};
var r4 = new e9();
function s3(o5) {
  const t6 = o5.accentColor;
  return { glowColor: t6, innerColor: G(t6), globalAlpha: 0.75 * t6.a };
}
var i4 = class {
  constructor() {
    this.size = 0.5;
  }
};
var c2 = new i4();
function l2(o5) {
  return F2(o5.accentColor, 0.75);
}
var h6 = class {
  constructor() {
    this.size = 0.5, this.visibleColor = new u3([3, 252, 111, 0.75]), this.occludedColor = new u3([252, 3, 69, 0.75]), this.undefinedColor = new u3([127, 127, 127, 0.75]);
  }
};
var u6 = new h6();
var d6 = class {
  constructor() {
    this.innerWidth = 2, this.outerWidth = 8, this.visibleInnerColor = new u3([3, 252, 111, 1]), this.visibleOuterColor = new u3([3, 252, 111, 0.15]), this.occludedInnerColor = new u3([252, 3, 69, 1]), this.occludedOuterColor = new u3([252, 3, 69, 0.1]), this.undefinedInnerColor = new u3([255, 255, 255, 1]), this.undefinedOuterColor = new u3([127, 127, 127, 0.2]);
  }
};
var w2 = new d6();

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightManipulators.js
var f4 = class extends ee {
  constructor(e11, i5) {
    const s4 = f2(l2(e11.effectiveTheme)), l3 = st(s4, c2.size, 32, 32), f5 = new e8(l3);
    super({ view: e11, renderObjects: [f5], metadata: i5, elevationInfo: { mode: "absolute-height", offset: 0 } }), r3(this), this.themeHandle = d3(() => ({ color: l2(e11.effectiveTheme) }), (e12) => {
      s4.setParameters(e12);
    });
  }
  destroy() {
    this.themeHandle.remove(), super.destroy();
  }
};
var d7 = class extends ee {
  constructor(e11, t6) {
    const { size: o5, visibleColor: r5, occludedColor: s4, undefinedColor: n5 } = u6;
    super({ view: e11, renderObjects: [u7(o5, r5, u5.Custom1), u7(o5, s4, u5.Custom2), u7(o5, n5, u5.Custom3)], metadata: t6, elevationInfo: { mode: "absolute-height", offset: 0 } }), r3(this);
  }
};
function u7(t6, o5, r5) {
  return new e8(st(f2(u3.toUnitRGBA(o5)), t6, 32, 32), r5);
}

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightTool.js
var I3;
!function(e11) {
  e11.Ready = "ready", e11.Creating = "creating", e11.Created = "created";
}(I3 || (I3 = {}));
var O2 = class extends o4 {
  constructor(e11) {
    super(e11), this.removeIncompleteOnCancel = false, this.analysisViewData = null, this._latestPointerMovePointerType = null, this._laserlineVisualElement = null, this._grabbedManipulator = null, this._analysisHandles = new r(), this._updatingHandles = new h4(), this._manipulatorHandles = new r(), this._targetTrackerManipulator = null;
  }
  initialize() {
    this._intersector = new C({ view: this.view }), this.addHandles(d3(() => this.state, (e11) => {
      e11 === I3.Created && this.finishToolCreation();
    }, A)), this._observerManipulator = this._createObserverManipulator(), this._createLaserLine(), this.addHandles([this._updatingHandles.add(() => {
      var _a;
      return (_a = this.analysisViewData) == null ? void 0 : _a.elevationAlignedObserver;
    }, (e11) => this._onObserverLocationChange(e11), P), this._updatingHandles.add(() => s3(this.view.effectiveTheme), ({ glowColor: e11, innerColor: t6, globalAlpha: i5 }) => this._updateLaserLineStyle(e11, t6, i5), P), this._updatingHandles.add(() => this._laserLineRendererDependencies(), (e11) => this._updateLaserLineRenderer(e11)), this._connectComputations(), this._updatingHandles.addWhen(() => !this._shouldRenderTracker, () => this._clearCursorTracker(), P)]);
  }
  destroy() {
    this._updatingHandles = u(this._updatingHandles), this._manipulatorHandles = u(this._manipulatorHandles), this._analysisHandles = u(this._analysisHandles), this._observerManipulator = null, this._clearCursorTracker(), this._removeLaserLine(), this._intersector = null, this._set("analysis", null);
  }
  get state() {
    var _a;
    return this.active ? this.hasGrabbedManipulators ? I3.Created : I3.Creating : null != ((_a = this.analysis.observer) == null ? void 0 : _a.position) ? I3.Created : I3.Ready;
  }
  get cursor() {
    return this.active && this._showTracker ? "crosshair" : null;
  }
  get updating() {
    return null != this.analysisViewData && this.analysisViewData.updating || this._updatingHandles.updating;
  }
  get _showTracker() {
    return this.active && "mouse" === this._latestPointerMovePointerType;
  }
  get _shouldRenderTracker() {
    var _a;
    return this._showTracker && null != ((_a = this.analysis.observer) == null ? void 0 : _a.position) && !this.hasGrabbedManipulators;
  }
  continue() {
    this.view.activeTool = this;
  }
  stop() {
    this.view.activeTool = null;
  }
  onEditableChange() {
    this.analysisViewData.editable = this.internallyEditable;
  }
  onInputEvent(e11) {
    switch (e11.type) {
      case "immediate-double-click":
        this._doubleClickHandler(e11);
        break;
      case "key-down":
        this._keyDownHandler(e11);
        break;
      case "pointer-move":
        this._pointerMoveHandler(e11);
    }
  }
  onInputEventAfter(e11) {
    if ("immediate-click" === e11.type)
      this._clickHandler(e11);
  }
  onShow() {
  }
  onHide() {
  }
  onDeactivate() {
    this._clearCursorTracker();
  }
  _connectComputations() {
    return this._updatingHandles.addOnCollectionChange(() => this.analysisViewData.computations, (e11) => this._onComputationsCollectionChange(e11), { initial: true, final: true });
  }
  _onComputationsCollectionChange({ added: e11, removed: t6 }) {
    for (const i5 of t6)
      this._disconnectComputation(i5);
    for (const i5 of e11)
      this._connectComputation(i5);
  }
  _connectComputation(e11) {
    if (this.destroyed)
      return void n.getLogger(this).warn("Attempting to connect an analysis to a destroyed LineOfSight tool. Ignoring.");
    const t6 = this._analysisHandles;
    if (t6.has(e11))
      return;
    const i5 = this._createTargetManipulator(e11.target);
    null == this._targetTrackerManipulator && i5.metadata.target === this.analysisViewData.cursorTarget && (this._targetTrackerManipulator = i5, this._targetTrackerManipulator.available = false, this._targetTrackerManipulator.interactive = false, this._updateLaserLineRenderer()), t6.add([this._updatingHandles.add(() => E(e11), () => D2(i5, e11), P), this._updatingHandles.add(() => e11.elevationAlignedTargetLocation, (e12) => this._onTargetLocationChange(e12, i5), P)], e11);
  }
  _disconnectComputation(e11) {
    if (this.destroyed)
      return void n.getLogger(this).warn("Attempting to disconnect an analysis from a destroyed LineOfSight tool. Ignoring.");
    this._analysisHandles.remove(e11);
    const t6 = this._getTargetManipulator(e11.target);
    null != t6 && (this.manipulators.remove(t6), this._manipulatorHandles.remove(t6), null != this._targetTrackerManipulator && this._targetTrackerManipulator === t6 && (this._targetTrackerManipulator = null));
  }
  _clearCursorTracker() {
    this.analysisViewData.cursorTarget = u(this.analysisViewData.cursorTarget);
  }
  _createTargetManipulator(e11) {
    const t6 = { target: e11, type: "target" }, i5 = new d7(this.view, t6);
    return this._manipulatorHandles.add([this._createTargetManipulatorDragPipeline(i5), i5.events.on("grab-changed", (e12) => this._manipulatorGrabChanged(i5, e12)), i5.events.on("immediate-click", (e12) => this._manipulatorClick(i5, e12))], i5), this.manipulators.add(i5), null != e11.position ? i5.elevationAlignedLocation = e11.position : i5.available = false, i5;
  }
  _getTargetManipulator(e11) {
    let t6 = null;
    return this.manipulators.forEach((i5) => {
      const a6 = i5.manipulator;
      null == t6 && "target" === a6.metadata.type && a6.metadata.target === e11 && (t6 = a6);
    }), t6;
  }
  _createObserverManipulator() {
    const e11 = new f4(this.view, { type: "observer", intersection: null });
    return this._manipulatorHandles.add([this._createObserverManipulatorDragPipeline(e11), e11.events.on("grab-changed", (t6) => this._manipulatorGrabChanged(e11, t6)), e11.events.on("immediate-click", (t6) => this._manipulatorClick(e11, t6))], e11), this.manipulators.add(e11), e11;
  }
  _screenToIntersection() {
    return (e11) => {
      const t6 = this._intersector.getScreenPointIntersection(e11.screenEnd);
      return null == t6 ? null : { ...e11, intersection: t6 };
    };
  }
  _createTargetManipulatorDragPipeline(e11) {
    return p3(e11, (t6, i5, a6) => {
      i5.next(this._screenToIntersection()).next(this._updateTargetDragStep(e11)).next(() => this._updateLaserLineRenderer()), a6.next(R(e11.metadata.target)).next(() => this._updateLaserLineRenderer());
    });
  }
  _createObserverManipulatorDragPipeline(e11) {
    return p3(e11, (e12, t6, i5) => {
      t6.next(this._screenToIntersection()).next(this._updateObserverDragStep()).next(() => this._updateLaserLineRenderer()), i5.next(this._cancelObserverDragStep()).next(() => this._updateLaserLineRenderer());
    });
  }
  _updateObserverDragStep() {
    return (e11) => (null != e11.intersection.mapPoint ? (null == this.analysis.observer && (this.analysis.observer = new u4()), this._updateFromIntersection(this.analysis.observer, e11.intersection)) : this.analysis.observer = null, e11);
  }
  _cancelObserverDragStep() {
    var _a;
    const e11 = null != ((_a = this.analysis.observer) == null ? void 0 : _a.position) ? this.analysis.observer.clone() : null;
    return (t6) => (this.analysis.observer = e11, t6);
  }
  _updateTargetDragStep(e11) {
    return (t6) => {
      this._updateFromIntersection(e11.metadata.target, t6.intersection);
      const i5 = t6.intersection.mapPoint;
      return null != i5 && (e11.elevationAlignedLocation = i5), t6;
    };
  }
  _manipulatorGrabChanged(e11, t6) {
    switch (t6.action) {
      case "start":
        this._grabbedManipulator = e11;
        break;
      case "end":
        this._grabbedManipulator === e11 && (this._grabbedManipulator = null);
    }
  }
  _laserLineRendererDependencies() {
    return { laserlineVisualElement: this._laserlineVisualElement, grabbedManipulator: this._grabbedManipulator, shouldRenderTracker: this._shouldRenderTracker, observerPosition: null != this.analysis.observer ? this.analysis.observer.position : null, visible: this.visible };
  }
  _updateLaserLineRenderer(e11 = this._laserLineRendererDependencies()) {
    const { laserlineVisualElement: t6, grabbedManipulator: i5, shouldRenderTracker: a6, observerPosition: n5, visible: r5 } = e11;
    if (null == t6)
      return;
    const s4 = null != i5 ? i5 : a6 && null != n5 ? this._targetTrackerManipulator : null;
    null != s4 && r5 ? (t6.visible = true, t6.heightManifoldTarget = s4.renderLocation, s4 !== this._observerManipulator ? t6.lineVerticalPlaneSegment = b2(this._observerManipulator.renderLocation, s4.renderLocation, j3) : t6.lineVerticalPlaneSegment = null) : (t6.visible = false, t6.heightManifoldTarget = null, t6.lineVerticalPlaneSegment = null);
  }
  _createLaserLine() {
    this._removeLaserLine();
    const { glowWidth: e11, innerWidth: t6 } = r4;
    this._laserlineVisualElement = new c({ view: this.view, attached: true, visible: this.visible, style: { glowWidth: e11, innerWidth: t6 }, isDecoration: true });
  }
  _removeLaserLine() {
    null != this._laserlineVisualElement && (this._laserlineVisualElement.destroy(), this._laserlineVisualElement = null);
  }
  _updateLaserLineStyle(e11, i5, a6) {
    const n5 = this._laserlineVisualElement;
    if (null == n5)
      return;
    const r5 = n5.style;
    n5.style = { ...r5, glowColor: u3.toUnitRGB(e11), innerColor: u3.toUnitRGB(i5), globalAlpha: a6 };
  }
  _onObserverLocationChange(e11) {
    null != e11 ? (this._observerManipulator.metadata.intersection = null, this._observerManipulator.available = true, this._observerManipulator.elevationAlignedLocation = e11) : this._observerManipulator.available = false;
  }
  _onTargetLocationChange(e11, t6) {
    null != e11 ? (t6.elevationAlignedLocation = e11, t6 !== this._targetTrackerManipulator && (t6.available = true)) : t6.available = false;
  }
  _addPointFromClickEvent(e11) {
    var _a;
    const t6 = this._intersector.getScreenPointIntersection(e11);
    if (null != (t6 == null ? void 0 : t6.mapPoint))
      if (null != ((_a = this.analysis.observer) == null ? void 0 : _a.position)) {
        this._clearCursorTracker();
        const e12 = new f();
        this._updateFromIntersection(e12, t6), this.analysis.targets.add(e12);
      } else {
        const e12 = new u4();
        this._updateFromIntersection(e12, t6), this.analysis.observer = e12;
      }
  }
  _clickHandler(e11) {
    this.active && e11.button !== t4.Right && (this._addPointFromClickEvent(n3(e11)), e11.stopPropagation());
  }
  _doubleClickHandler(e11) {
    this.active && e11.button !== t4.Right && (this.stop(), e11.stopPropagation());
  }
  _keyDownHandler(e11) {
    this.active && "Escape" === e11.key && (this.stop(), e11.stopPropagation());
  }
  _pointerMoveHandler(e11) {
    var _a;
    if (this.hasGrabbedManipulators)
      return;
    if (this._latestPointerMovePointerType = e11.pointerType, this._updateLaserLineRenderer(), !this._showTracker || null == ((_a = this.analysis.observer) == null ? void 0 : _a.position))
      return;
    const t6 = n3(e11), i5 = this._intersector.getScreenPointIntersection(t6);
    null != (i5 == null ? void 0 : i5.mapPoint) && (null == this.analysisViewData.cursorTarget && (this.analysisViewData.cursorTarget = new f()), this._updateFromIntersection(this.analysisViewData.cursorTarget, i5), this._updateLaserLineRenderer());
  }
  _updateFromIntersection(e11, t6) {
    if (null == t6.mapPoint)
      return e11.position = null, e11.elevationInfo = null, void (e11.feature = null);
    switch (t6.type) {
      case i2.OBJECT:
        if (null != t6.graphic) {
          const i6 = t6.graphic, a6 = a3(i6);
          "on-the-ground" === a6.mode && (a6.mode = "relative-to-ground", a6.offset = 0), e11.elevationInfo = new h2(a6), e11.feature = i6;
        } else
          e11.elevationInfo = null, e11.feature = null;
        break;
      case i2.TERRAIN:
        e11.elevationInfo = new h2({ mode: "on-the-ground" }), e11.feature = null;
        break;
      default:
        e11.elevationInfo = null, e11.feature = null;
    }
    const i5 = t6.mapPoint.clone();
    i5.z = h3(this.view, i5, { mode: "absolute-height", offset: 0 }, e11.elevationInfo), e11.position = i5;
  }
  _manipulatorClick(e11, t6) {
    if ("observer" === e11.metadata.type || e11.grabbing || e11.dragging || t6.button !== t4.Right || this.analysis.targets.length <= 1)
      return;
    const { target: i5 } = e11.metadata;
    this.analysis.targets.remove(i5), t6.stopPropagation();
  }
  get testInfo() {
    return { laserLineVisualElement: this._laserlineVisualElement, getTargetManipulator: (e11) => this._getTargetManipulator(e11) };
  }
};
function R(e11) {
  var _a;
  const t6 = (_a = e11.position) == null ? void 0 : _a.clone();
  return (i5) => (e11.position = t6, i5);
}
function D2(e11, t6) {
  const { isValid: i5, isTargetVisible: a6 } = t6.computationResult;
  e11.state = i5 ? a6 ? u5.Custom1 : u5.Custom2 : u5.Custom3;
}
function E(e11) {
  const { isValid: t6, isTargetVisible: i5 } = e11.computationResult;
  return { isValid: t6, isTargetVisible: i5 };
}
e([y({ constructOnly: true })], O2.prototype, "view", void 0), e([y({ constructOnly: true })], O2.prototype, "analysis", void 0), e([y({ readOnly: true })], O2.prototype, "state", null), e([y({ readOnly: true })], O2.prototype, "cursor", null), e([y()], O2.prototype, "removeIncompleteOnCancel", void 0), e([y({ readOnly: true })], O2.prototype, "updating", null), e([y({ constructOnly: true })], O2.prototype, "analysisViewData", void 0), e([y({ readOnly: true })], O2.prototype, "_showTracker", null), e([y()], O2.prototype, "_latestPointerMovePointerType", void 0), e([y()], O2.prototype, "_shouldRenderTracker", null), e([y()], O2.prototype, "_laserlineVisualElement", void 0), e([y()], O2.prototype, "_grabbedManipulator", void 0), O2 = e([a2("esri.views.3d.analysis.LineOfSight.LineOfSightTool")], O2);
var j3 = v();

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightVisualElement.js
var e10 = class {
  constructor(e11, i5, t6, s4) {
    this.visibleLineVisualElement = e11, this.occludedLineVisualElement = i5, this.undefinedLineVisualElement = t6, this.targetVisualElement = s4;
  }
  destroy() {
    this.visibleLineVisualElement.destroy(), this.occludedLineVisualElement.destroy(), this.undefinedLineVisualElement.destroy(), this.targetVisualElement.destroy();
  }
};

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightVisualization.js
var O3 = class extends S {
  constructor(e11) {
    super(e11), this._lineOfSightVisualElements = new Array(), this._computationHandles = new r(), this._updatingHandles = new h4();
  }
  initialize() {
    this.addHandles(this._connectComputations()), this._createObserverVisualization();
  }
  destroy() {
    this._updatingHandles = u(this._updatingHandles), this._computationHandles = u(this._computationHandles), this._observerVisualElement = u(this._observerVisualElement);
  }
  get visible() {
    return this.analysisViewData.visible;
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get interactiveAndEditable() {
    return this.analysisViewData.interactive && this.analysisViewData.editable;
  }
  get test() {
    return { disablePartialOcclusion: () => {
      for (const e11 of this._lineOfSightVisualElements)
        e11.visibleLineVisualElement.renderOccluded = h5.Occlude, e11.occludedLineVisualElement.renderOccluded = h5.Occlude, e11.undefinedLineVisualElement.renderOccluded = h5.Occlude;
    }, visualizations: this._lineOfSightVisualElements };
  }
  _createLineOfSightVisualization() {
    const e11 = w2, t6 = this.view, o5 = this.isDecoration, n5 = { view: t6, attached: true, width: e11.outerWidth, innerWidth: e11.innerWidth, isDecoration: o5 }, s4 = u3.toUnitRGBA(e11.visibleOuterColor), r5 = u3.toUnitRGBA(e11.visibleInnerColor), l3 = u3.toUnitRGBA(e11.occludedOuterColor), a6 = u3.toUnitRGBA(e11.occludedInnerColor), c3 = u3.toUnitRGBA(e11.undefinedOuterColor), d9 = u3.toUnitRGBA(e11.undefinedInnerColor), u8 = new f3({ ...n5, color: s4, innerColor: r5 }), m4 = new f3({ ...n5, color: l3, innerColor: a6 }), h7 = new f3({ ...n5, color: c3, innerColor: d9 }), b3 = new x3({ view: t6, attached: true, ..._, size: 8, isDecoration: o5 }), O4 = new e10(u8, m4, h7, b3);
    return this._lineOfSightVisualElements.push(O4), O4;
  }
  _destroyLineOfSightVisualization(e11) {
    e11.destroy(), this._lineOfSightVisualElements.splice(this._lineOfSightVisualElements.indexOf(e11), 1);
  }
  _updateLineOfSightVisualization(e11, t6, o5) {
    const n5 = w2, { computationResult: s4, inputPoints: r5 } = e11, { start: l3, end: a6, intersection: c3, isValid: m4, isTargetVisible: h7 } = s4, { observer: v3 } = r5, g3 = E2;
    g3[12] = v3[0], g3[13] = v3[1], g3[14] = v3[2];
    const f5 = e5(V3, l3, v3), b3 = e5(y3, a6, v3), O4 = e5(C2, c3, v3), { visibleLineVisualElement: _2, occludedLineVisualElement: A2, undefinedLineVisualElement: w3, targetVisualElement: L2 } = t6, S3 = null == this.analysisViewData.elevationAlignedObserver || null == e11.elevationAlignedTargetLocation, j4 = this.visible && !S3;
    _2.visible = j4, A2.visible = j4, w3.visible = j4, L2.visible = j4, L2.attached = !o5.interactiveAndEditable, j4 && (_2.geometry = null, A2.geometry = null, w3.geometry = null, L2.geometry = e11.elevationAlignedTargetLocation, m4 ? h7 ? (_2.geometry = [[e4(f5), e4(b3)]], _2.transform = g3, _2.color = u3.toUnitRGBA(n5.visibleOuterColor), L2.color = u3.toUnitRGBA(n5.visibleInnerColor)) : (_2.geometry = [[e4(f5), e4(O4)]], _2.transform = g3, _2.color = u3.toUnitRGBA(n5.occludedOuterColor), A2.geometry = [[e4(O4), e4(b3)]], A2.transform = g3, L2.color = u3.toUnitRGBA(n5.occludedInnerColor)) : (w3.geometry = [[e4(f5), e4(b3)]], w3.transform = g3, L2.color = u3.toUnitRGBA(n5.undefinedInnerColor)));
  }
  _getLineOfSightVisualizationDependencies(e11) {
    const { computationResult: i5 } = e11, { occludedOuterColor: t6, visibleOuterColor: o5 } = w2;
    return { computationResult: i5, occludedOuterColor: t6, visibleOuterColor: o5, visible: this.visible, interactiveAndEditable: this.interactiveAndEditable };
  }
  _connectComputation(e11) {
    const i5 = this._computationHandles;
    if (i5.has(e11))
      return;
    const t6 = this._createLineOfSightVisualization();
    i5.add([this._updatingHandles.add(() => this._getLineOfSightVisualizationDependencies(e11), (i6) => this._updateLineOfSightVisualization(e11, t6, i6), { initial: true, equals: () => false }), e3(() => this._destroyLineOfSightVisualization(t6))], e11);
  }
  _disconnectComputation(e11) {
    this._computationHandles.remove(e11);
  }
  _connectComputations() {
    return this._updatingHandles.addOnCollectionChange(() => this.analysisViewData.computations, (e11) => this._onComputationsCollectionChange(e11), { initial: true, final: true });
  }
  _onComputationsCollectionChange({ added: e11, removed: i5 }) {
    for (const t6 of i5)
      this._disconnectComputation(t6);
    for (const t6 of e11)
      this._connectComputation(t6);
  }
  _createObserverVisualization() {
    const e11 = u3.toUnitRGBA(w2.visibleInnerColor), t6 = new x3({ view: this.view, color: e11, ..._, isDecoration: this.isDecoration });
    this._observerVisualElement = t6, this.addHandles(this._updatingHandles.add(() => ({ observer: this.analysisViewData.elevationAlignedObserver, interactiveAndEditable: this.interactiveAndEditable, visible: this.visible }), ({ observer: e12, interactiveAndEditable: i5, visible: o5 }) => {
      null != e12 && !i5 && o5 ? (t6.geometry = e12, this._observerVisualElement.attached = true) : t6.attached = false;
    }, P));
  }
};
e([y({ constructOnly: true })], O3.prototype, "analysis", void 0), e([y({ constructOnly: true })], O3.prototype, "analysisViewData", void 0), e([y({ constructOnly: true })], O3.prototype, "view", void 0), e([y({ readOnly: true })], O3.prototype, "visible", null), e([y({ constructOnly: true })], O3.prototype, "isDecoration", void 0), e([y()], O3.prototype, "updating", null), e([y()], O3.prototype, "interactiveAndEditable", null), e([y()], O3.prototype, "test", null), O3 = e([a2("esri.views.3d.analysis.LineOfSight.LineOfSightVisualization")], O3);
var _ = { size: 6, pixelSnappingEnabled: false, primitive: "circle", elevationInfo: { mode: "absolute-height", offset: 0 }, outlineSize: 0 };
var V3 = n2();
var y3 = n2();
var C2 = n2();
var E2 = e6();

// node_modules/@arcgis/core/views/3d/analysis/LineOfSightAnalysisView3D.js
var m3 = class extends s(o3.EventedMixin(S)) {
  constructor(t6) {
    super(t6), this.type = "line-of-sight-view-3d", this.analysis = null, this.tool = null, this.computations = new V(), this.elevationAlignedObserver = null, this.observerEngineLocation = n2(), this.cursorTarget = null, this.editable = true;
  }
  initialize() {
    const t6 = this.view, i5 = this.analysis;
    this._analysisController = new U2({ analysis: i5, analysisViewData: this, view: t6 }), this._analysisVisualization = new O3({ analysis: i5, analysisViewData: this, view: t6, isDecoration: !this.parent }), this.addHandles([this._analysisController.on("result-changed", (t7) => {
      t7.target !== this.cursorTarget && this.emit("result-changed", t7);
    }), a5(this, O2)]);
  }
  destroy() {
    v2(this), this._analysisController = u(this._analysisController), this._analysisVisualization = u(this._analysisVisualization);
  }
  get results() {
    return this.computations.map((t6) => t6.result);
  }
  get priority() {
    return this._analysisController.priority;
  }
  set priority(t6) {
    this._analysisController.priority = t6;
  }
  get updating() {
    return null != this._analysisController && this._analysisController.updating || null != this._analysisVisualization && this._analysisVisualization.updating;
  }
  getResultForTarget(t6) {
    var _a;
    return (_a = this.computations.find((i5) => i5.target === t6)) == null ? void 0 : _a.result;
  }
  get testInfo() {
    return { visualization: this._analysisVisualization, controller: this._analysisController };
  }
};
e([y({ readOnly: true })], m3.prototype, "type", void 0), e([y({ constructOnly: true, nonNullable: true })], m3.prototype, "analysis", void 0), e([y()], m3.prototype, "tool", void 0), e([y({ readOnly: true })], m3.prototype, "results", null), e([y()], m3.prototype, "priority", null), e([y()], m3.prototype, "computations", void 0), e([y()], m3.prototype, "elevationAlignedObserver", void 0), e([y()], m3.prototype, "observerEngineLocation", void 0), e([y()], m3.prototype, "cursorTarget", void 0), e([y()], m3.prototype, "updating", null), e([y()], m3.prototype, "editable", void 0), e([y()], m3.prototype, "_analysisController", void 0), e([y()], m3.prototype, "_analysisVisualization", void 0), m3 = e([a2("esri.views.3d.analysis.LineOfSightAnalysisView3D")], m3);
var d8 = m3;
export {
  d8 as default
};
//# sourceMappingURL=LineOfSightAnalysisView3D-S3MT2D4K.js.map
