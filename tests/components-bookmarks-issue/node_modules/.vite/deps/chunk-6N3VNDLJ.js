import {
  a as a3
} from "./chunk-FDNEUO76.js";
import {
  d as d2
} from "./chunk-NUS62V7H.js";
import {
  i as i2
} from "./chunk-6EZXOD6N.js";
import {
  e as e2,
  t as t2
} from "./chunk-M7V6LN55.js";
import {
  We
} from "./chunk-EWD7I5UU.js";
import {
  r
} from "./chunk-U34ZXOJT.js";
import {
  b as b2
} from "./chunk-W5ALAOW2.js";
import {
  d
} from "./chunk-F3BQGS35.js";
import {
  a2,
  b as b3,
  c,
  h,
  l,
  t
} from "./chunk-OHE3HDFF.js";
import {
  f as f3
} from "./chunk-QYC3GV65.js";
import {
  S as S3
} from "./chunk-ZAM62XN5.js";
import {
  y as y2
} from "./chunk-J7AMTUNG.js";
import {
  o
} from "./chunk-TGXFDJCS.js";
import {
  p
} from "./chunk-VTH4DAHQ.js";
import {
  S as S2
} from "./chunk-SLQA5YBV.js";
import {
  m
} from "./chunk-ONK5AE7R.js";
import {
  w
} from "./chunk-IZKCZQUY.js";
import {
  f as f2
} from "./chunk-MBGZKT2Z.js";
import {
  i,
  n as n2
} from "./chunk-RUN6MNXL.js";
import {
  I,
  U
} from "./chunk-SAYWXQVM.js";
import {
  f,
  u2
} from "./chunk-SBL4URUW.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  b,
  u2 as u
} from "./chunk-JGDJR5EV.js";
import {
  n2 as n,
  s
} from "./chunk-7RBRCL6S.js";

// node_modules/@arcgis/core/networks/support/TopologyValidationJobInfo.js
var n3 = i()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var l2 = class extends i2 {
  constructor(t3) {
    super(t3), this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(t3) {
    const s4 = { ...t3, query: { f: "json" } }, { data: r2 } = await U(this.statusUrl, s4);
    return this.read(r2), this.editsResolver && this.editsResolver.resolve({ edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], exceededTransferLimit: true, historicMoment: null }), this;
  }
  async waitForJobCompletion(t3 = {}) {
    const { interval: e4 = 1e3, statusCallback: s4 } = t3;
    return new Promise((t4, o2) => {
      this._clearTimer();
      const i4 = setInterval(() => {
        this._timer || o2(u()), this.checkJobStatus().then((e5) => {
          const { status: r2 } = e5;
          switch (this.status = r2, r2) {
            case "job-succeeded":
              this._clearTimer(), t4(this);
              break;
            case "job-waiting":
            case "job-executing":
              s4 && s4(this);
          }
        }, (t5) => {
          this._clearTimer(), o2(t5);
        });
      }, e4);
      this._timer = i4;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
e([y()], l2.prototype, "editsResolver", void 0), e([y({ type: String, json: { write: true } })], l2.prototype, "statusUrl", void 0), e([o(n3)], l2.prototype, "status", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t3, e4) => {
  e4.submissionTime = t3 ? t3.getTime() : null;
} } } })], l2.prototype, "submissionTime", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t3, e4) => {
  e4.lastUpdatedTime = t3 ? t3.getTime() : null;
} } } })], l2.prototype, "lastUpdatedTime", void 0), l2 = e([a("esri.networks.support.TopologyValidationJobInfo")], l2);
var m2 = l2;

// node_modules/@arcgis/core/networks/support/utils.js
function n4(e4, t3) {
  const r2 = [], o2 = /* @__PURE__ */ new Map();
  for (const n7 of t3) {
    const t4 = e4.getLayerIdBySourceId(n7.networkSourceId);
    if (null == t4)
      continue;
    let r3 = o2.get(t4);
    void 0 === r3 && (r3 = []), r3.push(n7.objectId), o2.set(t4, r3);
  }
  const a6 = e4.featureServiceUrl;
  return o2.forEach((e5, t4) => r2.push({ layerUrl: `${a6}/${t4}`, objectIds: e5 })), r2;
}
async function s2(e4, t3) {
  const o2 = e4.layers, n7 = e4.layerInfos, s4 = e4.returnGeometry || false, l5 = e4.outSpatialReference;
  await Promise.all(o2.map(async (e5) => {
    await e5.load();
  }));
  return (await Promise.all(o2.map(async (e5) => {
    var _a;
    const o3 = n7.find((t4) => {
      var _a2;
      return t4.layerUrl === ((_a2 = e5.parsedUrl) == null ? void 0 : _a2.path);
    });
    if (!((_a = o3 == null ? void 0 : o3.objectIds) == null ? void 0 : _a.length))
      return { layer: e5, featureSet: void 0 };
    const i4 = e5.createQuery();
    i4.returnGeometry = s4, i4.outFields = o3.outFields || ["*"], i4.outSpatialReference = l5, i4.gdbVersion = e5.gdbVersion, i4.objectIds = o3.objectIds, t3 && (i4.where = "1=1");
    const u3 = d.fromJSON(await r(e5, i4));
    return { layer: e5, featureSet: u3 };
  }))).filter((e5) => void 0 !== e5.featureSet);
}
async function l3(e4, t3) {
  if ("Utility Network Layer" === e4) {
    const { default: e5 } = await import("./UtilityNetwork-BUAOCOQG.js");
    return new e5({ layerUrl: t3 });
  }
  return null;
}
async function i3(r2) {
  var _a;
  let a6 = "portalItem" in r2 ? r2 : { portalItem: r2 };
  !a6.portalItem || a6.portalItem instanceof S2 || (a6 = { ...a6, portalItem: new S2(a6.portalItem) });
  const n7 = a6.portalItem;
  if (await n7.load(), "Feature Service" !== n7.type)
    throw new s("portal:unknown-item-type", "Unknown item type '${type}'", { type: n7.type });
  const s4 = n7.url, i4 = await U(s4, { responseType: "json", query: { f: "json" } }), u3 = "Network Layer";
  if ((_a = i4.data.type) == null ? void 0 : _a.includes(u3))
    return l3(i4.data.type, s4);
  if (i4.data.layers) {
    const e4 = i4.data.layers.find((e5) => e5.type.includes(u3));
    if (e4) {
      const t3 = `${s4}/${e4.id}`;
      return l3(e4.type, t3);
    }
  }
  return null;
}

// node_modules/@arcgis/core/networks/Network.js
var b4 = class extends S3(m) {
  static fromPortalItem(e4) {
    return i3(e4);
  }
  constructor(e4) {
    super(e4), this.id = null, this.title = null, this.layerUrl = null, this.dataElement = null, this.fullExtent = null, this.spatialReference = null, this.type = null, this.sourceJSON = null, this.gdbVersion = null, this.historicMoment = null, this._applyEditsHandler = (e5) => {
      const { serviceUrl: t3, gdbVersion: r2, result: o2 } = e5, s4 = t3 === this.featureServiceUrl, i4 = b3(t3, r2, this.gdbVersion);
      s4 && i4 && o2.then((e6) => {
        c(t3, r2) && (this.historicMoment = e6.historicMoment);
      });
    }, this._updateMomentHandler = (e5) => {
      const { serviceUrl: t3, gdbVersion: r2, moment: o2 } = e5, s4 = t3 === this.featureServiceUrl, i4 = b3(t3, r2, this.gdbVersion);
      s4 && i4 && (this.historicMoment = o2);
    }, this.when().then(() => {
      this.addHandles([l(this._applyEditsHandler), a2(this._updateMomentHandler)]);
    }, () => {
    });
  }
  initialize() {
    this.when().catch((e4) => {
      b(e4) || n.getLogger(this).error("#load()", `Failed to load layer (title: '${this.title ?? "no title"}', id: '${this.id ?? "no id"}')`, { error: e4 });
    });
  }
  get datasetName() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.name) ?? null;
  }
  get owner() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.userIdentity) ?? null;
  }
  get schemaGeneration() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.schemaGeneration) ?? null;
  }
  get parsedUrl() {
    return I(this.layerUrl);
  }
  get featureServiceUrl() {
    return p(this.parsedUrl.path).url.path;
  }
  get networkServiceUrl() {
    return this.featureServiceUrl.replace(/\/FeatureServer/i, "/UtilityNetworkServer");
  }
  get layerId() {
    return p(this.parsedUrl.path).sublayer;
  }
  get networkSystemLayers() {
    return null;
  }
  async load(e4) {
    return this.addResolvingPromise(this._fetchDataElement(this.featureServiceUrl, this.layerId.toString(), e4)), this.addResolvingPromise(this._fetchLayerMetaData(this.layerUrl, e4)), this;
  }
  getLayerIdBySourceId(e4) {
    if (this.dataElement) {
      const t3 = this.dataElement.domainNetworks;
      for (const r2 of t3) {
        for (const t4 of r2.edgeSources ?? [])
          if (t4.sourceId === e4)
            return t4.layerId;
        for (const t4 of r2.junctionSources ?? [])
          if (t4.sourceId === e4)
            return t4.layerId;
      }
      return null;
    }
    return null;
  }
  async queryNamedTraceConfigurations(e4, t3) {
    var _a;
    const [{ queryNamedTraceConfigurations: r2 }, { default: o2 }] = await Promise.all([import("./queryNamedTraceConfigurations-ILDV34YJ.js"), import("./QueryNamedTraceConfigurationsParameters-V7IXICD3.js")]), s4 = this.networkServiceUrl, i4 = o2.from(e4);
    return (_a = await r2(s4, i4, { ...t3 })) == null ? void 0 : _a.namedTraceConfigurations;
  }
  async validateTopology(e4, t3) {
    var _a, _b, _c;
    if (!e4.validateArea)
      throw new s("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    const [{ validateNetworkTopology: r2 }, { default: s4 }] = await Promise.all([import("./validateNetworkTopology-CDE6RLRR.js"), import("./ValidateNetworkTopologyParameters-426MWRGQ.js")]), i4 = s4.from(e4);
    c(this.featureServiceUrl, this.gdbVersion || null) ? i4.sessionID = t : i4.sessionID = null, i4.gdbVersion = this.gdbVersion;
    const a6 = this.networkServiceUrl, n7 = this.featureServiceUrl, l5 = h(n7, null, this.gdbVersion, true), d3 = await r2(a6, i4, { ...t3 });
    if (d3 == null ? void 0 : d3.serviceEdits) {
      const e5 = [];
      for (const t4 of d3.serviceEdits) {
        const { editedFeatures: r3 } = t4, o2 = (r3 == null ? void 0 : r3.spatialReference) ? new f2(r3.spatialReference) : null;
        e5.push({ layerId: t4.layerId, editedFeatures: { adds: ((_a = r3 == null ? void 0 : r3.adds) == null ? void 0 : _a.map((e6) => k(e6, o2))) || [], updates: ((_b = r3 == null ? void 0 : r3.updates) == null ? void 0 : _b.map((e6) => ({ original: k(e6[0], o2), current: k(e6[1], o2) }))) || [], deletes: ((_c = r3 == null ? void 0 : r3.deletes) == null ? void 0 : _c.map((e6) => k(e6, o2))) || [], spatialReference: o2 } });
      }
      l5.resolve({ edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], editedFeatures: e5, exceededTransferLimit: false, historicMoment: d3.moment });
    }
    return d3;
  }
  async submitTopologyValidationJob(e4, t3) {
    let s4 = null;
    if (!e4.validateArea)
      throw new s("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    if (!this.gdbVersion) {
      const e5 = this.layerUrl.replace(/\/FeatureServer/i, "/VersionManagementServer").replace(/\/\d*$/, "");
      s4 = (await U(e5, { responseType: "json", query: { f: "json" } })).data.defaultVersionName;
    }
    const [{ submitValidateNetworkTopologyJob: i4 }, { default: a6 }] = await Promise.all([import("./validateNetworkTopology-CDE6RLRR.js"), import("./ValidateNetworkTopologyParameters-426MWRGQ.js")]), n7 = a6.from(e4);
    c(this.featureServiceUrl, this.gdbVersion || null) ? n7.sessionID = t : n7.sessionID = null, n7.gdbVersion = this.gdbVersion || s4;
    const l5 = this.networkServiceUrl, d3 = this.featureServiceUrl ? h(this.featureServiceUrl, null, this.gdbVersion, true) : void 0, p5 = await i4(l5, n7, { ...t3 });
    return new m2({ statusUrl: p5, editsResolver: d3 });
  }
  async _fetchLayerMetaData(e4, t3) {
    const o2 = await U(e4, { responseType: "json", query: { f: "json" }, ...t3 });
    this.sourceJSON = o2.data, this.read(o2.data, { origin: "service" });
  }
  async _fetchDataElement(e4, t3, o2) {
    if (this.dataElement)
      return;
    const s4 = await U(`${e4}/queryDataElements`, { responseType: "json", query: { layers: JSON.stringify([t3]), f: "json" }, ...o2 }).then((e5) => {
      var _a;
      return (_a = e5.data.layerDataElements) == null ? void 0 : _a[0];
    });
    s4 && this.read(s4, { origin: "service" });
  }
};
function k(e4, r2) {
  return new f3({ attributes: e4.attributes, geometry: y2({ ...e4.geometry, spatialReference: r2 }) });
}
e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: true } }, read: false } })], b4.prototype, "id", void 0), e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: { source: "name" } } }, read: false } })], b4.prototype, "title", void 0), e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: { source: "url" }, write: { target: "url", isRequired: true } } }, read: false } })], b4.prototype, "layerUrl", void 0), e([y({ type: Object, json: { origins: { service: { read: true } }, read: false } })], b4.prototype, "dataElement", void 0), e([y({ type: w, json: { origins: { service: { read: { source: "extent" } } }, read: false } })], b4.prototype, "fullExtent", void 0), e([y({ type: f2, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, read: false } })], b4.prototype, "spatialReference", void 0), e([y({ type: ["utility", "trace"], readOnly: true, json: { read: false, write: false } })], b4.prototype, "type", void 0), e([y({ readOnly: true })], b4.prototype, "datasetName", null), e([y({ readOnly: true })], b4.prototype, "owner", null), e([y({ readOnly: true })], b4.prototype, "schemaGeneration", null), e([y({ readOnly: true })], b4.prototype, "parsedUrl", null), e([y({ readOnly: true })], b4.prototype, "featureServiceUrl", null), e([y({ readOnly: true })], b4.prototype, "networkServiceUrl", null), e([y({ readOnly: true })], b4.prototype, "layerId", null), e([y()], b4.prototype, "sourceJSON", void 0), e([y({ readOnly: true })], b4.prototype, "networkSystemLayers", null), e([y()], b4.prototype, "gdbVersion", void 0), e([y({ type: Date })], b4.prototype, "historicMoment", void 0), b4 = e([a("esri.networks.Network")], b4);
var N = b4;

// node_modules/@arcgis/core/networks/RulesTable.js
var a4 = class extends u2(m) {
  constructor(e4) {
    super(e4), this.rulesCategorized = { attachment: [], containment: [], connectivity: [] }, this.request = U;
  }
  initialize() {
  }
  async load(e4) {
    const t3 = this.layer.load(e4).then(() => this._initializeRulesTable());
    return this.addResolvingPromise(t3), this;
  }
  getFeatureSQL(e4, t3) {
    var _a, _b;
    const o2 = e4.layerId.toString(), s4 = (_a = e4.fieldsIndex) == null ? void 0 : _a.normalizeFieldName("assetGroup"), r2 = (_b = e4.fieldsIndex) == null ? void 0 : _b.normalizeFieldName("assetType"), i4 = s4 ? t3.attributes[s4] : null, n7 = r2 ? t3.attributes[r2] : null, a6 = this.rulesHash[o2];
    if (a6) {
      const e5 = a6.assetGroupHash[i4];
      if (e5) {
        return e5.assetTypeHash[n7] || null;
      }
    }
    return null;
  }
  async _initializeRulesTable() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const e4 = {};
    let t3;
    !function(e5) {
      e5[e5.from = 0] = "from", e5[e5.to = 1] = "to", e5[e5.via = 2] = "via";
    }(t3 || (t3 = {}));
    const o2 = [{ networkSourceId: "fromNetworkSource", assetGroupId: "fromAssetGroup", assetTypeId: "fromAssetType" }, { networkSourceId: "toNetworkSource", assetGroupId: "toAssetGroup", assetTypeId: "toAssetType" }, { networkSourceId: "viaNetworkSource", assetGroupId: "viaAssetGroup", assetTypeId: "viaAssetType" }];
    this.rulesCategorized = { attachment: [], containment: [], connectivity: [] };
    for (const s4 of this.rules) {
      if (s4.ruleType === t2.RTAttachment) {
        this.rulesCategorized.attachment.push(s4);
        continue;
      }
      if (s4.ruleType === t2.RTContainment) {
        this.rulesCategorized.containment.push(s4);
        continue;
      }
      if (s4.ruleType === t2.RTJunctionJunctionConnectivity) {
        this.rulesCategorized.connectivity.push(s4);
        continue;
      }
      this.rulesCategorized.connectivity.push(s4);
      let r2 = [[t3.from, t3.to], [t3.to, t3.from]];
      s4.ruleType === t2.RTEdgeJunctionEdgeConnectivity && (r2 = [[t3.from, t3.via], [t3.via, t3.from], [t3.to, t3.via], [t3.via, t3.to]]);
      for (const i4 of r2) {
        const r3 = i4.shift(), a6 = i4.shift();
        let c3 = false;
        switch (s4.ruleType) {
          case t2.RTEdgeJunctionEdgeConnectivity:
            c3 = r3 === t3.from || r3 === t3.to;
            break;
          case t2.RTJunctionEdgeConnectivity:
            c3 = r3 === t3.to;
        }
        const u3 = o2[r3], p5 = ((_a = s4[u3.networkSourceId]) == null ? void 0 : _a.layerId.toString()) ?? "", d3 = (_c = (_b = s4[u3.assetGroupId]) == null ? void 0 : _b.assetGroupCode) == null ? void 0 : _c.toString(), l5 = s4[u3.assetTypeId], y3 = (_d = l5 == null ? void 0 : l5.assetTypeCode) == null ? void 0 : _d.toString(), m4 = o2[a6], h2 = ((_e = s4[m4.networkSourceId]) == null ? void 0 : _e.layerId.toString()) ?? "", f5 = (_g = (_f = s4[m4.assetGroupId]) == null ? void 0 : _f.assetGroupCode) == null ? void 0 : _g.toString(), T2 = s4[m4.assetTypeId], g = (_h = T2 == null ? void 0 : T2.assetTypeCode) == null ? void 0 : _h.toString(), v = e4[p5] ?? { assetGroupHash: {} };
        if (!(d3 && y3 && f5 && g))
          continue;
        const I2 = v.assetGroupHash[d3] ?? { assetTypeHash: {} }, S4 = I2.assetTypeHash[y3] ?? {};
        if (S4[h2] = S4[h2] ?? {}, c3) {
          S4[p5] = S4[p5] ?? {};
          const e5 = `(assetgroup = ${d3} AND assettype = ${y3})`;
          S4[p5].anyVertex = S4[p5].anyVertex ? `${S4[p5].anyVertex}` : `${e5}`, "esriNECPEndVertex" === (T2 == null ? void 0 : T2.connectivityPolicy) && (S4[p5].endVertex = ((_i = S4[p5]) == null ? void 0 : _i.endVertex) ? `${S4[p5].endVertex}` : `${e5}`);
        }
        const C = `(assetgroup = ${f5} AND assettype = ${g})`;
        S4[h2].anyVertex = ((_j = S4[h2]) == null ? void 0 : _j.anyVertex) ? `${S4[h2].anyVertex} OR ${C}` : `${C}`, "esriNECPEndVertex" === (T2 == null ? void 0 : T2.connectivityPolicy) && (S4[h2].endVertex = ((_k = S4[h2]) == null ? void 0 : _k.endVertex) ? `${S4[h2].endVertex} OR ${C}` : `${C}`), I2.assetTypeHash[y3] = S4, v.assetGroupHash[d3] = I2, e4[p5] = v;
      }
    }
    this.rulesHash = e4;
  }
};
e([y({ constructOnly: true })], a4.prototype, "layer", void 0), e([y({ constructOnly: true })], a4.prototype, "rules", void 0), e([y()], a4.prototype, "rulesHash", void 0), e([y()], a4.prototype, "rulesCategorized", void 0), e([y({ constructOnly: true })], a4.prototype, "request", void 0), a4 = e([a("esri.networks.RulesTable")], a4);
var c2 = a4;

// node_modules/@arcgis/core/networks/support/NetworkSystemLayers.js
var e3 = class extends S {
  constructor(r2) {
    super(r2), this.rulesTableId = null, this.rulesTableUrl = null, this.subnetworksTableId = null, this.subnetworksTableUrl = null, this.dirtyAreasLayerId = null, this.dirtyAreasLayerUrl = null, this.associationsTableId = null, this.associationsTableUrl = null;
  }
};
e([y({ constructOnly: true })], e3.prototype, "rulesTableId", void 0), e([y({ constructOnly: true })], e3.prototype, "rulesTableUrl", void 0), e([y({ constructOnly: true })], e3.prototype, "subnetworksTableId", void 0), e([y({ constructOnly: true })], e3.prototype, "subnetworksTableUrl", void 0), e([y({ constructOnly: true })], e3.prototype, "dirtyAreasLayerId", void 0), e([y({ constructOnly: true })], e3.prototype, "dirtyAreasLayerUrl", void 0), e([y({ constructOnly: true })], e3.prototype, "associationsTableId", void 0), e([y({ constructOnly: true })], e3.prototype, "associationsTableUrl", void 0), e3 = e([a("esri.networks.support.NetworkSystemLayers")], e3);
var l4 = e3;

// node_modules/@arcgis/core/networks/support/Terminal.js
var s3 = class extends f {
  constructor(r2) {
    super(r2), this.id = null, this.name = null;
  }
};
e([y({ type: Number, json: { read: { source: "terminalId" }, write: { target: "terminalId" } } })], s3.prototype, "id", void 0), e([y({ type: String, json: { read: { source: "terminalName" }, write: { target: "terminalName" } } })], s3.prototype, "name", void 0), e([y({ type: Boolean, json: { write: true } })], s3.prototype, "isUpstreamTerminal", void 0), s3 = e([a("esri.networks.support.Terminal")], s3);
var p2 = s3;

// node_modules/@arcgis/core/networks/support/TerminalConfiguration.js
var a5 = new n2({ esriUNTMBidirectional: "bidirectional", esriUNTMDirectional: "directional" });
var n5 = class extends f {
  constructor(r2) {
    super(r2), this.defaultConfiguration = null, this.id = null, this.name = null, this.terminals = [], this.traversabilityModel = null;
  }
};
e([y({ type: String, json: { write: true } })], n5.prototype, "defaultConfiguration", void 0), e([y({ type: Number, json: { read: { source: "terminalConfigurationId" }, write: { target: "terminalConfigurationId" } } })], n5.prototype, "id", void 0), e([y({ type: String, json: { read: { source: "terminalConfigurationName" }, write: { target: "terminalConfigurationName" } } })], n5.prototype, "name", void 0), e([y({ type: [p2], json: { write: true } })], n5.prototype, "terminals", void 0), e([y({ type: a5.apiValues, json: { type: a5.jsonValues, read: a5.read, write: a5.write } })], n5.prototype, "traversabilityModel", void 0), n5 = e([a("esri.networks.support.TerminalConfiguration")], n5);
var p3 = n5;

// node_modules/@arcgis/core/networks/support/TraceJobInfo.js
var m3 = i()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var n6 = class extends a3 {
  constructor(t3) {
    super(t3), this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(t3) {
    const e4 = { ...t3, query: { f: "json" } }, { data: r2 } = await U(this.statusUrl, e4), o2 = r2.traceResults ? { ...r2.traceResults, ...r2 } : r2;
    return this.read(o2), this;
  }
  async waitForJobCompletion(t3 = {}) {
    const { interval: s4 = 1e3, statusCallback: e4 } = t3;
    return new Promise((t4, o2) => {
      this._clearTimer();
      const i4 = setInterval(() => {
        this._timer || o2(u()), this.checkJobStatus().then((s5) => {
          const { status: r2 } = s5;
          switch (this.status = r2, r2) {
            case "job-succeeded":
              this._clearTimer(), t4(this);
              break;
            case "job-waiting":
            case "job-executing":
              e4 && e4(this);
          }
        }, (t5) => {
          this._clearTimer(), o2(t5);
        });
      }, s4);
      this._timer = i4;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
e([y({ type: String, json: { write: true } })], n6.prototype, "statusUrl", void 0), e([o(m3)], n6.prototype, "status", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t3, s4) => {
  s4.submissionTime = t3 ? t3.getTime() : null;
} } } })], n6.prototype, "submissionTime", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t3, s4) => {
  s4.lastUpdatedTime = t3 ? t3.getTime() : null;
} } } })], n6.prototype, "lastUpdatedTime", void 0), n6 = e([a("esri.networks.support.TraceJobInfo")], n6);
var p4 = n6;

// node_modules/@arcgis/core/networks/UtilityNetwork.js
var f4 = class extends N {
  constructor(e4) {
    super(e4), this.sharedNamedTraceConfigurations = [], this.type = "utility";
  }
  get serviceTerritoryFeatureLayerId() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.serviceTerritoryFeatureLayerId) ?? null;
  }
  get networkSystemLayers() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return new l4({ rulesTableId: (_a = this.sourceJSON) == null ? void 0 : _a.systemLayers.rulesTableId, rulesTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_b = this.sourceJSON) == null ? void 0 : _b.systemLayers.rulesTableId}` : null, subnetworksTableId: (_c = this.sourceJSON) == null ? void 0 : _c.systemLayers.subnetworksTableId, subnetworksTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_d = this.sourceJSON) == null ? void 0 : _d.systemLayers.subnetworksTableId}` : null, dirtyAreasLayerId: (_e = this.sourceJSON) == null ? void 0 : _e.systemLayers.dirtyAreasLayerId, dirtyAreasLayerUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_f = this.sourceJSON) == null ? void 0 : _f.systemLayers.dirtyAreasLayerId}` : null, associationsTableId: (_g = this.sourceJSON) == null ? void 0 : _g.systemLayers.associationsTableId, associationsTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_h = this.sourceJSON) == null ? void 0 : _h.systemLayers.associationsTableId}` : null });
  }
  get terminalConfigurations() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.terminalConfigurations.map((e4) => p3.fromJSON(e4))) || [];
  }
  get domainNetworkNames() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.domainNetworks.map((e4) => e4.domainNetworkName)) || [];
  }
  get _utilityLayerList() {
    var _a, _b;
    const e4 = /* @__PURE__ */ new Set();
    return (_b = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks) == null ? void 0 : _b.map((t3) => {
      t3.edgeSources.map((t4) => {
        e4.add(t4.layerId);
      }), t3.junctionSources.map((t4) => {
        e4.add(t4.layerId);
      });
    }), e4;
  }
  async load(e4) {
    return this.addResolvingPromise(super.load(e4)), this.addResolvingPromise(this._loadNamedTraceConfigurationsFromNetwork(e4)), this;
  }
  getTerminalConfiguration(e4) {
    var _a, _b, _c, _d;
    let t3 = null, r2 = null;
    const o2 = e4.layer;
    let s4 = null;
    if ("feature" === (o2 == null ? void 0 : o2.type)) {
      if (s4 = o2.layerId, null === s4)
        return null;
    } else {
      if ("subtype-sublayer" !== (o2 == null ? void 0 : o2.type))
        return null;
      if (s4 = ((_a = o2 == null ? void 0 : o2.parent) == null ? void 0 : _a.layerId) ?? null, null === s4)
        return null;
    }
    const a6 = e4.attributes;
    if (null == a6)
      return null;
    for (const l5 of Object.keys(a6))
      "ASSETGROUP" === l5.toUpperCase() && (t3 = e4.getAttribute(l5)), "ASSETTYPE" === l5.toUpperCase() && (r2 = e4.getAttribute(l5));
    if (!this.dataElement)
      return null;
    let i4 = null;
    const n7 = this.dataElement.domainNetworks;
    for (const l5 of n7) {
      const e5 = (_b = l5.junctionSources) == null ? void 0 : _b.find((e6) => e6.layerId === s4);
      if (e5) {
        const o3 = (_c = e5.assetGroups) == null ? void 0 : _c.find((e6) => e6.assetGroupCode === t3);
        if (o3) {
          const e6 = (_d = o3.assetTypes) == null ? void 0 : _d.find((e7) => e7.assetTypeCode === r2);
          if (e6) {
            i4 = e6.terminalConfigurationId;
            break;
          }
        }
      }
    }
    if (null != i4) {
      const e5 = this.dataElement.terminalConfigurations, t4 = e5 == null ? void 0 : e5.find((e6) => e6.terminalConfigurationId === i4);
      return t4 ? p3.fromJSON(t4) : null;
    }
    return null;
  }
  getTierNames(e4) {
    var _a;
    const t3 = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks.find((t4) => t4.domainNetworkName === e4);
    return (t3 == null ? void 0 : t3.tiers.map((e5) => e5.name)) || [];
  }
  async getRulesTable() {
    return this._sharedRulesTable || (this._sharedRulesTable = this._createRulesTable()), await this._sharedRulesTable;
  }
  isUtilityLayer(e4) {
    var _a;
    return this._utilityLayerList.has(e4.layerId) && (((_a = e4.url) == null ? void 0 : _a.startsWith(this.featureServiceUrl)) ?? false);
  }
  async queryAssociations(e4) {
    const [{ queryAssociations: t3 }, { default: r2 }] = await Promise.all([import("./queryAssociations-SX6UW6AV.js"), import("./QueryAssociationsParameters-AKM733YA.js")]), o2 = r2.from(e4);
    o2.gdbVersion = this.gdbVersion, o2.moment = this.historicMoment;
    return (await t3(this.networkServiceUrl, o2)).associations;
  }
  async synthesizeAssociationGeometries(e4) {
    const [{ synthesizeAssociationGeometries: t3 }, { default: r2 }] = await Promise.all([import("./synthesizeAssociationGeometries-IU6F77MS.js"), import("./SynthesizeAssociationGeometriesParameters-I4LLOIGC.js")]), o2 = r2.from(e4);
    return o2.gdbVersion = this.gdbVersion, o2.moment = this.historicMoment, t3(this.networkServiceUrl, o2);
  }
  async trace(e4) {
    const [{ trace: t3 }, { default: r2 }] = await Promise.all([import("./trace-XGNWGLF4.js"), import("./TraceParameters-DPAOEDYO.js")]), o2 = r2.from(e4);
    return o2.gdbVersion = this.gdbVersion, o2.moment = this.historicMoment, t3(this.networkServiceUrl, o2);
  }
  async submitTraceJob(e4) {
    const [{ submitTraceJob: t3 }, { default: r2 }] = await Promise.all([import("./trace-XGNWGLF4.js"), import("./TraceParameters-DPAOEDYO.js")]), o2 = r2.from(e4);
    o2.gdbVersion = this.gdbVersion, o2.moment = this.historicMoment;
    const s4 = await t3(this.networkServiceUrl, o2);
    return new p4({ statusUrl: s4 });
  }
  async canAddAssociation(e4) {
    const t3 = await this.getRulesTable();
    if (!t3)
      return false;
    await t3.load();
    const r2 = (e5, t4) => e5 ? 1 === e5.terminalId ? !(t4 == null ? void 0 : t4.terminalId) || (t4 == null ? void 0 : t4.terminalId) === e5.terminalId : e5.terminalId === (t4 == null ? void 0 : t4.terminalId) : !(t4 == null ? void 0 : t4.terminalId), o2 = (e5, t4) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      return ((_a = e5.fromNetworkSource) == null ? void 0 : _a.sourceId) === ((_b = t4.fromNetworkElement) == null ? void 0 : _b.networkSourceId) && ((_c = e5.toNetworkSource) == null ? void 0 : _c.sourceId) === ((_d = t4.toNetworkElement) == null ? void 0 : _d.networkSourceId) && ((_e = e5.fromAssetGroup) == null ? void 0 : _e.assetGroupCode) === ((_f = t4.fromNetworkElement) == null ? void 0 : _f.assetGroupCode) && ((_g = e5.fromAssetType) == null ? void 0 : _g.assetTypeCode) === ((_h = t4.fromNetworkElement) == null ? void 0 : _h.assetTypeCode) && ((_i = e5.toAssetGroup) == null ? void 0 : _i.assetGroupCode) === ((_j = t4.toNetworkElement) == null ? void 0 : _j.assetGroupCode) && ((_k = e5.toAssetType) == null ? void 0 : _k.assetTypeCode) === ((_l = t4.toNetworkElement) == null ? void 0 : _l.assetTypeCode) && r2(e5.fromTerminal, t4.fromNetworkElement) && r2(e5.toTerminal, t4.toNetworkElement);
    };
    if ("containment" === e4.associationType) {
      return t3.rulesCategorized.containment.some((t4) => o2(t4, e4));
    }
    if ("attachment" === e4.associationType) {
      return t3.rulesCategorized.attachment.some((t4) => o2(t4, e4));
    }
    return t3.rulesCategorized.connectivity.some((t4) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
      return t4.viaNetworkSource ? ((_a = t4.fromNetworkSource) == null ? void 0 : _a.sourceId) === ((_b = e4.fromNetworkElement) == null ? void 0 : _b.networkSourceId) && ((_c = t4.viaNetworkSource) == null ? void 0 : _c.sourceId) === ((_d = e4.toNetworkElement) == null ? void 0 : _d.networkSourceId) && ((_e = t4.fromAssetGroup) == null ? void 0 : _e.assetGroupCode) === ((_f = e4.fromNetworkElement) == null ? void 0 : _f.assetGroupCode) && ((_g = t4.fromAssetType) == null ? void 0 : _g.assetTypeCode) === ((_h = e4.fromNetworkElement) == null ? void 0 : _h.assetTypeCode) && ((_i = t4.viaAssetGroup) == null ? void 0 : _i.assetGroupCode) === ((_j = e4.toNetworkElement) == null ? void 0 : _j.assetGroupCode) && ((_k = t4.viaAssetType) == null ? void 0 : _k.assetTypeCode) === ((_l = e4.toNetworkElement) == null ? void 0 : _l.assetTypeCode) && r2(t4.fromTerminal, e4.fromNetworkElement) && r2(t4.viaTerminal, e4.toNetworkElement) || ((_m = t4.viaNetworkSource) == null ? void 0 : _m.sourceId) === ((_n = e4.fromNetworkElement) == null ? void 0 : _n.networkSourceId) && ((_o = t4.toNetworkSource) == null ? void 0 : _o.sourceId) === ((_p = e4.toNetworkElement) == null ? void 0 : _p.networkSourceId) && ((_q = t4.viaAssetGroup) == null ? void 0 : _q.assetGroupCode) === ((_r = e4.fromNetworkElement) == null ? void 0 : _r.assetGroupCode) && ((_s = t4.viaAssetType) == null ? void 0 : _s.assetTypeCode) === ((_t = e4.fromNetworkElement) == null ? void 0 : _t.assetTypeCode) && ((_u = t4.toAssetGroup) == null ? void 0 : _u.assetGroupCode) === ((_v = e4.toNetworkElement) == null ? void 0 : _v.assetGroupCode) && ((_w = t4.toAssetType) == null ? void 0 : _w.assetTypeCode) === ((_x = e4.toNetworkElement) == null ? void 0 : _x.assetTypeCode) && r2(t4.viaTerminal, e4.fromNetworkElement) && r2(t4.toTerminal, e4.toNetworkElement) : o2(t4, e4);
    });
  }
  generateAddAssociations(e4) {
    return { addFeatures: e4.map((e5) => {
      var _a, _b, _c, _d, _e, _f;
      return new f3({ attributes: { fromnetworksourceid: (_a = e5.fromNetworkElement) == null ? void 0 : _a.networkSourceId, fromglobalid: (_b = e5.fromNetworkElement) == null ? void 0 : _b.globalId, fromterminalid: (_c = e5.fromNetworkElement) == null ? void 0 : _c.terminalId, tonetworksourceid: (_d = e5.toNetworkElement) == null ? void 0 : _d.networkSourceId, toglobalid: (_e = e5.toNetworkElement) == null ? void 0 : _e.globalId, toterminalid: (_f = e5.toNetworkElement) == null ? void 0 : _f.terminalId, associationtype: e2[e5.associationType], iscontentvisible: e5.isContentVisible ? 1 : 0, percentalong: e5.percentAlong, globalid: e5.globalId } });
    }), id: this.networkSystemLayers.associationsTableId, identifierFields: { globalIdField: "globalid", objectIdField: "objectid" } };
  }
  generateDeleteAssociations(e4) {
    return { deleteFeatures: e4.map((e5) => ({ globalId: e5.globalId })), id: this.networkSystemLayers.associationsTableId, identifierFields: { globalIdField: "globalid", objectIdField: "objectid" } };
  }
  async _loadNamedTraceConfigurationsFromNetwork(e4) {
    var _a;
    if (0 === ((_a = this.sharedNamedTraceConfigurations) == null ? void 0 : _a.length))
      return;
    const t3 = this.sharedNamedTraceConfigurations.map((e5) => e5.globalId), r2 = await this.queryNamedTraceConfigurations({ globalIds: t3 }, e4);
    for (const o2 of this.sharedNamedTraceConfigurations) {
      const e5 = r2 == null ? void 0 : r2.find((e6) => e6.globalId === o2.globalId);
      if (e5) {
        const t4 = e5.write({}, { origin: "service" });
        o2.read(t4, { origin: "service" });
      }
    }
  }
  async _createRulesTable() {
    var _a;
    const e4 = this.networkSystemLayers.rulesTableUrl, t3 = new We({ url: e4 });
    await t3.load();
    const r2 = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks;
    if (!r2)
      return null;
    const o2 = r2.flatMap((e5) => [...e5.edgeSources || [], ...e5.junctionSources || []]), a6 = (await w2(t3)).map((e5) => this._hydrateRuleInfo(t3, o2, e5));
    return new c2({ layer: t3, rules: a6 });
  }
  _hydrateRuleInfo(e4, t3, r2) {
    const o2 = e4.fieldsIndex, s4 = o2.get("RULETYPE"), a6 = o2.get("CREATIONDATE"), i4 = o2.get("FROMNETWORKSOURCEID"), n7 = o2.get("FROMASSETGROUP"), l5 = o2.get("FROMASSETTYPE"), u3 = o2.get("FROMTERMINALID"), m4 = o2.get("TONETWORKSOURCEID"), d3 = o2.get("TOASSETGROUP"), c3 = o2.get("TOASSETTYPE"), y3 = o2.get("TOTERMINALID"), f5 = o2.get("VIANETWORKSOURCEID"), w3 = o2.get("VIAASSETGROUP"), T2 = o2.get("VIAASSETTYPE"), I2 = o2.get("VIATERMINALID"), g = r2.attributes[s4.name], k2 = new Date(r2.attributes[a6.name]), b5 = [{ networkSourceId: r2.attributes[i4.name], assetGroupId: r2.attributes[n7.name], assetTypeId: r2.attributes[l5.name], terminalId: r2.attributes[u3.name] }, { networkSourceId: r2.attributes[m4.name], assetGroupId: r2.attributes[d3.name], assetTypeId: r2.attributes[c3.name], terminalId: r2.attributes[y3.name] }, { networkSourceId: r2.attributes[f5.name], assetGroupId: r2.attributes[w3.name], assetTypeId: r2.attributes[T2.name], terminalId: r2.attributes[I2.name] }];
    let h2;
    !function(e5) {
      e5[e5.from = 0] = "from", e5[e5.to = 1] = "to", e5[e5.via = 2] = "via";
    }(h2 || (h2 = {}));
    const N2 = { ruleType: g, creationDate: k2 };
    for (const S4 of [h2.from, h2.to, h2.via]) {
      if (g !== t2.RTEdgeJunctionEdgeConnectivity && S4 === h2.via)
        continue;
      const e5 = b5[S4], r3 = t3.find((t4) => t4.sourceId === e5.networkSourceId), o3 = r3 == null ? void 0 : r3.assetGroups.find((t4) => t4.assetGroupCode === e5.assetGroupId), s5 = o3 == null ? void 0 : o3.assetTypes.find((t4) => t4.assetTypeCode === e5.assetTypeId), a7 = this._getTerminal(s5, e5);
      let i5 = "";
      switch (S4) {
        case h2.from:
          i5 = "from";
          break;
        case h2.to:
          i5 = "to";
          break;
        case h2.via:
          i5 = "via";
      }
      N2[`${i5}NetworkSource`] = r3, N2[`${i5}AssetGroup`] = o3, N2[`${i5}AssetType`] = s5, N2[`${i5}Terminal`] = a7 == null ? void 0 : a7.toJSON();
    }
    return N2;
  }
  _getTerminal(e4, t3) {
    var _a, _b;
    const r2 = e4 == null ? void 0 : e4.terminalConfigurationId, o2 = (_a = this.terminalConfigurations) == null ? void 0 : _a.find((e5) => e5.id === r2);
    return ((_b = o2 == null ? void 0 : o2.terminals) == null ? void 0 : _b.find((e5) => e5.id === t3.terminalId)) ?? null;
  }
};
async function w2(e4) {
  const t3 = new b2({ where: "1=1", outFields: ["*"] });
  return (await r(e4, t3)).features;
}
e([y({ type: [d2], json: { origins: { "web-map": { read: { source: "traceConfigurations" }, write: { target: "traceConfigurations" } }, service: { read: { source: "traceConfigurations" } } }, read: false } })], f4.prototype, "sharedNamedTraceConfigurations", void 0), e([y({ type: ["utility"], readOnly: true, json: { read: false, write: false } })], f4.prototype, "type", void 0), e([y({ readOnly: true })], f4.prototype, "serviceTerritoryFeatureLayerId", null), e([y({ readOnly: true })], f4.prototype, "networkSystemLayers", null), e([y({ readOnly: true })], f4.prototype, "terminalConfigurations", null), e([y({ readOnly: true })], f4.prototype, "domainNetworkNames", null), f4 = e([a("esri.networks.UtilityNetwork")], f4);
var T = f4;

export {
  n4 as n,
  s2 as s,
  T
};
//# sourceMappingURL=chunk-6N3VNDLJ.js.map
