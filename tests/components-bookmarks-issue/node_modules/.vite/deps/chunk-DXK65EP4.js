import {
  s as s3
} from "./chunk-H6MCGW3O.js";
import {
  n
} from "./chunk-J54I3TB7.js";
import {
  o as o3
} from "./chunk-4GGEQMYI.js";
import {
  o as o4
} from "./chunk-ZEMG7GKC.js";
import {
  e as e3
} from "./chunk-5MQ4HAUX.js";
import {
  a as a2
} from "./chunk-XIWETS2Q.js";
import {
  d as d2
} from "./chunk-QFKFOAJ6.js";
import {
  l
} from "./chunk-LOPMLCHC.js";
import {
  i
} from "./chunk-DRCNNCTI.js";
import {
  l as l2
} from "./chunk-MKOOEINB.js";
import {
  c
} from "./chunk-3DFMDDMO.js";
import {
  P
} from "./chunk-FV43HSGW.js";
import {
  d
} from "./chunk-ZR7OV2EH.js";
import {
  s as s2
} from "./chunk-GO2OGJDG.js";
import {
  s
} from "./chunk-TXLJQAAN.js";
import {
  e2
} from "./chunk-CSSLIU64.js";
import {
  a,
  t
} from "./chunk-CJNDQ2LH.js";
import {
  o as o2
} from "./chunk-CDBOQCLE.js";
import {
  o
} from "./chunk-P4MNTMCZ.js";
import {
  e
} from "./chunk-GLF3KRAL.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js
function e4(e5) {
  e5.vertex.code.add(o`vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {
vec3 camToVert = posWorld - camPosWorld;
bool isBackface = dot(camToVert, normalWorld) > 0.0;
if (isBackface) {
posClip.z += 0.0000003 * posClip.w;
}
return posClip;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js
function i2(i3, t2) {
  t2.hasSymbolColors ? (i3.include(e2), i3.attributes.add(e.SYMBOLCOLOR, "vec4"), i3.varyings.add("colorMixMode", "mediump float"), i3.vertex.code.add(o`int symbolColorMixMode;
vec4 getSymbolColor() {
return decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;
}
void forwardColorMixMode() {
colorMixMode = float(symbolColorMixMode) + 0.5;
}`)) : (i3.fragment.uniforms.add(new e3("colorMixMode", (o5) => c[o5.colorMixMode])), i3.vertex.code.add(o`vec4 getSymbolColor() { return vec4(1.0); }
void forwardColorMixMode() {}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js
function h(h2, x) {
  const { vertex: j, fragment: O } = h2, w = x.hasColorTexture && x.alphaDiscardMode !== s.Opaque;
  switch (x.output) {
    case o2.LinearDepth:
    case o2.Shadow:
    case o2.ShadowHighlight:
    case o2.ShadowExcludeHighlight:
    case o2.ObjectAndLayerIdColor:
      d(j, x), h2.include(o4, x), h2.include(o3, x), h2.include(l2, x), h2.include(l, x), h2.include(P, x), h2.include(d2, x), i(h2), h2.varyings.add("depth", "float"), w && O.uniforms.add(new s2("tex", (o5) => o5.texture)), j.code.add(o`void main(void) {
vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
forwardTextureCoordinates();
forwardObjectAndLayerIdColor();
}`), h2.include(s3, x), O.code.add(o`
          void main(void) {
            discardBySlice(vpos);
            ${w ? o`
                    vec4 texColor = texture(tex, ${x.hasColorTextureTransform ? o`colorUV` : o`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            ${x.output === o2.ObjectAndLayerIdColor ? o`outputObjectAndLayerIdColor();` : o`outputDepth(depth);`}
          }
        `);
      break;
    case o2.Normal: {
      d(j, x), h2.include(o4, x), h2.include(t, x), h2.include(n, x), h2.include(o3, x), h2.include(l2, x), w && O.uniforms.add(new s2("tex", (o6) => o6.texture)), x.normalType === a.ScreenDerivative && h2.varyings.add("vPositionView", "vec3");
      const o5 = x.normalType === a.Attribute || x.normalType === a.Compressed;
      j.code.add(o`
          void main(void) {
            vpos = getVertexInLocalOriginSpace();

            ${o5 ? o`vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));` : o`
                  // Get vertex position in camera space for screen-space derivative normals
                  vPositionView = (view * vec4(vpos, 1.0)).xyz;
                `}
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, vpos);
            forwardTextureCoordinates();
          }
        `), h2.include(P, x), h2.include(s3, x), O.code.add(o`
          void main() {
            discardBySlice(vpos);
            ${w ? o`
                    vec4 texColor = texture(tex, ${x.hasColorTextureTransform ? o`colorUV` : o`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}

            ${x.normalType === a.ScreenDerivative ? o`vec3 normal = screenDerivativeNormal(vPositionView);` : o`
                  vec3 normal = normalize(vNormalWorld);
                  if (gl_FrontFacing == false){
                    normal = -normal;
                  }`}
            fragColor = vec4(0.5 + 0.5 * normal, 1.0);
          }
        `);
      break;
    }
    case o2.Highlight:
      d(j, x), h2.include(o4, x), h2.include(o3, x), h2.include(l2, x), w && O.uniforms.add(new s2("tex", (o5) => o5.texture)), j.code.add(o`void main(void) {
vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();
}`), h2.include(P, x), h2.include(s3, x), h2.include(a2, x), O.code.add(o`
          void main() {
            discardBySlice(vpos);
            ${w ? o`
                    vec4 texColor = texture(tex, ${x.hasColorTextureTransform ? o`colorUV` : o`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            outputHighlight();
          }
        `);
  }
}

export {
  e4 as e,
  i2 as i,
  h
};
//# sourceMappingURL=chunk-DXK65EP4.js.map
