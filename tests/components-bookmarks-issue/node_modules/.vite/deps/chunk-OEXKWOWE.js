import {
  l as l2
} from "./chunk-B473F3N3.js";
import {
  l
} from "./chunk-PMQ5HDZI.js";
import {
  S
} from "./chunk-CHJMCUAV.js";
import {
  i
} from "./chunk-VIKID44H.js";
import {
  n as n2
} from "./chunk-D56W4LPT.js";
import {
  F,
  K,
  b,
  v as v2
} from "./chunk-Z2F5OKVA.js";
import {
  o,
  q,
  v
} from "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";
import {
  se
} from "./chunk-UWQ3OYA5.js";

// node_modules/@arcgis/core/views/support/euclideanAreaMeasurementUtils.js
function g(t, o2 = U()) {
  return h(t, o2);
}
function j(t, o2 = U()) {
  return h(t, o2, false);
}
function h(r, g2, j2 = r.hasZ) {
  const h2 = l2(r.spatialReference), U2 = se(h2);
  if (null == U2)
    return null;
  const v4 = (t, o2) => !(o2.length < 2) && (o(t, o2[0], o2[1], j2 && o2[2] || 0), true);
  let x = 0;
  for (const t of r.rings) {
    const o2 = t.length;
    if (o2 < 3)
      continue;
    const { positionsWorldCoords: a } = g2;
    for (; a.length < o2; )
      a.push(n());
    const j3 = y, U3 = o(d, 0, 0, 0), C = 1 / o2;
    for (let n3 = 0; n3 < o2; n3++) {
      if (!v4(j3, t[n3]))
        return null;
      if (!n2(j3, r.spatialReference, a[n3], h2))
        return null;
      q(U3, U3, a[n3], C);
    }
    const R = b(a[0], a[1], U3, v2());
    if (0 === v(F(R)))
      continue;
    for (let t2 = 0; t2 < o2; t2++)
      K(R, U3, a[t2], a[t2]);
    const V = k(a);
    for (let t2 = 0; t2 < V.length; t2 += 3)
      x += S(a[V[t2]], a[V[t2 + 1]], a[V[t2 + 2]]);
  }
  return l(x, U2);
}
var y = n();
var d = n();
function U() {
  return { positionsWorldCoords: [] };
}
function k(t) {
  return i(v3(t), [], 2);
}
function v3(t) {
  const o2 = new Float64Array(2 * t.length);
  for (let r = 0; r < t.length; ++r) {
    const n3 = t[r], e = 2 * r;
    o2[e] = n3[0], o2[e + 1] = n3[1];
  }
  return o2;
}

export {
  g,
  j,
  U,
  k
};
//# sourceMappingURL=chunk-OEXKWOWE.js.map
