import {
  o as o5,
  p as p4,
  r as r4,
  s as s4
} from "./chunk-EZMIPVQL.js";
import {
  A as A3,
  y as y3
} from "./chunk-7IFMSG3H.js";
import {
  d as d6
} from "./chunk-CA3XJ2RX.js";
import {
  u as u2
} from "./chunk-JASPUPTW.js";
import {
  r as r5
} from "./chunk-6BCJJDKK.js";
import {
  n as n6,
  r as r6,
  t as t3
} from "./chunk-DNFHDQRJ.js";
import {
  E as E2,
  Et,
  J,
  Rt,
  d as d5,
  f as f3,
  g as g3,
  gt,
  v,
  w,
  xt
} from "./chunk-TO6UIATU.js";
import {
  E,
  d as d4,
  f as f2,
  l as l2,
  n as n5,
  p as p3,
  s as s3,
  y as y2
} from "./chunk-WCBCYPOZ.js";
import {
  I,
  N,
  j as j2
} from "./chunk-UXQH3C5A.js";
import {
  t as t2
} from "./chunk-BEXFYHUM.js";
import {
  f,
  o as o4
} from "./chunk-PMQ5HDZI.js";
import {
  o as o3
} from "./chunk-I7LDU4W6.js";
import {
  r as r3,
  s as s2
} from "./chunk-YKIGDW5O.js";
import {
  h
} from "./chunk-I4SHZ6P5.js";
import {
  _,
  b,
  d as d3,
  e as e4,
  j,
  m,
  p as p2
} from "./chunk-3AIILHI5.js";
import {
  $
} from "./chunk-SA77Z3WI.js";
import {
  d as d2
} from "./chunk-DRC4XSYG.js";
import {
  n as n4
} from "./chunk-ZLQTPFTL.js";
import {
  n as n2
} from "./chunk-VEODBKUJ.js";
import {
  c as c2,
  r as r2
} from "./chunk-HLDUDRTD.js";
import {
  B,
  H
} from "./chunk-2ICUS4HL.js";
import {
  A as A2,
  G,
  e as e3,
  o as o2,
  p,
  q,
  r,
  u
} from "./chunk-JZBR4X6W.js";
import {
  n as n3,
  t
} from "./chunk-OIJCMME5.js";
import {
  e as e2
} from "./chunk-4KLYOMH2.js";
import {
  L,
  W2 as W
} from "./chunk-UWQ3OYA5.js";
import {
  A,
  C,
  d,
  x
} from "./chunk-Z4Y53NDM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  o
} from "./chunk-TXBMNSNF.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  c2 as c,
  g as g2,
  l,
  s
} from "./chunk-JGDJR5EV.js";
import {
  n2 as n
} from "./chunk-7RBRCL6S.js";
import {
  g
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/interactive/snapping/FeatureSnappingLayerSource.js
var i = class extends S {
  constructor(o7) {
    super(o7), this.layer = null, this.enabled = true, this.updating = false, this.availability = 1, this.sublayerSources = new V();
  }
};
e([y({ constructOnly: true })], i.prototype, "layer", void 0), e([y()], i.prototype, "enabled", void 0), e([y()], i.prototype, "updating", void 0), e([y()], i.prototype, "availability", void 0), e([y()], i.prototype, "sublayerSources", void 0), i = e([a("esri.views.interactive.snapping.FeatureSnappingLayerSource")], i);
var p5 = i;

// node_modules/@arcgis/core/views/interactive/snapping/SnappingOptions.js
var c3 = class extends S {
  constructor(e5) {
    super(e5), this.enabled = false, this.enabledToggled = false, this.forceDisabled = false, this.selfEnabled = true, this.featureEnabled = true, this.featureSources = new V(), this.distance = p4.distance, this.touchSensitivityMultiplier = p4.touchSensitivityMultiplier;
  }
  get effectiveEnabled() {
    return !this.forceDisabled && (this.enabledToggled ? !this.enabled : this.enabled);
  }
  get effectiveSelfEnabled() {
    return this.effectiveEnabled && this.selfEnabled;
  }
  get effectiveFeatureEnabled() {
    return this.effectiveEnabled && this.featureEnabled;
  }
  get _effectiveFeatureSources() {
    var _a;
    const e5 = this.featureSources;
    e5.some(p6) && n.getLogger(this).warnOnce("Do not configure SubtypeGroupLayer sources in SnappingOptions.featureSources directly. Create a FeatureSnappingLayerSource for each SubtypeSublayer.");
    const t4 = e5.filter(d7), i3 = ((_a = this._get("_effectiveFeatureSources")) == null ? void 0 : _a.filter(p6)) ?? new V();
    for (const r9 of t4) {
      const e6 = i3.find((e7) => e7.layer === r9.layer.parent);
      if (e6)
        e6.sublayerSources.includes(r9) || e6.sublayerSources.add(r9);
      else if (r9.layer.parent) {
        const e7 = new p5({ layer: r9.layer.parent });
        e7.sublayerSources.add(r9), i3.add(e7);
      }
    }
    for (const r9 of i3) {
      const e6 = r9.sublayerSources.filter((e7) => !t4.includes(e7));
      r9.sublayerSources.removeMany(e6);
    }
    i3.removeMany(i3.filter((e6) => 0 === e6.sublayerSources.length));
    const a2 = e5.filter(f4), l4 = this._get("_effectiveFeatureSources") ?? new V(), { added: c5, removed: u4 } = g(l4.toArray(), [...a2, ...i3]);
    return l4.removeMany(u4), l4.addMany(c5), l4;
  }
};
e([y()], c3.prototype, "enabled", void 0), e([y()], c3.prototype, "enabledToggled", void 0), e([y()], c3.prototype, "forceDisabled", void 0), e([y()], c3.prototype, "selfEnabled", void 0), e([y()], c3.prototype, "featureEnabled", void 0), e([y({ type: V.ofType(p5) })], c3.prototype, "featureSources", void 0), e([y()], c3.prototype, "distance", void 0), e([y()], c3.prototype, "touchSensitivityMultiplier", void 0), e([y({ readOnly: true })], c3.prototype, "effectiveEnabled", null), e([y({ readOnly: true })], c3.prototype, "effectiveSelfEnabled", null), e([y({ readOnly: true })], c3.prototype, "effectiveFeatureEnabled", null), e([y({ readOnly: true })], c3.prototype, "_effectiveFeatureSources", null), c3 = e([a("esri.views.interactive.snapping.SnappingOptions")], c3);
var u3 = c3;
function p6(e5) {
  return "subtype-group" === e5.layer.type;
}
function f4(e5) {
  return "subtype-group" !== e5.layer.type;
}
function d7(e5) {
  return "subtype-sublayer" === e5.layer.type;
}

// node_modules/@arcgis/core/views/interactive/snapping/FeatureSnappingSourceInfo.js
var f5 = class extends S {
  get layerView() {
    var _a, _b;
    return (_b = (_a = this.view) == null ? void 0 : _a.allLayerViews) == null ? void 0 : _b.find((e5) => e5.layer === this.layer);
  }
  get valid() {
    return this._valid;
  }
  get subtypeFilter() {
    var _a, _b;
    const { layer: e5, snappingSource: r9 } = this;
    if (!c2(e5) || !((_a = e5.subtypes) == null ? void 0 : _a.length))
      return { mode: "not-in-use", filter: null };
    const t4 = r9.layerSource.sublayerSources.filter((e6) => {
      var _a2;
      return e6.enabled && e6.layer.visible && t2((_a2 = this.view) == null ? void 0 : _a2.scale, e6.layer.effectiveScaleRange.minScale, e6.layer.effectiveScaleRange.maxScale);
    }).map((e6) => e6.layer.subtypeCode);
    if (!t4.length)
      return { mode: "none-visible", filter: null };
    if (t4.length === e5.subtypes.length)
      return { mode: "all-visible", filter: null };
    const i3 = ((_b = e5.fieldsIndex.get(e5.subtypeField)) == null ? void 0 : _b.name) ?? e5.subtypeField;
    return 1 === t4.length ? { mode: "in-use", filter: `${i3} = ${t4.getItemAt(0)}` } : { mode: "in-use", filter: `${i3} IN (${t4.join(", ")})` };
  }
  get floorFilter() {
    const { view: e5, layer: r9 } = this;
    return e5 && r9 ? o3({ view: e5, layer: r9 }) : null;
  }
  constructor(e5) {
    super(e5), this.rulesTable = null, this._valid = false;
  }
  initialize() {
    if (!this.snappingSource || !this.layer)
      return;
    const { layer: e5, snappingSource: r9 } = this;
    if ("refresh" in e5) {
      const t4 = e5;
      this.addHandles(t4.on("refresh", () => r9.refresh()));
    }
    this.loadRules(), this.addHandles([d(() => r9.updating, (e6) => r9.layerSource.updating = e6, A), d(() => r9.availability, (e6) => r9.layerSource.availability = e6, A)]);
  }
  getFetchCandidatesParameters(e5, r9, t4) {
    var _a, _b, _c, _d, _e;
    if (!this.valid)
      return [];
    const { layer: i3, layerView: l4, floorFilter: s5, rulesTable: a2, subtypeFilter: u4 } = this, y4 = { distance: t4, mode: ((_a = this.view) == null ? void 0 : _a.type) ?? "2d", point: e5, coordinateHelper: r9.coordinateHelper, ...m2(), filter: l4 && "filter" in l4 ? l4.filter : null };
    if (s5 && (y4.filter = h2(y4.filter, s5)), "not-in-use" !== u4.mode && "all-visible" !== u4.mode) {
      if ("none-visible" === u4.mode)
        return [];
      y4.filter ? y4.filter.where = n2(y4.filter.where, u4.mode) : y4.filter = new d2({ where: u4.filter });
    }
    const f7 = r9.feature, v3 = "subtype-sublayer" === ((_b = f7 == null ? void 0 : f7.sourceLayer) == null ? void 0 : _b.type) ? f7.sourceLayer.parent : f7 == null ? void 0 : f7.sourceLayer;
    if (a2 && f7 && v((_c = this.view) == null ? void 0 : _c.map) && (r2(i3) || c2(i3)) && i3.layerId && (r2(v3) || c2(v3)) && ((_d = this.view.map.utilityNetworks) == null ? void 0 : _d.find((e6) => e6.isUtilityLayer(v3)))) {
      if ("loaded" !== a2.loadStatus)
        return [];
      const e6 = [], r10 = i3.layerId, t5 = (_e = a2.getFeatureSQL(v3, f7)) == null ? void 0 : _e[r10];
      if (!t5)
        return [];
      const l5 = t5.anyVertex;
      let o7 = t5.endVertex;
      return o7 && l5 && o7 === l5 && (o7 = ""), o7 && e6.push({ ...y4, returnEdge: false, vertexMode: "ends", filter: h2(y4.filter, o7) }), l5 && e6.push({ ...y4, returnEdge: false, vertexMode: "all", filter: h2(y4.filter, l5) }), e6;
    }
    return [y4];
  }
  async loadRules() {
    var _a, _b;
    const { layer: e5, view: r9 } = this;
    if (e5 && r9 && v(r9 == null ? void 0 : r9.map) && (r2(e5) || c2(e5))) {
      const l4 = (_a = r9.map.utilityNetworks) == null ? void 0 : _a.find((r10) => r10.isUtilityLayer(e5));
      if (l4)
        try {
          this.rulesTable = await l4.getRulesTable(), await ((_b = this.rulesTable) == null ? void 0 : _b.load());
        } catch (i3) {
          return void n.getLogger("esri.views.interactive.snapping.FeatureSnappingSourceInfo").error("Failed to load rules table for snapping source", e5.title);
        }
    }
    this._valid = true;
  }
  remove() {
    this.destroy();
  }
  destroy() {
    var _a;
    (_a = this.snappingSource) == null ? void 0 : _a.destroy();
  }
};
function m2() {
  return { returnEdge: true, vertexMode: "all" };
}
function h2(e5, r9) {
  return null == e5 ? new d2({ where: r9 }) : e5.where ? new d2({ where: n2(e5.where, r9) }) : new d2({ where: r9 });
}
e([y({ constructOnly: true })], f5.prototype, "layer", void 0), e([y({ constructOnly: true })], f5.prototype, "snappingSource", void 0), e([y({ constructOnly: true })], f5.prototype, "view", void 0), e([y()], f5.prototype, "layerView", null), e([y()], f5.prototype, "rulesTable", void 0), e([y()], f5.prototype, "valid", null), e([y()], f5.prototype, "subtypeFilter", null), e([y()], f5.prototype, "floorFilter", null), e([y()], f5.prototype, "_valid", void 0), f5 = e([a("esri.views.interactive.snapping.FeatureSnappingSourceInfo")], f5);

// node_modules/@arcgis/core/views/interactive/snapping/candidates/RightAngleSnappingCandidate.js
var n7 = class extends t3 {
  constructor({ targetPoint: e5, constraint: i3, previousVertex: r9, otherVertex: s5, otherVertexType: n8, isDraped: o7, selfSnappingType: h5, objectId: a2 }) {
    super(e5, i3, o7, E.SELF), this.previousVertex = r9, this.otherVertex = s5, this.otherVertexType = n8, this.selfSnappingType = h5 ?? p7.None, this.objectId = a2 ?? null;
  }
  get hints() {
    const t4 = this.previousVertex, i3 = this.otherVertexType === o6.CENTER ? this.otherVertex : this.targetPoint, n8 = this.otherVertexType === o6.CENTER ? this.targetPoint : this.otherVertex;
    return [new n5(E2.TARGET, i3, n8, this.isDraped, this.domain), new n5(E2.REFERENCE, t4, i3, this.isDraped, this.domain), new s4(this.previousVertex, i3, n8, this.isDraped, this.domain)];
  }
};
var o6;
var p7;
!function(t4) {
  t4[t4.NEXT = 0] = "NEXT", t4[t4.CENTER = 1] = "CENTER";
}(o6 || (o6 = {})), function(t4) {
  t4[t4.None = 0] = "None", t4[t4.LastVertex = 1] = "LastVertex", t4[t4.FirstVertex = 2] = "FirstVertex", t4[t4.ExistingEdge = 3] = "ExistingEdge";
}(p7 || (p7 = {}));

// node_modules/@arcgis/core/views/interactive/snapping/FeatureSnappingEngine.js
var I2 = class extends S {
  get updating() {
    return this._snappingSources.some((e5) => null == e5 || e5.valid && e5.snappingSource.updating) || this._updatingHandles.updating;
  }
  constructor(e5) {
    super(e5), this.options = null, this._domain = E.FEATURE, this._updatingHandles = new h(), this._sourceModules = { featureService: { module: null, loader: null }, featureCollection: { module: null, loader: null }, graphics: { module: null, loader: null }, notes: { module: null, loader: null }, scene: { module: null, loader: null } };
  }
  initialize() {
    const e5 = x(() => {
      var _a;
      return (_a = this.options) == null ? void 0 : _a._effectiveFeatureSources;
    }, (e6, t4) => this._createSourceInfo(e6, t4));
    this._snappingSources = e5, this.addHandles(l(e5));
  }
  destroy() {
    this._set("options", null), this._updatingHandles.destroy();
  }
  async fetchCandidates(e5, t4, r9, s5) {
    var _a;
    if (!(t4 & this._domain && null != this.options && this.options.effectiveFeatureEnabled))
      return [];
    const i3 = [], o7 = this._computeScreenSizeDistanceParameters(e5, r9);
    for (const n8 of this._snappingSources) {
      if (null == n8 || !n8.valid || !n8.snappingSource.layerSource.enabled || ((_a = n8.layerView) == null ? void 0 : _a.suspended))
        continue;
      const t5 = n8.getFetchCandidatesParameters(e5, r9, o7);
      for (const e6 of t5)
        i3.push(n8.snappingSource.fetchCandidates(e6, s5).then((e7) => e7.filter((e8) => !this._candidateIsExcluded(n8.snappingSource, e8, r9.excludeFeature))));
    }
    const c5 = (await g2(i3)).flat();
    return this._addRightAngleCandidates(c5, e5, o7, r9), s(s5), f3(e5, c5), c5;
  }
  _addRightAngleCandidates(e5, t4, r9, n8) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const a2 = null != n8.vertexHandle ? (_b = (_a = n8.vertexHandle.rightEdge) == null ? void 0 : _a.rightVertex) == null ? void 0 : _b.pos : null != n8.editGeometryOperations && "polygon" === n8.editGeometryOperations.data.type ? (_d = (_c = n8.editGeometryOperations.data.components[0]) == null ? void 0 : _c.getFirstVertex()) == null ? void 0 : _d.pos : null, s5 = null != n8.vertexHandle ? (_f = (_e = n8.vertexHandle.leftEdge) == null ? void 0 : _e.leftVertex) == null ? void 0 : _f.pos : null != n8.editGeometryOperations ? (_h = (_g = n8.editGeometryOperations.data.components[0]) == null ? void 0 : _g.getLastVertex()) == null ? void 0 : _h.pos : null, { view: i3 } = this, o7 = p3(a2, i3, n8), c5 = p3(s5, i3, n8), u4 = e5.length;
    for (let p8 = 0; p8 < u4; p8++)
      this._addRightAngleCandidate(e5[p8], c5, t4, r9, e5), this._addRightAngleCandidate(e5[p8], o7, t4, r9, e5);
  }
  _addRightAngleCandidate(e5, t4, r9, n8, a2) {
    if (null == t4 || !G2(e5))
      return;
    const s5 = e5.constraint.closestTo(t4), i3 = (s5[0] - r9[0]) / n8.x, o7 = (s5[1] - r9[1]) / n8.y, { start: c5, end: u4 } = e5.constraint;
    if (i3 * i3 + o7 * o7 <= 1) {
      const r10 = new n7({ targetPoint: s5, otherVertex: t4, otherVertexType: o6.NEXT, previousVertex: b(f2(s5), f2(c5)) > b(f2(s5), f2(u4)) ? c5 : u4, constraint: new Et(t4, s5), objectId: e5.objectId, isDraped: e5.isDraped });
      a2.push(r10);
    }
  }
  _computeScreenSizeDistanceParameters(e5, t4) {
    let r9 = null != this.options ? this.options.distance * ("touch" === t4.pointer ? this.options.touchSensitivityMultiplier : 1) : 0;
    return null == this.view ? { x: r9, y: r9, z: r9, distance: r9 } : "2d" === this.view.type ? (r9 *= this.view.resolution, { x: r9, y: r9, z: r9, distance: r9 }) : this._computeScreenSizeDistanceParameters3D(e5, r9, this.view, t4);
  }
  _computeScreenSizeDistanceParameters3D(e5, t4, r9, n8) {
    const { spatialReference: a2 } = n8;
    r9.renderCoordsHelper.toRenderCoords(e5, a2, E3);
    const s5 = r9.state.camera.computeScreenPixelSizeAt(E3), c5 = s5 * r9.renderCoordsHelper.unitInMeters, u4 = c5 / W(a2), p8 = c5 / L(a2), l4 = t4 * u4, d8 = t4 * p8, m4 = d6(e5, a2, $, r9), g7 = m4 ? P(m4, e5, u4, 0, 0, r9, n8) : 0, S2 = m4 ? P(m4, e5, 0, u4, 0, r9, n8) : 0, f7 = m4 ? P(m4, e5, 0, 0, p8, r9, n8) : 0;
    return { x: 0 === g7 ? 0 : l4 / g7, y: 0 === S2 ? 0 : l4 / S2, z: 0 === f7 ? 0 : d8 / f7, distance: s5 * t4 };
  }
  _candidateIsExcluded(e5, t4, r9) {
    if (null == r9)
      return false;
    const n8 = this._getCandidateObjectId(t4);
    if (null == n8)
      return false;
    const a2 = e5.layerSource.layer;
    return "graphics" === a2.type ? r9.uid === n8 : r9.sourceLayer === a2 && (!(!r9.attributes || !("objectIdField" in a2)) && r9.attributes[a2.objectIdField] === n8);
  }
  _getCandidateObjectId(e5) {
    return e5 instanceof n6 ? e5.objectId : null;
  }
  async _createSourceInfo(e5, t4) {
    const r9 = e5.layer;
    r9.loaded || (await r9.load(), s(t4));
    const { view: n8 } = this, s5 = await this._createFeatureSnappingSourceType(e5);
    return s(t4), new f5(null == s5 ? {} : { snappingSource: s5, view: n8, layer: r9 });
  }
  async _createFeatureSnappingSourceType(e5) {
    switch (e5.layer.type) {
      case "feature":
      case "geojson":
      case "csv":
      case "oriented-imagery":
      case "subtype-group":
      case "wfs":
        return this._createFeatureSnappingSourceFeatureLayer(e5);
      case "graphics":
        return this._createFeatureSnappingSourceGraphicsLayer(e5);
      case "map-notes":
        return this._createFeatureSnappingSourceMapNotesLayer(e5);
      case "scene":
      case "building-scene":
        return this._createFeatureSnappingSourceSceneLayer(e5);
    }
    return null;
  }
  async _createFeatureSnappingSourceSceneLayer(e5) {
    const { view: t4 } = this;
    if (null == t4 || "3d" !== t4.type)
      return null;
    return new (await this._getSourceModule("scene")).SceneLayerSnappingSource({ layerSource: e5, view: t4 });
  }
  async _createFeatureSnappingSourceFeatureLayer(e5) {
    var _a;
    switch ((_a = e5.layer.source) == null ? void 0 : _a.type) {
      case "feature-layer":
      case "oriented-imagery":
        return new (await this._getSourceModule("featureService")).FeatureServiceSnappingSource({ spatialReference: this.spatialReference, view: this.view, layerSource: e5 });
      case "memory":
      case "csv":
      case "geojson":
      case "wfs":
        if ("mesh" === e5.layer.geometryType)
          return null;
        return new (await this._getSourceModule("featureCollection")).FeatureCollectionSnappingSource({ layerSource: e5, view: this.view });
    }
    return null;
  }
  async _createFeatureSnappingSourceGraphicsLayer(e5) {
    return new (await this._getSourceModule("graphics")).GraphicsSnappingSource({ getGraphicsLayers: () => [e5.layer], spatialReference: this.spatialReference, view: this.view, layerSource: e5 });
  }
  async _createFeatureSnappingSourceMapNotesLayer(e5) {
    return new (await this._getSourceModule("notes")).GraphicsSnappingSource({ getGraphicsLayers: () => {
      var _a;
      return ((_a = e5.layer.sublayers) == null ? void 0 : _a.toArray()) ?? [];
    }, spatialReference: this.spatialReference, view: this.view, layerSource: e5 });
  }
  async _getSourceModule(e5) {
    const t4 = this._sourceModules[e5];
    if (null == t4.loader) {
      const t5 = this._loadSourceModule(e5), r9 = { module: null, loader: t5 };
      this._sourceModules[e5] = r9;
      const n8 = await t5, a2 = { module: n8, loader: t5 };
      return this._sourceModules[e5] = a2, n8;
    }
    return null == t4.module ? t4.loader : t4.module;
  }
  _loadSourceModule(e5) {
    const t4 = this._updatingHandles;
    switch (e5) {
      case "featureService":
        return t4.addPromise(import("./FeatureServiceSnappingSource-5S4UHPWZ.js"));
      case "featureCollection":
        return t4.addPromise(import("./FeatureCollectionSnappingSource-OOJSMFS5.js"));
      case "graphics":
      case "notes":
        return t4.addPromise(import("./GraphicsSnappingSource-XK4VOLZL.js"));
      case "scene":
        return t4.addPromise(import("./SceneLayerSnappingSource-NAQJTO7R.js"));
    }
  }
  get test() {
    return { snappingSources: this._snappingSources };
  }
};
function G2(e5) {
  return (e5 instanceof r6 || e5 instanceof r5) && !H2(e5);
}
function H2({ constraint: { start: e5, end: t4 } }) {
  const r9 = p(e5, t4), n8 = b(f2(e5), f2(t4));
  return r9 < e2() || n8 / r9 < A4;
}
function P(e5, t4, r9, n8, a2, s5, { spatialReference: i3 }) {
  const o7 = r(z, t4);
  o7[0] += r9, o7[1] += n8, o7[2] += a2;
  const c5 = d6(o7, i3, $, s5);
  return c5 ? g3(c5, e5) : 1 / 0;
}
e([y({ constructOnly: true })], I2.prototype, "spatialReference", void 0), e([y({ constructOnly: true })], I2.prototype, "view", void 0), e([y()], I2.prototype, "options", void 0), e([y({ readOnly: true })], I2.prototype, "updating", null), e([y()], I2.prototype, "_snappingSources", void 0), I2 = e([a("esri.views.interactive.snapping.FeatureSnappingEngine")], I2);
var E3 = n3();
var z = n3();
var A4 = 1e-4;

// node_modules/@arcgis/core/views/interactive/snapping/SnappingAlgorithm.js
var l3 = class {
  constructor(e5, t4) {
    this.view = e5, this.options = t4, this.squaredShortLineThreshold = p4.shortLineThreshold * p4.shortLineThreshold;
  }
  snap(e5, t4) {
    return null != t4.vertexHandle ? "vertex" !== t4.vertexHandle.type ? [] : this.snapExistingVertex(e5, t4) : this.snapNewVertex(e5, t4);
  }
  edgeExceedsShortLineThreshold(e5, t4) {
    return this.exceedsShortLineThreshold(p3(e5.leftVertex.pos, this.view, t4), p3(e5.rightVertex.pos, this.view, t4), t4);
  }
  exceedsShortLineThreshold(e5, t4, { spatialReference: s5 }) {
    return 0 === this.squaredShortLineThreshold || d5(d6(t4, s5, $, this.view), d6(e5, s5, $, this.view)) > this.squaredShortLineThreshold;
  }
  isVertical(r9, s5, { spatialReference: h5 }) {
    const n8 = W(h5);
    return m(f2(r9), f2(s5)) * n8 < p4.verticalLineThresholdMeters;
  }
  squaredProximityThreshold(e5) {
    return "touch" === e5 ? this._squaredTouchProximityThreshold : this._squaredMouseProximityThreshold;
  }
  get _squaredMouseProximityThreshold() {
    return this.options.distance * this.options.distance;
  }
  get _squaredTouchProximityThreshold() {
    const { distance: e5, touchSensitivityMultiplier: t4 } = this.options, r9 = e5 * t4;
    return r9 * r9;
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/candidates/LineSnappingCandidate.js
var r7 = class extends t3 {
  constructor({ lineStart: e5, lineEnd: r9, targetPoint: o7, isDraped: a2 }) {
    super(o7, new Rt(e5, r9), a2, E.SELF), this._referenceLineHint = new n5(E2.REFERENCE_EXTENSION, e5, r9, a2, this.domain);
  }
  get hints() {
    return [this._referenceLineHint, new n5(E2.TARGET, this._lineEndClosestToTarget(), this.targetPoint, this.isDraped, this.domain)];
  }
  _lineEndClosestToTarget() {
    return this.constraint.closestEndTo(this.targetPoint);
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/LineSnapper.js
var j3 = class extends l3 {
  snapNewVertex(e5, t4) {
    const r9 = t4.editGeometryOperations.data.components[0], s5 = r9.edges.length, o7 = [];
    if (s5 < 1)
      return o7;
    const { spatialReference: n8 } = t4, a2 = d6(e5, n8, $, this.view), { view: p8 } = this, l4 = r9.edges[s5 - 1];
    let h5 = l4;
    do {
      if (this.edgeExceedsShortLineThreshold(h5, t4)) {
        const r10 = w(h5, p8, t4);
        this._processCandidateProposal(r10.left, r10.right, e5, a2, t4, o7);
      }
      h5 = h5.leftVertex.leftEdge;
    } while (h5 && h5 !== l4);
    return o7;
  }
  snapExistingVertex(e5, t4) {
    const r9 = [], s5 = t4.vertexHandle, o7 = s5.component;
    if (o7.edges.length < 2)
      return r9;
    const { view: a2 } = this, { spatialReference: p8 } = t4, l4 = d6(e5, p8, $, a2), h5 = s5.leftEdge, f7 = s5.rightEdge;
    h5 && f7 && this.edgeExceedsShortLineThreshold(h5, t4) && this.edgeExceedsShortLineThreshold(f7, t4) && this._processCandidateProposal(p3(h5.leftVertex.pos, a2, t4), p3(f7.rightVertex.pos, a2, t4), e5, l4, t4, r9);
    const g7 = o7.edges[0];
    let m4 = g7;
    do {
      if (m4 !== s5.leftEdge && m4 !== s5.rightEdge && this.edgeExceedsShortLineThreshold(m4, t4)) {
        const s6 = w(m4, a2, t4);
        this._processCandidateProposal(s6.left, s6.right, e5, l4, t4, r9);
      }
      m4 = m4.rightVertex.rightEdge;
    } while (m4 && m4 !== g7);
    return r9;
  }
  _processCandidateProposal(e5, t4, r9, s5, n8, p8) {
    var _a;
    const { spatialReference: d8, pointer: f7 } = n8, g7 = n3();
    E4(g7, e5, t4, r9, n8);
    const m4 = l2(g7);
    d5(s5, d6(m4, d8, $, this.view)) < this.squaredProximityThreshold(f7) && p8.push(new r7({ lineStart: e5, lineEnd: t4, targetPoint: m4, isDraped: "on-the-ground" === ((_a = n8.elevationInfo) == null ? void 0 : _a.mode) }));
  }
};
function E4(e5, t4, r9, s5, o7) {
  v2(e5, t4, r9, s5, o7) || w2(e5, s5, t4, r9);
}
function v2(o7, i3, n8, a2, { spatialReference: p8 }) {
  const d8 = y3(i3, n8, p8, p8);
  if (null == d8)
    return false;
  const l4 = y3(n8, a2, p8, p8);
  if (null == l4)
    return false;
  const h5 = u2(n8, a2, p8);
  if (null == h5)
    return false;
  const c5 = Math.abs(s2.shortestSignedDiff(d8, l4)) > Math.PI / 2 ? r3.normalize(d8 + Math.PI) : d8;
  return A3(o7, n8, p8, f(h5, "meters"), o4(c5, "radians", "geographic"), "geodesic"), o7[2] = a2[2], true;
}
function w2(e5, t4, r9, s5) {
  J(t4, { start: r9, end: s5, type: j2.LINE }, e5), e5[2] = t4[2];
}

// node_modules/@arcgis/core/views/interactive/snapping/candidates/ParallelLineSnappingCandidate.js
var g4 = class extends t3 {
  constructor({ referenceLine: i3, lineStart: f7, targetPoint: o7, isDraped: d8 }) {
    const h5 = t(f7), { left: g7, right: p8 } = i3;
    e3(h5, u(h5, h5, p8), g7), super(o7, new Rt(f7, l2(h5)), d8, E.SELF), this._referenceLines = [{ edge: i3, fadeLeft: true, fadeRight: true }];
  }
  get hints() {
    return [new n5(E2.TARGET, this.constraint.start, this.targetPoint, this.isDraped, this.domain), new r4(this.constraint.start, this.targetPoint, this.isDraped, this.domain), ...this._referenceLines.map((e5) => new n5(E2.REFERENCE, e5.edge.left, e5.edge.right, this.isDraped, this.domain, e5.fadeLeft, e5.fadeRight))];
  }
  addReferenceLine(e5) {
    const t4 = { edge: e5, fadeLeft: true, fadeRight: true };
    this._referenceLines.forEach((r9) => {
      G(e5.right, r9.edge.left) && (r9.fadeLeft = false, t4.fadeRight = false), G(e5.right, r9.edge.right) && (r9.fadeRight = false, t4.fadeRight = false), G(e5.left, r9.edge.right) && (r9.fadeRight = false, t4.fadeLeft = false), G(e5.left, r9.edge.left) && (r9.fadeLeft = false, t4.fadeLeft = false);
    }), this._referenceLines.push(t4);
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/ParallelLineSnapper.js
var g5 = class extends l3 {
  snapNewVertex(e5, t4) {
    const s5 = t4.editGeometryOperations.data.components[0], o7 = s5.edges.length, n8 = s5.vertices.length, l4 = [];
    if (o7 < 2)
      return l4;
    const { view: c5 } = this, h5 = d6(e5, t4.spatialReference, $, c5), p8 = p3(s5.vertices[n8 - 1].pos, c5, t4), g7 = p3(s5.vertices[0].pos, c5, t4), f7 = s5.edges[o7 - 1];
    let m4 = f7;
    do {
      if (this.edgeExceedsShortLineThreshold(m4, t4)) {
        const r9 = w(m4, c5, t4);
        this._checkEdgeForParallelLines(r9, p8, e5, h5, t4, l4), this._checkEdgeForParallelLines(r9, g7, e5, h5, t4, l4);
      }
      m4 = m4.leftVertex.leftEdge;
    } while (m4 && m4 !== f7);
    return l4;
  }
  snapExistingVertex(e5, t4) {
    const s5 = [], o7 = t4.vertexHandle, n8 = o7.component;
    if (n8.edges.length < 3)
      return s5;
    const { view: l4 } = this, c5 = d6(e5, t4.spatialReference, $, l4), h5 = o7.leftEdge, p8 = o7.rightEdge, g7 = n8.vertices[0], f7 = p3(g7.pos, l4, t4), m4 = n8.vertices.length, u4 = n8.vertices[m4 - 1], v3 = p3(u4.pos, l4, t4), x3 = n8.edges[0];
    let E5 = x3;
    do {
      if (E5 !== h5 && E5 !== p8 && this.edgeExceedsShortLineThreshold(E5, t4)) {
        const r9 = w(E5, l4, t4);
        h5 && this._checkEdgeForParallelLines(r9, p3(h5.leftVertex.pos, l4, t4), e5, c5, t4, s5), p8 && this._checkEdgeForParallelLines(r9, p3(p8.rightVertex.pos, l4, t4), e5, c5, t4, s5), o7 === g7 ? this._checkEdgeForParallelLines(r9, v3, e5, c5, t4, s5) : o7 === u4 && this._checkEdgeForParallelLines(r9, f7, e5, c5, t4, s5);
      }
      E5 = E5.rightVertex.rightEdge;
    } while (E5 && E5 !== x3);
    return s5;
  }
  _checkEdgeForParallelLines(t4, i3, l4, a2, g7, u4) {
    var _a;
    const v3 = t4.left, x3 = t4.right;
    if (I(m3, f2(i3), f2(v3), f2(x3)), b(m3, f2(i3)) < p4.parallelLineThreshold)
      return;
    I(m3, f2(l4), f2(v3), f2(x3), f2(i3));
    const { spatialReference: E5, pointer: L2 } = g7, P3 = s3(m3[0], m3[1], l4[2]);
    if (d5(a2, d6(P3, E5, $, this.view)) < this.squaredProximityThreshold(L2)) {
      if (this.isVertical(P3, i3, g7) || this.isVertical(v3, x3, g7))
        return;
      if (f6(t4, u4))
        return;
      u4.push(new g4({ referenceLine: t4, lineStart: i3, targetPoint: P3, isDraped: "on-the-ground" === ((_a = g7.elevationInfo) == null ? void 0 : _a.mode) }));
    }
  }
};
function f6(t4, r9) {
  const i3 = t4.left, o7 = t4.right;
  for (const l4 of r9)
    if (I(m3, f2(o7), f2(l4.constraint.start), f2(l4.constraint.end), f2(i3)), b(m3, f2(o7)) < p4.parallelLineThreshold)
      return l4.addReferenceLine(t4), true;
  return false;
}
var m3 = n4();

// node_modules/@arcgis/core/views/interactive/snapping/RightAngleSnapper.js
var F = class extends l3 {
  snapNewVertex(e5, t4) {
    const r9 = t4.editGeometryOperations.data.components[0], i3 = [];
    if (r9.vertices.length < 2)
      return i3;
    const { view: s5 } = this, n8 = d6(e5, t4.spatialReference, $, s5), o7 = r9.vertices.at(-1);
    this._checkForSnappingCandidate(p7.LastVertex, i3, o7.leftEdge, o7, o7.leftEdge.leftVertex, e5, n8, t4);
    const a2 = r9.vertices[0];
    return this._checkForSnappingCandidate(p7.FirstVertex, i3, a2.rightEdge, a2, a2.rightEdge.rightVertex, e5, n8, t4), i3;
  }
  snapExistingVertex(e5, t4) {
    const r9 = [], i3 = t4.vertexHandle;
    if (i3.component.vertices.length < 3)
      return r9;
    const { view: s5 } = this, n8 = d6(e5, t4.spatialReference, $, s5), o7 = i3.leftEdge, a2 = i3.rightEdge;
    if (o7 == null ? void 0 : o7.leftVertex.leftEdge) {
      const i4 = o7.leftVertex.leftEdge;
      this._checkForSnappingCandidate(p7.ExistingEdge, r9, i4, i4.rightVertex, i4.leftVertex, e5, n8, t4);
    }
    if (a2 == null ? void 0 : a2.rightVertex.rightEdge) {
      const i4 = a2.rightVertex.rightEdge;
      this._checkForSnappingCandidate(p7.ExistingEdge, r9, i4, i4.leftVertex, i4.rightVertex, e5, n8, t4);
    }
    return r9;
  }
  _checkForSnappingCandidate(e5, t4, r9, i3, s5, n8, o7, a2) {
    if (!this.edgeExceedsShortLineThreshold(r9, a2))
      return;
    const c5 = this.view, p8 = p3(i3.pos, c5, a2), g7 = p3(s5.pos, c5, a2);
    R(M, g7, p8, n8, a2), this._checkForSnappingCandidateAlongProjectedRay(e5, t4, g7, p8, M, n8, o7, a2);
  }
  _checkForSnappingCandidateAlongProjectedRay(e5, t4, r9, a2, p8, g7, d8, V2) {
    var _a;
    const { spatialReference: j4, pointer: C2 } = V2, w3 = e4(U, f2(g7), f2(a2)), y4 = j(p8, w3) / p2(p8), F3 = d3(U, f2(a2), p8, y4), R2 = s3(F3[0], F3[1], g7[2]);
    if (d5(d8, d6(R2, j4, $, this.view)) > this.squaredProximityThreshold(C2) || this.isVertical(R2, a2, V2) || this.isVertical(a2, r9, V2))
      return;
    const _3 = q(n3(), a2, p8, Math.sign(y4));
    t4.push(new n7({ targetPoint: R2, constraint: new Et(a2, l2(_3)), previousVertex: r9, otherVertex: a2, otherVertexType: o6.CENTER, selfSnappingType: e5, isDraped: "on-the-ground" === ((_a = V2.elevationInfo) == null ? void 0 : _a.mode) }));
  }
};
function R(e5, t4, r9, i3, s5) {
  _2(e5, t4, r9, i3, s5) || P2(e5, t4, r9);
}
function _2(i3, s5, n8, o7, { spatialReference: a2 }) {
  const c5 = y3(s5, n8, a2, a2);
  if (null == c5)
    return false;
  const g7 = y3(n8, o7, a2, a2);
  if (null == g7)
    return false;
  const l4 = Math.sign(r3.shortestSignedDiff(c5, g7)) * Math.PI * 0.5, f7 = o4(c5 + l4, "radians", "geographic"), d8 = n3(), m4 = u2(n8, o7, a2);
  return null != m4 && (A3(d8, n8, a2, f(m4, "meters"), f7, "geodesic"), e3(i3, d8, n8), true);
}
function P2(e5, t4, r9) {
  const s5 = e4(U, f2(r9), f2(t4));
  o2(e5, s5[1], -s5[0], 0);
}
var U = n4();
var M = n3();

// node_modules/@arcgis/core/views/interactive/snapping/candidates/RightAngleTriangleSnappingCandidate.js
var g6 = class extends t3 {
  constructor({ targetPoint: e5, point1: m4, point2: a2, isDraped: h5 }) {
    super(e5, new xt(l2(A2(n3(), m4, a2, 0.5)), 0.5 * m(f2(m4), f2(a2))), h5, E.SELF), this._p1 = m4, this._p2 = a2;
  }
  get hints() {
    return [new n5(E2.REFERENCE, this.targetPoint, this._p1, this.isDraped, this.domain), new n5(E2.REFERENCE, this.targetPoint, this._p2, this.isDraped, this.domain), new s4(this._p1, this.targetPoint, this._p2, this.isDraped, this.domain)];
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/RightAngleTriangleSnapper.js
var c4 = class extends l3 {
  snapNewVertex(e5, t4) {
    const i3 = t4.editGeometryOperations.data.components[0], r9 = [], s5 = i3.vertices.length;
    if ("polygon" !== t4.editGeometryOperations.data.type || s5 < 2)
      return r9;
    const { view: n8 } = this, p8 = i3.vertices[0], a2 = i3.vertices[s5 - 1], d8 = p3(p8.pos, n8, t4), l4 = p3(a2.pos, n8, t4);
    return this._processCandidateProposal(d8, l4, e5, t4, r9), r9;
  }
  snapExistingVertex(e5, t4) {
    const i3 = [], r9 = t4.vertexHandle, s5 = r9.component;
    if (s5.edges.length < 2)
      return i3;
    if ("polyline" === t4.editGeometryOperations.data.type && (0 === r9.index || r9.index === s5.vertices.length - 1))
      return i3;
    const { view: n8 } = this, p8 = p3(r9.leftEdge.leftVertex.pos, n8, t4), a2 = p3(r9.rightEdge.rightVertex.pos, n8, t4);
    return this._processCandidateProposal(p8, a2, e5, t4, i3), i3;
  }
  _processCandidateProposal(i3, o7, p8, c5, f7) {
    var _a;
    if (!this.exceedsShortLineThreshold(i3, o7, c5))
      return;
    const g7 = _(h3, f2(i3), f2(o7), 0.5), v3 = 0.5 * m(f2(i3), f2(o7)), x3 = N(h3, f2(p8), g7, v3), u4 = s3(x3[0], x3[1], p8[2]), { spatialReference: j4, pointer: y4 } = c5, w3 = d6(p8, j4, $, this.view);
    if (d5(w3, d6(u4, j4, $, this.view)) < this.squaredProximityThreshold(y4)) {
      if (this.isVertical(i3, u4, c5) || this.isVertical(u4, o7, c5))
        return;
      f7.push(new g6({ targetPoint: u4, point1: i3, point2: o7, isDraped: "on-the-ground" === ((_a = c5.elevationInfo) == null ? void 0 : _a.mode) }));
    }
  }
};
var h3 = n4();

// node_modules/@arcgis/core/views/interactive/snapping/SelfSnappingEngine.js
var h4 = class extends S {
  constructor(o7) {
    super(o7), this.updating = false, this._snappers = new V(), this._domain = E.SELF;
  }
  initialize() {
    this._snappers.push(new g5(this.view, this.options), new j3(this.view, this.options), new F(this.view, this.options), new c4(this.view, this.options));
  }
  set options(o7) {
    this._set("options", o7);
    for (const s5 of this._snappers)
      s5.options = o7;
  }
  async fetchCandidates(o7, s5, t4) {
    if (!(s5 & this._domain && this.options.effectiveSelfEnabled))
      return [];
    const i3 = [];
    for (const r9 of this._snappers.items)
      for (const s6 of r9.snap(o7, t4))
        i3.push(s6);
    return f3(o7, i3), i3;
  }
};
e([y({ readOnly: true })], h4.prototype, "updating", void 0), e([y({ constructOnly: true })], h4.prototype, "view", void 0), e([y()], h4.prototype, "options", null), h4 = e([a("esri.views.interactive.snapping.SelfSnappingEngine")], h4);

// node_modules/@arcgis/core/views/interactive/snapping/snappingFactory.js
function i2(i3, p8) {
  return [new h4({ view: i3, options: p8 }), new I2({ view: i3, options: p8, spatialReference: i3.spatialReference })];
}

// node_modules/@arcgis/core/views/interactive/snapping/candidates/IntersectionSnappingCandidate.js
var r8 = class extends t3 {
  constructor(s5, n8, r9, o7) {
    super(s5, new gt(s5), o7, E.ALL), this.first = n8, this.second = r9;
  }
  get hints() {
    return this.first.targetPoint = this.targetPoint, this.second.targetPoint = this.targetPoint, [...this.first.hints, ...this.second.hints, new o5(this.targetPoint, this.isDraped, this.domain)];
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/SnappingManager.js
var q2 = class extends o.EventedMixin(S) {
  constructor(t4) {
    super(t4), this.options = new u3(), this.snappingEnginesFactory = i2, this._engines = [], this._currentMainCandidate = null, this._currentOtherActiveCandidates = [], this._currentSnappedType = A5.MAIN;
  }
  initialize() {
    this.addHandles([d(() => {
      const { effectiveFeatureEnabled: t4, effectiveSelfEnabled: e5, touchSensitivityMultiplier: n8, distance: i3 } = this.options;
      return { effectiveFeatureEnabled: t4, effectiveSelfEnabled: e5, touchSensitivityMultiplier: n8, distance: i3 };
    }, () => {
      this.doneSnapping(), this.emit("changed");
    }, C), d(() => this.options, (t4) => {
      for (const e5 of this._engines)
        e5.options = t4;
    }, C), d(() => ({ viewReady: this.view.ready, viewSpatialReference: this.view.spatialReference, snappingEnginesFactory: this.snappingEnginesFactory }), ({ viewReady: t4, snappingEnginesFactory: e5 }) => this._recreateEngines(t4, e5), A)]);
  }
  destroy() {
    this._destroyEngines();
  }
  get updating() {
    return this._engines.some((t4) => t4.updating);
  }
  _recreateEngines(t4, e5) {
    if (this._destroyEngines(), !t4)
      return;
    const { view: n8, options: i3 } = this;
    this._engines = e5(n8, i3);
  }
  _destroyEngines() {
    for (const t4 of this._engines)
      t4.destroy();
    this._engines = [];
  }
  get _squaredMouseProximityThreshold() {
    return this.options.distance * this.options.distance;
  }
  get _squaredTouchProximityThreshold() {
    const { distance: t4, touchSensitivityMultiplier: e5 } = this.options, n8 = t4 * e5;
    return n8 * n8;
  }
  snap(t4) {
    return H3(t4) ? this._snapMultiPoint(t4) : this._snapSinglePoint(t4);
  }
  update(t4) {
    const { point: e5, context: n8 } = t4;
    this._removeVisualization();
    const i3 = this._currentMainCandidate;
    if (null == i3)
      return e5;
    const s5 = this._selectUpdateInput(t4);
    if (null == s5)
      return e5;
    const { spatialReference: r9 } = n8, a2 = B(s5, r9);
    if (null == a2)
      return e5;
    const { view: o7 } = this, { elevationInfo: p8, visualizer: d8 } = n8, h5 = [], f7 = d4(a2, o7, p8), g7 = i3.constraint.closestTo(f7);
    if (!this._arePointsWithinScreenThreshold(f7, g7, n8) || !z2(i3, n8.drawConstraints))
      return this._resetSnappingState(), e5;
    i3.targetPoint = g7, h5.push(...i3.hints);
    for (const c5 of this._currentOtherActiveCandidates)
      z2(c5, n8.drawConstraints) && (c5.targetPoint = g7, h5.push(...c5.hints));
    return null != d8 && this.addHandles(d8.draw(h5, { spatialReference: r9, elevationInfo: O(n8), view: o7, selfSnappingZ: n8.selfSnappingZ }), I3), y2(g7, o7, e5, n8);
  }
  doneSnapping() {
    this._removeVisualization(), this._resetSnappingState();
  }
  _selectUpdateInput({ point: t4, scenePoint: e5 }) {
    switch (this._currentSnappedType) {
      case A5.MAIN:
        return t4;
      case A5.SCENE:
        return e5;
    }
  }
  _resetSnappingState() {
    this._currentMainCandidate = null, this._currentOtherActiveCandidates = [], this._currentSnappedType = A5.MAIN;
  }
  _removeVisualization() {
    this.removeHandles(I3);
  }
  async _snapSinglePoint({ point: t4, context: e5, signal: n8 }) {
    const { view: i3 } = this, { elevationInfo: s5 } = e5, r9 = d4(t4, i3, s5), a2 = await this._fetchCandidates(r9, E.ALL, e5, n8);
    return this._createSnapResult(r9, A5.MAIN, a2, i3, t4, e5, n8);
  }
  async _snapMultiPoint({ point: t4, scenePoint: e5, context: n8, signal: i3 }) {
    const { view: s5 } = this, { coordinateHelper: r9, elevationInfo: a2, spatialReference: o7 } = n8;
    await H(e5.spatialReference, o7);
    const p8 = B(e5, o7), h5 = d4(p8, s5, a2), u4 = await this._fetchCandidates(h5, E.FEATURE, n8, i3);
    if (u4.length > 0) {
      const t5 = await this._fetchCandidates(h5, E.SELF, n8, i3);
      return this._createSnapResult(h5, A5.SCENE, [...u4, ...t5], s5, p8, n8, i3);
    }
    const f7 = d4(t4, s5, a2), _3 = await this._fetchCandidates(f7, E.SELF, n8, i3);
    return this._createSnapResult(f7, A5.MAIN, _3, s5, { z: r9.hasZ() && t4.hasZ ? t4.z ?? 0 : void 0, m: r9.hasM() && t4.hasM ? t4.m ?? 0 : void 0 }, n8, i3);
  }
  async _fetchCandidates(t4, e5, n8, i3) {
    return (await Promise.all(this._engines.map((s5) => s5.fetchCandidates(t4, e5, n8, i3)))).flat();
  }
  _createSnapResult(t4, e5, n8, s5, r9, a2, o7) {
    return { get valid() {
      return !c(o7);
    }, apply: () => {
      const { spatialReference: i3 } = a2, { snappedPoint: o8, hints: p8 } = this._processCandidates(t4, e5, n8, a2);
      return this._removeVisualization(), null != a2.visualizer && this.addHandles(a2.visualizer.draw(p8, { spatialReference: i3, elevationInfo: $, view: s5, selfSnappingZ: a2.selfSnappingZ }), I3), y2(o8, s5, r9, a2);
    } };
  }
  _processCandidates(t4, e5, n8, i3) {
    if (n8.length < 1)
      return this.doneSnapping(), { snappedPoint: t4, hints: [] };
    this._currentSnappedType !== e5 && this._resetSnappingState(), f3(t4, n8);
    const s5 = this._currentMainCandidate;
    if (null != s5) {
      const r9 = F2(s5, n8);
      if (r9 >= 0) {
        if (!(n8[r9] instanceof r8))
          return this._intersectWithOtherCandidates(r9, n8, t4, e5, i3);
        if (this._arePointsWithinScreenThreshold(t4, s5.targetPoint, i3))
          return this._updateSnappingCandidate(s5, e5, n8, i3);
      }
    }
    return this._intersectWithOtherCandidates(0, n8, t4, e5, i3);
  }
  _intersectWithOtherCandidates(t4, e5, n8, i3, s5) {
    const { coordinateHelper: r9 } = s5, a2 = e5[t4], o7 = [];
    for (let p8 = 0; p8 < e5.length; ++p8) {
      if (p8 === t4)
        continue;
      const i4 = e5[p8], s6 = a2.constraint.intersect(i4.constraint);
      if (s6)
        for (const t5 of s6.closestPoints(a2.targetPoint))
          o7.push([new r8(t5, a2, i4, i4.isDraped), this._squaredScreenDistance(n8, t5, r9)]);
    }
    return o7.length > 0 && (o7.sort((t5, e6) => t5[1] - e6[1]), o7[0][1] < this._squaredPointProximityThreshold(s5.pointer)) ? this._updateSnappingCandidate(o7[0][0], i3, e5, s5) : z2(a2, s5.drawConstraints) ? this._updateSnappingCandidate(a2, i3, e5, s5) : { snappedPoint: n8, hints: [] };
  }
  _updateSnappingCandidate(t4, e5, n8, i3) {
    this.doneSnapping(), this._currentMainCandidate = t4, this._currentSnappedType = e5;
    const s5 = this._currentMainCandidate.targetPoint, r9 = [];
    r9.push(...t4.hints);
    for (const a2 of n8) {
      if (t4 instanceof r8) {
        if (a2.constraint.equals(t4.first.constraint) || a2.constraint.equals(t4.second.constraint))
          continue;
      } else if (a2.constraint.equals(t4.constraint))
        continue;
      const e6 = a2.constraint.closestTo(s5);
      this._squaredScreenDistance(e6, s5, i3.coordinateHelper) < x2() && (a2.targetPoint = s5, this._currentOtherActiveCandidates.push(a2), r9.push(...a2.hints));
    }
    return { snappedPoint: s5, hints: r9 };
  }
  _squaredPointProximityThreshold(t4) {
    return "touch" === t4 ? this._squaredTouchProximityThreshold : this._squaredMouseProximityThreshold;
  }
  _arePointsWithinScreenThreshold(t4, e5, n8) {
    return this._squaredScreenDistance(t4, e5, n8.coordinateHelper) < this._squaredPointProximityThreshold(n8.pointer);
  }
  _squaredScreenDistance(t4, e5, n8) {
    return d5(this._toScreen(t4, n8), this._toScreen(e5, n8));
  }
  _toScreen(t4, e5) {
    return d6(t4, e5.spatialReference, $, this.view);
  }
  get test() {
    return { visualizationsActive: this.hasHandles(I3), engines: this._engines };
  }
};
var A5;
e([y({ constructOnly: true })], q2.prototype, "view", void 0), e([y()], q2.prototype, "options", void 0), e([y({ readOnly: true })], q2.prototype, "updating", null), e([y()], q2.prototype, "snappingEnginesFactory", void 0), e([y()], q2.prototype, "_engines", void 0), e([y()], q2.prototype, "_squaredMouseProximityThreshold", null), e([y()], q2.prototype, "_squaredTouchProximityThreshold", null), q2 = e([a("esri.views.interactive.snapping.SnappingManager")], q2), function(t4) {
  t4[t4.MAIN = 0] = "MAIN", t4[t4.SCENE = 1] = "SCENE";
}(A5 || (A5 = {}));
var I3 = "visualization-handle";
function x2() {
  return p4.satisfiesConstraintScreenThreshold * p4.satisfiesConstraintScreenThreshold;
}
function z2(t4, e5) {
  return !e5 || null == e5.direction && null == e5.distance || !(t4 instanceof r5 || t4 instanceof r6 || t4 instanceof r7 || t4 instanceof g4 || t4 instanceof g6) && (!(t4 instanceof n7) || null == e5.direction && t4.selfSnappingType === p7.LastVertex);
}
function F2(t4, e5) {
  return t4 instanceof r8 ? N2(e5, t4.first) >= 0 && N2(e5, t4.second) >= 0 ? 0 : -1 : N2(e5, t4);
}
function N2(t4, e5) {
  let n8 = -1;
  for (let i3 = 0; i3 < t4.length; ++i3)
    if (e5.constraint.equals(t4[i3].constraint)) {
      n8 = i3;
      break;
    }
  return n8;
}
function H3(t4) {
  return null != t4.scenePoint;
}
function O({ coordinateHelper: t4, elevationInfo: e5 }) {
  return t4.hasZ() ? $ : e5;
}

export {
  p5 as p,
  u3 as u,
  I2 as I,
  q2 as q
};
//# sourceMappingURL=chunk-YSRCOU2A.js.map
