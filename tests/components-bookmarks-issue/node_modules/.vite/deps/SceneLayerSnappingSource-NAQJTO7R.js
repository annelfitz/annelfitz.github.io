import {
  a as a2
} from "./chunk-RSP7TSD7.js";
import {
  r as r2
} from "./chunk-6K5SKR4X.js";
import {
  r
} from "./chunk-DNFHDQRJ.js";
import "./chunk-TO6UIATU.js";
import "./chunk-IB7OUIEK.js";
import {
  l as l3
} from "./chunk-WCBCYPOZ.js";
import "./chunk-3FTSPLRV.js";
import "./chunk-OMRW2J7M.js";
import "./chunk-UXQH3C5A.js";
import "./chunk-K3DEHPDR.js";
import "./chunk-I6RS7YIS.js";
import {
  h as h2
} from "./chunk-MUMDKJ7Y.js";
import "./chunk-LOGKJYZD.js";
import "./chunk-L7WI7KB2.js";
import "./chunk-3GY64OYE.js";
import "./chunk-QIEXJLRX.js";
import "./chunk-UNTPHF5R.js";
import "./chunk-YJFPDMSR.js";
import "./chunk-FFG7BDAP.js";
import {
  h
} from "./chunk-I4SHZ6P5.js";
import "./chunk-JBU54P54.js";
import "./chunk-H7T5AB2S.js";
import "./chunk-WKVHVZW2.js";
import "./chunk-TLU6YG3S.js";
import "./chunk-RLZYC2LS.js";
import "./chunk-WEER6QME.js";
import "./chunk-IRL6OOVK.js";
import "./chunk-3AIILHI5.js";
import "./chunk-SA77Z3WI.js";
import "./chunk-BKOYOJBG.js";
import "./chunk-YH2IYJYF.js";
import "./chunk-GGHKH3LP.js";
import "./chunk-VS6AHHIY.js";
import {
  B
} from "./chunk-XMYPMIYH.js";
import "./chunk-FQLGRQKL.js";
import "./chunk-W5ALAOW2.js";
import "./chunk-FHDHOWK5.js";
import "./chunk-B35SNV2V.js";
import "./chunk-Z2F5OKVA.js";
import "./chunk-UQA6M3KF.js";
import "./chunk-GLF3KRAL.js";
import "./chunk-ZLQTPFTL.js";
import "./chunk-KNMQQRV7.js";
import "./chunk-N5GQOIDP.js";
import "./chunk-NFB6O77E.js";
import "./chunk-AKEHDP75.js";
import "./chunk-5MMGIT64.js";
import "./chunk-ERD6I7QP.js";
import "./chunk-Z3NX5DTX.js";
import "./chunk-J4RP32NG.js";
import "./chunk-6NLHKXEW.js";
import "./chunk-S5I4QKJD.js";
import "./chunk-HWHMO3CO.js";
import "./chunk-NCRCDVOW.js";
import "./chunk-R4CJB3GP.js";
import "./chunk-VEODBKUJ.js";
import "./chunk-B647DRFJ.js";
import "./chunk-PJNK3TLV.js";
import "./chunk-J7AMTUNG.js";
import "./chunk-TGXFDJCS.js";
import "./chunk-6AQIVLDN.js";
import "./chunk-I5RCKVDX.js";
import "./chunk-6CWL7BCV.js";
import "./chunk-WNNYD62G.js";
import "./chunk-HV6S3GY2.js";
import "./chunk-IGR2BTWR.js";
import "./chunk-C7NPPGFR.js";
import "./chunk-ZPYA32PH.js";
import "./chunk-OCF7OAES.js";
import "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";
import "./chunk-4KLYOMH2.js";
import "./chunk-C62RZQQX.js";
import "./chunk-6Z6C6JVV.js";
import "./chunk-QLL2YG25.js";
import "./chunk-IZKCZQUY.js";
import "./chunk-M5ZB5S5C.js";
import "./chunk-MBGZKT2Z.js";
import "./chunk-UWQ3OYA5.js";
import "./chunk-ORO4D3FB.js";
import "./chunk-YOPMY6TS.js";
import "./chunk-VIN55KNF.js";
import "./chunk-NIDZ6R4E.js";
import "./chunk-IOB3DJMR.js";
import "./chunk-BPRXWDBO.js";
import "./chunk-7MT4ACA4.js";
import "./chunk-RUN6MNXL.js";
import "./chunk-SAYWXQVM.js";
import "./chunk-SBL4URUW.js";
import "./chunk-Z4Y53NDM.js";
import "./chunk-PVUNFEWX.js";
import "./chunk-TXBMNSNF.js";
import "./chunk-BVQWKK2V.js";
import "./chunk-D25BO7X7.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a
} from "./chunk-I2RC5KWA.js";
import "./chunk-SSFWZSUM.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import "./chunk-C26KUZ46.js";
import {
  c2 as c,
  l as l2,
  s
} from "./chunk-JGDJR5EV.js";
import {
  e as e2,
  l
} from "./chunk-QHK5ZYFW.js";
import "./chunk-L65HKN25.js";
import "./chunk-7RBRCL6S.js";
import {
  k
} from "./chunk-J2EGIWT6.js";
import "./chunk-Z4ZPL3B3.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorkerHandle.js
var p = class extends S {
  constructor(e3) {
    super(e3), this.availability = 0, this._ids = /* @__PURE__ */ new Set();
  }
  destroy() {
    this._workerHandle.destroy(), this._workerHandle = null;
  }
  initialize() {
    this._workerHandle = new l4(this.schedule, { fetchAllEdgeLocations: (e3, t) => this._fetchAllEdgeLocations(e3, t) });
  }
  async fetchCandidates(e3, t) {
    const r3 = e3.coordinateHelper, { point: o } = e3, s2 = h3;
    this.renderCoordsHelper.toRenderCoords(o, r3.spatialReference, s2);
    const n2 = e3.distance, a3 = "number" == typeof n2 ? n2 : n2.distance, d = await this._workerHandle.invoke({ bounds: B(s2[0], s2[1], s2[2], a3), returnEdge: e3.returnEdge, returnVertex: "none" !== e3.vertexMode }, t);
    return d.candidates.sort((e4, t2) => e4.distance - t2.distance), d.candidates.map((e4) => this._convertCandidate(r3, e4));
  }
  async add(e3, t) {
    this._ids.add(e3.id), await this._workerHandle.invokeMethod("add", e3, t);
  }
  async remove(e3, t) {
    this._ids.delete(e3.id), await this._workerHandle.invokeMethod("remove", e3, t);
  }
  _convertCandidate(e3, t) {
    switch (t.type) {
      case "edge":
        return new r({ objectId: t.objectId, targetPoint: this._convertRenderCoordinate(e3, t.target), edgeStart: this._convertRenderCoordinate(e3, t.start), edgeEnd: this._convertRenderCoordinate(e3, t.end), isDraped: false });
      case "vertex":
        return new r2({ objectId: t.objectId, targetPoint: this._convertRenderCoordinate(e3, t.target), isDraped: false });
    }
  }
  _convertRenderCoordinate({ spatialReference: e3 }, t) {
    const r3 = n();
    return this.renderCoordsHelper.fromRenderCoords(t, r3, e3), l3(r3);
  }
  async _fetchAllEdgeLocations(e3, t) {
    const r3 = [], o = [];
    for (const { id: s2, uid: n2 } of e3.components)
      this._ids.has(s2) && r3.push((async () => {
        const e4 = await this.fetchEdgeLocations(s2, t.signal), r4 = e4.locations.buffer;
        return o.push(r4), { id: s2, uid: n2, objectIds: e4.objectIds, locations: r4, origin: e4.origin, type: e4.type };
      })());
    return { result: { components: (await Promise.all(r3)).filter(({ id: e4 }) => this._ids.has(e4)) }, transferList: o };
  }
};
e([y({ constructOnly: true })], p.prototype, "renderCoordsHelper", void 0), e([y({ constructOnly: true })], p.prototype, "fetchEdgeLocations", void 0), e([y({ constructOnly: true })], p.prototype, "schedule", void 0), e([y({ readOnly: true })], p.prototype, "availability", void 0), p = e([a("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorkerHandle")], p);
var l4 = class extends h2 {
  constructor(e3, t) {
    super("SceneLayerSnappingSourceWorker", "fetchCandidates", {}, e3, { strategy: "dedicated", client: t });
  }
};
var h3 = n();

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/I3SSnappingSource.js
var p2 = class extends S {
  get updating() {
    return this._updatingHandles.updating;
  }
  constructor(e3) {
    super(e3), this.availability = 1, this._updatingHandles = new h(), this._abortController = new AbortController();
  }
  destroy() {
    this._tracker = l(this._tracker), this._abortController = e2(this._abortController), this._updatingHandles.destroy();
  }
  initialize() {
    const { view: e3 } = this, r3 = e3.resourceController;
    this._edgeWorker = new a2(h4(r3)), this._workerHandle = new p({ renderCoordsHelper: this.view.renderCoordsHelper, schedule: h4(r3), fetchEdgeLocations: async (e4, r4) => {
      if (null == this._tracker)
        throw new Error("tracker-not-initialized");
      return this._tracker.fetchEdgeLocations(e4, this._edgeWorker, r4);
    } }), this._updatingHandles.addPromise(this._setupLayerView()), this.addHandles([l2(this._workerHandle), l2(this._edgeWorker)]);
  }
  async fetchCandidates(e3, r3) {
    return this._workerHandle.fetchCandidates(e3, r3);
  }
  refresh() {
  }
  async _setupLayerView() {
    var _a;
    if (this.destroyed)
      return;
    const e3 = (_a = this._abortController) == null ? void 0 : _a.signal, r3 = await this.getLayerView();
    null == r3 || c(e3) || (this._tracker = r3.trackSnappingSources({ add: (r4, t) => {
      this._updatingHandles.addPromise(this._workerHandle.add({ id: r4, bounds: t }, e3));
    }, remove: (r4) => {
      this._updatingHandles.addPromise(this._workerHandle.remove({ id: r4 }, e3));
    } }));
  }
};
function h4(e3) {
  return (r3) => e3.immediate.schedule(r3);
}
e([y({ constructOnly: true })], p2.prototype, "getLayerView", void 0), e([y({ constructOnly: true })], p2.prototype, "view", void 0), e([y({ readOnly: true })], p2.prototype, "updating", null), e([y({ readOnly: true })], p2.prototype, "availability", void 0), p2 = e([a("esri.views.interactive.snapping.featureSources.I3SSnappingSource")], p2);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/SceneLayerSnappingSource.js
var c2 = class extends S {
  get updating() {
    return this._i3sSources.some((e3) => e3.updating);
  }
  constructor(e3) {
    super(e3), this.availability = 1, this._i3sSources = [];
  }
  destroy() {
    this._i3sSources.forEach((e3) => e3.destroy()), this._i3sSources.length = 0;
  }
  initialize() {
    const { view: e3 } = this, r3 = this.layerSource.layer;
    this._i3sSources = "building-scene" === r3.type ? this._getBuildingSceneI3SSources(e3, r3) : [this._getSceneLayerI3SSource(e3, r3)];
  }
  async fetchCandidates(e3, r3) {
    const t = await Promise.all(this._i3sSources.map((t2) => t2.fetchCandidates(e3, r3)));
    return s(r3), t.flat();
  }
  refresh() {
    this._i3sSources.forEach((e3) => e3.refresh());
  }
  _getBuildingSceneI3SSources(e3, r3) {
    return r3.allSublayers.toArray().map((t) => "building-component" === t.type ? new p2({ getLayerView: async () => (await e3.whenLayerView(r3)).whenSublayerView(t), view: e3 }) : null).filter(k);
  }
  _getSceneLayerI3SSource(e3, r3) {
    return new p2({ getLayerView: async () => {
      const t = await e3.whenLayerView(r3);
      return "scene-layer-graphics-3d" === t.type ? void 0 : t;
    }, view: e3 });
  }
};
e([y({ constructOnly: true })], c2.prototype, "layerSource", void 0), e([y({ constructOnly: true })], c2.prototype, "view", void 0), e([y({ readOnly: true })], c2.prototype, "updating", null), e([y({ readOnly: true })], c2.prototype, "availability", void 0), c2 = e([a("esri.views.interactive.snapping.featureSources.SceneLayerSnappingSource")], c2);
export {
  c2 as SceneLayerSnappingSource
};
//# sourceMappingURL=SceneLayerSnappingSource-NAQJTO7R.js.map
