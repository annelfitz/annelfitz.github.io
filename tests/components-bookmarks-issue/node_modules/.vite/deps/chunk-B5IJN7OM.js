import {
  f as f2,
  x
} from "./chunk-F7X3QPMY.js";
import {
  I
} from "./chunk-QYDOVVH7.js";
import {
  s as s3
} from "./chunk-RLZYC2LS.js";
import {
  l as l2
} from "./chunk-WZJNHZ6H.js";
import {
  M
} from "./chunk-HLDUDRTD.js";
import {
  b as b2,
  o,
  q,
  u as u4
} from "./chunk-C7NPPGFR.js";
import {
  A,
  j
} from "./chunk-OCF7OAES.js";
import {
  P as P2,
  e as e3,
  g,
  r,
  u as u3
} from "./chunk-JZBR4X6W.js";
import {
  n
} from "./chunk-OIJCMME5.js";
import {
  C,
  P2 as P,
  f2 as f,
  k,
  p
} from "./chunk-UWQ3OYA5.js";
import {
  U
} from "./chunk-SAYWXQVM.js";
import {
  V
} from "./chunk-PVUNFEWX.js";
import {
  S,
  y2 as y
} from "./chunk-NDIXNREV.js";
import {
  a3 as a2
} from "./chunk-I2RC5KWA.js";
import {
  e
} from "./chunk-2F6FFF5T.js";
import {
  L,
  b,
  m,
  s as s2,
  u2
} from "./chunk-JGDJR5EV.js";
import {
  e as e2,
  l,
  u
} from "./chunk-QHK5ZYFW.js";
import {
  a,
  s
} from "./chunk-7RBRCL6S.js";
import {
  z
} from "./chunk-J2EGIWT6.js";

// node_modules/@arcgis/core/views/3d/support/AsyncWorkerQueue.js
var s4 = class {
  constructor(t) {
    this.client = t, this._cancelled = false, this.size = 0, this.duration = 0;
  }
};
var e4 = class {
  constructor(t) {
    this.typeWorkerQuota = t, this.tasks = new Array(), this.numWorkers = 0, this.statistics = new r2();
  }
};
var r2 = class {
  constructor() {
    this.requests = 0, this.size = 0, this.duration = 0, this.speed = 0;
  }
};
var i = class {
  constructor(t, s8, r4, i4) {
    this._workerFunc = t, this._callbackFunc = s8, this._maxTotalNumWorkers = r4, this._totalNumWorkers = 0, this._clients = i4.map((t2) => new e4(t2));
  }
  destroy() {
    this._clients.length = 0;
  }
  hasQuota(t) {
    const s8 = this._clients[t];
    return !!s8 && (this._totalNumWorkers < this._maxTotalNumWorkers || s8.numWorkers + s8.tasks.length < s8.typeWorkerQuota);
  }
  push(t) {
    const s8 = this._clients[t.client];
    s8 && (this._totalNumWorkers < this._maxTotalNumWorkers ? (s8.numWorkers++, this._totalNumWorkers++, this._workerFunc(t, (t2, s9) => this._taskCallback(t2, s9))) : s8.tasks.push(t));
  }
  cancel(t) {
    this._taskFinished(t), t._cancelled = true;
  }
  _taskFinished(s8) {
    const e5 = this._clients[s8.client];
    this._totalNumWorkers--, e5 && (e5.numWorkers--, e5.statistics.requests++, e5.statistics.size += s8.size || 0, e5.statistics.duration += s8.duration || 0, e5.statistics.speed = e5.statistics.duration > 0 ? e5.statistics.size / e5.statistics.duration : 0, s3(e5.numWorkers >= 0)), this._next();
  }
  _next() {
    for (const t of this._clients)
      if (t && t.numWorkers < t.typeWorkerQuota && this._processQueue(t))
        return;
    for (const t of this._clients)
      if (t && this._processQueue(t))
        return;
  }
  _processQueue(t) {
    for (; t.tasks.length > 0; )
      if (this._workerFunc(t.tasks.shift(), (t2, s8) => this._taskCallback(t2, s8)))
        return t.numWorkers++, this._totalNumWorkers++, true;
    return false;
  }
  _taskCallback(t, s8) {
    t._cancelled || (this._callbackFunc(t, s8), this._taskFinished(t));
  }
  getStatsForType(t) {
    const s8 = this._clients[t];
    return s8 ? { quota: s8.typeWorkerQuota, workers: s8.numWorkers, queueSize: s8.tasks.length, requestStats: s8.statistics } : null;
  }
  get test() {
    const t = this;
    return { set workerFunc(s8) {
      t._workerFunc = s8;
    } };
  }
};

// node_modules/@arcgis/core/views/3d/support/StreamDataLoader.js
var D = class extends S {
  constructor() {
    super(...arguments), this._tasks = /* @__PURE__ */ new Map(), this._onLoadQueue = new Array(), this._doneQueue = new Array(), this.updating = false;
  }
  setup(e5, t, s8) {
    this._loadQueue = new i((e6, t2) => this._startLoading(e6, t2), (e6, t2) => this._doneLoadingCB(e6, t2), e5, t), s8 && (this._frameTask = s8.registerTask(I.STREAM_DATA_LOADER, this));
  }
  destroy() {
    this._frameTask = l(this._frameTask), this._tasks.forEach((e5) => e2(e5.abortController)), this._loadQueue = u(this._loadQueue), this._onLoadQueue = null, this._doneQueue = null, this._tasks = null;
  }
  hasDownloadSlots(e5) {
    return this._loadQueue.hasQuota(e5);
  }
  request(e5, t, s8, r4 = {}) {
    const o4 = L();
    o4.__signal = null != r4 ? r4.signal : null;
    const a5 = this._createOrUpdateTask(e5, t, s8, r4, o4);
    return m(r4, () => this._cancelRequest(a5, o4)), o4.promise;
  }
  _createTask(e5, t, s8, r4, o4, a5) {
    const n3 = new Q(e5, t, s8, r4, o4);
    return this._updateTask(n3, a5), this._tasks.set(o4, n3), 1 === this._tasks.size && this._set("updating", true), this._loadQueue.push(n3), n3;
  }
  _cancelRequest(e5, t) {
    var _a;
    z(e5.resolvers, t), t.reject(u2()), 0 === e5.resolvers.length && (e5.status === E.DOWNLOADING && (e5.status = E.CANCELLED, this._loadQueue.cancel(e5), (_a = e5.abortController) == null ? void 0 : _a.abort(), e5.request = null, e5.abortController = null), e5.status = E.CANCELLED, this._tasks.delete(e5.key), 0 === this._tasks.size && this._set("updating", false));
  }
  _updateTask(e5, t) {
    e5.resolvers.push(t);
  }
  _createOrUpdateTask(e5, t, s8, r4, o4) {
    const a5 = T((r4 == null ? void 0 : r4.uid) || e5, t, s8), n3 = this._tasks.get(a5);
    return n3 ? (this._updateTask(n3, o4), n3) : this._createTask(e5, r4, t, s8, a5, o4);
  }
  _doneLoadingCB(e5, t) {
    this._loadQueue && (s3(e5.status === E.DOWNLOADING), e5.status = E.DOWNLOADED, this._frameTask ? this._doneQueue.push({ task: e5, err: t }) : this._doneLoading(e5, t));
  }
  get running() {
    return this._doneQueue.length > 0 || this._onLoadQueue.length > 0;
  }
  runTask(e5) {
    for (; !e5.done && this._onLoadQueue.length > 0; ) {
      const t = this._onLoadQueue.shift();
      s2(t.task.abortController), t.task.abortController = null, t.callback(t.task), e5.madeProgress();
    }
    for (; !e5.done && this._doneQueue.length > 0; ) {
      const t = this._doneQueue.shift();
      t.task.status !== E.DOWNLOADED && (t.err = t.err || u2()), this._doneLoading(t.task, t.err), e5.madeProgress();
    }
  }
  _doneLoading(e5, t) {
    if (t && !b(t) && e5.numRetries > 0)
      return --e5.numRetries, void this._loadQueue.push(e5);
    let s8 = e5.result instanceof HTMLImageElement ? 0 : e5.resolvers.length;
    for (const r4 of e5.resolvers)
      if (t)
        b(t) ? r4.reject(t) : r4.reject(new s("stream-data-loader:request-error", `Failed to request resource at '${e5.url}'. ${t}`, { url: e5.url, error: t }));
      else {
        --s8;
        const t2 = s8 > 0 ? a(e5.result) : e5.result;
        r4.resolve(t2);
      }
    this._tasks.delete(e5.key), 0 === this._tasks.size && this._set("updating", false);
  }
  _startLoading(e5, s8) {
    if (e5.status === E.CANCELLED)
      return false;
    let r4, o4;
    switch (e5.startTime = performance.now(), e5.status = E.DOWNLOADING, e5.docType) {
      case "binary":
        o4 = "array-buffer", r4 = 0;
        break;
      case "image":
        o4 = "image";
        break;
      case "image+type":
        o4 = "array-buffer";
        break;
      default:
        o4 = "json";
    }
    e5.abortController = new AbortController();
    const a5 = e5.abortController.signal;
    e5.request = U(e5.url, { ...e5.options, responseType: o4, timeout: r4, signal: a5 });
    let n3 = () => {
    };
    const i4 = (t) => {
      e5.duration = performance.now() - e5.startTime, e5.size = t instanceof ArrayBuffer ? t.byteLength : e5.size || 0, e5.result = t, this._frameTask ? this._onLoadQueue.push({ callback: s8, task: e5 }) : (e5.abortController = null, s8(e5));
    }, u6 = (t) => {
      e5.status === E.DOWNLOADING && s8(e5, t), n3();
    };
    return "image+type" !== e5.docType ? (e5.request.then((e6) => i4(e6.data), u6), true) : (e5.request.then((s9) => {
      const l5 = s9.data, h2 = b3(l5);
      if (o4 = "image", e5.size = l5.byteLength, "unknown" === h2)
        return e5.request = U(e5.url, { responseType: o4, timeout: r4, signal: a5 }), void e5.request.then((e6) => i4(e6.data), u6);
      const c3 = new Blob([l5], { type: h2 }), d3 = window.URL.createObjectURL(c3);
      n3 = () => window.URL.revokeObjectURL(d3), e5.request = U(d3, { responseType: o4, timeout: r4, signal: a5 }), e5.request.then((e6) => i4(new A2(e6.data, h2, n3)), u6);
    }, u6), true);
  }
  get test() {
    return { loadQueue: this._loadQueue };
  }
};
e([y({ readOnly: true })], D.prototype, "updating", void 0), D = e([a2("esri.views.3d.support.StreamDataLoader")], D);
var y2 = { numRetries: 0 };
function b3(e5) {
  if (e5.byteLength < 2)
    return "unknown";
  const t = new Uint8Array(e5, 0, e5.byteLength);
  return 137 === t[0] && 80 === t[1] ? "image/png" : 71 === t[0] && 73 === t[1] ? "image/gif" : 66 === t[0] && 77 === t[1] ? "image/bmp" : 255 === t[0] && 216 === t[1] ? "image/jpeg" : "unknown";
}
var A2 = class {
  constructor(e5, t, s8) {
    this.image = e5, this.type = t, this.release = s8;
  }
  get isOpaque() {
    return "image/jpeg" === this.type;
  }
};
function O(e5) {
  return "image" in e5 && "type" in e5;
}
var Q = class extends s4 {
  constructor(e5, t, s8, r4, o4) {
    super(r4), this.url = e5, this.options = t, this.docType = s8, this.key = o4, this.result = null, this.status = E.QUEUED, this.request = null, this.abortController = null, this.resolvers = new Array(), this.startTime = 0, this.numRetries = y2.numRetries;
  }
};
function T(e5, t, s8) {
  return `${e5}:${t}:${s8}`;
}
var E;
!function(e5) {
  e5[e5.QUEUED = 1] = "QUEUED", e5[e5.DOWNLOADING = 2] = "DOWNLOADING", e5[e5.DOWNLOADED = 3] = "DOWNLOADED", e5[e5.CANCELLED = 4] = "CANCELLED";
}(E || (E = {}));

// node_modules/@arcgis/core/views/3d/terrain/ITile.js
var T2;
var S2;
!function(T5) {
  T5[T5.INSIDE = 0] = "INSIDE", T5[T5.INTERSECTS = 1] = "INTERSECTS", T5[T5.OUTSIDE = 2] = "OUTSIDE";
}(T2 || (T2 = {})), function(T5) {
  T5[T5.NORTH = 0] = "NORTH", T5[T5.NORTH_EAST = 1] = "NORTH_EAST", T5[T5.EAST = 2] = "EAST", T5[T5.SOUTH_EAST = 3] = "SOUTH_EAST", T5[T5.SOUTH = 4] = "SOUTH", T5[T5.SOUTH_WEST = 5] = "SOUTH_WEST", T5[T5.WEST = 6] = "WEST", T5[T5.NORTH_WEST = 7] = "NORTH_WEST";
}(S2 || (S2 = {}));

// node_modules/@arcgis/core/views/3d/support/supportedSpatialReference.js
function o2(e5) {
  return i2(e5) || f(e5) || p(e5);
}
function i2(r4) {
  return C(r4) || k(r4);
}

// node_modules/@arcgis/core/views/3d/terrain/TerrainConst.js
var n2 = 64;
var s5 = 512;
var i3 = 2.5;
var a3 = A(j / 10);
var l3 = 2;
var c = u4();
f2.WebMercatorAuxiliarySphere.getExtent(0, 0, 0, c);
var m2 = u4([-180, -90, 180, 90]);
var u5 = "Cannot extend surface to encompass all layers because it would result in too many root tiles.";
var p2 = "Surface extent is too large for tile resolution at level 0.";
var f3 = 3;
var g2 = f3;
function x2(e5) {
  return e5 < 4 ? 3 : g2;
}
var y3 = 4;

// node_modules/@arcgis/core/chunks/terrainUtilsPlanar.js
var g3 = n();
var d = n();
var x3 = n();
var M2 = n();
function S3(e5, t, o4 = 0) {
  const n3 = e5.extent;
  if (null == n3)
    return false;
  if (0 === o4)
    return b2(n3, t);
  const r4 = Math.min(n3[2] - n3[0], n3[3] - n3[1]);
  return q(n3, t, o4 * r4);
}
function v(e5, s8, l5, a5) {
  r(g3, l5), g3[a5] = s8[a5];
  const c3 = e3(g3, g3, s8), u6 = e3(d, e5, s8), f4 = P2(u6, c3), m4 = P2(c3, c3);
  let p4;
  p4 = f4 <= 0 ? s8 : m4 <= f4 ? l5 : u3(g3, s8, g(c3, c3, f4 / m4));
  const h2 = e3(g3, e5, p4);
  return Math.PI / 2 - Math.atan(h2[2] / Math.sqrt(h2[0] * h2[0] + h2[1] * h2[1]));
}
function w(e5, t, o4) {
  const n3 = e5.extent;
  if (null == n3)
    return 0;
  x3[0] = n3[0], x3[1] = n3[1], x3[2] = o4, M2[0] = n3[2], M2[1] = n3[3], M2[2] = o4;
  let r4 = 1 / 0, i4 = 1 / 0;
  return t[0] < x3[0] ? r4 = v(t, x3, M2, 0) : t[0] > M2[0] && (r4 = v(t, M2, x3, 0)), t[1] < x3[1] ? i4 = v(t, x3, M2, 1) : t[1] > M2[1] && (i4 = v(t, M2, x3, 1)), Math.min(r4, i4);
}
function T3(t, o4, n3, r4) {
  if (null == t)
    return x();
  const i4 = t.spatialReference;
  if (i4.isGeographic && !i2(i4))
    return new s("tilingscheme:local-unsupported-spatial-reference", "The tiling scheme spatial reference is not supported in local scenes");
  const s8 = f2.checkUnsupported(t);
  if (null != s8)
    return s8;
  if (null == n3)
    return new s("tilingscheme:extent-not-exist", "The layer does not provide a layer extent.");
  const l5 = j2(t, n3);
  return l5 || (null == o4 || i4.equals(o4) || o4.isWGS84 && i4.isWebMercator ? null : new s("tilingscheme:spatial-reference-mismatch", "The tiling scheme does not match the spatial reference of the local scene"));
}
function j2(t, o4) {
  const n3 = t.lods, r4 = n3[0].resolution * 2 ** n3[0].level, i4 = [r4 * t.size[0], r4 * t.size[1]], s8 = [t.origin.x, t.origin.y], l5 = o(o4), a5 = u4();
  f2.computeRowColExtent(l5, i4, s8, a5);
  const f4 = (a5[2] - a5[0]) * (a5[3] - a5[1]);
  if (f4 > n2) {
    const o5 = n3[0].scale * 2 ** n3[0].level;
    let i5 = Math.max((l5[3] - l5[1]) / t.size[1], (l5[2] - l5[0]) / t.size[0]) * o5 / r4;
    const s9 = Math.floor(Math.log(i5) / Math.log(10));
    return i5 = Math.ceil(i5 / 10 ** s9) * 10 ** s9, new s("tilingscheme:too-many-root-tiles", "Scale of level 0 of the tiling scheme (1:" + Math.floor(o5).toLocaleString() + ") is too large for the layer's extent. Suggested scale: 1:" + i5.toLocaleString() + ".", { level0Scale: o5, suggestedLevel0Scale: i5, requiredNumRootTiles: f4, allowedNumRootTiles: n2 });
  }
  return null;
}
var y4 = Object.freeze(Object.defineProperty({ __proto__: null, checkIfTileInfoSupportedForViewSR: T3, isInsideExtent: S3, tiltToExtentEdge: w }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/terrainUtilsSpherical.js
function r3() {
  return true;
}
function l4() {
  return 0;
}
function o3(r4, l5, o4, s8) {
  if (null == r4)
    return x();
  const c3 = (r4 == null ? void 0 : r4.lods.length) - 1, a5 = r4.spatialReference;
  if (a5.isWebMercator) {
    if (!f2.makeWebMercatorAuxiliarySphere(c3).compatibleWith(r4, s8))
      return new s("tilingscheme:incompatible-global-web-mercator", "The tiling scheme is not compatible with the ArcGIS Online Web Mercator tiling scheme");
  } else {
    if (!o2(a5))
      return new s("tilingscheme:global-unsupported-spatial-reference", "The tiling scheme spatial reference is not supported in global scenes");
    if (!f2.makeGCSWithTileSize(r4.spatialReference, r4.size[0], c3).compatibleWith(r4, s8))
      return r4.spatialReference.isWGS84 ? new s("tilingscheme:incompatible-global-wgs84", "The tiling scheme is not compatible with the ArcGIS Online WGS84 tiling scheme") : new s("tilingscheme:incompatible-global", "The tiling scheme is not compatible with the ArcGIS Online tiling scheme");
  }
  return null == l5 || r4.spatialReference.equals(l5) ? void 0 : new s("tilingscheme:spatial-reference-mismatch", "The tiling scheme does not match the spatial reference of the global scene");
}
var s6 = Object.freeze(Object.defineProperty({ __proto__: null, checkIfTileInfoSupportedForViewSR: o3, isInsideExtent: r3, tiltToExtentEdge: l4 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/terrain/terrainUtils.js
var c2 = { [l2.Global]: s6, [l2.Local]: y4 };
function a4(t, n3) {
  t || console.warn("Terrain: " + n3);
}
var T4 = false;
var s7 = false;
function S4(t) {
  s7 = t, T4 = T4 || t;
}
function E2(t) {
  T4 = t;
}
function p3(t, n3) {
  var _a;
  if (T4 && !t) {
    const t2 = (_a = new Error().stack) == null ? void 0 : _a.slice(5);
    throw console.warn("Terrain internal: " + (n3 ?? "") + " at " + t2), new Error("Assertion failed" + (n3 ? ": " + n3 : ""));
  }
}
function m3(t) {
  return O2(t) ? { fullExtent: t.fullExtent, minScale: t.layer.minScale, maxScale: t.layer.maxScale, tilemapCache: null } : t.layer;
}
function H(t) {
  return "imagery-tile" === (t == null ? void 0 : t.type) || "wcs" === (t == null ? void 0 : t.type);
}
function O2(t) {
  return "imagery-tile-3d" === (t == null ? void 0 : t.type);
}
function y5(t) {
  return "tile-3d" === (t == null ? void 0 : t.type);
}
function _(t) {
  return "vector-tile-3d" === (t == null ? void 0 : t.type);
}
function I2(t) {
  return "wmts-3d" === (t == null ? void 0 : t.type);
}
function d2(t) {
  return "elevation-3d" === (t == null ? void 0 : t.type);
}
function R(t) {
  return "group" === (t == null ? void 0 : t.type);
}
function U2(t) {
  return t && (y5(t) || I2(t) || O2(t) || _(t));
}
function W(t) {
  return t && (y5(t) || O2(t) || _(t) || I2(t));
}
function x4(t) {
  return W(t) || d2(t);
}
function N(t) {
  var _a;
  const n3 = (_a = t == null ? void 0 : t.sourceLayerInfo) == null ? void 0 : _a.data;
  return null != n3 && "type" in n3 && "raster-tile" === n3.type;
}
function A3(t) {
  return g4(t == null ? void 0 : t.sourceLayerInfo) || !!(t == null ? void 0 : t.isVTLBackground);
}
function L2(t) {
  var _a;
  const n3 = (_a = t == null ? void 0 : t.sourceLayerInfo) == null ? void 0 : _a.data;
  return null != n3 && "type" in n3 && "tile-texture" === n3.type;
}
function h(t) {
  var _a;
  const n3 = (_a = t == null ? void 0 : t.sourceLayerInfo) == null ? void 0 : _a.data;
  return n3 instanceof HTMLImageElement || n3 instanceof A2 || n3 instanceof HTMLCanvasElement || n3 instanceof ImageData;
}
function g4(t) {
  return null != (t == null ? void 0 : t.data) && "type" in t.data && "vector-tile" === t.data.type;
}
function w2(t) {
  return null != t && "release" in t && t.release(), null;
}
function C2(t) {
  return t.fetchTile && false !== t.hasOverriddenFetchTile;
}
function j3(t, n3, e5, r4, o4) {
  return c2[r4].checkIfTileInfoSupportedForViewSR(t, e5, n3, o4);
}
function v2(t, n3, e5) {
  var _a;
  let r4 = null, l5 = null;
  if ("wmts" === (t == null ? void 0 : t.type)) {
    const o4 = b4(t, n3, e5);
    r4 = o4.tileInfo, l5 = o4.fullExtent;
  } else {
    l5 = H(t) ? t.getCompatibleFullExtent(n3) : t.fullExtent;
    const i5 = e5 === l2.Local;
    if (H(t))
      r4 = t.getCompatibleTileInfo(n3, l5, i5);
    else if ("vector-tile" === (t == null ? void 0 : t.type)) {
      r4 = i5 && !M3(n3) || V2.force512VTL ? t.tileInfo : t.tileInfo.getCompatibleForVTL(256);
    } else
      r4 = t.tileInfo;
  }
  const i4 = "tilemapCache" in t ? (_a = t.tilemapCache) == null ? void 0 : _a.effectiveMaxLOD : void 0;
  return null != r4 && null != l5 && null == j3(r4, l5, n3, e5, i4) ? { tileInfo: r4, fullExtent: l5 } : null;
}
function b4(n3, e5, o4) {
  const l5 = M(n3);
  if (null != l5) {
    if (!V.isCollection(l5))
      return { tileInfo: l5.tileInfo, fullExtent: l5.fullExtent };
    {
      const t = l5.find((t2) => null == j3(t2.tileInfo, t2.fullExtent, e5, o4));
      if (t)
        return { tileInfo: t.tileInfo, fullExtent: t.fullExtent };
    }
  }
  return { tileInfo: null, fullExtent: null };
}
function M3(t) {
  return t.isWGS84 || t.isWebMercator || k(t) || !P(t);
}
var V2 = { force512VTL: false };
function k2(t) {
  return "[" + t[0] + "," + t[1] + "," + t[2] + "]";
}
function F(t) {
  return "(" + t[0] + "," + t[1] + "," + t[2] + ")";
}
function D2(t, n3, e5 = Z) {
  return Math.abs(t - n3) < e5;
}
function G(t) {
  return t === S2.NORTH_EAST ? S2.SOUTH_WEST : t === S2.NORTH_WEST ? S2.SOUTH_EAST : t === S2.SOUTH_WEST ? S2.NORTH_EAST : S2.NORTH_WEST;
}
function B(t) {
  return t === S2.NORTH ? S2.SOUTH : t === S2.EAST ? S2.WEST : t === S2.SOUTH ? S2.NORTH : S2.EAST;
}
function P3(t) {
  return t === S2.NORTH_WEST || t === S2.SOUTH_WEST;
}
function q2(t) {
  return t === S2.NORTH_WEST || t === S2.NORTH_EAST;
}
function z2(t) {
  return t === S2.NORTH_WEST || t === S2.WEST || t === S2.SOUTH_WEST;
}
function J(t) {
  return t === S2.NORTH_EAST || t === S2.EAST || t === S2.SOUTH_EAST;
}
function K(t) {
  return t === S2.SOUTH_EAST || t === S2.SOUTH || t === S2.SOUTH_WEST;
}
function Q2(t) {
  return t === S2.NORTH_EAST || t === S2.NORTH || t === S2.NORTH_WEST;
}
var X = [S2.NORTH, S2.EAST, S2.SOUTH, S2.WEST];
var Y = [S2.NORTH_EAST, S2.SOUTH_EAST, S2.SOUTH_WEST, S2.NORTH_WEST];
var Z = 1e-5;

export {
  n2 as n,
  s5 as s,
  i3 as i,
  a3 as a,
  l3 as l,
  c,
  m2 as m,
  u5 as u,
  p2 as p,
  x2 as x,
  y3 as y,
  D,
  A2 as A,
  O,
  T2 as T,
  S2 as S,
  o2 as o,
  i2,
  a4 as a2,
  T4 as T2,
  s7 as s2,
  S4 as S2,
  E2 as E,
  p3 as p2,
  m3 as m2,
  H,
  O2,
  y5 as y2,
  _,
  d2 as d,
  R,
  U2 as U,
  W,
  x4 as x2,
  N,
  A3 as A2,
  L2 as L,
  h,
  g4 as g,
  w2 as w,
  C2 as C,
  j3 as j,
  v2 as v,
  b4 as b,
  M3 as M,
  V2 as V,
  k2 as k,
  F,
  D2,
  G,
  B,
  P3 as P,
  q2 as q,
  z2 as z,
  J,
  K,
  Q2 as Q,
  X,
  Y
};
//# sourceMappingURL=chunk-B5IJN7OM.js.map
