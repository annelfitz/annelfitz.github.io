/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../request.js";import r from"../core/Error.js";import t from"../core/Logger.js";import{getDeepValue as o}from"../core/object.js";import{removeTrailingSlash as s}from"../core/urlUtils.js";import{asValidOptions as a,parseUrl as n}from"./utils.js";import i from"./support/NetworkServiceDescription.js";const l=()=>t.getLogger("esri.rest.networkService");function u(e,r,t,o){o[t]=[r.length,r.length+e.length],e.forEach((e=>{r.push(e.geometry)}))}function f(e,r){for(let t=0;t<r.length;t++){const o=e[r[t]];if(o&&o.length)for(const e of o)e.z=void 0}l().warnOnce("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.")}function c(e,r){for(let t=0;t<r.length;t++){const o=e[r[t]];if(o&&o.length)for(const e of o)if(null!=e&&e.hasZ)return!0}return!1}async function d(t,o,s){if(!t)throw new r("network-service:missing-url","Url to Network service is missing");const n=a({f:"json",token:o},s),{data:l}=await e(t,n),u=l.currentVersion>=10.4?p(t,o,s):v(t,s),{defaultTravelMode:f,supportedTravelModes:c}=await u;return l.defaultTravelMode=f,l.supportedTravelModes=c,i.fromJSON(l)}async function v(r,t){const i=a({f:"json"},t),{data:l}=await e(r.replace(/\/rest\/.*$/i,"/info"),i);if(!l?.owningSystemUrl)return{supportedTravelModes:[],defaultTravelMode:null};const{owningSystemUrl:u}=l,f=s(u)+"/sharing/rest/portals/self",{data:c}=await e(f,i),d=o("helperServices.routingUtilities.url",c);if(!d)return{supportedTravelModes:[],defaultTravelMode:null};const v=n(u),p=/\/solve$/i.test(v.path)?"Route":/\/solveclosestfacility$/i.test(v.path)?"ClosestFacility":"ServiceAreas",m=a({f:"json",serviceName:p},t),h=s(d)+"/GetTravelModes/execute",g=await e(h,m),w=[];let T=null;if(g?.data?.results?.length){const e=g.data.results;for(const r of e)if("supportedTravelModes"===r.paramName){if(r.value?.features)for(const{attributes:e}of r.value.features)if(e){const r=JSON.parse(e.TravelMode);w.push(r)}}else"defaultTravelMode"===r.paramName&&(T=r.value)}return{supportedTravelModes:w,defaultTravelMode:T}}async function p(t,o,n){try{const r=a({f:"json",token:o},n),i=s(t)+"/retrieveTravelModes",{data:{supportedTravelModes:l,defaultTravelMode:u}}=await e(i,r);return{supportedTravelModes:l,defaultTravelMode:u}}catch(i){throw new r("network-service:retrieveTravelModes","Could not get to the NAServer's retrieveTravelModes.",{error:i})}}export{u as collectGeometries,f as dropZValuesOffInputGeometry,d as fetchServiceDescription,c as isInputGeometryZAware};
