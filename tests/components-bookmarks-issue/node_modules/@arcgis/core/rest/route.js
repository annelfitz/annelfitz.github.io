/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../request.js";import{get as r}from"../core/accessorSupport/get.js";import{normalizeCentralMeridian as t}from"../geometry/support/normalizeUtils.js";import{collectGeometries as s,isInputGeometryZAware as o,fetchServiceDescription as a,dropZValuesOffInputGeometry as i}from"./networkService.js";import{parseUrl as n}from"./utils.js";import{routeParametersToQueryParameters as u}from"./route/utils.js";import f from"./support/FeatureSet.js";import p from"./support/RouteSolveResult.js";function c(e){return e instanceof f}async function l(f,p,l){const y=[],d=[],g={},h={},R=n(f),{path:v}=R;c(p.stops)&&s(p.stops.features,d,"stops.features",g),c(p.pointBarriers)&&s(p.pointBarriers.features,d,"pointBarriers.features",g),c(p.polylineBarriers)&&s(p.polylineBarriers.features,d,"polylineBarriers.features",g),c(p.polygonBarriers)&&s(p.polygonBarriers.features,d,"polygonBarriers.features",g);const B=await t(d);for(const e in g){const r=g[e];y.push(e),h[e]=B.slice(r[0],r[1])}if(o(h,y)){let e=null;try{e=await a(v,p.apiKey,l)}catch{}e&&!e.hasZ&&i(h,y)}for(const e in h)h[e].forEach(((t,s)=>{r(p,e)[s].geometry=t}));const E={...l,query:{...R.query,...u(p),f:"json"}},T=v.endsWith("/solve")?v:`${v}/solve`,{data:b}=await e(T,E);return m(b)}function m(e){const{barriers:r,directionLines:t,directionPoints:s,directions:o,messages:a,polygonBarriers:i,polylineBarriers:n,routes:u,stops:f,traversedEdges:c,traversedJunctions:l,traversedTurns:m}=e,y=e=>{const r=g.find((r=>r.routeName===e));if(null!=r)return r;const t={routeId:g.length+1,routeName:e};return g.push(t),t},d=e=>{const r=g.find((r=>r.routeId===e));if(null!=r)return r;const t={routeId:e,routeName:null};return g.push(t),t},g=[];u?.features.forEach(((e,r)=>{e.geometry.spatialReference=u.spatialReference??void 0;const t=e.attributes.Name,s=r+1;g.push({routeId:s,routeName:t,route:e})})),o?.forEach((e=>{const{routeName:r}=e;y(r).directions=e}));const h=(f?.features.every((e=>null==e.attributes.RouteName))??!1)&&g.length>0?g[0].routeName:null;return f?.features.forEach((e=>{e.geometry&&(e.geometry.spatialReference??=f.spatialReference??void 0);const r=h??e.attributes.RouteName,t=y(r);t.stops??=[],t.stops.push(e)})),t?.features.forEach((e=>{const r=e.attributes.RouteID,s=d(r),{geometryType:o,spatialReference:a}=t;s.directionLines??={features:[],geometryType:o,spatialReference:a},s.directionLines.features.push(e)})),s?.features.forEach((e=>{const r=e.attributes.RouteID,t=d(r),{geometryType:o,spatialReference:a}=s;t.directionPoints??={features:[],geometryType:o,spatialReference:a},t.directionPoints.features.push(e)})),c?.features.forEach((e=>{const r=e.attributes.RouteID,t=d(r),{geometryType:s,spatialReference:o}=c;t.traversedEdges??={features:[],geometryType:s,spatialReference:o},t.traversedEdges.features.push(e)})),l?.features.forEach((e=>{const r=e.attributes.RouteID,t=d(r),{geometryType:s,spatialReference:o}=l;t.traversedJunctions??={features:[],geometryType:s,spatialReference:o},t.traversedJunctions.features.push(e)})),m?.features.forEach((e=>{const r=e.attributes.RouteID,t=d(r);t.traversedTurns??={features:[]},t.traversedTurns.features.push(e)})),p.fromJSON({routeResults:g,barriers:r,polygonBarriers:i,polylineBarriers:n,messages:a})}export{l as solve};
