/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../geometry.js";import t from"../request.js";import{normalizeCentralMeridian as e}from"../geometry/support/normalizeUtils.js";import{srToRESTValue as o}from"../geometry/support/spatialReferenceUtils.js";import{parseUrl as n,encode as a,asValidOptions as r}from"./utils.js";import s from"./support/FindImagesResult.js";import i from"./support/ImageAngleResult.js";import m from"./support/ImageAreaResult.js";import u from"./support/ImageBoundaryResult.js";import c from"./support/ImageDistanceResult.js";import l from"./support/ImageGPSInfoResult.js";import f from"./support/ImageHeightResult.js";import p from"./support/ImageIdentifyResult.js";import y from"./support/ImagePixelLocationResult.js";import g from"./support/ImagePointResult.js";import d from"./support/ImageSampleResult.js";import S from"./support/ImageUrlResult.js";import j from"./support/MeasureAreaFromImageResult.js";import R from"./support/MeasureLengthFromImageResult.js";import N from"../geometry/SpatialReference.js";import{fromJSON as h}from"../geometry/support/jsonUtils.js";function O(t){const e=t?.time;if(e&&(null!=e.start||null!=e.end)){const o=[];null!=e.start&&o.push(e.start),null==e.end||o.includes(e.end)||o.push(e.end),t.time=o.join(",")}}async function w(t,o,s){const i=n(t),m=o.geometry?[o.geometry]:[],u=await e(m),c=o.toJSON();O(c);const l=u?.[0];null!=l&&(c.geometry=A(l));const f=a({...i.query,f:"json",...c});return r(f,s)}async function J(e,o,s){const m=o.toJSON();null!=m.angleName&&(m.angleName=m.angleName.join(",")),o?.point?.spatialReference?.imageCoordinateSystem&&(m.point.spatialReference=H(o.point.spatialReference)),o?.spatialReference?.imageCoordinateSystem&&(m.spatialReference=T(o.spatialReference));const u=n(e),c=a({...u.query,f:"json",...m}),l=r(c,s),{data:f}=await t(`${u.path}/computeAngles`,l);return f.spatialReference=f.spatialReference?null!=f.spatialReference.geodataXform?new N({wkid:0,imageCoordinateSystem:f.spatialReference}):N.fromJSON(f.spatialReference):null,"NaN"===f.north&&(f.north=null),"NaN"===f.up&&(f.up=null),new i(f)}async function I(e,o,s){const i=o.toJSON(),{geometries:m}=o;if(m)for(let t=0;t<m.length;t++)m[t].spatialReference?.imageCoordinateSystem&&(i.geometries.geometries[t].spatialReference=H(m[t].spatialReference));const u=n(e),c=a({...u.query,f:"json",...i}),l=r(c,s),{data:f}=await t(`${u.path}/computePixelLocation`,l);return y.fromJSON(f)}async function q(e,o,a){const r=await w(e,o,a),s=n(e),{data:i}=await t(`${s.path}/computeStatisticsHistograms`,r),{statistics:m}=i;return m?.length&&m.forEach((t=>{t.avg=t.mean,t.stddev=t.standardDeviation})),{statistics:m,histograms:i.histograms}}async function G(e,o,a){const r=await w(e,o,a),s=n(e),{data:i}=await t(`${s.path}/computeHistograms`,r);return{histograms:i.histograms}}async function $(o,s,i){const m=s.toJSON();O(m),m.outFields?.length&&(m.outFields=m.outFields.join(","));const u=await e(s.geometry),c=u?.[0];null!=c&&(m.geometry=A(c));const l=n(o),f=a({...l.query,f:"json",...m}),p=r(f,i),{data:y}=await t(`${l.path}/getSamples`,p),g=y?.samples?.map((t=>{const e="NaN"===t.value||""===t.value?null:t.value.split(" ").map((t=>Number(t)));return{...t,pixelValue:e}}));return d.fromJSON({samples:g})}async function C(o,s,i){const m=n(o),u=s.geometry?[s.geometry]:[];return e(u).then((e=>{const o=s.toJSON(),n=e?.[0];null!=n&&(o.geometry=JSON.stringify(A(n)));const u=a({...m.query,f:"json",...o}),c=r(u,i);return t(m.path+"/identify",c)})).then((t=>p.fromJSON(t.data)))}async function b(t,e,o){const n=await M(t,e,[e.fromGeometry,e.toGeometry],o);return f.fromJSON(n)}async function v(t,e,o){const n=await M(t,e,[e.geometry],o);return m.fromJSON(n)}async function F(t,e,o){const n=await M(t,e,[e.geometry],o);return g.fromJSON(n)}async function L(t,e,o){const n=await M(t,e,[e.fromGeometry,e.toGeometry],o);return c.fromJSON(n)}async function M(o,s,i,m){const u=n(o),c=await e(i),l=s.toJSON();null!=c[0]&&(l.fromGeometry=JSON.stringify(A(c[0]))),null!=c[1]&&(l.toGeometry=JSON.stringify(A(c[1])));const f=a({...u.query,f:"json",...l}),p=r(f,m),{data:y}=await t(u.path+"/measure",p);return y}async function P(t,e,o){const n=await x(t,e,o);return R.fromJSON(n)}async function U(t,e,o){const n=await x(t,e,o);return j.fromJSON(n)}async function x(e,o,s){const i=n(e),m=o.toJSON(),u=a({...i.query,f:"json",...m}),c=r(u,s),{data:l}=await t(i.path+"/measureFromImage",c);return l}function A(t){const e=t.toJSON();return t.spatialReference?.imageCoordinateSystem&&(e.spatialReference=H(t.spatialReference)),e}function H(t){const{imageCoordinateSystem:e}=t;if(e){const{id:t,referenceServiceName:o}=e;return null!=t?o?{icsid:t,icsns:o}:{icsid:t}:{ics:e}}return t.toJSON()}function T(t,e){if(!t.imageCoordinateSystem)return o(t);const n=H(t),{icsid:a,icsns:r}=n;return null==a||null!=r&&!e?.toLowerCase().includes("/"+r.toLowerCase()+"/")?JSON.stringify(n):`0:${a}`}async function B(e,o,s){const i=n(e),m=o.toJSON();o.outSpatialReference&&(m.outSR=T(o.outSpatialReference));const c=a({...i.query,f:"json",...m}),l=r(c,s),{data:f}=await t(i.path+"/queryBoundary",l);return u.fromJSON(f)}async function D(o,s,i){const m=s.toJSON();O(m),m.objectIds?.length&&(m.objectIds=m.objectIds.join(",")),m.geometry||m.objectIds||m.time||m.where||(m.where="1=1");const u=await e(s.geometry),c=u?.[0];null!=c&&(m.geometry=A(c));const f=c?.spatialReference??s.geometry?.spatialReference;f&&(m.inSR=T(f));const p=n(o),y=a({...p.query,f:"json",...m}),g=r(y,i),{data:d}=await t(`${p.path}/queryGPSInfo`,g);return l.fromJSON(d)}async function k(e,o,s){const i=o.toJSON();o.geometry.spatialReference.imageCoordinateSystem&&(i.geometry=A(o.geometry)),o.depthOffset&&o.adjust||delete i.options;const m=n(e),u=a({...m.query,f:"json",...i}),c=r(u,s),{data:l}=await t(`${m.path}/imageToMap`,c);return h(l)}async function z(e,o,s){const i=o.toJSON();o.rasterIds?.length&&(i.rasterIds=o.rasterIds.join(","));const m=n(e),u=a({...m.query,f:"json",...i}),c=r(u,s),{data:l}=await t(`${m.path}/imageToMapMultiray`,c);return h(l)}async function E(o,s,i){const m=s.toJSON(),u=await e(s.geometry),c=u?.[0];null!=c&&(m.geometry=A(c)),s.visibleOnly||delete m.options;const l=c?.spatialReference??s.geometry?.spatialReference;l&&(m.inSR=T(l));const f=n(o),p=a({...f.query,f:"json",...m}),y=r(p,i),{data:g}=await t(`${f.path}/mapToImage`,y);return h(g)}async function V(e,o,s){const i=o.toJSON(),m=n(e),u=a({...m.query,f:"json",...i}),c=r(u,s),{data:l}=await t(`${m.path}/getImageUrl`,c);return S.fromJSON(l)}async function X(o,i,m){const u=i.toJSON(),c=await e([i.fromGeometry,i.toGeometry]);null!=c[0]&&(u.fromGeometry=A(c[0]),c[0].spatialReference&&(u.inSR=T(c[0].spatialReference))),null!=c[1]&&(u.toGeometry=A(c[1])),i.objectIds?.length&&(u.objectIds=u.objectIds.join(","));const l=n(o),f=a({...l.query,f:"json",...u}),p=r(f,m),{data:y}=await t(`${l.path}/find`,p);return s.fromJSON(y)}export{J as computeAngles,G as computeHistograms,I as computePixelSpaceLocations,q as computeStatisticsHistograms,X as findImages,H as getImageSpatialReferenceJSON,T as getImageSpatialReferenceQueryParameter,V as getImageUrl,$ as getSamples,C as identify,k as imageToMap,z as imageToMapMultiray,E as mapToImage,v as measureAreaAndPerimeter,U as measureAreaFromImage,L as measureDistanceAndAngle,b as measureHeight,P as measureLengthFromImage,F as measurePointOrCentroid,B as queryBoundary,D as queryGPSInfo};
