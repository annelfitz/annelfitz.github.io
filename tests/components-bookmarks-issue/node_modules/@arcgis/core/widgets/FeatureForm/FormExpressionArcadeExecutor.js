/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import{createArcadeProfile as e,createArcadeExecutor as r}from"../../arcade.js";import s from"../../core/Accessor.js";import{debounce as o}from"../../core/promiseUtils.js";import{property as a}from"../../core/accessorSupport/decorators/property.js";import"../../core/has.js";import"../../core/Logger.js";import"../../core/RandomLCG.js";import{subclass as l}from"../../core/accessorSupport/decorators/subclass.js";import{UpdatingHandles as i}from"../../core/support/UpdatingHandles.js";import{fixFields as n}from"../../layers/support/fieldUtils.js";var u;const c=Symbol("FormExpressionArcadeExecutor");let p=class extends s{constructor(t){super(t),this[u]=!0,this._lastEvaluatedValue=null,this._abortController=new AbortController,this._stale=!1,this._updatingTracking=new i,this._executeAsyncDebounced=o((async(t,e,r)=>{const s=await this.executor.executeAsync(t,{...e,abortSignal:r});return r.aborted?this._lastEvaluatedValue:(this._lastEvaluatedValue=s,this._stale=!1,s)}))}get isAsync(){return this.executor.isAsync}get fieldsUsed(){return this.executor.fieldsUsed}get syntaxTree(){return this.executor.syntaxTree}get updating(){return this._updatingTracking.updating}get stale(){return this._stale}get geometryUsed(){return this.executor.geometryUsed}get variablesUsed(){return this.executor.variablesUsed}get lastEvaluatedValue(){return this._lastEvaluatedValue}abort(){this._abortController.abort()}execute(t,e){this._abortController=new AbortController;const r=this.executor.execute(t,{...e,abortSignal:this._abortController.signal});return this._lastEvaluatedValue=r,r}async executeAsync(t,e){return this._abortController=new AbortController,this._updatingTracking.addPromise(this._executeAsyncDebounced(t,e??{},this._abortController.signal))}markStale(){this._stale=!0}reset(){this.abort(),this._lastEvaluatedValue=null,this._stale=!1}};u=c,t([a()],p.prototype,"_lastEvaluatedValue",void 0),t([a()],p.prototype,"_stale",void 0),t([a()],p.prototype,"_updatingTracking",void 0),t([a({constructOnly:!0})],p.prototype,"executor",void 0),t([a()],p.prototype,"isAsync",null),t([a()],p.prototype,"fieldsUsed",null),t([a()],p.prototype,"syntaxTree",null),t([a()],p.prototype,"updating",null),t([a()],p.prototype,"stale",null),t([a()],p.prototype,"geometryUsed",null),t([a()],p.prototype,"variablesUsed",null),t([a()],p.prototype,"lastEvaluatedValue",null),p=t([l("esri.widgets.FeatureForm.FormExpressionArcadeExecutor")],p);const d=async(t,s)=>{const o=e("form-calculation"),a=await r(t,o,{});return s?.fieldsIndex&&(a.fieldsUsed=n(s.fieldsIndex,a.fieldsUsed)),new p({executor:a})};export{p as FormExpressionArcadeExecutor,d as createFormExpressionArcadeExecutor};
