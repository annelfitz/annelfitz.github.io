/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../intl.js";import"../../core/has.js";import t from"../../core/Error.js";import{clamp as e}from"../../core/mathUtils.js";import{mappedFind as n}from"../../core/maybe.js";import{convertDateFormatToIntlOptions as o,formatTimestamp as l,formatTimeOnly as r,formatDateOnly as i,formatDate as u}from"../../intl/date.js";import{utc as a}from"../../time/timeZoneUtils.js";import{isString as m,isNumber as s}from"./dataUtils.js";import{DateTime as f,FixedOffsetZone as c}from"luxon";import{getLocale as d}from"../../intl/locale.js";const y=a,p={date:null,time:null,timeZoneOffset:null},h=new Map([["hours",3600],["minutes",60],["seconds",1],["deciseconds",.1],["centiseconds",.01],["milliseconds",.001]]),v="yyyy-MM-dd",S="TT";var M;!function(t){t.HM="HH:mm",t.HMS="HH:mm:ss",t.HMS_MS="HH:mm:ss.SSS"}(M||(M={}));const O=[M.HMS_MS,M.HMS,M.HM,S],w="latn",Z=new Set(["date-only","time-only","timestamp-offset"]),H=t=>"valueAsDate"in t;function j(t){return{locale:d(),numberingSystem:w,zone:t??y}}function x(t){return t?.isValid?t.toMillis():null}function g(t,e){return null===t?null:f.fromMillis(t,j(e))}function V(t,e){if(null==t||!m(t)||""===t){if(e){const t=f.local().setZone(e);return{date:null,time:null,timeZoneOffset:t.isValid?t.offset.toString():null}}return p}const n=f.fromISO(t,{setZone:!0});return{date:n.toFormat(v,j()),time:n.toFormat(M.HMS_MS,j()),timeZoneOffset:n.offset.toString()}}function I(t,e){if(null==t||!s(t)||isNaN(t))return p;const n=g(t,e);return n?{date:n.toFormat(v,j(e)),time:n.toFormat(S,j(e))}:p}function F(t){switch(t.type){case"date":default:return o("short-date-short-time");case"date-only":return o("short-date");case"time-only":return o("short-time");case"timestamp-offset":return{...o("short-date-short-time"),timeZone:void 0,timeZoneName:"short"}}}function T(t,e,n){if(!t||null==e)return null;switch(t.type){case"date":return u(e,n);case"date-only":return i(e,n);case"time-only":return r(e,n);case"timestamp-offset":return l(e,n);default:return null}}function b(t){const{dateComponent:e,defaultTimeZone:n,timeComponent:o,timeZoneComponent:l,oldValue:r}=t;if(!e?.value||!o?.value)return null;const{year:i,month:u,day:m}=f.fromFormat(e.value,v),{hour:s,minute:d,second:y,millisecond:p}=D(o,a)??f.now(),h=V(r,n),S=null!=l?.value?parseInt(l.value,10):null!=h.timeZoneOffset?parseInt(h.timeZoneOffset,10):(new Date).getTimezoneOffset(),M=c.instance(S),O=f.fromObject({year:i,month:u,day:m,hour:s,minute:d,second:y,millisecond:p},{zone:M});return O.isValid?O.toISO({includeOffset:!0}):null}function C(t){const{dateComponent:e,timeComponent:n,timeZone:o,max:l,min:r,oldValue:i}=t,u=D(e,o);let a=!!t.applyRange;if(!u)return null;let m=null;if(null!=n?.value){const t=D(n,o),e=Date.now(),r=null!=l&&l<e?l:e,i=f.fromMillis(r,j(o)),a=u||i,{year:s,month:c,day:d}=a,{hour:y,minute:p,second:h,millisecond:v}=t||i;m=a.set({year:s,month:c,day:d,hour:y,minute:p,second:h,millisecond:v})}else{const t=g(A({value:i??Date.now(),max:l,min:r}),o),{year:e,month:n,day:s}=u,{hour:f,minute:c,second:d,millisecond:y}=t;a=!0,m=u.set({year:e,month:n,day:s,hour:f,minute:c,second:d,millisecond:y})}if(!m.isValid)return null;const s=m.toMillis();return a?A({value:s,max:l,min:r}):s}function D(t,e){if(null==t?.value||Array.isArray(t.value))return null;let n=null;return n=H(t)?f.fromFormat(t.value,v,j(e)):E(t.value),n?.isValid?n:null}function N(t){const{max:e,min:n,value:o}=t;return!isNaN(o)&&(!(null!=e&&o>e)&&!(null!=n&&o<n))}function A(t){const{max:n,min:o,value:l}=t;return null!=n&&null!=o?e(l,o,n):null!=n&&l>n?n:null!=o&&l<o?o:l}function z(e){if(!e)return"";const n=e.split(".").at(0);if(!n||n.length<1)throw new t("invalid time-only field",`Cannot parse valid time-only field value from ${e}`);const o=n.split(":"),l=new Array(3);for(let t=0;t<3;t++){const e=o.at(t)??"";l[t]=e.padStart(2,"0")}return l.join(":")}function U(t,e){switch(e){case"date":return t.getTime();case"date-only":return t.toISODate();case"time-only":return z(t.toISOTime(!0,!1));case"timestamp-offset":return t.toISOString(!1);default:return null}}function _(t){return!!t&&"object"==typeof t&&"getTime"in t&&"toISOString"in t&&"timeZone"in t}function k(t){if(!t||!m(t))return null;const e=f.fromFormat(t,v);return e.isValid?e:null}function E(t){return t&&m(t)?n(O,(e=>{const n=f.fromFormat(t,e);return n.isValid?n:null}))??null:null}function R(t){if(!t||!m(t))return null;const e=f.fromISO(t);return e.isValid?e:null}function $(t){const{type:e,range:n,value:o}=t;if(null==o||!n||o===n.min||o===n.max)return!0;if("date"===e)return N({value:o,min:n.min,max:n.max});const{rawMax:l,rawMin:r}=n;let i=null,u=null,a=null;switch(e){case"date-only":i=k(l),u=k(r),a=k(o);break;case"time-only":i=E(l),u=E(r),a=E(o);break;case"timestamp-offset":i=R(l),u=R(r),a=R(o)}return!a||N({value:a.valueOf(),min:u?.valueOf(),max:i?.valueOf()})}export{M as TimeStampOffsetPattern,U as arcadeDateToFieldValue,A as clampValueToRange,g as createDateTimeFromFieldValue,Z as dateFieldsWithStringFieldValue,k as dateOnlyToDateTime,$ as dateTimeIsInRange,x as dateTimeToFieldValue,v as defaultDatePattern,S as defaultTimePattern,j as getDefaultLocaleOptions,b as getISOFieldValueFromDateComponents,F as getIntlOptionsForField,T as getLabelForDateFieldValue,D as getLocalDateTimeFromComponent,C as getUnixFieldValueFromDateComponents,_ as isArcadeDate,H as isCalciteDateComponent,z as normalizeTimeOnlyString,w as numberingSystem,V as prepareISOFieldValueForDateComponents,I as prepareUnixFieldValueForDateComponents,O as supportedTimeFormats,E as timeOnlyToDateTime,h as timeResolutionToStepMap,R as timestampOffsetToDateTime,N as valueIsInRange};
