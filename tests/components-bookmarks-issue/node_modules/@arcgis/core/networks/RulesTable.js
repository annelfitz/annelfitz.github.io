/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import t from"../request.js";import{JSONSupportMixin as o}from"../core/JSONSupport.js";import s from"../core/Loadable.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import"../core/has.js";import"../core/Logger.js";import"../core/RandomLCG.js";import{subclass as i}from"../core/accessorSupport/decorators/subclass.js";import{RuleType as n}from"./support/typeUtils.js";let a=class extends(o(s)){constructor(e){super(e),this.rulesCategorized={attachment:[],containment:[],connectivity:[]},this.request=t}initialize(){}async load(e){const t=this.layer.load(e).then((()=>this._initializeRulesTable()));return this.addResolvingPromise(t),this}getFeatureSQL(e,t){const o=e.layerId.toString(),s=e.fieldsIndex?.normalizeFieldName("assetGroup"),r=e.fieldsIndex?.normalizeFieldName("assetType"),i=s?t.attributes[s]:null,n=r?t.attributes[r]:null,a=this.rulesHash[o];if(a){const e=a.assetGroupHash[i];if(e){return e.assetTypeHash[n]||null}}return null}async _initializeRulesTable(){const e={};let t;!function(e){e[e.from=0]="from",e[e.to=1]="to",e[e.via=2]="via"}(t||(t={}));const o=[{networkSourceId:"fromNetworkSource",assetGroupId:"fromAssetGroup",assetTypeId:"fromAssetType"},{networkSourceId:"toNetworkSource",assetGroupId:"toAssetGroup",assetTypeId:"toAssetType"},{networkSourceId:"viaNetworkSource",assetGroupId:"viaAssetGroup",assetTypeId:"viaAssetType"}];this.rulesCategorized={attachment:[],containment:[],connectivity:[]};for(const s of this.rules){if(s.ruleType===n.RTAttachment){this.rulesCategorized.attachment.push(s);continue}if(s.ruleType===n.RTContainment){this.rulesCategorized.containment.push(s);continue}if(s.ruleType===n.RTJunctionJunctionConnectivity){this.rulesCategorized.connectivity.push(s);continue}this.rulesCategorized.connectivity.push(s);let r=[[t.from,t.to],[t.to,t.from]];s.ruleType===n.RTEdgeJunctionEdgeConnectivity&&(r=[[t.from,t.via],[t.via,t.from],[t.to,t.via],[t.via,t.to]]);for(const i of r){const r=i.shift(),a=i.shift();let c=!1;switch(s.ruleType){case n.RTEdgeJunctionEdgeConnectivity:c=r===t.from||r===t.to;break;case n.RTJunctionEdgeConnectivity:c=r===t.to}const u=o[r],p=s[u.networkSourceId]?.layerId.toString()??"",d=s[u.assetGroupId]?.assetGroupCode?.toString(),l=s[u.assetTypeId],y=l?.assetTypeCode?.toString(),m=o[a],h=s[m.networkSourceId]?.layerId.toString()??"",f=s[m.assetGroupId]?.assetGroupCode?.toString(),T=s[m.assetTypeId],g=T?.assetTypeCode?.toString(),v=e[p]??{assetGroupHash:{}};if(!(d&&y&&f&&g))continue;const I=v.assetGroupHash[d]??{assetTypeHash:{}},S=I.assetTypeHash[y]??{};if(S[h]=S[h]??{},c){S[p]=S[p]??{};const e=`(assetgroup = ${d} AND assettype = ${y})`;S[p].anyVertex=S[p].anyVertex?`${S[p].anyVertex}`:`${e}`,"esriNECPEndVertex"===T?.connectivityPolicy&&(S[p].endVertex=S[p]?.endVertex?`${S[p].endVertex}`:`${e}`)}const C=`(assetgroup = ${f} AND assettype = ${g})`;S[h].anyVertex=S[h]?.anyVertex?`${S[h].anyVertex} OR ${C}`:`${C}`,"esriNECPEndVertex"===T?.connectivityPolicy&&(S[h].endVertex=S[h]?.endVertex?`${S[h].endVertex} OR ${C}`:`${C}`),I.assetTypeHash[y]=S,v.assetGroupHash[d]=I,e[p]=v}}this.rulesHash=e}};e([r({constructOnly:!0})],a.prototype,"layer",void 0),e([r({constructOnly:!0})],a.prototype,"rules",void 0),e([r()],a.prototype,"rulesHash",void 0),e([r()],a.prototype,"rulesCategorized",void 0),e([r({constructOnly:!0})],a.prototype,"request",void 0),a=e([i("esri.networks.RulesTable")],a);const c=a;export{c as default};
