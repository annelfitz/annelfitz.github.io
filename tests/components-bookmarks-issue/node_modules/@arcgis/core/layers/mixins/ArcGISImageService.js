/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import"../../geometry.js";import t from"../../Graphic.js";import{rasterRendererTypes as r,websceneRasterRendererTypes as i,read as s}from"../../rasterRenderers.js";import n from"../../request.js";import{deprecatedProperty as a}from"../../core/deprecate.js";import o from"../../core/Error.js";import{clone as l}from"../../core/lang.js";import u from"../../core/Logger.js";import{watch as p}from"../../core/reactiveUtils.js";import{urlToObject as m}from"../../core/urlUtils.js";import{property as c,ensureRange as d}from"../../core/accessorSupport/decorators/property.js";import{Integer as h,ensureClass as g,ensureNumber as f}from"../../core/accessorSupport/ensureType.js";import{reader as y}from"../../core/accessorSupport/decorators/reader.js";import{subclass as R}from"../../core/accessorSupport/decorators/subclass.js";import{writer as b}from"../../core/accessorSupport/decorators/writer.js";import{srToRESTValue as I}from"../../geometry/support/spatialReferenceUtils.js";import{opacity as w,url as v}from"../support/commonProperties.js";import S from"../support/DimensionalDefinition.js";import{ExportImageServiceParameters as x}from"../support/ExportImageServiceParameters.js";import _ from"../support/Field.js";import F from"../support/FieldsIndex.js";import{createBitmap as D}from"../support/imageBitmapUtils.js";import{isSupportedRendererType as T}from"../support/imageryRendererUtils.js";import P from"../support/MosaicRule.js";import j from"../support/MultidimensionalSubset.js";import O from"../support/PixelBlock.js";import{interpolationKebab as M,noDataInterpretationKebab as C,pixelTypeKebabDict as N}from"../support/rasterEnums.js";import q from"../support/RasterFunction.js";import A from"../support/RasterInfo.js";import E from"../support/RasterJobHandler.js";import{intersectMultimensionalSubset as J,getSubsetVariablesFromMdInfo as V,getDefaultMultidimensionalDefinition as Q}from"../support/rasterDatasets/multidimensionalUtils.js";import{decode as H,getFormat as U}from"../support/rasterFormats/RasterCodec.js";import{uvComponentToVector as B}from"../support/rasterFunctions/vectorFieldUtils.js";import{getSupportedRendererTypes as L,getDefaultBandCombination as z,createDefaultRenderer as G,normalizeRendererJSON as k}from"../../renderers/support/rasterRendererHelper.js";import W from"../../renderers/support/RasterSymbolizer.js";import{computeAngles as $,computePixelSpaceLocations as X,computeHistograms as K,computeStatisticsHistograms as Y,measureHeight as Z,measureAreaAndPerimeter as ee,measureDistanceAndAngle as te,measurePointOrCentroid as re,measureLengthFromImage as ie,measureAreaFromImage as se,getImageSpatialReferenceQueryParameter as ne,getSamples as ae,identify as oe,imageToMap as le,imageToMapMultiray as ue,mapToImage as pe,findImages as me,getImageUrl as ce,queryBoundary as de,queryGPSInfo as he}from"../../rest/imageService.js";import"../../core/has.js";import"../support/source/DataLayerSource.js";import{executeQueryJSON as ge}from"../../rest/query/executeQueryJSON.js";import"../../config.js";import"../../kernel.js";import"../../core/unitUtils.js";import"../../geometry/ellipsoidUtils.js";import"../../geometry/support/aaBoundingBox.js";import"../../core/mathUtils.js";import fe from"../../geometry/Extent.js";import"../../geometry/Geometry.js";import"../../geometry/Multipoint.js";import"../../geometry/Point.js";import ye from"../../geometry/Polygon.js";import"../../geometry/Polyline.js";import"../../geometry/support/normalizeUtilsCommon.js";import Re from"../../geometry/SpatialReference.js";import"../../geometry/support/Ellipsoid.js";import"../../core/pbf.js";import be from"../../rest/support/FeatureSet.js";import Ie from"../../rest/support/Query.js";import"../../rest/query/support/AttachmentInfo.js";import"../../rest/support/AttachmentQuery.js";import{executeForCount as we}from"../../rest/query/executeForCount.js";import{executeForIds as ve}from"../../rest/query/executeForIds.js";import"../../rest/support/RelationshipQuery.js";import"../../rest/support/TopFeaturesQuery.js";import{generateRasterInfo as Se,fetchServiceRasterInfo as xe,patchServiceInfo as _e}from"../../rest/imageService/fetchRasterInfo.js";import{getCatalogItemRasterInfo as Fe}from"../../rest/imageService/getCatalogItemRasterInfo.js";import De from"../../rest/support/FindImagesParameters.js";import Te from"../../rest/support/ImageAngleParameters.js";import Pe from"../../rest/support/ImageAreaParameters.js";import je from"../../rest/support/ImageBoundaryParameters.js";import Oe from"../../rest/support/ImageDistanceParameters.js";import Me from"../../rest/support/ImageGPSInfoParameters.js";import Ce from"../../rest/support/ImageHeightParameters.js";import Ne from"../../rest/support/ImageHistogramParameters.js";import qe from"../../rest/support/ImageIdentifyParameters.js";import Ae from"../../rest/support/ImagePixelLocationParameters.js";import Ee from"../../rest/support/ImagePointParameters.js";import Je from"../../rest/support/ImageSampleParameters.js";import Ve from"../../rest/support/ImageToMapMultirayParameters.js";import Qe from"../../rest/support/ImageToMapParameters.js";import He from"../../rest/support/ImageUrlParameters.js";import Ue from"../../rest/support/MapToImageParameters.js";import Be from"../../rest/support/MeasureFromImageParameters.js";import{createFlowMesh as Le}from"../../views/2d/engine/flow/dataUtils.js";const ze=new Set(["png","png8","png24","png32","jpg","bmp","gif","jpgpng","lerc","tiff"]),Ge=d(f,{min:0,max:255});function ke(e){if(!e)return null;const t=JSON.stringify(e).match(/"rasterFunction":"(.*?")/gi),r=t?.map((e=>e.replace('"rasterFunction":"',"").replace('"',"")));return r?r.join("/"):null}const We=d=>{let f=class extends d{constructor(){super(...arguments),this._functionRasterInfos={},this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this._cachedRendererJson=null,this._serviceSupportsMosaicRule=null,this._rasterAttributeTableFieldPrefix="Raster.",this.adjustAspectRatio=null,this.bandIds=void 0,this.capabilities=null,this.compressionQuality=void 0,this.compressionTolerance=.01,this.copyright=null,this.defaultMosaicRule=null,this.definitionExpression=null,this.exportImageServiceParameters=null,this.rasterInfo=null,this.fields=null,this.fullExtent=null,this.hasMultidimensions=!1,this.imageMaxHeight=4100,this.imageMaxWidth=4100,this.interpolation=void 0,this.minScale=0,this.maxScale=0,this.multidimensionalInfo=null,this.multidimensionalSubset=null,this.noData=null,this.noDataInterpretation=void 0,this.objectIdField=null,this.geometryType="polygon",this.typeIdField=null,this.types=[],this.pixelFilter=null,this.raster=void 0,this.sourceType=null,this.viewId=void 0,this.symbolizer=null,this.rasterFunctionInfos=null,this.serviceDataType=null,this.spatialReference=null,this.pixelType=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.url=null,this.version=void 0}initialize(){this._set("exportImageServiceParameters",new x({layer:this}))}readServiceSupportsMosaicRule(e,t){return this._isMosaicRuleSupported(t)}get _rasterFunctionNamesIndex(){const e=new Map;return!this.rasterFunctionInfos||null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.length<1||null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.forEach((t=>{e.set(t.name.toLowerCase().replaceAll(/ /gi,"_"),t.name)})),e}readBandIds(e,t){if(Array.isArray(e)&&e.length>0&&e.every((e=>"number"==typeof e)))return e}readCapabilities(e,t){return this._readCapabilities(t)}writeCompressionQuality(e,t,r){null!=e&&"lerc"!==this.format&&(t[r]=e)}writeCompressionTolerance(e,t,r){"lerc"===this.format&&null!=e&&(t[r]=e)}readDefaultMosaicRule(e,t){return this._serviceSupportsMosaicRule?P.fromJSON(t):null}get fieldsIndex(){return this.fields?new F(this.fields):null}set format(e){e&&ze.has(e.toLowerCase())&&this._set("format",e.toLowerCase())}readFormat(e,t){return"esriImageServiceDataTypeVector-UV"===t.serviceDataType||"esriImageServiceDataTypeVector-MagDir"===t.serviceDataType||null!=this.pixelFilter?"lerc":"jpgpng"}readMinScale(e,t){return null!=t.minLOD&&null!=t.maxLOD?e:0}readMaxScale(e,t){return null!=t.minLOD&&null!=t.maxLOD?e:0}set mosaicRule(e){let t=e;t?.mosaicMethod&&(t=P.fromJSON({...t.toJSON(),mosaicMethod:t.mosaicMethod,mosaicOperation:t.mosaicOperation})),this._set("mosaicRule",t)}readMosaicRule(e,t){const r=e||t.mosaicRule;return r?P.fromJSON(r):this._isMosaicRuleSupported(t)?P.fromJSON(t):null}writeMosaicRule(e,t,r){let i=this.mosaicRule;const s=this.definitionExpression;i?s&&s!==i.where&&(i=i.clone(),i.where=s):s&&(i=new P({where:s})),this._isValidCustomizedMosaicRule(i)&&(t[r]=i.toJSON())}writeNoData(e,t,r){null!=e&&"number"==typeof e&&(t[r]=Ge(e))}readObjectIdField(e,t){if(!e){const r=t.fields.find((e=>"esriFieldTypeOID"===e.type||"oid"===e.type));e=r?.name}return e}get parsedUrl(){return m(this.url)}readSourceType(e,t){return this._isMosaicDataset(t)?"mosaic-dataset":"raster-dataset"}set renderer(e){this.loaded&&(e=this._configRenderer(e)),this._set("renderer",e)}readRenderer(e,t,r){const i=t?.layerDefinition?.drawingInfo?.renderer,n=s(i,r);return null==n?null:("vector-field"===n.type&&t.symbolTileSize&&!i.symbolTileSize&&(n.symbolTileSize=t.symbolTileSize),T(n)||u.getLogger(this).warn("ArcGISImageService","Imagery layer doesn't support given renderer type."),n)}writeRenderer(e,t,r){t.layerDefinition=t.layerDefinition||{},t.layerDefinition.drawingInfo=t.layerDefinition.drawingInfo||{},t.layerDefinition.drawingInfo.renderer=e.toJSON(),"vector-field"===e.type&&(t.symbolTileSize=e.symbolTileSize)}get rasterFields(){const e=this._rasterAttributeTableFieldPrefix,t=new _({name:"Raster.ItemPixelValue",alias:"Item Pixel Value",domain:null,editable:!1,length:50,type:"string"}),r=new _({name:"Raster.ServicePixelValue",alias:"Service Pixel Value",domain:null,editable:!1,length:50,type:"string"}),i=new _({name:"Raster.ServicePixelValue.Raw",alias:"Raw Service Pixel Value",domain:null,editable:!1,length:50,type:"string"});let s=this.fields?l(this.fields):[];s.push(r),this.capabilities?.operations.supportsQuery&&this.fields&&this.fields.length>0&&s.push(t),this.version>=10.4&&null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.some((e=>"none"===e.name.toLowerCase()))&&s.push(i),null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.filter((e=>"none"!==e.name.toLowerCase())).forEach((e=>{s.push(new _({name:"Raster.ServicePixelValue."+e.name,alias:e.name,domain:null,editable:!1,length:50,type:"string"}))})),this._isVectorDataSet()&&(s.push(new _({name:"Raster.Magnitude",alias:"Magnitude",domain:null,editable:!1,type:"double"})),s.push(new _({name:"Raster.Direction",alias:"Direction",domain:null,editable:!1,type:"double"})));const{attributeTable:n}=this.rasterInfo??{};if(null!=n){const t=n.fields.filter((e=>"esriFieldTypeOID"!==e.type&&"value"!==e.name.toLowerCase())).map((t=>{const r=l(t);return r.name=e+t.name,r}));s=s.concat(t)}return s}get renderingRule(){return a(u.getLogger(this),"renderingRule",{replacement:"rasterFunction",version:"4.27",warnOnce:!0}),this.rasterFunction}set renderingRule(e){a(u.getLogger(this),"renderingRule",{replacement:"rasterFunction",version:"4.27",warnOnce:!0}),this._set("rasterFunction",e)}set rasterFunction(e){let t=e;t?.rasterFunction&&(t=q.fromJSON({...t.toJSON(),rasterFunction:t.rasterFunction,rasterFunctionArguments:t.rasterFunctionArguments})),this._set("rasterFunction",t)}readRasterFunction(e,t){const r=t.rasterFunctionInfos;return t.renderingRule||r?.length&&"None"!==r[0].name?this._isRFTJson(t.renderingRule)?q.fromJSON({rasterFunctionDefinition:t.renderingRule}):q.fromJSON(t.renderingRule||{rasterFunctionInfos:t.rasterFunctionInfos}):null}readSpatialReference(e,t){const r=e||t.extent.spatialReference;return r?Re.fromJSON(r):null}readPixelType(e){return N.fromJSON(e)||e}writePixelType(e,t,r){null!=this.serviceRasterInfo&&this.pixelType===this.serviceRasterInfo.pixelType||(t[r]=N.toJSON(e))}readVersion(e,t){let r=t.currentVersion;return r||(r=t.hasOwnProperty("fields")||t.hasOwnProperty("timeInfo")?10:9.3),r}applyFilter(e){let t=e;return this.pixelFilter&&(t=this._clonePixelData(e),this.pixelFilter(t)),t}async applyRenderer(e,t){let r=e;const{renderer:i,symbolizer:s,pixelFilter:n,bandIds:a}=this;if(!this._isPicture()&&i&&s&&!n){const n=JSON.stringify(this._cachedRendererJson)!==JSON.stringify(i.toJSON()),o=this._rasterJobHandler.instance;if(o){n&&(s.bind(),await o.updateSymbolizer(s,t),this._cachedRendererJson=i.toJSON());const l=await o.symbolize({bandIds:a,...e},t);r={extent:e.extent,pixelBlock:l}}else r={extent:e.extent,pixelBlock:s.symbolize({bandIds:a,...e})}}return r}destroy(){this._shutdownJobHandler()}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}async computeAngles(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeAngles)throw new o("imagery-layer:compute-angles","this operation is not supported on the input image service");return e=g(Te,e).clone(),$(this.url,e,this._getRequestOptions(t))}async computePixelSpaceLocations(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputePixelLocation)throw new o("imagery-layer:compute-pixel-space-locations","this operation is not supported on the input image service");return e=g(Ae,e).clone(),X(this.url,e,this._getRequestOptions(t))}async computeHistograms(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeHistograms)throw new o("imagery-layer:compute-histograms","this operation is not supported on the input image service");return e=g(Ne,e).clone(),this._applyMosaicAndRenderingRules(e),K(this.url,e,this._getRequestOptions(t))}async computeStatisticsHistograms(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeStatisticsHistograms)throw new o("imagery-layer:compute-statistics-histograms","this operation is not supported on the input image service");return e=g(Ne,e).clone(),this._applyMosaicAndRenderingRules(e),Y(this.url,e,this._getRequestOptions(t))}async measureHeight(e,t){const r=await this._fetchCapabilities(t?.signal);if(!("base-and-top"===e.operationType?r.mensuration.supportsHeightFromBaseAndTop:"base-and-top-shadow"===e.operationType?r.mensuration.supportsHeightFromBaseAndTopShadow:r.mensuration.supportsHeightFromTopAndTopShadow))throw new o("imagery-layer:measure-height","this operation is not supported on the input image service");return e=g(Ce,e).clone(),this._applyMosaicAndRenderingRules(e),Z(this.url,e,this._getRequestOptions(t))}async measureAreaAndPerimeter(e,t){const r=await this._fetchCapabilities(t?.signal);if(!(r.mensuration.supportsAreaAndPerimeter&&(!e.is3D||r.mensuration.supports3D)))throw new o("imagery-layer:measure-area-and-perimeter","this operation is not supported on the input image service");return e=g(Pe,e).clone(),this._applyMosaicAndRenderingRules(e),ee(this.url,e,this._getRequestOptions(t))}async measureDistanceAndAngle(e,t){const r=await this._fetchCapabilities(t?.signal);if(!(r.mensuration.supportsDistanceAndAngle&&(!e.is3D||r.mensuration.supports3D)))throw new o("imagery-layer:measure-distance-and-angle","this operation is not supported on the input image service");return e=g(Oe,e).clone(),this._applyMosaicAndRenderingRules(e),te(this.url,e,this._getRequestOptions(t))}async measurePointOrCentroid(e,t){const r=await this._fetchCapabilities(t?.signal);if(!(r.mensuration.supportsPointOrCentroid&&(!e.is3D||r.mensuration.supports3D)))throw new o("imagery-layer:measure-point-or-centroid","this operation is not supported on the input image service");return e=g(Ee,e).clone(),this._applyMosaicAndRenderingRules(e),re(this.url,e,this._getRequestOptions(t))}async measureLengthFromImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMeasureFromImage)throw new o("imagery-layer:measure-length-from-image","this operation is not supported on the input image service");if("polyline"!==e.geometry.type)throw new o("imagery-layer:measure-length-from-image","this input geometry must be a polyline");return e=g(Be,e).clone(),ie(this.url,e,this._getRequestOptions(t))}async measureAreaFromImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMeasureFromImage)throw new o("imagery-layer:measure-area-from-image","this operation is not supported on the input image service");if("polygon"!==e.geometry.type)throw new o("imagery-layer:measure-area-from-image","this input geometry must be a polygon");return e=g(Be,e).clone(),se(this.url,e,this._getRequestOptions(t))}getField(e){const{fieldsIndex:t}=this;return null!=t?t.get(e):void 0}getFieldDomain(e,t){const r=this.getField(e);return r?r.domain:null}async fetchImage(e,t,r,i={}){if(null==e||null==t||null==r)throw new o("imagery-layer:fetch-image","Insufficient parameters for requesting an image. A valid extent, width and height values are required.");if(this.renderer||this.symbolizer){const e=await this._generateRasterInfo(this.rasterFunction,{signal:i.signal});e&&(this.rasterInfo=e)}const s=this.getExportImageServiceParameters(e,t,r,i.timeExtent);if(null==s){if(i.requestAsImageElement&&this._canRequestImageElement(this.format)){const e=document.createElement("canvas");if(e.width=t,e.height=r,i.returnImageBitmap){return{imageBitmap:await D(e,`${We(this.parsedUrl)}/exportImage`,i.signal)}}return{imageOrCanvasElement:e}}const{bandIds:s,rasterInfo:n}=this,a=(s?.length||n.bandCount)??0,o=t*r,l=n.pixelType,u=[];for(let e=0;e<a;e++)u.push(O.createEmptyBand(l,o));return{pixelData:{pixelBlock:new O({width:t,height:r,pixels:u,mask:new Uint8Array(o),pixelType:l}),extent:e}}}const n=!!i.requestAsImageElement&&!this.pixelFilter,a=n&&!!i.returnImageBitmap,l={imageServiceParameters:s,imageProps:{extent:e,width:t,height:r,format:this.format},requestAsImageElement:n,returnImageBitmap:a,signal:i.signal};return this._requestArrayBuffer(l)}fetchKeyProperties(e){return n(We(this.parsedUrl)+"/keyProperties",{query:this._getQueryParams({renderingRule:this.version>=10.3?e?.rasterFunction:null})}).then((e=>e.data))}fetchRasterAttributeTable(e){return this.version<10.1?Promise.reject(new o("#fetchRasterAttributeTable()","Failed to get rasterAttributeTable")):n(We(this.parsedUrl)+"/rasterAttributeTable",{query:this._getQueryParams({renderingRule:this.version>=10.3?e?.rasterFunction:null})}).then((e=>be.fromJSON(e.data)))}getCatalogItemRasterInfo(e,t){const r={...t,query:this._getQueryParams()};return Fe(We(this.parsedUrl),e,r)}async getCatalogItemICSInfo(e,t){const{data:r}=await n(We(this.parsedUrl)+"/"+e+"/info/ics",{query:this._getQueryParams(),...t}),i=r?.ics;if(!i)return;let s=null;try{s=(await n(We(this.parsedUrl)+"/"+e+"/info",{query:this._getQueryParams(),...t})).data.extent}catch{}if(!s||!s.spatialReference)return{ics:i,icsToPixelTransform:null,icsExtent:null,northDirection:null};const a=this.version>=10.7?n(We(this.parsedUrl)+"/"+e+"/info/icstopixel",{query:this._getQueryParams(),...t}).then((e=>e.data)).catch((()=>({}))):{},o=s.spatialReference,l={geometries:JSON.stringify({geometryType:"esriGeometryEnvelope",geometries:[s]}),inSR:I(o),outSR:"0:"+e},u=n(We(this.parsedUrl)+"/project",{query:this._getQueryParams(l),...t}).then((e=>e.data)).catch((()=>({}))),p=5,m=(s.xmin+s.xmax)/2,c=(s.ymax-s.ymin)/(p+1),d=s.ymin+c,h=[];for(let n=0;n<p;n++)h.push({x:m,y:d+c*n});const g={geometries:JSON.stringify({geometryType:"esriGeometryPoint",geometries:h}),inSR:I(o),outSR:"0:"+e},f=n(We(this.parsedUrl)+"/project",{query:this._getQueryParams(g),...t}).then((e=>e.data)).catch((()=>({}))),y=await Promise.all([a,u,f]);let R=y[0].ipxf;if(null==R){const e=i.geodataXform?.xf_0;"topup"===e?.name?.toLowerCase()&&6===e?.coefficients?.length&&(R={affine:{name:"ics [sensor: Frame] to pixel (column, row) transformation",coefficients:e.coefficients,cellsizeRatio:0,type:"GeometricXform"}})}const b=fe.fromJSON(y[1]?.geometries?.[0]);b&&(b.spatialReference=new Re({wkid:0,imageCoordinateSystem:i}));const w=y[2].geometries?y[2].geometries.filter((e=>null!=e?.x&&null!=e.y&&"NaN"!==e.x&&"NaN"!==e.y)):[],v=w.length;if(v<3)return{ics:i,icsToPixelTransform:R,icsExtent:b,northDirection:null};let S=0,x=0,_=0,F=0;for(let n=0;n<v;n++)S+=w[n].x,x+=w[n].y,_+=w[n].x*w[n].x,F+=w[n].x*w[n].y;const D=(v*F-S*x)/(v*_-S*S);let T=0;const P=w[p-1].x>w[0].x,j=w[p-1].y>w[0].y;return D===1/0?T=j?90:270:0===D?T=P?0:180:D>0?T=P?180*Math.atan(D)/Math.PI:180*Math.atan(D)/Math.PI+180:D<0&&(T=j?180+180*Math.atan(D)/Math.PI:360+180*Math.atan(D)/Math.PI),{ics:i,icsToPixelTransform:R,icsExtent:b,northDirection:T}}async generateRasterInfo(e,t){if(e=g(q,e),this.serviceRasterInfo&&(!e||"none"===e.functionName?.toLowerCase()||this._isVectorFieldResampleFunction(e)))return this.serviceRasterInfo;const r=ke(e);if(!r)throw new o("imagery-layer:generate-raster-info","the rendering rule is not supported");if(this._functionRasterInfos[r])return this._functionRasterInfos[r];const i={...t,query:this._getQueryParams()},s=Se(We(this.parsedUrl),e,i);this._functionRasterInfos[r]=s;try{return await s}catch(n){throw this._functionRasterInfos[r]=null,n}}getExportImageServiceParameters(e,t,r,i){e=e.clone().shiftCentralMeridian();const s=ne(e.spatialReference,We(this.parsedUrl));this.pixelType!==this.serviceRasterInfo.pixelType&&(this.exportImageServiceParameters.pixelType=this.pixelType);const n=this.exportImageServiceParameters.toJSON(),{bandIds:a,noData:o}=n;let{renderingRule:l}=n;const u=this.rasterFunction?.rasterFunctionDefinition,p=!this.renderer||"raster-stretch"===this.renderer.type;if(a?.length&&this._hasRasterFunction(this.rasterFunction)&&!u&&p){const e={rasterFunction:"ExtractBand",rasterFunctionArguments:{BandIds:a}};if("Stretch"===l.rasterFunction)e.rasterFunctionArguments.Raster=l.rasterFunctionArguments.Raster,l.rasterFunctionArguments.Raster=e;else if("Colormap"===l.rasterFunction){const t=l.rasterFunctionArguments.Raster;"Stretch"===t?.rasterFunction?(e.rasterFunctionArguments.Raster=t.rasterFunctionArguments.Raster,t.rasterFunctionArguments.Raster=e):(e.rasterFunctionArguments.Raster=t,l.rasterFunctionArguments.Raster=e)}else e.rasterFunctionArguments.Raster=l,l=e;n.bandIds=void 0}else n.bandIds=a?.join(",");Array.isArray(o)&&o.length>0&&(n.noData=o.join(","));const m=this._processMultidimensionalIntersection(null,i,this.exportImageServiceParameters.mosaicRule);if(m.isOutSide)return null;n.mosaicRule=null!=m.mosaicRule?JSON.stringify(m.mosaicRule):null,i=m.timeExtent,n.renderingRule=this._getRenderingRuleString(q.fromJSON(l));const c={};if(null!=i){const{start:e,end:t}=i.toJSON();e&&t&&e===t?c.time=""+e:null==e&&null==t||(c.time=`${e??"null"},${t??"null"}`)}return{bbox:e.xmin+","+e.ymin+","+e.xmax+","+e.ymax,bboxSR:s,imageSR:s,size:t+","+r,...n,...c}}async getSamples(e,t){const r=await this._fetchCapabilities(t?.signal);if(!r?.operations.supportsGetSamples)throw new o("imagery-layer:get-samples","getSamples operation is not supported on the input image service");e=g(Je,e).clone();const{raster:i}=this;return i&&null==e.raster&&(e.raster=i),ae(this.url,e,this._getRequestOptions(t))}async identify(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsIdentify)throw new o("imagery-layer:identify","identify operation is not supported on the input image service");e=g(qe,e).clone(),this.version<10.91&&"extent"===e.geometry?.type&&(e.geometry=ye.fromExtent(e.geometry));const r=this._processMultidimensionalIntersection(e.geometry,e.timeExtent,e.mosaicRule||this.mosaicRule);if(r.isOutSide)throw new o("imagery-layer:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");e.timeExtent=r.timeExtent,e.mosaicRule=r.mosaicRule;const{raster:i,rasterFunction:s}=this;return s&&null==e.rasterFunction&&(e.rasterFunction=s),i&&null==e.raster&&(e.raster=i),oe(this.url,e,this._getRequestOptions(t))}async imageToMap(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsImageToMap)throw new o("imagery-layer:image-to-map","imageToMap operation is not supported on the input image service");return e=g(Qe,e),le(We(this.parsedUrl),e,this._getRequestOptions(t))}async imageToMapMultiray(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsImageToMapMultiray)throw new o("imagery-layer:image-to-map-multiray","imageToMapMultiray operation is not supported on the input image service");return e=g(Ve,e),ue(We(this.parsedUrl),e,this._getRequestOptions(t))}async mapToImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMapToImage)throw new o("imagery-layer:map-to-image","mapToImage operation is not supported on the input image service");return e=g(Ue,e),pe(We(this.parsedUrl),e,this._getRequestOptions(t))}async findImages(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsFindImages)throw new o("imagery-layer:find-images","findImages operation is not supported on the input image service");return e=g(De,e),me(We(this.parsedUrl),e,this._getRequestOptions(t))}async getImageUrl(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsGetImageUrl)throw new o("imagery-layer:get-image-url","getImageUrl operation is not supported on the input image service");return e=g(He,e),ce(We(this.parsedUrl),e,this._getRequestOptions(t))}createQuery(){return new Ie({outFields:["*"],returnGeometry:!0,where:this.definitionExpression||"1=1"})}async queryBoundary(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQueryBoundary)throw new o("imagery-layer:query-boundary","queryBoundary operation is not supported on the input image service");return e=g(je,e??{outSpatialReference:this.spatialReference}).clone(),de(We(this.parsedUrl),e,this._getRequestOptions(t))}async queryRasters(e,t){return({query:e,requestOptions:t}=await this._prepareForQuery(e,t)),ge(this.url,e,t)}async queryObjectIds(e,t){return({query:e,requestOptions:t}=await this._prepareForQuery(e,t)),ve(this.url,e,t)}async queryGPSInfo(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQueryGPSInfo)throw new o("imagery-layer:query-gps-info","queryGPSInfo operation is not supported on the input image service");return e=g(Me,e??{outSpatialReference:this.spatialReference}).clone(),he(We(this.parsedUrl),e,this._getRequestOptions(t))}async queryRasterCount(e,t){return({query:e,requestOptions:t}=await this._prepareForQuery(e,t)),we(this.url,e,t)}async queryVisibleRasters(e,t){if(!e)throw new o("imagery-layer: query-visible-rasters","missing query parameter");await this.load();const{pixelSize:r,returnDomainValues:i,returnTopmostRaster:s,showNoDataRecords:n}=t||{pixelSize:null,returnDomainValues:!1,returnTopmostRaster:!1,showNoDataRecords:!1};let a=!1,l=null,u=null;const p="raster.servicepixelvalue",m=this._rasterFunctionNamesIndex;if(null!=e.outFields&&(a=e.outFields.some((e=>!e.toLowerCase().includes(p))),this.version>=10.4)){const t=e.outFields.filter((e=>e.toLowerCase().includes(p)&&e.length>p.length)).map((e=>{const t=e.slice(p.length+1);return[this._updateRenderingRulesFunctionName(t,m),t]}));l=t.map((e=>new q({functionName:e[0]}))),u=t.map((e=>e[1]));const{rasterFunction:r}=this;0===l.length?r?.functionName?(l.push(r),u.push(r.functionName)):l=null:r?.functionName&&!l.some((e=>e.functionName===r.functionName))&&(l.push(r),u.push(r.functionName))}const c=null==e.outSpatialReference||e.outSpatialReference.equals(this.spatialReference),{multidimensionalSubset:d}=this;let h=e.timeExtent||this.timeExtent;if(d){const{isOutside:t,intersection:r}=J(d,{geometry:e.geometry,timeExtent:e.timeExtent,multidimensionalDefinition:this.exportImageServiceParameters.mosaicRule?.multidimensionalDefinition});if(t)throw new o("imagery-layer:query-visible-rasters","the request cannot be fulfilled when falling outside of the multidimensional subset");null!=r?.timeExtent&&(h=r.timeExtent)}const g=this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule,h);let f=e.geometry;this.version<10.91&&"extent"===f?.type&&(f=ye.fromExtent(f));const y=this._getQueryParams({geometry:f,timeExtent:h,mosaicRule:g,rasterFunction:this.version<10.4?this.rasterFunction:null,rasterFunctions:l,pixelSize:r,returnCatalogItems:a,returnGeometry:c,raster:this.raster,maxItemCount:s?1:null});delete y.f;const R=new qe(y);try{await this._generateRasterInfo(this.rasterFunction);const r=await oe(this.url,R,{signal:t?.signal,query:{...this.customParameters}}),s=e.outFields,o=null!=r.value&&r.value.toLowerCase().includes("nodata");if(!(a&&!c&&r?.catalogItems?.features.length&&(n||!o)))return this._processVisibleRastersResponse(r,{returnDomainValues:i,templateRRFunctionNames:u,showNoDataRecords:n,templateFields:s});const l=this.objectIdField||"ObjectId",p=r.catalogItems?.features??[],m=p.map((e=>e.attributes?.[l])),d=new Ie({objectIds:m,returnGeometry:!0,outSpatialReference:e.outSpatialReference,outFields:[l]}),h=await this.queryRasters(d);return h?.features?.length&&h.features.forEach((t=>{p.forEach((r=>{r.attributes[l]===t.attributes[l]&&(r.geometry=new ye(t.geometry),null!=e.outSpatialReference&&(r.geometry.spatialReference=e.outSpatialReference))}))})),this._processVisibleRastersResponse(r,{returnDomainValues:i,templateRRFunctionNames:u,showNoDataRecords:n,templateFields:s})}catch{throw new o("imagery-layer:query-visible-rasters","encountered error when querying visible rasters")}}async fetchVariableStatisticsHistograms(e,t){const r=n(We(this.parsedUrl)+"/statistics",{query:this._getQueryParams({variable:e}),signal:t}).then((e=>e.data?.statistics)),i=n(We(this.parsedUrl)+"/histograms",{query:this._getQueryParams({variable:e}),signal:t}).then((e=>e.data?.histograms)),s=await Promise.all([r,i]);return s[0]&&s[0].forEach((e=>{e.avg=e.mean,e.stddev=e.standardDeviation})),{statistics:s[0]||null,histograms:s[1]||null}}async createFlowMesh(e,t){const r=this._rasterJobHandler.instance;return r?r.createFlowMesh(e,t):Le(e.meshType,e.simulationSettings,e.flowData,null!=t.signal?t.signal:(new AbortController).signal)}getMultidimensionalSubsetVariables(e){const t=e??this.serviceRasterInfo.multidimensionalInfo;return V(this.multidimensionalSubset,t)}async _fetchService(e){await this._fetchServiceInfo(e),this.rasterInfo||(this.rasterInfo=this.serviceRasterInfo);const t=this.sourceJSON,r=null!=this.serviceRasterInfo?Promise.resolve(this.serviceRasterInfo):xe(We(this.parsedUrl),t,{signal:e,query:this._getQueryParams()}).then((e=>(this._set("serviceRasterInfo",e),this._set("multidimensionalInfo",e.multidimensionalInfo),_e(e,t),e))),i=this._hasRasterFunction(this.rasterFunction)?this._generateRasterInfo(this.rasterFunction,{signal:e}):null,s=this._getRasterFunctionInfos();return Promise.all([r,i,s]).then((e=>{e[1]?this._set("rasterInfo",e[1]):this._set("rasterInfo",e[0]),e[2]&&this._set("rasterFunctionInfos",e[2]),this.renderer&&!this._isSupportedRenderer(this.renderer)&&(this._set("renderer",null),u.getLogger(this).warn("ArcGISImageService","Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")),this._set("renderer",this._configRenderer(this.renderer)),this.addHandles([p((()=>this.rasterFunction),(e=>{(this.renderer||this.symbolizer||this.popupEnabled&&this.popupTemplate)&&this._generateRasterInfo(e).then((e=>{e&&(this.rasterInfo=e)}))}))]);const{serviceRasterInfo:t}=this;null!=t.multidimensionalInfo&&this._updateMultidimensionalDefinition(t)}))}_combineMosaicRuleWithTimeExtent(e,t){const r=this.timeInfo,{multidimensionalInfo:i}=this.serviceRasterInfo;if(null==e||null==i||null==t||null==r?.startField)return e;const{startField:s}=r,n=i.variables.some((e=>e.dimensions.some((e=>e.name===s))))?s:"StdTime";if(e=e.clone(),"mosaic-dataset"===this.sourceType)return e.multidimensionalDefinition=e.multidimensionalDefinition?.filter((e=>e.dimensionName!==n)),this._cleanupMultidimensionalDefinition(e);e.multidimensionalDefinition=e.multidimensionalDefinition||[];const a=e.multidimensionalDefinition.filter((e=>e.dimensionName===n)),o=null!=t.start?t.start.getTime():null,l=null!=t.end?t.end.getTime():null,u=null==o||null==l||o===l,p=u?[o||l]:[[o,l]],m=this.version>=10.8;if(a.length)a.forEach((e=>{e.dimensionName===n&&(m?(e.dimensionName=null,e.isSlice=!1,e.values=[]):(e.isSlice=u,e.values=p))}));else if(!m){const t=e.multidimensionalDefinition.filter((e=>null!=e.variableName&&null==e.dimensionName));t.length?t.forEach((e=>{e.dimensionName=n,e.isSlice=u,e.values=p})):e.multidimensionalDefinition.push(new S({variableName:"",dimensionName:n,isSlice:u,values:p}))}return this._cleanupMultidimensionalDefinition(e)}_cleanupMultidimensionalDefinition(e){return null==e?null:(e.multidimensionalDefinition&&(e.multidimensionalDefinition=e.multidimensionalDefinition.filter((e=>!(!e.variableName&&!e.dimensionName))),0===e.multidimensionalDefinition.length&&(e.multidimensionalDefinition=null)),"mosaic-dataset"!==this.sourceType&&null==e.multidimensionalDefinition?null:e)}async _prepareForQuery(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQuery)throw new o("imagery-layer:query-rasters","query operation is not supported on the input image service");return e=null!=e?g(Ie,e):this.createQuery(),t=this._getRequestOptions(t),this.raster&&(t.query={...t.query,raster:this.raster}),{query:e,requestOptions:t}}async _initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const e=new E;this._rasterJobHandler.connectionPromise=e.initialize().then((()=>{this._rasterJobHandler.instance=e}),(()=>{})),await this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null}_isSupportedRenderer(e){const{rasterInfo:t,rasterFunction:r}=this;return"unique-value"===e.type&&this._hasRasterFunction(r)&&1===t?.bandCount&&["u8","s8"].includes(t.pixelType)||null!=t&&null!=e&&L(t).includes(e.type)}async _fetchCapabilities(e){return this.capabilities||await this._fetchServiceInfo(e),this.capabilities}async _fetchServiceInfo(e){let t=this.sourceJSON;if(!t){const{data:r,ssl:i}=await n(We(this.parsedUrl),{query:this._getQueryParams(),signal:e});t=r,this.sourceJSON=t,i&&(this.url=this.url.replace(/^http:/i,"https:"))}if(t.capabilities?.toLowerCase().split(",").map((e=>e.trim())).indexOf("tilesonly")>-1)throw new o("imagery-layer:fetch-service-info","use ImageryTileLayer to open tiles-only image services");this.read(t,{origin:"service",url:this.parsedUrl})}_isMosaicDataset(e){return e.serviceSourceType?"esriImageServiceSourceTypeMosaicDataset"===e.serviceSourceType:e.fields?.length>0}_isMosaicRuleSupported(e){if(!e)return!1;const t=this._isMosaicDataset(e),r=e.currentVersion>=10.71&&e.hasMultidimensions&&!(e.fields?.length>1);return t||r}_isVectorFieldResampleFunction(e){if(null==e)return!1;const{functionName:t,functionArguments:r}=e,i="resample"===t?.toLowerCase(),s=r?.ResampleType||r?.resampleType;return i&&(7===s||10===s)}_isPicture(){return!this.format||this.format.includes("jpg")||this.format.includes("png")}_configRenderer(e){const t=this._isPicture(),{rasterInfo:r}=this;if(!t&&!this.pixelFilter||this._isVectorDataSet()){if(!this.bandIds&&r.bandCount>=3){const e=z(r);!e||3===r.bandCount&&0===e[0]&&1===e[1]&&2===e[2]||(this.bandIds=e)}e||(e=G(r,{bandIds:this.bandIds,variableName:this.rasterFunction?null:this.mosaicRule?.multidimensionalDefinition?.[0].variableName}));const t=k(e.toJSON());this.symbolizer?(this.symbolizer.rendererJSON=t,this.symbolizer.rasterInfo=r):this.symbolizer=new W({rendererJSON:t,rasterInfo:r}),this.symbolizer.bind().success||(this.symbolizer=null)}return e}_clonePixelData(e){return null==e?e:{extent:e.extent&&e.extent.clone(),pixelBlock:null!=e.pixelBlock?e.pixelBlock.clone():null}}_getQueryParams(e){null!=e?.renderingRule&&"string"!=typeof e.renderingRule&&(e.renderingRule=this._getRenderingRuleString(e.renderingRule));const{raster:t,viewId:r}=this;return{raster:t,viewId:r,f:"json",...e,...this.customParameters}}_getRequestOptions(e){return{...e,query:{...e?.query,...this.customParameters}}}_decodePixelBlock(e,t,r){return this._rasterJobHandler.instance?this._rasterJobHandler.instance.decode({data:e,options:t}):H(e,t,r)}async _getRasterFunctionInfos(e){const t=this.sourceJSON.rasterFunctionInfos;if(this.loaded)return t;if(t&&this.version>=10.3){if(1===t.length&&"none"===t[0].name.toLowerCase())return t;const r=await n(We(this.parsedUrl)+"/rasterFunctionInfos",{query:this._getQueryParams(),signal:e});return r.data?.rasterFunctionInfos}return null}_canRequestImageElement(e){return!this.pixelFilter&&(!e||e.includes("png"))}async _requestArrayBuffer(e){const{imageProps:t,requestAsImageElement:r,returnImageBitmap:i,signal:s}=e;if(r&&this._canRequestImageElement(t.format)){const r=`${We(this.parsedUrl)}/exportImage`,{data:a}=await n(r,{responseType:i?"blob":"image",query:this._getQueryParams({f:"image",...this.refreshParameters,...e.imageServiceParameters}),signal:s});if(a instanceof Blob){return{imageBitmap:await D(a,r,s),params:t}}return{imageOrCanvasElement:a,params:t}}const a=this._initJobHandler(),l=n(We(this.parsedUrl)+"/exportImage",{responseType:"array-buffer",query:this._getQueryParams({f:"image",...e.imageServiceParameters}),signal:s}),u=(await Promise.all([l,a]))[0].data,p=t.format||"jpgpng";let m=p;if("bsq"!==m&&"bip"!==m&&(m=U(u)),!m)throw new o("imagery-layer:fetch-image","unsupported format signature "+String.fromCharCode.apply(null,new Uint8Array(u)));const c={signal:s},d="gif"===p||"bmp"===p||p.includes("png")&&("png"===m||"jpg"===m)?H(u,{useCanvas:!0,...t},c):this._decodePixelBlock(u,{width:t.width,height:t.height,planes:null,pixelType:null,noDataValue:null,format:p},c);return{pixelData:{pixelBlock:await d,extent:t.extent},params:t}}_generateRasterInfo(e,t){return this.generateRasterInfo(e,t).catch((()=>null))}_isValidCustomizedMosaicRule(e){return e&&JSON.stringify(e.toJSON())!==JSON.stringify(this.defaultMosaicRule?.toJSON())}_updateMultidimensionalDefinition(e){if(this._isValidCustomizedMosaicRule(this.mosaicRule))return;let t=Q(e,{multidimensionalSubset:this.multidimensionalSubset});if(null!=t&&t.length>0){this.mosaicRule=this.mosaicRule||new P;const e=this.mosaicRule.multidimensionalDefinition;!this.sourceJSON.defaultVariableName&&this.rasterFunction&&"none"!==this.rasterFunction.functionName?.toLowerCase()&&t.forEach((e=>e.variableName="")),t=t.filter((({variableName:e,dimensionName:t})=>e&&"*"!==e||t)),!e?.length&&t.length&&(this.mosaicRule.multidimensionalDefinition=t)}}_processVisibleRastersResponse(e,r){r=r||{};const i=e.value,{templateRRFunctionNames:s,showNoDataRecords:n,returnDomainValues:a,templateFields:o}=r,l=e.processedValues;let u=e.catalogItems?.features,p=e.properties?.Values?.map((e=>e.replaceAll(/ /gi,", ")))||[];const m=this.objectIdField||"ObjectId",c="string"==typeof i&&i.toLowerCase().includes("nodata"),d=[];if(i&&!u&&!c){const e={};e[m]=0;p=[i],u=[new t(this.fullExtent,null,e)]}if(!u)return[];let h,g,f;this._updateResponseFieldNames(u,o),c&&!n&&(u=[]);for(let t=0;t<u.length;t++){if(h=u[t],null!=i){if(g=p[t],f=this.rasterFunction&&l&&l.length>0&&s&&s.length>0&&s.includes(this.rasterFunction.functionName)?l[s.indexOf(this.rasterFunction.functionName)]:i,"nodata"===g.toLowerCase()&&!n)continue;const e="Raster.ItemPixelValue",r="Raster.ServicePixelValue";h.attributes[e]=g,h.attributes[r]=f,this._updateFeatureWithMagDirValues(h,g);const a=this.fields&&this.fields.length>0;let o=this.rasterFunction&&null!=this.serviceRasterInfo.attributeTable?a?g:i:f;this.rasterFunction||(o=a?g:i),this._updateFeatureWithRasterAttributeTableValues(h,o)}if(h.sourceLayer=h.layer=this,a&&this._updateFeatureWithDomainValues(h),s&&l&&s.length===l.length)for(let e=0;e<s.length;e++){const t="Raster.ServicePixelValue."+s[e];h.attributes[t]=l[e]}d.push(u[t])}return d}_processMultidimensionalIntersection(e,t,r){const{multidimensionalSubset:i}=this;if(!i)return{isOutSide:!1,timeExtent:t,mosaicRule:r=this._combineMosaicRuleWithTimeExtent(r,t)};if(i){const{isOutside:r,intersection:s}=J(i,{geometry:e,timeExtent:t});if(r)return{isOutSide:!0,timeExtent:null,mosaicRule:null};null!=s?.timeExtent&&(t=s.timeExtent)}if(r=this._combineMosaicRuleWithTimeExtent(r,t),r?.multidimensionalDefinition){const{isOutside:e}=J(i,{multidimensionalDefinition:r.multidimensionalDefinition});if(e)return{isOutSide:!0,timeExtent:null,mosaicRule:null}}return{isOutSide:!1,timeExtent:t,mosaicRule:r}}_updateFeatureWithRasterAttributeTableValues(e,t){const r=this.rasterInfo.attributeTable||this.serviceRasterInfo.attributeTable;if(null==r)return;const{features:i,fields:s}=r,n=s.map((e=>e.name)).find((e=>"value"===e.toLowerCase()));if(!n)return;const a=i.filter((e=>e.attributes[n]===(null!=t?parseInt(t,10):null)));a&&a[0]&&s.forEach((t=>{const r=this._rasterAttributeTableFieldPrefix+t.name;e.attributes[r]=a[0].attributes[t.name]}))}_updateFeatureWithMagDirValues(e,t){if(!this._isVectorDataSet())return;const r=t.split(/,\s*/).map((e=>parseFloat(e))),i=r.map((e=>[e])),s=r.map((e=>({minValue:e,maxValue:e,noDataValue:null}))),n=new O({height:1,width:1,pixelType:"f32",pixels:i,statistics:s});null!=this.pixelFilter&&this.pixelFilter({pixelBlock:n,extent:new fe(0,0,0,0,this.spatialReference)});const a="esriImageServiceDataTypeVector-MagDir"===this.serviceDataType?[n.pixels[0][0],n.pixels[1][0]]:B([n.pixels[0][0],n.pixels[1][0]]);e.attributes["Raster.Magnitude"]=a[0],e.attributes["Raster.Direction"]=a[1]}_updateFeatureWithDomainValues(e){const t=this.fields&&this.fields.filter((e=>e.domain&&"coded-value"===e.domain.type));null!=t&&t.forEach((t=>{const r=e.attributes[t.name];if(null!=r){const i=t.domain.codedValues.find((e=>e.code===r));i&&(e.attributes[t.name]=i.name)}}))}_updateResponseFieldNames(e,t){if(!t||t.length<1)return;const r=this.fieldsIndex;null!=r&&e.forEach((e=>{if(e?.attributes)for(const i of t){const t=r.get(i)?.name;t&&t!==i&&(e.attributes[i]=e.attributes[t],delete e.attributes[t])}}))}_getRenderingRuleString(e){if(e){let t=e.toJSON();return t=t.rasterFunctionDefinition??t,(t.thumbnail||t.thumbnailEx)&&(t.thumbnail=t.thumbnailEx=null),JSON.stringify(t)}return null}_hasRasterFunction(e){return null!=e?.functionName&&"none"!==e.functionName.toLowerCase()}_updateRenderingRulesFunctionName(e,t){if(!e||e.length<1)return;if("Raw"===e)return e.replace("Raw","None");const r=e.toLowerCase().replaceAll(/ /gi,"_");return t.has(r)?t.get(r):e}_isRFTJson(e){return e?.name&&e.arguments&&e.function&&e.hasOwnProperty("functionType")}_isVectorDataSet(){return"esriImageServiceDataTypeVector-UV"===this.serviceDataType||"esriImageServiceDataTypeVector-MagDir"===this.serviceDataType}_applyMosaicAndRenderingRules(e){const{raster:t,mosaicRule:r,rasterFunction:i}=this;i&&e instanceof Ne&&null==e.rasterFunction&&(e.rasterFunction=i),r&&null==e.mosaicRule&&(e.mosaicRule=r),t&&null==e.raster&&(e.raster=t)}_readCapabilities(e){const t=e.capabilities?e.capabilities.toLowerCase().split(",").map((e=>e.trim())):["image","catalog"],{currentVersion:r,advancedQueryCapabilities:i,maxRecordCount:s}=e,n=t.includes("image"),a="esriImageServiceDataTypeElevation"===e.serviceDataType,o=!(!e.spatialReference&&!e.extent?.spatialReference),l=t.includes("edit"),u=t.includes("mensuration")&&o,p=null==e.mensurationCapabilities?[]:e.mensurationCapabilities.toLowerCase().split(",").map((e=>e.trim())),m=u&&p.includes("basic"),c=this._isMosaicDataset(e)&&t.includes("catalog"),d=t.includes("download");return{data:{supportsAttachment:!1},operations:{supportsComputeHistograms:n,supportsExportImage:n,supportsIdentify:n,supportsImageToMap:r>=11.2&&c,supportsImageToMapMultiray:r>=11.2&&c,supportsMapToImage:r>=11.2&&c,supportsFindImages:r>=11.2&&c,supportsGetImageUrl:r>=11.2&&d,supportsMeasure:u,supportsMeasureFromImage:r>=11.2,supportsDownload:d,supportsQuery:c&&e.fields&&e.fields.length>0,supportsGetSamples:r>=10.2&&n,supportsProject:r>=10.3&&n,supportsComputeStatisticsHistograms:r>=10.4&&n,supportsQueryBoundary:r>=10.6&&n,supportsCalculateVolume:r>=10.7&&a,supportsComputePixelLocation:r>=10.7&&c,supportsComputeAngles:r>=10.91,supportsQueryGPSInfo:r>=11.2&&c,supportsAdd:l,supportsDelete:l,supportsEditing:l,supportsUpdate:l,supportsCalculate:!1,supportsTruncate:!1,supportsValidateSql:!1,supportsChangeTracking:!1,supportsQueryAttachments:!1,supportsResizeAttachments:!1,supportsSync:!1,supportsExceedsLimitStatistics:!1,supportsQueryAnalytics:!1,supportsQueryTopFeatures:!1,supportsAsyncConvert3D:!1},query:{maxRecordCount:s,maxRecordCountFactor:void 0,supportsStatistics:!!i?.supportsStatistics,supportsOrderBy:!!i?.supportsOrderBy,supportsDistinct:!!i?.supportsDistinct,supportsPagination:!!i?.supportsPagination,supportsStandardizedQueriesOnly:!!i?.useStandardizedQueries,supportsPercentileStatistics:!!i?.supportsPercentileStatistics,supportsCentroid:!!i?.supportsReturningGeometryCentroid,supportsDistance:!!i?.supportsQueryWithDistance,supportsExtent:!!i?.supportsReturningQueryExtent,supportsGeometryProperties:!!i?.supportsReturningGeometryProperties,supportsHavingClause:!!i?.supportsHavingClause,supportsQuantization:!1,supportsQuantizationEditMode:!1,supportsQueryGeometry:!1,supportsResultType:!1,supportsMaxRecordCountFactor:!1,supportsSqlExpression:!1,supportsTopFeaturesQuery:!1,supportsQueryByAnonymous:!1,supportsQueryByOthers:!1,supportsHistoricMoment:!1,supportsFormatPBF:!1,supportsDisjointSpatialRelationship:!1,supportsCacheHint:!1,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsDefaultSpatialReference:!!i?.supportsDefaultSR,supportsFullTextSearch:!1,supportsCompactGeometry:!1,standardMaxRecordCount:void 0,tileMaxRecordCount:void 0},mensuration:{supportsDistanceAndAngle:m,supportsAreaAndPerimeter:m,supportsPointOrCentroid:m,supportsHeightFromBaseAndTop:u&&p.includes("base-top height"),supportsHeightFromBaseAndTopShadow:u&&p.includes("base-top shadow height"),supportsHeightFromTopAndTopShadow:u&&p.includes("top-top shadow height"),supports3D:u&&p.includes("3d")}}}};function We(e){return e?.path??""}return e([c({clonable:!1})],f.prototype,"_functionRasterInfos",void 0),e([c({clonable:!1})],f.prototype,"_rasterJobHandler",void 0),e([c({clonable:!1})],f.prototype,"_cachedRendererJson",void 0),e([c({readOnly:!0})],f.prototype,"_serviceSupportsMosaicRule",void 0),e([y("_serviceSupportsMosaicRule",["currentVersion","fields"])],f.prototype,"readServiceSupportsMosaicRule",null),e([c({readOnly:!0})],f.prototype,"_rasterAttributeTableFieldPrefix",void 0),e([c({readOnly:!0})],f.prototype,"_rasterFunctionNamesIndex",null),e([c()],f.prototype,"adjustAspectRatio",void 0),e([c({type:[h],json:{write:!0}})],f.prototype,"bandIds",void 0),e([y("bandIds")],f.prototype,"readBandIds",null),e([c({readOnly:!0,json:{read:!1}})],f.prototype,"capabilities",void 0),e([y("service","capabilities",["capabilities","currentVersion","serviceDataType"])],f.prototype,"readCapabilities",null),e([c({type:Number})],f.prototype,"compressionQuality",void 0),e([b("compressionQuality")],f.prototype,"writeCompressionQuality",null),e([c({type:Number})],f.prototype,"compressionTolerance",void 0),e([b("compressionTolerance")],f.prototype,"writeCompressionTolerance",null),e([c({json:{read:{source:"copyrightText"}}})],f.prototype,"copyright",void 0),e([c({readOnly:!0,dependsOn:["_serviceSupportsMosaicRule"]})],f.prototype,"defaultMosaicRule",void 0),e([y("defaultMosaicRule",["defaultMosaicMethod"])],f.prototype,"readDefaultMosaicRule",null),e([c({type:String,json:{name:"layerDefinition.definitionExpression",write:{enabled:!0,allowNull:!0}}})],f.prototype,"definitionExpression",void 0),e([c({readOnly:!0,constructOnly:!0})],f.prototype,"exportImageServiceParameters",void 0),e([c()],f.prototype,"rasterInfo",void 0),e([c({readOnly:!0,type:[_]})],f.prototype,"fields",void 0),e([c({readOnly:!0})],f.prototype,"fieldsIndex",null),e([c({type:["png","png8","png24","png32","jpg","bmp","gif","jpgpng","lerc","tiff"],json:{write:!0}})],f.prototype,"format",null),e([y("service","format",["serviceDataType"])],f.prototype,"readFormat",null),e([c({type:fe})],f.prototype,"fullExtent",void 0),e([c({readOnly:!0})],f.prototype,"hasMultidimensions",void 0),e([c({json:{read:{source:"maxImageHeight"}}})],f.prototype,"imageMaxHeight",void 0),e([c({json:{read:{source:"maxImageWidth"}}})],f.prototype,"imageMaxWidth",void 0),e([c({type:String,json:{type:M.jsonValues,read:M.read,write:M.write}})],f.prototype,"interpolation",void 0),e([c()],f.prototype,"minScale",void 0),e([y("service","minScale")],f.prototype,"readMinScale",null),e([c()],f.prototype,"maxScale",void 0),e([y("service","maxScale")],f.prototype,"readMaxScale",null),e([c({type:P})],f.prototype,"mosaicRule",null),e([y("mosaicRule",["mosaicRule","defaultMosaicMethod"])],f.prototype,"readMosaicRule",null),e([b("mosaicRule")],f.prototype,"writeMosaicRule",null),e([c()],f.prototype,"multidimensionalInfo",void 0),e([c({type:j,json:{write:!0}})],f.prototype,"multidimensionalSubset",void 0),e([c({json:{type:h}})],f.prototype,"noData",void 0),e([b("noData")],f.prototype,"writeNoData",null),e([c({type:String,json:{type:C.jsonValues,read:C.read,write:C.write}})],f.prototype,"noDataInterpretation",void 0),e([c({type:String,readOnly:!0,json:{read:{source:["fields"]}}})],f.prototype,"objectIdField",void 0),e([y("objectIdField")],f.prototype,"readObjectIdField",null),e([c({readOnly:!0})],f.prototype,"geometryType",void 0),e([c({})],f.prototype,"typeIdField",void 0),e([c({})],f.prototype,"types",void 0),e([c({readOnly:!0})],f.prototype,"parsedUrl",null),e([c({type:Function})],f.prototype,"pixelFilter",void 0),e([c()],f.prototype,"raster",void 0),e([c({readOnly:!0})],f.prototype,"sourceType",void 0),e([y("sourceType",["serviceSourceType","fields"])],f.prototype,"readSourceType",null),e([c()],f.prototype,"viewId",void 0),e([c({types:r,json:{name:"layerDefinition.drawingInfo.renderer",origins:{"web-scene":{types:i,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],f.prototype,"renderer",null),e([y("renderer")],f.prototype,"readRenderer",null),e([b("renderer")],f.prototype,"writeRenderer",null),e([c({clonable:!1})],f.prototype,"symbolizer",void 0),e([c(w)],f.prototype,"opacity",void 0),e([c({readOnly:!0})],f.prototype,"rasterFields",null),e([c({constructOnly:!0})],f.prototype,"rasterFunctionInfos",void 0),e([c({type:q})],f.prototype,"renderingRule",null),e([c({type:q,json:{name:"renderingRule"}})],f.prototype,"rasterFunction",null),e([y("rasterFunction",["renderingRule","rasterFunctionInfos"])],f.prototype,"readRasterFunction",null),e([c({readOnly:!0})],f.prototype,"serviceDataType",void 0),e([c({readOnly:!0,type:Re})],f.prototype,"spatialReference",void 0),e([y("spatialReference",["spatialReference","extent"])],f.prototype,"readSpatialReference",null),e([c({json:{type:N.jsonValues}})],f.prototype,"pixelType",void 0),e([y("pixelType")],f.prototype,"readPixelType",null),e([b("pixelType")],f.prototype,"writePixelType",null),e([c({constructOnly:!0,type:A})],f.prototype,"serviceRasterInfo",void 0),e([c()],f.prototype,"sourceJSON",void 0),e([c(v)],f.prototype,"url",void 0),e([c({readOnly:!0})],f.prototype,"version",void 0),e([y("version",["currentVersion","fields","timeInfo"])],f.prototype,"readVersion",null),f=e([R("esri.layers.mixins.ArcGISImageService")],f),f};export{We as ArcGISImageService};
