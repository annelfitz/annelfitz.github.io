/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import e from"../../../core/Error.js";import{property as r}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/Logger.js";import"../../../core/RandomLCG.js";import{subclass as s}from"../../../core/accessorSupport/decorators/subclass.js";import o from"../PixelBlock.js";import i from"../RasterInfo.js";import a from"../RasterStorageInfo.js";import n from"./BaseRaster.js";import{parseSpatialReference as l,parsePAMInfo as f}from"./pamParser.js";import{getElement as c,getElementValue as m}from"./xmlUtilities.js";import{isPlatformLittleEndian as p}from"../rasterFormats/utils.js";import{estimateStatisticsFromHistograms as h}from"../rasterFunctions/stretchUtils.js";import u from"../../../geometry/SpatialReference.js";import g from"../../../geometry/Extent.js";import d from"../../../geometry/Point.js";const y=new Map;y.set("Int8","s8"),y.set("UInt8","u8"),y.set("Int16","s16"),y.set("UInt16","u16"),y.set("Int32","s32"),y.set("UInt32","u32"),y.set("Float32","f32"),y.set("Float64","f32"),y.set("Double64","f32");const x=new Map;x.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),x.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),x.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),x.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let w=class extends n{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(t){await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const e=t?t.signal:null,r=await this.request(this.url,{responseType:"xml",signal:e}),{rasterInfo:s,files:o}=this._parseHeader(r.data),{skipMapInfo:i,skipExtensions:a=[]}=this.ioConfig;if(!a.includes("aux.xml")&&!i){const e=await this._fetchAuxiliaryData(t);null!=e&&(s.statistics=e.statistics??s.statistics,s.histograms=e.histograms,e.histograms&&null==s.statistics&&(s.statistics=h(e.histograms)))}i&&this.updateImageSpaceRasterInfo(s),this._set("rasterInfo",s),this._files=o;const n=await this.request(o.index,{responseType:"array-buffer",signal:e});this._storageIndex=I(n.data);const{blockWidth:l,blockHeight:f}=this.rasterInfo.storageInfo,c=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:m,height:p}=this.rasterInfo,u=[],g=this._getBandSegmentCount();let d=0,y=-1;for(;d<this._storageIndex.length;){y++;const t=Math.ceil(m/l/c**y)-1,e=Math.ceil(p/f/c**y)-1;d+=(t+1)*(e+1)*g*4,u.push({maxRow:e,maxCol:t,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=u,y>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=y),this.updateTileInfo()}async fetchRawTile(t,e,r,s={}){const{blockWidth:i,blockHeight:a,blockBoundary:n}=this.rasterInfo.storageInfo,l=n[t];if(!l||l.maxRow<e||l.maxCol<r||l.minRow>e||l.minCol>r)return null;const{bandCount:f,pixelType:c}=this.rasterInfo,{ranges:m,actualTileWidth:p,actualTileHeight:h}=this._getTileLocation(t,e,r);if(!m||0===m.length)return null;if(0===m[0].from&&0===m[0].to){const t=new Uint8Array(i*a);return new o({width:i,height:a,pixels:void 0,mask:t,validPixelCount:0})}const{bandIds:u}=this.ioConfig,g=this._getBandSegmentCount(),d=[];let y=0;for(y=0;y<g;y++)u&&!u.includes(y)||d.push(this.request(this._files.data,{range:{from:m[y].from,to:m[y].to},responseType:"array-buffer",signal:s.signal}));const w=await Promise.all(d),I=w.map((t=>t.data.byteLength)).reduce(((t,e)=>t+e)),b=new Uint8Array(I),R=[];let A=0;for(y=0;y<g;y++)R.push(A),b.set(new Uint8Array(w[y].data),A),A+=w[y].data.byteLength;const F=x.get(this.rasterInfo.storageInfo.compression).decoderFormat,S=await this.decodePixelBlock(b.buffer,{width:i,height:a,format:F,planes:u?.length||f,offsets:R,pixelType:c});if(null==S)return null;let{noDataValue:_}=this.rasterInfo;if(null!=_&&"lerc"!==F&&!S.mask&&(_=_[0],null!=_)){const t=S.width*S.height,e=new Uint8Array(t);if(Math.abs(_)>1e24)for(y=0;y<t;y++)Math.abs((S.pixels[0][y]-_)/_)>1e-6&&(e[y]=1);else for(y=0;y<t;y++)S.pixels[0][y]!==_&&(e[y]=1);S.mask=e}let k=0,M=0;if(p!==i||h!==a){let t=S.mask;if(t)for(y=0;y<a;y++)if(M=y*i,y<h)for(k=p;k<i;k++)t[M+k]=0;else for(k=0;k<i;k++)t[M+k]=0;else for(t=new Uint8Array(i*a),S.mask=t,y=0;y<h;y++)for(M=y*i,k=0;k<p;k++)t[M+k]=1}return S}_getBandSegmentCount(){return x.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(t,e,r){const{blockWidth:s,blockHeight:o,pyramidScalingFactor:i}=this.rasterInfo.storageInfo,{width:a,height:n}=this.rasterInfo,l=this._getBandSegmentCount();let f,c,m,p=0,h=0;for(m=0;m<t;m++)h=i**m,f=Math.ceil(a/s/h),c=Math.ceil(n/o/h),p+=f*c;h=i**t,f=Math.ceil(a/s/h),c=Math.ceil(n/o/h),p+=e*f+r,p*=4*l;const u=this._storageIndex.subarray(p,p+4*l);let g=0,d=0;const y=[];for(let x=0;x<l;x++)g=u[4*x]*2**32+u[4*x+1],d=g+u[4*x+2]*2**32+u[4*x+3],y.push({from:g,to:d});return{ranges:y,actualTileWidth:r<f-1?s:Math.ceil(a/h)-s*(f-1),actualTileHeight:e<c-1?o:Math.ceil(n/h)-o*(c-1)}}_parseHeader(t){const r=c(t,"MRF_META/Raster");if(!r)throw new e("mrf:open","not a valid MRF format");const s=c(r,"Size"),o=parseInt(s.getAttribute("x"),10),n=parseInt(s.getAttribute("y"),10),f=parseInt(s.getAttribute("c"),10),p=(m(r,"Compression")||"none").toLowerCase();if(!x.has(p))throw new e("mrf:open","currently does not support compression "+p);const h=m(r,"DataType")||"UInt8",w=y.get(h);if(null==w)throw new e("mrf:open","currently does not support pixel type "+h);const I=c(r,"PageSize"),b=parseInt(I.getAttribute("x"),10),R=parseInt(I.getAttribute("y"),10),A=c(r,"DataValues");let F,S;A&&(S=A.getAttribute("NoData"),null!=S&&(F=S.trim().split(" ").map((t=>parseFloat(t)))));if(c(t,"MRF_META/CachedSource"))throw new e("mrf:open","currently does not support MRF referencing other data files");const _=c(t,"MRF_META/GeoTags"),k=c(_,"BoundingBox");let M,j=!1;if(null!=k){const t=parseFloat(k.getAttribute("minx")),e=parseFloat(k.getAttribute("miny")),r=parseFloat(k.getAttribute("maxx")),s=parseFloat(k.getAttribute("maxy")),o=m(_,"Projection")||"";let i=u.WGS84;if("LOCAL_CS[]"!==o)if(o.toLowerCase().startsWith("epsg:")){const t=Number(o.slice(5));isNaN(t)||0===t||(i=new u({wkid:t}))}else i=l(o)??u.WGS84;else j=!0,i=new u({wkid:3857});M=new g(t,e,r,s),M.spatialReference=i}else j=!0,M=new g({xmin:-.5,ymin:.5-n,xmax:o-.5,ymax:.5,spatialReference:new u({wkid:3857})});const C=c(t,"MRF_META/Rsets"),T=parseInt(C?.getAttribute("scale")||"2",10),L=M.spatialReference,U=new a({origin:new d({x:M.xmin,y:M.ymax,spatialReference:L}),blockWidth:b,blockHeight:R,pyramidBlockWidth:b,pyramidBlockHeight:R,compression:p,pyramidScalingFactor:T}),B=new d({x:M.width/o,y:M.height/n,spatialReference:L}),E=new i({width:o,height:n,extent:M,isPseudoSpatialReference:j,spatialReference:L,bandCount:f,pixelType:w,pixelSize:B,noDataValue:F,storageInfo:U}),P=m(t,"datafile"),W=m(t,"IndexFile");return{rasterInfo:E,files:{mrf:this.url,index:W||this.url.replace(".mrf",".idx"),data:P||this.url.replace(".mrf",x.get(p).blobExtension)}}}async _fetchAuxiliaryData(t){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:t?.signal});return f(e)}catch{return null}}};function I(t){if(t.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let e,r,s,o,i,a;if(p){for(r=new Uint8Array(t),o=new ArrayBuffer(t.byteLength),s=new Uint8Array(o),i=0;i<t.byteLength/4;i++)for(a=0;a<4;a++)s[4*i+a]=r[4*i+3-a];e=new Uint32Array(o)}else e=new Uint32Array(t);return e}t([r()],w.prototype,"_files",void 0),t([r()],w.prototype,"_storageIndex",void 0),t([r({type:String,json:{write:!0}})],w.prototype,"datasetFormat",void 0),w=t([s("esri.layers.support.rasterDatasets.MRFRaster")],w);const b=w;export{b as default};
