/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import t from"../../../core/Error.js";import e from"./CloudRaster.js";import r from"./CovJSONRaster.js";import s from"./ImageAuxRaster.js";import o from"./ImageServerRaster.js";import a from"./InMemoryRaster.js";import c from"./MRFRaster.js";import n from"./TIFFRaster.js";const u=new Map;u.set("CRF",{desc:"Cloud Raster Format",constructor:e}),u.set("MRF",{desc:"Meta Raster Format",constructor:c}),u.set("TIFF",{desc:"GeoTIFF",constructor:n}),u.set("RasterTileServer",{desc:"Raster Tile Server",constructor:o}),u.set("JPG",{desc:"JPG Raster Format",constructor:s}),u.set("PNG",{desc:"PNG Raster Format",constructor:s}),u.set("GIF",{desc:"GIF Raster Format",constructor:s}),u.set("BMP",{desc:"BMP Raster Format",constructor:s}),u.set("CovJSON",{desc:"COVJSON Raster Format",constructor:r}),u.set("MEMORY",{desc:"In Memory Raster Format",constructor:a});class l{static get supportedFormats(){const t=new Set;return u.forEach(((e,r)=>t.add(r))),t}static async open(e){const{url:r,ioConfig:s,source:o,sourceJSON:a}=e;let c=e.datasetFormat??s?.datasetFormat;null==c&&(r.includes(".")?c=r.slice(r.lastIndexOf(".")+1).toUpperCase():"coverage"===o?.type?.toLowerCase()?c="CovJSON":o?.extent&&o.pixelblocks&&(c="MEMORY")),"OVR"===c||"TIF"===c?c="TIFF":"JPG"===c||"JPEG"===c||"JFIF"===c?c="JPG":"COVJSON"===c&&(c="CovJSON"),r.toLowerCase().includes("/imageserver")&&!r.toLowerCase().includes("/wcsserver")&&(c="RasterTileServer");const n={url:r,source:o,sourceJSON:a,datasetFormat:c,ioConfig:s??{bandIds:null,sampling:null}};if(Object.keys(n).forEach((t=>{null==n[t]&&delete n[t]})),c){if(!this.supportedFormats.has(c))throw new t("rasterfactory:open","not a supported format "+c);if("CRF"===c&&!s?.enableCRF)throw new t("rasterfactory:open",`cannot open raster: ${r}`);const o=new(0,u.get(c).constructor)(n);return await o.open({signal:e.signal}),o}const l=Array.from(u.keys()).filter((t=>"CovJSON"!==t&&"Memory"!==t));let i=0;const m=()=>{if(c=l[i++],!c)return null;if("CRF"===c&&!s?.enableCRF)return null;const t=new(0,u.get(c).constructor)(n);return t.open({signal:e.signal}).then((()=>t)).catch((()=>m()))};return m()}static register(t,e,r){u.has(t.toUpperCase())||u.set(t.toUpperCase(),{desc:e,constructor:r})}}export{l as default};
