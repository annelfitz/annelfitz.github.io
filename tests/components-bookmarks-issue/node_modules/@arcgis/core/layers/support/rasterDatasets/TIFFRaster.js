/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import{isSome as t}from"../../../core/arrayUtils.js";import r from"../../../core/Error.js";import i from"../../../core/Logger.js";import{property as s}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import{subclass as a}from"../../../core/accessorSupport/decorators/subclass.js";import n from"../RasterInfo.js";import o from"../RasterStorageInfo.js";import f from"./BaseRaster.js";import l from"./DBFParser.js";import{parsePAMInfo as u,parseSpatialReference as p}from"./pamParser.js";import{parseSignature as c,getPyramidIFDs as h,getMaskIFDs as m,parseIFD as d,parseFieldValues as y,isBSQConfig as g,getImageInfo as T}from"../rasterFormats/TiffDecoder.js";import x from"../rasterFormats/TiffTags.js";import{estimateStatisticsFromHistograms as w}from"../rasterFunctions/stretchUtils.js";import I from"../rasterTransforms/PolynomialTransform.js";import R from"../../../rest/support/FeatureSet.js";import b from"../../../geometry/SpatialReference.js";import E from"../../../geometry/Extent.js";import S from"../../../geometry/Point.js";const _=(e,t)=>e.get(t)?.values,F=(e,t)=>e.get(t)?.values?.[0];let v=class extends f{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this.datasetFormat="TIFF"}async open(e){await this.init();const t=e?e.signal:null,{data:s}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:t});if(!s)throw new r("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1,this.url.lastIndexOf("."));const{littleEndian:a,firstIFDPos:n,isBigTiff:o}=c(s),f=[];await this._readIFDs(f,s,a,n,0,o?8:4,t);const{imageInfo:l,rasterInfo:u}=k(f),p=h(f),d=m(f);if(this._headerInfo={littleEndian:a,isBigTiff:o,ifds:f,pyramidIFDs:p,maskIFDs:d,...l},this._set("rasterInfo",u),!l.isSupported)throw new r("tiffraster:open","this tiff is not supported: "+l.message);if(!l.tileWidth)throw new r("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");u.isPseudoSpatialReference&&i.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");const y=f[0].get("PREDICTOR")?.values?.[0],g=f[0].get("SAMPLEFORMAT")?.values?.[0];if(3===g&&2===y)throw new r("tiffraster:open","unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");const{skipMapInfo:T,skipExtensions:x=[]}=this.ioConfig;if(!x.includes("aux.xml")&&!T){const t=await this._fetchAuxiliaryMetaData(e);null!=t&&P(t,u)}x.includes("vat.dbf")||1!==u.bandCount||"u8"!==u.pixelType||T||(u.attributeTable=await this._fetchAuxiliaryTable(e),null!=u.attributeTable&&(u.keyProperties.DataType="thematic")),T&&this.updateImageSpaceRasterInfo(u),this.updateTileInfo()}async fetchRawTile(e,t,r,i={}){if(!this._headerInfo?.isSupported||this.isBlockOutside(e,t,r))return null;const s=await this._fetchRawTiffTile(e,t,r,!1,i);if(null!=s&&this._headerInfo.hasMaskBand){const a=await this._fetchRawTiffTile(e,t,r,!0,i);null!=a&&a.pixels[0]instanceof Uint8Array&&(s.mask=a.pixels[0])}return s}async _readIFDs(e,t,r,i,s,a=4,n){if(!i)return null;if(i>=t.byteLength||i<0){t=(await this.request(this.url,{range:{from:i+s,to:i+s+this._bufferSize},responseType:"array-buffer",signal:n})).data,s=i+s,i=0}const o=await this._readIFD(t,r,i,s,x.tiffTags,a,n);if(e.push(o.ifd),!o.nextIFD)return null;await this._readIFDs(e,t,r,o.nextIFD-s,s,a,n)}async _readIFD(e,r,i,s,a=x.tiffTags,n=4,o){if(!e)return null;const f=d(e,r,i,s,a,n);if(f.success){const i=[];if(f.ifd?.forEach((e=>{e.values||i.push(e)})),i.length>0){const a=i.map((e=>e.offlineOffsetSize)).filter(t),n=Math.min.apply(null,a.map((e=>e[0])));if(Math.min.apply(null,a.map((e=>e[0]+e[1])))-n<=this._bufferSize){const{data:t}=await this.request(this.url,{range:{from:n,to:n+this._bufferSize},responseType:"array-buffer",signal:o});e=t,s=n,i.forEach((t=>y(e,r,t,s)))}}if(f.ifd?.has("GEOKEYDIRECTORY")){const t=f.ifd.get("GEOKEYDIRECTORY"),i=t?.values;if(i&&i.length>4){const a=i[0]+"."+i[1]+"."+i[2],n=await this._readIFD(e,r,t.valueOffset+6-s,s,x.geoKeys,2,o);t.data=n.ifd,t.data&&t.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[a]})}}return f}if(f.requiredBufferSize&&f.requiredBufferSize!==e.byteLength){const t=await this.request(this.url,{range:{from:s,to:s+f.requiredBufferSize+4},responseType:"array-buffer",signal:o});return(e=t.data).byteLength<f.requiredBufferSize?null:this._readIFD(e,r,0,s,x.tiffTags,4,o)}}async _fetchRawTiffTile(e,t,r,i,s={}){const a=this._getTileLocation(e,t,r,i);if(!a)return null;const{ranges:n,actualTileWidth:o,actualTileHeight:f,ifd:l}=a,u=n.map((e=>this.request(this.url,{range:e,responseType:"array-buffer",signal:s.signal}))),p=await Promise.all(u),c=p.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t)),h=1===p.length?p[0].data:new ArrayBuffer(c),m=[0],d=[0];if(p.length>1){const e=new Uint8Array(h);for(let t=0,r=0;t<p.length;t++){const i=p[t].data;e.set(new Uint8Array(i),r),m[t]=r,r+=i.byteLength,d[t]=i.byteLength}}const{blockWidth:y,blockHeight:g}=this.getBlockWidthHeight(e),T=await this.decodePixelBlock(h,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:l,offsets:m,sizes:d},width:y,height:g,planes:null,pixelType:null});if(null==T)return null;let x,w,I;if(o!==y||f!==g){let e=T.mask;if(e)for(x=0;x<g;x++)if(I=x*y,x<f)for(w=o;w<y;w++)e[I+w]=0;else for(w=0;w<y;w++)e[I+w]=0;else for(e=new Uint8Array(y*g),T.mask=e,x=0;x<f;x++)for(I=x*y,w=0;w<o;w++)e[I+w]=1}return T}_getTileLocation(e,t,r,i=!1){const{firstPyramidLevel:s,blockBoundary:a}=this.rasterInfo.storageInfo,n=0===e?0:e-(s-1),{_headerInfo:o}=this;if(!o)return null;const f=i?o.maskIFDs[n]:0===n?o?.ifds[0]:o?.pyramidIFDs[n-1];if(!f)return null;const l=g(f,o),u=_(f,"TILEOFFSETS");if(void 0===u)return null;const p=_(f,"TILEBYTECOUNTS"),{minRow:c,minCol:h,maxRow:m,maxCol:d}=a[n];if(t>m||r>d||t<c||r<h)return null;const y=F(f,"IMAGEWIDTH"),T=F(f,"IMAGELENGTH"),x=F(f,"TILEWIDTH"),w=F(f,"TILELENGTH"),I=[];if(l){const{bandCount:e}=this.rasterInfo;for(let i=0;i<e;i++){const e=i*(m+1)*(d+1)+t*(d+1)+r;I[i]={from:u[e],to:u[e]+p[e]-1}}}else{const e=t*(d+1)+r;I.push({from:u[e],to:u[e]+p[e]-1})}for(let g=0;g<I.length;g++)if(null==I[g].from||!I[g].to||I[g].to<0)return null;return{ranges:I,ifd:f,actualTileWidth:r===d&&y%x||x,actualTileHeight:t===m&&T%w||w}}async _fetchAuxiliaryMetaData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e?.signal});return u(t)}catch{return null}}async _fetchAuxiliaryTable(e){try{const{data:t}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:e?.signal}),r=l.parse(t);return r?.recordSet?R.fromJSON(r.recordSet):null}catch{return null}}};function k(e){const t=T(e),{width:r,height:i,tileWidth:s,tileHeight:a,planes:f,pixelType:l,compression:u,firstPyramidLevel:c,maximumPyramidLevel:h,pyramidBlockWidth:m,pyramidBlockHeight:d,tileBoundary:y,affine:g,metadata:x}=t,w=t.extent.spatialReference?.wkt||t.extent.spatialReference?.wkid;let R=p(w),v=!!t.isPseudoGeographic;null==R&&(v=!0,R=new b({wkid:3857}));const k=new E({...t.extent,spatialReference:R}),P=new S(k?{x:k.xmin,y:k.ymax,spatialReference:R}:{x:0,y:0}),D=new o({blockWidth:s,blockHeight:a,pyramidBlockWidth:m,pyramidBlockHeight:d,compression:u,origin:P,firstPyramidLevel:c,maximumPyramidLevel:h,blockBoundary:y}),O=new S({x:(k.xmax-k.xmin)/r,y:(k.ymax-k.ymin)/i,spatialReference:R}),L=x?{BandProperties:x.bandProperties,DataType:x.dataType}:{};let j=null;const B=F(e[0],"PHOTOMETRICINTERPRETATION"),z=_(e[0],"COLORMAP");if(B<=3&&z?.length>3&&z.length%3==0){j=[];const e=z.length/3;for(let t=0;t<e;t++)j.push([t,z[t]>>>8,z[t+e]>>>8,z[t+2*e]>>>8])}const A=new n({width:r,height:i,bandCount:f,pixelType:l,pixelSize:O,storageInfo:D,spatialReference:R,isPseudoSpatialReference:v,keyProperties:L,extent:k,colormap:j,statistics:x?x.statistics:null});return g?.length&&(A.nativeExtent=new E({xmin:-.5,ymin:.5-i,xmax:r-.5,ymax:.5,spatialReference:R}),A.transform=new I({polynomialOrder:1,forwardCoefficients:[g[2]+g[0]/2,g[5]-g[3]/2,g[0],g[3],-g[1],-g[4]]}),A.extent=A.transform.forwardTransform(A.nativeExtent),A.pixelSize=new S({x:(k.xmax-k.xmin)/r,y:(k.ymax-k.ymin)/i,spatialReference:R}),D.origin.x=-.5,D.origin.y=.5),{imageInfo:t,rasterInfo:A}}function P(e,t){if(t.statistics=e.statistics??t.statistics,t.histograms=e.histograms,e.histograms&&null==t.statistics&&(t.statistics=w(e.histograms)),e.transform&&null==t.transform){t.transform=e.transform,t.nativeExtent=t.extent;const r=t.transform.forwardTransform(t.nativeExtent);t.pixelSize=new S({x:(r.xmax-r.xmin)/t.width,y:(r.ymax-r.ymin)/t.height,spatialReference:t.spatialReference}),t.extent=r}t.isPseudoSpatialReference&&e.spatialReference&&(t.spatialReference=e.spatialReference,t.extent.spatialReference=t.nativeExtent.spatialReference=t.storageInfo.origin.spatialReference=t.spatialReference)}e([s()],v.prototype,"_files",void 0),e([s()],v.prototype,"_headerInfo",void 0),e([s()],v.prototype,"_bufferSize",void 0),e([s({type:String,json:{write:!0}})],v.prototype,"datasetFormat",void 0),v=e([a("esri.layers.support.rasterDatasets.TIFFRaster")],v);const D=v;export{D as default};
