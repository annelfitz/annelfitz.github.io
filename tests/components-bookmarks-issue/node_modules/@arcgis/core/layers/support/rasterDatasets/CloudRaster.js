/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import t from"../../../core/Error.js";import{property as r}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/Logger.js";import"../../../core/RandomLCG.js";import{subclass as o}from"../../../core/accessorSupport/decorators/subclass.js";import i from"../LOD.js";import n from"../RasterInfo.js";import s from"../RasterStorageInfo.js";import a from"../TileInfo.js";import l from"./BaseRaster.js";import f from"./DBFParser.js";import{isTransformSupported as c,readTransform as m}from"../rasterTransforms/utils.js";import u from"../../../rest/support/FeatureSet.js";import p from"../../../geometry/SpatialReference.js";import d from"../../../geometry/Extent.js";import h from"../../../geometry/Point.js";const g=new Map;g.set("int16","esriFieldTypeSmallInteger"),g.set("int32","esriFieldTypeInteger"),g.set("int64","esriFieldTypeInteger"),g.set("float32","esriFieldTypeSingle"),g.set("float64","esriFieldTypeDouble"),g.set("text","esriFieldTypeString");const y=8;let x=class extends l{constructor(){super(...arguments),this.storageInfo=null,this.datasetFormat="CRF"}async open(e){await this.init();const{data:r}=await this.request(this.url+"/conf.json",{signal:e?.signal});if(!I(r))throw new t("cloudraster:open","Invalid or unsupported conf.json.");this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const{storageInfo:o,rasterInfo:i}=S(r);if("thematic"===i.dataType){const e=await this._fetchAuxiliaryInformation();i.attributeTable=e}this._set("storageInfo",o),this._set("rasterInfo",i),this.ioConfig.retryCount=this.ioConfig.retryCount||0}async fetchRawTile(e,t,r,o={}){const{transposeInfo:i}=this.rasterInfo.storageInfo,{transposedVariableName:n}=o,s=!(!i||!n),a=s?0:this.rasterInfo.storageInfo.maximumPyramidLevel-e;if(a<0)return null;const l=this._buildCacheFilePath(a,t,r,o.multidimensionalDefinition,n),f=this._getIndexRecordFromBundle(t,r,s),c=await this.request(l,{range:{from:0,to:this.storageInfo.headerSize-1},responseType:"array-buffer",signal:o.signal});if(!c)return null;const m=z(new Uint8Array(c.data),f);if(0===m.recordSize)return null;const u=await this.request(l,{range:{from:m.position,to:m.position+m.recordSize},responseType:"array-buffer",signal:o.signal});if(!u)return null;const[p,d]=this._getTileSize(s);return this.decodePixelBlock(u.data,{width:p,height:d,planes:null,pixelType:null,returnInterleaved:s})}async _fetchAuxiliaryInformation(e){const t=this.request(this.url+"/conf.vat.json",{signal:e}).then((e=>e.data)).catch((()=>null)),r=this.request(this.url+"/conf.vat.dbf",{responseType:"array-buffer",signal:e}).then((e=>e.data)).catch((()=>null)),o=await Promise.all([t,r]);let i;if(o[0]){let e=o[0].fields;const t=o[0].values;if(e&&t){e=e.map((e=>({type:"OID"===e.name?"esriFieldTypeOID":g.get(e.type),name:e.name,alias:e.alias||e.name})));const r=t.map((e=>({attributes:e})));e&&t&&(i={fields:e,features:r})}}if(!i&&o[1]){i=f.parse(o[1]).recordSet}return u.fromJSON(i)}_buildCacheFilePath(e,t,r,o,i){const n=this._getPackageSize(!!i),s=Math.floor(t/n)*n,a=Math.floor(r/n)*n,l="R"+b(s)+"C"+b(a);let f="L";f+=e>=10?e.toString():"0"+e.toString();const{multidimensionalInfo:c}=this.rasterInfo,m=o?.[0];if(null==c||!m)return`${this.url}/_alllayers/${f}/${l}.bundle`;let u="_yxs";if(!i){u=c.variables.find((e=>e.name===m.variableName)).dimensions[0].values.indexOf(m.values[0]).toString(16);const e=4-u.length;for(let t=0;t<e;t++)u="0"+u;u="S"+u}const p=v(i||m.variableName);return`${this.url}/_alllayers/${p}/${u}/${f}/${l}.bundle`}_getPackageSize(e=!1){const{transposeInfo:t}=this.rasterInfo.storageInfo;return e&&null!=t?t.packetSize??0:this.storageInfo.packetSize}_getTileSize(e=!1){const{storageInfo:t}=this.rasterInfo,{transposeInfo:r}=t;return e&&null!=r?r.tileSize:t.tileInfo.size}_getIndexRecordFromBundle(e,t,r=!1){const o=this._getPackageSize(r),i=o*(e%o)+t%o;if(i<0)throw new Error("Invalid level / row / col");return 20+i*this.storageInfo.recordSize+44}};function I(e){const t=["origin","extent","geodataXform","LODInfos","blockWidth","blockHeight","bandCount","pixelType","pixelSizeX","pixelSizeY","format","packetSize"];return e&&"RasterInfo"===e.type&&!t.some((t=>!e[t]))}function S(e){const t=["u1","u2","u4","u8","s8","u16","s16","u32","s32","f32","f64"][e.pixelType],{bandCount:r,colormap:o,blockWidth:l,blockHeight:f,firstPyramidLevel:c,maximumPyramidLevel:m}=e,u=e.statistics?.map((e=>({min:e.min,max:e.max,avg:e.mean,stddev:e.standardDeviation,median:e.median,mode:e.mode}))),g=e.histograms?.[0]?.counts?.length?e.histograms:null,x=e.extent.spatialReference,I=e.geodataXform?.spatialReference,S=new p(x?.wkid||x?.wkt||x?.wkt2?x:I);let v=new d({xmin:e.extent.xmin,ymin:e.extent.ymin,xmax:e.extent.xmax,ymax:e.extent.ymax,spatialReference:S});const z=new h({x:e.pixelSizeX,y:e.pixelSizeY,spatialReference:S}),b=Math.round((v.xmax-v.xmin)/z.x),k=Math.round((v.ymax-v.ymin)/z.y),T=w(e.geodataXform),j=T?v:null;T&&(v=T.forwardTransform(v),z.x=(v.xmax-v.xmin)/b,z.y=(v.ymax-v.ymin)/k);const R=e.properties??{},_=e.format.toLowerCase().replace("cache/",""),C=new h(e.origin.x,e.origin.y,S);let F,P,L,D;if(o?.colors)for(F=[],P=0;P<o.colors.length;P++)L=o.colors[P],D=o.values?o.values[P]:P,F.push([D,255&L,L<<16>>>24,L<<8>>>24,L>>>24]);const M=e.LODInfos,O=[];for(P=0;P<M.levels.length;P++)O.push(new i({level:M.levels[P],resolution:M.resolutions[P],scale:96/.0254*M.resolutions[P]}));const B=new a({dpi:96,lods:O,format:_,origin:C,size:[l,f],spatialReference:S}),$={recordSize:y,packetSize:e.packetSize,headerSize:e.packetSize*e.packetSize*y+64},q=[{maxCol:Math.ceil(b/l)-1,maxRow:Math.ceil(k/f)-1,minCol:0,minRow:0}];let X=2;if(m>0)for(P=0;P<m;P++)q.push({maxCol:Math.ceil(b/X/l)-1,maxRow:Math.ceil(k/X/f)-1,minCol:0,minRow:0}),X*=2;const N=e.mdInfo;let A=null;if(N&&R._yxs){const e=R._yxs;A={packetSize:e.PacketSize,tileSize:[e.TileXSize,e.TileYSize]}}return{storageInfo:$,rasterInfo:new n({width:b,height:k,pixelType:t,bandCount:r,extent:v,nativeExtent:j,transform:T,spatialReference:S,pixelSize:z,keyProperties:R,statistics:u,histograms:g,multidimensionalInfo:N,colormap:F,storageInfo:new s({blockWidth:l,blockHeight:f,pyramidBlockWidth:l,pyramidBlockHeight:f,origin:C,tileInfo:B,transposeInfo:A,firstPyramidLevel:c,maximumPyramidLevel:m,blockBoundary:q})})}}function w(e){if(!c(e))throw new t("cloudraster:open","the data contains unsupported geodata transform types");const r=m(e);if("identity"===r.type)return null;if("polynomial"!==r.type||!r.forwardCoefficients?.length||!r.inverseCoefficients?.length)throw new t("cloudraster:open","the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");return r}function v(e){return""===(e=e.trim())?"_v":e.replaceAll(/[\{|\}\-]/g,"_").replace("\\*","_v")}function z(e,t){const r=e.subarray(t,t+8);let o,i=0;for(o=0;o<5;o++)i|=(255&r[o])<<8*o;const n=0xffffffffff&i;for(i=0,o=5;o<8;o++)i|=(255&r[o])<<8*(o-5);return{position:n,recordSize:0xffffffffff&i}}function b(e){let t=e.toString(16);if(4!==t.length){let e=4-t.length;for(;e-- >0;)t="0"+t}return t}e([r({readOnly:!0})],x.prototype,"storageInfo",void 0),e([r({type:String,json:{write:!0}})],x.prototype,"datasetFormat",void 0),x=e([o("esri.layers.support.rasterDatasets.CloudRaster")],x);const k=x;export{k as default};
