/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import t from"../../../request.js";import i from"../../../core/Error.js";import{JSONSupport as r}from"../../../core/JSONSupport.js";import o from"../../../core/Logger.js";import{EsriPromiseMixin as n}from"../../../core/Promise.js";import{onAbort as s}from"../../../core/promiseUtils.js";import{property as l}from"../../../core/accessorSupport/decorators/property.js";import{ensureClass as a}from"../../../core/accessorSupport/ensureType.js";import"../../../core/RandomLCG.js";import"../../../core/has.js";import{subclass as c}from"../../../core/accessorSupport/decorators/subclass.js";import{sanitizeUrl as m}from"../arcgisLayerUrl.js";import{url as f}from"../commonProperties.js";import u from"../DimensionalDefinition.js";import h from"../LOD.js";import p from"../RasterStorageInfo.js";import d from"../TileInfo.js";import{isMultiSliceOrRangeDefinition as x,getSliceIndex as y,createSlices as g,getSliceIds as I}from"./multidimensionalUtils.js";import{getRasterId as R,getBlock as w,putBlock as S,deleteBlock as k,decreaseRefCount as v}from"./RawBlockCache.js";import{convertNoDataToMask as T}from"../rasterFormats/pixelRangeUtils.js";import{decode as b}from"../rasterFormats/RasterCodec.js";import{mosaic as P,approximateTransform as B,getLocalArithmeticNorthRotations as M}from"../rasterFunctions/pixelUtils.js";import{load as _,getWorldWidth as C,projectPoint as W,snapPyramid as j,shiftExtent as z,getWorldWrapCount as H,projectExtent as L,getProjectionOffsetGrid as E,getRasterDatasetAlignmentInfo as D,projectResolution as F}from"../rasterFunctions/rasterProjectionHelper.js";import{convertToLocalDirections as O,uvComponentToVector as A}from"../rasterFunctions/vectorFieldUtils.js";import{QueueProcessor as G}from"../../../views/support/QueueProcessor.js";import q from"../../../geometry/Extent.js";import J from"../../../geometry/Point.js";import N from"../../../geometry/SpatialReference.js";const V=8,U=256;let $=0,Q=class extends(n(r)){constructor(){super(...arguments),this._tileFetchQueue=new G({concurrency:32,process:(e,t)=>this._fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=_();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:d.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,t=C(e.spatialReference);return null!=t&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){const{transform:e}=this.rasterInfo;return null==e||"gcs-shift"===e.type}set rasterJobHandler(e){this._set("rasterJobHandler",e),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach((t=>t.rasterJobHandler=e))}get rasterId(){return this.url||"rasterId-"+$++}set url(e){this._set("url",m(e,o.getLogger(this)))}async open(e){throw new i("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,i,r={}){const o=r.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(e,t,i,o);return r={noClip:!0,...r},this.fetchPixels(n,o.size[0],o.size[1],r)}async identify(e,t={}){e=a(J,e).clone().normalize();const{multidimensionalDefinition:i,timeExtent:r}=t,{rasterInfo:o}=this,{hasMultidimensionalTranspose:n,multidimensionalInfo:s}=o;let{transposedVariableName:l}=t;const c=null!=s&&n&&(null!=r||x(i));if(c&&!l){l=null!=i&&i.length>0?i[0].variableName??void 0:s.variables[0].name,t={...t,transposedVariableName:l}}t=this._getRequestOptionsWithSliceId(t);const{spatialReference:m,extent:f}=o,{datumTransformation:u}=t;let h=W(e,m,u);if(!f.intersects(h))return{location:h,value:null};if(null!=o.transform){const e=o.transform.inverseTransform(h);if(!o.nativeExtent.intersects(e))return{location:e,value:null};h=e}let p=0;const d=null!=l&&null!=s&&o.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const e=this.primaryRasters.rasters[0];if(d)return e.identify(h,t);const{pixelSize:r}=o,n=3,s=r.x*n/2,l=r.y*n/2,a=new q({xmin:h.x-s,xmax:h.x+s,ymin:h.y-l,ymax:h.y+l,spatialReference:m}),c={interpolation:"nearest",multidimensionalDefinition:i,sliceId:t.sliceId},{pixelBlock:f}=await e.fetchPixels(a,n,n,c),{pixelBlock:u}=await this.fetchPixels(a,n,n,c);if(null==f)return{location:h,value:null};const p=Math.floor(n*n*.5),x=!f.mask||f.mask[p]?f.pixels.map((e=>e[p])):null;let y;return null!=u&&(y=!u.mask||u.mask[p]?u.pixels.map((e=>e[p])):void 0),{location:h,value:x,processedValue:y,pyramidLevel:0}}if(!d)if(t.srcResolution){p=j(t.srcResolution,o,this.ioConfig.sampling).pyramidLevel}else if(p=await this.computeBestPyramidLevelForLocation(e,t),null==p)return{location:h,value:null};const y=this.identifyPixelLocation(h,p,null,d);if(null===y)return{location:h,value:null};const{row:g,col:I,rowOffset:k,colOffset:v,blockWidth:T}=y,b=l??t.sliceId,P=R(this.rasterId,b),B=`${p}/${g}/${I}`;let M=w(P,null,B);null==M&&(M=this.fetchRawTile(p,g,I,t),S(P,null,B,M));const _=await M;if(!_?.pixels?.length)return{location:h,value:null};const C=k*T+v;return this._processIdentifyResult(_,{srcLocation:h,position:C,pyramidLevel:p,useTransposedTile:!!d,requestSomeSlices:c,identifyOptions:t})}async fetchPixels(e,t,i,r={}){e=z(e),r=this._getRequestOptionsWithSliceId(r);const{_hasNoneOrGCSShiftTransform:o}=this;if(r.requestRawData&&o)return this._fetchPixels(e,t,i,r);const n=C(e.spatialReference),s=H(e);if(null==n||0===s||1===s&&this._isGlobalWrappableSource&&o)return this._fetchPixels(e,t,i,r);if(s>=3)return{extent:e,pixelBlock:null};const l=[],{xmin:a,xmax:c}=e,m=Math.round(n/(c-a)*t),f=m-Math.round((n/2-a)/(c-a)*t);let u=0;const h=[];for(let y=0;y<=s;y++){const o=new q({xmin:0===y?a:-n/2,xmax:y===s?c-n*y:n/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),p=0===y?m-f:y===s?t-u:m;u+=p,h.push(p);const d=r.disableWrapAround&&y>0?null:this._fetchPixels(o,p,i,r);l.push(d)}const p=(await Promise.all(l)).map((e=>e?.pixelBlock));let d=null;const x={width:t,height:i};if(this.rasterJobHandler){d=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:x,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:h},r)).pixelBlock}else d=P(p,x,{blockWidths:h});return{extent:e,srcExtent:L(e,this.rasterInfo.spatialReference,r.datumTransformation),pixelBlock:d}}async fetchRawPixels(e,t,i,r={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const o=await this._fetchRawTiles(e,t,i,r),{nativeExtent:n,nativePixelSize:s,storageInfo:l}=this.rasterInfo,a=2**e,c=s.x*a,m=s.y*a,f=new q({xmin:n.xmin+c*t.x,xmax:n.xmin+c*(t.x+i.width-1),ymin:n.ymax-m*(t.y+i.height-1),ymax:n.ymax-m*t.y,spatialReference:n.spatialReference});if(!o)return{extent:f,srcExtent:f,pixelBlock:null};const{pixelBlocks:u,mosaicSize:h}=o;if(1===u.length&&null!=u[0]&&u[0].width===i.width&&u[0].height===i.height)return{extent:f,srcExtent:f,pixelBlock:o.pixelBlocks[0]};const p=e>0?l.pyramidBlockWidth:l.blockWidth,d=e>0?l.pyramidBlockHeight:l.blockHeight,x={x:t.x%p,y:t.y%d};let y;if(this.rasterJobHandler){y=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:u,srcMosaicSize:h,destDimension:i,clipOffset:x,clipSize:i,coefs:null,sampleSpacing:null,interpolation:r.interpolation,alignmentInfo:null,blockWidths:null},r)).pixelBlock}else y=P(u,h,{clipOffset:x,clipSize:i});return{extent:f,srcExtent:f,pixelBlock:y}}fetchRawTile(e,t,r,o){throw new i("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return L(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?b(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,i,r=0){const{customFetchParameters:o}=this.ioConfig,{range:n,query:s,headers:l}=i;r=r??i.retryCount??this.ioConfig.retryCount;const a=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await t(e,{...i,query:{...s,...o},headers:{...l,...a}})}catch(c){if(r>0)return r--,this.request(e,i,r);throw c}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;return null==t||null==e||0===e.length?null:y(e,t)}getTileExtentFromTileInfo(e,t,i,r){const o=r.lodAt(e);return this.getTileExtent({x:o.resolution,y:o.resolution},t,i,r.origin,r.spatialReference,r.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:r}=this.rasterInfo;if(!e.tileInfo){const o=[],n=e.maximumPyramidLevel||0;let s=Math.max(r.x,r.y),l=1/.0254*96*s;for(let e=0;e<=n;e++)o.unshift(new h({level:n-e,resolution:s,scale:l})),s*=2,l*=2;const a=new J({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new d({origin:a,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:o}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,i=512,r){const{width:o,height:n,nativeExtent:s,pixelSize:l,spatialReference:a}=e,c=new J({x:s.xmin,y:s.ymax,spatialReference:a});null==r&&(r=Math.max(0,Math.round(Math.log(Math.max(o,n))/Math.LN2-8)));const m=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[l],r);e.storageInfo=new p({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:r,blockBoundary:m})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,i,r,o,n=0,s=2){if(1===o.length&&n>0){o=[...o];let{x:e,y:t}=o[0];for(let i=0;i<n;i++)e*=s,t*=s,o.push({x:e,y:t})}const l=[],{x:a,y:c}=r;for(let m=0;m<o.length;m++){const{x:r,y:n}=o[m];l.push({minCol:Math.floor((e.xmin-a+.1*r)/t/r),maxCol:Math.floor((e.xmax-a-.1*r)/t/r),minRow:Math.floor((c-e.ymax+.1*n)/i/n),maxRow:Math.floor((c-e.ymin-.1*n)/i/n)})}return l}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:r}=this.rasterInfo.storageInfo;if(0===e)return t;if(null!=i&&i.length)return i[e-1];const o=r**e;return{x:t.x*o,y:t.y*o}}identifyPixelLocation(e,t,i,r){const{spatialReference:o,nativeExtent:n,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:l,origin:a,transposeInfo:c}=s,m=r&&null!=c?c.tileSize[0]:s.blockWidth,f=r&&null!=c?c.tileSize[1]:s.blockHeight,u=W(e,o,i);if(!n.intersects(u))return null;if(t<0||t>l)return null;const h=this.getPyramidPixelSize(t),{x:p,y:d}=h,x=(a.y-u.y)/d/f,y=(u.x-a.x)/p/m,g=Math.min(f-1,Math.floor((x-Math.floor(x))*f)),I=Math.min(m-1,Math.floor((y-Math.floor(y))*m));return{pyramidLevel:t,row:Math.floor(x),col:Math.floor(y),rowOffset:g,colOffset:I,blockWidth:m,srcLocation:u}}getTileExtent(e,t,i,r,o,n){const[s,l]=n,a=r.x+i*s*e.x,c=a+s*e.x,m=r.y-t*l*e.y,f=m-l*e.y;return new q({xmin:a,xmax:c,ymin:f,ymax:m,spatialReference:o})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,i){const r=this.rasterInfo.storageInfo.blockBoundary[e];return!r||r.maxRow<t||r.maxCol<i||r.minRow>t||r.minCol>i}updateImageSpaceRasterInfo(e){const{extent:t,pixelSize:i}=e;if(-.5===t.xmin&&.5===t.ymax&&1===i.x&&1===i.y&&null==e.transform)return;const{width:r,height:o}=e,n=N.WebMercator;e.spatialReference=n,e.extent=e.nativeExtent=new q({xmin:-.5,ymax:.5,xmax:r-.5,ymin:.5-o,spatialReference:n}),e.isPseudoSpatialReference=!0,e.transform=null,e.pixelSize=new J({x:1,y:1,spatialReference:n});const{extent:s,storageInfo:l}=e;if(l){l.origin=new J({x:s.xmin,y:s.ymax,spatialReference:n});const{tileInfo:t}=l;if(t){t.origin=l.origin;const i=(e.nativePixelSize.x+e.nativePixelSize.y)/2;t.lods.forEach(((e,t)=>{e.resolution=i*2**t,e.scale=96*e.resolution/.0254}))}}}async _fetchPixels(e,t,i,r={}){let o=H(e);if(o>=2)return{extent:e,pixelBlock:null};const n=this._getSourceDataInfo(e,t,i,r),{pyramidLevel:s,srcResolution:l,srcExtent:a,srcWidth:c,srcHeight:m,ul:f}=n;if(0===c||0===m)return{extent:e,srcExtent:a,pixelBlock:null};const{rasterInfo:u}=this,h=u.transform,p="gcs-shift"===h?.type,d=null!=C(e.spatialReference);!p&&d||(o=H(n.srcExtent,p));const x=await this._fetchRawTiles(s,f,{width:c,height:m,wrapCount:o},r);if(!x)return{extent:e,srcExtent:a,pixelBlock:null};const y=u.storageInfo,g=s>0?y.pyramidBlockWidth:y.blockWidth,I=s>0?y.pyramidBlockHeight:y.blockHeight;let{x:R,y:w}=u.pixelSize;if(s>0){const{pyramidResolutions:e,pyramidScalingFactor:t}=y;if(null!=e&&e[s-1])({x:R,y:w}=e[s-1]);else{const e=t**s;R*=e,w*=e}}const S=u.spatialReference,k=new J({x:R,y:w,spatialReference:S}),v=g===c&&I===m&&f.x%g==0&&f.y%I==0,T=new J({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),b=!e.spatialReference.equals(S),W=S.isGeographic?1e-9:1e-4,{datumTransformation:j}=r;if(!b&&v&&1===x.pixelBlocks.length&&g===t&&I===i&&X(l,T,W))return{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:x.pixelBlocks[0]};const z=d&&null!=C(a.spatialReference)&&this._hasNoneOrGCSShiftTransform,L=r.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");L&&!this.rasterJobHandler&&await _();const D=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:T.toJSON(),datumTransformation:j,rasterTransform:h,hasWrapAround:o>0||z,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:L},r):E({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:T,datumTransformation:j,rasterTransform:h,hasWrapAround:o>0||z,isAdaptive:!1,includeGCSGrid:L});let F;const A=!r.requestRawData,G={rows:D.spacing[0],cols:D.spacing[1]},q=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,x.extent.xmin):void 0,{pixelBlocks:N,mosaicSize:V,isPartiallyFilled:U}=x;let $=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:N,srcMosaicSize:V,destDimension:A?{width:t,height:i}:null,coefs:A?D.coefficients:null,sampleSpacing:A?G:null,projectDirections:L,gcsGrid:L?D.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:r.interpolation,alignmentInfo:q,blockWidths:null},r);({pixelBlock:F,localNorthDirections:$}=e)}else{const e=P(N,V,{alignmentInfo:q});F=A?B(e,{width:t,height:i},D.coefficients,G,r.interpolation):e,L&&D.gcsGrid&&($=M({width:t,height:i},D.gcsGrid),F=O(F,this.rasterInfo.dataType,$))}return r.requestRawData||L?{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:F,transformGrid:D,localNorthDirections:$,isPartiallyFilled:U}:{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:F}}async _fetchRawTiles(e,t,i,r){const{origin:o,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:l}=this.getBlockWidthHeight(e);let{x:a,y:c}=t,{width:m,height:f,wrapCount:u}=i;const h=this._getRasterTileAlignmentInfo(e,0);r.buffer&&(a-=r.buffer.cols,c-=r.buffer.rows,m+=2*r.buffer.cols,f+=2*r.buffer.rows);let p=0,d=0,x=0;if(u&&null!=h){({worldColumnCountFromOrigin:d,originColumnOffset:x,rightPadding:p}=h);d*h.blockWidth-p>=a+m&&(p=0)}const y=Math.floor(a/s),g=Math.floor(c/l),I=Math.floor((a+m+p-1)/s),R=Math.floor((c+f+p-1)/l),w=n[e];if(!w)return null;const{minRow:S,minCol:k,maxCol:v,maxRow:T}=w;if(0===u&&(R<S||I<k||g>T||y>v))return null;const b=new Array;let P=!1;const B=null==this.ioConfig.allowPartialFill?r.allowPartialFill:this.ioConfig.allowPartialFill;for(let H=g;H<=R;H++)for(let t=y;t<=I;t++){let i=t;if(!r.disableWrapAround&&u&&null!=h&&d<=t&&(i=t-d-x),H>=S&&i>=k&&T>=H&&v>=i){const t=this._tileFetchQueue.push({pyramidLevel:e,row:H,col:i,options:r},{signal:r.signal});B?b.push(new Promise((e=>{t.then((t=>e(t))).catch((()=>{P=!0,e(null)}))}))):b.push(t)}else b.push(Promise.resolve(null))}if(0===b.length)return null;const M=await Promise.all(b),_={height:(R-g+1)*l,width:(I-y+1)*s},{spatialReference:C}=this.rasterInfo,W=this.getPyramidPixelSize(e),{x:j,y:z}=W;return{extent:new q({xmin:o.x+y*s*j,xmax:o.x+(I+1)*s*j,ymin:o.y-(R+1)*l*z,ymax:o.y-g*l*z,spatialReference:C}),pixelBlocks:M,mosaicSize:_,isPartiallyFilled:P}}_fetchRawTile(e,t,i,r){const o=this.rasterInfo.storageInfo.blockBoundary[e];if(!o)return Promise.resolve(null);const{minRow:n,minCol:l,maxCol:a,maxRow:c}=o;if(t<n||i<l||t>c||i>a)return Promise.resolve(null);const m=R(this.rasterId,r.sliceId),f=`${e}/${t}/${i}`;let u=w(m,r.registryId,f);if(null==u){const o=new AbortController;u=this.fetchRawTile(e,t,i,{...r,signal:o.signal}),S(m,r.registryId,f,u,o),u.catch((()=>k(m,r.registryId,f)))}return r.signal&&s(r,(()=>{v(m,r.registryId,f)})),u}_computeMagDirValues(e){const{bandCount:t,dataType:i}=this.rasterInfo;if(!(2===t&&"vector-magdir"===i||"vector-uv"===i)||2!==e?.length||!e[0]?.length)return null;const r=e[0].length;if("vector-magdir"===i){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[o,n]=e,s=[],l=[];for(let a=0;a<r;a++){const[e,t]=A([o[a],n[a]]);s.push(e),l.push(t)}return[s,l]}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=D(this.rasterInfo)),null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,i,r={}){const o={datumTransformation:r.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};r.srcResolution&&(o.srcResolution=r.srcResolution,this._updateSourceDataInfo(e,o));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:l,pyramidLevel:a}=o,c=s/t,m=l/i,f=a<n&&c*m>=16,u=a===n&&this._requireTooManySrcTiles(s,l,t,i);if(f||u||(0===s||0===l)){const s=new J({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference});let l=F(s,this.rasterInfo.spatialReference,e,o.datumTransformation);const u=!l||r.srcResolution&&l.x+l.y<r.srcResolution.x+r.srcResolution.y;if(f&&r.srcResolution&&u){const e=Math.round(Math.log(Math.max(c,m))/Math.LN2)-1;if(n-a+3>=e){const t=2**e;l={x:r.srcResolution.x*t,y:r.srcResolution.y*t}}}l&&(o.srcResolution=l,this._updateSourceDataInfo(e,o))}return this._requireTooManySrcTiles(o.srcWidth,o.srcHeight,t,i)&&(o.srcWidth=0,o.srcHeight=0),o}_requireTooManySrcTiles(e,t,i,r){const{tileInfo:o}=this.rasterInfo.storageInfo,n=Math.ceil(e/o.size[0])*Math.ceil(t/o.size[1]),s=e/i,l=t/r,a=Math.max(1,(i+r)/1024);return n>=U*a||s>V||l>V}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:i}=this,r=i.spatialReference,{srcResolution:o,datumTransformation:n}=t,{pyramidLevel:s,pyramidResolution:l,excessiveReading:a}=j(o,i,this.ioConfig.sampling);if(a)return;let c=t.srcExtent||L(e,r,n);if(null==c)return;const m=i.transform;m&&(c=m.inverseTransform(c)),t.srcExtent=c;const{x:f,y:u}=i.storageInfo.origin,h=Math.floor((c.xmin-f)/l.x+.1),p=Math.floor((u-c.ymax)/l.y+.1),d=Math.floor((c.xmax-f)/l.x-.1),x=Math.floor((u-c.ymin)/l.y-.1),y=c.width<.1*l.x?0:d-h+1,g=c.height<.1*l.y?0:x-p+1;t.pyramidLevel=s,t.pyramidResolution=l,t.srcWidth=y,t.srcHeight=g,t.ul={x:h,y:p}}_getRequestOptionsWithSliceId(e){return null!=this.rasterInfo.multidimensionalInfo&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){const{srcLocation:i,position:r,pyramidLevel:o,useTransposedTile:n}=t,s=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[r]))return{location:i,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(null==l||!n){const t=e.pixels.map((e=>e[r])),n={location:i,value:t,pyramidLevel:o},s=this._computeMagDirValues(t.map((e=>[e])));return s?.length&&(n.magdirValue=s.map((e=>e[0]))),n}let a=e.pixels.map((e=>e.slice(r*s,r*s+s))),c=this._computeMagDirValues(a);const{requestSomeSlices:m,identifyOptions:f}=t;let h=g(l,f.transposedVariableName);if(m){const e=I(h,f.multidimensionalDefinition,f.timeExtent);a=a.map((t=>e.map((e=>t[e])))),c=c?.map((t=>e.map((e=>t[e])))),h=e.map((e=>h[e]))}const p=e.noDataValues||this.rasterInfo.noDataValue,d={pixels:a,pixelType:e.pixelType};let x;null!=p&&(T(d,p),x=d.mask);return{location:i,value:null,dataSeries:h.map(((e,t)=>{const i={value:0===x?.[t]?null:a.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition.map((e=>new u({...e,isSlice:!0})))};return c?.length&&(i.magdirValue=[c[0][t],c[1][t]]),i})),pyramidLevel:o}}};function X(e,t,i){return Math.abs(e.x-t.x)<i&&Math.abs(e.y-t.y)<i}e([l()],Q.prototype,"_rasterTileAlignmentInfo",void 0),e([l()],Q.prototype,"_tileFetchQueue",void 0),e([l({readOnly:!0})],Q.prototype,"_isGlobalWrappableSource",null),e([l({readOnly:!0})],Q.prototype,"_hasNoneOrGCSShiftTransform",null),e([l()],Q.prototype,"rasterJobHandler",null),e([l({readOnly:!0})],Q.prototype,"rasterId",null),e([l(f)],Q.prototype,"url",null),e([l({type:String,json:{write:!0}})],Q.prototype,"datasetName",void 0),e([l({type:String,json:{write:!0}})],Q.prototype,"datasetFormat",void 0),e([l()],Q.prototype,"hasUniqueSourceStorageInfo",void 0),e([l()],Q.prototype,"rasterInfo",void 0),e([l()],Q.prototype,"ioConfig",void 0),e([l()],Q.prototype,"sourceJSON",void 0),Q=e([c("esri.layers.support.rasterDatasets.BaseRaster")],Q);const K=Q;export{K as default};
