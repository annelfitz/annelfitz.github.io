/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import{property as r}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/Logger.js";import"../../../core/RandomLCG.js";import{enumeration as o}from"../../../core/accessorSupport/decorators/enumeration.js";import{reader as t}from"../../../core/accessorSupport/decorators/reader.js";import{subclass as s}from"../../../core/accessorSupport/decorators/subclass.js";import{writer as i}from"../../../core/accessorSupport/decorators/writer.js";import n from"./BaseRasterTransform.js";import f from"../../../geometry/Point.js";import p from"../../../geometry/Extent.js";var l;function a(e,r,o){const{x:t,y:s}=r;if(o<2){return{x:e[0]+t*e[2]+s*e[4],y:e[1]+t*e[3]+s*e[5]}}if(2===o){const r=t*t,o=s*s,i=t*s;return{x:e[0]+t*e[2]+s*e[4]+r*e[6]+i*e[8]+o*e[10],y:e[1]+t*e[3]+s*e[5]+r*e[7]+i*e[9]+o*e[11]}}const i=t*t,n=s*s,f=t*s,p=i*t,l=i*s,a=t*n,c=s*n;return{x:e[0]+t*e[2]+s*e[4]+i*e[6]+f*e[8]+n*e[10]+p*e[12]+l*e[14]+a*e[16]+c*e[18],y:e[1]+t*e[3]+s*e[5]+i*e[7]+f*e[9]+n*e[11]+p*e[13]+l*e[15]+a*e[17]+c*e[19]}}function c(e,r,o){const{xmin:t,ymin:s,xmax:i,ymax:n,spatialReference:f}=r;let l=[];if(o<2)l.push({x:t,y:n}),l.push({x:i,y:n}),l.push({x:t,y:s}),l.push({x:i,y:s});else{let e=10;for(let r=0;r<e;r++)l.push({x:t,y:s+(n-s)*r/(e-1)}),l.push({x:i,y:s+(n-s)*r/(e-1)});e=8;for(let r=1;r<=e;r++)l.push({x:t+(i-t)*r/e,y:s}),l.push({x:t+(i-t)*r/e,y:n})}l=l.map((r=>a(e,r,o)));const c=l.map((e=>e.x)),m=l.map((e=>e.y));return new p({xmin:Math.min.apply(null,c),xmax:Math.max.apply(null,c),ymin:Math.min.apply(null,m),ymax:Math.max.apply(null,m),spatialReference:f})}function m(e){const[r,o,t,s,i,n]=e,f=t*n-i*s,p=i*s-t*n;return[(i*o-r*n)/f,(t*o-r*s)/p,n/f,s/p,-i/f,-t/p]}let u=l=class extends n{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(e,r){const{coeffX:o,coeffY:t}=r;if(!o?.length||!t?.length||o.length!==t.length)return null;const s=[];for(let i=0;i<o.length;i++)s.push(o[i]),s.push(t[i]);return s}writeForwardCoefficients(e,r,o){const t=[],s=[];for(let i=0;i<e?.length;i++)i%2==0?t.push(e[i]):s.push(e[i]);r.coeffX=t,r.coeffY=s}get inverseCoefficients(){let e=this._get("inverseCoefficients");const r=this._get("forwardCoefficients");return!e&&r&&this.polynomialOrder<2&&(e=m(r)),e}set inverseCoefficients(e){this._set("inverseCoefficients",e)}readInverseCoefficients(e,r){const{inverseCoeffX:o,inverseCoeffY:t}=r;if(!o?.length||!t?.length||o.length!==t.length)return null;const s=[];for(let i=0;i<o.length;i++)s.push(o[i]),s.push(t[i]);return s}writeInverseCoefficients(e,r,o){const t=[],s=[];for(let i=0;i<e?.length;i++)i%2==0?t.push(e[i]):s.push(e[i]);r.inverseCoeffX=t,r.inverseCoeffY=s}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(e){if("point"===e.type){const r=a(this.forwardCoefficients,e,this.polynomialOrder);return new f({x:r.x,y:r.y,spatialReference:e.spatialReference})}return c(this.forwardCoefficients,e,this.polynomialOrder)}inverseTransform(e){if("point"===e.type){const r=a(this.inverseCoefficients,e,this.polynomialOrder);return new f({x:r.x,y:r.y,spatialReference:e.spatialReference})}return c(this.inverseCoefficients,e,this.polynomialOrder)}clone(){return new l({polynomialOrder:this.polynomialOrder,forwardCoefficients:this.forwardCoefficients?[...this.forwardCoefficients]:null,inverseCoefficients:this.inverseCoefficients?[...this.inverseCoefficients]:null})}};e([r({json:{write:!0}})],u.prototype,"polynomialOrder",void 0),e([r()],u.prototype,"forwardCoefficients",void 0),e([t("forwardCoefficients",["coeffX","coeffY"])],u.prototype,"readForwardCoefficients",null),e([i("forwardCoefficients")],u.prototype,"writeForwardCoefficients",null),e([r({json:{write:!0}})],u.prototype,"inverseCoefficients",null),e([t("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],u.prototype,"readInverseCoefficients",null),e([i("inverseCoefficients")],u.prototype,"writeInverseCoefficients",null),e([r()],u.prototype,"affectsPixelSize",null),e([o({PolynomialXform:"polynomial"})],u.prototype,"type",void 0),u=l=e([s("esri.layers.support.rasterTransforms.PolynomialTransform")],u);const y=u;export{y as default};
