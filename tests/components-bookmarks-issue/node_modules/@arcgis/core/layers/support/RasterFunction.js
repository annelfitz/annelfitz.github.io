/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import{JSONSupport as n}from"../../core/JSONSupport.js";import{clone as e}from"../../core/lang.js";import{property as o}from"../../core/accessorSupport/decorators/property.js";import"../../core/has.js";import"../../core/Logger.js";import{enumeration as r}from"../../core/accessorSupport/decorators/enumeration.js";import{reader as i}from"../../core/accessorSupport/decorators/reader.js";import{subclass as s}from"../../core/accessorSupport/decorators/subclass.js";import{writer as a}from"../../core/accessorSupport/decorators/writer.js";import u from"./RasterFunctionTemplate.js";var c;const p=new Set(["raster","raster2","dem","fillraster"]),f=new Set(["rasters"]),m=t=>t?.rasterFunction?d.fromJSON(t):t,l=t=>t&&t instanceof d?t.toJSON():t,y=t=>t?.functionName&&!t.declaredClass,F=t=>y(t)?new d(t):t,h=t=>{if(null==t)return null;t=e(t);const n={};for(const e of Object.keys(t))p.has(e.toLowerCase())?n[e]=m(t[e]):f.has(e.toLowerCase())&&Array.isArray(t[e])?n[e]=t[e].map(m):n[e]=t[e];return n},g={types:{key:"type",base:null,typeMap:{RasterFunctionTemplate:u}},json:{write:!0,name:"rasterFunctionDefinition"}};let d=c=class extends n{constructor(t){super(t),this.functionName=null,this.outputPixelType="unknown",this.variableName=null,this.functionDefinition=null}set functionArguments(t){if(t){const n=Object.keys(t);if(n.some((n=>p.has(n.toLowerCase())&&y(t[n])))||n.some((n=>f.has(n.toLowerCase())&&Array.isArray(t[n])&&t[n].some((t=>y(t)))))){t=e(t);for(const e of n)p.has(e.toLowerCase())?t[e]=F(t[e]):f.has(e.toLowerCase())&&Array.isArray(t[e])&&(t[e]=t[e].map((t=>F(t))))}}this._set("functionArguments",t)}readFunctionArguments(t){return h(t)}writeFunctionArguments(t,n,e){const o={};for(const r of Object.keys(t))p.has(r.toLowerCase())?o[r]=l(t[r]):f.has(r.toLowerCase())&&Array.isArray(t[r])?o[r]=t[r].map(l):o[r]=l(t[r]);n[e]=o}readFunctionName(t,n){const e=n.rasterFunctionInfos,o=n.name;return o||(e?.length&&"None"!==e[0].name?e[0].name:n.rasterFunctionDefinition?n.rasterFunctionDefinition.name:n.rasterFunction)}get rasterFunctionDefinition(){return this.functionDefinition?.toJSON()}set rasterFunctionDefinition(t){this.functionDefinition=t?u.fromJSON(t):null}get hasClipFunction(){return this.rasterFunctionDefinition?JSON.stringify(this.rasterFunctionDefinition).includes('"type":"ClipFunction"'):JSON.stringify(this).includes('"rasterFunction":"Clip"')}clone(){return new c({functionName:this.functionName,functionArguments:e(this.functionArguments),outputPixelType:this.outputPixelType,variableName:this.variableName,rasterFunctionDefinition:e(this.rasterFunctionDefinition)})}};t([o({json:{type:Object,name:"rasterFunctionArguments"}})],d.prototype,"functionArguments",null),t([i("functionArguments")],d.prototype,"readFunctionArguments",null),t([a("functionArguments")],d.prototype,"writeFunctionArguments",null),t([o({json:{type:String,write:{target:"rasterFunction"}}})],d.prototype,"functionName",void 0),t([i("functionName",["rasterFunction","rasterFunctionInfos","rasterFunctionDefinition"])],d.prototype,"readFunctionName",null),t([r({C128:"c128",C64:"c64",F32:"f32",F64:"f64",S16:"s16",S32:"s32",S8:"s8",U1:"u1",U16:"u16",U2:"u2",U32:"u32",U4:"u4",U8:"u8",UNKNOWN:"unknown"},{ignoreUnknown:!1}),o({json:{default:"unknown"}})],d.prototype,"outputPixelType",void 0),t([o({type:String,json:{read:!0,write:!0}})],d.prototype,"variableName",void 0),t([o()],d.prototype,"rasterFunctionDefinition",null),t([o(g)],d.prototype,"functionDefinition",void 0),t([o()],d.prototype,"hasClipFunction",null),d=c=t([s("esri.layers.support.RasterFunction")],d);const N=d;export{N as default};
