/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../../geometry.js";import{zeros as e}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{z as t,g as a}from"../../../chunks/vec32.js";import r from"../../../geometry/Circle.js";import n from"../../../geometry/Mesh.js";import{earth as i}from"../../../geometry/support/Ellipsoid.js";import{MeshVertexAttributes as s}from"../../../geometry/support/MeshVertexAttributes.js";import{isWebMercator as c}from"../../../geometry/support/spatialReferenceUtils.js";import{calculateRotationMatrix as o,transformMat3 as f,scaleAndAddWithFactor as l,scaleWithFactor as h}from"../transformations/utils.js";import m from"../../../geometry/Polygon.js";import y from"../../../geometry/SpatialReference.js";const g=Math.PI/180;function p(s){const{attributes:y}=s,{horizontalFieldOfView:p,geometry:u,verticalFieldOfView:x}=y;let R,H=1,w=null;if(u&&c(u?.spatialReference)&&(H=1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*u.y/i.radius)))),y.isSpherical){if(R=new r({center:u,radius:y.farDistance*H}),y.nearDistance){const e=new r({center:u,radius:y.nearDistance*H});R.addRing(e.rings[0])}const e=R.center;e&&(e.z=y.cameraHeight,w=n.createSphere(e,{size:2*y.farDistance}),w.centerAt(e))}else{let r=y.cameraPitch,n=y.cameraRoll,i=150;const c=[];p>150&&(r=90,n=0,i=5);const D=Math.ceil(p/i);if(D%2==0)for(let e=0;e<D/2;e++)c.push(y.cameraHeading-p/D*(e+.5),y.cameraHeading+p/D*(e+.5));else{c.push(y.cameraHeading);for(let e=1;e<D/2;e++)c.push(y.cameraHeading-p/D*e,y.cameraHeading+p/D*e)}c.sort();let j=y.farDistance?y.farDistance*H:y.cameraHeight*H/Math.cos(r*g);y.cameraPitch+x/2>=90&&(j=(y.farDistance||20)*H),R=new m({spatialReference:u?.spatialReference});for(const m of c){const i=o("HPR",[m,r,n]);w=M(s,i);const c=f([0,0,-1],i),{x:P,y:z}=u,F=l([P,z,y.cameraHeight],c,j,H),O=2*Math.tan(x*g/2)*j,V=2*Math.tan(p/D*g/2)*j,b=f([0,1,0],i),v=f([1,0,0],i),q=h(b,O/2,H),A=h(v,V/2,H),C=t(e(),q,A),S=a(e(),q,A),I=[a(e(),F,C),a(e(),F,S),t(e(),F,C),t(e(),F,S)].map((e=>d(e,y.cameraHeight,u,H)));I.push(I[0]),R.addRing(I)}}return{polygon:R,frustum:w}}function u(e,t){return e.contains(t)}function x(e,t){return Math.sign(e)!==Math.sign(t)}function M(r,i,c){const o=r.attributes,m=o.geometry,p=m.spatialReference??r.spatialReference;m.spatialReference=p instanceof y?p:y.fromJSON(p);const u=H(m),x=o.nearDistance<0?0:o.nearDistance*u;let M=o.cameraHeight*u/Math.cos(o.cameraPitch*g),d=!0;o.cameraPitch+o.verticalFieldOfView/2>=90&&(M=(o.farDistance??20)*u,d=!1);const R=2*Math.tan(o.verticalFieldOfView*g/2)*x,w=2*Math.tan(o.horizontalFieldOfView*g/2)*x,D=2*Math.tan(o.verticalFieldOfView*g/2)*M,j=2*Math.tan(o.horizontalFieldOfView*g/2)*M;let P,z;c?(P=c,z=h(t(e(),P,[m.x,m.y,o.cameraHeight]),1/M,1/u)):(z=[0,0,-1],z=f(z,i),P=l([m.x,m.y,o.cameraHeight],z,M,u),d&&(P[2]=0));const F=l([m.x,m.y,o.cameraHeight],z,x,u);let O=[0,1,0];O=f(O,i);let V=[1,0,0];V=f(V,i);let b=[],v=[];x?(v=[{faces:[4,0,3,4,7,3]},{faces:[5,1,2,5,6,2]},{faces:[4,0,1,4,5,1]},{faces:[6,2,3,6,7,3]}],b=b.concat(a(e(),F,t(e(),h(O,R/2,u),h(V,w/2,u)))),b=b.concat(a(e(),F,a(e(),h(O,R/2,u),h(V,w/2,u)))),b=b.concat(t(e(),F,t(e(),h(O,R/2,u),h(V,w/2,u)))),b=b.concat(t(e(),F,a(e(),h(O,R/2,u),h(V,w/2,u))))):(b=[m.x,m.y,o.cameraHeight],v=[{faces:[0,1,2,0,2,3,0,3,4,0,4,1]}]),b=b.concat(a(e(),P,t(e(),h(O,D/2,u),h(V,j/2,u)))),b=b.concat(a(e(),P,a(e(),h(O,D/2,u),h(V,j/2,u)))),b=b.concat(t(e(),P,t(e(),h(O,D/2,u),h(V,j/2,u)))),b=b.concat(t(e(),P,a(e(),h(O,D/2,u),h(V,j/2,u))));const q=new s({position:Float64Array.from(b)});return new n({vertexAttributes:q,components:v,spatialReference:m.spatialReference})}function d(a,r,n,i){{const s=Math.sqrt((a[2]-r)**2+(Math.sqrt((a[0]-n.x)**2+(a[1]-n.y)**2)/i)**2)*i,c=h(t(e(),[a[0],a[1],a[2]],[n.x,n.y,r]),1/s,1/i),o=r/(r-a[2]),f={x:(1-o)*n.x+o*a[0],y:(1-o)*n.y+o*a[1],z:(1-o)*r+o*a[2]},l=Math.sqrt((f.z-r)**2+(Math.sqrt((f.x-n.x)**2+(f.y-n.y)**2)/i)**2)*i,m=h(t(e(),[f.x,f.y,f.z],[n.x,n.y,r]),1/l,1/i);return x(c[0],m[0])&&x(c[1],m[1])&&x(c[2],m[2])||a[2]>=0?[a[0],a[1],0]:[f.x,f.y,f.z]}}function R(e){const{spatialReference:t,x:a,y:r}=e.geometry,{cameraHeading:n,cameraPitch:i,farDistance:s,nearDistance:c}=e,o=H(e.geometry),f=new m({spatialReference:t}),l=Math.abs(1.44*s*o);let h=Math.abs(1.44*c*o);(i<20||null==n)&&(h=l);const y=[];return y[0]={x:a+l*Math.sin((n-45)*g),y:r+l*Math.cos((n-45)*g)},y[1]={x:a+l*Math.sin((n+45)*g),y:r+l*Math.cos((n+45)*g)},y[2]={x:a+h*Math.sin((n+135)*g),y:r+h*Math.cos((n+135)*g)},y[3]={x:a+h*Math.sin((n+225)*g),y:r+h*Math.cos((n+225)*g)},f.addRing([[y[0].x,y[0].y,0],[y[1].x,y[1].y,0],[y[2].x,y[2].y,0],[y[3].x,y[3].y,0],[y[0].x,y[0].y,0]]),f}function H(e){return e&&c(e?.spatialReference)?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*e.y/i.radius))):1}function w(a,n){const i=1+n/100;if("esri.geometry.Circle"===a.declaredClass){const{radius:e,center:t}=a,n=new r({radius:e*i,center:t});return a.rings.length>1&&n.addRing(a.rings[1]),n}if("esri.geometry.Polygon"===a.declaredClass){const r=new m({spatialReference:a.spatialReference}),n=a.centroid;if(n){const s=[];for(let r=0;r<a.rings[0].length;r++){const c=Math.sqrt((n.x-a.rings[0][r][0])**2+(n.y-a.rings[0][r][1])**2),o=h(t(e(),[a.rings[0][r][0],a.rings[0][r][1],0],[n.x,n.y,0]),1/c,1),f=l([n.x,n.y,0],o,c*i,1);s.push({x:f[0],y:f[1]})}r.addRing([[s[0].x,s[0].y,0],[s[1].x,s[1].y,0],[s[2].x,s[2].y,0],[s[3].x,s[3].y,0],[s[0].x,s[0].y,0]])}return r}return a}export{u as checkIfPolygonContainsSelectedPoint,R as computePolygonForInspection,p as createCoveragePolygon,w as resizePolygon};
