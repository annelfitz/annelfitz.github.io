/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import t from"../../../core/Logger.js";import{isAbortError as a}from"../../../core/promiseUtils.js";import{mul as r}from"../../../core/libs/gl-matrix-2/math/mat3.js";import i from"../../../geometry/Point.js";import{initializeProjection as n,project as o,projectWithZConversion as s}from"../../../geometry/projection.js";import{fromExtent as c}from"../../../geometry/support/aaBoundingRect.js";import{distance as l}from"../../../geometry/support/pointUtils.js";import{geographicToWebMercator as m}from"../../../geometry/support/webMercatorUtils.js";import p from"../../ElevationLayer.js";import u from"../../ImageryLayer.js";import{isConstantElevation as f,validateElevationSourceURL as y}from"../core/ElevationSourceDefinitions.js";import{geographicToLTP as d,convertSphereVertexToOrientation as g,convertOrientationToPixelLocation as h,calculateRotationMatrix as w}from"./utils.js";import{TileElevationSampler as R}from"../../support/ElevationSampler.js";import{ElevationTile as v}from"../../support/ElevationTile.js";import{ElevationTileData as b}from"../../support/ElevationTileData.js";import z from"../../support/TileInfo.js";import{TileKey as O}from"../../support/TileKey.js";import{defaultImageSphereCenter as j}from"../../../widgets/PanoramicViewer/constants.js";const x=Math.PI/180;async function P(e,t,a=!1){if(!e)return[];e=e.map((e=>"esri.geometry.Point"===e.declaredClass?e:i.fromJSON(e)));const{feature:r}=t,{attributes:n}=r;if(isNaN(parseFloat(n.elevation))){const e=await M([r.geometry],t);r.attributes.elevation=e[0].z}return M(e,t,a).then((e=>I(e,t)))}async function M(e,t,a=!1){if(a)return e;const{feature:{attributes:{cameraOrientation:r,elevationSource:i,cameraHeight:n,location:o}}}=t;return i&&(f(i)||i.url?.length)?S(e,t):N(e,r&&"number"==typeof o.z?o.z-n:0)}async function S(e,r){const{feature:i,options:o,footprintExtent:s}=r,l=i.attributes.elevationSource;if(!l)return e;if(f(l)){const{constantElevation:t}=l;return"number"!=typeof t?e:N(e,t)}const{url:m}=l;if(!m)return e;const{elevationSample:d}=i;if(!d){if(!s)return e;const r=s.clone(),{error:n,isSupported:f,isDynamic:d}=await y(m);if(!f){t.getLogger(l).warn(n);const{location:a,cameraHeight:r,cameraOrientation:o}=i.attributes;return N(e,o&&"number"==typeof a.z?a.z-r:0)}let h,w=e;try{if(d){h=new u({url:m,format:"lerc",rasterFunction:{functionName:l.rasterFunction??"None"}}),await h.load(o);let e,t=512,a=512;const n=s.width/s.height;n>1?(a/=n,e=r.height/a):(t*=n,e=r.width/t);const p=await h.fetchImage(s,t,a,o),f=z.create({scales:[e],size:512,spatialReference:s.spatialReference}),y=new O(null,0,0,0,c(s)),d=new b(p.pixelData.pixelBlock.pixels[0],t,a,0),g=new v(y,d);i.elevationSample=new R(g,f,void 0)}else h=new p(m),await h.load(),i.elevationSample=await h.createElevationSampler(r,o);w=e.map(E(i.elevationSample))}catch(g){if(!a(g)){t.getLogger("esri.layers.orientedImagery.transformations.groundToImageUtils").warn(`#updateElevation() failed to update elevation using the provided elevation source URL: ${m}. Please provide a valid elevation source url.`,g);const{location:a,cameraHeight:r,cameraOrientation:n}=i.attributes;e=N(e,n&&"number"==typeof a.z?a.z-r:0)}}finally{h?.destroy()}return w}return await n(e[0].spatialReference,d.spatialReference,null,r.options),e.map(E(d))}function E(e){return t=>{t.z=1;const a=e.queryElevation(o(t,e.spatialReference));return a?.z&&(t.z=a.z),t}}function N(e,t){return e.map((e=>(e.z=t,e)))}function I(e,t){const{attributes:a}=t.feature;return a.isSpherical||360===a.horizontalFieldOfView?H(e,t):a.cameraOrientation?.isAdvanced?L(e,t):Promise.resolve(q(e,t))}async function H(e,t){const a=Array.isArray(e)?e:[e],r=new Array,{location:i,cameraOrientation:n,cameraHeading:o}=t.feature.attributes,s=t.imageProperties.height??1,c=t.imageProperties.width??1;return await W(i,a,o,c,s,r,n),r}async function W(e,t,a,r,n,o,c){const p=e.spatialReference.isWGS84&&4!==c?.type?m(e):new i(e),{latitude:u,longitude:f,ellipsoidRadius:y,squaredEccentricity:w}=c??{};for(const m of t){const e=m.spatialReference.isWGS84&&4===c?.type?new i(d(m,[u,f,y,w])):m.spatialReference.equals(p.spatialReference)?new i(m):await s(m,p.spatialReference),t=l(p,e);e.x-=p.x,e.y-=p.y,e.z=(e.z??0)-(p.z??0);const R=g(e,t);R.heading=(R.heading-a)%360;const{x:v,y:b}=h(R.heading,R.pitch,r,n);o.push(new i(v,b,j.spatialReference))}}function q(e,t){const{feature:a,imageProperties:n}=t,{width:o,height:s}=n,{attributes:c}=a,l=w("HPR",[c.cameraHeading,c.cameraPitch,c.cameraRoll]),p=Math.sin(c.imageRotation??0*x),u=Math.cos(c.imageRotation??0*x),f=o??1,y=s??1,g=[Math.abs(u*f+p*y),Math.abs(u*y-p*f)],h={horizontal:1/(2*Math.tan(c.horizontalFieldOfView*x/2)),vertical:1/(2*Math.tan(c.verticalFieldOfView*x/2))},R=[-h.horizontal,0,.5,0,h.vertical,.5,0,0,1];let v=new i(c.geometry);v.spatialReference.isWGS84&&4!==c.cameraOrientation?.type&&(v=m(v));const b=v.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*v.y/6378137))):1,z=r(new Array(9),l,R);return e.map((e=>{let t=new i(e);if(t.spatialReference.isWGS84)if(4===c.cameraOrientation?.type){const e=c.cameraOrientation;t=new i(d(t,[e.latitude,e.longitude,e.ellipsoidRadius,e.squaredEccentricity]))}else t=new i(m(t));const a=(t.z??0)-(v.z??0),r=(t.x-v.x)/b,n=(t.y-v.y)/b,o=(z[0]*r+z[1]*n+z[2]*a)/(z[6]*r+z[7]*n+z[8]*a),s=(z[3]*r+z[4]*n+z[5]*a)/(z[6]*r+z[7]*n+z[8]*a),l={x:o*g[0],y:s*g[1]};return{x:u*(l.x-g[0]/2)+p*(l.y-g[1]/2)+f/2,y:-p*(l.x-g[0]/2)+u*(l.y-g[1]/2)+y/2}}))}function L(t,a){const{feature:r}=a,{attributes:s}=r,c=s.cameraOrientation;if(!c)throw new e("groundToImageUtils:missing-camera-orientation-parameters","CameraOrientation Parameters are required to perform advanced transformations");let l=new i(s.location);l.spatialReference.isWGS84&&4!==s.cameraOrientation?.type&&(l=m(l));const p=l.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*l.y/6378137))):1;let u;if("esri.layers.orientedImagery.core.CameraOrientationOPK"===c.declaredClass){const{omega:e,phi:t,kappa:a}=c;u=w("OPK",[e,t,a])}else{const{cameraHeading:e,cameraPitch:t,cameraRoll:a}=s;u=w("HPR",[e,t,a])}const{principalOffsetPoint:f,focalLength:y,radialDistortionCoefficients:g,affineTransformations:h,tangentialDistortionCoefficients:R}=c;return Promise.all(t.map((async e=>{let r;return e.spatialReference.equals(l.spatialReference)?(r=new i(e),c(r)):(await n(t[0].spatialReference,l.spatialReference,null,a.options),r=o(e,l.spatialReference),r?c(r):null);function c(e){if(e.spatialReference.isWGS84)if(4===s.cameraOrientation?.type){const t=s.cameraOrientation;e=new i(d(e,[t.latitude,t.longitude,t.ellipsoidRadius,t.squaredEccentricity]))}else e=new i(m(e));const t=(e.z??0)-(l.z??0),a=(e.x-l.x)/p,r=(e.y-l.y)/p,n=(u[0]*a+u[1]*r+u[2]*t)/(u[6]*a+u[7]*r+u[8]*t),o=(u[3]*a+u[4]*r+u[5]*t)/(u[6]*a+u[7]*r+u[8]*t),c=n**2+o**2;let w=0,v=0,b=0,z=0,O=0,j=0,x=0;g&&(w=g[0]??0,v=g[1]??0,b=g[2]??0),R&&(z=R[0],O=R[1]),f&&(j=f[0]??0,x=f[1]??0);const P=1+(w||0)*c+(v||0)*c*c+(b||0)*c*c*c;let M=n*P+(z||0)*(c+2*n**2)+2*(O||0)*n*o,S=o*P+(O||0)*(c+2*o**2)+2*(z||0)*n*o;M=-(y??0)*M+j,S=-(y??0)*S+x;return{x:Number(h[0])+Number(h[1])*M+Number(h[2])*S,y:Number(h[3])+Number(h[4])*M+Number(h[5])*S}}})))}export{P as transformPoints,H as transformPointsEquirectangularPanorama,M as updateElevation,S as updateElevationUsingElevationSource};
