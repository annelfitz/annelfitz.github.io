/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import t from"../../../core/Logger.js";import{memoize as r}from"../../../core/memoize.js";import{waitTick as o,isAbortError as a}from"../../../core/promiseUtils.js";import{projectWithZConversion as n}from"../../../geometry/projection.js";import{fromExtent as i}from"../../../geometry/support/aaBoundingRect.js";import s from"../../ElevationLayer.js";import c from"../../ImageryLayer.js";import{TileElevationSampler as l}from"../../support/ElevationSampler.js";import{ElevationTile as p}from"../../support/ElevationTile.js";import{ElevationTileData as u}from"../../support/ElevationTileData.js";import m from"../../support/RasterFunction.js";import f from"../../support/TileInfo.js";import{TileKey as w}from"../../support/TileKey.js";import{fetchArcGISServiceJSON as y}from"../../../support/requestPresets.js";import{logAndThrow as g}from"../../../widgets/OrientedImageryViewer/utils.js";async function v(t,r,o){const a="url"in r?await j(r):r;if(!a)throw g("esri.layers.orientedImagery.transformations",new e("update-elevation:elevation-source","could not create a sampler using provided elevation source",r));return d(t,a,o)}async function d(e,t,r){await o(r);const a=new Array,n=z(t,r);for(const o of e){const e=await n(o);a.push(e)}return a}async function E(e,t,r=!0,a){await o(a);const{cameraHeight:n,cameraLocation:i,cameraOrientation:s}=e;return A(t,s&&"number"==typeof i.z?i.z-n:0,r,a)}var h;!function(e){e[e.DYNAMIC=0]="DYNAMIC",e[e.ELEVATION=1]="ELEVATION"}(h||(h={}));const j=r((async(e,r)=>{let o;const{extent:n,rasterFunction:i,url:s}=e;try{o=await R(s)}catch(c){if(a(c))return;t.getLogger("esri.layers.orientedImagery.transformations").error("updateElevationUsingElevationSource",c)}switch(o){case h.DYNAMIC:return await L(s,n,i,r);case h.ELEVATION:return await I(s,n,r);default:return}}));async function I(e,r,o){const n=new s(e);let i;try{await n.load(),i=await n.createElevationSampler(r,o)}catch(c){if(a(c))return;t.getLogger(n).error(c)}finally{n.destroy()}return i}async function L(e,t,r,o){const a=r?new m({functionName:r}):void 0,n=new c({url:e,rasterFunction:a,format:"lerc"});await n.load(o);let s,y=512,g=512;const v=t.width/t.height;v>1?(g/=v,s=t.height/g):(y*=v,s=t.width/y);const d=await n.fetchImage(t,y,g,o),E=f.create({scales:[s],size:512,spatialReference:t.spatialReference}),h=new w(null,0,0,0,i(t)),j=new u(d.pixelData.pixelBlock.pixels[0],y,g,0),I=new p(h,j);return new l(I,E,void 0)}async function R(t){const r=await y(t),{tileInfo:o,cacheType:a}=r;if(!r.hasOwnProperty("bandCount")||!r.hasOwnProperty("pixelSizeX"))throw new e("elevation-source:invalid-service-url",`ElevationSource URL expects an elevation 3D image service but given ${t}`);return"LERC"!==o?.format?.toUpperCase()||a&&"elevation"!==a.toLowerCase()?h.DYNAMIC:h.ELEVATION}function z(e,t){return async r=>{let o=r.clone();const a=r.spatialReference.equals(e.spatialReference)?o:await n(r,e.spatialReference,t),i=e.queryElevation(a);if(i){o=r.spatialReference.equals(e.spatialReference)?i.clone():await n(i,r.spatialReference,t)}return o.z=o.z??1,o}}async function A(e,t,r=!0,a){if(await o(a),r)return e.map((e=>(e.z=t,e)));for(const o of e)o.z=t;return e}export{j as getElevationSampler,E as updateUsingCameraProperties,A as updateUsingConstant,d as updateUsingElevationSampler,v as updateUsingElevationSource,R as validateElevationSourceURL};
