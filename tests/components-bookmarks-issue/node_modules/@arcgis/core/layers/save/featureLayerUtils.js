/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{equals as e,difference as r,isSome as a}from"../../core/arrayUtils.js";import t from"../../core/Error.js";import{updateOrigins as o}from"../../core/accessorSupport/originUtils.js";import{save as n,createJSONContextForWrite as s,getLayerJSON as i,setCommonItemProperties as l,saveAs as c,getPortalItem as u,addItem as p,ensureLayerConfig as y,ensureItemConfig as f,createErrorMessage as m}from"./utils.js";import{parse as d}from"../support/arcgisLayerUrl.js";import{fetchFeatureService as h,getLayerModuleType as w}from"../support/fetchService.js";import{isLayerWithFeatureLayerSource as v}from"../support/layerUtils.js";import{layerLookupMap as T}from"../support/lazyLayerLoader.js";import{getWGS84ExtentForItem as I,removeTypeKeyword as S,typeKeyword as b,toggleTypeKeyword as A,addTypeKeyword as L}from"../../portal/support/portalItemUtils.js";const P="Feature Service",E="feature-layer-utils",$=`${E}-save`,x=`${E}-save-as`,N=`${E}-saveall`,g=`${E}-saveall-as`;function O(e){return{isValid:v(e)&&("feature"!==e.type||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function U(e){const r=[],a=[];for(const{layer:t,layerJSON:o}of e)t.isTable?a.push(o):r.push(o);return{layers:r,tables:a}}function j(e){return U([e])}async function J(e,r){return/\/\d+\/?$/.test(e.url)?j(r[0]):M(r,e)}async function M(e,r){if(e.reverse(),!r)return U(e);const a=await R(r,e);for(const t of e)k(t.layer,t.layerJSON,a);return K(a,e),a}async function R(e,r){let a=await e.fetchData("json");if(D(a))return a;a||={},F(a);const{layer:{url:t,customParameters:o,apiKey:n}}=r[0];return await z(a,{url:t??"",customParameters:o,apiKey:n},r.map((e=>e.layer.layerId))),a}function D(e){return!!(e&&Array.isArray(e.layers)&&Array.isArray(e.tables))}function F(e){e.layers||=[],e.tables||=[]}function K(e,r){const a=[],t=[];for(const{layer:o}of r){const{isTable:e,layerId:r}=o;e?t.push(r):a.push(r)}Y(e.layers,a),Y(e.tables,t)}function Y(r,a){if(r.length<2)return;const t=[];for(const{id:e}of r)t.push(e);e(t.sort(_),a.slice().sort(_))&&r.sort(((e,r)=>{const t=a.indexOf(e.id),o=a.indexOf(r.id);return t<o?-1:t>o?1:0}))}function _(e,r){return e<r?-1:e>r?1:0}async function z(e,r,a){const{url:t,customParameters:o,apiKey:n}=r,{serviceJSON:s,layersJSON:i}=await h(t,{customParameters:o,apiKey:n}),l=G(e.layers,s.layers,a),c=G(e.tables,s.tables,a);e.layers=l.itemResources,e.tables=c.itemResources;const u=[...l.added,...c.added],p=i?[...i.layers,...i.tables]:[];await B(e,u,t,p)}function G(e,a,t){const o=r(e,a,((e,r)=>e.id===r.id));e=e.filter((e=>!o.removed.some((r=>r.id===e.id))));const n=o.added;return n.forEach((({id:r})=>{e.push({id:r})})),{itemResources:e,added:n.filter((({id:e})=>!t.includes(e)))}}async function B(e,r,a,t){const o=await V(r),n=r.map((({id:e,type:r})=>new(o.get(r))({url:a,layerId:e,sourceJSON:t.find((({id:r})=>r===e))})));await Promise.allSettled(n.map((e=>e.load()))),n.forEach((r=>{const{layerId:a,loaded:t,defaultPopupTemplate:o}=r;if(!t||null==o)return;const n={id:a,popupInfo:o.toJSON()};"ArcGISFeatureLayer"!==r.operationalLayerType&&(n.layerType=r.operationalLayerType),k(r,n,e)}))}async function V(e){const r=[];e.forEach((({type:e})=>{const a=w(e),t=T[a];r.push(t())}));const a=await Promise.all(r),t=new Map;return e.forEach((({type:e},r)=>{t.set(e,a[r])})),t}function k(e,r,a){e.isTable?q(a.tables,r):q(a.layers,r)}function q(e,r){const a=e.findIndex((({id:e})=>e===r.id));-1===a?e.push(r):e[a]=r}function C(e,r){if(!e.length)throw new t(`${r}:missing-parameters`,"'layers' array should contain at least one feature layer")}function H(e,r){const a=e.map((e=>e.portalItem.id));if(new Set(a).size>1)throw new t(`${r}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function Q(e,r){const a=e.map((e=>e.layerId));if(new Set(a).size!==a.length)throw new t(`${r}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function W(e){C(e,N),await Promise.all(e.map((e=>e.load())));for(const r of e)y(r,N,O),f({layer:r,itemType:P,errorNamePrefix:N});H(e,N),Q(e,N)}async function X(e,r){const{url:a,layerId:t,title:o,fullExtent:n,isTable:s}=e,i=d(a);r.url="FeatureServer"===i?.serverType?a:`${a}/${t}`,r.title||=o,r.extent=null,s||null==n||(r.extent=await I(n)),S(r,b.METADATA),S(r,b.MULTI_LAYER),L(r,b.SINGLE_LAYER),s&&L(r,b.TABLE)}function Z(e,r){for(const s of e){const a=s.parsedUrl.path,o=d(a),n=o?.url.path;if(!n)throw new t(`${r}:invalid-parameters`,m(s,`has unsupported url pattern: ${a}`),{layer:s});const i=o?.serverType;if("FeatureServer"!==i&&"MapServer"!==i)throw new t(`${r}:invalid-parameters`,m(s,`has unsupported server type: ${i}`),{layer:s});if("MapServer"===i&&e.length>1)throw new t(`${r}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const a=d(e[0].parsedUrl.path),o=a?.url.path,n=e.every((e=>{const r=d(e.parsedUrl.path);return r?.url.path===o}));if(!n)throw new t(`${r}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ee(e){C(e,g),await Promise.all(e.map((e=>e.load())));for(const r of e)y(r,g,O);Z(e,g),Q(e,g)}async function re(e,r){let t=0,o=0;for(const{isTable:a}of r)a?o++:t++;const n=r[0].parsedUrl.path,s=d(n);if(e.url="FeatureServer"===s?.serverType?s.url.path:n,e.title||=s.title,e.extent=null,t>0){const t=r.map((e=>e.fullExtent)).filter(a).reduce(((e,r)=>e.clone().union(r)));t&&(e.extent=await I(t))}S(e,b.METADATA),A(e,b.MULTI_LAYER,r.length>1),A(e,b.SINGLE_LAYER,1===r.length),A(e,b.TABLE,o>0&&0===t),l(e)}async function ae(e,r){return n({layer:e,itemType:P,validateLayer:O,createItemData:(e,r)=>J(r,[e]),errorNamePrefix:$},r)}async function te(e,r){await W(e);const a=e[0].portalItem,t=s(a),n=await Promise.all(e.map((e=>i(e,t,r)))),c=await J(a,e.map(((e,r)=>({layer:e,layerJSON:n[r]}))));return l(a),await a.update({data:c}),await Promise.all(e.slice(1).map((e=>e.portalItem.reload()))),o(t),a.clone()}async function oe(e,r,a){return c({layer:e,itemType:P,validateLayer:O,createItemData:(e,r)=>Promise.resolve(j(e)),errorNamePrefix:x,newItem:r,setItemProperties:X},a)}async function ne(e,r,a){await ee(e);const t=u({itemType:P,errorNamePrefix:g,newItem:r}),n=s(t),l=await Promise.all(e.map((e=>i(e,n,a)))),c=await M(e.map(((e,r)=>({layer:e,layerJSON:l[r]}))));await re(t,e),await p(t,c,a);for(const o of e)o.portalItem=t.clone();return o(n),t}export{ae as save,te as saveAll,ne as saveAllAs,oe as saveAs};
