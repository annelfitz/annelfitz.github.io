/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import{id as t}from"../../../kernel.js";import s from"../../../request.js";import r from"../../../TimeExtent.js";import{isSome as a}from"../../../core/arrayUtils.js";import i from"../../../core/Error.js";import has from"../../../core/has.js";import{JSONMap as o}from"../../../core/jsonMap.js";import n from"../../../core/Loadable.js";import u from"../../../core/Logger.js";import{setDeepValue as l}from"../../../core/object.js";import{debounce as c,after as d,throwIfAbortError as p}from"../../../core/promiseUtils.js";import{join as y}from"../../../core/urlUtils.js";import{generateBracedUUID as h}from"../../../core/uuid.js";import{property as m}from"../../../core/accessorSupport/decorators/property.js";import{subclass as f}from"../../../core/accessorSupport/decorators/subclass.js";import g from"../../../geometry/Extent.js";import{isRelativeVertexSpace as w,toRelativeVertexSpace as S}from"../../../geometry/support/meshVertexSpaceUtils.js";import{isOriginalExternal as q}from"../../../geometry/support/meshUtils/External.js";import{createFeatureEditResult as E,getFeatureJSON as O,getFeatureIds as R,getAttachmentEditsJSON as b,isProtectedOrPrivateVersionError as A,unpackEditResultData as F,createEditedFeatures as _}from"../applyEditsUtils.js";import{createDrawingInfo as x}from"./support/clientSideDefaults.js";import j from"./support/QueryTask.js";import{isHostedAgolService as I}from"../../support/arcgisLayerUrl.js";import{ensureLayerCredential as v}from"../../support/featureLayerUtils.js";import{getAssetMapTable as T}from"../../support/infoFor3D.js";import{executeQueryJSON as N}from"../../../rest/query/executeQueryJSON.js";import{unapplyEditsZUnitScaling as M}from"../../../rest/query/operations/editsZScale.js";import U from"../../../rest/support/Query.js";import{isSafeToEditVersion as J,isVersionInEditSession as k,isHistoricVersion as L,currentSessionId as Q}from"../../../versionManagement/support/versionManagementUtils.js";import C from"../../../geometry/SpatialReference.js";const D=new o({originalAndCurrentFeatures:"original-and-current-features",none:"none"}),P=new o({Started:"published",Publishing:"publishing",Stopped:"unavailable"});let $=class extends n{constructor(){super(...arguments),this.type="feature-layer",this.supportedSourceTypes=new Set(["Feature Layer","Oriented Imagery Layer","Table","Catalog Layer"]),this.refresh=c((async()=>{await this.load();const e=this.sourceJSON.editingInfo?.lastEditDate;if(null==e)return{dataChanged:!0,updates:{}};try{await this._fetchService(null)}catch{return{dataChanged:!0,updates:{}}}const t=e!==this.sourceJSON.editingInfo?.lastEditDate;return{dataChanged:t,updates:t?{editingInfo:this.sourceJSON.editingInfo,extent:this.sourceJSON.extent}:null}})),this._ongoingAssetUploads=new Map}load(e){const t=this.layer.sourceJSON,s=this._fetchService(t,{...e}).then((()=>this.layer.setUserPrivileges(this.sourceJSON.serviceItemId,e))).then((()=>this._ensureLatestMetadata(e)));return this.addResolvingPromise(s),Promise.resolve(this)}get queryTask(){const{capabilities:e,parsedUrl:t,dynamicDataSource:s,infoFor3D:r,gdbVersion:a,spatialReference:i,fieldsIndex:o}=this.layer,n=has("featurelayer-pbf")&&e?.query.supportsFormatPBF&&null==r,u=e?.operations?.supportsQueryAttachments??!1;return new j({url:t.path,pbfSupported:n,fieldsIndex:o,infoFor3D:r,dynamicDataSource:s,gdbVersion:a,sourceSpatialReference:i,queryAttachmentsSupported:u})}async addAttachment(e,t){await this.load();const{layer:r}=this;await v(r,"editing");const a=e.attributes[r.objectIdField],i=r.parsedUrl.path+"/"+a+"/addAttachment",o=this._getLayerRequestOptions(),n=this._getFormDataForAttachment(t,o.query);try{const e=await s(i,{body:n});return E(e.data.addAttachmentResult)}catch(u){throw this._createAttachmentErrorResult(a,u)}}async updateAttachment(e,t,r){await this.load();const{layer:a}=this;await v(a,"editing");const i=e.attributes[a.objectIdField],o=a.parsedUrl.path+"/"+i+"/updateAttachment",n=this._getLayerRequestOptions({query:{attachmentId:t}}),u=this._getFormDataForAttachment(r,n.query);try{const e=await s(o,{body:u});return E(e.data.updateAttachmentResult)}catch(l){throw this._createAttachmentErrorResult(i,l)}}async applyEdits(e,r){await this.load();const{layer:o}=this;await v(o,"editing");const n=o.infoFor3D,u=null!=n,l=u||(r?.globalIdUsed??!1),c=u?await this._uploadMeshesAndGetAssetMapEditsJSON(e):null,d=e.addFeatures?.map((e=>O(this.layer,e,n)))??[],p=(await Promise.all(d)).filter(a),y=e.updateFeatures?.map((e=>O(this.layer,e,n)))??[],h=(await Promise.all(y)).filter(a),m=R(this.layer,e.deleteFeatures,l);M(p,h,o.spatialReference);const f=await b(this.layer,e),g=o.capabilities.editing.supportsAsyncApplyEdits&&u,w=r?.gdbVersion||o.gdbVersion,S={gdbVersion:w,rollbackOnFailure:r?.rollbackOnFailureEnabled,useGlobalIds:l,returnEditMoment:r?.returnEditMoment,usePreviousEditMoment:r?.usePreviousEditMoment,async:g};await J(this.layer.url,w,!0);const q=k(this.layer.url,w||null);if(await L(o.url,w,o.historicMoment))throw new i("feature-layer-source:historic-version","Editing a historic version is not allowed");r?.returnServiceEditsOption?(S.edits=JSON.stringify([{id:o.layerId,adds:p,updates:h,deletes:m,attachments:f,assetMaps:c}]),S.returnServiceEditsOption=D.toJSON(r?.returnServiceEditsOption),S.returnServiceEditsInSourceSR=r?.returnServiceEditsInSourceSR):(S.adds=p.length?JSON.stringify(p):null,S.updates=h.length?JSON.stringify(h):null,S.deletes=m.length?l?JSON.stringify(m):m.join(","):null,S.attachments=f&&JSON.stringify(f),S.assetMaps=null!=c?JSON.stringify(c):void 0);const E=this._getLayerRequestOptions({method:"post",query:S});q&&(E.authMode="immediate",E.query.returnEditMoment=!0,E.query.sessionId=Q);const F=r?.returnServiceEditsOption?o.url:o.parsedUrl.path;let _;try{_=g?await this._asyncApplyEdits(F+"/applyEdits",E):await s(F+"/applyEdits",E)}catch(x){if(!A(x))throw x;E.authMode="immediate",_=g?await this._asyncApplyEdits(F+"/applyEdits",E):await s(F+"/applyEdits",E)}if(!o.capabilities.operations?.supportsEditing&&o.effectiveCapabilities?.operations?.supportsEditing){const e=t?.findCredential(o.url);await(e?.refreshToken())}return this._createEditsResult(_)}async deleteAttachments(e,t){await this.load();const{layer:r}=this;await v(r,"editing");const a=e.attributes[r.objectIdField],i=r.parsedUrl.path+"/"+a+"/deleteAttachments";try{return(await s(i,this._getLayerRequestOptions({query:{attachmentIds:t.join(",")},method:"post"}))).data.deleteAttachmentResults.map(E)}catch(o){throw this._createAttachmentErrorResult(a,o)}}fetchRecomputedExtents(e={}){const t=e.signal;return this.load({signal:t}).then((async()=>{const t=this._getLayerRequestOptions({...e,query:{returnUpdates:!0}}),{layerId:a,url:i}=this.layer,{data:o}=await s(`${i}/${a}`,t),{id:n,extent:u,fullExtent:l,timeExtent:c}=o,d=u||l;return{id:n,fullExtent:d&&g.fromJSON(d),timeExtent:c&&r.fromJSON({start:c[0],end:c[1]})}}))}async queryAttachments(e,t={}){await this.load();const s=this._getLayerRequestOptions(t);return this.queryTask.executeAttachmentQuery(e,s)}async queryFeatures(e,t){await this.load();const s=await this.queryTask.execute(e,{...t,query:this._createRequestQueryOptions(t)});return e.outStatistics?.length&&s.features.length&&s.features.forEach((t=>{const s=t.attributes;e.outStatistics?.forEach((({outStatisticFieldName:e})=>{if(e){const t=e.toLowerCase();t&&t in s&&e!==t&&(s[e]=s[t],delete s[t])}}))})),s}async queryFeaturesJSON(e,t){return await this.load(),this.queryTask.executeJSON(e,{...t,query:this._createRequestQueryOptions(t)})}async queryObjectIds(e,t){return await this.load(),this.queryTask.executeForIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryFeatureCount(e,t){return await this.load(),this.queryTask.executeForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryExtent(e,t){return await this.load(),this.queryTask.executeForExtent(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeatures(e,t){return await this.load(),this.queryTask.executeRelationshipQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeaturesCount(e,t){return await this.load(),this.queryTask.executeRelationshipQueryForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopFeatures(e,t){return await this.load(),this.queryTask.executeTopFeaturesQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopObjectIds(e,t){return await this.load(),this.queryTask.executeForTopIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopExtents(e,t){return await this.load(),this.queryTask.executeForTopExtents(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopCount(e,t){return await this.load(),this.queryTask.executeForTopCount(e,{...t,query:this._createRequestQueryOptions(t)})}async fetchPublishingStatus(){if(!I(this.layer.url))return"unavailable";const e=y(this.layer.url,"status"),t=await s(e,{query:{f:"json"}});return P.fromJSON(t.data.status)}async uploadAssets(e,t){const{uploadAssets:s}=await import("./support/uploadAssets.js");return s(e,{layer:this.layer,ongoingUploads:this._ongoingAssetUploads},t)}async _asyncApplyEdits(e,t){const r=(await s(e,t)).data.statusUrl;for(;;){const e=(await s(r,{query:{f:"json"},responseType:"json"})).data;switch(e.status){case"Completed":return s(e.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new i("async-applyEdits-failed","asynchronous applyEdits call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new i("async-applyEdits-failed","asynchronous applyEdits call failed (undefined response status)")}await d(V)}}_createRequestQueryOptions(e){const t={...this.layer.customParameters,token:this.layer.apiKey,...e?.query};return this.layer.datesInUnknownTimezone&&(t.timeReferenceUnknownClient=!0),t}async _fetchService(e,t){if(!e){const r={};has("featurelayer-advanced-symbols")&&(r.returnAdvancedSymbols=!0),t?.cacheBust&&(r._ts=Date.now());const{data:a}=await s(this.layer.parsedUrl.path,this._getLayerRequestOptions({query:r,signal:t?.signal}));e=a}this.sourceJSON=await this._patchServiceJSON(e,t?.signal);const r=e.type;if(!this.supportedSourceTypes.has(r))throw new i("feature-layer-source:unsupported-type",`Source type "${r}" is not supported`)}async _patchServiceJSON(e,t){if("Table"!==e.type&&e.geometryType&&!e?.drawingInfo?.renderer&&!e.defaultSymbol){const t=x(e.geometryType).renderer;l("drawingInfo.renderer",t,e)}if("esriGeometryMultiPatch"===e.geometryType&&e.infoFor3D&&(e.geometryType="mesh"),null==e.extent)try{const{data:r}=await s(this.layer.url,this._getLayerRequestOptions({signal:t}));r.spatialReference&&(e.extent={xmin:0,ymin:0,xmax:0,ymax:0,spatialReference:r.spatialReference})}catch(r){p(r)}return e}async _ensureLatestMetadata(e){if(this.layer.userHasUpdateItemPrivileges&&this.sourceJSON.cacheMaxAge>0)return this._fetchService(null,{...e,cacheBust:!0})}async _uploadMeshesAndGetAssetMapEditsJSON(e){const{addAssetFeatures:t}=e;if(!t?.length)return null;const s=await this._filterRedundantAssetMaps(t);if(!t?.length)return null;const r=new Array,a=new Map;for(const i of s){const{geometry:e}=i,{vertexSpace:t}=e;if(w(t))r.push(e);else{const t=S(e);a.set(t,e),i.geometry=t,r.push(t)}}await this.uploadAssets(r);for(const[i,o]of a)o.addExternalSources(i.metadata.externalSources.items);return{adds:this._getAssetMapEditsJSON(s),updates:[],deletes:[]}}_getAssetMapEditsJSON(e){const t=new Array,s=this.layer.globalIdField,r=this.layer.parsedUrl;for(const a of e){const e=a.geometry,{metadata:i}=e,o=i.getExternalSourcesOnService(r),n=a.getAttribute(s);if(0===o.length){u.getLogger(this).error(`Skipping feature ${n}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);continue}const{source:l}=o.find(q)??o[0];for(const s of l)1===s.parts.length?t.push({globalId:h(),parentGlobalId:n,assetName:s.assetName,assetHash:s.parts[0].partHash,flags:[]}):u.getLogger(this).error(`Skipping asset ${s.assetName}. It does not have exactly one part, so we cannot map it to a feature.`)}return t}_createEditsResult(e){const t=e.data,{layerId:s}=this.layer,r=[];let a=null;if(Array.isArray(t))for(const o of t)r.push({id:o.id,editedFeatures:o.editedFeatures}),o.id===s&&(a={addResults:o.addResults??[],updateResults:o.updateResults??[],deleteResults:o.deleteResults??[],attachments:o.attachments,editMoment:o.editMoment});else a=t;const i=F(a);if(r.length>0){i.editedFeatureResults=[];for(const e of r){const{editedFeatures:t}=e,s=t?.spatialReference?new C(t.spatialReference):null;i.editedFeatureResults.push({layerId:e.id,editedFeatures:_(t,s)})}}return i}_createAttachmentErrorResult(e,t){const s=t.details.messages?.[0]||t.message,r=t.details.httpStatus||t.details.messageCode;return{objectId:e,globalId:null,error:new i("feature-layer-source:attachment-failure",s,{code:r})}}_getFormDataForAttachment(e,t){const s=e instanceof FormData?e:e&&e.elements?new FormData(e):null;if(s)for(const r in t){const e=t[r];null!=e&&(s.set?s.set(r,e):s.append(r,e))}return s}_getLayerRequestOptions(e={}){const{parsedUrl:t,gdbVersion:s,dynamicDataSource:r}=this.layer;return{...e,query:{gdbVersion:s,layer:r?JSON.stringify({source:r}):void 0,...t.query,f:"json",...this._createRequestQueryOptions(e)},responseType:"json"}}async _filterRedundantAssetMaps(e){const{layer:t}=this,{globalIdField:s,infoFor3D:r,parsedUrl:i}=t;if(null==r||null==s)return e;const o=T(r);if(null==o)return e;const n=y(i.path,`../${o.id}`),u=new Array,l=new Array;for(const a of e)a.geometry.metadata.getExternalSourcesOnService(i).length>0?l.push(a):u.push(a);const c=l.map((e=>e.getAttribute(s))).filter(a);if(0===c.length)return e;const{assetMapFieldRoles:{parentGlobalId:d,assetHash:p}}=r,h=new U({where:`${d} IN (${c.map((e=>`'${e}'`))})`,outFields:[p,d],returnGeometry:!1}),m=await N(n,h),{features:f}=m;return 0===f.length?e:[...u,...l.filter((e=>{const t=e.getAttribute(s);if(!t)return!0;const{metadata:r}=e.geometry,a=f.filter((e=>e.getAttribute(d)===t));if(0===a.length)return!0;const o=a.map((e=>e.getAttribute(p)));return r.getExternalSourcesOnService(i).flatMap((({source:e})=>e.flatMap((e=>e.parts.map((e=>e.partHash)))))).some((e=>o.every((t=>e!==t))))}))]}};e([m()],$.prototype,"type",void 0),e([m({constructOnly:!0})],$.prototype,"layer",void 0),e([m({constructOnly:!0})],$.prototype,"supportedSourceTypes",void 0),e([m({readOnly:!0})],$.prototype,"queryTask",null),$=e([f("esri.layers.graphics.sources.FeatureLayerSource")],$);const V=1e3,G=$;export{G as default};
