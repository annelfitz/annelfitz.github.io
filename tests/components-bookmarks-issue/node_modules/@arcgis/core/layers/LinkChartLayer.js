/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import"../geometry.js";import t from"../core/Collection.js";import a from"../core/Error.js";import i from"../core/Logger.js";import{throwIfAborted as n}from"../core/promiseUtils.js";import{property as s}from"../core/accessorSupport/decorators/property.js";import"../core/has.js";import"../core/RandomLCG.js";import{subclass as o}from"../core/accessorSupport/decorators/subclass.js";import{encodeGeohash as r}from"../geohash/geohashUtils.js";import h from"./Layer.js";import{convertFromGeometry as l}from"./graphics/featureConversionUtils.js";import p from"./graphics/OptimizedGeometry.js";import{KnowledgeGraphLayerDataManager as d,mockOidFieldName as c,mockOriginIdFieldName as u,mockDestinationIdFieldName as y,mockLayoutGeometryFieldName as m,mockAggregationCountFieldName as g,geohashEncodingPrecision as f}from"./knowledgeGraph/KnowledgeGraphLayerDataManager.js";import k from"./knowledgeGraph/KnowledgeGraphSublayer.js";import{getRelationshipEndNodeIds as L}from"./knowledgeGraph/supportUtils.js";import{BlendLayer as C}from"./mixins/BlendLayer.js";import{ScaleRangeLayer as M}from"./mixins/ScaleRangeLayer.js";import{LCSimpleLayout as w,LCSmartTreeLayout as b,LCRadialTreeLayout as D,LCHierarchicalLayout as x,LCCommunityLayout as T,LCForceDirectedLayout as E,NodeFlag as N,load as G,LinkType as R}from"../libs/linkchartlayout/LinkChartLayout.js";import{fetchKnowledgeGraph as I}from"../rest/knowledgeGraphService.js";import v from"../rest/knowledgeGraph/EntityType.js";import A from"../rest/knowledgeGraph/RelationshipType.js";import _ from"../geometry/Extent.js";import j from"../geometry/Point.js";import P from"../geometry/Polyline.js";const S=(e,t,a)=>(e.has(t)||e.set(t,a()),e.get(t));let z=class extends(C(M(h))){constructor(e){if(super(e),this.dataPreloadedInLocalCache=!1,this.defaultLinkChartConfig=null,this._currentLinkChartConfig={layoutMode:"RADIAL_TREE"},this._graphTypeLookup=new Map,this.dataManager=null,this.knowledgeGraph=null,this.layers=new t,this.entityLinkChartDiagramLookup=new Map,this.relationshipLinkChartDiagramLookup=new Map,this.linkChartExtent=new _({xmin:-1e-7,ymin:-1e-7,xmax:1e-7,ymax:1e-7}),this.linkChartGeohashLookup=new Map,this.memberEntityTypes=null,this.memberRelationshipTypes=null,this.sublayerIdsCache=new Map,this.tables=new t,this.type="link-chart",this._originalInclusionList=e.inclusionModeDefinition,e.dataPreloadedInLocalCache&&!e.inclusionModeDefinition)throw new a("knowledge-graph:linkchart-layer-constructor","If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it")}normalizeCtorArgs(e){return{url:e.url,title:e.title,dataPreloadedInLocalCache:e.dataPreloadedInLocalCache,defaultLinkChartConfig:e.defaultLinkChartConfig}}_initializeLayerProperties(e){if(!this.title&&this.url){const e=this.url.split("/");this.title=e[e.length-2]}const t=new Set;let n=[],s=[];if(e.inclusionModeDefinition&&(!e.inclusionModeDefinition.namedTypeDefinitions||e.inclusionModeDefinition.namedTypeDefinitions.size<1))throw new a("knowledge-graph:composite-layer-constructor","If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");e.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&this._graphTypeLookup.set(e.name,e)})),e.knowledgeGraph.dataModel.relationshipTypes?.forEach((e=>{e.name&&this._graphTypeLookup.set(e.name,e)})),e.inclusionModeDefinition?.generateAllSublayers?(n=e.knowledgeGraph.dataModel.entityTypes??[],s=e.knowledgeGraph.dataModel.relationshipTypes??[]):e.inclusionModeDefinition?.namedTypeDefinitions&&e.inclusionModeDefinition?.namedTypeDefinitions.size>0?e.inclusionModeDefinition?.namedTypeDefinitions.forEach(((a,o)=>{if(!this._graphTypeLookup.get(o))return i.getLogger(this).warn(`A named type, ${o}, was in the inclusion list that wasn't in the data model and will be removed`),void e.inclusionModeDefinition?.namedTypeDefinitions.delete(o);this._graphTypeLookup.get(o)instanceof A||"strictOrigin"in this._graphTypeLookup.get(o)?t.has(o)||(t.add(o),s.push(this._graphTypeLookup.get(o))):this._graphTypeLookup.get(o)instanceof v||"properties"in this._graphTypeLookup.get(o)?t.has(o)||(t.add(o),n.push(this._graphTypeLookup.get(o))):(i.getLogger(this).warn(`A named type, ${o}, was in the inclusion list that wasn't properly modeled and will be removed`),e.inclusionModeDefinition?.namedTypeDefinitions.delete(o))})):(n=e.knowledgeGraph.dataModel.entityTypes??[],s=e.knowledgeGraph.dataModel.relationshipTypes??[]);const o=new d({knowledgeGraph:e.knowledgeGraph,inclusionModeDefinition:e.inclusionModeDefinition});this.knowledgeGraph=e.knowledgeGraph,this.memberEntityTypes=n,this.memberRelationshipTypes=s,this.dataManager=o}load(e){return this.addResolvingPromise(new Promise((t=>{I(this.url).then((a=>{if(this._initializeLayerProperties({knowledgeGraph:a,inclusionModeDefinition:this._originalInclusionList}),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.size||(this.dataManager.inclusionModeDefinition={generateAllSublayers:!1,namedTypeDefinitions:new Map},this.dataManager.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e.name,{useAllData:!0})})),this.dataManager.knowledgeGraph.dataModel.relationshipTypes?.forEach((e=>{e.name&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e.name,{useAllData:!0})}))),this.dataPreloadedInLocalCache)this.loadLayerAssumingLocalCache(),this.dataManager.inclusionModeDefinition&&(this.dataManager.inclusionModeDefinition.generateAllSublayers=!1),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((e=>{e.useAllData=!1,e.members?.forEach((e=>{let t;t=e.linkChartLocation instanceof p?e.linkChartLocation:e.linkChartLocation?l(e.linkChartLocation):null,t&&2===t.coords.length&&0===t.lengths.length?(this.linkChartGeohashLookup.set(e.id,r(t.coords[1],t.coords[0],f)),this.entityLinkChartDiagramLookup.set(e.id,t)):(this.linkChartGeohashLookup.set(e.id,""),this.relationshipLinkChartDiagramLookup.set(e.id,t))})),this.addResolvingPromise(this._initializeDiagram().then((async()=>{this.layers.forEach((async e=>{await e.refreshCachedQueryEngine()})),this.tables.forEach((async e=>{await e.refreshCachedQueryEngine()}))})))}));else{const t="GEOGRAPHIC"===this.defaultLinkChartConfig?.layoutMode;this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0,!1,t,!0).then((async()=>{n(e);const t=[],a=[];this.loadLayerAssumingLocalCache(),this.dataManager.inclusionModeDefinition&&(this.dataManager.inclusionModeDefinition.generateAllSublayers=!1,this.dataManager.inclusionModeDefinition.namedTypeDefinitions.forEach((e=>{e.useAllData=!1}))),await this._initializeDiagram(),this.layers.forEach((e=>{a.push(e.refreshCachedQueryEngine()),t.push(new Promise((t=>{e.on("layerview-create",(()=>{t(null)}))})))})),this.tables.forEach((e=>{a.push(e.refreshCachedQueryEngine())})),await Promise.all(a)})))}t(null)}))}))),Promise.resolve(this)}async addRecords(e,t){let a=[];t?.cascadeAddRelationshipEndNodes&&this.dataManager.knowledgeGraph.dataModel&&(a=await L(e,this.dataManager.knowledgeGraph));const i=e.concat(a).filter((e=>!this.sublayerIdsCache.get(e.typeName)?.has(e.id)));await this._handleNewRecords(i)}async removeRecords(e,{cascadeRemoveRelationships:t=!0,recalculateLayout:a=!1}={cascadeRemoveRelationships:!0,recalculateLayout:!1}){let i=[];for(const s of e)!1===this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(s.typeName)?.useAllData&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(s.typeName)?.members?.has(s.id)&&i.push(s);if(t){const e=new Set,t=[];for(const a of i)if(this.dataManager.nodeConnectionsLookup.has(a.id))for(const t of this.dataManager.nodeConnectionsLookup.get(a.id))e.add(t);for(const a of e)if(this.dataManager.memberIdTypeLookup.has(a))for(const e of this.dataManager.memberIdTypeLookup.get(a))this.dataManager.relationshipTypeNames.has(e)&&t.push({id:a,typeName:e});i=i.concat(t)}this.dataManager.removeFromLayer(i);for(const s of i)this.sublayerIdsCache.get(s.typeName)?.delete(s.id),this.dataManager.relationshipTypeNames.has(s.typeName)?this.relationshipLinkChartDiagramLookup.delete(s.id):this.entityLinkChartDiagramLookup.delete(s.id);a&&await this.calculateLinkChartLayout(this._currentLinkChartConfig.layoutMode,{});const n=[];return this.layers.forEach((e=>{n.push(e.refreshCachedQueryEngine())})),await Promise.all(n),this._refreshNamedTypes(),i}async expand(e,t){const a=await this.dataManager.getConnectedRecordIds(e,t),i=a.filter((e=>!this.sublayerIdsCache.get(e.typeName)?.has(e.id)));return await this._handleNewRecords(a),{records:i}}loadLayerAssumingLocalCache(){this.memberRelationshipTypes.forEach((e=>{const t=new k({objectType:e,parentCompositeLayer:this,graphType:"relationship",title:e.name});t.geometryType?this.layers.push(t):this.tables.push(t),this.dataManager.sublayerCaches.has(e.name)||this.dataManager.sublayerCaches.set(e.name,new Map)})),this.memberEntityTypes.forEach((e=>{const t=new k({objectType:e,parentCompositeLayer:this,graphType:"entity",title:e.name});t.geometryType?this.layers.push(t):this.tables.push(t),this.dataManager.sublayerCaches.has(e.name)||this.dataManager.sublayerCaches.set(e.name,new Map)})),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach(((e,t)=>{const a=S(this.sublayerIdsCache,t,(()=>new Set));e.members?.forEach((e=>{if(a.add(e.id),e.linkChartLocation)if(e.linkChartLocation instanceof p)this.dataManager.relationshipTypeNames.has(t)?this.relationshipLinkChartDiagramLookup.set(e.id,e.linkChartLocation):this.entityLinkChartDiagramLookup.set(e.id,e.linkChartLocation),2===e.linkChartLocation.coords.length&&0===e.linkChartLocation.lengths.length?this.linkChartGeohashLookup.set(e.id,r(e.linkChartLocation.coords[1],e.linkChartLocation.coords[0],f)):this.linkChartGeohashLookup.set(e.id,"");else{const a=l(e.linkChartLocation);this.dataManager.relationshipTypeNames.has(t)?this.relationshipLinkChartDiagramLookup.set(e.id,e.linkChartLocation?a:null):this.entityLinkChartDiagramLookup.set(e.id,e.linkChartLocation?a:null),"x"in e.linkChartLocation&&"y"in e.linkChartLocation?this.linkChartGeohashLookup.set(e.id,r(e.linkChartLocation.x,e.linkChartLocation.y,f)):this.linkChartGeohashLookup.set(e.id,"")}}))}))}async calculateLinkChartLayout(e="RADIAL_TREE",t){const n=[],s=[],o=[];this.dataManager.sublayerCaches.forEach(((e,t)=>{this.dataManager.entityTypeNames.has(t)?e.forEach((e=>{n.push({typeName:t,feature:e})})):this.dataManager.relationshipTypeNames.has(t)&&e.forEach((e=>{s.push({typeName:t,feature:e})}))})),this.entityLinkChartDiagramLookup=new Map,this.relationshipLinkChartDiagramLookup=new Map;const h=new Map,p=new Map,d=new Map,k=new Map,L=new Uint8Array(n.length),C=new Float64Array(n.length),M=new Float64Array(n.length),I=new Uint32Array(s.length),v=new Uint32Array(s.length),A=[],S="FORCE_DIRECTED",z=new _({xmin:-1e-7,ymin:-1e-7,xmax:1e-7,ymax:1e-7});let O,U="FORCE_DIRECTED",Q=0,F=0;switch(U="GEOGRAPHIC"===e?S:e,U){case"FORCE_DIRECTED":O=E.apply;break;case"COMMUNITY":O=T.apply;break;case"HIERARCHICAL":O=x.apply;break;case"RADIAL_TREE":O=D.apply;break;case"SMART_TREE":O=b.apply;break;default:O=w.apply}n.forEach((({typeName:a,feature:i})=>{if(t?.lockedNodeLocations?.has(i.attributes[c])){"GEOGRAPHIC"===e&&this.dataManager.geographicLookup.has(a)?L[Q]=N.IsGeographic:L[Q]=N.None;const n=t.lockedNodeLocations.get(i.attributes[c]);C[Q]=n.x,M[Q]=n.y}else if("GEOGRAPHIC"===e&&this.dataManager.geographicLookup.has(a)){L[Q]=N.IsGeographic;let e=null;const t=i.attributes[this.dataManager.geographicLookup.get(a).name],n=this.dataManager.geographicLookup.get(a)?.geometryType;switch(n){case"esriGeometryPoint":C[Q]=t?.x,M[Q]=t?.y;break;case"esriGeometryPolygon":e=t?.centroid,null!=e?.x&&null!=e?.y?(C[Q]=e.x,M[Q]=e.y):L[Q]=N.IsMovable;break;case"esriGeometryPolyline":case"esriGeometryMultipoint":e=t?.extent?.center,null!=e?.x&&null!=e?.y?(C[Q]=e.x,M[Q]=e.y):L[Q]=N.IsMovable;break;default:L[Q]=N.IsMovable}(null==C[Q]||null==M[Q]||Number.isNaN(C[Q])||Number.isNaN(M[Q]))&&(L[Q]=N.IsMovable,C[Q]=0,M[Q]=0)}else L[Q]=N.IsMovable,C[Q]=0,M[Q]=0;k.set(i.attributes[c],Q),A[Q]={feature:i,typeName:a},Q++}));let H=!1;const K=new Map;s.forEach((e=>{const t=e.feature.attributes[u],a=e.feature.attributes[y],i=k.get(t),n=k.get(a);if(void 0!==i&&void 0!==n){const s=t+"-"+a,r=K.get(s),h=r?.has(e.typeName);h||(I[F]=i,v[F]=n,void 0===r?K.set(s,new Map([[e.typeName,F]])):r.set(e.typeName,F),F++),o.push(e)}else H=!0,this.relationshipLinkChartDiagramLookup.set(t,null),this.linkChartGeohashLookup.set(t,null)})),H&&i.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null"),await G();const{success:$,links:B}=O(L,C,M,I.subarray(0,F),v.subarray(0,F));if(!$)throw new a("knowledge-graph:layout-failed","Attempting to arrange the records in the specified layout failed");for(let a=0;a<A.length;a++){if(M[a]>84.9999?M[a]=84.9999:M[a]<-84.9999&&(M[a]=-84.9999),C[a]>179.9999?C[a]=179.9999:C[a]<-179.9999&&(C[a]=-179.9999),A[a].feature.attributes[m]=new j(C[a],M[a]),h.has(A[a].typeName)){const e=h.get(A[a].typeName);e?.set(A[a].feature.attributes[c],A[a].feature)}else{const e=new Map;e.set(A[a].feature.attributes[c],A[a].feature),h.set(A[a].typeName,e)}d.set(A[a].feature.attributes[c],A[a].feature);const e=l(A[a].feature.attributes[m]);this.entityLinkChartDiagramLookup.set(A[a].feature.attributes[c],A[a].feature.attributes[m]?e:null),this.linkChartGeohashLookup.set(A[a].feature.attributes[c],r(A[a].feature.attributes[m].y,A[a].feature.attributes[m].x,f)),A[a].feature.attributes[m].x<z.xmin&&(z.xmin=A[a].feature.attributes[m].x),A[a].feature.attributes[m].x>z.xmax&&(z.xmax=A[a].feature.attributes[m].x),A[a].feature.attributes[m].y<z.ymin&&(z.ymin=A[a].feature.attributes[m].y),A[a].feature.attributes[m].y>z.ymax&&(z.ymax=A[a].feature.attributes[m].y)}if(this.linkChartExtent.xmin=z.xmin,this.linkChartExtent.xmax=z.xmax,this.linkChartExtent.ymin=z.ymin,this.linkChartExtent.ymax=z.ymax,!B)throw new a("knowledge-graph:layout-failed","Attempting to retrieve link geometry from diagram engine failed");const W=new Map,Y=new Map,q=new Map,J=new Set;for(let a=0;a<o.length;a++){const e=[],t=o[a],n=t.feature.attributes[u],s=t.feature.attributes[y],r=n+"-"+s,h=K.get(r).get(t.typeName),g=0===h?0:B?.vertexEndIndex[h-1];if(!J.has(h)){if(J.add(h),B.types[h]===R.Recursive){const t=[B.vertices[2*g],B.vertices[2*g+1]],a=[B.vertices[2*(g+1)],B.vertices[2*(g+1)+1]],i=[.5*(t[0]+a[0]),.5*(t[1]+a[1])],n=[i[0]-t[0],i[1]-t[1]],s=[i[0]+n[1],i[1]-n[0]],o=[i[0]-n[1],i[1]+n[0]];e.push(t),e.push(s),e.push(a),e.push(o),e.push(t)}else{if(B.types[h]!==R.Regular){i.getLogger(this).warn("A relationship generated an unsupported link geometry type.  It will not be rendered");continue}for(let t=g;t<B.vertexEndIndex[h];t++)e.push([B.vertices[2*t],B.vertices[2*t+1]])}const t=A[k.get(n)]?.feature.attributes[m],a=A[k.get(s)]?.feature.attributes[m];e[0][0]===t.x&&e[0][1]===t.y||(e[0]=[t.x,t.y]),e[e.length-1][0]===a.x&&e[e.length-1][1]===a.y||(e[e.length-1]=[a.x,a.y]);for(let i=1;i<e.length-1;i++)e[i][1]>85.5?e[i][1]=85.5:e[i][1]<-85.5&&(e[i][1]=-85.5),e[i][0]>179.9999?e[i][0]=179.9999:e[i][0]<-179.9999&&(e[i][0]=-179.9999);W.has(r)?W.get(r).push(e):W.set(r,[e])}const f=W.get(r);Y.has(r)||(Y.set(r,new Map),q.set(r,new Map));const L=Y.get(r),C=q.get(r);L.has(t.typeName)||(L.set(t.typeName,f.shift()),C.set(t.typeName,0));const M=L.get(t.typeName);C.set(t.typeName,C.get(t.typeName)+1);const w=new P({paths:M});if(t.feature.attributes[m]=w,p.has(t.typeName)){const e=p.get(t.typeName);e?.set(t.feature.attributes[c],t.feature)}else{const e=new Map;e.set(t.feature.attributes[c],t.feature),p.set(t.typeName,e)}d.set(t.feature.attributes[c],t.feature);const b=l(t.feature.attributes[m]);this.relationshipLinkChartDiagramLookup.set(t.feature.attributes[c],t.feature.attributes[m]?b:null),this.linkChartGeohashLookup.set(t.feature.attributes[c],"")}for(const a of o)a.feature.attributes[g]=q.get(a.feature.attributes[u]+"-"+a.feature.attributes[y])?.get(a.typeName)??null;return this._currentLinkChartConfig={layoutMode:e},{nodes:h,links:p,idMap:d}}async applyNewLinkChartLayout(e="RADIAL_TREE",t){const a=[];await this.calculateLinkChartLayout(e,t),this.layers.forEach((e=>{a.push(e.refreshCachedQueryEngine())})),await Promise.all(a),this._refreshNamedTypes()}getCurrentNodeLocations(){const e=new Map;return this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((t=>{t?.members?.forEach((t=>{const a=t.linkChartLocation;let i;const n=t.id;a&&(i="x"in a?{x:a.x,y:a.y}:{x:a.coords[0],y:a.coords[1]},e.set(n,new j({x:i.x,y:i.y})))}))})),e}async synchronizeInclusionListWithCache(){return new Promise((e=>{this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach(((e,t)=>{if(e.useAllData=!1,e.members&&e.members.size>0){if(!this.dataManager.sublayerCaches.get(t))return;const a=new Set(Array.from(this.dataManager.sublayerCaches.get(t).keys()));Array.from(e.members.keys()).filter((e=>!a.has(e))).forEach((t=>{e.members?.delete(t)}))}})),e()}))}async refreshLinkChartCache(e){await this.dataManager.refreshCacheContent(e);const t=[];this.layers.forEach((e=>{t.push(e.refreshCachedQueryEngine())})),await Promise.all(t),this._refreshNamedTypes()}async _handleNewRecords(e){const t=[];this.dataManager.addToLayer(e);for(const a of e)this.sublayerIdsCache.has(a.typeName)||(this.sublayerIdsCache.set(a.typeName,new Set),t.push(a.typeName)),this.sublayerIdsCache.get(a.typeName).add(a.id);for(const a of t)if(this._graphTypeLookup.has(a)){const e=this._graphTypeLookup.get(a),t="endPoints"in e?"relationship":"entity",i=new k({objectType:e,parentCompositeLayer:this,graphType:t,title:a});"entity"===t?this.dataManager.entityTypeNames.add(a):this.dataManager.relationshipTypeNames.add(a),i.geometryType?this.layers.push(i):this.tables.push(i),this.dataManager.sublayerCaches.set(a,new Map)}await this.dataManager.refreshCacheContent(e.map((e=>e.id))),await this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode)}async _initializeDiagram(){this.defaultLinkChartConfig?this.defaultLinkChartConfig.doNotRecalculateLayout?(this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach(((e,t)=>{e?.members?.forEach((e=>{const a=e.linkChartLocation;let i;const n=e.id;if(!a)return;i="x"in a?{x:a.x,y:a.y}:{x:a.coords[0],y:a.coords[1]};const s=l(i);this.dataManager.relationshipTypeNames.has(t)?this.relationshipLinkChartDiagramLookup.set(n,s):this.entityLinkChartDiagramLookup.set(n,s),this.linkChartGeohashLookup.set(n,r(i.x,i.y,f)),this.linkChartExtent.xmin>i.x&&(this.linkChartExtent.xmin=i.x),this.linkChartExtent.xmax<i.x&&(this.linkChartExtent.xmax=i.x),this.linkChartExtent.ymin>i.y&&(this.linkChartExtent.ymin=i.y),this.linkChartExtent.ymax<i.y&&(this.linkChartExtent.ymax=i.y)}))})),this.memberRelationshipTypes.forEach((e=>{e.name&&this.dataManager.sublayerCaches.get(e.name)?.forEach((e=>{const t=this.relationshipLinkChartDiagramLookup.get(e.attributes[u]),a=this.relationshipLinkChartDiagramLookup.get(e.attributes[y]);if(t&&a){const i=l(new P({paths:[[t.coords[0],t.coords[1]],[a.coords[0],a.coords[1]]]}));this.relationshipLinkChartDiagramLookup.set(e.attributes[c],i)}else this.relationshipLinkChartDiagramLookup.set(e.attributes[c],null);this.linkChartGeohashLookup.set(e.attributes[c],"")}))}))):await this.calculateLinkChartLayout(this.defaultLinkChartConfig.layoutMode,{lockedNodeLocations:this.getCurrentNodeLocations()}):await this.calculateLinkChartLayout("RADIAL_TREE",{lockedNodeLocations:this.getCurrentNodeLocations()})}_refreshNamedTypes(){for(const e of this.layers)e.emit("refresh",{dataChanged:!0});for(const e of this.tables)e.emit("refresh",{dataChanged:!0})}};e([s()],z.prototype,"dataPreloadedInLocalCache",void 0),e([s()],z.prototype,"defaultLinkChartConfig",void 0),e([s()],z.prototype,"dataManager",void 0),e([s()],z.prototype,"knowledgeGraph",void 0),e([s()],z.prototype,"layers",void 0),e([s()],z.prototype,"entityLinkChartDiagramLookup",void 0),e([s()],z.prototype,"relationshipLinkChartDiagramLookup",void 0),e([s()],z.prototype,"linkChartExtent",void 0),e([s()],z.prototype,"linkChartGeohashLookup",void 0),e([s()],z.prototype,"memberEntityTypes",void 0),e([s()],z.prototype,"memberRelationshipTypes",void 0),e([s()],z.prototype,"sublayerIdsCache",void 0),e([s()],z.prototype,"tables",void 0),e([s({json:{read:!1}})],z.prototype,"type",void 0),z=e([o("esri.layers.LinkChartLayer")],z);const O=z;export{O as default};
