/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{ForwardLinearDepth as e}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{Offset as r}from"../views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js";import{ShaderOutput as o}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as i}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as a}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{InstancedDoublePrecision as l}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js";import{NormalAttribute as t,NormalType as s}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js";import{PositionAttribute as n}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js";import{SymbolColor as d}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js";import{TextureCoordinateAttribute as c}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js";import{VertexColor as m}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js";import{VertexNormal as g}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js";import{VerticalOffset as p}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js";import{DefaultMaterialAuxiliaryPasses as v}from"../views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js";import{ComputeNormalTexture as u}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js";import{EvaluateAmbientOcclusion as b}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js";import{EvaluateSceneLighting as h,addAmbientBoostFactor as w,addLightingGlobalFactor as f}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightIntensity as x}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{multipassTerrainTest as y}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{Normals as C}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl.js";import{PhysicallyBasedRendering as L}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js";import{PhysicallyBasedRenderingParameters as j,PBRMode as T}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadShadowMapPass as P,ReadShadowMapDraw as M}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{colorTextureUV as O,normalTextureUV as A,emissiveTextureUV as E,occlusionTextureUV as S,metallicRoughnessTextureUV as $}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TextureTransformUV.glsl.js";import{VisualVariables as N}from"../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js";import{symbolAlphaCutoff as V}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js";import{DiscardOrAdjustAlphaPass as D}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js";import{MixExternalColor as _}from"../views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js";import{addProjViewLocalOrigin as U,addCameraPosition as B}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float3PassUniform as F}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{Float4PassUniform as I}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as R}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as z}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as W}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as k}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{TransparencyPassType as G}from"../views/3d/webgl-engine/lib/TransparencyPassType.js";import{VertexAttribute as q}from"../views/3d/webgl-engine/lib/VertexAttribute.js";function H(H){const J=new W,{vertex:K,fragment:Q,varyings:X}=J;if(U(K,H),J.include(n),X.add("vpos","vec3"),J.include(N,H),J.include(l,H),J.include(p,H),J.include(O,H),H.output===o.Color||H.output===o.Alpha){J.include(A,H),J.include(E,H),J.include(S,H),J.include($,H),B(K,H),J.include(t,H),J.include(a,H);const o=H.normalType===s.Attribute||H.normalType===s.Compressed;o&&H.offsetBackfaces&&J.include(r),J.include(u,H),J.include(g,H),H.instancedColor&&J.attributes.add(q.INSTANCECOLOR,"vec4"),X.add("vPositionLocal","vec3"),J.include(c,H),J.include(e,H),J.include(d,H),J.include(m,H),K.uniforms.add(new I("externalColor",(e=>e.externalColor))),X.add("vcolorExt","vec4"),H.multipassEnabled&&X.add("depth","float"),K.code.add(z`
      void main(void) {
        forwardNormalizedVertexColor();
        vcolorExt = externalColor;
        ${H.instancedColor?"vcolorExt *= instanceColor * 0.003921568627451;":""}
        vcolorExt *= vvColor();
        vcolorExt *= getSymbolColor();
        forwardColorMixMode();

        if (vcolorExt.a < ${z.float(V)}) {
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        } else {
          vpos = getVertexInLocalOriginSpace();
          vPositionLocal = vpos - view[3].xyz;
          vpos = subtractOrigin(vpos);
          ${o?z`vNormalWorld = dpNormal(vvLocalNormal(normalModel()));`:""}
          vpos = addVerticalOffset(vpos, localOrigin);
          ${H.hasVertexTangents?"vTangent = dpTransformVertexTangent(tangent);":""}
          gl_Position = transformPosition(proj, view, vpos);
          ${o&&H.offsetBackfaces?"gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, cameraPosition);":""}
        }

        ${H.multipassEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}
        forwardLinearDepth();
        forwardTextureCoordinates();
        forwardColorUV();
        forwardNormalUV();
        forwardEmissiveUV();
        forwardOcclusionUV();
        forwardMetallicRoughnessUV();
      }
    `)}switch(H.output){case o.Alpha:J.include(i,H),J.include(D,H),J.include(y,H),Q.uniforms.add(new R("opacity",(e=>e.opacity)),new R("layerOpacity",(e=>e.layerOpacity))),H.hasColorTexture&&Q.uniforms.add(new k("tex",(e=>e.texture))),Q.include(_),Q.code.add(z`
      void main() {
        discardBySlice(vpos);
        ${H.multipassEnabled?"terrainDepthTest(depth);":""}
        ${H.hasColorTexture?z`
                vec4 texColor = texture(tex, ${H.hasColorTextureTransform?z`colorUV`:z`vuv0`});
                ${H.textureAlphaPremultiplied?"texColor.rgb /= texColor.a;":""}
                discardOrAdjustAlpha(texColor);`:z`vec4 texColor = vec4(1.0);`}
        ${H.hasVertexColors?z`float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));`:z`float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));`}
        fragColor = vec4(opacity_);
      }
    `);break;case o.Color:J.include(i,H),J.include(h,H),J.include(b,H),J.include(D,H),J.include(H.instancedDoublePrecision?P:M,H),J.include(y,H),B(Q,H),Q.uniforms.add(K.uniforms.get("localOrigin"),new F("ambient",(e=>e.ambient)),new F("diffuse",(e=>e.diffuse)),new R("opacity",(e=>e.opacity)),new R("layerOpacity",(e=>e.layerOpacity))),H.hasColorTexture&&Q.uniforms.add(new k("tex",(e=>e.texture))),J.include(j,H),J.include(L,H),Q.include(_),J.include(C,H),w(Q),f(Q),x(Q),Q.code.add(z`
      void main() {
        discardBySlice(vpos);
        ${H.multipassEnabled?"terrainDepthTest(depth);":""}
        ${H.hasColorTexture?z`
                vec4 texColor = texture(tex, ${H.hasColorTextureTransform?z`colorUV`:z`vuv0`});
                ${H.textureAlphaPremultiplied?"texColor.rgb /= texColor.a;":""}
                discardOrAdjustAlpha(texColor);`:z`vec4 texColor = vec4(1.0);`}
        shadingParams.viewDirection = normalize(vpos - cameraPosition);
        ${H.normalType===s.ScreenDerivative?z`
                vec3 normal = screenDerivativeNormal(vPositionLocal);`:z`
                shadingParams.normalView = vNormalWorld;
                vec3 normal = shadingNormal(shadingParams);`}
        ${H.pbrMode===T.Normal?"applyPBRFactors();":""}
        float ssao = evaluateAmbientOcclusionInverse() * getBakedOcclusion();

        vec3 posWorld = vpos + localOrigin;

        float additionalAmbientScale = additionalDirectedAmbientLight(posWorld);
        float shadow = ${H.receiveShadows?"readShadowMap(vpos, linearDepth)":H.spherical?"lightingGlobalFactor * (1.0 - additionalAmbientScale)":"0.0"};

        vec3 matColor = max(ambient, diffuse);
        ${H.hasVertexColors?z`
                vec3 albedo = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
                float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));`:z`
                vec3 albedo = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
                float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));`}
        ${H.hasNormalTexture?z`
                mat3 tangentSpace = ${H.hasVertexTangents?"computeTangentSpace(normal);":"computeTangentSpace(normal, vpos, vuv0);"}
                vec3 shadingNormal = computeTextureNormal(tangentSpace, ${H.hasNormalTextureTransform?z`normalUV`:"vuv0"});`:z`vec3 shadingNormal = normal;`}
        vec3 normalGround = ${H.spherical?z`normalize(posWorld);`:z`vec3(0.0, 0.0, 1.0);`}

        ${H.snowCover?z`
                float snow = smoothstep(0.5, 0.55, dot(normal, normalGround));
                albedo = mix(albedo, vec3(1), snow);
                shadingNormal = mix(shadingNormal, normal, snow);
                ssao = mix(ssao, 1.0, snow);`:""}

        vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;

        ${H.pbrMode===T.Normal||H.pbrMode===T.Schematic?z`
                float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
                ${H.snowCover?z`
                        mrr = mix(mrr, vec3(0.0, 1.0, 0.04), snow);
                        emission = mix(emission, vec3(0.0), snow);`:""}

                vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);`:z`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
        fragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);
        ${H.transparencyPassType===G.Color?z`fragColor = premultiplyAlpha(fragColor);`:""}
      }
    `)}return J.include(v,H),J}const J=Object.freeze(Object.defineProperty({__proto__:null,build:H},Symbol.toStringTag,{value:"Module"}));export{J as D,H as b};
