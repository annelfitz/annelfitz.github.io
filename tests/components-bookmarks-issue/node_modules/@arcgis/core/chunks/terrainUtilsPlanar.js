/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../core/Error.js";import{c as t,f as o,k as n,g as r,h as i}from"./vec32.js";import{create as s}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import{containsPoint as l,containsPointWithMargin as a,fromExtent as c,create as u}from"../geometry/support/aaBoundingRect.js";import{isSupportedEarthGCS as f}from"../views/3d/support/supportedSpatialReference.js";import{maxRootTiles as m}from"../views/3d/terrain/TerrainConst.js";import{getMissingTileInfoError as p,TilingScheme as h}from"../views/3d/terrain/TilingScheme.js";const g=s(),d=s(),x=s(),M=s();function S(e,t,o=0){const n=e.extent;if(null==n)return!1;if(0===o)return l(n,t);const r=Math.min(n[2]-n[0],n[3]-n[1]);return a(n,t,o*r)}function v(e,s,l,a){t(g,l),g[a]=s[a];const c=o(g,g,s),u=o(d,e,s),f=n(u,c),m=n(c,c);let p;p=f<=0?s:m<=f?l:r(g,s,i(c,c,f/m));const h=o(g,e,p);return Math.PI/2-Math.atan(h[2]/Math.sqrt(h[0]*h[0]+h[1]*h[1]))}function w(e,t,o){const n=e.extent;if(null==n)return 0;x[0]=n[0],x[1]=n[1],x[2]=o,M[0]=n[2],M[1]=n[3],M[2]=o;let r=1/0,i=1/0;return t[0]<x[0]?r=v(t,x,M,0):t[0]>M[0]&&(r=v(t,M,x,0)),t[1]<x[1]?i=v(t,x,M,1):t[1]>M[1]&&(i=v(t,M,x,1)),Math.min(r,i)}function T(t,o,n,r){if(null==t)return p();const i=t.spatialReference;if(i.isGeographic&&!f(i))return new e("tilingscheme:local-unsupported-spatial-reference","The tiling scheme spatial reference is not supported in local scenes");const s=h.checkUnsupported(t);if(null!=s)return s;if(null==n)return new e("tilingscheme:extent-not-exist","The layer does not provide a layer extent.");const l=j(t,n);return l||(null==o||i.equals(o)||o.isWGS84&&i.isWebMercator?null:new e("tilingscheme:spatial-reference-mismatch","The tiling scheme does not match the spatial reference of the local scene"))}function j(t,o){const n=t.lods,r=n[0].resolution*2**n[0].level,i=[r*t.size[0],r*t.size[1]],s=[t.origin.x,t.origin.y],l=c(o),a=u();h.computeRowColExtent(l,i,s,a);const f=(a[2]-a[0])*(a[3]-a[1]);if(f>m){const o=n[0].scale*2**n[0].level;let i=Math.max((l[3]-l[1])/t.size[1],(l[2]-l[0])/t.size[0])*o/r;const s=Math.floor(Math.log(i)/Math.log(10));return i=Math.ceil(i/10**s)*10**s,new e("tilingscheme:too-many-root-tiles","Scale of level 0 of the tiling scheme (1:"+Math.floor(o).toLocaleString()+") is too large for the layer's extent. Suggested scale: 1:"+i.toLocaleString()+".",{level0Scale:o,suggestedLevel0Scale:i,requiredNumRootTiles:f,allowedNumRootTiles:m})}return null}const y=Object.freeze(Object.defineProperty({__proto__:null,checkIfTileInfoSupportedForViewSR:T,isInsideExtent:S,tiltToExtentEdge:w},Symbol.toStringTag,{value:"Module"}));export{w as a,T as c,S as i,y as t};
