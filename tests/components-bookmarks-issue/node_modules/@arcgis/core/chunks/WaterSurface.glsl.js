/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{ForwardLinearDepth as e}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{ShaderOutput as o}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as r}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as i}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{ObjectAndLayerIdColor as a}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js";import{OutputHighlight as s}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{EvaluateAmbientLighting as n}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js";import{MainLighting as t,addMainLightDirection as d,addMainLightIntensity as l}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{multipassTerrainTest as v}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{NormalUtils as g}from"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js";import{PBRMode as c}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadShadowMapDraw as m}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{Water as p}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Water.glsl.js";import{WaterDistortion as u}from"../views/3d/webgl-engine/core/shaderLibrary/shading/WaterDistortion.glsl.js";import{symbolAlphaCutoff as w}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js";import{ColorConversion as f}from"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js";import{addProjViewLocalOrigin as h,addCameraPosition as b}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float4PassUniform as y}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as j}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as C}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as L}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{TransparencyPassType as P}from"../views/3d/webgl-engine/lib/TransparencyPassType.js";import{VertexAttribute as S}from"../views/3d/webgl-engine/lib/VertexAttribute.js";function x(x){const M=new L,{vertex:N,fragment:O}=M;h(N,x),M.include(i,x),M.attributes.add(S.POSITION,"vec3"),M.attributes.add(S.UV0,"vec2");const _=new y("waterColor",(e=>e.color));if(x.output===o.Color&&x.draped)return M.varyings.add("vpos","vec3"),N.uniforms.add(_),N.code.add(C`
        void main(void) {
          if (waterColor.a < ${C.float(w)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vpos = position;
          gl_Position = transformPosition(proj, view, vpos);
        }
    `),O.uniforms.add(_),O.code.add(C`void main() {
fragColor = waterColor;
}`),M;switch(x.output!==o.Color&&x.output!==o.Alpha||(M.include(g,x),M.include(e,x),M.varyings.add("vuv","vec2"),M.varyings.add("vpos","vec3"),M.varyings.add("vnormal","vec3"),M.varyings.add("vtbnMatrix","mat3"),x.multipassEnabled&&M.varyings.add("depth","float"),N.uniforms.add(_),N.code.add(C`
      void main(void) {
        if (waterColor.a < ${C.float(w)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vuv = uv0;
        vpos = position;

        vnormal = getLocalUp(vpos, localOrigin);
        vtbnMatrix = getTBNMatrix(vnormal);

        ${x.multipassEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}

        gl_Position = transformPosition(proj, view, vpos);
        ${x.output===o.Color?"forwardLinearDepth();":""}
      }
    `)),M.include(v,x),x.output){case o.Alpha:M.include(r,x),O.uniforms.add(_),O.code.add(C`
        void main() {
          discardBySlice(vpos);
          ${x.multipassEnabled?"terrainDepthTest(depth);":""}

          fragColor = vec4(waterColor.a);
        }
      `);break;case o.Color:M.include(t),M.include(n,{pbrMode:c.Disabled,lightingSphericalHarmonicsOrder:2}),M.include(u),M.include(r,x),M.include(m,x),M.include(p,x),O.uniforms.add(_,new j("timeElapsed",(e=>e.timeElapsed)),N.uniforms.get("view"),N.uniforms.get("localOrigin")),b(O,x),O.include(f),d(O),l(O),O.code.add(C`
      void main() {
        discardBySlice(vpos);
        ${x.multipassEnabled?"terrainDepthTest(depth);":""}
        vec3 localUp = vnormal;
        // the created normal is in tangent space
        vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);

        // we rotate the normal according to the tangent-bitangent-normal-Matrix
        vec3 n = normalize(vtbnMatrix * tangentNormalFoam.xyz);
        vec3 v = -normalize(vpos - cameraPosition);
        float shadow = ${x.receiveShadows?C`1.0 - readShadowMap(vpos, linearDepth)`:"1.0"};
        vec4 vPosView = view * vec4(vpos, 1.0);
        vec4 final = vec4(getSeaColor(n, v, mainLightDirection, waterColor.rgb, mainLightIntensity, localUp, shadow, tangentNormalFoam.w, vPosView.xyz, vpos + localOrigin), waterColor.w);

        // gamma correction
        fragColor = delinearizeGamma(final);
        fragColor = highlightSlice(fragColor, vpos);
        ${x.transparencyPassType===P.Color?"fragColor = premultiplyAlpha(fragColor);":""}
      }
    `);break;case o.Normal:M.include(g,x),M.include(u,x),M.include(r,x),M.varyings.add("vpos","vec3"),M.varyings.add("vuv","vec2"),N.uniforms.add(_),N.code.add(C`
        void main(void) {
          if (waterColor.a < ${C.float(w)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vuv = uv0;
          vpos = position;

          gl_Position = transformPosition(proj, view, vpos);
        }
    `),O.uniforms.add(new j("timeElapsed",(e=>e.timeElapsed))),O.code.add(C`void main() {
discardBySlice(vpos);
vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);
tangentNormalFoam.xyz = normalize(tangentNormalFoam.xyz);
fragColor = vec4((tangentNormalFoam.xyz + vec3(1.0)) * 0.5, tangentNormalFoam.w);
}`);break;case o.Highlight:M.include(s,x),M.varyings.add("vpos","vec3"),N.uniforms.add(_),N.code.add(C`
      void main(void) {
        if (waterColor.a < ${C.float(w)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);
      }
    `),M.include(r,x),O.code.add(C`void main() {
discardBySlice(vpos);
outputHighlight();
}`);break;case o.ObjectAndLayerIdColor:M.include(a,x),M.varyings.add("vpos","vec3"),N.uniforms.add(_),N.code.add(C`
      void main(void) {
        if (waterColor.a < ${C.float(w)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);
        forwardObjectAndLayerIdColor();
      }
    `),M.include(r,x),O.code.add(C`void main() {
discardBySlice(vpos);
outputObjectAndLayerIdColor();
}`)}return M}const M=Object.freeze(Object.defineProperty({__proto__:null,build:x},Symbol.toStringTag,{value:"Module"}));export{M as W,x as b};
