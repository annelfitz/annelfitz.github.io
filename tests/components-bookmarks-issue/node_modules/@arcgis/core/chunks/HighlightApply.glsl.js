/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{s as e}from"./vec42.js";import{create as o}from"../core/libs/gl-matrix-2/factories/vec4f64.js";import{Float2PassUniform as i}from"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js";import{Float4PassUniform as t}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{glsl as r}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as l}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as n}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{VertexAttribute as a}from"../views/3d/webgl-engine/lib/VertexAttribute.js";import{o as s,b as c}from"./HighlightDownsample.glsl.js";function g(){const o=new l,{vertex:g,fragment:d}=o,f=g.code,h=d.code;return o.attributes.add(a.POSITION,"vec2"),o.varyings.add("uv","vec2"),o.attributes.add(a.UV0,"vec2"),g.uniforms.add(new n("coverageTex",(e=>e.coverageTexture)),new i("coverageRounding",(e=>e.coverageRounding))),f.add(r`void main() {
vec4 cov = texture(coverageTex, uv0 * coverageRounding);
if (cov.r == 0.0) {
gl_Position = vec4(0.0);
return;
}
gl_Position = vec4(position, 0.0, 1.0);
uv = position.xy * 0.5 + vec2(0.5);
}`),d.uniforms.add(new n("tex",(e=>e.blurTexture)),new n("highlightTexture",(e=>e.highlightTexture)),new t("uColor",(e=>e.color)),new t("haloColor",(e=>e.haloColor)),new t("opacities",(o=>e(u,o.haloOpacity,o.haloOpacityOccluded,o.fillOpacity,o.fillOpacityOccluded)))),d.constants.add("inner","float",1-(s-c)/s),h.add(r`void main() {
vec4 blurredHighlightValue = texture(tex, uv);
float highlightIntensity = blurredHighlightValue.a;
if (highlightIntensity == 0.0) {
discard;
}
vec4 origin_color = texture(highlightTexture, uv);
float outlineIntensity;
float fillIntensity;
if (blurredHighlightValue.g > blurredHighlightValue.b) {
outlineIntensity = haloColor.w * opacities[1];
fillIntensity = uColor.w * opacities[3];
}
else {
outlineIntensity = haloColor.w * opacities[0];
fillIntensity = uColor.w * opacities[2];
}
float outlineFactor = smoothstep(0.0, inner, highlightIntensity);
float fillFactor = any(notEqual(origin_color, vec4(0.0, 0.0, 0.0, 0.0))) ? 1.0 : 0.0;
float intensity = outlineIntensity * outlineFactor * (1.0 - fillFactor) + fillIntensity * fillFactor;
fragColor = vec4(mix(haloColor.rgb, uColor.rgb, fillFactor), intensity);
}`),o}const u=o(),d=Object.freeze(Object.defineProperty({__proto__:null,build:g},Symbol.toStringTag,{value:"Module"}));export{d as H,g as b};
