/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{clone as e,fromValues as s}from"../core/libs/gl-matrix-2/factories/vec4f64.js";import{ScreenSpacePass as a}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js";import{ReadLinearDepth as o}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js";import{CameraSpace as r}from"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js";import{RgbaFloatEncoding as i}from"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js";import{Float4PassUniform as t}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as l}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{NoParameters as n,glsl as d}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as c}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as m}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{S as h}from"./ShadowCastAccumulate.glsl.js";import{ShadowCastVisualization as u}from"../views/3d/webgl-engine/shaders/ShadowCastVisualizeTechniqueConfiguration.js";class p extends n{constructor(s){super(),this._data=s,this.sampleScale=0,this.opacityFromElevation=1,this.color=e(g),this.bandSize=.1,this.threshold=.5}get shadowCastMap(){return this._data.shadowCastTexture}}const g=s(.01,0,.25,1);function w(e){const s=new c,n=s.fragment;n.include(i),n.include(o),s.include(r),s.include(a);const{visualization:p,bandsEnabled:g}=e;n.constants.add("inverseSampleValue","float",h),n.uniforms.add(new m("shadowCastMap",(e=>e.shadowCastMap)),new l("sampleScale",(e=>e.sampleScale)),new l("opacityFromElevation",(e=>e.opacityFromElevation)),new t("uColor",(e=>e.color)));const w=p===u.Gradient,f=p===u.Threshold;return w&&g?n.uniforms.add(new l("bandSize",(e=>e.bandSize))):f&&n.uniforms.add(new l("threshold",(e=>e.threshold))),n.code.add(d`
    void main(void) {
      float record = texture(shadowCastMap, uv).r;
      float pixelSamples = record * inverseSampleValue;
      if (pixelSamples < 1.0) {
        discard;
      }

      float strength = pixelSamples * sampleScale;

      ${f?d`
          if (strength <= threshold) {
            discard;
          }`:""}

      ${w&&g?d`strength = ceil(strength / bandSize) * bandSize;`:""}

      fragColor = vec4(uColor.xyz, uColor.a * opacityFromElevation ${w?d`* strength`:""});
    }
  `),s}const f=Object.freeze(Object.defineProperty({__proto__:null,ShadowCastVisualizePassParameters:p,build:w},Symbol.toStringTag,{value:"Module"}));export{p as S,f as a,w as b};
