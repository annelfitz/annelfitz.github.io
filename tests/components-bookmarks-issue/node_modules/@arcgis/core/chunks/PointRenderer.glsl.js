/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{numberMaxFloat32 as e}from"../core/mathUtils.js";import{multiply as i,fromTranslation as o}from"../core/libs/gl-matrix-2/math/mat4.js";import{create as r}from"../core/libs/gl-matrix-2/factories/mat4f64.js";import{set as t}from"../core/libs/gl-matrix-2/math/vec2.js";import{create as a}from"../core/libs/gl-matrix-2/factories/vec2f64.js";import{s}from"./vec32.js";import{create as n}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import{create as c,positiveInfinity as l}from"../geometry/support/aaBoundingBox.js";import{addNearFar as p,addCalculateLinearDepth as d}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{ShaderOutput as m}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SlicePlaneParameters as g,SliceDraw as f}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{OutputHighlight as u}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{RgbaFloatEncoding as h}from"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js";import{Float2DrawUniform as S}from"../views/3d/webgl-engine/core/shaderModules/Float2DrawUniform.js";import{Float2PassUniform as x}from"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js";import{Float3DrawUniform as v}from"../views/3d/webgl-engine/core/shaderModules/Float3DrawUniform.js";import{NoParameters as w,glsl as z}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{Matrix4DrawUniform as b}from"../views/3d/webgl-engine/core/shaderModules/Matrix4DrawUniform.js";import{Matrix4PassUniform as M}from"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js";import{ShaderBuilder as j}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{VertexAttribute as P}from"../views/3d/webgl-engine/lib/VertexAttribute.js";class y extends w{constructor(){super(...arguments),this.clipBox=c(l),this.useFixedSizes=!1,this.useRealWorldSymbolSizes=!1,this.scaleFactor=1,this.minSizePx=0,this.size=0,this.sizePx=0}get fixedSize(){return this.drawScreenSpace?this.sizePx:this.size}get screenMinSize(){return this.useFixedSizes?0:this.minSizePx}get drawScreenSpace(){return this.useFixedSizes&&!this.useRealWorldSymbolSizes}}class O extends g{constructor(e,i,o){super(e),this.origin=e,this.isLeaf=i,this.splatSize=o}}function R(r){const a=new j,n=r.output===m.Color,c=r.output===m.LinearDepth,l=r.output===m.Highlight,{vertex:g,fragment:w}=a;return a.include(f,r),a.attributes.add(P.POSITION,"vec3"),a.attributes.add(P.COLOR,"vec3"),g.uniforms.add(new b("modelView",((e,r)=>i(B,r.camera.viewMatrix,o(B,e.origin)))),new M("proj",((e,i)=>i.camera.projectionMatrix)),new S("screenMinMaxSize",((e,i,o)=>t(_,o.useFixedSizes?0:o.minSizePx*i.camera.pixelRatio,F(e.isLeaf)*i.camera.pixelRatio))),r.useFixedSizes?new x("pointScale",((e,i)=>t(_,e.fixedSize*i.camera.pixelRatio,i.camera.fullHeight))):new S("pointScale",((e,i,o)=>t(_,e.splatSize*o.scaleFactor*i.camera.pixelRatio,i.camera.fullHeight/i.camera.pixelRatio)))),r.clippingEnabled?g.uniforms.add(new v("clipMin",((e,i,o)=>s(L,o.clipBox[0]-e.origin[0],o.clipBox[1]-e.origin[1],o.clipBox[2]-e.origin[2]))),new v("clipMax",((e,i,o)=>s(L,o.clipBox[3]-e.origin[0],o.clipBox[4]-e.origin[1],o.clipBox[5]-e.origin[2])))):(g.constants.add("clipMin","vec3",[-e,-e,-e]),g.constants.add("clipMax","vec3",[e,e,e])),c?(p(a),d(a),a.varyings.add("depth","float")):r.output!==m.Highlight&&a.varyings.add("vColor","vec3"),g.code.add(z`
    void main(void) {
      // Move clipped points outside of clipspace
      if (position.x < clipMin.x || position.y < clipMin.y || position.z < clipMin.z ||
        position.x > clipMax.x || position.y > clipMax.y || position.z > clipMax.z) {
        gl_Position = vec4(0.0,0.0,0.0,2.0);
        gl_PointSize = 0.0;
        return;
      }

      if (rejectBySlice(position)) {
        gl_Position = vec4(0.0,0.0,0.0,2.0);
        gl_PointSize = 0.0;
        return;
      }

      // Position in camera space
      vec4 camera = modelView * vec4(position, 1.0);

      float pointSize = pointScale.x;
      vec4 position = proj * camera;
     ${r.drawScreenSize?z`
      float clampedScreenSize = pointSize;`:z`
      float pointRadius = 0.5 * pointSize;
      vec4 cameraOffset = camera + vec4(0.0, pointRadius, 0.0, 0.0);
      vec4 positionOffset = proj * cameraOffset;
      float radius = abs(positionOffset.y - position.y);
      float viewHeight = pointScale.y;
      // screen diameter = (2 * r / w) * (h / 2)
      float screenPointSize = (radius / position.w) * viewHeight;
      float clampedScreenSize = clamp(screenPointSize, screenMinMaxSize.x, screenMinMaxSize.y);
      // Shift towards camera, to move rendered point out of terrain i.e. to
      // the camera-facing end of the virtual point when considering it as a
      // 3D sphere.
      camera.xyz -= normalize(camera.xyz) * pointRadius * clampedScreenSize / screenPointSize;
      position = proj * camera;`}

     gl_PointSize = clampedScreenSize;
     gl_Position = position;

     ${c?z`depth = calculateLinearDepth(nearFar, camera.z);`:""}
     ${n?z`vColor = color;`:""}
    }
  `),w.include(h,r),l&&a.include(u,r),w.code.add(z`
    void main(void) {
      vec2 vOffset = gl_PointCoord - vec2(0.5, 0.5);
      float r2 = dot(vOffset, vOffset);

      if (r2 > 0.25) {
        discard;
      }
      ${c?z`fragColor = float2rgba(depth);`:""}
      ${l?z`outputHighlight();`:""}
      ${n?z`fragColor = vec4(vColor, 1.0);`:""}
    }
  `),a}function F(e){return e?256:64}const B=r(),L=n(),_=a(),C=Object.freeze(Object.defineProperty({__proto__:null,PointRendererDrawParameters:O,PointRendererPassParameters:y,build:R,getMaxPointSizeScreenspace:F},Symbol.toStringTag,{value:"Module"}));export{y as P,O as a,C as b,R as c,F as g};
