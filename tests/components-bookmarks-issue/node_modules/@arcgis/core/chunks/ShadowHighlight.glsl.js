/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{invert as e,translate as i}from"../core/libs/gl-matrix-2/math/mat4.js";import{create as o}from"../core/libs/gl-matrix-2/factories/mat4f64.js";import{n as t,e as r}from"./vec32.js";import{create as a}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import{ScreenSpacePass as l}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js";import{unoccludedHighlightFlag as s}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{ReadLinearDepth as n}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js";import{ReadShadowMapPass as h}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{CameraSpace as d}from"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js";import{RgbaFloatEncoding as c}from"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js";import{Float2PassUniform as p}from"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js";import{Float3PassUniform as g}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{Float4PassUniform as m}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as v}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as f}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{Matrix4PassUniform as u}from"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js";import{ShaderBuilder as w}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as x}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{SnapshotSlot as P}from"../views/3d/webgl-engine/lib/ShadowMap.js";const b=.99999,D=.025;function F(o){const a=new w;a.include(h,o),a.include(d),a.include(l);const F=a.fragment;return F.include(c),F.include(n),F.uniforms.add(new x("defaultDepthTex",((e,i)=>i.shadowMap.getSnapshot(P.ExcludeHighlight))),new x("highlightDepthTex",((e,i)=>i.shadowMap.getSnapshot(P.Highlight))),new x("depthMap",((e,i)=>i.linearDepth?.getTexture())),new x("highlightTexture",(e=>e.highlight)),new m("uColor",(e=>e.shadowColor)),new p("nearFar",((e,i)=>i.camera.nearFar)),new v("opacity",(e=>e.shadowOpacity)),new v("occludedOpacity",(e=>e.occludedShadowOpacity)),new v("terminationFactor",(e=>e.opacityElevation*e.dayNightTerminator)),new g("lightingMainDirectionView",((e,i)=>t(y,r(y,i.lighting.mainLight.direction,i.camera.viewInverseTransposeMatrix)))),new u("inverseViewMatrix",((o,t)=>e(M,i(M,t.camera.viewMatrix,t.camera.center))))),F.constants.add("unoccludedHighlightFlag","vec4",s),F.code.add(f`
    vec3 normalFromDepth(vec3 pixelPos, vec2 fragCoord, ivec2 iuv) {
      float leftPixelDepth = linearDepthFromRGBA(texelFetch(depthMap, iuv + ivec2(-1, 0), 0), nearFar);
      float rightPixelDepth = linearDepthFromRGBA(texelFetch(depthMap, iuv + ivec2(1, 0), 0), nearFar);
      float bottomPixelDepth = linearDepthFromRGBA(texelFetch(depthMap, iuv + ivec2(0, -1), 0), nearFar);
      float topPixelDepth = linearDepthFromRGBA(texelFetch(depthMap, iuv + ivec2(0, 1), 0), nearFar);

      bool pickLeft = abs(pixelPos.z - leftPixelDepth) < abs(pixelPos.z - rightPixelDepth);
      bool pickBottom = abs(pixelPos.z - bottomPixelDepth) < abs(pixelPos.z - topPixelDepth);

      vec3 fragCoordHorizontal = pickLeft
                                  ? vec3(fragCoord + vec2(-1.0, 0.0), leftPixelDepth)
                                  : vec3(fragCoord + vec2(1.0, 0.0), rightPixelDepth);
      vec3 fragCoordVertical = pickBottom
                                  ? vec3(fragCoord + vec2(0.0, -1.0), bottomPixelDepth)
                                  : vec3(fragCoord + vec2(0.0, 1.0), topPixelDepth);

      vec3 verticalPixelPos = reconstructPosition(fragCoordHorizontal.xy, fragCoordHorizontal.z);
      vec3 horizontalPixelPos = reconstructPosition(fragCoordVertical.xy, fragCoordVertical.z);

      vec3 normal = normalize(cross(verticalPixelPos - pixelPos, horizontalPixelPos - pixelPos));
      // Flip normal depending on triangle winding order for consistency
      return pickLeft == pickBottom ? normal : -normal;
    }

    void main(void) {
      vec4 highlightInfo = texture(highlightTexture, uv);
      float visiblyHighlighted = (1.0 - clamp(distance(unoccludedHighlightFlag, highlightInfo), 0.0, 1.0)) * highlightInfo.a;
      if (visiblyHighlighted > ${f.float(b)}) {
        discard;
      }

      ivec2 iuv = ivec2(uv * vec2(textureSize(depthMap, 0)));
      float depth = rgba2float(texelFetch(depthMap, iuv, 0));
      // 0.0 is the clear value of depthMap, which means nothing has been drawn there and we should discard
      if (depth == 0.0) {
        discard;
      }

      float currentPixelDepth = linearDepthFromFloat(depth, nearFar);
      if (-currentPixelDepth>nearFar.y || -currentPixelDepth<nearFar.x) {
        discard;
      }

      vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);
      vec4 worldSpacePos = inverseViewMatrix * currentPixelPos;

      mat4 shadowMatrix;
      float linearDepth = -currentPixelDepth;
      int i = chooseCascade(linearDepth, shadowMatrix);
      if (i >= numCascades) {
        discard;
      }

      vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);

      // vertex completely outside? -> no shadow
      if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
        discard;
      }

      ivec2 texSize = textureSize(highlightDepthTex, 0);
      ivec2 uvShadow = ivec2(cascadeCoordinates(i, texSize, lvpos) * vec2(texSize));

      float depthHighlight = readShadowMapDepth(uvShadow, highlightDepthTex);
      bool shadowHighlight = depthHighlight < lvpos.z;
      if (!shadowHighlight) {
        discard;
      }

      float depthDefault = readShadowMapDepth(uvShadow, defaultDepthTex);
      bool shadowDefault = depthDefault < lvpos.z;

      vec3 normal = normalFromDepth(currentPixelPos.xyz, gl_FragCoord.xy, iuv);
      bool shaded = dot(normal, lightingMainDirectionView) < ${f.float(D)};

      float fragOpacity = (shadowDefault || shaded) ? occludedOpacity : opacity;
      fragColor = vec4(uColor.rgb, uColor.a * fragOpacity * terminationFactor);
    }
  `),a}const M=o(),y=a(),S=Object.freeze(Object.defineProperty({__proto__:null,build:F},Symbol.toStringTag,{value:"Module"}));export{S,F as b};
