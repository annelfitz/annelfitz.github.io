/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../core/Logger.js";import{fromRotationTranslationScaleOrigin as t,multiply as r,getScaling as o,scale as i,getTranslation as s}from"../../../core/libs/gl-matrix-2/math/mat4.js";import{create as n}from"../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{IDENTITY as a}from"../../../core/libs/gl-matrix-2/factories/quatf64.js";import{s as l,i as c,h as f}from"../../../chunks/vec32.js";import{ZEROS as p,create as m}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import g from"../../Point.js";import{getSphericalPCPF as u}from"../../spatialReferenceEllipsoidUtils.js";import{projectPointToVector as j}from"../../projection/projectPointToVector.js";import{fromMatrix as x}from"../axisAngleDegrees.js";import d from"../MeshTransform.js";import{isMeshWithRelativeVertexSpace as h}from"../meshVertexSpaceUtils.js";import{usesLocalTangentPlaneOnECEFForOperations as b}from"./geographicUtils.js";import{projectToPCPF as v,projectNormalToPCPF as w,projectTangentToPCPF as A,projectFromPCPF as k,projectNormalFromPCPF as y,projectTangentFromPCPF as R}from"./projection.js";import{projectPointToVertexSpace as F}from"./vertexSpaceConversion.js";const $="esri.geometry.support.meshUtils.scale";function P(e,t,r){if(!e.vertexAttributes?.position)return;const{vertexSpace:o,spatialReference:i}=e,s=r?.origin??e.anchor,n=r?.geographic,a=b($,o,i,n);h(e)?S(e,t,s):a?U(e,t,s):C(e,t,s)}function S(n,f,u){n.transform??=new d;const{vertexSpace:j,transform:h,spatialReference:b}=n,[v,w,A]=j.origin,k=new g({x:v,y:w,z:A,spatialReference:b}),y=q;if(k.equals(u))l(y,0,0,0);else if(!F(y,u,n))return void e.getLogger($).error(`Failed to project specified origin (wkid:${u.spatialReference.wkid}) to mesh (wkid:${b.wkid}) ${j.type} vertex space. Projection may be possible after calling projection.load().`);const R=l(z,f,f,f),P=t(M,a,p,R,y),{localMatrix:S}=h,U=r(M,P,S);h.scale=o(m(),U),i(U,U,c(q,h.scale)),h.rotation=x(U),h.translation=s(m(),U)}function U(e,t,r){const o=e.spatialReference,i=u(o),s=T;j(r,s,i)||j(e.origin,s,i);const n=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,c=new Float64Array(n.length),f=null!=a?new Float32Array(a.length):null,p=null!=l?new Float32Array(l.length):null;v(n,o,c),null!=a&&null!=f&&w(a,n,c,o,f),null!=l&&null!=p&&A(l,n,c,o,p),L(c,t,s),k(c,n,o),null!=a&&null!=f&&y(f,n,c,o,a),null!=l&&null!=p&&R(p,n,c,o,l),e.vertexAttributesChanged()}function C(t,r,o){const i=T;if(!j(o,i,t.spatialReference)){const r=t.origin;i[0]=r.x,i[1]=r.y,i[2]=r.z,e.getLogger($).error(`Failed to project specified origin (wkid:${o.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}L(t.vertexAttributes.position,r,i),t.vertexAttributesChanged()}function L(e,t,r=p){if(e)for(let o=0;o<e.length;o+=3){for(let t=0;t<3;t++)q[t]=e[o+t]-r[t];f(q,q,t);for(let t=0;t<3;t++)e[o+t]=q[t]+r[t]}}const q=m(),z=m(),M=n(),T=m();export{P as scale};
