/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../../geometry.js";import e from"../../../Ground.js";import t from"../../../core/Logger.js";import{getMetersPerUnitForSR as o}from"../../../core/unitUtils.js";import n from"../../Mesh.js";import{project as r}from"../../projection.js";import{compactIndices as i}from"../Indices.js";import a from"../MeshComponent.js";import{MeshVertexAttributes as s}from"../MeshVertexAttributes.js";import l from"../../Point.js";async function m(o,n,r){let i;if(p(o)||o instanceof e){const e=await u(o);return i=await e.createElevationSampler(n,{demResolution:r?.demResolution??"finest-contiguous"}),c(i,n,{material:r?.material})}return"string"==typeof r?.demResolution?(t.getLogger("esri.geometry.support.meshUtils.elevation").error("create()","demResolution must be a number when used directly with a sampler"),null):c(o,n,{material:r?.material,demResolution:r?.demResolution})}function c(e,t,l){const m=o(t.spatialReference),c=(l?.demResolution??e.demResolution.min)/m,u=Math.round(t.width/c),p=Math.round(t.height/c),d=u+1,h=p+1,y=new Float64Array(d*h*3),R=new Float32Array(d*h*2);let w=0,g=0;const j=new Uint32Array(u*p*2*3);let v=0,A=0;const x=!e.spatialReference.equals(t.spatialReference);f.spatialReference=t.spatialReference;const{xmin:b,ymin:M,height:U,width:F}=t;for(let o=0;o<h;o++){const t=M+U*(o/p);for(let n=0;n<d;n++){const i=b+F*(n/u);if(y[w++]=i,y[w++]=t,x){f.x=i,f.y=t;const o=r(f,e.spatialReference);y[w++]=e.elevationAt(o.x,o.y)??0}else y[w++]=e.elevationAt(i,t)??0;const a=n/u,s=o/p;R[g++]=a,R[g++]=s,o!==p&&n!==u&&(j[A++]=v+1,j[A++]=v+d+1,j[A++]=v+d,j[A++]=v,j[A++]=v+1,j[A++]=v+d),v++}}return new n({vertexAttributes:new s({position:y,uv:R}),components:[new a({faces:i(j),shading:"smooth",material:l?.material??null})],spatialReference:t.spatialReference})}async function u(e){return p(e)?e.load():(await e.load(),await Promise.allSettled(e.layers.items.map((e=>e.load()))),e)}function p(e){return"type"in e&&("elevation"===e.type||"base-elevation"===e.type)}const f=new l;export{m as create};
