/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{equals as t}from"../../core/arrayUtils.js";import{Axis as n}from"./Axis.js";import{getInfo as r}from"./spatialReferenceUtils.js";function e(t){if(!t)return null;if(Array.isArray(t))return t;const n=t.hasZ,r=t.hasM;if("point"===t.type)return r&&n?[t.x,t.y,t.z,t.m]:n?[t.x,t.y,t.z]:r?[t.x,t.y,t.m]:[t.x,t.y];if("polygon"===t.type)return t.rings.slice(0);if("polyline"===t.type)return t.paths.slice(0);if("multipoint"===t.type)return t.points.slice(0);if("extent"===t.type){const n=t.clone().normalize();if(!n)return null;let r=!1,e=!1;return n.forEach((t=>{t.hasZ&&(r=!0),t.hasM&&(e=!0)})),n.map((t=>{const n=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(r&&t.hasZ){const r=.5*(t.zmax-t.zmin);for(let t=0;t<n.length;t++)n[t].push(r)}if(e&&t.hasM){const r=.5*(t.mmax-t.mmin);for(let t=0;t<n.length;t++)n[t].push(r)}return n}))}return null}function i(t,n){const r=n[0]-t[0],e=n[1]-t[1];if(t.length>2&&n.length>2){const i=t[2]-n[2];return Math.sqrt(r*r+e*e+i*i)}return Math.sqrt(r*r+e*e)}function o(t,n,r){const e=t[0]+r*(n[0]-t[0]),i=t[1]+r*(n[1]-t[1]);return t.length>2&&n.length>2?[e,i,t[2]+r*(n[2]-t[2])]:[e,i]}function s(t,n,r,e){return f(t,n,r[e],r[e+1])}function f(t,n,r,e){const[i,o]=n,[s,f]=r,[l,u]=e,c=l-s,h=u-f,p=c*c+h*h,a=(i-s)*c+(o-f)*h,y=Math.min(1,Math.max(0,a/p));return t[0]=s+c*y,t[1]=f+h*y,t}function l(t,n,r){let e,i,o,s,f=!1,l=1/0;for(r.reset();r.nextPath();)if(r.nextPoint())for(e=r.x,i=r.y;r.nextPoint();)o=r.x,s=r.y,i>n!=s>n&&t<(o-e)*(n-i)/(s-i)+e&&(f=!f),l=Math.min(l,u(t,n,e,i,o,s)),e=o,i=s;return 0===l?0:(f?1:-1)*Math.sqrt(l)}function u(t,n,r,e,i,o){let s=r,f=e,l=i-s,u=o-f;if(0!==l||0!==u){const r=((t-s)*l+(n-f)*u)/(l*l+u*u);r>1?(s=i,f=o):r>0&&(s+=l*r,f+=u*r)}return l=t-s,u=n-f,l*l+u*u}function c(t,n){return o(t,n,.5)}function h(t){const n=t.length;let r=0;for(let e=0;e<n-1;++e)r+=i(t[e],t[e+1]);return r}function p(t,n){if(n<=0)return t[0];const r=t.length;let e=0;for(let s=0;s<r-1;++s){const r=i(t[s],t[s+1]);if(n-e<r){const i=(n-e)/r;return o(t[s],t[s+1],i)}e+=r}return t[r-1]}function a(t,r=n.X,e=n.Y){let i=0;const o=t.length;let s=t[0];for(let n=0;n<o-1;n++){const o=t[n+1];i+=(o[r]-s[r])*(o[e]+s[e]),s=o}return i>=0}function y(n){const r=n.length;return r>2&&t(n[0],n[r-1])}function m(t){if("rings"in t&&(g(t),t.rings.length>0&&!a(t.rings[0])))for(const n of t.rings)n.reverse()}function g(t){if("rings"in t)for(const n of t.rings)y(n)||n.push(n[0].slice())}function x(t){if("polygon"!==t.type&&"polyline"!==t.type)return t;return M("polygon"===t.type?t.rings:t.paths,t.spatialReference),t}function M(t,n){const e=r(n);if(!e)return;const i=e.valid[0],o=e.valid[1],s=o-i;for(const r of t){let t=1/0,n=-1/0;for(const s of r){const r=z(s[0],i,o);t=Math.min(t,r),n=Math.max(n,r),s[0]=r}const e=n-t;s-e<e&&r.forEach((t=>{t[0]<0&&(t[0]+=s)}))}}function z(t,n,r){const e=r-n;return t<n?r-(n-t)%e:t>r?n+(t-n)%e:t}function v(t,n){if(t===n)return!0;if(t.type!==n.type)return!1;if("point"===t.type||"mesh"===t.type||"extent"===t.type)return!0;if("multipoint"===t.type)return t.points.length===n.points.length;const[r,e]="polyline"===t.type?[t.paths,n.paths]:[t.rings,n.rings];return r.length===e.length&&r.every(((t,n)=>t.length===e[n].length))}export{g as closeRings,m as closeRingsAndFixWinding,l as distanceFromPointToPolygon,u as distanceToSegmentSquared,e as geometryToCoordinates,i as getLength,c as getMidpoint,h as getPathLength,p as getPointOnPath,v as hasCompatibleTopology,a as isClockwise,y as isClosed,s as projectPointOnLine,f as projectPointOnLineSeg,x as unnormalizeGeometryOnDatelineCrossing,M as unnormalizeVerticesOnDatelineCrossing,z as unnormalizedCoordinate};
