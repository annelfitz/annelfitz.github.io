/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import{deprecatedFunction as t}from"../core/deprecate.js";import r from"../core/Error.js";import o from"../core/Loadable.js";import s from"../core/Logger.js";import{EsriPromiseMixin as n}from"../core/Promise.js";import{whenOrAbort as i}from"../core/promiseUtils.js";import{watch as a}from"../core/reactiveUtils.js";import{property as c}from"../core/accessorSupport/decorators/property.js";import"../core/has.js";import"../core/RandomLCG.js";import{subclass as p}from"../core/accessorSupport/decorators/subclass.js";import{fromValues as l}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import m from"./Extent.js";import h from"./Geometry.js";import u from"./Point.js";import f from"./Polygon.js";import{composeAxes as d,create as x}from"./support/axisAngleDegrees.js";import y from"./support/MeshComponent.js";import{componentNotFoundMessage as v,meshNotLoadedMessage as g,invalidLocationMessage as j,invalidPolygonMessage as S,InvalidLocationError as w}from"./support/meshErrors.js";import b from"./support/MeshGeoreferencedVertexSpace.js";import A from"./support/MeshLocalVertexSpace.js";import L from"./support/MeshTransform.js";import{MeshVertexAttributes as M}from"./support/MeshVertexAttributes.js";import{isRelativeVertexSpace as F,vertexSpaceOriginToPoint as R,createVertexSpace as _,preferredVertexSpaceTypeForSR as U}from"./support/meshVertexSpaceUtils.js";import{triangulate as C}from"./support/triangulationUtils.js";import{getExtentFromBounds as E,getExtentFromPositions as P,getBoundsFromPositions as z}from"./support/meshUtils/bounds.js";import{centerAt as G}from"./support/meshUtils/centerAt.js";import{loadExternal as k}from"./support/meshUtils/loadExternal.js";import{Metadata as B}from"./support/meshUtils/Metadata.js";import{convertUnitGeometry as I,createUnitSizeBox as T,extractSingleFaceOfBox as V,createUnitSizeSphere as O,createUnitSizeCylinder as W,convertPlaneSizeParameter as D,createUnitSizePlane as N}from"./support/meshUtils/primitives.js";import{rotate as Z}from"./support/meshUtils/rotate.js";import{scale as q}from"./support/meshUtils/scale.js";var H;const K="esri.geometry.Mesh";function J(){return s.getLogger(K)}const Q={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:b,local:A}};let X=H=class extends(o.LoadableMixin(n(h))){constructor(e){super(e),this.components=null,this.vertexSpace=new b,this.transform=null,this.metadata=new B,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new M,this.type="mesh"}initialize(){(0===this.metadata.externalSources.length||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.addHandles(a((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((e=>e.clone()))})),(()=>this._clearSources()),{once:!0,sync:!0}))}))}get hasExtent(){return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const{components:e,spatialReference:t,vertexAttributes:r,vertexSpace:o}=this,s=r.position;if(0===s.length||e&&0===e.length)return new m({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t});if(F(o)){const{_untransformedBounds:e,transform:r}=this;return E(e,r,o,t)}return P(s,t)}get _untransformedBounds(){return z(this.vertexAttributes.position)}get anchor(){const e=R(this.vertexSpace,this.spatialReference);if(null!=e)return e;const{center:t,zmin:r}=this._transformedExtent;return new u({x:t.x,y:t.y,z:r,spatialReference:this.spatialReference})}get origin(){const e=R(this.vertexSpace,this.spatialReference);return null!=e?e:this._transformedExtent.center}get extent(){return this.loaded||null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(e){this._checkIfLoaded("addComponent()")&&(this.components||(this.components=[]),this.components.push(y.from(e)),this.notifyChange("components"))}removeComponent(e){if(this._checkIfLoaded("removeComponent()")){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}J().error("removeComponent()",v)}}rotate(e,t,r,o){return d(e,t,r,Y),Z(this,Y,o),this}offset(e,t,r){if(!this._checkIfLoaded("offset()"))return this;const{vertexSpace:o,vertexAttributes:s}=this,n=s?.position;if(!n)return this;if(F(o)){const[s,n,i]=o.origin;o.origin=l(s+e,n+t,i+r)}else{for(let o=0;o<n.length;o+=3)n[o]+=e,n[o+1]+=t,n[o+2]+=r;this.vertexAttributesChanged()}return this}scale(e,t){return this._checkIfLoaded("scale()")?(q(this,e,t),this):this}centerAt(e,t){return this._checkIfLoaded("centerAt()")?(G(this,e,t),this):this}load(e){const{metadata:{displaySource:t}}=this;return t&&this.addResolvingPromise(k(this,t,e)),Promise.resolve(this)}addExternalSources(e){this.metadata.externalSources.addMany(e)}updateDisplaySource(e){this.metadata.displaySource=e}clone(){return this.cloneWithVertexSpace(this.vertexSpace.clone())}cloneWithVertexSpace(e){let t=null;if(this.components){const e=new Map,r=new Map;t=this.components.map((t=>t.cloneWithDeduplication(e,r)))}const r={components:t,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),vertexSpace:e,transform:this.transform?.clone()??null,metadata:this.metadata.clone()};return new H(r)}cloneShallow(){return new H({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const t=import("./support/meshUtils/exporters/gltf/gltfexport.js"),r=this.load(),o=await Promise.all([t,r]),{toBinaryGLTF:s}=o[0];return s(this,e)}get memoryUsage(){let e=0;if(e+=this.vertexAttributes.memoryUsage,null!=this.components)for(const t of this.components)e+=t.memoryUsage;return e}_clearSources(){this.metadata.clearSources()}_checkIfLoaded(e){return!!this.loaded||(J().error(e,g),!1)}static createBox(e,t){if(!(e instanceof u))return J().error(".createBox()",j),null;const r=new H(I(T(),e,t));return t?.imageFace&&"all"!==t.imageFace?V(r,t.imageFace):r}static createSphere(e,t){return e instanceof u?new H(I(O(t?.densificationFactor||0),e,t)):(J().error(".createSphere()",j),null)}static createCylinder(e,t){return e instanceof u?new H(I(W(t?.densificationFactor||0),e,t)):(J().error(".createCylinder()",j),null)}static createPlane(e,t){if(!(e instanceof u))return J().error(".createPlane()",j),null;const r=t?.facing??"up",o=D(r,t?.size);return new H(I(N(r),e,{...t,size:o}))}static createFromPolygon(e,t){if(!(e instanceof f))return J().error(".createFromPolygon()",S),null;const r=C(e);return new H({vertexAttributes:new M({position:r.position}),components:[new y({faces:r.faces,shading:"flat",material:t?.material??null})],spatialReference:e.spatialReference,vertexSpace:new b})}static async createFromGLTF(e,t,r){if(!(e instanceof u)){const e=new w;throw J().error(".createfromGLTF()",e.message),e}const{loadGLTFMesh:o}=await i(import("./support/meshUtils/loadGLTFMesh.js"),r);return new H(await o(e,t,r))}static async createFromFiles(e,o,s){t(J(),"`Mesh.createFromFiles` is deprecated in favor of 'SceneLayer.convertMesh'",{replacement:"SceneLayer.convertMesh",version:"4.29"});const n=e=>J().error(".createFromFiles()",e.message);if(!(e instanceof u)){const e=new w;throw n(e),e}if(!s?.layer)throw new r("invalid:no-layer","SceneLayer required for file to mesh conversion.");return s.layer.convertMesh(o,{location:e,...s})}static createWithExternalSource(e,t,r){const o=r?.extent??null,{x:s,y:n,z:i,spatialReference:a}=e,c=r?.transform?.clone()??new L,p=l(s,n,i??0),m=_(r?.vertexSpace??U(a),p),h={source:t,extent:o},u=new B;return u.externalSources.push(h),new H({metadata:u,transform:c,vertexSpace:m,spatialReference:a})}static createIncomplete(e,t){const{x:o,y:s,z:n,spatialReference:i}=e,a=t?.transform?.clone()??new L,c=l(o,s,n??0),p=_(t?.vertexSpace??U(i),c),m=new H({transform:a,vertexSpace:p,spatialReference:i});return m.addResolvingPromise(Promise.reject(new r("mesh-incomplete","Mesh resources are not complete"))),m}};e([c({type:[y],json:{write:!0}})],X.prototype,"components",void 0),e([c({nonNullable:!0,types:Q,constructOnly:!0,json:{write:!0}})],X.prototype,"vertexSpace",void 0),e([c({type:L,json:{write:!0}})],X.prototype,"transform",void 0),e([c({constructOnly:!0})],X.prototype,"metadata",void 0),e([c()],X.prototype,"hasExtent",null),e([c()],X.prototype,"_transformedExtent",null),e([c()],X.prototype,"_untransformedBounds",null),e([c()],X.prototype,"anchor",null),e([c()],X.prototype,"origin",null),e([c({readOnly:!0,json:{read:!1}})],X.prototype,"extent",null),e([c({readOnly:!0,json:{read:!1,write:!0,default:!0}})],X.prototype,"hasZ",void 0),e([c({readOnly:!0,json:{read:!1,write:!0,default:!1}})],X.prototype,"hasM",void 0),e([c({type:M,nonNullable:!0,json:{write:!0}})],X.prototype,"vertexAttributes",void 0),X=H=e([p(K)],X);const Y=x(),$=X;export{$ as default};
