/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import n from"../core/Error.js";import{throwIfAborted as e,waitTick as r}from"../core/promiseUtils.js";import{trackAccess as t}from"../core/accessorSupport/tracking.js";import{SimpleObservable as l}from"../core/accessorSupport/tracking/SimpleObservable.js";import{create as o}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import{isSphericalECEF as i,isSphericalPCPF as u}from"./ellipsoidUtils.js";import s from"./Extent.js";import a from"./Multipoint.js";import{l as c,p as f,i as p}from"../chunks/pe.js";import m from"./Point.js";import h from"./Polygon.js";import g from"./Polyline.js";import R from"./SpatialReference.js";import{projectBuffer as j}from"./projection/projectBuffer.js";import{getProjector as y,projectorCache as d}from"./projection/projectors.js";import{projectXYZToVector as x}from"./projection/projectXYZToVector.js";import w from"./support/GeographicTransformation.js";import{equals as z,isValid as M}from"./support/spatialReferenceUtils.js";import{getGeometryZScaler as Z}from"./support/zscale.js";let v=null,A=null,S=null,G={};const P=new l;function b(){return!!v&&p()}function E(){return!!b()||(t(P),k(),!1)}function T(n,e){return!n||!e||(F(n,e)||E())}function _(n,e){return!F(n,e)&&!b()}function k(n){return null==S&&(S=Promise.all([c(),import("../chunks/geometryEngineBase.js").then((n=>n.g)),import("./geometryAdapters/hydrated.js")])),S.then((([,r,{hydratedAdapter:t}])=>{e(n),A=t,v=r.default,v._enableProjection(f),P.notify()}))}function B(n,e,r=null,t=null){return Array.isArray(n)?0===n.length?[]:U(A,n,n[0].spatialReference,e,r,t):U(A,[n],n.spatialReference,e,r,t)[0]}function U(n,e,r,t,l=null,o=null){if(null==r||null==t)return e;if(F(r,t,l))return e.map((n=>I(n,r,t)));if(null==l&&i(r)){return e.map((n=>I(n,r,R.WGS84))).map((n=>C(n,t)))}if(null==l&&i(t)){return e.map((n=>C(n,R.WGS84))).map((n=>I(n,R.WGS84,t)))}if(null==l){const n=w.cacheKey(r,t);void 0!==G[n]?l=G[n]:(null==(l=O(r,t,void 0))&&(l=new w),G[n]=l)}if(null==v||null==n)throw new X;return null!=o?v._project(n,e,r,t,l,o):v._project(n,e,r,t,l)}function W(n,e){const r=K([n],e);return null!=r.pending?{pending:r.pending,geometry:null}:null!=r.geometries?{pending:null,geometry:r.geometries[0]}:{pending:null,geometry:null}}function K(n,e){if(!b())for(const r of n)if(null!=r&&!z(r.spatialReference,e)&&M(r.spatialReference)&&M(e)&&!F(r.spatialReference,e))return t(P),{pending:k(),geometries:null};return{pending:null,geometries:n.map((n=>null==n?null:z(n.spatialReference,e)?n:M(n.spatialReference)&&M(e)?C(n,e):null))}}function O(n,e,r=null){if(null==n||null==e)return null;if(null==v||null==A)throw new X;const t=v._getTransformation(A,n,e,r,r?.spatialReference);return null!==t?w.fromGE(t):null}function V(n,e,r=null){if(null==v||null==A)throw new X;const t=v._getTransformationBySuitability(A,n,e,r,r?.spatialReference);if(null!==t){const n=[];for(const e of t)n.push(w.fromGE(e));return n}return[]}class X extends n{constructor(){super("projection:not-loaded","projection engine not fully loaded yet, please call load()")}}function Y(){v=null,A=null,S=null,G={}}const q={get loadPromise(){return S}};function C(n,e){try{const r=B(n,e);if(null==r)return null;"xmin"in n&&"xmin"in r&&(r.zmin=n.zmin,r.zmax=n.zmax);const t=Z(r.type,n.spatialReference,e);return null!=t&&t(r),r}catch(r){if(!(r instanceof X))throw r;return null}}async function D(n,e,r){const t=n.spatialReference;return null!=t&&null!=e&&await H(t,e,null,r),C(n,e)}function F(n,e,r){return!r&&(!!z(n,e)||M(n)&&M(e)&&!!y(n,e,d))}async function H(n,e,t,l){if(b())return r(l);if(Array.isArray(n)){for(const{source:r,dest:o,geographicTransformation:i}of n)if(r&&o&&!F(r,o,i))return k(l)}else if(n&&e&&!F(n,e,t))return k(l);return r(l)}function I(n,e,r){return n?"x"in n?L(n,e,new m,r,0):"xmin"in n?ln(n,e,new s,r,0):"rings"in n?rn(n,e,new h,r,0):"paths"in n?nn(n,e,new g,r,0):"points"in n?Q(n,e,new a,r,0):null:null}function J(n,e,r=e.spatialReference,t=0){return null!=r&&null!=n.spatialReference&&null!=L(n,n.spatialReference,e,r,t)}function L(n,e,r,t,l){un[0]=n.x,un[1]=n.y;const o=n.z;return un[2]=void 0!==o?o:l,j(un,e,0,un,t,0,1)?(r.x=un[0],r.y=un[1],r.spatialReference=t,void 0!==o||u(t)?(r.z=un[2],r.hasZ=!0):(r.z=void 0,r.hasZ=!1),void 0===n.m?(r.m=void 0,r.hasM=!1):(r.m=n.m,r.hasM=!0),r):null}function N(n,e,r=e.spatialReference,t=0){return null!=n.spatialReference&&null!=r&&null!=Q(n,n.spatialReference,e,r,t)}function Q(n,e,r,t,l){const{points:o,hasZ:i,hasM:s}=n,a=[],c=o.length,f=[];for(const u of o)f.push(u[0],u[1],i?u[2]:l);if(!j(f,e,0,f,t,0,c))return null;const p=i||u(t);for(let u=0;u<c;++u){const n=3*u,e=f[n],r=f[n+1];p&&s?a.push([e,r,f[n+2],o[u][3]]):p?a.push([e,r,f[n+2]]):s?a.push([e,r,o[u][2]]):a.push([e,r])}return r.points=a,r.spatialReference=t,r.hasZ=i,r.hasM=s,r}function $(n,e,r=e.spatialReference,t=0){return null!=n.spatialReference&&null!=r&&null!=nn(n,n.spatialReference,e,r,t)}function nn(n,e,r,t,l){const{paths:o,hasZ:i,hasM:s}=n,a=[];if(!on(o,i??!1,s??!1,e,a,t,l))return null;const c=i||u(t);return r.paths=a,r.spatialReference=t,r.hasZ=c,r.hasM=s,r}function en(n,e,r=e.spatialReference,t=0){return null!=n.spatialReference&&null!=r&&null!=rn(n,n.spatialReference,e,r,t)}function rn(n,e,r,t,l){const{rings:o,hasZ:i,hasM:s}=n,a=[];if(!on(o,i??!1,s??!1,e,a,t,l))return null;const c=i||u(t);return r.rings=a,r.spatialReference=t,r.hasZ=c,r.hasM=s,r}function tn(n,e,r=e.spatialReference,t=0){return null!=n.spatialReference&&null!=r&&null!=ln(n,n.spatialReference,e,r,t)}function ln(n,e,r,t,l){const{xmin:o,ymin:i,xmax:s,ymax:a,hasZ:c,hasM:f}=n,p=c?n.zmin:l;if(!x(o,i,p,e,un,t))return null;const m=c||u(t);r.xmin=un[0],r.ymin=un[1],m&&(r.zmin=un[2]);const h=c?n.zmax:l;return x(s,a,h,e,un,t)?(r.xmax=un[0],r.ymax=un[1],m&&(r.zmax=un[2]),f&&(r.mmin=n.mmin,r.mmax=n.mmax),r.spatialReference=t,r):null}function on(n,e,r,t,l,o,i=0){const s=new Array;for(const u of n)for(const n of u)s.push(n[0],n[1],e?n[2]:i);if(!j(s,t,0,s,o,0,s.length/3))return!1;let a=0;l.length=0;const c=e||u(o);for(const u of n){const n=new Array;for(const e of u)c&&r?n.push([s[a++],s[a++],s[a++],e[3]]):c?n.push([s[a++],s[a++],s[a++]]):r?(n.push([s[a++],s[a++],e[2]]),a++):(n.push([s[a++],s[a++]]),a++);l.push(n)}return!0}const un=o();export{F as canProjectWithoutEngine,O as getTransformation,V as getTransformations,H as initializeProjection,b as isLoaded,E as isLoadedOrLoad,T as isLoadedOrLoadFor,k as load,B as project,tn as projectExtent,U as projectMany,N as projectMultipoint,W as projectOrLoad,K as projectOrLoadMany,J as projectPoint,en as projectPolygon,$ as projectPolyline,D as projectWithZConversion,I as projectWithoutEngine,_ as requiresLoad,q as test,C as tryProjectWithZConversion,Y as unload};
