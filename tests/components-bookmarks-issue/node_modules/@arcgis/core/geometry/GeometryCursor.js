/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{clone as t}from"../core/lang.js";import{collectMultipath as e}from"./geometryCursorCollectUtils.js";import{isPolygon as s,isPolyline as i,isMultipoint as h,isExtent as r,isPoint as n}from"./support/jsonUtils.js";import o from"../layers/graphics/OptimizedGeometry.js";class a{static fromOptimized(t,e,s=!1,i=!1,h=1){return(new p).initialize(t,e,s,i,h)}static fromJSON(t,e=!1,s=!1){const[i,h]=u(t);return(new d).initialize(i,h,e,s,1)}static fromOptimizedCIM(t,e,s=!1,i=!1,h=1){return(new m).initialize(t,e,s,i,h)}static fromJSONCIM(t,e=!1,s=!1,i=1){const[h,r]=u(t);return(new y).initialize(h,r,e,s,i)}static fromFeatureSetReader(t){const e=t.readGeometryForDisplay(),s=t.geometryType;return e&&s?this.fromOptimized(e,s):null}static fromFeatureSetReaderCIM(t){const e=t.readGeometryForDisplay(),s=t.geometryType;return e&&s?this.fromOptimizedCIM(e,s):null}static createEmptyOptimized(t,e=!1,s=!1,i=1){return(new p).initialize(new o,t,e,s,i)}static createEmptyJSON(t,e=!1,s=!1){return(new d).initialize([],t,e,s,1)}static createEmptyOptimizedCIM(t,e=!1,s=!1,i=1){return(new m).initialize(new o,t,e,s,i)}static createEmptyJSONCIM(t,e=!1,s=!1,i=1){return(new y).initialize([],t,e,s,i)}asJSON(){const t=e(this);return"esriGeometryEnvelope"===this.geometryType?{xmin:t[0][0][0],ymin:t[0][0][1],xmax:t[0][2][0],ymax:t[0][2][1]}:"esriGeometryMultipoint"===this.geometryType?{points:t.flat()}:"esriGeometryPoint"===this.geometryType?{x:t[0][0][0],y:t[0][0][1]}:"esriGeometryPolygon"===this.geometryType?{rings:t}:{paths:t}}getCurrentRingArea(){if(this.pathSize<3)return 0;let t,e,s=0;if(this.seekPathStart(),!this.nextPoint())return 0;t=this.x,e=this.y;const i=t,h=e;for(;this.nextPoint();)s+=(t-this.x)*(e+this.y),t=this.x,e=this.y;return s+=(t-i)*(e+h),-.5*s}invertY(){this.yFactor*=-1}}class p extends a{constructor(){super(...arguments),this._end=-1}initialize(t,e,s,i,h){return this.hasZ=s,this.hasM=i,this.geometryType=e,this._stride=2+Number(s)+Number(i),this._geometry=t,this._pathIndex=-1,this._pathOffset=0,this._pointOffset=-this._stride,this._end=-1,this.yFactor=h,this}reset(){this.initialize(this._geometry,this.geometryType,this.hasZ,this.hasM,this.yFactor)}seekPath(t){if(t>=0&&t<this.totalSize){if(this._pathIndex<t)for(;this._pathIndex<t&&this.nextPath(););else if(this._pathIndex>t)for(;this._pathIndex>t&&this.prevPath(););return!0}return!1}seekPathStart(){this._pointOffset=this._pathOffset-this._stride}seekPathEnd(){this._pointOffset=this._end}seekInPath(t){const e=this._pathOffset+t*this._stride;return e>=0&&e<this._end&&(this._pointOffset=e,!0)}nextPoint(){return(this._pointOffset+=this._stride)<this._end}prevPoint(){return(this._pointOffset-=this._stride)>=this._pathOffset}nextPath(){return!(this.pathIndex>=this.totalSize-1)&&(this._pathIndex>=0&&(this._pathOffset+=this._stride*this.pathSize),this._pathIndex++,this._pointOffset=this._pathOffset-this._stride,this._end=this._pointOffset+this._stride+this._stride*this.pathSize,!0)}prevPath(){return!(this.pathIndex<=0)&&(this._pathIndex--,this._end=this._pathOffset,this._pathOffset-=this._stride*this.pathSize,this._pointOffset=this._pathOffset-this._stride,!0)}pathLength(){const t=this._end,e=this._stride,s=this._geometry.coords;let i=0;for(let h=this._pathOffset+e;h<t;h+=e){const t=s[h-e],r=s[h-e+1],n=s[h]-t,o=s[h+1]-r;i+=Math.sqrt(n*n+o*o)}return i}startPath(){this._geometry.lengths.push(0)}pushPath(t){this.startPath(),this.pushPoints(t)}pushPoint(t){for(let e=0;e<this._stride;++e)this._geometry.coords.push(t[e]);this._geometry.lengths[this.totalSize-1]++}pushXY(t,e){this._geometry.coords.push(t,e),this._geometry.lengths[this.totalSize-1]++}pushPoints(t){for(const e of t)for(let t=0;t<this._stride;++t)this._geometry.coords.push(e[t]);this._geometry.lengths[this.totalSize-1]+=t.length}pushCursor(t){const e=t.asOptimized();this._geometry.coords.push(...e.coords),this._geometry.lengths.push(...e.lengths)}asOptimized(){const t=this._geometry.clone();if(1!==this.yFactor)for(let e=1;e<t.coords.length;e+=this._stride)t.coords[e]*=this.yFactor;return"esriGeometryPoint"===this.geometryType&&(t.lengths.length=0),t}isClosed(){const t=this._geometry.coords,e=this._pathOffset,s=this._end-this._stride;for(let i=0;i<this._stride;i++)if(t[e+i]!==t[s+i])return!1;return!0}clone(){return(new p).initialize(this._geometry.clone(),this.geometryType,this.hasZ,this.hasM,this.yFactor)}get totalPoints(){return this._geometry.isPoint?1:this._geometry.lengths.reduce(((t,e)=>t+e))}get pathSize(){const{lengths:t}=this._geometry;return this._pathIndex<0||this._pathIndex>t.length-1?0:this._geometry.isPoint?1:t[this._pathIndex]}get totalSize(){return this._geometry.lengths.length}get x(){return this._geometry.coords[this._pointOffset]}set x(t){this._geometry.coords[this._pointOffset]=t}get y(){return this.yFactor*this._geometry.coords[this._pointOffset+1]}set y(t){this._geometry.coords[this._pointOffset+1]=this.yFactor*t}get z(){return this._geometry.coords[this._pointOffset+2]}set z(t){this._geometry.coords[this._pointOffset+2]=t}get m(){const t=this.hasZ?3:2;return this._geometry.coords[this._pointOffset+t]}set m(t){this._geometry.coords[this._pointOffset+3]=t}get pathIndex(){return this._pathIndex}get _coordIndex(){return this._pointOffset/this._stride}}function _(t){const e=[t.x,t.y];return t.z&&e.push(t.z),t.m&&e.push(t.m),e}function u(t){return s(t)?[t.rings,"esriGeometryPolygon"]:i(t)?[t.paths,"esriGeometryPolyline"]:h(t)?[[t.points],"esriGeometryMultipoint"]:r(t)?[[[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]],"esriGeometryEnvelope"]:n(t)?[[[_(t)]],"esriGeometryPoint"]:[[],"esriGeometryPolyline"]}class d extends a{initialize(t,e,s,i,h){return this._paths=t,this.geometryType=e,this.hasZ=s,this.hasM=i,this._pathIndex=this._pointIndex=-1,this.yFactor=h,this._mIndex=this.hasZ?3:2,this}reset(){this._pathIndex=this._pointIndex=-1}seekPath(t){return this._pathIndex=t,this._pointIndex=-1,t>=0&&t<this.totalSize&&(this._currentPath=this._paths[t],!0)}seekPathStart(){this._pointIndex=-1}seekPathEnd(){this._pointIndex=this._currentPath.length}seekInPath(t){return t>=0&&t<this._currentPath.length&&(this._pointIndex=t,this._currentPoint=this._currentPath[this._pointIndex],!0)}nextPoint(){return this._currentPoint=this._currentPath[++this._pointIndex],this._pointIndex<this._currentPath.length}prevPoint(){return this._currentPoint=this._currentPath[--this._pointIndex],this._pointIndex>=0}nextPath(){return this._pointIndex=-1,this._currentPath=this._paths[++this._pathIndex],this._pathIndex<this.totalSize}prevPath(){return this.pathIndex>0&&(this._pointIndex=-1,this._pathIndex--,this._currentPath=this._paths[this._pathIndex],!0)}pathLength(){const t=this._currentPath.length,e=this._currentPath;let s=0;for(let i=1;i<t;i++){const t=e[i-1],h=e[i],r=t[0],n=t[1],o=h[0]-r,a=h[1]-n;s+=Math.sqrt(o*o+a*a)}return s}startPath(){this._paths.push([])}pushPath(t){this._paths.push(t)}pushPoint(t){this._paths[this.totalSize-1].push(t)}pushXY(t,e){this._paths[this.totalSize-1].push([t,e])}pushPoints(t){this._paths[this.totalSize-1].push(...t)}pushCursor(t){const s=e(t);for(const e of s)this.pushPath(e)}asOptimized(){const t=new o;if("esriGeometryPoint"===this.geometryType)t.coords.push(...this._paths[0][0]),t.lengths.length=0;else for(const e of this._paths){for(const s of e)t.coords.push(s[0]),t.coords.push(s[1]*this.yFactor),this.hasZ&&t.coords.push(s[2]),this.hasM&&t.coords.push(s[this._mIndex]);t.lengths.push(e.length)}return t}isClosed(){const t=this._currentPath[0],e=this._currentPath[this._currentPath.length-1];for(let s=0;s<t.length;s++)if(t[s]!==e[s])return!1;return!0}clone(){return(new d).initialize(t(this._paths),this.geometryType,this.hasZ,this.hasM,this.yFactor)}get totalPoints(){return this._paths.map((t=>t.length)).reduce(((t,e)=>t+e))}get pathSize(){return this._pathIndex<0||this._pathIndex>this.totalSize-1?-1:this._paths[this._pathIndex].length}get totalSize(){return this._paths.length}get x(){return this._currentPoint[0]}set x(t){this._currentPoint[0]=t}get y(){return this.yFactor*this._currentPoint[1]}set y(t){this._currentPoint[1]=this.yFactor*t}get z(){return this._currentPoint[2]}set z(t){this._currentPoint[2]=t}get m(){return this._currentPoint[this._mIndex]}set m(t){this._currentPoint[this._mIndex]=t}get pathIndex(){return this._pathIndex}}const c=4,l=1;class m extends p{initialize(t,e,s,i,h){return super.initialize(t,e,s,i,h),this._controlPoints||(this._controlPoints=this._controlPoints=new Array(this.totalSize).fill(void 0).map((t=>new Set))),this}startPath(){super.startPath(),this._controlPoints.push(new Set)}clone(){const t=(new m).initialize(this._geometry.clone(),this.geometryType,this.hasZ,this.hasM,this.yFactor);return t._controlPoints=this._controlPoints,t}setControlPoint(){this._controlPoints[this.pathIndex].add(this._coordIndex)}getControlPoint(){return this._controlPoints[this.pathIndex].has(this._coordIndex)}setControlPointAt(t){this._controlPoints[this.pathIndex].add(t)}getControlPointAt(t){return this._controlPoints[this.pathIndex].has(t)}}class y extends d{initialize(t,e,s,i,h){return super.initialize(t,e,s,i,h)}clone(){return(new y).initialize(t(this._paths),this.geometryType,this.hasZ,this.hasM,this.yFactor)}setControlPoint(){this._paths[this.pathIndex][this._pointIndex][c]=l}getControlPoint(){return this._paths[this.pathIndex][this._pointIndex][c]===l}setControlPointAt(t){this._paths[this.pathIndex][t][c]=l}getControlPointAt(t){return this._paths[this.pathIndex][t][c]===l}}export{a as GeometryCursor};
