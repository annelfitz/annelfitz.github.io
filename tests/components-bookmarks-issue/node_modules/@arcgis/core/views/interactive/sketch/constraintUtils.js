/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../../geometry.js";import{valueInUnit as e,createLength as n,createAngle as t}from"../../../core/quantityUtils.js";import{verticalLengthUnitFromSpatialReference as r,lengthUnitFromSpatialReference as o}from"../../../core/unitUtils.js";import{f as i,c as l,g as u}from"../../../chunks/vec32.js";import{create as s}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectVectorToVector as c}from"../../../geometry/projection/projectVectorToVector.js";import{geodesicCompatibleSpatialReference as a}from"../../../geometry/support/geodesicUtils.js";import{makeDehydratedPoint as f}from"../../../layers/graphics/dehydratedPoint.js";import{getConvertedElevationFromXYZ as m}from"../../../support/elevationInfoUtils.js";import{CoordinateConstraint as d,constraintOrSet as p,VerticalCylinderConstraint as v,HorizontalPlaneConstraint as g,GeodesicConstraint as R,PointConstraint as j,VerticalHalfPlaneConstraint as w}from"./constraints.js";import{fromPoint as y,toElevationAlignedDehydratedPoint as x,fromVec3 as h}from"./normalizedPoint.js";import{getDegreesGeographic as S,DirectionMode as I,directionBetweenPoints as U,pointFromDistanceAlongAzimuth as M}from"../../support/angularMeasurementUtils.js";import b from"../../../geometry/SpatialReference.js";function Z(e,n,t,r,o,i){let l="geodesic",u=a(t);const s=y(e,n,r);return s[2]=0,u&&c(s,t,s,u)||(l="euclidean",u=t),{mode:l,view:n,elevationInfo:r,hasZ:o,directionMode:i,spatialReference:e.spatialReference,measurementSR:u,origin:s}}function A(n,t,r){if(null==t||null==n)return;const i=o(r.measurementSR);if(null==i)return;const l=W(n,r);if(null==l)return;const u=e(t,i);return new v(h(l),u)}function B(e,n,r,o){if(null==r||null==e)return;const i=W(e,o);if(null==i)return;const l=S(r),u=10,c=e=>{if(null==e)return;const n=s(),r=t(e,"degrees","geographic");return M(n,i,o.measurementSR,u,r,o.mode)?new w(i,n):void 0},a=()=>{if(null!=n&&null!=e)return S(U(n,e))};switch(o.directionMode){case I.Absolute:return c(l);case I.Relative:{const e=a();if(null==e)return;return c(e+l)}case I.RelativeBilateral:{const e=a();if(null==e)return;return p([c(e+l),c(e-l)])}}}function P(e,n){const t=D(e,n);return null!=t?new g(t):void 0}function T(e,n,t){const{context:r,longitude:o,latitude:i,direction:l,distance:u,elevation:s}=t;if(null!=o||null!=i||null!=u||null!=s||null!=l){if(null!=o||null!=i){const e=S(o),n=S(i),t=E(s,r);return new d(e,n,t)}return V(e,n,t)}}function V(n,t,{context:r,direction:o,distance:i,elevation:l}){if(null==t)return P(l,r);const{view:u,elevationInfo:s,measurementSR:a}=r,f=y(t,u,s);if(!a||!c(f,t.spatialReference,H,a))return;const m=[H[0],H[1]],d=null!=i?e(i,"meters"):void 0,v=S(o),g=E(l,r),w=e=>{const n=new R(m,a,d,g,e);return null==d||null==e||null==g&&r.hasZ?n:new j(n.closestTo(f))};if(null==v)return w(void 0);const x=()=>{if(null!=n&&null!=t)return S(U(n,t))};switch(r.directionMode){case I.Absolute:return w(v);case I.Relative:{const e=x();if(null==e)return;return w(e+v)}case I.RelativeBilateral:{const e=x();if(null==e)return;return p([w(e+v),w(e-v)])}}}function k(e){return"geodesic"===e.context.mode?T(null,null,e):z(e)}function q(e,n,t){const{context:r,x:o,y:i,distance:l,direction:u,elevation:s}=t;return"geodesic"===r.mode?T(n,e,t):null!=o||null!=i?z(t):G([A(e,l,r),B(e,n,u,r),P(s,r)])}function z({x:e,y:n,elevation:t,context:r}){J.x=e?.value??0,J.y=n?.value??0,J.spatialReference=r.spatialReference;const o=W(J,r);return new d(null!=e&&null!=o?o[0]:void 0,null!=n&&null!=o?o[1]:void 0,E(t,r))}function G(e){let n;for(const t of e)t&&(n=n?.intersect(t)??t);return n}function W(e,n){const{view:t,elevationInfo:r,measurementSR:o,origin:l,mode:u}=n,s=y(e,t,r);if(c(s,e.spatialReference,s,o))return"geodesic"!==u&&i(s,s,l),s}function C(e,n,t){const{view:r,measurementSR:o,spatialReference:i,origin:s,mode:a}=t,f=H;if("geodesic"===a?l(f,e):u(f,e,s),c(f,o,f,i))return x(f,r,n,t)}function D(e,n){return F(e,n)?.value??void 0}function E(n,t){const r=F(n,t);return null!=r?e(r,"meters"):void 0}function F(t,{view:o,origin:i,elevationInfo:l,hasZ:u,measurementSR:s}){if(null==t||!u)return;const c=r(s);if(null==c)return;const[a,f]=i,d=e(t,c),p="3d"===o?.type?m(o,a,f,d,s,l):d;return null!=p?n(p,c):void 0}const H=s(),J=f(0,0,0,b.WGS84);export{C as constraintSpaceToPoint,Z as getConstraintContext,T as getGeodesicConstraint,k as getPointConstraint,q as getPolylineOrPolygonConstraint,G as intersectAll,W as pointToConstraintSpace};
