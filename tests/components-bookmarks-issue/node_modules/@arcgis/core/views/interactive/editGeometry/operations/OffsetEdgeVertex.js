/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{deg2rad as t}from"../../../../core/mathUtils.js";import{subtract as i,normalize as e,dot as s}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{create as n}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{E as r,s as h,b as o,n as a,h as _,k as c,F as l,g as p,G as g,c as d}from"../../../../chunks/vec32.js";import{create as u}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{create as m,fromPositionAndNormal as f,signedDistance as D,copy as E,isPointInside as x,getNormal as b,intersectLine as I}from"../../../../geometry/support/plane.js";import{angle as M,projectPointSignedLength as N}from"../../../../geometry/support/vector.js";import{intersectLineAndRay as V,LineType as X}from"../../../support/geometry2dUtils.js";class Y{get plane(){return this._plane}get requiresSplitEdgeLeft(){return!this._left.isOriginalDirection}get requiresSplitEdgeRight(){return!this._right.isOriginalDirection}get edgeDirection(){return this._edgeDirection}constructor(t,i,e,s=0,n=y.IMMEDIATE){this._helper=t,this._planeType=i,this._edge=e,this.distance=s,this._plane=m(),this._offsetPlane=m(),this._minDistance=-1/0,this._maxDistance=1/0,this._selectedArrow=1,n===y.IMMEDIATE&&this._initialize()}_initialize(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()}_initializeNeighbors(){const t=this._toXYZ(this._edge.leftVertex.pos),i=this._toXYZ(this._edge.leftVertex.leftEdge?.leftVertex?.pos),e=this._toXYZ(this._edge.rightVertex.pos),s=this._toXYZ(this._edge.rightVertex.rightEdge?.rightVertex?.pos);this._edgeDirection=r(u(),t,e),i?(this._left=this._computeNeighbor(t,i,this._edgeDirection),this._right=this._computeNeighbor(e,s,this._edgeDirection,this._left)):(this._right=this._computeNeighbor(e,s,this._edgeDirection),this._left=this._computeNeighbor(t,i,this._edgeDirection,this._right))}_toXYZ(t){return null!=t?this._helper.toXYZ(t):null}_pointToXYZ(t){return this._toXYZ(this._helper.pointToVector(t))}_computeNeighbor(t,i,e,s){const n=u();if(i){r(n,t,i);const s=!this._passesBisectingAngleThreshold(n,e);return{start:t,end:i,direction:s?this._bisectVectorsPerpendicular(e,n):n,isOriginalDirection:!s}}return this._helper.hasZ()?s&&(o(n,e,s.direction),o(n,n,e),a(n,n),Math.sign(n[1])!==Math.sign(e[0])&&_(n,n,-1)):h(n,-e[1],e[0],0),{start:t,end:i,direction:n,isOriginalDirection:!0}}_passesBisectingAngleThreshold(t,i){const e=Math.abs(M(i,t));return e>=P&&e<=Math.PI-P}_bisectVectorsPerpendicular(t,i){const e=c(t,i)<0?t:l(u(),t),s=Math.abs(c(e,i));if(!(s<T||s>1-T))return this._bisectDirection(e,i);const n=o(u(),e,[0,0,1]);return a(n,n)}_bisectDirection(t,i){const e=p(u(),t,i);return a(e,e)}_initializePlane(){const t=this._computeNormalDirection(this._left),i=this._computeNormalDirection(this._right);c(t,i)<0&&l(i,i),f(this._left.start,this._bisectDirection(t,i),this._plane)}_computeNormalDirection(t){const i=o(u(),t.direction,this._edgeDirection);a(i,i);const e=o(u(),this._edgeDirection,i);return this._planeType===Z.XY&&(e[2]=0),a(e,e)}_initializeDistanceConstraints(){null==this._left.end||this.requiresSplitEdgeLeft||this._updateDistanceConstraint(D(this._plane,this._left.end)),null==this._right.end||this.requiresSplitEdgeRight||this._updateDistanceConstraint(D(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)}_updateDistanceConstraint(t){t<=0&&(this._minDistance=Math.max(this._minDistance,t)),t>=0&&(this._maxDistance=Math.min(this._maxDistance,t))}_updateIntersectDistanceConstraint(t){const r=b(t),h=this._edgeDirection,o=p(u(),this._left.start,this._left.direction),a=p(u(),this._right.start,this._right.direction),c=this._pointInBasis2D(n(),r,h,this._left.start),l=this._pointInBasis2D(n(),r,h,o),g=this._pointInBasis2D(n(),r,h,this._right.start),d=this._pointInBasis2D(n(),r,h,a),[m]=V({start:l,end:c,type:X.LINE},{start:d,end:g,type:X.LINE});if(!m)return;const f=i(n(),c,l);e(f,f);const E=i(n(),m,l),x=s(f,E),I=p(u(),o,_(u(),this._left.direction,-x)),M=D(t,I);this._updateDistanceConstraint(M)}_pointInBasis2D(t,i,e,s){return t[0]=N(i,s),t[1]=N(e,s),t}_offset(t,i){Number.isFinite(this._minDistance)&&(i=Math.max(this._minDistance,i)),Number.isFinite(this._maxDistance)&&(i=Math.min(this._maxDistance,i)),E(this._offsetPlane,this._plane),this._offsetPlane[3]-=i;const e=(t,i,e)=>null!=i&&I(this._offsetPlane,t,p(u(),t,i),e),s=u();(t===this._edge.leftVertex?e(this._left.start,this._left.direction,s):e(this._right.start,this._right.direction,s))&&this._helper.copy(this._helper.fromXYZ(s,void 0,this._helper.getM(t.pos)),t.pos)}selectArrowFromStartPoint(t){this._selectedArrow=x(this.plane,this._pointToXYZ(t))?1:-1}get selectedArrow(){return this._selectedArrow}signedDistanceToPoint(t){return D(this.plane,this._pointToXYZ(t))}apply(t){this._offset(t,this.distance)}undo(t){this._offset(t,0)}canAccumulate(t){return t instanceof Y&&this._edge.leftVertex.index===t._edge.leftVertex.index&&this._edge.rightVertex.index===t._edge.rightVertex.index&&this._edge.component===t._edge.component&&this._maybeEqualsVec3(this._left.direction,t._left.direction)&&this._maybeEqualsVec3(this._right.direction,t._right.direction)&&g(b(this._plane),b(t._plane))}accumulate(t,i){const e=this._plane[3]-i._plane[3]+i.distance;this._offset(t,e)}accumulateParams(t){const i=t.distance-t._plane[3];this.distance=i+this._plane[3]}clone(){const t=new Y(this._helper,this._planeType,this._edge,this.distance,y.DEFERRED);return E(t._plane,this._plane),E(t._offsetPlane,this._offsetPlane),t._maxDistance=this._maxDistance,t._minDistance=this._minDistance,t._left=this._cloneNeighbor(this._left),t._right=this._cloneNeighbor(this._right),t._edgeDirection=d(u(),this._edgeDirection),t}_maybeEqualsVec3(t,i){return null==t&&null==i||null!=t&&null!=i&&g(t,i)}_cloneNeighbor({start:t,end:i,direction:e,isOriginalDirection:s}){return{start:d(u(),t),end:null!=i?d(u(),i):null,direction:d(u(),e),isOriginalDirection:s}}}const P=t(15),T=.001;var Z,y;!function(t){t[t.XYZ=0]="XYZ",t[t.XY=1]="XY"}(Z||(Z={})),function(t){t[t.IMMEDIATE=0]="IMMEDIATE",t[t.DEFERRED=1]="DEFERRED"}(y||(y={}));export{Y as OffsetEdgeVertex,Z as PlaneType};
