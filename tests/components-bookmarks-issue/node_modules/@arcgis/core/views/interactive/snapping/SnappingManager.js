/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import e from"../../../core/Accessor.js";import n from"../../../core/Evented.js";import{isAborted as i}from"../../../core/promiseUtils.js";import{watch as s,sync as r,syncAndInitial as a}from"../../../core/reactiveUtils.js";import{property as o}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/Logger.js";import"../../../core/RandomLCG.js";import{subclass as p}from"../../../core/accessorSupport/decorators/subclass.js";import{project as c,initializeProjection as d}from"../../../geometry/projection.js";import{absoluteHeightElevationInfo as h}from"../../../support/elevationInfoUtils.js";import{fromPoint as l,toElevationAlignedDehydratedPoint as u}from"../sketch/normalizedPoint.js";import{defaults as f}from"./Settings.js";import{SnappingDomain as g}from"./SnappingDomain.js";import{defaultSnappingEnginesFactory as _}from"./snappingFactory.js";import m from"./SnappingOptions.js";import{sortCandidatesInPlace as S,squaredScreenDistance as v}from"./snappingUtils.js";import{DrapedEdgeSnappingCandidate as y}from"./candidates/DrapedEdgeSnappingCandidate.js";import{EdgeSnappingCandidate as C}from"./candidates/EdgeSnappingCandidate.js";import{IntersectionSnappingCandidate as P}from"./candidates/IntersectionSnappingCandidate.js";import{LineSnappingCandidate as E}from"./candidates/LineSnappingCandidate.js";import{ParallelLineSnappingCandidate as w}from"./candidates/ParallelLineSnappingCandidate.js";import{RightAngleSnappingCandidate as j,SelfSnappingRightAngleType as T}from"./candidates/RightAngleSnappingCandidate.js";import{RightAngleTriangleSnappingCandidate as M}from"./candidates/RightAngleTriangleSnappingCandidate.js";import{vectorToScreenPoint as R}from"../support/viewUtils.js";let q=class extends(n.EventedMixin(e)){constructor(t){super(t),this.options=new m,this.snappingEnginesFactory=_,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=A.MAIN}initialize(){this.addHandles([s((()=>{const{effectiveFeatureEnabled:t,effectiveSelfEnabled:e,touchSensitivityMultiplier:n,distance:i}=this.options;return{effectiveFeatureEnabled:t,effectiveSelfEnabled:e,touchSensitivityMultiplier:n,distance:i}}),(()=>{this.doneSnapping(),this.emit("changed")}),r),s((()=>this.options),(t=>{for(const e of this._engines)e.options=t}),r),s((()=>({viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,snappingEnginesFactory:this.snappingEnginesFactory})),(({viewReady:t,snappingEnginesFactory:e})=>this._recreateEngines(t,e)),a)])}destroy(){this._destroyEngines()}get updating(){return this._engines.some((t=>t.updating))}_recreateEngines(t,e){if(this._destroyEngines(),!t)return;const{view:n,options:i}=this;this._engines=e(n,i)}_destroyEngines(){for(const t of this._engines)t.destroy();this._engines=[]}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:t,touchSensitivityMultiplier:e}=this.options,n=t*e;return n*n}snap(t){return H(t)?this._snapMultiPoint(t):this._snapSinglePoint(t)}update(t){const{point:e,context:n}=t;this._removeVisualization();const i=this._currentMainCandidate;if(null==i)return e;const s=this._selectUpdateInput(t);if(null==s)return e;const{spatialReference:r}=n,a=c(s,r);if(null==a)return e;const{view:o}=this,{elevationInfo:p,visualizer:d}=n,h=[],f=l(a,o,p),g=i.constraint.closestTo(f);if(!this._arePointsWithinScreenThreshold(f,g,n)||!z(i,n.drawConstraints))return this._resetSnappingState(),e;i.targetPoint=g,h.push(...i.hints);for(const c of this._currentOtherActiveCandidates)z(c,n.drawConstraints)&&(c.targetPoint=g,h.push(...c.hints));return null!=d&&this.addHandles(d.draw(h,{spatialReference:r,elevationInfo:O(n),view:o,selfSnappingZ:n.selfSnappingZ}),I),u(g,o,e,n)}doneSnapping(){this._removeVisualization(),this._resetSnappingState()}_selectUpdateInput({point:t,scenePoint:e}){switch(this._currentSnappedType){case A.MAIN:return t;case A.SCENE:return e}}_resetSnappingState(){this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=A.MAIN}_removeVisualization(){this.removeHandles(I)}async _snapSinglePoint({point:t,context:e,signal:n}){const{view:i}=this,{elevationInfo:s}=e,r=l(t,i,s),a=await this._fetchCandidates(r,g.ALL,e,n);return this._createSnapResult(r,A.MAIN,a,i,t,e,n)}async _snapMultiPoint({point:t,scenePoint:e,context:n,signal:i}){const{view:s}=this,{coordinateHelper:r,elevationInfo:a,spatialReference:o}=n;await d(e.spatialReference,o);const p=c(e,o),h=l(p,s,a),u=await this._fetchCandidates(h,g.FEATURE,n,i);if(u.length>0){const t=await this._fetchCandidates(h,g.SELF,n,i);return this._createSnapResult(h,A.SCENE,[...u,...t],s,p,n,i)}const f=l(t,s,a),_=await this._fetchCandidates(f,g.SELF,n,i);return this._createSnapResult(f,A.MAIN,_,s,{z:r.hasZ()&&t.hasZ?t.z??0:void 0,m:r.hasM()&&t.hasM?t.m??0:void 0},n,i)}async _fetchCandidates(t,e,n,i){return(await Promise.all(this._engines.map((s=>s.fetchCandidates(t,e,n,i))))).flat()}_createSnapResult(t,e,n,s,r,a,o){return{get valid(){return!i(o)},apply:()=>{const{spatialReference:i}=a,{snappedPoint:o,hints:p}=this._processCandidates(t,e,n,a);return this._removeVisualization(),null!=a.visualizer&&this.addHandles(a.visualizer.draw(p,{spatialReference:i,elevationInfo:h,view:s,selfSnappingZ:a.selfSnappingZ}),I),u(o,s,r,a)}}}_processCandidates(t,e,n,i){if(n.length<1)return this.doneSnapping(),{snappedPoint:t,hints:[]};this._currentSnappedType!==e&&this._resetSnappingState(),S(t,n);const s=this._currentMainCandidate;if(null!=s){const r=F(s,n);if(r>=0){if(!(n[r]instanceof P))return this._intersectWithOtherCandidates(r,n,t,e,i);if(this._arePointsWithinScreenThreshold(t,s.targetPoint,i))return this._updateSnappingCandidate(s,e,n,i)}}return this._intersectWithOtherCandidates(0,n,t,e,i)}_intersectWithOtherCandidates(t,e,n,i,s){const{coordinateHelper:r}=s,a=e[t],o=[];for(let p=0;p<e.length;++p){if(p===t)continue;const i=e[p],s=a.constraint.intersect(i.constraint);if(s)for(const t of s.closestPoints(a.targetPoint))o.push([new P(t,a,i,i.isDraped),this._squaredScreenDistance(n,t,r)])}return o.length>0&&(o.sort(((t,e)=>t[1]-e[1])),o[0][1]<this._squaredPointProximityThreshold(s.pointer))?this._updateSnappingCandidate(o[0][0],i,e,s):z(a,s.drawConstraints)?this._updateSnappingCandidate(a,i,e,s):{snappedPoint:n,hints:[]}}_updateSnappingCandidate(t,e,n,i){this.doneSnapping(),this._currentMainCandidate=t,this._currentSnappedType=e;const s=this._currentMainCandidate.targetPoint,r=[];r.push(...t.hints);for(const a of n){if(t instanceof P){if(a.constraint.equals(t.first.constraint)||a.constraint.equals(t.second.constraint))continue}else if(a.constraint.equals(t.constraint))continue;const e=a.constraint.closestTo(s);this._squaredScreenDistance(e,s,i.coordinateHelper)<x()&&(a.targetPoint=s,this._currentOtherActiveCandidates.push(a),r.push(...a.hints))}return{snappedPoint:s,hints:r}}_squaredPointProximityThreshold(t){return"touch"===t?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}_arePointsWithinScreenThreshold(t,e,n){return this._squaredScreenDistance(t,e,n.coordinateHelper)<this._squaredPointProximityThreshold(n.pointer)}_squaredScreenDistance(t,e,n){return v(this._toScreen(t,n),this._toScreen(e,n))}_toScreen(t,e){return R(t,e.spatialReference,h,this.view)}get test(){return{visualizationsActive:this.hasHandles(I),engines:this._engines}}};var A;t([o({constructOnly:!0})],q.prototype,"view",void 0),t([o()],q.prototype,"options",void 0),t([o({readOnly:!0})],q.prototype,"updating",null),t([o()],q.prototype,"snappingEnginesFactory",void 0),t([o()],q.prototype,"_engines",void 0),t([o()],q.prototype,"_squaredMouseProximityThreshold",null),t([o()],q.prototype,"_squaredTouchProximityThreshold",null),q=t([p("esri.views.interactive.snapping.SnappingManager")],q),function(t){t[t.MAIN=0]="MAIN",t[t.SCENE=1]="SCENE"}(A||(A={}));const I="visualization-handle";function x(){return f.satisfiesConstraintScreenThreshold*f.satisfiesConstraintScreenThreshold}function z(t,e){return!e||null==e.direction&&null==e.distance||!(t instanceof y||t instanceof C||t instanceof E||t instanceof w||t instanceof M)&&(!(t instanceof j)||null==e.direction&&t.selfSnappingType===T.LastVertex)}function F(t,e){return t instanceof P?N(e,t.first)>=0&&N(e,t.second)>=0?0:-1:N(e,t)}function N(t,e){let n=-1;for(let i=0;i<t.length;++i)if(e.constraint.equals(t[i].constraint)){n=i;break}return n}function H(t){return null!=t.scenePoint}function O({coordinateHelper:t,elevationInfo:e}){return t.hasZ()?h:e}export{q as SnappingManager};
