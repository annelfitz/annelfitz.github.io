/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{cyclical2PI as e}from"../../../core/Cyclical.js";import{createAngle as t,valueInUnit as r}from"../../../core/quantityUtils.js";import{subtract as i,dot as s,squaredLength as n,scaleAndAdd as o}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{create as a}from"../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{r as c,f as p,s as g}from"../../../chunks/vec32.js";import{create as h}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{absoluteHeightElevationInfo as l}from"../../../support/elevationInfoUtils.js";import{VerticalHalfPlaneConstraint as f}from"../sketch/constraints.js";import{fromAnyMapPoint as d,asVec2 as m,fromValues as u,fromVec3 as x}from"../sketch/normalizedPoint.js";import{SnappingAlgorithm as V}from"./SnappingAlgorithm.js";import{squaredScreenDistance as E}from"./snappingUtils.js";import{SelfSnappingRightAngleType as j,RightAngleSnappingCandidate as v,OtherVertexType as S}from"./candidates/RightAngleSnappingCandidate.js";import{vectorToScreenPoint as k}from"../support/viewUtils.js";import{radiansGeographicBetweenVec as C,pointFromDistanceAlongAzimuth as w}from"../../support/angularMeasurementUtils.js";import{geodesicDistance as y}from"../../support/geodesicLengthMeasurementUtils.js";class F extends V{snapNewVertex(e,t){const r=t.editGeometryOperations.data.components[0],i=[];if(r.vertices.length<2)return i;const{view:s}=this,n=k(e,t.spatialReference,l,s),o=r.vertices.at(-1);this._checkForSnappingCandidate(j.LastVertex,i,o.leftEdge,o,o.leftEdge.leftVertex,e,n,t);const a=r.vertices[0];return this._checkForSnappingCandidate(j.FirstVertex,i,a.rightEdge,a,a.rightEdge.rightVertex,e,n,t),i}snapExistingVertex(e,t){const r=[],i=t.vertexHandle;if(i.component.vertices.length<3)return r;const{view:s}=this,n=k(e,t.spatialReference,l,s),o=i.leftEdge,a=i.rightEdge;if(o?.leftVertex.leftEdge){const i=o.leftVertex.leftEdge;this._checkForSnappingCandidate(j.ExistingEdge,r,i,i.rightVertex,i.leftVertex,e,n,t)}if(a?.rightVertex.rightEdge){const i=a.rightVertex.rightEdge;this._checkForSnappingCandidate(j.ExistingEdge,r,i,i.leftVertex,i.rightVertex,e,n,t)}return r}_checkForSnappingCandidate(e,t,r,i,s,n,o,a){if(!this.edgeExceedsShortLineThreshold(r,a))return;const c=this.view,p=d(i.pos,c,a),g=d(s.pos,c,a);R(M,g,p,n,a),this._checkForSnappingCandidateAlongProjectedRay(e,t,g,p,M,n,o,a)}_checkForSnappingCandidateAlongProjectedRay(e,t,r,a,p,g,d,V){const{spatialReference:j,pointer:C}=V,w=i(U,m(g),m(a)),y=s(p,w)/n(p),F=o(U,m(a),p,y),R=u(F[0],F[1],g[2]);if(E(d,k(R,j,l,this.view))>this.squaredProximityThreshold(C)||this.isVertical(R,a,V)||this.isVertical(a,r,V))return;const _=c(h(),a,p,Math.sign(y));t.push(new v({targetPoint:R,constraint:new f(a,x(_)),previousVertex:r,otherVertex:a,otherVertexType:S.CENTER,selfSnappingType:e,isDraped:"on-the-ground"===V.elevationInfo?.mode}))}}function R(e,t,r,i,s){_(e,t,r,i,s)||P(e,t,r)}function _(i,s,n,o,{spatialReference:a}){const c=C(s,n,a,a);if(null==c)return!1;const g=C(n,o,a,a);if(null==g)return!1;const l=Math.sign(e.shortestSignedDiff(c,g))*Math.PI*.5,f=t(c+l,"radians","geographic"),d=h(),m=y(n,o,a);return null!=m&&(w(d,n,a,r(m,"meters"),f,"geodesic"),p(i,d,n),!0)}function P(e,t,r){const s=i(U,m(r),m(t));g(e,s[1],-s[0],0)}const U=a(),M=h();export{F as RightAngleSnapper};
