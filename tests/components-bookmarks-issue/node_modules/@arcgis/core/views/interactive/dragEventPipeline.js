/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{isSome as t}from"../../core/arrayUtils.js";import"../../core/has.js";import{clone as n}from"../../core/lang.js";import{clamp as e}from"../../core/mathUtils.js";import{createScreenPoint as r}from"../../core/screenUtils.js";import{project as a}from"../../geometry/projection.js";import{isMeshWithRelativeVertexSpace as o}from"../../geometry/support/meshVertexSpaceUtils.js";import{hydratedSpatialReference as l,clonePoint as c}from"../../layers/graphics/hydratedFeatures.js";import{getZForElevationMode as s}from"../../support/elevationInfoUtils.js";import{EditGeometryOperations as u}from"./editGeometry/EditGeometryOperations.js";function i(t,n){let e=null,r=null;return a=>{if("cancel"===a.action)return void(null!=r&&(r.execute({action:"cancel"}),e=null,r=null));const o={action:a.action,screenStart:a.start,screenEnd:a.screenPoint};"start"===a.action&&null==e&&(e=new w,r=new w,n(t,e,r,a.pointerType,o)),null!=e&&e.execute(o),"end"===a.action&&null!=e&&(e=null,r=null)}}function p(t,n){return t.events.on("drag",i(t,n))}function m(t,n){const e=[t.x,t.y,t.z??0],r=n,a=[Math.cos(r),Math.sin(r)],o=Math.sqrt(a[0]*a[0]+a[1]*a[1]);if(0===o)return null;a[0]/=o,a[1]/=o;const l=t=>{const n=(t.x-e[0])*a[0]+(t.y-e[1])*a[1];t.x=e[0]+n*a[0],t.y=e[1]+n*a[1]};return t=>(l(t.mapStart),l(t.mapEnd),{...t,axis:a})}function f(t){let n=null;return e=>{if("start"===e.action&&(n=y(t,e.mapStart.spatialReference)),null==n)return null;const r=e.mapEnd.x-e.mapStart.x,a=e.mapEnd.y-e.mapStart.y,o=(e.mapEnd.z??0)-(e.mapStart.z??0);return n.move(r,a,o,e.action),{...e,translationX:r,translationY:a,translationZ:o}}}function d(t,n){return null==t?null:t.spatialReference.equals(n)?t.clone():a(t,n)}function y(t,n){const e=t.operations;if(!e)return null;const r=e.data.geometry,c=l(n);if(r.spatialReference.equals(c))return x(t,e,(()=>{}));if("mesh"!==r.type){const n=d(r,c);if(null==n)return null;const o=r.spatialReference;return x(t,u.fromGeometry(n,e.viewingMode),(()=>{const t=a(r,o);e.trySetGeometry(t)}))}if(o(r)){const n=d(r.origin,c);if(!n)return null;const o=r.spatialReference,l=u.fromGeometry(n,e.viewingMode);return x(t,e,(()=>{const t=a(l.data.geometry,o),n=t.x-r.origin.x,c=t.y-r.origin.y,s=(t.z??0)-(r.origin.z??0);e.move(n,c,s)}))}return null}function x(t,n,e){let r=0,a=0,o=0;return{move:(l,c,s,u)=>{"start"===u&&(r=0,a=0,o=0);const i=l-r,p=c-a,m=s-o;n.move(i,p,m),r+=i,a+=p,o+=m,e(),"end"===u&&t.endInteraction?.()}}}function E(t,n=null,e){let r=null;const o=null==n||t.spatialReference?.equals(n)?t=>t:t=>null!=t?a(t,n):t,l={exclude:[],...e};return n=>{if("start"===n.action&&(r=o(t.toMap(n.screenStart,l))),null==r)return null;const e=o(t.toMap(n.screenEnd,l));return null!=e?{...n,mapStart:r,mapEnd:e}:null}}function S(n){const e=n.map((t=>f(t))).filter(t);return t=>{const n=t.mapEnd.x-t.mapStart.x,r=t.mapEnd.y-t.mapStart.y,a=t.mapEnd.z-t.mapStart.z;return e.forEach((n=>n(t))),{...t,translationX:n,translationY:r,translationZ:a}}}function h(t,e){const r=new Map;for(const a of e)r.set(a,n(t[a]));return n=>(r.forEach(((n,e)=>{t[e]=n})),n)}function g(t){const n=t.operations?.createResetState();return t=>(n?.remove(),t)}function z(t){const n=t.map((t=>g(t))).filter((t=>null!=t));return t=>(n.forEach((n=>n(t))),t)}function v(){let t=0,n=0,e=0;return r=>{"start"===r.action&&(t=r.mapStart.x,n=r.mapStart.y,e=r.mapStart.z);const a=r.mapEnd.x-t,o=r.mapEnd.y-n,l=r.mapEnd.z-e;return t=r.mapEnd.x,n=r.mapEnd.y,e=r.mapEnd.z,{...r,mapDeltaX:a,mapDeltaY:o,mapDeltaZ:l,mapDeltaSpatialReference:r.mapStart.spatialReference}}}function j(){let t=0,n=0;return e=>{"start"===e.action&&(t=e.screenStart.x,n=e.screenStart.y);const r=e.screenEnd.x-t,a=e.screenEnd.y-n;return t=e.screenEnd.x,n=e.screenEnd.y,{...e,screenDeltaX:r,screenDeltaY:a}}}function M(t,n){let a=null,o=0,l=0;return c=>{if("start"===c.action&&(a=t.toScreen?.(n),null!=a&&(a.x<0||a.x>t.width||a.y<0||a.y>t.height?a=null:(o=c.screenStart.x-a.x,l=c.screenStart.y-a.y))),null==a)return null;const s=e(c.screenEnd.x-o,0,t.width),u=e(c.screenEnd.y-l,0,t.height),i=r(s,u);return c.screenStart=a,c.screenEnd=i,c}}const R=()=>{};class w{constructor(){this.execute=R}next(t,n=new w){return null!=t&&(this.execute=e=>{const r=t(e);null!=r&&n.execute(r)}),n}}function D(t,n,e=[]){if("2d"===t.type)return t=>t;let r=null;return a=>{"start"===a.action&&(r=t.toMap(a.screenStart,{exclude:e}),null!=r&&(r.z=s(r,t,n)));const o=t.toMap(a.screenEnd,{exclude:e});null!=o&&(o.z=s(o,t,n));const l=null!=r&&null!=o?{sceneStart:r,sceneEnd:o}:null;return{...a,scenePoints:l}}}function G(t,n,e){const r=n.elevationProvider.getElevation(t.x,t.y,t.z??0,t.spatialReference,"scene")??0,a=c(t);return a.z=r,a.hasZ=!0,a.z=s(a,n,e),a}function U(t,n){if("2d"===t.type)return t=>t;let e=null;return r=>{"start"===r.action&&(e=G(r.mapStart,t,n));const a=G(r.mapEnd,t,n),o=null!=e&&null!=a?{sceneStart:e,sceneEnd:a}:null;return{...r,scenePoints:o}}}export{w as EventPipeline,v as addMapDelta,j as addScreenDelta,m as constrainToMapAxis,i as createDragEventPipelineCallback,p as createManipulatorDragEventPipeline,M as dragAtLocation,f as dragManipulatedObject,S as dragManipulatedObjectMany,g as resetManipulatedObject,z as resetManipulatedObjectMany,h as resetProperties,D as sceneSnappingAtLocation,U as sceneSnappingAtProjectedLocation,E as screenToMap};
