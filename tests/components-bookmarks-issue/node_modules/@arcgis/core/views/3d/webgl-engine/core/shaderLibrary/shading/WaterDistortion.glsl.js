/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{set as e}from"../../../../../../core/libs/gl-matrix-2/math/vec2.js";import{create as t}from"../../../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{s as r}from"../../../../../../chunks/vec42.js";import{create as a}from"../../../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{FoamIntensity as o}from"./FoamRendering.glsl.js";import{ReadShadowMapPassParameters as m}from"./ReadShadowMap.glsl.js";import{Float2PassUniform as s}from"../../shaderModules/Float2PassUniform.js";import{Float4PassUniform as v}from"../../shaderModules/Float4PassUniform.js";import{glsl as l}from"../../shaderModules/interfaces.js";import{Texture2DPassUniform as i}from"../../shaderModules/Texture2DPassUniform.js";function u(t){t.fragment.uniforms.add(new i("texWaveNormal",(e=>e.waveNormal)),new i("texWavePerturbation",(e=>e.wavePerturbation)),new v("waveParams",(e=>r(c,e.waveStrength,e.waveTextureRepeat,e.flowStrength,e.flowOffset))),new s("waveDirection",(t=>e(n,t.waveDirection[0]*t.waveVelocity,t.waveDirection[1]*t.waveVelocity)))),t.include(o),t.fragment.code.add(l`const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);
vec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture(_tex, _uv).rg - 1.0;
}
float sampleNoiseTexture(vec2 _uv) {
return texture(texWavePerturbation, _uv).b;
}
vec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture(_tex, _uv).rgb - 1.0;
}
float computeProgress(vec2 uv, float time) {
return fract(time);
}
float computeWeight(vec2 uv, float time) {
float progress = computeProgress(uv, time);
return 1.0 - abs(1.0 - 2.0 * progress);
}
vec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {
float flowStrength = waveParams[2];
float flowOffset = waveParams[3];
vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;
float progress = computeProgress(uv, time + phaseOffset);
float weight = computeWeight(uv, time + phaseOffset);
vec2 result = uv;
result -= flowVector * (progress + flowOffset);
result += phaseOffset;
result += (time - progress) * FLOW_JUMP;
return vec3(result, weight);
}
const float TIME_NOISE_TEXTURE_REPEAT = 0.3737;
const float TIME_NOISE_STRENGTH = 7.77;
vec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {
float waveStrength = waveParams[0];
vec2 waveMovement = time * -_waveDir;
float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;
vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);
vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);
vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;
vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;
vec3 mixNormal = normalize(normal_A + normal_B);
mixNormal.xy *= waveStrength;
mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));
return mixNormal;
}
vec4 getSurfaceNormalAndFoam(vec2 _uv, float _time) {
float waveTextureRepeat = waveParams[1];
vec3 normal = getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);
float foam  = normals2FoamIntensity(normal, waveParams[0]);
return vec4(normal, foam);
}`)}class f extends m{}const c=a(),n=t();export{u as WaterDistortion,f as WaterDistortionPassParameters};
