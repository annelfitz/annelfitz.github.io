/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import has from"../../../../core/has.js";import e from"../../../../core/Logger.js";import{clamp as t}from"../../../../core/mathUtils.js";import{createRenderScreenPointArray3 as r}from"../../../../core/screenUtils.js";import{copy as s}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{s as i,f as a,k as n,h as o,g as l,c,l as u,q as h,e as p}from"../../../../chunks/vec32.js";import{create as m}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{ONES as f}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{PlaneIndex as d}from"../../../../geometry/support/frustum.js";import{create as T,distance2 as _,fromPoints as E,closestLineSegmentPoint as A}from"../../../../geometry/support/lineSegment.js";import{create as R,fromPoints as O,signedDistance as I,getNormal as S}from"../../../../geometry/support/plane.js";import{newLayout as g}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as b,isColorAlphaHighlightOIDOrDepth as v,is2DGeometryOutput as P}from"../core/shaderLibrary/ShaderOutput.js";import L from"../lib/GLMaterial.js";import{Material as N,RenderOccludedFlag as C}from"../lib/Material.js";import{RenderSlot as y}from"../lib/RenderSlot.js";import{isTranslationMatrix as j}from"../lib/Util.js";import{VertexAttribute as D}from"../lib/VertexAttribute.js";import{VisualVariablePassParameters as U}from"./VisualVariablePassParameters.js";import{LineMarkerAnchor as F}from"../shaders/LineMarkerTechniqueConfiguration.js";import{r as w}from"../../../../chunks/RibbonLine.glsl.js";import{vertexAttributeLocations as B,RibbonLineTechnique as x}from"../shaders/RibbonLineTechnique.js";import{RibbonLineTechniqueConfiguration as J,CapType as M}from"../shaders/RibbonLineTechniqueConfiguration.js";var G;!function(e){e[e.LEFT_JOIN_START=-2]="LEFT_JOIN_START",e[e.LEFT_JOIN_END=-1]="LEFT_JOIN_END",e[e.LEFT_CAP_START=-4]="LEFT_CAP_START",e[e.LEFT_CAP_END=-5]="LEFT_CAP_END",e[e.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",e[e.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",e[e.RIGHT_CAP_START=4]="RIGHT_CAP_START",e[e.RIGHT_CAP_END=5]="RIGHT_CAP_END"}(G||(G={}));class H extends N{constructor(e){super(e,new k),this._configuration=new J,this.produces=new Map([[y.OPAQUE_MATERIAL,e=>e===b.Highlight||e===b.ObjectAndLayerIdColor||(e===b.Color||e===b.Alpha)&&this.parameters.renderOccluded===C.OccludeAndTransparentStencil],[y.OPAQUE_NO_SSAO_DEPTH,e=>e===b.LinearDepth],[y.OCCLUDER_MATERIAL,e=>v(e)&&this.parameters.renderOccluded===C.OccludeAndTransparentStencil],[y.TRANSPARENT_OCCLUDER_MATERIAL,e=>v(e)&&this.parameters.renderOccluded===C.OccludeAndTransparentStencil],[y.TRANSPARENT_MATERIAL,e=>(e===b.Color||e===b.Alpha)&&this.parameters.writeDepth&&this.parameters.renderOccluded!==C.OccludeAndTransparentStencil],[y.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL,e=>(e===b.Color||e===b.Alpha)&&!this.parameters.writeDepth&&this.parameters.renderOccluded!==C.OccludeAndTransparentStencil],[y.DRAPED_MATERIAL,e=>P(e)]]),this._vertexAttributeLocations=B}getConfiguration(e,t){this._configuration.output=e,this._configuration.draped=t.slot===y.DRAPED_MATERIAL;const r=null!=this.parameters.stipplePattern&&e!==b.Highlight;return this._configuration.stippleEnabled=r,this._configuration.stippleOffColorEnabled=r&&null!=this.parameters.stippleOffColor,this._configuration.stipplePreferContinuous=r&&this.parameters.stipplePreferContinuous,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.roundJoins="round"===this.parameters.join,this._configuration.capType=this.parameters.cap,this._configuration.applyMarkerOffset=null!=this.parameters.markerParameters&&Y(this.parameters.markerParameters),this._configuration.hasPolygonOffset=this.parameters.hasPolygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.vvOpacity=!!this.parameters.vvOpacity,this._configuration.innerColorEnabled=this.parameters.innerWidth>0&&null!=this.parameters.innerColor,this._configuration.falloffEnabled=this.parameters.falloff>0,this._configuration.occluder=this.parameters.renderOccluded===C.OccludeAndTransparentStencil,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration.wireframe=this.parameters.wireframe,this._configuration}intersectDraped(e,r,s,i,a,n){if(!s.options.selectionMode)return;const o=e.attributes.get(D.POSITION).data,l=e.attributes.get(D.SIZE);let c=this.parameters.width;if(this.parameters.vvSize){const r=e.attributes.get(D.SIZEFEATUREATTRIBUTE).data[0];c*=t(this.parameters.vvSize.offset[0]+r*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else l&&(c*=l.data[0]);const u=i[0],h=i[1],p=(c/2+4)*e.screenToWorldRatio;let m=Number.MAX_VALUE,f=0;for(let d=0;d<o.length-5;d+=3){const e=o[d],r=o[d+1],s=u-e,i=h-r,a=o[d+3]-e,n=o[d+4]-r,l=t((a*s+n*i)/(a*a+n*n),0,1),c=a*l-s,p=n*l-i,T=c*c+p*p;T<m&&(m=T,f=d/3)}m<p*p&&a(n.dist,n.normal,f,!1)}intersect(r,p,m,f,T,R){if(!m.options.selectionMode||!r.visible)return;if(!j(p))return void e.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");const g=r.attributes,b=g.get(D.POSITION).data;let v=this.parameters.width;if(this.parameters.vvSize){const e=g.get(D.SIZEFEATUREATTRIBUTE).data[0];v*=t(this.parameters.vvSize.offset[0]+e*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else g.has(D.SIZE)&&(v*=g.get(D.SIZE).data[0]);const P=m.camera,L=$;s(L,m.point);const N=v*P.pixelRatio/2+4*P.pixelRatio;i(ce[0],L[0]-N,L[1]+N,0),i(ce[1],L[0]+N,L[1]+N,0),i(ce[2],L[0]+N,L[1]-N,0),i(ce[3],L[0]-N,L[1]-N,0);for(let e=0;e<4;e++)if(!P.unprojectFromRenderScreen(ce[e],ue[e]))return;O(P.eye,ue[0],ue[1],he),O(P.eye,ue[1],ue[2],pe),O(P.eye,ue[2],ue[3],me),O(P.eye,ue[3],ue[0],fe);let C=Number.MAX_VALUE,y=0;const U=W(this.parameters,g)?b.length-2:b.length-5;for(let e=0;e<U;e+=3){q[0]=b[e]+p[12],q[1]=b[e+1]+p[13],q[2]=b[e+2]+p[14];const t=(e+3)%b.length;if(X[0]=b[t]+p[12],X[1]=b[t+1]+p[13],X[2]=b[t+2]+p[14],I(he,q)<0&&I(he,X)<0||I(pe,q)<0&&I(pe,X)<0||I(me,q)<0&&I(me,X)<0||I(fe,q)<0&&I(fe,X)<0)continue;if(P.projectToRenderScreen(q,ee),P.projectToRenderScreen(X,te),ee[2]<0&&te[2]>0){a(Q,q,X);const e=P.frustum,t=-I(e[d.NEAR],q)/n(Q,S(e[d.NEAR]));o(Q,Q,t),l(q,q,Q),P.projectToRenderScreen(q,ee)}else if(ee[2]>0&&te[2]<0){a(Q,X,q);const e=P.frustum,t=-I(e[d.NEAR],X)/n(Q,S(e[d.NEAR]));o(Q,Q,t),l(X,X,Q),P.projectToRenderScreen(X,te)}else if(ee[2]<0&&te[2]<0)continue;ee[2]=0,te[2]=0;const r=_(E(ee,te,ie),L);r<C&&(C=r,c(re,q),c(se,X),y=e/3)}const F=m.rayBegin,w=m.rayEnd;if(C<N*N){let e=Number.MAX_VALUE;if(A(E(re,se,ie),E(F,w,ae),K)){a(K,K,F);const t=u(K);o(K,K,1/t),e=t/h(F,w)}R(e,K,y,!1)}}get _layout(){const e=g().vec3f(D.POSITION).vec3f(D.PREVPOSITION).vec3f(D.NEXTPOSITION).f32(D.SUBDIVISIONFACTOR).vec2f(D.UV0);return this.parameters.vvSize?e.f32(D.SIZEFEATUREATTRIBUTE):e.f32(D.SIZE),this.parameters.vvColor?e.f32(D.COLORFEATUREATTRIBUTE):e.vec4f(D.COLOR),this.parameters.vvOpacity&&e.f32(D.OPACITYFEATUREATTRIBUTE),has("enable-feature:objectAndLayerId-rendering")&&e.vec4u8(D.OBJECTANDLAYERIDCOLOR),e}createBufferWriter(){return new V(this._layout,this.parameters)}createGLMaterial(e){return new z(e)}validateParameters(e){"miter"!==e.join&&(e.miterLimit=0),null!=e.markerParameters&&(e.markerScale=e.markerParameters.width/e.width)}}class z extends L{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){this._output!==b.Color&&this._output!==b.Alpha||this._updateOccludeeState(e);const t=this._material.parameters.stipplePattern;return this._stipplePattern!==t&&(this._material.setParameters({stippleTexture:this._stippleTextureRepository.swap(t,this._stipplePattern)}),this._stipplePattern=t),this.ensureTechnique(x,e)}}class k extends U{constructor(){super(...arguments),this.width=0,this.color=f,this.join="miter",this.cap=M.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleTexture=null,this.stipplePreferContinuous=!0,this.markerParameters=null,this.markerScale=1,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}}class V{constructor(e,t){this.vertexBufferLayout=e,this._parameters=t,this.numJoinSubdivisions=0;const r=t.stipplePattern?1:0;switch(this._parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=r;break;case"round":this.numJoinSubdivisions=w+r}}_isClosed(e){return W(this._parameters,e.attributes)}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const t=2,r=e.attributes.get(D.POSITION).indices.length/2+1,s=this._isClosed(e);let i=s?2:2*t;return i+=((s?r:r-1)-(s?0:1))*(2*this.numJoinSubdivisions+4),i+=2,this._parameters.wireframe&&(i=2+4*(i-2)),i}write(e,t,r,s,a){const n=ne,o=oe,l=le,u=r.attributes.get(D.POSITION),m=u.indices,f=u.data.length/3,d=r.attributes.get(D.DISTANCETOSTART)?.data;m&&m.length!==2*(f-1)&&console.warn("RibbonLineMaterial does not support indices");const T=r.attributes.get(D.SIZEFEATUREATTRIBUTE)?.data[0]??r.attributes.get(D.SIZE)?.data[0]??1;let _=[1,1,1,1],E=0;const A=this.vertexBufferLayout.fields.has(D.COLORFEATUREATTRIBUTE);A?E=r.attributes.get(D.COLORFEATUREATTRIBUTE).data[0]:r.attributes.has(D.COLOR)&&(_=r.attributes.get(D.COLOR).data);const R=has("enable-feature:objectAndLayerId-rendering")?r.objectAndLayerIdColor:null,O=this.vertexBufferLayout.fields.has(D.OPACITYFEATUREATTRIBUTE),I=O?r.attributes.get(D.OPACITYFEATUREATTRIBUTE).data[0]:0,S=new Float32Array(s.buffer),g=has("enable-feature:objectAndLayerId-rendering")?new Uint8Array(s.buffer):null,b=this.vertexBufferLayout.stride/4;let v=a*b;const P=v;let L=0;const N=d?(e,t,r)=>L=d[r]:(e,t,r)=>L+=h(e,t),C=has("enable-feature:objectAndLayerId-rendering"),y=(e,t,r,s,i,a,n)=>{if(S[v++]=t[0],S[v++]=t[1],S[v++]=t[2],S[v++]=e[0],S[v++]=e[1],S[v++]=e[2],S[v++]=r[0],S[v++]=r[1],S[v++]=r[2],S[v++]=s,S[v++]=n,S[v++]=i,S[v++]=T,A)S[v++]=E;else{const e=Math.min(4*a,_.length-4);S[v++]=_[e],S[v++]=_[e+1],S[v++]=_[e+2],S[v++]=_[e+3]}O&&(S[v++]=I),C&&(null!=R&&(g[4*v]=R[0],g[4*v+1]=R[1],g[4*v+2]=R[2],g[4*v+3]=R[3]),v++)};v+=b,i(o,u.data[0],u.data[1],u.data[2]),e&&p(o,o,e);const j=this._isClosed(r);if(j){const t=u.data.length-3;i(n,u.data[t],u.data[t+1],u.data[t+2]),e&&p(n,n,e)}else i(l,u.data[3],u.data[4],u.data[5]),e&&p(l,l,e),y(o,o,l,1,G.LEFT_CAP_START,0,0),y(o,o,l,1,G.RIGHT_CAP_START,0,0),c(n,o),c(o,l);const U=j?0:1,F=j?f:f-1;for(let h=U;h<F;h++){const t=(h+1)%f*3;i(l,u.data[t],u.data[t+1],u.data[t+2]),e&&p(l,l,e),N(n,o,h),y(n,o,l,0,G.LEFT_JOIN_END,h,L),y(n,o,l,0,G.RIGHT_JOIN_END,h,L);const r=this.numJoinSubdivisions;for(let e=0;e<r;++e){const t=(e+1)/(r+1);y(n,o,l,t,G.LEFT_JOIN_END,h,L),y(n,o,l,t,G.RIGHT_JOIN_END,h,L)}y(n,o,l,1,G.LEFT_JOIN_START,h,L),y(n,o,l,1,G.RIGHT_JOIN_START,h,L),c(n,o),c(o,l)}j?(i(l,u.data[3],u.data[4],u.data[5]),e&&p(l,l,e),L=N(n,o,F),y(n,o,l,0,G.LEFT_JOIN_END,U,L),y(n,o,l,0,G.RIGHT_JOIN_END,U,L)):(L=N(n,o,F),y(n,o,o,0,G.LEFT_CAP_END,F,L),y(n,o,o,0,G.RIGHT_CAP_END,F,L)),Z(S,P+b,S,P,b);v=Z(S,v-b,S,v,b),this._parameters.wireframe&&this._addWireframeVertices(s,P,v,b)}_addWireframeVertices(e,t,r,s){const i=new Float32Array(e.buffer,r*Float32Array.BYTES_PER_ELEMENT),a=new Float32Array(e.buffer,t*Float32Array.BYTES_PER_ELEMENT,r-t);let n=0;const o=e=>n=Z(a,e,i,n,s);for(let l=0;l<a.length-1;l+=2*s)o(l),o(l+2*s),o(l+1*s),o(l+2*s),o(l+1*s),o(l+3*s)}}function Z(e,t,r,s,i){for(let a=0;a<i;a++)r[s++]=e[t++];return s}function W(e,t){if(!e.isClosed)return!1;return t.get(D.POSITION).indices.length>2}function Y(e){return e.anchor===F.Tip&&e.hideOnShortSegments&&"begin-end"===e.placement&&e.worldSpace}const q=m(),X=m(),Q=m(),K=m(),$=m(),ee=r(),te=r(),re=m(),se=m(),ie=T(),ae=T(),ne=m(),oe=m(),le=m(),ce=[r(),r(),r(),r()],ue=[m(),m(),m(),m()],he=R(),pe=R(),me=R(),fe=R();export{k as Parameters,H as RibbonLineMaterial};
