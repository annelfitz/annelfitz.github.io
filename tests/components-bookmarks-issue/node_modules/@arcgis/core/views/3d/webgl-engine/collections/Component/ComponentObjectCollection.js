/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import has from"../../../../../core/has.js";import e from"../../../../../core/Logger.js";import t from"../../../../../core/PooledArray.js";import{isArray as o}from"../../../../../core/typedArrayUtil.js";import{a as n}from"../../../../../chunks/vec32.js";import{clone as i}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{create as r}from"../../../../../geometry/support/aaBoundingBox.js";import{compactIndices as s}from"../../../../../geometry/support/Indices.js";import{c as a}from"../../../../../chunks/vec3.js";import{c as l}from"../../../../../chunks/vec33.js";import{ViewingMode as c}from"../../../../ViewingMode.js";import{ColorMixModeEnum as m,encodeSymbolColor as h}from"../../../layers/support/symbolColorUtils.js";import{computeOffsetObb as f}from"../../../support/orientedBoundingBox.js";import{glLayout as p}from"../../../support/buffer/glUtil.js";import{newLayout as u}from"../../../support/buffer/InterleavedLayout.js";import d from"./ComponentData.js";import{ComponentObject as g}from"./ComponentObject.js";import b from"./IntersectionGeometry.js";import{Renderable as y}from"./Renderable.js";import{RenderGeometry as v}from"./RenderGeometry.js";import{RenderSubmitSystem as C}from"./RenderSubmitSystem.js";import{createVertexBufferLayout as _}from"./SourceGeometry.js";import{UniformComponentParameters as j}from"./UniformComponentParameters.js";import{ComponentParametersVarying as M,ComponentParametersUniform as x,ComponentParameterSummary as O,ComponentMaterial as w}from"./Material/ComponentMaterial.js";import{attributeLocations as A}from"./Material/ComponentTechnique.js";import{encodeElevationOffset as R}from"./Material/shader/ComponentData.glsl.js";import{getVisibility as D,updateVisibilityWithCount as I}from"../../lib/ComponentUtils.js";import{assert as S}from"../../lib/Util.js";import{VertexAttribute as E}from"../../lib/VertexAttribute.js";import{getVerticalOffsetI3S as V}from"../../lib/verticalOffsetUtils.js";import{EdgeInputBufferLayout as P}from"../../lib/edgeRendering/bufferLayouts.js";import{extractComponentsEdgeLocationsLayout as B}from"../../lib/edgeRendering/edgeProcessing.js";import{BufferManager as N}from"../../lib/TextureBackedBuffer/BufferManager.js";import{BufferObject as U}from"../../../../webgl/BufferObject.js";import{Usage as T,PrimitiveType as L}from"../../../../webgl/enums.js";import{VertexArrayObject as G}from"../../../../webgl/VertexArrayObject.js";const k=()=>e.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");class q{constructor(e,o){this._renderManager=e,this._viewingMode=o,this._elevationRangeCacheVerticalOffset=NaN,this._elevationRangeCacheMin=NaN,this._elevationRangeCacheMax=NaN,this._visible=new t,this._hidden=new t,this._renderSubmit=new C(this),this._renderManager.register(this._renderSubmit),this._hasObjectAndLayerId=has("enable-feature:objectAndLayerId-rendering"),this._componentBufferManager=new N(e.rctx,2+(this._hasObjectAndLayerId?1:0))}destroy(){S(0===this._hidden.length&&0===this._visible.length,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy(),this._visible.forAll((e=>e.destroy())),this._hidden.forAll((e=>e.destroy())),this._visible.clear(),this._hidden.clear()}createObject(e){const t=e.geometry,o=new d(this._componentBufferManager,s(t.componentOffsets)),n=this._createRenderable(e,o),i=new b(this._viewingMode,t.positionData,o),r=new g(e.transform,e.toMapSpace,e.obb.clone(),o,n,i);return(r.visible?this._visible:this._hidden).push(r),r}destroyObject(e){const t=e;(t.visible?this._visible:this._hidden).removeUnordered(t),t.destroy(),this._notifyDirty()}setObjectVisibility(e,t){const o=e;t!==o.visible&&(t?(this._hidden.removeUnordered(o),this._visible.push(o)):(this._visible.removeUnordered(o),this._hidden.push(o)),o.visible=t,this._notifyDirty())}preSubmit(e){const t=e.camera.eye;this.visibleObjects.forAll((e=>e.renderable.meta.cameraDepthSquared=n(t,e.obb.center)))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const o=e.renderable.material;t(o),o.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const o=e;o.components.visibility.reset(t),o.components.visibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.components.visibility.forEachComponent(t)}getComponentCount(e){const t=e,o=t.components.visibility.componentCount;return{visible:o,invisible:t.components.count-o}}setComponentData(e,t){const o=e,n=o.renderable.material,i=o.components,r=i.materialDataBuffer,s=i.materialDataIndices,a=new j,l=r.textureBuffer,c=new Uint8Array(4),p=new Uint32Array(c.buffer);let u=0,d=0,g=0,b=i.verticalOffsets,y=1/0,v=-1/0,C=!1,_=!1,w=0;for(let f=0;f<i.count;f++){t(f,a),u+=+(a.externalColor[3]<1),d+=+(a.externalColorMixMode===m.Replace&&1===a.externalColor[3]),g+=+a.castShadows,h(a.externalColor,a.externalColorMixMode,c),c[2]=254&c[2]|+a.castShadows,l.setData(s[f],0,c[0],c[1],c[2],c[3]),C||=f>0&&w!==p[0],w=p[0],_||=0!==a.elevationOffset,_&&null==b&&(b=new Array(f).fill(0)),null!=b&&(b[f]=a.elevationOffset),y=Math.min(y,a.elevationOffset),v=Math.max(v,a.elevationOffset),R(a.elevationOffset,c),l.setData(s[f],1,c[0],c[1],c[2],c[3]);const e=a.objectAndLayerIdColor;null!=e&&l.setData(s[f],2,e[0],e[1],e[2],e[3]),a.pickable!==D(i.pickability,f)&&(i.pickability=I(i.pickability,i.count,f,a.pickable))}i.verticalOffsets=_?b:null,o.offsetObb=_?f(o.obb,y,v,this._viewingMode,o.offsetObb??o.obb.clone()):null,C||_||this._hasObjectAndLayerId?(n.componentParameters=new M,n.componentParameters.castShadows=H(g,i.count),n.componentParameters.transparent=H(u,i.count),n.componentParameters.opaqueOverride=H(d,i.count),n.componentParameters.texture=l,l.updateTexture()):(n.componentParameters=new x,n.componentParameters.castShadows=a.castShadows?O.All:O.None,n.componentParameters.externalColor=a.externalColor,n.componentParameters.externalColorMixMode=a.externalColorMixMode),this._elevationRangeCacheVerticalOffset=NaN,this._notifyDirty()}getComponentAabb(e,t,o,n=!1){e.intersectionGeometry.getComponentAabb(t,o);const i=e,r=i.components.verticalOffsets;if(n||null==r)return o;const s=r[t];if(this._viewingMode===c.Local||0===s)return o[2]+=s,o[5]+=s,o;const a=V(s);return a.localOrigin=i.transform.position,a.applyToAabb(o)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,o){return e.intersectionGeometry.getComponentPositions(t,o)}expandRangeWithComponentObjectElevationRange(e,t,o,n){Number.isNaN(this._elevationRangeCacheVerticalOffset)||this._elevationRangeCacheVerticalOffset!==t||n.expandElevationRangeValues(this._elevationRangeCacheMin,this._elevationRangeCacheMax);const i=e,r=i.components,s=r.count,a=r.verticalOffsets,l=i.intersectionGeometry,m=this._viewingMode===c.Local,h=l.getComponentAabbs(),f=X;let p=1/0,u=-1/0;for(let c=0;c<s;c++){const e=6*c,r=a?.[c]??0;let s=1/0,l=-1/0;if(m)s=h[e+2]+r+t,l=h[e+5]+r+t;else{if(f[0]=h[e],f[1]=h[e+1],f[2]=h[e+2],f[3]=h[e+3],f[4]=h[e+4],f[5]=h[e+5],0!==r){const e=V(r);e.localOrigin=i.transform.position,e.applyToAabb(f)}const s=Math.max(Math.abs(f[3]),Math.abs(f[0])),a=Math.max(Math.abs(f[4]),Math.abs(f[1])),l=t+f[5]+o;n.expandElevationRangeValues(t+f[2],Math.sqrt(s*s+a*a+l*l)-o)}n.expandElevationRangeValues(s,l),p=Math.min(p,s),u=Math.max(u,l)}this._elevationRangeCacheVerticalOffset=t,this._elevationRangeCacheMin=p,this._elevationRangeCacheMax=u}intersect(e,t,o,n,i,r,s){const a=e,{transform:l}=a,{position:c}=l;return null!=i&&(i.localOrigin=c),a.intersectionGeometry.intersect(t,o,n,i,a.components.verticalOffsets,l,r,s)}addEdges(e,t,o,n){const i=e,{indices:r,positions:s}=i.intersectionGeometry,a=i.components.offsets;return t.addComponentObject(i,s,r,a,o,n)}async extractEdgeInformation(e,t,o){const n=e,r=n.components.visibility;if(r.allInvisible())return{buffer:B.createBuffer(0),origin:[0,0,0]};const{indices:s,positions:c}=n.intersectionGeometry,m=n.components.offsets,h=P.createBuffer(c.length/3);l(h.position.typedBuffer,c,h.position.typedBufferStride,3),a(h.position,h.position,n.transform.rotationScale),this._setComponentIndices(h.componentIndex,s,m);const f=h.count,p=this._computeVisibilityIndices(s,r,m,f);return{origin:i(n.transform.position),buffer:await t.extractComponentsEdgeLocations({indices:p,indicesLength:p.length,skipDeduplicate:!0,data:h,writerSettings:{reducedPrecision:!1,variants:0}},o)}}_setComponentIndices(e,t,o){let n=0;for(let i=0;i<o.length-1;i++){const r=o[i],s=o[i+1];for(let o=r;o<s;o++){const i=t?t[o]:o;e.set(i,n)}n++}}_computeVisibilityIndices(e,t,n,i){if(e&&t.allVisible())return e;let r=0;t.forEachComponentRange(((e,t)=>(r+=n[t]-n[e],!0)));const s=o(e)?new Array(r):2===e?.BYTES_PER_ELEMENT||i<=65536?new Uint16Array(r):new Uint32Array(r);let a=0;return t.forEachComponentRange(((t,o)=>{const i=n[t],r=n[o];for(let n=i;n<r;n++)s[a++]=e?e[n]:n;return!0})),s}addComponentHighlight(e,t){const o=e.components;null==o.highlightCounts&&(o.highlightCounts=new Uint32Array(o.count+1));0===o.highlightCounts[t]++&&(o.highlightsDirty(),this._notifyDirty()),o.highlightCounts[o.count]++}removeComponentHighlight(e,t){const o=e.components;if(null==o.highlightCounts)return void k().warn("Removing non-existing highlight.");const n=o.highlightCounts[t],i=o.highlightCounts[o.count];if(0!==n){if(n>1)return o.highlightCounts[t]=n-1,void(o.highlightCounts[o.count]=i-1);o.highlightCounts[t]=0,o.highlightsDirty(),this._notifyDirty(),1===i?o.highlightCounts=null:o.highlightCounts[o.count]=i-1}else k().warn("Removing non-existing highlight.")}clearHighlights(e){const t=e.components;null!=t.highlightCounts&&(t.highlightCounts=null,t.highlightsDirty(),this._notifyDirty())}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._visible}_createRenderable(e,t){const o=this._renderManager.rctx,n=e.geometry,i=n.vertices.layoutParameters,r=U.createVertex(o,T.STATIC_DRAW,n.vertices.data),s=n.indices?U.createIndex(o,T.STATIC_DRAW,n.indices):null,a=p(_(i)),l=new Uint16Array(n.vertices.count);for(let p=0;p<t.count;p++){const e=t.offsets[p],o=t.offsets[p+1],i=t.materialDataIndices[p];if(null!=n.indices)for(let t=e;t<o;t++){l[n.indices[t]]=i}else for(let t=e;t<o;t++)l[t]=i}const c=U.createVertex(o,T.STATIC_DRAW,l.buffer),m=new w(e.transform,e.toMapSpace),h=new G(o,A,{data:a,componentIndices:W},{data:r,componentIndices:c},s),f=new v(h,L.TRIANGLES,i,null!=s),u={cameraDepthSquared:.5,gpuMemoryEstimate:r.usedMemory+c.usedMemory+(null!=s?s.usedMemory:0)};return new y(m,f,u)}_notifyDirty(){this._renderManager.notifyDirty()}}const W=p(u().u16(E.COMPONENTINDEX));function H(e,t){return e===t?O.All:0===e?O.None:O.Some}const X=r();export{q as ComponentObjectCollection};
