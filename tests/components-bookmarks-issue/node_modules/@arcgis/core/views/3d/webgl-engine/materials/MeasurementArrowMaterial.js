/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{s as t,n as e,f as r,b as s,q as o,e as i}from"../../../../chunks/vec32.js";import{create as n}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{fromValues as a}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{newLayout as c}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as l}from"../core/shaderLibrary/ShaderOutput.js";import u from"../lib/GLMaterial.js";import{Material as p,MaterialParameters as f}from"../lib/Material.js";import{RenderSlot as h}from"../lib/RenderSlot.js";import{VertexAttribute as m}from"../lib/VertexAttribute.js";import{MeasurementArrowAttributeLocations as g,MeasurementArrowTechniqueConfiguration as d,MeasurementArrowTechnique as b}from"../shaders/MeasurementArrowTechnique.js";class A extends p{constructor(t){super(t,new _),this._vertexAttributeLocations=g,this.produces=new Map([[h.OPAQUE_MATERIAL,t=>!this._transparent&&(t===l.Color||t===l.Alpha)],[h.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL,t=>this._transparent&&(t===l.Color||t===l.Alpha)]]),this._configuration=new d}getConfiguration(t,e){return this._configuration.polygonOffsetEnabled=this.parameters.polygonOffset,this._configuration.transparent=this._transparent,this._configuration.transparencyPassType=e.transparencyPassType,this._configuration}intersect(){}createGLMaterial(t){return new O(t)}createBufferWriter(){return new j}get _transparent(){const{parameters:t}=this;return t.outlineColor[3]<1||t.stripeEvenColor[3]<1||t.stripeOddColor[3]<1}}class O extends u{beginSlot(t){return this.ensureTechnique(b,t)}}class _ extends f{constructor(){super(...arguments),this.width=32,this.outlineSize=.2,this.outlineColor=a(1,.5,0,1),this.stripeEvenColor=a(1,1,1,1),this.stripeOddColor=a(1,.5,0,1),this.stripeLength=1,this.polygonOffset=!1}}const T=c().vec3f(m.POSITION).vec3f(m.NORMAL).vec2f(m.UV0).f32(m.LENGTH),L=n(),v=n(),E=n(),I=n(),M=n();class j{constructor(){this.vertexBufferLayout=T}elementCount(t){return 2*(t.attributes.get(m.POSITION).indices.length/2+1)}write(n,a,c,l,u){const{data:p,indices:f}=c.attributes.get(m.POSITION),h=c.attributes.get(m.NORMAL).data,g=p.length/3;f&&f.length!==2*(g-1)&&console.warn("MeasurementArrowMaterial does not support indices");const d=L,b=v,A=E,O=I,_=M,T=l.position,j=l.normal,w=l.uv0;let y=0;for(let m=0;m<g;++m){const c=3*m;if(t(d,p[c],p[c+1],p[c+2]),m<g-1){const o=3*(m+1);t(b,p[o],p[o+1],p[o+2]),t(_,h[o],h[o+1],h[o+2]),e(_,_),r(A,b,d),e(A,A),s(O,_,A),e(O,O)}const l=o(d,b);n&&a&&(i(d,d,n),i(b,b,n),i(O,O,a));const f=u+2*m,L=f+1;T.setVec(f,d),T.setVec(L,d),j.setVec(f,O),j.setVec(L,O),w.set(f,0,y),w.set(f,1,-1),w.set(L,0,y),w.set(L,1,1),m<g-1&&(y+=l)}const C=l.length;for(let t=0;t<2*g;++t)C.set(u+t,y)}}export{A as MeasurementArrowMaterial,_ as Parameters};
