/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{IDENTITY as e}from"../../../../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{ONES as t}from"../../../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{TextureCoordinateAttributeType as r}from"../attributes/TextureCoordinateAttribute.glsl.js";import{VertexTextureCoordinates as a}from"../attributes/VertexTextureCoordinates.glsl.js";import{NormalsDoubleSidedMode as n}from"./Normals.glsl.js";import{Float2PassUniform as o}from"../../shaderModules/Float2PassUniform.js";import{glsl as s}from"../../shaderModules/interfaces.js";import{Matrix3PassUniform as m}from"../../shaderModules/Matrix3PassUniform.js";import{Texture2DDrawUniform as d}from"../../shaderModules/Texture2DDrawUniform.js";import{Texture2DPassUniform as l}from"../../shaderModules/Texture2DPassUniform.js";import{BindType as i}from"../../shaderTechnique/BindType.js";import{VertexAttribute as c}from"../../../lib/VertexAttribute.js";function T(T,u){const x=T.fragment;u.hasVertexTangents?(T.attributes.add(c.TANGENT,"vec4"),T.varyings.add("vTangent","vec4"),u.doubleSidedMode===n.WindingOrder?x.code.add(s`mat3 computeTangentSpace(vec3 normal) {
float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;
vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);
vec3 bitangent = cross(normal, tangent) * tangentHeadedness;
return mat3(tangent, bitangent, normal);
}`):x.code.add(s`mat3 computeTangentSpace(vec3 normal) {
float tangentHeadedness = vTangent.w;
vec3 tangent = normalize(vTangent.xyz);
vec3 bitangent = cross(normal, tangent) * tangentHeadedness;
return mat3(tangent, bitangent, normal);
}`)):x.code.add(s`mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {
vec3 Q1 = dFdx(pos);
vec3 Q2 = dFdy(pos);
vec2 stx = dFdx(st);
vec2 sty = dFdy(st);
float det = stx.t * sty.s - sty.t * stx.s;
vec3 T = stx.t * Q2 - sty.t * Q1;
T = T - normal * dot(normal, T);
T *= inversesqrt(max(dot(T,T), 1.e-10));
vec3 B = sign(det) * cross(normal, T);
return mat3(T, B, normal);
}`),u.textureCoordinateType!==r.None&&(T.include(a,u),x.uniforms.add(u.pbrTextureBindType===i.Pass?new l("normalTexture",(e=>e.textureNormal)):new d("normalTexture",(e=>e.textureNormal))),u.hasNormalTextureTransform&&(x.uniforms.add(new o("scale",(e=>e.scale??t))),x.uniforms.add(new m("normalTextureTransformMatrix",(t=>t.normalTextureTransformMatrix??e)))),x.code.add(s`vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {
vec3 rawNormal = textureLookup(normalTexture, uv).rgb * 2.0 - 1.0;`),u.hasNormalTextureTransform&&x.code.add(s`mat3 normalTextureRotation = mat3(normalTextureTransformMatrix[0][0]/scale[0], normalTextureTransformMatrix[0][1]/scale[1], 0.0,
normalTextureTransformMatrix[1][0]/scale[0], normalTextureTransformMatrix[1][1]/scale[1], 0.0,
0.0, 0.0, 0.0 );
rawNormal.xy = (normalTextureRotation * vec3(rawNormal.x, rawNormal.y, 1.0)).xy;`),x.code.add(s`return tangentSpace * rawNormal;
}`))}export{T as ComputeNormalTexture};
