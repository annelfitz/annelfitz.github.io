/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{RgbaFloatEncoding as e}from"../util/RgbaFloatEncoding.glsl.js";import{addCameraPosition as t,addPixelRatio as o}from"../util/View.glsl.js";import{Float4PassUniform as i}from"../../shaderModules/Float4PassUniform.js";import{FloatPassUniform as r}from"../../shaderModules/FloatPassUniform.js";import{glsl as l}from"../../shaderModules/interfaces.js";import{Texture2DPassUniform as a}from"../../shaderModules/Texture2DPassUniform.js";import{computeLongestPattern as p,computeTextureSize as n}from"../../../materials/stippleTextureRepository.js";import{ensureColor4 as s}from"../../../shaders/ensureColor4.js";function d(e,t){e.constants.add("stippleAlphaColorDiscard","float",.001),e.constants.add("stippleAlphaHighlightDiscard","float",.5),t.stippleEnabled?c(e,t):f(e)}function c(p,n){const d=!(n.draped&&n.stipplePreferContinuous),{vertex:c,fragment:f}=p;f.include(e),n.draped||(t(c,n),c.uniforms.add(new r("worldToScreenPerDistanceRatio",((e,t)=>1/t.camera.perScreenPixelRatio))),c.code.add(l`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)),p.varyings.add("vStippleDistance","float"),p.varyings.add("vStippleDistanceLimits","vec2"),p.varyings.add("vStipplePatternStretch","float"),c.code.add(l`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${u};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `),c.code.add(l`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`),c.code.add(l`
    if (segmentLengthPseudoScreen >= ${d?"patternLength":"1e4"}) {
  `),o(c),c.code.add(l`float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
float segmentLengthScreenRounded = flooredRepetitions * patternLength;
float stretch = repetitions / flooredRepetitions;
vStipplePatternStretch = max(0.75, stretch);
return vec2(0.0, segmentLengthScreenRounded);
}
return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
}`),f.uniforms.add(new a("stipplePatternTexture",(e=>e.stippleTexture)),new r("stipplePatternSDFNormalizer",(e=>m(e.stipplePattern))),new r("stipplePatternPixelSizeInv",(e=>1/S(e)))),f.code.add(l`float getStippleSDF(out bool isClamped) {
float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;
float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv * vLineSizeInv;
u = fract(u);
float encodedSDF = rgba2float(texture(stipplePatternTexture, vec2(u, 0.5)));
float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;
return (sdf - 0.5) * vStipplePatternStretch + 0.5;
}
float getStippleSDF() {
bool ignored;
return getStippleSDF(ignored);
}
float getStippleAlpha() {
bool isClamped;
float stippleSDF = getStippleSDF(isClamped);
float antiAliasedResult = clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);
return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
}`),n.stippleOffColorEnabled?(f.uniforms.add(new i("stippleOffColor",(e=>s(e.stippleOffColor)))),f.code.add(l`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)):f.code.add(l`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)}function f(e){e.fragment.code.add(l`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`)}function m(e){return e?(Math.floor(.5*(p(e)-1))+.5)/e.pixelRatio:1}function S(e){const t=e.stipplePattern;return t?n(e.stipplePattern)/t.pixelRatio:1}const u=l.float(.4);export{d as LineStipple,S as computePixelSize};
