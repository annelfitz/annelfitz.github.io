/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{hasIdentityRotation as e,isOrthoNormal as t}from"../../../../../core/libs/gl-matrix-2/math/mat4.js";import{BufferViewVec4u8 as f,BufferViewVec4f as o,BufferViewFloat as r,BufferViewVec2f as i,BufferViewVec2i16 as s,BufferViewVec3f as n}from"../../../../../geometry/support/buffer/BufferView.js";import{assert as c}from"../../lib/Util.js";import{VertexAttribute as l}from"../../lib/VertexAttribute.js";function d(e,t,f,o=1){const{data:r,indices:i}=e,s=t.typedBuffer,n=t.typedBufferStride,c=i.length;if(f*=n,1===o)for(let l=0;l<c;++l)s[f]=r[i[l]],f+=n;else for(let l=0;l<c;++l){const e=r[i[l]];for(let t=0;t<o;t++)s[f]=e,f+=n}}function u(e,t,f){const{data:o,indices:r}=e,i=t.typedBuffer,s=t.typedBufferStride,n=r.length;f*=s;for(let c=0;c<n;++c){const e=2*r[c];i[f]=o[e],i[f+1]=o[e+1],f+=s}}function a(e,t,f,o){const{data:r,indices:i}=e,s=t.typedBuffer,n=t.typedBufferStride,c=i.length;if(f*=n,null==o||1===o)for(let l=0;l<c;++l){const e=3*i[l];s[f]=r[e],s[f+1]=r[e+1],s[f+2]=r[e+2],f+=n}else for(let l=0;l<c;++l){const e=3*i[l];for(let t=0;t<o;++t)s[f]=r[e],s[f+1]=r[e+1],s[f+2]=r[e+2],f+=n}}function p(e,t,f,o=1){const{data:r,indices:i}=e,s=t.typedBuffer,n=t.typedBufferStride,c=i.length;if(f*=n,1===o)for(let l=0;l<c;++l){const e=4*i[l];s[f]=r[e],s[f+1]=r[e+1],s[f+2]=r[e+2],s[f+3]=r[e+3],f+=n}else for(let l=0;l<c;++l){const e=4*i[l];for(let t=0;t<o;++t)s[f]=r[e],s[f+1]=r[e+1],s[f+2]=r[e+2],s[f+3]=r[e+3],f+=n}}function y(e,t,f){const o=e.typedBuffer,r=e.typedBufferStride;t*=r;for(let i=0;i<f;++i)o[t]=0,o[t+1]=0,o[t+2]=0,o[t+3]=0,t+=r}function B(e,t,f){const{data:o,indices:r}=e,i=t.typedBuffer,s=t.typedBufferStride,n=r.length;f*=s;for(let c=0;c<n;++c){const e=9*r[c];for(let t=0;t<9;++t)i[f+t]=o[e+t];f+=s}}function g(e,t,f){const{data:o,indices:r}=e,i=t.typedBuffer,s=t.typedBufferStride,n=r.length;f*=s;for(let c=0;c<n;++c){const e=16*r[c];for(let t=0;t<16;++t)i[f+t]=o[e+t];f+=s}}function b(t,f,o,r,i=1){if(!f)return void a(t,o,r,i);const{data:s,indices:n}=t,c=o.typedBuffer,l=o.typedBufferStride,d=n.length,u=f[0],p=f[1],y=f[2],B=f[4],g=f[5],b=f[6],O=f[8],h=f[9],S=f[10],N=f[12],R=f[13],E=f[14];r*=l;let A=0,L=0,F=0;const z=e(f)?e=>{A=s[e]+N,L=s[e+1]+R,F=s[e+2]+E}:e=>{const t=s[e],f=s[e+1],o=s[e+2];A=u*t+B*f+O*o+N,L=p*t+g*f+h*o+R,F=y*t+b*f+S*o+E};if(1===i)for(let e=0;e<d;++e)z(3*n[e]),c[r]=A,c[r+1]=L,c[r+2]=F,r+=l;else for(let e=0;e<d;++e){z(3*n[e]);for(let e=0;e<i;++e)c[r]=A,c[r+1]=L,c[r+2]=F,r+=l}}function O(f,o,r,i,s=1){if(!o)return void a(f,r,i,s);const{data:n,indices:c}=f,l=o,d=r.typedBuffer,u=r.typedBufferStride,p=c.length,y=l[0],B=l[1],g=l[2],b=l[4],O=l[5],h=l[6],S=l[8],N=l[9],R=l[10],E=!t(l),A=1e-6,L=1-A;i*=u;let F=0,z=0,m=0;const I=e(l)?e=>{F=n[e],z=n[e+1],m=n[e+2]}:e=>{const t=n[e],f=n[e+1],o=n[e+2];F=y*t+b*f+S*o,z=B*t+O*f+N*o,m=g*t+h*f+R*o};if(1===s)if(E)for(let e=0;e<p;++e){I(3*c[e]);const t=F*F+z*z+m*m;if(t<L&&t>A){const e=1/Math.sqrt(t);d[i]=F*e,d[i+1]=z*e,d[i+2]=m*e}else d[i]=F,d[i+1]=z,d[i+2]=m;i+=u}else for(let e=0;e<p;++e)I(3*c[e]),d[i]=F,d[i+1]=z,d[i+2]=m,i+=u;else for(let e=0;e<p;++e){if(I(3*c[e]),E){const e=F*F+z*z+m*m;if(e<L&&e>A){const t=1/Math.sqrt(e);F*=t,z*=t,m*=t}}for(let e=0;e<s;++e)d[i]=F,d[i+1]=z,d[i+2]=m,i+=u}}function h(e,f,o,r,i=1){if(!f)return void p(e,o,r,i);const{data:s,indices:n}=e,c=f,l=o.typedBuffer,d=o.typedBufferStride,u=n.length,a=c[0],y=c[1],B=c[2],g=c[4],b=c[5],O=c[6],h=c[8],S=c[9],N=c[10],R=!t(c),E=1e-6,A=1-E;if(r*=d,1===i)for(let t=0;t<u;++t){const e=4*n[t],f=s[e],o=s[e+1],i=s[e+2],c=s[e+3];let u=a*f+g*o+h*i,p=y*f+b*o+S*i,L=B*f+O*o+N*i;if(R){const e=u*u+p*p+L*L;if(e<A&&e>E){const t=1/Math.sqrt(e);u*=t,p*=t,L*=t}}l[r]=u,l[r+1]=p,l[r+2]=L,l[r+3]=c,r+=d}else for(let t=0;t<u;++t){const e=4*n[t],f=s[e],o=s[e+1],c=s[e+2],u=s[e+3];let p=a*f+g*o+h*c,L=y*f+b*o+S*c,F=B*f+O*o+N*c;if(R){const e=p*p+L*L+F*F;if(e<A&&e>E){const t=1/Math.sqrt(e);p*=t,L*=t,F*=t}}for(let t=0;t<i;++t)l[r]=p,l[r+1]=L,l[r+2]=F,l[r+3]=u,r+=d}}function S(e,t,f,o,r=1){const{data:i,indices:s}=e,n=f.typedBuffer,c=f.typedBufferStride,l=s.length;if(o*=c,t!==i.length||4!==t)if(1!==r)if(4!==t)for(let d=0;d<l;++d){const e=3*s[d];for(let t=0;t<r;++t)n[o]=i[e],n[o+1]=i[e+1],n[o+2]=i[e+2],n[o+3]=255,o+=c}else for(let d=0;d<l;++d){const e=4*s[d];for(let t=0;t<r;++t)n[o]=i[e],n[o+1]=i[e+1],n[o+2]=i[e+2],n[o+3]=i[e+3],o+=c}else{if(4===t){for(let e=0;e<l;++e){const t=4*s[e];n[o]=i[t],n[o+1]=i[t+1],n[o+2]=i[t+2],n[o+3]=i[t+3],o+=c}return}for(let e=0;e<l;++e){const t=3*s[e];n[o]=i[t],n[o+1]=i[t+1],n[o+2]=i[t+2],n[o+3]=255,o+=c}}else{n[o]=i[0],n[o+1]=i[1],n[o+2]=i[2],n[o+3]=i[3];const e=new Uint32Array(f.typedBuffer.buffer,f.start),t=c/4,s=e[o/=4];o+=t;const d=l*r;for(let f=1;f<d;++f)e[o]=s,o+=t}}function N(e,t,f){const{data:o,indices:r}=e,i=t.typedBuffer,s=t.typedBufferStride,n=r.length,c=o[0];f*=s;for(let l=0;l<n;++l)i[f]=c,f+=s}function R(e,t,f,o,r=1){const i=t.typedBuffer,s=t.typedBufferStride;if(o*=s,1===r)for(let n=0;n<f;++n)i[o]=e[0],i[o+1]=e[1],i[o+2]=e[2],i[o+3]=e[3],o+=s;else for(let n=0;n<f;++n)for(let t=0;t<r;++t)i[o]=e[0],i[o+1]=e[1],i[o+2]=e[2],i[o+3]=e[3],o+=s}function E(e,t,o,r,i,s){for(const n of t.fields.keys()){const t=e.attributes.get(n),c=t?.indices;if(t&&c)A(n,t,o,r,i,s);else if(n===l.OBJECTANDLAYERIDCOLOR&&null!=e.objectAndLayerIdColor){const t=e.attributes.get(l.POSITION)?.indices;if(t){const o=t.length,r=i.getField(n,f);R(e.objectAndLayerIdColor,r,o,s)}}}}function A(e,t,d,a,y,B){switch(e){case l.POSITION:{c(3===t.size);const f=y.getField(e,n);c(!!f,`No buffer view for ${e}`),f&&b(t,d,f,B);break}case l.NORMAL:{c(3===t.size);const f=y.getField(e,n);c(!!f,`No buffer view for ${e}`),f&&O(t,a,f,B);break}case l.NORMALCOMPRESSED:{c(2===t.size);const f=y.getField(e,s);c(!!f,`No buffer view for ${e}`),f&&u(t,f,B);break}case l.UV0:{c(2===t.size);const f=y.getField(e,i);c(!!f,`No buffer view for ${e}`),f&&u(t,f,B);break}case l.COLOR:case l.SYMBOLCOLOR:{const o=y.getField(e,f);c(!!o,`No buffer view for ${e}`),c(3===t.size||4===t.size),!o||3!==t.size&&4!==t.size||S(t,t.size,o,B);break}case l.COLORFEATUREATTRIBUTE:{const f=y.getField(e,r);c(!!f,`No buffer view for ${e}`),c(1===t.size),f&&1===t.size&&N(t,f,B);break}case l.TANGENT:{c(4===t.size);const f=y.getField(e,o);c(!!f,`No buffer view for ${e}`),f&&h(t,a,f,B);break}case l.PROFILERIGHT:case l.PROFILEUP:case l.PROFILEVERTEXANDNORMAL:case l.FEATUREVALUE:{c(4===t.size);const f=y.getField(e,o);c(!!f,`No buffer view for ${e}`),f&&p(t,f,B)}}}export{d as writeBufferFloat,B as writeBufferMat3f,g as writeBufferMat4f,u as writeBufferVec2,a as writeBufferVec3,p as writeBufferVec4,y as writeBufferVec4Zeros,S as writeColor,N as writeColorFeatureAttribute,A as writeDefaultAttribute,E as writeDefaultAttributes,O as writeNormal,R as writeObjectAndLayerIdColor,b as writePosition,h as writeTangent};
