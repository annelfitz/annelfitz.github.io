/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../core/Accessor.js";import r from"../../../core/Evented.js";import{when as o}from"../../../core/reactiveUtils.js";import{property as a}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/Logger.js";import"../../../core/RandomLCG.js";import{subclass as i}from"../../../core/accessorSupport/decorators/subclass.js";import{afterDispatch as s}from"../../../core/accessorSupport/watch.js";import{fromValues as n}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as l}from"../../../geometry/ellipsoidUtils.js";import p from"../../ViewAnimation.js";import{ViewingMode as c}from"../../ViewingMode.js";import{Constraints as m}from"./Constraints.js";import{AnimationController as d}from"./controllers/AnimationController.js";import{State as h}from"./controllers/CameraController.js";import{PropertiesPool as u}from"../support/PropertiesPool.js";import g from"../webgl/RenderCamera.js";import{PaddingSide as C}from"../webgl-engine/lib/rendererUtils.js";import{RenderState as y}from"../../support/RenderState.js";let _=class extends t{constructor(){super(...arguments),this._propertiesPool=new u({camera:g},this),this._lastSeenCameraProjectionValues=new g,this.mode=y.ANIMATING,this._cssCamera=new g,this._camera=new g,this.rasterPixelRatio=1,this.contentPixelRatio=1,this.events=new r,this.viewingMode=c.Global,this._cameraChanged=!1,this._updateQueue=new Array,this._processingUpdates=!1}init(e,t){this._set("viewingMode",e),this._set("spatialReference",t),this._set("constraints",new m({mode:this.viewingMode}))}exit(){this.cameraController=null,this._propertiesPool.destroy(),this._propertiesPool=new u({camera:g},this)}destroy(){this.cameraController=null,this._propertiesPool?.destroy(),this._propertiesPool=null}createInitialCamera(){if(this.viewingMode===c.Global){const e=l(this.spatialReference).radius;this.camera=new g({eye:n(4*e,0,0),center:n(e,0,0),up:n(0,0,1)})}else this.camera=new g({eye:n(0,0,100),center:n(0,0,0),up:n(0,1,0)})}get animation(){return this.cameraController instanceof d&&null!=this.cameraController.viewAnimation?this.cameraController.viewAnimation:null}get cssCamera(){const e=this._cssCamera.copyFrom(this.camera),{height:t,width:r,pixelRatio:o}=this.camera;return e.pixelRatio=1,e.height=Math.round(t/o),e.width=Math.round(r/o),e}get camera(){return this._camera}set camera(e){e!==v&&v.copyFrom(e),v.computeUp(this.viewingMode),this.events.emit("before-camera-change",v);const t=this._camera;if(w(this._lastSeenCameraProjectionValues,v)&&(this._lastSeenCameraProjectionValues.copyFrom(v),this.events.emit("camera-projection-changed",this._lastSeenCameraProjectionValues)),!t.equals(v)&&(this._camera=this._propertiesPool.get("camera").copyFrom(v),this._cameraChanged=!t.almostEquals(v),this._cameraChanged)){const e=s((()=>{this._cameraChanged=!1,e.remove()}))}}get pixelRatio(){return this.camera.pixelRatio}get alignPixelEnabled(){return this.pixelRatio===this.rasterPixelRatio&&this.mode===y.IDLE}get updating(){return this.mode!==y.IDLE}get contentCamera(){return this._contentCamera??this.camera}set contentCamera(e){this._contentCamera=null!=e?e.clone():null}get fixedContentCamera(){return null!=this._contentCamera}get isGlobal(){return this.viewingMode===c.Global}get isLocal(){return this.viewingMode===c.Local}get navigating(){return!(!this.cameraController||!this.cameraController.isInteractive)}get stationary(){return!this._cameraChanged&&!this.navigating}get cameraController(){return this._get("cameraController")}set cameraController(e){this.stopActiveCameraController()?(this.cameraController?.destroy(),e&&(this.removeHandles(j),this.addHandles(o((()=>e.state===h.Finished||e.state===h.Stopped),(()=>{this._set("cameraController",null),this.updateCamera((t=>e.onControllerEnd(t)))}),{sync:!0,once:!0}),j),e.onControllerStart(this.camera)),this._set("cameraController",e)):e&&(e.state=h.Rejected)}switchCameraController(e){return this.cameraController=e,e.state!==h.Rejected}stopActiveCameraController(){return!(this.cameraController&&!this.cameraController.stopController())}updateCamera(e){this._updateQueue.push(e),this._processUpdateQueue()}_processUpdateQueue(){if(0===this._updateQueue.length||this._processingUpdates)return;this._processingUpdates=!0;const e=this._updateQueue.shift();v.copyFrom(this._get("camera")),e(v),this.camera=v,this._processingUpdates=!1,this._processUpdateQueue()}};e([a()],_.prototype,"mode",void 0),e([a({readOnly:!0,type:p})],_.prototype,"animation",null),e([a({type:g})],_.prototype,"cssCamera",null),e([a()],_.prototype,"_cssCamera",void 0),e([a({type:g})],_.prototype,"camera",null),e([a()],_.prototype,"_camera",void 0),e([a({readOnly:!0})],_.prototype,"pixelRatio",null),e([a()],_.prototype,"rasterPixelRatio",void 0),e([a()],_.prototype,"contentPixelRatio",void 0),e([a({readOnly:!0})],_.prototype,"alignPixelEnabled",null),e([a({readOnly:!0})],_.prototype,"updating",null),e([a({})],_.prototype,"_contentCamera",void 0),e([a({type:g})],_.prototype,"contentCamera",null),e([a({readOnly:!0})],_.prototype,"fixedContentCamera",null),e([a({readOnly:!0})],_.prototype,"constraints",void 0),e([a({readOnly:!0})],_.prototype,"events",void 0),e([a({readOnly:!0})],_.prototype,"isGlobal",null),e([a({readOnly:!0})],_.prototype,"isLocal",null),e([a({readOnly:!0})],_.prototype,"viewingMode",void 0),e([a({readOnly:!0})],_.prototype,"spatialReference",void 0),e([a()],_.prototype,"navigating",null),e([a()],_.prototype,"stationary",null),e([a()],_.prototype,"_cameraChanged",void 0),e([a()],_.prototype,"cameraController",null),_=e([i("esri.views.3d.state.ViewState")],_);const f=_;function w(e,t){return e.fov!==t.fov||(e.fullViewport[0]!==t.fullViewport[0]||e.fullViewport[1]!==t.fullViewport[1]||e.fullViewport[2]!==t.fullViewport[2]||e.fullViewport[3]!==t.fullViewport[3]||(e.padding[C.TOP]!==t.padding[C.TOP]||e.padding[C.RIGHT]!==t.padding[C.RIGHT]||e.padding[C.BOTTOM]!==t.padding[C.BOTTOM]||e.padding[C.LEFT]!==t.padding[C.LEFT]))}const v=new g,j="ViewStateHandles";export{f as default};
