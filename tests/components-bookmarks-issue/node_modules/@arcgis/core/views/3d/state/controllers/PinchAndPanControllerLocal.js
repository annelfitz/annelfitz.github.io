/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import{createScreenPointArray as i,screenPointObjectToArray as e}from"../../../../core/screenUtils.js";import"../../../../core/Logger.js";import"../../../../core/has.js";import"../../../../core/RandomLCG.js";import"../../../../core/Error.js";import{subclass as n}from"../../../../core/accessorSupport/decorators/subclass.js";import{distance as s}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{F as o,c as r,k as a,f as m,l as h,n as l,h as c,g as p}from"../../../../chunks/vec32.js";import{create as _,fromValues as u}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{wrapAxisAngle as d}from"../../../../geometry/support/axisAngle.js";import{create as C,fromNormalAndOffset as g,setOffsetFromPoint as v,negate as M,getNormal as b}from"../../../../geometry/support/plane.js";import{pixelDistanceToInteractionFactor as w,applyAll as f}from"../../camera/constraintUtils.js";import{ConstraintOptions as j}from"../../camera/constraintUtils/ConstraintOptions.js";import{ConstraintTypes as P}from"../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as V}from"../../camera/constraintUtils/InteractionType.js";import{ExponentialFalloff as z}from"../../input/util.js";import{getVoxelWasm as S}from"../../layers/VoxelWasm.js";import{InteractiveController as E}from"./InteractiveController.js";import{PanPlanarMomentumController as H}from"./momentum/PanPlanarMomentumController.js";import{RotationMomentumController as y}from"./momentum/RotationMomentumController.js";import{ZoomPlanarMomentumController as O}from"./momentum/ZoomPlanarMomentumController.js";import{NavigationMode as x,contentIntersectorOptions as F,navigationMode as A,panDistanceModifier as R,minHeightLimit as U,screenPixelArea as L,centroid as T,applyZoomToPoint as k,applyPanPlanar as I,normalizeRotationDelta as N,applyRotation as Z,intersectPlaneFromScreenPointAtEye as D}from"../utils/navigationUtils.js";import G from"../../webgl/RenderCamera.js";import{PanPlanarMomentumEstimator as B}from"../../../navigation/PanPlanarMomentumEstimator.js";import{RotationMomentumEstimator as W}from"../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as q}from"../../../navigation/ZoomMomentumEstimator.js";const J=u(0,0,1);let K=class extends E{constructor(){super(...arguments),this._rotationValueSmooth=new z(.05),this._scalingValueSmooth=new z(.05),this._planeHorizontal=C(),this._planeVertical=C(),this._rotationMomentumEstimator=new W,this._panMomentumEstimator=new B(300,12,.9),this._zoomMomentumEstimator=new q,this._beginRadius=0,this._beginCenter=_(),this._beginAngle=0,this._tmpPoints=[],this._navMode=x.Horizontal,this._beginCenterScreen=i(),this._tmpCentroid3d=_(),this._tmpCentroid2d=i(),this._tmp2d=i(),this._pointerCount=0,this._beginCamera=new G,this._constraintOptions=new j(P.ALL,V.NONE,0,this._beginCamera)}begin(t){if(!this.active)return;const i=this.view.navigation.momentumEnabled;this._zoomMomentumEstimator.enabled=i,this._rotationMomentumEstimator.enabled=i,this._panMomentumEstimator.enabled=i,this._beginRadius=t.radius,this._pointerCount=t.pointers.size,this._beginAngle=t.angle,this._rotationValueSmooth.reset(),this._scalingValueSmooth.reset(),e(t.center,this._beginCenterScreen),g(J,0,this._planeHorizontal);const n=_(),s=this._intersectionHelper.intersectScreenFreePointFallback(this._beginCenterScreen,n,0===this.view.map.ground.opacity?F:{}),u=_();o(u,this.startCamera.viewForward);const d=_();r(d,J);const C=a(u,d);this._navMode=A(this.startCamera,this._beginCenterScreen,this.view.renderCoordsHelper,this.view.viewingMode);const w=Math.min(R,1/Math.abs(a(d,this.startCamera.viewForward)))*Math.max(Math.abs(this.view.camera.position.z),U);v(this._planeHorizontal,this._planeHorizontal,n),this.startCamera.aboveGround||M(this._planeHorizontal,this._planeHorizontal);const f=_(),j=_(),P=_();m(f,n,this.currentCamera.eye);const V=h(f);if(l(f,f),this._navMode===x.Vertical){c(d,d,C),m(b(this._planeVertical),u,d),l(b(this._planeVertical),b(this._planeVertical)),v(this._planeVertical,this._planeVertical,n);const i=this.view._stage.renderView.getMinimalDepthForArea(S(this.view),this._beginCenterScreen[0],this._beginCenterScreen[1],this.view.state.camera,L);let e=null!=i?i:w;e=s?Math.min(e,V):e,r(P,p(j,this.currentCamera.eye,c(j,f,e))),this._planeVertical[3]=-a(b(this._planeVertical),P),this._computePlanePoints(t.pointers,this._planeVertical,this.startCamera,this._tmpPoints),T(this._tmpPoints,this._beginCenter)}else{const i=s?V:w;r(P,p(j,this.currentCamera.eye,c(j,f,i))),this._planeHorizontal[3]=-a(b(this._planeHorizontal),P),this._computePlanePoints(t.pointers,this._planeHorizontal,this.startCamera,this._tmpPoints),T(this._tmpPoints,this._beginCenter)}this._beginCamera.copyFrom(this.startCamera)}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.startCamera);const i=t.pointers.size>1,n=this._navMode===x.Horizontal?this._planeHorizontal:this._planeVertical,o=this._beginCenter;if(i){const i=this._beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this._scalingValueSmooth.gain=e,this._scalingValueSmooth.update(i),k(this.currentCamera,o,this._scalingValueSmooth.value,this.view.state.constraints.minimumPoiDistance),this._zoomMomentumEstimator.add(this._scalingValueSmooth.value,.001*t.timestamp),this._constraintOptions.interactionType=V.ZOOM,this._constraintOptions.interactionFactor=w(Math.abs(t.radius-this._beginRadius)),f(this.view,this.currentCamera,this._constraintOptions)}if(this._computePlanePoints(t.pointers,n,this.currentCamera,this._tmpPoints),T(this._tmpPoints,this._tmpCentroid3d),e(t.center,this._tmpCentroid2d),I(this.currentCamera,o,this._tmpCentroid3d),this._panMomentumEstimator.add(this._tmpCentroid2d,this._tmpCentroid3d,.001*t.timestamp),this._constraintOptions.interactionType=V.PAN,this._constraintOptions.interactionFactor=w(s(this._beginCenterScreen,this._tmpCentroid2d)),f(this.view,this.currentCamera,this._constraintOptions),i){const i=o,e=this._rotationValueSmooth.value,n=e+N(t.angle-e),s=.00125*Math.min(Math.max(t.radius,40),120);this._rotationValueSmooth.gain=s,this._rotationValueSmooth.update(n);const r=this._rotationValueSmooth.value-this._beginAngle;this._rotationMomentumEstimator.add(r,.001*t.timestamp);const a=b(this._planeHorizontal);Z(this.currentCamera,i,d(a,r)),this._constraintOptions.interactionType=V.TUMBLE,this._constraintOptions.interactionFactor=w(Math.abs(t.radius*r)),f(this.view,this.currentCamera,this._constraintOptions)}this.commitCamera()}end(t){t.pointers.size===this._pointerCount&&this.update(t),this.finishController();const i=this._zoomMomentumEstimator.evaluateMomentum();if(i)return new O({view:this.view,momentum:i,zoomCenter:this._beginCenter});const e=this._rotationMomentumEstimator.evaluateMomentum();if(e)return new y({view:this.view,momentum:e,center:this._beginCenter,axis:b(this._planeHorizontal)});const n=this._panMomentumEstimator.evaluateMomentum();return n?new H({view:this.view,momentum:n}):null}_computePlanePoints(t,i,e,n){n.length=t.size;const s=this._tmp2d;let o=0;return t.forEach((t=>{s[0]=t.x,s[1]=t.y,void 0===n[o]&&(n[o]=_()),D(i,e,s,n[o]),o+=1})),n}get _intersectionHelper(){return this.view.sceneIntersectionHelper}};K=t([n("esri.views.3d.state.controllers.PinchAndPanControllerLocal")],K);export{K as PinchAndPanControllerLocal};
