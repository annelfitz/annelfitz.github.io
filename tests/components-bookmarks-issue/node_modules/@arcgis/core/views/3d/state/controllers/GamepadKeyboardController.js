/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import{neverReached as e}from"../../../../core/compilerUtils.js";import{clamp as i,acosClamped as a,deg2rad as r}from"../../../../core/mathUtils.js";import{property as o}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as s}from"../../../../core/accessorSupport/decorators/subclass.js";import{translate as n,rotate as c,identity as m}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as l}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{f as h,e as p,g as d,h as u,c as _,F as f,l as v,s as C,n as g,b as y,q as w,E as O,k as b}from"../../../../chunks/vec32.js";import{create as S}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as x}from"../../../../geometry/ellipsoidUtils.js";import{wrap as j}from"../../../../geometry/support/ray.js";import{e as L,h as M,t as T}from"../../../../chunks/sphere.js";import{angle as A}from"../../../../geometry/support/vector.js";import{sv3d as E}from"../../../../geometry/support/vectorStacks.js";import{applyAll as z}from"../../camera/constraintUtils.js";import{ConstraintOptions as I}from"../../camera/constraintUtils/ConstraintOptions.js";import{ConstraintTypes as R}from"../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as U}from"../../camera/constraintUtils/InteractionType.js";import{TiltMode as D}from"../../camera/constraintUtils/TiltMode.js";import{TiltRange as H}from"../Constraints.js";import{InteractiveController as N}from"./InteractiveController.js";import{panMotionToRotationMatrix as k,onSurfaceTiltToEyeTiltGlobal as P,offSurfaceTiltToEyeTiltGlobal as F}from"../utils/navigationUtils.js";import{viewAngle as G}from"../utils/viewUtils.js";import{headingTiltToDirectionUp as V}from"../../support/cameraUtils.js";import{createDirectionUp as B}from"../../support/cameraUtilsInternal.js";import K from"../../webgl/RenderCamera.js";import{extractTransformation as X,isZeroTransformation as q,extractTransformationKeyboard as Z}from"../../../navigation/gamepadAndKeyboardUtils.js";let J=class extends N{constructor(t){super(t),this._filteredSurfaceElevation=0,this._transformation={translation:[0,0,0],heading:0,tilt:0,zoom:0},this._keysButtonState=[0,0,0,0,0,0,0,0,0,0,0,0],this._tmpCamera=new K,this._headingStart=0,this._constraintOptions=new I(R.ALL,U.NONE,0,new K,null,D.LOOK_AROUND)}handleEventGamepad(t){const e=X(t,this.view.navigation.gamepad,this._transformation);("end"===t.action||q(e))&&this.finishController()}activateDirection(t){this._keysButtonState[t]=1,Z(this._keysButtonState,this._transformation)}deactivateDirection(t){this._keysButtonState[t]=0;const e=Z(this._keysButtonState,this._transformation);q(e)&&this.finishController()}onControllerStart(t){this._filteredSurfaceElevation=this.view.pointsOfInterest.cameraOnSurface.location.z,this._headingStart=this.view.camera.heading,super.onControllerStart(t)}_updateFilteredSurfaceElevation(t){const e=this.view.pointsOfInterest.cameraOnSurface.location.z,i=1;this._filteredSurfaceElevation+=i*(e-this._filteredSurfaceElevation)*t}stepController(t,e){this._updateStartHeading(),this._updateFilteredSurfaceElevation(t),this.currentCamera.copyViewFrom(e),this._updateCameraCenter(),this._constraintOptions.interactionStartCamera?.copyFrom(this.currentCamera),this._calculateControlTransformation(t,this.currentCamera,at),this._applyDisabledMovementTypes(at),this._applyPan(at.pan),this._applyRotate(at.rotate),this._applyZoom(at.zoom),this._applyAscend(at.ascend),this._constraintOptions.interactionType=U.NONE,this._constraintOptions.selection=R.COLLISION,z(this.view,this.currentCamera,this._constraintOptions),super.stepController(t,e)}_updateStartHeading(){0!==this._transformation.heading&&(this._headingStart=this.view.camera.heading)}_applyRotate(t){if(!t.enabled)return;const e=this.currentCamera;h(rt,e.center,e.eye),p(rt,rt,t.matrix),e.center=d(rt,rt,e.eye),e.up=p(rt,e.up,t.matrix),this._constraintOptions.interactionType=U.LOOK_AROUND,this._constraintOptions.selection=R.ALL_EXCEPT_COLLISION,z(this.view,e,this._constraintOptions)}_applyPan(t,e=this.currentCamera){if(!t.enabled)return;e.eye=p(rt,e.eye,t.matrix),e.center=p(rt,e.center,t.matrix);this.view.state.isGlobal&&(e.up=p(rt,e.up,t.matrix)),this._constraintOptions.interactionType=U.PAN,this._constraintOptions.selection=R.ALL,z(this.view,e,this._constraintOptions)}_applyZoom(t){if(!t)return;const e=this.currentCamera.viewForward;this.currentCamera.eye=d(rt,this.currentCamera.eye,u(E.get(),e,t)),_(ot,e),f(ot,ot),this._constraintOptions.interactionDirection=ot,this._constraintOptions.interactionType=U.ZOOM,this._constraintOptions.selection=R.ALL_EXCEPT_COLLISION,z(this.view,this.currentCamera,this._constraintOptions),this._constraintOptions.interactionDirection=null}_applyAscend(t){if(!t)return;const e=this.view.renderCoordsHelper.worldUpAtPosition(this.currentCamera.eye,E.get());this._constraintOptions.interactionDirection=_(ot,e);if(this.view.state.isGlobal){const e=v(this.currentCamera.eye),i=(e+t)/e;this.currentCamera.eye=u(rt,this.currentCamera.eye,i),this.currentCamera.center=u(rt,this.currentCamera.center,i)}else{const i=u(E.get(),e,t);this.currentCamera.eye=d(rt,this.currentCamera.eye,i),this.currentCamera.center=d(rt,this.currentCamera.center,i)}this._updateCameraCenter(),this._constraintOptions.interactionType=U.ASCEND,this._constraintOptions.selection=R.COLLISION,z(this.view,this.currentCamera,this._constraintOptions)&&this._updateCameraCenter(),this._constraintOptions.selection=R.ALL_EXCEPT_COLLISION,z(this.view,this.currentCamera,this._constraintOptions),this._constraintOptions.interactionDirection=null}_calculateControlTransformation(t,e,i){nt(i);const a=this._computeVelocities(t);this.view.state.isLocal?this._calculateControlTransformationLocal(a,e,i):this._calculateControlTransformationGlobal(a,e,i)}_updateCameraCenter(){const t=this.view.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude,e=this.view.renderCoordsHelper,i=this.currentCamera.ray;this.currentCamera.center=e.intersectManifoldClosestSilhouette(i,t,rt)}_calculateControlTransformationLocal(t,a,r){const{viewRight:o,viewForward:s}=a,m=this._transformation,l=this.view.navigation.gamepad,h=C(E.get(),s[0],s[1],0);g(h,h);const p=m.translation[0]*t.pan;if(0!==p){const t=u(E.get(),o,p);n(r.pan.matrix,r.pan.matrix,t),r.pan.enabled=!0}switch(l.mode){case"pan":{const e=-m.translation[1]*t.pan;if(0!==e){const t=u(E.get(),h,e);n(r.pan.matrix,r.pan.matrix,t),r.pan.enabled=!0}r.zoom=m.zoom*t.zoom;break}case"zoom":r.zoom=(-m.translation[1]+m.zoom)*t.zoom;break;default:e(l.mode)}const d=m.translation[2]*t.ascend;r.ascend=d;const _=-m.heading*t.rotate;0!==_&&(c(r.rotate.matrix,r.rotate.matrix,_,this.view.renderCoordsHelper.worldUpAtPosition(a.eye,E.get())),r.rotate.enabled=!0);const f=m.tilt*t.rotate,v=G(this.view.renderCoordsHelper,a.center,a.eye),y=i(v+f,H.min,H.max)-v;y&&(c(r.rotate.matrix,r.rotate.matrix,y,o),r.rotate.enabled=!0)}_calculateControlTransformationGlobal(t,e,i){const{eye:a,viewRight:r}=e,o=this._transformation,s=this.view.navigation.gamepad,n=y(E.get(),r,a);g(n,n),f(n,n),k(this.startCamera,e,o,t,this.view.camera.heading,this._headingStart,this.view.camera.tilt,i,s),this._tmpCamera.copyFrom(this.currentCamera),this._applyPan(at.pan,this._tmpCamera);const m=this.view.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude,l=o.translation[2]*t.ascend;i.ascend=l;const h=-o.heading*t.rotate;0!==h&&(c(i.rotate.matrix,i.rotate.matrix,h,this._tmpCamera.eye),i.rotate.enabled=!0);const p=o.tilt*t.rotate,d=this._clampTiltDeltaGlobalToValidRange(p,e.ray,m);0!==d&&(c(i.rotate.matrix,i.rotate.matrix,d,this._tmpCamera.viewRight),i.rotate.enabled=!0),i.zoom+=o.zoom*t.zoom}_clampTiltDeltaGlobalToValidRange(t,e,a){const r=x(this.view.spatialReference),o=P(H.min,e.origin,a,r);let s=0,n=0;const c=E.get();if(this.view.renderCoordsHelper.intersectManifold(e,a,c)){const t=G(this.view.renderCoordsHelper,c,e.origin);s=P(t,e.origin,a,r),n=P(H.max,e.origin,a,r)}else{L(M(T,a+r.radius),e,c);const t=Math.PI+A(e.direction,c);s=F(t,e.origin,a,r),n=F(H.max,e.origin,a,r)}return i(s+t,o,n)-s}_getPointAbsoluteSurfaceElevation(t,e,i){const{renderCoordsHelper:a}=this.view,r=a.getAltitude(t),o=e+Math.abs(r-e);return a.setAltitude(i,o,t),o}_clampedDistanceToSurface(t,e){const{renderCoordsHelper:i}=this.view,{camera:a}=this.view.state,{direction:r}=V(this.view,e,0,W,st),o=i.intersectManifoldClosestSilhouette(j(e,r),t,E.get()),s=w(e,o),n=i.intersectManifoldClosestSilhouette(j(e,O(E.get(),e,a.center)),t,E.get()),c=w(e,n);return Math.min(s,c)}_computeHeadingRotateRadius(t){const{renderCoordsHelper:e,state:i}=this.view,{camera:r,isGlobal:o}=i,s=e.intersectManifoldClosestSilhouette(r.ray,this._filteredSurfaceElevation,E.get());if(o){const e=h(E.get(),t,s),i=v(e);u(e,e,1/i);const r=g(E.get(),t),o=a(b(r,e));return i*Math.sin(Math.min(Y,o))}{const i=_(E.get(),t);return e.setAltitude(i,this._filteredSurfaceElevation),w(s,i)}}_minimumAscendVelocity(){return this.view.state.constraints.collision.enabled?0:tt}_computeVelocities(t){const e=this._filteredSurfaceElevation,a=e+x(this.view.spatialReference).radius,{camera:r,isGlobal:o}=this.view.state,s=E.get(),n=this._getPointAbsoluteSurfaceElevation(r.eye,e,s),c=this._clampedDistanceToSurface(e,s),m=r.width/2,l=$*r.width,h=$*r.width,p=c*Math.tan(.5*r.fovX)/m,d=p/a,u=p/this._computeHeadingRotateRadius(s),_=n-e;return{pan:(o?d:p)*l*t,ascend:Math.max(this._minimumAscendVelocity()*t,2**(l*t/m)*_-_),zoom:2**(l*t/m)*c-c,rotate:i(u*h,et,it)*t}}_applyDisabledMovementTypes(t){null==this.disableMovements||void 0!==this.disableMovements.mode&&this.view.state.viewingMode!==this.disableMovements.mode||(t.zoom=this.disableMovements.zoom?0:t.zoom,t.ascend=this.disableMovements.ascend?0:t.ascend,t.pan.enabled=!this.disableMovements.pan,this.disableMovements.pan&&m(t.pan.matrix),t.rotate.enabled=!this.disableMovements.rotate,this.disableMovements.rotate&&m(t.rotate.matrix))}static activatesFor(t,e){const i=X(e,t.navigation.gamepad,Q);return!("end"===e.action||q(i))}};t([o({constructOnly:!0})],J.prototype,"gamepadDevice",void 0),t([o({constructOnly:!0})],J.prototype,"disableMovements",void 0),J=t([s("esri.views.3d.state.controllers.GamepadKeyboardController")],J);const Q={translation:[0,0,0],heading:0,tilt:0,zoom:0},W=80,Y=r(W),$=.75,tt=5,et=r(30),it=r(80),at={zoom:0,ascend:0,pan:{enabled:!1,matrix:l()},rotate:{enabled:!1,matrix:l()}},rt=S(),ot=S(),st=B();function nt(t){t.zoom=0,t.ascend=0,t.pan.enabled=!1,m(t.pan.matrix),t.rotate.enabled=!1,m(t.rotate.matrix)}export{J as GamepadKeyboardController};
