/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{equals as e}from"../../../core/arrayUtils.js";import{isPowerOfTwo as t}from"../../../core/mathUtils.js";import{disposeMaybe as r}from"../../../core/maybe.js";import{q as i,o as s,H as o,f as a,n,k as l,z as g,G as d}from"../../../chunks/vec32.js";import{create as h,clone as m}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{containsXY as u}from"../../../geometry/support/aaBoundingRect.js";import{earth as c}from"../../../geometry/support/Ellipsoid.js";import{glLayout as f}from"../support/buffer/glUtil.js";import{GeometryState as p}from"./GeometryState.js";import{NeighborIndex as y}from"./ITile.js";import{LayerClass as _}from"./LayerClass.js";import{PatchGeometry as x}from"./PatchGeometry.js";import{maxTileNeighborLevelDelta as v}from"./TerrainConst.js";import{enableTerrainInternalChecks as E,internalAssert as $,neighborEdgeIndices as S,oppositeEdge as C,neighborCornerIndices as D,v32s as T,lij2s as b}from"./terrainUtils.js";import{TextureFader as j,ActivationTime as A}from"./TextureFader.js";import{isEdgeNeighbor as V}from"./Tile.js";import R from"./TileOverlayData.js";import{fallsWithinLayer as w}from"./tileUtils.js";import{VertexArrayObject as L}from"../webgl-engine/lib/VertexArrayObject.js";import{terrainVertexAttributeLocations as N}from"../webgl-engine/shaders/TerrainTechnique.js";import{BufferObject as P}from"../../webgl/BufferObject.js";import{PixelFormat as F}from"../../webgl/enums.js";class G{constructor(){this.geometry=new x,this.intersectionData=null,this.geometryState=null,this._vao=null,this._texture=null,this._textureRef=new j((()=>this.tile.surface.fadeDuration)),this.overlay=new R,this._localOrigin=null,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._modifiedFlags=0}get tile(){return this._tile}get localOrigin(){return this._localOrigin}init(e,t){this.clear(),this._tile=e,this.geometry.reset(),this.intersectionData=null,this.geometryState=new p,this._localOrigin=t,this.overlay.clear()}clear(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear(),this._tile=null,this.intersectionData=null,this.geometryState=null}updateGeometryIfNeeded(e){if((!this._vao||this._geometryStateChangedSinceLastUpdate||this.wireframeChanged||this.clippingAreaChanged||this.samplerDataChanged||this.numVerticesPerSideChanged||this.dirtyCorners||this.dirtyEdgeResolutions||this.dirtyEdges)&&(this._updateGeometry(e),this._geometryStateChangedSinceLastUpdate=!1),E&&this.tile.intersectsClippingArea)for(let t=0;t<4;++t)$(this.geometry.getEdgeCount(t)===this.geometryState.edgeResolutions[t]+1)}_calculateEdgeResolution(e,t){const r=this.tile,i=this.geometryState.numVerticesPerSide-1;if(!r.surface.isGlobal){const t=r.surface.extent;if(null!=t&&(0===e&&r.extent[3]>t[3]||1===e&&r.extent[2]>t[2]||2===e&&r.extent[1]<t[1]||3===e&&r.extent[0]<t[0]))return i}const s=r.level,o=S[e];if(!t)return $(null==r.surface?.rootTiles||r.surface.updatingRootTiles||!r.shouldHaveNeighbor(o)),i;if(t.isLoaded){const r=t,o=r.renderData.geometryState,a=s-r.level;if($(a>=0),0===a){const e=o.numVerticesPerSide-1;return Math.max(e,i)}const n=2**a,l=o.edgeResolutions[(e+2)%4]/n;return Math.max(1,l)}$(!t.isLeaf);let a=i;return t.forAllSubtreeOnSide(C(o),(e=>e===r||(e.isLoaded?(a=Math.max(a,2**(e.level-s)),!0):($(!e.isLeaf),!1)))),a}updateNeighborData(){const e=this.tile;if(!e.intersectsClippingArea)return;const r=e.renderData.geometryState,i=t=>(t.isLoaded||t.level===e.level)&&t?.intersectsClippingArea,s=r.edgePeerNeighbors,o=r.edgePeerNeighborSamplerVersions;for(let a=0;a<4;++a){const n=e.findNeighborTile(S[a],i),l=W(e,n),g=l?.renderData?.geometryState.samplerDataVersion??-1,d=s[a],h=l!==W(e,d),m=o[a]!==g;E&&n&&($(e.level>=n.level),$(e.level-n.level<=v)),s[a]=n,(h||m)&&(o[a]=g,this._markEdgeDirty(a));const u=r.edgeResolutions[a],c=this._calculateEdgeResolution(a,n);$(t(c)),$(c>=1),r.edgeResolutions[a]=c,u!==c&&this._markEdgeResolutionDirty(a)}for(let t=0;t<4;++t){const o=e.findNeighborTile(D[t],i);r.cornerPeerNeighbors[t]=o;const a=W(e,s[t]),n=W(e,s[(t+1)%4]),l=W(e,o);B[t]=l,B[(t+1)%4]=n,B[(t+2)%4]=e,B[(t+3)%4]=a,$(B.some((t=>t?.isLoaded||t===e)));const g=B.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);B.forEach(((e,t)=>{e&&e?.level>g&&(B[t]=null)})),$(B.some((t=>t?.isLoaded||t===e)));const d=r.cornerNeighborCornerTiles,h=r.cornerNeighborCornerTileSamplerVersions;for(let e=0;e<4;++e){const r=B[e],i=r?.renderData.geometryState.samplerDataVersion??-1,s=4*t+e,o=d[s]!==r,a=!o&&h[s]!==i;(o||a)&&(d[s]=r,h[s]=i,this._markCornerDirty(t))}E&&$(ee.some((r=>d[4*t+r]?.isLoaded||d[4*t+r]===e)))}E&&$(this.geometryState.edgeResolutions.every((e=>e>0)));for(let t=0;t<4;++t)B[t]=null}_updateGeometry(e){if(!this.tile.intersectsClippingArea)return;E&&$(!this.tile.intersectsClippingArea||this.geometryState.edgeResolutions.every((e=>e>0))),this.intersectionData=null;const{tile:t,_vao:r,geometry:i,geometryState:s}=this,o=!r||!{geometry:i}||this.wireframeChanged||this.samplerDataChanged||this.clippingAreaChanged||this.numVerticesPerSideChanged,a=0!==this.dirtyEdgeResolutions,n=s.edgeResolutions.reduce(((e,t)=>e+t+1),0),l=o||a&&n>(i?.maxEdgeVertexCount??0),g=!l&&a,d=!g&&(0!==this.dirtyEdges||a),h=!d&&0!==this.dirtyCorners;l?(this.releaseGeometry(),this._createGeometry(e)):g?t.updateEdgeElevationsAndResolutions():d||h?t.updateEdgeElevations():h?t.updateCornerElevations():console.warn("Update for no reason?"),this._modifiedFlags=0}get hasGeometry(){return this._hasGeometry}releaseGeometry(){return this._hasGeometry=!1,this.intersectionData=null,!!this._vao&&(this._vao=r(this._vao),this.geometry.release(),!0)}ensureTexture(e,t,r){const i=t?F.RGBA:F.RGB;return null==this._texture||this._texture.descriptor.width===e&&this._texture.descriptor.pixelFormat===i||this.releaseTexture(),null==this._texture&&(this._texture=r(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){null!=this._texture&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())}get numVerticesPerSideChanged(){return!!(this._modifiedFlags&q)}get samplerDataChanged(){return!!(this._modifiedFlags&z)}get clippingAreaChanged(){return!!(this._modifiedFlags&J)}get wireframeChanged(){return!!(this._modifiedFlags&K)}get dirtyEdges(){return this._modifiedFlags>>Q&15}get dirtyCorners(){return this._modifiedFlags>>Y&15}get dirtyEdgeResolutions(){return this._modifiedFlags>>Z&15}_markCornerDirty(e){const t=1<<e<<Y;this._modifiedFlags|=t}_markEdgeDirty(e){const t=1<<e<<Q;this._modifiedFlags|=t,this._markCornerDirty((e+0)%4),this._markCornerDirty((e+3)%4)}_markEdgeResolutionDirty(e){const t=1<<e<<Z;this._modifiedFlags|=t,this._markEdgeDirty(e)}_markAllEdgesAndCornersDirty(){this._modifiedFlags|=15<<Y|15<<Q|15<<Z}updateGeometryState(){const t=this._getElevationInfo(),r=this.tile,i=t.samplerData?r.getElevationVerticesPerSide(t.maxTileLevel):r.getDefaultVerticesPerSide(),s=Math.max(i,5);let o=r.clippingArea;r.intersectsClippingArea&&!r.isWithinClippingArea||(o=null);const a=this.geometryState;let n=!1;a.numVerticesPerSide!==s&&(this._modifiedFlags|=1,a.numVerticesPerSide=s,a.samplerDataVersion++,n=!0),t.changed&&(this._modifiedFlags|=2,a.samplerData=t.samplerData,a.samplerDataVersion++,n=!0),e(a.clippingArea,o)||(this._modifiedFlags=4,a.clippingArea=o,n=!0);const l=r.surface.wireframe;return a.wireframe!==l&&(this._modifiedFlags=8,a.wireframe=l,n=!0),this._geometryStateChangedSinceLastUpdate||=n,n&&this._markAllEdgesAndCornersDirty(),this._hasGeometry=!0,this._geometryStateChangedSinceLastUpdate}_createGeometry(e){this.tile.createGeometry();const t=this.geometry.vertexAttributes,r=this.geometry.indices,i=e.gl;this._vao=new L(e,N,{geometry:f(t.layout)},{geometry:P.createVertex(e,i.STATIC_DRAW,t.buffer)},P.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0}get vao(){return this._vao}setTextureReference(e,t=A.Immediate){null!=e&&e.texture!==this._texture&&this.releaseTexture(),this._textureRef.push(e,t)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_getElevationInfo(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[_.ELEVATION],r=t.length,i=new Array(r);let s=0,o=0,a=!1;for(let g=0;g<r;g++){const r=t[g];if(null!=r.upsampleInfo){const t=r.upsampleInfo.tile,n=t.layerInfo[_.ELEVATION][g].data,l=n&&n.samplerData;e&&e[s]===l||(a=!0),i[s++]=l,o=Math.max(o,t.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(g,_.ELEVATION);if(w(this.tile,t.layer,!1)){const t=r.data;e&&e[s]===t.samplerData||(a=!0),i[s++]=t.samplerData,o=this.tile.level}}}null!=e&&e.length!==s&&(a=!0);const n=s>0,l=n?i:null;return n&&(i.length=s),{changed:a,samplerData:l,maxTileLevel:o}}get estimatedGeometryMemoryUsage(){const e=this.intersectionData?.estimatedMemoryUsage??0;return(this.geometry.indices?.byteLength??0)+(this.geometry.vertexAttributes?.byteLength??0)+e}get texture(){return this._texture}get test(){return{hasTexture:null!=this._texture}}checkGeometryWaterproofness(){if(!E)return;const e=this.tile;if(!e.isLoaded||!e.intersectsClippingArea||0===e.level)return void $(e?.isLoaded);const r=e.surface.extent;if(null!=r&&!e.intersectsExtent(r))return;const f=S.map(((t,i)=>null!=r&&(i<2?-1:1)*(e.extent[3-i]-r[3-i])<0)),p=e.level;$(0===this.dirtyCorners),$(0===this.dirtyEdges),$(0===this.dirtyEdgeResolutions),$(!this.numVerticesPerSideChanged),$(!this.samplerDataChanged),$(!this.clippingAreaChanged),$(!this.wireframeChanged);const _=D.map((t=>e.findNeighborCornerTileExact(t,(t=>!t.intersectsClippingArea||t.isLoaded||t.level===e.level))??null)).map((e=>e?.intersectsClippingArea?e:null)),x=this.geometryState;for(let t=0;t<4;++t){const r=x.cornerPeerNeighbors[t],i=_[t];$(i===r,`Tile[${e.lij}].corner[${t}] out of date: cur=[${r?.lij}] exp=[${i?.lij}]`)}S.forEach(((r,_)=>{if(f[_])return;const x=e.findNeighborTile(r,(e=>(e.level===p||e?.isLoaded)&&e?.intersectsClippingArea));if(!x){const t=!e.surface.updatingRootTiles&&null!=e.surface.rootTiles&&e.surface.rootTiles.length>0&&e.shouldHaveNeighbor(r);return void $(!t)}$(x.isLoaded||x.level===e.level),$(x===this.geometryState.edgePeerNeighbors[_]);const v=p-x.level;if(!x.isLoaded)return $(!x.isLeaf),void $(0===v);const E=x.renderData;$(V(e,x,r)),$(v>=0);const S=2**v;if(v<0)return void $(!1);const C=e.renderData,D=C.geometry,j=C.localOrigin,A=D.getEdgeCount(_),R=D.numVerticesPerSide-1,w=E.geometry;if(!w)return void $(!1);const L=E.localOrigin,N=this.geometryState.edgePeerNeighbors[_];if(N?.isLoaded){const e=N.renderData;$(C.geometryState.edgePeerNeighborSamplerVersions[_]===e.geometryState.samplerDataVersion),$(this.geometryState.edgePeerNeighborSamplerVersions[_]===e.geometryState.samplerDataVersion)}const P=(_+2)%4,F=w.getEdgeCount(P),G=A-1,B=F-1;$(G*S===B,`Tile[${e.lij}]:e${_},res=${G} edgeRes mismatch with Neighbor[${x.lij}]:e${P},res=${B} (expected:${G*S})`);const W=e.extent,q=r===y.NORTH||r===y.SOUTH,z=F-1,J=z>>v,K=A-1;if(J<1)return void $(1===K);$(J===K),$(t(J));const Q=w.numVerticesPerSide-1;$(v>0||J===Math.max(Q,R));const Y=e.getNeighborEdgeStartVertexIndex(_,x);$(0<=Y&&Y<S);const Z=Y*J;$(0<=Z&&Z<=z-J);let ee=0,te=Z;D.getEdgeVertexPosition(_,O,j,0),D.getEdgeVertexPosition(_,I,j,A-1);const re=i(O,I),ie=Math.max(X,1e-4*re);for(let t=0;t<=J;++t){D.getEdgeVertexPosition(_,O,j,ee),w.getEdgeVertexPosition(P,I,L,te);const i=t/J,f=q?W[0]+i*(W[2]-W[0]):r===y.WEST?W[0]:W[2],p=q?r===y.SOUTH?W[1]:W[3]:W[1]+i*(W[3]-W[1]),v=e.surface.extent;if(null==v||u(v,f,p)){const t=s(O,I),r=o(O)-c.radius,i=o(I)-c.radius,u=t<ie;if(!u){console.warn(`Tile edge vertex position mismatch: between [${e.lij}].edge${_}[${ee}/${A}] and [${x.lij}].edge${P}[${te}/${F}]`),null!=v&&console.warn("  surface extent= ",v," x,y=",f,",",p);const s=h();a(s,C.localOrigin,E.localOrigin),o(s)>0&&console.warn(`   localOrigins: ${C.localOrigin} vs ${E.localOrigin} d=${o(s)} [${s}]`);(()=>{const t=m(O),r=m(I);e.updateEdgeElevations(),x.updateEdgeElevations(),D.getEdgeVertexPosition(_,O,j,ee),w.getEdgeVertexPosition(P,I,L,te);const i=h();g(i,O,t),o(i)>0&&console.warn(`  XXX Tile[${e.lij}] edge out of date: ${t} vs ${O} d=${o(i)} [${i}]`),g(i,I,r),o(i)>0&&console.warn(`  XXX Neighbor[${x.lij}] edge out of date: ${r} vs ${I} d=${o(i)} [${i}]`)})();const n=D.getEdgeCount(_),l=w.getEdgeCount(F);$(u,`Mismatch in tile [${e.lij}].edge[${_}][${ee}/${n}] vs neighbor [${x.lij}].edge[${P}][${te}/${l}] ${T(O)} vs ${T(I)}  dist=${t} h(t|n|d)=${r}|${i}|${i-r}`)}D.getEdgeNormal(_,M,ee),w.getEdgeNormal(P,U,te),n(k,M),n(H,U);const y=l(k,H),S=1-y<.01||!1||e===x;if(!S){const t=h();g(t,M,U);const r=()=>`Mismatch in tile edge normal ${b(e.lij)} (${ee}/${A-1}) edge ${_} vs neighbor ${b(x.lij)}  (${te}/${F-1}) nedge ${P} :${T(M)} vs ${T(U)}  dot = ${y} : ${T(t)}`;console.warn("Mismatch in tile edge normal: ",r());{e.updateEdgeElevations(),x.updateEdgeElevations();const t=h(),r=h();D.getEdgeNormal(_,t,ee),w.getEdgeNormal(P,r,te),d(M,t)||console.warn("Missing update in tile normal: ",T(M)," => ",T(t)),d(U,r)||console.warn("Missing update in neighbor normal: ",T(U)," => ",T(r))}$(S,r())}}ee+=1,te+=1}}))}}const O=h(),I=h(),M=h(),U=h(),k=h(),H=h(),X=1,B=[null,null,null,null];function W(e,t){return t?.isLoaded||t===e?t:null}const q=1,z=2,J=4,K=8,Q=4,Y=8,Z=12,ee=[0,1,2,3];export{A as ActivationTime,G as PatchRenderData,W as neighborTileIfLoadedOrSelf,ee as zeroToFour};
