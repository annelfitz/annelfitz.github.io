/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../core/mathUtils.js";import{abortMaybe as t}from"../../../core/maybe.js";import i from"../../../core/ObjectPool.js";import{f as s,p as n,k as r,h as a,g as o,l,c as h}from"../../../chunks/vec32.js";import{create as u,unitZ as d}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getEpsilon as c}from"../../../core/libs/gl-matrix-2/math/common.js";import{getReferenceEllipsoid as g}from"../../../geometry/ellipsoidUtils.js";import{create as p,equals as f}from"../../../geometry/support/aaBoundingRect.js";import{c as _,g as m}from"../../../chunks/sphere.js";import{isGroupLayer as y}from"../../../layers/support/layerUtils.js";import{VectorTile as A}from"../../2d/engine/vectorTiles/VectorTile.js";import{ImageWithType as M}from"../support/StreamDataLoader.js";import{ElevationBounds as T}from"./ElevationBounds.js";import{ElevationTileAgent as v}from"./ElevationTileAgent.js";import{TextureUpdate as E}from"./interfaces.js";import{TileFrustumVisibility as I,NeighborIndex as D}from"./ITile.js";import{LayerClasses as L,LayerClass as x}from"./LayerClass.js";import{MapTileAgent as S}from"./MapTileAgent.js";import{RasterTile as O}from"./RasterTile.js";import{maxPatchTesselation as N,getElevationDesiredResolutionLevel as b}from"./TerrainConst.js";import{weakAssert as j,getLayerWithExtentRange as U,isBlendableLayerView as C,oppositeCorner as B,internalAssert as P,enableTerrainInternalChecks as R,neighborEdgeIndices as V,oppositeEdge as w,neighborCornerIndices as G,isNorth as W,isSouth as q,isWest as F,isEast as H,enableWaterproofnessTests as k,almostEquals as X,isWestCorner as Y,isNorthCorner as z}from"./terrainUtils.js";import{tileAgentDone as $}from"./TileAgent.js";import{TilePerLayerInfo as J}from"./TilePerLayerInfo.js";import Q from"./TileTexture.js";import{TileUpdate as K}from"./TileUpdate.js";import{fallsWithinLayer as Z}from"./tileUtils.js";const ee=.1;class te{constructor(){this._lij=[0,0,0],this._children=[null,null,null,null],this._pendingUpdates=0,this.renderData=null,this._dirty=!0,this._previouslyRendered=!1,this.extent=p(),this._elevationBoundsMin=NaN,this._elevationBoundsMax=0,this.layerInfo=[[],[]],this.extentInRadians=p(),this.centerAtSeaLevel=u(),this._center=[u(),_(),u()],this.up=d(),this._isWithinClippingArea=!0,this._intersectsClippingArea=!0,this._maxTesselation=0,this._usedMemory=null,this._mapTileMemoryInternal=0,this._mapDataRefCount=0,this.screenDepth=0,this.renderOrder=0,this._edgeLen=0,this._edgeLen2=0,this._curvatureHeight=0,this.extentMidX=0,this.extentMidY=0,this.distanceToPOI=-1,this._lastPOI=u(),this.maxLevelDeltaNeighborCount=0,this.unmergableChildCount=0}get lij(){return this._lij}static prune(){ne.prune(0),re.prune(0),J.prune()}get _isCached(){return!this.isLeaf&&this._mapDataRefCount<=0}get maxTesselation(){return this._maxTesselation}get isWithinClippingArea(){return this._isWithinClippingArea}get intersectsClippingArea(){return this._intersectsClippingArea}get clippingArea(){return this._clippingArea}get parent(){return this._parent}get children(){return this._children}get surface(){return this._surface}get elevationBoundsMin(){return this._elevationBoundsMin}get elevationBoundsMax(){return this._elevationBoundsMax}get level(){return this._lij[0]}get key(){return`${this._lij[0]}/${this._lij[1]}/${this._lij[2]}`}get edgeLen(){return this._edgeLen}get radius(){return this._center[oe.MIDDLE][3]}get visible(){return this._dirty&&this.computeVisibility(),this._visible}get frustumVisibility(){return this._dirty&&this.computeVisibility(),this._frustumVisibility}computeVisibility(){this._dirty=!1;const e=this.parent,t=e?.frustumVisibility??I.INTERSECTS;this._frustumVisibility=t===I.INSIDE?I.INSIDE:t===I.OUTSIDE?I.OUTSIDE:this._calculateFrustumVisibilityStatus(this.surface.frustum);const i=this._frustumVisibility!==I.OUTSIDE&&this._intersectsClippingArea;i!==this._visible&&(this._visible=i,this._surface.emit("tiles-visibility-changed"),this._surface.renderer.setDirty(),this.updateAgentSuspension())}get loadable(){return this.visible||this._surface.view.state.fixedContentCamera}get rendered(){const e=!!this.renderData;return e!==this._previouslyRendered&&(this._surface.emit("tiles-visibility-changed"),this._previouslyRendered=e,this._surface.renderer.setDirty()),e}init(e,t,i,s,n){this._lij[0]=e,this._lij[1]=t,this._lij[2]=i,this.ellipsoid=g(n.tilingScheme.spatialReference),n.tilingScheme.getExtent(e,t,i,this.extent),n.tilingScheme.convertExtentToRadians(this.extent,this.extentInRadians),this.extentMidX=.5*(this.extent[0]+this.extent[2]),this.extentMidY=.5*(this.extent[1]+this.extent[3]),this._isWithinClippingArea=!0,this._intersectsClippingArea=!0,this._clippingArea=null,this._mapDataRefCount=0,n.upsampleMapCache.pop(this.key),this._edgeLen=0,this._edgeLen2=0,this._center[oe.MIDDLE][3]=0,this.elevationLevel=e,s&&!Number.isNaN(s.elevationBoundsMin)?(this._elevationBoundsMin=s.elevationBoundsMin,this._elevationBoundsMax=s.elevationBoundsMax):(this._elevationBoundsMin=0,this._elevationBoundsMax=0),this._pendingUpdates=0,this.renderData=null,this.screenDepth=0,this._visible=!1,this._previouslyRendered=!1,this._parent=s,this.unsetChildren(),this._surface=n,this.updateVisibility(),this.maxLevelDeltaNeighborCount=0,this.unmergableChildCount=0;for(const r of L){const e=n.numLayers(r),t=this.layerInfo[r];for(const i of t)i.release();t.length=e;for(let i=0;i<e;i++)t[i]=J.acquire(this._surface.upsampleInfoPool),r===x.ELEVATION&&this.findElevationBoundsForLayer(i,-1)}this.computeElevationBounds(),this._maxTesselation=Math.min(n.tilingScheme.pixelSize,N)}dispose(){j(!this.renderData,"tile.renderData was not unloaded"),this._surface.upsampleMapCache.pop(this.key);for(const e of L){for(const t of this.layerInfo[e])t.release();this.layerInfo[e].length=0}this._parent=null;for(let e=0;e<4;++e)this._children[e]=null;this._surface=null,this.setMemoryDirty()}refMapData(){++this._mapDataRefCount,this._isCached||this._surface.upsampleMapCache.pop(this.key)}unrefMapData(){if(--this._mapDataRefCount,this._isCached){this.setMemoryDirty();const e=this._cachedMemory;e>0&&this._surface.upsampleMapCache.put(this.key,this,e)}}setMemoryDirty(){this._usedMemory=null}get usedMemory(){return this._ensureUsedMemory()+(this._isCached?0:this._mapTileMemoryInternal)}get _cachedMemory(){return this._isCached?this._mapTileMemory:0}get _mapTileMemory(){return this._ensureUsedMemory(),this.layerInfo[x.MAP].reduce(((e,t)=>e+(t instanceof A?t.usedMemory/t.referenced:0)),this._mapTileMemoryInternal)}get _cpuImageMemorySize(){const e=4,t=this._surface.tilingScheme.pixelSize;return t*t*e}_ensureUsedMemory(){if(null!=this._usedMemory)return this._usedMemory;this._usedMemory=this._baseUsedMemory,this._mapTileMemoryInternal=0;let e=0;for(const{data:i}of this.layerInfo[x.MAP])i instanceof A?e+=this._getTerrainDataMemory(i):this._mapTileMemoryInternal+=this._getTerrainDataMemory(i);const t=this._cpuImageMemorySize;for(const i of this.layerInfo[x.ELEVATION])this._usedMemory+=i.data?t:0;return this.renderData&&(this._usedMemory+=this.renderData.estimatedGeometryMemoryUsage,this._mapTileMemoryInternal+=this.renderData.texture?.usedMemory??0),this._isCached&&this._surface.upsampleMapCache.updateSize(this.key,this,this._mapTileMemoryInternal+e),this._usedMemory}getUsedMemoryForLayer(e,t){const i=this.layerInfo[e][t];return i?.data?e===x.MAP?this._isCached?0:this._getTerrainDataMemory(i.data):e===x.ELEVATION?this._cpuImageMemorySize:0:0}_getTerrainDataMemory(e){return e instanceof Q?e.texture.usedMemory:e instanceof HTMLImageElement||e instanceof M?this._cpuImageMemorySize:e instanceof O?e.memoryUsage:e instanceof A?e.usedMemory/e.referenced:0}updateScreenDepth(e){const t=this._center[oe.MIDDLE],i=e,s=t[0],n=t[1],r=t[2],a=i[2]*s+i[6]*n+i[10]*r+i[14];this.screenDepth=a<0?0:a/(i[3]*s+i[7]*n+i[11]*r+i[15])}shouldSplit(e,t,i){if(!this.visible)return K.NONE;if(e.frustum&&(!this._intersectsClippingArea||this._calculateFrustumVisibilityStatus(e.frustum)===I.OUTSIDE))return K.NONE;const h=this.level;s(pe,m(this._center[oe.MIDDLE]),t);let u=n(pe),d=pe,c=m(this._center[oe.MIDDLE]);s(fe,this._center[oe.TOP],t);const g=n(fe);g<u&&(u=g,d=fe,c=this._center[oe.TOP]),s(_e,this._center[oe.BOTTOM],t);const p=n(_e);if(p<u&&(u=p,d=_e,c=this._center[oe.BOTTOM]),this._edgeLen2>u&&h<e.maxLod)return K.SPLIT;const f=Math.sqrt(u),_=e.fovX*f*2,y=this._edgeLen/_,A=()=>{if(h<e.maxLod)return this.elevationLevel=h,K.NONE;const t=h+Math.ceil(-Math.log2(e.relativeWidthLimit/y));return t!==this.elevationLevel?(this.elevationLevel=t,K.ELEVATION):K.NONE},M=null!=i?i-h:1/0;if(M<=.5)return A();const T=r(this.up,pe),v=this._elevationBoundsMax-this._elevationBoundsMin,E=v/this.edgeLen;if(e.aboveGround&&T>0&&E<.001){if(T/f-Math.sin(this._curvatureHeight/(this.edgeLen*Math.SQRT1_2)*Math.PI)-E>0)return K.NONE}const D=null!=i?3-Math.min(M,2):1;if(y*D<e.relativeWidthLimit||h>=e.maxLod)return A();if(h<7)return K.SPLIT;a(me,this.up,T),s(me,me,d);const L=n(me);if(L<=this.radius*this.radius)return K.SPLIT;a(me,me,this.radius/Math.sqrt(L)),o(me,me,c),s(me,t,me);const x=Math.min(1,(Math.abs(r(me,this.up))+.5*v+this._curvatureHeight)/l(me)),S=ee/e.angledSplitBias,O=e.fovY*f*2;return x*(this._edgeLen/O*D)<S*e.relativeHeightLimit?K.NONE:K.SPLIT}setChildren(e,t,i,s){j(!!(e&&t&&i&&s),"Null child passed");const n=this._children;return n[0]=e,n[1]=t,n[2]=i,n[3]=s,n}unsetChildren(){this._children[0]=null,this._children[1]=null,this._children[2]=null,this._children[3]=null}get isLoaded(){return this.renderData?.hasGeometry??!1}load(){this.refMapData();for(const e of L)this._createOrUpdateAgents(0,e);this.surface.renderer.loadTile(this)}unload(e){e.unloadTile(this);for(const t of L){const e=this.layerInfo[t];for(const t of e)t.loadingAgent&&t.loadingAgent!==$&&(se(t.loadingAgent),t.loadingAgent=null),t.pendingUpdates=0}this.resetPendingUpdate(K.GEOMETRY),this.resetPendingUpdate(K.TEXTURE_NOFADING),this.resetPendingUpdate(K.TEXTURE_FADING),this.unrefMapData()}unloadMapData(){const e=this.layerInfo[x.MAP];for(const t of e)t.loadingAgent&&t.loadingAgent!==$&&(se(t.loadingAgent),t.loadingAgent=null),t.pendingUpdates=0;this.renderData&&this.renderData.releaseTexture(),this.setMemoryDirty()}updateClippingStatus(e){if(f(e,this._clippingArea))return!1;const t=this._intersectsClippingArea,i=this._isWithinClippingArea;null!=e?(this._intersectsClippingArea=this.intersectsExtent(e),this._isWithinClippingArea=this._isWithinExtent(e)):(this._intersectsClippingArea=!0,this._isWithinClippingArea=!0),this._clippingArea=e,this.updateVisibility();const s=i&&this._isWithinClippingArea,n=!(i||t||this._isWithinClippingArea||this._intersectsClippingArea);return!this.renderData||s||n||this.setPendingUpdate(K.GEOMETRY),!0}updateVisibility(){this._dirty=!0,this._surface.setTileTreeDirty()}getLayerInfo(e,t){return this.layerInfo[t][e]}hasLayerData(e,t){const i=this.layerInfo[t][e];return!(!i?.data||i.dataInvalidated)}get updating(){if(this.hasPendingUpdates)return!0;for(const e of L){const t=this.layerInfo[e];for(const e of t)if(e.loadingAgent&&e.loadingAgent!==$&&e.loadingAgent.updating)return!0}return!1}_isSuspended(e){return!!this.hasPendingUpdate(K.SPLIT)||e!==x.ELEVATION&&!this.loadable}get hasPendingUpdates(){return 0!==this._pendingUpdates}hasPendingUpdate(e){return(this._pendingUpdates&e)===e}setPendingUpdate(e){const t=this._pendingUpdates;return this._pendingUpdates|=e,e===K.SPLIT||e===K.MERGE?this._surface.setTileTreeDirty():this._surface.requestUpdate(),t!==this._pendingUpdates}resetPendingUpdate(e){return!!this.hasPendingUpdate(e)&&(this._pendingUpdates&=~e,!0)}requestLayerData(e,i,s){const n=this.layerInfo[i][e];if(n.waitingAgents.has(s))return console.warn("agent already requested this piece of map data (tile %s, agent tile %s, layer: %d/%d)",this._lij.toString(),s.tile.lij.toString(),i,e),!0;if(n.waitingAgents.push(s),n.data&&!n.dataInvalidated){console.warn("agent requested existing data (tile %s, agent tile %s, layer: %d/%d)",this._lij.toString(),s.tile.lij.toString(),i,e);const t=n.data&&"type"in n.data&&"vector-tile"===n.data.type;return s.dataArrived(this,t),!0}if(n.requestPromise)return!0;t(n.requestAbort),n.requestAbort=new AbortController;const r=this._surface.requestTileData(this,e,i,n.requestAbort);if(!r)return n.requestAbort=null,!1;const a=()=>{n.requestPromise===r&&(n.requestPromise=null,n.requestAbort=null)};return n.requestPromise=r,r.then(a,a),!0}get isLeaf(){return null==this._children[0]}hasLij(e){return this._lij[0]===e[0]&&this._lij[1]===e[1]&&this._lij[2]===e[2]}findByLij(e){if(this.hasLij(e))return this;const t=this._children;if(!t[0])return null;return t[0].findByLij(e)||t[1].findByLij(e)||t[2].findByLij(e)||t[3].findByLij(e)}distanceToSquared(e){return n(s(me,m(this._center[oe.MIDDLE]),e))}containsPoint(e){const t=this.extent;return e[0]>=t[0]&&e[1]>=t[1]&&e[0]<=t[2]&&e[1]<=t[3]}containsPointXY(e,t){const i=this.extent;return e>=i[0]&&t>=i[1]&&e<=i[2]&&t<=i[3]}unrequestLayerData(e,t,i){const s=this.layerInfo[t][e],n=s.waitingAgents,r=null!=n.removeUnordered(i);j(r,"agent has not requested this piece of map data"),n.length<1&&(s.abortRequest(),this.setMemoryDirty())}dataArrived(e,t,i){const s=null!=i&&"type"in i&&"vector-tile"===i.type,n=this.layerInfo[t][e];n.data=i,n.dataInvalidated=!1,n.waitingAgents.forAll((e=>e.dataArrived(this,s))),n.waitingAgents.clear(),this.setMemoryDirty()}dataMissing(e,t,i){i.notInTilemap||console.error(`Tile ${this._lij.toString()} layer ${t}/${e} error ${i}`);const s=this.layerInfo[t][e];s.dataMissing=!0,s.waitingAgents.forAll((e=>e.dataMissing())),s.waitingAgents.clear(),this.setMemoryDirty()}updateRenderData(e,t,i){switch(i&&this.forEachLoadedNeighbor((i=>i.updateRenderData(e,t))),e){case x.MAP:return this._updateTexture(t);case x.ELEVATION:return this._updateGeometry()}}_updateTexture(e){this.renderData&&(this.resetPendingUpdate(e===E.FADING?K.TEXTURE_NOFADING:K.TEXTURE_FADING),this.setPendingUpdate(e===E.FADING?K.TEXTURE_FADING:K.TEXTURE_NOFADING))}_updateGeometry(){this.setPendingUpdate(K.GEOMETRY);for(const e of this.layerInfo[x.ELEVATION])e.pendingUpdates|=K.GEOMETRY}invalidateLayerData(e,t){this.layerInfo[t][e].invalidateSourceData(),this.restartAgents(t)}computeElevationBounds(){const e=this._elevationBoundsMin,t=this._elevationBoundsMax;let i=1/0,s=-1/0;const n=this.layerInfo[x.ELEVATION];let r=!0;for(const a of n)null!=a.elevationBounds&&(i=Math.min(i,a.elevationBounds.min),s=Math.max(s,a.elevationBounds.max),a.elevationBounds.hasNoDataValues||(r=!1));r&&(i=Math.min(i,0),s=Math.max(s,0)),e===i&&t===s||(this._elevationBoundsMin=i,this._elevationBoundsMax=s,this.updateRadiusAndCenter(),this._surface.setTileTreeDirty())}_updateCenter(){const e=this._elevationBoundsMin,t=this._elevationBoundsMax,i=.5*(e+t),s=this._center;a(me,this.up,i),o(m(s[oe.MIDDLE]),this.centerAtSeaLevel,me),a(me,this.up,e),o(s[oe.TOP],this.centerAtSeaLevel,me),a(me,this.up,t),o(s[oe.BOTTOM],this.centerAtSeaLevel,me)}findElevationBoundsForLayer(e,t){const i=this.layerInfo[x.ELEVATION][e],s=b(this.level),n=Math.max(this.elevationLevel-s,0),r=i.elevationBounds;if(null!=r&&r.level>=t&&r.level<=n)return;const a=this._surface.layerViewByIndex(e,x.ELEVATION),o=U(a);if(!Z(this,o,!1))return;const l=ae;let h=!1;const u=i.data;if(u&&u.level<=n){const e=i.data;l.min=e.samplerData.data.minValue,l.max=e.samplerData.data.maxValue,l.hasNoDataValues=e.samplerData.data.hasNoDataValues,l.level=this.level,h=!0}else{let t,i,r=0;for(let a=this._parent;a&&(!i||r<s)&&(r=this.elevationLevel-a.level,t=i||t,i=a.layerInfo[x.ELEVATION][e].data,!(!i&&t&&a.level<=n));a=a.parent);i=i||t,i&&(i.computeMinMaxValue(this._lij[0],this._lij[1],this._lij[2],l),l.min!==1/0&&(l.level=i.level,h=!0))}h&&(null==i.elevationBounds&&(i.elevationBounds=new T),i.elevationBounds.copyFrom(l))}modifyLayers(e,t,i){const s=this.layerInfo[i];for(const a of s)a.loadingAgent&&a.loadingAgent!==$&&(se(a.loadingAgent),a.loadingAgent=null),a.waitingAgents.clear();for(let a=0;a<s.length;++a)void 0===e[a]&&s[a].release();const n=new Array(...s),r=t.length;s.length=r;for(let a=0;a<r;a++){const e=t[a];s[a]=e>-1?n[e]:J.acquire(this._surface.upsampleInfoPool)}this.setMemoryDirty()}restartAgents(e){this.renderData&&(this._createOrUpdateAgents(0,e),this.updateRenderData(e,E.FADING))}updateAgents(e){if(this.renderData){const t=this.layerInfo[e];for(const e of t)e.loadingAgent===$&&(e.loadingAgent=null);this._createOrUpdateAgents(0,e)}}updateAgentSuspension(){for(const e of L){const t=this._isSuspended(e);for(const i of this.layerInfo[e])i.loadingAgent&&i.loadingAgent!==$&&(i.loadingAgent.setSuspension(t),i.loadingAgent===$&&this.updateRenderData(e,E.FADING))}}removeLayerAgent(e,t){const i=this.layerInfo[t][e];i.loadingAgent&&i.loadingAgent!==$&&i.loadingAgent.dispose(),i.loadingAgent=null}agentDone(e,t){const i=this.layerInfo[t][e];i.loadingAgent=$,i.data||null!=i.upsampleInfo||this._createOrUpdateAgents(e+1,t)}_hasBlendableAncestor(e){return"normal"!==e.blendMode||y(e.parent)&&this._hasBlendableAncestor(e.parent)}_hasBlendModes(e,t,i){for(let s=e;s<t;++s){const e=this._surface.layerViewByIndex(s,i);if(C(e)&&"normal"!==e?.layer?.blendMode||y(e?.layer?.parent)&&this._hasBlendableAncestor(e?.layer?.parent))return!0}return!1}_createOrUpdateAgents(e,t){const i=this.layerInfo[t];if(0===i.length)return;const s=this._isSuspended(t);for(let n=e;n<i.length;++n){const r=i[n];let a=!1;const o=this._surface.layerViewByIndex(n,t),l=U(o);if(r.loadingAgent?Z(this,l,!1)?(r.loadingAgent!==$&&r.loadingAgent.setSuspension(s),r.loadingAgent!==$&&(a=r.loadingAgent.update())):r.dispose():Z(this,l,!1)&&(r.loadingAgent=ie(this,n,t,s),a=r.loadingAgent.startLoading(),a?r.loadingAgent===$&&this.setPendingUpdate(K.GEOMETRY):(se(r.loadingAgent),r.loadingAgent=$)),r.loadingAgent===$&&this.updateRenderData(t,E.FADING),!this._hasBlendModes(e,i.length,t)&&a&&o.isOpaque)return}}_isWithinExtent(e){const t=this.extent;return t[0]>=e[0]&&e[2]>=t[2]&&t[1]>=e[1]&&e[3]>=t[3]}intersectsExtent(e){const t=this.extent;return t[2]>=e[0]&&e[2]>=t[0]&&t[3]>=e[1]&&e[3]>=t[1]}getElevationVerticesPerSide(t){const i=this.elevationLevel-this.level,s=Math.max(this.level-t,b(this.level)-i),n=e(1+(this.maxTesselation>>s),2,this.maxTesselation+1),r=this.getDefaultVerticesPerSide();return Math.max(n,r)}get test(){return{cachedMemory:this._cachedMemory}}_findLIJ(e,t){if(!e)return null;const i=this.surface.rootTiles;if(null!=i)for(const s of i)if(le(s,e)){let i=s,n=e[0]-i.level-1;for(;n>=0&&!i.isLeaf&&!t(i);){const t=e[1]>>n&1,s=e[2]>>n&1;i=i.children[2*t+s],n--}return t(i)?i:null}return null}findNeighborTile(e,t){const i=this._lij,s=this.getNeighborLIJ(i,e);return s?he(i,s)?t(this)?this:null:this._findLIJ(s,t):null}findCorner(e,t){const i=e===D.NORTH_EAST?1:e===D.NORTH_WEST?0:e===D.SOUTH_WEST?2:3;let s=this;for(;s.children[0]&&(!t||!t(s));)s=s.children[i];return s}findNeighborCornerTileExact(e,t){return this.findNeighborTile(e,(e=>t(e)||e.level===this.level))?.findCorner(B(e),t)||null}forAllSubtreeOnSide(e,t){const i=e===D.NORTH?[0,1]:e===D.NORTH_EAST?[1]:e===D.EAST?[1,3]:e===D.SOUTH_EAST?[3]:e===D.SOUTH?[2,3]:e===D.SOUTH_WEST?[2]:e===D.WEST?[0,2]:[0],s=e=>{const n=e.children;!t(e)&&n[0]&&i.forEach((e=>s(n[e])))};s(this)}getNeighborEdgeStartVertexIndex(e,t){if(!t)return 0;const i=this.level-t.level;if(P(!R||i>=0),0===i)return 0;const s=2**i,n=!(1&~e),r=n?0:1,a=t.lij[r+1]*s,o=this._lij[r+1],l=o-a,h=n?s-1-l:l;return R&&(P(a<=o&&o<a+s),P(0<=h&&h<s)),h}forEachLoadedNeighbor(e){const t=this.level,i=e=>e.level===t||e.isLoaded;V.forEach((t=>{const s=this.findNeighborTile(t,i);null!=s&&s!==this&&s.forAllSubtreeOnSide(w(t),(i=>!!i.isLoaded&&(e(i,t),!0)))})),G.forEach((t=>{const s=this.findNeighborTile(t,i)?.findCorner(B(t),(e=>e.isLoaded));P(!s||de(this,s,t)),s?.isLoaded&&e(s,t)}))}getNeighborLIJ(e,t){const i=W(t)?-1:q(t)?1:0,s=F(t)?-1:H(t)?1:0,n=[e[0],e[1]+i,e[2]+s];return n[1]<0?null:this.surface.isGlobal?this.wrapLIJ(n):n[2]<0?null:n}wrapLIJ(e){return!e||e[1]<0||e[1]>=2**e[0]?null:this.surface.wrapEastWest(e)}get westNeighborWestExtent(){return this.extent[0]*(this.isWestEnd?-1:1)}get eastNeighborEastExtent(){return this.extent[2]*(this.isEastEnd?-1:1)}get isEastEnd(){return this._lij[2]===this.surface.lijEastEnd(this.level)-1}get isWestEnd(){return 0===this._lij[2]}get isNorthEnd(){return 0===this._lij[1]}get isSouthEnd(){const e=this.surface.extent,t=e?.[1]??null;return null!=t&&this.extent[1]+c()>=t}checkGeometryWaterproofness(){k&&(P(this.isLoaded),this.renderData?.checkGeometryWaterproofness())}shouldHaveNeighbor(e){const t=this.extent,i=this.surface.rootTilesExtent,s=.25*(t[2]-t[0]);if(W(e)&&t[3]+s>=i[3])return!1;if(q(e)&&t[1]-s<=i[1])return!1;const n=this.surface.isGlobal;return!(!n&&F(e)&&t[0]-s<=i[0])&&!(!n&&H(e)&&t[2]+s>=i[2])}updateDistanceToPOI(e){const t=this._lastPOI;if(this.distanceToPOI>=0&&t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2])return;h(this._lastPOI,e);const i=this._center[oe.MIDDLE],s=e[0]-i[0],n=e[1]-i[1],r=e[2]-i[2];this.distanceToPOI=s*s+n*n+r*r}}function ie(e,t,i,s){const n=i===x.ELEVATION?re.acquire():ne.acquire();return n.init(e,t,i,s),n}function se(e){e.dispose(),e instanceof v?re.release(e):e instanceof S&&ne.release(e)}const ne=new i(S),re=new i(v),ae=new T;var oe;function le(e,t){const i=e.lij,s=t[0]-i[0];return!(s<0)&&(t[1]>>s===i[1]&&t[2]>>s===i[2])}function he(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function ue(e,t,i){if(null==e||null==t)return!1;if(0===e.level&&0===t.level){if(e.isEastEnd&&t.isWestEnd&&i===D.EAST)return!0;if(e.isWestEnd&&t.isEastEnd&&i===D.WEST)return!0}const s=Math.max(1e-6*(e.extent[2]-e.extent[0]),1);switch(i){case D.NORTH:return X(e.extent[3],t.extent[1],s);case D.SOUTH:return X(e.extent[1],t.extent[3],s);case D.EAST:return X(e.extent[2],t.extent[0],s)||X(e.extent[2],-t.extent[0],s);case D.WEST:return X(e.extent[0],t.extent[2],s)||X(e.extent[0],-t.extent[2],s)}}function de(e,t,i){return null!=e&&null!=t&&t!==e&&(e.level>=t.level?ce(e,t,i):ce(t,e,B(i)))}function ce(e,t,i){P(e.level>=t.level);const s=Y(i),n=z(i),r=e.extent,a=t.extent,o=[s?r[0]:r[2],n?r[3]:r[1]],l=[s?a[2]:a[0],n?a[1]:a[3]],h=1e-5*(r[2]-r[0]),u=X(o[0],l[0],h)||e.surface.isGlobal&&X(o[0],-l[0],h),d=X(o[1],l[1],h);if(u&&d)return!0;if(e.level===t.level)return P(!1),!1;if(!u&&!d)return P(!1),!1;const c=u?ge(a[1],a[3],r[1],r[3],h):ge(a[0],a[2],r[0],r[2],h);return P(c),c}function ge(e,t,i,s,n){return e-n<=i&&i<=s&&s<=t+n}!function(e){e[e.TOP=0]="TOP",e[e.MIDDLE=1]="MIDDLE",e[e.BOTTOM=2]="BOTTOM"}(oe||(oe={}));const pe=u(),fe=u(),_e=u(),me=u();export{oe as CenterPosition,te as Tile,de as isCornerNeighbor,ue as isEdgeNeighbor,he as lijEquals};
