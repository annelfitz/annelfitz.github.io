/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{lerp as t}from"../../../core/mathUtils.js";import{n as e,s as i,g as s,h as o,H as n,b as r,k as l,o as a,z as h}from"../../../chunks/vec32.js";import{create as u}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{lonLatToSphericalPCPF as d}from"../../../geometry/projection/lonLatToSphericalPCPF.js";import{newDoubleArray as c}from"../../../geometry/support/DoubleArray.js";import{intersectsSphere as p,numPlanes as f,PlaneIndex as m}from"../../../geometry/support/frustum.js";import{c as g,g as x}from"../../../chunks/sphere.js";import{PatchType as $}from"./interfaces.js";import{TileFrustumVisibility as _}from"./ITile.js";import{createSphericalGlobePatch as v,updateCornerSpherical as M,updateEdgesAndCornersSpherical as S,updateEdgeElevationsAndResolutionsSpherical as b}from"./PatchGeometryFactory.js";import{enableTerrainInternalChecks as j,internalAssert as T,almostEquals as E}from"./terrainUtils.js";import{Tile as H,CenterPosition as I}from"./Tile.js";import{compareTilesByLij as B}from"./tileUtils.js";class D extends H{constructor(t,e,i,s,o){super(),this._convexHull=new Array(24),this._boundingSphere=g(),this._baseUsedMemory=1816,this.init(t,e,i,s,o)}init(i,s,o,n,r){super.init(i,s,o,n,r);const l=this.ellipsoid.radius,a=this.extentInRadians[0],h=this.extentInRadians[1],u=this.extentInRadians[2],c=this.extentInRadians[3],p=t(h,c,.5),f=t(a,u,.5),m=0===i?0:Math.min(Math.abs(h),Math.abs(c));this._edgeLen=(u-a)*Math.cos(m)*l,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=l-Math.sqrt(l*l-this._edgeLen2/4),d(this.centerAtSeaLevel,f,p,this.ellipsoid.radius),e(this.up,this.centerAtSeaLevel),this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateBoundingVolumes();const t=this._center;if(0===this.lij[0])i(x(t[I.MIDDLE]),0,0,0),i(t[I.TOP],0,0,0),i(t[I.BOTTOM],0,0,0),t[I.MIDDLE][3]=this.ellipsoid.radius+this.elevationBoundsMax;else{this._updateCenter();const e=t[I.MIDDLE],i=this.convexHull;let s=0;for(let t=0;t<8;++t)s=Math.max(s,y(x(e),i,3*t));t[I.MIDDLE][3]=Math.sqrt(s)}}_calculateFrustumVisibilityStatus(t){if(!p(t,this._boundingSphere))return _.OUTSIDE;if(this.lij[0]<10)return _.INTERSECTS;const e=this.convexHull,i=this.surface.view.state.camera.near;let s=!0;for(let o=0;o<f;o++){const n=o===m.NEAR,r=t[o],l=r[0],a=r[1],h=r[2],u=r[3]-(n?i:0);let d=!1;for(let t=0;t<8;++t){const i=3*t;if(l*e[i]+a*e[i+1]+h*e[i+2]+u<0){if(d=!0,!s)break}else s=!1}if(!d)return _.OUTSIDE}return s?_.INSIDE:_.INTERSECTS}computeElevationBounds(){super.computeElevationBounds(),this._updateBoundingVolumes()}createGeometry(){v(this.renderData,this._getPatchType()),this._updateBoundingVolumes(),this.setMemoryDirty()}_updateBoundingVolumes(){this._updateConvexHull(),this._updateBoundingSphere(),j&&this._checkBVs()}_updateBoundingSphere(){const t=this._boundingSphere,e=x(t),r=this.elevationBoundsMin,l=this.elevationBoundsMax,a=this.ellipsoid.radius,h=l;if(0===this.level)i(e,0,0,0),t[3]=a+h;else{const i=this.extentInRadians,h=.5*(i[0]+i[2]),u=i[1],d=i[3];O(A,h,u,a),O(V,h,d,a),s(e,A,V);o(e,e,(a+.5*(r+l))/n(e));const c=this.convexHull;let p=0;const f=(t,e)=>{const i=t[0]-c[3*e],s=t[1]-c[3*e+1],o=t[2]-c[3*e+2];return Math.sqrt(i*i+s*s+o*o)};for(let t=0;t<8;++t){const i=f(e,t);p=Math.max(p,i)}const m=p;t[3]=m+2}}_updateConvexHull(){const t=this.extentInRadians,i=this.ellipsoid.radius;if(0===this.level)return;const a=this.elevationBoundsMin,d=this.elevationBoundsMax,c=this._getPatchType(),p=this.surface.isWebMercator,f=p&&c===$.HAS_NORTH_POLE,m=p&&c===$.HAS_SOUTH_POLE,g=m||f,x=Math.PI/2,_=t[0],v=t[2],M=m?-x:t[1],S=f?x:t[3],b=.5*(_+v),j=a,H=i+(g?Math.min(0,j-1):j),I=(t,e,i)=>O(t,e,i,H),B=u(),D=u(),L=u(),y=u();I(B,_,M),I(D,_,S),I(L,v,S),I(y,v,M);const R=(t,e)=>{for(let i=0;i<3;++i)this._convexHull[3*e+i]=t[i]};R(B,0),R(D,1),R(L,2),R(y,3);const A=d,V=i+(g?Math.max(0,A+1):A),C=u(),N=u(),U=u();O(N,b,S,H),O(U,b,M,H),s(C,N,U),e(C,C);const k=u(),F=u(),w=(t,i)=>{h(F,t,i),e(F,F);const n=-l(t,k)/l(F,k);T(n>=0),o(F,F,n),s(t,t,F)};if(2**this.lij[0]>2*this.lij[1]){const t=U,i=u();r(i,P,t),e(i,i),r(k,t,i),e(k,k),T(E(l(k,t)/n(t),0)),w(B,D),w(y,L),R(B,0),R(y,3)}else if(2**this.lij[0]!==2*this.lij[1]){const t=N,i=u();r(i,P,t),e(i,i),r(k,i,t),e(k,k),w(D,B),w(L,y),R(D,1),R(L,2)}const q=(t,e)=>{const i=V/l(e,C);for(let s=0;s<3;++s)this._convexHull[3*t+s]=e[s]*i};q(4,B),q(5,D),q(6,L),q(7,y)}_getPatchType(){const t=this.lij[1],e=0===t,i=t===(1<<this.level)-1;return e?i?$.HAS_BOTH_POLES:$.HAS_NORTH_POLE:i?$.HAS_SOUTH_POLE:$.REGULAR}intersectsRay(t,e,i,s){const o=this._boundingSphere,n=o[3]+i,r=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],l=o[0]-t[0],a=o[1]-t[1],h=o[2]-t[2],u=(l*e[0]+a*e[1]+h*e[2])/r,d=e[0]*u-l,c=e[1]*u-a,p=e[2]*u-h;return d*d+c*c+p*p<n*n}getDefaultVerticesPerSide(){return this.level<L.length?L[this.level]+1:2}updateCornerElevations(){M(this.renderData),this._updateBoundingVolumes()}updateEdgeElevations(){S(this.renderData),this._updateBoundingVolumes()}updateEdgeElevationsAndResolutions(){b(this.renderData),this._updateBoundingVolumes()}_checkBVs(){if(!j)return;if(this.level<=2)return;const t=this._boundingSphere,i=t[3],o=x(t),d=u(),p=this.ellipsoid.radius,f=this.elevationBoundsMin,m=this.elevationBoundsMax,g=p+f,$=1,_=0,v=this._center[I.MIDDLE][3],M=this.convexHull,S=(t,e)=>{for(let i=0;i<3;++i)t[i]=M[3*e+i]};{const t=u(),i=u(),s=u(),o=u(),n=u(),a=(a,u,d,c)=>{S(i,a),S(s,u),S(o,d),h(i,i,s),h(o,o,s),r(t,i,o),e(t,t);const p=l(t,s);S(n,c);const f=l(t,n),m=Math.abs(f-p);T(E(m,0),`Non coplanar ${a},${u},${d},${c} diff = ${m}`)};a(0,1,2,3),a(4,5,6,7),a(0,1,4,5),a(1,2,5,6),a(2,3,6,7),a(3,0,7,4)}const b=c(24),H=(t,e,i)=>{const s=4*t;for(let o=0;o<3;++o)b[s+o]=e[o];b[s+3]=i},D=u(),L=u(),y=u(),P=u(),A=(t,i,s,o)=>{S(D,i),S(L,s),S(y,o),h(D,D,L),e(D,D),h(y,y,L),e(y,y),r(P,D,y),e(P,P);const n=l(P,L);H(t,P,n)};A(0,0,1,2),A(1,1,0,4),A(2,1,5,2),A(3,3,2,6),A(4,4,0,3),A(5,4,6,5);const V=1,C=(t,e,i,s)=>{const o=4*t;return b[o]*e+b[o+1]*i+b[o+2]*s-b[o+3]},N=(t,e,i,s)=>C(t,e,i,s)>=-V,U=(t,e)=>N(t,e[0],e[1],e[2]),k=2**this.lij[0]>2*this.lij[1],F=(t,e,s)=>Math.sqrt(R(t,e,s,o[0],o[1],o[2]))<i,w=t=>F(t[0],t[1],t[2]),q=(t,e)=>F(t[e],t[e+1],t[e+2]),G=this.extentInRadians,z=.5*(G[0]+G[2]),W=G[1],J=G[3],K=u(),Q=u();O(K,z,J,g),O(Q,z,W,g);const X=k?"Upper":"Lower";let Y=!0;for(let e=0;e<6;++e){for(let t=0;t<8;++t){const i=3*t,s=N(e,M[i],M[i+1],M[i+2]);Y&&=s,T(s,`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}T(U(e,Q),`Tile[${this.lij}] (${X}) bottom mid outside of plane ${e}`),T(U(e,K),`Tile[${this.lij}] (${X}) top mid outside of plane ${e}`)}T(Y,"Not all convex hull points are inside  convex hull polyhedron"),T(w(Q),`Tile[${this.lij}] (${X}) bottom mid outside of bounding sphere`),T(w(K),`Tile[${this.lij}] (${X}) top mid outside of bounding sphere`);for(let e=0;e<8;++e){const t=q(M,3*e);T(t,`Tile[${this.lij}] Convex hull point ${e} outside of bounding sphere`)}for(let e=0;e<6;++e)for(let t=0;t<8;++t){const i=3*t;N(e,M[i],M[i+1],M[i+2])||console.error(`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}const{extentInRadians:Z}=this,tt=Math.max(Z[2]-Z[0],Z[3]-Z[1]),et=Math.round(tt*p),{renderData:it}=this;if(!it)return;const{geometry:st,geometryState:ot,localOrigin:nt}=it,rt=st.vertexAttributes?.position;if(!rt)return;const lt=u(),at=st.numVerticesPerSide-2,{indices:ht,indexCount:ut,edgeVerticesStartIndex:dt,poleVerticesStartIndex:ct}=st;if(!ht)return;const pt=new Set;for(let e=0;e<ut;++e){const t=ht[e];if(pt.has(t))continue;pt.add(t);const r=t<ct,l=t>=dt;let h=!1,u=-1;if(l){let e=dt;for(let i=0;i<4;++i){const s=ot.edgeResolutions[i];if(t===e||t===e+s-1){h=!0;break}if(e+=s,t<e){u=i;break}}}const c=l?ot.edgePeerNeighbors[u]:null,g=l&&c&&B(this,c)>0;rt.getVec(t,d),s(lt,d,nt);const x=n(lt)-p;let M=0,S=!1;const b=f-x,j=x-m,T=b>$,E=j>$,H=T||E,I=()=>{const e=r?"internal":l&&!h?"edge":h?"corner":"pole";return`Tile[${this.lij}].vertex[${t}]:${e}`+(T?"(below)":E?"(above)":"")+(g?"(Neighbor)":"")},D=a(lt,o);if(D>=i+_){const t=D-i;H||(console.error(`${I()} is out of the bounding sphere by ${t.toFixed(0)} / ${i.toFixed(0)}[tol=${_}] h=${x.toFixed(0)} / [${f.toFixed(0)}..${m.toFixed(0)}] (${(t/i).toFixed(0)})`),S=!0)}for(let e=0;e<6;++e)if(!N(e,lt[0],lt[1],lt[2])){const s=C(e,lt[0],lt[1],lt[2]),o=t%at,n=(t-o)/at;0===e&&b||5===e&&j||(console.error(`${I()} (${o},${n})|${at}] is out of the bounding trapezoid plane ${e} h=${Math.round(x)} / [${Math.round(f)}..${Math.round(m)}] dist=${Math.round(s)} radii = ${Math.round(i)}/${Math.round(v)}} : maxL = ${et}`),++M)}if(S||M>0)break}}get convexHull(){return this._convexHull}}const L=[128,64,64,32,16,8,8,4];function y(t,e,i){return R(t[0],t[1],t[2],e[i],e[i+1],e[i+2])}function R(t,e,i,s,o,n){const r=s-t,l=o-e,a=n-i;return r*r+l*l+a*a}const O=(t,e,i,s)=>{const o=Math.cos(e),n=Math.sin(e),r=Math.cos(i),l=Math.sin(i);t[0]=s*r*o,t[1]=s*r*n,t[2]=s*l},P=[0,0,1],A=u(),V=u();export{D as SphericalPatch};
