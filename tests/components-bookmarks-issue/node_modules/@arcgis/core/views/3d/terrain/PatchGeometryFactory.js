/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{isPowerOfTwo as e,clamp as t}from"../../../core/mathUtils.js";import{empty as n}from"../../../geometry/support/aaBoundingBox.js";import{fromValues as o}from"../../../geometry/support/aaBoundingRect.js";import{sampleElevation as s}from"./ElevationData.js";import{PatchType as r}from"./interfaces.js";import{NeighborIndex as i}from"./ITile.js";import{encodeUVInBuffer as a}from"./PatchGeometry.js";import{PatchGeometryLUT as c}from"./PatchGeometryLUT.js";import{neighborTileIfLoadedOrSelf as l,zeroToFour as u}from"./PatchRenderData.js";import{internalAssert as d,enableTerrainInternalChecks as f,neighborEdgeIndices as m,almostEquals as g}from"./terrainUtils.js";import{isCornerNeighbor as p}from"./Tile.js";import{compareTilesByLij as x}from"./tileUtils.js";import{compressNormal as h}from"../webgl-engine/lib/Normals.js";const M=65536;function S(e,t){const{tile:o,geometry:s,geometryState:i}=e,{extentInRadians:a,surface:c}=o,{isWebMercator:l,renderer:u}=c,{numVerticesPerSide:d,wireframe:f}=i,m=d-1,g=(d-2)**2,p=l&&(t===r.HAS_SOUTH_POLE||t===r.HAS_BOTH_POLES),x=l&&(t===r.HAS_NORTH_POLE||t===r.HAS_BOTH_POLES),h=((p?1:0)+(x?1:0))*pe*d,M=fe(i),S=g+h+4*M,L=u.tileGeometryCache.acquire(S);s.numVerticesPerSide=d,s.vertexAttributes=L,s.maxEdgeVertexCount=M;const{boundingBox:B}=s;n(B);const I=O(e);re.update(m,a,I),v(e),s.poleVerticesStartIndex=g;const b=y(e,p,x);s.edgeVerticesStartIndex=g+h,X(e),V(e),W(s,b,f),e.intersectionData=null}function y(e,t,n){const{tile:o,localOrigin:s,geometry:r}=e,{extent:i,ellipsoid:c}=o,{boundingBox:l,numVerticesPerSide:u,vertexAttributes:d,poleVerticesStartIndex:f}=r,m=u-1,g=s[0],p=s[1],x=s[2],M=c.radius,S=i[1],y=i[3],v=[];let L=f;const B=(e,t)=>{const n=t*u;de(-g,-p,e*M-x,l),v.push(new oe(1===e,n,1===e?0:2,L,pe));const o=P(-1===e?S:y,M),s=e*Math.PI/2-o,r=.99*(1===e?1:-1),i=M+0,{position:c,uv0:f}=d,{typedBuffer:B,typedBufferStride:I}=d.normalCompressed;for(let u=1;u<=pe;++u){const e=o+s*(u/pe),t=Math.cos(e),n=Math.sin(e);for(let o=0;o<=m;o++){const e=o/m,s=re.sinLonLUT[o],u=re.cosLonLUT[o]*t,d=s*t,M=n,S=u*i-g,y=d*i-p,v=M*i-x;de(S,y,v,l),c.setValues(L,S,y,v),a(f,L,e,r),h(B,L,u,d,M,I),++L}}};return t&&B(-1,0),n&&B(1,m),v}function v(e){const{tile:t}=e;if(!t.intersectsClippingArea)return;const{geometry:n,geometryState:o,localOrigin:r}=e,{numVerticesPerSide:i,samplerData:c}=o,l=i-2,u=i-1,{vertexAttributes:d,boundingBox:f}=n,m=d.position,g=d.uv0,{typedBuffer:p,typedBufferStride:x}=d.normalCompressed,{extent:M}=t,S=M[0],y=M[2],v=M[1],L=M[3],B=t.ellipsoid.radius,I=r[0],V=r[1],b=r[2],C=m.typedBuffer,P=m.typedBufferStride,A=1/u;let E=0;if(1<=l){const e=A,t=v*(1-e)+L*e,n=re.sinLatLUT[1],o=re.cosLatLUT[1];for(let r=1;r<=l;r++){const i=r*A,l=S*(1-i)+y*i,u=re.sinLonLUT[r],d=re.cosLonLUT[r],m=B+s(l,t,c),p=m*d*o-I,x=m*u*o-V,h=m*n-b;de(p,x,h,f);const M=(r-1)*P;C[M]=p,C[M+1]=x,C[M+2]=h,a(g,r-1,i,e)}}for(let O=1;O<=l;O++){const e=O*A,t=v*(1-e)+L*e,n=re.sinLatLUT[O],o=re.cosLatLUT[O],r=O+1,i=r*A,d=v*(1-i)+L*i,m=re.sinLatLUT[r],M=re.cosLatLUT[r],T=re.sinLonLUT[0],D=re.cosLonLUT[0],R=B+s(S,t,c);let U=D*o*R-I,w=T*o*R-V,N=n*R-b;const j=E*P;let F=C[j],H=C[j+1],q=C[j+2];for(let L=1;L<=l;L++){const e=L*A,r=S*(1-e)+y*e,T=re.sinLonLUT[L],D=re.cosLonLUT[L];let R=0,j=0,_=0;if(L<l){const e=(E+1)*P;R=C[e],j=C[e+1],_=C[e+2]}else{const e=re.sinLonLUT[u],r=re.cosLonLUT[u],i=B+s(y,t,c);R=r*o*i-I,j=e*o*i-V,_=n*i-b}const W=U,G=w,k=N;U=F,w=H,N=q,F=R,H=j,q=_;const z=R-W,J=j-G,K=_-k;let Q=0,X=0,Y=0;if(O>1){const e=(E-l)*P;Q=C[e],X=C[e+1],Y=C[e+2]}else{const e=re.sinLatLUT[0],t=re.cosLatLUT[0],n=B+s(r,v,c);Q=D*t*n-I,X=T*t*n-V,Y=e*n-b}const Z=B+s(r,d,c),$=D*M*Z-I,ee=T*M*Z-V,te=m*Z-b;if(O<l){const t=E+l,n=t*P;C[n]=$,C[n+1]=ee,C[n+2]=te,de($,ee,te,f),a(g,t,e,i)}const ne=Q-$,oe=X-ee,se=Y-te;let ie=D*o,ae=T*o,ce=n;ce*ce<.999&&(ie=K*oe-J*se,ae=z*se-K*ne,ce=J*ne-z*oe);const le=1/Math.sqrt(ie*ie+ae*ae+ce*ce);h(p,E,ie*le,ae*le,ce*le,x),++E}}}function L(e){e.tile.intersectsClippingArea&&(V(e),te(e),e.intersectionData=null)}function B(e){e.tile.intersectsClippingArea&&(Y(e),V(e),te(e),ne(e),e.intersectionData=null)}function I(e){e.tile.intersectsClippingArea&&(C(e),b(e,!0),te(e),e.intersectionData=null)}function V(e){e.tile.intersectsClippingArea&&(C(e),b(e))}function b(t,n=!1){const{geometry:o,geometryState:r,tile:i,localOrigin:c}=t,{level:u,extent:p,extentInRadians:h,ellipsoid:M}=i,S=M.radius,y=h[0],v=h[2],L=h[1],B=h[3],{samplerData:I}=r,V=p[0],b=p[2],C=p[1],P=p[3],A=O(t),{boundingBox:E,vertexAttributes:T}=o,D=c[0],R=c[1],U=c[2],w=T.position,N=w.typedBuffer,j=w.typedBufferStride,F=T.uv0;for(let O=0;O<4;++O){const c=1===O||3===O,h=r.edgeResolutions[O];d(e(h));const M=h+1,T=l(i,r.edgePeerNeighbors[O]);if(ce(i,T,O)){Z(t,O,T);continue}const w=null!=T;d(!w||T.level===i.level),d(!w||x(i,T)<=0);const H=T?.renderData,q=H?.geometryState;if(f){const e=i.surface;if(!T&&e&&!e.updatingRootTiles){const t=m[O],n=i.findNeighborTile(t,(e=>e.isLoaded||e.isLeaf||e.level===i.level));n?n.intersectsClippingArea&&(d(!n.isLoaded),d(!n.isLeaf),d(n.level===u)):d(null==e?.rootTiles||!i.shouldHaveNeighbor(t))}}const _=1===O?p[2]:p[0],W=T?.extent,G=W&&c?1===O?W[0]:W[2]:_,k=0===O?p[3]:p[1],z=1===O?1:0,J=0===O?1:0,K=1===O?v:y,Q=0===O?B:L,X=Math.sin(K),Y=Math.cos(K),$=Math.sin(Q),ee=Math.cos(Q),te=q?.samplerData,ne=w?(e,t,n)=>.5*(s(e,t,I)+s(n,t,te)):(e,t,n)=>s(e,t,I),oe=o.outerEdgesOffsetAndLength[2*O+0],se=n&&M>3?M-3:1,re=null!=I&&I.some((e=>null!=e)),ie=null!=te&&te.some((e=>null!=e)),ae=re||ie,le=1/h,ue=oe;d(!W||g(W[2]-W[0],p[2]-p[0]));(()=>{const e=1===O?-1:3===O?1:0,t=0===O?-1:2===O?1:0,n=(p[2]-p[0])*le,r=e*n,i=t*n,l=c?e*((v-y)*le):0,u=c?0:t*le,d=J,f=c?K+l:K,m=c?Math.sin(f):X,g=c?Math.cos(f):Y,x=c?K-l:K,h=c?Math.sin(x):X,L=c?Math.cos(x):Y,B=c?Q:A(d+u),T=c?$:Math.sin(B),H=c?ee:Math.cos(B),q=c?Q:A(d-u),W=c?$:Math.sin(q),Z=c?ee:Math.cos(q);let oe=0,re=0,ie=0;{const e=0*le,t=c?_:V*(1-e)+b*e,n=c?G:t,o=c?C*(1-e)+P*e:k,s=c?K:y*(1-e)+v*e,r=c?X:Math.sin(s),i=c?Y:Math.cos(s),a=c?A(e):Q,l=c?Math.sin(a):$,u=c?Math.cos(a):ee,d=S+ne(t,o,n);oe=i*u*d,re=r*u*d,ie=l*d}let ce=0,fe=0,me=0;{const e=1*le,t=c?_:V*(1-e)+b*e,n=c?G:t,o=c?C*(1-e)+P*e:k,s=c?K:y*(1-e)+v*e,r=c?X:Math.sin(s),i=c?Y:Math.cos(s),a=c?A(e):Q,l=c?Math.sin(a):$,u=c?Math.cos(a):ee,d=S+ne(t,o,n);ce=i*u*d,fe=r*u*d,me=l*d}for(let p=1;p<M-1;p+=se){let e=0,t=0,n=0;{const o=(p+1)*le,s=c?_:V*(1-o)+b*o,r=c?G:s,i=c?C*(1-o)+P*o:k,a=c?K:y*(1-o)+v*o,l=c?X:Math.sin(a),u=c?Y:Math.cos(a),d=c?A(o):Q,f=c?Math.sin(d):$,m=c?Math.cos(d):ee,g=S+ne(s,i,r);e=u*m*g,t=l*m*g,n=f*g}const l=e,u=t,d=n,f=ce,x=fe,M=me;ce=l,fe=u,me=d;{const e=ue+p,t=e*j,n=f-D,o=x-R,s=M-U;N[t]=n,N[t+1]=o,N[t+2]=s,de(n,o,s,E);const r=p*le;a(F,e,c?z:r,c?r:J)}const B=oe,q=re,se=ie;oe=f,re=x,ie=M;const ge=f,pe=x,xe=M,he=1/Math.sqrt(ge*ge+pe*pe+xe*xe),Me=xe*he;let Se=0,ye=0,ve=0;if(ae&&Me*Me<.999){let e=0,t=0,n=0;{const o=0===O?-1:1;e=o*(l-B),t=o*(u-q),n=o*(d-se)}{const o=p*le,a=c?_:V*(1-o)+b*o,l=c?G:a,u=c?C*(1-o)+P*o:k,d=c?K:y*(1-o)+v*o,f=c?X:Math.sin(d),x=c?Y:Math.cos(d),M=c?A(o):Q,B=c?Math.sin(M):$,E=c?Math.cos(M):ee;let D=ge,R=pe,U=xe;if(w){const e=S+s(l-r,u-i,te),t=c?E:Z;D=(c?L:x)*t*e,R=(c?h:f)*t*e,U=(c?B:W)*e}{const o=S+s(a+r,u+i,I),l=c?E:H,d=(c?g:x)*l*o,p=(c?m:f)*l*o,h=(c?B:T)*o;w||(D=2*ge-d,R=2*pe-p,U=2*xe-h);const M=3===O?-1:1,y=M*(D-d),v=M*(R-p),L=M*(U-h);Se=n*v-t*L,ye=e*L-n*y,ve=t*y-e*v;const V=1/Math.sqrt(Se*Se+ye*ye+ve*ve);Se*=V,ye*=V,ve*=V}}}else Se=ge*he,ye=pe*he,ve=xe*he;o.setEdgeNormalFromValues(O,p,Se,ye,ve)}})()}}function C(e){$(e)}function P(e,t){return Math.PI/2-2*Math.atan(Math.exp(-e/t))}function A(e,t,n,o){return P(e*(1-o)+t*o,n)}function E(e,t,n){return e*(1-n)+t*n}function O(e){const{tile:t}=e;if(t.surface.isWebMercator){const e=t.extent,n=t.ellipsoid.radius;return t=>A(e[1],e[3],n,t)}const n=t.extentInRadians;return e=>E(n[1],n[3],e)}function T(e,t){const{tile:o,geometryState:s,geometry:r}=e,{extent:i,surface:a}=o,{wireframe:c}=s,l=i[0],u=i[1],d=i[2]-l,f=i[3]-u,{numVerticesPerSide:m,clippingArea:g}=s,p=null!=g?Math.max(0,(g[0]-l)/d):0,x=null!=g?Math.max(0,(g[1]-u)/f):0,h=null!=g?Math.min(1,(g[2]-l)/d):1,M=null!=g?Math.min(1,(g[3]-u)/f):1,S=(m-2)**2,y=fe(s),v=S+4*y,L=a.renderer.tileGeometryCache.acquire(v),{boundingBox:B}=r;n(B),r.numVerticesPerSide=m,r.vertexAttributes=L,r.maxEdgeVertexCount=y,r.minu=p,r.minv=x,r.maxu=h,r.maxv=M,D(e),r.edgeVerticesStartIndex=S,X(e),N(e),W(r,[],c),e.intersectionData=null}function D(e){const{tile:n}=e;if(!n.intersectsClippingArea)return;const{geometry:o,geometryState:r,localOrigin:i}=e,{samplerData:c,clippingArea:l,numVerticesPerSide:u}=r,{surface:d,extent:f,ellipsoid:m}=n,{isWebMercatorOnPlateCarree:g}=d,p=null!=l?l:ie,x=f[0],M=f[1],S=f[2],y=f[3],v=Math.max(x,p[0]),L=Math.min(S,p[2]),B=Math.max(M,p[1]),I=Math.min(y,p[3]),V=m.radius,b=n.horizontalScale,C=u-1,P=u-2,{minu:A,minv:E,maxu:O,maxv:T,boundingBox:D,vertexAttributes:R}=o,U=R.position,w=R.uv0,{typedBuffer:N,typedBufferStride:j}=R.normalCompressed,F=i[0],H=i[1],q=i[2],_=U.typedBuffer,W=U.typedBufferStride;let G=0;const k=t(M,B,I),z=g?(Math.PI/2-2*Math.atan(Math.exp(-k/V)))*V:k*b,J=1/C,K=t(M*(1-J)+y*J,B,I);let Q=z,X=g?(Math.PI/2-2*Math.atan(Math.exp(-K/V)))*V:K*b;for(let Y=1;Y<=P;Y++){const e=Y/C,n=t(M*(1-e)+y*e,B,I),o=t(e,E,T),r=X,i=(Y-1)/C,l=t(M*(1-i)+y*i,B,I),u=Q,d=(Y+1)/C,f=t(M*(1-d)+y*d,B,I),m=g?(Math.PI/2-2*Math.atan(Math.exp(-f/V)))*V:f*b,p=t(d,E,T);Q=X,X=m;const R=t(x,v,L);let U=R*b,k=s(R,n,c);const z=1/C,J=t(z,A,O),K=t(x*(1-J)+S*J,v,L);let Z=J,$=K,ee=K*b,te=s(K,n,c);if(1===Y){const e=ee-F,n=Q-H,s=te-q,r=0*W;_[r]=e,_[r+1]=n,_[r+2]=s,de(e,n,s,D);const i=t(z,A,O);a(w,G,i,o)}for(let g=1;g<=P;g++){const e=ee,i=te,d=(g+1)/C,M=t(d,A,O),y=t(x*(1-d)+S*d,v,L),B=$;$=y;{const e=G+1,t=e*W;if(1===Y||g===P){const i=y*b,l=s(y,n,c);if(1===Y&&g<P){const n=i-F,s=r-H,c=l-q;_[t]=n,_[t+1]=s,_[t+2]=c,de(n,s,c,D),a(w,e,M,o)}ee=i,te=l}else ee=_[t]+F,te=_[t+2]+q}const I=ee,V=te,E=U,T=k;U=e,k=i;const R=(G-P)*W,z=1===Y?s(B,l,c):_[R+2]+q,J=s(B,f,c);if(Y<P){const t=G+P,n=t*W,o=e-F,s=m-H,r=J-q;_[n]=o,_[n+1]=s,_[n+2]=r,de(o,s,r,D);const i=Z;Z=M,a(w,t,i,p)}{const e=I-E,t=u-m,n=t*(V-T),o=e*(z-J),s=-t*e,r=n*n+o*o+s*s;if(0===r)h(N,G,0,0,1,j);else{const e=1/Math.sqrt(r);h(N,G,n*e,o*e,s*e,j)}}++G}}}function R(e,t){e.tile.intersectsClippingArea&&(F(e),j(e,!0),te(e),e.intersectionData=null)}function U(e,t){e.tile.intersectsClippingArea&&(Y(e),N(e),te(e),ne(e),e.intersectionData=null)}function w(e,t){e.tile.intersectsClippingArea&&(N(e),te(e),e.intersectionData=null)}function N(e,t){e.tile.intersectsClippingArea&&(F(e),j(e,!1))}function j(n,o){const{geometry:r,geometryState:i,tile:a,localOrigin:c}=n,{surface:u,extent:g}=a,{clippingArea:p,samplerData:h}=i,M=null!=p?p:ie,S=g[0],y=g[2],v=g[1],L=g[3],B=[L>M[3],y>M[2],v<M[1],S<M[0]],I=a.horizontalScale,V=_(u.isWebMercatorOnPlateCarree,a.ellipsoid.radius,I),{minu:b,minv:C,maxu:P,maxv:A,boundingBox:E}=r,O=Math.max(S,M[0]),T=Math.min(y,M[2]),D=Math.max(v,M[1]),R=Math.min(L,M[3]),U=c[0],w=c[1],N=c[2];for(let j=0;j<4;++j){const c=1===j||3===j,g=i.edgeResolutions[j];d(e(g));const p=g+1,M=B[j],F=l(a,i.edgePeerNeighbors[j]);if(!M&&ce(a,F,j)){Z(n,j,F);continue}const H=null!=F&&!M,q=F?.renderData,_=q?.geometryState;if(f&&(d(!H||F.level===a.level),d(!H||x(a,F)<=0),a&&!F&&!u.updatingRootTiles)){const e=m[j],t=a.findNeighborTile(e,(e=>e.isLoaded||e.isLeaf||e.level===a.level));u.updatingRootTiles||(t?t.intersectsClippingArea&&(d(!t.isLoaded),d(!t.isLeaf),d(t.level===a.level)):d(null==u?.rootTiles||!a.shouldHaveNeighbor(e)))}const W=t(1===j?y:S,O,T),G=t(0===j?L:v,D,R),k=_?.samplerData,z=o&&p>3?p-3:1,J=t(1===j?1:0,b,P),K=t(0===j?1:0,C,A),Q=H?(e,t)=>.5*(s(e,t,k)+s(e,t,h)):(e,t)=>s(e,t,h),X=(y-S)/g,Y=c?1===j?X:-X:0,$=c?0:0===j?X:-X,ee=-Y,te=-$;let ne=0,oe=0,se=0;{const e=0/g,n=c?W:t(S*(1-e)+y*e,O,T),o=c?t(v*(1-e)+L*e,D,R):G,s=Q(n,o);ne=n*I,oe=V(o),se=s}let re=0,ie=0,ae=0;{const e=1/g,n=c?W:t(S*(1-e)+y*e,O,T),o=c?t(v*(1-e)+L*e,D,R):G,s=Q(n,o);re=n*I,ie=V(o),ae=s}for(let e=1;e<p-1;e+=z){const n=e/g,o=re,i=ie,a=ae;{const s=c?J:t(n,b,P),l=c?t(n,C,A):K,u=o-U,d=i-w,f=a-N;de(o,d,f,E),r.setEdgeVertexFromValuesRawPositionUV(j,e,u,d,f,s,l)}{const n=(e+1)/g,o=c?W:t(S*(1-n)+y*n,O,T),s=c?t(v*(1-n)+L*n,D,R):G,r=Q(o,s);re=o*I,ie=V(s),ae=r}const l=re,u=ae,d=ne,f=oe,m=se;ne=o,oe=i,se=a;let p=0,x=0,M=0;if(c){const e=ie-i,r=u-a,c=f-i,l=m-a,d=t(v*(1-n)+L*n,D,R),g=W+ee,S=g*I-o,y=s(g,d,h)-a,B=3===j?-1:1;if(p=B*(-c+e)*y,x=B*S*(-l+r),M=-B*S*(-c+e),H){const t=W+Y,n=t*I-o;p=(-c+e)*(y-(s(t,d,k)-a)),x=(S-n)*(-l+r),M=-(S-n)*(-c+e)}}else{const e=l-o,r=u-a,c=d-o,f=m-a,g=t(S*(1-n)+y*n,O,T),v=G+te,L=s(g,v,h)-a,B=V(v)-i,I=2===j?-1:1;if(p=I*B*(-f+r),x=I*(-c+e)*L,M=-I*B*(-c+e),H){const t=g,n=G+$,o=V(n)-i;p=(-B+o)*(-f+r),x=(-c+e)*(-L+(s(t,n,k)-a)),M=-(-B+o)*(-c+e)}}const B=1/Math.sqrt(p*p+x*x+M*M);r.setEdgeNormalFromValues(j,e,p*B,x*B,M*B)}}}function F(e,t){$(e)}function H(e,t){return(Math.PI/2-2*Math.atan(Math.exp(-e/t)))*t}function q(e,t){return e*t}function _(e,t,n){return e?e=>H(e,t):e=>q(e,n)}function W(e,t,n){const{numVerticesPerSide:o,vertexAttributes:s,maxEdgeVertexCount:r}=e,i=o-1,a=s.count,c=2*(o-3)*(o-3),l=4*(i+r-3),d=u.reduce(((t,n)=>t+(i+e.getEdgeCount(n)-3)),0),f=t.reduce(((e,t)=>e+i*(2*(t.latitudeResolution-1)+1)),0),m=3*(n?2:1),g=(c+l+f)*m,p=a>=M?new Uint32Array(g):new Uint16Array(g);for(let u=0;u<g;++u)p[u]=0;e.indices=p,e.indexCount=(c+d+f)*m,e.poleIndicesStartIndex=c*m,e.edgeIndicesStartIndex=(c+f)*m,n?(J(e),K(e,t),Q(e)):(G(e),k(e,t),z(e))}function G(e){const{numVerticesPerSide:t,indices:n,vertexAttributes:o}=e,{position:s}=o,{typedBuffer:r,typedBufferStride:i}=s,a=t-2,c=t-3,l=0,u=t-3;let d=0;for(let f=0;f<c;++f){const e=f*a;for(let t=l;t<u;++t){const o=e+t,s=o+1,c=s+a,l=c-1;me(o,s,c,l,i,r)?(n[d]=o,n[d+1]=s,n[d+2]=c,n[d+3]=c,n[d+4]=l,n[d+5]=o):(n[d]=o,n[d+1]=s,n[d+2]=l,n[d+3]=l,n[d+4]=s,n[d+5]=c),d+=6}}}function k(e,t){const{numVerticesPerSide:n,indices:o,poleIndicesStartIndex:s}=e,r=n-1;let i=s;for(const a of t){const t=a.isNorth?1:2,s=a.isNorth?2:1,c=a.isNorth?3:4,l=a.isNorth?4:3;let u=e.getEdgeVertexIndex(a.connectedOuterEdgeOffset,0),d=1;for(let e=0;e<a.latitudeResolution;++e){const f=0===e?a.rowOffset:u+n;for(let n=0;n<r;n++){const r=f+n;o[i]=u,o[i+t]=u+1,o[i+s]=r,e<a.latitudeResolution-1?(o[i+c]=u+1,o[i+l]=r+1,o[i+5]=r,i+=6):i+=3,u+=d}u=f,d=1}}}function z(e){const{indices:t,numVerticesPerSide:n,edgeIndicesStartIndex:o}=e,s=n-1,r=s-2;let i=o;for(let a=0;a<4;++a){const n=ue[a];let o=0,c=0;const l=e.getEdgeCount(a),u=n.count;d(u===s-1);const f=1===a||2===a,m=f?1:2,g=f?2:1,p=e.getEdgeFirstVertexIndex(a),x=1,h=n.vertex0Index,M=n.stride;for(;o<l-1||c<u-1;){const e=h+c*M,n=p+o*x,a=o<l-1,d=c<u-1,f=a&&(!d||(a?0+s*(o+.5)/(l-1):0)<=(d?1+r*(c+.5)/(u-1):0));f?++o:++c;const S=f?n+x:e+M;t[i]=e,t[i+m]=n,t[i+g]=S,i+=3}}e.indexCount=i}function J(e){const{indices:t,numVerticesPerSide:n,vertexAttributes:o}=e,{position:s}=o,{typedBuffer:r,typedBufferStride:i}=s,a=n-2;let c=0;for(let l=0;l<n-3;++l){const e=l*a;for(let o=0;o<n-3;++o){const n=l*a+o,s=n+1,u=s+a,d=u-1,f=e+o,m=f+1,g=m+a;me(f,m,g,g-1,i,r)?(ge(t,c,n,s,u),c+=6,ge(t,c,u,d,n)):(ge(t,c,n,s,d),c+=6,ge(t,c,d,u,s)),c+=6}}}function K(e,t){const{indices:n,numVerticesPerSide:o,poleIndicesStartIndex:s}=e,r=o-1;let i=s;for(const a of t){const t=a.connectedOuterEdgeOffset;let s=e.getEdgeVertexIndex(t,0),c=1;for(let e=0;e<a.latitudeResolution;++e){const t=0===e?a.rowOffset:s+o;for(let o=0;o<r;o++)ge(n,i,s,s+1,t+o),i+=6,e<a.latitudeResolution-1&&(ge(n,i,s+1,t+o+1,t+o),i+=6),s+=c;s=t,c=1}}}function Q(e){const{indices:t,numVerticesPerSide:n,edgeIndicesStartIndex:o}=e,s=n-1,r=s-2;let i=o;for(let a=0;a<4;++a){const n=ue[a];let o=0,c=0;const l=e.getEdgeCount(a),u=n.count;d(u===s-1);const f=1===a||2===a,m=f?1:3,g=f?3:1,p=e.getEdgeFirstVertexIndex(a),x=1,h=n.vertex0Index,M=n.stride;for(;o<l-1||c<u-1;){const e=h+c*M,n=p+o*x,a=o<l-1,d=c<u-1,f=a&&(!d||(a?0+s*(o+.5)/(l-1):0)<=(d?1+r*(c+.5)/(u-1):0));f?++o:++c;const S=f?n+x:e+M;t[i]=e,t[i+m]=n,t[i+m+1]=n,t[i+g]=S,t[i+g+1]=S,t[i+5]=e,i+=6}}e.indexCount=i}function X(e){const{geometry:t,geometryState:n}=e,{edgeResolutions:o}=n,{numVerticesPerSide:s,edgeVerticesStartIndex:r}=t,i=s-2;let a=r;for(let c=0;c<4;++c){{const e=0===c||2===c,t=(0===c?i-1:0)*i+(1===c?i-1:0),n=(e?0:1)*i+(e?1:0),o=ue[c];o.vertex0Index=t,o.stride=n,o.count=i}{const e=o[c]+1;t.outerEdgesOffsetAndLength[2*c+0]=a,t.outerEdgesOffsetAndLength[2*c+1]=e,a+=e}}}function Y(e){X(e),e.geometryState.wireframe?Q(e.geometry):z(e.geometry)}function Z(n,o,s){const r=(o+2)%4,{geometryState:i,geometry:c,tile:l,localOrigin:u}=n,f=l.level-s.level,m=1===o||3===o,g=i.edgeResolutions[o];d(e(g));const p=g+1,{boundingBox:x,minu:h,minv:M,maxu:S,maxv:y,vertexAttributes:v}=c,L=t(1===o?1:0,h,S),B=t(0===o?1:0,M,y),I=s.renderData,V=I.geometryState,b=I.geometry,C=b.getEdgeCount(r),P=l.getNeighborEdgeStartVertexIndex(o,s)*g,A=g*2**f;d(V.edgeResolutions[r]===A),d(C-1===A);const E=I.localOrigin[0]-u[0],O=I.localOrigin[1]-u[1],T=I.localOrigin[2]-u[2],D=c.getEdgeFirstVertexIndex(o),R=v.position,U=R.typedBuffer,w=R.typedBufferStride,N=v.normalCompressed,j=N.typedBuffer,F=N.typedBufferStride,H=v.uv0,q=b.vertexAttributes,_=b.getEdgeFirstVertexIndex(r),W=q.position.typedBuffer,G=q.position.typedBufferStride,k=q.normalCompressed.typedBuffer,z=q.normalCompressed.typedBufferStride;for(let e=1;e<p-1;++e){const n=D+e,o=_+(P+e),s=n*w,r=o*G,i=W[r]+E,c=W[r+1]+O,l=W[r+2]+T;U[s]=i,U[s+1]=c,U[s+2]=l,de(i,c,l,x);const u=n*F,d=o*z;j[u]=k[d],j[u+1]=k[d+1];const f=e/g,p=m?L:t(f,h,S),v=m?t(f,M,y):B;a(H,n,p,v)}}function $(e){const{geometry:n,geometryState:o,localOrigin:r,tile:i}=e,{clippingArea:c,samplerData:l}=o,{minu:u,minv:f,maxu:m,maxv:g,boundingBox:p,vertexAttributes:h}=n,{surface:M,ellipsoid:S,extent:y,extentInRadians:v,horizontalScale:L}=i,B="local"===M.view?.viewingMode,I=S.radius;let V=0,b=0,C=0;const P=(e,t,n)=>{const o=v[0===t?1:3],s=v[0===e?0:2],r=Math.cos(o),i=Math.sin(o),a=Math.sin(s),c=Math.cos(s),l=I+n;V=c*r*l,b=a*r*l,C=i*l},A=B?(()=>{const e=c,n=null!=e&&(y[3]>e[3]||y[2]>e[2]||y[1]<e[1]||y[0]<e[0]),o=_(M.isWebMercatorOnPlateCarree,I,L);return(s,r,i)=>{const a=0===s?y[0]:y[2],c=0===r?y[1]:y[3],l=n?t(a,e[0],e[2]):a,u=n?t(c,e[1],e[3]):c,d=i;V=l*L,b=o(u),C=d}})():P;let E=0,T=0,D=0,R=0,U=0,w=0,N=0,j=0,F=0;const H=B&&M.isWebMercatorOnPlateCarree,q=(e,t,n,o,s)=>{let r=0,i=0,a=0;if(B){const e=t*L,s=H?(Math.PI/2-2*Math.atan(Math.exp(-n/I)))*I:n*L;r=e-V,i=s-b,a=o-C}else{const s=O(e),c=e.tile,l=c.extent,u=c.extentInRadians,d=(t-l[0])/(l[2]-l[0]),f=(n-l[1])/(l[3]-l[1]),m=u[0]*(1-d)+u[2]*d,g=s(f),p=Math.cos(g),x=Math.sin(g),h=Math.sin(m),M=Math.cos(m),S=I+o;r=M*p*S-V,i=h*p*S-b,a=x*S-C}switch(s){case 0:N+=r,j+=i,F+=a;break;case 1:R-=r,U-=i,w-=a;break;case 2:N-=r,j-=i,F-=a;break;case 3:R+=r,U+=i,w+=a}},W=c??ie,G=y[0],k=y[2],z=y[1],J=y[3],K=[J>W[3],k>W[2],z<W[1],G<W[0]],Q=Math.max(G,W[0]),X=Math.min(k,W[2]),Y=Math.max(z,W[1]),Z=Math.min(J,W[3]),$=e=>Math.max(W[0],Math.min(W[2],e)),te=e=>Math.max(W[1],Math.min(W[3],e)),ne=e=>{const t=o.cornerNeighborCornerTiles;E=0,T=0,D=1,R=0,U=0,w=0,N=0,j=0,F=0;let n=1/0;for(let o=0;o<4;++o){const s=t[4*e+o];n=Math.min(n,s?.level??1/0)}for(let o=0;o<4;++o){const s=t[4*e+o];ae[o]=s?.level===n?s:null}let r=1,i=0;for(let o=0;o<4;++o){const e=ae[o];e&&(r=Math.max(r,e?.renderData.geometryState.numVerticesPerSide),i=e.extent[2]-e.extent[0])}const a=i,c=r;d(c>1);const l=a/c;for(let o=0;o<4;++o){const e=ae[(o+3)%4],t=ae[o%4];if(!e&&!t)continue;const n=0===o?1:1===o?2:2===o?3:0,r=0===o?2:1===o?3:2===o?0:1;if(e&&t){const i=se[o][0]*l,a=se[o][1]*l,c=e.extent,u=$(c[0===n||1===n?2:0]+i),d=te(c[0===n||3===n?3:1]+a),f=t.extent,m=$(f[0===r||1===r?2:0]+i),g=te(f[0===r||3===r?3:1]+a),p=e.renderData,x=t.renderData,h=s(u,d,p.geometryState.samplerData),M=s(m,g,x.geometryState.samplerData);q(p,u,d,.5*(h+M),o)}else{const i=e??t,a=e?n:r,c=i.extent,u=se[o],d=$(c[0===a||1===a?2:0]+u[0]*l),f=te(c[0===a||3===a?3:1]+u[1]*l),m=i.renderData,g=s(d,f,m.geometryState.samplerData);q(m,d,f,g,o)}}if(!B){const e=Math.sqrt(V*V+b*b+C*C);E=V/e,T=b/e,D=C/e}if(B||D*D<.999){const e=Math.sqrt(R*R+U*U+w*w);R/=e,U/=e,w/=e;const t=Math.sqrt(N*N+j*j+F*F);N/=t,j/=t,F/=t,E=w*j-U*F,T=R*F-w*N,D=U*N-R*j;const n=1/Math.sqrt(E*E+T*T+D*D);E*=n,T*=n,D*=n}},oe=o.cornerNeighborCornerTiles;for(let O=0;O<4;++O){const e=O,c=(O+1)%4,M=0===O||1===O?1:0,S=0===O||3===O?1:0,y=t(M,u,m),v=t(S,f,g),L=n.getEdgeFirstVertexIndex(e),B=n.getEdgeCount(e),I=0===O||3===O?B-1:0,P=n.getEdgeFirstVertexIndex(c),R=n.getEdgeCount(c),U=0===O||1===O?R-1:0;let w=-1;for(let t=0;t<4;++t){const e=oe[4*O+t],n=oe[4*O+w];e&&(-1===w||x(n,e)>0)&&(w=t)}const N=w,j=oe[4*O+N];if(j!==i){const e=i.level-j.level,t=2**e,n=[j.lij[0]+e,j.lij[1]*t,j.lij[2]*t],s=[n[1]+t===i.lij[1],0===O&&(1===N||0===N&&j!==oe[4*O+3])||1===O&&(0===N||1===N&&j!==oe[4*O+2]),n[1]===i.lij[1]+1,2===O&&(3===N||2===N&&j!==oe[4*O+1])||3===O&&(2===N||3===N&&j!==oe[4*O+0])],c=s.reduce(((e,t)=>e+(t?1:0)),0);d(1===c||2===c);let l=-1,u=-1;const f=j.renderData;if(1===c){const e=s.findIndex((e=>e));d(0<=e&&e<=3),l=(e+2)%4;const t=o.edgeResolutions[e];u=i.getNeighborEdgeStartVertexIndex(e,j)*t+t*(0===e&&0===O||1===e&&0===O||2===e&&1===O||3===e&&3===O?1:0)}else{d(s[1]||s[3]),l=s[1]?3:1;const e=f.geometryState.edgeResolutions[l];u=0===O||3===O?0:e}const m=f.geometry;{const e=L+I,t=P+U,n=m.getEdgeFirstVertexIndex(l)+u,o=m.vertexAttributes,s=f.localOrigin;{const i=o.position,a=i.typedBuffer,c=n*i.typedBufferStride,l=a[c]+s[0]-r[0],u=a[c+1]+s[1]-r[1],d=a[c+2]+s[2]-r[2];de(l,u,d,p);const f=h.position,m=f.typedBuffer;{const t=e*f.typedBufferStride;m[t]=l,m[t+1]=u,m[t+2]=d}{const e=t*f.typedBufferStride;m[e]=l,m[e+1]=u,m[e+2]=d}}const i=h.uv0;a(i,e,y,v),a(i,t,y,v);{const s=o.normalCompressed.typedBuffer,r=n*o.normalCompressed.typedBufferStride,i=h.normalCompressed,a=i.typedBuffer;{const t=e*i.typedBufferStride;a[t]=s[r],a[t+1]=s[r+1]}{const e=t*i.typedBufferStride;a[e]=s[r],a[e+1]=s[r+1]}}}}else{const o=K[e],i=K[c];let a;if(o||i){const e=t(G*(1-M)+k*M,Q,X),n=t(z*(1-S)+J*S,Y,Z);a=s(e,n,l)}else a=ee(oe,O);A(M,S,a),ne(O);const u=V-r[0],d=b-r[1],f=C-r[2];de(u,d,f,p),n.setEdgeVertexFromValuesRawPositionUVNormal(e,I,u,d,f,y,v,E,T,D),n.setEdgeVertexFromValuesRawPositionUVNormal(c,U,u,d,f,y,v,E,T,D)}}for(let t=0;t<4;++t)ae[t]=null}function ee(e,t){const n=4*t,o=u.reduce(((t,o)=>Math.min(t,e[n+o]?.level??1/0)),1/0);f&&(d(!e[n+0]||!e[n+2]||p(e[n+0],e[n+2],i.SOUTH_WEST)),d(!e[n+1]||!e[n+3]||p(e[n+1],e[n+3],i.NORTH_WEST)));let r=0,a=0;for(let i=0;i<4;++i){const t=e[n+i];if(t&&t.level===o){const e=0===i||1===i,n=0===i||3===i,o=t.extent,c=o[e?0:2],l=o[n?1:3],u=t.renderData?.geometryState?.samplerData;a+=s(c,l,u),r++}}const c=r?a/r:0;return d(null!=c),c}function te(e){const{vao:t,geometry:n}=e,{vertexAttributes:o,edgeVerticesStartIndex:s}=n,r=o.position.typedBuffer;t.vertexBuffers.geometry.setSubData(r,s,s,r.length)}function ne(e){const{vao:t,geometry:n}=e,{indices:o,indexCount:s,edgeIndicesStartIndex:r}=n;t.indexBuffer.setSubData(o,r,r,s)}class oe{constructor(e,t,n,o,s){this.isNorth=e,this.connectedRowOffset=t,this.connectedOuterEdgeOffset=n,this.rowOffset=o,this.latitudeResolution=s}}const se=[[0,1],[1,0],[0,-1],[-1,0]],re=new c,ie=o(-1/0,-1/0,1/0,1/0),ae=[null,null,null,null];function ce(e,t,n){if(!t)return!1;const o=x(e,t);return o>0||0===o&&n>=2}class le{constructor(){this.vertex0Index=0,this.stride=1,this.count=0}getVertexIndex(e){return d(0<=e&&e<this.count),this.vertex0Index+this.stride*e}}const ue=[new le,new le,new le,new le];function de(e,t,n,o){e<o[0]?o[0]=e:e>o[3]&&(o[3]=e),t<o[1]?o[1]=t:t>o[4]&&(o[4]=t),n<o[2]?o[2]=n:n>o[5]&&(o[5]=n)}function fe(e){const{edgeResolutions:t,numVerticesPerSide:n}=e,o=1+Math.max(...t);return Math.max(n,o)}function me(e,t,n,o,s,r){const i=e*s,a=r[i],c=r[i+1],l=r[i+2],u=t*s,d=r[u],f=r[u+1],m=r[u+2],g=n*s,p=r[g],x=r[g+1],h=r[g+2],M=o*s,S=r[M],y=r[M+1],v=r[M+2];return(d-S)*(d-S)+(f-y)*(f-y)+(m-v)*(m-v)>(a-p)*(a-p)+(c-x)*(c-x)+(l-h)*(l-h)}function ge(e,t,n,o,s){e[t]=n,e[t+1]=o,e[t+2]=o,e[t+3]=s,e[t+4]=s,e[t+5]=n}const pe=6;export{T as createPlanarGlobePatch,S as createSphericalGlobePatch,I as updateCornerSpherical,R as updateCornersPlanar,U as updateEdgeElevationsAndResolutionsPlanar,B as updateEdgeElevationsAndResolutionsSpherical,w as updateEdgesAndCornersPlanar,L as updateEdgesAndCornersSpherical};
