/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import{Cyclical as t}from"../../../core/Cyclical.js";import n from"../../../core/Logger.js";import{deg2rad as r,rad2deg as o}from"../../../core/mathUtils.js";import{throwIfAborted as i}from"../../../core/promiseUtils.js";import{h as a,g as c,o as l,c as s,q as u}from"../../../chunks/vec32.js";import{clone as f,create as m}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as p}from"../../../geometry/ellipsoidUtils.js";import d from"../../../geometry/Point.js";import{projectWithZConversion as h,project as g}from"../../../geometry/projection.js";import y from"../../../geometry/SpatialReference.js";import{projectPointToVector as v,projectPointToVectorAsync as w}from"../../../geometry/projection/projectPointToVector.js";import{projectVectorToPoint as R,projectVectorToPointAsync as x}from"../../../geometry/projection/projectVectorToPoint.js";import{projectVectorToVector as M}from"../../../geometry/projection/projectVectorToVector.js";import{ViewingMode as T}from"../../ViewingMode.js";import{cameraOnContentAlongViewDirection as j}from"../camera/intersectionUtils.js";import{t as S,c as C}from"../../../chunks/cameraUtilsPlanar.js";import{t as z,c as b}from"../../../chunks/cameraUtilsSpherical.js";import{getGreatCircleSpanAt as U}from"./earthUtils.js";import{getElevationAtPoint as P}from"./ElevationProvider.js";import{isSpatialReferenceSupported as A}from"../../support/spatialReferenceSupport.js";const D=()=>n.getLogger("esri.views.3d.support.cameraUtils"),H=39.37,L=96,G=1,q=8,E=5,O=1,I=m(),k={heading:0,tilt:0},J=m(),V=new t(-20037508.342788905,20037508.342788905),F=new t(-180,180);var W;function X(e){return e.spatialReference??y.WGS84}function K(e){return"global"===e.viewingMode?b:C}function Y(e,t,n,r,o){return K(e).headingTiltToDirectionUp(t,n,r,o)}function N(e,t){if(null==t)return null;const n=e.renderSpatialReference,o=K(e).headingTiltToDirectionUp,i=m();if(!v(t.position,i,n))return null;const l=o(i,t.heading,t.tilt);a(l.direction,l.direction,e.state.camera.distance),c(l.direction,l.direction,i);const s=j(e,i,l.direction,l.up);return s.fov=r(t.fov),s.row=t.layout.row,s.rows=t.layout.rows,s.column=t.layout.column,s.columns=t.layout.columns,s}!function(e){e[e.LOCKED=0]="LOCKED",e[e.ADJUST=1]="ADJUST"}(W||(W={}));const Z=m();function B(t,n,r){const i=t.renderSpatialReference,a=ne(t,n.eye,n.viewForward,n.up,k);let c=X(t);return M(n.eye,i,Z,c)||(c=y.WGS84,M(n.eye,i,Z,c)),null==r?r=new e(new d(Z,c),a.heading,a.tilt,o(n.fov)):(r.position.x=Z[0],r.position.y=Z[1],r.position.z=Z[2],r.position.spatialReference=c,r.heading=a.heading,r.tilt=a.tilt,r.fov=o(n.fov)),r.layout.row=n.row,r.layout.rows=n.rows,r.layout.column=n.column,r.layout.columns=n.columns,r}function Q(e,t,n){const o=e.state.camera,i=o.width/2/o.pixelRatio;e.renderCoordsHelper.viewingMode===T.Global&&null!=n&&(t*=Math.cos(r(n))),t/=e.renderCoordsHelper.unitInMeters;return i/(L*H/t)/Math.tan(o.fovX/2)}function $(e,t,n){const o=e.state.camera,i=t*Math.tan(o.fovX/2),a=o.width/2/o.pixelRatio;let c=L*H/(a/i);return e.renderCoordsHelper.viewingMode===T.Global&&null!=n&&(c/=Math.cos(r(n))),c*e.renderCoordsHelper.unitInMeters}async function _(e,t,n,r,o,i){return te(e,t,Q(e,n,t.latitude),r,o,i)}function ee(e,t,n,r,o,i){return ze(e,ce(e,r.heading,r.tilt,t,n,o),r.fov,i)}async function te(e,t,n,r,o,a){const c=await le(e,r.heading,r.tilt,t,n,o,a);return i(a),be(e,c,r.fov,a)}function ne(e,t,n,r,o){return K(e).directionToHeadingTilt(t,n,r,o)}function re(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,J,e.spatialReference)&&e.elevationProvider&&(P(e.elevationProvider,J)??0)>J[2]-O)}async function oe(e,t,n){if(re(e,t))return!0;const{elevationProvider:r,spatialReference:o,renderCoordsHelper:a}=e;if(null==r||!a.fromRenderCoords(t,J,o))return!1;const[c,l,s]=J,u=await r.queryElevation(c,l,s,o,"ground",n)??0;return i(n),u>s-O}async function ie(e,t,n){const r=m();if(null==t)return s(r,e.state.camera.center);if(t instanceof d){const{renderSpatialReference:o,basemapTerrain:a,elevationProvider:c}=e,l=t.spatialReference;if(await w(t,r,o,0,{signal:n}),i(n),null==t.z&&null!=a&&null!=c){const o=await c.queryElevation(t.x,t.y,t.z??0,l,"ground",n);i(n),null!=o&&e.renderCoordsHelper.setAltitude(r,o)}return r}return s(r,t)}function ae(e,t){const n=m();if(null==t)return s(n,e.state.camera.center);if(t instanceof d){if(!v(t,n,e.renderSpatialReference))return null;const{basemapTerrain:r,elevationProvider:o}=e;if(null==t.z&&null!=r&&null!=o){const r=P(o,t);null!=r&&e.renderCoordsHelper.setAltitude(n,r)}return n}return s(n,t)}function ce(e,t,n,r,o,i){return se(e,t,n,r instanceof d?r:null,ae(e,r),o,i)}async function le(e,t,n,r,o,a,c){const l=r instanceof d?r:null,s=await ie(e,r,c);return i(c),ue(e,t,n,l,s,o,a,c)}function se(e,t,n,r,o,i,a){if(null==o)return null;if(!r&&(r=new d({spatialReference:X(e)}),!R(o,e.renderSpatialReference,r)))return null;const c=fe(e,t,n,o,i,a);if(me(e,n,a)&&re(e,c.eye)){const{tilt:a,mode:c}=pe(e,n,o,i);return se(e,t,a,r,o,i,c)}return de(c,o)}async function ue(e,t,n,r,o,a,c,l){r||(r=new d({spatialReference:X(e)}),await x(o,e.renderSpatialReference,r,{signal:l})||(r=null)),i(l);const s=fe(e,t,n,o,a,c);if(me(e,n,c)&&await oe(e,s.eye,l)){i(l);const{tilt:c,mode:s}=pe(e,n,o,a);return ue(e,t,c,r,o,a,s,l)}return de(s,o)}function fe(e,t,n,r,o,i){const a=xe(e,t,n,r,o=Math.max(o,e.state.constraints.minimumPoiDistance),i);return(0,K(e).eyeForCenterWithHeadingTilt)(r,o,a.heading,a.tilt)}function me(e,t,n){const r=e.map.ground.navigationConstraint;return n===W.ADJUST&&"global"===e.viewingMode&&t>0&&(null==r||"stay-above"===r.type)}function pe(e,t,n,r){const o=Se(e,n,r,je(e,r,t,n));return{tilt:o,mode:t-o<1?W.LOCKED:W.ADJUST}}function de(e,t){return{...e,center:f(t)}}function he(e,t){const{state:n,spatialReference:r}=e,o=t.spatialReference;return n.isGlobal&&A(o,T.Global)||n.isLocal&&r.equals(o)}function ge(e,t){let n,r,o;if(e.state.isGlobal){const e=new d(t.xmin,t.ymin,t.spatialReference),i=new d(t.xmax,t.ymax,t.spatialReference),a=t.spatialReference.isGeographic?F:V;n=new d({x:a.center(e.x,i.x),y:(i.y+e.y)/2,z:null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0,spatialReference:t.spatialReference});const c=p(t.spatialReference),l=U(n,e,i);r=l.lon,o=l.lat,a.diff(e.x,i.x)>a.range/2&&(r+=c.halfCircumference),r=Math.min(r,c.halfCircumference),o=Math.min(o,c.halfCircumference)}else{const i=e.renderSpatialReference??t.spatialReference;i.equals(t.spatialReference)||(t=g(t,i)),r=t.xmax-t.xmin,o=t.ymax-t.ymin;const a=null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0;n=new d({x:t.xmin+.5*r,y:t.ymin+.5*o,z:a,spatialReference:i})}const i=null!=t.zmax&&null!=t.zmin?t.zmax-t.zmin:0,a=e.state.camera,c=1/Math.tan(a.fovX/2),l=1/Math.tan(a.fovY/2),s=1/Math.tan(a.fov/2);return{center:n,distance:Math.max(.5*r*c,.5*o*l,.5*i*s)/G}}async function ye(e,t,n,r,o,a){const c=he(e,t)?t:await h(t,e.spatialReference,{signal:a});i(a);const{center:l,distance:s}=ge(e,c),u=await le(e,n,r,l,s,o,a);return i(a),be(e,u,e.camera.fov,a)}function ve(e,t,n,r,o,i){let a;try{a=he(e,t)?t:g(t,e.spatialReference)}catch(u){return null}const{center:c,distance:l}=ge(e,a),s=ce(e,n,r,c,l,o);return null==s?null:ze(e,s,e.camera.fov,i)}function we(e,t,n){const r=e.renderSpatialReference,o=new d({spatialReference:X(e)});if(!R(n,r,o))return null;const i=Math.tan(t.fovX/2),a=Math.tan(t.fovY/2),c=l(t.eye,n),s=2*c*i*G,u=2*c*a*G;return"global"===e.viewingMode?z(e,o,s,u):S(e,o,s,u)}function Re(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>q)return!0;const o=t,i=e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation;return u(o,i)/(Math.tan(.5*e.state.camera.fov)*r)>E}function xe(e,t,n,r,o,i){let a=0;return i===W.ADJUST&&Re(e,r,o)?(t=0,a=Te(e,o,n,r)):a=Ce(e,r,o,n),a=e.state.constraints.clampTilt(o,a),{heading:t,tilt:n=Se(e,r,o,a)}}const Me=.7;function Te(e,t,n,r){const o=Ce(e,r,t,n);if(!e.state.constraints.tilt)return o;const i=e.state.constraints.tilt(t);i.max=Math.min(i.max,.5*Math.PI);const a=i.min*(1-Me)+i.max*Me;return Math.min(o,a)}function je(e,t,n,r){let o=Ce(e,r,t,n);if(!e.state.constraints.tilt)return o;const i=e.state.constraints.tilt(t);return o=Math.min(o,.5*Math.PI),i.min*(1-Me)+o*Me}function Se(e,t,n,r){return K(e).lookAtTiltToEyeTilt(r,t,n)}function Ce(e,t,n,r){return K(e).eyeTiltToLookAtTilt(r,t,n)}function ze(t,n,r,o){if(null==n)return null;const i=t.renderSpatialReference,a=new d({spatialReference:X(t)});return R(n.eye,i,a)?(o??=new e,o.position=a,o.heading=n.heading,o.tilt=n.tilt,o.fov=r,o):null}async function be(t,n,r,o){const a=t.renderSpatialReference,c=new d({spatialReference:X(t)});return await x(n.eye,a,c,{signal:o}),i(o),new e(c,n.heading,n.tilt,r)}function Ue(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.levelAtScale(t);D().error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function Pe(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.scaleAtLevel(t);D().error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}function Ae(e,t){return M(t.center,e.renderSpatialReference,I,y.WGS84),$(e,t.distance,I[1])}export{W as OrientationMode,Ae as computeScale,ne as directionToHeadingTilt,$ as distanceToScale,N as externalToInternal,te as fromCenterDistanceAsync,ee as fromCenterDistanceSync,_ as fromCenterScale,ye as fromExtentAsync,ve as fromExtentSync,le as getObserverForPointAtDistanceAsync,ce as getObserverForPointAtDistanceSync,X as getViewSR,Y as headingTiltToDirectionUp,B as internalToExternal,Q as scaleToDistance,Ue as scaleToZoom,we as toExtent,Pe as zoomToScale};
