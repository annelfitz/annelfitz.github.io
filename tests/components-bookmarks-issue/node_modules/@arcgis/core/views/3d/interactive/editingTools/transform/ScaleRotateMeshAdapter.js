/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import e from"../../../../../core/Accessor.js";import{deg2rad as o,rad2deg as i}from"../../../../../core/mathUtils.js";import{when as r,sync as n}from"../../../../../core/reactiveUtils.js";import{property as s}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/Logger.js";import"../../../../../core/RandomLCG.js";import{subclass as a}from"../../../../../core/accessorSupport/decorators/subclass.js";import{axis as l,angle as c}from"../../../../../geometry/support/axisAngleDegrees.js";import{createGraphicGeometryUndoRecord as p}from"./undoRecords.js";let g=class extends e{constructor(t){super(t),this._interactionState=null}initialize(){this.addHandles([r((()=>{const t=this._interactionState;return t&&t.angle!==t.previousAngle?{interactionState:t,angle:t.state.angle}:null}),(({interactionState:t})=>{this._updateMeshRotation(t)}),n),r((()=>{const t=this._interactionState;return t&&t.scale!==t.previousScale?{interactionState:t,scale:t.state.scale}:null}),(({interactionState:t})=>{this._updateMeshSize(t)}),n)])}get initialAngle(){return this._interactionState?.initialAngle??0}get angle(){const t=this.geometry.transform;if(null==t)return this._interactionState?.angle??0;const e=l(t.rotation)[2];return Math.abs(e)>.999999?o(c(t.rotation))*Math.sign(e):0}get angleClockwise(){return-this.angle}get relativeAngle(){return this.angle-this.initialAngle}get relativeAngleClockwise(){return-this.relativeAngle}get scale(){return this._interactionState?.scale??1}startInteraction(){const t=new u({angle:this.angle});this._interactionState=t;const e=()=>{this._interactionState=null};return{state:t,done:e,cancel:()=>{t.cancel(),e()}}}createUndoRecord(){return p(this.object)}_updateMeshRotation(t){const{angle:e,previousAngle:o}=t;t.previousAngle=e;const r=i(e-o);this.geometry.rotate(0,0,r,{origin:this.geometry.anchor})}_updateMeshSize(t){const{scale:e,previousScale:o}=t;t.previousScale=e;const i=e/o,r=this.geometry.anchor;this.geometry.scale(i,{origin:r})}};t([s({constructOnly:!0})],g.prototype,"object",void 0),t([s({constructOnly:!0})],g.prototype,"geometry",void 0),t([s({constructOnly:!0})],g.prototype,"viewingMode",void 0),t([s()],g.prototype,"initialAngle",null),t([s()],g.prototype,"angle",null),t([s()],g.prototype,"angleClockwise",null),t([s()],g.prototype,"relativeAngle",null),t([s()],g.prototype,"relativeAngleClockwise",null),t([s()],g.prototype,"scale",null),t([s()],g.prototype,"_interactionState",void 0),g=t([a("esri.views.3d.interactive.editingTools.transform.ScaleRotateMeshAdapter")],g);let u=class extends e{get state(){const{angle:t,scale:e}=this;return{angle:t,scale:e}}constructor(t){super(t),this.angle=0,this.initialAngle=0,this.previousAngle=0,this.previousScale=1,this.scale=1,this.initialAngle=t.angle,this.previousAngle=t.angle}cancel(){this.angle=this.initialAngle,this.scale=1}};t([s()],u.prototype,"angle",void 0),t([s()],u.prototype,"initialAngle",void 0),t([s()],u.prototype,"previousAngle",void 0),t([s()],u.prototype,"previousScale",void 0),t([s()],u.prototype,"scale",void 0),t([s()],u.prototype,"state",null),u=t([a("esri.views.3d.interactive.editingTools.transform.ScaleRotateMeshAdapter.InteractionState")],u);export{g as ScaleRotateMeshAdapter};
