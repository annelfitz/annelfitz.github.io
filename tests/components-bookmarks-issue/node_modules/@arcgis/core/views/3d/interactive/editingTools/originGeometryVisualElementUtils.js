/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{removeHandles as e,destroyHandle as t,refHandle as o}from"../../../../core/handleUtils.js";import{deg2rad as n}from"../../../../core/mathUtils.js";import{watch as i,initial as r}from"../../../../core/reactiveUtils.js";import{signal as a}from"../../../../core/signal.js";import{s}from"../../../../chunks/vec32.js";import{create as l}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectPointToVector as c}from"../../../../geometry/projection/projectPointToVector.js";import{projectVectorToVector as p}from"../../../../geometry/projection/projectVectorToVector.js";import{create as m,empty as u,getMin as h}from"../../../../geometry/support/aaBoundingBox.js";import{containsXY as f}from"../../../../geometry/support/aaBoundingRect.js";import{GrabbingState as v}from"./GrabbingState.js";import{manipulatedObjectGeometry as d}from"./manipulatedObjectUtils.js";import{ManipulatorState as g}from"./ManipulatorState.js";import{Settings as j}from"./settings.js";import{ExtendedLineVisualElement as b}from"../visualElements/ExtendedLineVisualElement.js";import{LaserlineVisualElement as w}from"../visualElements/LaserlineVisualElement.js";import{PointVisualElement as y}from"../visualElements/PointVisualElement.js";import{evaluateElevationAlignmentAtPoint as E}from"../../layers/graphics/elevationAlignmentUtils.js";import{ElevationContext as T}from"../../layers/graphics/ElevationContext.js";import{RenderOccludedFlag as x}from"../../webgl-engine/lib/Material.js";function D(t){const o=[],n=S(t,o);return P(t,o,n),{visualElement:n,remove:()=>e(o)}}function P(e,o,l){const{view:c,object:m}=e,f=new j({getTheme:()=>c.effectiveTheme}),y=new b({view:c,extensionType:f.visualElements.zVerticalLine.extensionType,innerWidth:1,attached:!1,writeDepthEnabled:!1,renderOccluded:x.OccludeAndTransparent,isDecoration:!0});o.push(i((()=>f.visualElements.zVerticalLine),(e=>e.apply(y)),r));const D=new w({view:c,intersectsLineInfinite:!0,attached:!1,isDecoration:!0}),P=n(f.visualElements.heightPlaneAngleCutoff),S=new w({view:c,attached:!1,angleCutoff:P,isDecoration:!0}),A=m.elevationInfo,L=T.fromElevationInfo(A),M="on-the-ground"===A.mode||!A.offset&&"absolute-height"!==A.mode,U=new g,I=a(1);o.push(i((()=>({heightPlane:f.visualElements.heightPlane,alpha:I.value})),(({heightPlane:e,alpha:t})=>e.apply(S,t)),r));const O=a(1);o.push(i((()=>({shadowStyle:f.visualElements.pointObjects.shadowStyle,alpha:O.value})),(({shadowStyle:e,alpha:t})=>e.apply(D,t)),r));const B=()=>{U.update(e);const t=V(d(m)),o=M&&(m.isDraped||null==t||!t.hasZ);let n=!0;if(o||null==t)n=!1;else{const e=E(t,c.elevationProvider,L,c.renderCoordsHelper);s(C,t.x,t.y,e),p(C,t.spatialReference,C,c.renderCoordsHelper.spatialReference),y.setStartEndFromWorldDownAtLocation(C),D.intersectsWorldUpAtLocation=C}const i=U.grabbingState&v.Z?f.visualElements.laserlineAlphaMultiplier:1;I.value=i;const r=u(R);!o&&m.visible&&l.calculateMapBounds(r)&&p(h(r,C),c.spatialReference,C,c.renderCoordsHelper.spatialReference)?(S.heightManifoldTarget=C,S.attached=!0):S.attached=!1;const a=U.grabbingState&v.XY?f.visualElements.laserlineAlphaMultiplier:1;O.value=a;const g=n&&m.visible&&!o;D.attached=g,y.attached=g};o.push(i((()=>[m.visible,m.isDraped]),B),m.on("committed",B)),e.forEachManipulator((e=>{o.push(e.events.on("grab-changed",B))})),o.push(t(D)),o.push(t(y)),o.push(t(S)),B()}function S(e,o){const{view:n,object:i}=e,r=new y({view:n,geometry:V(d(i)),elevationInfo:i.elevationInfo,isDecoration:!0});return A(e,r,o),o.push(t(r)),r}function V(e){return null==e?null:"point"===e.type?e:"mesh"===e.type?e.anchor.clone():null}function A(e,t,o){const{view:n,object:a}=e,s=()=>{t.attached=a.visible},l=new j({getTheme:()=>n.effectiveTheme});L(e,t,o),l.visualElements.pointObjects.outline.apply(t),o.push(i((()=>a.visible),s,r))}function L(e,t,n){const{view:i,object:r}=e;let a=null;const s=e=>{null!=a&&(a.remove(),a=null),r.isDraped&&null!=e&&(a=M(i,e,(()=>{t.geometry=e})))},l=()=>{const e=V(d(r));s(e),t.geometry=e};n.push(r.on("committed",l),o((()=>a))),l()}function M(e,t,o){const n=e.elevationProvider.spatialReference;c(t,C,n);const i=C[0],r=C[1];return e.elevationProvider.on("elevation-change",(e=>{f(e.extent,i,r)&&o()}))}const C=l(),R=m();export{D as createVisualElements};
