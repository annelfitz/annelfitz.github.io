/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import t from"../../../../core/Error.js";import{clone as e}from"../../../../core/lang.js";import{getMetersPerVerticalUnitForSR as r}from"../../../../core/unitUtils.js";import{e as s}from"../../../../chunks/earcut.js";import{normalFromMat4 as o}from"../../../../core/libs/gl-matrix-2/math/mat3.js";import{create as n}from"../../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{invert as i,invertOrIdentity as a}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as l}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{c,n as m,s as p,f as h,b as g,e as d,z as u}from"../../../../chunks/vec32.js";import{fromArray as f,create as y}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{computeTranslationToOriginAndRotation as b}from"../../../../geometry/projection/computeTranslationToOriginAndRotation.js";import{create as _,empty as x,expandWithBuffer as S,intersectsClippingArea as j}from"../../../../geometry/support/aaBoundingBox.js";import{newDoubleArray as P}from"../../../../geometry/support/DoubleArray.js";import{newIndexArray as E,getZeroIndexArray as M}from"../../../../geometry/support/Indices.js";import{a as O}from"../../../../chunks/vec3.js";import{makeVertexCandidate as w,makeEdgeCandidate as C}from"../../../../layers/graphics/data/SnappingCandidate.js";import{getDriverAxisSizeValue as I}from"../../../../renderers/support/renderingInfoUtils.js";import{ViewingMode as v}from"../../../ViewingMode.js";import{needsElevationUpdates3D as A,SampleElevationInfo as L}from"./elevationAlignmentUtils.js";import{Graphics3DObject3DGraphicLayer as z}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as B}from"./Graphics3DSymbolLayer.js";import{validateSymbolLayerSize as D,computeCentroid as R}from"./graphicUtils.js";import{ApplyRendererDiffResult as T}from"./interfaces.js";import{geometryAsPolygon as G}from"./polygonUtils.js";import{createMaterial as U}from"../support/edgeUtils.js";import{debugFlags as N}from"../../support/debugFlags.js";import{SamplePosition as V}from"../../support/ElevationProvider.js";import{geometryToRenderInfo as F}from"../../support/renderInfoUtils/polygon.js";import{NormalType as k}from"../../webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js";import{Attribute as H}from"../../webgl-engine/lib/Attribute.js";import{CullFaceOptions as W}from"../../webgl-engine/lib/basicInterfaces.js";import{ContentObjectType as q}from"../../webgl-engine/lib/ContentObjectType.js";import{Geometry as Z}from"../../webgl-engine/lib/Geometry.js";import{isGeometryWithMapPositions as J}from"../../webgl-engine/lib/GeometryWithMapPositions.js";import{compressNormals as K,compressNormal as Q}from"../../webgl-engine/lib/Normals.js";import{Object3D as X}from"../../webgl-engine/lib/Object3D.js";import{VertexAttribute as Y}from"../../webgl-engine/lib/VertexAttribute.js";import{DefaultMaterial as $}from"../../webgl-engine/materials/DefaultMaterial.js";const tt=["polygon","extent"];class et extends B{constructor(t,e,r,s){super(t,e,r,s),this.ensureDrapedStatus(!1)}async doLoad(){if(!this._drivenProperties.size){const e=D(this._getSymbolSize());if(e)throw new t("graphics3dextrudesymbollayer:invalid-size",e)}const e=this.symbolLayer?.material?.color,r=this._getCombinedOpacityAndColor(e),s=f(r),o=r[3],n=o<1||this.needsDrivenTransparentPass,i={usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0,diffuse:s,ambient:s,opacity:o,transparent:n,cullFace:n?W.None:W.Back,hasVertexColors:!0,hasSlicePlane:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,offsetTransparentBackfaces:!0,normalType:k.Compressed};this._materials[wt.Main]=new $(i),this._materials[wt.Bottom]=new $({...i,cullFace:W.Back}),this._context.stage.addMany(this._materials)}destroy(){super.destroy(),this._context.stage.removeMany(this._materials),this._materials.length=0}createGraphics3DGraphic(t){const e=t.graphic;if(!this._validateGeometry(e.geometry,tt,this.symbolLayer.type))return null;const r=this._getVertexOpacityAndColor(t.renderingInfo,255),s=this.setGraphicElevationContext(e);return this._createAs3DShape(e,t.renderingInfo,r,s,e.uid)}layerOpacityChanged(t,e){const r=this.symbolLayer?.material?.color,s=this._getCombinedOpacity(r),o=s<1||this.needsDrivenTransparentPass;this._materials[wt.Main]?.setParameters({opacity:s,transparent:o}),this._materials[wt.Bottom]?.setParameters({opacity:s,transparent:o});const n=this._getLayerOpacity();t.forEach((t=>{const r=e(t);null!=r&&r.layerOpacityChanged(n,this._context.isAsync)}))}layerElevationInfoChanged(t,e){return this.updateGraphics3DGraphicElevationInfo(t,e,A)}slicePlaneEnabledChanged(t,e){return this._materials[wt.Main]?.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),this._materials[wt.Bottom]?.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),t.forEach((t=>{const r=e(t);null!=r&&r.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)})),!0}physicalBasedRenderingChanged(){const t={usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0};return this._materials[wt.Main]?.setParameters(t),this._materials[wt.Bottom]?.setParameters(t),!0}_getExtrusionSize(t){let e;return e=t.size&&this._drivenProperties.size?I(t.size,2)??0:this._getSymbolSize(),e/=this._context.renderCoordsHelper.unitInMeters,e}applyRendererDiff(t,e){return this._drivenPropertiesChanged(e)?T.RecreateSymbol:T.RecreateGraphics}async queryForSnapping(t,s,o,n){const i=this._getExtrusionSize(o)*this._context.renderCoordsHelper.unitInMeters/r(s),{objectId:a,target:l}=t,c=e(l);switch(c.z=(c.z??0)+i,t.type){case"edge":{const{start:r,end:s}=t,o=e(r),n=e(s);return o.z=(o.z??0)+i,n.z=(n.z??0)+i,[C(a,c,1/0,o,n)]}case"vertex":return[w(a,c,1/0),C(a,l,1/0,l,c)];default:return[]}}_getSymbolSize(){return this.symbolLayer.size??1}_createAs3DShape(t,e,r,a,c){const m=G(t.geometry);if(null==m)return null;if(0===m.rings.length||!m.rings.some((t=>t.length>0)))return this._logGeometryValidationWarnings(m.rings,"rings","ExtrudeSymbol3DLayer"),null;const p=F(m,this._context.elevationProvider,this._context.renderCoordsHelper,a);this._logGeometryCreationWarnings(p,m.rings,"rings","ExtrudeSymbol3DLayer");const h=R(m);if(null==h)return null;const g=new Array,d=new Array,u=_(),f=l(),M=y(),w=this._context.renderCoordsHelper.viewingMode===v.Global;w||this._context.renderCoordsHelper.worldUpAtPosition(null,M),b(m.spatialReference,[h.x,h.y,0],f,this._context.renderCoordsHelper.spatialReference);const C=l();i(C,f);const I=n();o(I,C);const{polygons:L,mapPositions:B,position:D}=p,T=new Map,N=this._materials[wt.Main];for(const o of L){const t=o.count;if(this._context.clippingExtent&&(x(u),S(u,o.mapPositions),!j(u,this._context.clippingExtent)))continue;const n=s(o.mapPositions,o.holeIndices,3);if(0===n.length)continue;const i=n.length,a=6*t,l=E(a+i),m=E(i),p=P(3*a),h=P(3*a),y=P(3*a),b=P(a);st(D,B,n,o,p,y,h,b,l,m,this._getExtrusionSize(e),M,w),O(p,p,C);const _=this._context.stage.renderView.getObjectAndLayerIdColor({graphicUid:c,layerUid:this._context.layer.uid}),I=new Ct(p,y,K(h),b),v=rt(N,l,l.length-m.length,I,r,_),A=t,L=t,z=2*o.count,R=new It(A,L,z,i/3);ft(v,R,f),T.set(v,R),g.push(v,rt(this._materials[wt.Bottom],m,0,I,r,_)),d.push(I.heights)}if(0===g.length)return null;const V=new X({geometries:g,layerUid:this._context.layer.uid,graphicUid:c,isElevationSource:!0});V.transformation=f;const k=U(this.symbolLayer,{opacity:this._getLayerOpacity()}),H=null!=k?{baseMaterial:this._materials[wt.Main],edgeMaterials:[k],properties:{mergeGeometries:!0,hasSlicePlane:this._context.slicePlaneEnabled}}:null,W=new z(this,V,g,null,null,((t,e,r,s,o)=>ut(t,e,r,s,o,d,T)),a,H);return W.alignedSampledElevation=p.sampledElevation,W.needsElevationUpdates=A(a.mode),W}}function rt(t,e,r,s,o,n){const i=M(e.length),a=[[Y.POSITION,new H(s.positions,e,3,!0)],[Y.NORMALCOMPRESSED,new H(s.normals,e,2,!0)],[Y.COLOR,new H(o,i,4,!0)]];return new Z(t,a,s.elevation,q.Mesh,n,r)}function st(t,e,r,s,o,n,i,a,l,c,m,p,h){{const g=r.length/3,d=2*s.count;ot(t,e,s.index,s.count,r,0,g,o,n,i,a,l,c,d,m,p,h)}{let t=0,e=2*s.count,r=0;const c=s.pathLengths[0];at(o,n,a,i,t,c,s.count,e,l,r,m),e+=4*c,r+=2*c,t+=c;for(let p=1;p<s.pathLengths.length;++p){const c=s.pathLengths[p];at(o,n,a,i,t,c,s.count,e,l,r,m),e+=4*c,r+=2*c,t+=c}}}function ot(t,e,r,s,o,n,i,a,l,p,h,g,d,u,f,y,b){c(bt,y);{const o=f>0?1:-1;let n=3*r,i=0,c=3*i,g=s,d=3*g;for(let r=0;r<s;++r){const r=t[n],s=t[n+1],u=t[n+2];b&&(bt[0]=r,bt[1]=s,bt[2]=u,m(bt,bt)),a[c+0]=r,a[c+1]=s,a[c+2]=u;const y=e[n+0],_=e[n+1],x=e[n+2];l[c+0]=y,l[c+1]=_,l[c+2]=x,p[c+0]=-o*bt[0],p[c+1]=-o*bt[1],p[c+2]=-o*bt[2],h[i]=0,a[d+0]=r+f*bt[0],a[d+1]=s+f*bt[1],a[d+2]=u+f*bt[2],l[d+0]=y,l[d+1]=_,l[d+2]=x,h[g]=f,c+=3,d+=3,n+=3,i+=1,g+=1}}{let t=3*n,e=0,r=3*u;const a=f<0?St:xt,l=f<0?xt:St;for(let n=0;n<i;++n)d[e]=o[t+a[0]],d[e+1]=o[t+a[1]],d[e+2]=o[t+a[2]],g[r]=o[t+l[0]]+s,g[r+1]=o[t+l[1]]+s,g[r+2]=o[t+l[2]]+s,e+=3,r+=3,t+=3}}function nt(t,e,r,s,o,n,i){s[n]=s[i],i*=3,t[n*=3]=t[i],t[n+1]=t[i+1],t[n+2]=t[i+2],e[n]=e[i],e[n+1]=e[i+1],e[n+2]=e[i+2],r[n]=o[0],r[n+1]=o[1],r[n+2]=o[2]}const it=y();function at(t,e,r,s,o,n,i,a,l,c,m){let p=o,h=o+1,g=o+i,d=o+i+1,u=a,f=a+1,y=a+2*n,b=a+2*n+1;m<0&&(p=o+i+1,d=o);let _=3*c;for(let x=0;x<n;++x)x===n-1&&(h=o,m>0?d=o+i:p=o+i),gt(t,p,h,g,it),nt(t,e,s,r,it,u,p),nt(t,e,s,r,it,f,h),nt(t,e,s,r,it,y,g),nt(t,e,s,r,it,b,d),l[_]=u,l[_+1]=y,l[_+2]=b,l[_+3]=u,l[_+4]=b,l[_+5]=f,_+=6,p++,h++,g++,d++,u+=2,f+=2,y+=2,b+=2}const lt=y(),ct=y(),mt=y(),pt=y(),ht=y();function gt(t,e,r,s,o){e*=3,r*=3,s*=3,p(lt,t[e++],t[e++],t[e++]),p(ct,t[r++],t[r++],t[r++]),p(mt,t[s++],t[s++],t[s++]),h(pt,ct,lt),h(ht,mt,lt),g(o,ht,pt),m(o,o)}const dt=y();function ut(t,e,r,s,o,n,i){const c=t.stageObject,m=c.geometries,h=m.length,g="absolute-height"!==e.mode;let u=0;const f=c.transformation,y=a(l(),f);for(let a=0;a<h;a+=2){const t=m[a];if(!J(t))continue;const e=t.getMutableAttribute(Y.POSITION).data,l=n[a/2],h=new V(t.mapPositions),b=e.length/3;let _=!1,x=0;{let t=0;for(let n=0;n<b;n++){dt[0]=e[t],dt[1]=e[t+1],dt[2]=e[t+2],s(h,_t),g&&(x+=_t.sampledElevation),N.TESTS_DISABLE_OPTIMIZATIONS?(p(yt,h.array[h.offset],h.array[h.offset+1],_t.z+l[t/3]),null!=r&&o.toRenderCoords(yt,r,yt),d(yt,yt,y)):(p(yt,e[t],e[t+1],e[t+2]),d(yt,yt,f),o.setAltitude(yt,_t.z+l[t/3]),d(yt,yt,y)),e[t]=yt[0],e[t+1]=yt[1],e[t+2]=yt[2];const n=jt/o.unitInMeters;(Math.abs(dt[0]-e[t])>=n||Math.abs(dt[1]-e[t+1])>=n||Math.abs(dt[2]-e[t+2])>=n)&&(_=!0),h.offset+=3,t+=3}}if(_){const e=i.get(t);e&&ft(t,e,f),c.geometryVertexAttributeUpdated(m[a],Y.NORMALCOMPRESSED),t.invalidateBoundingInfo(),c.geometryVertexAttributeUpdated(m[a],Y.POSITION),m[a+1].invalidateBoundingInfo(),c.geometryVertexAttributeUpdated(m[a+1],Y.POSITION)}u+=x/b}return u/h}function ft(t,e,r){const s=t.getMutableAttribute(Y.POSITION),o=t.getMutableAttribute(Y.NORMALCOMPRESSED).data,{topVertexStart:n,topVertexCount:i,topFaceStart:a,topFaceCount:l}=e,c=s.data,h=i,f=t.attributes.get(Y.POSITION).indices,y=a+l,b=n+i,_=P(3*h);for(let m=0;m<h;++m){const t=3*m;_[t+0]=0,_[t+1]=0,_[t+2]=0}const x=Pt,S=Et,j=Mt,E=Ot,M=bt;for(let P=a;P<y;++P){const t=3*P;for(let e=0;e<3;++e){const s=f[t+e];E[e]=s;const o=3*s;p(yt,c[o+0],c[o+1],c[o+2]),d(x[e],yt,r)}u(S,x[1],x[0]),u(j,x[2],x[0]),g(M,S,j),m(M,M);for(let e=0;e<3;++e){const t=3*(E[e]-n);_[t+0]+=M[0],_[t+1]+=M[1],_[t+2]+=M[2]}}for(let m=n;m<b;++m){const t=3*(m-n),e=_[t+0],r=_[t+1],s=_[t+2],i=Math.sqrt(e*e+r*r+s*s);Q(o,m,e/i,r/i,s/i)}}const yt=y(),bt=y(),_t=new L,xt=[0,2,1],St=[0,1,2],jt=.01,Pt=[y(),y(),y()],Et=y(),Mt=y(),Ot=[0,0,0];var wt;!function(t){t[t.Main=0]="Main",t[t.Bottom=1]="Bottom"}(wt||(wt={}));class Ct{constructor(t,e,r,s){this.positions=t,this.elevation=e,this.normals=r,this.heights=s}}class It{constructor(t,e,r,s){this.topVertexStart=t,this.topVertexCount=e,this.topFaceStart=r,this.topFaceCount=s}}export{et as Graphics3DExtrudeSymbolLayer};
