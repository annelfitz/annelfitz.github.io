/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../../../geometry.js";import e from"../../../../request.js";import{binaryIndexOf as t,splitIntoChunks as r}from"../../../../core/arrayUtils.js";import o from"../../../../core/Error.js";import has from"../../../../core/has.js";import{isInt16Array as n,isInt32Array as i}from"../../../../core/typedArrayUtil.js";import{invert as a}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as s}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{s as l,e as c,c as u}from"../../../../chunks/vec32.js";import{create as f}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{canProjectWithoutEngine as p}from"../../../../geometry/projection.js";import{getSphericalPCPF as m}from"../../../../geometry/spatialReferenceEllipsoidUtils.js";import{projectVectorToVector as d}from"../../../../geometry/projection/projectVectorToVector.js";import{create as h,empty as y,expandPointInPlace as g,intersects as b}from"../../../../geometry/support/aaBoundingRect.js";import{g as S}from"../../../../chunks/sphere.js";import w from"../../../../rest/support/Query.js";import{readBinaryAttribute as T}from"./I3SBinaryReader.js";import{computeGlobalTransformation as I}from"./I3SProjectionUtil.js";import{createSolidEdgeMaterial as E,createMaterialFromEdges as v}from"../support/edgeUtils.js";import{parseColorMixMode as R,ColorMixModeEnum as x}from"../support/symbolColorUtils.js";import{Obb as j,compute as M}from"../../support/orientedBoundingBox.js";import C from"../../../../geometry/SpatialReference.js";function U(e){return e?parseInt(e.substring(e.lastIndexOf("/")+1,e.length),10):void 0}function N(e){if(has("disable-feature:i3s-draco")||!e)return!1;for(const t of e)for(const e of t.geometryBuffers)if("draco"===e.compressedAttributes?.encoding)return!0;return!1}function k(e,t,r,o){r.traverse(t,(t=>{const r=t.serviceMbsInIndexSR;return(null!=r&&O(e,r))!==F.OUTSIDE&&(o(t),!0)}))}function D(e,t,r){let o=0,n=0;for(let i=0;i<t.length&&o<e.length;i++)e[o]===t[i]&&(r(i)&&(e[n]=e[o],n++),o++);e.length=n}function W(e,r,o){let n=0,i=0;for(;n<o.length;){t(e,o[n])>=0===r&&(o[i]=o[n],i++),n++}o.length=i}const _=h();function q(e,t){if(0===t.rotationScale[1]&&0===t.rotationScale[2]&&0===t.rotationScale[3]&&0===t.rotationScale[5]&&0===t.rotationScale[6]&&0===t.rotationScale[7])return _[0]=(e[0]-t.position[0])/t.rotationScale[0],_[1]=(e[1]-t.position[1])/t.rotationScale[4],_[2]=(e[2]-t.position[0])/t.rotationScale[0],_[3]=(e[3]-t.position[1])/t.rotationScale[4],_}var F;function O(e,t){const r=t[0],o=t[1],n=t[3],i=e[0]-r,a=r-e[2],s=e[1]-o,l=o-e[3],c=Math.max(i,a,0),u=Math.max(s,l,0),f=c*c+u*u;if(f>n*n)return F.OUTSIDE;if(f>0)return F.INTERSECTS_CENTER_OUTSIDE;return-Math.max(i,a,s,l)>n?F.INSIDE:F.INTERSECTS_CENTER_INSIDE}function L(e,t,r){const o=[],n=r?.missingFields,i=r?.originalFields;for(const a of e){const e=a.toLowerCase();let r=!1;for(const n of t)if(e===n.name.toLowerCase()){o.push(n.name),r=!0,i&&i.push(a);break}!r&&n&&n.push(a)}return o}async function A(e,t,r,n,i,a){if(0===t.length)return[];const s=e.attributeStorageInfo;if(null!=e.associatedLayer)try{return await P(e.associatedLayer,t,r,n,a)}catch(l){if(e.associatedLayer.loaded)throw l}if(s){const l=K(t,r,i);if(null==l)throw new o("scenelayer:features-not-loaded","Tried to query attributes for unloaded features");const c=e.parsedUrl.path;return(await Promise.all(l.map((t=>G(c,s,t.node,t.indices,n,e.apiKey,e.customParameters,a).then((e=>{for(let r=0;r<t.graphics.length;r++){const o=t.graphics[r],n=e[r];if(o.attributes)for(const e in o.attributes)e in n||(n[e]=o.attributes[e]);o.attributes=n}return t.graphics})))))).flat()}throw new o("scenelayer:no-attribute-source","This scene layer does not have a source for attributes available")}function K(e,t,r){const o=new Map,n=[],i=r();for(const a of e){const e=a.attributes[t];for(let t=0;t<i.length;t++){const r=i[t],s=r.featureIds.indexOf(e);if(s>=0){let e=o.get(r.node);e||(e={node:r.node,indices:[],graphics:[]},n.push(e),o.set(r.node,e)),e.indices.push(s),e.graphics.push(a);for(let r=t;r>0;r--)i[r]=i[r-1];i[0]=r;break}}}return n}async function P(e,t,r,o,n){t.sort(((e,t)=>e.attributes[r]-t.attributes[r]));const i=t.map((e=>e.attributes[r])),a=[],s=L(o,e.fields,{originalFields:a}),l=await B(e,i,s,n);for(let c=0;c<t.length;c++){const e=t[c],r=l[c],o={};if(e.attributes)for(const t in e.attributes)o[t]=e.attributes[t];for(let t=0;t<a.length;t++)o[a[t]]=r[s[t]];e.attributes=o}return t}function B(e,t,n,i){const a=e.capabilities.query.maxRecordCount;if(null!=a&&t.length>a){const o=r(t,a);return Promise.all(o.map((t=>B(e,t,n,i)))).then((e=>e.flat()))}const s=new w({objectIds:t,outFields:n,orderByFields:[e.objectIdField]});return e.queryFeatures(s,i).then((e=>{if(e&&e.features&&e.features.length===t.length)return e.features.map((e=>e.attributes));throw new o("scenelayer:feature-not-in-associated-layer","Feature not found in associated feature layer")}))}function G(e,t,r,o,n,i,a,s){return $(e,t,r.resources.attributes,o,n,i,a,s)}async function $(t,r,o,n,i,a,s,l){const c=[];for(const e of r)if(e&&i.includes(e.name)){const r=`${t}/nodes/${o}/attributes/${e.key}/0`;c.push({url:r,storageInfo:e})}const u=await Promise.allSettled(c.map((t=>e(t.url,{responseType:"array-buffer",query:{...s,token:a},signal:l?.signal}).then((e=>T(t.storageInfo,e.data)))))),f=[];for(const e of n){const t={};for(let r=0;r<u.length;r++){const o=u[r];if("fulfilled"===o.status){const n=o.value;t[c[r].storageInfo.name]=Q(n,e)}}f.push(t)}return f}!function(e){e[e.OUTSIDE=0]="OUTSIDE",e[e.INTERSECTS_CENTER_OUTSIDE=1]="INTERSECTS_CENTER_OUTSIDE",e[e.INTERSECTS_CENTER_INSIDE=2]="INTERSECTS_CENTER_INSIDE",e[e.INSIDE=3]="INSIDE"}(F||(F={}));const z=-32768,V=-(2**31);function Q(e,t){if(!e)return null;const r=e[t];if(n(e))return r===z?null:r;if(i(e))return r===V?null:r;return r!=r?null:r}function Z(e){const t=e.store,r=t.indexCRS||t.geographicCRS,n=void 0===r?t.indexWKT:void 0;if(n){if(!e.spatialReference)throw new o("layerview:no-store-spatial-reference-wkt-index-and-no-layer-spatial-reference","Found indexWKT in the scene layer store but no layer spatial reference",{});if(n!==e.spatialReference.wkt)throw new o("layerview:store-spatial-reference-wkt-index-incompatible","The indexWKT of the scene layer store does not match the WKT of the layer spatial reference",{})}const i=r?new C(U(r)):e.spatialReference;return i.equals(e.spatialReference)?e.spatialReference:i}function H(e){const t=e.store,r=t.vertexCRS||t.projectedCRS,n=void 0===r?t.vertexWKT:void 0;if(n){if(!e.spatialReference)throw new o("layerview:no-store-spatial-reference-wkt-vertex-and-no-layer-spatial-reference","Found vertexWKT in the scene layer store but no layer spatial reference",{});if(n!==e.spatialReference.wkt)throw new o("layerview:store-spatial-reference-wkt-vertex-incompatible","The vertexWKT of the scene layer store does not match the WKT of the layer spatial reference",{})}const i=r?new C(U(r)):e.spatialReference;return i.equals(e.spatialReference)?e.spatialReference:i}function J(e,t){return null==t?"@null":t===m(t)?"@ECEF":e.equals(t)?"":null!=t.wkid?"@"+t.wkid:null}function X(e,t,r){if(!p(e,t))throw new o("layerview:spatial-reference-incompatible","The spatial reference of this scene layer is incompatible with the spatial reference of the view",{});if("local"===r&&!ee(e,t))throw new o("layerview:spatial-reference-incompatible","The spatial reference of this scene layer is incompatible with the spatial reference of the view",{})}function Y(e,t,r){if(e.serviceUpdateTimeStamp?.lastUpdate!==t.serviceUpdateTimeStamp?.lastUpdate||!r.isEmpty||e.associatedLayer?.url!==t.associatedLayer?.url)throw new o("layerview:recycle-failed")}function ee(e,t){return e.equals(t)||e.isWGS84&&t.isWebMercator||e.isWebMercator&&t.isWGS84}function te(e,t,r){const o=Z(e),n=H(e);X(o,t,r),X(n,t,r)}function re(e){return(null==e.geometryType||"triangles"===e.geometryType)&&((null==e.topology||"PerAttributeArray"===e.topology)&&null!=e.vertexAttributes?.position)}function oe(e){if(null==e.store?.defaultGeometrySchema||!re(e.store.defaultGeometrySchema))throw new o("scenelayer:unsupported-geometry-schema","The geometry schema of this scene layer is not supported.",{url:e.parsedUrl.path})}function ne(e,t){te(e,t.spatialReference,t.viewingMode)}function ie(e){return null!=e.geometryType&&"points"===e.geometryType&&((null==e.topology||"PerAttributeArray"===e.topology)&&((null==e.encoding||""===e.encoding||"lepcc-xyz"===e.encoding)&&null!=e.vertexAttributes?.position))}function ae(e){if(null==e.store?.defaultGeometrySchema||!ie(e.store.defaultGeometrySchema))throw new o("pointcloud:unsupported-geometry-schema","The geometry schema of this point cloud scene layer is not supported.",{})}function se(e,t){X(e.spatialReference,t.spatialReference,t.viewingMode)}function le(e){return"simple"===e.type||"class-breaks"===e.type||"unique-value"===e.type}function ce(e){return"mesh-3d"===e.type}function ue(e){if(null==e||!le(e))return!0;if(("unique-value"===e.type||"class-breaks"===e.type)&&null==e.defaultSymbol)return!0;const t=e.getSymbols();if(0===t.length)return!0;for(const r of t){if(!ce(r)||0===r.symbolLayers.length)return!0;for(const e of r.symbolLayers.items)if("fill"!==e.type||null==e.material?.color||"replace"!==e.material.colorMixMode)return!0}return!1}const fe=E({color:[0,0,0,0],opacity:0});class pe{constructor(){this.edgeMaterial=null,this.material=null,this.castShadows=!0}}function me(e){const t=new pe;let r=!1,o=!1;for(const n of e.symbolLayers.items)if("fill"===n.type&&n.enabled){const e=n.material,i=n.edges;if(null!=e&&!r){const o=e.color,i=R(e.colorMixMode);t.material=null!=o?{color:[o.r/255,o.g/255,o.b/255],alpha:o.a,colorMixMode:i}:{color:[1,1,1],alpha:1,colorMixMode:x.Multiply},t.castShadows=n.castShadows,r=!0}null==i||o||(t.edgeMaterial=v(i,{}),o=!0)}return t.material||(t.material={color:[1,1,1],alpha:1,colorMixMode:x.Multiply}),t}function de(e,t){return(0|e)+(0|t)|0}function he(e,t,r,o,n,i,s){if(!i||0===i.length||null==t||!e.serviceMbsInIndexSR)return null;const f=I(e.serviceMbsInIndexSR,n,r,t);a(ve,f);let p=null;const m=()=>{if(!p)if(p=be,y(we),null!=e.serviceObbInIndexSR){e.serviceObbInIndexSR.transform(Te,r,t,n,s),Te.getCorners(p);for(const e of p)c(e,e,ve),g(we,e)}else{const o=e.serviceMbsInIndexSR;if(!o)return;const i=o[3];d(S(o),r,Ie,t),c(Ie,Ie,ve),Ie[2]+=n;for(let e=0;e<8;++e){const t=1&e?i:-i,r=2&e?i:-i,o=4&e?i:-i,n=p[e];u(n,[Ie[0]+t,Ie[1]+r,Ie[2]+o]),g(we,n)}}};let h=1/0,w=-1/0;const T=e=>{if("replace"!==e.type)return;const r=e.geometry;if(!r?.hasZ)return;y(Se);const n=r.spatialReference||o,i=r.rings.reduce(((e,r)=>r.reduce(((e,r)=>(l(Ie,r[0],r[1],r[2]),d(Ie,n,Ie,t),c(Ie,Ie,ve),g(Se,Ie),Math.min(Ie[2],e))),e)),1/0);m(),b(we,Se)&&(h=Math.min(h,i),w=Math.max(w,i))};if(i.forEach((e=>T(e))),h===1/0)return null;const E=(e,t,r)=>{c(Ie,r,f),e[t]=Ie[0],e[t+1]=Ie[1],e[t+2]=Ie[2],t+=24,r[2]=h,c(Ie,r,f),e[t]=Ie[0],e[t+1]=Ie[1],e[t+2]=Ie[2],t+=24,r[2]=w,c(Ie,r,f),e[t]=Ie[0],e[t+1]=Ie[1],e[t+2]=Ie[2]};for(let a=0;a<8;++a)E(Ee.data,3*a,p[a]);return M(Ee)}function ye(e){return e[3]>=0}function ge(e){null!=e&&(e[3]=-1)}const be=[f(),f(),f(),f(),f(),f(),f(),f()],Se=h(),we=h(),Te=new j,Ie=f(),Ee={data:new Array(72),size:3,exclusive:!0,stride:3},ve=s();export{F as MbsIntersectResult,pe as SymbolInfo,de as addWraparound,se as checkPointCloudLayerCompatibleWithView,ae as checkPointCloudLayerValid,Y as checkRecyclable,ne as checkSceneLayerCompatibleWithView,oe as checkSceneLayerValid,X as checkSpatialReference,te as checkSpatialReferences,he as computeVisibilityObb,N as containsDraco,U as extractWkid,D as filterInPlace,L as findFieldsCaseInsensitive,k as findIntersectingNodes,J as getCacheKeySuffix,Q as getCachedAttributeValue,q as getClipRect,Z as getIndexCrs,me as getSymbolInfo,H as getVertexCrs,O as intersectBoundingRectWithMbs,ge as invalidateMbs,ee as isSupportedLocalModeProjection,ye as isValidMbs,W as objectIdFilter,$ as queryAttributesFromCachedAttributesId,ue as rendererNeedsTextures,fe as transparentEdgeMaterial,A as whenGraphicAttributes};
