/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../../core/Evented.js";import{someMap as t}from"../../../../core/MapUtils.js";class s extends e{constructor(e,t){super(),this._updateAndCompare=e,this._notifyUpdated=t,this._nodes=new Map,this._graphics=new Map,this._duplicates=new Map}clear(){if(this._graphics.size>0){const e=this.toArray();this._graphics.clear(),this.emit("change",{added:[],removed:e})}this._nodes.clear()}get length(){return this._graphics.size}get(e){return this._graphics.get(e)}getNode(e){return this._nodes.get(e)}hasNode(e){return this._nodes.has(e)}nodes(){return this._nodes.values()}addNode(e,t){this._nodes.set(e,t);const s=t.graphics;if(0===s.length)return;const n=new Set;for(let i=0;i<s.length;i++){const t=s[i],o=t.objectId,r=this._graphics.get(o);if(r){n.add(o),t!==r&&(s[i]=r);const d=this._duplicates.get(o);d?d.push(e):this._duplicates.set(o,[r.nodeIndex,e])}else t.nodeIndex=e,this._graphics.set(o,t)}n.size&&this._updateForeignGraphics(t);const o=n.size>0?s.filter((e=>!n.has(e.objectId))):s;o.length>0&&this.emit("change",{added:o,removed:[]})}removeNode(e){const t=this._nodes.get(e);if(!t)return void console.error("Removing unknown node");this._nodes.delete(e);const s=new Set,n=[];for(const o of t.graphics){const t=o.objectId,i=this._graphics.get(t);if(!i)continue;const r=this._duplicates.get(t);if(r){const n=r.indexOf(e);if(-1===n){console.error("error: removing graphic from node that should not reference it.");continue}if(r.splice(n,1),i.nodeIndex===e){let e=this.getNode(r[0]);for(let t=1;t<r.length;t++){const s=this.getNode(r[t]);(null==e||null!=s&&s.node.level>e.node.level)&&(e=s)}null!=e&&s.add(e)}1===r.length&&this._duplicates.delete(t)}else this._graphics.delete(t),n.push(o)}n.length>0&&this.emit("change",{added:[],removed:n}),s.forEach((e=>this._updateForeignGraphics(e)))}_updateForeignGraphics(e){const t=[],s=e.node.index,n=e.node.level;let o=0;for(;o<e.graphics.length;){const i=e.graphics[o].nodeIndex;if(i===s){o++;continue}let r=1;for(;o+r<e.graphics.length&&e.graphics[o+r].nodeIndex===i;)r++;const d=this.getNode(i);if(null!=d&&d.node.level>n)o+=r;else{for(let n=o;n<o+r;n++){const o=e.graphics[n];o.nodeIndex=s,this._updateAndCompare(o,e,n)&&t.push(o)}o+=r}}this._notifyUpdated(t)}toArray(){return Array.from(this._graphics.values())}find(e){let s;return t(this._graphics,(t=>!!e(t)&&(s=t,!0))),s}forEach(e){this._graphics.forEach((t=>e(t)))}forEachNode(e){this._nodes.forEach(((t,s)=>e(t,s)))}get nodeCount(){return this._nodes.size}_checkInvariants(){const e=new Map;this._nodes.forEach(((t,s)=>{s!==t.node.index&&console.error("Mismatched node index"),t.graphics.forEach((t=>{e.set(t.objectId,1+(e.get(t.objectId)??0));const n=this._duplicates.get(t.objectId);n&&!n.includes(s)&&console.error("Node not listed in duplicate list"),n||t.nodeIndex===s||console.error("Unique graphic does not reference owning node index")}))})),this._graphics.size!==e.size&&console.error("Mismatch between actual and expected number of graphics");let t=0;e.forEach(((e,s)=>{t+=e>1?1:0;const n=this._graphics.get(s);if(!n)return void console.error("Missing graphic entry");const o=this._nodes.get(n.nodeIndex);if(!o)return void console.error("Graphic references unkown node");const i=this._duplicates.get(s);i?(i.length!==e&&console.error("Wrong number of entries in duplicate list"),i.forEach((e=>{const t=this._nodes.get(e);t?t.node.level>o.node.level&&console.error("Duplicated graphic does not reference highest level node"):console.error("Unknown node in duplicate list")}))):e>1&&console.error("Missing duplicates entry")})),this._duplicates.size!==t&&console.error("Mismatch between expected and actual number of duplicate entries")}}export{s as I3SGraphicsMap};
