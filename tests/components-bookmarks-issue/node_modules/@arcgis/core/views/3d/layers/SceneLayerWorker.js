/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../geometry/SpatialReference.js";import{toFloat64Array as t}from"../../../geometry/support/DoubleArray.js";import r from"../../../geometry/support/MeshGeoreferencedVertexSpace.js";import o from"../../../geometry/support/MeshLocalVertexSpace.js";import{b as n,n as s}from"../../../chunks/vec3.js";import{IndexType as i}from"../../../libs/i3s/enums.js";import{get as a}from"../../../libs/i3s/I3SModule.js";import{NodeIMModificationImpact as f}from"./i3s/I3SNode.js";async function c(e){g=await _();const t=[e.geometryBuffer];return{result:E(g,e,t),transferList:t}}async function l(e){g=await _();const t=[e.geometryBuffer],{geometryBuffer:r}=e,o=r.byteLength,n=g._malloc(o),s=new Uint8Array(g.HEAPU8.buffer,n,o);s.set(new Uint8Array(r));const i=g.dracoDecompressPointCloudData(n,s.byteLength);if(g._free(n),i.error.length>0)throw new Error(`i3s.wasm: ${i.error}`);const a=i.featureIds?.length>0?i.featureIds.slice():null,f=i.positions.slice();return a&&t.push(a.buffer),t.push(f.buffer),{result:{positions:f,featureIds:a},transferList:t}}async function u(e){await _(),L(e);const t={buffer:e.buffer};return{result:t,transferList:[t.buffer]}}async function m(e){await _(),w(e)}async function y(e){g=await _(),g.setLegacySchema(e.context,e.jsonSchema)}async function p(n){const{localMatrix:s,origin:i,positions:a,vertexSpace:f,localMode:c}=n,l=e.fromJSON(n.inSpatialReference),u=e.fromJSON(n.outSpatialReference);let m;if("georeferenced"===f.type&&null==f.origin){const[{projectBuffer:e},{initializeProjection:t}]=await Promise.all([import("../../../geometry/projection/projectBuffer.js"),import("../../../geometry/projection.js")]);await t(l,u),m=new Float64Array(a.length),e(a,l,0,m,u,0,m.length/3)}else{const e="georeferenced"===f.type?r.fromJSON(f):o.fromJSON(f),{project:n}=await import("../../../geometry/support/meshUtils/georeference.js");m=t(n({positions:a,transform:s?{localMatrix:s}:void 0,vertexSpace:e,inSpatialReference:l,outSpatialReference:u,localMode:c}))}const y=m.length,[p,d,b]=i;for(let e=0;e<y;e+=3)m[e]-=p,m[e+1]-=d,m[e+2]-=b;return{result:{projected:m,original:a},transferList:[m.buffer,a.buffer]}}async function d({normalMatrix:e,normals:t}){const r=new Float32Array(t.length);return n(r,t,e),s(r,r),{result:{transformed:r,original:t},transferList:[r.buffer,t.buffer]}}function b(e){I(e)}let h,g;function w(e){if(!g)return;const t=e.modifications,r=g._malloc(8*t.length),o=new Float64Array(g.HEAPU8.buffer,r,t.length);for(let n=0;n<t.length;++n)o[n]=t[n];g.setModifications(e.context,r,t.length,e.isGeodetic),g._free(r)}function E(e,t,r){const{context:o,localOrigin:n,globalTrafo:s,mbs:a,obbData:f,elevationOffset:c,geometryBuffer:l,geometryDescriptor:u,indexToVertexProjector:m,vertexToRenderProjector:y}=t,p=e._malloc(l.byteLength),d=33,b=e._malloc(d*Float64Array.BYTES_PER_ELEMENT),h=new Uint8Array(e.HEAPU8.buffer,p,l.byteLength);h.set(new Uint8Array(l));const g=new Float64Array(e.HEAPU8.buffer,b,d);S(g,n);let w=g.byteOffset+3*g.BYTES_PER_ELEMENT,E=new Float64Array(g.buffer,w);S(E,s),w+=16*g.BYTES_PER_ELEMENT,E=new Float64Array(g.buffer,w),S(E,a),w+=4*g.BYTES_PER_ELEMENT,f&&(E=new Float64Array(g.buffer,w),S(E,f));const A=u,L={isDraco:!1,isLegacy:!1,color:t.layouts.some((e=>e.some((e=>"color"===e.name)))),normal:t.needNormals&&t.layouts.some((e=>e.some((e=>"normalCompressed"===e.name)))),uv0:t.layouts.some((e=>e.some((e=>"uv0"===e.name)))),uvRegion:t.layouts.some((e=>e.some((e=>"uvRegion"===e.name)))),featureIndex:A.featureIndex},I=e.process(o,!!t.obbData,p,h.byteLength,A,L,b,c,m,y,t.normalReferenceFrame);if(e._free(b),e._free(p),I.error.length>0)throw new Error(`i3s.wasm: ${I.error}`);if(I.discarded)return null;const j=I.componentOffsets.length>0?I.componentOffsets.slice():null,_=I.featureIds.length>0?I.featureIds.slice():null,x=I.anchorIds.length>0?Array.from(I.anchorIds):null,M=I.anchors.length>0?Array.from(I.anchors):null,P=I.interleavedVertedData.slice().buffer,U=I.indicesType===i.Int16?new Uint16Array(I.indices.buffer,I.indices.byteOffset,I.indices.byteLength/2).slice():new Uint32Array(I.indices.buffer,I.indices.byteOffset,I.indices.byteLength/4).slice(),O=I.positions.slice(),T=I.positionIndicesType===i.Int16?new Uint16Array(I.positionIndices.buffer,I.positionIndices.byteOffset,I.positionIndices.byteLength/2).slice():new Uint32Array(I.positionIndices.buffer,I.positionIndices.byteOffset,I.positionIndices.byteLength/4).slice(),R={layout:t.layouts[0],interleavedVertexData:P,indices:U,hasColors:I.hasColors,hasModifications:I.hasModifications,positionData:{data:O,indices:T}};return _&&r.push(_.buffer),j&&r.push(j.buffer),r.push(P),r.push(U.buffer),r.push(O.buffer),r.push(T.buffer),{componentOffsets:j,featureIds:_,anchorIds:x,anchors:M,transformedGeometry:R,obb:I.obb}}function A(e){return 0===e?f.Unmodified:1===e?f.PotentiallyModified:2===e?f.Culled:f.Unknown}function L(e){if(!g)return;const{context:t,buffer:r}=e,o=g._malloc(r.byteLength),n=r.byteLength/Float64Array.BYTES_PER_ELEMENT,s=new Float64Array(g.HEAPU8.buffer,o,n),i=new Float64Array(r);s.set(i),g.filterOBBs(t,o,n),i.set(s),g._free(o)}function I(e){g&&0===g.destroy(e)&&(g=null)}function S(e,t){for(let r=0;r<t.length;++r)e[r]=t[r]}async function j(){g||await _()}function _(){return g?Promise.resolve(g):(h||(h=a().then((e=>(g=e,h=null,g)))),h)}const x={transform:(e,t)=>g&&E(g,e,t),destroy:I};export{b as destroyContext,l as dracoDecompressPointCloudData,u as filterObbsForModifications,L as filterObbsForModificationsSync,j as initialize,A as interpretObbModificationResults,c as process,p as project,y as setLegacySchema,m as setModifications,w as setModificationsSync,x as test,d as transformNormals};
