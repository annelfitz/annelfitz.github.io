/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../../Color.js";import"../../../../core/has.js";import{deg2rad as t}from"../../../../core/mathUtils.js";import{fromMat4 as r,transpose as o}from"../../../../core/libs/gl-matrix-2/math/mat3.js";import{create as n}from"../../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{fromTranslation as a,multiply as s,invert as i,getTranslation as l}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as c,IDENTITY as u,clone as m}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{ONES as f}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{s as p,g as h,h as d,k as g,n as x,f as _,b as T}from"../../../../chunks/vec32.js";import{ZEROS as b,ONES as y,create as v}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{ONES as w}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{canProjectWithoutEngine as j}from"../../../../geometry/projection.js";import{computeTranslationToOriginAndRotation as C}from"../../../../geometry/projection/computeTranslationToOriginAndRotation.js";import{projectBuffer as R}from"../../../../geometry/projection/projectBuffer.js";import{projectVectorToPoint as M}from"../../../../geometry/projection/projectVectorToPoint.js";import{create as P,empty as A,expandWithBuffer as E,intersectsClippingArea as O}from"../../../../geometry/support/aaBoundingBox.js";import{newFloatArray as I}from"../../../../geometry/support/FloatArray.js";import{getZeroIndexArray as S,getContinuousIndexArray as N}from"../../../../geometry/support/Indices.js";import B from"../../../../geometry/support/MeshComponent.js";import U from"../../../../geometry/support/MeshMaterialMetallicRoughness.js";import F from"../../../../geometry/support/MeshTextureTransform.js";import{isRelativeVertexSpace as D}from"../../../../geometry/support/meshVertexSpaceUtils.js";import{equals as $}from"../../../../geometry/support/spatialReferenceUtils.js";import{a as L,b as G}from"../../../../chunks/vec3.js";import{project as V}from"../../../../geometry/support/meshUtils/georeference.js";import{transformNormal as H,projectNormalToPCPF as k,transformTangent as q,projectTangentToPCPF as z}from"../../../../geometry/support/meshUtils/projection.js";import{makeDehydratedPoint as Y}from"../../../../layers/graphics/dehydratedPoint.js";import{MeshTransformUpdateAction as W}from"../../../../layers/graphics/sources/interfaces.js";import{ViewingMode as J}from"../../../ViewingMode.js";import{isEncodedMeshTexture as K}from"../../glTF/internal/resourceUtils.js";import{getTransformMatrix as Q}from"../../glTF/internal/TextureTransformUtils.js";import{perObjectElevationAligner as X}from"./ElevationAligners.js";import{needsElevationUpdates3D as Z,evaluateElevationInfoAtPoint as ee}from"./elevationAlignmentUtils.js";import{Graphics3DMeshObject3DGraphicLayer as te}from"./Graphics3DMeshObject3DGraphicLayer.js";import{Object3DEdgeState as re}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as oe}from"./Graphics3DSymbolLayer.js";import{MaterialInfoCache as ne,MeshFastUpdateProcessor as ae}from"./MeshFastUpdateProcessor.js";import{createMaterial as se}from"../support/edgeUtils.js";import{parseColorMixMode as ie,encodeSymbolColor as le}from"../support/symbolColorUtils.js";import{debugFlags as ce}from"../../support/debugFlags.js";import{Attribute as ue}from"../../webgl-engine/lib/Attribute.js";import{AlphaDiscardMode as me,CullFaceOptions as fe}from"../../webgl-engine/lib/basicInterfaces.js";import{ContentObjectType as pe}from"../../webgl-engine/lib/ContentObjectType.js";import{Geometry as he}from"../../webgl-engine/lib/Geometry.js";import{Object3D as de}from"../../webgl-engine/lib/Object3D.js";import{Texture as ge}from"../../webgl-engine/lib/Texture.js";import{VertexAttribute as xe}from"../../webgl-engine/lib/VertexAttribute.js";import{DefaultMaterial as _e}from"../../webgl-engine/materials/DefaultMaterial.js";import{NativeLineMaterial as Te}from"../../webgl-engine/materials/NativeLineMaterial.js";import{useSchematicPBR as be,defaultSchematicMRRFactors as ye,defaultAdvancedMRRFactors as ve}from"../../webgl-engine/materials/pbrUtils.js";import{TextureWrapMode as we}from"../../../webgl/enums.js";const je=["mesh"];class Ce extends oe{constructor(e,t,r,o){super(e,t,r,o),this._materialInfoCache=new ne,this._fastUpdateProcessor=new ae,this._textures=new Map,this.ensureDrapedStatus(!1)}async doLoad(){ce.DRAW_MESH_GEOMETRY_NORMALS&&(this._debugVertexNormalMaterial=new Te({color:[1,0,1,1]}),this._debugFaceNormalMaterial=new Te({color:[0,1,1,1]}))}destroy(){super.destroy(),this._textures.forEach((e=>e.unload())),this._context.stage.removeMany(this._materialInfoCache.materials),this._context.stage.removeMany(Array.from(this._textures.values())),this._materialInfoCache.clear(),this._textures.clear(),this._fastUpdateProcessor.destroy(this._context.stage)}get materials(){return this._materialInfoCache.materials}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,je,"fill on mesh-3d"))return null;const r=this.setGraphicElevationContext(t),o=e.renderingInfo;return this._createAs3DShape(t,o,r,t.uid)}onRemoveGraphic(e){this._fastUpdateProcessor.onRemoveGraphic(e,this._materialInfoCache,this._context)}layerOpacityChanged(e,t){const r=this._getLayerOpacity();this._updateMaterialParameters((e=>{e.material.setParameters({layerOpacity:r});const t=e.material.parameters;this._setMaterialTransparentParameter(t,e),e.material.setParameters({transparent:t.transparent})})),e.forEach((e=>t(e)?.layerOpacityChanged(r,this._context.isAsync)))}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,Z)}slicePlaneEnabledChanged(e,t){return this._updateMaterialParameters((({material:e})=>{e.setParameters({hasSlicePlane:this._context.slicePlaneEnabled})})),e.forEach((e=>t(e)?.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync))),!0}physicalBasedRenderingChanged(){const e=this._usePBR();return this._updateMaterialParameters((({material:t})=>t.setParameters({usePBR:e}))),!0}updateTransform(e,t,r,o){const n=e.fastTransformUpdatesEnabled;switch(o){case W.EnableFastUpdates:if(n)return!0;break;case W.DisableFastUpdates:if(!n)return!0;break;default:if(!n)return!1}const a=this._context.renderCoordsHelper.spatialReference,s=Xe,{origin:i,transform:l}=r;if(!C(t,p(ze,i.x,i.y,i.z??0),s,a))return!1;switch(o){case W.EnableFastUpdates:this._fastUpdateProcessor.enable(e,this._materialInfoCache,this._context);break;case W.DisableFastUpdates:this._fastUpdateProcessor.disable(e,this._materialInfoCache,this._context);break;case W.UpdateFastLocalOrigin:e.updateFastLocalOrigin(s,l,this._context.localOriginFactory)}const{elevationContext:c}=e;c.centerPointInElevationSR=this._getCenterPointInElevationSR(s);const{elevationProvider:u,renderCoordsHelper:m}=this._context,f=(e,t)=>ee(e,u,c,m,t);return e.alignedSampledElevation=X(e,c,u.spatialReference,f,m,s),e.updateTransform(s,l,this._context.isAsync),!0}_requiresSymbolVertexColors(){return this._drivenProperties.color||this._drivenProperties.opacity}_materialPropertiesDefault(e,t){const r=this._requiresSymbolVertexColors(),o=!!e.vertexAttributes.color,n=!!e.vertexAttributes.tangent;return{hasSymbolVertexColors:r,hasVertexColors:o,hasVertexTangents:n,uid:`vc:${o},vt:${n},vct${t},svc:${r}`}}_materialProperties(e,t,r){const o=this._materialPropertiesDefault(e,r);if(!t.material)return o;const{color:n,colorTexture:a,colorTextureTransform:s,normalTexture:i,normalTextureTransform:l,doubleSided:c,alphaCutoff:u,alphaMode:m}=t.material,f=Ge(n),p=Ge(a),h=Ve(s),d=Ge(i),g=Ve(l);if(o.color=n,o.colorTexture=a,o.normalTexture=i,o.uid=`${o.uid},cmuid:${f},ctmuid:${p},cttuid:${h},ntmuid:${d},nttuid:${g},ds:${c},ac:${u},am:${m}`,t.material instanceof U){const{metallic:e,roughness:r,metallicRoughnessTexture:n,metallicRoughnessTextureTransform:a,emissiveColor:i,emissiveTexture:c,emissiveTextureTransform:u,occlusionTexture:m,occlusionTextureTransform:f}=t.material,p=Ge(n),h=Ve(a),d=Ge(i),g=Ge(c),x=Ve(u),_=Ge(m),T=Ve(f);o.metallic=e,o.roughness=r,o.metallicRoughnessTexture=n,o.emissiveColor=i,o.emissiveTexture=c,o.occlusionTexture=m,o.colorTextureTransform=Be(s),o.normalTextureTransform=Be(l),o.emissiveTextureTransform=Be(u),o.occlusionTextureTransform=Be(f),o.metallicRoughnessTextureTransform=Be(a),o.uid=`${o.uid},mrm:${e},mrr:${r},mrt:${p},mrtt:${h},emuid:${d},etmuid:${g},ett:${x},otmuid:${_},ott:${T}`}return o}_getInternalTextureId(e){const t=this._getInternalTexture(e,me.Opaque);return t?.id}_getInternalTexture(e,t){const r=Le(e);if(!r)return null;const o=`${e.contentHash}/${t}`;let n=this._textures.get(o);if(!n){let a=null;const s=this._context.stage.renderView.renderingContext.parameters.maxMaxAnisotropy,i={wrap:Ue(e.wrap),noUnpackFlip:!0,maxAnisotropy:s,mipmap:s>1};K(r)?(a=r.data,i.preMultiplyAlpha=!1,i.encoding=r.encoding):(a=r,i.preMultiplyAlpha=t!==me.Opaque,i.downsampleUncompressed=this._context.graphicsCoreOwner.view.qualitySettings.graphics3D.uncompressedTextureDownsamplingEnabled),n=new ge(a,i),this._textures.set(o,n),n.load(this._context.stage.renderView.renderingContext),this._context.stage.add(n)}return n}_setInternalMaterialParameters(t,r){if(null!=t.color&&$e(t.color,r),null!=t.colorTexture){const e=this._getInternalTexture(t.colorTexture,r.textureAlphaMode);e?(r.textureId=e.id,r.textureAlphaPremultiplied=!!e.parameters.preMultiplyAlpha):r.textureId=void 0}t.normalTexture&&(r.normalTextureId=this._getInternalTextureId(t.normalTexture)),t.emissiveColor&&(r.emissiveFactor=e.toUnitRGB(t.emissiveColor)),t.emissiveTexture&&(r.emissiveTextureId=this._getInternalTextureId(t.emissiveTexture)),t.occlusionTexture&&(r.occlusionTextureId=this._getInternalTextureId(t.occlusionTexture)),t.metallicRoughnessTexture&&(r.metallicRoughnessTextureId=this._getInternalTextureId(t.metallicRoughnessTexture)),r.colorTextureTransformMatrix=Q(t.colorTextureTransform),r.normalTextureTransformMatrix=Q(t.normalTextureTransform);const o=null!=t.normalTextureTransform?.scale?t.normalTextureTransform?.scale:f;r.scale=[o[0],o[1]],r.occlusionTextureTransformMatrix=Q(t.occlusionTextureTransform),r.emissiveTextureTransformMatrix=Q(t.emissiveTextureTransform),r.metallicRoughnessTextureTransformMatrix=Q(t.metallicRoughnessTextureTransform)}_setExternalMaterialParameters(t){const r=this._drivenProperties.color;let o=this.symbolLayer.material?.colorMixMode??null;if(r)t.externalColor=w;else{const r=this.symbolLayer.material?.color??null;r?t.externalColor=e.toUnitRGBA(r):(o=null,t.externalColor=w)}o&&(t.colorMixMode=o),t.castShadows=!!this.symbolLayer.castShadows}_getOrCreateMaterial(t,r){const o=r.material?.color,n=r.material?.colorTexture,a=r.material?.alphaMode,s="blend"===a,i=!("opaque"===a)&&(De(t)||null!=o&&o.a<1||n?.transparent||s),l=this._materialProperties(t,r,i),c=this._materialInfoCache.byUid(l.uid);if(c)return c.material;const u={uid:l.uid,material:null,isComponentTransparent:i,alphaMode:r.material?r.material.alphaMode:"opaque"},m=be({normalTexture:l.normalTexture,metallicRoughnessTexture:l.metallicRoughnessTexture,metallicFactor:l.metallic,roughnessFactor:l.roughness,emissiveTexture:l.emissiveTexture,emissiveFactor:e.toUnitRGB(l.emissiveColor),occlusionTexture:l.occlusionTexture}),f={usePBR:this._usePBR(),isSchematic:m,hasVertexColors:l.hasVertexColors,hasSymbolColors:l.hasSymbolVertexColors,hasVertexTangents:l.hasVertexTangents,ambient:b,diffuse:y,opacity:1,doubleSided:!0,doubleSidedType:"winding-order",cullFace:fe.None,layerOpacity:this._getLayerOpacity(),hasSlicePlane:this._context.slicePlaneEnabled,initTextureTransparent:!0};f.mrrFactors=m?[...ye]:[l.metallic,l.roughness,ve[2]],r.material&&(f.doubleSided=r.material.doubleSided,f.cullFace=r.material.doubleSided?fe.None:fe.Back,f.textureAlphaCutoff=r.material.alphaCutoff),this._setExternalMaterialParameters(f),this._setMaterialTransparentParameter(f,u),this._setInternalMaterialParameters(l,f);const p=new _e(f);return u.material=p,this._materialInfoCache.set(l.uid,u),this._context.stage.add(p),p}_usePBR(){return this._context.physicalBasedRenderingEnabled}_setMaterialTransparentParameter(e,t){e.transparent=this.needsDrivenTransparentPass||t.isComponentTransparent||e.layerOpacity<1||e.opacity<1||e.externalColor&&e.externalColor[3]<1,"auto"===t.alphaMode?e.textureAlphaMode=e.transparent?me.MaskBlend:me.Opaque:e.textureAlphaMode="opaque"===t.alphaMode?me.Opaque:"mask"===t.alphaMode?me.Mask:me.Blend}_addDebugNormals(e,t){const r=t.length,o=e.spatialReference.isGeographic?20015077/180:1,n=.1*Math.max(e.extent.width*o,e.extent.height*o,e.extent.zmax-e.extent.zmin),a=[],s=[],i=[],l=[];for(let f=0;f<r;f++){const e=t[f],r=e.attributes.get(xe.POSITION),o=e.attributes.get(xe.NORMAL),c=r.data,u=r.indices,m=o.data,p=o.indices;for(let t=0;t<u.length;t++){const e=3*u[t],r=3*p[t];for(let t=0;t<3;t++)a.push(c[e+t]);for(let t=0;t<3;t++)a.push(c[e+t]+m[r+t]*n);if(s.push(s.length),s.push(s.length),t%3==0){Se(c,u,t,Je),Ie(c,u,t,ze,Ye,We),h(ze,ze,Ye),h(ze,ze,We),d(ze,ze,1/3);for(let e=0;e<3;e++)i.push(ze[e]);for(let e=0;e<3;e++)i.push(ze[e]+Je[e]*n);l.push(l.length),l.push(l.length)}}}const c=t[0].transformation,u=new he(this._debugVertexNormalMaterial,[[xe.POSITION,new ue(a,s,3,!0)]],null,pe.Line);t.push(u),u.transformation=c;const m=new he(this._debugFaceNormalMaterial,[[xe.POSITION,new ue(i,l,3,!0)]],null,pe.Line);m.transformation=c,t.push(m)}_createAs3DShape(e,t,r,o){const n=e.geometry;if("mesh"!==n.type)return null;const a=this._createGeometryInfo(n,t,o);if(null==a)return null;const{geometries:s,objectTransformation:i}=a;ce.DRAW_MESH_GEOMETRY_NORMALS&&this._addDebugNormals(n,s);const l=new de({geometries:s,layerUid:this._context.layer.uid,graphicUid:o,isElevationSource:!0});l.transformation=i;const c=se(this.symbolLayer,{opacity:this._getLayerOpacity()}),u=c?new re(s[0].material,[c],{mergeGeometries:!0,hasSlicePlane:this._context.slicePlaneEnabled}):null,m=new te(this,l,s,null,null,X,r,u);this._fastUpdateProcessor.onAddGraphic(),m.needsElevationUpdates=Z(r.mode),m.useObjectOriginAsAttachmentOrigin=!0,r.centerPointInElevationSR=this._getCenterPointInElevationSR(l.transformation);const{elevationProvider:f,renderCoordsHelper:p}=this._context,h=(e,t)=>ee(e,f,r,p,t);return m.alignedSampledElevation=X(m,r,f.spatialReference,h,p),m}_getCenterPointInElevationSR(e){const t=Y(0,0,0,null!=this._context.elevationProvider.spatialReference?this._context.elevationProvider.spatialReference:null);return M([e[12],e[13],e[14]],this._context.renderCoordsHelper.spatialReference,t),t}_createPositionBuffer(e,t){let r=e.vertexAttributes.position;const o=t.reprojection===tt.RENDER?t.transformBeforeProject:null;if(o&&(r=L(new Float64Array(r.length),r,o)),t.reprojection===tt.NONE)return t.needsBufferCopy?new Float64Array(r):r;const n=o?r:new Float64Array(r.length);return R(r,e.spatialReference,0,n,this._context.renderCoordsHelper.spatialReference,0,r.length/3),n}_createNormalBuffer(e,t,r){let o=e.vertexAttributes.normal;if(null==o)return null;const n=r.reprojection===tt.RENDER?r.transformBeforeProject:null;n&&(o=H(o,new Float32Array(o.length),n));if("local"===this._context.graphicsCoreOwner.view.viewingMode||r.reprojection===tt.NONE)return r.needsBufferCopy&&e.vertexAttributes.normal===o?new Float32Array(o):o;const a=e.vertexAttributes.position,s=n?o:new Float32Array(o.length);return k(o,a,t,e.spatialReference,s)}_createTangentBuffer(e,t,r){let o=e.vertexAttributes.tangent;if(null==o)return null;const n=r.reprojection===tt.RENDER?r.transformBeforeProject:null;n&&(o=q(o,new Float32Array(o.length),n));if("local"===this._context.graphicsCoreOwner.view.viewingMode||r.reprojection===tt.NONE)return r.needsBufferCopy&&e.vertexAttributes.normal===o?new Float32Array(o):o;const a=e.vertexAttributes.position,s=n?o:new Float32Array(o.length);return z(o,a,t,e.spatialReference,s)}_createSymbolColorBuffer(e){if(this._requiresSymbolVertexColors()){const t=this._getVertexOpacityAndColor(e),r=ie(this.symbolLayer?.material?.colorMixMode),o=new Uint8Array(4);return le(t,r,o),o}return null}_createBuffers(e,t){const r=e.vertexAttributes&&e.vertexAttributes.position;if(!r)return this.logger.warn("Mesh geometry must contain position vertex attributes"),null;const o=e.vertexAttributes.normal,n=e.vertexAttributes.uv,a=e.vertexAttributes.tangent;if(o&&o.length!==r.length)return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"),null;if(a&&a.length/4!=r.length/3)return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"),null;if(n&&n.length/2!=r.length/3)return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"),null;const s=this._computeReprojectionInfo(e),i=this._createPositionBuffer(e,s),l=He(e),u=this._createSymbolColorBuffer(t),m=this._createNormalBuffer(e,i,s),f=this._createTangentBuffer(e,i,s);return{positionBuffer:i,normalBuffer:m,tangentBuffer:f,uvBuffer:n,colorBuffer:l,symbolColorBuffer:u,objectTransformation:s.reprojection===tt.NONE&&s.objectTransformation?s.objectTransformation:this._transformOriginLocal(e,i,m,f),geometryTransformation:s.reprojection===tt.NONE&&s.geometryTransformation?s.geometryTransformation:c()}}_computeReprojectionInfo(e){const{vertexSpace:t}=e,r="georeferenced"===t.type?$(this._context.renderCoordsHelper.spatialReference,e.spatialReference)?tt.NONE:tt.RENDER:tt.NONE;if(D(t)){const o=t.origin,n=c(),i=e.transform?.localMatrix??u;if(r===tt.NONE){C(e.spatialReference,o,n,this._context.renderCoordsHelper.spatialReference);return{reprojection:r,objectTransformation:n,geometryTransformation:m(i),needsBufferCopy:!1}}const l=a(c(),o);return s(l,l,i),{reprojection:r,transformBeforeProject:l,needsBufferCopy:!0}}return{reprojection:r,needsBufferCopy:!0}}_transformOriginLocal(e,t,n,a){const s=this._context.renderCoordsHelper.spatialReference,l=e.anchor;qe[0]=l.x,qe[1]=l.y,qe[2]=l.z??0;const u=c();return C(e.spatialReference,qe,u,s),i(Ke,u),L(t,t,Ke),(n||a)&&(r(Qe,u),o(Qe,Qe),n&&G(n,n,Qe),a&&G(a,a,Qe,4)),u}_validateFaces(e,t){const r=e.vertexAttributes.position.length/3,o=t.faces;if(o){let e=-1;for(let t=0;t<o.length;t++){const r=o[t];r>e&&(e=r)}if(r<=e)return this.logger.warn(`Vertex index ${e} is out of bounds of the mesh position buffer`),!1}else if(r%3!=0)return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"),!1;return!0}_isOutsideClippingArea(e){if(!this._context.clippingExtent)return!1;const t=e.vertexAttributes?.position;if(!t)return!1;const r=this._context.elevationProvider.spatialReference,o=V({positions:t,transform:e.transform,vertexSpace:e.vertexSpace,inSpatialReference:e.spatialReference,outSpatialReference:r??e.spatialReference,localMode:this._context.stage.viewingMode===J.Local}),n=o.length/3;return A(Ze),E(Ze,o,0,n),!O(Ze,this._context.clippingExtent)}_createGeometryInfo(e,t,r){if(!j(e.spatialReference,this._context.renderCoordsHelper.spatialReference))return this.logger.warn("Geometry spatial reference is not compatible with the view"),null;if(!this._validateVertexSpace(e))return null;if(this._isOutsideClippingArea(e))return null;const o=this._createBuffers(e,t);if(null==o)return null;const{positionBuffer:n,uvBuffer:a,colorBuffer:s,symbolColorBuffer:i,normalBuffer:c,tangentBuffer:u,objectTransformation:m,geometryTransformation:f}=o,p=Ne(e),h=new Array;let d=!1;const g=l(ze,m),x=this._context.localOriginFactory.getOrigin(g);for(const l of p){if(!this._validateFaces(e,l))return null;const t=Me(e,l);if(0===t.length)continue;const o=Pe(n,c,l,t);o.didFlipNormals&&(d=!0);const m=[[xe.POSITION,new ue(n,t,3,!0)],[xe.NORMAL,new ue(o.normals,o.indices,3,!0)]];s&&m.push([xe.COLOR,new ue(s,t,4,!0)]),i&&m.push([xe.SYMBOLCOLOR,new ue(i,S(t.length),4,!0)]),a&&m.push([xe.UV0,new ue(a,t,2,!0)]),u&&m.push([xe.TANGENT,new ue(u,t,4,!0)]);const p=this._context.stage.renderView.getObjectAndLayerIdColor({graphicUid:r,layerUid:this._context.layer.uid}),g=this._getOrCreateMaterial(e,l),_=new he(g,m,null,pe.Mesh,p);_.transformation=f,_.localOrigin=x,h.push(_)}return d&&this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals."),{geometries:h,objectTransformation:m}}_updateMaterialParameters(e){this._materialInfoCache.forEachMaterialInfo(e),this._fastUpdateProcessor.forEachMaterialInfo(e),this._fastUpdateProcessor.forEachClonedMaterial(((e,t)=>{t.setParameters(e.parameters)}))}_validateVertexSpace(e){const{_context:{graphicsCoreOwner:{view:{state:{viewingMode:t}}}}}=this,{vertexSpace:r}=e;return t!==J.Local||"local"!==r.type||(this.logger.warn("Displaying a mesh with a local vertex space in a view in local viewing mode is not supported."),!1)}test(){return{...super.test(),materials:this._materialInfoCache.materials}}}class Re{constructor(e,t,r){this.normals=e,this.indices=t,this.didFlipNormals=r}}function Me(e,t){return t.faces??N(e.vertexAttributes.position.length/3)}function Pe(e,t,r,o){switch(r.shading||"flat"){default:case"source":return Ee(e,t,r,o);case"flat":return Ae(e,o);case"smooth":return Oe(e,o)}}function Ae(e,t){const r=I(t.length),o=new Array(3*t.length);for(let n=0;n<t.length;n+=3){const a=Se(e,t,n,Je);for(let e=0;e<3;e++)r[n+e]=a[e],o[n+e]=n/3}return new Re(r,o,!1)}function Ee(e,t,r,o){if(null==t)return Ae(e,o);let n=!1;if(!r.trustSourceNormals)for(let a=0;a<o.length;a+=3){Se(e,o,a,Je);for(let e=0;e<3;e++){const r=3*o[a+e];ze[0]=t[r],ze[1]=t[r+1],ze[2]=t[r+2],g(Je,ze)<0&&(t[r]=-t[r],t[r+1]=-t[r+1],t[r+2]=-t[r+2],n=!0)}}return new Re(t,o,n)}function Oe(e,t){const r={};for(let a=0;a<t.length;a+=3){const o=Se(e,t,a,Je);for(let e=0;e<3;e++){const n=t[a+e];let s=r[n];s||(s={normal:v(),count:0},r[n]=s),h(s.normal,s.normal,o),s.count++}}const o=I(3*t.length),n=new Array(3*t.length);for(let a=0;a<t.length;a++){const e=r[t[a]];1!==e.count&&(x(e.normal,e.normal),e.count=1);for(let t=0;t<3;t++)o[3*a+t]=e.normal[t];n[a]=a}return new Re(o,n,!1)}function Ie(e,t,r,o,n,a){const s=3*t[r],i=3*t[r+1],l=3*t[r+2];o[0]=e[s],o[1]=e[s+1],o[2]=e[s+2],n[0]=e[i],n[1]=e[i+1],n[2]=e[i+2],a[0]=e[l],a[1]=e[l+1],a[2]=e[l+2]}function Se(e,t,r,o){return Ie(e,t,r,ze,Ye,We),_(Ye,Ye,ze),_(We,We,ze),T(ze,Ye,We),x(o,ze),o}function Ne(e){return e.components??et}function Be(e){if(!e)return null;const{scale:r,offset:o,rotation:n}=e;return{scale:r,offset:o,rotation:t(n)}}function Ue(e="repeat"){if("string"==typeof e){const t=Fe(e);return{s:t,t}}return{s:Fe(e.horizontal),t:Fe(e.vertical)}}function Fe(e){switch(e){case"clamp":return we.CLAMP_TO_EDGE;case"mirror":return we.MIRRORED_REPEAT;default:return we.REPEAT}}function De(e){const t=e.vertexAttributes.color;if(null==t)return!1;for(let r=3;r<t.length;r+=4)if(255!==t[r])return!0;return!1}function $e(t,r){r.diffuse=e.toUnitRGB(t),r.opacity=t.a}function Le(e){return e.data??e.url}function Ge(t){return null==t?"-":t instanceof e?t.toHex():t.contentHash}function Ve(e){const{offset:t,scale:r,rotation:o}=e??ke;return`${t[0]},${t[1]},${o},${r[0]},${r[1]}`}function He(e){return e.vertexAttributes.color}const ke=new F,qe=v(),ze=v(),Ye=v(),We=v(),Je=v(),Ke=c(),Qe=n(),Xe=c(),Ze=P(),et=[new B];var tt;!function(e){e[e.NONE=0]="NONE",e[e.RENDER=1]="RENDER"}(tt||(tt={}));export{Ce as Graphics3DMeshFillSymbolLayer};
