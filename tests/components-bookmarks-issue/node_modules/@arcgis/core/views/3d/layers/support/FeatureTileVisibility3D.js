/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{acosClamped as e}from"../../../../core/mathUtils.js";import t from"../../../../core/ObjectPool.js";import{n as s,z as i,k as r,r as n,s as o,o as u,b as c,g as l,h as a,H as d,F as _,f as h}from"../../../../chunks/vec32.js";import{create as f,fromValues as m}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as p}from"../../../../geometry/ellipsoidUtils.js";import{getSphericalPCPF as T}from"../../../../geometry/spatialReferenceEllipsoidUtils.js";import{projectBuffer as E}from"../../../../geometry/projection/projectBuffer.js";import{projectVec3Array as R}from"../../../../geometry/projection/projectVec3Array.js";import{PlaneIndex as g,PointIndex as F}from"../../../../geometry/support/frustum.js";import{create as I,projectVector as S,fromPoints as A,getNormal as O,signedDistance as b}from"../../../../geometry/support/plane.js";import{wrap as B}from"../../../../geometry/support/ray.js";import{ViewingMode as P}from"../../../ViewingMode.js";import{FeatureTileDescriptor3D as j,Visibility as M}from"./FeatureTileDescriptor3D.js";import{Frustum as x}from"../../state/Frustum.js";import{FrustumExtentIntersection as H}from"../../support/FrustumExtentIntersection.js";class N{constructor(e){this._renderCoordsHelper=e,this._surfaceElevation=0,this._cache=new Map,this._frustumBoundingSphereCenter=f(),this._frustumBoundingSphereRadius=0,this._frustum=new x(e),this._extendedFrustum=new x(e),this._intersector=new H({renderCoordsHelper:e}),this._renderSR=e.spatialReference;const t=T(this._renderSR);this._renderSREllipsoidRadius=p(t).radius,this._renderCoordsHelper=e}begin(e,t){this._surfaceElevation=t,this._aboveGround=this._renderCoordsHelper.getAltitude(e.eye)>t,this._frustum.update(e),k(this._frustum),this._updateExtendedFrustum(e),this._updateFrustumBoundingSphere()}end(){this._cache.clear()}calculate(e){const t=this._renderCoordsHelper.viewingMode===P.Global&&e.lij[0]>=V&&e.lij[0]<G,s=this._getOrCalculateSingleTileVisibility(e,!t);return s!==M.INVISIBLE&&t?this._calculateAggregatedChildrenVisibility(e):s}_calculateAggregatedChildrenVisibility(e){let t=M.INVISIBLE;const s=this._cache.get(e.id);if(null!=s)return s;const i=W.acquire();e.getChildren(i);for(const r of i){const e=this.calculate(r);if(e!==M.INVISIBLE&&(t=e,e===M.VISIBLE_ON_SURFACE))break}return W.release(i),this._cache.set(e.id,t),t}_getOrCalculateSingleTileVisibility(e,t){const s=this._cache.get(e.id);if(null!=s)return s;const i=this._calculateSingleTileVisibility(e);return t&&this._cache.set(e.id,i),i}_calculateSingleTileVisibility(e){if(!this._aboveGround&&this._renderCoordsHelper.viewingMode===P.Global&&e.lij[0]<L){return this._calculateSingleTileVisibilitySided(e,!1)===M.INVISIBLE?this._calculateSingleTileVisibilitySided(e,!0):void 0}return this._calculateSingleTileVisibilitySided(e,this._aboveGround)}_isTileVisibleInFrustum(e){return this._renderCoordsHelper.viewingMode===P.Local?this._isTileVisibleInFrustumLocal(e):this._isTileVisibleInFrustumGlobal(e)}_updateFrustumBoundingSphere(){const e=this._frustum,t=e.origin,o=le;s(o,e.direction);const u=e.points,c=ae;i(c,u[4],t);const l=.5*r(c,c)/r(o,c),a=this._frustumBoundingSphereCenter;n(a,t,o,l);const d=1+l;this._frustumBoundingSphereRadius=d}_isTileVisibleInFrustumLocal(e){const t=e.tilingScheme.spatialReference,s=e.extent,c=this._renderSR,l=$;if(l[0]=s[0],l[1]=s[1],l[2]=0,l[3]=s[2],l[4]=s[3],l[5]=0,!E(l,t,0,l,c,0,2))return!1;const a=ee;o(a[0],l[0],l[1],0),o(a[1],l[3],l[1],0),o(a[2],l[3],l[4],0),o(a[3],l[0],l[4],0);const d=te;o(d,.5*(l[0]+l[3]),.5*(l[1]+l[4]),.5*(l[2]+l[5]));const _=se;o(_,0,0,1);const h=.5*u(a[0],a[2]),f=this._frustum,m=this._frustumBoundingSphereRadius,p=this._frustumBoundingSphereCenter,T=_e;i(T,p,d);const R=r(_,T),g=de;n(g,d,_,R);if(u(g,p)>h+m)return!1;const F=Z,I=R+m,S=R-m;for(let i=0;i<4;++i)n(F[i],a[i],_,I),n(F[i+4],a[i],_,S);return!J(f.planes,F,8)}_isTileVisibleInFrustumGlobal(e){const t=e.tilingScheme.spatialReference,_=e.extent;if(e.lij[0]<K)return!0;const h=ee,f=.5*(_[0]+_[2]);if(o(h[0],_[0],_[1],0),o(h[1],_[2],_[1],0),o(h[2],_[2],_[3],0),o(h[3],_[0],_[3],0),o(h[4],f,_[1],0),o(h[5],f,_[3],0),!R(h,t,0,h,this._renderSR,0,6))return!1;const p=h[0][2]>0,T=h[3][2]<0,E=p||T,g=this._renderSREllipsoidRadius;if(E){const e=m(0,0,1),t=re;q(t,e,h[0]);const s=ne;if(q(s,e,h[1]),p){const i=ie,r=h[4],n=oe;q(n,r,e),q(i,n,r);const o=h[0];c(o,t,i),D(o,g);const u=h[1];c(u,s,i),D(u,g)}else if(T){const i=ie,r=h[5],n=oe;q(n,r,e),q(i,r,n);const o=h[3];c(o,i,t),D(o,g);const u=h[2];c(u,i,s),D(u,g)}}const F=te;{const e=Te;i(e,h[3],h[0]),s(e,e);const t=Ee;l(t,h[0],h[3]),a(t,t,.5);const o=-r(t,e),u=Re,c=ge;l(u,h[0],h[1]),a(u,u,.5),l(c,h[2],h[3]),a(c,c,.5);const d=Fe;i(d,c,u),s(d,d);const _=-(o+r(e,u))/r(e,d);n(F,u,d,_),D(F,g)}const I=this._frustumBoundingSphereRadius,S=this._frustumBoundingSphereCenter,A=this._frustum,O=A.planes,b=ue;s(b,F);let B=1;for(let i=0;i<4;++i){s(Ce,h[i]);const e=r(Ce,b);e>=0&&e<B&&(B=e)}const P=Math.sqrt(1-B*B);if(P>.9)return!0;{const e=r(b,S),t=d(S);if(t<=I)return!0;const s=e/t;if(e<=0){if(-e>I)return!1}const i=I/t;if(Math.sqrt(1-s*s)*Math.sqrt(1-i*i)-i*s>P)return!1}if(h.some((e=>A.intersectsPoint(e))))return!0;if(A.intersectsPoint(F))return!0;const j=fe;i(j,S,he);const M=r(j,b),x=ce;a(x,b,M);const H=u(x,S),N=t.isWGS84,V=e.lij,G=N&&V[2]===2**V[0]-1,L=N&&0===V[2],y=L?xe:G?je:Be,C=L?He:G?Me:Pe,v=A.points;{const e=h,t=Ne,s=Ie,i=Se,r=he;for(const n of y){const o=e[n];if(z(s,e[(n+1)%4],o),z(i,r,o),q(t,i,s),Q(t,v,1))return!1}}let w=null;if(M<2*I){const e=2.5*I;if(H>B*e+I)return!1;const t=pe,s=e/B;for(let i=0;i<4;++i)a(t[i],h[i],s/g);o(t[4],0,0,0),w=t}else{const e=(M+I)/B,t=(M-I)/B,s=me;for(let i=0;i<4;++i){const r=h[i];a(s[i+4],r,t/g),a(s[i],r,e/g)}w=s}if(J(O,w,w.length))return!1;const U=A.lines,W=Ae,k=Oe;for(const i of C){s(W,h[i]);for(const e of U)if(s(k,e.direction),ye(k,W,w,v))return!1}return!0}_calculateSingleTileVisibilitySided(e,t){return this._isTileVisibleInFrustum(e)?(this._intersector.update(e.extent,e.tilingScheme.spatialReference,this._surfaceElevation,t),this._intersector.isVisibleInFrustum(this._frustum,this._renderSREllipsoidRadius,!0)?M.VISIBLE_ON_SURFACE:M.VISIBLE_WHEN_EXTENDED):M.INVISIBLE}_updateExtendedFrustum(t){this._extendedFrustum.update(t),k(this._extendedFrustum);const s=this._renderCoordsHelper.worldUpAtPosition(t.eye,v);this._aboveGround||_(s,s);const i=e(-r(s,t.viewForward));if(this._hasExtendedFrustum=i>t.fovY/2,!this._hasExtendedFrustum)return;const n=this._extendedFrustumParameters(),o=this._extendedFrustum.mutablePoints;for(let e=0;e<4;e++){const t=n.pointIndices[e],s=o[t],i=this._renderCoordsHelper.getAltitude(s);if(n.needsAltitudeAdjustment(i)){switch(this._renderCoordsHelper.worldUpAtPosition(s,v),t){case F.FAR_BOTTOM_LEFT:case F.FAR_TOP_LEFT:case F.NEAR_BOTTOM_LEFT:case F.NEAR_TOP_LEFT:S(this._extendedFrustum.planes[g.LEFT],v,v);break;case F.FAR_BOTTOM_RIGHT:case F.FAR_TOP_RIGHT:case F.NEAR_BOTTOM_RIGHT:case F.NEAR_TOP_RIGHT:S(this._extendedFrustum.planes[g.RIGHT],v,v)}a(v,v,n.direction),this._renderCoordsHelper.intersectInfiniteManifold(B(s,v),n.zWithMargin,s)}}if(this._extendedFrustum.updatePoints(o),A(o[F.NEAR_BOTTOM_LEFT],o[F.NEAR_BOTTOM_RIGHT],o[F.NEAR_TOP_RIGHT],w),A(o[F.NEAR_BOTTOM_RIGHT],o[F.NEAR_TOP_RIGHT],o[F.NEAR_TOP_LEFT],U),r(O(w),O(U))<0){const e=this._extendedFrustum.mutablePoints;this._aboveGround?[e[F.NEAR_BOTTOM_LEFT],e[F.NEAR_BOTTOM_RIGHT]]=[e[F.NEAR_BOTTOM_RIGHT],e[F.NEAR_BOTTOM_LEFT]]:[e[F.NEAR_TOP_LEFT],e[F.NEAR_TOP_RIGHT]]=[e[F.NEAR_TOP_RIGHT],e[F.NEAR_TOP_LEFT]],this._extendedFrustum.updatePoints(e)}}_extendedFrustumParameters(){return this._aboveGround?this._extendedFrustumParametersAboveSurface():this._extendedFrustumParametersBelowSurface()}_extendedFrustumParametersAboveSurface(){const e=this._surfaceElevation-C;return{zWithMargin:e,pointIndices:x.planePointIndices.bottom,direction:-1,needsAltitudeAdjustment:t=>t>e}}_extendedFrustumParametersBelowSurface(){const e=this._surfaceElevation+C;return{zWithMargin:e,pointIndices:x.planePointIndices.top,direction:1,needsAltitudeAdjustment:t=>t<e}}}const V=2,G=6,L=12,y=.95,C=1,v=f(),w=I(),U=I(),W=new t(Array,(e=>{4!==e.length&&(e[0]=new j,e[1]=new j,e[2]=new j,e[3]=new j)}),(e=>{e[0].release(),e[1].release(),e[2].release(),e[3].release()}));function k(e){const t=x.nearFarLineIndices,s=e.mutablePoints;for(const i of t){const[e,t]=i,r=s[e],n=s[t];h(v,n,r),a(v,v,y),l(s[t],r,v)}e.updatePoints(s)}function q(e,t,i){return c(e,t,i),s(e,e),e}function z(e,t,r){return i(e,t,r),s(e,e),e}function D(e,t){return a(e,e,t/d(e)),e}const X=[g.LEFT,g.RIGHT,g.BOTTOM,g.TOP,g.FAR];function Y(e,t,s){for(let i=0;i<s;++i)if(b(e,t[i])<0)return!1;return!0}function J(e,t,s){for(const i of X)if(Y(e[i],t,s))return!0;return!1}const K=3;function Q(e,t,s){for(const i of t)if(r(i,e)<s)return!1;return!0}const Z=[f(),f(),f(),f(),f(),f(),f(),f()],$=[0,0,0,0,0,0],ee=[f(),f(),f(),f(),f(),f()],te=f(),se=f(),ie=f(),re=f(),ne=f(),oe=f(),ue=f(),ce=f(),le=f(),ae=f(),de=f(),_e=f(),he=m(0,0,0),fe=f(),me=[f(),f(),f(),f(),f(),f(),f(),f()],pe=[f(),f(),f(),f(),f()],Te=f(),Ee=f(),Re=f(),ge=f(),Fe=f(),Ie=f(),Se=f(),Ae=f(),Oe=f(),be=f(),Be=[0,1,2,3],Pe=[0,1,2,3],je=[0,1,3],Me=[0,1,3],xe=[1,2,3],He=[1,2,3],Ne=f();function Ve(e,t,s){let i=1/0,n=-1/0;for(const o of s){const e=r(t,o);i=Math.min(i,e),n=Math.max(n,e)}e[0]=i,e[1]=n}function Ge(e,t,s,i){let n=1/0,o=-1/0;for(const u of i){const i=r(s,u);if(n=Math.min(n,i),o=Math.max(o,i),n<=t&&o>=e)return!1}return!0}const Le=[0,0];function ye(e,t,s,i){const r=be;q(r,e,t);const n=Le;return Ve(n,r,s),Ge(n[0],n[1],r,i)}const Ce=f();export{N as FeatureTileVisibility3D,K as globalTileLevelThreshold,J as isConvexHullOutsideOfFrustum};
