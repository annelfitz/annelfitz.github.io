/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{cyclicalDegrees as e,Cyclical as r}from"../../core/Cyclical.js";import{createAngle as t,convertRotationType as i}from"../../core/quantityUtils.js";import{convertUnit as o}from"../../core/unitUtils.js";import{angle as n}from"../../core/libs/gl-matrix-2/math/vec2.js";import{UNIT_Y as s,create as a}from"../../core/libs/gl-matrix-2/factories/vec2f64.js";import{s as c,j as l,c as u}from"../../chunks/vec32.js";import{create as m}from"../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectVectorToVector as f}from"../../geometry/projection/projectVectorToVector.js";import{geodesicCompatibleSpatialReference as g,inverseGeodeticSolver as p,directGeodeticSolver as v,InverseGeodeticSolverResult as d}from"../../geometry/support/geodesicUtils.js";import{equals as h}from"../../geometry/support/spatialReferenceUtils.js";var j;function R(e,r){if(null==e||null==r)return;const i=b(e,r);return null!=i?t(i,"radians","geographic"):void 0}!function(e){e.Absolute="absolute",e.Relative="relative",e.RelativeBilateral="relative-bilateral"}(j||(j={}));const b=(()=>{const e=m(),r=m();return(t,i)=>(c(e,t.x,t.y,t.z??0),c(r,i.x,i.y,i.z??0),y(e,r,t.spatialReference,i.spatialReference))})(),y=(()=>{const e=a(),r=m(),t=m();return(i,a,c,u)=>{if(l(i,a))return;const m=g(c),v=g(u);if(m&&v&&h(m,v)&&f(i,c,r,m)&&f(a,u,t,v)){const{azimuth:e}=p(M,r,t,m);return null!=e?o(e,"degrees","radians"):void 0}e[0]=a[0]-i[0],e[1]=a[1]-i[1];let d=n(s,e);return e[0]<0&&(d=U-d),d}})();function x(e,r,t,i=j.Absolute){if(r&&t)switch(i){case j.Absolute:return R(r,t);case j.Relative:return w(z(e,r,t),j.Relative);case j.RelativeBilateral:return w(z(e,r,t),j.RelativeBilateral)}}function z(e,r,i){if(!e||!r||!i)return;const o=b(e,r),n=b(r,i);return null!=o&&null!=n?t(n-o,"radians","geographic"):void 0}function w(e,r){if(null==e)return;const i=B(e);switch(r){case j.Absolute:{const e=T.normalize(i,0,!0);return t(e,"degrees","geographic")}case j.Relative:{let e=V.normalize(i,0,!0);return-180===e&&(e=180),t(e,"degrees","geographic")}case j.RelativeBilateral:{const e=Math.abs(V.normalize(i,0,!0));return t(e,"degrees","geographic")}}}const A=(()=>{const e=m();return(r,t,n,s,a,l="geodesic")=>{u(e,t);const m=B(a);if("geodesic"===l){const i=g(n);if(i&&f(e,n,e,i))return v(r,e,m,s,i),r[2]=t[2],!!f(r,i,r,n)}const p=i(m,"geographic","arithmetic"),d=o(p,"degrees","radians"),h=t[0]+s*Math.cos(d),j=t[1]+s*Math.sin(d),R=t[2];return c(r,h,j,R),!0}})();function B(e){return null!=e?i(o(e.value,e.unit,"degrees"),e.rotationType,"geographic"):void 0}const M=new d,U=2*Math.PI,T=e,V=new r(-180,180);export{j as DirectionMode,R as directionBetweenPoints,x as directionForVertices,B as getDegreesGeographic,w as getNormalizedDirection,A as pointFromDistanceAlongAzimuth,y as radiansGeographicBetweenVec};
