/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import t from"../../core/Error.js";import"../../core/has.js";import{checkWebGLError as e}from"./checkWebGLError.js";import{TextureType as i,ResourceType as r,TextureSamplingMode as s,PixelFormat as o,PixelType as a,SizedPixelFormat as n,CompressedTextureFormat as h}from"./enums.js";import{GLObjectType as l}from"./GLObjectType.js";import{estimateMemory as p}from"./TextureDescriptor.js";import{ValidatedTextureDescriptor as d}from"./ValidatedTextureDescriptor.js";const _=4,c=null;let m=class h{constructor(e,r=null,s=null){if(this.type=l.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,s=r;else{const i=d.validate(e,r);if(!i)throw new t("Texture descriptor invalid");this._descriptor=i}this._descriptor.target===i.TEXTURE_CUBE_MAP?this._setDataCubeMap(s):this.setData(s)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return p(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._glName&&this._descriptor.context.instanceCounter.decrement(r.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,r){const s=this._descriptor;if(s.width!==e||s.height!==r){if(this._wasImmutablyAllocated)throw new t("Immutable textures can't be resized!");s.width=e,s.height=r,this._descriptor.target===i.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(t=null){for(let e=i.TEXTURE_CUBE_MAP_POSITIVE_X;e<=i.TEXTURE_CUBE_MAP_NEGATIVE_Z;e++)this._setData(t,e)}setData(t){this._setData(t)}_setData(i,s){if(!this._descriptor.context?.gl)return;const o=this._descriptor.context.gl;e(o),this._glName||(this._glName=o.createTexture(),this._glName&&this._descriptor.context.instanceCounter.increment(r.Texture,this)),void 0===i&&(i=null);const a=this._descriptor,n=s??a.target,l=R(n);null===i&&(a.width=a.width||_,a.height=a.height||_,l&&(a.depth=a.depth??1));const p=this._descriptor.context.bindTexture(this,h.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(h.TEXTURE_UNIT_FOR_UPDATES),u(a),this._configurePixelStorage(),e(o);const d=this._deriveInternalFormat();if(I(i)){let t="width"in i?i.width:i.codedWidth,r="height"in i?i.height:i.codedHeight;const s=1;i instanceof HTMLVideoElement&&(t=i.videoWidth,r=i.videoHeight),a.width&&a.height,l&&a.depth,a.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(n,d,a.hasMipmap,t,r,s),this._texImage(n,0,d,t,r,s,i),e(o),a.hasMipmap&&this.generateMipmap(),a.width||(a.width=t),a.height||(a.height=r),l&&!a.depth&&(a.depth=s)}else{const{width:r,height:s,depth:h}=a;if(null==r||null==s)throw new t("Width and height must be specified!");if(l&&null==h)throw new t("Depth must be specified!");if(a.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(n,d,a.hasMipmap,r,s,h),A(i)){const e=i.levels,l=w(n,r,s,h),p=Math.min(l-1,e.length-1);o.texParameteri(a.target,this._descriptor.context.gl.TEXTURE_MAX_LEVEL,p);const _=d;if(!M(_))throw new t("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel(((t,i,r,s)=>{const o=e[Math.min(t,e.length-1)];this._compressedTexImage(n,t,_,i,r,s,o)}),p)}else this._texImage(n,0,d,r,s,h,i),e(o),a.hasMipmap&&this.generateMipmap()}T(o,this._descriptor),g(o,this._descriptor),E(this._descriptor.context,this._descriptor),e(o),this._descriptor.context.bindTexture(p,h.TEXTURE_UNIT_FOR_UPDATES)}updateData(e,i,r,s,o,a,n=0){a||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const l=this._descriptor,p=this._deriveInternalFormat(),{context:d,pixelFormat:_,dataType:c,target:m,isImmutable:u}=l;if(u&&!this._wasImmutablyAllocated)throw new t("Cannot update immutable texture before allocation!");const T=d.bindTexture(this,h.TEXTURE_UNIT_FOR_UPDATES,!0);(i<0||r<0||s>l.width||o>l.height||i+s>l.width||r+o>l.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:g}=d;n&&g.pixelStorei(g.UNPACK_SKIP_ROWS,n),I(a)?g.texSubImage2D(m,e,i,r,s,o,_,c,a):A(a)?g.compressedTexSubImage2D(m,e,i,r,s,o,p,a.levels[e]):g.texSubImage2D(m,e,i,r,s,o,_,c,a),n&&g.pixelStorei(g.UNPACK_SKIP_ROWS,0),d.bindTexture(T,h.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,i,r,s,o,a,n,l){l||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const p=this._descriptor,d=this._deriveInternalFormat(),{context:_,pixelFormat:c,dataType:m,isImmutable:u,target:T}=p;if(u&&!this._wasImmutablyAllocated)throw new t("Cannot update immutable texture before allocation!");R(T)||console.warn("Attempting to set 3D texture data on a non-3D texture");const g=_.bindTexture(this,h.TEXTURE_UNIT_FOR_UPDATES);_.setActiveTexture(h.TEXTURE_UNIT_FOR_UPDATES),(i<0||r<0||s<0||o>p.width||a>p.height||n>p.depth||i+o>p.width||r+a>p.height||s+n>p.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:E}=_;if(A(l))l=l.levels[e],E.compressedTexSubImage3D(T,e,i,r,s,o,a,n,d,l);else{const t=l;E.texSubImage3D(T,e,i,r,s,o,a,n,c,m,t)}_.bindTexture(g,h.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const e=this._descriptor;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new t("Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,u(e)}e.samplingMode===s.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=s.LINEAR_MIPMAP_NEAREST):e.samplingMode===s.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=s.NEAREST_MIPMAP_NEAREST);const i=this._descriptor.context.bindTexture(this,h.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(h.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(i,h.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(t){t!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=t,this._samplingModeDirty=!0)}setWrapMode(t){t!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=t,u(this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const t=this._descriptor,e=t.context.gl;this._samplingModeDirty&&(T(e,t),this._samplingModeDirty=!1),this._wrapModeDirty&&(g(e,t),this._wrapModeDirty=!1)}_deriveInternalFormat(){if(null!=this._descriptor.internalFormat)return this._descriptor.internalFormat===o.DEPTH_STENCIL&&(this._descriptor.internalFormat=o.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case a.FLOAT:switch(this._descriptor.pixelFormat){case o.RGBA:return this._descriptor.internalFormat=n.RGBA32F;case o.RGB:return this._descriptor.internalFormat=n.RGB32F;default:throw new t("Unable to derive format")}case a.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case o.RGBA:return this._descriptor.internalFormat=n.RGBA8;case o.RGB:return this._descriptor.internalFormat=n.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===o.DEPTH_STENCIL?o.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){const t=this._descriptor.context.gl,{unpackAlignment:e,flipped:i,preMultiplyAlpha:r}=this._descriptor;t.pixelStorei(t.UNPACK_ALIGNMENT,e),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,i?1:0),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r?1:0)}_texStorage(e,i,r,s,o,a){const{gl:n}=this._descriptor.context;if(!x(i))throw new t("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const h=r?w(e,s,o,a):1;if(R(e)){if(null==a)throw new t("Missing depth dimension for 3D texture upload");n.texStorage3D(e,h,i,s,o,a)}else n.texStorage2D(e,h,i,s,o);this._wasImmutablyAllocated=!0}_texImage(e,i,r,s,o,a,n){const h=this._descriptor.context.gl,l=R(e),{isImmutable:p,pixelFormat:d,dataType:_}=this._descriptor;if(p){if(null!=n){const r=n;if(l){if(null==a)throw new t("Missing depth dimension for 3D texture upload");h.texSubImage3D(e,i,0,0,0,s,o,a,d,_,r)}else h.texSubImage2D(e,i,0,0,s,o,d,_,r)}}else{const p=n;if(l){if(null==a)throw new t("Missing depth dimension for 3D texture upload");h.texImage3D(e,i,r,s,o,a,0,d,_,p)}else h.texImage2D(e,i,r,s,o,0,d,_,p)}}_compressedTexImage(e,i,r,s,o,a,n){const h=this._descriptor.context.gl,l=R(e);if(this._descriptor.isImmutable){if(null!=n)if(l){if(null==a)throw new t("Missing depth dimension for 3D texture upload");h.compressedTexSubImage3D(e,i,0,0,0,s,o,a,r,n)}else h.compressedTexSubImage2D(e,i,0,0,s,o,r,n)}else if(l){if(null==a)throw new t("Missing depth dimension for 3D texture upload");h.compressedTexImage3D(e,i,r,s,o,a,0,n)}else h.compressedTexImage2D(e,i,r,s,o,0,n)}_forEachMipmapLevel(e,r=1/0){let{width:s,height:o,depth:a,hasMipmap:n,target:h}=this._descriptor;const l=h===i.TEXTURE_3D;if(null==s||null==o||l&&null==a)throw new t("Missing texture dimensions for mipmap calculation");for(let t=0;e(t,s,o,a),n&&(1!==s||1!==o||l&&1!==a)&&!(t>=r);++t)s=Math.max(1,s>>1),o=Math.max(1,o>>1),l&&(a=Math.max(1,a>>1))}};function u(t){(null!=t.width&&t.width<0||null!=t.height&&t.height<0||null!=t.depth&&t.depth<0)&&console.error("Negative dimension parameters are not allowed!")}function T(t,e){let i=e.samplingMode,r=e.samplingMode;i===s.LINEAR_MIPMAP_NEAREST||i===s.LINEAR_MIPMAP_LINEAR?(i=s.LINEAR,e.hasMipmap||(r=s.LINEAR)):i!==s.NEAREST_MIPMAP_NEAREST&&i!==s.NEAREST_MIPMAP_LINEAR||(i=s.NEAREST,e.hasMipmap||(r=s.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,i),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,r)}function g(t,e){"number"==typeof e.wrapMode?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}function E(t,e){const i=t.capabilities.textureFilterAnisotropic;if(!i)return;t.gl.texParameterf(e.target,i.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}function x(t){return t in n}function M(t){return t in h}function A(t){return null!=t&&"type"in t&&"compressed"===t.type}function f(t){return null!=t&&"byteLength"in t}function I(t){return null!=t&&!A(t)&&!f(t)}function R(t){return t===i.TEXTURE_3D||t===i.TEXTURE_2D_ARRAY}function w(t,e,r,s=1){let o=Math.max(e,r);return t===i.TEXTURE_3D&&(o=Math.max(o,s)),Math.round(Math.log(o)/Math.LN2)+1}m.TEXTURE_UNIT_FOR_UPDATES=0;export{m as Texture,c as tracer};
