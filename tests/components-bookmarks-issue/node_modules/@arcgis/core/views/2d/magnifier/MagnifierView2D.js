/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../request.js";import{createTask as r}from"../../../core/asyncUtils.js";import s from"../../../core/Handles.js";import{clamp as t}from"../../../core/mathUtils.js";import{destroyMaybe as i,abortMaybe as o,disposeMaybe as a}from"../../../core/maybe.js";import{watch as n,initial as l}from"../../../core/reactiveUtils.js";import{isSVG as h}from"../../../core/urlUtils.js";import{create as m}from"../../../core/libs/gl-matrix-2/factories/mat3f32.js";import{UpdatingHandles as u}from"../../../core/support/UpdatingHandles.js";import{DisplayObject as c}from"../engine/DisplayObject.js";import{Pos2us as d}from"../engine/webgl/DefaultVertexAttributeLayouts.js";import{WGLDrawPhase as _}from"../engine/webgl/enums.js";import{createMagnifierProgram as p,magnifierProgramTemplate as f}from"../engine/webgl/shaders/MagnifierPrograms.js";import{loadMagnifierResources as g}from"../../magnifier/resources.js";import{BufferObject as x}from"../../webgl/BufferObject.js";import{PrimitiveType as b,Usage as T,PixelFormat as y,TextureWrapMode as k,TextureSamplingMode as R}from"../../webgl/enums.js";import{Texture as v}from"../../webgl/Texture.js";import{TextureDescriptor as j}from"../../webgl/TextureDescriptor.js";import{VertexArrayObject as w}from"../../webgl/VertexArrayObject.js";class A extends c{constructor(){super(),this._handles=new s,this._resourcePixelRatio=1,this.updatingHandles=new u,this.visible=!1}destroy(){this._handles=i(this._handles),this._disposeRenderResources(),this._resourcesTask=o(this._resourcesTask)}get backgroundColor(){return this._backgroundColor}set backgroundColor(e){this._backgroundColor=e,this.requestRender()}get magnifier(){return this._magnifier}set magnifier(e){this._magnifier=e,this._handles.removeAll(),this._handles.add([n((()=>e.version),(()=>{this.visible=e.visible&&null!=e.position&&e.size>0,this.requestRender()}),l),n((()=>[e.maskUrl,e.overlayUrl]),(()=>this._reloadResources())),n((()=>e.size),(()=>{this._disposeRenderResources(),this.requestRender()}))])}_createTransforms(){return{displayViewScreenMat3:m()}}doRender(e){const r=e.context;if(!this._resourcesTask)return void this._reloadResources();if(e.drawPhase!==_.MAP||!this._canRender())return;this._updateResources(e);const s=this._magnifier;if(null==s.position)return;const i=e.pixelRatio,o=s.size*i,a=1/s.factor,n=Math.ceil(a*o);this._readbackTexture.resize(n,n);const{size:l}=e.state,h=i*l[0],m=i*l[1],u=.5*n,c=.5*n,d=t(i*s.position.x,u,h-u-1),p=t(m-i*s.position.y,c,m-c-1);r.setBlendingEnabled(!0);const f=d-u,g=p-c,x=this._readbackTexture;r.bindTexture(x,0),r.gl.copyTexImage2D(x.descriptor.target,0,x.descriptor.pixelFormat,f,g,n,n,0);const T=this.backgroundColor,y=T?[T.a*T.r/255,T.a*T.g/255,T.a*T.b/255,T.a]:[1,1,1,1],k=(d+s.offset.x*i)/h*2-1,R=(p-s.offset.y*i)/m*2-1,v=o/h*2,j=o/m*2,w=this._program;r.bindVAO(this._vertexArrayObject),r.bindTexture(this._overlayTexture,6),r.bindTexture(this._maskTexture,7),r.useProgram(w),w.setUniform4fv("u_background",y),w.setUniform1i("u_readbackTexture",0),w.setUniform1i("u_overlayTexture",6),w.setUniform1i("u_maskTexture",7),w.setUniform4f("u_drawPos",k,R,v,j),w.setUniform1i("u_maskEnabled",s.maskEnabled?1:0),w.setUniform1i("u_overlayEnabled",s.overlayEnabled?1:0),r.setStencilTestEnabled(!1),r.setColorMask(!0,!0,!0,!0),r.drawArrays(b.TRIANGLE_STRIP,0,4),r.bindVAO()}_canRender(){return this._mask&&this._overlay&&null!=this._magnifier}_reloadResources(){this._resourcesTask&&this._resourcesTask.abort();const s=null!=this._magnifier?this._magnifier.maskUrl:null,t=null!=this._magnifier?this._magnifier.overlayUrl:null;this._resourcesTask=r((async r=>{const i=null==s||null==t?g(r):null,o=null!=s?e(s,{responseType:"image",signal:r}).then((e=>e.data)):i.then((e=>e.mask)),a=null!=t?e(t,{responseType:"image",signal:r}).then((e=>e.data)):i.then((e=>e.overlay)),[n,l]=await Promise.all([o,a]);this._mask=n,this._overlay=l,this._disposeRenderResources(),this.requestRender()})),this.updatingHandles.addPromise(this._resourcesTask.promise)}_disposeRenderResources(){this._readbackTexture=a(this._readbackTexture),this._overlayTexture=a(this._overlayTexture),this._maskTexture=a(this._maskTexture),this._vertexArrayObject=a(this._vertexArrayObject),this._program=a(this._program)}_updateResources(e){if(e.pixelRatio!==this._resourcePixelRatio&&this._disposeRenderResources(),this._readbackTexture)return;const r=e.context;this._resourcePixelRatio=e.pixelRatio;const s=Math.ceil(this._magnifier.size*e.pixelRatio);this._program=p(r);const t=new Uint16Array([0,1,0,0,1,1,1,0]),i=f.attributes;this._vertexArrayObject=new w(r,i,d,{geometry:x.createVertex(r,T.STATIC_DRAW,t)}),this._overlay.width=s,this._overlay.height=s;const o=new j;o.internalFormat=y.RGBA,o.wrapMode=k.CLAMP_TO_EDGE,o.samplingMode=R.NEAREST,o.flipped=!0,o.preMultiplyAlpha=!h(this._overlay.src)||!e.context.driverTest.svgPremultipliesAlpha.result,this._overlayTexture=new v(r,o,this._overlay),this._mask.width=s,this._mask.height=s,o.pixelFormat=o.internalFormat=y.ALPHA,this._maskTexture=new v(r,o,this._mask);const a=1/this._magnifier.factor;o.pixelFormat=o.internalFormat=y.RGBA,o.width=o.height=Math.ceil(a*s),o.samplingMode=R.LINEAR,o.flipped=!1,this._readbackTexture=new v(r,o)}}export{A as default};
