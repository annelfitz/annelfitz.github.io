/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../../../request.js";import has from"../../../../../core/has.js";import{ignoreAbortErrors as t,throwIfNotAbortError as s}from"../../../../../core/promiseUtils.js";import{diff as r,hasRootDiffOnly as a,hasRootDiff as i}from"../../../../../core/accessorSupport/diffUtils.js";import{QueryEngine as n}from"../../../../../layers/graphics/data/QueryEngine.js";import{executeQueryForCount as o}from"../../../../../rest/query/operations/query.js";import{FeatureStoreStatistics as h}from"../FeatureStoreStatistics.js";import{FeatureSourceQueryInfo as d}from"./FeatureSourceQueryInfo.js";import{StreamMessenger as u}from"./StreamMessenger.js";import{DrillDownTileLoadStrategy as c}from"./strategies/DrillDownTileLoadStrategy.js";import{PagedTileLoadStrategy as _}from"./strategies/PagedTileLoadStrategy.js";import{SnapshotLoadStrategy as g}from"./strategies/SnapshotLoadStrategy.js";import{StreamLoadStrategy as m}from"./strategies/StreamLoadStrategy.js";import{FeatureSourceChunkStore as l}from"./strategies/chunks/SourceChunkStore.js";import{FeatureMetadata as p}from"../support/FeatureMetadata.js";import{UpdateTracking2D as y}from"../../support/UpdateTracking2D.js";class v{constructor(e,t,s,r){this._aggregateAdapter=e,this._subscriptions=t,this._onChange=s,this._connection=r,this._updateTracking=new y({debugName:"FeatureSource"}),this._didInvalidateData=!1,this._store=new l(this._onChange)}destroy(){this._strategy?.destroy(),this._store.destroy(),this._streamMessenger?.destroy()}get _eventLog(){return this._connection.eventLog}get metadata(){if(!this._metadata)throw new Error("InternalError: Metadata not defined. Was update called?");return this._metadata}get service(){return this._schema.service}get store(){return this._store}get streamMessenger(){return null==this._streamMessenger&&this._initStreamMessenger(),this._streamMessenger}get statistics(){return h.from(this._store)}get updateTracking(){return this._updateTracking}get queryEngine(){if(!this._queryEngine){if(!this._schema)return null;const{dataFilter:e}=this._schema.mutable,t=this._schema.mutable.availableFields,s=this._metadata;this._queryEngine=new n({featureStore:this._store,fieldsIndex:s.fieldsIndex,geometryType:s.geometryType,objectIdField:s.objectIdField,hasM:!1,hasZ:!1,spatialReference:e.outSpatialReference,cacheSpatialQueries:!0,aggregateAdapter:this._aggregateAdapter,timeInfo:s.timeInfo,definitionExpression:e.definitionExpression,availableFields:t})}return this._queryEngine}get isStream(){return"stream"===this._schema.type}chunks(){return Array.from(this._store.chunks())}cleanupRemovedChunks(){return this._store.cleanupRemovedChunks()}onSubscribe(e){this._eventLog.onEvent({type:"subscribe",tile:e.tile.id});const t=this._strategy?.load(e);t&&(t.then((()=>this._eventLog.onEvent({type:"loaded",tile:e.tile.id}))).catch((t=>this._eventLog.onEvent({type:"error",tile:e.tile.id,error:t}))),this._updateTracking.addPromise(t))}onResume(e){this._updateTracking.addPromise(t(this._strategy?.load(e)))}onUnsubscribe(e){this._eventLog.onEvent({type:"unsubscribe",tile:e.tile.id}),this._strategy?.unload(e)}getOverride(e){return this._updateTracking.addPromise(this._doGetOverride(e))}applyOverride(e){this._didInvalidateData=!0,this._store.applyOverrides(e,this.metadata)}async update(e,t){const s=e.source,n=r(this._schema?.mutable,s.mutable);if(!n)return!1;if(has("esri-2d-update-debug")&&console.debug(`Version[${t}] FeatureSource.update`,{changes:n}),this._schema=s,this._metadata=new p(this._schema.service.metadata),this._queryEngine?.destroy(),this._queryEngine=null,"feature"===this._schema.type&&null!=this._schema.service.queryMetadata.lastEditDate&&(this._lastEditDate=this._schema.service.queryMetadata.lastEditDate),null==this._streamMessenger&&"stream"===this._schema.type&&this._initStreamMessenger(),a(n,"sourceRefreshVersion")&&this._strategy?.refresh)return await this._strategy.refresh(),!0;if("feature"===s.type&&a(n,"availableFields")){if(await this._queryLastEditDateChanged()||this._didInvalidateData)this._didInvalidateData=!1,await this._updateStrategy(t);else{this._eventLog.onEvent({type:"updateFieldsStart"});try{await this._strategy.updateFields(s.mutable.availableFields),this._eventLog.onEvent({type:"updateFieldsEnd"})}catch(o){this._eventLog.onEvent({type:"updateFieldsError",error:o})}}return!1}return!(!i(n,"dataFilter")&&!i(n,"sourceRefreshVersion"))&&(await this._updateStrategy(t),!0)}_initStreamMessenger(){null==this._streamMessenger&&(this._streamMessenger=new u(this._connection))}async _doGetOverride(e){return this._strategy.queryOverride(e)}async _queryLastEditDateChanged(){if(null==this._lastEditDate)return!1;const t=this._schema.service.source,s={...t.query,f:"json"},r=(await e(t.path,{query:s,responseType:"json"})).data.editingInfo.lastEditDate;return r!==this._lastEditDate&&(this._lastEditDate=r,!0)}async _createStrategy(){const e=this.service,t="isSourceHosted"in e&&e.isSourceHosted,s=Array.isArray(e.source),r=e.source&&"collection"in e.source,a=t||s||r;if("stream"===this._schema.type){const e=new m(this._schema.service,this._schema.mutable.dataFilter,this._store,{outSR:this._schema.mutable.dataFilter.outSpatialReference},this.metadata);return this._streamMessenger.strategy=e,e}const i=d.fromSchema(this._schema,this._metadata),n=await this._supportSnapshotMode(this._schema,i);return n?new g(this._schema.service,i,this._store,n.featureCount,this.metadata,this._eventLog):a?new _(this._schema.service,i,this._store,this.metadata,this._eventLog):new c(this._schema.service,i,this._store,this.metadata,this._eventLog)}async _updateStrategy(e){const t=await this._createStrategy();this._eventLog.onEvent({type:"updateStrategyStart",about:t.about});const r=!!this._strategy;this._store.clear(),this._strategy?.destroy(),this._strategy=t,has("esri-2d-update-debug")&&console.debug(`Version[${e}] FeatureSource.updateStrategy`,{strategy:t});const a=Array.from(this._subscriptions.values());if(!a.length)return void this._eventLog.onEvent({type:"updateStrategyEnd"});const i=Promise.all(a.map((e=>this._strategy.load(e).then((()=>this._eventLog.onEvent({type:"loaded",tile:e.tile.id}))).catch((t=>this._eventLog.onEvent({type:"error",tile:e.tile.id,error:t}))))));this._updateTracking.addPromise(i);try{r&&await i}catch(n){s(n)}this._eventLog.onEvent({type:"updateStrategyEnd"}),has("esri-2d-update-debug")&&console.debug(`Version[${e}] FeatureSource.updateStrategyEnd`,{strategy:t})}async _supportSnapshotMode(e,t){const{queryMetadata:s}=e.service,r=s.snapshotInfo;if(!r||!r.supportsSnapshotMinThreshold||!r.snapshotCountThresholds)return null;const a=e.service.source,i=t.createQuery();i.inner.orderByFields=[],i.inner.returnGeometry=!1;const n=(await o(a,i.inner,{query:i.customParameters})).data.count,{min:h,max:d}=r.snapshotCountThresholds;return n<=h||r.supportsSnapshotMaxThreshold&&n<d?{featureCount:n}:null}}export{v as FeatureSource};
