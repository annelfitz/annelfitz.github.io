/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import has from"../../../../core/has.js";import{destroyMaybe as t}from"../../../../core/maybe.js";import{throwIfNotAbortError as e,throwIfAborted as s}from"../../../../core/promiseUtils.js";import{diff as r,hasDiff as i}from"../../../../core/accessorSupport/diffUtils.js";import a from"../../../../geometry/SpatialReference.js";import{MultiTileMeshData as o}from"../../engine/webgl/mesh/MultiTileMeshData.js";import{FeatureMeshFactory as n}from"../../engine/webgl/mesh/factories/FeatureMeshFactory.js";import{ResourceProxy as c}from"../../engine/webgl/mesh/factories/ResourceProxy.js";import{ProcessorTileMessageQueue as h}from"./ProcessorTileMessageQueue.js";import{BinningStrategy as u}from"./processor/BinningStrategy.js";import{ClusterStrategy as g}from"./processor/ClusterStrategy.js";import{FeatureUpdateStrategy as d}from"./processor/FeatureUpdateStrategy.js";import{AttributeStore as y}from"./support/AttributeStore.js";import{ComputedAttributeStorage as p}from"./support/ComputedAttributeStorage.js";class _{constructor(t,e){this._connection=t,this._source=e,this._version=1,this._proxy=new c({fetch:(t,e)=>this._connection.layerView.fetch(t,e),fetchDictionary:(t,e)=>this._connection.layerView.fetchDictionary(t,e)}),this._attributeStore=new y({isLocal:!1,update:t=>this._connection.container.updateAttributeView(t)})}destroy(){this._proxy.destroy(),this._strategy?.destroy(),this._attributeStore.destroy()}get aggregateQueryEngine(){return this._strategy?.aggregateQueryEngine}getDisplayFeatures(t){return this._strategy?this._strategy.getDisplayFeatures(t):{features:[],aggregates:[]}}getFeatureObjectIdsForAggregate(t){return this._strategy?this._strategy.getFeatureObjectIdsForAggregate(t):[]}onSubscribe(t){this._strategy?.onSubscribe(t)}onUnsubscribe(t){this._strategy?.onUnsubscribe(t)}async update(t,e,s,o,c){const h=t.processor,u=r(this._schema,h);if(!u&&!o)return;has("esri-2d-update-debug")&&console.debug(`Version[${this._version}] SymbolProcessor.update`,{changes:u,schema:h}),this._schema=h;const g=a.fromJSON(t.source.mutable.dataFilter.outSpatialReference),d=new p({fields:this._source.metadata.fieldsIndex,spatialReference:g});return await this._attributeStore.update(h.storage,d,this._source.metadata,g,e),this._strategy?.invalidateAttributeData(),o||i(u,"mesh")?(i(u,"mesh.strategy")&&await this._updateStrategy(h.mesh.strategy,g,c,h.mesh.timeZone),this._updateSortKey(d,"sortKey"in h.mesh?h.mesh.sortKey:null),(i(u,"mesh.factory")||"dictionary"===h.mesh.factory.symbology.type)&&(this._factory=await n.create(d,this._proxy,h.mesh.factory,s)),this._invalidate(),this._version=e,this._connection.container.updateRenderState(this._version)):void 0}async applyOverride(t){if(!this._strategy)return;const e=this._strategy.applyOverride(t);for await(const r of e)try{await this._process(r)}catch(s){}this._source.applyOverride(t)}async updateChunks(){await this._doUpdateChunks(),this._strategy?.afterUpdateChunks()}async removeChunks(t){this._strategy?.removeChunks(t),this._attributeStore.incrementDisplayIdGeneration()}updateHighlight({highlights:t}){if(!this._strategy)return void this._attributeStore.setHighlight(t.map((({objectId:t,highlightFlags:e})=>({objectId:t,highlightFlags:e,displayId:-1}))),t);const e=this._strategy.displayMap(t,(({objectId:t})=>t),((t,{highlightFlags:e},s)=>({objectId:s,displayId:t,highlightFlags:e})));this._attributeStore.setHighlight(e,t)}async _doUpdateChunks(){if(!this._strategy)return;const t=this._strategy.updateChunks(),s=[],r=new Map;for await(const a of t){let t=r.get(a.id);null==t&&(t=new h({concurrency:16,process:t=>this._process(t)}),r.set(a.id,t));const i=t.push(a).catch((t=>e(t)));s.push(i)}try{await Promise.all(s)}catch(i){}has("esri-2d-update-debug")&&console.log("SendUpdates"),this._attributeStore.sendUpdates(),has("esri-2d-update-debug")&&console.log("SendUpdates.await")}async _updateStrategy(t,e,s,r){switch(this._strategy?.destroy(),t.type){case"feature":this._strategy=new d(this._source,this._attributeStore,r);break;case"binning":this._strategy=await u.create(t,e,this._source,this._attributeStore,r);break;case"cluster":this._strategy=await g.create(this._connection,t,e,this._source,this._attributeStore,r)}for(const i of s)this._strategy.onSubscribe(i)}async _updateSortKey(e,s){if(this._sortInfo=t(this._sortInfo?.computed),null!=s){const t=s.byRenderer?null:await e.createComputedField(s);this._sortInfo={...s,computed:t}}}_invalidate(){this._strategy&&this._strategy.invalidate()}async _process(t){const e=t.subscription;if(has("esri-2d-update-debug")){const s=e.tile;console.debug(`Version[${this._version}] Tile[${s.key.id}, end=${t.end}] Processor._process`)}await this._fetchResources(t),s(e.signal);const r=await this._write(t,e.tile.createArcadeEvaluationOptions(this._schema.mesh.timeZone)),i=e.tile.tileInfoView.tileInfo.isWrappable,{message:a,transferList:o}=r.serialize(i),n=t.createMessage(a,this._version,this._attributeStore.epoch);if(s(e.signal),await this._connection.container.onMessage(n,{signal:e.signal,transferList:o}),this._attributeStore.sendUpdates(),has("esri-2d-update-debug")){const s=e.tile;console.debug(`Version[${this._version}] Tile[${s.key.id}, end=${t.end}] Processor._process.await`)}}async _fetchResources(t){await this._fetchMatcherResources(t),await this._fetchWriterResources(t)}async _fetchMatcherResources(t){if(t.reader)return this._factory.enqueueMatcherRequests(this._proxy,t.reader)}async _fetchWriterResources(t){if(!t.reader)return;const e=t.reader.getCursor(),s=t.subscription.tile.createArcadeEvaluationOptions(this._schema.mesh.timeZone);for(;e.next();)this._factory.enqueueWriterRequests(this._proxy,e,s);await this._proxy.fetchEnqueuedResources()}async _write(t,e){const s=t.subscription.tile,r=t.reader?.getCursor(),i=r?.getSize()??0,a=s.tileInfoView.tileInfo.isWrappable,n=new o(s.key,this._strategy.enablePixelBuffering,a,i);if(!r)return n;const c=s.createArcadeEvaluationOptions(this._schema.mesh.timeZone);for(;r.next();){const t=this._getSortKeyValue(r,e);n.entityStart(r.getDisplayId(),t),this._factory.write(n,this._proxy,r,c,s.level),n.entityEnd()}return n}_getSortKeyValue(t,e){if(!this._sortInfo)return 0;const{computed:s,order:r,byRenderer:i}=this._sortInfo,a=i?this._factory.getSortKey(t,e):s?.read(t,e);return null==a||isNaN(a)?0:a*("asc"===r?-1:1)}}export{_ as default};
