/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{ASendState as e,AProcessorStrategy as t}from"./AProcessorStrategy.js";import{FeatureTileUpdateMessage as s,FeatureTileAppendMessage as r}from"../sources/FeatureSourceMessage.js";import{OverrideChunk as n}from"../sources/strategies/chunks/OverrideChunk.js";class a extends e{}class o extends t{constructor(e,t,s){super(e,t),this._timeZone=s,this.handledChunks=new Set,this.handledChunksForIdCreation=new Set,this.handledChunksForAttributeData=new Set,this._streamLayerDeferredObjectIdsToRemove=[]}destroy(){super.destroy();for(const e of this._source.chunks())this._cleanupChunkIds(e)}invalidateAttributeData(){this.handledChunksForAttributeData.clear()}onSubscribe(e){super.onSubscribe(e),this._evalOptions=e.tile.createArcadeEvaluationOptions(this._timeZone)}createState(e){return new a(e)}get aggregateQueryEngine(){return null}displayMap(e,t,s){const r=new Map(e.map((e=>[t(e),e]))),n=[];for(const a of this._source.chunks()){const e=a.reader.getCursor();for(;e.next();){const t=e.getObjectId(),a=e.getDisplayId(),o=r.get(t);if(null!=o){const e=s(a,o,t);n.push(e),r.delete(t)}}}return n}getDisplayFeatures(e){const t=new Set(e),s=new Set,r=[];for(const n of this._source.chunks()){const e=n.reader.getCursor();for(;e.next();){const n=e.getObjectId(),a=e.getDisplayId();t.has(a)&&!s.has(n)&&(r.push({...e.readLegacyFeatureWorldSpace(),displayId:a}),s.add(n))}}return{features:r,aggregates:[]}}async*applyOverride(e){const t=[],r=e.reader.getCursor();for(;r.next();){const e=r.getObjectId();t.push(e);const s=this._attributeStore.createDisplayIdForObjectId(e);r.setDisplayId(s),this._attributeStore.setAttributeData(s,r,this._evalOptions)}const a=this.getDisplayIds(t),o=this.getDisplayIds(e.removed),d=new n(this._source.metadata);d.applyOverrides(e),this.handledChunks.add(d.chunkId),this.handledChunksForAttributeData.add(d.chunkId),this.handledChunksForIdCreation.add(d.chunkId);for(const n of this._sendStates.values())n.handledChunks.add(d.chunkId),yield new s(n.subscription,null,a,!1,d.queryInfo);for(const n of this._sendStates.values()){const e=d.getTileReader(n.subscription.tile);yield new s(n.subscription,e,o,!1,d.queryInfo)}for(const s of e.removed)this._attributeStore.releaseDisplayIdForObjectId(s)}async*updateChunks(){if(this._source.chunks().length){await this._updateAttributeData();for(const e of this._sendStates.values())yield*this._update(e)}}removeChunks(e){for(const t of e)this.handledChunks.delete(t.chunkId),this.handledChunksForAttributeData.delete(t.chunkId),this._cleanupChunkIds(t)}afterUpdateChunks(){for(const e of this._streamLayerDeferredObjectIdsToRemove)this._attributeStore.releaseDisplayIdForObjectId(e);this._streamLayerDeferredObjectIdsToRemove=[]}_cleanupChunkIds(e){if(this.handledChunksForIdCreation.has(e.chunkId)){const t=e.reader.getCursor();for(;t.next();){const e=t.getObjectId();this._source.isStream?this._streamLayerDeferredObjectIdsToRemove.push(e):this._attributeStore.releaseDisplayIdForObjectId(e)}this.handledChunksForIdCreation.delete(e.chunkId)}}async _updateAttributeData(){for(const e of this._source.chunks()){const{chunkId:t,reader:s}=e;if(!this.handledChunksForIdCreation.has(t)){this.handledChunksForIdCreation.add(t);const e=s.getCursor();for(;e.next();){const t=this._attributeStore.createDisplayIdForObjectId(e.getObjectId());e.setDisplayId(t)}}}for(const e of this._source.chunks())if(!this.handledChunksForAttributeData.has(e.chunkId)){this.handledChunksForAttributeData.add(e.chunkId);const t=e.reader.getCursor();for(;t.next();){const e=t.getDisplayId();this._attributeStore.setAttributeData(e,t,this._evalOptions)}}}*_update(e){const{subscription:t,handledChunks:s}=e;for(const n of this._source.chunks()){const{chunkId:a}=n;if(s.has(a))continue;s.add(a);const o=n.getTileReader(t.tile);o&&(yield new r(e.subscription,o,!1,n.end,n.queryInfo))}}}export{a as DefaultSendState,o as FeatureUpdateStrategy};
