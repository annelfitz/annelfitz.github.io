/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../../../../core/Error.js";import t from"../../../../../../rest/support/Query.js";import{ALoadStrategy as r}from"./ALoadStrategy.js";import{createQueryAdapter as s}from"./support/queryAdapters.js";import{FeatureSetReaderJSON as o}from"../../support/FeatureSetReaderJSON.js";import{QueueProcessor as n}from"../../../../../support/QueueProcessor.js";class a extends r{constructor(e,t,r,o,a){super(r),this._serviceInfo=e,this._queryInfo=t,this._metadata=o,this._eventLog=a,this._queue=new n({concurrency:16,process:async e=>{const t={signal:e.options?.signal,query:e.query.customParameters};return this._adapter.executeQuery(e.query.inner,t)}}),this._adapter=s(e,o)}async updateFields(r){this._queryInfo.updateFields(r);const s=Array.from(this._store.chunks()).map((async e=>{const r=t.fromJSON(e.queryInfo.queryJSON);if(r)try{return await this._tryUpdateFields(e.reader,r),null}catch(s){return s}})),o=(await Promise.all(s)).filter((e=>e));if(o.length)throw new e("featurelayer-query","Encountered errors when downloading fields",{errors:o})}async queryOverride({edits:e}){const t=[],r=[];for(const o of e.removed)null!=o.objectId&&-1!==o.objectId?t.push(o.objectId):r.push(o.globalId);r.length&&t.push(...this._mapGlobalIdsToObjectIds(r));const s=e.addOrModified.map((({objectId:e})=>e));let n;if(s.length){const e=this._queryInfo.createQuery({objectIds:s});n=await this._fetch(e)}else n=o.empty(this._metadata);return{reader:n,removed:t}}_mapGlobalIdsToObjectIds(e){const t=new Set(e),r=this._metadata.globalIdField;if(null==r)throw new Error("InternalError: Recieved an edit with globalIds, but not supported by the service");const s=[];return this._store.forEachUnsafe((e=>{const o=e.readAttribute(r);t.has(o)&&s.push(e.getObjectId())})),s}async _fetch(e,t){const r=await this._enqueue(e,t);return await this._tryUpdateFields(r,e.inner),r}async _tryUpdateFields(e,t){const r=this._queryInfo.createPatchFieldsQuery(t,e);if(!r)return;const s=await this._enqueue(r,this._options);e.joinAttributes(s)}async _enqueue(e,t){return this._eventLog.onEvent({type:"fetchStart"}),this._queue.push({query:e,options:t}).finally((()=>{this._eventLog.onEvent({type:"fetchEnd",done:0===this._queue.length})}))}}export{a as AFetchLoadStrategy};
