/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../../../../geometry.js";import{getGeohashBounds as e}from"../../../../../geohash/geohashUtils.js";import{unquantizeOptimizedGeometry as t,convertToFeature as s}from"../../../../../layers/graphics/featureConversionUtils.js";import{OptimizedFeature as r}from"../../../../../layers/graphics/OptimizedFeature.js";import{checkProjectionSupport as o}from"../../../../../layers/graphics/data/projectionSupport.js";import{ComputedAggregateField as a}from"../aggregation/ComputedAggregateField.js";import{AAggregateStrategy as i}from"./AAggregateStrategy.js";import{ASendState as n}from"./AProcessorStrategy.js";import{FeatureTileAppendMessage as l,FeatureTileUpdateMessage as d}from"../sources/FeatureSourceMessage.js";import{ComputedAttributeStorage as c}from"../support/ComputedAttributeStorage.js";import u from"../support/FeatureFilter.js";import{FeatureMetadata as p}from"../support/FeatureMetadata.js";import{FeatureSetReaderJSON as f}from"../support/FeatureSetReaderJSON.js";import h from"../../../tiling/TileKey.js";import m from"../../../../../geometry/SpatialReference.js";class g extends n{constructor(e,t){super(e),this.bins=new Map,this.done=!1,this._store=t}reset(){this.destroy(),this.bins.clear(),this.done=!1,this.handledChunks.clear()}destroy(){const e=this.subscription.tile.key.level;for(const t of this.bins.values()){const s=t.cachedFeature?.objectId;null!=s&&this._store.releaseDisplayIdForObjectId(`${s}.${e}`)}}*featuresWorldSpace(){for(const e of this.bins.values()){const s=e.cachedFeature;if(s){const e=s.clone();e.geometry&&t(e.geometry,e.geometry,!1,!1,this.subscription.tile.transform),yield e}}}getGeohashBounds(t,s){const r=this.subscription.tile;return e(r.extent,r.resolution,s,t)}}class y extends i{static async create(e,t,s,r,i){const n=new c({spatialReference:t}),l=e.fixedBinLevel,d=await Promise.all(e.fields.map((async e=>a.create(n,e)))),p=e.featureFilter?await u.create({geometryType:s.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:s.metadata.timeInfo,fieldsIndex:s.metadata.fieldsIndex,spatialReference:t,filterJSON:e.featureFilter}):null;return await o(t,m.WGS84),new y({fields:d,geohashLevel:l,spatialReference:t,featureFilter:p,timeZone:i},e.fields,s,r)}constructor(e,t,s,r){super(s,r,e.spatialReference,e.fields),this._indexOptions=e,this._metadata=new p({geometryType:"esriGeometryPolygon",objectIdField:"aggregateId",fields:t,globalIdField:null,spatialReference:s.metadata.spatialReference,subtypeField:null,subtypes:null,timeInfo:null,timeReferenceUnknownClient:null,typeIdField:null,types:null})}createState(e){return new g(e,this._attributeStore)}async*applyOverride(e){for(const t of this._sendStates.values()){t.reset();const e=new l(t.subscription,f.empty(this._source.metadata),!0,!1,{});yield e}}displayMap(e,t,s){const r=new Map(e.map((e=>[t(e),e]))),o=[];for(const a of this._sendStates.values())for(const e of a.featuresWorldSpace()){const{objectId:t,displayId:a}=e,i=r.get(t);if(null!=i){const e=s(a,i,t);o.push(e),r.delete(t)}}return o}getDisplayFeatures(e){const t=new Set(e),r=new Set,o=[];for(const a of this._sendStates.values())for(const e of a.featuresWorldSpace())t.has(e.displayId)&&!r.has(e.objectId)&&(e.geometry&&o.push({...s(e,this._metadata.geometryType,!1,!1),displayId:e.displayId}),r.add(e.objectId));return{features:[],aggregates:o}}getFeatureObjectIdsForAggregate(e){for(const t of this._sendStates.values())for(const s of t.bins.values())if(s.id===e)return Array.from(s.objectIds);return[]}async*updateChunks(){if(this._source.chunks().length)for(const e of this._sendStates.values())yield*this._update(e,this._source)}forEachAggregateWorldSpace(e){for(const t of this._sendStates.values())for(const s of t.featuresWorldSpace())e(s)}async*_update(e,t){const{handledChunks:s,subscription:o,bins:a}=e,{spatialReference:i,geohashLevel:n}=this._indexOptions,l=o.tile;if(e.done)return;for(const r of t.chunks()){if(s.has(r.chunkId))continue;s.add(r.chunkId);const t=r.queryInfo;if("tileId"in t){const e=new h(t.tileId);if(e.level!==l.level||e.world!==l.key.world)continue}const o=r.getGeohashIndex(this._indexOptions),d=e.getGeohashBounds(i,n);null!=d&&o.putBins(a,d)}const c=[],u=o.tile.transform,p=o.tile.key.level;for(const d of a.values()){if(d.cachedFeature)d.cachedFeature.attributes=d.getAttributes();else{const e=d.getGeometry(this.spatialReference,u),t=new r(e,d.getAttributes(),null);e||(t.centroid=d.getGeometryCentroid(this.spatialReference,u)),t.objectId=d.id,t.displayId=this._attributeStore.createDisplayIdForObjectId(`${t.objectId}.${p}`),d.cachedFeature=t}c.push(d.cachedFeature)}this.events.emit("changed"),e.done=!t.updateTracking.updating;const m=f.fromOptimizedFeatures(c,this._metadata,u),g=m.getCursor(),y=e.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.timeZone);for(;g.next();)this._attributeStore.setAttributeData(g.getDisplayId(),g,y);const b=new d(e.subscription,m,[],e.done,{});yield b}}export{g as BinningState,y as BinningStrategy};
