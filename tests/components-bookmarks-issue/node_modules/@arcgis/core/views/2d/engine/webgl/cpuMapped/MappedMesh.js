/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{destroyMaybe as e}from"../../../../../core/maybe.js";import{i1616to32 as t}from"../number.js";import{MappedBuffer as r}from"./Buffer.js";import{unpackDataView as i}from"../shaderGraph/techniques/mesh/dataViewUtils.js";import{vertexLayoutHash as s}from"../shaderGraph/techniques/mesh/utils.js";import{PrimitiveType as o}from"../../../../webgl/enums.js";import{VertexArrayObject as f}from"../../../../webgl/VertexArrayObject.js";const n=0,u=1,a=1e3;class h{constructor(e){this._bufferPool=e,this._computeLayouts=new Map,this._vaos=new Map,this._invalidated=!1}destroy(){for(const[e,t]of this._vaos)t?.disposeVAOOnly();this._indexBuffer=e(this._indexBuffer),this._vertexBuffer=e(this._vertexBuffer)}_getVertexAttributeLayout(e){if(!e)return null;const t=[];for(const r of e.attributes)t.push({name:r.name,type:r.type,count:r.count,divisor:0,normalized:r.normalized??!1,offset:r.offset,stride:e.stride});return{geometry:t}}getLayout(e){if(!this._layout)return null;const{locationInfo:t,useComputeBuffer:r,computeAttributeMap:i}=e,o=this._layout.attributes.filter((e=>t.locations.has(e.name)));if(!r)return{attributes:o,hash:this._layout.hash,stride:this._layout.stride};const f=Object.values(i).flat().join("-");if(this._computeLayouts.has(f))return this._computeLayouts.get(f);const n=this._layout.stride;for(const{name:s,count:a,type:h,normalized:c,offset:d,packPrecisionFactor:l}of this._layout.attributes){const e=i[s];null!=e&&2===e.length&&(o.push({name:e[0],count:a,type:h,normalized:c,offset:d+n,packPrecisionFactor:l}),o.push({name:e[1],count:a,type:h,normalized:c,offset:d+2*n,packPrecisionFactor:l}))}const u={attributes:o,stride:n,hash:s(o)};return this._computeLayouts.set(f,u),u}getDrawArgs(e,t,r,i){return i?{primitive:o.POINTS,count:t/3,offset:r/3}:{primitive:e,count:t,offset:r}}getDebugVertexInfo(e){if(!this._vertexBuffer)return null;const t=this.getLayout(e);if(null==t)return null;const r=t.stride,s=this._vertexBuffer.getView(0,this._vertexBuffer.byteSize),o=new DataView(s.slice().buffer);let f=s.byteLength/r;e.useComputeBuffer&&(f=this._indexBuffer.fillPointer/3);const n=this._indexBuffer.getView(0,this._indexBuffer.byteSize);let u=0;const a=[];for(let h=0;h<f;h++){if(e.useComputeBuffer){u=n[3*h]*r}const s={};for(const e of t.attributes){let t=`${e.offset} ${e.name}`,r=i(o,e,u);if(e.packPrecisionFactor)if(t+=` (precision: ${e.packPrecisionFactor})`,"number"==typeof r)r/=e.packPrecisionFactor;else for(let i=0;i<r.length;i++)r[i]/=e.packPrecisionFactor;s[t]=r}u+=r,a.push(s)}return{vertices:a,layout:t}}_ensure(e,t,i){if(this._vertexBuffer&&this._indexBuffer){if(this._layout?.hash!==e.hash)throw new Error("InternalError: Expected vertex layouts to match");this._indexBuffer.ensure(Math.max(t,1e3)),this._vertexBuffer.ensure(Math.max(i,1e3))}else{const s=e.stride/Uint32Array.BYTES_PER_ELEMENT;if(this._layout=e,this._position=e.attributes.find((e=>"pos"===e.name||"position"===e.name)),!this._position)throw new Error("InternalError: Unable to find position attribute");this._indexBuffer=new r("index",Math.max(t,a),1,this._bufferPool),this._vertexBuffer=new r("vertex",Math.max(i,a),s,this._bufferPool)}}append(e){const t=e.layout.stride,r=e.indices.byteLength/Uint32Array.BYTES_PER_ELEMENT,i=e.vertices.byteLength/t;this._ensure(e.layout,r,i);const{vertices:s,indices:o}=e,f=this._vertexBuffer.insert(s,0,s.byteLength/t,0);return{vertexFrom:f,indexFrom:this._indexBuffer.insert(o,0,o.byteLength/4,f)}}copyRecordFrom(e,r,i,s){const{indexStart:o,indexCount:f,vertexStart:n,vertexCount:u}=r;this._ensure(e._layout,f,u);const a=e._position,h=i*(a.packPrecisionFactor??1),c=s*(a.packPrecisionFactor??1),d=a.offset,l=t(h,c),_=this._vertexBuffer.copyFrom(e._vertexBuffer,n,u,l,d),m=this._indexBuffer.copyFrom(e._indexBuffer,o,f,_-n,0),x=r.clone();return x.vertexStart=_,x.indexStart=m,x.overlaps=0,x}remove(e,t,r,i){this._indexBuffer.free(e,t),this._vertexBuffer.free(r,i)}upload(){this._invalidated=!0}getVAO(e,t,r){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;const i=r?.useComputeBuffer?u:n;let s=this._vaos.get(i);if(this._invalidated||r?.useComputeBuffer){(this._vertexBuffer.invalidated||this._indexBuffer.invalidated||r?.useComputeBuffer&&this._indexBuffer.invalidatedComputeBuffer)&&(this._vertexBuffer.invalidate(),this._indexBuffer.invalidate(),s?.disposeVAOOnly(),s=null),this._vertexBuffer.upload(),this._indexBuffer.upload();const o=this._indexBuffer.getGPUBuffer(e,1===i),n=this._vertexBuffer.getGPUBuffer(e);s||(s=new f(e,t.locations,this._getVertexAttributeLayout(this.getLayout(r)),{geometry:n},o),this._vaos.set(i,s)),this._invalidated=!1}return s}get memoryStats(){return{bytesUsed:this._vertexBuffer.memoryStats.bytesUsed+this._indexBuffer.memoryStats.bytesUsed,bytesReserved:this._vertexBuffer.memoryStats.bytesReserved+this._indexBuffer.memoryStats.bytesReserved,vertex:this._vertexBuffer.memoryStats,index:this._indexBuffer.memoryStats}}reshuffle(e){this._vertexBuffer&&this._vertexBuffer.reshuffle(e.vertex.count,e.vertex.operations),this._indexBuffer&&this._indexBuffer.reshuffle(e.index.count,e.index.operations)}}export{h as MappedMesh};
