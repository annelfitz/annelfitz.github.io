/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{throwIfAborted as t}from"../../../../../core/promiseUtils.js";import{timeExtentsEqual as a,setUniforms as r}from"../utils.js";import{BufferObject as e}from"../../../../webgl/BufferObject.js";import{DataType as s,BlendFactor as o,PrimitiveType as i,Usage as n,PixelFormat as m,TextureWrapMode as l}from"../../../../webgl/enums.js";import{Texture as p}from"../../../../webgl/Texture.js";import{TextureDescriptor as c}from"../../../../webgl/TextureDescriptor.js";import{VertexArrayObject as h}from"../../../../webgl/VertexArrayObject.js";import{VertexElementDescriptor as _}from"../../../../webgl/VertexElementDescriptor.js";class f{constructor(t){this._params=t,this.animated=!1}isCompatible(t){if(!(t instanceof f))return!1;if(!a(this._params.timeExtent,t._params.timeExtent))return!1;let r=!0;return r=r&&this._params.loadImagery===t._params.loadImagery,r=r&&this._params.color.kind===t._params.color.kind,r=r&&this._params.opacity.kind===t._params.opacity.kind,r}async load(a,r){const{extent:e,size:s}=a;t(r);const o=await this._params.loadImagery(e,s[0],s[1],this._params.timeExtent,r);return new x(o,{color:this._params.color,opacity:this._params.opacity})}render(t,a,e){const{context:s}=t,{program:n}=e;s.setFaceCullingEnabled(!1),s.setBlendingEnabled(!0),s.setBlendFunction(o.ONE,o.ONE_MINUS_SRC_ALPHA),s.useProgram(n),n.setUniformMatrix3fv("u_dvsMat3",a.dvsMat3),s.bindTexture(e.texture,0),n.setUniform1i("u_texture",0),n.setUniform1f("u_Min",e.min),n.setUniform1f("u_Max",e.max),r(n,"color","vec4",this._params.color),r(n,"opacity","float",this._params.opacity),s.bindVAO(e.vertexArray),s.drawArrays(i.TRIANGLE_STRIP,0,4)}}const d=new Map;d.set("a_position",0),d.set("a_texcoord",1);const u={geometry:[new _("a_position",2,s.UNSIGNED_SHORT,0,8),new _("a_texcoord",2,s.UNSIGNED_SHORT,4,8)]},w={vsPath:"raster/flow/imagery",fsPath:"raster/flow/imagery",attributes:d};class x{constructor(t,a){this._flowData=t,this._values=a}attach(t){const{context:a}=t,{width:r,height:s}=this._flowData,o=e.createVertex(a,n.STATIC_DRAW,new Uint16Array([0,0,0,1,r,0,1,1,0,s,0,0,r,s,1,0])),i=new h(a,d,u,{geometry:o}),_=[];"ramp"===this._values.color.kind&&_.push("vvColor"),"ramp"===this._values.opacity.kind&&_.push("vvOpacity");const f=t.painter.materialManager.getProgram(w,_);let x=1e6,g=-1e6;for(let e=0;e<s;e++)for(let t=0;t<r;t++)if(0!==this._flowData.mask[e*r+t]){const a=this._flowData.data[2*(e*r+t)],s=this._flowData.data[2*(e*r+t)+1],o=Math.sqrt(a*a+s*s);x=Math.min(x,o),g=Math.max(g,o)}const y=new Uint8Array(4*r*s);for(let e=0;e<s;e++)for(let t=0;t<r;t++)if(0!==this._flowData.mask[e*r+t]){const a=this._flowData.data[2*(e*r+t)],s=this._flowData.data[2*(e*r+t)+1],o=(Math.sqrt(a*a+s*s)-x)/(g-x);y[4*(e*r+t)]=255*o,y[4*(e*r+t)+1]=0,y[4*(e*r+t)+2]=0,y[4*(e*r+t)+3]=255}else y[4*(e*r+t)]=0,y[4*(e*r+t)+1]=0,y[4*(e*r+t)+2]=0,y[4*(e*r+t)+3]=0;const A=new c;A.internalFormat=m.RGBA,A.wrapMode=l.CLAMP_TO_EDGE,A.flipped=!0,A.width=r,A.height=s;const b=new p(a,A,y);this.vertexArray=i,this.program=f,this.texture=b,this.min=x,this.max=g,this._flowData=null}detach(){this.vertexArray.dispose(),this.texture.dispose()}get ready(){return this.program.compiled}}export{f as Imagery,x as ImageryResources};
