/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t,a as e}from"../../../../../../../chunks/tslib.es6.js";import{tileSize as o}from"../../../definitions.js";import{uniform as s,location as i,UniformGroup as r,define as l,FragmentOutput as d,input as a}from"../../GraphShaderModule.js";import{FixedArray as n,Vec4 as p,Mat3 as h,Vec3 as c,texture2D as u,Mat4 as m,step as y,Float as v,dot as w,max as x,Sampler2D as f}from"../../graph/glsl.js";import{FeatureVertexInput as g,FeatureFragmentInput as A,AFeatureShader as T}from"../shaders/AFeatureShader.js";import{failHittest as b}from"../shaders/hittestUtils.js";import{max4 as j}from"../shaders/utils.js";class D extends g{}t([i(3,v)],D.prototype,"inverseArea",void 0);class C extends A{}class V extends r{}t([s(n.ofType(p,2))],V.prototype,"isActive",void 0),t([s(n.ofType(p,8))],V.prototype,"colors",void 0),t([s(v)],V.prototype,"dotValue",void 0);class F extends r{}t([s(f)],F.prototype,"dotTexture0",void 0),t([s(f)],F.prototype,"dotTexture1",void 0),t([s(v)],F.prototype,"tileZoomFactor",void 0),t([s(v)],F.prototype,"pixelRatio",void 0),t([s(v)],F.prototype,"tileDotsOverArea",void 0);class _ extends T{_dotThreshold(t,e,o){return t.divide(e).divide(o)}vertex(t){const e=new h(2/o,0,0,0,-2/o,0,-1,1,1).multiply(new c(t.pos,1)),s=this.clip(t.id),i=new p(e.xy,s,1),r=this.storage.getVVData(t.id).multiply(this.instance.isActive.get(0)).multiply(t.inverseArea),l=this.storage.getDataDrivenData0(t.id).multiply(this.instance.isActive.get(1)).multiply(t.inverseArea),d=this.draw.tileZoomFactor.multiply(o).divide(this.draw.pixelRatio),a=this._dotThreshold(r,this.instance.dotValue,this.draw.tileDotsOverArea),n=this._dotThreshold(l,this.instance.dotValue,this.draw.tileDotsOverArea),u=t.pos.add(.5).divide(d);return{glPosition:i,color:new p(0,0,0,0),textureCoords:u,thresholds0:a,thresholds1:n}}fragment(t){const e=new d,o=u(this.draw.dotTexture0,t.textureCoords),s=u(this.draw.dotTexture1,t.textureCoords),i=t.thresholds0.subtract(o),r=t.thresholds1.subtract(s);let l;const a=m.fromColumns(this.instance.colors[0],this.instance.colors[1],this.instance.colors[2],this.instance.colors[3]),n=m.fromColumns(this.instance.colors[4],this.instance.colors[5],this.instance.colors[6],this.instance.colors[7]);if(this.blending){const t=y(new v(0),i),e=y(new v(0),r),o=w(t,i).add(w(e,r)),s=y(o,new v(0)),d=new v(1).subtract(s),p=o.add(s),h=i.multiply(t).divide(p),c=r.multiply(e).divide(p),u=a.multiply(h).add(n.multiply(c));l=d.multiply(u)}else{const t=x(j(i),j(r)),e=y(t,new v(0)),o=new v(1).subtract(e),s=y(t,i),d=y(t,r),p=a.multiply(s).add(n.multiply(d));l=o.multiply(p)}return e.glFragColor=l,e}hittest(t){return b(this.hittestRequest)}}t([l],_.prototype,"blending",void 0),t([s(V)],_.prototype,"instance",void 0),t([s(F)],_.prototype,"draw",void 0),t([e(0,a(D))],_.prototype,"vertex",null),t([e(0,a(A))],_.prototype,"fragment",null);export{F as DotDensityPolygonDrawUniforms,C as DotDensityPolygonFragmentInput,V as DotDensityPolygonInstanceUniforms,_ as DotDensityPolygonShader,D as DotDensityPolygonVertexInput};
