/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t,a as e}from"../../../../../../../chunks/tslib.es6.js";import{VertexInput as o,location as r,FragmentInput as s,UniformGroup as n,uniform as i,GraphShaderModule as a,define as l,FragmentOutput as p,input as u}from"../../GraphShaderModule.js";import{Vec4 as m,texture2D as d,Float as c,Vec2 as y,Sampler2D as v}from"../../graph/glsl.js";import{getHeatmapCompressionFactor as g}from"./heatmapUtils.js";class x extends o{}t([r(0,y)],x.prototype,"pos",void 0);class f extends s{}class h extends n{}t([i(v)],h.prototype,"texture",void 0),t([i(y)],h.prototype,"minAndInvRange",void 0),t([i(c)],h.prototype,"normalization",void 0);class w extends n{}t([i(v)],w.prototype,"texture",void 0);class b extends a{constructor(){super(...arguments),this.usesHalfFloatPrecision=!1}vertex(t){return{glPosition:new m(t.pos.multiply(2).subtract(1),1,1),uv:t.pos}}fragment(t){const{accumulatedDensity:e,gradient:o}=this;let r=d(e.texture,t.uv).r.multiply(new c(g(this.usesHalfFloatPrecision)));r=r.multiply(e.normalization),r=r.subtract(e.minAndInvRange.x).multiply(e.minAndInvRange.y);const s=d(o.texture,new y(r,.5)),n=new p;return n.glFragColor=new m(s.rgb.multiply(s.a),s.a),n}}t([l],b.prototype,"usesHalfFloatPrecision",void 0),t([i(h)],b.prototype,"accumulatedDensity",void 0),t([i(w)],b.prototype,"gradient",void 0),t([e(0,u(x))],b.prototype,"vertex",null),t([e(0,u(f))],b.prototype,"fragment",null);export{h as AccumulatedDensity,w as Gradient,f as HeatmapResolveFragmentInput,b as HeatmapResolveShader,x as HeatmapResolveVertexInput};
