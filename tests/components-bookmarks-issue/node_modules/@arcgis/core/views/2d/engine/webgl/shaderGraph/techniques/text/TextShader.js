/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t,a as e}from"../../../../../../../chunks/tslib.es6.js";import{minMaxZoomPrecisionFactor as i,labelPlacementOffsetPadding as o}from"../../../definitions.js";import{location as s,option as a,uniform as r,define as l,ComputeVertexInput as p,input as n}from"../../GraphShaderModule.js";import{abs as d,min as u,Float as m,floor as y,step as c,Vec3 as h,Mat3 as v,Vec4 as f,texture2D as V,smoothstep as b,Int as w,bitRShift as x,bitAnd as g,Vec2 as S,Bool as z}from"../../graph/glsl.js";import{FeatureVertexInput as j,FeatureFragmentInput as M,AFeatureShader as R}from"../shaders/AFeatureShader.js";import{bitsetTextIsBackground as C,sdfFontSize as O,bitsetTextIsMapAligned as P,maxSdfDistance as U}from"../shaders/constants.js";import{distPointTriangle as A}from"../shaders/hittestUtils.js";import{MosaicInfo as L}from"../shaders/MosaicInfo.js";import{getBit as _}from"../shaders/utils.js";import{VisualVariableColor as k}from"../shaders/VisualVariableColor.js";import{VisualVariableOpacity as N}from"../shaders/VisualVariableOpacity.js";import{VisualVariableRotation as H}from"../shaders/VisualVariableRotation.js";import{VisualVariableSizeMinMaxValue as I}from"../shaders/VisualVariableSizeMinMaxValue.js";import{VisualVariableSizeScaleStops as D}from"../shaders/VisualVariableSizeScaleStops.js";import{VisualVariableSizeStops as F}from"../shaders/VisualVariableSizeStops.js";import{VisualVariableSizeUnitValue as B}from"../shaders/VisualVariableSizeUnitValue.js";import{getVisualVariableSize as E,getVisualVariableRotation as W}from"../shaders/vvUtils.js";const q=360/254;class G extends j{}t([s(3,f)],G.prototype,"color",void 0),t([s(4,S)],G.prototype,"offset",void 0),t([s(5,S)],G.prototype,"textureUV",void 0),t([s(6,m)],G.prototype,"fontSize",void 0),t([s(7,m)],G.prototype,"referenceSize",void 0),t([s(8,m)],G.prototype,"haloFontSize",void 0),t([s(9,f)],G.prototype,"haloColor",void 0),t([s(10,S)],G.prototype,"zoomRange",void 0),t([s(11,m)],G.prototype,"clipAngle",void 0),t([s(12,f)],G.prototype,"referenceSymbol",void 0);class Z extends p{}t([s(13,S)],Z.prototype,"offsetNextVertex1",void 0),t([s(14,S)],Z.prototype,"offsetNextVertex2",void 0);class J extends M{}class K extends R{constructor(){super(...arguments),this.computeAttributes={offset:["offsetNextVertex1","offsetNextVertex2"]},this.isHaloPass=!1,this.isBackgroundPass=!1,this.isLabel=!1}clipLabel(t,e,o){const s=e.multiply(q),a=d(this.view.rotation.subtract(s)),r=u(new m(360).subtract(a),a);let l=new m(0);const p=y(this.view.currentZoom.multiply(i)).divide(i),n=t.x,h=t.y,v=new m(1).subtract(c(n,p)).multiply(2),f=c(new m(90),r).multiply(2),V=new m(2).multiply(new m(1).subtract(c(p,h)));return l=l.add(o.multiply(v)),l=l.add(o.multiply(f)),l=l.add(V),l}vertex(t,e){const i=_(t.bitset,C),s=new m(1).subtract(i);let a=t.fontSize,r=a.divide(O);const l=this.isHaloPass?t.haloColor:this._getVertexColor(t),p=this.isLabel?l.multiply(this.storage.getAnimationValue(t.id)):l,n=this.view.displayViewScreenMat3.multiply(new h(t.pos,1));let d=t.offset,u=new m(1),y=v.identity();if(this.isLabel){if(!t.referenceSymbol)throw new Error("InternalError: Optional attribute 'referenceSymbol' expected for labels");const e=t.referenceSymbol,i=e.xy,s=e.z,a=this._unpackDirection(e.w),r=E(this,t.id,s).divide(2),l=a.multiply(r.add(o));d=d.add(i).add(l)}else{u=E(this,t.id,t.referenceSize).divide(t.referenceSize),a=a.multiply(u),r=r.multiply(u),d=d.multiply(u),y=W(this,t.id),d=y.multiply(new h(d,0)).xy}const c=_(t.bitset,P),V=this._getViewRotationMatrix(c).multiply(new h(d,0));let b=this.isLabel?this.clipLabel(t.zoomRange,t.clipAngle,c):this.clip(t.id,t.zoomRange);b=this.isBackgroundPass?b.add(s.multiply(2)):b.add(i.multiply(2));const w=new f(n.xy.add(V.xy),b,1),x=t.textureUV.divide(this.mosaicInfo.size);let g=new m(0);if(this.isHaloPass){g=t.haloFontSize.divide(r).divide(U)}return{glPosition:w,color:p,size:r,textureUV:x,antialiasingWidth:new m(.105*O).divide(a).divide(this.view.pixelRatio),haloDistanceOffset:g,...this.maybeRunHittest(t,e,{vvSizeAdjustment:u,vvRotation:y})}}_getViewRotationMatrix(t){const e=this.view.displayViewMat3,i=this.view.displayMat3,o=new m(1).subtract(t);return e.multiply(t).add(i.multiply(o))}fragment(t){const e=new m(2/8),i=new m(1).subtract(e),o=V(this.mosaicInfo.texture,t.textureUV).a;let s=i.subtract(t.haloDistanceOffset);this.highlight&&(s=s.divide(2));const a=t.antialiasingWidth,r=b(s.subtract(a),s.add(a),o);return this.getFragmentOutput(t.color.multiply(r),t)}hittest(t,e,{vvSizeAdjustment:i,vvRotation:o}){const s=o.multiply(new h(t.offset.multiply(i),0)),a=o.multiply(new h(e.offsetNextVertex1.multiply(i),0)),r=o.multiply(new h(e.offsetNextVertex2.multiply(i),0)),{viewMat3:l,tileMat3:p}=this.view,n=l.multiply(p).multiply(new h(t.pos,1)),d=n.add(p.multiply(s)).xy,u=n.add(p.multiply(a)).xy,m=n.add(p.multiply(r)).xy;return A(this.hittestRequest.position,d.xy,u.xy,m.xy)}_unpackDirection(t){const e=new w(t),i=x(e,new w(2)),o=g(e,new w(3));return new S(new m(i).subtract(1),new m(o).subtract(1))}_getVertexColor(t){let e=t.color;if(this.visualVariableColor){const i=this.storage.getColorValue(t.id);e=this.visualVariableColor.getColor(i,t.color,new z(!1))}if(this.visualVariableOpacity){const i=this.storage.getOpacityValue(t.id),o=this.visualVariableOpacity.getOpacity(i);e=e.multiply(o)}return e}}t([a(k)],K.prototype,"visualVariableColor",void 0),t([a(N)],K.prototype,"visualVariableOpacity",void 0),t([a(H)],K.prototype,"visualVariableRotation",void 0),t([a(I)],K.prototype,"visualVariableSizeMinMaxValue",void 0),t([a(D)],K.prototype,"visualVariableSizeScaleStops",void 0),t([a(F)],K.prototype,"visualVariableSizeStops",void 0),t([a(B)],K.prototype,"visualVariableSizeUnitValue",void 0),t([r(L)],K.prototype,"mosaicInfo",void 0),t([l],K.prototype,"isHaloPass",void 0),t([l],K.prototype,"isBackgroundPass",void 0),t([l],K.prototype,"isLabel",void 0),t([e(0,n(G)),e(1,n(Z))],K.prototype,"vertex",null),t([e(0,n(J))],K.prototype,"fragment",null);export{J as TextFragmentInput,K as TextShader,G as TextVertexInput};
