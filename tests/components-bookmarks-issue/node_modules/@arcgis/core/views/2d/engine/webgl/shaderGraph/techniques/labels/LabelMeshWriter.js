/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{memoize as e}from"../../../../../../../core/MapUtils.js";import{fromRotation as t}from"../../../../../../../core/libs/gl-matrix-2/math/mat2d.js";import{create as i}from"../../../../../../../core/libs/gl-matrix-2/factories/mat2df32.js";import{getXAnchorDirection as s,getYAnchorDirection as a}from"../../../alignmentUtils.js";import{getDisplayIdTexel as o}from"../../../DisplayId.js";import n from"../../../collisions/BoundingBox.js";import{LabelMetric as r}from"../../../collisions/LabelMetric.js";import{smoothPaths as l,pathDivide as h}from"../../../mesh/templates/segmentUtils.js";import{getMinMaxZoom as c,processColorInput as m}from"../fill/meshWriterUtils.js";import{TextMeshWriter as d,maxLabelZoom as u}from"../text/TextMeshWriter.js";const g=1,p=0,f=128,_=e((e=>{let t=0;if(0===e)return 1/0;for(;!(e%2);)t++,e/=2;return t}));class x extends d{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,i,s){if(this._zoomLevel=s||0,null!=i)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const i=t.readXForDisplay(),s=t.readYForDisplay();return this._writePoint(e,i,s,t)}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const i=t.readCentroidForDisplay();if(!i)return;const[s,a]=i.coords;return this._writePoint(e,s,a,t)}case"esriGeometryPolyline":{const i=t.readLegacyGeometryForDisplay();this._writeLines(e,t,i)}}}_writePoint(e,t,i,n){const l=this._getShaping();if(!l)return;let h=this._getPointReferenceBounds();h||(h={offsetX:0,offsetY:0,size:0});const c=l.boundsT,m=s(this.evaluatedMeshParams.horizontalAlignment),d=a(this.evaluatedMeshParams.verticalAlignment),u=this.evaluatedMeshParams.scaleInfo?.maxScale??0,g=this.evaluatedMeshParams.scaleInfo?.minScale??0,p=o(n.getDisplayId());e.metricStart(new r(p,t,i,m,d,u,g,h)),e.metricBoxWrite(c),this._writeGlyphs(e,n.getDisplayId(),t,i,l,0,h),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t,i){const{repeatLabel:s,scaleInfo:a}=this.evaluatedMeshParams,o=this.evaluatedMeshParams.repeatLabelDistance||128,n=this._getShaping();if(!n)return;this._current={out:e,id:t.getDisplayId(),shaping:n,zoomRange:c(a,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0}};const r=l(i.paths,n.bounds.width),m=this._placeSubdivGlyphs.bind(this),d=(n.bounds.width+o)/(1<<g);for(const l of r)h(l,d,m,!!s)}_placeSubdivGlyphs(e,t,i,s){const{allowOverrun:a,labelPosition:o,repeatLabelDistance:n}=this.evaluatedMeshParams,r=this._current.zoomRange[0],l=_(t),h=this._current.shaping.bounds.width/(1<<g),c=Math.sqrt(n||f)/(1<<g),m=Math.min(i,s-i),d=this._current.shaping.isMultiline?u:Math.log2(m/(c+h/2)),p=0===t?d:Math.min(l,d),x=Math.max(r,this._zoomLevel+g-p),M=this._zoomLevel-x,y=this._current.shaping.bounds.width/2*2**M;this._current.shaping.isMultiline?0===t&&this._placeStraight(e,x):a&&M<0?this._placeStraightAlong(e,r):"parallel"===o?this._placeStraightAlong(e,x):"curved"===o&&this._placeCurved(e,x,y)}_placeStraight(e,t){const{out:i,id:s,shaping:a,referenceBounds:n}=this._current,{x:l,y:h}=e,c=o(s),m=this.evaluatedMeshParams.scaleInfo?.maxScale??0,d=this.evaluatedMeshParams.scaleInfo?.minScale??0;i.metricStart(new r(c,e.x,e.y,0,0,m,d,null)),i.metricBoxWrite(a.boundsT);const u=e.angle*(180/Math.PI)%360,g=(e.angle*(180/Math.PI)+180)%360;this._writeGlyphs(i,s,l,h,a,0,n,{clipAngle:u,mapAligned:!0,isLineLabel:!0,minZoom:t}),this._writeGlyphs(i,s,l,h,a,0,n,{clipAngle:g,mapAligned:!0,isLineLabel:!0,minZoom:t}),i.metricEnd()}_placeCurved(e,t,i){const{out:s,id:a}=this._current,n=e.clone(),l=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360,c=o(a),m=this.evaluatedMeshParams.scaleInfo?.maxScale??0,d=this.evaluatedMeshParams.scaleInfo?.minScale??0;s.metricStart(new r(c,e.x,e.y,0,0,m,d,null)),this._placeFirst(n,t,1,l),this._placeBack(e,n,t,i,1,l),this._placeForward(e,n,t,i,1,l),this._placeFirst(n,t,0,h),this._placeBack(e,n,t,i,0,h),this._placeForward(e,n,t,i,0,h),s.metricEnd()}_placeStraightAlong(e,s){const{out:a,id:n,shaping:l,zoomRange:h,referenceBounds:c}=this._current,{boxBorderLineColor:m,boxBackgroundColor:d}=this.evaluatedMeshParams,g=e.clone(),p=e.angle*(180/Math.PI)%360,f=(e.angle*(180/Math.PI)+180)%360;if(l.glyphs.length>0&&(m||d)){const o=Math.max(s,h[0],0),r=Math.min(u,h[1]),m=t(i(),-e.angle),[d,g]=l.shapeBackground(m),_={minZoom:o,maxZoom:r,clipAngle:p,mapAligned:!0,isLineLabel:!0};a.recordStart(this.instanceId,this.attributeLayout,l.glyphs[0].textureBinding),this._writeTextBox(a,n,e.x,e.y,g,c,_),a.recordEnd(),_.clipAngle=f,a.recordStart(this.instanceId,this.attributeLayout,l.glyphs[0].textureBinding),this._writeTextBox(a,n,e.x,e.y,g,c,_),a.recordEnd()}const _=o(n),x=this.evaluatedMeshParams.scaleInfo?.maxScale??0,M=this.evaluatedMeshParams.scaleInfo?.minScale??0;a.metricStart(new r(_,e.x,e.y,0,0,x,M,null)),this._placeFirst(g,s,1,p,!0),this._placeFirst(g,s,0,f,!0),a.metricEnd()}_placeBack(e,t,i,s,a,o){const n=e.clone();let r=e.backwardLength+p;for(;n.prev()&&!(r>=s);)this._placeOnSegment(n,t,r,i,-1,a,o),r+=n.length+p}_placeForward(e,t,i,s,a,o){const n=e.clone();let r=e.remainingLength+p;for(;n.next()&&!(r>=s);)this._placeOnSegment(n,t,r,i,1,a,o),r+=n.length+p}_placeFirst(e,t,i,s,a=!1){const o=e,{out:n,id:r,shaping:l,zoomRange:h,referenceBounds:c}=this._current,m=l.glyphs;for(const d of m){const m=d.x>l.bounds.x?i:1-i,g=m*e.remainingLength+(1-m)*e.backwardLength,f=Math.abs(d.x+d.width/2-l.bounds.x),_=Math.max(0,this._zoomLevel+Math.log2(f/(g+p))),x=Math.max(t,a?0:_);d.maxZoom=Math.min(h[1],u),d.angle=e.angle+(1-i)*Math.PI,d.minZoom=Math.max(h[0],x),this._writeLineGlyph(n,r,o.x,o.y,l.bounds,d,s,c,!0),i&&this._isVisible(d.minZoom,d.maxZoom)&&n.metricBoxWrite(d.bounds)}}_placeOnSegment(e,t,i,s,a,o,r){const{out:l,id:h,shaping:c,referenceBounds:m}=this._current,d=c.glyphs,u=e.dx/e.length,g=e.dy/e.length,f={x:e.x+i*-a*u,y:e.y+i*-a*g};for(const _ of d){const d=_.x>c.bounds.x?o:1-o;if(!(d&&1===a||!d&&-1===a))continue;const u=Math.abs(_.x+_.width/2-c.bounds.x),g=Math.max(0,this._zoomLevel+Math.log2(u/i)-.1),x=Math.max(s,this._zoomLevel+Math.log2(u/(i+e.length+p)));if(0!==g&&(_.angle=e.angle+(1-o)*Math.PI,_.minZoom=x,_.maxZoom=g,this._writeLineGlyph(l,h,f.x,f.y,c.bounds,_,r,m,!0),o&&this._isVisible(_.minZoom,_.maxZoom))){const i=_.bounds,s=e.x-t.x,a=e.y-t.y,o=new n(i.center[0]+s,i.center[1]+a,i.width,i.height);l.metricBoxWrite(o)}}}_writeLineGlyph(e,t,i,s,a,o,n,r,l){const h=i+a.x,c=s+a.y,d=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),u=Math.max(a.width,a.height)*d;e.recordStart(this.instanceId,this.attributeLayout,o.textureBinding),e.recordBounds(h,c,u,u);const{texcoords:g,offsets:p}=o,f=this._textMeshTransformProps.fontSize;this._writeQuad(e,t,i,s,{texcoords:g,offsets:p,fontSize:f,color:m(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:r,minZoom:Math.max(this._current.zoomRange[0],o.minZoom),maxZoom:Math.min(this._current.zoomRange[1],o.maxZoom),clipAngle:n,mapAligned:l,isLineLabel:!0}),e.recordEnd()}_isVisible(e,t){const i=this._zoomLevel;return e<=i&&i<=t}}export{x as LabelMeshWriter};
