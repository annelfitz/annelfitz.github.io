/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{createScreenPoint as t}from"../../../../core/screenUtils.js";import{identity as e,multiply as r,translate as s,scale as o,rotate as i}from"../../../../core/libs/gl-matrix-2/math/mat3.js";import{create as a}from"../../../../core/libs/gl-matrix-2/factories/mat3f32.js";import{fromValues as n}from"../../../../core/libs/gl-matrix-2/factories/vec2f32.js";import{fromValues as l}from"../../../../core/libs/gl-matrix-2/factories/vec3f32.js";import{normalizeMapX as c}from"../../../../geometry/support/normalizeUtils.js";import{getInfo as p}from"../../../../geometry/support/spatialReferenceUtils.js";import{getWorldWidth as m}from"../../viewpointUtils.js";import{brushes as d}from"../brushes.js";import{WGLDrawPhase as f}from"./enums.js";import h from"./WGLContainer.js";class u extends h{constructor(){super(...arguments),this._localOrigin=t(0,0),this._viewStateId=-1,this._dvsMat3=a()}get dvsMat3(){return this._dvsMat3}beforeRender(t){this._updateMatrices(t),this._updateOverlays(t,this.children);for(const e of this.children)e.beforeRender(t)}prepareRenderPasses(t){const e=t.registerRenderPass({name:"overlay",brushes:[d.overlay],target:()=>this.children,drawPhase:f.MAP});return[...super.prepareRenderPasses(t),e]}_updateMatrices(t){const{state:a}=t,{id:p,size:m,pixelRatio:d,resolution:f,rotation:h,viewpoint:u,displayMat3:M}=a;if(this._viewStateId===p)return;const v=Math.PI/180*h,g=d*m[0],_=d*m[1],{x:w,y:b}=u.targetGeometry,y=c(w,a.spatialReference);this._localOrigin.x=y,this._localOrigin.y=b;const j=f*g,x=f*_,R=e(this._dvsMat3);r(R,R,M),s(R,R,n(g/2,_/2)),o(R,R,l(g/j,-_/x,1)),i(R,R,-v),this._viewStateId=p}_updateOverlays(t,e){const{state:r}=t,{rotation:s,spatialReference:o,worldScreenWidth:i,size:a,viewpoint:n}=r,l=this._localOrigin;let c=0;const d=p(o);if(d&&o.isWrappable){const t=a[0],p=a[1],f=180/Math.PI*s,h=Math.abs(Math.cos(f)),u=Math.abs(Math.sin(f)),M=Math.round(t*h+p*u),[v,g]=d.valid,_=m(o),{x:w,y:b}=n.targetGeometry,y=[w,b],j=[0,0];r.toScreen(j,y);const x=[0,0];let R;R=M>i?.5*i:.5*M;const P=Math.floor((w+.5*_)/_),O=v+P*_,C=g+P*_,I=[j[0]+R,0];r.toMap(x,I),x[0]>C&&(c=_),I[0]=j[0]-R,r.toMap(x,I),x[0]<O&&(c=-_);for(const r of e){const t=r.elementView.bounds;if(null==t)continue;const[e,,s]=t;e<v&&s>v?r.updateDrawCoords(l,_):s>g&&e<g?r.updateDrawCoords(l,-_):r.updateDrawCoords(l,c)}}else for(const p of e)p.updateDrawCoords(l,c)}}export{u as default};
