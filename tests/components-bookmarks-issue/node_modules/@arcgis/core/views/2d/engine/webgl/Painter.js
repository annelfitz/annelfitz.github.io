/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import{disposeMaybe as e}from"../../../../core/maybe.js";import{brushes as t}from"../brushes.js";import s from"../vectorTiles/shaders/VTLMaterialManager.js";import{BitBlitRenderer as r}from"./BitBlitRenderer.js";import{WGLDrawPhase as i}from"./enums.js";import n from"./MaterialManager.js";import a from"./TextureManager.js";import{TextureUploadManager as o}from"./TextureUploadManager.js";import l from"./VertexStream.js";import{WorldExtentRenderer as h}from"./WorldExtentClipRenderer.js";import{AnimationEffect as f}from"./effects/AnimationEffect.js";import{BlendEffect as c}from"./effects/BlendEffect.js";import{FeatureEffect as d}from"./effects/FeatureEffect.js";import u from"./effects/HighlightEffect.js";import{HittestEffect as p}from"./effects/HittestEffect.js";import{HittestEffectVTL as _}from"./effects/HittestEffectVTL.js";import{EffectManager as b}from"./effects/post-processing/EffectManager.js";import m from"./painter/RenderPass.js";import{TechniqueProgramCache as E}from"./shaderGraph/techniques/TechniqueProgramCache.js";import{TextureSamplingMode as g,TextureWrapMode as S,CompareFunction as w,BlendFactor as M,RenderbufferFormat as P,PrimitiveType as C,DataType as B,BlendOperation as T,Face as A}from"../../../webgl/enums.js";import{FramebufferObject as R}from"../../../webgl/FramebufferObject.js";import{Renderbuffer as F}from"../../../webgl/Renderbuffer.js";import{RenderbufferDescriptor as N}from"../../../webgl/RenderbufferDescriptor.js";import{TextureDescriptor as O}from"../../../webgl/TextureDescriptor.js";class D{constructor(e,t){this.context=e,this._currentPipelineStateNeedsUpdate=!1,this._blitRenderer=new r,this._worldExtentRenderer=new h,this._brushCache=new Map,this._lastWidth=null,this._lastHeight=null,this._vtlMaterialManager=new s,this._blendEffect=new c,this._stencilBuf=null,this._prevBeforeLayerFBOStack=[],this._fboPool=[],this.effects={highlight:new u,hittest:new p,hittestVTL:new _,integrate:new f,insideEffect:new d("inside"),outsideEffect:new d("outside")},this._programCache=new E,this._shaderState={shader:null,uniforms:null,defines:null,optionalAttributes:null,useComputeBuffer:!1},this.materialManager=new n(e),this.textureManager=new a(t),this.textureUploadManager=new o(t),this._effectsManager=new b,this._quadMesh=new l(e,[0,0,1,0,0,1,1,1])}dispose(){if(this._programCache.destroy(),this.materialManager.dispose(),this.textureManager.dispose(),this.textureUploadManager.destroy(),this._blitRenderer=e(this._blitRenderer),this._worldExtentRenderer=e(this._worldExtentRenderer),this._quadMesh.dispose(),this._brushCache&&(this._brushCache.forEach((e=>e.dispose())),this._brushCache.clear(),this._brushCache=null),this._fbos){let e;for(e in this._fbos)this._fbos[e]&&this._fbos[e].dispose()}for(const e of this._fboPool)e.dispose();if(this._fboPool.length=0,this.effects){let e;for(e in this.effects)this.effects[e]&&this.effects[e].dispose()}this._effectsManager.dispose(),this._blendEffect.dispose(this.context),this._vtlMaterialManager=e(this._vtlMaterialManager)}clearShaderCache(){this._programCache.destroy(),this._programCache=new E}get blitRenderer(){return this._blitRenderer}get vectorTilesMaterialManager(){return this._vtlMaterialManager}getFbos(){if(!this._fbos)throw new Error("InternalError: Painter FBOs not initialized");return this._fbos}acquireFbo(e,t){let s;if(this._fboPool.length>0)s=this._fboPool.pop();else{const r=new O(e,t);r.samplingMode=g.NEAREST,r.wrapMode=S.CLAMP_TO_EDGE,s=new R(this.context,r,this._stencilBuf)}return s.width===e&&s.height===t||s.resize(e,t),s}releaseFbo(e){this._fboPool.push(e)}getSharedStencilBuffer(){return this._stencilBuf}beforeRenderPhases(e,t,s){const{context:r}=e;this._worldExtentRenderer.render(e,t,s);const{width:i,height:n}=r.getViewport();if(this.updateFBOs(i,n),this._prevFBO=r.getBoundFramebufferObject(),r.bindFramebuffer(this.getFbos().output),r.setColorMask(!0,!0,!0,!0),null!=t){const{r:e,g:s,b:i,a:n}=t;r.setClearColor(n*e/255,n*s/255,n*i/255,n)}else r.setClearColor(0,0,0,0);r.setDepthWriteEnabled(!0),r.setClearDepth(1),r.clear(r.gl.COLOR_BUFFER_BIT|r.gl.DEPTH_BUFFER_BIT),r.setDepthWriteEnabled(!1)}afterRenderPhases(e){const{context:t}=e;t.bindFramebuffer(this._prevFBO),t.setStencilFunction(w.EQUAL,1,255),t.setStencilTestEnabled(!0),t.setDepthTestEnabled(!1),this.blitTexture(t,this.getFbos().output.colorTexture,g.NEAREST)}beforeRenderLayer(e,t,s){const{context:r,blendMode:i,effects:n,drawPhase:a,requireFBO:o}=e;if(o||x(a,i,n,s)){const e=r.getBoundFramebufferObject();this._prevBeforeLayerFBOStack.push(e);const{width:t,height:s}=r.getViewport(),i=this.acquireFbo(t,s);r.bindFramebuffer(i),r.setColorMask(!0,!0,!0,!0),r.setClearColor(0,0,0,0),r.setDepthWriteEnabled(!0),r.setClearDepth(1),r.clear(r.gl.COLOR_BUFFER_BIT|r.gl.DEPTH_BUFFER_BIT),r.setDepthWriteEnabled(!1)}r.setDepthWriteEnabled(!1),r.setDepthTestEnabled(!1),r.setStencilTestEnabled(!0),r.setClearStencil(t),r.setStencilWriteMask(255),r.clear(r.gl.STENCIL_BUFFER_BIT)}afterRenderLayer(e,t){const{context:s,blendMode:r,effects:n,requireFBO:a,drawPhase:o}=e;if(a||x(o,r,n,t)){const a=s.getBoundFramebufferObject();null!=n&&n.length>0&&o===i.MAP&&(s.setColorMask(!0,!0,!0,!0),this._applyEffects(e,n,a)),s.bindFramebuffer(this._prevBeforeLayerFBOStack.pop()),s.setStencilTestEnabled(!1),s.setStencilWriteMask(0),s.setBlendingEnabled(!0),s.setBlendFunctionSeparate(M.ONE,M.ONE_MINUS_SRC_ALPHA,M.ONE,M.ONE_MINUS_SRC_ALPHA),s.setColorMask(!0,!0,!0,!0);const l=null==r||o===i.HIGHLIGHT?"normal":r;this._blendEffect.draw(e,a.colorTexture,g.NEAREST,l,t),this.releaseFbo(a)}}renderObject(e,s,r,i){const n=t[r];if(!n)return;let a=this._brushCache.get(n);void 0===a&&(a=new n,this._brushCache.set(n,a)),a.prepareState(e),a.draw(e,s,i)}renderObjects(e,s,r,i){const n=t[r];if(!n)return;let a=this._brushCache.get(n);void 0===a&&(a=new n,this._brushCache.set(n,a)),a.drawMany(e,s,i)}registerRenderPass(e){const t=e.brushes.map((e=>(this._brushCache.has(e)||this._brushCache.set(e,new e),this._brushCache.get(e))));return new m(t,e)}blitTexture(e,t,s,r=1){e.setBlendingEnabled(!0),e.setBlendFunctionSeparate(M.ONE,M.ONE_MINUS_SRC_ALPHA,M.ONE,M.ONE_MINUS_SRC_ALPHA),e.setColorMask(!0,!0,!0,!0),this._blitRenderer.render(e,t,s,r),this._currentPipelineStateNeedsUpdate=!0}getPostProcessingEffects(e){return this._effectsManager.getPostProcessingEffects(e)}updateFBOs(e,t){if(e!==this._lastWidth||t!==this._lastHeight){if(this._lastWidth=e,this._lastHeight=t,this._fbos){let s;for(s in this._fbos)this._fbos[s].resize(e,t);return}const s=new O(e,t);s.samplingMode=g.NEAREST,s.wrapMode=S.CLAMP_TO_EDGE;const r=new N(P.DEPTH_STENCIL,e,t);this._stencilBuf=new F(this.context,r),this._fbos={output:new R(this.context,s,this._stencilBuf),effect0:new R(this.context,s,this._stencilBuf)}}}_applyEffects(e,t,s){const{context:r}=e,i=this._effectsManager.getPostProcessingEffects(t);for(const{postProcessingEffect:n,effect:a}of i)r.bindFramebuffer(s),n.draw(e,s,a);this._currentPipelineStateNeedsUpdate=!0}setShader(e){this._shaderState.shader=e.shader,this._shaderState.uniforms=e.uniforms,this._shaderState.defines=e.defines,this._shaderState.optionalAttributes=e.optionalAttributes,this._shaderState.useComputeBuffer=e.useComputeBuffer??!1}setPipelineState(e){e!==this._currentPipelineState&&(this._currentPipelineState=e,this._currentPipelineStateNeedsUpdate=!0)}submitDraw(e,t){const{instance:s}=t,r=s.instanceId,{shader:i,uniforms:n,defines:a,optionalAttributes:o,useComputeBuffer:l}=this._shaderState,h=t.target.getMesh(r),f={useComputeBuffer:l,locationInfo:i.locationInfo,computeAttributeMap:i.computeAttributes},c=h.getLayout(f);if(null==c)return null;const{primitive:d,count:u,offset:p}=h.getDrawArgs(C.TRIANGLES,t.count,t.start*Uint32Array.BYTES_PER_ELEMENT,l),_=this._programCache.getProgram(i,c,n,a??{},o??{});_.setUniforms(n),_.bind(e),this.updatePipelineState(e),this._updateStencilRef(e,t.target);const b=h.getVAO(e,i.locationInfo,f);return e.bindVAO(b),e.drawElements(d,u,B.UNSIGNED_INT,p),e.bindVAO(null),_.cleanupTemporaryTextures(),{vertexShader:_.vertexShader,fragmentShader:_.fragmentShader}}submitDrawQuad(e){const{shader:t,uniforms:s,defines:r,optionalAttributes:i}=this._shaderState,n=this._programCache.getProgram(t,this._quadMesh.layout,s,r??{},i??{});n.setUniforms(s),n.bind(e),this.updatePipelineState(e),this._updateStencilRef(e,null),this._quadMesh.draw(),e.bindVAO(null),n.cleanupTemporaryTextures()}submitDrawMesh(e,t,s){const{shader:r,uniforms:i,defines:n,optionalAttributes:a}=this._shaderState,o=this._programCache.getProgram(r,t.layout,i,n??{},a??{});if(o.setUniforms(i),o.bind(e),this.updatePipelineState(e),this._updateStencilRef(e,null),s)for(const l of s)t.bind(e,l),t.draw(e);else for(let l=0;l<t.parts.length;l++)t.bind(e,l),t.draw(e);t.unbind(e),o.cleanupTemporaryTextures()}updatePipelineState(e){this._currentPipelineStateNeedsUpdate&&(this._currentPipelineStateNeedsUpdate=!1,this._updatePipelineState(e))}_updatePipelineState(e){if(null==this._currentPipelineState)throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");const{color:t,depth:s,stencil:r}=this._currentPipelineState;if(t){const{blendMode:s,write:r}=t;switch(e.setColorMask(...r),e.setBlendingEnabled(!0),e.setBlendEquation(T.ADD),s){case"composite":e.setBlendFunctionSeparate(M.ONE,M.ONE_MINUS_SRC_ALPHA,M.ONE,M.ONE_MINUS_SRC_ALPHA);break;case"additive":e.setBlendFunctionSeparate(M.ONE,M.ONE,M.ONE,M.ONE);break;case"custom":{const{blendParameters:s}=t,{dstAlpha:r,dstRGB:i,srcAlpha:n,srcRGB:a}=s;e.setBlendFunctionSeparate(a,i,n,r);break}case"delete":e.setBlendEquation(T.REVERSE_SUBTRACT),e.setBlendFunctionSeparate(M.ONE,M.ONE_MINUS_SRC_ALPHA,M.ONE,M.ONE_MINUS_SRC_ALPHA)}}if(s){const{test:t,write:r}=s;r?(e.setDepthWriteEnabled(!0),e.setDepthRange(r.zNear,r.zFar)):e.setDepthWriteEnabled(!1),t?(e.setDepthTestEnabled(!0),e.setDepthFunction(t)):e.setDepthTestEnabled(!1)}else e.setDepthTestEnabled(!1),e.setDepthWriteEnabled(!1);if(r){const{test:t,write:s}=r;if(t){const{compare:s,mask:r,op:i,ref:n}=t;e.setStencilTestEnabled(!0),"function"!=typeof n&&e.setStencilFunctionSeparate(A.FRONT_AND_BACK,s,n,r),e.setStencilOpSeparate(A.FRONT_AND_BACK,i.fail,i.zFail,i.zPass)}else e.setStencilTestEnabled(!1);if(s){const{mask:t}=s;e.setStencilWriteMask(t)}else e.setStencilWriteMask(0)}else e.setStencilTestEnabled(!1),e.setStencilWriteMask(0)}_updateStencilRef(e,t){if(null==this._currentPipelineState)throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");const{stencil:s}=this._currentPipelineState;if(s){const{test:r}=s;if(r){const{compare:s,mask:i,ref:n}=r;"function"==typeof n&&e.setStencilFunctionSeparate(A.FRONT_AND_BACK,s,n(t),i)}}}}function x(e,t,s,r){return e!==i.LABEL_ALPHA&&e!==i.LABEL&&e!==i.HIGHLIGHT&&(1!==r||null!=t&&"normal"!==t||null!=s&&s.length>0)}export{D as default};
