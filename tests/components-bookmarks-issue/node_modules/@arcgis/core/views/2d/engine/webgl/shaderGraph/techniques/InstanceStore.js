/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{numericHash as t}from"../../../../../../core/string.js";import{TechniqueInstance as e}from"./TechniqueInstance.js";import{castInstanceId as n}from"./mesh/instanceIdUtils.js";class s{constructor(){this._instanceById=new Map}destroy(){this._instanceById.clear()}get size(){return this._instanceById.size}updateStart(){this._instanceByIdNext=new Map}updateEnd(){if(!this._instanceByIdNext)throw new Error("InternalError: Found updateEnd call without corresponding updateStart");for(const t of this._instanceById.keys())this._instanceByIdNext.has(t)||this._instanceById.delete(t);for(const[t,e]of this._instanceByIdNext.entries()){const n=this._instanceById.get(t);n?n.setInput(e.getInput()):this._instanceById.set(t,e)}this._instanceByIdNext=null}values(){return this._instanceById.values()}ensureInstance(s,i,r){let a=`${s.registryName}`;for(const t in i){const e=i[t];if("object"==typeof e&&"geometry"===t)for(const n in e)a+=`.${t}.${n}.${null!=e[n]}`;else a+=`.${t}.${null!=i[t]}`}if(null!=r)for(const t in r)r[t]&&(a+=`-${t}`);const c=t(a);if(this._instanceByIdNext){const t=new e(n(c),s,s.meshWriter.name,i,r);return this._instanceByIdNext.set(c,t),t}if(!this._instanceById.has(c)){const t=new e(n(c),s,s.meshWriter.name,i,r);this._instanceById.set(c,t)}return this._instanceById.get(c)}getInstance(t){return this._instanceById.get(t)}}export{s as default};
