/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{disposeMaybe as t}from"../../../../core/maybe.js";import{estimateSize as e}from"../../../../core/typedArrayUtil.js";import"../../tiling/TileInfoView.js";import r from"../../tiling/TileKey.js";import"../../tiling/TileQueue.js";import"../../tiling/TileStrategy.js";import{BucketType as n}from"./enums.js";import{deserializeSymbols as s}from"./decluttering/util.js";import{BufferObject as i}from"../../../webgl/BufferObject.js";import{Usage as a}from"../../../webgl/enums.js";import{VertexArrayObject as o}from"../../../webgl/VertexArrayObject.js";class h{constructor(t,e){this.layerUIDs=[],this.isDestroyed=!1,this._data=t;let r=1;const n=new Uint32Array(t);this.layerUIDs=[];const s=n[r++];for(let i=0;i<s;i++)this.layerUIDs[i]=n[r++];this.bufferDataOffset=r,e&&(this.layer=e.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return null==this._data}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(t){null!=this._data&&(this.doPrepareForRendering(t,this._data,this.bufferDataOffset),this._data=null)}}class f extends h{constructor(t,e){super(t,e),this.type=n.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const r=new Uint32Array(t);let s=this.bufferDataOffset;this.lineIndexStart=r[s++],this.lineIndexCount=r[s++];const i=r[s++];if(i>0){this.patternMap=new Map;for(let t=0;t<i;t++){const t=r[s++],e=r[s++],n=r[s++];this.patternMap.set(t,[e,n])}}this.bufferDataOffset=s}get memoryUsed(){return(this.data?.byteLength??0)+(this.vao?.usedMemory??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=t(this.vao)}doPrepareForRendering(t,e,r){const n=new Uint32Array(e),s=new Int32Array(n.buffer),h=n[r++],f=i.createVertex(t,a.STATIC_DRAW,new Int32Array(s.buffer,4*r,h));r+=h;const l=n[r++],c=i.createIndex(t,a.STATIC_DRAW,new Uint32Array(n.buffer,4*r,l));r+=l;const u=this.layer.lineMaterial;this.vao=new o(t,u.getAttributeLocations(),u.getLayoutInfo(),{geometry:f},c)}}class l extends h{constructor(t,e){super(t,e),this.type=n.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const r=new Uint32Array(t);let s=this.bufferDataOffset;this.fillIndexStart=r[s++],this.fillIndexCount=r[s++],this.outlineIndexStart=r[s++],this.outlineIndexCount=r[s++];const i=r[s++];if(i>0){this.patternMap=new Map;for(let t=0;t<i;t++){const t=r[s++],e=r[s++],n=r[s++];this.patternMap.set(t,[e,n])}}this.bufferDataOffset=s}get memoryUsed(){return(this.data?.byteLength??0)+(this.fillVAO?.usedMemory??0)+(this.outlineVAO?.usedMemory??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=t(this.fillVAO),this.outlineVAO=t(this.outlineVAO)}doPrepareForRendering(t,e,r){const n=new Uint32Array(e),s=new Int32Array(n.buffer),h=n[r++],f=i.createVertex(t,a.STATIC_DRAW,new Int32Array(s.buffer,4*r,h));r+=h;const l=n[r++],c=i.createIndex(t,a.STATIC_DRAW,new Uint32Array(n.buffer,4*r,l));r+=l;const u=n[r++],y=i.createVertex(t,a.STATIC_DRAW,new Int32Array(s.buffer,4*r,u));r+=u;const d=n[r++],A=i.createIndex(t,a.STATIC_DRAW,new Uint32Array(n.buffer,4*r,d));r+=d;const I=this.layer,p=I.fillMaterial,g=I.outlineMaterial;this.fillVAO=new o(t,p.getAttributeLocations(),p.getLayoutInfo(),{geometry:f},c),this.outlineVAO=new o(t,g.getAttributeLocations(),g.getLayoutInfo(),{geometry:y},A)}}class c extends h{constructor(t,e,i){super(t,e),this.type=n.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const a=new Uint32Array(t),o=new Int32Array(t),h=new Float32Array(t);let f=this.bufferDataOffset;this.isIconSDF=!!a[f++];const l=a[f++],c=a[f++],u=a[f++],y=new r(l,c,u,0),d=a[f++];for(let r=0;r<d;r++){const t=a[f++],e=a[f++],r=a[f++];this.iconPerPageElementsMap.set(t,[e,r])}const A=a[f++];for(let r=0;r<A;r++){const t=a[f++],e=a[f++],r=a[f++];this.glyphPerPageElementsMap.set(t,[e,r])}const I=a[f++],p=a[f++];this.iconOpacity=new Int32Array(I),this.textOpacity=new Int32Array(p),f=s(a,o,h,f,this.symbols,i,y),this.bufferDataOffset=f}get memoryUsed(){return(this.data?.byteLength??0)+(this.iconVAO?.usedMemory??0)+(this.textVAO?.usedMemory??0)+e(this.iconOpacity)+e(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let t=0;for(const[e,r]of this.iconPerPageElementsMap)t+=r[1];for(const[e,r]of this.glyphPerPageElementsMap)t+=r[1];return t/3}doDestroy(){this.iconVAO=t(this.iconVAO),this.textVAO=t(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const t=this.iconOpacity,e=this.iconVAO.vertexBuffers.opacity;t.length>0&&t.byteLength===e.usedMemory&&e.setSubData(t,0,0,t.length);const r=this.textOpacity,n=this.textVAO.vertexBuffers.opacity;r.length>0&&r.byteLength===n.usedMemory&&n.setSubData(r,0,0,r.length)}doPrepareForRendering(t,e,r){const n=new Uint32Array(e),s=new Int32Array(n.buffer),h=n[r++],f=i.createVertex(t,a.STATIC_DRAW,new Int32Array(s.buffer,4*r,h));r+=h;const l=n[r++],c=i.createIndex(t,a.STATIC_DRAW,new Uint32Array(n.buffer,4*r,l));r+=l;const u=n[r++],y=i.createVertex(t,a.STATIC_DRAW,new Int32Array(s.buffer,4*r,u));r+=u;const d=n[r++],A=i.createIndex(t,a.STATIC_DRAW,new Uint32Array(n.buffer,4*r,d));r+=d;const I=i.createVertex(t,a.STATIC_DRAW,this.iconOpacity.buffer),p=i.createVertex(t,a.STATIC_DRAW,this.textOpacity.buffer),g=this.layer,x=g.iconMaterial,m=g.textMaterial;this.iconVAO=new o(t,x.getAttributeLocations(),x.getLayoutInfo(),{geometry:f,opacity:I},c),this.textVAO=new o(t,m.getAttributeLocations(),m.getLayoutInfo(),{geometry:y,opacity:p},A)}}class u extends h{constructor(t,e){super(t,e),this.type=n.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const r=new Uint32Array(t);let s=this.bufferDataOffset;this.circleIndexStart=r[s++],this.circleIndexCount=r[s++],this.bufferDataOffset=s}get memoryUsed(){return(this.data?.byteLength??0)+(this.vao?.usedMemory??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=t(this.vao)}doPrepareForRendering(t,e,r){const n=new Uint32Array(e),s=new Int32Array(n.buffer),h=n[r++],f=i.createVertex(t,a.STATIC_DRAW,new Int32Array(s.buffer,4*r,h));r+=h;const l=n[r++],c=i.createIndex(t,a.STATIC_DRAW,new Uint32Array(n.buffer,4*r,l));r+=l;const u=this.layer.circleMaterial;this.vao=new o(t,u.getAttributeLocations(),u.getLayoutInfo(),{geometry:f},c)}}export{u as CircleRenderBucket,l as FillRenderBucket,f as LineRenderBucket,h as RenderBucketBase,c as SymbolRenderBucket};
