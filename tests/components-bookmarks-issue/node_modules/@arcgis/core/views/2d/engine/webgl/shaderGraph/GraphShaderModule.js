/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import e from"../../../../../core/Logger.js";import{numericHash as r}from"../../../../../core/string.js";import{ShaderBuilder2D as o}from"./ShaderBuilder2D.js";import{Float as n,Int as s,Vec4 as i,Vec2 as p}from"./graph/glsl.js";import{GlslShaderWriter as a}from"./graph/GlslGraphWriter.js";import{ShaderGraphContext as c}from"./graph/ShaderGraphContext.js";import{setReachableUids as u}from"./graph/ShaderGraphNode.js";import{TypedShaderProgram as d}from"./typed/TypedShaderProgram.js";function y(t){return new t}function h(t,e,r){const o=t.constructor[e]??[];t.constructor.hasOwnProperty(e)||Object.defineProperty(t.constructor,e,{value:o.slice()}),t.constructor[e].push(r)}function f(t,e){return(r,o)=>{h(r,"locations",{typeCtor:e,propertyKey:o,parameterIndex:null,index:t})}}const l=t=>(e,r)=>{h(e,"builtins",{builtin:t,propertyKey:r})},m=t=>(e,r,o)=>{h(e,"inputs",{inputCtor:t,propertyKey:r,parameterIndex:o})},g=t=>(e,r)=>{h(e,"uniforms",{typeCtor:t,propertyKey:r})},_=t=>(e,r)=>{h(e,"options",{typeCtor:t,propertyKey:r})},K=(t,e)=>{h(t,"defines",{propertyKey:e})};function x(t){return(e,r)=>{h(e,"transformFeedbackBindings",{propertyKey:r,parameterIndex:null,index:t})}}const C=(t,e)=>(r,o)=>{r.constructor.builtins.push({builtin:t,propertyKey:o,typeCtor:e})};class I{}I.builtins=[],t([C("gl_VertexID",s)],I.prototype,"glVertexID",void 0);class b{}class v{}v.builtins=[],t([C("gl_FragCoord",i)],v.prototype,"glFragCoord",void 0),t([C("gl_PointCoord",p)],v.prototype,"glPointCoord",void 0);class w{}t([l("gl_FragColor")],w.prototype,"glFragColor",void 0);class F{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}}class P{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const t=this._shaderModuleClass.inputs.findLast((t=>"vertex"===t.propertyKey&&0===t.parameterIndex));if(!t)throw new Error("Unable to find vertex input parameter");return t}get computeInput(){return this._shaderModuleClass.inputs.findLast((t=>"vertex"===t.propertyKey&&1===t.parameterIndex))}get fragmentInput(){const t=this._shaderModuleClass.inputs.findLast((t=>"fragment"===t.propertyKey));if(!t)throw new Error("Unable to find fragment input parameter");return t}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const t=new Map,r=new Set;for(const o of this.locations)r.has(o.index)?e.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${o.propertyKey} to ${o.index}. Index already in use`,{locationsMap:t}):(t.set(o.propertyKey,o.index),r.add(o.index));return t}get locationInfo(){if(!this._locationInfo){const t=this.locationsMap,e=Array.from(t.entries()).map((([t,e])=>`${t}.${e}`)).join("."),o=r(e);this._locationInfo={hash:o,locations:t}}return this._locationInfo}get renamedLocationsMap(){const t=new Map;for(const e of this.locations)t.set("a_"+e.propertyKey,e.index);return t}get optionPropertyKeys(){if(!this._optionPropertyKeys){const t=new Set;for(const e of this._options)t.add(e.propertyKey);this._optionPropertyKeys=t}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(t,e,r,o){try{const{vertex:n,fragment:s,uniformBindings:i}=this._generateShaders(t,e,r,o);return new d(n,s,this.renamedLocationsMap,this.locationInfo,i,this.transformFeedbackBindings)}catch(n){return console.error("Failed to create program",{error:n}),new d("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(t){const e=this._options.find((e=>e.propertyKey===t));if(e)return{type:"option",className:e.typeCtor};const r=this._uniforms.find((e=>e.propertyKey===t));if(!r)throw new Error(`Unable to find uniform class type for property: ${t}`);return{type:"required",className:r.typeCtor}}getShaderKey(t,e,r,o){const n=Object.keys(r).map((t=>`${t}.${r[t]}`)).join("."),s=Object.keys(o).map((t=>`${t}.${o[t]}`)).join("."),i=Object.keys(e).filter((t=>this.optionPropertyKeys.has(t)&&e[t])).join(".");return`${this.constructor.name}.${t.hash}.${n}.${s}.${i}`}_generateShaders(t,e,r,o){const n=[];this._setDefines(r),this._setOptionalUniforms(n,e),this._setRequiredUniforms(n);const s=this._hydrateVertexInput(o),i=this._injectPackPrecisionFactor(s,t),p=this._hydrateComputeInput(),d=p&&this._injectPackPrecisionFactor(p,t),y=this.vertex(i,d),h=this._hydrateFragmentInput(y),f=this.fragment(h),l=new Set;for(const a in f){const t=f[a];u(l,t)}const m=this._getVertexInputBuiltins(),g=c.createVertex({...s,...p},y,m,n,this.transformFeedbackBindings,l);(new a).write(g);const _=this._getFragmentInputBuiltins(f);_.set("glPointCoord","gl_PointCoord");const K=c.createFragment(h,f,_,n,g,this.transformFeedbackBindings);(new a).write(K);const x=this._createShaderBuilder(g,K),C=x.generate("vertex",!1),I=x.generate("fragment",!1);return this.logShader&&(console.log(C),console.log(I)),{vertex:C,fragment:I,uniformBindings:n}}_setDefines(t){for(const e in t)this[e]=t[e]}_setOptionalUniforms(t,e){for(const r of this._options){e[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(t,r):this[r.propertyKey]=null}}_setRequiredUniforms(t){for(const e of this._uniforms)this[e.propertyKey]=this._hydrateUniformGroup(t,e)}_hydrateUniformGroup(t,e){const r=new(0,e.typeCtor);for(const o of r._uniforms??[]){const n=y(o.typeCtor),s=`u_${e.propertyKey}_${o.propertyKey}`,i=n.type,p=[e.propertyKey,o.propertyKey].join(".");if("type"in o.typeCtor&&"array"===o.typeCtor.type){const e=n;t.push({shaderModulePath:p,uniformName:s,uniformType:i,uniformArrayLength:e.size,uniformArrayElementType:e.elementType.type,uniformHydrated:n})}else t.push({shaderModulePath:p,uniformName:s,uniformType:i,uniformHydrated:n});r[o.propertyKey]=n}return r}_hydrateVertexInput(t){const e=this.vertexInput.inputCtor,r=e.locations.reduce(((e,r)=>!1===t[r.propertyKey]?e:{...e,[r.propertyKey]:y(r.typeCtor)}),{});for(const{propertyKey:o,typeCtor:n}of e.builtins){const t=y(n);r[o]=t}return r}_hydrateComputeInput(){if(null==this.computeInput)return null;return this.computeInput.inputCtor.locations.reduce(((t,e)=>({...t,[e.propertyKey]:y(e.typeCtor)})),{})}_injectPackPrecisionFactor(t,e){const r={};for(const o in t){const s=t[o],i=e.attributes.find((t=>t.name===o));if(i?.packPrecisionFactor){if("float"!==s.type&&"vec2"!==s.type&&"vec3"!==s.type&&"vec4"!==s.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);r[o]=s.divide(new n(i.packPrecisionFactor))}else r[o]=s}return r}_hydrateFragmentInput(t){const e={};for(const r in t)e[r]=t[r];for(const{propertyKey:r,typeCtor:o}of v.builtins){const t=y(o);e[r]=t}return e}_getVertexInputBuiltins(){const t=this.vertexInput.inputCtor,e=new Map;for(const{builtin:r,propertyKey:o}of t.builtins)e.set(o,r);return e}_getFragmentInputBuiltins(t){const e=t.constructor,r=new Map;for(const o of e.builtins??[])r.set(o.propertyKey,o.builtin);return r}_createShaderBuilder(t,e){const r=new o;return this._insertDebugInfo(r),t.insertVertexShader(r),e.insertFragmentShader(r),r}_insertDebugInfo(t){t.vertex.code.add("// DEFINES: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._defines)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`);t.vertex.code.add(""),t.vertex.code.add("// OPTIONS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._options)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`)}}export{b as ComputeVertexInput,v as FragmentInput,w as FragmentOutput,P as GraphShaderModule,F as UniformGroup,I as VertexInput,l as builtin,K as define,m as input,f as location,_ as option,x as transformFeedback,g as uniform};
