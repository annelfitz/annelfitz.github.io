/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../../core/pbf.js";import{isAborted as t}from"../../../../core/promiseUtils.js";import{loadLibtess as r}from"../../../../geometry/libtess.js";import{TileClipper as s,SimpleBuilder as i}from"../../../../geometry/support/TileClipper.js";import o from"./Feature.js";import{getTileMargins as c}from"./GeometryUtils.js";import{TriangleIndexBuffer as n}from"./IndexMemoryBuffer.js";import l from"./SourceLayerData.js";import{FillVertexBuffer as a,OutlineVertexBuffer as u,LineVertexBuffer as f,CircleVertexBuffer as p,SymbolVertexBuffer as h}from"./VertexMemoryBuffer.js";import m from"./buckets/CircleBucket.js";import _ from"./buckets/FillBucket.js";import y from"./buckets/LineBucket.js";import d from"./buckets/SymbolBucket.js";import{StyleLayerType as k}from"./style/StyleDefinition.js";import{TileStatus as T}from"../../tiling/enums.js";class g{constructor(t,r,o,n,l,a){if(this._pbfTiles={},this._tileClippers={},this._client=o,this._tile=r,this._sourceDataMaxLOD=n,a){this._styleLayerUIDs=new Set;for(const e of a)this._styleLayerUIDs.add(e)}this._styleRepository=l,this._layers=this._styleRepository?.layers??[];const[u,f,p]=r.tileKey.split("/").map(parseFloat);this._level=u;const h=c(this._level);for(const c of Object.keys(t)){const r=t[c];this._pbfTiles[c]=new e(new Uint8Array(r.protobuff),new DataView(r.protobuff));if(r.refKey){const[e]=r.refKey.split("/").map(parseFloat),t=u-e;if(t>0){const e=(1<<t)-1,r=f&e,i=p&e;this._tileClippers[c]=new s(t,r,i,8,h)}}this._tileClippers[c]||(this._tileClippers[c]=new i)}}_canParseStyleLayer(e){return!this._styleLayerUIDs||this._styleLayerUIDs.has(e)}async parse(e){const t=r(),s=this._initialize(e),{returnedBuckets:i}=s;this._processLayers(s),this._linkReferences(s),this._filterFeatures(s);const o=[],c=new Set,n=(e,t)=>{c.has(e)||(o.push({name:e,repeat:t}),c.add(e))},l={};for(const r of i)r.getResources(r.tileClipper,n,l);if(this._tile.status===T.INVALID)return[];const a=this._fetchResources(o,l,e);return Promise.all([...a,t]).then((()=>this._processFeatures(s.returnedBuckets)))}_initialize(e){const t=e?.signal;return{signal:t,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(e){const{sourceNameToTileData:t,zoom:r,layers:s,sourceNameToTileClipper:i,sourceNameToUniqueSourceLayerBuckets:o,sourceNameToUniqueSourceLayers:c,returnedBuckets:n,layerIdToBucket:l,referencerUIDToReferencedId:a}=e,u=this._sourceDataMaxLOD;for(let f=s.length-1;f>=0;f--){const e=s[f];if(r<u){if(e.minzoom&&r<Math.floor(e.minzoom)||e.maxzoom&&r>=e.maxzoom)continue}else if(e.maxzoom&&r>=e.maxzoom)continue;if(e.type===k.BACKGROUND||!this._canParseStyleLayer(e.uid)||!t[e.source]||!i[e.source])continue;const p=t[e.source],h=i[e.source],m=e.sourceLayer,_=p[m];if(_){let t=c[e.source];if(t||(t=c[e.source]=new Set),t.add(e.sourceLayer),e.refLayerId)a.set(e.uid,e.refLayerId);else{const t=this._createBucket(e);if(t){t.layerUIDs=[e.uid],t.layerExtent=_.extent,t.tileClipper=h;let r=o[e.source];r||(r=o[e.source]={});let s=r[m];s||(s=r[m]=[]),s.push(t),n.push(t),l[e.id]=t}}}}}_linkReferences(e){const{layerIdToBucket:t,referencerUIDToReferencedId:r}=e;r.forEach(((e,r)=>{t[e]&&t[e].layerUIDs.push(r)}))}_filterFeatures(e){const{signal:r,sourceNameToTileData:s,sourceNameToUniqueSourceLayerBuckets:i,sourceNameToUniqueSourceLayers:c}=e,n=10*this._level,l=10*(this._level+1),a=[],u=[];for(const t of Object.keys(c)){c[t].forEach((e=>{a.push(e),u.push(t)}))}for(let f=0;f<a.length;f++){const e=u[f],c=a[f];if(!s[e]||!i[e])continue;const p=s[e][c],h=i[e][c];if(!h||0===h.length)continue;if(t(r))return;let m=0;const _=p.getData();for(;_.nextTag(2);){const e=_.getMessage(),t=new o(e,p,m++);e.release();const r=t.values;if(r){const e=r._minzoom;if(e&&e>=l)continue;const t=r._maxzoom;if(t&&t<=n)continue}for(const s of h)s.pushFeature(t)}}}_fetchResources(e,t,r){const s=[],i=this._tile.getWorkerTileHandler();let o,c;e.length>0&&(o=i.fetchSprites(e,this._client,r),s.push(o));for(const n in t){const e=t[n];e.size>0&&(c=i.fetchGlyphs(this._tile.tileKey,n,e,this._client,r),s.push(c))}return s}_processFeatures(e){const t=e.filter((e=>e.hasFeatures()||this._canParseStyleLayer(e.layer.uid)));for(const r of t)r.processFeatures(r.tileClipper);return t}_parseTileData(e){const t={};for(const r of Object.keys(e)){const s=e[r],i={};for(;s.next();)switch(s.tag()){case 3:{const e=s.getMessage(),t=new l(e);e.release(),i[t.name]=t;break}default:s.skip()}t[r]=i}return t}_createBucket(e){switch(e.type){case k.BACKGROUND:return null;case k.FILL:return this._createFillBucket(e);case k.LINE:return this._createLineBucket(e);case k.CIRCLE:return this._createCircleBucket(e);case k.SYMBOL:return this._createSymbolBucket(e)}}_createFillBucket(e){return new _(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new a(e.fillMaterial.getStride()),new n,new u(e.outlineMaterial.getStride()),new n)}_createLineBucket(e){return new y(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new f(e.lineMaterial.getStride()),new n)}_createCircleBucket(e){return new m(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new p(e.circleMaterial.getStride()),new n)}_createSymbolBucket(e){const t=this._tile;return new d(t.tileKey,e,this._level,new h(e.iconMaterial.getStride()),new n,new h(e.textMaterial.getStride()),new n,t.placementEngine,t.getWorkerTileHandler())}}export{g as default};
