/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import a from"../../../renderers/support/AuthoringInfo.js";import i from"../../../renderers/support/AuthoringInfoVisualVariable.js";import{createFlowRenderer as r,estimateMagnitudeRange as n}from"../../../renderers/support/rasterRendererHelper.js";import t from"../../../renderers/visualVariables/ColorVariable.js";import l from"../../../renderers/visualVariables/OpacityVariable.js";import o from"../../../renderers/visualVariables/SizeVariable.js";import{processRasterRendererParameters as s}from"../support/utils.js";import{getDataRange as m,createDataValues as u,createColors as p,getBasemapInfo as c}from"../../renderers/support/utils.js";import{cloneScheme as f,getSchemes as d}from"../../symbology/flow.js";const h=5;async function w(e){const a={...e};return a.theme||(a.theme="flow-line"),s(a)}async function b(e){let a=e.flowScheme,i=null,r=null;const n=await c(null,e.view);if(i=null!=n.basemapId?n.basemapId:null,r=null!=n.basemapTheme?n.basemapTheme:null,a)return{scheme:f(a),basemapId:i,basemapTheme:r};const t=d({basemapTheme:r,theme:e.theme,hasSizeVariable:e.hasSizeVariable});return t&&(a=t.primaryScheme,i=t.basemapId,r=t.basemapTheme),{scheme:a,basemapId:i,basemapTheme:r}}async function y(r,s){s.flowRepresentation&&(r.flowRepresentation=s.flowRepresentation);const c=await b({theme:s.theme,flowScheme:s.flowScheme,view:s.view,hasSizeVariable:s.includeSizeVariable}),d=c.scheme;if(!d)throw new e("flow-renderer:insufficient-info","Unable to find flow scheme");r.flowSpeed=d.flowSpeed,r.density=d.density,r.trailLength=d.trailLength,r.trailWidth=d.trailWidth,r.trailCap=d.trailCap,r.color=d.color;const w=[],y=[],V="Magnitude",g=s.layer.rasterInfo,v=null==g.statistics||"vector-magdir"!==g.dataType&&"vector-uv"!==g.dataType?{minMagnitude:0,maxMagnitude:10}:n(g.dataType,g.statistics);if(null==v?.minMagnitude||null==v.maxMagnitude)throw new e("flow-renderer:insufficient-info","stats not available");const S={min:v.minMagnitude,max:v.maxMagnitude},x={min:S.min,max:null!=S.max?S.max/2:null},I=m(x,null,null,null),T=u(I,x,null);if(s.includeColorVariable){const a=p(d.colors,h);if(a.length<h)throw new e("flow-renderer:insufficient-info","Flow scheme does not have enough colors");const r=new t({field:V,stops:T.map(((e,i)=>({value:e,color:a[i]})))});w.push(r);const n=new i({type:"color",minSliderValue:S.min,maxSliderValue:S.max,theme:"high-to-low"});y.push(n)}if(s.includeOpacityVariable){const e=new l({field:V,stops:[{value:T[0],opacity:d.minOpacity},{value:T[4],opacity:d.maxOpacity}]});w.push(e);const a=new i({type:"opacity",minSliderValue:S.min,maxSliderValue:S.max});y.push(a)}if(s.includeSizeVariable){const e=new o({field:V,stops:[{value:S.min,size:d.minSize},{value:S.max,size:d.maxSize}]});w.push(e);const a=new i({type:"size",minSliderValue:S.min,maxSliderValue:S.max,theme:"high-to-low"});y.push(a)}const z=new a({type:"flow",visualVariables:y.length?y:void 0,flowTheme:d.theme});return r.visualVariables=w,r.authoringInfo=z,r.legendOptions=s.legendOptions,{renderer:r,visualVariables:w.map((e=>e.clone())),flowScheme:f(d),basemapId:c.basemapId,basemapTheme:c.basemapTheme,layerEffect:d.layerEffect,statistics:S}}async function V(a){a=await w(a);const i=r(a.layer.rasterInfo);if(null==i)throw new e("flow-renderer:not-supported","Only vector data is supported");return y(i,a)}export{V as createRenderer};
