/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import{getScaleForResolution as a}from"../../geometry/support/scaleUtils.js";import t from"../statistics/spatialStatistics.js";import{verifyBinningParams as n}from"../support/binningUtils.js";import{binningCapableLayerTypes as i,featureCapableLayerTypes as s,createLayerAdapter as r,getLayerTypeLabels as o}from"../support/adapters/support/layerUtils.js";const l=500,c=1e8,p=1280,f=12,m=30,u=15;async function g(a){const{view:t,sampleSize:c}=a;if(!(a&&t&&a.layer))throw new e("scale-range:missing-parameters","'view' and 'layer' parameters are required");a.forBinning&&n(a,"scale-range");const{layer:p,...f}=a,m=a.forBinning?i:s,u=r(p,m,a.forBinning);if(!u)throw new e("scale-range:invalid-parameters","'layer' must be one of these types: "+o(m).join(", "));const g={layerAdapter:u,...f};g.sampleSize=c||l,await t.when();const y=null!=g.signal?{signal:g.signal}:null;return await u.load(y),g}function y(e,a){const t=f,n=p/4,i=m,s=p/4,r=u,o=p/2;let l=0,c=0,g=0,y=0;switch(e){case"point":case"multipoint":{const e=a;l=e.avgMinDistance??0,c=t,g=e.minDistance??0,y=n;break}case"polyline":{const e=a;l=e.avgLength??0,c=i,g=e.minLength??0,y=s;break}case"polygon":{const e=a;l=e.avgSize??0,c=r,g=e.minSize??0,y=o;break}}return{resolutionForMinScale:l>0?l/c:null,resolutionForMaxScale:g>0?g/y:null}}function S(e,t,n){const i=y(e.geometryType,t);return{minScale:a(i.resolutionForMinScale??0,n.spatialReference),maxScale:a(i.resolutionForMaxScale??0,n.spatialReference)}}function w(e,a,t=!0){if(e.constraints&&"effectiveLODs"in e.constraints){const n=e.constraints.effectiveLODs,i=t?n:n.slice(0).reverse();let s=null;for(const e of i)if(!(t?e.scale>a:e.scale<a)){s=e;break}return s}}function h(a,t,n,i){const{view:s,snapToLOD:r,layerAdapter:o}=a;if(r){const e=w(s,t),a=w(s,n,!1);t=e?e.scale:t,n=a?a.scale:n}if(t<n)throw new e("scale-range:invalid","calculated minScale is less than maxScale.");return n>t/2&&(n=Math.floor(n/2)),t>c&&(t=0),"polygon"!==o.geometryType&&(n=0),{minScale:Math.ceil(t),maxScale:Math.floor(n),spatialStatistics:i}}async function v(a){const n=await g(a),{view:i,sampleSize:s,layerAdapter:r,signal:o}=n,l=await r.getSampleFeatures({view:i,sampleSize:s,returnGeometry:!0,signal:o},"json");if(!l?.length)throw new e("scale-range:insufficient-info","No features are available to calculate statistics");const c=await t({features:l,geometryType:r.geometryType}),{minScale:p,maxScale:f}=S(r,c,i);return h(n,p,f,c)}export{v as default};
