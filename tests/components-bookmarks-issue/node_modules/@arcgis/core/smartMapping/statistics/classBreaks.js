/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import a from"../../core/Error.js";import{verifyBasicFieldValidity as e,verifyNumericField as s,verifyFilterValidty as i}from"./support/utils.js";import{verifyBinningParams as r}from"../support/binningUtils.js";import{getNormalizationType as n,getFieldsList as l}from"../support/utils.js";import{binningCapableLayerTypes as t,featureCapableLayerTypes as o,createLayerAdapter as m,getLayerTypeLabels as p}from"../support/adapters/support/layerUtils.js";const u=5;async function f(f){if(!f?.layer||!f.field&&!f.valueExpression)throw new a("class-breaks:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(f.valueExpression&&!f.view)throw new a("class-breaks:missing-parameters","View is required when 'valueExpression' is specified");f.forBinning&&r(f,"class-breaks");const{layer:d,...c}=f,w=f.forBinning?t:o,h=m(d,w,f.forBinning);if(!h)throw new a("class-breaks:invalid-parameters","'layer' must be one of these types: "+p(w).join(", "));const y={layerAdapter:h,...c};y.normalizationType=n(y),y.numClasses=y.numClasses||u;const v=null!=y.signal?{signal:y.signal}:null;await h.load(v);const b=y.field,z=y.minValue,k=y.maxValue,g=null!=z||null!=k,x=y.classificationMethod,V="percent-of-total"===y.normalizationType,E=!1!==y.analyzeData,T=b?h.getField(b):null,q=await l({field:y.field,normalizationField:y.normalizationField,valueExpression:y.valueExpression}),j=e(h,q,"class-breaks:invalid-parameters");if(j)throw j;if(T){const a=s(h,T,"class-breaks:invalid-parameters");if(a)throw a}if(y.valueExpression&&y.normalizationType)throw new a("class-breaks:invalid-parameters","Normalization is not allowed when 'valueExpression' is specified");if(g)if(E){if(V&&null==y.normalizationTotal)throw new a("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'minValue', 'maxValue' are specified")}else{if(null==z||null==k)throw new a("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");if(z>=k)throw new a("class-breaks:invalid-parameters","'minValue' should be less than 'maxValue'");if(x&&"equal-interval"!==x)throw new a("class-breaks:invalid-parameters","'classificationMethod' other than 'equal-interval' is not allowed when 'analyzeData' is false");if(V&&null==y.normalizationTotal)throw new a("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'analyzeData' is false")}else if(!E)throw new a("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");const B=i(y.filter,"class-breaks:invalid-parameters");if(B)throw B;return y}async function d(a){const{layerAdapter:e,...s}=await f(a);return e.classBreaks(s)}export{d as default};
