/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import e from"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import r from"../../core/Error.js";import i from"../heuristics/outline.js";import o from"../heuristics/sizeRange.js";import{errorCallback as n,createSymbol as a,getSymbolSizeFromScheme as s,getSymbolOutlineFromScheme as l,getBasemapInfo as t}from"./support/utils.js";import{verifyBinningParams as m}from"../support/binningUtils.js";import{binningCapableLayerTypes as p,featureCapableLayerTypes as d,createLayerAdapter as c,getLayerTypeLabels as u}from"../support/adapters/support/layerUtils.js";import{cloneScheme as y,getSchemes as b}from"../symbology/location.js";async function f(e){if(!e?.layer)throw new r("location-renderer:missing-parameters","'layer' parameter is required");e.forBinning&&m(e,"location-renderer");const i={...e,layer:e.layer};i.symbolType=i.symbolType||"2d";const o=e.forBinning?p:d,n=c(i.layer,o,e.forBinning);if(!n)throw new r("location-renderer:invalid-parameters","'layer' must be one of these types: "+u(o).join(", "));i.layer=n;const a=null!=i.signal?{signal:i.signal}:null;await n.load(a);const s=n.geometryType;if(i.outlineOptimizationEnabled="polygon"===s&&i.outlineOptimizationEnabled,i.sizeOptimizationEnabled=("point"===s||"multipoint"===s||"polyline"===s)&&i.sizeOptimizationEnabled,"mesh"===s)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else{if("3d-volumetric-uniform"===i.symbolType&&"point"!==s)throw new r("location-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new r("location-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}return i}async function h(e,r){let i=e.locationScheme,o=null,n=null;const a=await t(e.basemap,e.view);if(o=null!=a.basemapId?a.basemapId:null,n=null!=a.basemapTheme?a.basemapTheme:null,i)return{scheme:y(i),basemapId:o,basemapTheme:n};const s=b({basemapTheme:n,geometryType:r,worldScale:!!e.symbolType?.includes("3d-volumetric"),view:e.view});return s&&(i=s.primaryScheme,o=s.basemapId,n=s.basemapTheme),{scheme:i,basemapId:o,basemapTheme:n}}async function w(t){const m=await f(t),p=m.layer.geometryType,d=await h(m,p),c=d.scheme;if(!c)throw new r("location-renderer:insufficient-info","Unable to find location scheme");const{view:u,layer:b,signal:w}=m,[v,g]=await Promise.all([m.outlineOptimizationEnabled?i({view:u,layer:b,signal:w}).catch(n):null,m.sizeOptimizationEnabled?o({view:u,layer:b,signal:w}).catch(n):null]),T=v&&v.opacity,j=new e({symbol:a(p,{type:m.symbolType,color:c.color,size:s(c,p),outline:l(c,p,T),meshInfo:{colorMixMode:m.colorMixMode,edgesType:m.edgesType}})});return v&&v.visualVariables&&v.visualVariables.length&&(j.visualVariables=v.visualVariables.map((e=>e.clone()))),g&&g.minSize&&(j.visualVariables?j.visualVariables.push(g.minSize):j.visualVariables=[g.minSize]),{renderer:j,locationScheme:y(c),basemapId:d.basemapId,basemapTheme:d.basemapTheme}}export{w as createRenderer};
