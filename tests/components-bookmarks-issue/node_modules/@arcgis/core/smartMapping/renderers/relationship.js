/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import{clone as n}from"../../core/lang.js";import{fetchMessageBundle as a}from"../../intl/messages.js";import i from"../../renderers/support/AuthoringInfo.js";import{AuthoringInfoClassBreakInfo as l}from"../../renderers/support/AuthoringInfoClassBreakInfo.js";import{AuthoringInfoFieldInfo as r}from"../../renderers/support/AuthoringInfoFieldInfo.js";import{createRenderer as s}from"./type.js";import{createColors as o,getClassBreaks as t,verifyBasicFieldValidity as m,getBasemapInfo as d}from"./support/utils.js";import{verifyBinningParams as u}from"../support/binningUtils.js";import{binningCapableLayerTypes as f,featureCapableLayerTypes as p,createLayerAdapter as c,getLayerTypeLabels as h}from"../support/adapters/support/layerUtils.js";import{getColors as y,cloneScheme as b,getSchemes as w,flatten2DArray as v}from"../symbology/relationship.js";import{applyColorToSymbol as g}from"../../symbols/support/utils.js";const I=new Set(["equal-interval","natural-breaks","quantile"]),M=new Set(["HH","HL","LH","LL"]),V={2:[["HL","HH"],["LL","LH"]],3:[["HL","HM","HH"],["ML","MM","MH"],["LL","LM","LH"]],4:[["HL","HM1","HM2","HH"],["M2L","M2M1","M2M2","M2H"],["M1L","M1M1","M1M2","M1H"],["LL","LM1","LM2","LH"]]},z={2:["L","H"],3:["L","M","H"],4:["L","M1","M2","H"]},F=e=>({minValue:e.minValue,maxValue:e.maxValue});async function T(n){if(!(n?.layer&&n.view&&n.field1&&n.field2))throw new e("relationship-renderer:missing-parameters","'layer', 'view', 'field1' and 'field2' parameters are required");n.forBinning&&u(n,"relationship-renderer");const a={...n,layer:n.layer,field1:n.field1,field2:n.field2};if(a.symbolType??="2d",a.defaultSymbolEnabled??=!0,a.classificationMethod??="quantile",a.numClasses??=3,a.focus??=null,!I.has(a.classificationMethod))throw new e("relationship-renderer:invalid-parameters",`classification method ${a.classificationMethod} is not supported`);if(a.numClasses<2||a.numClasses>4)throw new e("relationship-renderer:invalid-parameters","'numClasses' must be 2, 3 or 4");if(n.focus&&!M.has(n.focus))throw new e("relationship-renderer:invalid-parameters","'focus' must be 'HH', 'HL', 'LH', 'LL' or null");const i=n.forBinning?f:p,l=c(a.layer,i,n.forBinning);if(!l)throw new e("relationship-renderer:invalid-parameters","'layer' must be one of these types: "+h(i).join(", "));a.layer=l;const r=null!=a.signal?{signal:a.signal}:null;await l.load(r);const s=l.geometryType,o=a.symbolType.includes("3d");if(a.outlineOptimizationEnabled="polygon"===s&&a.outlineOptimizationEnabled,a.sizeOptimizationEnabled=("point"===s||"multipoint"===s||"polyline"===s)&&a.sizeOptimizationEnabled,"mesh"===s)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else{if("3d-volumetric-uniform"===a.symbolType&&"point"!==s)throw new e("relationship-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o&&"polygon"===s)throw new e("relationship-renderer:not-supported","3d symbols are not supported for polygon layers");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new e("relationship-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const{field1:t,field2:d}=a,y=[t.field,d.field];t.normalizationField&&y.push(t.normalizationField),d.normalizationField&&y.push(d.normalizationField);const b=m(l,y,"relationship-renderer:invalid-parameters");if(b)throw b;return a}async function H(n){if(!n?.renderer||!n.numClasses)throw new e("update-relationship-renderer:missing-parameters","'renderer' and 'numClasses' parameters are required");const{field1:a,field2:i,renderer:l,numClasses:r,colors:s}=n,o=r**2;if((a||i)&&!(a&&i&&a.field&&i.field))throw new e("update-relationship-renderer:missing-parameters","'field1' and 'field2' parameters are required");if(a&&!a.classBreakInfos||i&&!i.classBreakInfos)throw new e("update-relationship-renderer:missing-parameters","'field1.classBreakInfos' and 'field2.classBreakInfos' are required");if(!l.authoringInfo)throw new e("update-relationship-renderer:missing-parameters","'renderer.authoringInfo' is required");if(l.uniqueValueInfos?.length!==o)throw new e("update-relationship-renderer:invalid-parameters",`Renderer must have ${o} unique value infos to support ${r} classes`);if(s&&s.length!==o)throw new e("update-relationship-renderer:invalid-parameters",`The scheme must have ${o} colors`);return n}async function L(e){let n=e.relationshipScheme,a=null,i=null;const l=await d(e.basemap,e.view);if(a=null!=l.basemapId?l.basemapId:null,i=null!=l.basemapTheme?l.basemapTheme:null,n)return{scheme:b(n),basemapId:a,basemapTheme:i};const r=w({basemapTheme:i,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return r&&(n=r.primaryScheme,a=r.basemapId,i=r.basemapTheme),{scheme:n,basemapId:a,basemapTheme:i}}function k(e,a){const i=n(V[e]);return v(i,a)}function x(e,n){return k(e,n).map((e=>({value:e,count:0})))}function C(e,n,a,i){const{field:l,normalizationField:r}=e,{field:s,normalizationField:o}=n,t=a.map((e=>[e.minValue,e.maxValue])),m=i.map((e=>[e.minValue,e.maxValue])),d=t.length,u=z[d];return`\n  var field1 = $feature['${l}'];\n  var field2 = $feature['${s}'];\n  var hasNormField1 = ${r?"true":"false"};\n  var hasNormField2 = ${o?"true":"false"};\n  var normField1 = ${r?`$feature['${r}']`:"null"};\n  var normField2 = ${o?`$feature['${o}']`:"null"};\n\n  if (\n    IsEmpty(field1) ||\n    IsEmpty(field2) ||\n    (hasNormField1 && (IsEmpty(normField1) || normField1 == 0)) ||\n    (hasNormField2 && (IsEmpty(normField2) || normField2 == 0))\n  ) {\n    return null;\n  }\n\n  var value1 = IIf(hasNormField1, (field1 / normField1), field1);\n  var value2 = IIf(hasNormField2, (field2 / normField2), field2);\n\n  var breaks1 = ${JSON.stringify(t)};\n  var breaks2 = ${JSON.stringify(m)};\n  var classCodes = ${JSON.stringify(u)};\n\n  function getClassCode(value, breaks) {\n    var code = null;\n\n    for (var i in breaks) {\n      var info = breaks[i];\n      if (value >= info[0] && value <= info[1]) {\n        code = classCodes[i];\n        break;\n      }\n    }\n\n    return code;\n  }\n\n  var code1 = getClassCode(value1, breaks1);\n  var code2 = getClassCode(value2, breaks2);\n\n  var classValue = IIf(IsEmpty(code1) || IsEmpty(code2), null, code1 + code2);\n  return classValue;\n  `}async function E(n,o,t){const m=await a("esri/smartMapping/t9n/smartMapping"),{basemap:d,classificationMethod:u,field1:f,field2:p,focus:c,numClasses:h,signal:b}=n,w=n.layer,v=o.classBreakInfos,g=t.classBreakInfos;if(h!==v.length||v.length!==g.length)throw new e("relationship-renderer:error","incompatible class breaks");const I=x(h,c),M=C(n.field1,n.field2,v,g),V=(await L({basemap:d,geometryType:w.geometryType,theme:"default",relationshipScheme:n.relationshipScheme,worldScale:!!n.symbolType?.includes("3d-volumetric"),view:n.view})).scheme,z=await s({layer:w,basemap:d,valueExpression:M,valueExpressionTitle:m.relationship.legendTitle,numTypes:-1,sortEnabled:!1,defaultSymbolEnabled:n.defaultSymbolEnabled,typeScheme:{colors:y(V,h,c),...V},statistics:{uniqueValueInfos:I},legendOptions:n.legendOptions,outlineOptimizationEnabled:n.outlineOptimizationEnabled,sizeOptimizationEnabled:n.sizeOptimizationEnabled,symbolType:n.symbolType,colorMixMode:n.colorMixMode,edgesType:n.edgesType,view:n.view,signal:b}),F=z.renderer,T=F.uniqueValueInfos,H=m.relationship;for(const e of T??[])e.label=H[e.value];const k=new i({type:"relationship",classificationMethod:u,numClasses:h,focus:c,field1:new r({field:f.field,normalizationField:f.normalizationField,label:f.label,classBreakInfos:v.map((({minValue:e,maxValue:n})=>new l({minValue:e,maxValue:n})))}),field2:new r({field:p.field,normalizationField:p.normalizationField,label:p.label,classBreakInfos:g.map((({minValue:e,maxValue:n})=>new l({minValue:e,maxValue:n})))})});return F.authoringInfo=k,{renderer:F,classBreaks:{field1:o,field2:t},uniqueValueInfos:z.uniqueValueInfos,relationshipScheme:V,basemapId:z.basemapId,basemapTheme:z.basemapTheme}}function B(e,n,a){const i=k(n,a);e.sort(((e,n)=>{const a=i.indexOf(e.value),l=i.indexOf(n.value);let r=0;return a<l?r=-1:a>l&&(r=1),r}))}function $(e,n){const a=e.authoringInfo;a.numClasses=n.numClasses,a.focus=n.focus||null,a.focus||delete a.focus;const{field1:i,field2:s}=n;a.field1=new r({field:i.field,normalizationField:i.normalizationField,label:i.label,classBreakInfos:i.classBreakInfos.map((e=>new l(F(e))))}),a.field2=new r({field:s.field,normalizationField:s.normalizationField,label:s.label,classBreakInfos:s.classBreakInfos.map((e=>new l(F(e))))}),e.authoringInfo=a}async function S(e){const n=await H(e),{field1:a,field2:i,renderer:l,numClasses:r,focus:s,colors:t}=n,m=l.clone();m.valueExpression=C(a,i,a.classBreakInfos,i.classBreakInfos);const d=m.uniqueValueInfos??[];if(B(d,r,s),t){const e=o(t,t.length);d.forEach(((n,a)=>g(n.symbol,e[a])))}return $(m,n),m}async function q(n){const a=await T(n),{layer:i,classificationMethod:l,field1:r,field2:s,numClasses:o,view:m,signal:d}=a,u={layer:i,classificationMethod:l,field:r.field,normalizationField:r.normalizationField,normalizationType:r.normalizationField?"field":null,minValue:r.minValue,maxValue:r.maxValue,analyzeData:!(null!=r.minValue&&null!=r.maxValue),numClasses:o,view:m,signal:d},f={layer:i,classificationMethod:l,field:s.field,normalizationField:s.normalizationField,normalizationType:s.normalizationField?"field":null,minValue:s.minValue,maxValue:s.maxValue,analyzeData:!(null!=s.minValue&&null!=s.maxValue),numClasses:o,view:m,signal:d},[p,c]=await Promise.all([t(u),t(f)]);if(!p||!c)throw new e("relationship-renderer:error","error when calculating class breaks");return E(a,p.result,c.result)}export{q as createRenderer,S as updateRenderer};
