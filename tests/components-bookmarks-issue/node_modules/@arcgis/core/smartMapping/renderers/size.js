/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import e from"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import i from"../../core/Error.js";import{toPt as r}from"../../core/screenUtils.js";import{fetchMessageBundle as a}from"../../intl/messages.js";import{substitute as n}from"../../intl/substitute.js";import s from"../../renderers/support/AuthoringInfo.js";import l from"../../renderers/support/AuthoringInfoSizeStop.js";import o from"../../renderers/support/AuthoringInfoVisualVariable.js";import{setLabelsForClassBreaks as t}from"../../renderers/support/utils.js";import m from"../../renderers/visualVariables/SizeVariable.js";import{TransformationType as p}from"../../renderers/visualVariables/support/sizeVariableUtils.js";import u from"../heuristics/ageUnit.js";import d from"../heuristics/outline.js";import c from"../heuristics/referenceSize.js";import y from"../heuristics/sizeRange.js";import{createPrimitiveOverrides as f,updateReferenceSizeSymbol as w,createReferenceSizeSymbol as v,getReferenceSizeStops as b}from"./support/referenceSizeUtils.js";import{getSummaryStatistics as z,getClassBreaks as h,errorCallback as g,createColors as S,formatDate as T,updateAgeRendererAuthoringInfoVV as x,verifyBasicFieldValidity as V,getSizeRangeForAxis as E,createSymbol as O,getSymbolOutlineFromScheme as j,getSymbolSizeFromScheme as I,getBasemapInfo as k,getDataRange as q}from"./support/utils.js";import{getAgeExpressions as B,verifyDates as F,supportedAgeUnits as R}from"../statistics/support/ageUtils.js";import{verifyBinningParams as U}from"../support/binningUtils.js";import{getFieldsList as D,getNormalizationType as M,isAnyDateField as C}from"../support/utils.js";import{binningCapableLayerTypes as A,featureCapableLayerTypes as G,createLayerAdapter as L,getLayerTypeLabels as P}from"../support/adapters/support/layerUtils.js";import{cloneScheme as W,getSchemes as $}from"../symbology/size.js";const H=2**53-1;async function _(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("size-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("size-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");if(e.referenceSizeOptions&&!e.view&&!e.field)throw new i("size-visual-variable:missing-parameters","'view' and 'field' are required when 'referenceSizeOptions' is specified");if(e.referenceSizeOptions&&e.valueExpression)throw new i("size-visual-variable:missing-parameters","'valueExpression' is not supported when 'referenceSizeOptions' is specified");e.forBinning&&U(e,"size-visual-variable");const r={...e};if(r.theme&&"high-to-low"!==r.theme&&r.referenceSizeOptions)throw new i("size-visual-variable:not-supported","Only 'high-to-low' theme is supported when 'referenceSizeOptions' is specified");if("90-10"===r.theme)throw new i("size-visual-variable:not-supported","Only 'high-to-low', 'above', 'below' themes are supported.");const a=e.forBinning?A:G,n=L(r.layer,a,e.forBinning);if(!n)throw new i("size-visual-variable:invalid-parameters","'layer' must be one of these types: "+P(a).join(", "));r.layer=n,"height"===r.axis&&(r.sizeOptimizationEnabled=!1);const s=null!=r.signal?{signal:r.signal}:null;await n.load(s);const l=n.geometryType;if("mesh"===l)throw new i("size-visual-variable:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(r.worldScale){if("polyline"===l||"polygon"===l)throw new i("size-visual-variable:not-supported","'worldScale' sizing is not supported for polyline and polygon layers");if(!r.view||"3d"!==r.view.type)throw new i("size-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true")}if(r.referenceSizeOptions&&!e.forBinning&&"polygon"!==l)throw new i("size-visual-variable:invalid-parameters","Reference size is only supported for polygon layers");const o=await D({field:r.field,normalizationField:r.normalizationField,valueExpression:r.valueExpression}),t=V(n,o,"size-visual-variable:invalid-parameters");if(t)throw t;return r}async function J(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("size-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("size-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&U(e,"size-continuous-renderer");const r={...e};r.symbolType=r.symbolType||"2d",r.defaultSymbolEnabled??=!0;const a=e.forBinning?A:G,n=L(r.layer,a,e.forBinning);if(!n)throw new i("size-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+P(a).join(", "));r.layer=n;const s=null!=r.signal?{signal:r.signal}:null;await n.load(s);const l=n.geometryType,o=r.symbolType.includes("3d");if(r.outlineOptimizationEnabled=!r.referenceSizeOptions&&"polygon"===l&&r.outlineOptimizationEnabled,"mesh"===l)throw new i("size-continuous-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(o&&("polyline"===l||"polygon"===l))throw new i("size-continuous-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new i("size-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");if(r.referenceSizeOptions&&!e.forBinning&&"polygon"!==l)throw new i("size-continuous-renderer:invalid-parameters","Reference size is only supported for polygon layers");const t=await D({field:r.field,normalizationField:r.normalizationField,valueExpression:r.valueExpression}),m=V(n,t,"size-continuous-renderer:invalid-parameters");if(m)throw m;return r}function K(e){if(!e||!(e.layer&&e.view&&e.sizeStops&&e.field))throw new i("update-renderer-with-reference-size:missing-parameters","'field', 'layer', 'view and 'sizeStops' parameters are required");if(e.referenceSizeOptions&&!e.sizeScheme&&!e.typeScheme)throw new i("update-renderer-with-reference-size:missing-parameters","'sizeScheme' or 'typeScheme' is required when 'referenceSizeOptions' is specified");const r=e.layer;let a=e.renderer;if(!a)if(e.forBinning){if(!("featureReduction"in r&&r.featureReduction&&"renderer"in r.featureReduction&&r.featureReduction.renderer)||"class-breaks"!==r.featureReduction.renderer.type&&"unique-value"!==r.featureReduction.renderer.type)throw new i("update-renderer-with-reference-size:invalid-parameters","Feature reduction renderer is not supported");a=r.featureReduction.renderer}else{if(!("renderer"in r)||!r.renderer||"class-breaks"!==r.renderer.type&&"unique-value"!==r.renderer.type)throw new i("update-renderer-with-reference-size:invalid-parameters","Renderer is not supported");a=r.renderer}const n=a.authoringInfo;if(!n||!n?.visualVariables?.some((e=>"reference-size"===e.sizeInfoType)))throw new i("update-renderer-with-reference-size:invalid-parameters","'renderer.authoringInfo.visualVariables' should have an authoringInfoVisualVariable with 'sizeInfoType' set to 'reference-size'");return{...e,renderer:a}}async function N(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new i("size-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("size-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&U(e,"size-class-breaks-renderer");const r={...e};r.symbolType=r.symbolType||"2d",r.defaultSymbolEnabled??=!0,r.classificationMethod??="equal-interval",r.normalizationType=M(r);const a=e.forBinning?A:G,n=L(r.layer,a,e.forBinning);if(!n)throw new i("size-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+P(a).join(", "));r.layer=n;if(!(null!=r.minValue&&null!=r.maxValue)&&(null!=r.minValue||null!=r.maxValue))throw new i("size-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const s=null!=r.signal?{signal:r.signal}:null;await n.load(s);const l=n.geometryType,o=r.symbolType.includes("3d");if(r.outlineOptimizationEnabled="polygon"===l&&r.outlineOptimizationEnabled,"mesh"===l)throw new i("size-class-breaks-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(o&&("polyline"===l||"polygon"===l))throw new i("size-class-breaks-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new i("size-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const t=await D({field:r.field,normalizationField:r.normalizationField}),m=V(n,t,"size-class-breaks-renderer:invalid-parameters");if(m)throw m;return r}function Q(e){const i={...e};delete i.basemap,delete i.sizeScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled;const r=i;return r.analyzeData=!(null!=i.minValue&&null!=i.maxValue),r}function X(e){const i={...e},r=!!i.symbolType?.includes("3d-volumetric"),a=i;return a.worldScale=r,r&&(a.axis="3d-volumetric-uniform"===i.symbolType?"all":"height"),delete i.symbolType,delete i.defaultSymbolEnabled,a}async function Y(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new i("size-age-renderer:missing-parameters","'layer', 'view', 'startTime', 'endTime' parameters are required");const r={...e};r.symbolType??="2d",r.defaultSymbolEnabled??=!0;const a=L(r.layer,G);if(!a)throw new i("size-age-renderer:invalid-parameters","'layer' must be one of these types: "+P(G).join(", "));r.layer=a;const n=null!=r.signal?{signal:r.signal}:null;await a.load(n);const s=a.geometryType,l=r.symbolType.includes("3d");if(r.outlineOptimizationEnabled="polygon"===s&&r.outlineOptimizationEnabled,"mesh"===s)throw new i("size-age-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(l&&("polyline"===s||"polygon"===s))throw new i("size-age-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new i("size-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const o=F(a,r.startTime,r.endTime,"size-age-renderer:invalid-parameters");if(o)throw o;if(r.unit&&!R.includes(r.unit))throw new i("size-age-renderer:invalid-unit",`Supported units are: ${R.join(", ")}`);return r}async function Z(e){let i=e.sizeScheme,r=null,a=null;const n=await k(e.basemap,e.view);if(r=null!=n.basemapId?n.basemapId:null,a=null!=n.basemapTheme?n.basemapTheme:null,i)return{scheme:W(i),basemapId:r,basemapTheme:a};const s=$({basemapTheme:a,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});return s&&(i=s.primaryScheme,r=s.basemapId,a=s.basemapTheme),{scheme:i,basemapId:r,basemapTheme:a}}function ee(e,i){let r;switch(i){case"point":case"multipoint":{const i=e;r=[i.minSize,i.maxSize];break}case"polyline":{const i=e;r=[i.minWidth,i.maxWidth];break}case"polygon":{const i=e;r=[i.marker.minSize,i.marker.maxSize];break}}return r}function ie(e,i){e.transformationType===p.ClampedLinear&&"below"===i&&e.flipSizes()}async function re(e,i,r,a){return i?[0,i.size]:e?[e.minSize,e.maxSize]:ee(r.scheme,a)}function ae(e,i,r){if(r.referenceSizeOptions&&null!=e.min&&null!=e.max&&null!=e.avg&&null!=e.stddev){const i=100,r=0,a=0,n=1,s=e.avg,l=e.min,o=e.max,t=e.stddev,m=0!==s?t/s:0,p=l>a&&l<n&&o<2*n&&m<.5,u=l>r&&l<i&&o<2*i&&m<.5;return{minDataValue:p?a:u?r:l,maxDataValue:p?n:u?i:s+2*t,defaultValuesUsed:!1}}const{theme:a,field:n}=r,s=r.layer,l=n&&!("function"==typeof n)?s.getField(n):null,o=C(l);return q(e,i,a,o,"above"===a||"below"===a)}async function ne(e,r,a,n,t){const{theme:p,field:u,normalizationField:d,minValue:c,maxValue:y,axis:f}=e,w=e.layer.geometryType,v=await Z({basemap:e.basemap,geometryType:w,sizeScheme:e.sizeScheme,worldScale:e.worldScale,view:e.view}),z=v.scheme;if(!z)throw new i("size-visual-variable:insufficient-info","Unable to find size scheme");const h=await re(n,t,v,w),{minDataValue:g,maxDataValue:S,defaultValuesUsed:T}=ae(r,a,e),x=[],V="height"===f,O=V?f:void 0,j=h[0];let I=h[1];if(V&&"number"==typeof j&&"number"==typeof I){const e=E({minSize:j,maxSize:I},O);x.push(new m({axis:"width-and-depth",minSize:e.minSize})),I=e.maxSize}const k=new m({field:u,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,valueUnit:"unknown",normalizationField:d,axis:O,minSize:j,maxSize:I,minDataValue:g,maxDataValue:S,legendOptions:e.legendOptions});ie(k,p),x.unshift(k);const q=e.referenceSizeOptions?new o({type:"size",field:e.field,normalizationField:e.normalizationField,sizeStops:b(k).map((({label:e,size:i,value:r})=>new l({label:e,size:i,value:r}))),sizeInfoType:e.referenceSizeOptions?"reference-size":void 0,referenceSizeSymbolStyle:e.referenceSizeOptions?.symbolStyle,minSliderValue:null!=c?c:r.min,maxSliderValue:null!=y?y:r.max}):new o({type:"size",theme:p,minSliderValue:null!=c?c:r.min,maxSliderValue:null!=y?y:r.max}),B=new s({visualVariables:[q]});return{basemapId:v.basemapId,basemapTheme:v.basemapTheme,visualVariables:x,statistics:r,isGrid:t?.isGrid,defaultValuesUsed:T,sizeScheme:W(z),authoringInfo:B}}async function se(i,r,n,s,l){const o=await a("esri/smartMapping/t9n/smartMapping"),t=l.layer,m=l.field,p=t.geometryType,u=l.defaultSymbolEnabled,d=W(i.sizeScheme),c="polygon"===p,y=c?d.marker:d,w=c?d.background:null,z=c?"point":p,h=r?.opacity,g=!!l.referenceSizeOptions,S=i.isGrid,T=g?[]:i.visualVariables.map((e=>e.clone()));r?.visualVariables?.length&&T.push(...r.visualVariables.map((e=>e.clone())));const x=g?f({view:l.view,field:m,normalizationField:s,sizeStops:b(i.visualVariables[0]),sizeByScaleEnabled:S}):null;return{renderer:new e({backgroundFillSymbol:!S&&w&&O(p,{type:l.symbolType,color:w.color,outline:j(w,p,h)}),classBreakInfos:[{minValue:-H,maxValue:H,symbol:x?v({type:l.referenceSizeOptions.symbolStyle,color:y.color,primitiveOverrides:x}):O(z,{type:l.symbolType,color:y.color,size:I(y,z),outline:j(y,z,h)})}],defaultLabel:u?o.other:null,defaultSymbol:u&&!g?O(z,{type:l.symbolType,color:y.noDataColor,size:I(y,z,!0),outline:j(y,z,h)}):null,field:m,normalizationField:s,normalizationType:n,valueExpression:l.valueExpression,valueExpressionTitle:l.valueExpressionTitle,visualVariables:T,authoringInfo:i.authoringInfo?.clone()}),visualVariables:i.visualVariables.map((e=>e.clone())),statistics:i.statistics,defaultValuesUsed:i.defaultValuesUsed,isGrid:S,sizeScheme:W(i.sizeScheme),basemapId:i.basemapId,basemapTheme:i.basemapTheme}}function le(e,i){const a=r(e.minSize),n=(r(e.maxSize)-a)/(i>=4?i-1:i),s=[];for(let r=0;r<i;r++)s.push(a+n*r);return s}async function oe(i,r){const n=await a("esri/smartMapping/t9n/smartMapping"),l=i.layer,o=i.defaultSymbolEnabled,m=l.geometryType,p="polygon"===m,u=i.symbolType?.includes("3d-volumetric"),d=await Z({basemap:i.basemap,geometryType:m,sizeScheme:i.sizeScheme,worldScale:u,view:i.view}),c=d.scheme,{result:y,outlineResult:f}=r,w=y?.classBreakInfos??[],v=i.classificationMethod,b=i.normalizationType,z=p?c.marker:c,h=p?c.background:null,g=p?"point":m,S=ee(z,g),T=u?E({minSize:S[0],maxSize:S[1]},"height"):null,x=le({minSize:S[0],maxSize:T?T.maxSize:S[1]},w.length),V=f?.opacity,k=new e({backgroundFillSymbol:h&&O(m,{type:i.symbolType,color:h.color,outline:j(h,m,V)}),classBreakInfos:w.map(((e,r)=>({minValue:e.minValue,maxValue:e.maxValue,symbol:O(g,{type:i.symbolType,color:z.color,size:x[r],widthAndDepth:T&&T.minSize,outline:j(z,g,V)}),label:e.label}))),defaultLabel:o?n.other:null,defaultSymbol:o?O(g,{type:i.symbolType,color:z.noDataColor,size:I(z,g,!0),widthAndDepth:T&&T.minSize,outline:j(z,g,V)}):null,field:i.field,valueExpression:i.valueExpression,valueExpressionTitle:i.valueExpressionTitle,normalizationType:b,normalizationField:i.normalizationField,normalizationTotal:"percent-of-total"===b?y?.normalizationTotal:void 0,legendOptions:i.legendOptions,authoringInfo:new s({type:"class-breaks-size",classificationMethod:v,standardDeviationInterval:i.standardDeviationInterval})});return"standard-deviation"!==v&&t({classBreakInfos:k.classBreakInfos,classificationMethod:v,normalizationType:b,round:!0}),f?.visualVariables?.length&&(k.visualVariables=f.visualVariables.map((e=>e.clone()))),{renderer:k,sizeScheme:W(c),classBreaksResult:y,defaultValuesUsed:!!r.defaultValuesUsed,basemapId:d.basemapId,basemapTheme:d.basemapTheme}}async function te(e){const i=await _(e),{view:r,field:a,valueExpression:n,minValue:s,maxValue:l,layer:o,normalizationField:t,signal:m,statistics:p,forBinning:u}=i,d=t?"field":void 0,[f,w,v,b]=await Promise.all([p??z({layer:o,field:a,valueExpression:n,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:d,normalizationField:t,minValue:s,maxValue:l,view:r,signal:m}),"90-10"===i.theme?h({layer:o,field:a,normalizationField:t,valueExpression:n,classificationMethod:"quantile",minValue:s,maxValue:l,view:r,numClasses:10,signal:m}):null,i.sizeOptimizationEnabled?y({view:r,layer:o,signal:m}).catch(g):null,i.referenceSizeOptions?c({layer:o,view:r,forBinning:u,signal:m}).catch(g):null]);return ne(i,f,w?.result,v,b)}async function me(e){const i=await J(e),r={layer:i.layer,view:i.view,signal:i.signal},[a,n]=await Promise.all([te(X(i)),i.outlineOptimizationEnabled?d(r).catch(g):null]),s=i.normalizationField;return se(a,n,s?"field":void 0,s,i)}async function pe(e){const{field:i,forBinning:r,layer:a,normalizationField:n,referenceSizeOptions:s,renderer:o,sizeScheme:t,sizeStops:m,typeScheme:p,view:u}=K(e),{isGrid:d}=await c({view:u,layer:a,forBinning:r}),y=f({view:u,field:i,normalizationField:n,sizeStops:m,sizeByScaleEnabled:d}),b=o.clone();if("class-breaks"===b.type){const e="polygon"===("geometryType"in a?a.geometryType:null)&&t&&"marker"in t?t.marker:null;b.classBreakInfos.forEach((i=>{"cim"===i.symbol.type?w(i.symbol,{type:s?.symbolStyle,color:e?.color,primitiveOverrides:y}):s&&e&&(i.symbol=v({type:s.symbolStyle,color:e.color,primitiveOverrides:y}))}))}else if("unique-value"===b.type){const e=b.uniqueValueInfos??[],i="polygon"===("geometryType"in a?a.geometryType:null)&&p&&"colors"in p?p.colors:null,r=i?S(i,e.length):null;e.forEach(((e,i)=>{"cim"===e.symbol?.type?w(e.symbol,{type:s?.symbolStyle,color:r?r[i]:void 0,primitiveOverrides:y}):s&&r&&(e.symbol=v({type:s.symbolStyle,color:r[i],primitiveOverrides:y}))}))}const z=b.authoringInfo.visualVariables.find((e=>"reference-size"===e.sizeInfoType));return z&&(z.field=i,z.normalizationField=n,z.sizeStops=m.map((({label:e,size:i,value:r})=>new l({label:e,size:i,value:r})))),b}async function ue(e){const i=await N(e);return oe(i,await h(Q(i),i.outlineOptimizationEnabled))}async function de(e){const i=await Y(e),{defaultSymbolEnabled:r,view:s,startTime:l,endTime:o,symbolType:t,minValue:m,maxValue:p,signal:c}=i,y=i.layer,f={layer:i.layer,view:i.view,signal:c},[w,v]=await Promise.all([i.unit?{unit:i.unit,statistics:null,valueExpression:null}:await u({view:s,layer:y,startTime:l,endTime:o,minValue:m,maxValue:p,signal:c}),i.outlineOptimizationEnabled?d(f).catch(g):null]),{unit:b,statistics:z}=w,h=B({layer:y,startTime:l,endTime:o,unit:b}).valueExpression,S=await a("esri/smartMapping/t9n/smartMapping"),V=n(S[`ageInfo_${b}`],{unit:b,startTime:T(l,b,y,s),endTime:T(o,b,y,s)}),E=await te(X({layer:y,basemap:i.basemap,valueExpression:h,symbolType:t,statistics:z,legendOptions:{title:V},theme:i.theme,sizeScheme:i.sizeScheme,sizeOptimizationEnabled:i.sizeOptimizationEnabled,view:i.view,minValue:m,maxValue:p,signal:c})),O={layer:y,valueExpression:h,defaultSymbolEnabled:r,symbolType:t},j=await se(E,v,null,null,O),I=j.renderer.authoringInfo?.visualVariables;return I?.forEach((e=>x(e,l,o,b))),{...j,unit:b}}export{de as createAgeRenderer,ue as createClassBreaksRenderer,me as createContinuousRenderer,te as createVisualVariables,pe as updateRendererWithReferenceSize};
