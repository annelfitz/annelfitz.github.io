/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import{pickRandom as t}from"../../../core/arrayUtils.js";import r from"../../../core/Error.js";import a from"../../../core/Logger.js";import{assertIsSome as i}from"../../../core/maybe.js";import{timeout as s}from"../../../core/promiseUtils.js";import{whenOnce as o}from"../../../core/reactiveUtils.js";import{property as n}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import{subclass as l}from"../../../core/accessorSupport/decorators/subclass.js";import{toQuantizationTransform as u}from"../../../geometry/support/quantizationUtils.js";import{kebabDict as m}from"../../../layers/support/fieldType.js";import{isTimeOnlyField as p}from"../../../layers/support/fieldUtils.js";import y from"../../../rest/support/QuantizationParameters.js";import{getArcadeForPredominantCategory as f}from"../../statistics/support/predominanceUtils.js";import{summaryStatistics as d,uniqueValues as c,histogram as h,classBreaks as w,heatmapStatistics as g}from"../../statistics/support/statsWorker.js";import{mergeWhereClauses as F}from"../../statistics/support/utils.js";import{WorkerClient as S}from"../../statistics/support/WorkerClient.js";import{getFieldsList as v,isAnyDateField as q,fieldDelimiter as V}from"../utils.js";import x from"./LayerAdapter.js";import{ensureFeaturesJSON as z,getSummaryStatsQuery as _,getSummaryStatisticsFromFeatureSet as L,getViewInfoParams as M,getMissingFields as N,updateQueryWithFeatureFilter as T,getUVQuery as E,getUniqueValuesFromFeatureSet as C,getBins as j,getDomainsForFields as I,getPredominantCategoriesFromUVInfos as k}from"./support/utils.js";import{processSummaryStatisticsResult as O,createUVResult as Q,resolveCBResult as b}from"../../../statistics/utils.js";import{loadArcade as J}from"../../../support/arcadeOnDemand.js";const P=5;let U=null,B=class extends x{constructor(){super(...arguments),this._hasLocalSource=!1,this.adapterName="in-memory-layer-adapter"}destroy(){this.workerClient?.destroy()}async _waitForLayerViewUpdate(e){if(!e)throw new r(`${this.adapterName}:insufficient-data", "layerView is required to fetch the features`);const t=new AbortController,i=o((()=>!e.updating),t.signal);await s(i,5e3,t).catch((e=>{throw a.getLogger(this).warn("LayerView is taking too long to update. Aborting fetch from layerView."),e}))}async _fetchFeatureSetFromMemory(e,t,a){const i=this.layer;if(this._hasLocalSource&&"queryFeatures"in i)return i.queryFeatures(e);if(!t)throw new r(`${this.adapterName}:insufficient-data`,"view is required to fetch the features from layerView");const s=await t.whenLayerView(this.layer);return await this._waitForLayerViewUpdate(s),s.queryFeatures(e,{signal:a})}async _fetchFeaturesFromMemory(e,t,a,i){const s=this.layer,o="json"===i;if(this._hasLocalSource&&"queryFeatures"in s){const e=await s.queryFeatures(t);return o?z(e.features):e.features}if(await this._waitForLayerViewUpdate(e),o&&"queryFeaturesJSON"in e&&e.queryFeaturesJSON){const{features:r}=await e.queryFeaturesJSON(t,{signal:a});return r}if(!("queryFeatures"in e))throw new r(`${this.adapterName}:not-supported`,"'queryFeatures' is not supported on the layerView");const n=await e.queryFeatures(t,{signal:a});return o?z(n.features):n.features}_fetchFeaturesForStats(e,t){return v({field:e.field,field2:e.field2,field3:e.field3,normalizationField:e.normalizationField,valueExpression:e.valueExpression}).then((r=>this.getSampleFeatures({sampleSize:-1,view:e.view,returnGeometry:e.returnGeometry,filter:e.filter,requiredFields:r,signal:e.signal},t)))}async _summaryStatsFromClientQuery(e,t){const{view:r,signal:a}=e,i=_(this,e,t),s=await this._fetchFeatureSetFromMemory(i,r,a),o=L(s,q(t)||p(t));return O(o)}async _getNormalizationTotalFromMemory(e,t,a){const{featuresJSON:i,graphics:s,layerView:o,query:n}=t,l=(!i&&!s&&o&&"querySummaryStatistics"in o?await o.querySummaryStatistics(n,{field:e},{signal:a}):i?await this.workerClient.summaryStatistics({field:e},i):await d({attribute:{field:e},features:s??[]})).sum;if(null==l)throw new r(`${this.adapterName}:invalid`,"invalid normalizationTotal");return l}async _summaryStatsFromMemory(e,t){const{view:r,field:a,valueExpression:i,normalizationType:s,signal:o}=e,n={field:a,valueExpression:i,normalizationType:s,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue},{featuresJSON:l,graphics:u,layerView:p,query:y,fieldInfos:f}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"querySummaryStatistics"});return i&&r&&(l||u)&&(n.fieldType=t?.type?m.toJSON(t.type):null,n.viewInfoParams=M(r),n.timeZone=r.timeZone,n.fieldInfos=f),"percent-of-total"===s&&null==e.normalizationTotal&&(n.normalizationTotal=await this._getNormalizationTotalFromMemory(a,{featuresJSON:l,graphics:u,layerView:p,query:y},o)),!l&&!u&&p&&"querySummaryStatistics"in p?p.querySummaryStatistics(y,n,{signal:o}):l?this.workerClient.summaryStatistics(n,l):d({attribute:n,features:u})}async _getFilteredFeatures(e,t){let r=[];if("intersects"===t?.spatialRelationship){const{intersect:a}=await import("../../../geometry/geometryEngineAsync.js"),i=null!=t.geometry?t.geometry:null;for(const t of e){const e=null!=t.geometry?t.geometry:null;if(e&&i){await a(e,i)&&r.push(t)}}}else r=e;return e.length&&"declaredClass"in e[0]&&"esri.Graphic"===e[0].declaredClass?{graphics:r}:{featuresJSON:r}}async _processStatsFromMemoryParams(e){const{features:t,filter:r}=e;if(t?.length)return this._getFilteredFeatures(t,r);const{view:a,field:i,field2:s,field3:o,normalizationField:n,valueExpression:l,layerViewFunc:u,signal:m}=e;let p=e.returnGeometry;if(null==p&&l){if(!U){const{arcadeUtils:e}=await J();U=e}const e=U.hasGeometryOperations(l);e&&await U.enableGeometryOperations(),p=e}let y=null,f=null,d=null,c=null,h=null;if(a)try{y=await a.whenLayerView(this.layer),f=null!=u&&u in y&&"function"==typeof y[u]}catch{f=!1}if(f)try{await this._waitForLayerViewUpdate(y);const e=await v({field:i,field2:s,field3:o,normalizationField:n,valueExpression:l});N(this,e,y).length?f=!1:(d=this.layer.createQuery(),d.outFields=e,d.returnGeometry=!1,T(d,r)),y.suspended&&(f=!1)}catch{f=!1}return f||(c=await this._fetchFeaturesForStats({field:i,field2:s,field3:o,valueExpression:l,normalizationField:n,returnGeometry:p,filter:r,view:a,signal:m},"json"),h=(await v({valueExpression:l})).map((e=>this.getField(e)?.toJSON())).filter(Boolean)),{layerView:y,query:d,featuresJSON:c,fieldInfos:h}}async _uvFromClientQuery(e,t){const{view:r,signal:a}=e,i=E(this,e),s=await this._fetchFeatureSetFromMemory(i,r,a),o=await C(s,{layer:this,field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:V,view:e.view,signal:e.signal});return Q(o,t,e.returnAllCodedValues,V)}async _uvFromMemory(e,t){const{view:r,field:a,valueExpression:i,returnAllCodedValues:s,signal:o}=e,{featuresJSON:n,graphics:l,layerView:u,query:m,fieldInfos:p}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryUniqueValues"}),y={field:a,field2:e.field2,field3:e.field3,fieldDelimiter:V,valueExpression:i,domains:t,returnAllCodedValues:s};return i&&r&&(n||l)&&(y.viewInfoParams=M(r),y.timeZone=r.timeZone,y.fieldInfos=p),!n&&!l&&u&&"queryUniqueValues"in u?u.queryUniqueValues(m,y,{signal:o}):n?this.workerClient.uniqueValues(y,n):c({attribute:y,features:l})}_histogramForField(e){let t=null;return t=null!=e.minValue&&null!=e.maxValue?Promise.resolve({min:e.minValue,max:e.maxValue}):this.summaryStatistics(e).then((e=>{if(!e.count)throw new r(`${this.adapterName}:insufficient-data`,"Either the layer has no features or none of the features have data for the field");return{min:e.min,max:e.max}})),t.then((t=>j(this,{min:t.min,max:t.max},e.field,e.numBins??void 0,e.view,e.filter,e.signal)))}async _histogramFromMemory(e){const{view:t,field:r,valueExpression:a,signal:i}=e,{featuresJSON:s,graphics:o,layerView:n,query:l,fieldInfos:u}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryHistogram"}),m={field:r,valueExpression:a,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return a&&t&&(s||o)&&(m.viewInfoParams=M(t),m.timeZone=t.timeZone,m.fieldInfos=u),"percent-of-total"===e.normalizationType&&null==e.normalizationTotal&&(m.normalizationTotal=await this._getNormalizationTotalFromMemory(r,{featuresJSON:s,graphics:o,layerView:n,query:l},i)),!s&&!o&&n&&"queryHistogram"in n?n.queryHistogram(l,m,{signal:i}):s?this.workerClient.histogram(m,s):h({attribute:m,features:o})}_classBreaksFromInterpolation(e){const{minValue:t,maxValue:r}=e,a=e.numClasses||P,i=[],s=(r-t)/a;for(let l=0;l<a;l++){const e=t+l*s;i.push({minValue:e,maxValue:e+s})}i[a-1].maxValue=r;const o={classBreaks:i,normalizationTotal:e.normalizationTotal},n=b(o,e.classificationMethod);return Promise.resolve(n)}async _classBreaksFromMemory(e){const{view:t,field:r,valueExpression:a,signal:i}=e,{featuresJSON:s,graphics:o,layerView:n,query:l,fieldInfos:u}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryClassBreaks"}),m={field:r,valueExpression:a,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return a&&t&&(s||o)&&(m.viewInfoParams=M(t),m.timeZone=t.timeZone,m.fieldInfos=u),"percent-of-total"===e.normalizationType&&null==e.normalizationTotal&&(m.normalizationTotal=await this._getNormalizationTotalFromMemory(r,{featuresJSON:s,graphics:o,layerView:n,query:l},i)),!s&&!o&&n&&"queryClassBreaks"in n?n.queryClassBreaks(l,m,{signal:i}):s?this.workerClient.classBreaks(m,s):w({attribute:m,features:o})}async _heatmapStatsFromMemory(e){const{view:t,field:r,radius:a}=e;i(t,"InMemoryLayerAdapter: must have a view");const s=await t.whenLayerView(this.layer);if("queryHeatmapStatistics"in s&&!s.updating)return s.queryHeatmapStatistics({field:e.field,radius:e.radius});const{featuresJSON:o,graphics:n}=await this._processStatsFromMemoryParams({...e,returnGeometry:!0}),l=new y({extent:t.extent,tolerance:"2d"===t.type?t.state.resolution:t.pixelSizeAt?.(t.center)}),m={field:r,radius:a,transform:u(l),spatialReference:t.spatialReference?.toJSON(),size:t.size};return o?.length||n?.length?o?this.workerClient.heatmapStatistics(m,o):g({attribute:m,features:n}):{min:null,max:null}}getField(e=""){return this.layer.getField(e)}getFieldUsageInfo(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!0,supportsStatistics:!0}:null}getFieldDomain(e,t){return this.layer.getFieldDomain(e,t)}createQuery(){return this.layer.createQuery()}async summaryStatistics(e){const{field:t,valueExpression:a,sqlExpression:i,features:s,view:o}=e,n=t?this.getField(t):null,l=!!a,u="3d"===o?.type;if(!a&&i&&!this.supportsSQLExpression)throw new r(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return l||s||u?this._summaryStatsFromMemory(e,n):this._summaryStatsFromClientQuery(e,n)}async uniqueValues(e){const{valueExpression:t,sqlExpression:a,features:i,view:s}=e,o=await I(e,this),n=!!t,l="3d"===s?.type;if(!t&&a&&!this.supportsSQLExpression)throw new r(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return n||i||l?this._uvFromMemory(e,o):this._uvFromClientQuery(e,o)}async histogram(e){const{features:t,valueExpression:a,normalizationType:i,sqlExpression:s}=e,o=t||!!a;if(!a&&s&&!this.supportsSQLExpression)throw new r(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return o||i?this._histogramFromMemory(e):this._histogramForField(e)}async classBreaks(e){return!1!==e.analyzeData?this._classBreaksFromMemory(e):this._classBreaksFromInterpolation(e)}async queryFeatureCount(e){const{whereClause:t,view:a,signal:i}=e;if(!a)throw new r(`${this.adapterName}:insufficient-data`,"view is required to fetch the features from layerView");const s=this.layer.createQuery();s.where=F(s.where,t);const n=await a.whenLayerView(this.layer);return await o((()=>!n.updating),i),n.queryFeatureCount(s,{signal:i})}async generateRenderer(e,t){throw new r(`${this.adapterName}:not-supported`,"Layer does not support generateRenderer operation")}async predominantCategories(e){const{fields:t,view:r,signal:a}=e,i=f(t),s=await this._uvFromMemory({valueExpression:i,view:r,signal:a});return k(s.uniqueValueInfos,t)}async heatmapStatistics(e){return this._heatmapStatsFromMemory(e)}async getSampleFeatures(e,a){const{view:i,sampleSize:s,requiredFields:o,returnGeometry:n,filter:l,signal:u}=e,m=this.layer.createQuery(),p=1;if(m.outSpatialReference=i?.spatialReference,m.returnGeometry=!!n,m.outFields=o,T(m,l),!i)throw new r(`${this.adapterName}:not-supported`,"view is required to get sample features for Layer");const y=await i.whenLayerView(this.layer);if(N(this,o,y).length)throw new r(`${this.adapterName}:not-supported`,"Required fields need to be passed in the outFields for Layer");const f=await this._fetchFeaturesFromMemory(y,m,u,a),d=null!=s&&s>0&&s<=f.length?s:f.length;return t(f,d,p)}load(e){const t=this.layer.load(e).then((async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression="stream"===t.type||t.capabilities?.query?.supportsSqlExpression,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=t.fullExtent,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.workerClient=S.getInstance(),await this.workerClient.open(e.signal)}));return this.addResolvingPromise(t),Promise.resolve(this)}};e([n({constructOnly:!0})],B.prototype,"layer",void 0),B=e([l("esri.smartMapping.support.adapters.InMemoryLayerAdapter")],B);const $=B;export{$ as default};
