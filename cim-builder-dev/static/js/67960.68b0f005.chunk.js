"use strict";(globalThis.webpackChunkmy_app=globalThis.webpackChunkmy_app||[]).push([[67960],{67960:(e,t,i)=>{i.r(t),i.d(t,{SelfSnappingEngine:()=>I});var s=i(6326),r=i(91967),n=i(19276),o=i(46053),a=(i(81806),i(76460),i(47249),i(85842)),h=i(73582),c=i(24648),l=i(9392),d=i(12482),p=i(23862),g=i(31633),u=i(19555),f=i(63078),v=i(70330),x=i(17072);class w{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=f.N.shortLineThreshold*f.N.shortLineThreshold}snap(e,t){return null!=t.vertexHandle?"vertex"!==t.vertexHandle.type?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold((0,p.Lp)(e.leftVertex.pos,this.view,t),(0,p.Lp)(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:i}){return 0===this.squaredShortLineThreshold||(0,v.pM)((0,x.j)(t,i,d.qt,this.view),(0,x.j)(e,i,d.qt,this.view))>this.squaredShortLineThreshold}isVertical(e,t,{spatialReference:i}){const s=(0,g.GA)(i);return(0,u.Io)((0,p.Xz)(e),(0,p.Xz)(t))*s<f.N.verticalLineThresholdMeters}squaredProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}}var L=i(45633),m=i(89646),E=i(79337);class V extends w{constructor(e,t,i){super(e,t),this._geodesicLengthMeasurementUtils=i}snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,r=[];if(s<1)return r;const{spatialReference:n}=t,o=(0,x.j)(e,n,d.qt,this.view),{view:a}=this,h=i.edges[s-1];let c=h;do{if(this.edgeExceedsShortLineThreshold(c,t)){const i=(0,v.is)(c,a,t);this._processCandidateProposal(i.left,i.right,e,o,t,r)}c=c.leftVertex.leftEdge}while(c&&c!==h);return r}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,r=s.component;if(r.edges.length<2)return i;const{view:n}=this,{spatialReference:o}=t,a=(0,x.j)(e,o,d.qt,n),h=s.leftEdge,c=s.rightEdge;h&&c&&this.edgeExceedsShortLineThreshold(h,t)&&this.edgeExceedsShortLineThreshold(c,t)&&this._processCandidateProposal((0,p.Lp)(h.leftVertex.pos,n,t),(0,p.Lp)(c.rightVertex.pos,n,t),e,a,t,i);const l=r.edges[0];let g=l;do{if(g!==s.leftEdge&&g!==s.rightEdge&&this.edgeExceedsShortLineThreshold(g,t)){const s=(0,v.is)(g,n,t);this._processCandidateProposal(s.left,s.right,e,a,t,i)}g=g.rightVertex.rightEdge}while(g&&g!==l);return i}_processCandidateProposal(e,t,i,s,r,n){const{spatialReference:o,pointer:a}=r,g=(0,l.vt)();!function(e,t,i,s,r,n){(function(e,t,i,s,{spatialReference:r},n){const o=(0,m.IP)(t,i,r,r);if(null==o)return!1;const a=(0,m.IP)(i,s,r,r);if(null==a)return!1;const l=n.geodesicDistance(i,s,r);if(null==l)return!1;const d=Math.abs(h.wf.shortestSignedDiff(o,a))>Math.PI/2?h.uC.normalize(o+Math.PI):o;return(0,m.rT)(e,i,r,(0,c.l3)(l,"meters"),(0,c.Wq)(d,"radians","geographic"),"geodesic"),e[2]=s[2],!0})(e,t,i,s,r,n)||function(e,t,i,s){(0,E.Yv)(t,{start:i,end:s,type:1},e),e[2]=t[2]}(e,s,t,i)}(g,e,t,i,r,this._geodesicLengthMeasurementUtils);const u=(0,p.de)((0,p._7)(g));(0,v.pM)(s,(0,x.j)(u,o,d.qt,this.view))<this.squaredProximityThreshold(a)&&n.push(new L.o({lineStart:e,lineEnd:t,targetPoint:u,isDraped:"on-the-ground"===r.elevationInfo?.mode}))}}var _=i(72745),y=i(20612),P=i(74050);class T extends w{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,r=i.vertices.length,n=[];if(s<2)return n;const{view:o}=this,a=(0,x.j)(e,t.spatialReference,d.qt,o),h=(0,p.Lp)(i.vertices[r-1].pos,o,t),c=(0,p.Lp)(i.vertices[0].pos,o,t),l=i.edges[s-1];let g=l;do{if(this.edgeExceedsShortLineThreshold(g,t)){const i=(0,v.is)(g,o,t);this._checkEdgeForParallelLines(i,h,e,a,t,n),this._checkEdgeForParallelLines(i,c,e,a,t,n)}g=g.leftVertex.leftEdge}while(g&&g!==l);return n}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,r=s.component;if(r.edges.length<3)return i;const{view:n}=this,o=(0,x.j)(e,t.spatialReference,d.qt,n),a=s.leftEdge,h=s.rightEdge,c=r.vertices[0],l=(0,p.Lp)(c.pos,n,t),g=r.vertices.length,u=r.vertices[g-1],f=(0,p.Lp)(u.pos,n,t),w=r.edges[0];let L=w;do{if(L!==a&&L!==h&&this.edgeExceedsShortLineThreshold(L,t)){const r=(0,v.is)(L,n,t);a&&this._checkEdgeForParallelLines(r,(0,p.Lp)(a.leftVertex.pos,n,t),e,o,t,i),h&&this._checkEdgeForParallelLines(r,(0,p.Lp)(h.rightVertex.pos,n,t),e,o,t,i),s===c?this._checkEdgeForParallelLines(r,f,e,o,t,i):s===u&&this._checkEdgeForParallelLines(r,l,e,o,t,i)}L=L.rightVertex.rightEdge}while(L&&L!==w);return i}_checkEdgeForParallelLines(e,t,i,s,r,n){const o=e.left,a=e.right;if((0,P.fg)(q,(0,p.Xz)(t),(0,p.Xz)(o),(0,p.Xz)(a)),(0,u.hG)(q,(0,p.Xz)(t))<f.N.parallelLineThreshold)return;(0,P.fg)(q,(0,p.Xz)(i),(0,p.Xz)(o),(0,p.Xz)(a),(0,p.Xz)(t));const{spatialReference:h,pointer:c}=r,l=(0,p.de)((0,p.fA)(q[0],q[1],i[2]));if((0,v.pM)(s,(0,x.j)(l,h,d.qt,this.view))<this.squaredProximityThreshold(c)){if(this.isVertical(l,t,r)||this.isVertical(o,a,r))return;if(function(e,t){const i=e.left,s=e.right;for(const r of t)if((0,P.fg)(q,(0,p.Xz)(s),(0,p.Xz)(r.constraint.start),(0,p.Xz)(r.constraint.end),(0,p.Xz)(i)),(0,u.hG)(q,(0,p.Xz)(s))<f.N.parallelLineThreshold)return r.addReferenceLine(e),!0;return!1}(e,n))return;n.push(new y.B({referenceLine:e,lineStart:t,targetPoint:l,isDraped:"on-the-ground"===r.elevationInfo?.mode}))}}}const q=(0,_.vt)();var z=i(20664),S=i(75543),M=i(78228);class X extends w{constructor(e,t,i){super(e,t),this._geodesicLengthMeasurementUtils=i}snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=[];if(i.vertices.length<2)return s;const{view:r}=this,n=(0,x.j)(e,t.spatialReference,d.qt,r),o=i.vertices.at(-1);this._checkForSnappingCandidate(1,s,o.leftEdge,o,o.leftEdge.leftVertex,e,n,t);const a=i.vertices[0];return this._checkForSnappingCandidate(2,s,a.rightEdge,a,a.rightEdge.rightVertex,e,n,t),s}snapExistingVertex(e,t){const i=[],s=t.vertexHandle;if(s.component.vertices.length<3)return i;const{view:r}=this,n=(0,x.j)(e,t.spatialReference,d.qt,r),o=s.leftEdge,a=s.rightEdge;if(o?.leftVertex.leftEdge){const s=o.leftVertex.leftEdge;this._checkForSnappingCandidate(3,i,s,s.rightVertex,s.leftVertex,e,n,t)}if(a?.rightVertex.rightEdge){const s=a.rightVertex.rightEdge;this._checkForSnappingCandidate(3,i,s,s.leftVertex,s.rightVertex,e,n,t)}return i}_checkForSnappingCandidate(e,t,i,s,r,n,o,a){if(!this.edgeExceedsShortLineThreshold(i,a))return;const d=this.view,g=(0,p.Lp)(s.pos,d,a),f=(0,p.Lp)(r.pos,d,a);(function(e,t,i,s,r,n){(function(e,t,i,s,{spatialReference:r},n){const o=(0,m.IP)(t,i,r,r);if(null==o)return!1;const a=(0,m.IP)(i,s,r,r);if(null==a)return!1;const d=Math.sign(h.uC.shortestSignedDiff(o,a))*Math.PI*.5,p=(0,c.Wq)(o+d,"radians","geographic"),g=(0,l.vt)(),u=n.geodesicDistance(i,s,r);return null!=u&&((0,m.rT)(g,i,r,(0,c.l3)(u,"meters"),p,"geodesic"),(0,z.d)(e,g,i),!0)})(e,t,i,s,r,n)||function(e,t,i){const s=(0,u.Re)(C,(0,p.Xz)(i),(0,p.Xz)(t));(0,z.i)(e,s[1],-s[0],0)}(e,t,i)})(R,f,g,n,a,this._geodesicLengthMeasurementUtils),this._checkForSnappingCandidateAlongProjectedRay(e,t,f,g,R,n,o,a)}_checkForSnappingCandidateAlongProjectedRay(e,t,i,s,r,n,o,a){const{spatialReference:h,pointer:c}=a,g=(0,u.Re)(C,(0,p.Xz)(n),(0,p.Xz)(s)),f=(0,u.Om)(r,g)/(0,u.m3)(r),w=(0,u.Ln)(C,(0,p.Xz)(s),r,f),L=(0,p.de)((0,p.fA)(w[0],w[1],n[2]));if((0,v.pM)(o,(0,x.j)(L,h,d.qt,this.view))>this.squaredProximityThreshold(c)||this.isVertical(L,s,a)||this.isVertical(s,i,a))return;const m=(0,z.b)((0,l.vt)(),s,r,Math.sign(f));t.push(new M.H({targetPoint:L,constraint:new S.FX(s,(0,p._7)(m)),previousVertex:i,otherVertex:s,otherVertexType:1,selfSnappingType:e,isDraped:"on-the-ground"===a.elevationInfo?.mode}))}}const C=(0,_.vt)(),R=(0,l.vt)();var F=i(59380);class k extends w{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=[],r=i.vertices.length;if("polygon"!==t.editGeometryOperations.data.type||r<2)return s;const{view:n}=this,o=i.vertices[0],a=i.vertices[r-1],h=(0,p.Lp)(o.pos,n,t),c=(0,p.Lp)(a.pos,n,t);return this._processCandidateProposal(h,c,e,t,s),s}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,r=s.component;if(r.edges.length<2)return i;if("polyline"===t.editGeometryOperations.data.type&&(0===s.index||s.index===r.vertices.length-1))return i;const{view:n}=this,o=(0,p.Lp)(s.leftEdge.leftVertex.pos,n,t),a=(0,p.Lp)(s.rightEdge.rightVertex.pos,n,t);return this._processCandidateProposal(o,a,e,t,i),i}_processCandidateProposal(e,t,i,s,r){if(!this.exceedsShortLineThreshold(e,t,s))return;const n=(0,u.Cc)(j,(0,p.Xz)(e),(0,p.Xz)(t),.5),o=.5*(0,u.Io)((0,p.Xz)(e),(0,p.Xz)(t)),a=(0,P.Dh)(j,(0,p.Xz)(i),n,o),h=(0,p.de)((0,p.fA)(a[0],a[1],i[2])),{spatialReference:c,pointer:l}=s,g=(0,x.j)(i,c,d.qt,this.view);if((0,v.pM)(g,(0,x.j)(h,c,d.qt,this.view))<this.squaredProximityThreshold(l)){if(this.isVertical(e,h,s)||this.isVertical(h,t,s))return;r.push(new F.R({targetPoint:h,point1:e,point2:t,isDraped:"on-the-ground"===s.elevationInfo?.mode}))}}}const j=(0,_.vt)();let I=class extends r.A{constructor(e){super(e),this.updating=!1,this._snappers=new n.A,this._domain=2}initialize(){this._snappers.push(new T(this.view,this.options),new V(this.view,this.options,this.geodesicLengthMeasurementUtils),new X(this.view,this.options,this.geodesicLengthMeasurementUtils),new k(this.view,this.options))}set options(e){this._set("options",e);for(const t of this._snappers)t.options=e}async fetchCandidates(e,t,i){if(!(t&this._domain&&this.options.effectiveSelfEnabled))return[];const s=[];for(const r of this._snappers.items)for(const t of r.snap(e,i))s.push(t);return(0,v.xX)(e,s),s}};(0,s.Cg)([(0,o.MZ)({readOnly:!0})],I.prototype,"updating",void 0),(0,s.Cg)([(0,o.MZ)({constructOnly:!0})],I.prototype,"view",void 0),(0,s.Cg)([(0,o.MZ)({constructOnly:!0})],I.prototype,"geodesicLengthMeasurementUtils",void 0),(0,s.Cg)([(0,o.MZ)()],I.prototype,"options",null),I=(0,s.Cg)([(0,a.$)("esri.views.interactive.snapping.SelfSnappingEngine")],I)},89646:(e,t,i)=>{i.d(t,{$h:()=>g,Ef:()=>V,IP:()=>f,P1:()=>L,hF:()=>E,jQ:()=>w,rT:()=>m,uR:()=>v});var s=i(73582),r=i(24648),n=i(31633),o=i(19555),a=i(72745),h=i(20664),c=i(9392),l=i(14487),d=i(7137),p=i(80963);function g(e,t){if(null==e||null==t)return;const i=u(e,t);return null!=i?(0,r.Wq)(i,"radians","geographic"):void 0}const u=(()=>{const e=(0,c.vt)(),t=(0,c.vt)();return(i,s)=>((0,h.i)(e,i.x,i.y,i.z??0),(0,h.i)(t,s.x,s.y,s.z??0),f(e,t,i.spatialReference,s.spatialReference))})(),f=(()=>{const e=(0,a.vt)(),t=(0,c.vt)(),i=(0,c.vt)();return(s,r,c,g)=>{if((0,h.q)(s,r))return;const u=(0,d.Xn)(c),f=(0,d.Xn)(g);if(u&&f&&(0,p.aI)(u,f)&&(0,l.F)(s,c,t,u)&&(0,l.F)(r,g,i,f)){const{azimuth:e}=(0,d._3)(y,t,i,u);return null!=e?(0,n.oU)(e,"degrees","radians"):void 0}e[0]=r[0]-s[0],e[1]=r[1]-s[1];let v=(0,o.g7)(a.JP,e);return e[0]<0&&(v=P-v),v}})();function v(e,t,i,s="absolute"){if(t&&i)switch(s){case"absolute":return g(t,i);case"relative":return w(x(e,t,i),"relative");case"relative-bilateral":return w(x(e,t,i),"relative-bilateral")}}function x(e,t,i){if(!e||!t||!i)return;const s=u(e,t),n=u(t,i);return null!=s&&null!=n?(0,r.Wq)(n-s,"radians","geographic"):void 0}function w(e,t){if(null!=e)switch(t){case"absolute":return L(e);case"relative":{const t=E(e);let i=q.normalize(t,0,!0);return-180===i&&(i=180),(0,r.Wq)(i,"degrees","geographic")}case"relative-bilateral":{const t=E(e),i=Math.abs(q.normalize(t,0,!0));return(0,r.Wq)(i,"degrees","geographic")}}}function L(e){const t=E(e),i=T.normalize(t,0,!0);return(0,r.Wq)(i,"degrees","geographic")}const m=(()=>{const e=(0,c.vt)();return(t,i,s,o,a,c="geodesic")=>{(0,h.c)(e,i);const p=E(a);if("geodesic"===c){const r=(0,d.Xn)(s);if(r&&(0,l.F)(e,s,e,r))return(0,d.vN)(t,e,p,o,r),t[2]=i[2],!!(0,l.F)(t,r,t,s)}const g=(0,r.g2)(p,"geographic","arithmetic"),u=(0,n.oU)(g,"degrees","radians"),f=i[0]+o*Math.cos(u),v=i[1]+o*Math.sin(u),x=i[2];return(0,h.i)(t,f,v,x),!0}})();function E(e){if(null!=e)return(0,r.g2)(_(e),e.rotationType,"geographic")}function V(e){if(null!=e)return(0,r.g2)(_(e),e.rotationType,"arithmetic")}function _(e){return(0,n.oU)(e.value,e.unit,"degrees")}const y=new d.Zj,P=2*Math.PI,T=s.ie,q=new s.hr(-180,180)}}]);
//# sourceMappingURL=67960.68b0f005.chunk.js.map