{"version":3,"file":"static/js/6290.f1f1df5f.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/components/debounce.js","../node_modules/@esri/calcite-components/dist/components/floating-ui.js","../node_modules/@esri/calcite-components/dist/components/guid.js","../node_modules/@esri/calcite-components/dist/components/tooltip.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.0-beta.95\n */\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto$1.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString$1.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport { Symbol as S, isSymbol as a, baseGetTag as b, isObjectLike as c, debounce as d, freeGlobal as f, isObject as i, root as r };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.0-beta.95\n */\nimport { c as getElementDir } from './dom.js';\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition$1 = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min$1 = Math.min;\nconst max$1 = Math.max;\n\nfunction within(min$1$1, value, max$1$1) {\n  return max$1(min$1$1, min$1(value, max$1$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const alignment = getAlignment(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max); // Make sure that arrow points at the reference\n\n    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];\n    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)\n  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      const parent = currentNode.parentNode;\n      currentNode = isShadowRoot(parent) ? parent.host : parent;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize: _ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestorResize = _ancestorResize && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return () => {\n    var _observer;\n\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nconst repositionDebounceTimeout = 100;\nconst effectivePlacements = [\n  \"top\",\n  \"bottom\",\n  \"right\",\n  \"left\",\n  \"top-start\",\n  \"top-end\",\n  \"bottom-start\",\n  \"bottom-end\",\n  \"right-start\",\n  \"right-end\",\n  \"left-start\",\n  \"left-end\"\n];\nconst defaultMenuPlacement = \"bottom-start\";\nconst FloatingCSS = {\n  animation: \"calcite-floating-ui-anim\",\n  animationActive: \"calcite-floating-ui-anim--active\"\n};\nfunction getMiddleware({ placement, disableFlip, flipPlacements, offsetDistance, offsetSkidding, arrowEl, type }) {\n  const defaultMiddleware = [shift(), hide()];\n  if (type === \"menu\") {\n    return [\n      ...defaultMiddleware,\n      flip({\n        fallbackPlacements: flipPlacements || [\"top-start\", \"top\", \"top-end\", \"bottom-start\", \"bottom\", \"bottom-end\"]\n      })\n    ];\n  }\n  if (type === \"popover\" || type === \"tooltip\") {\n    const middleware = [\n      ...defaultMiddleware,\n      offset({\n        mainAxis: typeof offsetDistance === \"number\" ? offsetDistance : 0,\n        crossAxis: typeof offsetSkidding === \"number\" ? offsetSkidding : 0\n      })\n    ];\n    if (placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\") {\n      middleware.push(autoPlacement({ alignment: placement === \"auto-start\" ? \"start\" : placement === \"auto-end\" ? \"end\" : null }));\n    }\n    else if (!disableFlip) {\n      middleware.push(flip(flipPlacements ? { fallbackPlacements: flipPlacements } : {}));\n    }\n    if (arrowEl) {\n      middleware.push(arrow({\n        element: arrowEl\n      }));\n    }\n    return middleware;\n  }\n  return [];\n}\nfunction filterComputedPlacements(placements, el) {\n  const filteredPlacements = placements.filter((placement) => effectivePlacements.includes(placement));\n  if (filteredPlacements.length !== placements.length) {\n    console.warn(`${el.tagName}: Invalid value found in: flipPlacements. Try any of these: ${effectivePlacements\n      .map((placement) => `\"${placement}\"`)\n      .join(\", \")\n      .trim()}`, { el });\n  }\n  return filteredPlacements;\n}\n/*\nIn floating-ui, \"*-start\" and \"*-end\" are already flipped in RTL.\nThere is no need for our \"*-leading\" and \"*-trailing\" values anymore.\nhttps://github.com/floating-ui/floating-ui/issues/1530\nhttps://github.com/floating-ui/floating-ui/issues/1563\n*/\nfunction getEffectivePlacement(floatingEl, placement) {\n  const placements = [\"left\", \"right\"];\n  if (getElementDir(floatingEl) === \"rtl\") {\n    placements.reverse();\n  }\n  return placement\n    .replace(/-leading/gi, \"-start\")\n    .replace(/-trailing/gi, \"-end\")\n    .replace(/leading/gi, placements[0])\n    .replace(/trailing/gi, placements[1]);\n}\n/**\n * Positions the floating element relative to the reference element.\n *\n * @param root0\n * @param root0.referenceEl\n * @param root0.floatingEl\n * @param root0.overlayPositioning\n * @param root0.placement\n * @param root0.disableFlip\n * @param root0.flipPlacements\n * @param root0.offsetDistance\n * @param root0.offsetSkidding\n * @param root0.arrowEl\n * @param root0.type\n */\nasync function positionFloatingUI({ referenceEl, floatingEl, overlayPositioning = \"absolute\", placement, disableFlip, flipPlacements, offsetDistance, offsetSkidding, arrowEl, type }) {\n  var _a;\n  if (!referenceEl || !floatingEl) {\n    return null;\n  }\n  const { x, y, placement: effectivePlacement, strategy: position, middlewareData } = await computePosition(referenceEl, floatingEl, {\n    strategy: overlayPositioning,\n    placement: placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\"\n      ? undefined\n      : getEffectivePlacement(floatingEl, placement),\n    middleware: getMiddleware({\n      placement,\n      disableFlip,\n      flipPlacements,\n      offsetDistance,\n      offsetSkidding,\n      arrowEl,\n      type\n    })\n  });\n  if (middlewareData === null || middlewareData === void 0 ? void 0 : middlewareData.arrow) {\n    const { x: arrowX, y: arrowY } = middlewareData.arrow;\n    Object.assign(arrowEl.style, {\n      left: arrowX != null ? `${arrowX}px` : \"\",\n      top: arrowY != null ? `${arrowY}px` : \"\"\n    });\n  }\n  const referenceHidden = (_a = middlewareData === null || middlewareData === void 0 ? void 0 : middlewareData.hide) === null || _a === void 0 ? void 0 : _a.referenceHidden;\n  const visibility = referenceHidden ? \"hidden\" : null;\n  const pointerEvents = visibility ? \"none\" : null;\n  floatingEl.setAttribute(\"data-placement\", effectivePlacement);\n  const transform = `translate(${Math.round(x)}px,${Math.round(y)}px)`;\n  Object.assign(floatingEl.style, {\n    visibility,\n    pointerEvents,\n    position,\n    top: \"0\",\n    left: \"0\",\n    transform\n  });\n}\nconst cleanupMap = new WeakMap();\n/**\n * Helper to set up floating element interactions on connectedCallback.\n *\n * @param component\n * @param referenceEl\n * @param floatingEl\n */\nfunction connectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n  disconnectFloatingUI(component, referenceEl, floatingEl);\n  cleanupMap.set(component, autoUpdate(referenceEl, floatingEl, () => {\n    if (component.open) {\n      component.reposition();\n    }\n  }));\n}\n/**\n * Helper to tear down floating element interactions on disconnectedCallback.\n *\n * @param component\n * @param referenceEl\n * @param floatingEl\n */\nfunction disconnectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n  const cleanup = cleanupMap.get(component);\n  if (cleanup) {\n    cleanup();\n  }\n  cleanupMap.delete(component);\n}\nconst visiblePointerSize = 4;\n/**\n * Default offset the position of the floating element away from the reference element.\n *\n * @default 6\n */\nconst defaultOffsetDistance = Math.ceil(Math.hypot(visiblePointerSize, visiblePointerSize));\n\nexport { FloatingCSS as F, disconnectFloatingUI as a, defaultOffsetDistance as b, connectFloatingUI as c, defaultMenuPlacement as d, filterComputedPlacements as f, positionFloatingUI as p, repositionDebounceTimeout as r };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.0-beta.95\n */\nfunction gen(counts) {\n  return counts\n    .map((count) => {\n    let out = \"\";\n    for (let i = 0; i < count; i++) {\n      out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n    }\n    return out;\n  })\n    .join(\"-\");\n}\nconst guid = () => gen([2, 1, 1, 1, 3]);\n\nexport { guid as g };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.0-beta.95\n */\nimport { proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client/index.js';\nimport { g as guid } from './guid.js';\nimport { b as defaultOffsetDistance, c as connectFloatingUI, a as disconnectFloatingUI, p as positionFloatingUI, F as FloatingCSS, r as repositionDebounceTimeout } from './floating-ui.js';\nimport { q as queryElementRoots, t as toAriaBoolean } from './dom.js';\nimport { d as debounce } from './debounce.js';\n\nconst CSS = {\n  container: \"container\",\n  arrow: \"arrow\"\n};\nconst TOOLTIP_DELAY_MS = 500;\nconst ARIA_DESCRIBED_BY = \"aria-describedby\";\n\nclass TooltipManager {\n  constructor() {\n    // --------------------------------------------------------------------------\n    //\n    //  Private Properties\n    //\n    // --------------------------------------------------------------------------\n    this.registeredElements = new WeakMap();\n    this.hoverTimeouts = new WeakMap();\n    this.registeredElementCount = 0;\n    // --------------------------------------------------------------------------\n    //\n    //  Private Methods\n    //\n    // --------------------------------------------------------------------------\n    this.queryTooltip = (composedPath) => {\n      const { registeredElements } = this;\n      const registeredElement = composedPath.find((pathEl) => registeredElements.has(pathEl));\n      return registeredElements.get(registeredElement);\n    };\n    this.keyDownHandler = (event) => {\n      if (event.key === \"Escape\") {\n        const { activeTooltipEl } = this;\n        if (activeTooltipEl) {\n          this.clearHoverTimeout(activeTooltipEl);\n          this.toggleTooltip(activeTooltipEl, false);\n        }\n      }\n    };\n    this.mouseEnterShow = (event) => {\n      this.hoverEvent(event, true);\n    };\n    this.mouseLeaveHide = (event) => {\n      this.hoverEvent(event, false);\n    };\n    this.clickHandler = (event) => {\n      const clickedTooltip = this.queryTooltip(event.composedPath());\n      this.clickedTooltip = clickedTooltip;\n      if (clickedTooltip === null || clickedTooltip === void 0 ? void 0 : clickedTooltip.closeOnClick) {\n        this.toggleTooltip(clickedTooltip, false);\n      }\n    };\n    this.focusShow = (event) => {\n      this.focusEvent(event, true);\n    };\n    this.blurHide = (event) => {\n      this.focusEvent(event, false);\n    };\n    this.hoverToggle = (tooltip, value) => {\n      const { hoverTimeouts } = this;\n      hoverTimeouts.delete(tooltip);\n      if (value) {\n        this.closeExistingTooltip();\n      }\n      this.toggleTooltip(tooltip, value);\n    };\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Public Methods\n  //\n  // --------------------------------------------------------------------------\n  registerElement(referenceEl, tooltip) {\n    this.registeredElementCount++;\n    this.registeredElements.set(referenceEl, tooltip);\n    if (this.registeredElementCount === 1) {\n      this.addListeners();\n    }\n  }\n  unregisterElement(referenceEl) {\n    if (this.registeredElements.delete(referenceEl)) {\n      this.registeredElementCount--;\n    }\n    if (this.registeredElementCount === 0) {\n      this.removeListeners();\n    }\n  }\n  addListeners() {\n    document.addEventListener(\"keydown\", this.keyDownHandler);\n    document.addEventListener(\"pointerover\", this.mouseEnterShow, { capture: true });\n    document.addEventListener(\"pointerout\", this.mouseLeaveHide, { capture: true });\n    document.addEventListener(\"pointerdown\", this.clickHandler, { capture: true });\n    document.addEventListener(\"focusin\", this.focusShow, { capture: true });\n    document.addEventListener(\"focusout\", this.blurHide, { capture: true });\n  }\n  removeListeners() {\n    document.removeEventListener(\"keydown\", this.keyDownHandler);\n    document.removeEventListener(\"pointerover\", this.mouseEnterShow, { capture: true });\n    document.removeEventListener(\"pointerout\", this.mouseLeaveHide, { capture: true });\n    document.removeEventListener(\"pointerdown\", this.clickHandler, { capture: true });\n    document.removeEventListener(\"focusin\", this.focusShow, { capture: true });\n    document.removeEventListener(\"focusout\", this.blurHide, { capture: true });\n  }\n  clearHoverTimeout(tooltip) {\n    const { hoverTimeouts } = this;\n    if (hoverTimeouts.has(tooltip)) {\n      window.clearTimeout(hoverTimeouts.get(tooltip));\n      hoverTimeouts.delete(tooltip);\n    }\n  }\n  closeExistingTooltip() {\n    const { activeTooltipEl } = this;\n    if (activeTooltipEl) {\n      this.toggleTooltip(activeTooltipEl, false);\n    }\n  }\n  focusTooltip(tooltip, value) {\n    this.closeExistingTooltip();\n    if (value) {\n      this.clearHoverTimeout(tooltip);\n    }\n    this.toggleTooltip(tooltip, value);\n  }\n  toggleTooltip(tooltip, value) {\n    tooltip.open = value;\n    if (value) {\n      this.activeTooltipEl = tooltip;\n    }\n  }\n  hoverTooltip(tooltip, value) {\n    this.clearHoverTimeout(tooltip);\n    const { hoverTimeouts } = this;\n    const timeoutId = window.setTimeout(() => this.hoverToggle(tooltip, value), TOOLTIP_DELAY_MS );\n    hoverTimeouts.set(tooltip, timeoutId);\n  }\n  activeTooltipHover(event) {\n    const { activeTooltipEl, hoverTimeouts } = this;\n    const { type } = event;\n    if (!activeTooltipEl) {\n      return;\n    }\n    if (type === \"pointerover\" && event.composedPath().includes(activeTooltipEl)) {\n      this.clearHoverTimeout(activeTooltipEl);\n    }\n    else if (type === \"pointerout\" && !hoverTimeouts.has(activeTooltipEl)) {\n      this.hoverTooltip(activeTooltipEl, false);\n    }\n  }\n  hoverEvent(event, value) {\n    const tooltip = this.queryTooltip(event.composedPath());\n    this.activeTooltipHover(event);\n    if (!tooltip) {\n      return;\n    }\n    this.hoverTooltip(tooltip, value);\n  }\n  focusEvent(event, value) {\n    const tooltip = this.queryTooltip(event.composedPath());\n    if (!tooltip || tooltip === this.clickedTooltip) {\n      this.clickedTooltip = null;\n      return;\n    }\n    this.focusTooltip(tooltip, value);\n  }\n}\n\nconst tooltipCss = \"@-webkit-keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in{0%{opacity:0}100%{opacity:1}}@-webkit-keyframes in-down{0%{opacity:0;-webkit-transform:translate3D(0, -5px, 0);transform:translate3D(0, -5px, 0)}100%{opacity:1;-webkit-transform:translate3D(0, 0, 0);transform:translate3D(0, 0, 0)}}@keyframes in-down{0%{opacity:0;-webkit-transform:translate3D(0, -5px, 0);transform:translate3D(0, -5px, 0)}100%{opacity:1;-webkit-transform:translate3D(0, 0, 0);transform:translate3D(0, 0, 0)}}@-webkit-keyframes in-up{0%{opacity:0;-webkit-transform:translate3D(0, 5px, 0);transform:translate3D(0, 5px, 0)}100%{opacity:1;-webkit-transform:translate3D(0, 0, 0);transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;-webkit-transform:translate3D(0, 5px, 0);transform:translate3D(0, 5px, 0)}100%{opacity:1;-webkit-transform:translate3D(0, 0, 0);transform:translate3D(0, 0, 0)}}@-webkit-keyframes in-scale{0%{opacity:0;-webkit-transform:scale3D(0.95, 0.95, 1);transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;-webkit-transform:scale3D(1, 1, 1);transform:scale3D(1, 1, 1)}}@keyframes in-scale{0%{opacity:0;-webkit-transform:scale3D(0.95, 0.95, 1);transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;-webkit-transform:scale3D(1, 1, 1);transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;-webkit-animation-fill-mode:both;animation-fill-mode:both;-webkit-animation-duration:var(--calcite-animation-timing);animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{-webkit-animation-name:in;animation-name:in}.calcite-animate__in-down{-webkit-animation-name:in-down;animation-name:in-down}.calcite-animate__in-up{-webkit-animation-name:in-up;animation-name:in-up}.calcite-animate__in-scale{-webkit-animation-name:in-scale;animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0.01}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing)}:host([hidden]){display:none}:host{display:block;position:absolute;z-index:999;-webkit-transform:scale(0);transform:scale(0)}.calcite-floating-ui-anim{position:relative;-webkit-transition:var(--calcite-floating-ui-transition);transition:var(--calcite-floating-ui-transition);visibility:hidden;-webkit-transition-property:visibility, opacity, -webkit-transform;transition-property:visibility, opacity, -webkit-transform;transition-property:transform, visibility, opacity;transition-property:transform, visibility, opacity, -webkit-transform;opacity:0;-webkit-box-shadow:0 0 16px 0 rgba(0, 0, 0, 0.16);box-shadow:0 0 16px 0 rgba(0, 0, 0, 0.16);z-index:1;border-radius:0.25rem}:host([data-placement^=bottom]) .calcite-floating-ui-anim{-webkit-transform:translateY(-5px);transform:translateY(-5px)}:host([data-placement^=top]) .calcite-floating-ui-anim{-webkit-transform:translateY(5px);transform:translateY(5px)}:host([data-placement^=left]) .calcite-floating-ui-anim{-webkit-transform:translateX(5px);transform:translateX(5px)}:host([data-placement^=right]) .calcite-floating-ui-anim{-webkit-transform:translateX(-5px);transform:translateX(-5px)}:host([data-placement]) .calcite-floating-ui-anim--active{opacity:1;visibility:visible;-webkit-transform:translate(0);transform:translate(0)}:host([calcite-hydrated-hidden]){visibility:hidden !important;pointer-events:none}.arrow,.arrow::before{position:absolute;inline-size:8px;block-size:8px;z-index:-1}.arrow::before{content:\\\"\\\";--tw-shadow:0 4px 8px -1px rgba(0, 0, 0, 0.08), 0 2px 4px -1px rgba(0, 0, 0, 0.04);--tw-shadow-colored:0 4px 8px -1px var(--tw-shadow-color), 0 2px 4px -1px var(--tw-shadow-color);-webkit-box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);-webkit-transform:rotate(45deg);transform:rotate(45deg);background:var(--calcite-ui-foreground-1)}:host([data-placement^=top]) .arrow{inset-block-end:-4px}:host([data-placement^=bottom]) .arrow{inset-block-start:-4px}:host([data-placement^=left]) .arrow{direction:ltr;inset-inline-end:-4px}:host([data-placement^=right]) .arrow{direction:ltr;inset-inline-start:-4px}.container{position:relative;overflow:hidden;border-radius:0.25rem;background-color:var(--calcite-ui-foreground-1);padding-block:0.75rem;padding-inline:1rem;font-size:var(--calcite-font-size--2);line-height:1.375;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-ui-text-1);max-inline-size:20rem;max-block-size:20rem;text-align:start}.calcite-floating-ui-anim{border-radius:0.25rem;border-width:1px;border-style:solid;border-color:var(--calcite-ui-border-3);background-color:var(--calcite-ui-foreground-1)}.arrow::before{outline:1px solid var(--calcite-ui-border-3)}\";\n\nconst manager = new TooltipManager();\nconst Tooltip = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    // --------------------------------------------------------------------------\n    //\n    //  Properties\n    //\n    // --------------------------------------------------------------------------\n    /** Closes the component when the `referenceElement` is clicked. */\n    this.closeOnClick = false;\n    /**\n     * Offset the position of the component away from the `referenceElement`.\n     *\n     * @default 6\n     */\n    this.offsetDistance = defaultOffsetDistance;\n    /**\n     * Offset the position of the component along the `referenceElement`.\n     */\n    this.offsetSkidding = 0;\n    /**\n     * When true, the component is open.\n     */\n    this.open = false;\n    /**\n     * Determines the type of positioning to use for the overlaid content.\n     *\n     * Using the \"absolute\" value will work for most cases. The component will be positioned inside of overflowing parent containers and will affect the container's layout. The \"fixed\" value should be used to escape an overflowing parent container, or when the reference element's `position` CSS property is \"fixed\".\n     *\n     */\n    this.overlayPositioning = \"absolute\";\n    /**\n     * Determines where the component will be positioned relative to the `referenceElement`.\n     *\n     * @see [LogicalPlacement](https://github.com/Esri/calcite-components/blob/master/src/utils/floating-ui.ts#L25)\n     */\n    this.placement = \"auto\";\n    this.guid = `calcite-tooltip-${guid()}`;\n    this.hasLoaded = false;\n    // --------------------------------------------------------------------------\n    //\n    //  Private Methods\n    //\n    // --------------------------------------------------------------------------\n    this.debouncedReposition = debounce(() => this.reposition(), repositionDebounceTimeout);\n    this.setUpReferenceElement = (warn = true) => {\n      this.removeReferences();\n      this.effectiveReferenceElement = this.getReferenceElement();\n      connectFloatingUI(this, this.effectiveReferenceElement, this.el);\n      const { el, referenceElement, effectiveReferenceElement } = this;\n      if (warn && referenceElement && !effectiveReferenceElement) {\n        console.warn(`${el.tagName}: reference-element id \"${referenceElement}\" was not found.`, {\n          el\n        });\n      }\n      this.addReferences();\n    };\n    this.getId = () => {\n      return this.el.id || this.guid;\n    };\n    this.addReferences = () => {\n      const { effectiveReferenceElement } = this;\n      if (!effectiveReferenceElement) {\n        return;\n      }\n      const id = this.getId();\n      if (\"setAttribute\" in effectiveReferenceElement) {\n        effectiveReferenceElement.setAttribute(ARIA_DESCRIBED_BY, id);\n      }\n      manager.registerElement(effectiveReferenceElement, this.el);\n    };\n    this.removeReferences = () => {\n      const { effectiveReferenceElement } = this;\n      if (!effectiveReferenceElement) {\n        return;\n      }\n      if (\"removeAttribute\" in effectiveReferenceElement) {\n        effectiveReferenceElement.removeAttribute(ARIA_DESCRIBED_BY);\n      }\n      manager.unregisterElement(effectiveReferenceElement);\n    };\n  }\n  offsetDistanceOffsetHandler() {\n    this.debouncedReposition();\n  }\n  offsetSkiddingHandler() {\n    this.debouncedReposition();\n  }\n  openHandler() {\n    this.debouncedReposition();\n  }\n  overlayPositioningHandler() {\n    this.debouncedReposition();\n  }\n  placementHandler() {\n    this.debouncedReposition();\n  }\n  referenceElementHandler() {\n    this.setUpReferenceElement();\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Lifecycle\n  //\n  // --------------------------------------------------------------------------\n  connectedCallback() {\n    this.setUpReferenceElement(this.hasLoaded);\n  }\n  componentDidLoad() {\n    if (this.referenceElement && !this.effectiveReferenceElement) {\n      this.setUpReferenceElement();\n    }\n    this.debouncedReposition();\n    this.hasLoaded = true;\n  }\n  disconnectedCallback() {\n    this.removeReferences();\n    disconnectFloatingUI(this, this.effectiveReferenceElement, this.el);\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Public Methods\n  //\n  // --------------------------------------------------------------------------\n  /** Updates the position of the component. */\n  async reposition() {\n    const { el, effectiveReferenceElement, placement, overlayPositioning, offsetDistance, offsetSkidding, arrowEl } = this;\n    return positionFloatingUI({\n      floatingEl: el,\n      referenceEl: effectiveReferenceElement,\n      overlayPositioning,\n      placement,\n      offsetDistance,\n      offsetSkidding,\n      arrowEl,\n      type: \"tooltip\"\n    });\n  }\n  getReferenceElement() {\n    const { referenceElement, el } = this;\n    return ((typeof referenceElement === \"string\"\n      ? queryElementRoots(el, { id: referenceElement })\n      : referenceElement) || null);\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Render Methods\n  //\n  // --------------------------------------------------------------------------\n  render() {\n    const { effectiveReferenceElement, label, open } = this;\n    const displayed = effectiveReferenceElement && open;\n    const hidden = !displayed;\n    return (h(Host, { \"aria-hidden\": toAriaBoolean(hidden), \"aria-label\": label, \"aria-live\": \"polite\", \"calcite-hydrated-hidden\": hidden, id: this.getId(), role: \"tooltip\" }, h(\"div\", { class: {\n        [FloatingCSS.animation]: true,\n        [FloatingCSS.animationActive]: displayed\n      } }, h(\"div\", { class: CSS.arrow, ref: (arrowEl) => (this.arrowEl = arrowEl) }), h(\"div\", { class: CSS.container }, h(\"slot\", null)))));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"offsetDistance\": [\"offsetDistanceOffsetHandler\"],\n    \"offsetSkidding\": [\"offsetSkiddingHandler\"],\n    \"open\": [\"openHandler\"],\n    \"overlayPositioning\": [\"overlayPositioningHandler\"],\n    \"placement\": [\"placementHandler\"],\n    \"referenceElement\": [\"referenceElementHandler\"]\n  }; }\n  static get style() { return tooltipCss; }\n}, [1, \"calcite-tooltip\", {\n    \"closeOnClick\": [516, \"close-on-click\"],\n    \"label\": [1],\n    \"offsetDistance\": [514, \"offset-distance\"],\n    \"offsetSkidding\": [514, \"offset-skidding\"],\n    \"open\": [516],\n    \"overlayPositioning\": [513, \"overlay-positioning\"],\n    \"placement\": [513],\n    \"referenceElement\": [1, \"reference-element\"],\n    \"effectiveReferenceElement\": [32],\n    \"reposition\": [64]\n  }]);\nfunction defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"calcite-tooltip\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"calcite-tooltip\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Tooltip);\n      }\n      break;\n  } });\n}\ndefineCustomElement();\n\nexport { Tooltip as T, defineCustomElement as d };\n"],"names":["freeGlobal","global","Object","freeSelf","self","root","Function","Symbol","objectProto$1","prototype","hasOwnProperty","nativeObjectToString$1","toString","symToStringTag$1","toStringTag","undefined","nativeObjectToString","symToStringTag","baseGetTag","value","isOwn","call","tag","unmasked","e","result","getRawTag","objectToString","reWhitespace","reTrimStart","baseTrim","string","slice","index","length","test","charAt","trimmedEndIndex","replace","isObject","type","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","toNumber","isObjectLike","isSymbol","other","valueOf","isBinary","now","Date","nativeMax","Math","max","nativeMin","min","debounce","func","wait","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","apply","leadingEdge","setTimeout","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","arguments","this","clearTimeout","cancel","flush","getSide","placement","split","getAlignment","getMainAxisFromPlacement","includes","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","x","width","commonY","y","height","mainAxis","commonAlign","isVertical","coords","getSideObjectFromPadding","padding","top","right","bottom","left","expandPaddingObject","rectToClientRect","rect","async","detectOverflow","middlewareArguments","_await$platform$isEle","platform","rects","elements","strategy","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","offsetParent","getOffsetParent","min$1","max$1","within","min$1$1","max$1$1","hash$1","getOppositePlacement","matched","getAlignmentSides","alignment","mainAlignmentSide","main","cross","hash","start","end","getOppositeAlignmentPlacement","sides","allPlacements","reduce","acc","side","concat","autoPlacement","name","_middlewareData$autoP","_middlewareData$autoP2","_middlewareData$autoP3","_middlewareData$autoP4","_placementsSortedByLe","middlewareData","allowedPlacements","autoAlignment","detectOverflowOptions","placements","filter","getPlacementList","overflow","currentIndex","currentPlacement","isRTL","reset","currentOverflows","allOverflows","overflows","nextPlacement","data","placementsSortedByLeastOverflow","sort","a","b","placementThatFitsOnAllSides","find","every","resetPlacement","flip","_middlewareData$flip","initialPlacement","checkMainAxis","crossAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","flipAlignment","oppositePlacement","getExpandedPlacements","overflowsData","push","_middlewareData$flip$","_middlewareData$flip2","nextIndex","_overflowsData$map$so","map","d","getSideOffsets","isAnySideFullyClipped","some","hide","_temp","offsets","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","offset","diffCoords","mainAxisMulti","crossAxisMulti","rawValue","alignmentAxis","convertValueToCoords","isWindow","document","location","alert","setInterval","getWindow","node","window","ownerDocument","defaultView","getComputedStyle","getNodeName","nodeName","toLowerCase","getUAString","uaData","navigator","userAgentData","brands","item","brand","version","join","userAgent","isHTMLElement","HTMLElement","Element","isShadowRoot","ShadowRoot","isOverflowElement","overflowX","overflowY","isTableElement","isContainingBlock","isFirefox","css","transform","perspective","contain","willChange","isLayoutViewport","round","getBoundingClientRect","includeScale","isFixedStrategy","_win$visualViewport$o","_win$visualViewport","_win$visualViewport$o2","_win$visualViewport2","clientRect","scaleX","scaleY","offsetWidth","offsetHeight","win","addVisualOffsets","visualViewport","offsetLeft","offsetTop","Node","documentElement","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getWindowScrollBarX","getRectRelativeToOffsetParent","isOffsetParentAnElement","isScaled","scroll","offsetRect","clientLeft","clientTop","getParentNode","assignedSlot","parentNode","host","getTrueOffsetParent","position","currentNode","parent","getContainingBlock","getDimensions","getNearestOverflowAncestor","body","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","target","updatedList","getClientRectFromClippingAncestor","clippingParent","html","clientWidth","clientHeight","layoutViewport","getViewportRect","getInnerBoundingClientRect","_element$ownerDocumen","scrollWidth","scrollHeight","direction","getDocumentRect","getClippingAncestors","clippingAncestors","clipperElement","child","rootNode","getRootNode","contains","next","firstClippingAncestor","clippingRect","accRect","clippingAncestor","getElementRects","getClientRects","Array","from","computePosition","config","middleware","statefulPlacement","resetCount","i","fn","nextX","nextY","computePosition$1","repositionDebounceTimeout","effectivePlacements","FloatingCSS","animation","animationActive","getMiddleware","disableFlip","flipPlacements","offsetDistance","offsetSkidding","arrowEl","defaultMiddleware","limiter","mainAxisCoord","crossAxisCoord","maxSide","limitedCoords","arrowDimensions","minProp","maxProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","center","shouldAddOffset","centerOffset","arrow","filterComputedPlacements","el","filteredPlacements","console","warn","tagName","trim","getEffectivePlacement","floatingEl","getElementDir","reverse","positionFloatingUI","referenceEl","overlayPositioning","_a","effectivePlacement","arrowX","arrowY","assign","style","visibility","pointerEvents","setAttribute","cleanupMap","WeakMap","connectFloatingUI","component","disconnectFloatingUI","set","update","ancestorScroll","_ancestorScroll","ancestorResize","_ancestorResize","elementResize","animationFrame","ancestors","forEach","ancestor","addEventListener","passive","frameId","observer","initialUpdate","ResizeObserver","observe","prevRefRect","frameLoop","nextRefRect","requestAnimationFrame","_observer","removeEventListener","disconnect","cancelAnimationFrame","autoUpdate","open","reposition","cleanup","get","delete","defaultOffsetDistance","ceil","hypot","guid","count","out","random","substring","CSS","ARIA_DESCRIBED_BY","manager","constructor","registeredElements","hoverTimeouts","registeredElementCount","queryTooltip","composedPath","registeredElement","pathEl","has","keyDownHandler","event","key","activeTooltipEl","clearHoverTimeout","toggleTooltip","mouseEnterShow","hoverEvent","mouseLeaveHide","clickHandler","clickedTooltip","closeOnClick","focusShow","focusEvent","blurHide","hoverToggle","tooltip","closeExistingTooltip","registerElement","addListeners","unregisterElement","removeListeners","capture","focusTooltip","hoverTooltip","timeoutId","activeTooltipHover","Tooltip","proxyCustomElement","super","__registerHost","__attachShadow","hasLoaded","debouncedReposition","setUpReferenceElement","removeReferences","effectiveReferenceElement","getReferenceElement","referenceElement","addReferences","getId","id","removeAttribute","offsetDistanceOffsetHandler","offsetSkiddingHandler","openHandler","overlayPositioningHandler","placementHandler","referenceElementHandler","connectedCallback","componentDidLoad","disconnectedCallback","queryElementRoots","render","label","displayed","hidden","h","Host","toAriaBoolean","role","class","ref","watchers","defineCustomElement","customElements","define"],"sourceRoot":""}