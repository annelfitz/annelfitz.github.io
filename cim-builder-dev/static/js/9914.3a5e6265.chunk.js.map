{"version":3,"file":"static/js/9914.3a5e6265.chunk.js","mappings":"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CjCsB,KAEN,SAASD,EAAgCN,EAAc2B,GACrD,IAAK3B,EACH,OAAOA,EAET,MAAM4B,EAAS5B,EAAaxH,cAActF,QAAQ,KAAO,EACzD,OAAK0O,EAGE5B,EACJd,QAAQ,UAAW,IACnB2C,UAAU,EAAGD,GACb7K,OAAOiJ,EAAahI,MAAM4J,GAAQ1C,QAAQ,QAAS,KACnDV,MAAM,QACNlH,KAAI,CAACwK,EAAS9Q,IAAiB2Q,EAAJ,IAAN3Q,EAAe8Q,EAAQ5C,QAAQ,MAAO,IAAY4C,KACvEhC,KAAK,KACLZ,QAAQ,KAAM,MATRyC,EAAK3B,GAehB,MAAM+B,EAAgB,KAChBC,EAAa,CACjB,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACAD,EACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,QACA,QACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,QACA,QACA,SAEIE,EAAU,CACd,KACA,KACA,KACA,KACA,KACA,KACA,KACA,QACA,KACAF,EACA,QACA,QACA,QACA,KACA,QACA,KACA,KACA,KACA,QACA,KACA,KACA,KACA,KACA,KACA,KACA,QACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,QACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,QACA,QACA,SAEIG,EAAmB,CACvB,OACA,UACA,OACA,OACA,OACA,WACA,OACA,OACA,UACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,UACA,OACA,OACA,QAEIC,EAA8BC,GAAoBF,EAAiB7B,SAAS+B,GAC5EC,GAAyB,IAAIC,KAAKC,cAAeC,kBAAkBJ,gBACnEK,EAAoD,SAA3BJ,GAAsCF,EAA2BE,GAE5FA,EADA,OAEEK,EAA+BN,GAAoBD,EAA2BC,GAAmBA,EAAkBK,EAOzH,SAASE,EAAmBC,GAA0B,IAAlBC,EAAkB,uDAAR,OAC5C,MAAMC,EAAgC,SAAZD,EAAqBZ,EAAUD,EACzD,OAAKY,EA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","sources":["../node_modules/@esri/calcite-components/dist/esm/focusTrapComponent-299664a8.js","../node_modules/@esri/calcite-components/dist/esm/key-d26d2bfe.js","../node_modules/@esri/calcite-components/dist/esm/loadable-48424264.js","../node_modules/@esri/calcite-components/dist/esm/locale-5313c9c2.js","../node_modules/@esri/calcite-components/dist/esm/observers-3d5b9a3f.js","../node_modules/@esri/calcite-components/dist/esm/t9n-4c805851.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.3\n */\nimport { l as tabbable, m as focusable, n as isTabbable, o as isFocusable, f as focusElement, p as tabbableOptions } from './dom-0e4fb5f9.js';\n\n/*!\n* focus-trap 7.2.0\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   firstTabbableNode: HTMLElement|null,\n    //   lastTabbableNode: HTMLElement|null,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element) {\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) ||\n      // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n      optionValue = optionValue.apply(void 0, params);\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,\n        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          // NOTE: If tabindex is positive (in order to manipulate the tab order separate\n          //  from the DOM order), this __will not work__ because the list of focusableNodes,\n          //  while it contains tabbable nodes, does not sort its nodes in any order other\n          //  than DOM order, because it can't: Where would you place focusable (but not\n          //  tabbable) nodes in that order? They have no order, because they aren't tabbale...\n          // Support for positive tabindex is already broken and hard to manage (possibly\n          //  not supportable, TBD), so this isn't going to make things worse than they\n          //  already are, and at least makes things better for the majority of cases where\n          //  tabindex is either 0/unset or negative.\n          // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375\n          var nodeIdx = focusableNodes.findIndex(function (n) {\n            return n === node;\n          });\n          if (nodeIdx < 0) {\n            return undefined;\n          }\n          if (forward) {\n            return focusableNodes.slice(nodeIdx + 1).find(function (n) {\n              return isTabbable(n, config.tabbableOptions);\n            });\n          }\n          return focusableNodes.slice(0, nodeIdx).reverse().find(function (n) {\n            return isTabbable(n, config.tabbableOptions);\n          });\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n  };\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === doc.activeElement) {\n      return;\n    }\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  var checkFocusIn = function checkFocusIn(e) {\n    var target = getActualTarget(e);\n    var targetContained = findContainerIndex(target) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var target = getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {\n          var firstTabbableNode = _ref2.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var lastTabbableNode = _ref3.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = _destinationGroup.firstTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n\n  var checkKey = function checkKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n      return;\n    }\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n      if (onActivate) {\n        onActivate();\n      }\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      if (onDeactivate) {\n        onDeactivate();\n      }\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n      state.paused = true;\n      removeListeners();\n      return this;\n    },\n    unpause: function unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      return this;\n    }\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nconst trapStack = [];\n/**\n * Helper to set up the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n */\nfunction connectFocusTrap(component) {\n  const { focusTrapEl } = component;\n  if (!focusTrapEl) {\n    return;\n  }\n  if (focusTrapEl.tabIndex == null) {\n    focusTrapEl.tabIndex = -1;\n  }\n  const focusTrapOptions = {\n    clickOutsideDeactivates: true,\n    document: focusTrapEl.ownerDocument,\n    escapeDeactivates: false,\n    fallbackFocus: focusTrapEl,\n    setReturnFocus: (el) => {\n      focusElement(el);\n      return false;\n    },\n    tabbableOptions,\n    trapStack\n  };\n  component.focusTrap = createFocusTrap(focusTrapEl, focusTrapOptions);\n}\n/**\n * Helper to activate the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n */\nfunction activateFocusTrap(component) {\n  if (!component.focusTrapDisabled) {\n    component.focusTrap?.activate();\n  }\n}\n/**\n * Helper to deactivate the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n */\nfunction deactivateFocusTrap(component) {\n  component.focusTrap?.deactivate();\n}\n/**\n * Helper to update the element(s) that are used within the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @example\n * const modal = document.querySelector(\"calcite-modal\");\n * const input = document.createElement(\"calcite-input\");\n * content.appendChild(input);\n * await input.componentOnReady();\n * await modal.updateFocusTrapElements();\n * requestAnimationFrame(() => input.setFocus());\n */\nfunction updateFocusTrapElements(component) {\n  component.focusTrap?.updateContainerElements(component.focusTrapEl);\n}\n\nexport { activateFocusTrap as a, connectFocusTrap as c, deactivateFocusTrap as d, updateFocusTrapElements as u };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.3\n */\nfunction isActivationKey(key) {\n  return key === \"Enter\" || key === \" \";\n}\nconst numberKeys = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\n\nexport { isActivationKey as i, numberKeys as n };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.3\n */\nconst resolveMap = new WeakMap();\nconst promiseMap = new WeakMap();\n/**\n * This helper util sets up the component for the ability to know when the component has been loaded.\n *\n * This should be used in the `componentWillLoad` lifecycle hook.\n *\n * ```\n * componentWillLoad(): void {\n *   setUpLoadableComponent(this);\n * }\n * ```\n *\n * @param component\n */\nfunction setUpLoadableComponent(component) {\n  promiseMap.set(component, new Promise((resolve) => resolveMap.set(component, resolve)));\n}\n/**\n * This helper util lets the loadable component know that it is now loaded.\n *\n * This should be used in the `componentDidLoad` lifecycle hook.\n *\n * ```\n * componentDidLoad(): void {\n *   setComponentLoaded(this);\n * }\n * ```\n *\n * @param component\n */\nfunction setComponentLoaded(component) {\n  resolveMap.get(component)();\n}\n/**\n * This helper util can be used to ensure a component has been loaded (The \"componentDidLoad\" stencil lifecycle method has been called).\n *\n * Requires \"setUpLoadableComponent\" and \"setComponentLoaded\" to be called first.\n *\n * A component developer can await this method before proceeding with any logic that requires a component to be loaded first.\n *\n * ```\n * async setFocus(): Promise<void> {\n *   await componentLoaded(this);\n * }\n * ```\n *\n * @param component\n * @returns Promise<void>\n */\nfunction componentLoaded(component) {\n  return promiseMap.get(component);\n}\n\nexport { setComponentLoaded as a, componentLoaded as c, setUpLoadableComponent as s };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.3\n */\nimport { c as closestElementCrossShadowBoundary, a as containsCrossShadowBoundary } from './dom-0e4fb5f9.js';\nimport { n as numberKeys } from './key-d26d2bfe.js';\nimport { c as createObserver } from './observers-3d5b9a3f.js';\n\nconst defaultMinusSignRegex = new RegExp(\"-\", \"g\");\nconst unnecessaryDecimalRegex = new RegExp(\"\\\\.?0+$\");\n// adopted from https://stackoverflow.com/a/66939244\nclass BigDecimal {\n  constructor(input) {\n    this.add = (num) => BigDecimal.fromBigInt(this.value + new BigDecimal(num).value);\n    this.subtract = (num) => BigDecimal.fromBigInt(this.value - new BigDecimal(num).value);\n    this.multiply = (num) => BigDecimal._divRound(this.value * new BigDecimal(num).value, BigDecimal.SHIFT);\n    this.divide = (num) => BigDecimal._divRound(this.value * BigDecimal.SHIFT, new BigDecimal(num).value);\n    if (input instanceof BigDecimal) {\n      return input;\n    }\n    const [integers, decimals] = String(input).split(\".\").concat(\"\");\n    this.value =\n      BigInt(integers + decimals.padEnd(BigDecimal.DECIMALS, \"0\").slice(0, BigDecimal.DECIMALS)) +\n        BigInt(BigDecimal.ROUNDED && decimals[BigDecimal.DECIMALS] >= \"5\");\n    this.isNegative = input.charAt(0) === \"-\";\n  }\n  getIntegersAndDecimals() {\n    const s = this.value\n      .toString()\n      .replace(defaultMinusSignRegex, \"\")\n      .padStart(BigDecimal.DECIMALS + 1, \"0\");\n    const integers = s.slice(0, -BigDecimal.DECIMALS);\n    const decimals = s.slice(-BigDecimal.DECIMALS).replace(unnecessaryDecimalRegex, \"\");\n    return { integers, decimals };\n  }\n  toString() {\n    const { integers, decimals } = this.getIntegersAndDecimals();\n    return `${this.isNegative ? \"-\" : \"\"}${integers}${decimals.length ? \".\" + decimals : \"\"}`;\n  }\n  formatToParts(formatter) {\n    const { integers, decimals } = this.getIntegersAndDecimals();\n    const parts = formatter.numberFormatter.formatToParts(BigInt(integers));\n    this.isNegative && parts.unshift({ type: \"minusSign\", value: formatter.minusSign });\n    if (decimals.length) {\n      parts.push({ type: \"decimal\", value: formatter.decimal });\n      decimals.split(\"\").forEach((char) => parts.push({ type: \"fraction\", value: char }));\n    }\n    return parts;\n  }\n  format(formatter) {\n    const { integers, decimals } = this.getIntegersAndDecimals();\n    const integersFormatted = `${this.isNegative ? formatter.minusSign : \"\"}${formatter.numberFormatter.format(BigInt(integers))}`;\n    const decimalsFormatted = decimals.length\n      ? `${formatter.decimal}${decimals\n        .split(\"\")\n        .map((char) => formatter.numberFormatter.format(Number(char)))\n        .join(\"\")}`\n      : \"\";\n    return `${integersFormatted}${decimalsFormatted}`;\n  }\n}\n// Configuration: constants\nBigDecimal.DECIMALS = 100; // number of decimals on all instances\nBigDecimal.ROUNDED = true; // numbers are truncated (false) or rounded (true)\nBigDecimal.SHIFT = BigInt(\"1\" + \"0\".repeat(BigDecimal.DECIMALS)); // derived constant\nBigDecimal._divRound = (dividend, divisor) => BigDecimal.fromBigInt(dividend / divisor + (BigDecimal.ROUNDED ? ((dividend * BigInt(2)) / divisor) % BigInt(2) : BigInt(0)));\nBigDecimal.fromBigInt = (bigint) => Object.assign(Object.create(BigDecimal.prototype), { value: bigint });\nfunction isValidNumber(numberString) {\n  return !(!numberString || isNaN(Number(numberString)));\n}\nfunction parseNumberString(numberString) {\n  if (!numberString || !stringContainsNumbers(numberString)) {\n    return \"\";\n  }\n  return sanitizeExponentialNumberString(numberString, (nonExpoNumString) => {\n    let containsDecimal = false;\n    const result = nonExpoNumString\n      .split(\"\")\n      .filter((value, i) => {\n      if (value.match(/\\./g) && !containsDecimal) {\n        containsDecimal = true;\n        return true;\n      }\n      if (value.match(/\\-/g) && i === 0) {\n        return true;\n      }\n      return numberKeys.includes(value);\n    })\n      .reduce((string, part) => string + part);\n    return isValidNumber(result) ? new BigDecimal(result).toString() : \"\";\n  });\n}\n// regex for number sanitization\nconst allLeadingZerosOptionallyNegative = /^([-0])0+(?=\\d)/;\nconst decimalOnlyAtEndOfString = /(?!^\\.)\\.$/;\nconst allHyphensExceptTheStart = /(?!^-)-/g;\nconst isNegativeDecimalOnlyZeros = /^-\\b0\\b\\.?0*$/;\nconst sanitizeNumberString = (numberString) => sanitizeExponentialNumberString(numberString, (nonExpoNumString) => {\n  const sanitizedValue = nonExpoNumString\n    .replace(allHyphensExceptTheStart, \"\")\n    .replace(decimalOnlyAtEndOfString, \"\")\n    .replace(allLeadingZerosOptionallyNegative, \"$1\");\n  return isValidNumber(sanitizedValue)\n    ? isNegativeDecimalOnlyZeros.test(sanitizedValue)\n      ? sanitizedValue\n      : new BigDecimal(sanitizedValue).toString()\n    : nonExpoNumString;\n});\nfunction sanitizeExponentialNumberString(numberString, func) {\n  if (!numberString) {\n    return numberString;\n  }\n  const firstE = numberString.toLowerCase().indexOf(\"e\") + 1;\n  if (!firstE) {\n    return func(numberString);\n  }\n  return numberString\n    .replace(/[eE]*$/g, \"\")\n    .substring(0, firstE)\n    .concat(numberString.slice(firstE).replace(/[eE]/g, \"\"))\n    .split(/[eE]/)\n    .map((section, i) => (i === 1 ? func(section.replace(/\\./g, \"\")) : func(section)))\n    .join(\"e\")\n    .replace(/^e/, \"1e\");\n}\nfunction stringContainsNumbers(string) {\n  return numberKeys.some((number) => string.includes(number));\n}\n\nconst defaultLocale = \"en\";\nconst t9nLocales = [\n  \"ar\",\n  \"bg\",\n  \"bs\",\n  \"ca\",\n  \"cs\",\n  \"da\",\n  \"de\",\n  \"el\",\n  defaultLocale,\n  \"es\",\n  \"et\",\n  \"fi\",\n  \"fr\",\n  \"he\",\n  \"hr\",\n  \"hu\",\n  \"id\",\n  \"it\",\n  \"ja\",\n  \"ko\",\n  \"lt\",\n  \"lv\",\n  \"no\",\n  \"nl\",\n  \"pl\",\n  \"pt-BR\",\n  \"pt-PT\",\n  \"ro\",\n  \"ru\",\n  \"sk\",\n  \"sl\",\n  \"sr\",\n  \"sv\",\n  \"th\",\n  \"tr\",\n  \"uk\",\n  \"vi\",\n  \"zh-CN\",\n  \"zh-HK\",\n  \"zh-TW\"\n];\nconst locales = [\n  \"ar\",\n  \"bg\",\n  \"bs\",\n  \"ca\",\n  \"cs\",\n  \"da\",\n  \"de\",\n  \"de-CH\",\n  \"el\",\n  defaultLocale,\n  \"en-AU\",\n  \"en-CA\",\n  \"en-GB\",\n  \"es\",\n  \"es-MX\",\n  \"et\",\n  \"fi\",\n  \"fr\",\n  \"fr-CH\",\n  \"he\",\n  \"hi\",\n  \"hr\",\n  \"hu\",\n  \"id\",\n  \"it\",\n  \"it-CH\",\n  \"ja\",\n  \"ko\",\n  \"lt\",\n  \"lv\",\n  \"mk\",\n  \"no\",\n  \"nl\",\n  \"pl\",\n  \"pt\",\n  \"pt-PT\",\n  \"ro\",\n  \"ru\",\n  \"sk\",\n  \"sl\",\n  \"sr\",\n  \"sv\",\n  \"th\",\n  \"tr\",\n  \"uk\",\n  \"vi\",\n  \"zh-CN\",\n  \"zh-HK\",\n  \"zh-TW\"\n];\nconst numberingSystems = [\n  \"arab\",\n  \"arabext\",\n  \"bali\",\n  \"beng\",\n  \"deva\",\n  \"fullwide\",\n  \"gujr\",\n  \"guru\",\n  \"hanidec\",\n  \"khmr\",\n  \"knda\",\n  \"laoo\",\n  \"latn\",\n  \"limb\",\n  \"mlym\",\n  \"mong\",\n  \"mymr\",\n  \"orya\",\n  \"tamldec\",\n  \"telu\",\n  \"thai\",\n  \"tibt\"\n];\nconst isNumberingSystemSupported = (numberingSystem) => numberingSystems.includes(numberingSystem);\nconst browserNumberingSystem = new Intl.NumberFormat().resolvedOptions().numberingSystem;\nconst defaultNumberingSystem = browserNumberingSystem === \"arab\" || !isNumberingSystemSupported(browserNumberingSystem)\n  ? \"latn\"\n  : browserNumberingSystem;\nconst getSupportedNumberingSystem = (numberingSystem) => isNumberingSystemSupported(numberingSystem) ? numberingSystem : defaultNumberingSystem;\n/**\n * Gets the locale that best matches the context.\n *\n * @param locale  the BCP 47 locale code\n * @param context - specifies whether the locale code should match in the context of CLDR or T9N (translation)\n */\nfunction getSupportedLocale(locale, context = \"cldr\") {\n  const contextualLocales = context === \"cldr\" ? locales : t9nLocales;\n  if (!locale) {\n    return defaultLocale;\n  }\n  if (contextualLocales.includes(locale)) {\n    return locale;\n  }\n  locale = locale.toLowerCase();\n  // we support both 'nb' and 'no' (BCP 47) for Norwegian but only `no` has corresponding bundle\n  if (locale === \"nb\") {\n    return \"no\";\n  }\n  // we use `pt-BR` as it will have the same translations as `pt`, which has no corresponding bundle\n  if (context === \"t9n\" && locale === \"pt\") {\n    return \"pt-BR\";\n  }\n  if (locale.includes(\"-\")) {\n    locale = locale.replace(/(\\w+)-(\\w+)/, (_match, language, region) => `${language}-${region.toUpperCase()}`);\n    if (!contextualLocales.includes(locale)) {\n      locale = locale.split(\"-\")[0];\n    }\n  }\n  // we can `zh-CN` as base translation for chinese locales which has no corresponding bundle.\n  if (locale === \"zh\") {\n    return \"zh-CN\";\n  }\n  if (!contextualLocales.includes(locale)) {\n    console.warn(`Translations for the \"${locale}\" locale are not available and will fall back to the default, English (en).`);\n    return defaultLocale;\n  }\n  return locale;\n}\nconst connectedComponents = new Set();\n/**\n * This utility sets up internals for messages support.\n *\n * It needs to be called in `connectedCallback` before any logic that depends on locale\n *\n * @param component\n */\nfunction connectLocalized(component) {\n  updateEffectiveLocale(component);\n  if (connectedComponents.size === 0) {\n    mutationObserver?.observe(document.documentElement, {\n      attributes: true,\n      attributeFilter: [\"lang\"],\n      subtree: true\n    });\n  }\n  connectedComponents.add(component);\n}\n/**\n * This is only exported for components that implemented the now deprecated `locale` prop.\n *\n * Do not use this utils for new components.\n *\n * @param component\n */\nfunction updateEffectiveLocale(component) {\n  component.effectiveLocale = getLocale(component);\n}\n/**\n * This utility tears down internals for messages support.\n *\n * It needs to be called in `disconnectedCallback`\n *\n * @param component\n */\nfunction disconnectLocalized(component) {\n  connectedComponents.delete(component);\n  if (connectedComponents.size === 0) {\n    mutationObserver.disconnect();\n  }\n}\nconst mutationObserver = createObserver(\"mutation\", (records) => {\n  records.forEach((record) => {\n    const el = record.target;\n    connectedComponents.forEach((component) => {\n      const inUnrelatedSubtree = !containsCrossShadowBoundary(el, component.el);\n      if (inUnrelatedSubtree) {\n        return;\n      }\n      const closestLangEl = closestElementCrossShadowBoundary(component.el, \"[lang]\");\n      if (!closestLangEl) {\n        component.effectiveLocale = defaultLocale;\n        return;\n      }\n      const closestLang = closestLangEl.lang;\n      component.effectiveLocale =\n        // user set lang=\"\" means unknown language, so we use default\n        closestLangEl.hasAttribute(\"lang\") && closestLang === \"\" ? defaultLocale : closestLang;\n    });\n  });\n});\n/**\n * This util helps resolve a component's locale.\n * It will also fall back on the deprecated `locale` if a component implemented this previously.\n *\n * @param component\n */\nfunction getLocale(component) {\n  return (component.el.lang ||\n    closestElementCrossShadowBoundary(component.el, \"[lang]\")?.lang ||\n    document.documentElement.lang ||\n    defaultLocale);\n}\n/**\n * This util formats and parses numbers for localization\n */\nclass NumberStringFormat {\n  constructor() {\n    this.delocalize = (numberString) => \n    // For performance, (de)localization is skipped if the formatter isn't initialized.\n    // In order to localize/delocalize, e.g. when lang/numberingSystem props are not default values,\n    // `numberFormatOptions` must be set in a component to create and cache the formatter.\n    this._numberFormatOptions\n      ? sanitizeExponentialNumberString(numberString, (nonExpoNumString) => nonExpoNumString\n        .trim()\n        .replace(new RegExp(`[${this._minusSign}]`, \"g\"), \"-\")\n        .replace(new RegExp(`[${this._group}]`, \"g\"), \"\")\n        .replace(new RegExp(`[${this._decimal}]`, \"g\"), \".\")\n        .replace(new RegExp(`[${this._digits.join(\"\")}]`, \"g\"), this._getDigitIndex))\n      : numberString;\n    this.localize = (numberString) => this._numberFormatOptions\n      ? sanitizeExponentialNumberString(numberString, (nonExpoNumString) => isValidNumber(nonExpoNumString.trim())\n        ? new BigDecimal(nonExpoNumString.trim())\n          .format(this)\n          .replace(new RegExp(`[${this._actualGroup}]`, \"g\"), this._group)\n        : nonExpoNumString)\n      : numberString;\n  }\n  get group() {\n    return this._group;\n  }\n  get decimal() {\n    return this._decimal;\n  }\n  get minusSign() {\n    return this._minusSign;\n  }\n  get digits() {\n    return this._digits;\n  }\n  get numberFormatter() {\n    return this._numberFormatter;\n  }\n  get numberFormatOptions() {\n    return this._numberFormatOptions;\n  }\n  /**\n   * numberFormatOptions needs to be set before localize/delocalize is called to ensure the options are up to date\n   */\n  set numberFormatOptions(options) {\n    options.locale = getSupportedLocale(options?.locale);\n    options.numberingSystem = getSupportedNumberingSystem(options?.numberingSystem);\n    if (\n    // No need to create the formatter if `locale` and `numberingSystem`\n    // are the default values and `numberFormatOptions` has not been set\n    (!this._numberFormatOptions &&\n      options.locale === defaultLocale &&\n      options.numberingSystem === defaultNumberingSystem &&\n      // don't skip initialization if any options besides locale/numberingSystem are set\n      Object.keys(options).length === 2) ||\n      // cache formatter by only recreating when options change\n      JSON.stringify(this._numberFormatOptions) === JSON.stringify(options)) {\n      return;\n    }\n    this._numberFormatOptions = options;\n    this._numberFormatter = new Intl.NumberFormat(this._numberFormatOptions.locale, this._numberFormatOptions);\n    this._digits = [\n      ...new Intl.NumberFormat(this._numberFormatOptions.locale, {\n        useGrouping: false,\n        numberingSystem: this._numberFormatOptions.numberingSystem\n      }).format(9876543210)\n    ].reverse();\n    const index = new Map(this._digits.map((d, i) => [d, i]));\n    const parts = new Intl.NumberFormat(this._numberFormatOptions.locale).formatToParts(-12345678.9);\n    this._actualGroup = parts.find((d) => d.type === \"group\").value;\n    // change whitespace group characters that don't render correctly\n    this._group = this._actualGroup.trim().length === 0 ? \" \" : this._actualGroup;\n    this._decimal = parts.find((d) => d.type === \"decimal\").value;\n    this._minusSign = parts.find((d) => d.type === \"minusSign\").value;\n    this._getDigitIndex = (d) => index.get(d);\n  }\n}\nconst numberStringFormatter = new NumberStringFormat();\n\nexport { defaultNumberingSystem as a, getSupportedNumberingSystem as b, connectLocalized as c, disconnectLocalized as d, getSupportedLocale as g, isValidNumber as i, numberStringFormatter as n, parseNumberString as p, sanitizeNumberString as s };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.3\n */\n/**\n * This utility ensures observers are created only for browser contexts.\n *\n * @param type - the type of observer to create\n * @param callback - the observer callback\n * @param options - the observer options\n */\nfunction createObserver(type, callback, options) {\n  const Observer = getObserver(type);\n  return new Observer(callback, options);\n}\nfunction getObserver(type) {\n  // based on https://github.com/whatwg/dom/issues/126#issuecomment-1049814948\n  class ExtendedMutationObserver extends window.MutationObserver {\n    constructor(callback) {\n      super(callback);\n      this.observedEntry = [];\n      this.callback = callback;\n    }\n    observe(target, options) {\n      this.observedEntry.push({ target, options });\n      return super.observe(target, options);\n    }\n    unobserve(target) {\n      const newObservedEntries = this.observedEntry.filter((observed) => observed.target !== target);\n      this.observedEntry = [];\n      this.callback(super.takeRecords(), this);\n      this.disconnect();\n      newObservedEntries.forEach((observed) => this.observe(observed.target, observed.options));\n    }\n  }\n  return (function () {\n    return (type === \"intersection\"\n      ? window.IntersectionObserver\n      : type === \"mutation\"\n        ? ExtendedMutationObserver\n        : window.ResizeObserver);\n  })();\n}\n\nexport { createObserver as c };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.3\n */\nimport { a as getAssetPath } from './index-88b94637.js';\nimport { g as getSupportedLocale } from './locale-5313c9c2.js';\n\nconst componentLangToMessageBundleCache = {};\nasync function getMessageBundle(lang, component) {\n  const key = `${component}_${lang}`;\n  if (componentLangToMessageBundleCache[key]) {\n    return componentLangToMessageBundleCache[key];\n  }\n  componentLangToMessageBundleCache[key] = fetch(getAssetPath(`./assets/${component}/t9n/messages_${lang}.json`))\n    .then((resp) => {\n    if (!resp.ok) {\n      throwMessageFetchError();\n    }\n    return resp.json();\n  })\n    .catch(() => throwMessageFetchError());\n  return componentLangToMessageBundleCache[key];\n}\nfunction throwMessageFetchError() {\n  throw new Error(\"could not fetch component message bundle\");\n}\nfunction mergeMessages(component) {\n  component.messages = {\n    ...component.defaultMessages,\n    ...component.messageOverrides\n  };\n}\n/**\n * This utility sets up the messages used by the component. It should be awaited in the `componentWillLoad` lifecycle hook.\n *\n * @param component\n */\nasync function setUpMessages(component) {\n  component.defaultMessages = await fetchMessages(component, component.effectiveLocale);\n  mergeMessages(component);\n}\nasync function fetchMessages(component, lang) {\n  const { el } = component;\n  const tag = el.tagName.toLowerCase();\n  const componentName = tag.replace(\"calcite-\", \"\");\n  return getMessageBundle(getSupportedLocale(lang, \"t9n\"), componentName);\n}\n/**\n * This utility must be set up for the component to update its default message bundle if the locale changes.\n *\n * It can be set up in **either** of the following ways:\n *\n * 1. called from `LocalizedComponent`'s `onLocaleChange` method or\n * 2. called from a watcher configured to watch `LocalizedComponent`'s `effectiveLocale` prop\n *\n * @param component\n * @param lang\n */\nasync function updateMessages(component, lang) {\n  component.defaultMessages = await fetchMessages(component, lang);\n  mergeMessages(component);\n}\n/**\n * This utility sets up internals for messages support.\n *\n * It needs to be called in `connectedCallback`\n *\n * **Note**: this must be called after `LocalizedComponent`'s `connectLocalized` method.\n *\n * @param component\n */\nfunction connectMessages(component) {\n  component.onMessagesChange = defaultOnMessagesChange;\n}\n/**\n * This utility tears down internals for messages support.\n *\n * It needs to be called in `disconnectedCallback`\n *\n * @param component\n */\nfunction disconnectMessages(component) {\n  component.onMessagesChange = undefined;\n}\nfunction defaultOnMessagesChange() {\n  mergeMessages(this);\n}\n\nexport { connectMessages as c, disconnectMessages as d, setUpMessages as s, updateMessages as u };\n"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","arg","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","String","Number","_toPrimitive","_toPropertyKey","configurable","writable","activeFocusTraps","trapStack","trap","activeTrap","pause","trapIndex","indexOf","splice","unpause","isTabEvent","e","keyCode","isKeyForward","shiftKey","isKeyBackward","delay","fn","setTimeout","findIndex","arr","idx","every","valueOrHandler","_len","params","Array","_key","getActualTarget","event","shadowRoot","composedPath","internalTrapStack","createFocusTrap","elements","userOptions","doc","document","config","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","state","containers","containerGroups","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","delayInitialFocusTimer","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","element","_ref","container","tabbableNodes","contains","find","node","getNodeForOption","optionValue","_len2","_key2","Error","concat","querySelector","getInitialFocusNode","activeElement","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","map","tabbable","tabbableOptions","focusableNodes","focusable","lastTabbableNode","nextTabbableNode","forward","nodeIdx","n","slice","isTabbable","reverse","group","tryFocus","focus","preventScroll","tagName","toLowerCase","select","isSelectableInput","getReturnFocusNode","previousActiveElement","checkPointerDown","clickOutsideDeactivates","deactivate","returnFocus","isFocusable","allowOutsideClick","preventDefault","checkFocusIn","targetContained","Document","stopImmediatePropagation","checkKey","isBackward","destinationNode","containerIndex","containerGroup","startOfGroupIndex","_ref2","destinationGroupIndex","lastOfGroupIndex","_ref3","_destinationGroupIndex","checkKeyNav","checkClick","addListeners","addEventListener","capture","passive","removeListeners","removeEventListener","activate","activateOptions","this","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","then","deactivateOptions","options","onDeactivate","onPostDeactivate","checkCanReturnFocus","clearTimeout","finishDeactivation","updateContainerElements","containerElements","elementsAsArray","Boolean","connectFocusTrap","component","focusTrapEl","tabIndex","focusTrapOptions","ownerDocument","fallbackFocus","setReturnFocus","el","focusElement","focusTrap","activateFocusTrap","focusTrapDisabled","deactivateFocusTrap","updateFocusTrapElements","isActivationKey","numberKeys","resolveMap","WeakMap","promiseMap","setUpLoadableComponent","set","Promise","resolve","setComponentLoaded","get","componentLoaded","defaultMinusSignRegex","RegExp","unnecessaryDecimalRegex","BigDecimal","constructor","add","num","fromBigInt","subtract","multiply","_divRound","SHIFT","divide","integers","decimals","split","BigInt","padEnd","DECIMALS","ROUNDED","isNegative","charAt","getIntegersAndDecimals","s","toString","replace","padStart","formatToParts","formatter","parts","numberFormatter","unshift","type","minusSign","decimal","char","format","join","isValidNumber","numberString","isNaN","parseNumberString","string","number","includes","sanitizeExponentialNumberString","nonExpoNumString","containsDecimal","result","match","reduce","part","repeat","dividend","divisor","bigint","assign","create","prototype","allLeadingZerosOptionallyNegative","decimalOnlyAtEndOfString","allHyphensExceptTheStart","isNegativeDecimalOnlyZeros","sanitizeNumberString","sanitizedValue","test","func","firstE","substring","section","defaultLocale","t9nLocales","locales","numberingSystems","isNumberingSystemSupported","numberingSystem","browserNumberingSystem","Intl","NumberFormat","resolvedOptions","defaultNumberingSystem","getSupportedNumberingSystem","getSupportedLocale","locale","context","contextualLocales","_match","language","region","toUpperCase","console","warn","connectedComponents","Set","connectLocalized","effectiveLocale","lang","closestElementCrossShadowBoundary","documentElement","getLocale","updateEffectiveLocale","size","mutationObserver","observe","attributes","attributeFilter","subtree","disconnectLocalized","delete","disconnect","createObserver","records","record","containsCrossShadowBoundary","closestLangEl","closestLang","hasAttribute","numberStringFormatter","delocalize","_numberFormatOptions","trim","_minusSign","_group","_decimal","_digits","_getDigitIndex","localize","_actualGroup","digits","_numberFormatter","numberFormatOptions","JSON","stringify","useGrouping","index","Map","d","callback","Observer","ExtendedMutationObserver","window","MutationObserver","super","observedEntry","unobserve","newObservedEntries","observed","takeRecords","IntersectionObserver","ResizeObserver","getObserver","componentLangToMessageBundleCache","throwMessageFetchError","mergeMessages","messages","defaultMessages","messageOverrides","async","setUpMessages","fetchMessages","componentName","fetch","getAssetPath","resp","ok","json","catch","getMessageBundle","updateMessages","connectMessages","onMessagesChange","defaultOnMessagesChange","disconnectMessages"],"sourceRoot":""}