"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[1918],{5808:(e,t,n)=>{n.d(t,{O:()=>i});const i={geodesic:0,loxodrome:1,"great-elliptic":2,"normal-section":3,"shape-preserving":4}},11918:(e,t,n)=>{n.r(t),n.d(t,{execute:()=>v,isLoaded:()=>d,load:()=>h,supportsCurves:()=>m});var i=n(83047),r=n(83290);let o;function s(){return!!o&&(0,r.i)()}async function c(){if(!s()){const[e,t]=await Promise.all([Promise.all([n.e(3661),n.e(1878),n.e(9117),n.e(6859),n.e(2764)]).then(n.bind(n,12764)),Promise.all([n.e(3661),n.e(1878),n.e(9117),n.e(8344)]).then(n.bind(n,15756)).then(({injectPe:e})=>e),(0,r.l)()]);o=new e.OperatorGeodeticDistance,t(r.p)}}function l(e,t,n,i){return o.execute(e,t,n,i,null)}var a=n(5808);let u,p,f,m;function d(){return!!u&&s()}async function h(){if(!d()){const[e]=await Promise.all([Promise.all([n.e(3661),n.e(1878),n.e(9117),n.e(3299),n.e(3169)]).then(n.bind(n,78125)),c()]);u=e.fromGeometry,p=e.fromSpatialReference,f=e.getSpatialReference,m=o.supportsCurves()}}function v(e,t,n={}){const{curveType:r="geodesic",unit:o}=n,s=f(e);let c=l(u(e),u(t),p(s),a.O[r]);return c&&o&&(c=(0,i.oU)(c,"meters",o)),c}}}]);