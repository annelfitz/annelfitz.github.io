"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[6558],{6558:(e,t,n)=>{n.r(t),n.d(t,{OperatorGeodeticArea:()=>q});var s=n(55537),i=n(88885),a=n(5247),_=n(39117),r=n(83661),h=n(79187),o=n(95213),m=n(31139),l=n(47591),u=n(31635),p=n(11878),c=n(16859);class g{constructor(e,t,n,s,i=100){this.m_startPt=e.clone(),this.m_endPt=t.clone(),this.m_cE2=s,this.m_cE=Math.sqrt(this.m_cE2),this.m_c1By2e=1/(2*this.m_cE),this.m_cRpu=n.getGCS().getUnit().getUnitToBaseFactor(),this.isPcs=2===n.getCoordinateSystemType(),this.PEProjcs=n.getPECoordSys(),this.m_points=(0,r.d)(2*i,Number.NaN)}setSegmentEndPoints(e,t){this.m_startPt.assign(e),this.m_endPt.assign(t)}makeFunctor(){return e=>{const t=[0,0];t[0]=this.m_startPt.x*(1-e)+this.m_endPt.x*e,t[1]=this.m_startPt.y*(1-e)+this.m_endPt.y*e,this.isPcs&&_.aj.projToGeogCenter(this.PEProjcs,1,t,0);const n=Math.sin(t[1]*this.m_cRpu);return 0===this.m_cE2?n:-Math.log((1-this.m_cE*n)/(1+this.m_cE*n))*this.m_c1By2e+n/(1-this.m_cE2*n*n)}}}function d(e,t,n,s,i){const r=(new a.O).execute(e,t,0,0,i);let o;o=s?(new _.O).execute(r,s,i):r;const m=1===n.getUnit().getUnitToBaseFactor()?Math.PI/180:1,l=new h.Envelope2D;o.queryEnvelope(l);const u=new h.Envelope2D,p=new h.Envelope2D,c=new h.Envelope2D;u.setCoords({xmin:l.xmin,ymin:75*m,xmax:l.xmax,ymax:90*m}),p.setCoords({xmin:l.xmin,ymin:-60*m,xmax:l.xmax,ymax:75*m}),c.setCoords({xmin:l.xmin,ymin:-90*m,xmax:l.xmax,ymax:-60*m}),u.inflateCoords(.01*u.width(),0),p.inflateCoords(.01*p.width(),0),c.inflateCoords(.01*c.width(),0);let g=0;return g+=E(o,u,n,i),g+=E(o,p,n,i),g+=E(o,c,n,i),g}function E(e,t,n,i){const a=(new m.O).execute(e,t,n,i);if(null!==a&&!a.isEmpty()){const e=new h.Envelope2D;a.queryEnvelope(e);const{first:t,second:o}=function(e,t){const n=function(e,t){const n=e.getUnit().getUnitToBaseFactor(),i=t.getCenter();i.scale(180*n/Math.PI);const a=new r.P;a.x=0,a.y=0;let h=0;if(0===h){i.y>45?(a.y=r.o,h=0):i.y<-45?(a.y=-r.o,h=1):i.x>=45&&i.x<135?(a.x=r.o,h=2):i.x>=135||i.x<-135?(a.x=r.o,h=3):i.x<-45&&i.x>=-135?(a.x=-r.o,h=4):(a.x=0,h=5);const e=n*Math.sqrt((0,r.a)(t.xmin-t.xmax)+(0,r.a)(t.ymin-t.ymax)),s=a.clone(),_=t.getCenter();if(_.scale(n),h<2&&(s.x=_.x),r.P.distance(s,_)+.5*e>r.o)return null}const o=P[h];if(null!==o&&o.getGCS().equalHorizontal(e))return o;const m=e.getText(),l=a.x,u=a.y;let p=0,c=-1;6!==h?c=_.aG.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:((0,s.g)(false),p=0,c=_.aG.PE_PRJ_CYLINDRICAL_EQAREA);const g=(0,_.v)("EqualAreaPCS");let d;c===_.aG.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?d=`PROJCS["${g}",${m},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${l}],PARAMETER["Latitude_of_Origin",${u}],UNIT["Meter",1.0]]`:c===_.aG.PE_PRJ_CYLINDRICAL_EQAREA?d=`PROJCS["${g}",${m},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${l}],PARAMETER["Standard_Parallel_1",${p}],PARAMETER["Latitude_of_Origin",${u}],UNIT["Meter",1.0]]`:(0,s.d)("getEqualAreaPcsFixed");const E=(0,_.o)(d);return P[h]&&P[h].destroy(),P[h]=E,E}(e,t);if(null!==n)return(0,r.k)(n,!1);const i=e.getText(),a=e.getUnit().getUnitToBaseFactor(),h=(t.xmin+t.width()/2)*a,o=(t.ymin+t.height()/2)*a;let m=0,l=0,u=-1;t.ymin*a>=75*Math.PI/180||t.ymax*a<=-60*Math.PI/180?u=_.aG.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:t.ymin>0||t.ymax<0?(m=(t.ymin+1/3*t.height())*a,l=(t.ymin+2/3*t.height())*a,u=_.aG.PE_PRJ_ALBERS):(m=(t.ymin+2/3*t.height())*a,u=_.aG.PE_PRJ_CYLINDRICAL_EQAREA);const p=(0,_.v)("EqualAreaPCS");let c;return u===_.aG.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?c=`PROJCS["${p}",${i},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${h}],PARAMETER["Latitude_of_Origin",${o}],UNIT["Meter",1.0]]`:u===_.aG.PE_PRJ_ALBERS?c=`PROJCS["${p}",${i},PROJECTION["Albers"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${h}],PARAMETER["Standard_Parallel_1",${m}],PARAMETER["Standard_Parallel_2",${l}],PARAMETER["Latitude_of_Origin",${o}],UNIT["Meter",1.0]]`:u===_.aG.PE_PRJ_CYLINDRICAL_EQAREA?c=`PROJCS["${p}",${i},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${h}],PARAMETER["Standard_Parallel_1",${m}],PARAMETER["Latitude_of_Origin",${o}],UNIT["Meter",1.0]]`:(0,s.d)("getEqualAreaPCSInstance"),(0,r.k)((0,_.o)(c),!0)}(n,e),m=(0,_.g)(n,t,null),l=(new _.O).execute(a,m,i).calculateArea2D();return o&&t.destroy(),l}return 0}const P=[null,null,null,null,null,null,null];class f{getOperatorType(){return 10314}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}execute(e,t,n){if(0===t.getCoordinateSystemType()&&(0,s.a)(""),e.isEmpty()||e.getDimension()<2)return 0;if((0,s.c)(e),e.getGeometryType()===s.G.enumEnvelope){const s=new i.a;return s.addEnvelope(e,!1),this.execute(s,t,n)}let u=e;e.getDescription().getAttributeCount()>1&&(u=e.clone(),u.dropAllAttributes());const p=(new a.O).execute(u,0,t.getTolerance(0),0,n);let c=null;const E=t.getGCS();E!==t&&(c=(0,_.g)(t,E));let P=(new _.L).execute(p,t,!1,n);return P.isEmpty()?0:(P===e&&(P=e.clone()),t.isPannable()?function(e,t,n){const s=new h.Envelope2D;e.queryEnvelope(s);const a=(0,o.c)(t,s,!0).total(),l=t.getPannableExtent();l.xmin=s.xmin-10*a,l.xmax=s.xmax+10*a;const u=(new m.O).execute(e,l,t,n).getImpl().querySegmentIterator();u.stripAttributes();const p=(0,_.F)();t.querySpheroidData(p);const c=p.e2,d=0===c?2:1,E=new r.P(0,0),P=new r.P(0,0),f=new r.K(0),S=new g(E,P,t,c,100);for(;u.nextPath();)for(;u.hasNextSegment();){const e=u.nextSegment();E.assign(e.getStartXY()),P.assign(e.getEndXY()),S.setSegmentEndPoints(E,P);const t=(0,i.x)(6,0,1,1e-12,1e-15,S.makeFunctor());f.pe((P.x-E.x)*t)}const y=p.majorSemiAxis;return d*y*y*(1-c)*Math.PI*f.getResult()/t.getPannableExtent().width()}(P,t,n):function(e,t,n,s,i){const a=function(e,t,n){const s=e.calculateLength2D(),i=(new l.O).execute(e,t,n)/25e3,a=s/e.getSegmentCount()*2;let _=Math.min(a,s/i);return 0===_&&(_=1),(0,r.k)(_,s/_)}(e,t,i);let _=d(e,a.first,n,s,i),h=1,o=0,m=0;do{if(h++,a.first*=.5,a.first<50*t.getTolerance(0))return _;a.second*=2,m=d(e,a.first,n,s,i),o=Math.abs(m-_),_=m}while(Math.abs(_)>1&&o>1e-8*Math.abs(_)&&(a.second<65e3&&h<8||h<4));return m}(P,t,E,c,n))}}function S(){return{m_p_PCS:new r.P,m_factor:Number.NaN,setValues:y,assign:x}}function y(e,t){this.m_factor=e,this.m_p_PCS.assign(t)}function x(e){this.m_factor=e.m_factor,this.m_p_PCS.assign(e.m_p_PCS)}class A{constructor(e,t,n,s){this.m_ptStart=new o.d,this.m_ptEnd=new o.d,this.m_ptStart.assign(t),this.m_ptEnd.assign(n),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y,this.m_e=Math.sqrt(e),this.m_e2=e,this.m_c1MinusE2=1-e;const i=Math.sin(s);let a;a=0===this.m_e2?2*i:i*((0,r.y)(this.m_e*i)+1/(1-this.m_e2*i*i)),this.m_baseA=a}setSegmentEndPoints(e,t){this.m_ptStart.assign(e),this.m_ptEnd.assign(t),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y}makeFunctor(){return e=>{const t=1-e,n=t*this.m_ptStart.x+e*this.m_ptEnd.x,s=t*this.m_ptStart.y+e*this.m_ptEnd.y,i=t*this.m_ptStart.z+e*this.m_ptEnd.z,a=n*n+s*s,_=i/Math.sqrt(i*i+this.m_c1MinusE2*this.m_c1MinusE2*a);let h;return h=0===this.m_e2?2*_:_*((0,r.y)(this.m_e*_)+1/(1-this.m_e2*_*_)),(this.m_deltaY*n-this.m_deltaX*s)/a*(h-this.m_baseA)}}}function R(){return{sin_phi:Number.NaN,one_p_sin_phi:Number.NaN,one_m_sin_phi:Number.NaN,one_m_e_2_sin_2_phi:Number.NaN,sin_half_phi_pf:Number.NaN,sin_half_phi_pz:Number.NaN,sin_half_asin_e_sin_phi_pf:Number.NaN,sin_half_asin_e_sin_phi_pz:Number.NaN,atanh_sin_phi:Number.NaN,atanh_esin_phi:Number.NaN,make_negative:!1,initialize:C,changeSign:M,assign:T,clone:w}}function C(e,t,n,s){const i=.5*e;this.sin_phi=Math.sin(e);const a=t*this.sin_phi,_=.5*Math.asin(a);this.one_p_sin_phi=1+this.sin_phi,this.one_m_sin_phi=1-this.sin_phi,this.one_m_e_2_sin_2_phi=(1+a)*(1-a),this.sin_half_phi_pf=Math.sin(i+n),this.sin_half_phi_pz=Math.sin(i+s),this.sin_half_asin_e_sin_phi_pf=Math.sin(_+n),this.sin_half_asin_e_sin_phi_pz=Math.sin(_+s),this.atanh_sin_phi=Math.log(this.sin_half_phi_pf/this.sin_half_phi_pz),this.atanh_esin_phi=Math.log(this.sin_half_asin_e_sin_phi_pf/this.sin_half_asin_e_sin_phi_pz)}function M(){this.sin_phi=-this.sin_phi;let e=this.one_p_sin_phi;this.one_p_sin_phi=this.one_m_sin_phi,this.one_m_sin_phi=e,e=this.sin_half_phi_pf,this.sin_half_phi_pf=this.sin_half_phi_pz,this.sin_half_phi_pz=e,e=this.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pf=this.sin_half_asin_e_sin_phi_pz,this.sin_half_asin_e_sin_phi_pz=e,this.atanh_sin_phi=-this.atanh_sin_phi,this.atanh_esin_phi=-this.atanh_esin_phi}function T(e){this.sin_phi=e.sin_phi,this.one_p_sin_phi=e.one_p_sin_phi,this.one_m_sin_phi=e.one_m_sin_phi,this.one_m_e_2_sin_2_phi=e.one_m_e_2_sin_2_phi,this.sin_half_phi_pf=e.sin_half_phi_pf,this.sin_half_phi_pz=e.sin_half_phi_pz,this.sin_half_asin_e_sin_phi_pf=e.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pz=e.sin_half_asin_e_sin_phi_pz,this.atanh_sin_phi=e.atanh_sin_phi,this.atanh_esin_phi=e.atanh_esin_phi,this.make_negative=e.make_negative}function w(){return{...this}}class N{constructor(e,t,n){this.m_transformPCS2GCS=null,this.m_scaleToRadians=new p.T,this.m_scaleToDegrees=new p.T,this.m_progressTracker=n,(0,s.g)(4!==t),this.m_curveType=t,this.m_inputSR=e,e&&0!==e.getCoordinateSystemType()||(0,s.a)(""),this.m_inputGCS=e.getGCS(),this.m_a=0,this.m_eSquared=0,this.m_b=0,this.m_rpu=0}executePolygonGeodeticArea(e){let t,n=e.clone();if(n.dropAllAttributes(),e.hasNonLinearSegments()&&(n=(new a.O).execute(n,0,this.m_inputSR.getTolerance(0),0,this.m_progressTracker)),this.m_inputSR.isPannable()){const e=new h.Envelope2D;n.queryEnvelope(e);const t=this.m_inputSR.getPannableExtent();if(!t.containsEnvelope(e)){const s=t.getCenterX()-e.getCenterX(),i=new p.T;i.setShiftCoords(s,0),n.applyTransformation(i),e.move(s,0);const a=new r.E;t.queryIntervalX(a);const h=new r.E;e.queryIntervalX(h),n=a.contains(h)?(0,_.af)(n,this.m_inputSR):(new _.O).foldInto360RangeGeodetic(n,this.m_inputSR,this.m_curveType)}}if(this.m_transformPCS2GCS?(n=(new _.L).execute(n,this.m_inputSR,!1,this.m_progressTracker),t=n.createInstance(),(0,_.am)(this.m_transformPCS2GCS,n,t,this.m_progressTracker)||(t=(new _.O).execute(n,this.m_transformPCS2GCS,this.m_progressTracker))):t=(new _.L).execute(n,this.m_inputGCS,!1,this.m_progressTracker),t.isEmpty())return 0;if(1===this.m_curveType){const e=(0,_.F)();return this.m_inputGCS.querySpheroidData(e),this.m_a=e.majorSemiAxis,this.m_eSquared=e.e2,this.loxodromeArea(t)}const s=t.getImpl();this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_scaleToRadians.setScale(this.m_rpu),s.applyTransformation(this.m_scaleToRadians),this.m_scaleToDegrees=this.m_scaleToRadians,this.m_scaleToDegrees.invertThis();const i=(0,_.F)();if(this.m_inputGCS.querySpheroidData(i),this.m_a=i.majorSemiAxis,this.m_b=i.minorSemiAxis,this.m_eSquared=i.e2,2===this.m_curveType)return this.executeClippedPolygonGreatEllipticArea(t);{const e={stack:[],error:void 0,hasError:!1};try{const n=_.aY.unit(9101),s=this.m_inputGCS.getPECoordSys(),i=(0,u.mS)(e,s.cloneAlterUnits(n),!1);let a,r,h=this.executeClippedPolygonGeodeticArea(t,i,0),o=0;do{o++,a=this.executeClippedPolygonGeodeticArea(t,i,o),r=Math.abs(a-h),h=a}while(Math.abs(a)>1&&r>1e-8*Math.abs(a)&&o<7);return a}catch(t){e.error=t,e.hasError=!0}finally{(0,u.hk)(e)}}}executeClippedPolygonGeodeticArea(e,t,n){const s={stack:[],error:void 0,hasError:!1};try{const i=new h.Envelope2D;e.queryEnvelope(i);const a=(0,u.mS)(s,this.getEqualAreaPCSInstance(t,i),!1),o=e.clone();(0,_.aZ)(a,o);const m=50,l=o.getImpl().getAttributeStreamRef(0),p=e.getImpl().getAttributeStreamRef(0),c=(0,u.mS)(s,new _.a7,!1),g=(0,u.mS)(s,new _.a7,!1),d=40,E=[0,0],P=(0,r.n)(S,d),f=(0,r.d)(d,-1),y=S(),x=S();let A,R;const C=a;let M=o.calculateArea2D();const T=new r.K(0),w=.5*Math.PI,N=1e-10*Math.abs(M)+1e-6,q=e.getPathCount();let b,v,I,G;const L=new r.P,z=new r.P,D=new r.P,O=new r.P,k=new r.P,F=new r.P;let $,Y;for(v=e.getPathStart(0),b=0;b<q;b++,v=I)for(I=e.getPathEnd(b),l.queryPoint2D(I-1<<1,D),p.queryPoint2D(I-1<<1,L),Math.abs(L.y)>w&&(L.y=(0,r.f)(w,L.y)),G=v;G<I;G++,D.assign(O),L.assign(z)){if(l.queryPoint2D(G<<1,O),p.queryPoint2D(G<<1,z),Math.abs(z.y)>w&&(z.y=(0,r.f)(w,z.y)),$=r.P.distance(D,O),$<m||0===L.y&&0===z.y)continue;_.a8.geodeticDistance(this.m_a,this.m_eSquared,L.x,L.y,z.x,z.y,c,g,null,this.m_curveType);const e=c.val,t=g.val;for(y.setValues(0,D),x.setValues(1,O),R=n,P[0].assign(x),f[0]=n,A=0;A>=0;){Y=.5*(y.m_factor+x.m_factor),_.a8.geodeticCoordinate(this.m_a,this.m_eSquared,L.x,L.y,e*Y,t,c,g,this.m_curveType),k.x=c.val,k.y=g.val,E[0]=k.x,E[1]=k.y,_.aj.geogToProj(C,1,E),F.x=E[0],F.y=E[1];const n=.5*-F.offset(y.m_p_PCS,x.m_p_PCS)*r.P.distance(y.m_p_PCS,x.m_p_PCS);if(T.pe(n),Math.abs(n)>N||Math.abs(n)>0&&R>0)x.setValues(Y,F),A++,P[A].assign(x),Math.abs(n)<=N?(R--,f[A-1]=R,f[A]=R):(R=f[A-1],f[A]=R);else{if(A<=0)break;y.assign(x),A--,x.assign(P[A]),R=f[A]}}}return M+=T.getResult(),Math.abs(M)}catch(e){s.error=e,s.hasError=!0}finally{(0,u.hk)(s)}}executeClippedPolygonGreatEllipticArea(e){const t=[],n=[],s=new r.P,i=new r.P,a=(0,_.a9)(1,this.m_eSquared,new r.P(0,.5*Math.PI)),m=new r.K(0),l=new r.K(0),u=new r.K(0),p=new o.d,c=new o.d,g=new h.Envelope2D;e.queryLooseEnvelope(g);let d=0;g.containsCoords(g.xmin,0)||(d=Math.abs(g.ymin)<Math.abs(g.ymax)?g.ymin:g.ymax);const E=new A(this.m_eSquared,p,c,d),P=this.m_a*this.m_a,f=e.getImpl().querySegmentIterator();for(f.stripAttributes();f.nextPath();)for(;f.hasNextSegment();){const e=f.nextSegment();s.assign(e.getStartXY()),i.assign(e.getEndXY()),i.x-s.x>Math.PI?s.x+=2*Math.PI:i.x-s.x<-Math.PI&&(i.x+=2*Math.PI),this.splitSegmentCrossingItegralThreshold(e,t,n);for(let e of t)p.assign((0,_.a9)(this.m_a,this.m_eSquared,e.getStartXY())),c.assign((0,_.a9)(this.m_a,this.m_eSquared,e.getEndXY())),E.setSegmentEndPoints(p,c),this.adaptiveIntegrationWithRomberg(E,m);for(let e of n){let t=e.getStartXY(),n=e.getEndXY(),s=d;t.y<0&&(n=(0,r.c)(t,t=n),t.y=-t.y,n.y=-n.y,s=-s);const i=(0,_.a9)(1,this.m_eSquared,t),h=(0,_.a9)(1,this.m_eSquared,n),m=Math.min(t.y,n.y),p=(0,_.a_)(this.m_eSquared,t.x,n.x,s,m);l.pe(p);const c=Math.abs((0,_.a_)(this.m_eSquared,t.x,n.x,m,r.o)),g=new o.d;g.setSub(i,a);const E=new o.d;E.setSub(h,a);const f=new o.d;f.setCrossProductVector(g,E);let S=P*(c-.5*f.length());S=(0,r.f)(S,n.x-t.x),u.pe(S)}t.length=0,n.length=0}return u.getResult()+P*(.5*(1-this.m_eSquared)*m.getResult()+l.getResult())}getEqualAreaPCSInstance(e,t){const n=t.getCenterX();let s,i;const a=t.height();let h,o;(h=t.ymin>45*Math.PI/180||t.ymax<45*-Math.PI/180)?s=(0,r.f)(.5*Math.PI,t.getCenterY()):(s=t.getCenterY(),i=t.ymin+a*(2/3));const m=(0,_.v)("EqualAreaPCS"),l=e.toString();return o=h?_.aY.fromString(_.aG.PE_TYPE_PROJCS,`PROJCS["${m}", ${l}, PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing", 0],PARAMETER["Central_Meridian", ${n}], PARAMETER["Latitude_of_Origin", ${s}], UNIT["Meter",1.0]]`):_.aY.fromString(_.aG.PE_TYPE_PROJCS,`PROJCS["${m}", ${l}, PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting", 0],PARAMETER["False_Northing", 0],PARAMETER["Central_Meridian", ${n}],PARAMETER["Standard_Parallel_1", ${i}],PARAMETER["Latitude_of_Origin", ${s}],UNIT["Meter",1.0]]`),o}splitSegmentCrossingItegralThreshold(e,t,n){const s=100,a=400,h=(0,_.a9)(this.m_a,this.m_eSquared,new r.P(0,r.o)),m=(0,_.a9)(this.m_a,this.m_eSquared,new r.P(0,-r.o)),l=this.splitSegmentPassingThroughPole(e);for(let e of l){const l=e.getStartXY(),u=e.getEndXY(),p=(0,_.a9)(this.m_a,this.m_eSquared,l),c=(0,_.a9)(this.m_a,this.m_eSquared,u),g=new r.P,d=new o.d;let E=o.d.sqrDistance(h,p),P=o.d.sqrDistance(p,c);if(E<=s){if(!(P>a)){n.push(new i.L({start:l,end:u}));continue}d.assign(c.sub(p)),d.normalizeThis(),d.assign(p.add(d.mul(20))),g.assign((0,_.ah)(this.m_a,this.m_eSquared,d)),n.push(new i.L({start:l,end:g})),l.assign(g)}if(p.assign((0,_.a9)(this.m_a,this.m_eSquared,l)),E=o.d.sqrDistance(h,c),P=o.d.sqrDistance(p,c),E<=s){if(!(P>a)){n.push(new i.L({start:l,end:u}));continue}d.assign(c.sub(p)),d.normalizeThis(),d.assign(c.sub(d.mul(20))),g.assign((0,_.ah)(this.m_a,this.m_eSquared,d)),n.push(new i.L({start:g,end:u})),u.assign(g)}if(p.assign((0,_.a9)(this.m_a,this.m_eSquared,l)),c.assign((0,_.a9)(this.m_a,this.m_eSquared,u)),E=o.d.sqrDistance(m,p),P=o.d.sqrDistance(p,c),E<=s){if(!(P>a)){n.push(new i.L({start:l,end:u}));continue}d.assign(c.sub(p)),d.normalizeThis(),d.assign(p.add(d.mul(20))),g.assign((0,_.ah)(this.m_a,this.m_eSquared,d)),n.push(new i.L({start:l,end:g})),l.assign(g)}if(p.assign((0,_.a9)(this.m_a,this.m_eSquared,l)),c.assign((0,_.a9)(this.m_a,this.m_eSquared,u)),E=o.d.sqrDistance(m,c),P=o.d.sqrDistance(p,c),E<=s){if(!(P>a)){n.push(new i.L({start:l,end:u}));continue}d.assign(c.sub(p)),d.normalizeThis(),d.assign(c.sub(d.mul(20))),g.assign((0,_.ah)(this.m_a,this.m_eSquared,d)),n.push(new i.L({start:g,end:u})),u.assign(g)}t.push(new i.L({start:l,end:u}))}}splitSegmentPassingThroughPole(e){const t={stack:[],error:void 0,hasError:!1};try{const n=[],s=new o.d,a=new o.d,h=new o.d,m=new r.P,l=20,p=3.124139361,g=10,d=e.getStartXY(),E=e.getEndXY(),P=(0,u.mS)(t,new _.a7,!1);if(_.a8.geodeticDistance(this.m_a,this.m_eSquared,d.x,d.y,E.x,E.y,P,null,null,2),Math.abs(E.x-d.x)>p&&P.val>l){const e=new c.a(new r.P(0,90),d.divide(this.m_rpu),E.divide(this.m_rpu),this.m_inputGCS,2,2);let t=(0,_.ac)(e.makeFunctor(),0,1,1e-10);if(t.second<=g&&t.first>0&&t.first<1)return s.assign((0,_.a9)(this.m_a,this.m_eSquared,d)),a.assign((0,_.a9)(this.m_a,this.m_eSquared,E)),(0,r.x)(s,a,t.first,h),m.assign((0,_.ah)(this.m_a,this.m_eSquared,h)),n.push(new i.L({start:d,end:m})),n.push(new i.L({start:m,end:E})),n;if(e.setPointDistFrom(new r.P(0,-90)),t=(0,_.ac)(e.makeFunctor(),0,1,1e-10),t.second<=g&&t.first>0&&t.first<1)return s.assign((0,_.a9)(this.m_a,this.m_eSquared,d)),a.assign((0,_.a9)(this.m_a,this.m_eSquared,E)),(0,r.x)(s,a,t.first,h),m.assign((0,_.ah)(this.m_a,this.m_eSquared,h)),n.push(new i.L({start:d,end:m})),n.push(new i.L({start:m,end:E})),n}return n.push(new i.L({start:d,end:E})),n}catch(e){t.error=e,t.hasError=!0}finally{(0,u.hk)(t)}}adaptiveIntegrationWithRomberg(e,t){const n=e.makeFunctor();let s=0,a=1,_=n(s),r=n(a);const h=1e-17,o=1e-14;let m=(s+a)/2,l=n(m),u=Math.abs(l-_),p=Math.abs(r-l),c=0;for(;c++<32&&(u/p<.1||p/u<.1);)u<p?(t.pe((0,i.x)(5,s,m,o,h,n)),s=m,_=l):(t.pe((0,i.x)(5,m,a,o,h,n)),a=m,r=l),m=(s+a)/2,l=Math.abs(n(m)),u=Math.abs(l-_),p=Math.abs(r-l);t.pe((0,i.x)(5,s,a,o,h,n))}loxodromeAreaHemi(e,t,n,s,i){const a=n.clone(),_=i.clone();let h,o,m,l,u,p,c,g,d,E,P,f,S,y,x,A;return a.make_negative&&a.changeSign(),_.make_negative&&_.changeSign(),P=s-t,1===Math.abs(a.sin_phi)||1===Math.abs(_.sin_phi)?e.half_qp*P:a.sin_phi===_.sin_phi?(E=.5*e.one_m_e_2*a.sin_phi*(1/a.one_m_e_2_sin_2_phi+(0,r.y)(e.e*a.sin_phi))*P,E):(x=Math.log(_.sin_half_phi_pf*a.sin_half_phi_pz/(_.sin_half_phi_pz*a.sin_half_phi_pf)),A=Math.log(_.sin_half_asin_e_sin_phi_pf*a.sin_half_asin_e_sin_phi_pz/(_.sin_half_asin_e_sin_phi_pz*a.sin_half_asin_e_sin_phi_pf)),1===this.m_eSquared?(u=0,h=.5*(x+_.sin_phi/_.one_m_e_2_sin_2_phi-a.sin_phi/a.one_m_e_2_sin_2_phi),o=0):(u=-2*e.atanh_e_over_e*(Math.log(_.one_p_sin_phi/a.one_p_sin_phi)-e.e*A),h=(x-e.e*A)/e.one_m_e_2,o=(Math.log(_.one_m_e_2_sin_2_phi/a.one_m_e_2_sin_2_phi)+u/e.atanh_e_over_e)/e.one_m_e_2),m=-A*(a.atanh_esin_phi+_.atanh_esin_phi),l=1/a.one_m_e_2_sin_2_phi-1/_.one_m_e_2_sin_2_phi,p=(0,r.z)(_.one_m_sin_phi/e.one_p_e,e.e)-(0,r.z)(a.one_m_sin_phi/e.one_p_e,e.e),c=(0,r.z)(_.one_p_sin_phi/e.one_p_e,e.e)-(0,r.z)(a.one_p_sin_phi/e.one_p_e,e.e),g=(0,r.z)(a.one_m_sin_phi/-e.one_m_e,e.e)-(0,r.z)(_.one_m_sin_phi/-e.one_m_e,e.e),d=(0,r.z)(a.one_p_sin_phi/-e.one_m_e,e.e)-(0,r.z)(_.one_p_sin_phi/-e.one_m_e,e.e),E=.25/h*(o+m+l+u+.5*(p+c+g+d)),E+=e.half_qp,f=.5*e.one_m_e_2*a.sin_phi*(1/a.one_m_e_2_sin_2_phi+(0,r.y)(e.e*a.sin_phi)),S=.5*e.one_m_e_2*_.sin_phi*(1/_.one_m_e_2_sin_2_phi+(0,r.y)(e.e*_.sin_phi)),S<f&&(y=f,f=S,S=y),E<f&&(E=f),E>S&&(E=S),E*=P,E)}loxodromeArea(e){const t=Math.PI/180;let n=0;const s={e:Number.NaN,one_p_e:Number.NaN,one_m_e:Number.NaN,one_m_e_2:Number.NaN,atanh_e_over_e:Number.NaN,half_qp:Number.NaN,f:Number.NaN,z:Number.NaN},i=R(),a=R();s.e=Math.sqrt(this.m_eSquared),s.one_p_e=1+s.e,s.one_m_e=1-s.e,s.one_m_e_2=1-this.m_eSquared,s.atanh_e_over_e=(0,r.y)(s.e),this.m_eSquared>=1?s.half_qp=1:s.half_qp=.5*(1+s.atanh_e_over_e*s.one_m_e_2),s.f=.25*Math.PI,s.z=.75*Math.PI,a.initialize(0,s.e,s.f,s.z);const _=e.getPathCount(),h=new r.P,o=new r.P,m=e.getImpl().getAttributeStreamRef(0);for(let r=0;r<_;r++){const _=e.getPathStart(r),l=e.getPathEnd(r);if(!(l-_<=1)){m.queryPoint2D(2*(l-1),h);for(let e=_;e<l;e++){m.queryPoint2D(2*e,o);const r=h.y*t,l=o.y*t;if(e===_?(i.initialize(r,s.e,s.f,s.z),i.make_negative=!1):i.assign(a),a.initialize(l,s.e,s.f,s.z),a.make_negative=!1,h.y*o.y<0){if(h.y>=90&&o.y<=-90||o.y>=90&&h.y<=-90)return Number.NaN;const e=R();e.initialize(0,s.e,s.f,s.z),e.make_negative=!1;const _=i.atanh_sin_phi-s.e*i.atanh_esin_phi,m=a.atanh_sin_phi-s.e*a.atanh_esin_phi,l=(m*h.x-_*o.x)/(m-_);r<0?(i.make_negative=!0,n-=this.loxodromeAreaHemi(s,h.x*t,i,l*t,e),i.make_negative=!1,n+=this.loxodromeAreaHemi(s,l*t,e,o.x*t,a)):(n+=this.loxodromeAreaHemi(s,h.x*t,i,l*t,e),a.make_negative=!0,n-=this.loxodromeAreaHemi(s,l*t,e,o.x*t,a),a.make_negative=!1)}else h.y>=0?n+=this.loxodromeAreaHemi(s,h.x*t,i,o.x*t,a):(i.make_negative=!0,a.make_negative=!0,n-=this.loxodromeAreaHemi(s,h.x*t,i,o.x*t,a),i.make_negative=!1,a.make_negative=!1);h.assign(o)}}}return this.m_a*n*this.m_a}calculate(e){if(e.isEmpty()||e.getDimension()<2)return 0;if(e.getGeometryType()===s.G.enumEnvelope){const t=new i.a;return t.addEnvelope(e,!1),this.calculate(t)}return this.m_inputSR!==this.m_inputGCS&&null===this.m_transformPCS2GCS&&(this.m_transformPCS2GCS=(0,_.g)(this.m_inputSR,this.m_inputGCS,null)),this.executePolygonGeodeticArea(e)}}class q{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}execute(e,t,n,i){return(0,s.c)(e),4===n?(new f).execute(e,t,i):new N(t,n,i).calculate(e)}}},47591:(e,t,n)=>{n.d(t,{O:()=>g});var s=n(55537),i=n(39117),a=n(88885),_=n(83661),r=n(95213),h=n(79187),o=n(5247),m=n(31139);function l(){return{m_pGcs:new _.P,m_xyz:new r.d,m_factor:Number.NaN,m_geoLength:Number.NaN,setValues:u,setLength:p,assign:c}}function u(e,t,n,s){this.m_factor=e,this.m_pGcs.assign(t),this.m_xyz.assign(s),this.m_geoLength=n}function p(e){this.m_geoLength=e}function c(e){this.m_pGcs.assign(e.m_pGcs),this.m_xyz.assign(e.m_xyz),this.m_factor=e.m_factor,this.m_geoLength=e.m_geoLength}class g{getOperatorType(){return 10315}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}_ExecuteShapePreservingLength(e,t,n,s,a){if(e.hasNonLinearSegments()&&(e=(new o.O).execute(e,0,t.getTolerance(0),0,a)),t.isPannable()){let s=90,_=-90;if(1===n.getUnit().getUnitToBaseFactor()&&(s*=Math.PI/180,_*=Math.PI/180),2===t.getCoordinateSystemType()){let e=null;const n=[0,0,0,0];e=t.getPECoordSys(),n[0]=0,n[1]=s,n[2]=0,n[3]=_,i.aj.geogToProj(e,2,n),s=n[1],_=n[3]}const r=new h.Envelope2D;e.queryEnvelope(r),r.ymin=_,r.ymax=s,e=(new m.O).execute(e,r,t,a)}else{const n=t.getPCSHorizon();if((e=(new i.Q).execute(e,n,t,a))===n){const t=e.clone();e=t}}return e.isEmpty()?0:this._ExecuteIterativeApproach(e,t,n,s,1,a)}_ExecuteIterativeApproach(e,t,n,a,h,o){const m=(0,i.F)();n.querySpheroidData(m);const u=m.majorSemiAxis,p=m.e2,c=n.getUnit().getUnitToBaseFactor(),g=(0,_.n)(l,40),P=(0,_.d)(40,Number.NaN),f=l(),S=l();let y;const x=[0,0,0,0],A=t.getPECoordSys(),R=new _.P,C=new _.P,M=new _.P,T=new _.P,w=new _.P;let N=0;const q=e.querySegmentIterator();for(;q.nextPath();)for(;q.hasNextSegment();){const e=q.nextSegment();R.assign(e.getStartXY()),C.assign(e.getEndXY()),2===t.getCoordinateSystemType()?(x[0]=R.x,x[1]=R.y,x[2]=C.x,x[3]=C.y,i.aj.projToGeog(A,2,x),M.x=x[0]*c,M.y=x[1]*c,T.x=x[2]*c,T.y=x[3]*c):(M.setCoordsPoint2D(R),T.setCoordsPoint2D(C),M.scale(c),T.scale(c));const n=new r.d,a=new r.d;d(u,p,M,n),d(u,p,T,a);let _=E(u,n,a);f.setValues(0,M,Number.NaN,n),S.setValues(1,T,_,a),y=h,g[0].assign(S),P[0]=h;let o=0;for(;;){o>128&&(0,s.d)("iterations exceeded");const n=.5*(f.m_factor+S.m_factor),a=e.getCoord2D(n);2===t.getCoordinateSystemType()?(x[0]=a.x,x[1]=a.y,i.aj.projToGeog(A,1,x),w.x=x[0]*c,w.y=x[1]*c):(w.setCoordsPoint2D(a),w.scale(c)),M.setCoordsPoint2D(f.m_pGcs),T.setCoordsPoint2D(S.m_pGcs);const m=new r.d;d(u,p,w,m);const l=E(u,f.m_xyz,m),R=E(u,S.m_xyz,m);_=S.m_geoLength,Number.isNaN(_)&&(_=E(u,f.m_xyz,S.m_xyz));const C=l+R,q=y===h&&C>=20&&Math.abs(C-_)>1e-8*(_+C);if(o+2<40&&(q||Math.abs(C-_)>0&&y>0))S.setLength(R),g[o].assign(S),S.setValues(n,w,l,m),g[++o].assign(S),q?(y=h,P[o]=h):(y--,P[o-1]=y,P[o]=y);else{if(N+=C,0===o)break;f.assign(S),S.assign(g[--o]),y=P[o]}}}return N}execute(e,t,n){if(t&&0!==t.getCoordinateSystemType()||(0,s.a)(""),e.isEmpty()||e.getDimension()<1)return 0;let _=null;const r=t.getGCS();r!==t&&(_=(0,i.g)(t,r,null));const h=e.getGeometryType();if(h===s.G.enumEnvelope){const s=new a.a;return s.addEnvelope(e,!1),this._ExecuteShapePreservingLength(s,t,r,_,n)}if((0,s.f)(h)){const s=new a.P;return s.addSegment(e,!0),this._ExecuteShapePreservingLength(s,t,r,_,n)}return this._ExecuteShapePreservingLength(e,t,r,_,n)}}function d(e,t,n,s){s.assign((0,i.a9)(e,t,n))}function E(e,t,n){const s=e,i=new r.d;i.setSub(t,n);const a=i.length();return 2*s*Math.asin(a/(2*s))}}}]);