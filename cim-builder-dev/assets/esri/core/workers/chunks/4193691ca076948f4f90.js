"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[1088,6859],{16859:(t,e,i)=>{i.d(e,{G:()=>M,a:()=>f,m:()=>D});var n=i(31635),s=i(55537),o=i(88885),r=i(39117),m=i(95213),a=i(79187),u=i(83661),c=i(11878),h=i(26640),l=i(76061),_=i(31088);class g{getOperatorType(){return 10317}supportsCurves(){return!0}accelerateGeometry(t,e,i){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,i,n,s,o){return new _.OperatorGeodeticDensifyCursor(t,e,4,i,n,s,o)}execute(t,e,i,n,o,r){const m=new l.S([t]),a=this.executeMany(m,e,i,n,o,r).next();return a||(0,s.d)("null output"),a}}var p=i(31139);class y{[Symbol.dispose](){this.m_peR1.destroy(),this.m_peR2.destroy(),this.m_peR3.destroy(),this.m_peR1=null,this.m_peR2=null,this.m_peR3=null}constructor(t,e,i){this.m_peR1=new r.a7,this.m_peR2=new r.a7,this.m_peR3=new r.a7,void 0!==t?this.reset(t,e,i):this.reset(1,0,1)}reset(t,e,i){this.m_a=t,this.m_e2=e,this.m_b=this.m_a*Math.sqrt(1-this.m_e2),this.m_unitToDegree=i,this.m_unitToRad=.017453292519943295*i,this.m_u180=180/this.m_unitToDegree,this.m_u360=360/this.m_unitToDegree}calculateBbox(t,e,i,n){const s=this.m_peR1,o=this.m_peR2,m=this.m_peR3;r.a8.geodeticDistance(this.m_a,this.m_e2,t*this.m_unitToRad,e*this.m_unitToRad,i*this.m_unitToRad,n*this.m_unitToRad,m,s,o,0);const c=Math.cos(s.val),h=Math.cos(o.val+3.141592653589793),l=e*this.m_unitToRad,_=r.ai.phiToEta(this.m_e2,l),g=Math.sin(s.val)*Math.cos(_);let p=e;if(c*h<0){const t=c<0?-1:1,e=Math.acos(Math.abs(g))*t;p=r.ai.etaToPhi(this.m_e2,e)/this.m_unitToRad}let y=(0,u.l)((i-t)*this.m_unitToRad,2*Math.PI);Math.abs(y)>Math.PI&&(y=y>0?y-2*Math.PI:y+2*Math.PI),y/=this.m_unitToRad,i=t+y;const d=new a.Envelope2D;return d.xmin=Math.min(t,i),d.xmax=Math.max(t,i),d.ymin=Math.min(e,n),d.ymin=Math.min(d.ymin,p),d.ymax=Math.max(e,n),d.ymax=Math.max(d.ymax,p),d}minDistanceGeodesic(t,e){const i=d(t),n=d(e);if(i&&n)return this.lowerDistanceGeodetic_(t.xmin,t.ymin,e.xmin,e.ymin);const s=this.normalizeGeodesic_(e,t);return function(t,e){return e.xmax<t.xmin||e.xmin>t.xmax||e.ymax<t.ymin||e.ymin>t.ymax}(t,s)?t.ymin>=s.ymax?this.minDistanceGeodesicUpDown_(t,s):s.ymin>=t.ymax?this.minDistanceGeodesicUpDown_(s,t):t.xmin>s.xmax?this.minDistanceGeodesicLeftRight_(s,t):this.minDistanceGeodesicLeftRight_(t,s):0}normalizeGeodesic_(t,e){const i=t.clone(),n=t.clone();let s=x(i,e);if(0===s)return i;for(;n.xmax>e.xmin;){n.xmin-=this.m_u360,n.xmax-=this.m_u360;const t=x(n,e);if(t<s&&(i.assign(n),s=t,0===s))return i}for(n.assign(t);n.xmin<e.xmax;){n.xmin+=this.m_u360,n.xmax+=this.m_u360;const t=x(n,e);if(t<s&&(i.assign(n),s=t,0===s))return i}return i}lowerDistanceGeodetic_(t,e,i,n){const s=this.m_peR1;{const o=this.m_b*this.m_b/this.m_a,m=r.ai.phiToPhig(this.m_e2,this.m_unitToRad*e),a=r.ai.phiToPhig(this.m_e2,this.m_unitToRad*n);r.a8.geodeticDistance(o,0,this.m_unitToRad*t,m,this.m_unitToRad*i,a,s,null,null,0)}return s.val}minDistanceGeodesicUpDown_(t,e){if(e.xmin<=t.xmin?e.xmax>=t.xmin:t.xmax>=e.xmin)return this.lowerDistanceGeodetic_(0,t.ymin,0,e.ymax);if(e.xmin>t.xmax){const i=this.lowerDistanceGeodeticSegMeridional_(t.xmax,t.ymin,t.ymax,e.xmin,e.ymin,e.ymax);if(e.xmax-t.xmin<this.m_u180)return i;const n=this.lowerDistanceGeodeticSegMeridional_(t.xmin,t.ymin,t.ymax,e.xmax,e.ymin,e.ymax);return Math.min(i,n)}{const i=this.lowerDistanceGeodeticSegMeridional_(t.xmin,t.ymin,t.ymax,e.xmax,e.ymin,e.ymax);if(t.xmax-e.xmin<this.m_u180)return i;const n=this.lowerDistanceGeodeticSegMeridional_(t.xmax,t.ymin,t.ymax,e.xmin,e.ymin,e.ymax);return Math.min(i,n)}}minDistanceGeodesicLeftRight_(t,e){let i=Math.abs(t.xmax-e.xmin);for(;i>this.m_u180;)i-=this.m_u360;let n=Math.abs(t.xmin-e.xmax);for(;n>this.m_u180;)n-=this.m_u360;return Math.abs(i)<=Math.abs(n)?this.minDistanceGeodesicLeftRightNormalized_(t,e):this.minDistanceGeodesicLeftRightNormalized_(e,t)}minDistanceGeodesicLeftRightNormalized_(t,e){let i,n;return i=this.lowerDistanceGeodetic_(t.xmax,t.ymin,e.xmin,e.ymin),t.ymin>=e.ymin&&t.ymin<=e.ymax&&(n=this.lowerDistanceGeodeticPtMeridional_(t.xmax,t.ymin,e.xmin,e.ymin,e.ymax),i=Math.min(i,n)),e.ymin>=t.ymin&&e.ymin<=t.ymax&&(n=this.lowerDistanceGeodeticPtMeridional_(e.xmin,e.ymin,t.xmax,t.ymin,t.ymax),i=Math.min(i,n)),n=this.lowerDistanceGeodetic_(t.xmax,t.ymax,e.xmin,e.ymax),i=Math.min(i,n),t.ymax>=e.ymin&&t.ymax<=e.ymax&&(n=this.lowerDistanceGeodeticPtMeridional_(t.xmax,t.ymax,e.xmin,e.ymin,e.ymax),i=Math.min(i,n)),e.ymax>=t.ymin&&e.ymax<=t.ymax&&(n=this.lowerDistanceGeodeticPtMeridional_(e.xmin,e.ymax,t.xmax,t.ymin,t.ymax),i=Math.min(i,n)),i}lowerDistanceGeodeticSegMeridional_(t,e,i,n,s,o){let r=this.lowerDistanceGeodeticPtMeridional_(t,e,n,s,o);const m=this.lowerDistanceGeodeticPtMeridional_(t,i,n,s,o);let a=this.lowerDistanceGeodeticPtMeridional_(n,s,t,e,i);const u=this.lowerDistanceGeodeticPtMeridional_(n,o,t,e,i);return r=Math.min(r,m),a=Math.min(a,u),Math.min(r,a)}lowerDistanceGeodeticPtMeridional_(t,e,i,n,s){const o=this.m_b*this.m_b/this.m_a,a=r.ai.phiToPhig(this.m_e2,this.m_unitToRad*e),c=r.ai.phiToPhig(this.m_e2,this.m_unitToRad*n),h=r.ai.phiToPhig(this.m_e2,this.m_unitToRad*s),l=this.m_peR1,_=this.m_peR2;r.a8.geodeticDistance(o,0,this.m_unitToRad*i,c,this.m_unitToRad*t,a,l,null,null,0),r.a8.geodeticDistance(o,0,this.m_unitToRad*i,h,this.m_unitToRad*t,a,_,null,null,0);const g=(0,r.a9)(1,0,new u.P(this.m_unitToRad*t,a)),p=(0,r.a9)(1,0,new u.P(this.m_unitToRad*i,c)),y=(0,r.a9)(1,0,new u.P(this.m_unitToRad*i,h));let d=new m.d;d.setCrossProductVector(p,y);const x=p.dotProduct(y);if(d.length()<1.568e-10)return x>=0?Math.min(l.val,_.val):0;d=d.getUnitVector();let P=new m.d;if(P.setCrossProductVector(d,g),P.length()<1.568e-10)return Math.min(l.val,_.val)-1e-5*o;P=P.getUnitVector();let D=g.sub(d.mul(g.dotProduct(d)));{const e=new m.d;e.setCrossProductVector(p,D);const i=new m.d;i.setCrossProductVector(D,y);let n=d.dotProduct(e)>0&&d.dotProduct(i)>0;if(n||(D.negateThis(),e.setCrossProductVector(p,D),i.setCrossProductVector(D,y),n=d.dotProduct(e)>0&&d.dotProduct(i)>0),n){D=D.getUnitVector();const e=(0,r.ah)(1,0,D),i=this.m_peR3;r.a8.geodeticDistance(o,0,this.m_unitToRad*t,a,e.x,e.y,i,null,null,0);const n=Math.min(l.val,_.val);return Math.min(n,i.val)}}return Math.min(l.val,_.val)}}function d(t){return t.xmin===t.xmax&&t.ymin===t.ymax}function x(t,e){let i,n=0;return i=t.xmin-e.xmax,i>n&&(n=i),i=e.xmin-t.xmax,i>n&&(n=i),n}class P{}function D(t){return{outPoint:void 0===t?new u.P:t.clone()}}function v(t,e){t.outPoint.assign(e.outPoint)}function G(){return new a.Envelope2D}class f{constructor(t,e,i,n,s=0,o=4){this.m_ptDistFrom=new u.P,this.m_segStartPt=new u.P,this.m_segEndPt=new u.P,this.m_geodeticLength=new r.a7,this.m_az12=new r.a7,this.m_minGeodeticDist=new r.a7,this.m_segStartPt3d=new m.d,this.m_segEndPt3d=new m.d,this.m_sr=n,this.m_distCurveType=s,this.m_segCurveType=o,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=2===this.m_sr.getCoordinateSystemType()&&this.m_sr.isPannable();const a=(0,r.F)();this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_eSquared=a.e2,this.setPointDistFrom(t),this.setSegmentEndPoints(e,i)}setSegmentEndPoints(t,e){this.m_segStartPt.assign(t),this.m_segEndPt.assign(e),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),2===this.m_segCurveType&&(this.m_segStartPt3d.assign((0,r.a9)(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign((0,r.a9)(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(t){this.m_ptDistFrom.assign(t),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(t){this.m_segCurveType=t}setDistanceCurveType(t){this.m_distCurveType=t}makeFunctor(){return t=>{let e;switch(this.m_segCurveType){case 0:case 1:case 3:{const i={stack:[],error:void 0,hasError:!1};try{const s=(0,n.mS)(i,new r.a7,!1),o=(0,n.mS)(i,new r.a7,!1);r.a8.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*t,this.m_az12.val,s,o,this.m_segCurveType),e=new u.P(s.val,o.val);break}catch(t){i.error=t,i.hasError=!0}finally{(0,n.hk)(i)}}case 2:{const i=m.d.lerp(this.m_segStartPt3d,this.m_segEndPt3d,t);e=(0,r.ah)(this.m_a,this.m_eSquared,i);break}case 4:e=u.P.lerp(this.m_segStartPt,this.m_segEndPt,t),this.m_bIsPannablePcs&&((0,r.ab)(this.m_sr,0,[e],1),e.mulThis(this.m_rpu));break;default:(0,s.d)("Invalid curve type")}return r.a8.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,e.x,e.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:r.a8.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=u.P.distance(this.m_segStartPt,this.m_segEndPt);break;default:(0,s.d)("Invalid curve type")}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}}function S(){return new P}class M{[Symbol.dispose](){this.m_envHelper[Symbol.dispose]()}constructor(t,e,i,n,s){this.m_boxGeomA=G(),this.m_boxGeomB=G(),this.m_envGeomA=new a.Envelope2D,this.m_envGeomB=new a.Envelope2D,this.m_progressCounter=0,this.m_transformPCS2GCS=null,this.m_segmentBoxesA=new Map,this.m_segmentBoxesB=new Map,this.m_boundaryPtsA=[],this.m_boundaryPtsB=[],this.m_scaleToRadians=new c.T,this.m_scaleToDegrees=new c.T,this.m_inputSR=t,this.m_distCurveType=e,this.m_progressTracker=i,this.m_maxDistance=n,this.m_maxDeviation=s,this.m_inputGCS=t.getGCS(),this.m_peGeogcs=this.m_inputGCS.getPECoordSys(),this.m_tolerance=0;const o=(0,r.F)();this.m_inputGCS.querySpheroidData(o),this.m_a=o.majorSemiAxis,this.m_eSquared=o.e2,this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_envHelper=new y(this.m_a,this.m_eSquared,1),4===this.m_distCurveType&&(this.m_distCurveType=0),this.m_boxGeomA.setEmpty(),this.m_boxGeomB.setEmpty(),this.m_envGeomA.setEmpty(),this.m_envGeomB.setEmpty(),this.m_bIsPannablePcs=2===this.m_inputSR.getCoordinateSystemType()&&this.m_inputSR.isPannable()}progress(t=!1){}calculate(t,e,i,n){const s=D(),o=D();if(t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB),this.checkGeometriesIntersect(t,e,s,o))return i&&v(i,s),n&&v(n,o),0;const r=this.prepareGeometry(t);if(r.isEmpty())return Number.NaN;const m=this.prepareGeometry(e);if(m.isEmpty())return Number.NaN;this.m_tolerance=this.computeTolerance(r,m);const a=this._ExecuteBruteForce(r,m,s,o);return a>=this.m_maxDistance?Number.NaN:(i&&(this.prepareOutput(s),v(i,s)),n&&(this.prepareOutput(o),v(n,o)),a)}createDistanceFunctor(t,e,i){const n=new f(t,e,i,this.m_inputSR,this.m_distCurveType);return this.m_bIsPannablePcs||1===this.m_inputSR.getCoordinateSystemType()||n.setSegmentCurveType(2),n}_NormalizeAndProject(t){if(this.m_inputSR.isPannable()&&(t=(new r.O).foldInto360Range(t,this.m_inputSR)),2===this.m_inputSR.getCoordinateSystemType()){const e=(0,r.g)(this.m_inputSR,this.m_inputGCS,null);t=(new r.O).execute(t,e,this.m_progressTracker)}return t}_ExecuteBruteForce(t,e,i,n){switch(t.getGeometryType()){case s.G.enumPoint:return this.calculateDistanceGeodeticPointGeometry(t,e,i,n);case s.G.enumMultiPoint:return this.calculateDistanceGeodeticMultipointGeometry(t,e,i,n);case s.G.enumPolyline:case s.G.enumPolygon:case s.G.enumEnvelope:return this.calculateDistanceGeodeticMultipathGeometry(t,e,i,n);default:(0,s.a)("")}}calculateDistanceGeodeticPointGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:return this.calculateDistanceGeodeticPointPoint(t,e,i,n);case s.G.enumMultiPoint:return this.calculateDistanceGeodeticPointMultipoint(t,e,i,n);case s.G.enumPolyline:case s.G.enumPolygon:return this.calculateDistanceGeodeticPointMultipath(t,e,i,n);default:(0,s.a)("")}}calculateDistanceGeodeticPointPoint(t,e,i,s){const o={stack:[],error:void 0,hasError:!1};try{const m=t.getXY();m.scale(this.m_rpu);const a=e.getXY();a.scale(this.m_rpu),i.outPoint.assign(m),s.outPoint.assign(a);const u=(0,n.mS)(o,new r.a7,!1);return r.a8.geodeticDistance(this.m_a,this.m_eSquared,m.x,m.y,a.x,a.y,u,null,null,this.m_distCurveType),u.val}catch(t){o.error=t,o.hasError=!0}finally{(0,n.hk)(o)}}calculateDistanceGeodeticPointMultipoint(t,e,i,s){const o={stack:[],error:void 0,hasError:!1};try{this.computeEnvelopesAndBoxes(t,e);const a=this.estimateMinimumDistance(i,s);let c=a<this.m_maxDistance?a:this.m_maxDistance;const h=t.getXY();h.scale(this.m_rpu),i.outPoint.assign(h);const l=(0,r.a9)(this.m_a,this.m_eSquared,h),_=new u.P,g=e.getImpl(),p=(0,n.mS)(o,new r.a7,!1),y=g.getPointCount();for(let t=0;t<y;++t){g.queryXY(t,_),_.scale(this.m_rpu);const e=(0,r.a9)(this.m_a,this.m_eSquared,_);if(!(m.d.distance(l,e)>c)&&!(this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA,this.m_boxGeomB)>c)&&(r.a8.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,_.x,_.y,p,null,null,this.m_distCurveType),p.val<c&&(c=p.val,s.outPoint=_,0===c)))return c}return c===this.m_maxDistance?Number.POSITIVE_INFINITY:c}catch(t){o.error=t,o.hasError=!0}finally{(0,n.hk)(o)}}calculateDistanceGeodeticPointMultipath(t,e,i,o){const m={stack:[],error:void 0,hasError:!1};try{const a=new u.P,c=new u.P;a.assign(t.getXY()),c.assign(t.getXY()),i.outPoint.assign(c.mul(this.m_rpu)),this.m_bIsPannablePcs&&(0,r.aa)(this.m_inputSR,[a],1,!1),this.computeEnvelopesAndBoxes(t,e);const h=this.estimateMinimumDistance(i,o);let l=h<this.m_maxDistance?h:this.m_maxDistance;const _=e.getImpl(),g=new u.P(0,0),p=new u.P(0,0),y=[1],d=this.canUseSpatialTree(t,e),x=S();d&&this.buildSpatialTree(x,e);const P=G();P.setCoords({xmin:c.x,ymin:c.y,xmax:c.x,ymax:c.y});const D=(0,n.mS)(m,this.createDistanceFunctor(c,g,p),!1),v=_.querySegmentIterator();if(v.stripAttributes(),d)(0,s.g)(0);else for(;v.nextPath();)for(;v.hasNextSegment();){const t=v.nextSegment(),e=this.findOrComputeBoxSegment(v.getStartPointIndex(),t,this.m_segmentBoxesB);if(this.m_envHelper.minDistanceGeodesic(P,e)>l)continue;const i=this.calculateDistanceGeodeticPointSegment(a,c,t,y,D);if(i.second<l&&(this.updateOutputSegment(o,t,i.first),l=i.second,0===l))return 0}return l===this.m_maxDistance?Number.POSITIVE_INFINITY:l}catch(t){m.error=t,m.hasError=!0}finally{(0,n.hk)(m)}}calculateDistanceGeodeticMultipointGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:return this.calculateDistanceGeodeticPointMultipoint(e,t,n,i);case s.G.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipoint(t,e,i,n);case s.G.enumPolyline:case s.G.enumPolygon:case s.G.enumEnvelope:return this.calculateDistanceGeodeticMultipointMultipath(t,e,i,n);default:(0,s.a)("")}}calculateDistanceGeodeticMultipointMultipoint(t,e,i,s){const o={stack:[],error:void 0,hasError:!1};try{const a=(0,n.mS)(o,new r.a7,!1);this.computeEnvelopesAndBoxes(t,e);const c=this.estimateMinimumDistance(i,s);let h=c<this.m_maxDistance?c:this.m_maxDistance;const l=new u.P,_=new u.P,g=t.getImpl(),p=e.getImpl(),y=G(),d=g.getPointCount(),x=p.getPointCount();for(let t=0;t<d;++t){if(l.assign(g.getXY(t)),y.setCoords({xmin:l.x,ymin:l.y,xmax:l.x,ymax:l.y}),this.m_envHelper.minDistanceGeodesic(y,this.m_boxGeomB)>h)continue;l.scale(this.m_rpu);const e=(0,r.a9)(this.m_a,this.m_eSquared,l);for(let t=0;t<x;++t){_.assign(p.getXY(t)),_.scale(this.m_rpu);const n=(0,r.a9)(this.m_a,this.m_eSquared,_);if(!(m.d.distance(e,n)>=h)&&(r.a8.geodeticDistance(this.m_a,this.m_eSquared,l.x,l.y,_.x,_.y,a,null,null,this.m_distCurveType),a.val<h&&(i.outPoint.assign(l),s.outPoint.assign(_),h=a.val,0===h)))return h}}return h===this.m_maxDistance?Number.POSITIVE_INFINITY:h}catch(t){o.error=t,o.hasError=!0}finally{(0,n.hk)(o)}}calculateDistanceGeodeticMultipointMultipath(t,e,i,o){const m={stack:[],error:void 0,hasError:!1};try{const a=e.getImpl().querySegmentIterator();a.stripAttributes(),this.computeEnvelopesAndBoxes(t,e);const c=this.estimateMinimumDistance(i,o);let h=c<this.m_maxDistance?c:this.m_maxDistance;const l=new u.P,_=new u.P(0,0),g=new u.P(0,0),p=new u.P(0,0),y=[0],d=G(),x=(0,n.mS)(m,this.createDistanceFunctor(_,g,p),!1),P=S(),D=this.canUseSpatialTree(t,e);D&&this.buildSpatialTree(P,e);const v=t.getPointCount();for(let e=0;e<v;++e)if(l.assign(t.getXY(e)),_.assign(t.getXY(e)),this.m_bIsPannablePcs&&(0,r.aa)(this.m_inputSR,[l],1,!1),d.setCoords({xmin:_.x,ymin:_.y,xmax:_.x,ymax:_.y}),!(this.m_envHelper.minDistanceGeodesic(d,this.m_boxGeomB)>h))if(x.setPointDistFrom(_),D)(0,s.g)(0);else{for(;a.nextPath();)for(;a.hasNextSegment();){const t=a.nextSegment();if(this.m_envHelper.minDistanceGeodesic(d,this.findOrComputeBoxSegment(a.getStartPointIndex(),t,this.m_segmentBoxesB))>h)continue;const e=this.calculateDistanceGeodeticPointSegment(l,_,t,y,x);if(e.second<h&&(i.outPoint.assign(_.mul(this.m_rpu)),this.updateOutputSegment(o,t,e.first),h=e.second,0===h))return 0}a.resetToFirstPath()}return h===this.m_maxDistance?Number.POSITIVE_INFINITY:h}catch(t){m.error=t,m.hasError=!0}finally{(0,n.hk)(m)}}calculateDistanceGeodeticMultipathGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:return this.calculateDistanceGeodeticPointMultipath(e,t,n,i);case s.G.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipath(e,t,n,i);case s.G.enumPolyline:case s.G.enumPolygon:case s.G.enumEnvelope:return this.calculateDistanceGeodeticMultipathMultipath(t,e,i,n);default:(0,s.a)("")}}calculateDistanceGeodeticMultipathMultipath(t,e,i,n){const s=[t],o=[e],r=this.swapGeometries(s,o),m=s[0],a=o[0];this.computeEnvelopesAndBoxes(s[0],o[0]);const c=this.estimateMinimumDistance(i,n),h=this.calculateDistanceGeodeticMultipathMultipath_(m,a,i,n,c);return r&&(n.outPoint=(0,u.c)(i.outPoint,i.outPoint=n.outPoint)),h}calculateDistanceGeodeticMultipathMultipath_(t,e,i,m,a=Number.MAX_VALUE){const c={stack:[],error:void 0,hasError:!1};try{let l=a;const _=new u.P(0,0),g=new u.P,p=new u.P(0,0),y=new u.P,d=new u.P(0,0),x=new u.P,P=new u.P,D=new u.P,v=[new u.P],f=[0],M=[0],b=G(),E=G(),T=(0,n.mS)(c,this.createDistanceFunctor(d,_,p),!1),I=S(),N=this.canUseSpatialTree(t,e);N&&this.buildSpatialTree(I,e);const w=e.querySegmentIterator();w.stripAttributes();const B=new o.S,C=(0,h.s)(t);for(let e=0;e<C.length;++e){const n=C[e];t.getSegmentBuffer(n,B,!0);const o=B.get();if(b.assign(this.findOrComputeBoxSegment(n,o,this.m_segmentBoxesA)),N)(0,s.g)(0);else{if(d.assign(o.getStartXY()),x.assign(o.getStartXY()),P.assign(o.getEndXY()),D.assign(o.getEndXY()),this.m_bIsPannablePcs&&((0,r.ab)(this.m_inputSR,0,[x],1),(0,r.ab)(this.m_inputSR,0,[D],1)),this.m_envHelper.minDistanceGeodesic(b,this.m_boxGeomB)>l)continue;for(;w.nextPath();){for(;w.hasNextSegment();){const t=w.nextSegment();if(_.assign(t.getStartXY()),g.assign(t.getStartXY()),p.assign(t.getEndXY()),y.assign(t.getEndXY()),o.intersect(t,v,f,M,this.m_tolerance))return this.updateOutputSegment(i,o,f[0]),this.updateOutputSegment(m,t,M[0]),0;if(this.m_bIsPannablePcs&&((0,r.ab)(this.m_inputSR,0,[g],1),(0,r.ab)(this.m_inputSR,0,[y],1)),E.assign(this.findOrComputeBoxPoint(w.getStartPointIndex(),g,y,this.m_segmentBoxesB)),this.m_envHelper.minDistanceGeodesic(b,E)>l)continue;T.setSegmentEndPoints(_,p),T.setPointDistFrom(x);let e=(0,r.ac)(T.makeFunctor(),0,1,1e-10);if(e.second<l&&(i.outPoint.assign(x.mul(this.m_rpu)),this.updateOutputSegment(m,t,e.first),l=e.second,0===l))break;if(T.setPointDistFrom(D),e=(0,r.ac)(T.makeFunctor(),0,1,1e-10),e.second<l&&(i.outPoint.assign(D.mul(this.m_rpu)),this.updateOutputSegment(m,t,e.first),l=e.second,0===l))break;if(T.setSegmentEndPoints(d,P),T.setPointDistFrom(g),e=(0,r.ac)(T.makeFunctor(),0,1,1e-10),e.second<l&&(this.updateOutputSegment(i,o,e.first),m.outPoint.assign(g.mul(this.m_rpu)),l=e.second,0===l))break;if(T.setPointDistFrom(y),e=(0,r.ac)(T.makeFunctor(),0,1,1e-10),e.second<l&&(this.updateOutputSegment(i,o,e.first),m.outPoint.assign(y.mul(this.m_rpu)),l=e.second,0===l))break}if(0===l)return 0}w.resetToFirstPath()}}return l===this.m_maxDistance?Number.POSITIVE_INFINITY:l}catch(t){c.error=t,c.hasError=!0}finally{(0,n.hk)(c)}}calculateDistanceGeodeticPointSegment(t,e,i,n,s){const o=i.getStartXY(),m=i.getEndXY();return i.intersectPoint(t,n,this.m_tolerance)?(0,u.k)(n[0],0):(s.setPointDistFrom(e),s.setSegmentEndPoints(o,m),(0,r.ac)(s.makeFunctor(),0,1,1e-10))}prepareGeometry(t){let e=t.clone();const i=t.getGeometryType();if(i===s.G.enumPoint||i===s.G.enumMultiPoint)return this._NormalizeAndProject(e);if(i===s.G.enumEnvelope&&(e=this.envelopeToPolygon(e)),this.m_inputSR.isPannable())return this.prepareGeometryPannable(e,4);if(2===this.m_inputSR.getCoordinateSystemType()){if(e=(0,r.ad)(e,this.m_inputSR,0,null),e.isEmpty())return e;e=(new g).execute(e,this.m_inputSR,5e4,this.m_maxDeviation/2,0,null);const t=this.m_inputSR.getSRToGCSTransform();return(new r.O).execute(e,t,this.m_progressTracker)}const n=new a.Envelope2D;e.queryLooseEnvelope(n);const o=this.m_inputSR.getPannableExtent();if(n.ymin<o.ymin||n.ymax>o.ymax){const t=new a.Envelope2D(n.xmin-1,o.ymin,n.xmax+1,o.ymax);if(e=(new p.O).execute(e,t,this.m_inputSR,this.m_progressTracker),e.isEmpty())return e}return n.width()>2*o.width()?(e=(0,r.ae)(e,-2*o.width(),2*o.width(),this.m_inputSR,!0,0,!0,this.m_progressTracker),e):e}prepareGeometryPannable(t,e){const i=new a.Envelope2D;t.queryEnvelope(i);const n=this.m_inputSR.getPannableExtent();if(n.containsEnvelope(i))return t;const s=new u.E;n.queryIntervalX(s);const o=new u.E;return i.queryIntervalX(o),s.contains(o)?(0,r.af)(t,this.m_inputSR):(new r.O).foldInto360RangeGeodetic(t,this.m_inputSR,e)}prepareOutput(t){t.outPoint.scale(1/this.m_rpu),2===this.m_inputSR.getCoordinateSystemType()&&(0,r.aa)(this.m_inputSR,[t.outPoint],1,!1)}updateOutputSegment(t,e,i){e.queryCoord2D(i,t.outPoint),this.m_bIsPannablePcs&&(0,r.ab)(this.m_inputSR,0,[t.outPoint],1),t.outPoint.mulThis(this.m_rpu)}computeTolerance(t,e){t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB);const i=new a.Envelope2D(this.m_envGeomA);return i.mergeEnvelope2D(this.m_envGeomB),(0,m.a)(null,i)}envelopeToPolygon(t){const e=new o.a;return e.addEnvelope(t,!1),e}computeEnvelopesAndBoxes(t,e){t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB),this.m_boxGeomA=this.computeBoxGeometry(t,this.m_boundaryPtsA,this.m_segmentBoxesA),this.m_boxGeomB=this.computeBoxGeometry(e,this.m_boundaryPtsB,this.m_segmentBoxesB)}computeBoxGeometry(t,e,i){switch(t.getGeometryType()){case s.G.enumPoint:return this.computeBoxPoint(t,e);case s.G.enumMultiPoint:return this.computeBoxMultiPoint(t,e);case s.G.enumPolyline:case s.G.enumPolygon:return this.computeBoxMultiPath(t,e,i);default:(0,s.d)("Invalid geometry type")}}computeBoxPoint(t,e){const i=t.getXY();e.length=0,e.push(i.mul(this.m_rpu));const n=G();return n.setCoords({xmin:i.x,ymin:i.y,xmax:i.x,ymax:i.y}),n}computeBoxMultiPoint(t,e){let i=!0;for(let n=0;n<t.getPointCount();++n){const s=t.getXY(n);if(i){e.length=0;for(let t=0;t<4;++t)e.push(s.clone());i=!1}s.x<e[0].x&&e[0].assign(s),s.y>e[1].y&&e[1].assign(s),s.x>e[2].x&&e[2].assign(s),s.y<e[3].y&&e[3].assign(s)}for(let t=0;t<e.length;++t)e[t].mulThis(this.m_rpu);const n=G();return t.queryEnvelope(n),n}computeBoxMultiPath(t,e,i){let n=!0;const s=G();s.setEmpty();const o=t.querySegmentIterator();for(o.stripAttributes();o.nextPath();)for(;o.hasNextSegment();){const t=o.nextSegment(),m=t.getStartXY(),a=t.getEndXY();if(this.m_bIsPannablePcs&&((0,r.ab)(this.m_inputSR,0,[m],1),(0,r.ab)(this.m_inputSR,0,[a],1)),n){for(let t=0;t<4;++t)e.push(m.clone());n=!1}m.x<e[0].x&&e[0].assign(m),m.y>e[1].y&&e[1].assign(m),m.x>e[2].x&&e[2].assign(m),m.y<e[3].y&&e[3].assign(m),a.x<e[0].x&&e[0].assign(a),a.y>e[1].y&&e[1].assign(a),a.x>e[2].x&&e[2].assign(a),a.y<e[3].y&&e[3].assign(a);const u=this.findOrComputeBoxPoint(o.getStartPointIndex(),m,a,i);s.mergeEnvelope2D(u)}for(let t=0;t<e.length;++t)e[t].mulThis(this.m_rpu);return s}findOrComputeBoxSegment(t,e,i){if(!i.has(t)){let n=G();if(e.queryEnvelope(n),this.m_bIsPannablePcs){const t=u.P.construct(n.xmin,n.ymin),e=u.P.construct(n.xmax,n.ymax);(0,r.ab)(this.m_inputSR,0,[t],1),(0,r.ab)(this.m_inputSR,0,[e],1),n=this.m_envHelper.calculateBbox(t.x,t.y,e.x,e.y)}return i.set(t,n),n}return i.get(t)}findOrComputeBoxPoint(t,e,i,n){if(!n.has(t)){let s=G();return s.setCoords({xmin:e.x,ymin:e.y,xmax:i.x,ymax:i.y}),this.m_bIsPannablePcs&&(s=this.m_envHelper.calculateBbox(s.xmin,s.ymin,s.xmax,s.ymax)),n.set(t,s),s}return n.get(t)}estimateMinimumDistance(t,e){const i={stack:[],error:void 0,hasError:!1};try{const s=t=>(0,r.a9)(this.m_a,this.m_eSquared,t),o=this.m_boundaryPtsA.map(s),a=this.m_boundaryPtsB.map(s);let u=Number.MAX_VALUE,c=0,h=0;for(let t=0;t<o.length;++t)for(let e=0;e<a.length;++e){const i=m.d.distance(o[t],a[e]);i<u&&(u=i,c=t,h=e)}t.outPoint.assign(this.m_boundaryPtsA[c]),e.outPoint.assign(this.m_boundaryPtsB[h]);const l=(0,n.mS)(i,new r.a7,!1);return r.a8.geodeticDistance(this.m_a,this.m_eSquared,this.m_boundaryPtsA[c].x,this.m_boundaryPtsA[c].y,this.m_boundaryPtsB[h].x,this.m_boundaryPtsB[h].y,l,null,null,this.m_distCurveType),l.val}catch(t){i.error=t,i.hasError=!0}finally{(0,n.hk)(i)}}swapGeometries(t,e){return(0,s.v)(t[0])>(0,s.v)(e[0])&&(e[0]=(0,u.c)(t[0],t[0]=e[0]),this.m_envGeomB=(0,u.c)(this.m_envGeomA,this.m_envGeomA=this.m_envGeomB),!0)}canUseSpatialTree(t,e){return!1}checkGeometriesIntersect(t,e,i,n){let o=t.getGeometryType(),m=e.getGeometryType();if(this.m_envGeomA.isIntersecting(this.m_envGeomB)){if(o===s.G.enumPoint&&2===e.getDimension()){const s=[0],o=[t.getXY()];if((0,r.ag)(e,o,1,this.m_tolerance,s),0!==s[0])return i.outPoint.assign(o[0]),n.outPoint.assign(o[0]),!0}else if(m===s.G.enumPoint&&2===t.getDimension()){const s=[2],o=[e.getXY()];if((0,r.ag)(t,o,1,this.m_tolerance,s),0!==s[0])return i.outPoint.assign(o[0]),n.outPoint.assign(o[0]),!0}if(o===s.G.enumMultiPoint&&2===e.getDimension())return this.multipointIntersectsArea(t,e,i,n);if(m===s.G.enumMultiPoint&&2===t.getDimension())return this.multipointIntersectsArea(e,t,n,i);let a,u,c=t,l=e;if(o===s.G.enumEnvelope&&(a=this.envelopeToPolygon(t),c=a,o=s.G.enumPolygon),m===s.G.enumEnvelope&&(u=this.envelopeToPolygon(e),l=u,m=s.G.enumPolygon),(0,s.h)(o)&&(0,s.h)(m)){const t=c.querySegmentIterator(),e=l.querySegmentIterator(),s=(0,h.m)(),o=(0,h.m)();if((0,h.w)(c,l,t,e,s,o))return i.outPoint.assign(s.outPoint),n.outPoint.assign(s.outPoint),!0}}return!1}multipointIntersectsArea(t,e,i,n){const s=t.getPointCount();for(let o=0;o<s;++o){const s=[2],m=t.getXY(o);if((0,r.ag)(e,[m],1,this.m_tolerance,s),0!==s[0])return i.outPoint.assign(m),n.outPoint.assign(m),!0}return!1}getNearestNeighbourVisitor(t,e,i,n,o,r,m){return(0,s.g)(0),{}}buildSpatialTree(t,e){(0,s.g)(0)}}},26640:(t,e,i)=>{i.d(e,{D:()=>D,m:()=>c,s:()=>d,w:()=>y});var n=i(31635),s=i(55537),o=i(88885),r=i(39117),m=i(83661),a=i(79187),u=i(95213);function c(){return{outPoint:new m.P,index:-1,t:Number.NaN}}function h(t,e,i){return{outPoint:t.clone(),index:e,t:i}}function l(t,e,i,n){t.outPoint.assign(e),t.index=i,t.t=n}function _(t,e){t.outPoint.assign(e.outPoint),t.index=e.index,t.t=e.t}function g(t,e,i,n){t.index=i,t.t=n,e.queryCoord2D(t.t,t.outPoint)}function p(t,e){const i=c();_(i,t),_(t,e),_(e,i)}function y(t,e,i,n,o,m){if(t.getGeometryType()===s.G.enumPolygon){for(;n.nextPath();)if(n.hasNextSegment()){const e=n.nextSegment();if(0!==(0,r.R)(t,e.getEndXY(),0))return l(o,e.getEndXY(),-1,Number.NaN),l(m,e.getEndXY(),-1,Number.NaN),!0}n.resetToFirstPath()}if(e.getGeometryType()===s.G.enumPolygon){for(;i.nextPath();)if(i.hasNextSegment()){const t=i.nextSegment();if(0!==(0,r.R)(e,t.getEndXY(),0))return l(o,t.getEndXY(),-1,Number.NaN),l(m,t.getEndXY(),-1,Number.NaN),!0}i.resetToFirstPath()}return!1}function d(t){const e=t.getPathCount(),i=(0,m.d)(t.getSegmentCount(),0);let n=0;for(let s=0;s<e;++s){const e=n+t.getSegmentCountPath(s);for(let o=n,r=t.getPathStart(s);o<e;++o,++r)i[o]=r;n=e}return(0,o.s)(t.getPointCount(),i),i}function x(t,e){return!!Number.isNaN(e)||t<=e}function P(t){const e=new o.a;return e.addEnvelope(t,!1),e}class D{constructor(t,e){if(this.m_env2DgeometryA=null,this.m_env2DgeometryB=null,this.m_progressCounter=0,this.m_progressTracker=e,this.m_maxSqrDistance=t*t,this.m_maxDistance=t,this.m_bIsNearCalc=!1,Number.isNaN(this.m_maxDistance)?this.m_maxDistance=Number.POSITIVE_INFINITY:this.m_maxDistance=t,this.m_maxSqrDistance=this.m_maxDistance*this.m_maxDistance,Number.isFinite(this.m_maxSqrDistance)){let t=Math.sqrt(this.m_maxSqrDistance);for(;t<this.m_maxDistance;)this.m_maxSqrDistance*=1+Number.EPSILON,t=Math.sqrt(this.m_maxSqrDistance)}}calculate(t,e,i,n){if((t.getGeometryType()!==u.P.type||e.getGeometryType()!==u.P.type)&&(this.m_env2DgeometryA=new a.Envelope2D,this.m_env2DgeometryB=new a.Envelope2D,t.queryEnvelope(this.m_env2DgeometryA),e.queryEnvelope(this.m_env2DgeometryB),!x(this.m_env2DgeometryA.distanceFromEnvelope(this.m_env2DgeometryB),this.m_maxDistance)))return Number.POSITIVE_INFINITY;const s=h(new m.P,(0,m.j)(),Number.NaN),o=h(new m.P,(0,m.j)(),Number.NaN),r=this._ExecuteBruteForce(t,e,s,o);return x(r,this.m_maxDistance)?(null!==i&&_(i,s),null!==n&&_(n,o),r):Number.POSITIVE_INFINITY}isNear(t,e){if(this.m_bIsNearCalc=!0,t.isEmpty()||e.isEmpty())return!1;if(t===e)return!0;let i=!0;if(t.getGeometryType()!==u.P.type&&t.getGeometryType()!==u.E.type||e.getGeometryType()!==u.P.type&&e.getGeometryType()!==u.E.type||(i=!1),i){if(this.m_env2DgeometryA=new a.Envelope2D,this.m_env2DgeometryB=new a.Envelope2D,t.queryEnvelope(this.m_env2DgeometryA),e.queryEnvelope(this.m_env2DgeometryB),!(this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)>this.m_maxSqrDistance))return!0;if(this.m_env2DgeometryA.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>this.m_maxSqrDistance)return!1}const n=h(new m.P,(0,m.j)(),Number.NaN),s=h(new m.P,(0,m.j)(),Number.NaN);return this._ExecuteBruteForce(t,e,n,s)<=this.m_maxDistance}progress_(t=!1){}_ExecuteBruteForce(t,e,i,n){switch(t.getGeometryType()){case s.G.enumPoint:return this.distancePointGeometry(t,e,i,n);case s.G.enumMultiPoint:return this.distanceMultipointGeometry(t,e,i,n);case s.G.enumEnvelope:return this.distanceEnvelopeGeometry(t,e,i,n);case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipathGeometry(t,e,i,n);default:return Number.NaN}}distancePointGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:return this.distancePointPoint(t,e,i,n);case s.G.enumMultiPoint:return this.distancePointMultipoint(t,e,i,n);case s.G.enumPolyline:case s.G.enumPolygon:return this.distancePointMultipath(t,e,i,n);case s.G.enumEnvelope:return this.distancePointEnvelope(t,e,i,n);default:return Number.NaN}}distancePointPoint(t,e,i,n){const s=t.getXY(),o=e.getXY();return l(i,s,0,0),l(n,o,0,0),Math.sqrt(m.P.sqrDistance(s,o))}distancePointMultipoint(t,e,i,n){const s=t.getXY();let o=this.m_maxSqrDistance,r=o,a=!1;const u=e.getPointCount(),c=new m.P;for(let t=0;t<u;++t)if(e.queryXY(t,c),r=m.P.sqrDistance(s,c),this.m_bIsNearCalc){if(r<=o)return 0}else if(!(r>o)&&(!a&&r===o||r<o)&&(o=r,l(i,s,0,0),l(n,c,t,0),a=!0,0===o))return 0;return a?Math.sqrt(o):Number.POSITIVE_INFINITY}distancePointMultipath(t,e,i,n){const o=!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB),u=t.getXY();if(!o&&e.getGeometryType()===s.G.enumPolygon&&0!==(0,r.R)(e,u,0))return l(i,u,0,0),l(n,u,-1,Number.NaN),0;e.getImpl().getAccelerators();let c=this.m_maxSqrDistance,h=c,_=-1;const g=new a.Envelope2D,p=e.querySegmentIterator();let y=!1;for(;p.nextPath();)for(;p.hasNextSegment();){const t=p.nextSegment();t.queryEnvelope(g);const e=g.sqrDistance(u);if(e>c)continue;if(!this.m_bIsNearCalc&&y&&e===c)continue;_=t.getClosestCoordinate(u,!1);const s=t.getCoord2D(_);if(h=m.P.sqrDistance(u,s),this.m_bIsNearCalc){if(h<=c)return 0}else if(!(h>c)&&(!y||h<c)&&(c=h,l(i,u,0,0),l(n,s,p.getStartPointIndex(),_),y=!0,0===c))return 0}return y?Math.sqrt(c):Number.POSITIVE_INFINITY}distancePointEnvelope(t,e,i,n){const s=t.getXY();l(i,s,0,0),l(n,s,-1,Number.NaN);const o=e.asEnvelope2D();return o.contains(s)?0:Math.sqrt(o.sqrDistance(s,n.outPoint))}distanceMultipointGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:{this.m_env2DgeometryB=(0,m.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const s=this.distancePointMultipoint(e,t,n,i);return this.m_env2DgeometryB=(0,m.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s}case s.G.enumMultiPoint:return this.distanceMultipointMultipoint(t,e,i,n,1,1);case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipointMultipath(t,e,i,n);case s.G.enumEnvelope:return this.distanceMultipointMultipath(t,P(e),i,n);default:return Number.NaN}}distanceMultipointMultipoint(t,e,i,s,o,r){const a={stack:[],error:void 0,hasError:!1};try{if(this.m_bIsNearCalc&&1===o&&1===r){const n=Math.trunc((0,m.s)(Math.sqrt(t.getPointCount())+1,1,(0,m.i)())),o=Math.trunc((0,m.s)(Math.sqrt(e.getPointCount())+1,1,(0,m.i)()));if((n>=4||o>=4)&&this.distanceMultipointMultipoint(t,e,i,s,n,o)<=this.m_maxSqrDistance)return 0}let u=this.m_maxSqrDistance;const c=[t],h=[e],_=this.swapGeometriesIfBGtA(c,h);_&&(this.m_env2DgeometryB=(0,m.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),r=(0,m.c)(o,o=r),p(i,s)),(0,n.mS)(a,(0,m.h)(()=>{p(i,s),this.m_env2DgeometryB=(0,m.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!_),!1);const g=c[0].getImpl(),y=h[0].getImpl(),d=g.getPointCount(),x=y.getPointCount(),P=x>1;let D=!1;const v=new m.P,G=new m.P;for(let t=0;t<d;t+=o){if(g.queryXY(t,v),P){const t=this.m_env2DgeometryB.sqrDistance(v);if(this.m_bIsNearCalc){if(t>u)continue;if(this.m_env2DgeometryB.sqrMaxMinDistance(v)<=u)return 0}else if(t>=u)continue}for(let e=0;e<x;e+=r){y.queryXY(e,G);const n=m.P.sqrDistance(v,G);if(this.m_bIsNearCalc){if(n<=u)return 0}else if(!(n>u||D&&n===u)&&(!D||n<u)&&(l(i,v,t,0),l(s,G,e,0),D=!0,u=n,0===u))return D?Math.sqrt(u):Number.POSITIVE_INFINITY}}return D?Math.sqrt(u):Number.POSITIVE_INFINITY}catch(t){a.error=t,a.hasError=!0}finally{(0,n.hk)(a)}}distanceMultipointMultipath(t,e,i,n){let o=!!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)&&e.getGeometryType()===s.G.enumPolygon;const u=e.querySegmentIterator();u.stripAttributes();const c=new a.Envelope2D,h=new m.P;let _=this.m_maxSqrDistance;const g=t.getImpl(),p=g.getPointCount(),y=p>1;let d=!1;for(;u.nextPath();)for(;u.hasNextSegment();){const t=u.nextSegment();if(t.queryLooseEnvelope(c),y){const t=c.sqrDistanceEnvelope(this.m_env2DgeometryA,null,null);if(this.m_bIsNearCalc){if(t>_)continue}else if(t>_||d&&t===_)continue}for(let s=0;s<p;s++){if(g.queryXY(s,h),o&&0!==(0,r.R)(e,h,0))return l(i,h,-1,Number.NaN),l(n,h,s,0),0;{const t=c.sqrDistance(h);if(this.m_bIsNearCalc){if(t>_)continue}else if(t>_)continue}const m=t.getClosestCoordinate(h,!1),a=t.getCoord2D(m);h.subThis(a);const p=h.sqrLength();if(this.m_bIsNearCalc){if(p<=_)return 0}else if(!(p>_)&&(!d||p<_)&&(_=p,l(i,g.getXY(s),s,0),l(n,a,u.getStartPointIndex(),m),d=!0,0===_))return 0}o=!1}return d?Math.sqrt(_):Number.POSITIVE_INFINITY}distanceEnvelopeGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:return this.distancePointEnvelope(e,t,n,i);case s.G.enumMultiPoint:{this.m_env2DgeometryB=(0,m.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const s=this.distanceMultipointMultipath(e,P(t),n,i);return this.m_env2DgeometryB=(0,m.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s}case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipathMultipath(P(t),e,i,n);case s.G.enumEnvelope:return this.distanceEnvelopeEnvelope(t,e,i,n);default:return Number.NaN}}distanceEnvelopeEnvelope(t,e,i,n){i.t=Number.NaN,i.index=-1,n.t=Number.NaN,n.index=-1;const s=t.asEnvelope2D(),o=e.asEnvelope2D();return Math.sqrt(s.sqrDistanceEnvelope(o,i.outPoint,n.outPoint))}distanceMultipathGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:{this.m_env2DgeometryB=(0,m.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const s=this.distancePointMultipath(e,t,n,i);return this.m_env2DgeometryB=(0,m.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s}case s.G.enumMultiPoint:{this.m_env2DgeometryB=(0,m.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const s=this.distanceMultipointMultipath(e,t,n,i);return this.m_env2DgeometryB=(0,m.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s}case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipathMultipath(t,e,i,n);case s.G.enumEnvelope:return this.distanceMultipathMultipath(t,P(e),i,n);default:return Number.NaN}}distanceMultipathMultipath(t,e,i,s){const r={stack:[],error:void 0,hasError:!1};try{const u=[t],h=[e],l=this.swapGeometriesIfAGtB(u,h);l&&(this.m_env2DgeometryB=(0,m.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),p(i,s)),(0,n.mS)(r,(0,m.h)(()=>{p(i,s),this.m_env2DgeometryB=(0,m.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!l),!1);const x=u[0],P=h[0],D=x.querySegmentIterator();D.stripAttributes();const v=P.querySegmentIterator();if(v.stripAttributes(),this.m_bIsNearCalc&&this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)<=this.m_maxSqrDistance)return 0;if(this.m_bIsNearCalc){const t=Math.trunc((0,m.s)(Math.sqrt(x.getPointCount())+1,1,(0,m.i)())),e=Math.trunc((0,m.s)(Math.sqrt(x.getPointCount())+1,1,(0,m.i)()));if(this.distanceMultipointMultipoint(x,P,i,s,t,e)<=this.m_maxSqrDistance)return 0}if(this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)){const t=c(),e=c();if(y(x,P,D,v,t,e))return _(i,t),_(s,e),0}const G=d(x),f=[],S=new o.S,M=new a.Envelope2D,b=new a.Envelope2D,E=new a.Envelope2D;let T=this.m_maxSqrDistance,I=!0,N=!1;for(let t=0,e=G.length;t<e;++t){x.querySegment(G[t],S,!0);const e=S.get();if(e.queryEnvelope(M),!(M.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>T)){if(this.m_bIsNearCalc&&M.sqrMaxDistanceEnvelope(this.m_env2DgeometryB)<=T)return 0;for(;v.nextPath();){if(this.progress_(),I)P.queryPathEnvelope(v.getPathIndex(),E),f[v.getPathIndex()]=E.clone();else if(M.sqrDistanceEnvelope(f[v.getPathIndex()],null,null)>T)continue;for(;v.hasNextSegment();){const n=v.nextSegment();if(n.queryEnvelope(b),M.sqrDistanceEnvelope(b,null,null)<=T){const o=!M.isIntersecting(b),r=[0],m=[0];let a=e.distance(n,o,r,m);if(a*=a,this.m_bIsNearCalc&&a<=this.m_maxSqrDistance)return 0;if(a<T||a===T&&G[t]<i.index){if(N=!0,g(i,e,G[t],r[0]),g(s,n,v.getStartPointIndex(),m[0]),0===a)return 0;T=a}}}}v.resetToFirstPath(),I=!1}}return N?Math.sqrt(T):Number.POSITIVE_INFINITY}catch(t){r.error=t,r.hasError=!0}finally{(0,n.hk)(r)}}swapGeometriesIfAGtB(t,e){return(0,s.v)(t[0])>(0,s.v)(e[0])&&(e[0]=(0,m.c)(t[0],t[0]=e[0]),!0)}swapGeometriesIfBGtA(t,e){return this.swapGeometriesIfAGtB(e,t)}}},31088:(t,e,i)=>{i.r(e),i.d(e,{OperatorGeodeticDensifyByLength:()=>r,OperatorGeodeticDensifyCursor:()=>m});var n=i(76061),s=i(55537),o=i(39117);class r{getOperatorType(){return 10310}supportsCurves(){return!0}accelerateGeometry(t,e,i){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,i,n,s){return new m(t,i,n,e,-1,-1,s)}execute(t,e,i,o,r){const m=new n.S([t]),a=this.executeMany(m,e,i,o,r).next();return a||(0,s.d)("null output"),a}}class m extends n.G{constructor(t,e,i,n,o,r,m){super(),this.m_progressTracker=m,r>0&&(0,s.t)(""),4!==i&&o>0&&(0,s.t)(""),e||(0,s.a)(""),0===e.getCoordinateSystemType()&&(0,s.a)(""),n>0||o>0||(0,s.a)(""),this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=e,this.m_curveType=i,this.m_maxLengthMeters=n,this.m_maxDeviationMeters=o,this.m_maxAngle=r}next(){{let t;for(;t=this.m_inputGeoms.next();)return(0,s.c)(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.geodeticDensify(t);return null}}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodeticDensify(t){return(0,o.ak)(t,this.m_spatialReference,this.m_curveType,this.m_maxLengthMeters,this.m_maxDeviationMeters,this.m_progressTracker)}}},76061:(t,e,i)=>{i.d(e,{G:()=>n,S:()=>s});class n{*[Symbol.iterator](){let t=this.next();for(;t;)yield t,t=this.next()}}class s extends n{constructor(t){super(),this.m_iGeom=-1,this.m_aGeoms=t?t.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const t=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,t}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}}}]);